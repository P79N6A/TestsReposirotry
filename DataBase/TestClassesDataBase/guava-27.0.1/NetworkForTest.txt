private static class NetworkForTest<N,E> extends AbstractNetwork<N,E> {
  private final Network<N,E> network;
  NetworkForTest(  Network<N,E> network){
    this.network=network;
  }
  static <N,E>NetworkForTest<N,E> from(  Network<N,E> network){
    return new NetworkForTest<>(network);
  }
  @Override public Set<N> nodes(){
    return network.nodes();
  }
  @Override public Set<E> edges(){
    return network.edges();
  }
  @Override public boolean isDirected(){
    return network.isDirected();
  }
  @Override public boolean allowsParallelEdges(){
    return network.allowsParallelEdges();
  }
  @Override public boolean allowsSelfLoops(){
    return network.allowsSelfLoops();
  }
  @Override public ElementOrder<N> nodeOrder(){
    return network.nodeOrder();
  }
  @Override public ElementOrder<E> edgeOrder(){
    return network.edgeOrder();
  }
  @Override public Set<N> adjacentNodes(  N node){
    return network.adjacentNodes(node);
  }
  @Override public Set<N> predecessors(  N node){
    return network.predecessors(node);
  }
  @Override public Set<N> successors(  N node){
    return network.successors(node);
  }
  @Override public Set<E> incidentEdges(  N node){
    return network.incidentEdges(node);
  }
  @Override public Set<E> inEdges(  N node){
    return network.inEdges(node);
  }
  @Override public Set<E> outEdges(  N node){
    return network.outEdges(node);
  }
  @Override public EndpointPair<N> incidentNodes(  E edge){
    return network.incidentNodes(edge);
  }
  @Override public Set<E> adjacentEdges(  E edge){
    return network.adjacentEdges(edge);
  }
}
