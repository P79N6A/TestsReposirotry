/** 
 * Helper class for testing with non-finite values.  {@link #ALL_MANY_VALUES} gives a numberinstances with many combinations of finite and non-finite values. All have  {@link #MANY_VALUES_COUNT} values. If all the values are finite then the mean is {@link #MANY_VALUES_MEAN} and the sum-of-squares-of-deltas is {@link #MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS}. The smallest and largest finite values are always {@link #MANY_VALUES_MIN} and {@link #MANY_VALUES_MAX}, although setting non-finite values will change the true min and max.
 */
static class ManyValues {
  private final ImmutableList<Double> values;
  ManyValues(  double[] values){
    this.values=ImmutableList.copyOf(Doubles.asList(values));
  }
  ImmutableList<Double> asIterable(){
    return values;
  }
  double[] asArray(){
    return Doubles.toArray(values);
  }
  boolean hasAnyPositiveInfinity(){
    return Iterables.any(values,Predicates.equalTo(POSITIVE_INFINITY));
  }
  boolean hasAnyNegativeInfinity(){
    return Iterables.any(values,Predicates.equalTo(NEGATIVE_INFINITY));
  }
  boolean hasAnyNaN(){
    return Iterables.any(values,Predicates.equalTo(NaN));
  }
  boolean hasAnyNonFinite(){
    return hasAnyPositiveInfinity() || hasAnyNegativeInfinity() || hasAnyNaN();
  }
  @Override public String toString(){
    return values.toString();
  }
  private static ImmutableList<ManyValues> createAll(){
    ImmutableList.Builder<ManyValues> builder=ImmutableList.builder();
    double[] values=new double[5];
    for (    double first : ImmutableList.of(1.1,POSITIVE_INFINITY,NEGATIVE_INFINITY,NaN)) {
      values[0]=first;
      values[1]=-44.44;
      for (      double third : ImmutableList.of(33.33,POSITIVE_INFINITY,NEGATIVE_INFINITY,NaN)) {
        values[2]=third;
        values[3]=555.555;
        for (        double fifth : ImmutableList.of(-2.2,POSITIVE_INFINITY,NEGATIVE_INFINITY,NaN)) {
          values[4]=fifth;
          builder.add(new ManyValues(values));
        }
      }
    }
    return builder.build();
  }
}
