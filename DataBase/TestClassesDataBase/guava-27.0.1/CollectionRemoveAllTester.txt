/** 
 * A generic JUnit test which tests  {@code removeAll} operations on a collection. Can't be invokeddirectly; please see  {@link com.google.common.collect.testing.CollectionTestSuiteBuilder}.
 * @author George van den Driessche
 * @author Chris Povirk
 */
@SuppressWarnings("unchecked") @GwtCompatible @Ignore public class CollectionRemoveAllTester<E> extends AbstractCollectionTester<E> {
  @CollectionFeature.Require(SUPPORTS_REMOVE) public void testRemoveAll_emptyCollection(){
    assertFalse("removeAll(emptyCollection) should return false",collection.removeAll(MinimalCollection.of()));
    expectUnchanged();
  }
  @CollectionFeature.Require(SUPPORTS_REMOVE) public void testRemoveAll_nonePresent(){
    assertFalse("removeAll(disjointCollection) should return false",collection.removeAll(MinimalCollection.of(e3())));
    expectUnchanged();
  }
  @CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_allPresent(){
    assertTrue("removeAll(intersectingCollection) should return true",collection.removeAll(MinimalCollection.of(e0())));
    expectMissing(e0());
  }
  @CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_somePresent(){
    assertTrue("removeAll(intersectingCollection) should return true",collection.removeAll(MinimalCollection.of(e0(),e3())));
    expectMissing(e0());
  }
  @CollectionFeature.Require({SUPPORTS_REMOVE,FAILS_FAST_ON_CONCURRENT_MODIFICATION}) @CollectionSize.Require(SEVERAL) public void testRemoveAllSomePresentConcurrentWithIteration(){
    try {
      Iterator<E> iterator=collection.iterator();
      assertTrue(collection.removeAll(MinimalCollection.of(e0(),e3())));
      iterator.next();
      fail("Expected ConcurrentModificationException");
    }
 catch (    ConcurrentModificationException expected) {
    }
  }
  /** 
 * Trigger the  {@code other.size() >= this.size()} case in {@link AbstractSet#removeAll()}. 
 */
  @CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_somePresentLargeCollectionToRemove(){
    assertTrue("removeAll(largeIntersectingCollection) should return true",collection.removeAll(MinimalCollection.of(e0(),e0(),e0(),e3(),e3(),e3())));
    expectMissing(e0());
  }
  @CollectionFeature.Require(absent=SUPPORTS_REMOVE) public void testRemoveAll_unsupportedEmptyCollection(){
    try {
      assertFalse("removeAll(emptyCollection) should return false or throw " + "UnsupportedOperationException",collection.removeAll(MinimalCollection.of()));
    }
 catch (    UnsupportedOperationException tolerated) {
    }
    expectUnchanged();
  }
  @CollectionFeature.Require(absent=SUPPORTS_REMOVE) public void testRemoveAll_unsupportedNonePresent(){
    try {
      assertFalse("removeAll(disjointCollection) should return false or throw " + "UnsupportedOperationException",collection.removeAll(MinimalCollection.of(e3())));
    }
 catch (    UnsupportedOperationException tolerated) {
    }
    expectUnchanged();
  }
  @CollectionFeature.Require(absent=SUPPORTS_REMOVE) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_unsupportedPresent(){
    try {
      collection.removeAll(MinimalCollection.of(e0()));
      fail("removeAll(intersectingCollection) should throw UnsupportedOperationException");
    }
 catch (    UnsupportedOperationException expected) {
    }
    expectUnchanged();
    assertTrue(collection.contains(e0()));
  }
  @CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(ZERO) public void testRemoveAll_nullCollectionReferenceEmptySubject(){
    try {
      collection.removeAll(null);
    }
 catch (    NullPointerException tolerated) {
    }
  }
  @CollectionFeature.Require(SUPPORTS_REMOVE) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_nullCollectionReferenceNonEmptySubject(){
    try {
      collection.removeAll(null);
      fail("removeAll(null) should throw NullPointerException");
    }
 catch (    NullPointerException expected) {
    }
  }
  @CollectionFeature.Require(value=SUPPORTS_REMOVE,absent=ALLOWS_NULL_QUERIES) public void testRemoveAll_containsNullNo(){
    MinimalCollection<?> containsNull=MinimalCollection.of((Object)null);
    try {
      assertFalse("removeAll(containsNull) should return false or throw",collection.removeAll(containsNull));
    }
 catch (    NullPointerException tolerated) {
    }
    expectUnchanged();
  }
  @CollectionFeature.Require({SUPPORTS_REMOVE,ALLOWS_NULL_QUERIES}) public void testRemoveAll_containsNullNoButAllowed(){
    MinimalCollection<?> containsNull=MinimalCollection.of((Object)null);
    assertFalse("removeAll(containsNull) should return false",collection.removeAll(containsNull));
    expectUnchanged();
  }
  @CollectionFeature.Require({SUPPORTS_REMOVE,ALLOWS_NULL_VALUES}) @CollectionSize.Require(absent=ZERO) public void testRemoveAll_containsNullYes(){
    initCollectionWithNullElement();
    assertTrue("removeAll(containsNull) should return true",collection.removeAll(Collections.singleton(null)));
  }
  @CollectionFeature.Require(SUPPORTS_REMOVE) public void testRemoveAll_containsWrongType(){
    try {
      assertFalse("removeAll(containsWrongType) should return false or throw",collection.removeAll(MinimalCollection.of(WrongType.VALUE)));
    }
 catch (    ClassCastException tolerated) {
    }
    expectUnchanged();
  }
}
