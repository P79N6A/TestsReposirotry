/** 
 * Basic tests for shared references
 */
@RunWith(RobolectricTestRunner.class) public class SharedReferenceTest {
  /** 
 * Tests out the basic operations (isn't everything a basic operation?)
 */
  @Test public void testBasic(){
    SharedReference<Thing> tRef=new SharedReference<Thing>(new Thing("abc"),THING_RELEASER);
    Assert.assertTrue(SharedReference.isValid(tRef));
    Assert.assertEquals(1,tRef.getRefCountTestOnly());
    Thing t=tRef.get();
    Assert.assertEquals("abc",t.get());
    tRef.addReference();
    Assert.assertTrue(SharedReference.isValid(tRef));
    Assert.assertEquals(2,tRef.getRefCountTestOnly());
    Assert.assertEquals(t,tRef.get());
    Assert.assertEquals("abc",t.get());
    tRef.deleteReference();
    Assert.assertTrue(SharedReference.isValid(tRef));
    Assert.assertEquals(1,tRef.getRefCountTestOnly());
    Assert.assertEquals(t,tRef.get());
    Assert.assertEquals("abc",t.get());
    tRef.deleteReference();
    Assert.assertFalse(SharedReference.isValid(tRef));
    Assert.assertEquals(0,tRef.getRefCountTestOnly());
    try {
      tRef.addReference();
      Assert.fail();
    }
 catch (    SharedReference.NullReferenceException e) {
    }
    try {
      tRef.deleteReference();
      Assert.fail();
    }
 catch (    SharedReference.NullReferenceException e) {
    }
    Assert.assertFalse(SharedReference.isValid(null));
    SharedReference<Thing> t2Ref=new SharedReference<Thing>(new Thing2("abc"),THING_RELEASER);
    t2Ref.deleteReference();
  }
  @Test public void testNewSharedReference(){
    final Thing thing=new Thing("abc");
    Assert.assertSame(thing,new SharedReference(thing,THING_RELEASER).get());
  }
  @Test public void testCustomReleaser(){
    final Thing thing=new Thing("abc");
    final ResourceReleaser releaser=Mockito.mock(ResourceReleaser.class);
    final SharedReference<Thing> tRef=new SharedReference<Thing>(thing,releaser);
    tRef.deleteReference();
    Mockito.verify(releaser,Mockito.times(1)).release(thing);
  }
public static class Thing implements Closeable {
    private String mValue;
    public Thing(    String value){
      mValue=value;
    }
    public String get(){
      return mValue;
    }
    public void close() throws IOException {
      mValue=null;
    }
  }
  /** 
 * A subclass of Thing that throws an exception on close
 */
public static class Thing2 extends Thing {
    private String mValue;
    public Thing2(    String value){
      super(value);
    }
    public void close() throws IOException {
      throw new IOException("");
    }
  }
  public final ResourceReleaser<Thing> THING_RELEASER=new ResourceReleaser<Thing>(){
    @Override public void release(    Thing value){
      try {
        Closeables.close(value,true);
      }
 catch (      IOException ioe) {
        Assert.fail();
      }
    }
  }
;
}
