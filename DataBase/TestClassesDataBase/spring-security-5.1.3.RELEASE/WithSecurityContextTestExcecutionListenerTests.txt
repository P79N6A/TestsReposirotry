@RunWith(MockitoJUnitRunner.class) public class WithSecurityContextTestExcecutionListenerTests {
  private ConfigurableApplicationContext context;
  @Mock private TestContext testContext;
  private WithSecurityContextTestExecutionListener listener;
  @Before public void setup(){
    listener=new WithSecurityContextTestExecutionListener();
    context=new AnnotationConfigApplicationContext(Config.class);
  }
  @After public void cleanup(){
    TestSecurityContextHolder.clearContext();
    if (context != null) {
      context.close();
    }
  }
  @Test @SuppressWarnings({"rawtypes","unchecked"}) public void beforeTestMethodNullSecurityContextNoError() throws Exception {
    Class testClass=FakeTest.class;
    when(testContext.getTestClass()).thenReturn(testClass);
    when(testContext.getTestMethod()).thenReturn(ReflectionUtils.findMethod(testClass,"testNoAnnotation"));
    listener.beforeTestMethod(testContext);
  }
  @Test @SuppressWarnings({"rawtypes","unchecked"}) public void beforeTestMethodNoApplicationContext() throws Exception {
    Class testClass=FakeTest.class;
    when(testContext.getApplicationContext()).thenThrow(new IllegalStateException());
    when(testContext.getTestMethod()).thenReturn(ReflectionUtils.findMethod(testClass,"testWithMockUser"));
    listener.beforeTestMethod(testContext);
    assertThat(TestSecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("user");
  }
  @Test public void withSecurityContextAfterSqlScripts(){
    SqlScriptsTestExecutionListener sql=new SqlScriptsTestExecutionListener();
    WithSecurityContextTestExecutionListener security=new WithSecurityContextTestExecutionListener();
    List<TestExecutionListener> listeners=Arrays.asList(security,sql);
    AnnotationAwareOrderComparator.sort(listeners);
    assertThat(listeners).containsExactly(sql,security);
  }
  @Test public void orderOverridden(){
    AbstractTestExecutionListener otherListener=new AbstractTestExecutionListener(){
    }
;
    List<TestExecutionListener> listeners=new ArrayList<>();
    listeners.add(otherListener);
    listeners.add(this.listener);
    AnnotationAwareOrderComparator.sort(listeners);
    assertThat(listeners).containsSequence(this.listener,otherListener);
  }
  @Test public void handlesGenericAnnotation() throws Exception {
    Method method=ReflectionUtils.findMethod(WithSecurityContextTestExcecutionListenerTests.class,"handlesGenericAnnotationTestMethod");
    TestContext testContext=mock(TestContext.class);
    when(testContext.getTestMethod()).thenReturn(method);
    when(testContext.getApplicationContext()).thenThrow(new IllegalStateException(""));
    this.listener.beforeTestMethod(testContext);
    assertThat(SecurityContextHolder.getContext().getAuthentication().getPrincipal()).isInstanceOf(WithSuperClassWithSecurityContext.class);
  }
  @WithSuperClassWithSecurityContext public void handlesGenericAnnotationTestMethod(){
  }
  @Retention(RetentionPolicy.RUNTIME) @WithSecurityContext(factory=SuperClassWithSecurityContextFactory.class) @interface WithSuperClassWithSecurityContext {  String username() default "WithSuperClassWithSecurityContext";
}
static class SuperClassWithSecurityContextFactory implements WithSecurityContextFactory<Annotation> {
    @Override public SecurityContext createSecurityContext(    Annotation annotation){
      SecurityContext context=SecurityContextHolder.createEmptyContext();
      context.setAuthentication(new TestingAuthenticationToken(annotation,"NA"));
      return context;
    }
  }
static class FakeTest {
    public void testNoAnnotation(){
    }
    @WithMockUser public void testWithMockUser(){
    }
  }
@Configuration static class Config {
  }
}
