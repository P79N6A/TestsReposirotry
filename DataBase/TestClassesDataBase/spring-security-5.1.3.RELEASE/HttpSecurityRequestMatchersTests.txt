/** 
 * @author Rob Winch
 */
public class HttpSecurityRequestMatchersTests {
  AnnotationConfigWebApplicationContext context;
  MockHttpServletRequest request;
  MockHttpServletResponse response;
  MockFilterChain chain;
  @Autowired FilterChainProxy springSecurityFilterChain;
  @Before public void setup(){
    this.request=new MockHttpServletRequest("GET","");
    this.request.setMethod("GET");
    this.response=new MockHttpServletResponse();
    this.chain=new MockFilterChain();
  }
  @After public void cleanup(){
    if (this.context != null) {
      this.context.close();
    }
  }
  @Test public void mvcMatcher() throws Exception {
    loadConfig(MvcMatcherConfig.class);
    this.request.setServletPath("/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/path.html");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/path/");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
  }
  @Test public void mvcMatcherGetFiltersNoUnsupportedMethodExceptionFromDummyRequest(){
    loadConfig(MvcMatcherConfig.class);
    assertThat(springSecurityFilterChain.getFilters("/path")).isNotEmpty();
  }
@EnableWebSecurity @Configuration @EnableWebMvc static class MvcMatcherConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.mvcMatcher("/path").httpBasic().and().authorizeRequests().anyRequest().denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
@RestController static class PathController {
      @RequestMapping("/path") public String path(){
        return "path";
      }
    }
  }
  @Test public void requestMatchersMvcMatcher() throws Exception {
    loadConfig(RequestMatchersMvcMatcherConfig.class);
    this.request.setServletPath("/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/path.html");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/path/");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
  }
@EnableWebSecurity @Configuration @EnableWebMvc static class RequestMatchersMvcMatcherConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.requestMatchers().mvcMatchers("/path").and().httpBasic().and().authorizeRequests().anyRequest().denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
@RestController static class PathController {
      @RequestMapping("/path") public String path(){
        return "path";
      }
    }
  }
  @Test public void requestMatchersMvcMatcherServletPath() throws Exception {
    loadConfig(RequestMatchersMvcMatcherServeltPathConfig.class);
    this.request.setServletPath("/spring");
    this.request.setRequestURI("/spring/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("");
    this.request.setRequestURI("/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
    setup();
    this.request.setServletPath("/other");
    this.request.setRequestURI("/other/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
  }
@EnableWebSecurity @Configuration @EnableWebMvc static class RequestMatchersMvcMatcherServeltPathConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.requestMatchers().mvcMatchers("/path").servletPath("/spring").mvcMatchers("/never-match").and().httpBasic().and().authorizeRequests().anyRequest().denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
@RestController static class PathController {
      @RequestMapping("/path") public String path(){
        return "path";
      }
    }
  }
  public void loadConfig(  Class<?>... configs){
    this.context=new AnnotationConfigWebApplicationContext();
    this.context.register(configs);
    this.context.setServletContext(new MockServletContext());
    this.context.refresh();
    this.context.getAutowireCapableBeanFactory().autowireBean(this);
  }
}
