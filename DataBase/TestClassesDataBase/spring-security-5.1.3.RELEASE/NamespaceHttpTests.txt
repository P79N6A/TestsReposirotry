/** 
 * Tests to verify that all the functionality of <http> attributes are present in Java Config.
 * @author Rob Winch
 * @author Joe Grandja
 */
public class NamespaceHttpTests {
  @Rule public final SpringTestRule spring=new SpringTestRule();
  @Autowired private MockMvc mockMvc;
  @Test public void configureWhenAccessDecisionManagerSetThenVerifyUse() throws Exception {
    AccessDecisionManagerRefConfig.ACCESS_DECISION_MANAGER=mock(AccessDecisionManager.class);
    when(AccessDecisionManagerRefConfig.ACCESS_DECISION_MANAGER.supports(FilterInvocation.class)).thenReturn(true);
    when(AccessDecisionManagerRefConfig.ACCESS_DECISION_MANAGER.supports(any(ConfigAttribute.class))).thenReturn(true);
    this.spring.register(AccessDecisionManagerRefConfig.class).autowire();
    this.mockMvc.perform(get("/"));
    verify(AccessDecisionManagerRefConfig.ACCESS_DECISION_MANAGER,times(1)).decide(any(Authentication.class),any(),anyCollection());
  }
@EnableWebSecurity static class AccessDecisionManagerRefConfig extends WebSecurityConfigurerAdapter {
    static AccessDecisionManager ACCESS_DECISION_MANAGER;
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().permitAll().accessDecisionManager(ACCESS_DECISION_MANAGER);
    }
  }
  @Test public void configureWhenAccessDeniedPageSetAndRequestForbiddenThenForwardedToAccessDeniedPage() throws Exception {
    this.spring.register(AccessDeniedPageConfig.class).autowire();
    this.mockMvc.perform(get("/admin").with(user(PasswordEncodedUser.user()))).andExpect(status().isForbidden()).andExpect(forwardedUrl("/AccessDeniedPage"));
  }
@EnableWebSecurity static class AccessDeniedPageConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().antMatchers("/admin").hasRole("ADMIN").anyRequest().authenticated().and().exceptionHandling().accessDeniedPage("/AccessDeniedPage");
    }
  }
  @Test public void configureWhenAuthenticationManagerProvidedThenVerifyUse() throws Exception {
    AuthenticationManagerRefConfig.AUTHENTICATION_MANAGER=mock(AuthenticationManager.class);
    this.spring.register(AuthenticationManagerRefConfig.class).autowire();
    this.mockMvc.perform(formLogin());
    verify(AuthenticationManagerRefConfig.AUTHENTICATION_MANAGER,times(1)).authenticate(any(Authentication.class));
  }
@EnableWebSecurity static class AuthenticationManagerRefConfig extends WebSecurityConfigurerAdapter {
    static AuthenticationManager AUTHENTICATION_MANAGER;
    @Override protected AuthenticationManager authenticationManager() throws Exception {
      return AUTHENTICATION_MANAGER;
    }
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().authenticated().and().formLogin();
    }
  }
  @Test public void configureWhenSessionCreationPolicyAlwaysThenSessionCreatedOnRequest() throws Exception {
    this.spring.register(CreateSessionAlwaysConfig.class).autowire();
    MvcResult mvcResult=this.mockMvc.perform(get("/")).andReturn();
    HttpSession session=mvcResult.getRequest().getSession(false);
    assertThat(session).isNotNull();
    assertThat(session.isNew()).isTrue();
  }
@EnableWebSecurity static class CreateSessionAlwaysConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().permitAll().and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS);
    }
  }
  @Test public void configureWhenSessionCreationPolicyStatelessThenSessionNotCreatedOnRequest() throws Exception {
    this.spring.register(CreateSessionStatelessConfig.class).autowire();
    MvcResult mvcResult=this.mockMvc.perform(get("/")).andReturn();
    HttpSession session=mvcResult.getRequest().getSession(false);
    assertThat(session).isNull();
  }
@EnableWebSecurity static class CreateSessionStatelessConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().permitAll().and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }
  }
  @Test public void configureWhenSessionCreationPolicyIfRequiredThenSessionCreatedWhenRequiredOnRequest() throws Exception {
    this.spring.register(IfRequiredConfig.class).autowire();
    MvcResult mvcResult=this.mockMvc.perform(get("/unsecure")).andReturn();
    HttpSession session=mvcResult.getRequest().getSession(false);
    assertThat(session).isNull();
    mvcResult=this.mockMvc.perform(formLogin()).andReturn();
    session=mvcResult.getRequest().getSession(false);
    assertThat(session).isNotNull();
    assertThat(session.isNew()).isTrue();
  }
@EnableWebSecurity static class IfRequiredConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().antMatchers("/unsecure").permitAll().anyRequest().authenticated().and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED).and().formLogin();
    }
  }
  @Test public void configureWhenSessionCreationPolicyNeverThenSessionNotCreatedOnRequest() throws Exception {
    this.spring.register(CreateSessionNeverConfig.class).autowire();
    MvcResult mvcResult=this.mockMvc.perform(get("/")).andReturn();
    HttpSession session=mvcResult.getRequest().getSession(false);
    assertThat(session).isNull();
  }
@EnableWebSecurity static class CreateSessionNeverConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().anonymous().and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER);
    }
  }
  @Test public void configureWhenAuthenticationEntryPointSetAndRequestUnauthorizedThenRedirectedToAuthenticationEntryPoint() throws Exception {
    this.spring.register(EntryPointRefConfig.class).autowire();
    this.mockMvc.perform(get("/")).andExpect(status().is3xxRedirection()).andExpect(redirectedUrlPattern("**/entry-point"));
  }
@EnableWebSecurity static class EntryPointRefConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().authenticated().and().exceptionHandling().authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint("/entry-point")).and().formLogin();
    }
  }
  @Test public void configureWhenJaasApiIntegrationFilterAddedThenJaasSubjectObtained() throws Exception {
    LoginContext loginContext=mock(LoginContext.class);
    when(loginContext.getSubject()).thenReturn(new Subject());
    JaasAuthenticationToken authenticationToken=mock(JaasAuthenticationToken.class);
    when(authenticationToken.isAuthenticated()).thenReturn(true);
    when(authenticationToken.getLoginContext()).thenReturn(loginContext);
    this.spring.register(JaasApiProvisionConfig.class).autowire();
    this.mockMvc.perform(get("/").with(authentication(authenticationToken)));
    verify(loginContext,times(1)).getSubject();
  }
@EnableWebSecurity static class JaasApiProvisionConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.addFilter(new JaasApiIntegrationFilter());
    }
  }
  @Test public void configureWhenHttpBasicAndRequestUnauthorizedThenReturnWWWAuthenticateWithRealm() throws Exception {
    this.spring.register(RealmConfig.class).autowire();
    this.mockMvc.perform(get("/")).andExpect(status().isUnauthorized()).andExpect(header().string("WWW-Authenticate","Basic realm=\"RealmConfig\""));
  }
@EnableWebSecurity static class RealmConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().authenticated().and().httpBasic().realmName("RealmConfig");
    }
  }
  @Test public void configureWhenAntPatternMatchingThenAntPathRequestMatcherUsed() throws Exception {
    this.spring.register(RequestMatcherAntConfig.class).autowire();
    FilterChainProxy filterChainProxy=this.spring.getContext().getBean(FilterChainProxy.class);
    assertThat(filterChainProxy.getFilterChains().get(0)).isInstanceOf(DefaultSecurityFilterChain.class);
    DefaultSecurityFilterChain securityFilterChain=(DefaultSecurityFilterChain)filterChainProxy.getFilterChains().get(0);
    assertThat(securityFilterChain.getRequestMatcher()).isInstanceOf(AntPathRequestMatcher.class);
  }
@EnableWebSecurity static class RequestMatcherAntConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.antMatcher("/api/**");
    }
  }
  @Test public void configureWhenRegexPatternMatchingThenRegexRequestMatcherUsed() throws Exception {
    this.spring.register(RequestMatcherRegexConfig.class).autowire();
    FilterChainProxy filterChainProxy=this.spring.getContext().getBean(FilterChainProxy.class);
    assertThat(filterChainProxy.getFilterChains().get(0)).isInstanceOf(DefaultSecurityFilterChain.class);
    DefaultSecurityFilterChain securityFilterChain=(DefaultSecurityFilterChain)filterChainProxy.getFilterChains().get(0);
    assertThat(securityFilterChain.getRequestMatcher()).isInstanceOf(RegexRequestMatcher.class);
  }
@EnableWebSecurity static class RequestMatcherRegexConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.regexMatcher("/regex/.*");
    }
  }
  @Test public void configureWhenRequestMatcherProvidedThenRequestMatcherUsed() throws Exception {
    this.spring.register(RequestMatcherRefConfig.class).autowire();
    FilterChainProxy filterChainProxy=this.spring.getContext().getBean(FilterChainProxy.class);
    assertThat(filterChainProxy.getFilterChains().get(0)).isInstanceOf(DefaultSecurityFilterChain.class);
    DefaultSecurityFilterChain securityFilterChain=(DefaultSecurityFilterChain)filterChainProxy.getFilterChains().get(0);
    assertThat(securityFilterChain.getRequestMatcher()).isInstanceOf(RequestMatcherRefConfig.MyRequestMatcher.class);
  }
@EnableWebSecurity static class RequestMatcherRefConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.requestMatcher(new MyRequestMatcher());
    }
static class MyRequestMatcher implements RequestMatcher {
      public boolean matches(      HttpServletRequest request){
        return true;
      }
    }
  }
  @Test public void configureWhenIgnoredAntPatternsThenAntPathRequestMatcherUsedWithNoFilters() throws Exception {
    this.spring.register(SecurityNoneConfig.class).autowire();
    FilterChainProxy filterChainProxy=this.spring.getContext().getBean(FilterChainProxy.class);
    assertThat(filterChainProxy.getFilterChains().get(0)).isInstanceOf(DefaultSecurityFilterChain.class);
    DefaultSecurityFilterChain securityFilterChain=(DefaultSecurityFilterChain)filterChainProxy.getFilterChains().get(0);
    assertThat(securityFilterChain.getRequestMatcher()).isInstanceOf(AntPathRequestMatcher.class);
    assertThat(((AntPathRequestMatcher)securityFilterChain.getRequestMatcher()).getPattern()).isEqualTo("/resources/**");
    assertThat(securityFilterChain.getFilters()).isEmpty();
    assertThat(filterChainProxy.getFilterChains().get(1)).isInstanceOf(DefaultSecurityFilterChain.class);
    securityFilterChain=(DefaultSecurityFilterChain)filterChainProxy.getFilterChains().get(1);
    assertThat(securityFilterChain.getRequestMatcher()).isInstanceOf(AntPathRequestMatcher.class);
    assertThat(((AntPathRequestMatcher)securityFilterChain.getRequestMatcher()).getPattern()).isEqualTo("/public/**");
    assertThat(securityFilterChain.getFilters()).isEmpty();
  }
@EnableWebSecurity static class SecurityNoneConfig extends WebSecurityConfigurerAdapter {
    @Override public void configure(    WebSecurity web) throws Exception {
      web.ignoring().antMatchers("/resources/**","/public/**");
    }
    @Override protected void configure(    HttpSecurity http) throws Exception {
    }
  }
  @Test public void configureWhenNullSecurityContextRepositoryThenSecurityContextNotSavedInSession() throws Exception {
    this.spring.register(SecurityContextRepoConfig.class).autowire();
    MvcResult mvcResult=this.mockMvc.perform(formLogin()).andReturn();
    HttpSession session=mvcResult.getRequest().getSession(false);
    assertThat(session).isNull();
  }
@EnableWebSecurity static class SecurityContextRepoConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().authenticated().and().securityContext().securityContextRepository(new NullSecurityContextRepository()).and().formLogin();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication().withUser(PasswordEncodedUser.user());
    }
  }
  @Test public void configureWhenServletApiDisabledThenRequestNotServletApiWrapper() throws Exception {
    this.spring.register(ServletApiProvisionConfig.class,MainController.class).autowire();
    this.mockMvc.perform(get("/"));
    assertThat(MainController.HTTP_SERVLET_REQUEST_TYPE).isNotInstanceOf(SecurityContextHolderAwareRequestWrapper.class);
  }
@EnableWebSecurity static class ServletApiProvisionConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().permitAll().and().servletApi().disable();
    }
  }
  @Test public void configureWhenServletApiDefaultThenRequestIsServletApiWrapper() throws Exception {
    this.spring.register(ServletApiProvisionDefaultsConfig.class,MainController.class).autowire();
    this.mockMvc.perform(get("/"));
    assertThat(SecurityContextHolderAwareRequestWrapper.class).isAssignableFrom(MainController.HTTP_SERVLET_REQUEST_TYPE);
  }
@EnableWebSecurity static class ServletApiProvisionDefaultsConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().permitAll();
    }
  }
@Controller static class MainController {
    static Class<? extends HttpServletRequest> HTTP_SERVLET_REQUEST_TYPE;
    @GetMapping("/") public String index(    HttpServletRequest request){
      HTTP_SERVLET_REQUEST_TYPE=request.getClass();
      return "index";
    }
  }
  @Test public void configureWhenUseExpressionsEnabledThenExpressionBasedSecurityMetadataSource() throws Exception {
    this.spring.register(UseExpressionsConfig.class).autowire();
    UseExpressionsConfig config=this.spring.getContext().getBean(UseExpressionsConfig.class);
    assertThat(ExpressionBasedFilterInvocationSecurityMetadataSource.class).isAssignableFrom(config.filterInvocationSecurityMetadataSourceType);
  }
@EnableWebSecurity static class UseExpressionsConfig extends WebSecurityConfigurerAdapter {
    private Class<? extends FilterInvocationSecurityMetadataSource> filterInvocationSecurityMetadataSourceType;
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().antMatchers("/users**","/sessions/**").hasRole("USER").antMatchers("/signup").permitAll().anyRequest().hasRole("USER");
    }
    @Override public void init(    final WebSecurity web) throws Exception {
      super.init(web);
      final HttpSecurity http=this.getHttp();
      web.postBuildAction(() -> {
        FilterSecurityInterceptor securityInterceptor=http.getSharedObject(FilterSecurityInterceptor.class);
        UseExpressionsConfig.this.filterInvocationSecurityMetadataSourceType=securityInterceptor.getSecurityMetadataSource().getClass();
      }
);
    }
  }
  @Test public void configureWhenUseExpressionsDisabledThenDefaultSecurityMetadataSource() throws Exception {
    this.spring.register(DisableUseExpressionsConfig.class).autowire();
    DisableUseExpressionsConfig config=this.spring.getContext().getBean(DisableUseExpressionsConfig.class);
    assertThat(DefaultFilterInvocationSecurityMetadataSource.class).isAssignableFrom(config.filterInvocationSecurityMetadataSourceType);
  }
@EnableWebSecurity static class DisableUseExpressionsConfig extends WebSecurityConfigurerAdapter {
    private Class<? extends FilterInvocationSecurityMetadataSource> filterInvocationSecurityMetadataSourceType;
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.apply(new UrlAuthorizationConfigurer<>(getApplicationContext())).getRegistry().antMatchers("/users**","/sessions/**").hasRole("USER").antMatchers("/signup").hasRole("ANONYMOUS").anyRequest().hasRole("USER");
    }
    @Override public void init(    final WebSecurity web) throws Exception {
      super.init(web);
      final HttpSecurity http=this.getHttp();
      web.postBuildAction(() -> {
        FilterSecurityInterceptor securityInterceptor=http.getSharedObject(FilterSecurityInterceptor.class);
        DisableUseExpressionsConfig.this.filterInvocationSecurityMetadataSourceType=securityInterceptor.getSecurityMetadataSource().getClass();
      }
);
    }
  }
}
