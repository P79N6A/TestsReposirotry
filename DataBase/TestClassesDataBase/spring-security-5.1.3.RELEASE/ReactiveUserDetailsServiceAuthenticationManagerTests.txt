/** 
 * @author Rob Winch
 * @since 5.0
 */
@RunWith(MockitoJUnitRunner.class) public class ReactiveUserDetailsServiceAuthenticationManagerTests {
  @Mock ReactiveUserDetailsService repository;
  @Mock PasswordEncoder passwordEncoder;
  UserDetailsRepositoryReactiveAuthenticationManager manager;
  String username;
  String password;
  @Before public void setup(){
    manager=new UserDetailsRepositoryReactiveAuthenticationManager(repository);
    username="user";
    password="pass";
  }
  @Test(expected=IllegalArgumentException.class) public void constructorNullUserDetailsService(){
    ReactiveUserDetailsService userDetailsService=null;
    new UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService);
  }
  @Test public void authenticateWhenUserNotFoundThenBadCredentials(){
    when(repository.findByUsername(username)).thenReturn(Mono.empty());
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(username,password);
    Mono<Authentication> authentication=manager.authenticate(token);
    StepVerifier.create(authentication).expectError(BadCredentialsException.class).verify();
  }
  @Test public void authenticateWhenPasswordNotEqualThenBadCredentials(){
    UserDetails user=PasswordEncodedUser.withUsername(this.username).password(this.password).roles("USER").build();
    when(repository.findByUsername(user.getUsername())).thenReturn(Mono.just(user));
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(username,this.password + "INVALID");
    Mono<Authentication> authentication=manager.authenticate(token);
    StepVerifier.create(authentication).expectError(BadCredentialsException.class).verify();
  }
  @Test public void authenticateWhenSuccessThenSuccess(){
    UserDetails user=PasswordEncodedUser.withUsername(this.username).password(this.password).roles("USER").build();
    when(repository.findByUsername(user.getUsername())).thenReturn(Mono.just(user));
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(username,password);
    Authentication authentication=manager.authenticate(token).block();
    assertThat(authentication).isEqualTo(authentication);
  }
  @Test public void authenticateWhenPasswordEncoderAndSuccessThenSuccess(){
    this.manager.setPasswordEncoder(this.passwordEncoder);
    when(this.passwordEncoder.matches(any(),any())).thenReturn(true);
    User user=new User(this.username,this.password,AuthorityUtils.createAuthorityList("ROLE_USER"));
    when(this.repository.findByUsername(user.getUsername())).thenReturn(Mono.just(user));
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(this.username,this.password);
    Authentication authentication=this.manager.authenticate(token).block();
    assertThat(authentication).isEqualTo(authentication);
  }
  @Test public void authenticateWhenPasswordEncoderAndFailThenFail(){
    this.manager.setPasswordEncoder(this.passwordEncoder);
    when(this.passwordEncoder.matches(any(),any())).thenReturn(false);
    User user=new User(this.username,this.password,AuthorityUtils.createAuthorityList("ROLE_USER"));
    when(this.repository.findByUsername(user.getUsername())).thenReturn(Mono.just(user));
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(this.username,this.password);
    Mono<Authentication> authentication=this.manager.authenticate(token);
    StepVerifier.create(authentication).expectError(BadCredentialsException.class).verify();
  }
}
