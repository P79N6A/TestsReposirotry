/** 
 * @author Rob Winch
 * @since 3.2
 */
@RunWith(MockitoJUnitRunner.class) public class DelegatingSecurityContextRunnableTests {
  @Mock private Runnable delegate;
  @Mock private SecurityContext securityContext;
  @Mock private Object callableResult;
  private Runnable runnable;
  private ExecutorService executor;
  private SecurityContext originalSecurityContext;
  @Before public void setUp() throws Exception {
    originalSecurityContext=SecurityContextHolder.createEmptyContext();
    doAnswer(new Answer<Object>(){
      public Object answer(      InvocationOnMock invocation) throws Throwable {
        assertThat(SecurityContextHolder.getContext()).isEqualTo(securityContext);
        return null;
      }
    }
).when(delegate).run();
    executor=Executors.newFixedThreadPool(1);
  }
  @After public void tearDown(){
    SecurityContextHolder.clearContext();
  }
  @Test(expected=IllegalArgumentException.class) public void constructorNullDelegate(){
    new DelegatingSecurityContextRunnable(null);
  }
  @Test(expected=IllegalArgumentException.class) public void constructorNullDelegateNonNullSecurityContext(){
    new DelegatingSecurityContextRunnable(null,securityContext);
  }
  @Test(expected=IllegalArgumentException.class) public void constructorNullDelegateAndSecurityContext(){
    new DelegatingSecurityContextRunnable(null,null);
  }
  @Test(expected=IllegalArgumentException.class) public void constructorNullSecurityContext(){
    new DelegatingSecurityContextRunnable(delegate,null);
  }
  @Test public void call() throws Exception {
    runnable=new DelegatingSecurityContextRunnable(delegate,securityContext);
    assertWrapped(runnable);
  }
  @Test public void callDefaultSecurityContext() throws Exception {
    SecurityContextHolder.setContext(securityContext);
    runnable=new DelegatingSecurityContextRunnable(delegate);
    SecurityContextHolder.clearContext();
    assertWrapped(runnable);
  }
  @Test public void callOnSameThread() throws Exception {
    originalSecurityContext=securityContext;
    SecurityContextHolder.setContext(originalSecurityContext);
    executor=synchronousExecutor();
    runnable=new DelegatingSecurityContextRunnable(delegate,securityContext);
    assertWrapped(runnable);
  }
  @Test(expected=IllegalArgumentException.class) public void createNullDelegate(){
    DelegatingSecurityContextRunnable.create(null,securityContext);
  }
  @Test(expected=IllegalArgumentException.class) public void createNullDelegateAndSecurityContext(){
    DelegatingSecurityContextRunnable.create(null,null);
  }
  @Test public void createNullSecurityContext() throws Exception {
    SecurityContextHolder.setContext(securityContext);
    runnable=DelegatingSecurityContextRunnable.create(delegate,null);
    SecurityContextHolder.clearContext();
    assertWrapped(runnable);
  }
  @Test public void create() throws Exception {
    runnable=DelegatingSecurityContextRunnable.create(delegate,securityContext);
    assertWrapped(runnable);
  }
  @Test public void toStringDelegates(){
    runnable=new DelegatingSecurityContextRunnable(delegate,securityContext);
    assertThat(runnable.toString()).isEqualTo(delegate.toString());
  }
  private void assertWrapped(  Runnable runnable) throws Exception {
    Future<?> submit=executor.submit(runnable);
    submit.get();
    verify(delegate).run();
    assertThat(SecurityContextHolder.getContext()).isEqualTo(originalSecurityContext);
  }
  private static ExecutorService synchronousExecutor(){
    return new ExecutorServiceAdapter(new SyncTaskExecutor());
  }
}
