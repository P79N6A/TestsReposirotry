/** 
 * Tests  {@link AbstractAccessDecisionManager}.
 * @author Ben Alex
 */
@SuppressWarnings("unchecked") public class AbstractAccessDecisionManagerTests {
  @Test public void testAllowIfAccessDecisionManagerDefaults(){
    List list=new Vector();
    DenyAgainVoter denyVoter=new DenyAgainVoter();
    list.add(denyVoter);
    MockDecisionManagerImpl mock=new MockDecisionManagerImpl(list);
    assertThat(!mock.isAllowIfAllAbstainDecisions()).isTrue();
    mock.setAllowIfAllAbstainDecisions(true);
    assertThat(mock.isAllowIfAllAbstainDecisions()).isTrue();
  }
  @Test public void testDelegatesSupportsClassRequests() throws Exception {
    List list=new Vector();
    list.add(new DenyVoter());
    list.add(new MockStringOnlyVoter());
    MockDecisionManagerImpl mock=new MockDecisionManagerImpl(list);
    assertThat(mock.supports(String.class)).isTrue();
    assertThat(!mock.supports(Integer.class)).isTrue();
  }
  @Test public void testDelegatesSupportsRequests() throws Exception {
    List list=new Vector();
    DenyVoter voter=new DenyVoter();
    DenyAgainVoter denyVoter=new DenyAgainVoter();
    list.add(voter);
    list.add(denyVoter);
    MockDecisionManagerImpl mock=new MockDecisionManagerImpl(list);
    ConfigAttribute attr=new SecurityConfig("DENY_AGAIN_FOR_SURE");
    assertThat(mock.supports(attr)).isTrue();
    ConfigAttribute badAttr=new SecurityConfig("WE_DONT_SUPPORT_THIS");
    assertThat(!mock.supports(badAttr)).isTrue();
  }
  @Test public void testProperlyStoresListOfVoters() throws Exception {
    List list=new Vector();
    DenyVoter voter=new DenyVoter();
    DenyAgainVoter denyVoter=new DenyAgainVoter();
    list.add(voter);
    list.add(denyVoter);
    MockDecisionManagerImpl mock=new MockDecisionManagerImpl(list);
    assertThat(mock.getDecisionVoters()).hasSize(list.size());
  }
  @Test public void testRejectsEmptyList() throws Exception {
    List list=new Vector();
    try {
      new MockDecisionManagerImpl(list);
      fail("Should have thrown IllegalArgumentException");
    }
 catch (    IllegalArgumentException expected) {
    }
  }
  @Test public void testRejectsNullVotersList() throws Exception {
    try {
      new MockDecisionManagerImpl(null);
      fail("Should have thrown IllegalArgumentException");
    }
 catch (    IllegalArgumentException expected) {
    }
  }
  @Test public void testRoleVoterAlwaysReturnsTrueToSupports(){
    RoleVoter rv=new RoleVoter();
    assertThat(rv.supports(String.class)).isTrue();
  }
  @Test public void testWillNotStartIfDecisionVotersNotSet() throws Exception {
    try {
      new MockDecisionManagerImpl(null);
      fail("Should have thrown IllegalArgumentException");
    }
 catch (    IllegalArgumentException expected) {
    }
  }
private class MockDecisionManagerImpl extends AbstractAccessDecisionManager {
    protected MockDecisionManagerImpl(    List<AccessDecisionVoter<? extends Object>> decisionVoters){
      super(decisionVoters);
    }
    public void decide(    Authentication authentication,    Object object,    Collection<ConfigAttribute> configAttributes){
    }
  }
private class MockStringOnlyVoter implements AccessDecisionVoter<Object> {
    public boolean supports(    Class<?> clazz){
      return String.class.isAssignableFrom(clazz);
    }
    public boolean supports(    ConfigAttribute attribute){
      throw new UnsupportedOperationException("mock method not implemented");
    }
    public int vote(    Authentication authentication,    Object object,    Collection<ConfigAttribute> attributes){
      throw new UnsupportedOperationException("mock method not implemented");
    }
  }
}
