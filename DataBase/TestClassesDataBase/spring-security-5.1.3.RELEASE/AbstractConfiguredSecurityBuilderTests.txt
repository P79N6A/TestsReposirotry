/** 
 * Tests for  {@link AbstractConfiguredSecurityBuilder}.
 * @author Joe Grandja
 */
public class AbstractConfiguredSecurityBuilderTests {
  private TestConfiguredSecurityBuilder builder;
  @Before public void setUp(){
    this.builder=new TestConfiguredSecurityBuilder(mock(ObjectPostProcessor.class));
  }
  @Test(expected=IllegalArgumentException.class) public void constructorWhenObjectPostProcessorIsNullThenThrowIllegalArgumentException(){
    new TestConfiguredSecurityBuilder(null);
  }
  @Test(expected=IllegalArgumentException.class) public void objectPostProcessorWhenNullThenThrowIllegalArgumentException(){
    this.builder.objectPostProcessor(null);
  }
  @Test public void applyWhenDuplicateConfigurerAddedThenDuplicateConfigurerRemoved() throws Exception {
    this.builder.apply(new TestSecurityConfigurer());
    this.builder.apply(new TestSecurityConfigurer());
    assertThat(this.builder.getConfigurers(TestSecurityConfigurer.class)).hasSize(1);
  }
  @Test(expected=IllegalStateException.class) public void buildWhenBuildTwiceThenThrowIllegalStateException() throws Exception {
    this.builder.build();
    this.builder.build();
  }
  @Test(expected=IllegalStateException.class) public void getObjectWhenNotBuiltThenThrowIllegalStateException() throws Exception {
    this.builder.getObject();
  }
  @Test public void buildWhenConfigurerAppliesAnotherConfigurerThenObjectStillBuilds() throws Exception {
    DelegateSecurityConfigurer.CONFIGURER=mock(SecurityConfigurer.class);
    this.builder.apply(new DelegateSecurityConfigurer());
    this.builder.build();
    verify(DelegateSecurityConfigurer.CONFIGURER).init(this.builder);
    verify(DelegateSecurityConfigurer.CONFIGURER).configure(this.builder);
  }
  @Test(expected=IllegalStateException.class) public void getConfigurerWhenMultipleConfigurersThenThrowIllegalStateException() throws Exception {
    TestConfiguredSecurityBuilder builder=new TestConfiguredSecurityBuilder(mock(ObjectPostProcessor.class),true);
    builder.apply(new DelegateSecurityConfigurer());
    builder.apply(new DelegateSecurityConfigurer());
    builder.getConfigurer(DelegateSecurityConfigurer.class);
  }
  @Test(expected=IllegalStateException.class) public void removeConfigurerWhenMultipleConfigurersThenThrowIllegalStateException() throws Exception {
    TestConfiguredSecurityBuilder builder=new TestConfiguredSecurityBuilder(mock(ObjectPostProcessor.class),true);
    builder.apply(new DelegateSecurityConfigurer());
    builder.apply(new DelegateSecurityConfigurer());
    builder.removeConfigurer(DelegateSecurityConfigurer.class);
  }
  @Test public void removeConfigurersWhenMultipleConfigurersThenConfigurersRemoved() throws Exception {
    DelegateSecurityConfigurer configurer1=new DelegateSecurityConfigurer();
    DelegateSecurityConfigurer configurer2=new DelegateSecurityConfigurer();
    TestConfiguredSecurityBuilder builder=new TestConfiguredSecurityBuilder(mock(ObjectPostProcessor.class),true);
    builder.apply(configurer1);
    builder.apply(configurer2);
    List<DelegateSecurityConfigurer> removedConfigurers=builder.removeConfigurers(DelegateSecurityConfigurer.class);
    assertThat(removedConfigurers).hasSize(2);
    assertThat(removedConfigurers).containsExactly(configurer1,configurer2);
    assertThat(builder.getConfigurers(DelegateSecurityConfigurer.class)).isEmpty();
  }
  @Test public void getConfigurersWhenMultipleConfigurersThenConfigurersReturned() throws Exception {
    DelegateSecurityConfigurer configurer1=new DelegateSecurityConfigurer();
    DelegateSecurityConfigurer configurer2=new DelegateSecurityConfigurer();
    TestConfiguredSecurityBuilder builder=new TestConfiguredSecurityBuilder(mock(ObjectPostProcessor.class),true);
    builder.apply(configurer1);
    builder.apply(configurer2);
    List<DelegateSecurityConfigurer> configurers=builder.getConfigurers(DelegateSecurityConfigurer.class);
    assertThat(configurers).hasSize(2);
    assertThat(configurers).containsExactly(configurer1,configurer2);
    assertThat(builder.getConfigurers(DelegateSecurityConfigurer.class)).hasSize(2);
  }
private static class DelegateSecurityConfigurer extends SecurityConfigurerAdapter<Object,TestConfiguredSecurityBuilder> {
    private static SecurityConfigurer<Object,TestConfiguredSecurityBuilder> CONFIGURER;
    @Override public void init(    TestConfiguredSecurityBuilder builder) throws Exception {
      builder.apply(CONFIGURER);
    }
  }
private static class TestSecurityConfigurer extends SecurityConfigurerAdapter<Object,TestConfiguredSecurityBuilder> {
  }
private static class TestConfiguredSecurityBuilder extends AbstractConfiguredSecurityBuilder<Object,TestConfiguredSecurityBuilder> {
    private TestConfiguredSecurityBuilder(    ObjectPostProcessor<Object> objectPostProcessor){
      super(objectPostProcessor);
    }
    private TestConfiguredSecurityBuilder(    ObjectPostProcessor<Object> objectPostProcessor,    boolean allowConfigurersOfSameType){
      super(objectPostProcessor,allowConfigurersOfSameType);
    }
    public Object performBuild() throws Exception {
      return "success";
    }
  }
}
