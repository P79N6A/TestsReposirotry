/** 
 * @author Luke Taylor
 * @since 3.0.3
 */
public class AnnotationSecurityAspectTests {
  private AffirmativeBased adm;
  private @Mock AuthenticationManager authman;
  private TestingAuthenticationToken anne=new TestingAuthenticationToken("anne","","ROLE_A");
  private AspectJMethodSecurityInterceptor interceptor;
  private SecuredImpl secured=new SecuredImpl();
  private SecuredImplSubclass securedSub=new SecuredImplSubclass();
  private PrePostSecured prePostSecured=new PrePostSecured();
  @Before public final void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    interceptor=new AspectJMethodSecurityInterceptor();
    AccessDecisionVoter[] voters=new AccessDecisionVoter[]{new RoleVoter(),new PreInvocationAuthorizationAdviceVoter(new ExpressionBasedPreInvocationAdvice())};
    adm=new AffirmativeBased(Arrays.<AccessDecisionVoter<? extends Object>>asList(voters));
    interceptor.setAccessDecisionManager(adm);
    interceptor.setAuthenticationManager(authman);
    interceptor.setSecurityMetadataSource(new SecuredAnnotationSecurityMetadataSource());
    AnnotationSecurityAspect secAspect=AnnotationSecurityAspect.aspectOf();
    secAspect.setSecurityInterceptor(interceptor);
  }
  @After public void clearContext(){
    SecurityContextHolder.clearContext();
  }
  @Test public void securedInterfaceMethodAllowsAllAccess() throws Exception {
    secured.securedMethod();
  }
  @Test(expected=AuthenticationCredentialsNotFoundException.class) public void securedClassMethodDeniesUnauthenticatedAccess() throws Exception {
    secured.securedClassMethod();
  }
  @Test public void securedClassMethodAllowsAccessToRoleA() throws Exception {
    SecurityContextHolder.getContext().setAuthentication(anne);
    secured.securedClassMethod();
  }
  @Test(expected=AccessDeniedException.class) public void internalPrivateCallIsIntercepted(){
    SecurityContextHolder.getContext().setAuthentication(anne);
    try {
      secured.publicCallsPrivate();
      fail("Expected AccessDeniedException");
    }
 catch (    AccessDeniedException expected) {
    }
    securedSub.publicCallsPrivate();
  }
  @Test(expected=AccessDeniedException.class) public void protectedMethodIsIntercepted() throws Exception {
    SecurityContextHolder.getContext().setAuthentication(anne);
    secured.protectedMethod();
  }
  @Test public void overriddenProtectedMethodIsNotIntercepted() throws Exception {
    securedSub.protectedMethod();
  }
  @Test(expected=AccessDeniedException.class) public void denyAllPreAuthorizeDeniesAccess() throws Exception {
    configureForElAnnotations();
    SecurityContextHolder.getContext().setAuthentication(anne);
    prePostSecured.denyAllMethod();
  }
  @Test public void postFilterIsApplied() throws Exception {
    configureForElAnnotations();
    SecurityContextHolder.getContext().setAuthentication(anne);
    List<String> objects=prePostSecured.postFilterMethod();
    assertThat(objects).hasSize(2);
    assertThat(objects.contains("apple")).isTrue();
    assertThat(objects.contains("aubergine")).isTrue();
  }
  private void configureForElAnnotations(){
    DefaultMethodSecurityExpressionHandler eh=new DefaultMethodSecurityExpressionHandler();
    interceptor.setSecurityMetadataSource(new PrePostAnnotationSecurityMetadataSource(new ExpressionBasedAnnotationAttributeFactory(eh)));
    interceptor.setAccessDecisionManager(adm);
    AfterInvocationProviderManager aim=new AfterInvocationProviderManager();
    aim.setProviders(Arrays.asList(new PostInvocationAdviceProvider(new ExpressionBasedPostInvocationAdvice(eh))));
    interceptor.setAfterInvocationManager(aim);
  }
}
