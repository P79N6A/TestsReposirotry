/** 
 * @author Rob Winch
 */
public class AuthenticationManagerBuilderTests {
  @Rule public final SpringTestRule spring=new SpringTestRule();
  @Test public void buildWhenAddAuthenticationProviderThenDoesNotPerformRegistration() throws Exception {
    ObjectPostProcessor<Object> opp=mock(ObjectPostProcessor.class);
    AuthenticationProvider provider=mock(AuthenticationProvider.class);
    AuthenticationManagerBuilder builder=new AuthenticationManagerBuilder(opp);
    builder.authenticationProvider(provider);
    builder.build();
    verify(opp,never()).postProcess(provider);
  }
  @Test public void customAuthenticationEventPublisherWithWeb() throws Exception {
    ObjectPostProcessor<Object> opp=mock(ObjectPostProcessor.class);
    AuthenticationEventPublisher aep=mock(AuthenticationEventPublisher.class);
    when(opp.postProcess(any())).thenAnswer(a -> a.getArgument(0));
    AuthenticationManager am=new AuthenticationManagerBuilder(opp).authenticationEventPublisher(aep).inMemoryAuthentication().and().build();
    try {
      am.authenticate(new UsernamePasswordAuthenticationToken("user","password"));
    }
 catch (    AuthenticationException success) {
    }
    verify(aep).publishAuthenticationFailure(any(),any());
  }
  @Test public void getAuthenticationManagerWhenGlobalPasswordEncoderBeanThenUsed() throws Exception {
    this.spring.register(PasswordEncoderGlobalConfig.class).autowire();
    AuthenticationManager manager=this.spring.getContext().getBean(AuthenticationConfiguration.class).getAuthenticationManager();
    Authentication auth=manager.authenticate(new UsernamePasswordAuthenticationToken("user","password"));
    assertThat(auth.getName()).isEqualTo("user");
    assertThat(auth.getAuthorities()).extracting(GrantedAuthority::getAuthority).containsOnly("ROLE_USER");
  }
@EnableWebSecurity static class PasswordEncoderGlobalConfig extends WebSecurityConfigurerAdapter {
    @Autowired void configureGlobal(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication().withUser("user").password("password").roles("USER");
    }
    @Bean PasswordEncoder passwordEncoder(){
      return NoOpPasswordEncoder.getInstance();
    }
  }
  @Test public void getAuthenticationManagerWhenProtectedPasswordEncoderBeanThenUsed() throws Exception {
    this.spring.register(PasswordEncoderGlobalConfig.class).autowire();
    AuthenticationManager manager=this.spring.getContext().getBean(AuthenticationConfiguration.class).getAuthenticationManager();
    Authentication auth=manager.authenticate(new UsernamePasswordAuthenticationToken("user","password"));
    assertThat(auth.getName()).isEqualTo("user");
    assertThat(auth.getAuthorities()).extracting(GrantedAuthority::getAuthority).containsOnly("ROLE_USER");
  }
@EnableWebSecurity static class PasswordEncoderConfig extends WebSecurityConfigurerAdapter {
    protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication().withUser("user").password("password").roles("USER");
    }
    @Bean PasswordEncoder passwordEncoder(){
      return NoOpPasswordEncoder.getInstance();
    }
  }
  @Autowired(required=false) MockMvc mockMvc;
  @Test public void authenticationManagerWhenMultipleProvidersThenWorks() throws Exception {
    this.spring.register(MultiAuthenticationProvidersConfig.class).autowire();
    this.mockMvc.perform(formLogin()).andExpect(authenticated().withUsername("user").withRoles("USER"));
    this.mockMvc.perform(formLogin().user("admin")).andExpect(authenticated().withUsername("admin").withRoles("USER","ADMIN"));
  }
@EnableWebSecurity static class MultiAuthenticationProvidersConfig extends WebSecurityConfigurerAdapter {
    protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication().withUser(PasswordEncodedUser.user()).and().inMemoryAuthentication().withUser(PasswordEncodedUser.admin());
    }
  }
  @Test public void buildWhenAuthenticationProviderThenIsConfigured() throws Exception {
    ObjectPostProcessor<Object> opp=mock(ObjectPostProcessor.class);
    AuthenticationProvider provider=mock(AuthenticationProvider.class);
    AuthenticationManagerBuilder builder=new AuthenticationManagerBuilder(opp);
    builder.authenticationProvider(provider);
    builder.build();
    assertThat(builder.isConfigured()).isTrue();
  }
  @Test public void buildWhenParentThenIsConfigured() throws Exception {
    ObjectPostProcessor<Object> opp=mock(ObjectPostProcessor.class);
    AuthenticationManager parent=mock(AuthenticationManager.class);
    AuthenticationManagerBuilder builder=new AuthenticationManagerBuilder(opp);
    builder.parentAuthenticationManager(parent);
    builder.build();
    assertThat(builder.isConfigured()).isTrue();
  }
  @Test public void buildWhenNotConfiguredThenIsConfiguredFalse() throws Exception {
    ObjectPostProcessor<Object> opp=mock(ObjectPostProcessor.class);
    AuthenticationManagerBuilder builder=new AuthenticationManagerBuilder(opp);
    builder.build();
    assertThat(builder.isConfigured()).isFalse();
  }
  public void buildWhenUserFromProperties() throws Exception {
    this.spring.register(UserFromPropertiesConfig.class).autowire();
    this.mockMvc.perform(formLogin().user("joe","joespassword")).andExpect(authenticated().withUsername("joe").withRoles("USER"));
  }
@Configuration @EnableGlobalAuthentication @Import(ObjectPostProcessorConfiguration.class) static class UserFromPropertiesConfig {
    @Value("classpath:org/springframework/security/config/users.properties") Resource users;
    @Bean public AuthenticationManager authenticationManager() throws Exception {
      return new ProviderManager(Arrays.asList(authenticationProvider()));
    }
    @Bean public AuthenticationProvider authenticationProvider() throws Exception {
      DaoAuthenticationProvider provider=new DaoAuthenticationProvider();
      provider.setUserDetailsService(userDetailsService());
      return provider;
    }
    @Bean public UserDetailsService userDetailsService() throws Exception {
      Properties properties=new Properties();
      properties.load(this.users.getInputStream());
      return new InMemoryUserDetailsManager(properties);
    }
  }
}
