/** 
 * Tests  {@link AspectJMethodSecurityInterceptor}.
 * @author Ben Alex
 * @author Luke Taylor
 * @author Rob Winch
 */
public class AspectJMethodSecurityInterceptorTests {
  private TestingAuthenticationToken token;
  private AspectJMethodSecurityInterceptor interceptor;
  private @Mock AccessDecisionManager adm;
  private @Mock MethodSecurityMetadataSource mds;
  private @Mock AuthenticationManager authman;
  private @Mock AspectJCallback aspectJCallback;
  private ProceedingJoinPoint joinPoint;
  @Before public final void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    SecurityContextHolder.clearContext();
    token=new TestingAuthenticationToken("Test","Password");
    interceptor=new AspectJMethodSecurityInterceptor();
    interceptor.setAccessDecisionManager(adm);
    interceptor.setAuthenticationManager(authman);
    interceptor.setSecurityMetadataSource(mds);
    joinPoint=mock(ProceedingJoinPoint.class);
    Signature sig=mock(Signature.class);
    when(sig.getDeclaringType()).thenReturn(TargetObject.class);
    JoinPoint.StaticPart staticPart=mock(JoinPoint.StaticPart.class);
    when(joinPoint.getSignature()).thenReturn(sig);
    when(joinPoint.getStaticPart()).thenReturn(staticPart);
    CodeSignature codeSig=mock(CodeSignature.class);
    when(codeSig.getName()).thenReturn("countLength");
    when(codeSig.getDeclaringType()).thenReturn(TargetObject.class);
    when(codeSig.getParameterTypes()).thenReturn(new Class[]{String.class});
    when(staticPart.getSignature()).thenReturn(codeSig);
    when(mds.getAttributes(any())).thenReturn(SecurityConfig.createList("ROLE_USER"));
    when(authman.authenticate(token)).thenReturn(token);
  }
  @After public void clearContext(){
    SecurityContextHolder.clearContext();
  }
  @Test public void callbackIsInvokedWhenPermissionGranted() throws Throwable {
    SecurityContextHolder.getContext().setAuthentication(token);
    interceptor.invoke(joinPoint,aspectJCallback);
    verify(aspectJCallback).proceedWithObject();
    interceptor.invoke(joinPoint);
  }
  @SuppressWarnings("unchecked") @Test public void callbackIsNotInvokedWhenPermissionDenied() throws Exception {
    doThrow(new AccessDeniedException("denied")).when(adm).decide(any(),any(),any());
    SecurityContextHolder.getContext().setAuthentication(token);
    try {
      interceptor.invoke(joinPoint,aspectJCallback);
      fail("Expected AccessDeniedException");
    }
 catch (    AccessDeniedException expected) {
    }
    verify(aspectJCallback,never()).proceedWithObject();
  }
  @Test public void adapterHoldsCorrectData() throws Exception {
    TargetObject to=new TargetObject();
    Method m=ClassUtils.getMethodIfAvailable(TargetObject.class,"countLength",new Class[]{String.class});
    when(joinPoint.getTarget()).thenReturn(to);
    when(joinPoint.getArgs()).thenReturn(new Object[]{"Hi"});
    MethodInvocationAdapter mia=new MethodInvocationAdapter(joinPoint);
    assertThat(mia.getArguments()[0]).isEqualTo("Hi");
    assertThat(mia.getStaticPart()).isEqualTo(m);
    assertThat(mia.getMethod()).isEqualTo(m);
    assertThat(mia.getThis()).isSameAs(to);
  }
  @Test public void afterInvocationManagerIsNotInvokedIfExceptionIsRaised() throws Throwable {
    token.setAuthenticated(true);
    SecurityContextHolder.getContext().setAuthentication(token);
    AfterInvocationManager aim=mock(AfterInvocationManager.class);
    interceptor.setAfterInvocationManager(aim);
    when(aspectJCallback.proceedWithObject()).thenThrow(new RuntimeException());
    try {
      interceptor.invoke(joinPoint,aspectJCallback);
      fail("Expected exception");
    }
 catch (    RuntimeException expected) {
    }
    verifyZeroInteractions(aim);
  }
  @Test @SuppressWarnings("unchecked") public void invokeWithAspectJCallbackRunAsReplacementCleansAfterException() throws Exception {
    SecurityContext ctx=SecurityContextHolder.getContext();
    ctx.setAuthentication(token);
    token.setAuthenticated(true);
    final RunAsManager runAs=mock(RunAsManager.class);
    final RunAsUserToken runAsToken=new RunAsUserToken("key","someone","creds",token.getAuthorities(),TestingAuthenticationToken.class);
    interceptor.setRunAsManager(runAs);
    when(runAs.buildRunAs(eq(token),any(MethodInvocation.class),any(List.class))).thenReturn(runAsToken);
    when(aspectJCallback.proceedWithObject()).thenThrow(new RuntimeException());
    try {
      interceptor.invoke(joinPoint,aspectJCallback);
      fail("Expected Exception");
    }
 catch (    RuntimeException success) {
    }
    assertThat(SecurityContextHolder.getContext()).isSameAs(ctx);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(token);
  }
  @Test @SuppressWarnings("unchecked") public void invokeRunAsReplacementCleansAfterException() throws Throwable {
    SecurityContext ctx=SecurityContextHolder.getContext();
    ctx.setAuthentication(token);
    token.setAuthenticated(true);
    final RunAsManager runAs=mock(RunAsManager.class);
    final RunAsUserToken runAsToken=new RunAsUserToken("key","someone","creds",token.getAuthorities(),TestingAuthenticationToken.class);
    interceptor.setRunAsManager(runAs);
    when(runAs.buildRunAs(eq(token),any(MethodInvocation.class),any(List.class))).thenReturn(runAsToken);
    when(joinPoint.proceed()).thenThrow(new RuntimeException());
    try {
      interceptor.invoke(joinPoint);
      fail("Expected Exception");
    }
 catch (    RuntimeException success) {
    }
    assertThat(SecurityContextHolder.getContext()).isSameAs(ctx);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(token);
  }
}
