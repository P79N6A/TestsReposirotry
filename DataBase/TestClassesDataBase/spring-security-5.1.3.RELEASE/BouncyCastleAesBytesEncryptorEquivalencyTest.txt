public class BouncyCastleAesBytesEncryptorEquivalencyTest {
  private byte[] testData;
  private String password;
  private String salt;
  private SecureRandom secureRandom=new SecureRandom();
  @Before public void setup(){
    password=UUID.randomUUID().toString();
    byte[] saltBytes=new byte[16];
    secureRandom.nextBytes(saltBytes);
    salt=new String(Hex.encode(saltBytes));
  }
  @Test public void bouncyCastleAesCbcWithPredictableIvEquvalent() throws Exception {
    CryptoAssumptions.assumeCBCJCE();
    BytesEncryptor bcEncryptor=new BouncyCastleAesCbcBytesEncryptor(password,salt,new PredictableRandomBytesKeyGenerator(16));
    BytesEncryptor jceEncryptor=new AesBytesEncryptor(password,salt,new PredictableRandomBytesKeyGenerator(16));
    testEquivalence(bcEncryptor,jceEncryptor);
  }
  @Test public void bouncyCastleAesCbcWithSecureIvCompatible() throws Exception {
    CryptoAssumptions.assumeCBCJCE();
    BytesEncryptor bcEncryptor=new BouncyCastleAesCbcBytesEncryptor(password,salt,KeyGenerators.secureRandom(16));
    BytesEncryptor jceEncryptor=new AesBytesEncryptor(password,salt,KeyGenerators.secureRandom(16));
    testCompatibility(bcEncryptor,jceEncryptor);
  }
  @Test public void bouncyCastleAesGcmWithPredictableIvEquvalent() throws Exception {
    CryptoAssumptions.assumeGCMJCE();
    BytesEncryptor bcEncryptor=new BouncyCastleAesGcmBytesEncryptor(password,salt,new PredictableRandomBytesKeyGenerator(16));
    BytesEncryptor jceEncryptor=new AesBytesEncryptor(password,salt,new PredictableRandomBytesKeyGenerator(16),CipherAlgorithm.GCM);
    testEquivalence(bcEncryptor,jceEncryptor);
  }
  @Test public void bouncyCastleAesGcmWithSecureIvCompatible() throws Exception {
    CryptoAssumptions.assumeGCMJCE();
    BytesEncryptor bcEncryptor=new BouncyCastleAesGcmBytesEncryptor(password,salt,KeyGenerators.secureRandom(16));
    BytesEncryptor jceEncryptor=new AesBytesEncryptor(password,salt,KeyGenerators.secureRandom(16),CipherAlgorithm.GCM);
    testCompatibility(bcEncryptor,jceEncryptor);
  }
  private void testEquivalence(  BytesEncryptor left,  BytesEncryptor right) throws Exception {
    for (int size=1; size < 2048; size++) {
      testData=new byte[size];
      secureRandom.nextBytes(testData);
      byte[] leftEncrypted=left.encrypt(testData);
      byte[] rightEncrypted=right.encrypt(testData);
      Assert.assertArrayEquals(leftEncrypted,rightEncrypted);
      byte[] leftDecrypted=left.decrypt(leftEncrypted);
      byte[] rightDecrypted=right.decrypt(rightEncrypted);
      Assert.assertArrayEquals(testData,leftDecrypted);
      Assert.assertArrayEquals(testData,rightDecrypted);
    }
  }
  private void testCompatibility(  BytesEncryptor left,  BytesEncryptor right) throws Exception {
    for (int size=1; size < 2048; size++) {
      testData=new byte[size];
      secureRandom.nextBytes(testData);
      byte[] leftEncrypted=left.encrypt(testData);
      byte[] rightEncrypted=right.encrypt(testData);
      byte[] leftDecrypted=left.decrypt(rightEncrypted);
      byte[] rightDecrypted=right.decrypt(leftEncrypted);
      Assert.assertArrayEquals(testData,leftDecrypted);
      Assert.assertArrayEquals(testData,rightDecrypted);
    }
  }
  /** 
 * A BytesKeyGenerator that always generates the same sequence of values
 */
private static class PredictableRandomBytesKeyGenerator implements BytesKeyGenerator {
    private final Random random;
    private final int keyLength;
    public PredictableRandomBytesKeyGenerator(    int keyLength){
      this.random=new Random(1);
      this.keyLength=keyLength;
    }
    public int getKeyLength(){
      return keyLength;
    }
    public byte[] generateKey(){
      byte[] bytes=new byte[keyLength];
      random.nextBytes(bytes);
      return bytes;
    }
  }
}
