/** 
 * @author Rob Winch
 * @since 5.0
 */
@RunWith(MockitoJUnitRunner.class) public class AuthorizationWebFilterTests {
  @Mock private ServerWebExchange exchange;
  @Mock private WebFilterChain chain;
  PublisherProbe<Void> chainResult=PublisherProbe.empty();
  @Test public void filterWhenNoSecurityContextThenThrowsAccessDenied(){
    when(this.chain.filter(this.exchange)).thenReturn(this.chainResult.mono());
    AuthorizationWebFilter filter=new AuthorizationWebFilter((a,e) -> Mono.error(new AccessDeniedException("Denied")));
    Mono<Void> result=filter.filter(this.exchange,this.chain);
    StepVerifier.create(result).expectError(AccessDeniedException.class).verify();
    this.chainResult.assertWasNotSubscribed();
  }
  @Test public void filterWhenNoAuthenticationThenThrowsAccessDenied(){
    when(this.chain.filter(this.exchange)).thenReturn(this.chainResult.mono());
    AuthorizationWebFilter filter=new AuthorizationWebFilter((a,e) -> a.flatMap(auth -> Mono.error(new AccessDeniedException("Denied"))));
    Mono<Void> result=filter.filter(this.exchange,this.chain).subscriberContext(ReactiveSecurityContextHolder.withSecurityContext(Mono.just(new SecurityContextImpl())));
    StepVerifier.create(result).expectError(AccessDeniedException.class).verify();
    this.chainResult.assertWasNotSubscribed();
  }
  @Test public void filterWhenAuthenticationThenThrowsAccessDenied(){
    when(this.chain.filter(this.exchange)).thenReturn(this.chainResult.mono());
    AuthorizationWebFilter filter=new AuthorizationWebFilter((a,e) -> Mono.error(new AccessDeniedException("Denied")));
    Mono<Void> result=filter.filter(this.exchange,this.chain).subscriberContext(ReactiveSecurityContextHolder.withAuthentication(new TestingAuthenticationToken("a","b","R")));
    StepVerifier.create(result).expectError(AccessDeniedException.class).verify();
    this.chainResult.assertWasNotSubscribed();
  }
  @Test public void filterWhenDoesNotAccessAuthenticationThenSecurityContextNotSubscribed(){
    PublisherProbe<SecurityContext> context=PublisherProbe.empty();
    when(this.chain.filter(this.exchange)).thenReturn(this.chainResult.mono());
    AuthorizationWebFilter filter=new AuthorizationWebFilter((a,e) -> Mono.error(new AccessDeniedException("Denied")));
    Mono<Void> result=filter.filter(this.exchange,this.chain).subscriberContext(ReactiveSecurityContextHolder.withSecurityContext(context.mono()));
    StepVerifier.create(result).expectError(AccessDeniedException.class).verify();
    this.chainResult.assertWasNotSubscribed();
    context.assertWasNotSubscribed();
  }
  @Test public void filterWhenGrantedAndDoesNotAccessAuthenticationThenChainSubscribedAndSecurityContextNotSubscribed(){
    PublisherProbe<SecurityContext> context=PublisherProbe.empty();
    when(this.chain.filter(this.exchange)).thenReturn(this.chainResult.mono());
    AuthorizationWebFilter filter=new AuthorizationWebFilter((a,e) -> Mono.just(new AuthorizationDecision(true)));
    Mono<Void> result=filter.filter(this.exchange,this.chain).subscriberContext(ReactiveSecurityContextHolder.withSecurityContext(context.mono()));
    StepVerifier.create(result).verifyComplete();
    this.chainResult.assertWasSubscribed();
    context.assertWasNotSubscribed();
  }
  @Test public void filterWhenGrantedAndDoeAccessAuthenticationThenChainSubscribedAndSecurityContextSubscribed(){
    PublisherProbe<SecurityContext> context=PublisherProbe.empty();
    when(this.chain.filter(this.exchange)).thenReturn(this.chainResult.mono());
    AuthorizationWebFilter filter=new AuthorizationWebFilter((a,e) -> a.map(auth -> new AuthorizationDecision(true)).defaultIfEmpty(new AuthorizationDecision(true)));
    Mono<Void> result=filter.filter(this.exchange,this.chain).subscriberContext(ReactiveSecurityContextHolder.withSecurityContext(context.mono()));
    StepVerifier.create(result).verifyComplete();
    this.chainResult.assertWasSubscribed();
    context.assertWasSubscribed();
  }
}
