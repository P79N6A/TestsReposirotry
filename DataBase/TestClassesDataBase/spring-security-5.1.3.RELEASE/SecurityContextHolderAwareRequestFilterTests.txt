/** 
 * Tests  {@link SecurityContextHolderAwareRequestFilter}.
 * @author Ben Alex
 * @author Rob Winch
 * @author Eddú Meléndez
 */
@RunWith(PowerMockRunner.class) @PrepareForTest(ClassUtils.class) public class SecurityContextHolderAwareRequestFilterTests {
  @Captor private ArgumentCaptor<HttpServletRequest> requestCaptor;
  @Mock private AuthenticationManager authenticationManager;
  @Mock private AuthenticationEntryPoint authenticationEntryPoint;
  @Mock private LogoutHandler logoutHandler;
  @Mock private FilterChain filterChain;
  @Mock private HttpServletRequest request;
  @Mock private HttpServletResponse response;
  private List<LogoutHandler> logoutHandlers;
  private SecurityContextHolderAwareRequestFilter filter;
  @Before public void setUp() throws Exception {
    this.logoutHandlers=Arrays.asList(this.logoutHandler);
    this.filter=new SecurityContextHolderAwareRequestFilter();
    this.filter.setAuthenticationEntryPoint(this.authenticationEntryPoint);
    this.filter.setAuthenticationManager(this.authenticationManager);
    this.filter.setLogoutHandlers(this.logoutHandlers);
    this.filter.afterPropertiesSet();
  }
  @After public void clearContext(){
    SecurityContextHolder.clearContext();
  }
  @Test public void expectedRequestWrapperClassIsUsed() throws Exception {
    this.filter.setRolePrefix("ROLE_");
    this.filter.doFilter(new MockHttpServletRequest(),new MockHttpServletResponse(),this.filterChain);
    this.filter.doFilter(new MockHttpServletRequest(),new MockHttpServletResponse(),this.filterChain);
    verify(this.filterChain,times(2)).doFilter(any(SecurityContextHolderAwareRequestWrapper.class),any(HttpServletResponse.class));
    this.filter.destroy();
  }
  @Test public void authenticateFalse() throws Exception {
    assertThat(wrappedRequest().authenticate(this.response)).isFalse();
    verify(this.authenticationEntryPoint).commence(eq(this.requestCaptor.getValue()),eq(this.response),any(AuthenticationException.class));
    verifyZeroInteractions(this.authenticationManager,this.logoutHandler);
    verify(this.request,times(0)).authenticate(any(HttpServletResponse.class));
  }
  @Test public void authenticateTrue() throws Exception {
    SecurityContextHolder.getContext().setAuthentication(new TestingAuthenticationToken("test","password","ROLE_USER"));
    assertThat(wrappedRequest().authenticate(this.response)).isTrue();
    verifyZeroInteractions(this.authenticationEntryPoint,this.authenticationManager,this.logoutHandler);
    verify(this.request,times(0)).authenticate(any(HttpServletResponse.class));
  }
  @Test public void authenticateNullEntryPointFalse() throws Exception {
    this.filter.setAuthenticationEntryPoint(null);
    this.filter.afterPropertiesSet();
    assertThat(wrappedRequest().authenticate(this.response)).isFalse();
    verify(this.request).authenticate(this.response);
    verifyZeroInteractions(this.authenticationEntryPoint,this.authenticationManager,this.logoutHandler);
  }
  @Test public void authenticateNullEntryPointTrue() throws Exception {
    when(this.request.authenticate(this.response)).thenReturn(true);
    this.filter.setAuthenticationEntryPoint(null);
    this.filter.afterPropertiesSet();
    assertThat(wrappedRequest().authenticate(this.response)).isTrue();
    verify(this.request).authenticate(this.response);
    verifyZeroInteractions(this.authenticationEntryPoint,this.authenticationManager,this.logoutHandler);
  }
  @Test public void login() throws Exception {
    TestingAuthenticationToken expectedAuth=new TestingAuthenticationToken("user","password","ROLE_USER");
    when(this.authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))).thenReturn(expectedAuth);
    wrappedRequest().login(expectedAuth.getName(),String.valueOf(expectedAuth.getCredentials()));
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(expectedAuth);
    verifyZeroInteractions(this.authenticationEntryPoint,this.logoutHandler);
    verify(this.request,times(0)).login(anyString(),anyString());
  }
  @Test public void loginWithExistingUser() throws Exception {
    TestingAuthenticationToken expectedAuth=new TestingAuthenticationToken("user","password","ROLE_USER");
    when(this.authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))).thenReturn(new TestingAuthenticationToken("newuser","not be found","ROLE_USER"));
    SecurityContextHolder.getContext().setAuthentication(expectedAuth);
    try {
      wrappedRequest().login(expectedAuth.getName(),String.valueOf(expectedAuth.getCredentials()));
      fail("Expected Exception");
    }
 catch (    ServletException success) {
      assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(expectedAuth);
      verifyZeroInteractions(this.authenticationEntryPoint,this.logoutHandler);
      verify(this.request,times(0)).login(anyString(),anyString());
    }
  }
  @Test public void loginFail() throws Exception {
    AuthenticationException authException=new BadCredentialsException("Invalid");
    when(this.authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))).thenThrow(authException);
    try {
      wrappedRequest().login("invalid","credentials");
      fail("Expected Exception");
    }
 catch (    ServletException success) {
      assertThat(success.getCause()).isEqualTo(authException);
    }
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
    verifyZeroInteractions(this.authenticationEntryPoint,this.logoutHandler);
    verify(this.request,times(0)).login(anyString(),anyString());
  }
  @Test public void loginNullAuthenticationManager() throws Exception {
    this.filter.setAuthenticationManager(null);
    this.filter.afterPropertiesSet();
    String username="username";
    String password="password";
    wrappedRequest().login(username,password);
    verify(this.request).login(username,password);
    verifyZeroInteractions(this.authenticationEntryPoint,this.authenticationManager,this.logoutHandler);
  }
  @Test public void loginNullAuthenticationManagerFail() throws Exception {
    this.filter.setAuthenticationManager(null);
    this.filter.afterPropertiesSet();
    String username="username";
    String password="password";
    ServletException authException=new ServletException("Failed Login");
    doThrow(authException).when(this.request).login(username,password);
    try {
      wrappedRequest().login(username,password);
      fail("Expected Exception");
    }
 catch (    ServletException success) {
      assertThat(success).isEqualTo(authException);
    }
    verifyZeroInteractions(this.authenticationEntryPoint,this.authenticationManager,this.logoutHandler);
  }
  @Test public void logout() throws Exception {
    TestingAuthenticationToken expectedAuth=new TestingAuthenticationToken("user","password","ROLE_USER");
    SecurityContextHolder.getContext().setAuthentication(expectedAuth);
    HttpServletRequest wrappedRequest=wrappedRequest();
    wrappedRequest.logout();
    verify(this.logoutHandler).logout(wrappedRequest,this.response,expectedAuth);
    verifyZeroInteractions(this.authenticationManager,this.logoutHandler);
    verify(this.request,times(0)).logout();
  }
  @Test public void logoutNullLogoutHandler() throws Exception {
    this.filter.setLogoutHandlers(null);
    this.filter.afterPropertiesSet();
    wrappedRequest().logout();
    verify(this.request).logout();
    verifyZeroInteractions(this.authenticationEntryPoint,this.authenticationManager,this.logoutHandler);
  }
  @Test public void getAsyncContextNullFromSuper() throws Exception {
    assertThat(wrappedRequest().getAsyncContext()).isNull();
  }
  @Test public void getAsyncContextStart() throws Exception {
    ArgumentCaptor<Runnable> runnableCaptor=ArgumentCaptor.forClass(Runnable.class);
    SecurityContext context=SecurityContextHolder.createEmptyContext();
    TestingAuthenticationToken expectedAuth=new TestingAuthenticationToken("user","password","ROLE_USER");
    context.setAuthentication(expectedAuth);
    SecurityContextHolder.setContext(context);
    AsyncContext asyncContext=mock(AsyncContext.class);
    when(this.request.getAsyncContext()).thenReturn(asyncContext);
    Runnable runnable=new Runnable(){
      @Override public void run(){
      }
    }
;
    wrappedRequest().getAsyncContext().start(runnable);
    verifyZeroInteractions(this.authenticationManager,this.logoutHandler);
    verify(asyncContext).start(runnableCaptor.capture());
    DelegatingSecurityContextRunnable wrappedRunnable=(DelegatingSecurityContextRunnable)runnableCaptor.getValue();
    assertThat(ReflectionTestUtils.getField(wrappedRunnable,"delegateSecurityContext")).isEqualTo(context);
    assertThat(ReflectionTestUtils.getField(wrappedRunnable,"delegate"));
  }
  @Test public void startAsyncStart() throws Exception {
    ArgumentCaptor<Runnable> runnableCaptor=ArgumentCaptor.forClass(Runnable.class);
    SecurityContext context=SecurityContextHolder.createEmptyContext();
    TestingAuthenticationToken expectedAuth=new TestingAuthenticationToken("user","password","ROLE_USER");
    context.setAuthentication(expectedAuth);
    SecurityContextHolder.setContext(context);
    AsyncContext asyncContext=mock(AsyncContext.class);
    when(this.request.startAsync()).thenReturn(asyncContext);
    Runnable runnable=new Runnable(){
      @Override public void run(){
      }
    }
;
    wrappedRequest().startAsync().start(runnable);
    verifyZeroInteractions(this.authenticationManager,this.logoutHandler);
    verify(asyncContext).start(runnableCaptor.capture());
    DelegatingSecurityContextRunnable wrappedRunnable=(DelegatingSecurityContextRunnable)runnableCaptor.getValue();
    assertThat(ReflectionTestUtils.getField(wrappedRunnable,"delegateSecurityContext")).isEqualTo(context);
    assertThat(ReflectionTestUtils.getField(wrappedRunnable,"delegate"));
  }
  @Test public void startAsyncWithRequestResponseStart() throws Exception {
    ArgumentCaptor<Runnable> runnableCaptor=ArgumentCaptor.forClass(Runnable.class);
    SecurityContext context=SecurityContextHolder.createEmptyContext();
    TestingAuthenticationToken expectedAuth=new TestingAuthenticationToken("user","password","ROLE_USER");
    context.setAuthentication(expectedAuth);
    SecurityContextHolder.setContext(context);
    AsyncContext asyncContext=mock(AsyncContext.class);
    when(this.request.startAsync(this.request,this.response)).thenReturn(asyncContext);
    Runnable runnable=new Runnable(){
      @Override public void run(){
      }
    }
;
    wrappedRequest().startAsync(this.request,this.response).start(runnable);
    verifyZeroInteractions(this.authenticationManager,this.logoutHandler);
    verify(asyncContext).start(runnableCaptor.capture());
    DelegatingSecurityContextRunnable wrappedRunnable=(DelegatingSecurityContextRunnable)runnableCaptor.getValue();
    assertThat(ReflectionTestUtils.getField(wrappedRunnable,"delegateSecurityContext")).isEqualTo(context);
    assertThat(ReflectionTestUtils.getField(wrappedRunnable,"delegate"));
  }
  @Test public void updateRequestFactory() throws Exception {
    SecurityContextHolder.getContext().setAuthentication(new TestingAuthenticationToken("user","password","PREFIX_USER"));
    this.filter.setRolePrefix("PREFIX_");
    assertThat(wrappedRequest().isUserInRole("PREFIX_USER")).isTrue();
  }
  private HttpServletRequest wrappedRequest() throws Exception {
    this.filter.doFilter(this.request,this.response,this.filterChain);
    verify(this.filterChain).doFilter(this.requestCaptor.capture(),any(HttpServletResponse.class));
    return this.requestCaptor.getValue();
  }
}
