/** 
 * @author Luke Taylor
 */
public class ConcurrentSessionManagementTests extends AbstractWebServerIntegrationTests {
  @Test public void maxConcurrentLoginsValueIsRespected() throws Exception {
    final MockHttpSession session1=new MockHttpSession();
    final MockHttpSession session2=new MockHttpSession();
    MockMvc mockMvc=createMockMvc("classpath:/spring/http-security-concurrency.xml","classpath:/spring/in-memory-provider.xml","classpath:/spring/testapp-servlet.xml");
    mockMvc.perform(get("secure/index").session(session1)).andExpect(status().is3xxRedirection());
    MockHttpServletRequestBuilder login1=login().session(session1);
    mockMvc.perform(login1).andExpect(authenticated().withUsername("jimi"));
    MockHttpServletRequestBuilder login2=login().session(session2);
    mockMvc.perform(login2).andExpect(redirectedUrl("/login.jsp?login_error=true"));
    Exception exception=(Exception)session2.getAttribute("SPRING_SECURITY_LAST_EXCEPTION");
    assertThat(exception).isNotNull();
    assertThat(exception.getMessage()).contains("Maximum sessions of 1 for this principal exceeded");
    mockMvc.perform(post("/logout").with(csrf())).andExpect(status().is3xxRedirection()).andDo(new ResultHandler(){
      @SuppressWarnings("serial") @Override public void handle(      MvcResult result) throws Exception {
        context.publishEvent(new SessionDestroyedEvent(session1){
          @Override public List<SecurityContext> getSecurityContexts(){
            return Collections.emptyList();
          }
          @Override public String getId(){
            return session1.getId();
          }
        }
);
      }
    }
);
    login2=login().session(session2);
    mockMvc.perform(login2).andExpect(authenticated().withUsername("jimi"));
    mockMvc.perform(get("/secure/index").session(session2)).andExpect(content().string(containsString("A Secure Page")));
  }
  private MockHttpServletRequestBuilder login(){
    return post("/login").param("username","jimi").param("password","jimispassword").with(csrf());
  }
}
