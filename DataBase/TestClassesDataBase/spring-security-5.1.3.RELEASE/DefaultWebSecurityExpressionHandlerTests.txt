@RunWith(MockitoJUnitRunner.class) public class DefaultWebSecurityExpressionHandlerTests {
  @Mock private AuthenticationTrustResolver trustResolver;
  @Mock private Authentication authentication;
  @Mock private FilterInvocation invocation;
  private DefaultWebSecurityExpressionHandler handler;
  @Before public void setup(){
    handler=new DefaultWebSecurityExpressionHandler();
  }
  @After public void cleanup(){
    SecurityContextHolder.clearContext();
  }
  @Test public void expressionPropertiesAreResolvedAgainstAppContextBeans() throws Exception {
    StaticApplicationContext appContext=new StaticApplicationContext();
    RootBeanDefinition bean=new RootBeanDefinition(SecurityConfig.class);
    bean.getConstructorArgumentValues().addGenericArgumentValue("ROLE_A");
    appContext.registerBeanDefinition("role",bean);
    handler.setApplicationContext(appContext);
    EvaluationContext ctx=handler.createEvaluationContext(mock(Authentication.class),mock(FilterInvocation.class));
    ExpressionParser parser=handler.getExpressionParser();
    assertThat(parser.parseExpression("@role.getAttribute() == 'ROLE_A'").getValue(ctx,Boolean.class)).isTrue();
    assertThat(parser.parseExpression("@role.attribute == 'ROLE_A'").getValue(ctx,Boolean.class)).isTrue();
  }
  @Test(expected=IllegalArgumentException.class) public void setTrustResolverNull(){
    handler.setTrustResolver(null);
  }
  @Test public void createEvaluationContextCustomTrustResolver(){
    handler.setTrustResolver(trustResolver);
    Expression expression=handler.getExpressionParser().parseExpression("anonymous");
    EvaluationContext context=handler.createEvaluationContext(authentication,invocation);
    assertThat(expression.getValue(context,Boolean.class)).isFalse();
    verify(trustResolver).isAnonymous(authentication);
  }
}
