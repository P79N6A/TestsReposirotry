/** 
 * @author Rob Winch
 * @since 5.1
 */
@RunWith(MockitoJUnitRunner.class) public class OAuth2AuthorizationCodeGrantWebFilterTests {
  private OAuth2AuthorizationCodeGrantWebFilter filter;
  @Mock private ReactiveAuthenticationManager authenticationManager;
  @Mock private ReactiveClientRegistrationRepository clientRegistrationRepository;
  @Mock private ServerOAuth2AuthorizedClientRepository authorizedClientRepository;
  @Before public void setup(){
    this.filter=new OAuth2AuthorizationCodeGrantWebFilter(this.authenticationManager,this.clientRegistrationRepository,this.authorizedClientRepository);
  }
  @Test public void constructorWhenAuthenticationManagerNullThenIllegalArgumentException(){
    this.authenticationManager=null;
    assertThatCode(() -> new OAuth2AuthorizationCodeGrantWebFilter(this.authenticationManager,this.clientRegistrationRepository,this.authorizedClientRepository)).isInstanceOf(IllegalArgumentException.class);
  }
  @Test public void constructorWhenClientRegistrationRepositoryNullThenIllegalArgumentException(){
    this.clientRegistrationRepository=null;
    assertThatCode(() -> new OAuth2AuthorizationCodeGrantWebFilter(this.authenticationManager,this.clientRegistrationRepository,this.authorizedClientRepository)).isInstanceOf(IllegalArgumentException.class);
  }
  @Test public void constructorWhenAuthorizedClientRepositoryNullThenIllegalArgumentException(){
    this.authorizedClientRepository=null;
    assertThatCode(() -> new OAuth2AuthorizationCodeGrantWebFilter(this.authenticationManager,this.clientRegistrationRepository,this.authorizedClientRepository)).isInstanceOf(IllegalArgumentException.class);
  }
  @Test public void filterWhenNotMatchThenAuthenticationManagerNotCalled(){
    MockServerWebExchange exchange=MockServerWebExchange.from(MockServerHttpRequest.get("/"));
    DefaultWebFilterChain chain=new DefaultWebFilterChain(e -> e.getResponse().setComplete());
    this.filter.filter(exchange,chain).block();
    verifyZeroInteractions(this.authenticationManager);
  }
  @Test public void filterWhenMatchThenAuthorizedClientSaved(){
    Mono<Authentication> authentication=Mono.just(TestOAuth2AuthorizationCodeAuthenticationTokens.unauthenticated());
    OAuth2AuthorizationCodeAuthenticationToken authenticated=TestOAuth2AuthorizationCodeAuthenticationTokens.authenticated();
    ServerAuthenticationConverter converter=e -> authentication;
    this.filter=new OAuth2AuthorizationCodeGrantWebFilter(this.authenticationManager,converter,this.authorizedClientRepository);
    MockServerWebExchange exchange=MockServerWebExchange.from(MockServerHttpRequest.get("/authorize/oauth2/code/registration-id"));
    DefaultWebFilterChain chain=new DefaultWebFilterChain(e -> e.getResponse().setComplete());
    when(this.authenticationManager.authenticate(any())).thenReturn(Mono.just(authenticated));
    when(this.authorizedClientRepository.saveAuthorizedClient(any(),any(),any())).thenReturn(Mono.empty());
    this.filter.filter(exchange,chain).block();
    verify(this.authorizedClientRepository).saveAuthorizedClient(any(),any(AnonymousAuthenticationToken.class),any());
  }
}
