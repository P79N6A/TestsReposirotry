/** 
 * @author Rob Winch
 * @since 5.1
 */
@RunWith(MockitoJUnitRunner.class) public class UserDetailsRepositoryReactiveAuthenticationManagerTests {
  @Mock private ReactiveUserDetailsService userDetailsService;
  @Mock private PasswordEncoder encoder;
  @Mock private ReactiveUserDetailsPasswordService userDetailsPasswordService;
  @Mock private Scheduler scheduler;
  private UserDetails user=User.withUsername("user").password("password").roles("USER").build();
  private UserDetailsRepositoryReactiveAuthenticationManager manager;
  @Before public void setup(){
    this.manager=new UserDetailsRepositoryReactiveAuthenticationManager(this.userDetailsService);
    when(this.scheduler.schedule(any())).thenAnswer(a -> {
      Runnable r=a.getArgument(0);
      return Schedulers.immediate().schedule(r);
    }
);
  }
  @Test public void setSchedulerWhenNullThenIllegalArgumentException(){
    assertThatCode(() -> this.manager.setScheduler(null)).isInstanceOf(IllegalArgumentException.class);
  }
  @Test public void authentiateWhenCustomSchedulerThenUsed(){
    when(this.userDetailsService.findByUsername(any())).thenReturn(Mono.just(this.user));
    when(this.encoder.matches(any(),any())).thenReturn(true);
    this.manager.setScheduler(this.scheduler);
    this.manager.setPasswordEncoder(this.encoder);
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(this.user,this.user.getPassword());
    Authentication result=this.manager.authenticate(token).block();
    verify(this.scheduler).schedule(any());
  }
  @Test public void authenticateWhenPasswordServiceThenUpdated(){
    String encodedPassword="encoded";
    when(this.userDetailsService.findByUsername(any())).thenReturn(Mono.just(this.user));
    when(this.encoder.matches(any(),any())).thenReturn(true);
    when(this.encoder.upgradeEncoding(any())).thenReturn(true);
    when(this.encoder.encode(any())).thenReturn(encodedPassword);
    when(this.userDetailsPasswordService.updatePassword(any(),any())).thenReturn(Mono.just(this.user));
    this.manager.setPasswordEncoder(this.encoder);
    this.manager.setUserDetailsPasswordService(this.userDetailsPasswordService);
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(this.user,this.user.getPassword());
    Authentication result=this.manager.authenticate(token).block();
    verify(this.encoder).encode(this.user.getPassword());
    verify(this.userDetailsPasswordService).updatePassword(eq(this.user),eq(encodedPassword));
  }
  @Test public void authenticateWhenPasswordServiceAndBadCredentialsThenNotUpdated(){
    when(this.userDetailsService.findByUsername(any())).thenReturn(Mono.just(this.user));
    when(this.encoder.matches(any(),any())).thenReturn(false);
    this.manager.setPasswordEncoder(this.encoder);
    this.manager.setUserDetailsPasswordService(this.userDetailsPasswordService);
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(this.user,this.user.getPassword());
    assertThatThrownBy(() -> this.manager.authenticate(token).block()).isInstanceOf(BadCredentialsException.class);
    verifyZeroInteractions(this.userDetailsPasswordService);
  }
  @Test public void authenticateWhenPasswordServiceAndUpgradeFalseThenNotUpdated(){
    when(this.userDetailsService.findByUsername(any())).thenReturn(Mono.just(this.user));
    when(this.encoder.matches(any(),any())).thenReturn(true);
    when(this.encoder.upgradeEncoding(any())).thenReturn(false);
    this.manager.setPasswordEncoder(this.encoder);
    this.manager.setUserDetailsPasswordService(this.userDetailsPasswordService);
    UsernamePasswordAuthenticationToken token=new UsernamePasswordAuthenticationToken(this.user,this.user.getPassword());
    Authentication result=this.manager.authenticate(token).block();
    verifyZeroInteractions(this.userDetailsPasswordService);
  }
}
