/** 
 * Tests for  {@link HttpsRedirectWebFilter}
 * @author Josh Cummings
 */
@RunWith(MockitoJUnitRunner.class) public class HttpsRedirectWebFilterTests {
  HttpsRedirectWebFilter filter;
  @Mock WebFilterChain chain;
  @Before public void configureFilter(){
    this.filter=new HttpsRedirectWebFilter();
    when(this.chain.filter(any(ServerWebExchange.class))).thenReturn(Mono.empty());
  }
  @Test public void filterWhenExchangeIsInsecureThenRedirects(){
    ServerWebExchange exchange=get("http://localhost");
    this.filter.filter(exchange,this.chain).block();
    assertThat(statusCode(exchange)).isEqualTo(302);
    assertThat(redirectedUrl(exchange)).isEqualTo("https://localhost");
  }
  @Test public void filterWhenExchangeIsSecureThenNoRedirect(){
    ServerWebExchange exchange=get("https://localhost");
    this.filter.filter(exchange,this.chain).block();
    assertThat(exchange.getResponse().getStatusCode()).isNull();
  }
  @Test public void filterWhenExchangeMismatchesThenNoRedirect(){
    ServerWebExchangeMatcher matcher=mock(ServerWebExchangeMatcher.class);
    when(matcher.matches(any(ServerWebExchange.class))).thenReturn(ServerWebExchangeMatcher.MatchResult.notMatch());
    this.filter.setRequiresHttpsRedirectMatcher(matcher);
    ServerWebExchange exchange=get("http://localhost:8080");
    this.filter.filter(exchange,this.chain).block();
    assertThat(exchange.getResponse().getStatusCode()).isNull();
  }
  @Test public void filterWhenExchangeMatchesAndRequestIsInsecureThenRedirects(){
    ServerWebExchangeMatcher matcher=mock(ServerWebExchangeMatcher.class);
    when(matcher.matches(any(ServerWebExchange.class))).thenReturn(ServerWebExchangeMatcher.MatchResult.match());
    this.filter.setRequiresHttpsRedirectMatcher(matcher);
    ServerWebExchange exchange=get("http://localhost:8080");
    this.filter.filter(exchange,this.chain).block();
    assertThat(statusCode(exchange)).isEqualTo(302);
    assertThat(redirectedUrl(exchange)).isEqualTo("https://localhost:8443");
    verify(matcher).matches(any(ServerWebExchange.class));
  }
  @Test public void filterWhenRequestIsInsecureThenPortMapperRemapsPort(){
    PortMapper portMapper=mock(PortMapper.class);
    when(portMapper.lookupHttpsPort(314)).thenReturn(159);
    this.filter.setPortMapper(portMapper);
    ServerWebExchange exchange=get("http://localhost:314");
    this.filter.filter(exchange,this.chain).block();
    assertThat(statusCode(exchange)).isEqualTo(302);
    assertThat(redirectedUrl(exchange)).isEqualTo("https://localhost:159");
    verify(portMapper).lookupHttpsPort(314);
  }
  @Test public void filterWhenInsecureRequestHasAPathThenRedirects(){
    ServerWebExchange exchange=get("http://localhost:8080/path/page.html?query=string");
    this.filter.filter(exchange,this.chain).block();
    assertThat(statusCode(exchange)).isEqualTo(302);
    assertThat(redirectedUrl(exchange)).isEqualTo("https://localhost:8443/path/page.html?query=string");
  }
  @Test public void setRequiresTransportSecurityMatcherWhenSetWithNullValueThenThrowsIllegalArgument(){
    assertThatCode(() -> this.filter.setRequiresHttpsRedirectMatcher(null)).isInstanceOf(IllegalArgumentException.class);
  }
  @Test public void setPortMapperWhenSetWithNullValueThenThrowsIllegalArgument(){
    assertThatCode(() -> this.filter.setPortMapper(null)).isInstanceOf(IllegalArgumentException.class);
  }
  private String redirectedUrl(  ServerWebExchange exchange){
    return exchange.getResponse().getHeaders().get(HttpHeaders.LOCATION).iterator().next();
  }
  private int statusCode(  ServerWebExchange exchange){
    return exchange.getResponse().getStatusCode().value();
  }
  private ServerWebExchange get(  String uri){
    return MockServerWebExchange.from(MockServerHttpRequest.get(uri).build());
  }
}
