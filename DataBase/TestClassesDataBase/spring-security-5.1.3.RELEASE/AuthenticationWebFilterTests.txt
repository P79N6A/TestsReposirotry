/** 
 * @author Rob Winch
 * @since 5.0
 */
@RunWith(MockitoJUnitRunner.class) public class AuthenticationWebFilterTests {
  @Mock private ServerAuthenticationSuccessHandler successHandler;
  @Mock private ServerAuthenticationConverter authenticationConverter;
  @Mock private ReactiveAuthenticationManager authenticationManager;
  @Mock private ServerAuthenticationFailureHandler failureHandler;
  @Mock private ServerSecurityContextRepository securityContextRepository;
  private AuthenticationWebFilter filter;
  @Before public void setup(){
    this.filter=new AuthenticationWebFilter(this.authenticationManager);
    this.filter.setAuthenticationSuccessHandler(this.successHandler);
    this.filter.setServerAuthenticationConverter(this.authenticationConverter);
    this.filter.setSecurityContextRepository(this.securityContextRepository);
    this.filter.setAuthenticationFailureHandler(this.failureHandler);
  }
  @Test public void filterWhenDefaultsAndNoAuthenticationThenContinues(){
    this.filter=new AuthenticationWebFilter(this.authenticationManager);
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    EntityExchangeResult<String> result=client.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class).consumeWith(b -> assertThat(b.getResponseBody()).isEqualTo("ok")).returnResult();
    verifyZeroInteractions(this.authenticationManager);
    assertThat(result.getResponseCookies()).isEmpty();
  }
  @Test public void filterWhenDefaultsAndAuthenticationSuccessThenContinues(){
    when(this.authenticationManager.authenticate(any())).thenReturn(Mono.just(new TestingAuthenticationToken("test","this","ROLE")));
    this.filter=new AuthenticationWebFilter(this.authenticationManager);
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    EntityExchangeResult<String> result=client.get().uri("/").headers(headers -> headers.setBasicAuth("test","this")).exchange().expectStatus().isOk().expectBody(String.class).consumeWith(b -> assertThat(b.getResponseBody()).isEqualTo("ok")).returnResult();
    assertThat(result.getResponseCookies()).isEmpty();
  }
  @Test public void filterWhenDefaultsAndAuthenticationFailThenUnauthorized(){
    when(this.authenticationManager.authenticate(any())).thenReturn(Mono.error(new BadCredentialsException("failed")));
    this.filter=new AuthenticationWebFilter(this.authenticationManager);
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    EntityExchangeResult<Void> result=client.get().uri("/").headers(headers -> headers.setBasicAuth("test","this")).exchange().expectStatus().isUnauthorized().expectHeader().valueMatches("WWW-Authenticate","Basic realm=\"Realm\"").expectBody().isEmpty();
    assertThat(result.getResponseCookies()).isEmpty();
  }
  @Test public void filterWhenConvertEmptyThenOk(){
    when(this.authenticationConverter.convert(any())).thenReturn(Mono.empty());
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    client.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class).consumeWith(b -> assertThat(b.getResponseBody()).isEqualTo("ok")).returnResult();
    verify(this.securityContextRepository,never()).save(any(),any());
    verifyZeroInteractions(this.authenticationManager,this.successHandler,this.failureHandler);
  }
  @Test public void filterWhenConvertErrorThenServerError(){
    when(this.authenticationConverter.convert(any())).thenReturn(Mono.error(new RuntimeException("Unexpected")));
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    client.get().uri("/").exchange().expectStatus().is5xxServerError().expectBody().isEmpty();
    verify(this.securityContextRepository,never()).save(any(),any());
    verifyZeroInteractions(this.authenticationManager,this.successHandler,this.failureHandler);
  }
  @Test public void filterWhenConvertAndAuthenticationSuccessThenSuccess(){
    Mono<Authentication> authentication=Mono.just(new TestingAuthenticationToken("test","this","ROLE_USER"));
    when(this.authenticationConverter.convert(any())).thenReturn(authentication);
    when(this.authenticationManager.authenticate(any())).thenReturn(authentication);
    when(this.successHandler.onAuthenticationSuccess(any(),any())).thenReturn(Mono.empty());
    when(this.securityContextRepository.save(any(),any())).thenAnswer(a -> Mono.just(a.getArguments()[0]));
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    client.get().uri("/").exchange().expectStatus().isOk().expectBody().isEmpty();
    verify(this.successHandler).onAuthenticationSuccess(any(),eq(authentication.block()));
    verify(this.securityContextRepository).save(any(),any());
    verifyZeroInteractions(this.failureHandler);
  }
  @Test public void filterWhenConvertAndAuthenticationEmptyThenServerError(){
    Mono<Authentication> authentication=Mono.just(new TestingAuthenticationToken("test","this","ROLE_USER"));
    when(this.authenticationConverter.convert(any())).thenReturn(authentication);
    when(this.authenticationManager.authenticate(any())).thenReturn(Mono.empty());
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    client.get().uri("/").exchange().expectStatus().is5xxServerError().expectBody().isEmpty();
    verify(this.securityContextRepository,never()).save(any(),any());
    verifyZeroInteractions(this.successHandler,this.failureHandler);
  }
  @Test public void filterWhenNotMatchAndConvertAndAuthenticationSuccessThenContinues(){
    this.filter.setRequiresAuthenticationMatcher(e -> ServerWebExchangeMatcher.MatchResult.notMatch());
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    EntityExchangeResult<String> result=client.get().uri("/").headers(headers -> headers.setBasicAuth("test","this")).exchange().expectStatus().isOk().expectBody(String.class).consumeWith(b -> assertThat(b.getResponseBody()).isEqualTo("ok")).returnResult();
    assertThat(result.getResponseCookies()).isEmpty();
    verifyZeroInteractions(this.authenticationConverter,this.authenticationManager,this.successHandler);
  }
  @Test public void filterWhenConvertAndAuthenticationFailThenEntryPoint(){
    Mono<Authentication> authentication=Mono.just(new TestingAuthenticationToken("test","this","ROLE_USER"));
    when(this.authenticationConverter.convert(any())).thenReturn(authentication);
    when(this.authenticationManager.authenticate(any())).thenReturn(Mono.error(new BadCredentialsException("Failed")));
    when(this.failureHandler.onAuthenticationFailure(any(),any())).thenReturn(Mono.empty());
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    client.get().uri("/").exchange().expectStatus().isOk().expectBody().isEmpty();
    verify(this.failureHandler).onAuthenticationFailure(any(),any());
    verify(this.securityContextRepository,never()).save(any(),any());
    verifyZeroInteractions(this.successHandler);
  }
  @Test public void filterWhenConvertAndAuthenticationExceptionThenServerError(){
    Mono<Authentication> authentication=Mono.just(new TestingAuthenticationToken("test","this","ROLE_USER"));
    when(this.authenticationConverter.convert(any())).thenReturn(authentication);
    when(this.authenticationManager.authenticate(any())).thenReturn(Mono.error(new RuntimeException("Failed")));
    WebTestClient client=WebTestClientBuilder.bindToWebFilters(this.filter).build();
    client.get().uri("/").exchange().expectStatus().is5xxServerError().expectBody().isEmpty();
    verify(this.securityContextRepository,never()).save(any(),any());
    verifyZeroInteractions(this.successHandler,this.failureHandler);
  }
  @Test(expected=IllegalArgumentException.class) public void setRequiresAuthenticationMatcherWhenNullThenException(){
    this.filter.setRequiresAuthenticationMatcher(null);
  }
}
