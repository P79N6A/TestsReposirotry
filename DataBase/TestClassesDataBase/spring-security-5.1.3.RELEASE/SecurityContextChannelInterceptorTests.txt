@RunWith(MockitoJUnitRunner.class) public class SecurityContextChannelInterceptorTests {
  @Mock MessageChannel channel;
  @Mock MessageHandler handler;
  @Mock Principal principal;
  MessageBuilder<String> messageBuilder;
  Authentication authentication;
  SecurityContextChannelInterceptor interceptor;
  AnonymousAuthenticationToken expectedAnonymous;
  @Before public void setup(){
    authentication=new TestingAuthenticationToken("user","pass","ROLE_USER");
    messageBuilder=MessageBuilder.withPayload("payload");
    expectedAnonymous=new AnonymousAuthenticationToken("key","anonymous",AuthorityUtils.createAuthorityList("ROLE_ANONYMOUS"));
    interceptor=new SecurityContextChannelInterceptor();
  }
  @After public void cleanup(){
    clearContext();
  }
  @Test(expected=IllegalArgumentException.class) public void constructorNullHeader(){
    new SecurityContextChannelInterceptor(null);
  }
  @Test public void preSendCustomHeader() throws Exception {
    String headerName="header";
    interceptor=new SecurityContextChannelInterceptor(headerName);
    messageBuilder.setHeader(headerName,authentication);
    interceptor.preSend(messageBuilder.build(),channel);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);
  }
  @Test public void preSendUserSet() throws Exception {
    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER,authentication);
    interceptor.preSend(messageBuilder.build(),channel);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);
  }
  @Test(expected=IllegalArgumentException.class) public void setAnonymousAuthenticationNull(){
    interceptor.setAnonymousAuthentication(null);
  }
  @Test public void preSendUsesCustomAnonymous() throws Exception {
    expectedAnonymous=new AnonymousAuthenticationToken("customKey","customAnonymous",AuthorityUtils.createAuthorityList("ROLE_CUSTOM"));
    interceptor.setAnonymousAuthentication(expectedAnonymous);
    interceptor.preSend(messageBuilder.build(),channel);
    assertAnonymous();
  }
  @Test public void preSendUserNotAuthentication() throws Exception {
    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER,principal);
    interceptor.preSend(messageBuilder.build(),channel);
    assertAnonymous();
  }
  @Test public void preSendUserNotSet() throws Exception {
    interceptor.preSend(messageBuilder.build(),channel);
    assertAnonymous();
  }
  @Test public void preSendUserNotSetCustomAnonymous() throws Exception {
    interceptor.preSend(messageBuilder.build(),channel);
    assertAnonymous();
  }
  @Test public void afterSendCompletion() throws Exception {
    SecurityContextHolder.getContext().setAuthentication(authentication);
    interceptor.afterSendCompletion(messageBuilder.build(),channel,true,null);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
  }
  @Test public void afterSendCompletionNullAuthentication() throws Exception {
    interceptor.afterSendCompletion(messageBuilder.build(),channel,true,null);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
  }
  @Test public void beforeHandleUserSet() throws Exception {
    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER,authentication);
    interceptor.beforeHandle(messageBuilder.build(),channel,handler);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);
  }
  @Test public void beforeHandleUserNotAuthentication() throws Exception {
    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER,principal);
    interceptor.beforeHandle(messageBuilder.build(),channel,handler);
    assertAnonymous();
  }
  @Test public void beforeHandleUserNotSet() throws Exception {
    interceptor.beforeHandle(messageBuilder.build(),channel,handler);
    assertAnonymous();
  }
  @Test public void afterMessageHandledUserNotSet() throws Exception {
    interceptor.afterMessageHandled(messageBuilder.build(),channel,handler,null);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
  }
  @Test public void afterMessageHandled() throws Exception {
    SecurityContextHolder.getContext().setAuthentication(authentication);
    interceptor.afterMessageHandled(messageBuilder.build(),channel,handler,null);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
  }
  @Test public void restoresOriginalContext() throws Exception {
    TestingAuthenticationToken original=new TestingAuthenticationToken("original","original","ROLE_USER");
    SecurityContextHolder.getContext().setAuthentication(original);
    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER,authentication);
    interceptor.beforeHandle(messageBuilder.build(),channel,handler);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);
    interceptor.afterMessageHandled(messageBuilder.build(),channel,handler,null);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(original);
  }
  /** 
 * If a user sends a websocket when processing another websocket
 * @throws Exception
 */
  @Test public void restoresOriginalContextNestedThreeDeep() throws Exception {
    AnonymousAuthenticationToken anonymous=new AnonymousAuthenticationToken("key","anonymous",AuthorityUtils.createAuthorityList("ROLE_USER"));
    TestingAuthenticationToken origional=new TestingAuthenticationToken("original","origional","ROLE_USER");
    SecurityContextHolder.getContext().setAuthentication(origional);
    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER,authentication);
    interceptor.beforeHandle(messageBuilder.build(),channel,handler);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);
    messageBuilder.setHeader(SimpMessageHeaderAccessor.USER_HEADER,null);
    interceptor.beforeHandle(messageBuilder.build(),channel,handler);
    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(anonymous.getName());
    interceptor.afterMessageHandled(messageBuilder.build(),channel,handler,null);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(authentication);
    interceptor.afterMessageHandled(messageBuilder.build(),channel,handler,null);
    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(origional);
  }
  private void assertAnonymous(){
    Authentication currentAuthentication=SecurityContextHolder.getContext().getAuthentication();
    assertThat(currentAuthentication).isInstanceOf(AnonymousAuthenticationToken.class);
    AnonymousAuthenticationToken anonymous=(AnonymousAuthenticationToken)currentAuthentication;
    assertThat(anonymous.getName()).isEqualTo(expectedAnonymous.getName());
    assertThat(anonymous.getAuthorities()).containsOnlyElementsOf(expectedAnonymous.getAuthorities());
    assertThat(anonymous.getKeyHash()).isEqualTo(expectedAnonymous.getKeyHash());
  }
}
