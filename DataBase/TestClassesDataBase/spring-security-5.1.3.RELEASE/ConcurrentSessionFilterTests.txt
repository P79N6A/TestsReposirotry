/** 
 * Tests  {@link ConcurrentSessionFilter}.
 * @author Ben Alex
 * @author Luke Taylor
 */
public class ConcurrentSessionFilterTests {
  @After public void cleanup(){
    SecurityContextHolder.clearContext();
  }
  @Test(expected=IllegalArgumentException.class) public void constructorSessionRegistryWhenSessionRegistryNullThenExceptionThrown(){
    new ConcurrentSessionFilter(null);
  }
  @SuppressWarnings("deprecation") @Test(expected=IllegalArgumentException.class) public void constructorSessionRegistryExpiresUrlWhenInvalidUrlThenExceptionThrown(){
    new ConcurrentSessionFilter(new SessionRegistryImpl(),"oops");
  }
  @SuppressWarnings("deprecation") @Test(expected=IllegalArgumentException.class) public void constructorSessionRegistryExpiresUrlWhenSessionRegistryNullThenExceptionThrown(){
    new ConcurrentSessionFilter(null,"/expired");
  }
  @Test(expected=IllegalArgumentException.class) public void constructorSessionRegistrySessionInformationExpiredStrategyWhenStrategyIsNullThenThrowsException(){
    new ConcurrentSessionFilter(new SessionRegistryImpl(),(SessionInformationExpiredStrategy)null);
  }
  @Test public void detectsExpiredSessions() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpSession session=new MockHttpSession();
    request.setSession(session);
    MockHttpServletResponse response=new MockHttpServletResponse();
    SessionRegistry registry=new SessionRegistryImpl();
    registry.registerNewSession(session.getId(),"principal");
    registry.getSessionInformation(session.getId()).expireNow();
    SimpleRedirectSessionInformationExpiredStrategy expiredSessionStrategy=new SimpleRedirectSessionInformationExpiredStrategy("/expired.jsp");
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry,expiredSessionStrategy);
    filter.setLogoutHandlers(new LogoutHandler[]{new SecurityContextLogoutHandler()});
    filter.afterPropertiesSet();
    FilterChain fc=mock(FilterChain.class);
    filter.doFilter(request,response,fc);
    verifyZeroInteractions(fc);
    assertThat(response.getRedirectedUrl()).isEqualTo("/expired.jsp");
  }
  @Test public void returnsExpectedMessageWhenNoExpiredUrlSet() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpSession session=new MockHttpSession();
    request.setSession(session);
    MockHttpServletResponse response=new MockHttpServletResponse();
    SessionRegistry registry=new SessionRegistryImpl();
    registry.registerNewSession(session.getId(),"principal");
    registry.getSessionInformation(session.getId()).expireNow();
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry);
    FilterChain fc=mock(FilterChain.class);
    filter.doFilter(request,response,fc);
    verifyZeroInteractions(fc);
    assertThat(response.getContentAsString()).isEqualTo("This session has been expired (possibly due to multiple concurrent logins being " + "attempted as the same user).");
  }
  @Test(expected=IllegalArgumentException.class) public void detectsMissingSessionRegistry() throws Exception {
    new ConcurrentSessionFilter(null);
  }
  @Test public void lastRequestTimeUpdatesCorrectly() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpSession session=new MockHttpSession();
    request.setSession(session);
    MockHttpServletResponse response=new MockHttpServletResponse();
    FilterChain fc=mock(FilterChain.class);
    SessionRegistry registry=new SessionRegistryImpl();
    registry.registerNewSession(session.getId(),"principal");
    SimpleRedirectSessionInformationExpiredStrategy expiredSessionStrategy=new SimpleRedirectSessionInformationExpiredStrategy("/expired.jsp");
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry,expiredSessionStrategy);
    Date lastRequest=registry.getSessionInformation(session.getId()).getLastRequest();
    Thread.sleep(1000);
    filter.doFilter(request,response,fc);
    verify(fc).doFilter(request,response);
    assertThat(registry.getSessionInformation(session.getId()).getLastRequest().after(lastRequest)).isTrue();
  }
  @Test public void doFilterWhenNoSessionThenChainIsContinued() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpServletResponse response=new MockHttpServletResponse();
    RedirectStrategy redirect=mock(RedirectStrategy.class);
    SessionRegistry registry=mock(SessionRegistry.class);
    SessionInformation information=new SessionInformation("user","sessionId",new Date(System.currentTimeMillis() - 1000));
    information.expireNow();
    when(registry.getSessionInformation(anyString())).thenReturn(information);
    String expiredUrl="/expired";
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry,expiredUrl);
    filter.setRedirectStrategy(redirect);
    MockFilterChain chain=new MockFilterChain();
    filter.doFilter(request,response,chain);
    assertThat(chain.getRequest()).isNotNull();
  }
  @Test public void doFilterWhenNoSessionInformationThenChainIsContinued() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    request.setSession(new MockHttpSession());
    MockHttpServletResponse response=new MockHttpServletResponse();
    RedirectStrategy redirect=mock(RedirectStrategy.class);
    SessionRegistry registry=mock(SessionRegistry.class);
    String expiredUrl="/expired";
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry,expiredUrl);
    filter.setRedirectStrategy(redirect);
    MockFilterChain chain=new MockFilterChain();
    filter.doFilter(request,response,chain);
    assertThat(chain.getRequest()).isNotNull();
  }
  @Test public void doFilterWhenCustomRedirectStrategyThenCustomRedirectStrategyUsed() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpSession session=new MockHttpSession();
    request.setSession(session);
    MockHttpServletResponse response=new MockHttpServletResponse();
    RedirectStrategy redirect=mock(RedirectStrategy.class);
    SessionRegistry registry=mock(SessionRegistry.class);
    SessionInformation information=new SessionInformation("user","sessionId",new Date(System.currentTimeMillis() - 1000));
    information.expireNow();
    when(registry.getSessionInformation(anyString())).thenReturn(information);
    String expiredUrl="/expired";
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry,expiredUrl);
    filter.setRedirectStrategy(redirect);
    filter.doFilter(request,response,new MockFilterChain());
    verify(redirect).sendRedirect(request,response,expiredUrl);
  }
  @Test public void doFilterWhenOverrideThenCustomRedirectStrategyUsed() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpSession session=new MockHttpSession();
    request.setSession(session);
    MockHttpServletResponse response=new MockHttpServletResponse();
    RedirectStrategy redirect=mock(RedirectStrategy.class);
    SessionRegistry registry=mock(SessionRegistry.class);
    SessionInformation information=new SessionInformation("user","sessionId",new Date(System.currentTimeMillis() - 1000));
    information.expireNow();
    when(registry.getSessionInformation(anyString())).thenReturn(information);
    final String expiredUrl="/expired";
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry,expiredUrl + "will-be-overrridden"){
      @Override protected String determineExpiredUrl(      HttpServletRequest request,      SessionInformation info){
        return expiredUrl;
      }
    }
;
    filter.setRedirectStrategy(redirect);
    filter.doFilter(request,response,new MockFilterChain());
    verify(redirect).sendRedirect(request,response,expiredUrl);
  }
  @Test public void doFilterWhenNoExpiredUrlThenResponseWritten() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpSession session=new MockHttpSession();
    request.setSession(session);
    MockHttpServletResponse response=new MockHttpServletResponse();
    SessionRegistry registry=mock(SessionRegistry.class);
    SessionInformation information=new SessionInformation("user","sessionId",new Date(System.currentTimeMillis() - 1000));
    information.expireNow();
    when(registry.getSessionInformation(anyString())).thenReturn(information);
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry);
    filter.doFilter(request,response,new MockFilterChain());
    assertThat(response.getContentAsString()).contains("This session has been expired (possibly due to multiple concurrent logins being attempted as the same user).");
  }
  @Test public void doFilterWhenCustomLogoutHandlersThenHandlersUsed() throws Exception {
    LogoutHandler handler=mock(LogoutHandler.class);
    MockHttpServletRequest request=new MockHttpServletRequest();
    MockHttpSession session=new MockHttpSession();
    request.setSession(session);
    MockHttpServletResponse response=new MockHttpServletResponse();
    SessionRegistry registry=mock(SessionRegistry.class);
    SessionInformation information=new SessionInformation("user","sessionId",new Date(System.currentTimeMillis() - 1000));
    information.expireNow();
    when(registry.getSessionInformation(anyString())).thenReturn(information);
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(registry);
    filter.setLogoutHandlers(new LogoutHandler[]{handler});
    filter.doFilter(request,response,new MockFilterChain());
    verify(handler).logout(eq(request),eq(response),any());
  }
  @Test(expected=IllegalArgumentException.class) public void setLogoutHandlersWhenNullThenThrowsException(){
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(new SessionRegistryImpl());
    filter.setLogoutHandlers(null);
  }
  @Test(expected=IllegalArgumentException.class) public void setLogoutHandlersWhenEmptyThenThrowsException(){
    ConcurrentSessionFilter filter=new ConcurrentSessionFilter(new SessionRegistryImpl());
    filter.setLogoutHandlers(new LogoutHandler[0]);
  }
}
