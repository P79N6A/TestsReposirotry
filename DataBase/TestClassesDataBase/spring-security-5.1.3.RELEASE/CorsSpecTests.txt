/** 
 * @author Rob Winch
 * @since 5.0
 */
@RunWith(MockitoJUnitRunner.class) public class CorsSpecTests {
  @Mock private CorsConfigurationSource source;
  @Mock private ApplicationContext context;
  ServerHttpSecurity http;
  HttpHeaders expectedHeaders=new HttpHeaders();
  Set<String> headerNamesNotPresent=new HashSet<>();
  @Before public void setup(){
    this.http=new TestingServerHttpSecurity().applicationContext(this.context);
    CorsConfiguration value=new CorsConfiguration();
    value.setAllowedOrigins(Arrays.asList("*"));
    when(this.source.getCorsConfiguration(any())).thenReturn(value);
  }
  @Test public void corsWhenEnabledThenAccessControlAllowOriginAndSecurityHeaders(){
    this.http.cors().configurationSource(this.source);
    this.expectedHeaders.set("Access-Control-Allow-Origin","*");
    this.expectedHeaders.set("X-Frame-Options","DENY");
    assertHeaders();
  }
  @Test public void corsWhenCorsConfigurationSourceBeanThenAccessControlAllowOriginAndSecurityHeaders(){
    when(this.context.getBeanNamesForType(any(ResolvableType.class))).thenReturn(new String[]{"source"},new String[0]);
    when(this.context.getBean("source")).thenReturn(this.source);
    this.expectedHeaders.set("Access-Control-Allow-Origin","*");
    this.expectedHeaders.set("X-Frame-Options","DENY");
    assertHeaders();
  }
  @Test public void corsWhenNoConfigurationSourceThenNoCorsHeaders(){
    when(this.context.getBeanNamesForType(any(ResolvableType.class))).thenReturn(new String[0]);
    this.headerNamesNotPresent.add("Access-Control-Allow-Origin");
    assertHeaders();
  }
  private void assertHeaders(){
    WebTestClient client=buildClient();
    FluxExchangeResult<String> response=client.get().uri("https://example.com/").headers(h -> h.setOrigin("https://origin.example.com")).exchange().returnResult(String.class);
    Map<String,List<String>> responseHeaders=response.getResponseHeaders();
    if (!this.expectedHeaders.isEmpty()) {
      assertThat(responseHeaders).describedAs(response.toString()).containsAllEntriesOf(this.expectedHeaders);
    }
    if (!this.headerNamesNotPresent.isEmpty()) {
      assertThat(responseHeaders.keySet()).doesNotContainAnyElementsOf(this.headerNamesNotPresent);
    }
  }
  private WebTestClient buildClient(){
    return WebTestClientBuilder.bindToWebFilters(this.http.build()).build();
  }
}
