/** 
 * @author Rob Winch
 * @author Artsiom Yudovin
 */
@RunWith(SpringJUnit4ClassRunner.class) @SecurityTestExecutionListeners public class GlobalMethodSecurityConfigurationTests {
  @Rule public final SpringTestRule spring=new SpringTestRule();
  @Rule public ExpectedException thrown=ExpectedException.none();
  @Autowired(required=false) private MethodSecurityService service;
  private AuthenticationManager authenticationManager;
  @Autowired public void setMethodInterceptor(  MethodSecurityInterceptor interceptor){
    this.authenticationManager=interceptor.getAuthenticationManager();
  }
  @Autowired(required=false) MockEventListener<AbstractAuthenticationEvent> events;
  @Test public void configureWhenGlobalMethodSecurityIsMissingMetadataSourceThenException(){
    this.thrown.expect(UnsatisfiedDependencyException.class);
    this.spring.register(IllegalStateGlobalMethodSecurityConfig.class).autowire();
  }
@EnableGlobalMethodSecurity public static class IllegalStateGlobalMethodSecurityConfig extends GlobalMethodSecurityConfiguration {
  }
  @Test public void configureWhenGlobalMethodSecurityHasCustomMetadataSourceThenNoEnablingAttributeIsNeeded(){
    this.spring.register(CustomMetadataSourceConfig.class).autowire();
  }
@EnableGlobalMethodSecurity public static class CustomMetadataSourceConfig extends GlobalMethodSecurityConfiguration {
    @Bean @Override protected MethodSecurityMetadataSource customMethodSecurityMetadataSource(){
      return mock(MethodSecurityMetadataSource.class);
    }
  }
  @Test public void methodSecurityAuthenticationManagerPublishesEvent(){
    this.spring.register(InMemoryAuthWithGlobalMethodSecurityConfig.class).autowire();
    try {
      this.authenticationManager.authenticate(new UsernamePasswordAuthenticationToken("foo","bar"));
    }
 catch (    AuthenticationException e) {
    }
    assertThat(this.events.getEvents()).extracting(Object::getClass).containsOnly((Class)AuthenticationFailureBadCredentialsEvent.class);
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) public static class InMemoryAuthWithGlobalMethodSecurityConfig extends GlobalMethodSecurityConfiguration {
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
    @Bean public MockEventListener<AbstractAuthenticationEvent> listener(){
      return new MockEventListener<AbstractAuthenticationEvent>(){
      }
;
    }
  }
  @Test @WithMockUser public void methodSecurityWhenAuthenticationTrustResolverIsBeanThenAutowires(){
    this.spring.register(CustomTrustResolverConfig.class).autowire();
    AuthenticationTrustResolver trustResolver=this.spring.getContext().getBean(AuthenticationTrustResolver.class);
    when(trustResolver.isAnonymous(any())).thenReturn(true,false);
    assertThatThrownBy(() -> this.service.preAuthorizeNotAnonymous()).isInstanceOf(AccessDeniedException.class);
    this.service.preAuthorizeNotAnonymous();
    verify(trustResolver,atLeastOnce()).isAnonymous(any());
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) static class CustomTrustResolverConfig {
    @Bean public AuthenticationTrustResolver trustResolver(){
      return mock(AuthenticationTrustResolver.class);
    }
    @Bean public MethodSecurityServiceImpl service(){
      return new MethodSecurityServiceImpl();
    }
  }
  @Test @WithMockUser public void defaultWebSecurityExpressionHandlerHasBeanResolverSet(){
    this.spring.register(ExpressionHandlerHasBeanResolverSetConfig.class).autowire();
    Authz authz=this.spring.getContext().getBean(Authz.class);
    assertThatThrownBy(() -> this.service.preAuthorizeBean(false)).isInstanceOf(AccessDeniedException.class);
    this.service.preAuthorizeBean(true);
  }
@EnableGlobalMethodSecurity(prePostEnabled=true,proxyTargetClass=true) static class ExpressionHandlerHasBeanResolverSetConfig {
    @Bean public MethodSecurityServiceImpl service(){
      return new MethodSecurityServiceImpl();
    }
    @Bean public Authz authz(){
      return new Authz();
    }
  }
  @Test @WithMockUser public void methodSecuritySupportsAnnotaitonsOnInterfaceParamerNames(){
    this.spring.register(MethodSecurityServiceConfig.class).autowire();
    assertThatThrownBy(() -> this.service.postAnnotation("deny")).isInstanceOf(AccessDeniedException.class);
    this.service.postAnnotation("grant");
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) static class MethodSecurityServiceConfig {
    @Bean public MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
  }
  @Test @WithMockUser public void globalMethodSecurityConfigurationAutowiresPermissionEvaluator(){
    this.spring.register(AutowirePermissionEvaluatorConfig.class).autowire();
    PermissionEvaluator permission=this.spring.getContext().getBean(PermissionEvaluator.class);
    when(permission.hasPermission(any(),eq("something"),eq("read"))).thenReturn(true,false);
    this.service.hasPermission("something");
    assertThatThrownBy(() -> this.service.hasPermission("something")).isInstanceOf(AccessDeniedException.class);
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) public static class AutowirePermissionEvaluatorConfig {
    @Bean public PermissionEvaluator permissionEvaluator(){
      return mock(PermissionEvaluator.class);
    }
    @Bean public MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
  }
  @Test public void multiPermissionEvaluatorConfig() throws Exception {
    this.spring.register(MultiPermissionEvaluatorConfig.class).autowire();
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) public static class MultiPermissionEvaluatorConfig {
    @Bean public PermissionEvaluator permissionEvaluator(){
      return mock(PermissionEvaluator.class);
    }
    @Bean public PermissionEvaluator permissionEvaluator2(){
      return mock(PermissionEvaluator.class);
    }
  }
  @Test @WithMockUser public void enableGlobalMethodSecurityWorksOnSuperclass(){
    this.spring.register(ChildConfig.class).autowire();
    assertThatThrownBy(() -> this.service.preAuthorize()).isInstanceOf(AccessDeniedException.class);
  }
@Configuration static class ChildConfig extends ParentConfig {
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) static class ParentConfig {
    @Bean public MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
  }
  @Test @WithMockUser public void supportAuthenticationManagerInParent(){
    try (AnnotationConfigWebApplicationContext parent=new AnnotationConfigWebApplicationContext()){
      parent.register(Sec2479ParentConfig.class);
      parent.refresh();
      try (AnnotationConfigWebApplicationContext child=new AnnotationConfigWebApplicationContext()){
        child.setParent(parent);
        child.register(Sec2479ChildConfig.class);
        child.refresh();
        this.spring.context(child).autowire();
        assertThatThrownBy(() -> this.service.preAuthorize()).isInstanceOf(AccessDeniedException.class);
      }
     }
   }
@Configuration static class Sec2479ParentConfig {
    @Bean public AuthenticationManager am(){
      return mock(AuthenticationManager.class);
    }
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) static class Sec2479ChildConfig {
    @Bean public MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
  }
  @Test public void enableGlobalMethodSecurityDoesNotTriggerEagerInitializationOfBeansInGlobalAuthenticationConfigurer(){
    this.spring.register(Sec2815Config.class).autowire();
    MockBeanPostProcessor pp=this.spring.getContext().getBean(MockBeanPostProcessor.class);
    assertThat(pp.beforeInit).containsKeys("dataSource");
    assertThat(pp.afterInit).containsKeys("dataSource");
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) static class Sec2815Config {
    @Bean public MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
    @Bean public MockBeanPostProcessor mockBeanPostProcessor(){
      return new MockBeanPostProcessor();
    }
    @Bean public DataSource dataSource(){
      return mock(DataSource.class);
    }
@Configuration static class AuthConfig extends GlobalAuthenticationConfigurerAdapter {
      @Autowired DataSource dataSource;
      @Override public void init(      AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication();
      }
    }
  }
static class MockBeanPostProcessor implements BeanPostProcessor {
    Map<String,Object> beforeInit=new HashMap<String,Object>();
    Map<String,Object> afterInit=new HashMap<String,Object>();
    @Override public Object postProcessBeforeInitialization(    Object bean,    String beanName) throws BeansException {
      this.beforeInit.put(beanName,bean);
      return bean;
    }
    @Override public Object postProcessAfterInitialization(    Object bean,    String beanName) throws BeansException {
      this.afterInit.put(beanName,bean);
      return bean;
    }
  }
  @Test public void globalSecurityProxiesSecurity(){
    this.spring.register(Sec3005Config.class).autowire();
    assertThat(this.service.getClass()).matches(c -> !Proxy.isProxyClass(c),"is not proxy class");
  }
@EnableGlobalMethodSecurity(prePostEnabled=true,mode=AdviceMode.ASPECTJ) @EnableTransactionManagement static class Sec3005Config {
    @Bean public MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
    @Autowired public void configureGlobal(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
  }
  @Test @WithMockUser public void preAuthorizeBeanSpel(){
    this.spring.register(PreAuthorizeBeanSpelConfig.class).autowire();
    assertThatThrownBy(() -> this.service.preAuthorizeBean(false)).isInstanceOf(AccessDeniedException.class);
    this.service.preAuthorizeBean(true);
  }
@Configuration @EnableGlobalMethodSecurity(prePostEnabled=true) public static class PreAuthorizeBeanSpelConfig {
    @Bean MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
    @Bean Authz authz(){
      return new Authz();
    }
  }
  @Test @WithMockUser public void roleHierarchy(){
    this.spring.register(RoleHierarchyConfig.class).autowire();
    assertThatThrownBy(() -> this.service.preAuthorize()).isInstanceOf(AccessDeniedException.class);
    this.service.preAuthorizeAdmin();
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) @Configuration public static class RoleHierarchyConfig {
    @Bean MethodSecurityService service(){
      return new MethodSecurityServiceImpl();
    }
    @Bean RoleHierarchy roleHierarchy(){
      RoleHierarchyImpl result=new RoleHierarchyImpl();
      result.setHierarchy("ROLE_USER > ROLE_ADMIN");
      return result;
    }
  }
  @Test @WithMockUser(authorities="ROLE:USER") public void grantedAuthorityDefaultsAutowires(){
    this.spring.register(CustomGrantedAuthorityConfig.class).autowire();
    CustomGrantedAuthorityConfig.CustomAuthorityService customService=this.spring.getContext().getBean(CustomGrantedAuthorityConfig.CustomAuthorityService.class);
    assertThatThrownBy(() -> this.service.preAuthorize()).isInstanceOf(AccessDeniedException.class);
    customService.customPrefixRoleUser();
  }
@EnableGlobalMethodSecurity(prePostEnabled=true) static class CustomGrantedAuthorityConfig {
    @Bean public GrantedAuthorityDefaults ga(){
      return new GrantedAuthorityDefaults("ROLE:");
    }
    @Bean public CustomAuthorityService service(){
      return new CustomAuthorityService();
    }
    @Bean public MethodSecurityServiceImpl methodSecurityService(){
      return new MethodSecurityServiceImpl();
    }
static class CustomAuthorityService {
      @PreAuthorize("hasRole('ROLE:USER')") public void customPrefixRoleUser(){
      }
    }
  }
}
