/** 
 * @author Rob Winch
 */
public class AuthorizeRequestsTests {
  AnnotationConfigWebApplicationContext context;
  MockHttpServletRequest request;
  MockHttpServletResponse response;
  MockFilterChain chain;
  MockServletContext servletContext;
  @Autowired FilterChainProxy springSecurityFilterChain;
  @Before public void setup(){
    this.servletContext=spy(new MockServletContext());
    this.request=new MockHttpServletRequest("GET","");
    this.request.setMethod("GET");
    this.response=new MockHttpServletResponse();
    this.chain=new MockFilterChain();
  }
  @After public void cleanup(){
    if (this.context != null) {
      this.context.close();
    }
  }
  @Test public void antMatchersMethodAndNoPatterns() throws Exception {
    loadConfig(AntMatchersNoPatternsConfig.class);
    this.request.setMethod("POST");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_FORBIDDEN);
  }
@EnableWebSecurity @Configuration static class AntMatchersNoPatternsConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().antMatchers(HttpMethod.POST).denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
  }
  @Test public void antMatchersPathVariables() throws Exception {
    loadConfig(AntPatchersPathVariables.class);
    this.request.setServletPath("/user/user");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
    this.setup();
    this.request.setServletPath("/user/deny");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_FORBIDDEN);
  }
  @Test public void antMatchersPathVariablesCaseInsensitive() throws Exception {
    loadConfig(AntPatchersPathVariables.class);
    this.request.setServletPath("/USER/user");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
    this.setup();
    this.request.setServletPath("/USER/deny");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_FORBIDDEN);
  }
@EnableWebSecurity @Configuration static class AntPatchersPathVariables extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().requestMatchers(new AntPathRequestMatcher("/user/{user}",null,false)).access("#user == 'user'").anyRequest().denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
  }
  @Test public void antMatchersPathVariablesCaseInsensitiveCamelCaseVariables() throws Exception {
    loadConfig(AntMatchersPathVariablesCamelCaseVariables.class);
    this.request.setServletPath("/USER/user");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
    this.setup();
    this.request.setServletPath("/USER/deny");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_FORBIDDEN);
  }
@EnableWebSecurity @Configuration static class AntMatchersPathVariablesCamelCaseVariables extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().requestMatchers(new AntPathRequestMatcher("/user/{userName}",null,false)).access("#userName == 'user'").anyRequest().denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
  }
  @Test public void roleHiearchy() throws Exception {
    loadConfig(RoleHiearchyConfig.class);
    SecurityContext securityContext=new SecurityContextImpl();
    securityContext.setAuthentication(new UsernamePasswordAuthenticationToken("test","notused",AuthorityUtils.createAuthorityList("ROLE_USER")));
    this.request.getSession().setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY,securityContext);
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
  }
@EnableWebSecurity @Configuration static class RoleHiearchyConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.authorizeRequests().anyRequest().hasRole("ADMIN");
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
    @Bean public RoleHierarchy roleHiearchy(){
      RoleHierarchyImpl result=new RoleHierarchyImpl();
      result.setHierarchy("ROLE_USER > ROLE_ADMIN");
      return result;
    }
  }
  @Test public void mvcMatcher() throws Exception {
    loadConfig(MvcMatcherConfig.class);
    this.request.setRequestURI("/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setRequestURI("/path.html");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/path/");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
  }
@EnableWebSecurity @Configuration @EnableWebMvc static class MvcMatcherConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.httpBasic().and().authorizeRequests().mvcMatchers("/path").denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
@RestController static class PathController {
      @RequestMapping("/path") public String path(){
        return "path";
      }
    }
  }
  @Test public void mvcMatcherServletPath() throws Exception {
    loadConfig(MvcMatcherServletPathConfig.class);
    this.request.setServletPath("/spring");
    this.request.setRequestURI("/spring/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/spring");
    this.request.setRequestURI("/spring/path.html");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/spring");
    this.request.setRequestURI("/spring/path/");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
    setup();
    this.request.setServletPath("/foo");
    this.request.setRequestURI("/foo/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
    setup();
    this.request.setServletPath("/");
    this.request.setRequestURI("/path");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
  }
@EnableWebSecurity @Configuration @EnableWebMvc static class MvcMatcherServletPathConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.httpBasic().and().authorizeRequests().mvcMatchers("/path").servletPath("/spring").denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
@RestController static class PathController {
      @RequestMapping("/path") public String path(){
        return "path";
      }
    }
  }
  @Test public void mvcMatcherPathVariables() throws Exception {
    loadConfig(MvcMatcherPathVariablesConfig.class);
    this.request.setRequestURI("/user/user");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
    this.setup();
    this.request.setRequestURI("/user/deny");
    this.springSecurityFilterChain.doFilter(this.request,this.response,this.chain);
    assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
  }
@EnableWebSecurity @Configuration @EnableWebMvc static class MvcMatcherPathVariablesConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.httpBasic().and().authorizeRequests().mvcMatchers("/user/{userName}").access("#userName == 'user'");
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
@RestController static class PathController {
      @RequestMapping("/path") public String path(){
        return "path";
      }
    }
  }
@EnableWebSecurity @Configuration @EnableWebMvc static class MvcMatcherPathServletPathRequiredConfig extends WebSecurityConfigurerAdapter {
    @Override protected void configure(    HttpSecurity http) throws Exception {
      http.httpBasic().and().authorizeRequests().mvcMatchers("/user").denyAll();
    }
    @Override protected void configure(    AuthenticationManagerBuilder auth) throws Exception {
      auth.inMemoryAuthentication();
    }
@RestController static class PathController {
      @RequestMapping("/path") public String path(){
        return "path";
      }
    }
  }
  public void loadConfig(  Class<?>... configs){
    this.context=new AnnotationConfigWebApplicationContext();
    this.context.register(configs);
    this.context.setServletContext(this.servletContext);
    this.context.refresh();
    this.context.getAutowireCapableBeanFactory().autowireBean(this);
  }
}
