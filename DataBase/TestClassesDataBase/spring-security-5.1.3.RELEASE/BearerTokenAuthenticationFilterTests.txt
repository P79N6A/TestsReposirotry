/** 
 * Tests  {@link BearerTokenAuthenticationFilterTests}
 * @author Josh Cummings
 */
@RunWith(MockitoJUnitRunner.class) public class BearerTokenAuthenticationFilterTests {
  @Mock AuthenticationEntryPoint authenticationEntryPoint;
  @Mock AuthenticationManager authenticationManager;
  @Mock BearerTokenResolver bearerTokenResolver;
  MockHttpServletRequest request;
  MockHttpServletResponse response;
  MockFilterChain filterChain;
  @InjectMocks BearerTokenAuthenticationFilter filter;
  @Before public void httpMocks(){
    this.request=new MockHttpServletRequest();
    this.response=new MockHttpServletResponse();
    this.filterChain=new MockFilterChain();
  }
  @Before public void setterMocks(){
    this.filter.setAuthenticationEntryPoint(this.authenticationEntryPoint);
    this.filter.setBearerTokenResolver(this.bearerTokenResolver);
  }
  @Test public void doFilterWhenBearerTokenPresentThenAuthenticates() throws ServletException, IOException {
    when(this.bearerTokenResolver.resolve(this.request)).thenReturn("token");
    this.filter.doFilter(this.request,this.response,this.filterChain);
    ArgumentCaptor<BearerTokenAuthenticationToken> captor=ArgumentCaptor.forClass(BearerTokenAuthenticationToken.class);
    verify(this.authenticationManager).authenticate(captor.capture());
    assertThat(captor.getValue().getPrincipal()).isEqualTo("token");
  }
  @Test public void doFilterWhenNoBearerTokenPresentThenDoesNotAuthenticate() throws ServletException, IOException {
    when(this.bearerTokenResolver.resolve(this.request)).thenReturn(null);
    dontAuthenticate();
  }
  @Test public void doFilterWhenMalformedBearerTokenThenPropagatesError() throws ServletException, IOException {
    BearerTokenError error=new BearerTokenError(BearerTokenErrorCodes.INVALID_REQUEST,HttpStatus.BAD_REQUEST,"description","uri");
    OAuth2AuthenticationException exception=new OAuth2AuthenticationException(error);
    when(this.bearerTokenResolver.resolve(this.request)).thenThrow(exception);
    dontAuthenticate();
    verify(this.authenticationEntryPoint).commence(this.request,this.response,exception);
  }
  @Test public void doFilterWhenAuthenticationFailsThenPropagatesError() throws ServletException, IOException {
    BearerTokenError error=new BearerTokenError(BearerTokenErrorCodes.INVALID_TOKEN,HttpStatus.UNAUTHORIZED,"description","uri");
    OAuth2AuthenticationException exception=new OAuth2AuthenticationException(error);
    when(this.bearerTokenResolver.resolve(this.request)).thenReturn("token");
    when(this.authenticationManager.authenticate(any(BearerTokenAuthenticationToken.class))).thenThrow(exception);
    this.filter.doFilter(this.request,this.response,this.filterChain);
    verify(this.authenticationEntryPoint).commence(this.request,this.response,exception);
  }
  @Test public void setAuthenticationEntryPointWhenNullThenThrowsException(){
    assertThatCode(() -> this.filter.setAuthenticationEntryPoint(null)).isInstanceOf(IllegalArgumentException.class).hasMessageContaining("authenticationEntryPoint cannot be null");
  }
  @Test public void setBearerTokenResolverWhenNullThenThrowsException(){
    assertThatCode(() -> this.filter.setBearerTokenResolver(null)).isInstanceOf(IllegalArgumentException.class).hasMessageContaining("bearerTokenResolver cannot be null");
  }
  @Test public void constructorWhenNullAuthenticationManagerThenThrowsException(){
    assertThatCode(() -> new BearerTokenAuthenticationFilter(null)).isInstanceOf(IllegalArgumentException.class).hasMessageContaining("authenticationManager cannot be null");
  }
  private void dontAuthenticate() throws ServletException, IOException {
    this.filter.doFilter(this.request,this.response,this.filterChain);
    verifyNoMoreInteractions(this.authenticationManager);
  }
}
