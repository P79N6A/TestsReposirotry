/** 
 * @author Rob Winch
 * @since 5.0
 */
@RunWith(MockitoJUnitRunner.class) public class PathMatcherServerWebExchangeMatcherTests {
  @Mock PathPattern pattern;
  @Mock PathPattern.PathMatchInfo pathMatchInfo;
  MockServerWebExchange exchange;
  PathPatternParserServerWebExchangeMatcher matcher;
  String path;
  @Before public void setup(){
    MockServerHttpRequest request=MockServerHttpRequest.post("/path").build();
    MockServerHttpResponse response=new MockServerHttpResponse();
    DefaultWebSessionManager sessionManager=new DefaultWebSessionManager();
    exchange=MockServerWebExchange.from(request);
    path="/path";
    matcher=new PathPatternParserServerWebExchangeMatcher(pattern);
  }
  @Test(expected=IllegalArgumentException.class) public void constructorPatternWhenPatternNullThenThrowsException(){
    new PathPatternParserServerWebExchangeMatcher((PathPattern)null);
  }
  @Test(expected=IllegalArgumentException.class) public void constructorPatternAndMethodWhenPatternNullThenThrowsException(){
    new PathPatternParserServerWebExchangeMatcher((PathPattern)null,HttpMethod.GET);
  }
  @Test public void matchesWhenPathMatcherTrueThenReturnTrue(){
    when(pattern.matches(any())).thenReturn(true);
    when(pattern.matchAndExtract(any())).thenReturn(pathMatchInfo);
    when(pathMatchInfo.getUriVariables()).thenReturn(new HashMap<>());
    assertThat(matcher.matches(exchange).block().isMatch()).isTrue();
  }
  @Test public void matchesWhenPathMatcherFalseThenReturnFalse(){
    when(pattern.matches(any())).thenReturn(false);
    assertThat(matcher.matches(exchange).block().isMatch()).isFalse();
  }
  @Test public void matchesWhenPathMatcherTrueAndMethodTrueThenReturnTrue(){
    matcher=new PathPatternParserServerWebExchangeMatcher(pattern,exchange.getRequest().getMethod());
    when(pattern.matches(any())).thenReturn(true);
    when(pattern.matchAndExtract(any())).thenReturn(pathMatchInfo);
    when(pathMatchInfo.getUriVariables()).thenReturn(new HashMap<>());
    assertThat(matcher.matches(exchange).block().isMatch()).isTrue();
  }
  @Test public void matchesWhenPathMatcherTrueAndMethodFalseThenReturnFalse(){
    HttpMethod method=HttpMethod.OPTIONS;
    assertThat(exchange.getRequest().getMethod()).isNotEqualTo(method);
    matcher=new PathPatternParserServerWebExchangeMatcher(pattern,method);
    assertThat(matcher.matches(exchange).block().isMatch()).isFalse();
    verifyZeroInteractions(pattern);
  }
}
