@RunWith(MockitoJUnitRunner.class) public class SecurityMockMvcConfigurerTests {
  @Mock private Filter filter;
  @Mock private Filter beanFilter;
  @Mock private ConfigurableMockMvcBuilder<?> builder;
  @Mock private WebApplicationContext context;
  @Mock private ServletContext servletContext;
  @Before public void setup(){
    when(this.context.getServletContext()).thenReturn(this.servletContext);
  }
  @Test public void beforeMockMvcCreatedOverrideBean() throws Exception {
    returnFilterBean();
    SecurityMockMvcConfigurer configurer=new SecurityMockMvcConfigurer(this.filter);
    configurer.beforeMockMvcCreated(this.builder,this.context);
    verify(this.builder).addFilters(this.filter);
    verify(this.servletContext).setAttribute(BeanIds.SPRING_SECURITY_FILTER_CHAIN,this.filter);
  }
  @Test public void beforeMockMvcCreatedBean() throws Exception {
    returnFilterBean();
    SecurityMockMvcConfigurer configurer=new SecurityMockMvcConfigurer();
    configurer.beforeMockMvcCreated(this.builder,this.context);
    verify(this.builder).addFilters(this.beanFilter);
  }
  @Test public void beforeMockMvcCreatedNoBean() throws Exception {
    SecurityMockMvcConfigurer configurer=new SecurityMockMvcConfigurer(this.filter);
    configurer.beforeMockMvcCreated(this.builder,this.context);
    verify(this.builder).addFilters(this.filter);
  }
  @Test(expected=IllegalStateException.class) public void beforeMockMvcCreatedNoFilter() throws Exception {
    SecurityMockMvcConfigurer configurer=new SecurityMockMvcConfigurer();
    configurer.beforeMockMvcCreated(this.builder,this.context);
  }
  private void returnFilterBean(){
    when(this.context.containsBean(anyString())).thenReturn(true);
    when(this.context.getBean(anyString(),eq(Filter.class))).thenReturn(this.beanFilter);
  }
}
