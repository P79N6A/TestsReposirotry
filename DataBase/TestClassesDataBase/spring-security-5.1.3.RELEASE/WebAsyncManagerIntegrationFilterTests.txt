/** 
 * @author Rob Winch
 */
@RunWith(MockitoJUnitRunner.class) public class WebAsyncManagerIntegrationFilterTests {
  @Mock private SecurityContext securityContext;
  @Mock private HttpServletRequest request;
  @Mock private HttpServletResponse response;
  @Mock private AsyncWebRequest asyncWebRequest;
  private WebAsyncManager asyncManager;
  private JoinableThreadFactory threadFactory;
  private MockFilterChain filterChain;
  private WebAsyncManagerIntegrationFilter filter;
  @Before public void setUp(){
    filterChain=new MockFilterChain();
    threadFactory=new JoinableThreadFactory();
    SimpleAsyncTaskExecutor executor=new SimpleAsyncTaskExecutor();
    executor.setThreadFactory(threadFactory);
    asyncManager=WebAsyncUtils.getAsyncManager(request);
    asyncManager.setAsyncWebRequest(asyncWebRequest);
    asyncManager.setTaskExecutor(executor);
    when(request.getAttribute(WebAsyncUtils.WEB_ASYNC_MANAGER_ATTRIBUTE)).thenReturn(asyncManager);
    filter=new WebAsyncManagerIntegrationFilter();
  }
  @After public void clearSecurityContext(){
    SecurityContextHolder.clearContext();
  }
  @Test public void doFilterInternalRegistersSecurityContextCallableProcessor() throws Exception {
    SecurityContextHolder.setContext(securityContext);
    asyncManager.registerCallableInterceptors(new CallableProcessingInterceptorAdapter(){
      @Override public <T>void postProcess(      NativeWebRequest request,      Callable<T> task,      Object concurrentResult) throws Exception {
        assertThat(SecurityContextHolder.getContext()).isNotSameAs(securityContext);
      }
    }
);
    filter.doFilterInternal(request,response,filterChain);
    VerifyingCallable verifyingCallable=new VerifyingCallable();
    asyncManager.startCallableProcessing(verifyingCallable);
    threadFactory.join();
    assertThat(asyncManager.getConcurrentResult()).isSameAs(securityContext);
  }
  @Test public void doFilterInternalRegistersSecurityContextCallableProcessorContextUpdated() throws Exception {
    SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());
    asyncManager.registerCallableInterceptors(new CallableProcessingInterceptorAdapter(){
      @Override public <T>void postProcess(      NativeWebRequest request,      Callable<T> task,      Object concurrentResult) throws Exception {
        assertThat(SecurityContextHolder.getContext()).isNotSameAs(securityContext);
      }
    }
);
    filter.doFilterInternal(request,response,filterChain);
    SecurityContextHolder.setContext(securityContext);
    VerifyingCallable verifyingCallable=new VerifyingCallable();
    asyncManager.startCallableProcessing(verifyingCallable);
    threadFactory.join();
    assertThat(asyncManager.getConcurrentResult()).isSameAs(securityContext);
  }
private static final class JoinableThreadFactory implements ThreadFactory {
    private Thread t;
    public Thread newThread(    Runnable r){
      t=new Thread(r);
      return t;
    }
    public void join() throws InterruptedException {
      t.join();
    }
  }
private class VerifyingCallable implements Callable<SecurityContext> {
    public SecurityContext call() throws Exception {
      return SecurityContextHolder.getContext();
    }
  }
}
