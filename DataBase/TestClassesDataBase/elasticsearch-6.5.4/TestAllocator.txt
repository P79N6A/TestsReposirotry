class TestAllocator extends ReplicaShardAllocator {
  private Map<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> data=null;
  private AtomicBoolean fetchDataCalled=new AtomicBoolean(false);
  TestAllocator(){
    super(Settings.EMPTY);
  }
  public void clean(){
    data=null;
  }
  public void cleanWithEmptyData(){
    data=new HashMap<>();
  }
  public boolean getFetchDataCalledAndClean(){
    return fetchDataCalled.getAndSet(false);
  }
  public TestAllocator addData(  DiscoveryNode node,  String syncId,  StoreFileMetaData... files){
    if (data == null) {
      data=new HashMap<>();
    }
    Map<String,StoreFileMetaData> filesAsMap=new HashMap<>();
    for (    StoreFileMetaData file : files) {
      filesAsMap.put(file.name(),file);
    }
    Map<String,String> commitData=new HashMap<>();
    if (syncId != null) {
      commitData.put(Engine.SYNC_COMMIT_ID,syncId);
    }
    data.put(node,new TransportNodesListShardStoreMetaData.StoreFilesMetaData(shardId,new Store.MetadataSnapshot(unmodifiableMap(filesAsMap),unmodifiableMap(commitData),randomInt())));
    return this;
  }
  @Override protected AsyncShardFetch.FetchResult<TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData> fetchData(  ShardRouting shard,  RoutingAllocation allocation){
    fetchDataCalled.set(true);
    Map<DiscoveryNode,TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData> tData=null;
    if (data != null) {
      tData=new HashMap<>();
      for (      Map.Entry<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> entry : data.entrySet()) {
        tData.put(entry.getKey(),new TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData(entry.getKey(),entry.getValue()));
      }
    }
    return new AsyncShardFetch.FetchResult<>(shardId,tData,Collections.emptySet());
  }
  @Override protected boolean hasInitiatedFetching(  ShardRouting shard){
    return fetchDataCalled.get();
  }
}
