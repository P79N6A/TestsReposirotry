/** 
 * Initializes natives and installs test security manager (init'd early by base classes to ensure it happens regardless of which test case happens to be first, test ordering, etc). <p> The idea is to mimic as much as possible what happens with ES in production mode (e.g. assign permissions and install security manager the same way)
 */
public class BootstrapForTesting {
static {
    Path javaTmpDir=PathUtils.get(Objects.requireNonNull(System.getProperty("java.io.tmpdir"),"please set ${java.io.tmpdir} in pom.xml"));
    try {
      Security.ensureDirectoryExists(javaTmpDir);
    }
 catch (    Exception e) {
      throw new RuntimeException("unable to create test temp directory",e);
    }
    final boolean systemCallFilter=Booleans.parseBoolean(System.getProperty("tests.system_call_filter","true"));
    Bootstrap.initializeNatives(javaTmpDir,true,systemCallFilter,true);
    Bootstrap.initializeProbes();
    BootstrapInfo.getSystemProperties();
    try {
      final Logger logger=LogManager.getLogger(JarHell.class);
      JarHell.checkJarHell(logger::debug);
    }
 catch (    Exception e) {
      throw new RuntimeException("found jar hell in test classpath",e);
    }
    IfConfig.logIfNecessary();
    if (systemPropertyAsBoolean("tests.security.manager",true)) {
      try {
        Permissions perms=new Permissions();
        Security.addClasspathPermissions(perms);
        FilePermissionUtils.addDirectoryPath(perms,"java.io.tmpdir",javaTmpDir,"read,readlink,write,delete");
        if (Strings.hasLength(System.getProperty("tests.config"))) {
          FilePermissionUtils.addSingleFilePath(perms,PathUtils.get(System.getProperty("tests.config")),"read,readlink");
        }
        final boolean testsCoverage=Booleans.parseBoolean(System.getProperty("tests.coverage","false"));
        if (testsCoverage) {
          Path coverageDir=PathUtils.get(System.getProperty("tests.coverage.dir"));
          FilePermissionUtils.addSingleFilePath(perms,coverageDir.resolve("jacoco.exec"),"read,write");
          FilePermissionUtils.addSingleFilePath(perms,coverageDir.resolve("jacoco-it.exec"),"read,write");
        }
        if (System.getProperty("tests.gradle") == null) {
          perms.add(new RuntimePermission("setIO"));
        }
        perms.add(new SocketPermission("localhost:0","listen,resolve"));
        perms.add(new SocketPermission("localhost:1024-","listen,resolve"));
        Map<String,URL> codebases=Security.getCodebaseJarMap(JarHell.parseClassPath());
        if (System.getProperty("tests.gradle") == null) {
          addClassCodebase(codebases,"plugin-classloader","org.elasticsearch.plugins.ExtendedPluginsClassLoader");
          addClassCodebase(codebases,"elasticsearch-secure-sm","org.elasticsearch.secure_sm.SecureSM");
        }
        final Policy testFramework=Security.readPolicy(Bootstrap.class.getResource("test-framework.policy"),codebases);
        final Policy esPolicy=new ESPolicy(codebases,perms,getPluginPermissions(),true);
        Policy.setPolicy(new Policy(){
          @Override public boolean implies(          ProtectionDomain domain,          Permission permission){
            return esPolicy.implies(domain,permission) || testFramework.implies(domain,permission);
          }
        }
);
        System.setSecurityManager(SecureSM.createTestSecureSM());
        Security.selfTest();
        for (        URL url : Collections.list(BootstrapForTesting.class.getClassLoader().getResources(PluginInfo.ES_PLUGIN_PROPERTIES))) {
          Properties properties=new Properties();
          try (InputStream stream=FileSystemUtils.openFileURLStream(url)){
            properties.load(stream);
          }
           String clazz=properties.getProperty("classname");
          if (clazz != null) {
            Class.forName(clazz);
          }
        }
      }
 catch (      Exception e) {
        throw new RuntimeException("unable to install test security manager",e);
      }
    }
  }
  /** 
 * Add the codebase url of the given classname to the codebases map, if the class exists. 
 */
  private static void addClassCodebase(  Map<String,URL> codebases,  String name,  String classname){
    try {
      Class<?> clazz=BootstrapForTesting.class.getClassLoader().loadClass(classname);
      URL location=clazz.getProtectionDomain().getCodeSource().getLocation();
      if (location.toString().endsWith(".jar") == false) {
        if (codebases.put(name,location) != null) {
          throw new IllegalStateException("Already added " + name + " codebase for testing");
        }
      }
    }
 catch (    ClassNotFoundException e) {
    }
  }
  /** 
 * we don't know which codesources belong to which plugin, so just remove the permission from key codebases like core, test-framework, etc. this way tests fail if accesscontroller blocks are missing.
 */
  @SuppressForbidden(reason="accesses fully qualified URLs to configure security") static Map<String,Policy> getPluginPermissions() throws Exception {
    List<URL> pluginPolicies=Collections.list(BootstrapForTesting.class.getClassLoader().getResources(PluginInfo.ES_PLUGIN_POLICY));
    if (pluginPolicies.isEmpty()) {
      return Collections.emptyMap();
    }
    Set<URL> codebases=new HashSet<>(parseClassPathWithSymlinks());
    Set<URL> excluded=new HashSet<>(Arrays.asList(Bootstrap.class.getProtectionDomain().getCodeSource().getLocation(),BootstrapForTesting.class.getProtectionDomain().getCodeSource().getLocation(),LuceneTestCase.class.getProtectionDomain().getCodeSource().getLocation(),RandomizedRunner.class.getProtectionDomain().getCodeSource().getLocation(),Assert.class.getProtectionDomain().getCodeSource().getLocation()));
    codebases.removeAll(excluded);
    final List<Policy> policies=new ArrayList<>(pluginPolicies.size());
    for (    URL policyFile : pluginPolicies) {
      policies.add(Security.readPolicy(policyFile,Security.getCodebaseJarMap(codebases)));
    }
    Map<String,Policy> map=new HashMap<>();
    for (    URL url : codebases) {
      map.put(url.getFile(),new Policy(){
        @Override public boolean implies(        ProtectionDomain domain,        Permission permission){
          for (          Policy p : policies) {
            if (p.implies(domain,permission)) {
              return true;
            }
          }
          return false;
        }
      }
);
    }
    return Collections.unmodifiableMap(map);
  }
  /** 
 * return parsed classpath, but with symlinks resolved to destination files for matching this is for matching the toRealPath() in the code where we have a proper plugin structure
 */
  @SuppressForbidden(reason="does evil stuff with paths and urls because devs and jenkins do evil stuff with paths and urls") static Set<URL> parseClassPathWithSymlinks() throws Exception {
    Set<URL> raw=JarHell.parseClassPath();
    Set<URL> cooked=new HashSet<>(raw.size());
    for (    URL url : raw) {
      boolean added=cooked.add(PathUtils.get(url.toURI()).toRealPath().toUri().toURL());
      if (added == false) {
        throw new IllegalStateException("Duplicate in classpath after resolving symlinks: " + url);
      }
    }
    return raw;
  }
  public static void ensureInitialized(){
  }
}
