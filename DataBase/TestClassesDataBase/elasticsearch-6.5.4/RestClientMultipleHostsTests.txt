/** 
 * Tests for  {@link RestClient} behaviour against multiple hosts: fail-over, blacklisting etc.Relies on a mock http client to intercept requests and return desired responses based on request path.
 */
public class RestClientMultipleHostsTests extends RestClientTestCase {
  private ExecutorService exec=Executors.newFixedThreadPool(1);
  private List<Node> nodes;
  private HostsTrackingFailureListener failureListener;
  @SuppressWarnings("unchecked") public RestClient createRestClient(  NodeSelector nodeSelector){
    CloseableHttpAsyncClient httpClient=mock(CloseableHttpAsyncClient.class);
    when(httpClient.<HttpResponse>execute(any(HttpAsyncRequestProducer.class),any(HttpAsyncResponseConsumer.class),any(HttpClientContext.class),any(FutureCallback.class))).thenAnswer(new Answer<Future<HttpResponse>>(){
      @Override public Future<HttpResponse> answer(      InvocationOnMock invocationOnMock) throws Throwable {
        HttpAsyncRequestProducer requestProducer=(HttpAsyncRequestProducer)invocationOnMock.getArguments()[0];
        final HttpUriRequest request=(HttpUriRequest)requestProducer.generateRequest();
        final HttpHost httpHost=requestProducer.getTarget();
        HttpClientContext context=(HttpClientContext)invocationOnMock.getArguments()[2];
        assertThat(context.getAuthCache().get(httpHost),instanceOf(BasicScheme.class));
        final FutureCallback<HttpResponse> futureCallback=(FutureCallback<HttpResponse>)invocationOnMock.getArguments()[3];
        exec.execute(new Runnable(){
          @Override public void run(){
            if (request.getURI().getPath().equals("/soe")) {
              futureCallback.failed(new SocketTimeoutException(httpHost.toString()));
            }
 else             if (request.getURI().getPath().equals("/coe")) {
              futureCallback.failed(new ConnectTimeoutException(httpHost.toString()));
            }
 else             if (request.getURI().getPath().equals("/ioe")) {
              futureCallback.failed(new IOException(httpHost.toString()));
            }
 else {
              int statusCode=Integer.parseInt(request.getURI().getPath().substring(1));
              StatusLine statusLine=new BasicStatusLine(new ProtocolVersion("http",1,1),statusCode,"");
              futureCallback.completed(new BasicHttpResponse(statusLine));
            }
          }
        }
);
        return null;
      }
    }
);
    int numNodes=RandomNumbers.randomIntBetween(getRandom(),2,5);
    nodes=new ArrayList<>(numNodes);
    for (int i=0; i < numNodes; i++) {
      nodes.add(new Node(new HttpHost("localhost",9200 + i)));
    }
    nodes=Collections.unmodifiableList(nodes);
    failureListener=new HostsTrackingFailureListener();
    return new RestClient(httpClient,10000,new Header[0],nodes,null,failureListener,nodeSelector,false);
  }
  /** 
 * Shutdown the executor so we don't leak threads into other test runs.
 */
  @After public void shutdownExec(){
    exec.shutdown();
  }
  public void testRoundRobinOkStatusCodes() throws IOException {
    RestClient restClient=createRestClient(NodeSelector.ANY);
    int numIters=RandomNumbers.randomIntBetween(getRandom(),1,5);
    for (int i=0; i < numIters; i++) {
      Set<HttpHost> hostsSet=hostsSet();
      for (int j=0; j < nodes.size(); j++) {
        int statusCode=randomOkStatusCode(getRandom());
        Response response=restClient.performRequest(new Request(randomHttpMethod(getRandom()),"/" + statusCode));
        assertEquals(statusCode,response.getStatusLine().getStatusCode());
        assertTrue("host not found: " + response.getHost(),hostsSet.remove(response.getHost()));
      }
      assertEquals("every host should have been used but some weren't: " + hostsSet,0,hostsSet.size());
    }
    failureListener.assertNotCalled();
  }
  public void testRoundRobinNoRetryErrors() throws IOException {
    RestClient restClient=createRestClient(NodeSelector.ANY);
    int numIters=RandomNumbers.randomIntBetween(getRandom(),1,5);
    for (int i=0; i < numIters; i++) {
      Set<HttpHost> hostsSet=hostsSet();
      for (int j=0; j < nodes.size(); j++) {
        String method=randomHttpMethod(getRandom());
        int statusCode=randomErrorNoRetryStatusCode(getRandom());
        try {
          Response response=restClient.performRequest(new Request(method,"/" + statusCode));
          if (method.equals("HEAD") && statusCode == 404) {
            assertEquals(404,response.getStatusLine().getStatusCode());
            assertEquals(statusCode,response.getStatusLine().getStatusCode());
            assertTrue("host not found: " + response.getHost(),hostsSet.remove(response.getHost()));
          }
 else {
            fail("request should have failed");
          }
        }
 catch (        ResponseException e) {
          if (method.equals("HEAD") && statusCode == 404) {
            throw e;
          }
          Response response=e.getResponse();
          assertEquals(statusCode,response.getStatusLine().getStatusCode());
          assertTrue("host not found: " + response.getHost(),hostsSet.remove(response.getHost()));
          assertEquals(0,e.getSuppressed().length);
        }
      }
      assertEquals("every host should have been used but some weren't: " + hostsSet,0,hostsSet.size());
    }
    failureListener.assertNotCalled();
  }
  public void testRoundRobinRetryErrors() throws IOException {
    RestClient restClient=createRestClient(NodeSelector.ANY);
    String retryEndpoint=randomErrorRetryEndpoint();
    try {
      restClient.performRequest(new Request(randomHttpMethod(getRandom()),retryEndpoint));
      fail("request should have failed");
    }
 catch (    ResponseException e) {
      e=(ResponseException)e.getCause();
      Set<HttpHost> hostsSet=hostsSet();
      failureListener.assertCalled(nodes);
      do {
        Response response=e.getResponse();
        assertEquals(Integer.parseInt(retryEndpoint.substring(1)),response.getStatusLine().getStatusCode());
        assertTrue("host [" + response.getHost() + "] not found, most likely used multiple times",hostsSet.remove(response.getHost()));
        if (e.getSuppressed().length > 0) {
          assertEquals(1,e.getSuppressed().length);
          Throwable suppressed=e.getSuppressed()[0];
          assertThat(suppressed,instanceOf(ResponseException.class));
          e=(ResponseException)suppressed;
        }
 else {
          e=null;
        }
      }
 while (e != null);
      assertEquals("every host should have been used but some weren't: " + hostsSet,0,hostsSet.size());
    }
catch (    IOException e) {
      e=(IOException)e.getCause();
      Set<HttpHost> hostsSet=hostsSet();
      failureListener.assertCalled(nodes);
      do {
        HttpHost httpHost=HttpHost.create(e.getMessage());
        assertTrue("host [" + httpHost + "] not found, most likely used multiple times",hostsSet.remove(httpHost));
        if (e.getSuppressed().length > 0) {
          assertEquals(1,e.getSuppressed().length);
          Throwable suppressed=e.getSuppressed()[0];
          assertThat(suppressed,instanceOf(IOException.class));
          e=(IOException)suppressed;
        }
 else {
          e=null;
        }
      }
 while (e != null);
      assertEquals("every host should have been used but some weren't: " + hostsSet,0,hostsSet.size());
    }
    int numIters=RandomNumbers.randomIntBetween(getRandom(),2,5);
    for (int i=1; i <= numIters; i++) {
      Set<HttpHost> hostsSet=hostsSet();
      for (int j=0; j < nodes.size(); j++) {
        retryEndpoint=randomErrorRetryEndpoint();
        try {
          restClient.performRequest(new Request(randomHttpMethod(getRandom()),retryEndpoint));
          fail("request should have failed");
        }
 catch (        ResponseException e) {
          Response response=e.getResponse();
          assertThat(response.getStatusLine().getStatusCode(),equalTo(Integer.parseInt(retryEndpoint.substring(1))));
          assertTrue("host [" + response.getHost() + "] not found, most likely used multiple times",hostsSet.remove(response.getHost()));
          failureListener.assertCalled(response.getHost());
          assertEquals(0,e.getSuppressed().length);
        }
catch (        IOException e) {
          e=(IOException)e.getCause();
          HttpHost httpHost=HttpHost.create(e.getMessage());
          assertTrue("host [" + httpHost + "] not found, most likely used multiple times",hostsSet.remove(httpHost));
          failureListener.assertCalled(httpHost);
          assertEquals(0,e.getSuppressed().length);
        }
      }
      assertEquals("every host should have been used but some weren't: " + hostsSet,0,hostsSet.size());
      if (getRandom().nextBoolean()) {
        HttpHost selectedHost=null;
        int iters=RandomNumbers.randomIntBetween(getRandom(),2,10);
        for (int y=0; y < iters; y++) {
          int statusCode=randomErrorNoRetryStatusCode(getRandom());
          Response response;
          try {
            response=restClient.performRequest(new Request(randomHttpMethod(getRandom()),"/" + statusCode));
          }
 catch (          ResponseException e) {
            response=e.getResponse();
          }
          assertThat(response.getStatusLine().getStatusCode(),equalTo(statusCode));
          if (selectedHost == null) {
            selectedHost=response.getHost();
          }
 else {
            assertThat(response.getHost(),equalTo(selectedHost));
          }
        }
        failureListener.assertNotCalled();
        for (int y=0; y < i + 1; y++) {
          retryEndpoint=randomErrorRetryEndpoint();
          try {
            restClient.performRequest(new Request(randomHttpMethod(getRandom()),retryEndpoint));
            fail("request should have failed");
          }
 catch (          ResponseException e) {
            Response response=e.getResponse();
            assertThat(response.getStatusLine().getStatusCode(),equalTo(Integer.parseInt(retryEndpoint.substring(1))));
            assertThat(response.getHost(),equalTo(selectedHost));
            failureListener.assertCalled(selectedHost);
          }
catch (          IOException e) {
            e=(IOException)e.getCause();
            HttpHost httpHost=HttpHost.create(e.getMessage());
            assertThat(httpHost,equalTo(selectedHost));
            failureListener.assertCalled(selectedHost);
          }
        }
      }
    }
  }
  public void testNodeSelector() throws IOException {
    NodeSelector firstPositionOnly=new NodeSelector(){
      @Override public void select(      Iterable<Node> restClientNodes){
        boolean found=false;
        for (Iterator<Node> itr=restClientNodes.iterator(); itr.hasNext(); ) {
          if (nodes.get(0) == itr.next()) {
            found=true;
          }
 else {
            itr.remove();
          }
        }
        assertTrue(found);
      }
    }
;
    RestClient restClient=createRestClient(firstPositionOnly);
    int rounds=between(1,10);
    for (int i=0; i < rounds; i++) {
      Request request=new Request("GET","/200");
      Response response=restClient.performRequest(request);
      assertEquals(nodes.get(0).getHost(),response.getHost());
    }
  }
  public void testSetNodes() throws IOException {
    RestClient restClient=createRestClient(NodeSelector.SKIP_DEDICATED_MASTERS);
    List<Node> newNodes=new ArrayList<>(nodes.size());
    for (int i=0; i < nodes.size(); i++) {
      Node.Roles roles=i == 0 ? new Node.Roles(false,true,true) : new Node.Roles(true,false,false);
      newNodes.add(new Node(nodes.get(i).getHost(),null,null,null,roles,null));
    }
    restClient.setNodes(newNodes);
    int rounds=between(1,10);
    for (int i=0; i < rounds; i++) {
      Request request=new Request("GET","/200");
      Response response=restClient.performRequest(request);
      assertEquals(newNodes.get(0).getHost(),response.getHost());
    }
  }
  private static String randomErrorRetryEndpoint(){
switch (RandomNumbers.randomIntBetween(getRandom(),0,3)) {
case 0:
      return "/" + randomErrorRetryStatusCode(getRandom());
case 1:
    return "/coe";
case 2:
  return "/soe";
case 3:
return "/ioe";
}
throw new UnsupportedOperationException();
}
/** 
 * Build a mutable  {@link Set} containing all the {@link Node#getHost() hosts}in use by the test.
 */
private Set<HttpHost> hostsSet(){
Set<HttpHost> hosts=new HashSet<>();
for (Node node : nodes) {
hosts.add(node.getHost());
}
return hosts;
}
}
