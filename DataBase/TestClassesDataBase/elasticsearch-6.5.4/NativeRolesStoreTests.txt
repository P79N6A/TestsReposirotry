public class NativeRolesStoreTests extends ESTestCase {
  private ThreadPool threadPool;
  @Before public void createThreadPool(){
    threadPool=new TestThreadPool("index audit trail update mapping tests");
  }
  @After public void terminateThreadPool() throws Exception {
    terminate(threadPool);
  }
  public void testBWCFieldPermissions() throws IOException {
    Path path=getDataPath("roles2xformat.json");
    byte[] bytes=Files.readAllBytes(path);
    String roleString=new String(bytes,Charset.defaultCharset());
    RoleDescriptor role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "role1",new BytesArray(roleString),logger,new XPackLicenseState(Settings.EMPTY));
    assertNotNull(role);
    assertNotNull(role.getIndicesPrivileges());
    RoleDescriptor.IndicesPrivileges indicesPrivileges=role.getIndicesPrivileges()[0];
    assertThat(indicesPrivileges.getGrantedFields(),arrayContaining("foo","boo"));
    assertNull(indicesPrivileges.getDeniedFields());
  }
  public void testRoleDescriptorWithFlsDlsLicensing() throws IOException {
    XPackLicenseState licenseState=mock(XPackLicenseState.class);
    when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(false);
    RoleDescriptor flsRole=new RoleDescriptor("fls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().privileges("READ").indices("*").grantedFields("*").deniedFields("foo").build()},null);
    assertFalse(flsRole.getTransientMetadata().containsKey("unlicensed_features"));
    BytesReference matchAllBytes=XContentHelper.toXContent(QueryBuilders.matchAllQuery(),XContentType.JSON,false);
    RoleDescriptor dlsRole=new RoleDescriptor("dls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().indices("*").privileges("READ").query(matchAllBytes).build()},null);
    assertFalse(dlsRole.getTransientMetadata().containsKey("unlicensed_features"));
    RoleDescriptor flsDlsRole=new RoleDescriptor("fls_ dls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().indices("*").privileges("READ").grantedFields("*").deniedFields("foo").query(matchAllBytes).build()},null);
    assertFalse(flsDlsRole.getTransientMetadata().containsKey("unlicensed_features"));
    RoleDescriptor noFlsDlsRole=new RoleDescriptor("no_fls_dls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().indices("*").privileges("READ").build()},null);
    assertFalse(noFlsDlsRole.getTransientMetadata().containsKey("unlicensed_features"));
    XContentBuilder builder=flsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    BytesReference bytes=BytesReference.bytes(builder);
    RoleDescriptor role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "-fls",bytes,logger,licenseState);
    assertNotNull(role);
    assertTrue(role.getTransientMetadata().containsKey("unlicensed_features"));
    assertThat(role.getTransientMetadata().get("unlicensed_features"),instanceOf(List.class));
    assertThat((List<String>)role.getTransientMetadata().get("unlicensed_features"),contains("fls"));
    builder=dlsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    bytes=BytesReference.bytes(builder);
    role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "dls",bytes,logger,licenseState);
    assertNotNull(role);
    assertTrue(role.getTransientMetadata().containsKey("unlicensed_features"));
    assertThat(role.getTransientMetadata().get("unlicensed_features"),instanceOf(List.class));
    assertThat((List<String>)role.getTransientMetadata().get("unlicensed_features"),contains("dls"));
    builder=flsDlsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    bytes=BytesReference.bytes(builder);
    role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "fls_dls",bytes,logger,licenseState);
    assertNotNull(role);
    assertTrue(role.getTransientMetadata().containsKey("unlicensed_features"));
    assertThat(role.getTransientMetadata().get("unlicensed_features"),instanceOf(List.class));
    assertThat((List<String>)role.getTransientMetadata().get("unlicensed_features"),contains("fls","dls"));
    builder=noFlsDlsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    bytes=BytesReference.bytes(builder);
    role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "no_fls_dls",bytes,logger,licenseState);
    assertNotNull(role);
    assertFalse(role.getTransientMetadata().containsKey("unlicensed_features"));
    when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(true);
    builder=flsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    bytes=BytesReference.bytes(builder);
    role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "fls",bytes,logger,licenseState);
    assertNotNull(role);
    assertFalse(role.getTransientMetadata().containsKey("unlicensed_features"));
    builder=dlsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    bytes=BytesReference.bytes(builder);
    role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "dls",bytes,logger,licenseState);
    assertNotNull(role);
    assertFalse(role.getTransientMetadata().containsKey("unlicensed_features"));
    builder=flsDlsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    bytes=BytesReference.bytes(builder);
    role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "fls_dls",bytes,logger,licenseState);
    assertNotNull(role);
    assertFalse(role.getTransientMetadata().containsKey("unlicensed_features"));
    builder=noFlsDlsRole.toXContent(XContentBuilder.builder(XContentType.JSON.xContent()),ToXContent.EMPTY_PARAMS);
    bytes=BytesReference.bytes(builder);
    role=NativeRolesStore.transformRole(RoleDescriptor.ROLE_TYPE + "no_fls_dls",bytes,logger,licenseState);
    assertNotNull(role);
    assertFalse(role.getTransientMetadata().containsKey("unlicensed_features"));
  }
  public void testPutOfRoleWithFlsDlsUnlicensed() throws IOException {
    final Client client=mock(Client.class);
    final ClusterService clusterService=mock(ClusterService.class);
    final XPackLicenseState licenseState=mock(XPackLicenseState.class);
    final AtomicBoolean methodCalled=new AtomicBoolean(false);
    final SecurityIndexManager securityIndex=new SecurityIndexManager(client,SecurityIndexManager.SECURITY_INDEX_NAME,clusterService);
    final NativeRolesStore rolesStore=new NativeRolesStore(Settings.EMPTY,client,licenseState,securityIndex){
      @Override void innerPutRole(      final PutRoleRequest request,      final RoleDescriptor role,      final ActionListener<Boolean> listener){
        if (methodCalled.compareAndSet(false,true)) {
          listener.onResponse(true);
        }
 else {
          fail("method called more than once!");
        }
      }
    }
;
    securityIndex.clusterChanged(new ClusterChangedEvent("fls_dls_license",getClusterStateWithSecurityIndex(),getEmptyClusterState()));
    PutRoleRequest putRoleRequest=new PutRoleRequest();
    RoleDescriptor flsRole=new RoleDescriptor("fls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().privileges("READ").indices("*").grantedFields("*").deniedFields("foo").build()},null);
    PlainActionFuture<Boolean> future=new PlainActionFuture<>();
    rolesStore.putRole(putRoleRequest,flsRole,future);
    ElasticsearchSecurityException e=expectThrows(ElasticsearchSecurityException.class,future::actionGet);
    assertThat(e.getMessage(),containsString("field and document level security"));
    BytesReference matchAllBytes=XContentHelper.toXContent(QueryBuilders.matchAllQuery(),XContentType.JSON,false);
    RoleDescriptor dlsRole=new RoleDescriptor("dls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().indices("*").privileges("READ").query(matchAllBytes).build()},null);
    future=new PlainActionFuture<>();
    rolesStore.putRole(putRoleRequest,dlsRole,future);
    e=expectThrows(ElasticsearchSecurityException.class,future::actionGet);
    assertThat(e.getMessage(),containsString("field and document level security"));
    RoleDescriptor flsDlsRole=new RoleDescriptor("fls_ dls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().indices("*").privileges("READ").grantedFields("*").deniedFields("foo").query(matchAllBytes).build()},null);
    future=new PlainActionFuture<>();
    rolesStore.putRole(putRoleRequest,flsDlsRole,future);
    e=expectThrows(ElasticsearchSecurityException.class,future::actionGet);
    assertThat(e.getMessage(),containsString("field and document level security"));
    RoleDescriptor noFlsDlsRole=new RoleDescriptor("no_fls_dls",null,new IndicesPrivileges[]{IndicesPrivileges.builder().indices("*").privileges("READ").build()},null);
    future=new PlainActionFuture<>();
    rolesStore.putRole(putRoleRequest,noFlsDlsRole,future);
    assertTrue(future.actionGet());
  }
  private ClusterState getClusterStateWithSecurityIndex(){
    final boolean withAlias=randomBoolean();
    final String securityIndexName=SECURITY_INDEX_NAME + (withAlias ? "-" + randomAlphaOfLength(5) : "");
    Settings settings=Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED,Version.CURRENT).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,0).build();
    MetaData metaData=MetaData.builder().put(IndexMetaData.builder(securityIndexName).settings(settings)).put(new IndexTemplateMetaData(SecurityIndexManager.SECURITY_TEMPLATE_NAME,0,0,Collections.singletonList(securityIndexName),Settings.EMPTY,ImmutableOpenMap.of(),ImmutableOpenMap.of())).build();
    if (withAlias) {
      metaData=SecurityTestUtils.addAliasToMetaData(metaData,securityIndexName);
    }
    Index index=new Index(securityIndexName,UUID.randomUUID().toString());
    ShardRouting shardRouting=ShardRouting.newUnassigned(new ShardId(index,0),true,RecoverySource.ExistingStoreRecoverySource.INSTANCE,new UnassignedInfo(Reason.INDEX_CREATED,""));
    IndexShardRoutingTable table=new IndexShardRoutingTable.Builder(new ShardId(index,0)).addShard(shardRouting.initialize(randomAlphaOfLength(8),null,shardRouting.getExpectedShardSize()).moveToStarted()).build();
    RoutingTable routingTable=RoutingTable.builder().add(IndexRoutingTable.builder(index).addIndexShard(table).build()).build();
    ClusterState clusterState=ClusterState.builder(new ClusterName(NativeRolesStoreTests.class.getName())).metaData(metaData).routingTable(routingTable).build();
    return clusterState;
  }
  private ClusterState getEmptyClusterState(){
    return ClusterState.builder(new ClusterName(NativeRolesStoreTests.class.getName())).build();
  }
}
