public class DateHistogramTests extends BaseAggregationTestCase<DateHistogramAggregationBuilder> {
  @Override protected DateHistogramAggregationBuilder createTestAggregatorBuilder(){
    DateHistogramAggregationBuilder factory=new DateHistogramAggregationBuilder(randomAlphaOfLengthBetween(3,10));
    factory.field(INT_FIELD_NAME);
    if (randomBoolean()) {
      factory.interval(randomIntBetween(1,100000));
    }
 else {
      if (randomBoolean()) {
        factory.dateHistogramInterval(randomFrom(DateHistogramInterval.YEAR,DateHistogramInterval.QUARTER,DateHistogramInterval.MONTH,DateHistogramInterval.WEEK,DateHistogramInterval.DAY,DateHistogramInterval.HOUR,DateHistogramInterval.MINUTE,DateHistogramInterval.SECOND));
      }
 else {
        int branch=randomInt(4);
switch (branch) {
case 0:
          factory.dateHistogramInterval(DateHistogramInterval.seconds(randomIntBetween(1,1000)));
        break;
case 1:
      factory.dateHistogramInterval(DateHistogramInterval.minutes(randomIntBetween(1,1000)));
    break;
case 2:
  factory.dateHistogramInterval(DateHistogramInterval.hours(randomIntBetween(1,1000)));
break;
case 3:
factory.dateHistogramInterval(DateHistogramInterval.days(randomIntBetween(1,1000)));
break;
case 4:
factory.dateHistogramInterval(DateHistogramInterval.weeks(randomIntBetween(1,1000)));
break;
default :
throw new IllegalStateException("invalid branch: " + branch);
}
}
}
if (randomBoolean()) {
factory.extendedBounds(ExtendedBoundsTests.randomExtendedBounds());
}
if (randomBoolean()) {
factory.format("###.##");
}
if (randomBoolean()) {
factory.keyed(randomBoolean());
}
if (randomBoolean()) {
factory.minDocCount(randomIntBetween(0,100));
}
if (randomBoolean()) {
factory.missing(randomIntBetween(0,10));
}
if (randomBoolean()) {
factory.offset(randomIntBetween(0,100000));
}
if (randomBoolean()) {
List<BucketOrder> order=randomOrder();
if (order.size() == 1 && randomBoolean()) {
factory.order(order.get(0));
}
 else {
factory.order(order);
}
}
return factory;
}
private List<BucketOrder> randomOrder(){
List<BucketOrder> orders=new ArrayList<>();
switch (randomInt(4)) {
case 0:
orders.add(BucketOrder.key(randomBoolean()));
break;
case 1:
orders.add(BucketOrder.count(randomBoolean()));
break;
case 2:
orders.add(BucketOrder.aggregation(randomAlphaOfLengthBetween(3,20),randomBoolean()));
break;
case 3:
orders.add(BucketOrder.aggregation(randomAlphaOfLengthBetween(3,20),randomAlphaOfLengthBetween(3,20),randomBoolean()));
break;
case 4:
int numOrders=randomIntBetween(1,3);
for (int i=0; i < numOrders; i++) {
orders.addAll(randomOrder());
}
break;
default :
fail();
}
return orders;
}
private static Document documentForDate(String field,long millis){
Document doc=new Document();
doc.add(new LongPoint(field,millis));
doc.add(new SortedNumericDocValuesField(field,millis));
return doc;
}
public void testRewriteTimeZone() throws IOException {
Assume.assumeTrue(getCurrentTypes().length > 0);
DateFormatter format=DateFormatters.forPattern("strict_date_optional_time");
try (Directory dir=newDirectory();IndexWriter w=new IndexWriter(dir,newIndexWriterConfig())){
long millis1=DateFormatters.toZonedDateTime(format.parse("2018-03-11T11:55:00")).toInstant().toEpochMilli();
w.addDocument(documentForDate(DATE_FIELD_NAME,millis1));
long millis2=DateFormatters.toZonedDateTime(format.parse("2017-10-30T18:13:00")).toInstant().toEpochMilli();
w.addDocument(documentForDate(DATE_FIELD_NAME,millis2));
try (IndexReader readerThatDoesntCross=DirectoryReader.open(w)){
long millis3=DateFormatters.toZonedDateTime(format.parse("2018-03-25T02:44:00")).toInstant().toEpochMilli();
w.addDocument(documentForDate(DATE_FIELD_NAME,millis3));
try (IndexReader readerThatCrosses=DirectoryReader.open(w)){
QueryShardContext shardContextThatDoesntCross=createShardContext(readerThatDoesntCross);
QueryShardContext shardContextThatCrosses=createShardContext(readerThatCrosses);
DateHistogramAggregationBuilder builder=new DateHistogramAggregationBuilder("my_date_histo");
builder.field(DATE_FIELD_NAME);
builder.dateHistogramInterval(DateHistogramInterval.DAY);
assertNull(builder.rewriteTimeZone(shardContextThatDoesntCross));
assertNull(builder.rewriteTimeZone(shardContextThatCrosses));
DateTimeZone tz=DateTimeZone.forOffsetHours(1);
builder.timeZone(tz);
assertSame(tz,builder.rewriteTimeZone(shardContextThatDoesntCross));
assertSame(tz,builder.rewriteTimeZone(shardContextThatCrosses));
tz=DateTimeZone.forID("Europe/Paris");
builder.timeZone(tz);
assertEquals(DateTimeZone.forOffsetHours(1),builder.rewriteTimeZone(shardContextThatDoesntCross));
assertSame(tz,builder.rewriteTimeZone(shardContextThatCrosses));
builder.dateHistogramInterval(DateHistogramInterval.MONTH);
assertSame(tz,builder.rewriteTimeZone(shardContextThatDoesntCross));
assertSame(tz,builder.rewriteTimeZone(shardContextThatCrosses));
builder=new DateHistogramAggregationBuilder("my_date_histo");
builder.field(DATE_FIELD_NAME);
builder.timeZone(tz);
builder.interval(1000L * 60 * 60* 24);
assertEquals(DateTimeZone.forOffsetHours(1),builder.rewriteTimeZone(shardContextThatDoesntCross));
assertSame(tz,builder.rewriteTimeZone(shardContextThatCrosses));
builder.interval(1000L * 60 * 60* 24* 30);
assertSame(tz,builder.rewriteTimeZone(shardContextThatDoesntCross));
assertSame(tz,builder.rewriteTimeZone(shardContextThatCrosses));
}
 }
 }
 }
}
