public class LicensesManagerServiceTests extends ESSingleNodeTestCase {
  @Override protected Collection<Class<? extends Plugin>> getPlugins(){
    return Collections.singletonList(LocalStateCompositeXPackPlugin.class);
  }
  @Override protected Settings nodeSettings(){
    return Settings.builder().put(super.nodeSettings()).put(XPackSettings.SECURITY_ENABLED.getKey(),false).put(XPackSettings.MONITORING_ENABLED.getKey(),false).put(XPackSettings.WATCHER_ENABLED.getKey(),false).put(XPackSettings.GRAPH_ENABLED.getKey(),false).put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(),false).build();
  }
  @Override protected boolean resetNodeAfterTest(){
    return true;
  }
  @Before public void waitForTrialLicenseToBeGenerated() throws Exception {
    assertBusy(() -> assertNotNull(getInstanceFromNode(ClusterService.class).state().metaData().custom(LicensesMetaData.TYPE)));
  }
  public void testStoreAndGetLicenses() throws Exception {
    LicenseService licenseService=getInstanceFromNode(LicenseService.class);
    ClusterService clusterService=getInstanceFromNode(ClusterService.class);
    License goldLicense=TestUtils.generateSignedLicense("gold",TimeValue.timeValueHours(1));
    TestUtils.registerAndAckSignedLicenses(licenseService,goldLicense,LicensesStatus.VALID);
    License silverLicense=TestUtils.generateSignedLicense("silver",TimeValue.timeValueHours(2));
    TestUtils.registerAndAckSignedLicenses(licenseService,silverLicense,LicensesStatus.VALID);
    License platinumLicense=TestUtils.generateSignedLicense("platinum",TimeValue.timeValueHours(1));
    TestUtils.registerAndAckSignedLicenses(licenseService,platinumLicense,LicensesStatus.VALID);
    LicensesMetaData licensesMetaData=clusterService.state().metaData().custom(LicensesMetaData.TYPE);
    assertThat(licensesMetaData.getLicense(),equalTo(platinumLicense));
    final License getLicenses=licenseService.getLicense();
    assertThat(getLicenses,equalTo(platinumLicense));
  }
  public void testEffectiveLicenses() throws Exception {
    final LicenseService licenseService=getInstanceFromNode(LicenseService.class);
    final ClusterService clusterService=getInstanceFromNode(ClusterService.class);
    License goldLicense=TestUtils.generateSignedLicense("gold",TimeValue.timeValueSeconds(5));
    TestUtils.registerAndAckSignedLicenses(licenseService,goldLicense,LicensesStatus.VALID);
    LicensesMetaData licensesMetaData=clusterService.state().metaData().custom(LicensesMetaData.TYPE);
    assertThat(LicenseService.getLicense(licensesMetaData),equalTo(goldLicense));
    License platinumLicense=TestUtils.generateSignedLicense("platinum",TimeValue.timeValueSeconds(3));
    TestUtils.registerAndAckSignedLicenses(licenseService,platinumLicense,LicensesStatus.VALID);
    licensesMetaData=clusterService.state().metaData().custom(LicensesMetaData.TYPE);
    assertThat(LicenseService.getLicense(licensesMetaData),equalTo(platinumLicense));
  }
  public void testInvalidLicenseStorage() throws Exception {
    LicenseService licenseService=getInstanceFromNode(LicenseService.class);
    ClusterService clusterService=getInstanceFromNode(ClusterService.class);
    License signedLicense=TestUtils.generateSignedLicense(TimeValue.timeValueMinutes(2));
    License tamperedLicense=License.builder().fromLicenseSpec(signedLicense,signedLicense.signature()).expiryDate(signedLicense.expiryDate() + 10 * 24 * 60* 60* 1000L).validate().build();
    TestUtils.registerAndAckSignedLicenses(licenseService,tamperedLicense,LicensesStatus.INVALID);
    LicensesMetaData licensesMetaData=clusterService.state().metaData().custom(LicensesMetaData.TYPE);
    assertThat(licensesMetaData.getLicense(),not(equalTo(tamperedLicense)));
  }
  public void testRemoveLicenses() throws Exception {
    LicenseService licenseService=getInstanceFromNode(LicenseService.class);
    ClusterService clusterService=getInstanceFromNode(ClusterService.class);
    License license=TestUtils.generateSignedLicense(TimeValue.timeValueHours(1));
    TestUtils.registerAndAckSignedLicenses(licenseService,license,LicensesStatus.VALID);
    LicensesMetaData licensesMetaData=clusterService.state().metaData().custom(LicensesMetaData.TYPE);
    assertThat(licensesMetaData.getLicense(),not(LicensesMetaData.LICENSE_TOMBSTONE));
    removeAndAckSignedLicenses(licenseService);
    licensesMetaData=clusterService.state().metaData().custom(LicensesMetaData.TYPE);
    assertThat(licensesMetaData.getLicense(),equalTo(LicensesMetaData.LICENSE_TOMBSTONE));
  }
  private void removeAndAckSignedLicenses(  final LicenseService licenseService){
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicBoolean success=new AtomicBoolean(false);
    licenseService.removeLicense(new DeleteLicenseRequest(),new ActionListener<ClusterStateUpdateResponse>(){
      @Override public void onResponse(      ClusterStateUpdateResponse clusterStateUpdateResponse){
        if (clusterStateUpdateResponse.isAcknowledged()) {
          success.set(true);
        }
        latch.countDown();
      }
      @Override public void onFailure(      Exception throwable){
        latch.countDown();
      }
    }
);
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      fail(e.getMessage());
    }
    assertThat("remove license(s) failed",success.get(),equalTo(true));
  }
}
