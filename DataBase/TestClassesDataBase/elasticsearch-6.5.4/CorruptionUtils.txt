public final class CorruptionUtils {
  private static final Logger logger=LogManager.getLogger(CorruptionUtils.class);
  private CorruptionUtils(){
  }
  public static void corruptIndex(  Random random,  Path indexPath,  boolean corruptSegments) throws IOException {
    final Path[] filesToCorrupt=Files.walk(indexPath).filter(p -> {
      final String name=p.getFileName().toString();
      boolean segmentFile=name.startsWith("segments_") || name.endsWith(".si");
      return Files.isRegularFile(p) && name.startsWith("extra") == false && IndexWriter.WRITE_LOCK_NAME.equals(name) == false && (corruptSegments ? segmentFile : segmentFile == false);
    }
).toArray(Path[]::new);
    corruptFile(random,filesToCorrupt);
  }
  /** 
 * Corrupts a random file at a random position
 */
  public static void corruptFile(  Random random,  Path... files) throws IOException {
    assertTrue("files must be non-empty",files.length > 0);
    final Path fileToCorrupt=RandomPicks.randomFrom(random,files);
    assertTrue(fileToCorrupt + " is not a file",Files.isRegularFile(fileToCorrupt));
    try (Directory dir=FSDirectory.open(fileToCorrupt.toAbsolutePath().getParent())){
      long checksumBeforeCorruption;
      try (IndexInput input=dir.openInput(fileToCorrupt.getFileName().toString(),IOContext.DEFAULT)){
        checksumBeforeCorruption=CodecUtil.retrieveChecksum(input);
      }
       try (FileChannel raf=FileChannel.open(fileToCorrupt,StandardOpenOption.READ,StandardOpenOption.WRITE)){
        long maxPosition=raf.size();
        if (fileToCorrupt.getFileName().toString().endsWith(".cfs") && maxPosition > 4) {
          maxPosition-=4;
        }
        final int position=random.nextInt((int)Math.min(Integer.MAX_VALUE,maxPosition));
        corruptAt(fileToCorrupt,raf,position);
      }
       long checksumAfterCorruption;
      long actualChecksumAfterCorruption;
      try (ChecksumIndexInput input=dir.openChecksumInput(fileToCorrupt.getFileName().toString(),IOContext.DEFAULT)){
        assertThat(input.getFilePointer(),is(0L));
        input.seek(input.length() - 8);
        checksumAfterCorruption=input.getChecksum();
        actualChecksumAfterCorruption=input.readLong();
      }
       StringBuilder msg=new StringBuilder();
      msg.append("before: [").append(checksumBeforeCorruption).append("] ");
      msg.append("after: [").append(checksumAfterCorruption).append("] ");
      msg.append("checksum value after corruption: ").append(actualChecksumAfterCorruption).append("] ");
      msg.append("file: ").append(fileToCorrupt.getFileName()).append(" length: ");
      msg.append(dir.fileLength(fileToCorrupt.getFileName().toString()));
      logger.info("Checksum {}",msg);
      assumeTrue("Checksum collision - " + msg.toString(),checksumAfterCorruption != checksumBeforeCorruption || actualChecksumAfterCorruption != checksumBeforeCorruption);
      assertThat("no file corrupted",fileToCorrupt,notNullValue());
    }
   }
  static void corruptAt(  Path path,  FileChannel channel,  int position) throws IOException {
    channel.position(position);
    long filePointer=channel.position();
    ByteBuffer bb=ByteBuffer.wrap(new byte[1]);
    channel.read(bb);
    bb.flip();
    byte oldValue=bb.get(0);
    byte newValue=(byte)(oldValue + 1);
    bb.put(0,newValue);
    channel.position(filePointer);
    channel.write(bb);
    logger.info("Corrupting file --  flipping at position {} from {} to {} file: {}",filePointer,Integer.toHexString(oldValue),Integer.toHexString(newValue),path.getFileName());
  }
}
