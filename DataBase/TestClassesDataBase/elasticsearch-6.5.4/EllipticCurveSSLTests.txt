public class EllipticCurveSSLTests extends SecurityIntegTestCase {
  @Override protected Settings nodeSettings(  int nodeOrdinal){
    final Path keyPath=getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/prime256v1-key.pem");
    final Path certPath=getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/prime256v1-cert.pem");
    return Settings.builder().put(super.nodeSettings(nodeOrdinal).filter(s -> s.startsWith("xpack.ssl") == false)).put("xpack.ssl.key",keyPath).put("xpack.ssl.certificate",certPath).put("xpack.ssl.certificate_authorities",certPath).put("xpack.ssl.verification_mode","certificate").build();
  }
  @Override protected Settings transportClientSettings(){
    final Path keyPath=getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/prime256v1-key.pem");
    final Path certPath=getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/prime256v1-cert.pem");
    return Settings.builder().put(super.transportClientSettings().filter(s -> s.startsWith("xpack.ssl") == false)).put("xpack.ssl.key",keyPath).put("xpack.ssl.certificate",certPath).put("xpack.ssl.certificate_authorities",certPath).put("xpack.ssl.verification_mode","certificate").build();
  }
  @Override protected boolean transportSSLEnabled(){
    return true;
  }
  public void testConnection() throws Exception {
    final Path keyPath=getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/prime256v1-key.pem");
    final Path certPath=getDataPath("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/prime256v1-cert.pem");
    PrivateKey privateKey=PemUtils.readPrivateKey(keyPath,() -> null);
    Certificate[] certs=CertParsingUtils.readCertificates(Collections.singletonList(certPath.toString()),null);
    X509ExtendedKeyManager x509ExtendedKeyManager=CertParsingUtils.keyManager(certs,privateKey,new char[0]);
    SSLContext sslContext=SSLContext.getInstance("TLS");
    sslContext.init(new X509ExtendedKeyManager[]{x509ExtendedKeyManager},new TrustManager[]{CertParsingUtils.trustManager(CertParsingUtils.readCertificates(Collections.singletonList(certPath)))},new SecureRandom());
    SSLSocketFactory socketFactory=sslContext.getSocketFactory();
    NodesInfoResponse response=client().admin().cluster().prepareNodesInfo().setTransport(true).get();
    TransportAddress address=randomFrom(response.getNodes()).getTransport().getAddress().publishAddress();
    final CountDownLatch latch=new CountDownLatch(1);
    try (SSLSocket sslSocket=AccessController.doPrivileged(new PrivilegedExceptionAction<SSLSocket>(){
      @Override public SSLSocket run() throws Exception {
        return (SSLSocket)socketFactory.createSocket(address.address().getAddress(),address.address().getPort());
      }
    }
)){
      final AtomicReference<HandshakeCompletedEvent> reference=new AtomicReference<>();
      sslSocket.addHandshakeCompletedListener((event) -> {
        reference.set(event);
        latch.countDown();
      }
);
      sslSocket.startHandshake();
      latch.await();
      HandshakeCompletedEvent event=reference.get();
      assertNotNull(event);
      SSLSession session=event.getSession();
      Certificate[] peerChain=session.getPeerCertificates();
      assertEquals(1,peerChain.length);
      assertEquals(certs[0],peerChain[0]);
      assertThat(session.getCipherSuite(),containsString("ECDSA"));
    }
   }
  @BeforeClass public static void assumeECDSACiphersSupported() throws Exception {
    SSLContext sslContext=SSLContext.getInstance("TLSv1.2");
    sslContext.init(null,null,null);
    SSLEngine sslEngine=sslContext.createSSLEngine();
    assumeTrue("ECDSA ciphers must be supported for this test to run. Enabled ciphers: " + Arrays.toString(sslEngine.getEnabledCipherSuites()) + ", supported ciphers: "+ Arrays.toString(sslEngine.getSupportedCipherSuites()),Arrays.stream(sslEngine.getEnabledCipherSuites()).anyMatch(s -> s.contains("ECDSA")));
  }
}
