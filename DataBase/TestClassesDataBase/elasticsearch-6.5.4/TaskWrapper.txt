/** 
 * Wraps a  {@link Sniffer.Task} and allows to wait for its completion. This is needed to verifythat tasks are either never started or always completed. Calling  {@link Future#get()} against a cancelled future willthrow  {@link CancellationException} straight-away but the execution of the task will continue if it had already started,in which case  {@link Future#cancel(boolean)} returns true which is not very helpful.
 */
private static final class TaskWrapper implements Runnable {
  final Sniffer.Task task;
  final CountDownLatch completionLatch=new CountDownLatch(1);
  TaskWrapper(  Sniffer.Task task){
    this.task=task;
  }
  @Override public void run(){
    try {
      task.run();
    }
  finally {
      completionLatch.countDown();
    }
  }
  boolean await() throws InterruptedException {
    return completionLatch.await(1000,TimeUnit.MILLISECONDS);
  }
}
