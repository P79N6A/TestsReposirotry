public class UnicastZenPingTests extends ESTestCase {
  private ThreadPool threadPool;
  private ExecutorService executorService;
  private Stack<Closeable> closeables;
  @Before public void setUp() throws Exception {
    super.setUp();
    threadPool=new TestThreadPool(getClass().getName());
    final ThreadFactory threadFactory=EsExecutors.daemonThreadFactory("[" + getClass().getName() + "]");
    executorService=EsExecutors.newScaling(getClass().getName() + "/" + getTestName(),0,2,60,TimeUnit.SECONDS,threadFactory,threadPool.getThreadContext());
    closeables=new Stack<>();
  }
  @After public void tearDown() throws Exception {
    try {
      logger.info("shutting down...");
      final List<Closeable> reverse=new ArrayList<>();
      while (!closeables.isEmpty()) {
        reverse.add(closeables.pop());
      }
      IOUtils.close(reverse);
    }
  finally {
      terminate(executorService);
      terminate(threadPool);
      super.tearDown();
    }
  }
  public void testSimplePings() throws IOException, InterruptedException, ExecutionException {
    final Settings settings=Settings.builder().put("cluster.name","test").put(TcpTransport.PORT.getKey(),0).build();
    final Settings settingsMismatch=Settings.builder().put(settings).put("cluster.name","mismatch").put(TcpTransport.PORT.getKey(),0).build();
    NetworkService networkService=new NetworkService(Collections.emptyList());
    final BiFunction<Settings,Version,Transport> supplier=(s,v) -> new MockTcpTransport(s,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,v);
    NetworkHandle handleA=startServices(settings,threadPool,"UZP_A",Version.CURRENT,supplier);
    closeables.push(handleA.transportService);
    NetworkHandle handleB=startServices(settings,threadPool,"UZP_B",Version.CURRENT,supplier);
    closeables.push(handleB.transportService);
    NetworkHandle handleC=startServices(settingsMismatch,threadPool,"UZP_C",Version.CURRENT,supplier);
    closeables.push(handleC.transportService);
    final Version versionD;
    if (randomBoolean()) {
      versionD=VersionUtils.randomVersionBetween(random(),Version.CURRENT.minimumCompatibilityVersion(),Version.CURRENT);
    }
 else {
      versionD=Version.CURRENT;
    }
    logger.info("UZP_D version set to [{}]",versionD);
    NetworkHandle handleD=startServices(settingsMismatch,threadPool,"UZP_D",versionD,supplier);
    closeables.push(handleD.transportService);
    final ClusterState state=ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build();
    final ClusterState stateMismatch=ClusterState.builder(new ClusterName("mismatch")).version(randomNonNegativeLong()).build();
    final Settings hostsSettings=Settings.builder().putList("discovery.zen.ping.unicast.hosts",NetworkAddress.format(new InetSocketAddress(handleA.address.address().getAddress(),handleA.address.address().getPort())),NetworkAddress.format(new InetSocketAddress(handleB.address.address().getAddress(),handleB.address.address().getPort())),NetworkAddress.format(new InetSocketAddress(handleC.address.address().getAddress(),handleC.address.address().getPort())),NetworkAddress.format(new InetSocketAddress(handleD.address.address().getAddress(),handleD.address.address().getPort()))).put("cluster.name","test").build();
    Settings hostsSettingsMismatch=Settings.builder().put(hostsSettings).put(settingsMismatch).build();
    ClusterState stateA=ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).localNodeId("UZP_A")).build();
    TestUnicastZenPing zenPingA=new TestUnicastZenPing(hostsSettings,threadPool,handleA,() -> stateA);
    zenPingA.start();
    closeables.push(zenPingA);
    ClusterState stateB=ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build();
    TestUnicastZenPing zenPingB=new TestUnicastZenPing(hostsSettings,threadPool,handleB,() -> stateB);
    zenPingB.start();
    closeables.push(zenPingB);
    ClusterState stateC=ClusterState.builder(stateMismatch).nodes(DiscoveryNodes.builder().add(handleC.node).localNodeId("UZP_C")).build();
    TestUnicastZenPing zenPingC=new TestUnicastZenPing(hostsSettingsMismatch,threadPool,handleC,() -> stateC){
      @Override protected Version getVersion(){
        return versionD;
      }
    }
;
    zenPingC.start();
    closeables.push(zenPingC);
    ClusterState stateD=ClusterState.builder(stateMismatch).nodes(DiscoveryNodes.builder().add(handleD.node).localNodeId("UZP_D")).build();
    TestUnicastZenPing zenPingD=new TestUnicastZenPing(hostsSettingsMismatch,threadPool,handleD,() -> stateD);
    zenPingD.start();
    closeables.push(zenPingD);
    logger.info("ping from UZP_A");
    Collection<ZenPing.PingResponse> pingResponses=zenPingA.pingAndWait().toList();
    assertThat(pingResponses.size(),equalTo(1));
    ZenPing.PingResponse ping=pingResponses.iterator().next();
    assertThat(ping.node().getId(),equalTo("UZP_B"));
    assertThat(ping.getClusterStateVersion(),equalTo(state.version()));
    assertPings(handleA,handleB);
    assertNoPings(handleA,handleC);
    assertNoPings(handleA,handleD);
    logger.info("ping from UZP_B");
    pingResponses=zenPingB.pingAndWait().toList();
    assertThat(pingResponses.size(),equalTo(1));
    ping=pingResponses.iterator().next();
    assertThat(ping.node().getId(),equalTo("UZP_A"));
    assertThat(ping.getClusterStateVersion(),equalTo(ElectMasterService.MasterCandidate.UNRECOVERED_CLUSTER_VERSION));
    assertPings(handleB,handleA);
    assertNoPings(handleB,handleC);
    assertNoPings(handleB,handleD);
    logger.info("ping from UZP_C");
    pingResponses=zenPingC.pingAndWait().toList();
    assertThat(pingResponses.size(),equalTo(1));
    assertNoPings(handleC,handleA);
    assertNoPings(handleC,handleB);
    assertPings(handleC,handleD);
    logger.info("ping from UZP_D");
    pingResponses=zenPingD.pingAndWait().toList();
    assertThat(pingResponses.size(),equalTo(1));
    assertNoPings(handleD,handleA);
    assertNoPings(handleD,handleB);
    assertPings(handleD,handleC);
    zenPingC.close();
    handleD.counters.clear();
    logger.info("ping from UZP_D after closing UZP_C");
    pingResponses=zenPingD.pingAndWait().toList();
    assertThat(pingResponses.size(),equalTo(0));
    assertNoPings(handleD,handleA);
    assertNoPings(handleD,handleB);
    assertPings(handleD,handleC);
  }
  public void testUnknownHostNotCached() throws ExecutionException, InterruptedException {
    final Settings settings=Settings.builder().put("cluster.name","test").put(TcpTransport.PORT.getKey(),0).build();
    final NetworkService networkService=new NetworkService(Collections.emptyList());
    final Map<String,TransportAddress[]> addresses=new HashMap<>();
    final BiFunction<Settings,Version,Transport> supplier=(s,v) -> new MockTcpTransport(s,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,v){
      @Override public TransportAddress[] addressesFromString(      String address,      int perAddressLimit) throws UnknownHostException {
        final TransportAddress[] transportAddresses=addresses.get(address);
        if (transportAddresses == null) {
          throw new UnknownHostException(address);
        }
 else {
          return transportAddresses;
        }
      }
    }
;
    final NetworkHandle handleA=startServices(settings,threadPool,"UZP_A",Version.CURRENT,supplier);
    closeables.push(handleA.transportService);
    final NetworkHandle handleB=startServices(settings,threadPool,"UZP_B",Version.CURRENT,supplier);
    closeables.push(handleB.transportService);
    final NetworkHandle handleC=startServices(settings,threadPool,"UZP_C",Version.CURRENT,supplier);
    closeables.push(handleC.transportService);
    addresses.put("UZP_A",new TransportAddress[]{new TransportAddress(new InetSocketAddress(handleA.address.address().getAddress(),handleA.address.address().getPort()))});
    addresses.put("UZP_C",new TransportAddress[]{new TransportAddress(new InetSocketAddress(handleC.address.address().getAddress(),handleC.address.address().getPort()))});
    final Settings hostsSettings=Settings.builder().putList("discovery.zen.ping.unicast.hosts","UZP_A","UZP_B","UZP_C").put("cluster.name","test").build();
    final ClusterState state=ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build();
    ClusterState stateA=ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).localNodeId("UZP_A")).build();
    final TestUnicastZenPing zenPingA=new TestUnicastZenPing(hostsSettings,threadPool,handleA,() -> stateA);
    zenPingA.start();
    closeables.push(zenPingA);
    ClusterState stateB=ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build();
    TestUnicastZenPing zenPingB=new TestUnicastZenPing(hostsSettings,threadPool,handleB,() -> stateB);
    zenPingB.start();
    closeables.push(zenPingB);
    ClusterState stateC=ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleC.node).localNodeId("UZP_C")).build();
    TestUnicastZenPing zenPingC=new TestUnicastZenPing(hostsSettings,threadPool,handleC,() -> stateC);
    zenPingC.start();
    closeables.push(zenPingC);
{
      final Collection<ZenPing.PingResponse> pingResponses=zenPingA.pingAndWait().toList();
      assertThat(pingResponses.size(),equalTo(1));
      ZenPing.PingResponse ping=pingResponses.iterator().next();
      assertThat(ping.node().getId(),equalTo("UZP_C"));
      assertThat(ping.getClusterStateVersion(),equalTo(state.version()));
      assertNoPings(handleA,handleB);
      assertPings(handleA,handleC);
      assertNull(handleA.counters.get(handleB.address));
    }
    final HashMap<TransportAddress,Integer> moreThan=new HashMap<>();
    moreThan.put(handleB.address,0);
    moreThan.put(handleC.address,handleA.counters.get(handleC.address).intValue());
    addresses.put("UZP_B",new TransportAddress[]{new TransportAddress(new InetSocketAddress(handleB.address.address().getAddress(),handleB.address.address().getPort()))});
{
      handleA.counters.clear();
      final Collection<ZenPing.PingResponse> secondPingResponses=zenPingA.pingAndWait().toList();
      assertThat(secondPingResponses.size(),equalTo(2));
      final Set<String> ids=new HashSet<>(secondPingResponses.stream().map(p -> p.node().getId()).collect(Collectors.toList()));
      assertThat(ids,equalTo(new HashSet<>(Arrays.asList("UZP_B","UZP_C"))));
      assertPings(handleA,handleB);
      assertPings(handleA,handleC);
    }
  }
  public void testPortLimit() throws InterruptedException {
    final NetworkService networkService=new NetworkService(Collections.emptyList());
    final Transport transport=new MockTcpTransport(Settings.EMPTY,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,Version.CURRENT){
      @Override public BoundTransportAddress boundAddress(){
        return new BoundTransportAddress(new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(),9500)},new TransportAddress(InetAddress.getLoopbackAddress(),9500));
      }
    }
;
    closeables.push(transport);
    final TransportService transportService=new TransportService(Settings.EMPTY,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,x -> null,null,Collections.emptySet());
    closeables.push(transportService);
    final int limitPortCounts=randomIntBetween(1,10);
    final List<TransportAddress> transportAddresses=UnicastZenPing.resolveHostsLists(executorService,logger,Collections.singletonList("127.0.0.1"),limitPortCounts,transportService,TimeValue.timeValueSeconds(1));
    assertThat(transportAddresses,hasSize(limitPortCounts));
    final Set<Integer> ports=new HashSet<>();
    for (    final TransportAddress address : transportAddresses) {
      assertTrue(address.address().getAddress().isLoopbackAddress());
      ports.add(address.getPort());
    }
    assertThat(ports,equalTo(IntStream.range(9300,9300 + limitPortCounts).mapToObj(m -> m).collect(Collectors.toSet())));
  }
  public void testRemovingLocalAddresses() throws InterruptedException {
    final NetworkService networkService=new NetworkService(Collections.emptyList());
    final InetAddress loopbackAddress=InetAddress.getLoopbackAddress();
    final Transport transport=new MockTcpTransport(Settings.EMPTY,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,Version.CURRENT){
      @Override public BoundTransportAddress boundAddress(){
        return new BoundTransportAddress(new TransportAddress[]{new TransportAddress(loopbackAddress,9300),new TransportAddress(loopbackAddress,9301)},new TransportAddress(loopbackAddress,9302));
      }
    }
;
    closeables.push(transport);
    final TransportService transportService=new TransportService(Settings.EMPTY,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,x -> null,null,Collections.emptySet());
    closeables.push(transportService);
    final List<TransportAddress> transportAddresses=UnicastZenPing.resolveHostsLists(executorService,logger,Collections.singletonList(NetworkAddress.format(loopbackAddress)),10,transportService,TimeValue.timeValueSeconds(1));
    assertThat(transportAddresses,hasSize(7));
    final Set<Integer> ports=new HashSet<>();
    for (    final TransportAddress address : transportAddresses) {
      assertTrue(address.address().getAddress().isLoopbackAddress());
      ports.add(address.getPort());
    }
    assertThat(ports,equalTo(IntStream.range(9303,9310).mapToObj(m -> m).collect(Collectors.toSet())));
  }
  public void testUnknownHost() throws InterruptedException {
    final Logger logger=mock(Logger.class);
    final NetworkService networkService=new NetworkService(Collections.emptyList());
    final String hostname=randomAlphaOfLength(8);
    final UnknownHostException unknownHostException=new UnknownHostException(hostname);
    final Transport transport=new MockTcpTransport(Settings.EMPTY,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,Version.CURRENT){
      @Override public BoundTransportAddress boundAddress(){
        return new BoundTransportAddress(new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(),9300)},new TransportAddress(InetAddress.getLoopbackAddress(),9300));
      }
      @Override public TransportAddress[] addressesFromString(      String address,      int perAddressLimit) throws UnknownHostException {
        throw unknownHostException;
      }
    }
;
    closeables.push(transport);
    final TransportService transportService=new TransportService(Settings.EMPTY,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,x -> null,null,Collections.emptySet());
    closeables.push(transportService);
    final List<TransportAddress> transportAddresses=UnicastZenPing.resolveHostsLists(executorService,logger,Arrays.asList(hostname),1,transportService,TimeValue.timeValueSeconds(1));
    assertThat(transportAddresses,empty());
    verify(logger).warn("failed to resolve host [" + hostname + "]",unknownHostException);
  }
  public void testResolveTimeout() throws InterruptedException {
    final Logger logger=mock(Logger.class);
    final NetworkService networkService=new NetworkService(Collections.emptyList());
    final CountDownLatch latch=new CountDownLatch(1);
    final Transport transport=new MockTcpTransport(Settings.EMPTY,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,Version.CURRENT){
      @Override public BoundTransportAddress boundAddress(){
        return new BoundTransportAddress(new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(),9500)},new TransportAddress(InetAddress.getLoopbackAddress(),9500));
      }
      @Override public TransportAddress[] addressesFromString(      String address,      int perAddressLimit) throws UnknownHostException {
        if ("hostname1".equals(address)) {
          return new TransportAddress[]{new TransportAddress(TransportAddress.META_ADDRESS,9300)};
        }
 else         if ("hostname2".equals(address)) {
          try {
            latch.await();
            return new TransportAddress[]{new TransportAddress(TransportAddress.META_ADDRESS,9300)};
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
 else {
          throw new UnknownHostException(address);
        }
      }
    }
;
    closeables.push(transport);
    final TransportService transportService=new TransportService(Settings.EMPTY,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,x -> null,null,Collections.emptySet());
    closeables.push(transportService);
    final TimeValue resolveTimeout=TimeValue.timeValueSeconds(randomIntBetween(1,3));
    try {
      final List<TransportAddress> transportAddresses=UnicastZenPing.resolveHostsLists(executorService,logger,Arrays.asList("hostname1","hostname2"),1,transportService,resolveTimeout);
      assertThat(transportAddresses,hasSize(1));
      verify(logger).trace("resolved host [{}] to {}","hostname1",new TransportAddress[]{new TransportAddress(TransportAddress.META_ADDRESS,9300)});
      verify(logger).warn("timed out after [{}] resolving host [{}]",resolveTimeout,"hostname2");
      verifyNoMoreInteractions(logger);
    }
  finally {
      latch.countDown();
    }
  }
  public void testResolveReuseExistingNodeConnections() throws ExecutionException, InterruptedException {
    final Settings settings=Settings.builder().put("cluster.name","test").put(TcpTransport.PORT.getKey(),0).build();
    NetworkService networkService=new NetworkService(Collections.emptyList());
    final BiFunction<Settings,Version,Transport> supplier=(s,v) -> new MockTcpTransport(s,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,v);
    NetworkHandle handleA=startServices(settings,threadPool,"UZP_A",Version.CURRENT,supplier,EnumSet.allOf(Role.class));
    closeables.push(handleA.transportService);
    NetworkHandle handleB=startServices(settings,threadPool,"UZP_B",Version.CURRENT,supplier,EnumSet.allOf(Role.class));
    closeables.push(handleB.transportService);
    final boolean useHosts=randomBoolean();
    final Settings.Builder hostsSettingsBuilder=Settings.builder().put("cluster.name","test");
    if (useHosts) {
      hostsSettingsBuilder.putList("discovery.zen.ping.unicast.hosts",NetworkAddress.format(new InetSocketAddress(handleB.address.address().getAddress(),handleB.address.address().getPort())));
    }
 else {
      hostsSettingsBuilder.put("discovery.zen.ping.unicast.hosts",(String)null);
    }
    final Settings hostsSettings=hostsSettingsBuilder.build();
    final ClusterState state=ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build();
    handleA.transportService.connectToNode(handleB.node);
    handleA.transportService.addConnectionListener(new TransportConnectionListener(){
      @Override public void onConnectionOpened(      Transport.Connection connection){
        fail("should not open any connections. got [" + connection.getNode() + "]");
      }
    }
);
    final ClusterState stateA=ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).add(handleB.node).localNodeId("UZP_A")).build();
    final TestUnicastZenPing zenPingA=new TestUnicastZenPing(hostsSettings,threadPool,handleA,() -> stateA);
    zenPingA.start();
    closeables.push(zenPingA);
    final ClusterState stateB=ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build();
    TestUnicastZenPing zenPingB=new TestUnicastZenPing(hostsSettings,threadPool,handleB,() -> stateB);
    zenPingB.start();
    closeables.push(zenPingB);
    Collection<ZenPing.PingResponse> pingResponses=zenPingA.pingAndWait().toList();
    assertThat(pingResponses.size(),equalTo(1));
    ZenPing.PingResponse ping=pingResponses.iterator().next();
    assertThat(ping.node().getId(),equalTo("UZP_B"));
    assertThat(ping.getClusterStateVersion(),equalTo(state.version()));
  }
  public void testPingingTemporalPings() throws ExecutionException, InterruptedException {
    final Settings settings=Settings.builder().put("cluster.name","test").put(TcpTransport.PORT.getKey(),0).build();
    NetworkService networkService=new NetworkService(Collections.emptyList());
    final BiFunction<Settings,Version,Transport> supplier=(s,v) -> new MockTcpTransport(s,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,v);
    NetworkHandle handleA=startServices(settings,threadPool,"UZP_A",Version.CURRENT,supplier,EnumSet.allOf(Role.class));
    closeables.push(handleA.transportService);
    NetworkHandle handleB=startServices(settings,threadPool,"UZP_B",Version.CURRENT,supplier,EnumSet.allOf(Role.class));
    closeables.push(handleB.transportService);
    final Settings hostsSettings=Settings.builder().put("cluster.name","test").put("discovery.zen.ping.unicast.hosts",(String)null).build();
    final ClusterState state=ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build();
    final ClusterState stateA=ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).add(handleB.node).localNodeId("UZP_A")).build();
    final TestUnicastZenPing zenPingA=new TestUnicastZenPing(hostsSettings,threadPool,handleA,() -> stateA);
    zenPingA.start();
    closeables.push(zenPingA);
    final ClusterState stateB=ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build();
    TestUnicastZenPing zenPingB=new TestUnicastZenPing(hostsSettings,threadPool,handleB,() -> stateB);
    zenPingB.start();
    closeables.push(zenPingB);
{
      logger.info("pinging from UZP_A so UZP_B will learn about it");
      Collection<ZenPing.PingResponse> pingResponses=zenPingA.pingAndWait().toList();
      assertThat(pingResponses.size(),equalTo(1));
      ZenPing.PingResponse ping=pingResponses.iterator().next();
      assertThat(ping.node().getId(),equalTo("UZP_B"));
      assertThat(ping.getClusterStateVersion(),equalTo(state.version()));
    }
{
      logger.info("pinging from UZP_B");
      Collection<ZenPing.PingResponse> pingResponses=zenPingB.pingAndWait().toList();
      assertThat(pingResponses.size(),equalTo(1));
      ZenPing.PingResponse ping=pingResponses.iterator().next();
      assertThat(ping.node().getId(),equalTo("UZP_A"));
      assertThat(ping.getClusterStateVersion(),equalTo(-1L));
    }
  }
  public void testInvalidHosts() throws InterruptedException {
    final Logger logger=mock(Logger.class);
    final NetworkService networkService=new NetworkService(Collections.emptyList());
    final Transport transport=new MockTcpTransport(Settings.EMPTY,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),networkService,Version.CURRENT){
      @Override public BoundTransportAddress boundAddress(){
        return new BoundTransportAddress(new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(),9300)},new TransportAddress(InetAddress.getLoopbackAddress(),9300));
      }
    }
;
    closeables.push(transport);
    final TransportService transportService=new TransportService(Settings.EMPTY,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,x -> null,null,Collections.emptySet());
    closeables.push(transportService);
    final List<TransportAddress> transportAddresses=UnicastZenPing.resolveHostsLists(executorService,logger,Arrays.asList("127.0.0.1:9300:9300","127.0.0.1:9301"),1,transportService,TimeValue.timeValueSeconds(1));
    assertThat(transportAddresses,hasSize(1));
    assertThat(transportAddresses.get(0).getAddress(),equalTo("127.0.0.1"));
    assertThat(transportAddresses.get(0).getPort(),equalTo(9301));
    verify(logger).warn(eq("failed to resolve host [127.0.0.1:9300:9300]"),Matchers.any(ExecutionException.class));
  }
  private void assertNoPings(  final NetworkHandle fromNode,  final NetworkHandle toNode){
    final AtomicInteger counter=fromNode.counters.getOrDefault(toNode.address,new AtomicInteger());
    final String onNodeName=fromNode.node.getName();
    assertNotNull("handle for [" + onNodeName + "] has no 'expected' counter",counter);
    final String forNodeName=toNode.node.getName();
    assertThat("node [" + onNodeName + "] ping count to ["+ forNodeName+ "] is unexpected",counter.get(),equalTo(0));
  }
  private void assertPings(  final NetworkHandle fromNode,  final NetworkHandle toNode){
    final AtomicInteger counter=fromNode.counters.getOrDefault(toNode.address,new AtomicInteger());
    final String onNodeName=fromNode.node.getName();
    assertNotNull("handle for [" + onNodeName + "] has no 'expected' counter",counter);
    final String forNodeName=toNode.node.getName();
    if (Constants.WINDOWS) {
      assertThat("node [" + onNodeName + "] ping count to ["+ forNodeName+ "] is unexpected",counter.get(),greaterThan(0));
    }
 else {
      assertThat("node [" + onNodeName + "] ping count to ["+ forNodeName+ "] is unexpected",counter.get(),equalTo(3));
    }
  }
  private NetworkHandle startServices(  final Settings settings,  final ThreadPool threadPool,  final String nodeId,  final Version version,  final BiFunction<Settings,Version,Transport> supplier){
    return startServices(settings,threadPool,nodeId,version,supplier,emptySet());
  }
  private NetworkHandle startServices(  final Settings settings,  final ThreadPool threadPool,  final String nodeId,  final Version version,  final BiFunction<Settings,Version,Transport> supplier,  final Set<Role> nodeRoles){
    final Settings nodeSettings=Settings.builder().put(settings).put("node.name",nodeId).put(TransportService.TRACE_LOG_INCLUDE_SETTING.getKey(),"internal:discovery/zen/unicast").build();
    final Transport transport=supplier.apply(nodeSettings,version);
    final MockTransportService transportService=new MockTransportService(nodeSettings,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,boundAddress -> new DiscoveryNode(nodeId,nodeId,boundAddress.publishAddress(),emptyMap(),nodeRoles,version),null,Collections.emptySet());
    transportService.start();
    transportService.acceptIncomingRequests();
    final ConcurrentMap<TransportAddress,AtomicInteger> counters=ConcurrentCollections.newConcurrentMap();
    transportService.addTracer(new MockTransportService.Tracer(){
      @Override public void requestSent(      DiscoveryNode node,      long requestId,      String action,      TransportRequestOptions options){
        counters.computeIfAbsent(node.getAddress(),k -> new AtomicInteger());
        counters.get(node.getAddress()).incrementAndGet();
      }
    }
);
    return new NetworkHandle(transport.boundAddress().publishAddress(),transportService,transportService.getLocalNode(),counters);
  }
private static class NetworkHandle {
    public final TransportAddress address;
    public final TransportService transportService;
    public final DiscoveryNode node;
    public final ConcurrentMap<TransportAddress,AtomicInteger> counters;
    NetworkHandle(    final TransportAddress address,    final TransportService transportService,    final DiscoveryNode discoveryNode,    final ConcurrentMap<TransportAddress,AtomicInteger> counters){
      this.address=address;
      this.transportService=transportService;
      this.node=discoveryNode;
      this.counters=counters;
    }
  }
private static class TestUnicastZenPing extends UnicastZenPing {
    TestUnicastZenPing(    Settings settings,    ThreadPool threadPool,    NetworkHandle networkHandle,    PingContextProvider contextProvider){
      super(Settings.builder().put("node.name",networkHandle.node.getName()).put(settings).build(),threadPool,networkHandle.transportService,new SettingsBasedHostsProvider(settings,networkHandle.transportService),contextProvider);
    }
    volatile CountDownLatch allTasksCompleted;
    volatile AtomicInteger pendingTasks;
    volatile CountDownLatch pingingRoundClosed;
    PingCollection pingAndWait() throws ExecutionException, InterruptedException {
      allTasksCompleted=new CountDownLatch(1);
      pingingRoundClosed=new CountDownLatch(1);
      pendingTasks=new AtomicInteger();
      markTaskAsStarted("send pings");
      markTaskAsStarted("send pings");
      markTaskAsStarted("send pings");
      final AtomicReference<PingCollection> response=new AtomicReference<>();
      ping(response::set,TimeValue.timeValueMillis(1),TimeValue.timeValueSeconds(1));
      pingingRoundClosed.await();
      final PingCollection result=response.get();
      assertNotNull("pinging didn't complete",result);
      return result;
    }
    @Override protected void finishPingingRound(    PingingRound pingingRound){
      try {
        allTasksCompleted.await();
      }
 catch (      InterruptedException e) {
      }
      super.finishPingingRound(pingingRound);
      pingingRoundClosed.countDown();
    }
    @Override protected void sendPings(    TimeValue timeout,    PingingRound pingingRound){
      super.sendPings(timeout,pingingRound);
      markTaskAsCompleted("send pings");
    }
    @Override protected void submitToExecutor(    AbstractRunnable abstractRunnable){
      markTaskAsStarted("executor runnable");
      super.submitToExecutor(new AbstractRunnable(){
        @Override public void onRejection(        Exception e){
          try {
            super.onRejection(e);
          }
  finally {
            markTaskAsCompleted("executor runnable (rejected)");
          }
        }
        @Override public void onAfter(){
          markTaskAsCompleted("executor runnable");
        }
        @Override protected void doRun() throws Exception {
          abstractRunnable.run();
        }
        @Override public void onFailure(        Exception e){
          throw new AssertionError("unexpected error",e);
        }
      }
);
    }
    private void markTaskAsStarted(    String task){
      logger.trace("task [{}] started. count [{}]",task,pendingTasks.incrementAndGet());
    }
    private void markTaskAsCompleted(    String task){
      final int left=pendingTasks.decrementAndGet();
      logger.trace("task [{}] completed. count [{}]",task,left);
      if (left == 0) {
        allTasksCompleted.countDown();
      }
    }
    @Override protected TransportResponseHandler<UnicastPingResponse> getPingResponseHandler(    PingingRound pingingRound,    DiscoveryNode node){
      markTaskAsStarted("ping [" + node + "]");
      TransportResponseHandler<UnicastPingResponse> original=super.getPingResponseHandler(pingingRound,node);
      return new TransportResponseHandler<UnicastPingResponse>(){
        @Override public UnicastPingResponse read(        StreamInput in) throws IOException {
          return original.read(in);
        }
        @Override public void handleResponse(        UnicastPingResponse response){
          original.handleResponse(response);
          markTaskAsCompleted("ping [" + node + "]");
        }
        @Override public void handleException(        TransportException exp){
          original.handleException(exp);
          markTaskAsCompleted("ping [" + node + "] (error)");
        }
        @Override public String executor(){
          return original.executor();
        }
      }
;
    }
  }
}
