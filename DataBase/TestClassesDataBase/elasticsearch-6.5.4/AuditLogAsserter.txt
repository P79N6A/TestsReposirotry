/** 
 * Used to assert audit logs. Logs are asserted to match in any order because we don't always scroll in the same order but each log checker must match a single log and all logs must be matched.
 */
protected class AuditLogAsserter {
  protected final List<Function<Map<String,Object>,Boolean>> logCheckers=new ArrayList<>();
  public AuditLogAsserter expectSqlCompositeActionGetIndex(  String user,  String... indices){
    expect(true,SQL_ACTION_NAME,user,empty());
    expect(true,GetIndexAction.NAME,user,hasItems(indices));
    return this;
  }
  public AuditLogAsserter expectSqlCompositeActionFieldCaps(  String user,  String... indices){
    expect(true,SQL_ACTION_NAME,user,empty());
    expect(true,FieldCapabilitiesAction.NAME,user,hasItems(indices));
    return this;
  }
  public AuditLogAsserter expect(  boolean granted,  String action,  String principal,  Matcher<? extends Iterable<? extends String>> indicesMatcher){
    String request;
switch (action) {
case SQL_ACTION_NAME:
      request="SqlQueryRequest";
    break;
case GetIndexAction.NAME:
  request=GetIndexRequest.class.getSimpleName();
break;
case FieldCapabilitiesAction.NAME:
request=FieldCapabilitiesRequest.class.getSimpleName();
break;
default :
throw new IllegalArgumentException("Unknown action [" + action + "]");
}
final String eventAction=granted ? "access_granted" : "access_denied";
final String realm=principal.equals("test_admin") ? "default_file" : "default_native";
return expect(eventAction,action,principal,realm,indicesMatcher,request);
}
public AuditLogAsserter expect(String eventAction,String action,String principal,String realm,Matcher<? extends Iterable<? extends String>> indicesMatcher,String request){
logCheckers.add(m -> eventAction.equals(m.get("event.action")) && action.equals(m.get("action")) && principal.equals(m.get("user.name"))&& realm.equals(m.get("user.realm"))&& Matchers.nullValue(String.class).matches(m.get("user.run_by.name"))&& Matchers.nullValue(String.class).matches(m.get("user.run_by.realm"))&& indicesMatcher.matches(m.get("indices"))&& request.equals(m.get("request.name")));
return this;
}
public void assertLogs() throws Exception {
assertFalse("Previous test had an audit-related failure. All subsequent audit related assertions are bogus because we can't " + "guarantee that we fully cleaned up after the last test.",auditFailure);
try {
assertBusy(() -> {
SecurityManager sm=System.getSecurityManager();
if (sm != null) {
sm.checkPermission(new SpecialPermission());
}
BufferedReader logReader=AccessController.doPrivileged((PrivilegedAction<BufferedReader>)() -> {
try {
return Files.newBufferedReader(AUDIT_LOG_FILE,StandardCharsets.UTF_8);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
}
);
logReader.skip(auditLogWrittenBeforeTestStart);
List<Map<String,Object>> logs=new ArrayList<>();
String line;
while ((line=logReader.readLine()) != null) {
try {
final Map<String,Object> log=XContentHelper.convertToMap(JsonXContent.jsonXContent,line,false);
if (false == ("access_denied".equals(log.get("event.action")) || "access_granted".equals(log.get("event.action")))) {
continue;
}
assertThat(log.containsKey("action"),is(true));
if (false == (SQL_ACTION_NAME.equals(log.get("action")) || GetIndexAction.NAME.equals(log.get("action")) || FieldCapabilitiesAction.NAME.equals(log.get("action")))) {
continue;
}
assertThat(log.containsKey("user.name"),is(true));
List<String> indices=new ArrayList<>();
if (log.containsKey("indices")) {
indices=(ArrayList<String>)log.get("indices");
if ("test_admin".equals(log.get("user.name"))) {
  indices.remove(".security");
  indices.remove(".security-6");
}
}
Collections.sort(indices);
log.put("indices",indices);
logs.add(log);
}
 catch (final ElasticsearchParseException e) {
throw new IllegalArgumentException("Unrecognized log: " + line,e);
}
}
List<Map<String,Object>> allLogs=new ArrayList<>(logs);
List<Integer> notMatching=new ArrayList<>();
checker: for (int c=0; c < logCheckers.size(); c++) {
Function<Map<String,Object>,Boolean> logChecker=logCheckers.get(c);
for (Iterator<Map<String,Object>> logsItr=logs.iterator(); logsItr.hasNext(); ) {
Map<String,Object> log=logsItr.next();
if (logChecker.apply(log)) {
logsItr.remove();
continue checker;
}
}
notMatching.add(c);
}
if (false == notMatching.isEmpty()) {
fail("Some checkers " + notMatching + " didn't match any logs. All logs:"+ logsMessage(allLogs)+ "\nRemaining logs:"+ logsMessage(logs));
}
if (false == logs.isEmpty()) {
fail("Not all logs matched. Unmatched logs:" + logsMessage(logs));
}
}
);
}
 catch (AssertionError e) {
auditFailure=true;
logger.warn("Failed to find an audit log. Skipping remaining tests in this class after this the missing audit" + "logs could turn up later.");
throw e;
}
}
private String logsMessage(List<Map<String,Object>> logs){
if (logs.isEmpty()) {
return "  none!";
}
StringBuilder logsMessage=new StringBuilder();
for (Map<String,Object> log : logs) {
logsMessage.append('\n').append(log);
}
return logsMessage.toString();
}
}
