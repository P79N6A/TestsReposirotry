public class ShortCircuitingRenormalizerTests extends ESTestCase {
  private static final String JOB_ID="foo";
  private static final int TEST_SIZE=1000;
  private ScoresUpdater scoresUpdater;
  @Before public void setUpMocks(){
    scoresUpdater=mock(ScoresUpdater.class);
    when(scoresUpdater.getNormalizationWindow()).thenReturn(30L);
  }
  public void testNormalize() throws InterruptedException {
    ExecutorService threadpool=Executors.newScheduledThreadPool(10);
    try {
      ShortCircuitingRenormalizer renormalizer=new ShortCircuitingRenormalizer(JOB_ID,scoresUpdater,threadpool);
      for (int i=1; i < TEST_SIZE / 2; ++i) {
        Quantiles quantiles=new Quantiles(JOB_ID,new Date(),Integer.toString(i));
        renormalizer.renormalize(quantiles);
      }
      renormalizer.waitUntilIdle();
      for (int i=TEST_SIZE / 2; i <= TEST_SIZE; ++i) {
        Quantiles quantiles=new Quantiles(JOB_ID,new Date(),Integer.toString(i));
        renormalizer.renormalize(quantiles);
      }
      renormalizer.waitUntilIdle();
      ArgumentCaptor<String> stateCaptor=ArgumentCaptor.forClass(String.class);
      verify(scoresUpdater,atLeastOnce()).update(stateCaptor.capture(),anyLong(),anyLong());
      List<String> quantilesUsed=stateCaptor.getAllValues();
      assertFalse(quantilesUsed.isEmpty());
      assertTrue("quantilesUsed.size() is " + quantilesUsed.size(),quantilesUsed.size() <= TEST_SIZE);
      assertEquals(Integer.toString(TEST_SIZE),quantilesUsed.get(quantilesUsed.size() - 1));
      int previous=0;
      for (      String state : quantilesUsed) {
        int current=Integer.parseInt(state);
        assertTrue("Out of sequence states were " + previous + " and "+ current+ " in "+ quantilesUsed,current > previous);
        previous=current;
      }
      int intermediateWaitPoint=TEST_SIZE / 2 - 1;
      assertTrue(quantilesUsed + " should contain " + intermediateWaitPoint,quantilesUsed.contains(Integer.toString(intermediateWaitPoint)));
    }
  finally {
      threadpool.shutdown();
    }
    assertTrue(threadpool.awaitTermination(1,TimeUnit.SECONDS));
  }
  public void testIsEnabled_GivenNormalizationWindowIsZero(){
    ScoresUpdater scoresUpdater=mock(ScoresUpdater.class);
    when(scoresUpdater.getNormalizationWindow()).thenReturn(0L);
    ShortCircuitingRenormalizer renormalizer=new ShortCircuitingRenormalizer(JOB_ID,scoresUpdater,null);
    assertThat(renormalizer.isEnabled(),is(false));
  }
  public void testIsEnabled_GivenNormalizationWindowGreaterThanZero(){
    ScoresUpdater scoresUpdater=mock(ScoresUpdater.class);
    when(scoresUpdater.getNormalizationWindow()).thenReturn(1L);
    ShortCircuitingRenormalizer renormalizer=new ShortCircuitingRenormalizer(JOB_ID,scoresUpdater,null);
    assertThat(renormalizer.isEnabled(),is(true));
  }
}
