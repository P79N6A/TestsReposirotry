private class TranslogThread extends Thread {
  private final CountDownLatch downLatch;
  private final int opsPerThread;
  private final int threadId;
  private final Collection<LocationOperation> writtenOperations;
  private final Exception[] threadExceptions;
  private final Translog translog;
  private final AtomicLong seqNoGenerator;
  TranslogThread(  Translog translog,  CountDownLatch downLatch,  int opsPerThread,  int threadId,  Collection<LocationOperation> writtenOperations,  AtomicLong seqNoGenerator,  Exception[] threadExceptions){
    this.translog=translog;
    this.downLatch=downLatch;
    this.opsPerThread=opsPerThread;
    this.threadId=threadId;
    this.writtenOperations=writtenOperations;
    this.seqNoGenerator=seqNoGenerator;
    this.threadExceptions=threadExceptions;
  }
  @Override public void run(){
    try {
      downLatch.await();
      for (int opCount=0; opCount < opsPerThread; opCount++) {
        Translog.Operation op;
        final Translog.Operation.Type type=randomFrom(Translog.Operation.Type.values());
switch (type) {
case CREATE:
case INDEX:
          op=new Translog.Index("test",threadId + "_" + opCount,seqNoGenerator.getAndIncrement(),primaryTerm.get(),randomUnicodeOfLengthBetween(1,20 * 1024).getBytes("UTF-8"));
        break;
case DELETE:
      op=new Translog.Delete("test",threadId + "_" + opCount,new Term("_uid",threadId + "_" + opCount),seqNoGenerator.getAndIncrement(),primaryTerm.get(),1 + randomInt(100000),randomFrom(VersionType.values()));
    break;
case NO_OP:
  op=new Translog.NoOp(seqNoGenerator.getAndIncrement(),primaryTerm.get(),randomAlphaOfLength(16));
break;
default :
throw new AssertionError("unsupported operation type [" + type + "]");
}
Translog.Location loc=add(op);
writtenOperations.add(new LocationOperation(op,loc));
if (rarely()) {
assertEquals(op,translog.readOperation(loc));
}
afterAdd();
}
}
 catch (Exception t) {
threadExceptions[threadId]=t;
}
}
protected Translog.Location add(Translog.Operation op) throws IOException {
return translog.add(op);
}
protected void afterAdd() throws IOException {
}
}
