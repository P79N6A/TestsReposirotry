public class NativeAutodetectProcessTests extends ESTestCase {
  private static final int NUMBER_FIELDS=5;
  private ExecutorService executorService;
  @Before @SuppressWarnings("unchecked") public void initialize(){
    executorService=mock(ExecutorService.class);
    when(executorService.submit(any(Runnable.class))).thenReturn(mock(Future.class));
  }
  public void testProcessStartTime() throws Exception {
    InputStream logStream=mock(InputStream.class);
    when(logStream.read(new byte[1024])).thenReturn(-1);
    try (NativeAutodetectProcess process=new NativeAutodetectProcess("foo",logStream,mock(OutputStream.class),mock(InputStream.class),mock(OutputStream.class),NUMBER_FIELDS,null,new AutodetectResultsParser(Settings.EMPTY),mock(Runnable.class))){
      process.start(executorService,mock(StateProcessor.class),mock(InputStream.class));
      ZonedDateTime startTime=process.getProcessStartTime();
      Thread.sleep(500);
      ZonedDateTime now=ZonedDateTime.now();
      assertTrue(now.isAfter(startTime));
      ZonedDateTime startPlus3=startTime.plus(3,ChronoUnit.SECONDS);
      assertTrue(now.isBefore(startPlus3));
    }
   }
  public void testWriteRecord() throws IOException {
    InputStream logStream=mock(InputStream.class);
    when(logStream.read(new byte[1024])).thenReturn(-1);
    String[] record={"r1","r2","r3","r4","r5"};
    ByteArrayOutputStream bos=new ByteArrayOutputStream(1024);
    try (NativeAutodetectProcess process=new NativeAutodetectProcess("foo",logStream,bos,mock(InputStream.class),mock(OutputStream.class),NUMBER_FIELDS,Collections.emptyList(),new AutodetectResultsParser(Settings.EMPTY),mock(Runnable.class))){
      process.start(executorService,mock(StateProcessor.class),mock(InputStream.class));
      process.writeRecord(record);
      process.flushStream();
      ByteBuffer bb=ByteBuffer.wrap(bos.toByteArray());
      int numFields=bb.getInt();
      Assert.assertEquals(record.length,numFields);
      for (int i=0; i < numFields; i++) {
        int recordSize=bb.getInt();
        assertEquals(2,recordSize);
        byte[] charBuff=new byte[recordSize];
        for (int j=0; j < recordSize; j++) {
          charBuff[j]=bb.get();
        }
        String value=new String(charBuff,StandardCharsets.UTF_8);
        Assert.assertEquals(record[i],value);
      }
    }
   }
  public void testFlush() throws IOException {
    InputStream logStream=mock(InputStream.class);
    when(logStream.read(new byte[1024])).thenReturn(-1);
    ByteArrayOutputStream bos=new ByteArrayOutputStream(ControlMsgToProcessWriter.FLUSH_SPACES_LENGTH + 1024);
    try (NativeAutodetectProcess process=new NativeAutodetectProcess("foo",logStream,bos,mock(InputStream.class),mock(OutputStream.class),NUMBER_FIELDS,Collections.emptyList(),new AutodetectResultsParser(Settings.EMPTY),mock(Runnable.class))){
      process.start(executorService,mock(StateProcessor.class),mock(InputStream.class));
      FlushJobParams params=FlushJobParams.builder().build();
      process.flushJob(params);
      ByteBuffer bb=ByteBuffer.wrap(bos.toByteArray());
      assertThat(bb.remaining(),is(greaterThan(ControlMsgToProcessWriter.FLUSH_SPACES_LENGTH)));
    }
   }
  public void testWriteResetBucketsControlMessage() throws IOException {
    DataLoadParams params=new DataLoadParams(TimeRange.builder().startTime("1").endTime("86400").build(),Optional.empty());
    testWriteMessage(p -> p.writeResetBucketsControlMessage(params),ControlMsgToProcessWriter.RESET_BUCKETS_MESSAGE_CODE);
  }
  public void testWriteUpdateConfigMessage() throws IOException {
    testWriteMessage(p -> p.writeUpdateModelPlotMessage(new ModelPlotConfig()),ControlMsgToProcessWriter.UPDATE_MESSAGE_CODE);
  }
  public void testPersistJob() throws IOException {
    testWriteMessage(p -> p.persistJob(),ControlMsgToProcessWriter.BACKGROUND_PERSIST_MESSAGE_CODE);
  }
  public void testWriteMessage(  CheckedConsumer<NativeAutodetectProcess> writeFunction,  String expectedMessageCode) throws IOException {
    InputStream logStream=mock(InputStream.class);
    when(logStream.read(new byte[1024])).thenReturn(-1);
    ByteArrayOutputStream bos=new ByteArrayOutputStream(1024);
    try (NativeAutodetectProcess process=new NativeAutodetectProcess("foo",logStream,bos,mock(InputStream.class),mock(OutputStream.class),NUMBER_FIELDS,Collections.emptyList(),new AutodetectResultsParser(Settings.EMPTY),mock(Runnable.class))){
      process.start(executorService,mock(StateProcessor.class),mock(InputStream.class));
      writeFunction.accept(process);
      process.writeUpdateModelPlotMessage(new ModelPlotConfig());
      process.flushStream();
      String message=new String(bos.toByteArray(),StandardCharsets.UTF_8);
      assertTrue(message.contains(expectedMessageCode));
    }
   }
@FunctionalInterface private interface CheckedConsumer<T> {
    void accept(    T t) throws IOException ;
  }
}
