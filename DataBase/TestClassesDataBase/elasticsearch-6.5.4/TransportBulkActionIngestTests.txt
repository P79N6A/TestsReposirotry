public class TransportBulkActionIngestTests extends ESTestCase {
  /** 
 * Index for which mock settings contain a default pipeline.
 */
  private static final String WITH_DEFAULT_PIPELINE="index_with_default_pipeline";
  private static final Settings SETTINGS=Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(),true).build();
  /** 
 * Services needed by bulk action 
 */
  TransportService transportService;
  ClusterService clusterService;
  IngestService ingestService;
  /** 
 * Arguments to callbacks we want to capture, but which require generics, so we must use @Captor 
 */
  @Captor ArgumentCaptor<BiConsumer<IndexRequest,Exception>> failureHandler;
  @Captor ArgumentCaptor<Consumer<Exception>> completionHandler;
  @Captor ArgumentCaptor<TransportResponseHandler<BulkResponse>> remoteResponseHandler;
  @Captor ArgumentCaptor<Iterable<DocWriteRequest<?>>> bulkDocsItr;
  /** 
 * The actual action we want to test, with real indexing mocked 
 */
  TestTransportBulkAction action;
  /** 
 * Single item bulk write action that wraps index requests 
 */
  TestSingleItemBulkWriteAction singleItemBulkWriteAction;
  /** 
 * True if the next call to the index action should act as an ingest node 
 */
  boolean localIngest;
  /** 
 * The nodes that forwarded index requests should be cycled through. 
 */
  DiscoveryNodes nodes;
  DiscoveryNode remoteNode1;
  DiscoveryNode remoteNode2;
  /** 
 * A subclass of the real bulk action to allow skipping real bulk indexing, and marking when it would have happened. 
 */
class TestTransportBulkAction extends TransportBulkAction {
    boolean isExecuted=false;
    boolean needToCheck;
    boolean indexCreated=true;
    TestTransportBulkAction(){
      super(SETTINGS,null,transportService,clusterService,ingestService,null,null,new ActionFilters(Collections.emptySet()),null,new AutoCreateIndex(SETTINGS,new ClusterSettings(SETTINGS,ClusterSettings.BUILT_IN_CLUSTER_SETTINGS),new IndexNameExpressionResolver(SETTINGS)));
    }
    @Override protected boolean needToCheck(){
      return needToCheck;
    }
    @Override void executeBulk(    Task task,    final BulkRequest bulkRequest,    final long startTimeNanos,    final ActionListener<BulkResponse> listener,    final AtomicArray<BulkItemResponse> responses,    Map<String,IndexNotFoundException> indicesThatCannotBeCreated){
      assertTrue(indexCreated);
      isExecuted=true;
    }
    @Override void createIndex(    String index,    TimeValue timeout,    ActionListener<CreateIndexResponse> listener){
      indexCreated=true;
      listener.onResponse(null);
    }
  }
class TestSingleItemBulkWriteAction extends TransportSingleItemBulkWriteAction<IndexRequest,IndexResponse> {
    TestSingleItemBulkWriteAction(    TestTransportBulkAction bulkAction){
      super(SETTINGS,IndexAction.NAME,TransportBulkActionIngestTests.this.transportService,TransportBulkActionIngestTests.this.clusterService,null,null,null,new ActionFilters(Collections.emptySet()),null,IndexRequest::new,IndexRequest::new,ThreadPool.Names.INDEX,bulkAction,null);
    }
    @Override protected IndexResponse newResponseInstance(){
      return new IndexResponse();
    }
  }
  @Before public void setupAction(){
    MockitoAnnotations.initMocks(this);
    transportService=mock(TransportService.class);
    clusterService=mock(ClusterService.class);
    localIngest=true;
    DiscoveryNode localNode=mock(DiscoveryNode.class);
    when(localNode.isIngestNode()).thenAnswer(stub -> localIngest);
    when(clusterService.localNode()).thenReturn(localNode);
    remoteNode1=mock(DiscoveryNode.class);
    remoteNode2=mock(DiscoveryNode.class);
    nodes=mock(DiscoveryNodes.class);
    ImmutableOpenMap<String,DiscoveryNode> ingestNodes=ImmutableOpenMap.<String,DiscoveryNode>builder(2).fPut("node1",remoteNode1).fPut("node2",remoteNode2).build();
    when(nodes.getIngestNodes()).thenReturn(ingestNodes);
    ClusterState state=mock(ClusterState.class);
    when(state.getNodes()).thenReturn(nodes);
    MetaData metaData=MetaData.builder().indices(ImmutableOpenMap.<String,IndexMetaData>builder().putAll(Collections.singletonMap(WITH_DEFAULT_PIPELINE,IndexMetaData.builder(WITH_DEFAULT_PIPELINE).settings(settings(Version.CURRENT).put(IndexSettings.DEFAULT_PIPELINE.getKey(),"default_pipeline").build()).numberOfShards(1).numberOfReplicas(1).build())).build()).build();
    when(state.getMetaData()).thenReturn(metaData);
    when(state.metaData()).thenReturn(metaData);
    when(clusterService.state()).thenReturn(state);
    doAnswer(invocation -> {
      ClusterChangedEvent event=mock(ClusterChangedEvent.class);
      when(event.state()).thenReturn(state);
      ((ClusterStateApplier)invocation.getArguments()[0]).applyClusterState(event);
      return null;
    }
).when(clusterService).addStateApplier(any(ClusterStateApplier.class));
    ingestService=mock(IngestService.class);
    action=new TestTransportBulkAction();
    singleItemBulkWriteAction=new TestSingleItemBulkWriteAction(action);
    reset(transportService);
  }
  public void testIngestSkipped() throws Exception {
    BulkRequest bulkRequest=new BulkRequest();
    IndexRequest indexRequest=new IndexRequest("index","type","id");
    indexRequest.source(Collections.emptyMap());
    bulkRequest.add(indexRequest);
    action.execute(null,bulkRequest,ActionListener.wrap(response -> {
    }
,exception -> {
      throw new AssertionError(exception);
    }
));
    assertTrue(action.isExecuted);
    verifyZeroInteractions(ingestService);
  }
  public void testSingleItemBulkActionIngestSkipped() throws Exception {
    IndexRequest indexRequest=new IndexRequest("index","type","id");
    indexRequest.source(Collections.emptyMap());
    singleItemBulkWriteAction.execute(null,indexRequest,ActionListener.wrap(response -> {
    }
,exception -> {
      throw new AssertionError(exception);
    }
));
    assertTrue(action.isExecuted);
    verifyZeroInteractions(ingestService);
  }
  public void testIngestLocal() throws Exception {
    Exception exception=new Exception("fake exception");
    BulkRequest bulkRequest=new BulkRequest();
    IndexRequest indexRequest1=new IndexRequest("index","type","id");
    indexRequest1.source(Collections.emptyMap());
    indexRequest1.setPipeline("testpipeline");
    IndexRequest indexRequest2=new IndexRequest("index","type","id");
    indexRequest2.source(Collections.emptyMap());
    indexRequest2.setPipeline("testpipeline");
    bulkRequest.add(indexRequest1);
    bulkRequest.add(indexRequest2);
    AtomicBoolean responseCalled=new AtomicBoolean(false);
    AtomicBoolean failureCalled=new AtomicBoolean(false);
    action.execute(null,bulkRequest,ActionListener.wrap(response -> {
      BulkItemResponse itemResponse=response.iterator().next();
      assertThat(itemResponse.getFailure().getMessage(),containsString("fake exception"));
      responseCalled.set(true);
    }
,e -> {
      assertThat(e,sameInstance(exception));
      failureCalled.set(true);
    }
));
    assertFalse(action.isExecuted);
    assertFalse(responseCalled.get());
    assertFalse(failureCalled.get());
    verify(ingestService).executeBulkRequest(bulkDocsItr.capture(),failureHandler.capture(),completionHandler.capture(),any());
    completionHandler.getValue().accept(exception);
    assertTrue(failureCalled.get());
    Iterator<DocWriteRequest<?>> req=bulkDocsItr.getValue().iterator();
    failureHandler.getValue().accept((IndexRequest)req.next(),exception);
    indexRequest2.setPipeline(IngestService.NOOP_PIPELINE_NAME);
    completionHandler.getValue().accept(null);
    assertTrue(action.isExecuted);
    assertFalse(responseCalled.get());
    verifyZeroInteractions(transportService);
  }
  public void testSingleItemBulkActionIngestLocal() throws Exception {
    Exception exception=new Exception("fake exception");
    IndexRequest indexRequest=new IndexRequest("index","type","id");
    indexRequest.source(Collections.emptyMap());
    indexRequest.setPipeline("testpipeline");
    AtomicBoolean responseCalled=new AtomicBoolean(false);
    AtomicBoolean failureCalled=new AtomicBoolean(false);
    singleItemBulkWriteAction.execute(null,indexRequest,ActionListener.wrap(response -> {
      responseCalled.set(true);
    }
,e -> {
      assertThat(e,sameInstance(exception));
      failureCalled.set(true);
    }
));
    assertFalse(action.isExecuted);
    assertFalse(responseCalled.get());
    assertFalse(failureCalled.get());
    verify(ingestService).executeBulkRequest(bulkDocsItr.capture(),failureHandler.capture(),completionHandler.capture(),any());
    completionHandler.getValue().accept(exception);
    assertTrue(failureCalled.get());
    indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME);
    completionHandler.getValue().accept(null);
    assertTrue(action.isExecuted);
    assertFalse(responseCalled.get());
    verifyZeroInteractions(transportService);
  }
  public void testIngestForward() throws Exception {
    localIngest=false;
    BulkRequest bulkRequest=new BulkRequest();
    IndexRequest indexRequest=new IndexRequest("index","type","id");
    indexRequest.source(Collections.emptyMap());
    indexRequest.setPipeline("testpipeline");
    bulkRequest.add(indexRequest);
    BulkResponse bulkResponse=mock(BulkResponse.class);
    AtomicBoolean responseCalled=new AtomicBoolean(false);
    ActionListener<BulkResponse> listener=ActionListener.wrap(response -> {
      responseCalled.set(true);
      assertSame(bulkResponse,response);
    }
,e -> {
      throw new AssertionError(e);
    }
);
    action.execute(null,bulkRequest,listener);
    verify(ingestService,never()).executeBulkRequest(any(),any(),any(),any());
    ArgumentCaptor<DiscoveryNode> node=ArgumentCaptor.forClass(DiscoveryNode.class);
    verify(transportService).sendRequest(node.capture(),eq(BulkAction.NAME),any(),remoteResponseHandler.capture());
    boolean usedNode1=node.getValue() == remoteNode1;
    if (usedNode1 == false) {
      assertSame(remoteNode2,node.getValue());
    }
    assertFalse(action.isExecuted);
    assertFalse(responseCalled.get());
    remoteResponseHandler.getValue().handleResponse(bulkResponse);
    assertTrue(responseCalled.get());
    assertFalse(action.isExecuted);
    reset(transportService);
    action.execute(null,bulkRequest,listener);
    verify(transportService).sendRequest(node.capture(),eq(BulkAction.NAME),any(),remoteResponseHandler.capture());
    if (usedNode1) {
      assertSame(remoteNode2,node.getValue());
    }
 else {
      assertSame(remoteNode1,node.getValue());
    }
  }
  public void testSingleItemBulkActionIngestForward() throws Exception {
    localIngest=false;
    IndexRequest indexRequest=new IndexRequest("index","type","id");
    indexRequest.source(Collections.emptyMap());
    indexRequest.setPipeline("testpipeline");
    IndexResponse indexResponse=mock(IndexResponse.class);
    AtomicBoolean responseCalled=new AtomicBoolean(false);
    ActionListener<IndexResponse> listener=ActionListener.wrap(response -> {
      responseCalled.set(true);
      assertSame(indexResponse,response);
    }
,e -> {
      throw new AssertionError(e);
    }
);
    singleItemBulkWriteAction.execute(null,indexRequest,listener);
    verify(ingestService,never()).executeBulkRequest(any(),any(),any(),any());
    ArgumentCaptor<DiscoveryNode> node=ArgumentCaptor.forClass(DiscoveryNode.class);
    verify(transportService).sendRequest(node.capture(),eq(BulkAction.NAME),any(),remoteResponseHandler.capture());
    boolean usedNode1=node.getValue() == remoteNode1;
    if (usedNode1 == false) {
      assertSame(remoteNode2,node.getValue());
    }
    assertFalse(action.isExecuted);
    assertFalse(responseCalled.get());
    BulkItemResponse itemResponse=new BulkItemResponse(0,DocWriteRequest.OpType.CREATE,indexResponse);
    BulkItemResponse[] bulkItemResponses=new BulkItemResponse[1];
    bulkItemResponses[0]=itemResponse;
    remoteResponseHandler.getValue().handleResponse(new BulkResponse(bulkItemResponses,0));
    assertTrue(responseCalled.get());
    assertFalse(action.isExecuted);
    reset(transportService);
    singleItemBulkWriteAction.execute(null,indexRequest,listener);
    verify(transportService).sendRequest(node.capture(),eq(BulkAction.NAME),any(),remoteResponseHandler.capture());
    if (usedNode1) {
      assertSame(remoteNode2,node.getValue());
    }
 else {
      assertSame(remoteNode1,node.getValue());
    }
  }
  public void testUseDefaultPipeline() throws Exception {
    Exception exception=new Exception("fake exception");
    IndexRequest indexRequest=new IndexRequest(WITH_DEFAULT_PIPELINE,"type","id");
    indexRequest.source(Collections.emptyMap());
    AtomicBoolean responseCalled=new AtomicBoolean(false);
    AtomicBoolean failureCalled=new AtomicBoolean(false);
    singleItemBulkWriteAction.execute(null,indexRequest,ActionListener.wrap(response -> {
      responseCalled.set(true);
    }
,e -> {
      assertThat(e,sameInstance(exception));
      failureCalled.set(true);
    }
));
    assertFalse(action.isExecuted);
    assertFalse(responseCalled.get());
    assertFalse(failureCalled.get());
    verify(ingestService).executeBulkRequest(bulkDocsItr.capture(),failureHandler.capture(),completionHandler.capture(),any());
    completionHandler.getValue().accept(exception);
    assertTrue(failureCalled.get());
    indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME);
    completionHandler.getValue().accept(null);
    assertTrue(action.isExecuted);
    assertFalse(responseCalled.get());
    verifyZeroInteractions(transportService);
  }
  public void testCreateIndexBeforeRunPipeline() throws Exception {
    Exception exception=new Exception("fake exception");
    IndexRequest indexRequest=new IndexRequest("missing_index","type","id");
    indexRequest.setPipeline("testpipeline");
    indexRequest.source(Collections.emptyMap());
    AtomicBoolean responseCalled=new AtomicBoolean(false);
    AtomicBoolean failureCalled=new AtomicBoolean(false);
    action.needToCheck=true;
    action.indexCreated=false;
    singleItemBulkWriteAction.execute(null,indexRequest,ActionListener.wrap(response -> responseCalled.set(true),e -> {
      assertThat(e,sameInstance(exception));
      failureCalled.set(true);
    }
));
    assertFalse(action.isExecuted);
    assertFalse(responseCalled.get());
    assertFalse(failureCalled.get());
    verify(ingestService).executeBulkRequest(bulkDocsItr.capture(),failureHandler.capture(),completionHandler.capture(),any());
    completionHandler.getValue().accept(exception);
    assertTrue(failureCalled.get());
    indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME);
    completionHandler.getValue().accept(null);
    assertTrue(action.isExecuted);
    assertFalse(responseCalled.get());
    verifyZeroInteractions(transportService);
  }
}
