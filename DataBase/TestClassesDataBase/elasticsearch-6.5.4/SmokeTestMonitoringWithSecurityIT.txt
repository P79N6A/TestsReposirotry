/** 
 * This test checks that a Monitoring's HTTP exporter correctly exports to a monitoring cluster protected by security with HTTPS/SSL. It sets up a cluster with Monitoring and Security configured with SSL. Once started, an HTTP exporter is activated and it exports data locally over HTTPS/SSL. The test then uses a transport client to check that the data have been correctly received and indexed in the cluster.
 */
public class SmokeTestMonitoringWithSecurityIT extends ESIntegTestCase {
  /** 
 * A JUnit class level rule that runs after the AfterClass method in  {@link ESIntegTestCase}, which stops the cluster. After the cluster is stopped, there are a few netty threads that can linger, so we wait for them to finish otherwise these lingering threads can intermittently trigger the thread leak detector
 */
  @ClassRule public static final ExternalResource STOP_NETTY_RESOURCE=new ExternalResource(){
    @Override protected void after(){
      try {
        GlobalEventExecutor.INSTANCE.awaitInactivity(5,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
catch (      IllegalStateException e) {
        if (e.getMessage().equals("thread was not started") == false) {
          throw e;
        }
      }
      try {
        ThreadDeathWatcher.awaitInactivity(5,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
;
  private static final String USER="test_user";
  private static final String PASS="x-pack-test-password";
  private static final String MONITORING_PATTERN=".monitoring-*";
  @Override protected Collection<Class<? extends Plugin>> transportClientPlugins(){
    return Collections.singletonList(XPackPlugin.class);
  }
  @Override protected Settings externalClusterClientSettings(){
    return Settings.builder().put(SecurityField.USER_SETTING.getKey(),USER + ":" + PASS).put(NetworkModule.TRANSPORT_TYPE_KEY,SecurityField.NAME4).build();
  }
  @Before public void enableExporter() throws Exception {
    Settings exporterSettings=Settings.builder().put("xpack.monitoring.collection.enabled",true).put("xpack.monitoring.exporters._http.enabled",true).put("xpack.monitoring.exporters._http.host","https://" + randomNodeHttpAddress()).build();
    assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(exporterSettings));
  }
  @After public void disableExporter(){
    Settings exporterSettings=Settings.builder().putNull("xpack.monitoring.collection.enabled").putNull("xpack.monitoring.exporters._http.enabled").putNull("xpack.monitoring.exporters._http.host").build();
    assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(exporterSettings));
  }
  private boolean getMonitoringUsageExportersDefined() throws Exception {
    final XPackUsageResponse usageResponse=new XPackUsageRequestBuilder(client()).execute().get();
    final Optional<MonitoringFeatureSetUsage> monitoringUsage=usageResponse.getUsages().stream().filter(usage -> usage instanceof MonitoringFeatureSetUsage).map(usage -> (MonitoringFeatureSetUsage)usage).findFirst();
    assertThat("Monitoring feature set does not exist",monitoringUsage.isPresent(),is(true));
    return monitoringUsage.get().getExporters().isEmpty() == false;
  }
  @AwaitsFix(bugUrl="https://github.com/elastic/elasticsearch/issues/31940") public void testHTTPExporterWithSSL() throws Exception {
    assertBusy(() -> assertThat("[_http] exporter is not defined",getMonitoringUsageExportersDefined(),is(true)));
    assertBusy(() -> {
      GetIndexTemplatesResponse response=client().admin().indices().prepareGetTemplates(MONITORING_PATTERN).get();
      assertThat(response.getIndexTemplates().size(),greaterThanOrEqualTo(2));
    }
);
    assertBusy(() -> {
      try {
        assertThat(client().admin().indices().prepareExists(MONITORING_PATTERN).get().isExists(),equalTo(true));
      }
 catch (      Exception e) {
        fail("exception when checking for monitoring documents: " + e.getMessage());
      }
    }
);
    ensureYellowAndNoInitializingShards(MONITORING_PATTERN);
    assertBusy(() -> {
      try {
        assertThat(client().prepareSearch(MONITORING_PATTERN).setSize(0).get().getHits().getTotalHits(),greaterThan(0L));
      }
 catch (      Exception e) {
        fail("exception when checking for monitoring documents: " + e.getMessage());
      }
    }
);
  }
  private String randomNodeHttpAddress(){
    List<NodeInfo> nodes=client().admin().cluster().prepareNodesInfo().clear().setHttp(true).get().getNodes();
    assertThat(nodes.size(),greaterThan(0));
    InetSocketAddress[] httpAddresses=new InetSocketAddress[nodes.size()];
    for (int i=0; i < nodes.size(); i++) {
      httpAddresses[i]=nodes.get(i).getHttp().address().publishAddress().address();
    }
    return NetworkAddress.format(randomFrom(httpAddresses));
  }
}
