/** 
 * Wrappers and convenience methods for common filesystem operations
 */
public class FileUtils {
  public static List<Path> lsGlob(  Path directory,  String glob){
    List<Path> paths=new ArrayList<>();
    try (DirectoryStream<Path> stream=Files.newDirectoryStream(directory,glob)){
      for (      Path path : stream) {
        paths.add(path);
      }
      return paths;
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  public static void rm(  Path... paths){
    try {
      IOUtils.rm(paths);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  public static Path mkdir(  Path path){
    try {
      return Files.createDirectories(path);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  public static Path cp(  Path source,  Path target){
    try {
      return Files.copy(source,target);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  public static Path mv(  Path source,  Path target){
    try {
      return Files.move(source,target);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  public static void append(  Path file,  String text){
    try (BufferedWriter writer=Files.newBufferedWriter(file,StandardCharsets.UTF_8,StandardOpenOption.CREATE,StandardOpenOption.APPEND)){
      writer.write(text);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  public static String slurp(  Path file){
    try {
      return String.join("\n",Files.readAllLines(file,StandardCharsets.UTF_8));
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  /** 
 * Gets the owner of a file in a way that should be supported by all filesystems that have a concept of file owner
 */
  public static String getFileOwner(  Path path){
    try {
      FileOwnerAttributeView view=Files.getFileAttributeView(path,FileOwnerAttributeView.class);
      return view.getOwner().getName();
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  /** 
 * Gets attributes that are supported by all filesystems
 */
  public static BasicFileAttributes getBasicFileAttributes(  Path path){
    try {
      return Files.readAttributes(path,BasicFileAttributes.class);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  /** 
 * Gets attributes that are supported by posix filesystems
 */
  public static PosixFileAttributes getPosixFileAttributes(  Path path){
    try {
      return Files.readAttributes(path,PosixFileAttributes.class);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  public static Path getTempDir(){
    return Paths.get("/tmp");
  }
  public static Path getDefaultArchiveInstallPath(){
    return getTempDir().resolve("elasticsearch");
  }
  public static String getCurrentVersion(){
    return slurp(getPackagingArchivesDir().resolve("version"));
  }
  public static Path getPackagingArchivesDir(){
    String fromEnv=System.getenv("PACKAGING_ARCHIVES");
    assertThat(fromEnv,not(isEmptyOrNullString()));
    return Paths.get(fromEnv);
  }
  public static Path getDistributionFile(  Distribution distribution){
    return getDistributionFile(distribution,getCurrentVersion());
  }
  public static Path getDistributionFile(  Distribution distribution,  String version){
    return getPackagingArchivesDir().resolve(distribution.filename(version));
  }
  public static void assertPathsExist(  Path... paths){
    Arrays.stream(paths).forEach(path -> assertTrue(path + " should exist",Files.exists(path)));
  }
  public static void assertPathsDontExist(  Path... paths){
    Arrays.stream(paths).forEach(path -> assertFalse(path + " should not exist",Files.exists(path)));
  }
}
