public class FileBasedUnicastHostsProviderTests extends ESTestCase {
  private boolean legacyLocation;
  private ThreadPool threadPool;
  private ExecutorService executorService;
  private MockTransportService transportService;
  private Path configPath;
  @Before public void setUp() throws Exception {
    super.setUp();
    threadPool=new TestThreadPool(FileBasedUnicastHostsProviderTests.class.getName());
    executorService=Executors.newSingleThreadExecutor();
  }
  @After public void tearDown() throws Exception {
    try {
      terminate(executorService);
    }
  finally {
      try {
        terminate(threadPool);
      }
  finally {
        super.tearDown();
      }
    }
  }
  @Before public void createTransportSvc(){
    final MockTcpTransport transport=new MockTcpTransport(Settings.EMPTY,threadPool,BigArrays.NON_RECYCLING_INSTANCE,new NoneCircuitBreakerService(),new NamedWriteableRegistry(Collections.emptyList()),new NetworkService(Collections.emptyList())){
      @Override public BoundTransportAddress boundAddress(){
        return new BoundTransportAddress(new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(),9300)},new TransportAddress(InetAddress.getLoopbackAddress(),9300));
      }
    }
;
    transportService=new MockTransportService(Settings.EMPTY,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,null);
  }
  public void testBuildDynamicNodes() throws Exception {
    final List<String> hostEntries=Arrays.asList("#comment, should be ignored","192.168.0.1","192.168.0.2:9305","255.255.23.15");
    final List<TransportAddress> nodes=setupAndRunHostProvider(hostEntries);
    assertEquals(hostEntries.size() - 1,nodes.size());
    assertEquals("192.168.0.1",nodes.get(0).getAddress());
    assertEquals(9300,nodes.get(0).getPort());
    assertEquals("192.168.0.2",nodes.get(1).getAddress());
    assertEquals(9305,nodes.get(1).getPort());
    assertEquals("255.255.23.15",nodes.get(2).getAddress());
    assertEquals(9300,nodes.get(2).getPort());
  }
  public void testBuildDynamicNodesLegacyLocation() throws Exception {
    legacyLocation=true;
    testBuildDynamicNodes();
    assertDeprecatedLocationWarning();
  }
  public void testEmptyUnicastHostsFile() throws Exception {
    final List<String> hostEntries=Collections.emptyList();
    final List<TransportAddress> addresses=setupAndRunHostProvider(hostEntries);
    assertEquals(0,addresses.size());
  }
  public void testEmptyUnicastHostsFileLegacyLocation() throws Exception {
    legacyLocation=true;
    testEmptyUnicastHostsFile();
    assertDeprecatedLocationWarning();
  }
  public void testUnicastHostsDoesNotExist(){
    final Settings settings=Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(),createTempDir()).build();
    final FileBasedUnicastHostsProvider provider=new FileBasedUnicastHostsProvider(settings,createTempDir().toAbsolutePath());
    final List<TransportAddress> addresses=provider.buildDynamicHosts((hosts,limitPortCounts) -> UnicastZenPing.resolveHostsLists(executorService,logger,hosts,limitPortCounts,transportService,TimeValue.timeValueSeconds(10)));
    assertEquals(0,addresses.size());
  }
  public void testInvalidHostEntries() throws Exception {
    final List<String> hostEntries=Arrays.asList("192.168.0.1:9300:9300");
    final List<TransportAddress> addresses=setupAndRunHostProvider(hostEntries);
    assertEquals(0,addresses.size());
  }
  public void testInvalidHostEntriesLegacyLocation() throws Exception {
    legacyLocation=true;
    testInvalidHostEntries();
    assertDeprecatedLocationWarning();
  }
  public void testSomeInvalidHostEntries() throws Exception {
    final List<String> hostEntries=Arrays.asList("192.168.0.1:9300:9300","192.168.0.1:9301");
    final List<TransportAddress> addresses=setupAndRunHostProvider(hostEntries);
    assertEquals(1,addresses.size());
    assertEquals("192.168.0.1",addresses.get(0).getAddress());
    assertEquals(9301,addresses.get(0).getPort());
  }
  public void testSomeInvalidHostEntriesLegacyLocation() throws Exception {
    legacyLocation=true;
    testSomeInvalidHostEntries();
    assertDeprecatedLocationWarning();
  }
  private List<TransportAddress> setupAndRunHostProvider(  final List<String> hostEntries) throws IOException {
    final Path homeDir=createTempDir();
    final Settings settings=Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(),homeDir).build();
    if (randomBoolean()) {
      configPath=homeDir.resolve("config");
    }
 else {
      configPath=createTempDir();
    }
    final Path discoveryFilePath=legacyLocation ? configPath.resolve("discovery-file") : configPath;
    Files.createDirectories(discoveryFilePath);
    final Path unicastHostsPath=discoveryFilePath.resolve(UNICAST_HOSTS_FILE);
    try (BufferedWriter writer=Files.newBufferedWriter(unicastHostsPath)){
      writer.write(String.join("\n",hostEntries));
    }
     return new FileBasedUnicastHostsProvider(settings,configPath).buildDynamicHosts((hosts,limitPortCounts) -> UnicastZenPing.resolveHostsLists(executorService,logger,hosts,limitPortCounts,transportService,TimeValue.timeValueSeconds(10)));
  }
  private void assertDeprecatedLocationWarning(){
    assertWarnings("Found dynamic hosts list at [" + configPath.resolve("discovery-file").resolve(UNICAST_HOSTS_FILE) + "] but this path is deprecated. This list should be at ["+ configPath.resolve(UNICAST_HOSTS_FILE)+ "] instead. Support for the deprecated path will be removed in future.");
  }
}
