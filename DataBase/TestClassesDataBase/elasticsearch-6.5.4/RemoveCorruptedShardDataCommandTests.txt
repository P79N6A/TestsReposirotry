public class RemoveCorruptedShardDataCommandTests extends IndexShardTestCase {
  private ShardId shardId;
  private ShardRouting routing;
  private Path dataDir;
  private Environment environment;
  private Settings settings;
  private ShardPath shardPath;
  private IndexMetaData indexMetaData;
  private IndexShard indexShard;
  private Path translogPath;
  private Path indexPath;
  @Before public void setup() throws IOException {
    shardId=new ShardId("index0","_na_",0);
    final String nodeId=randomAlphaOfLength(10);
    routing=TestShardRouting.newShardRouting(shardId,nodeId,true,ShardRoutingState.INITIALIZING,RecoverySource.EmptyStoreRecoverySource.INSTANCE);
    dataDir=createTempDir();
    environment=TestEnvironment.newEnvironment(Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(),dataDir).putList(Environment.PATH_DATA_SETTING.getKey(),dataDir.toAbsolutePath().toString()).build());
    final Path path=NodeEnvironment.resolveNodePath(dataDir,0);
    Files.createDirectories(path);
    settings=Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED,Version.CURRENT).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,1).put(MergePolicyConfig.INDEX_MERGE_ENABLED,false).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,0).build();
    final NodeEnvironment.NodePath nodePath=new NodeEnvironment.NodePath(path);
    shardPath=new ShardPath(false,nodePath.resolve(shardId),nodePath.resolve(shardId),shardId);
    final IndexMetaData.Builder metaData=IndexMetaData.builder(routing.getIndexName()).settings(settings).primaryTerm(0,randomIntBetween(1,100)).putMapping("_doc","{ \"properties\": {} }");
    indexMetaData=metaData.build();
    indexShard=newStartedShard(p -> newShard(routing,shardPath,indexMetaData,null,null,new InternalEngineFactory(),() -> {
    }
,EMPTY_EVENT_LISTENER),true);
    translogPath=shardPath.resolveTranslog();
    indexPath=shardPath.resolveIndex();
  }
  public void testShardLock() throws Exception {
    indexDocs(indexShard,true);
    final RemoveCorruptedShardDataCommand command=new RemoveCorruptedShardDataCommand();
    final MockTerminal t=new MockTerminal();
    final OptionParser parser=command.getParser();
    try {
      final OptionSet options=parser.parse("-d",indexPath.toString());
      command.execute(t,options,environment);
      fail("expected the command to fail not being able to acquire the lock");
    }
 catch (    Exception e) {
      assertThat(e.getMessage(),containsString("Failed to lock shard's directory"));
    }
    closeShards(indexShard);
    try {
      final OptionSet options=parser.parse("-d",indexPath.toString());
      command.execute(t,options,environment);
      fail("expected the command to fail not being able to find a corrupt file marker");
    }
 catch (    ElasticsearchException e) {
      assertThat(e.getMessage(),startsWith("Shard does not seem to be corrupted at"));
      assertThat(t.getOutput(),containsString("Lucene index is clean at"));
    }
  }
  public void testCorruptedIndex() throws Exception {
    final int numDocs=indexDocs(indexShard,true);
    closeShards(indexShard);
    final boolean corruptSegments=randomBoolean();
    CorruptionUtils.corruptIndex(random(),indexPath,corruptSegments);
    final IndexShard corruptedShard=reopenIndexShard(true);
    allowShardFailures();
    expectThrows(IndexShardRecoveryException.class,() -> newStartedShard(p -> corruptedShard,true));
    closeShards(corruptedShard);
    final RemoveCorruptedShardDataCommand command=new RemoveCorruptedShardDataCommand();
    final MockTerminal t=new MockTerminal();
    final OptionParser parser=command.getParser();
    t.addTextInput("n");
    final OptionSet options=parser.parse("-d",indexPath.toString());
    t.setVerbosity(Terminal.Verbosity.VERBOSE);
    try {
      command.execute(t,options,environment);
      fail();
    }
 catch (    ElasticsearchException e) {
      if (corruptSegments) {
        assertThat(e.getMessage(),is("Index is unrecoverable"));
      }
 else {
        assertThat(e.getMessage(),containsString("aborted by user"));
      }
    }
    logger.info("--> output:\n{}",t.getOutput());
    if (corruptSegments == false) {
      t.addTextInput("y");
      command.execute(t,options,environment);
      final String output=t.getOutput();
      logger.info("--> output:\n{}",output);
      failOnShardFailures();
      final IndexShard newShard=newStartedShard(p -> reopenIndexShard(false),true);
      final Set<String> shardDocUIDs=getShardDocUIDs(newShard);
      final Pattern pattern=Pattern.compile("Corrupted Lucene index segments found -\\s+(?<docs>\\d+) documents will be lost.");
      final Matcher matcher=pattern.matcher(output);
      assertThat(matcher.find(),equalTo(true));
      final int expectedNumDocs=numDocs - Integer.parseInt(matcher.group("docs"));
      assertThat(shardDocUIDs.size(),equalTo(expectedNumDocs));
      closeShards(newShard);
    }
  }
  public void testCorruptedTranslog() throws Exception {
    final int numDocsToKeep=indexDocs(indexShard,false);
    closeShards(indexShard);
    TestTranslog.corruptRandomTranslogFile(logger,random(),Arrays.asList(translogPath));
    final IndexShard corruptedShard=reopenIndexShard(true);
    allowShardFailures();
    final Exception exception=expectThrows(Exception.class,() -> newStartedShard(p -> corruptedShard,true));
    final Throwable cause=exception.getCause() instanceof EngineException ? exception.getCause().getCause() : exception.getCause();
    assertThat(cause,instanceOf(TranslogCorruptedException.class));
    closeShards(corruptedShard);
    final RemoveCorruptedShardDataCommand command=new RemoveCorruptedShardDataCommand();
    final MockTerminal t=new MockTerminal();
    final OptionParser parser=command.getParser();
    final OptionSet options=parser.parse("-d",translogPath.toString());
    t.addTextInput("n");
    t.setVerbosity(Terminal.Verbosity.VERBOSE);
    try {
      command.execute(t,options,environment);
      fail();
    }
 catch (    ElasticsearchException e) {
      assertThat(e.getMessage(),containsString("aborted by user"));
      assertThat(t.getOutput(),containsString("Continue and remove corrupted data from the shard ?"));
    }
    logger.info("--> output:\n{}",t.getOutput());
    t.reset();
    t.addTextInput("y");
    command.execute(t,options,environment);
    final String output=t.getOutput();
    logger.info("--> output:\n{}",output);
    failOnShardFailures();
    final IndexShard newShard=newStartedShard(p -> reopenIndexShard(false),true);
    final Set<String> shardDocUIDs=getShardDocUIDs(newShard);
    assertThat(shardDocUIDs.size(),equalTo(numDocsToKeep));
    closeShards(newShard);
  }
  public void testCorruptedBothIndexAndTranslog() throws Exception {
    final int numDocsToKeep=indexDocs(indexShard,false);
    closeShards(indexShard);
    CorruptionUtils.corruptIndex(random(),indexPath,false);
    final IndexShard corruptedShard=reopenIndexShard(true);
    allowShardFailures();
    expectThrows(IndexShardRecoveryException.class,() -> newStartedShard(p -> corruptedShard,true));
    closeShards(corruptedShard);
    TestTranslog.corruptRandomTranslogFile(logger,random(),Arrays.asList(translogPath));
    final RemoveCorruptedShardDataCommand command=new RemoveCorruptedShardDataCommand();
    final MockTerminal t=new MockTerminal();
    final OptionParser parser=command.getParser();
    final OptionSet options=parser.parse("-d",translogPath.toString());
    t.addTextInput("n");
    t.addTextInput("n");
    t.setVerbosity(Terminal.Verbosity.VERBOSE);
    try {
      command.execute(t,options,environment);
      fail();
    }
 catch (    ElasticsearchException e) {
      assertThat(e.getMessage(),containsString("aborted by user"));
      assertThat(t.getOutput(),containsString("Continue and remove corrupted data from the shard ?"));
    }
    logger.info("--> output:\n{}",t.getOutput());
    t.reset();
    t.addTextInput("y");
    command.execute(t,options,environment);
    final String output=t.getOutput();
    logger.info("--> output:\n{}",output);
    failOnShardFailures();
    final IndexShard newShard=newStartedShard(p -> reopenIndexShard(false),true);
    final Set<String> shardDocUIDs=getShardDocUIDs(newShard);
    final Pattern pattern=Pattern.compile("Corrupted Lucene index segments found -\\s+(?<docs>\\d+) documents will be lost.");
    final Matcher matcher=pattern.matcher(output);
    assertThat(matcher.find(),equalTo(true));
    final int expectedNumDocs=numDocsToKeep - Integer.parseInt(matcher.group("docs"));
    assertThat(shardDocUIDs.size(),equalTo(expectedNumDocs));
    closeShards(newShard);
  }
  public void testResolveIndexDirectory() throws Exception {
    indexDoc(indexShard,"_doc","0","{}");
    flushShard(indexShard,true);
    writeIndexState();
    closeShards(indexShard);
    final RemoveCorruptedShardDataCommand command=new RemoveCorruptedShardDataCommand();
    final OptionParser parser=command.getParser();
    final OptionSet options=parser.parse("--index",shardId.getIndex().getName(),"--shard-id",Integer.toString(shardId.id()));
    command.findAndProcessShardPath(options,environment,shardPath -> assertThat(shardPath.resolveIndex(),equalTo(indexPath)));
    final OptionSet options2=parser.parse("--dir",indexPath.toAbsolutePath().toString());
    command.findAndProcessShardPath(options2,environment,shardPath -> assertThat(shardPath.resolveIndex(),equalTo(indexPath)));
  }
  private IndexShard reopenIndexShard(  boolean corrupted) throws IOException {
    final ShardRouting shardRouting=ShardRoutingHelper.initWithSameId(indexShard.routingEntry(),RecoverySource.ExistingStoreRecoverySource.INSTANCE);
    final IndexMetaData metaData=IndexMetaData.builder(indexMetaData).settings(Settings.builder().put(indexShard.indexSettings().getSettings()).put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(),"checksum")).build();
    CheckedFunction<IndexSettings,Store,IOException> storeProvider=corrupted == false ? null : indexSettings -> {
      final ShardId shardId=shardPath.getShardId();
      final BaseDirectoryWrapper baseDirectoryWrapper=newFSDirectory(shardPath.resolveIndex());
      baseDirectoryWrapper.setCheckIndexOnClose(false);
      return new Store(shardId,indexSettings,baseDirectoryWrapper,new DummyShardLock(shardId));
    }
;
    return newShard(shardRouting,shardPath,metaData,storeProvider,null,indexShard.engineFactory,indexShard.getGlobalCheckpointSyncer(),EMPTY_EVENT_LISTENER);
  }
  private int indexDocs(  IndexShard indexShard,  boolean flushLast) throws IOException {
    int numDocs=0;
    int numDocsToKeep=0;
    for (int i=0, attempts=randomIntBetween(5,10); i < attempts; i++) {
      final int numExtraDocs=between(10,100);
      for (long j=0; j < numExtraDocs; j++) {
        indexDoc(indexShard,"_doc",Long.toString(numDocs + j),"{}");
      }
      numDocs+=numExtraDocs;
      if (flushLast || i < attempts - 1) {
        numDocsToKeep+=numExtraDocs;
        flushShard(indexShard,true);
      }
    }
    logger.info("--> indexed {} docs, {} to keep",numDocs,numDocsToKeep);
    writeIndexState();
    return numDocsToKeep;
  }
  private void writeIndexState() throws IOException {
    try (NodeEnvironment nodeEnvironment=new NodeEnvironment(environment.settings(),environment,nId -> {
    }
)){
      final Path[] paths=nodeEnvironment.indexPaths(indexMetaData.getIndex());
      IndexMetaData.FORMAT.write(indexMetaData,paths);
      logger.info("--> index metadata persisted to {} ",Arrays.toString(paths));
    }
   }
}
