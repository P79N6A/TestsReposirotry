public abstract class KerberosRealmTestCase extends ESTestCase {
  protected Path dir;
  protected ThreadPool threadPool;
  protected Settings globalSettings;
  protected ResourceWatcherService resourceWatcherService;
  protected Settings settings;
  protected RealmConfig config;
  protected KerberosTicketValidator mockKerberosTicketValidator;
  protected NativeRoleMappingStore mockNativeRoleMappingStore;
  protected XPackLicenseState licenseState;
  protected static final Set<String> roles=Sets.newHashSet("admin","kibana_user");
  @Before public void setup() throws Exception {
    threadPool=new TestThreadPool("kerb realm tests");
    resourceWatcherService=new ResourceWatcherService(Settings.EMPTY,threadPool);
    dir=createTempDir();
    globalSettings=Settings.builder().put("path.home",dir).build();
    settings=buildKerberosRealmSettings(writeKeyTab(dir.resolve("key.keytab"),"asa").toString(),100,"10m",true,randomBoolean());
    licenseState=mock(XPackLicenseState.class);
    when(licenseState.isAuthorizationRealmAllowed()).thenReturn(true);
  }
  @After public void shutdown() throws InterruptedException {
    resourceWatcherService.stop();
    terminate(threadPool);
  }
  protected void mockKerberosTicketValidator(  final byte[] decodedTicket,  final Path keytabPath,  final boolean krbDebug,  final Tuple<String,String> value,  final Exception e){
    assert value != null || e != null;
    doAnswer((i) -> {
      ActionListener<Tuple<String,String>> listener=(ActionListener<Tuple<String,String>>)i.getArguments()[3];
      if (e != null) {
        listener.onFailure(e);
      }
 else {
        listener.onResponse(value);
      }
      return null;
    }
).when(mockKerberosTicketValidator).validateTicket(aryEq(decodedTicket),eq(keytabPath),eq(krbDebug),any(ActionListener.class));
  }
  protected void assertSuccessAuthenticationResult(  final User expectedUser,  final String outToken,  final AuthenticationResult result){
    assertThat(result,is(notNullValue()));
    assertThat(result.getStatus(),is(equalTo(AuthenticationResult.Status.SUCCESS)));
    assertThat(result.getUser(),is(equalTo(expectedUser)));
    final Map<String,List<String>> responseHeaders=threadPool.getThreadContext().getResponseHeaders();
    assertThat(responseHeaders,is(notNullValue()));
    assertThat(responseHeaders.get(KerberosAuthenticationToken.WWW_AUTHENTICATE).get(0),is(equalTo(KerberosAuthenticationToken.NEGOTIATE_AUTH_HEADER_PREFIX + outToken)));
  }
  protected KerberosRealm createKerberosRealm(  final String... userForRoleMapping){
    return createKerberosRealm(Collections.emptyList(),userForRoleMapping);
  }
  protected KerberosRealm createKerberosRealm(  final List<Realm> delegatedRealms,  final String... userForRoleMapping){
    config=new RealmConfig("test-kerb-realm",settings,globalSettings,TestEnvironment.newEnvironment(globalSettings),new ThreadContext(globalSettings));
    mockNativeRoleMappingStore=roleMappingStore(Arrays.asList(userForRoleMapping));
    mockKerberosTicketValidator=mock(KerberosTicketValidator.class);
    final KerberosRealm kerberosRealm=new KerberosRealm(config,mockNativeRoleMappingStore,mockKerberosTicketValidator,threadPool,null);
    Collections.shuffle(delegatedRealms,random());
    kerberosRealm.initialize(delegatedRealms,licenseState);
    return kerberosRealm;
  }
  @SuppressWarnings("unchecked") protected NativeRoleMappingStore roleMappingStore(  final List<String> userNames){
    final List<String> expectedUserNames=userNames.stream().map(this::maybeRemoveRealmName).collect(Collectors.toList());
    final Client mockClient=mock(Client.class);
    when(mockClient.threadPool()).thenReturn(threadPool);
    when(mockClient.settings()).thenReturn(settings);
    final NativeRoleMappingStore store=new NativeRoleMappingStore(Settings.EMPTY,mockClient,mock(SecurityIndexManager.class));
    final NativeRoleMappingStore roleMapper=spy(store);
    doAnswer(invocation -> {
      final UserRoleMapper.UserData userData=(UserRoleMapper.UserData)invocation.getArguments()[0];
      final ActionListener<Set<String>> listener=(ActionListener<Set<String>>)invocation.getArguments()[1];
      if (expectedUserNames.contains(userData.getUsername())) {
        listener.onResponse(roles);
      }
 else {
        listener.onFailure(Exceptions.authorizationError("Expected UPN '" + expectedUserNames + "' but was '"+ userData.getUsername()+ "'"));
      }
      return null;
    }
).when(roleMapper).resolveRoles(any(UserRoleMapper.UserData.class),any(ActionListener.class));
    return roleMapper;
  }
  protected String randomPrincipalName(){
    final StringBuilder principalName=new StringBuilder();
    principalName.append(randomAlphaOfLength(5));
    final boolean withInstance=randomBoolean();
    if (withInstance) {
      principalName.append("/").append(randomAlphaOfLength(5));
    }
    principalName.append("@");
    principalName.append(randomAlphaOfLength(5).toUpperCase(Locale.ROOT));
    return principalName.toString();
  }
  /** 
 * Usually principal names are in the form 'user/instance@REALM'. This method removes '@REALM' part from the principal name if {@link KerberosRealmSettings#SETTING_REMOVE_REALM_NAME} is {@code true} elsewill return the input string.
 * @param principalName user principal name
 * @return username after removal of realm
 */
  protected String maybeRemoveRealmName(  final String principalName){
    if (KerberosRealmSettings.SETTING_REMOVE_REALM_NAME.get(settings)) {
      int foundAtIndex=principalName.indexOf('@');
      if (foundAtIndex > 0) {
        return principalName.substring(0,foundAtIndex);
      }
    }
    return principalName;
  }
  /** 
 * Extracts and returns realm part from the principal name.
 * @param principalName user principal name
 * @return realm name if found else returns {@code null}
 */
  protected String realmName(  final String principalName){
    String[] values=principalName.split("@");
    if (values.length > 1) {
      return values[1];
    }
    return null;
  }
  /** 
 * Write content to provided keytab file.
 * @param keytabPath {@link Path} to keytab file.
 * @param content Content for keytab
 * @return key tab path
 * @throws IOException if I/O error occurs while writing keytab file
 */
  public static Path writeKeyTab(  final Path keytabPath,  final String content) throws IOException {
    try (BufferedWriter bufferedWriter=Files.newBufferedWriter(keytabPath,StandardCharsets.US_ASCII)){
      bufferedWriter.write(Strings.isNullOrEmpty(content) ? "test-content" : content);
    }
     return keytabPath;
  }
  /** 
 * Build kerberos realm settings with default config and given keytab
 * @param keytabPath key tab file path
 * @return {@link Settings} for kerberos realm
 */
  public static Settings buildKerberosRealmSettings(  final String keytabPath){
    return buildKerberosRealmSettings(keytabPath,100,"10m",true,false);
  }
  /** 
 * Build kerberos realm settings
 * @param keytabPath key tab file path
 * @param maxUsersInCache max users to be maintained in cache
 * @param cacheTTL time to live for cached entries
 * @param enableDebugging for krb5 logs
 * @param removeRealmName {@code true} if we want to remove realm name from the username of form 'user@REALM'
 * @return {@link Settings} for kerberos realm
 */
  public static Settings buildKerberosRealmSettings(  final String keytabPath,  final int maxUsersInCache,  final String cacheTTL,  final boolean enableDebugging,  final boolean removeRealmName){
    final Settings.Builder builder=Settings.builder().put(KerberosRealmSettings.HTTP_SERVICE_KEYTAB_PATH.getKey(),keytabPath).put(KerberosRealmSettings.CACHE_MAX_USERS_SETTING.getKey(),maxUsersInCache).put(KerberosRealmSettings.CACHE_TTL_SETTING.getKey(),cacheTTL).put(KerberosRealmSettings.SETTING_KRB_DEBUG_ENABLE.getKey(),enableDebugging).put(KerberosRealmSettings.SETTING_REMOVE_REALM_NAME.getKey(),removeRealmName);
    return builder.build();
  }
}
