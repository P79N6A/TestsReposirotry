/** 
 * A disruption that prevents time from advancing on nodes. This is needed to allow time sensitive tests to have full control of time. This disruption requires  {@link ClockMock} being available on the nodes.
 */
private static class TimeFreezeDisruption implements ServiceDisruptionScheme {
  private InternalTestCluster cluster;
  private boolean frozen;
  @Override public void applyToCluster(  InternalTestCluster cluster){
    this.cluster=cluster;
  }
  @Override public void removeFromCluster(  InternalTestCluster cluster){
    stopDisrupting();
  }
  @Override public void removeAndEnsureHealthy(  InternalTestCluster cluster){
    stopDisrupting();
  }
  @Override public synchronized void applyToNode(  String node,  InternalTestCluster cluster){
    if (frozen) {
      ((ClockMock)cluster.getInstance(Clock.class,node)).freeze();
    }
  }
  @Override public void removeFromNode(  String node,  InternalTestCluster cluster){
    ((ClockMock)cluster.getInstance(Clock.class,node)).unfreeze();
  }
  @Override public synchronized void startDisrupting(){
    frozen=true;
    for (    String node : cluster.getNodeNames()) {
      applyToNode(node,cluster);
    }
  }
  @Override public void stopDisrupting(){
    frozen=false;
    for (    String node : cluster.getNodeNames()) {
      removeFromNode(node,cluster);
    }
  }
  @Override public void testClusterClosed(){
  }
  @Override public TimeValue expectedTimeToHeal(){
    return TimeValue.ZERO;
  }
  @Override public String toString(){
    return "time frozen";
  }
}
