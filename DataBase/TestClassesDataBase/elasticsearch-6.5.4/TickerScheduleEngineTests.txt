public class TickerScheduleEngineTests extends ESTestCase {
  private TickerScheduleTriggerEngine engine;
  protected ClockMock clock=ClockMock.frozen();
  @Before public void init() throws Exception {
    engine=createEngine();
  }
  private TickerScheduleTriggerEngine createEngine(){
    Settings settings=Settings.EMPTY;
    if (usually()) {
      settings=Settings.builder().put(TickerScheduleTriggerEngine.TICKER_INTERVAL_SETTING.getKey(),"10ms").build();
    }
    return new TickerScheduleTriggerEngine(settings,mock(ScheduleRegistry.class),clock);
  }
  private void advanceClockIfNeeded(  DateTime newCurrentDateTime){
    clock.setTime(newCurrentDateTime);
  }
  @After public void cleanup() throws Exception {
    engine.stop();
  }
  public void testStart() throws Exception {
    int count=randomIntBetween(2,5);
    final CountDownLatch firstLatch=new CountDownLatch(count);
    final CountDownLatch secondLatch=new CountDownLatch(count);
    List<Watch> watches=new ArrayList<>();
    for (int i=0; i < count; i++) {
      watches.add(createWatch(String.valueOf(i),interval("1s")));
    }
    final BitSet bits=new BitSet(count);
    engine.register(new Consumer<Iterable<TriggerEvent>>(){
      @Override public void accept(      Iterable<TriggerEvent> events){
        for (        TriggerEvent event : events) {
          int index=Integer.parseInt(event.jobName());
          if (!bits.get(index)) {
            logger.info("job [{}] first fire",index);
            bits.set(index);
            firstLatch.countDown();
          }
 else {
            logger.info("job [{}] second fire",index);
            secondLatch.countDown();
          }
        }
      }
    }
);
    engine.start(watches);
    advanceClockIfNeeded(new DateTime(clock.millis(),UTC).plusMillis(1100));
    if (!firstLatch.await(3 * count,TimeUnit.SECONDS)) {
      fail("waiting too long for all watches to be triggered");
    }
    advanceClockIfNeeded(new DateTime(clock.millis(),UTC).plusMillis(1100));
    if (!secondLatch.await(3 * count,TimeUnit.SECONDS)) {
      fail("waiting too long for all watches to be triggered");
    }
    engine.stop();
    assertThat(bits.cardinality(),is(count));
  }
  public void testAddHourly() throws Exception {
    final String name="job_name";
    final CountDownLatch latch=new CountDownLatch(1);
    engine.start(Collections.emptySet());
    engine.register(new Consumer<Iterable<TriggerEvent>>(){
      @Override public void accept(      Iterable<TriggerEvent> events){
        for (        TriggerEvent event : events) {
          assertThat(event.jobName(),is(name));
          logger.info("triggered job on [{}]",clock);
        }
        latch.countDown();
      }
    }
);
    int randomMinute=randomIntBetween(0,59);
    DateTime testNowTime=new DateTime(clock.millis(),UTC).withMinuteOfHour(randomMinute).withSecondOfMinute(59);
    DateTime scheduledTime=testNowTime.plusSeconds(2);
    logger.info("Setting current time to [{}], job execution time [{}]",testNowTime,scheduledTime);
    clock.setTime(testNowTime);
    engine.add(createWatch(name,daily().at(scheduledTime.getHourOfDay(),scheduledTime.getMinuteOfHour()).build()));
    advanceClockIfNeeded(scheduledTime);
    if (!latch.await(5,TimeUnit.SECONDS)) {
      fail("waiting too long for all watches to be triggered");
    }
  }
  public void testAddDaily() throws Exception {
    final String name="job_name";
    final CountDownLatch latch=new CountDownLatch(1);
    engine.start(Collections.emptySet());
    engine.register(new Consumer<Iterable<TriggerEvent>>(){
      @Override public void accept(      Iterable<TriggerEvent> events){
        for (        TriggerEvent event : events) {
          assertThat(event.jobName(),is(name));
          logger.info("triggered job on [{}]",new DateTime(clock.millis(),UTC));
          latch.countDown();
        }
      }
    }
);
    int randomHour=randomIntBetween(0,23);
    int randomMinute=randomIntBetween(0,59);
    DateTime testNowTime=new DateTime(clock.millis(),UTC).withHourOfDay(randomHour).withMinuteOfHour(randomMinute).withSecondOfMinute(59);
    DateTime scheduledTime=testNowTime.plusSeconds(2);
    logger.info("Setting current time to [{}], job execution time [{}]",testNowTime,scheduledTime);
    clock.setTime(testNowTime);
    engine.add(createWatch(name,daily().at(scheduledTime.getHourOfDay(),scheduledTime.getMinuteOfHour()).build()));
    advanceClockIfNeeded(scheduledTime);
    if (!latch.await(5,TimeUnit.SECONDS)) {
      fail("waiting too long for all watches to be triggered");
    }
  }
  public void testAddWeekly() throws Exception {
    final String name="job_name";
    final CountDownLatch latch=new CountDownLatch(1);
    engine.start(Collections.emptySet());
    engine.register(new Consumer<Iterable<TriggerEvent>>(){
      @Override public void accept(      Iterable<TriggerEvent> events){
        for (        TriggerEvent event : events) {
          assertThat(event.jobName(),is(name));
          logger.info("triggered job");
        }
        latch.countDown();
      }
    }
);
    int randomHour=randomIntBetween(0,23);
    int randomMinute=randomIntBetween(0,59);
    int randomDay=randomIntBetween(1,7);
    DateTime testNowTime=new DateTime(clock.millis(),UTC).withDayOfWeek(randomDay).withHourOfDay(randomHour).withMinuteOfHour(randomMinute).withSecondOfMinute(59);
    DateTime scheduledTime=testNowTime.plusSeconds(2);
    logger.info("Setting current time to [{}], job execution time [{}]",testNowTime,scheduledTime);
    clock.setTime(testNowTime);
    int watcherDay=(scheduledTime.getDayOfWeek() % 7) + 1;
    engine.add(createWatch(name,weekly().time(WeekTimes.builder().on(DayOfWeek.resolve(watcherDay)).at(scheduledTime.getHourOfDay(),scheduledTime.getMinuteOfHour()).build()).build()));
    advanceClockIfNeeded(scheduledTime);
    if (!latch.await(5,TimeUnit.SECONDS)) {
      fail("waiting too long for all watches to be triggered");
    }
  }
  public void testAddSameJobSeveralTimesAndExecutedOnce() throws InterruptedException {
    engine.start(Collections.emptySet());
    final CountDownLatch firstLatch=new CountDownLatch(1);
    final CountDownLatch secondLatch=new CountDownLatch(1);
    AtomicInteger counter=new AtomicInteger(0);
    engine.register(new Consumer<Iterable<TriggerEvent>>(){
      @Override public void accept(      Iterable<TriggerEvent> events){
        events.forEach(event -> {
          if (counter.getAndIncrement() == 0) {
            firstLatch.countDown();
          }
 else {
            secondLatch.countDown();
          }
        }
);
      }
    }
);
    int times=scaledRandomIntBetween(3,30);
    for (int i=0; i < times; i++) {
      engine.add(createWatch("_id",interval("1s")));
    }
    advanceClockIfNeeded(new DateTime(clock.millis(),UTC).plusMillis(1100));
    if (!firstLatch.await(3,TimeUnit.SECONDS)) {
      fail("waiting too long for all watches to be triggered");
    }
    advanceClockIfNeeded(new DateTime(clock.millis(),UTC).plusMillis(1100));
    if (!secondLatch.await(3,TimeUnit.SECONDS)) {
      fail("waiting too long for all watches to be triggered");
    }
    assertThat(counter.get(),is(2));
  }
  public void testAddOnlyWithNewSchedule(){
    engine.start(Collections.emptySet());
    Watch oncePerSecondWatch=createWatch("_id",interval("1s"));
    engine.add(oncePerSecondWatch);
    TickerScheduleTriggerEngine.ActiveSchedule activeSchedule=engine.getSchedules().get("_id");
    engine.add(oncePerSecondWatch);
    assertThat(engine.getSchedules().get("_id"),is(activeSchedule));
    Watch oncePerMinuteWatch=createWatch("_id",interval("1m"));
    engine.add(oncePerMinuteWatch);
    assertThat(engine.getSchedules().get("_id"),not(is(activeSchedule)));
  }
  private Watch createWatch(  String name,  Schedule schedule){
    return new Watch(name,new ScheduleTrigger(schedule),new ExecutableNoneInput(),InternalAlwaysCondition.INSTANCE,null,null,Collections.emptyList(),null,null,Versions.MATCH_ANY);
  }
}
