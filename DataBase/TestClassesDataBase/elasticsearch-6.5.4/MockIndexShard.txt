/** 
 * Mock for  {@link IndexShard}
 */
protected class MockIndexShard implements IndicesClusterStateService.Shard {
  private volatile long clusterStateVersion;
  private volatile ShardRouting shardRouting;
  private volatile RecoveryState recoveryState;
  private volatile Set<String> inSyncAllocationIds;
  private volatile IndexShardRoutingTable routingTable;
  private volatile long term;
  public MockIndexShard(  ShardRouting shardRouting,  long term){
    this.shardRouting=shardRouting;
    this.term=term;
  }
  @Override public ShardId shardId(){
    return shardRouting.shardId();
  }
  @Override public RecoveryState recoveryState(){
    return recoveryState;
  }
  @Override public void updateShardState(  ShardRouting shardRouting,  long newPrimaryTerm,  BiConsumer<IndexShard,ActionListener<ResyncTask>> primaryReplicaSyncer,  long applyingClusterStateVersion,  Set<String> inSyncAllocationIds,  IndexShardRoutingTable routingTable,  Set<String> pre60AllocationIds) throws IOException {
    failRandomly();
    assertThat(this.shardId(),equalTo(shardRouting.shardId()));
    assertTrue("current: " + this.shardRouting + ", got: "+ shardRouting,this.shardRouting.isSameAllocation(shardRouting));
    if (this.shardRouting.active()) {
      assertTrue("and active shard must stay active, current: " + this.shardRouting + ", got: "+ shardRouting,shardRouting.active());
    }
    if (this.shardRouting.primary()) {
      assertTrue("a primary shard can't be demoted",shardRouting.primary());
    }
 else     if (shardRouting.primary()) {
      assertTrue("a replica can only be promoted when active. current: " + this.shardRouting + " new: "+ shardRouting,shardRouting.active());
    }
    this.shardRouting=shardRouting;
    if (shardRouting.primary()) {
      term=newPrimaryTerm;
      this.clusterStateVersion=applyingClusterStateVersion;
      this.inSyncAllocationIds=inSyncAllocationIds;
      this.routingTable=routingTable;
    }
  }
  @Override public ShardRouting routingEntry(){
    return shardRouting;
  }
  @Override public IndexShardState state(){
    return null;
  }
  public void updateTerm(  long newTerm){
    assertThat("term can only be incremented: " + shardRouting,newTerm,greaterThanOrEqualTo(term));
    if (shardRouting.primary() && shardRouting.active()) {
      assertThat("term can not be changed on an active primary shard: " + shardRouting,newTerm,equalTo(term));
    }
    this.term=newTerm;
  }
}
