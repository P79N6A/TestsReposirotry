@ESIntegTestCase.ClusterScope(supportsDedicatedMasters=false,numDataNodes=0,numClientNodes=0) public class GceDiscoverTests extends ESIntegTestCase {
  /** 
 * Holds a list of the current discovery nodes started in tests 
 */
  private static final Map<String,DiscoveryNode> nodes=new ConcurrentHashMap<>();
  @After public void clearGceNodes(){
    nodes.clear();
  }
  @Override protected Collection<Class<? extends Plugin>> nodePlugins(){
    return singletonList(TestPlugin.class);
  }
  @Override protected Settings nodeSettings(  int nodeOrdinal){
    return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put("discovery.zen.hosts_provider","gce").put("cloud.gce.project_id","test").put("cloud.gce.zone","test").put(ZenDiscovery.JOIN_TIMEOUT_SETTING.getKey(),"1s").put(ZenDiscovery.PING_TIMEOUT_SETTING.getKey(),"500ms").build();
  }
  @Override protected boolean addTestZenDiscovery(){
    return false;
  }
  public void testJoin(){
    final String masterNode=internalCluster().startMasterOnlyNode();
    registerGceNode(masterNode);
    ClusterStateResponse clusterStateResponse=client(masterNode).admin().cluster().prepareState().setMasterNodeTimeout("1s").clear().setNodes(true).get();
    assertNotNull(clusterStateResponse.getState().nodes().getMasterNodeId());
    final String secondNode=internalCluster().startNode();
    registerGceNode(secondNode);
    clusterStateResponse=client(secondNode).admin().cluster().prepareState().setMasterNodeTimeout("1s").clear().setNodes(true).setLocal(true).get();
    assertNotNull(clusterStateResponse.getState().nodes().getMasterNodeId());
    assertNoTimeout(client().admin().cluster().prepareHealth().setWaitForNodes(Integer.toString(2)).get());
    assertNumberOfNodes(2);
    final String thirdNode=internalCluster().startDataOnlyNode();
    registerGceNode(thirdNode);
    assertNoTimeout(client().admin().cluster().prepareHealth().setWaitForNodes(Integer.toString(3)).get());
    assertNumberOfNodes(3);
  }
  /** 
 * Register an existing node as a GCE node
 * @param nodeName the name of the node
 */
  private static void registerGceNode(  final String nodeName){
    final TransportService transportService=internalCluster().getInstance(TransportService.class,nodeName);
    assertNotNull(transportService);
    final DiscoveryNode discoveryNode=transportService.getLocalNode();
    assertNotNull(discoveryNode);
    if (nodes.put(discoveryNode.getName(),discoveryNode) != null) {
      throw new IllegalArgumentException("Node [" + discoveryNode.getName() + "] cannot be registered twice");
    }
  }
  /** 
 * Asserts that the cluster nodes info contains an expected number of node
 * @param expected the expected number of nodes
 */
  private static void assertNumberOfNodes(  final int expected){
    assertEquals(expected,client().admin().cluster().prepareNodesInfo().clear().get().getNodes().size());
  }
  /** 
 * Test plugin that exposes internal test cluster nodes as if they were real GCE nodes. Use  {@link #registerGceNode(String)} method to expose nodes in the tests.
 */
public static class TestPlugin extends GceDiscoveryPlugin {
    public TestPlugin(    Settings settings){
      super(settings);
    }
    @Override protected GceInstancesService createGceInstancesService(){
      return new GceInstancesService(){
        @Override public Collection<Instance> instances(){
          return Access.doPrivileged(() -> {
            final List<Instance> instances=new ArrayList<>();
            for (            DiscoveryNode discoveryNode : nodes.values()) {
              Instance instance=new Instance();
              instance.setName(discoveryNode.getName());
              instance.setStatus("STARTED");
              NetworkInterface networkInterface=new NetworkInterface();
              networkInterface.setNetworkIP(discoveryNode.getAddress().toString());
              instance.setNetworkInterfaces(singletonList(networkInterface));
              instances.add(instance);
            }
            return instances;
          }
);
        }
        @Override public String projectId(){
          return PROJECT_SETTING.get(settings);
        }
        @Override public List<String> zones(){
          return ZONE_SETTING.get(settings);
        }
        @Override public void close() throws IOException {
        }
      }
;
    }
  }
}
