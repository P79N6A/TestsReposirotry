/** 
 * This test makes sure that the http host and path fields in the watch_record action result are not analyzed so they can be used in aggregations
 */
public class HistoryTemplateHttpMappingsTests extends AbstractWatcherIntegrationTestCase {
  private MockWebServer webServer=new MockWebServer();
  @Before public void init() throws Exception {
    webServer.start();
  }
  @After public void cleanup() throws Exception {
    webServer.close();
  }
  public void testHttpFields() throws Exception {
    PutWatchResponse putWatchResponse=watcherClient().preparePutWatch("_id").setSource(watchBuilder().trigger(schedule(interval("5s"))).input(httpInput(HttpRequestTemplate.builder("localhost",webServer.getPort()).path("/input/path"))).condition(InternalAlwaysCondition.INSTANCE).addAction("_webhook",webhookAction(HttpRequestTemplate.builder("localhost",webServer.getPort()).path("/webhook/path").method(HttpMethod.POST).body("_body")))).get();
    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("{}"));
    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("{}"));
    assertThat(putWatchResponse.isCreated(),is(true));
    timeWarp().trigger("_id");
    flush();
    refresh();
    assertWatchWithMinimumActionsCount("_id",ExecutionState.EXECUTED,1);
    SearchResponse response=client().prepareSearch(HistoryStoreField.INDEX_PREFIX_WITH_TEMPLATE + "*").setSource(searchSource().aggregation(terms("input_result_path").field("result.input.http.request.path")).aggregation(terms("input_result_host").field("result.input.http.request.host")).aggregation(terms("webhook_path").field("result.actions.webhook.request.path"))).get();
    assertThat(response,notNullValue());
    assertThat(response.getHits().getTotalHits(),is(1L));
    Aggregations aggs=response.getAggregations();
    assertThat(aggs,notNullValue());
    Terms terms=aggs.get("input_result_path");
    assertThat(terms,notNullValue());
    assertThat(terms.getBuckets().size(),is(1));
    assertThat(terms.getBucketByKey("/input/path"),notNullValue());
    assertThat(terms.getBucketByKey("/input/path").getDocCount(),is(1L));
    terms=aggs.get("webhook_path");
    assertThat(terms,notNullValue());
    assertThat(terms.getBuckets().size(),is(1));
    assertThat(terms.getBucketByKey("/webhook/path"),notNullValue());
    assertThat(terms.getBucketByKey("/webhook/path").getDocCount(),is(1L));
    assertThat(webServer.requests(),hasSize(2));
    assertThat(webServer.requests().get(0).getUri().getPath(),is("/input/path"));
    assertThat(webServer.requests().get(1).getUri().getPath(),is("/webhook/path"));
  }
  public void testExceptionMapping(){
    assertAcked(client().admin().indices().prepareDelete(HistoryStoreField.INDEX_PREFIX + "*"));
    String id=randomAlphaOfLength(10);
    boolean abortAtInput=randomBoolean();
    if (abortAtInput) {
      webServer.enqueue(new MockResponse().setBeforeReplyDelay(TimeValue.timeValueSeconds(5)));
    }
 else {
      webServer.enqueue(new MockResponse().setBody("{}"));
      webServer.enqueue(new MockResponse().setBeforeReplyDelay(TimeValue.timeValueSeconds(5)));
    }
    PutWatchResponse putWatchResponse=watcherClient().preparePutWatch(id).setSource(watchBuilder().trigger(schedule(interval("5s"))).input(httpInput(HttpRequestTemplate.builder("localhost",webServer.getPort()).path("/").readTimeout(abortAtInput ? TimeValue.timeValueMillis(10) : TimeValue.timeValueSeconds(10)))).condition(InternalAlwaysCondition.INSTANCE).addAction("_webhook",webhookAction(HttpRequestTemplate.builder("localhost",webServer.getPort()).readTimeout(TimeValue.timeValueMillis(10)).path("/webhook/path").method(HttpMethod.POST).body("_body")))).get();
    assertThat(putWatchResponse.isCreated(),is(true));
    watcherClient().prepareExecuteWatch(id).setRecordExecution(true).get();
    flushAndRefresh(HistoryStoreField.INDEX_PREFIX + "*");
    SearchResponse searchResponse=client().prepareSearch(HistoryStoreField.INDEX_PREFIX + "*").setQuery(QueryBuilders.termQuery("watch_id",id)).get();
    assertHitCount(searchResponse,1L);
    List<Boolean> indexed=new ArrayList<>();
    GetMappingsResponse mappingsResponse=client().admin().indices().prepareGetMappings(HistoryStoreField.INDEX_PREFIX + "*").get();
    Iterator<ImmutableOpenMap<String,MappingMetaData>> iterator=mappingsResponse.getMappings().valuesIt();
    while (iterator.hasNext()) {
      ImmutableOpenMap<String,MappingMetaData> mapping=iterator.next();
      assertThat(mapping.containsKey("doc"),is(true));
      Map<String,Object> docMapping=mapping.get("doc").getSourceAsMap();
      if (abortAtInput) {
        Boolean enabled=ObjectPath.eval("properties.result.properties.input.properties.error.enabled",docMapping);
        indexed.add(enabled);
      }
 else {
        Boolean enabled=ObjectPath.eval("properties.result.properties.actions.properties.error.enabled",docMapping);
        indexed.add(enabled);
      }
    }
    assertThat(indexed,hasSize(greaterThanOrEqualTo(1)));
    assertThat(indexed,hasItem(false));
    assertThat(indexed,not(hasItem(true)));
  }
}
