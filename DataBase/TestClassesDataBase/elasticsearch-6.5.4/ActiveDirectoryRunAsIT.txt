/** 
 * This tests that "run-as" works on LDAP/AD realms
 */
public class ActiveDirectoryRunAsIT extends AbstractAdLdapRealmTestCase {
  private static boolean useLegacyBindPassword;
  @BeforeClass public static void selectRealmConfig(){
    realmConfig=RealmConfig.AD;
    useLegacyBindPassword=randomBoolean();
  }
  @Override protected Settings nodeSettings(  int nodeOrdinal){
    useLegacyBindPassword=randomBoolean();
    final Settings.Builder builder=Settings.builder().put(super.nodeSettings(nodeOrdinal));
switch (realmConfig) {
case AD:
      builder.put(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".bind_dn","ironman@ad.test.elasticsearch.com").put(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".user_search.pool.enabled",false);
    if (useLegacyBindPassword) {
      builder.put(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".bind_password",ActiveDirectorySessionFactoryTests.PASSWORD);
    }
 else {
      SecuritySettingsSource.addSecureSettings(builder,secureSettings -> {
        secureSettings.setString(XPACK_SECURITY_AUTHC_REALMS_EXTERNAL + ".secure_bind_password",ActiveDirectorySessionFactoryTests.PASSWORD);
      }
);
    }
  break;
default :
throw new IllegalStateException("Unknown realm config " + realmConfig);
}
return builder.build();
}
public void testRunAs() throws Exception {
String avenger=realmConfig.loginWithCommonName ? "Natasha Romanoff" : "blackwidow";
final AuthenticateRequest request=new AuthenticateRequest(avenger);
final ActionFuture<AuthenticateResponse> future=runAsClient(avenger).execute(AuthenticateAction.INSTANCE,request);
final AuthenticateResponse response=future.get(30,TimeUnit.SECONDS);
assertThat(response.user().principal(),Matchers.equalTo(avenger));
}
protected Client runAsClient(String user){
final Map<String,String> headers=MapBuilder.<String,String>newMapBuilder().put(BASIC_AUTH_HEADER,UsernamePasswordToken.basicAuthHeaderValue(ElasticUser.NAME,BOOTSTRAP_PASSWORD)).put(AuthenticationServiceField.RUN_AS_USER_HEADER,user).map();
return client().filterWithHeader(headers);
}
}
