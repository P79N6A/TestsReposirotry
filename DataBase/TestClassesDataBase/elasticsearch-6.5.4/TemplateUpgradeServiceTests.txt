public class TemplateUpgradeServiceTests extends ESTestCase {
  private ThreadPool threadPool;
  private ClusterService clusterService;
  @Before public void setUpTest() throws Exception {
    threadPool=new TestThreadPool("TemplateUpgradeServiceTests");
    clusterService=createClusterService(threadPool);
  }
  @After public void tearDownTest() throws Exception {
    threadPool.shutdownNow();
    clusterService.close();
  }
  public void testCalculateChangesAddChangeAndDelete(){
    boolean shouldAdd=randomBoolean();
    boolean shouldRemove=randomBoolean();
    boolean shouldChange=randomBoolean();
    MetaData metaData=randomMetaData(IndexTemplateMetaData.builder("user_template").patterns(randomIndexPatterns()).build(),IndexTemplateMetaData.builder("removed_test_template").patterns(randomIndexPatterns()).build(),IndexTemplateMetaData.builder("changed_test_template").patterns(randomIndexPatterns()).build());
    final TemplateUpgradeService service=new TemplateUpgradeService(Settings.EMPTY,null,clusterService,threadPool,Arrays.asList(templates -> {
      if (shouldAdd) {
        assertNull(templates.put("added_test_template",IndexTemplateMetaData.builder("added_test_template").patterns(randomIndexPatterns()).build()));
      }
      return templates;
    }
,templates -> {
      if (shouldRemove) {
        assertNotNull(templates.remove("removed_test_template"));
      }
      return templates;
    }
,templates -> {
      if (shouldChange) {
        assertNotNull(templates.put("changed_test_template",IndexTemplateMetaData.builder("changed_test_template").patterns(randomIndexPatterns()).order(10).build()));
      }
      return templates;
    }
));
    Optional<Tuple<Map<String,BytesReference>,Set<String>>> optChanges=service.calculateTemplateChanges(metaData.templates());
    if (shouldAdd || shouldRemove || shouldChange) {
      Tuple<Map<String,BytesReference>,Set<String>> changes=optChanges.orElseThrow(() -> new AssertionError("Should have non empty changes"));
      if (shouldAdd) {
        assertThat(changes.v1().get("added_test_template"),notNullValue());
        if (shouldChange) {
          assertThat(changes.v1().keySet(),hasSize(2));
          assertThat(changes.v1().get("changed_test_template"),notNullValue());
        }
 else {
          assertThat(changes.v1().keySet(),hasSize(1));
        }
      }
 else {
        if (shouldChange) {
          assertThat(changes.v1().get("changed_test_template"),notNullValue());
          assertThat(changes.v1().keySet(),hasSize(1));
        }
 else {
          assertThat(changes.v1().keySet(),empty());
        }
      }
      if (shouldRemove) {
        assertThat(changes.v2(),hasSize(1));
        assertThat(changes.v2().contains("removed_test_template"),equalTo(true));
      }
 else {
        assertThat(changes.v2(),empty());
      }
    }
 else {
      assertThat(optChanges.isPresent(),equalTo(false));
    }
  }
  @SuppressWarnings("unchecked") public void testUpdateTemplates(){
    int additionsCount=randomIntBetween(0,5);
    int deletionsCount=randomIntBetween(0,3);
    List<ActionListener<AcknowledgedResponse>> putTemplateListeners=new ArrayList<>();
    List<ActionListener<AcknowledgedResponse>> deleteTemplateListeners=new ArrayList<>();
    Client mockClient=mock(Client.class);
    AdminClient mockAdminClient=mock(AdminClient.class);
    IndicesAdminClient mockIndicesAdminClient=mock(IndicesAdminClient.class);
    when(mockClient.admin()).thenReturn(mockAdminClient);
    when(mockAdminClient.indices()).thenReturn(mockIndicesAdminClient);
    doAnswer(invocation -> {
      Object[] args=invocation.getArguments();
      assert args.length == 2;
      PutIndexTemplateRequest request=(PutIndexTemplateRequest)args[0];
      assertThat(request.name(),equalTo("add_template_" + request.order()));
      putTemplateListeners.add((ActionListener)args[1]);
      return null;
    }
).when(mockIndicesAdminClient).putTemplate(any(PutIndexTemplateRequest.class),any(ActionListener.class));
    doAnswer(invocation -> {
      Object[] args=invocation.getArguments();
      assert args.length == 2;
      DeleteIndexTemplateRequest request=(DeleteIndexTemplateRequest)args[0];
      assertThat(request.name(),startsWith("remove_template_"));
      deleteTemplateListeners.add((ActionListener)args[1]);
      return null;
    }
).when(mockIndicesAdminClient).deleteTemplate(any(DeleteIndexTemplateRequest.class),any(ActionListener.class));
    Set<String> deletions=new HashSet<>(deletionsCount);
    for (int i=0; i < deletionsCount; i++) {
      deletions.add("remove_template_" + i);
    }
    Map<String,BytesReference> additions=new HashMap<>(additionsCount);
    for (int i=0; i < additionsCount; i++) {
      additions.put("add_template_" + i,new BytesArray("{\"index_patterns\" : \"*\", \"order\" : " + i + "}"));
    }
    final TemplateUpgradeService service=new TemplateUpgradeService(Settings.EMPTY,mockClient,clusterService,threadPool,Collections.emptyList());
    IllegalStateException ise=expectThrows(IllegalStateException.class,() -> service.upgradeTemplates(additions,deletions));
    assertThat(ise.getMessage(),containsString("template upgrade service should always happen in a system context"));
    service.upgradesInProgress.set(additionsCount + deletionsCount + 2);
    final ThreadContext threadContext=threadPool.getThreadContext();
    try (ThreadContext.StoredContext ignore=threadContext.stashContext()){
      threadContext.markAsSystemContext();
      service.upgradeTemplates(additions,deletions);
    }
     assertThat(putTemplateListeners,hasSize(additionsCount));
    assertThat(deleteTemplateListeners,hasSize(deletionsCount));
    for (int i=0; i < additionsCount; i++) {
      if (randomBoolean()) {
        putTemplateListeners.get(i).onFailure(new RuntimeException("test - ignore"));
      }
 else {
        putTemplateListeners.get(i).onResponse(new AcknowledgedResponse(randomBoolean()){
        }
);
      }
    }
    for (int i=0; i < deletionsCount; i++) {
      if (randomBoolean()) {
        int prevUpdatesInProgress=service.upgradesInProgress.get();
        deleteTemplateListeners.get(i).onFailure(new RuntimeException("test - ignore"));
        assertThat(prevUpdatesInProgress - service.upgradesInProgress.get(),equalTo(1));
      }
 else {
        int prevUpdatesInProgress=service.upgradesInProgress.get();
        deleteTemplateListeners.get(i).onResponse(new AcknowledgedResponse(randomBoolean()){
        }
);
        assertThat(prevUpdatesInProgress - service.upgradesInProgress.get(),equalTo(1));
      }
    }
    assertThat(service.upgradesInProgress.get(),equalTo(2));
  }
  private static final Set<DiscoveryNode.Role> MASTER_DATA_ROLES=Collections.unmodifiableSet(EnumSet.of(DiscoveryNode.Role.MASTER,DiscoveryNode.Role.DATA));
  @SuppressWarnings("unchecked") public void testClusterStateUpdate() throws InterruptedException {
    final AtomicReference<ActionListener<AcknowledgedResponse>> addedListener=new AtomicReference<>();
    final AtomicReference<ActionListener<AcknowledgedResponse>> changedListener=new AtomicReference<>();
    final AtomicReference<ActionListener<AcknowledgedResponse>> removedListener=new AtomicReference<>();
    final Semaphore updateInvocation=new Semaphore(0);
    final Semaphore calculateInvocation=new Semaphore(0);
    final Semaphore changedInvocation=new Semaphore(0);
    final Semaphore finishInvocation=new Semaphore(0);
    MetaData metaData=randomMetaData(IndexTemplateMetaData.builder("user_template").patterns(randomIndexPatterns()).build(),IndexTemplateMetaData.builder("removed_test_template").patterns(randomIndexPatterns()).build(),IndexTemplateMetaData.builder("changed_test_template").patterns(randomIndexPatterns()).build());
    Client mockClient=mock(Client.class);
    AdminClient mockAdminClient=mock(AdminClient.class);
    IndicesAdminClient mockIndicesAdminClient=mock(IndicesAdminClient.class);
    when(mockClient.admin()).thenReturn(mockAdminClient);
    when(mockAdminClient.indices()).thenReturn(mockIndicesAdminClient);
    doAnswer(invocation -> {
      Object[] args=invocation.getArguments();
      assert args.length == 2;
      PutIndexTemplateRequest request=(PutIndexTemplateRequest)args[0];
      if (request.name().equals("added_test_template")) {
        assertThat(addedListener.getAndSet((ActionListener)args[1]),nullValue());
      }
 else       if (request.name().equals("changed_test_template")) {
        assertThat(changedListener.getAndSet((ActionListener)args[1]),nullValue());
      }
 else {
        fail("unexpected put template call for " + request.name());
      }
      return null;
    }
).when(mockIndicesAdminClient).putTemplate(any(PutIndexTemplateRequest.class),any(ActionListener.class));
    doAnswer(invocation -> {
      Object[] args=invocation.getArguments();
      assert args.length == 2;
      DeleteIndexTemplateRequest request=(DeleteIndexTemplateRequest)args[0];
      assertThat(request.name(),startsWith("removed_test_template"));
      assertThat(removedListener.getAndSet((ActionListener)args[1]),nullValue());
      return null;
    }
).when(mockIndicesAdminClient).deleteTemplate(any(DeleteIndexTemplateRequest.class),any(ActionListener.class));
    final TemplateUpgradeService service=new TemplateUpgradeService(Settings.EMPTY,mockClient,clusterService,threadPool,Arrays.asList(templates -> {
      assertNull(templates.put("added_test_template",IndexTemplateMetaData.builder("added_test_template").patterns(Collections.singletonList("*")).build()));
      return templates;
    }
,templates -> {
      assertNotNull(templates.remove("removed_test_template"));
      return templates;
    }
,templates -> {
      assertNotNull(templates.put("changed_test_template",IndexTemplateMetaData.builder("changed_test_template").patterns(Collections.singletonList("*")).order(10).build()));
      return templates;
    }
)){
      @Override void tryFinishUpgrade(      AtomicBoolean anyUpgradeFailed){
        super.tryFinishUpgrade(anyUpgradeFailed);
        finishInvocation.release();
      }
      @Override void upgradeTemplates(      Map<String,BytesReference> changes,      Set<String> deletions){
        super.upgradeTemplates(changes,deletions);
        updateInvocation.release();
      }
      @Override Optional<Tuple<Map<String,BytesReference>,Set<String>>> calculateTemplateChanges(      ImmutableOpenMap<String,IndexTemplateMetaData> templates){
        final Optional<Tuple<Map<String,BytesReference>,Set<String>>> ans=super.calculateTemplateChanges(templates);
        calculateInvocation.release();
        return ans;
      }
      @Override public void clusterChanged(      ClusterChangedEvent event){
        super.clusterChanged(event);
        changedInvocation.release();
      }
    }
;
    ClusterState prevState=ClusterState.EMPTY_STATE;
    ClusterState state=ClusterState.builder(prevState).nodes(DiscoveryNodes.builder().add(new DiscoveryNode("node1","node1",buildNewFakeTransportAddress(),emptyMap(),MASTER_DATA_ROLES,Version.CURRENT)).localNodeId("node1").masterNodeId("node1").build()).metaData(metaData).build();
    setState(clusterService,state);
    changedInvocation.acquire();
    assertThat(changedInvocation.availablePermits(),equalTo(0));
    calculateInvocation.acquire();
    assertThat(calculateInvocation.availablePermits(),equalTo(0));
    updateInvocation.acquire();
    assertThat(updateInvocation.availablePermits(),equalTo(0));
    assertThat(finishInvocation.availablePermits(),equalTo(0));
    assertThat(addedListener.get(),notNullValue());
    assertThat(changedListener.get(),notNullValue());
    assertThat(removedListener.get(),notNullValue());
    prevState=state;
    state=ClusterState.builder(prevState).metaData(MetaData.builder(state.metaData()).removeTemplate("user_template")).build();
    setState(clusterService,state);
    changedInvocation.acquire();
    assertThat(changedInvocation.availablePermits(),equalTo(0));
    assertThat(calculateInvocation.availablePermits(),equalTo(0));
    assertThat(updateInvocation.availablePermits(),equalTo(0));
    assertThat(finishInvocation.availablePermits(),equalTo(0));
    addedListener.getAndSet(null).onResponse(new AcknowledgedResponse(true){
    }
);
    changedListener.getAndSet(null).onResponse(new AcknowledgedResponse(true){
    }
);
    removedListener.getAndSet(null).onResponse(new AcknowledgedResponse(true){
    }
);
    finishInvocation.acquire(3);
    assertThat(finishInvocation.availablePermits(),equalTo(0));
    calculateInvocation.acquire();
    assertThat(calculateInvocation.availablePermits(),equalTo(0));
    setState(clusterService,state);
    changedInvocation.acquire();
    assertThat(changedInvocation.availablePermits(),equalTo(0));
    calculateInvocation.acquire();
    assertThat(calculateInvocation.availablePermits(),equalTo(0));
    updateInvocation.acquire();
    assertThat(updateInvocation.availablePermits(),equalTo(0));
    assertThat(finishInvocation.availablePermits(),equalTo(0));
    addedListener.getAndSet(null).onFailure(new RuntimeException("test - ignore"));
    changedListener.getAndSet(null).onFailure(new RuntimeException("test - ignore"));
    removedListener.getAndSet(null).onFailure(new RuntimeException("test - ignore"));
    finishInvocation.acquire(3);
    assertThat(finishInvocation.availablePermits(),equalTo(0));
    calculateInvocation.acquire();
    assertThat(calculateInvocation.availablePermits(),equalTo(0));
    setState(clusterService,state);
    changedInvocation.acquire();
    assertThat(changedInvocation.availablePermits(),equalTo(0));
    assertThat(calculateInvocation.availablePermits(),equalTo(0));
    assertThat(updateInvocation.availablePermits(),equalTo(0));
    assertThat(finishInvocation.availablePermits(),equalTo(0));
  }
  private static final int NODE_TEST_ITERS=100;
  private DiscoveryNodes randomNodes(  int dataAndMasterNodes,  int clientNodes){
    DiscoveryNodes.Builder builder=DiscoveryNodes.builder();
    String masterNodeId=null;
    for (int i=0; i < dataAndMasterNodes; i++) {
      String id=randomAlphaOfLength(10) + "_" + i;
      Set<DiscoveryNode.Role> roles;
      if (i == 0) {
        masterNodeId=id;
        if (randomBoolean()) {
          roles=EnumSet.of(DiscoveryNode.Role.MASTER,DiscoveryNode.Role.DATA);
        }
 else {
          roles=EnumSet.of(DiscoveryNode.Role.MASTER);
        }
      }
 else {
        if (randomBoolean()) {
          roles=EnumSet.of(DiscoveryNode.Role.DATA);
        }
 else {
          roles=EnumSet.of(DiscoveryNode.Role.MASTER);
        }
      }
      String node="node_" + i;
      builder.add(new DiscoveryNode(node,id,buildNewFakeTransportAddress(),emptyMap(),roles,randomVersion(random())));
    }
    builder.masterNodeId(masterNodeId);
    for (int i=0; i < clientNodes; i++) {
      String node="client_" + i;
      builder.add(new DiscoveryNode(node,randomAlphaOfLength(10) + "__" + i,buildNewFakeTransportAddress(),emptyMap(),EnumSet.noneOf(DiscoveryNode.Role.class),randomVersion(random())));
    }
    return builder.build();
  }
  public static MetaData randomMetaData(  IndexTemplateMetaData... templates){
    MetaData.Builder builder=MetaData.builder();
    for (    IndexTemplateMetaData template : templates) {
      builder.put(template);
    }
    for (int i=0; i < randomIntBetween(1,5); i++) {
      builder.put(IndexMetaData.builder(randomAlphaOfLength(10)).settings(settings(Version.CURRENT)).numberOfReplicas(randomIntBetween(0,3)).numberOfShards(randomIntBetween(1,5)));
    }
    return builder.build();
  }
  List<String> randomIndexPatterns(){
    return IntStream.range(0,between(1,10)).mapToObj(n -> randomUnicodeOfCodepointLengthBetween(1,100)).collect(Collectors.toList());
  }
}
