@TestLogging("org.elasticsearch.xpack.ml.action:DEBUG") public class MachineLearningLicensingTests extends BaseMlIntegTestCase {
  @Before public void resetLicensing(){
    enableLicensing();
    ensureStableCluster(1);
    ensureYellow();
  }
  public void testMachineLearningPutJobActionRestricted() throws Exception {
    String jobId="testmachinelearningputjobactionrestricted";
    License.OperationMode mode=randomInvalidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(false);
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),listener);
      listener.actionGet();
      fail("put job action should not be enabled!");
    }
 catch (    ElasticsearchSecurityException e) {
      assertThat(e.status(),is(RestStatus.FORBIDDEN));
      assertThat(e.getMessage(),containsString("non-compliant"));
      assertThat(e.getMetadata(LicenseUtils.EXPIRED_FEATURE_METADATA),hasItem(XPackField.MACHINE_LEARNING));
    }
    mode=randomValidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(true);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),listener);
      PutJobAction.Response response=listener.actionGet();
      assertNotNull(response);
    }
   }
  public void testMachineLearningOpenJobActionRestricted() throws Exception {
    String jobId="testmachinelearningopenjobactionrestricted";
    assertMLAllowed(true);
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response response=putJobListener.actionGet();
      assertNotNull(response);
    }
     License.OperationMode mode=randomInvalidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(false);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),listener);
      listener.actionGet();
      fail("open job action should not be enabled!");
    }
 catch (    ElasticsearchSecurityException e) {
      assertThat(e.status(),is(RestStatus.FORBIDDEN));
      assertThat(e.getMessage(),containsString("non-compliant"));
      assertThat(e.getMetadata(LicenseUtils.EXPIRED_FEATURE_METADATA),hasItem(XPackField.MACHINE_LEARNING));
    }
    mode=randomValidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(true);
    assertBusy(() -> {
      JobState jobState=getJobStats(jobId).getState();
      assertEquals(JobState.CLOSED,jobState);
    }
);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),listener);
      AcknowledgedResponse response=listener.actionGet();
      assertNotNull(response);
    }
   }
  public void testMachineLearningPutDatafeedActionRestricted() throws Exception {
    String jobId="testmachinelearningputdatafeedactionrestricted";
    String datafeedId=jobId + "-datafeed";
    assertMLAllowed(true);
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response putJobResponse=putJobListener.actionGet();
      assertNotNull(putJobResponse);
    }
     License.OperationMode mode=randomInvalidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(false);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutDatafeedAction.Response> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putDatafeed(new PutDatafeedAction.Request(createDatafeed(datafeedId,jobId,Collections.singletonList(jobId))),listener);
      listener.actionGet();
      fail("put datafeed action should not be enabled!");
    }
 catch (    ElasticsearchSecurityException e) {
      assertThat(e.status(),is(RestStatus.FORBIDDEN));
      assertThat(e.getMessage(),containsString("non-compliant"));
      assertThat(e.getMetadata(LicenseUtils.EXPIRED_FEATURE_METADATA),hasItem(XPackField.MACHINE_LEARNING));
    }
    mode=randomValidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(true);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutDatafeedAction.Response> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putDatafeed(new PutDatafeedAction.Request(createDatafeed(datafeedId,jobId,Collections.singletonList(jobId))),listener);
      PutDatafeedAction.Response response=listener.actionGet();
      assertNotNull(response);
    }
   }
  public void testAutoCloseJobWithDatafeed() throws Exception {
    String jobId="testautoclosejobwithdatafeed";
    String datafeedId=jobId + "-datafeed";
    assertMLAllowed(true);
    String datafeedIndex=jobId + "-data";
    prepareCreate(datafeedIndex).addMapping("type","{\"type\":{\"properties\":{\"time\":{\"type\":\"date\"}}}}",XContentType.JSON).get();
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response putJobResponse=putJobListener.actionGet();
      assertNotNull(putJobResponse);
      PlainActionFuture<PutDatafeedAction.Response> putDatafeedListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putDatafeed(new PutDatafeedAction.Request(createDatafeed(datafeedId,jobId,Collections.singletonList(datafeedIndex))),putDatafeedListener);
      PutDatafeedAction.Response putDatafeedResponse=putDatafeedListener.actionGet();
      assertNotNull(putDatafeedResponse);
      PlainActionFuture<AcknowledgedResponse> openJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),openJobListener);
      AcknowledgedResponse openJobResponse=openJobListener.actionGet();
      assertNotNull(openJobResponse);
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).startDatafeed(new StartDatafeedAction.Request(datafeedId,0L),listener);
      listener.actionGet();
    }
     if (randomBoolean()) {
      enableLicensing(randomInvalidLicenseType());
    }
 else {
      disableLicensing();
    }
    assertMLAllowed(false);
    assertBusy(() -> {
      JobState jobState=getJobStats(jobId).getState();
      assertEquals(JobState.CLOSED,jobState);
      DatafeedState datafeedState=getDatafeedStats(datafeedId).getDatafeedState();
      assertEquals(DatafeedState.STOPPED,datafeedState);
      ClusterState state=client().admin().cluster().prepareState().get().getState();
      PersistentTasksCustomMetaData tasks=state.metaData().custom(PersistentTasksCustomMetaData.TYPE);
      assertEquals(0,tasks.taskMap().size());
    }
);
    enableLicensing(randomValidLicenseType());
    assertMLAllowed(true);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<AcknowledgedResponse> openJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),openJobListener);
      AcknowledgedResponse openJobResponse=openJobListener.actionGet();
      assertNotNull(openJobResponse);
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).startDatafeed(new StartDatafeedAction.Request(datafeedId,0L),listener);
      listener.actionGet();
    }
     assertBusy(() -> {
      JobState jobState=getJobStats(jobId).getState();
      assertEquals(JobState.OPENED,jobState);
      DatafeedState datafeedState=getDatafeedStats(datafeedId).getDatafeedState();
      assertEquals(DatafeedState.STARTED,datafeedState);
      ClusterState state=client().admin().cluster().prepareState().get().getState();
      PersistentTasksCustomMetaData tasks=state.metaData().custom(PersistentTasksCustomMetaData.TYPE);
      assertEquals(2,tasks.taskMap().size());
    }
);
    if (randomBoolean()) {
      enableLicensing(randomInvalidLicenseType());
    }
 else {
      disableLicensing();
    }
    assertMLAllowed(false);
    assertBusy(() -> {
      JobState jobState=getJobStats(jobId).getState();
      assertEquals(JobState.CLOSED,jobState);
      DatafeedState datafeedState=getDatafeedStats(datafeedId).getDatafeedState();
      assertEquals(DatafeedState.STOPPED,datafeedState);
      ClusterState state=client().admin().cluster().prepareState().get().getState();
      PersistentTasksCustomMetaData tasks=state.metaData().custom(PersistentTasksCustomMetaData.TYPE);
      assertEquals(0,tasks.taskMap().size());
    }
);
  }
  public void testMachineLearningStartDatafeedActionRestricted() throws Exception {
    String jobId="testmachinelearningstartdatafeedactionrestricted";
    String datafeedId=jobId + "-datafeed";
    assertMLAllowed(true);
    String datafeedIndex=jobId + "-data";
    prepareCreate(datafeedIndex).addMapping("type","{\"type\":{\"properties\":{\"time\":{\"type\":\"date\"}}}}",XContentType.JSON).get();
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response putJobResponse=putJobListener.actionGet();
      assertNotNull(putJobResponse);
      PlainActionFuture<PutDatafeedAction.Response> putDatafeedListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putDatafeed(new PutDatafeedAction.Request(createDatafeed(datafeedId,jobId,Collections.singletonList(datafeedIndex))),putDatafeedListener);
      PutDatafeedAction.Response putDatafeedResponse=putDatafeedListener.actionGet();
      assertNotNull(putDatafeedResponse);
      PlainActionFuture<AcknowledgedResponse> openJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),openJobListener);
      AcknowledgedResponse openJobResponse=openJobListener.actionGet();
      assertNotNull(openJobResponse);
    }
     License.OperationMode mode=randomInvalidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(false);
    assertBusy(() -> {
      JobState jobState=getJobStats(jobId).getState();
      assertEquals(JobState.CLOSED,jobState);
      ClusterState state=client().admin().cluster().prepareState().get().getState();
      PersistentTasksCustomMetaData tasks=state.metaData().custom(PersistentTasksCustomMetaData.TYPE);
      assertEquals(0,tasks.taskMap().size());
    }
);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).startDatafeed(new StartDatafeedAction.Request(datafeedId,0L),listener);
      listener.actionGet();
      fail("start datafeed action should not be enabled!");
    }
 catch (    ElasticsearchSecurityException e) {
      assertThat(e.status(),is(RestStatus.FORBIDDEN));
      assertThat(e.getMessage(),containsString("non-compliant"));
      assertThat(e.getMetadata(LicenseUtils.EXPIRED_FEATURE_METADATA),hasItem(XPackField.MACHINE_LEARNING));
    }
    mode=randomValidLicenseType();
    enableLicensing(mode);
    assertMLAllowed(true);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<AcknowledgedResponse> openJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),openJobListener);
      AcknowledgedResponse openJobResponse=openJobListener.actionGet();
      assertNotNull(openJobResponse);
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).startDatafeed(new StartDatafeedAction.Request(datafeedId,0L),listener);
      AcknowledgedResponse response=listener.actionGet();
      assertNotNull(response);
    }
   }
  public void testMachineLearningStopDatafeedActionNotRestricted() throws Exception {
    String jobId="testmachinelearningstopdatafeedactionnotrestricted";
    String datafeedId=jobId + "-datafeed";
    assertMLAllowed(true);
    String datafeedIndex=jobId + "-data";
    prepareCreate(datafeedIndex).addMapping("type","{\"type\":{\"properties\":{\"time\":{\"type\":\"date\"}}}}",XContentType.JSON).get();
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response putJobResponse=putJobListener.actionGet();
      assertNotNull(putJobResponse);
      PlainActionFuture<PutDatafeedAction.Response> putDatafeedListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putDatafeed(new PutDatafeedAction.Request(createDatafeed(datafeedId,jobId,Collections.singletonList(datafeedIndex))),putDatafeedListener);
      PutDatafeedAction.Response putDatafeedResponse=putDatafeedListener.actionGet();
      assertNotNull(putDatafeedResponse);
      PlainActionFuture<AcknowledgedResponse> openJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),openJobListener);
      AcknowledgedResponse openJobResponse=openJobListener.actionGet();
      assertNotNull(openJobResponse);
      PlainActionFuture<AcknowledgedResponse> startDatafeedListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).startDatafeed(new StartDatafeedAction.Request(datafeedId,0L),startDatafeedListener);
      AcknowledgedResponse startDatafeedResponse=startDatafeedListener.actionGet();
      assertNotNull(startDatafeedResponse);
    }
     boolean invalidLicense=randomBoolean();
    if (invalidLicense) {
      enableLicensing(randomInvalidLicenseType());
    }
 else {
      enableLicensing(randomValidLicenseType());
    }
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<StopDatafeedAction.Response> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).stopDatafeed(new StopDatafeedAction.Request(datafeedId),listener);
      if (invalidLicense) {
        assertBusy(() -> {
          GetDatafeedsStatsAction.Response response=new MachineLearningClient(client).getDatafeedsStats(new GetDatafeedsStatsAction.Request(datafeedId)).actionGet();
          assertEquals(DatafeedState.STOPPED,response.getResponse().results().get(0).getDatafeedState());
        }
);
      }
 else {
        listener.actionGet();
      }
      if (invalidLicense) {
        assertBusy(() -> {
          GetJobsStatsAction.Response response=new MachineLearningClient(client).getJobsStats(new GetJobsStatsAction.Request(jobId)).actionGet();
          assertEquals(JobState.CLOSED,response.getResponse().results().get(0).getState());
        }
);
      }
    }
   }
  public void testMachineLearningCloseJobActionNotRestricted() throws Exception {
    String jobId="testmachinelearningclosejobactionnotrestricted";
    assertMLAllowed(true);
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response putJobResponse=putJobListener.actionGet();
      assertNotNull(putJobResponse);
      PlainActionFuture<AcknowledgedResponse> openJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).openJob(new OpenJobAction.Request(jobId),openJobListener);
      AcknowledgedResponse openJobResponse=openJobListener.actionGet();
      assertNotNull(openJobResponse);
    }
     boolean invalidLicense=randomBoolean();
    if (invalidLicense) {
      enableLicensing(randomInvalidLicenseType());
    }
 else {
      enableLicensing(randomValidLicenseType());
    }
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<CloseJobAction.Response> listener=PlainActionFuture.newFuture();
      CloseJobAction.Request request=new CloseJobAction.Request(jobId);
      request.setCloseTimeout(TimeValue.timeValueSeconds(20));
      if (invalidLicense) {
        assertBusy(() -> {
          GetJobsStatsAction.Response response=new MachineLearningClient(client).getJobsStats(new GetJobsStatsAction.Request(jobId)).actionGet();
          assertEquals(JobState.CLOSED,response.getResponse().results().get(0).getState());
        }
);
      }
 else {
        new MachineLearningClient(client).closeJob(request,listener);
        listener.actionGet();
      }
    }
   }
  public void testMachineLearningDeleteJobActionNotRestricted() throws Exception {
    String jobId="testmachinelearningclosejobactionnotrestricted";
    assertMLAllowed(true);
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response putJobResponse=putJobListener.actionGet();
      assertNotNull(putJobResponse);
    }
     License.OperationMode mode=randomLicenseType();
    enableLicensing(mode);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).deleteJob(new DeleteJobAction.Request(jobId),listener);
      listener.actionGet();
    }
   }
  public void testMachineLearningDeleteDatafeedActionNotRestricted() throws Exception {
    String jobId="testmachinelearningdeletedatafeedactionnotrestricted";
    String datafeedId=jobId + "-datafeed";
    assertMLAllowed(true);
    Settings settings=internalCluster().transportClient().settings();
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<PutJobAction.Response> putJobListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putJob(new PutJobAction.Request(createJob(jobId)),putJobListener);
      PutJobAction.Response putJobResponse=putJobListener.actionGet();
      assertNotNull(putJobResponse);
      PlainActionFuture<PutDatafeedAction.Response> putDatafeedListener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).putDatafeed(new PutDatafeedAction.Request(createDatafeed(datafeedId,jobId,Collections.singletonList(jobId))),putDatafeedListener);
      PutDatafeedAction.Response putDatafeedResponse=putDatafeedListener.actionGet();
      assertNotNull(putDatafeedResponse);
    }
     License.OperationMode mode=randomLicenseType();
    enableLicensing(mode);
    try (TransportClient client=new TestXPackTransportClient(settings,LocalStateMachineLearning.class)){
      client.addTransportAddress(internalCluster().getDataNodeInstance(Transport.class).boundAddress().publishAddress());
      PlainActionFuture<AcknowledgedResponse> listener=PlainActionFuture.newFuture();
      new MachineLearningClient(client).deleteDatafeed(new DeleteDatafeedAction.Request(datafeedId),listener);
      listener.actionGet();
    }
   }
  private static OperationMode randomInvalidLicenseType(){
    return randomFrom(License.OperationMode.GOLD,License.OperationMode.STANDARD,License.OperationMode.BASIC);
  }
  private static OperationMode randomValidLicenseType(){
    return randomFrom(License.OperationMode.TRIAL,License.OperationMode.PLATINUM);
  }
  private static OperationMode randomLicenseType(){
    return randomFrom(License.OperationMode.values());
  }
  private static void assertMLAllowed(  boolean expected){
    for (    XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {
      assertEquals(licenseState.isMachineLearningAllowed(),expected);
    }
  }
  public static void disableLicensing(){
    disableLicensing(randomValidLicenseType());
  }
  public static void disableLicensing(  License.OperationMode operationMode){
    for (    XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {
      licenseState.update(operationMode,false,null);
    }
  }
  public static void enableLicensing(){
    enableLicensing(randomValidLicenseType());
  }
  public static void enableLicensing(  License.OperationMode operationMode){
    for (    XPackLicenseState licenseState : internalCluster().getInstances(XPackLicenseState.class)) {
      licenseState.update(operationMode,true,null);
    }
  }
}
