public class IndexUpgradeIT extends IndexUpgradeIntegTestCase {
  @Before public void resetLicensing() throws Exception {
    enableLicensing();
  }
  public void testIndexUpgradeInfo(){
    assertAcked(client().admin().indices().prepareCreate("test").get());
    ensureYellow("test");
    IndexUpgradeInfoResponse response=client().prepareExecute(IndexUpgradeInfoAction.INSTANCE).setIndices("test").get();
    assertThat(response.getActions().entrySet(),empty());
  }
  public void testIndexUpgradeInfoLicense() throws Exception {
    assumeTrue("License is only valid when tested against snapshot/test keys",Build.CURRENT.isSnapshot());
    assertAcked(client().admin().indices().prepareCreate("test").get());
    ensureYellow("test");
    disableLicensing();
    ElasticsearchSecurityException e=expectThrows(ElasticsearchSecurityException.class,() -> client().prepareExecute(IndexUpgradeInfoAction.INSTANCE).setIndices("test").get());
    assertThat(e.getMessage(),equalTo("current license is non-compliant for [upgrade]"));
    enableLicensing();
    IndexUpgradeInfoResponse response=client().prepareExecute(IndexUpgradeInfoAction.INSTANCE).setIndices("test").get();
    assertThat(response.getActions().entrySet(),empty());
  }
  public void testUpToDateIndexUpgrade() throws Exception {
    String testIndex="test";
    String testType="doc";
    assertAcked(client().admin().indices().prepareCreate(testIndex).get());
    indexRandom(true,client().prepareIndex(testIndex,testType,"1").setSource("{\"foo\":\"bar\"}",XContentType.JSON),client().prepareIndex(testIndex,testType,"2").setSource("{\"foo\":\"baz\"}",XContentType.JSON));
    ensureYellow(testIndex);
    IllegalStateException ex=expectThrows(IllegalStateException.class,() -> client().prepareExecute(IndexUpgradeAction.INSTANCE).setIndex(testIndex).get());
    assertThat(ex.getMessage(),equalTo("Index [" + testIndex + "] cannot be upgraded"));
    SearchResponse searchResponse=client().prepareSearch(testIndex).get();
    assertEquals(2L,searchResponse.getHits().getTotalHits());
  }
  public void testInternalUpgradePrePostChecks() throws Exception {
    String testIndex="internal_index";
    String testType="test";
    Long val=randomLong();
    AtomicBoolean preUpgradeIsCalled=new AtomicBoolean();
    AtomicBoolean postUpgradeIsCalled=new AtomicBoolean();
    IndexUpgradeCheck check=new IndexUpgradeCheck<Long>("test",Settings.EMPTY,indexMetaData -> {
      if (indexMetaData.getIndex().getName().equals(testIndex)) {
        return UpgradeActionRequired.UPGRADE;
      }
 else {
        return UpgradeActionRequired.NOT_APPLICABLE;
      }
    }
,client(),internalCluster().clusterService(internalCluster().getMasterName()),Strings.EMPTY_ARRAY,null,listener -> {
      assertFalse(preUpgradeIsCalled.getAndSet(true));
      assertFalse(postUpgradeIsCalled.get());
      listener.onResponse(val);
    }
,(aLong,listener) -> {
      assertTrue(preUpgradeIsCalled.get());
      assertFalse(postUpgradeIsCalled.getAndSet(true));
      assertEquals(aLong,val);
      listener.onResponse(TransportResponse.Empty.INSTANCE);
    }
);
    assertAcked(client().admin().indices().prepareCreate(testIndex).get());
    indexRandom(true,client().prepareIndex(testIndex,testType,"1").setSource("{\"foo\":\"bar\"}",XContentType.JSON),client().prepareIndex(testIndex,testType,"2").setSource("{\"foo\":\"baz\"}",XContentType.JSON));
    ensureYellow(testIndex);
    IndexUpgradeService service=new IndexUpgradeService(Settings.EMPTY,Collections.singletonList(check));
    PlainActionFuture<BulkByScrollResponse> future=PlainActionFuture.newFuture();
    service.upgrade(new TaskId("abc",123),testIndex,clusterService().state(),future);
    BulkByScrollResponse response=future.actionGet();
    assertThat(response.getCreated(),equalTo(2L));
    SearchResponse searchResponse=client().prepareSearch(testIndex).get();
    assertEquals(2L,searchResponse.getHits().getTotalHits());
    assertTrue(preUpgradeIsCalled.get());
    assertTrue(postUpgradeIsCalled.get());
  }
  public void testIndexUpgradeInfoOnEmptyCluster(){
    IndexUpgradeInfoResponse response=client().prepareExecute(IndexUpgradeInfoAction.INSTANCE).setIndices("_all").get();
    assertThat(response.getActions().entrySet(),empty());
    assertThrows(client().prepareExecute(IndexUpgradeInfoAction.INSTANCE).setIndices("test"),IndexNotFoundException.class);
  }
}
