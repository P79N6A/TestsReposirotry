public class Netty4HttpChannelTests extends ESTestCase {
  private NetworkService networkService;
  private ThreadPool threadPool;
  private MockBigArrays bigArrays;
  @Before public void setup() throws Exception {
    networkService=new NetworkService(Collections.emptyList());
    threadPool=new TestThreadPool("test");
    bigArrays=new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY),new NoneCircuitBreakerService());
  }
  @After public void shutdown() throws Exception {
    if (threadPool != null) {
      threadPool.shutdownNow();
    }
  }
  public void testResponse(){
    final FullHttpResponse response=executeRequest(Settings.EMPTY,"request-host");
    assertThat(response.content(),equalTo(Netty4Utils.toByteBuf(new TestResponse().content())));
  }
  public void testCorsEnabledWithoutAllowOrigins(){
    Settings settings=Settings.builder().put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(),true).build();
    HttpResponse response=executeRequest(settings,"remote-host","request-host");
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),nullValue());
  }
  public void testCorsEnabledWithAllowOrigins(){
    final String originValue="remote-host";
    Settings settings=Settings.builder().put(SETTING_CORS_ENABLED.getKey(),true).put(SETTING_CORS_ALLOW_ORIGIN.getKey(),originValue).build();
    HttpResponse response=executeRequest(settings,originValue,"request-host");
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),notNullValue());
    String allowedOrigins=response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
    assertThat(allowedOrigins,is(originValue));
  }
  public void testCorsAllowOriginWithSameHost(){
    String originValue="remote-host";
    String host="remote-host";
    Settings settings=Settings.builder().put(SETTING_CORS_ENABLED.getKey(),true).build();
    HttpResponse response=executeRequest(settings,originValue,host);
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),notNullValue());
    String allowedOrigins=response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
    assertThat(allowedOrigins,is(originValue));
    originValue="http://" + originValue;
    response=executeRequest(settings,originValue,host);
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),notNullValue());
    allowedOrigins=response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
    assertThat(allowedOrigins,is(originValue));
    originValue=originValue + ":5555";
    host=host + ":5555";
    response=executeRequest(settings,originValue,host);
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),notNullValue());
    allowedOrigins=response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
    assertThat(allowedOrigins,is(originValue));
    originValue=originValue.replace("http","https");
    response=executeRequest(settings,originValue,host);
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),notNullValue());
    allowedOrigins=response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
    assertThat(allowedOrigins,is(originValue));
  }
  public void testThatStringLiteralWorksOnMatch(){
    final String originValue="remote-host";
    Settings settings=Settings.builder().put(SETTING_CORS_ENABLED.getKey(),true).put(SETTING_CORS_ALLOW_ORIGIN.getKey(),originValue).put(SETTING_CORS_ALLOW_METHODS.getKey(),"get, options, post").put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(),true).build();
    HttpResponse response=executeRequest(settings,originValue,"request-host");
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),notNullValue());
    String allowedOrigins=response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
    assertThat(allowedOrigins,is(originValue));
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS),equalTo("true"));
  }
  public void testThatAnyOriginWorks(){
    final String originValue=Netty4CorsHandler.ANY_ORIGIN;
    Settings settings=Settings.builder().put(SETTING_CORS_ENABLED.getKey(),true).put(SETTING_CORS_ALLOW_ORIGIN.getKey(),originValue).build();
    HttpResponse response=executeRequest(settings,originValue,"request-host");
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN),notNullValue());
    String allowedOrigins=response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
    assertThat(allowedOrigins,is(originValue));
    assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS),nullValue());
  }
  public void testHeadersSet(){
    Settings settings=Settings.builder().build();
    try (Netty4HttpServerTransport httpServerTransport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,xContentRegistry(),new NullDispatcher())){
      httpServerTransport.start();
      final FullHttpRequest httpRequest=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,"/");
      httpRequest.headers().add(HttpHeaderNames.ORIGIN,"remote");
      final WriteCapturingChannel writeCapturingChannel=new WriteCapturingChannel();
      Netty4HttpRequest request=new Netty4HttpRequest(xContentRegistry(),httpRequest,writeCapturingChannel);
      Netty4HttpChannel channel=new Netty4HttpChannel(httpServerTransport,request,null,randomBoolean(),threadPool.getThreadContext());
      TestResponse resp=new TestResponse();
      final String customHeader="custom-header";
      final String customHeaderValue="xyz";
      resp.addHeader(customHeader,customHeaderValue);
      channel.sendResponse(resp);
      List<Object> writtenObjects=writeCapturingChannel.getWrittenObjects();
      assertThat(writtenObjects.size(),is(1));
      HttpResponse response=(HttpResponse)writtenObjects.get(0);
      assertThat(response.headers().get("non-existent-header"),nullValue());
      assertThat(response.headers().get(customHeader),equalTo(customHeaderValue));
      assertThat(response.headers().get(HttpHeaderNames.CONTENT_LENGTH),equalTo(Integer.toString(resp.content().length())));
      assertThat(response.headers().get(HttpHeaderNames.CONTENT_TYPE),equalTo(resp.contentType()));
    }
   }
  public void testReleaseOnSendToClosedChannel(){
    final Settings settings=Settings.builder().build();
    final NamedXContentRegistry registry=xContentRegistry();
    try (Netty4HttpServerTransport httpServerTransport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,registry,new NullDispatcher())){
      final FullHttpRequest httpRequest=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,"/");
      final EmbeddedChannel embeddedChannel=new EmbeddedChannel();
      final Netty4HttpRequest request=new Netty4HttpRequest(registry,httpRequest,embeddedChannel);
      final HttpPipelinedRequest pipelinedRequest=randomBoolean() ? new HttpPipelinedRequest(request.request(),1) : null;
      final Netty4HttpChannel channel=new Netty4HttpChannel(httpServerTransport,request,pipelinedRequest,randomBoolean(),threadPool.getThreadContext());
      final TestResponse response=new TestResponse(bigArrays);
      assertThat(response.content(),instanceOf(Releasable.class));
      embeddedChannel.close();
      channel.sendResponse(response);
    }
   }
  public void testReleaseOnSendToChannelAfterException() throws IOException {
    final Settings settings=Settings.builder().build();
    final NamedXContentRegistry registry=xContentRegistry();
    try (Netty4HttpServerTransport httpServerTransport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,registry,new NullDispatcher())){
      final FullHttpRequest httpRequest=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,"/");
      final EmbeddedChannel embeddedChannel=new EmbeddedChannel();
      final Netty4HttpRequest request=new Netty4HttpRequest(registry,httpRequest,embeddedChannel);
      final HttpPipelinedRequest pipelinedRequest=randomBoolean() ? new HttpPipelinedRequest(request.request(),1) : null;
      final Netty4HttpChannel channel=new Netty4HttpChannel(httpServerTransport,request,pipelinedRequest,randomBoolean(),threadPool.getThreadContext());
      final BytesRestResponse response=new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR,JsonXContent.contentBuilder().startObject().endObject());
      assertThat(response.content(),not(instanceOf(Releasable.class)));
      if (randomBoolean()) {
        BytesStreamOutput out=channel.bytesOutput();
        assertThat(out,instanceOf(ReleasableBytesStreamOutput.class));
      }
 else {
        try (XContentBuilder builder=channel.newBuilder()){
          builder.startObject().endObject();
        }
       }
      channel.sendResponse(response);
    }
   }
  public void testConnectionClose() throws Exception {
    final Settings settings=Settings.builder().build();
    try (Netty4HttpServerTransport httpServerTransport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,xContentRegistry(),new NullDispatcher())){
      httpServerTransport.start();
      final FullHttpRequest httpRequest;
      final boolean close=randomBoolean();
      if (randomBoolean()) {
        httpRequest=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,"/");
        if (close) {
          httpRequest.headers().add(HttpHeaderNames.CONNECTION,HttpHeaderValues.CLOSE);
        }
      }
 else {
        httpRequest=new DefaultFullHttpRequest(HttpVersion.HTTP_1_0,HttpMethod.GET,"/");
        if (!close) {
          httpRequest.headers().add(HttpHeaderNames.CONNECTION,HttpHeaderValues.KEEP_ALIVE);
        }
      }
      final EmbeddedChannel embeddedChannel=new EmbeddedChannel();
      final Netty4HttpRequest request=new Netty4HttpRequest(xContentRegistry(),httpRequest,embeddedChannel);
      assertTrue(embeddedChannel.isOpen());
      final Netty4HttpChannel channel=new Netty4HttpChannel(httpServerTransport,request,null,randomBoolean(),threadPool.getThreadContext());
      final TestResponse resp=new TestResponse();
      channel.sendResponse(resp);
      assertThat(embeddedChannel.isOpen(),equalTo(!close));
    }
   }
  private FullHttpResponse executeRequest(  final Settings settings,  final String host){
    return executeRequest(settings,null,host);
  }
  private FullHttpResponse executeRequest(  final Settings settings,  final String originValue,  final String host){
    try (Netty4HttpServerTransport httpServerTransport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,xContentRegistry(),new NullDispatcher())){
      httpServerTransport.start();
      final FullHttpRequest httpRequest=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,"/");
      if (originValue != null) {
        httpRequest.headers().add(HttpHeaderNames.ORIGIN,originValue);
      }
      httpRequest.headers().add(HttpHeaderNames.HOST,host);
      final WriteCapturingChannel writeCapturingChannel=new WriteCapturingChannel();
      final Netty4HttpRequest request=new Netty4HttpRequest(xContentRegistry(),httpRequest,writeCapturingChannel);
      Netty4HttpChannel channel=new Netty4HttpChannel(httpServerTransport,request,null,randomBoolean(),threadPool.getThreadContext());
      channel.sendResponse(new TestResponse());
      List<Object> writtenObjects=writeCapturingChannel.getWrittenObjects();
      assertThat(writtenObjects.size(),is(1));
      return (FullHttpResponse)writtenObjects.get(0);
    }
   }
private static class WriteCapturingChannel implements Channel {
    private List<Object> writtenObjects=new ArrayList<>();
    @Override public ChannelId id(){
      return null;
    }
    @Override public EventLoop eventLoop(){
      return null;
    }
    @Override public Channel parent(){
      return null;
    }
    @Override public ChannelConfig config(){
      return null;
    }
    @Override public boolean isOpen(){
      return false;
    }
    @Override public boolean isRegistered(){
      return false;
    }
    @Override public boolean isActive(){
      return false;
    }
    @Override public ChannelMetadata metadata(){
      return null;
    }
    @Override public SocketAddress localAddress(){
      return null;
    }
    @Override public SocketAddress remoteAddress(){
      return null;
    }
    @Override public ChannelFuture closeFuture(){
      return null;
    }
    @Override public boolean isWritable(){
      return false;
    }
    @Override public long bytesBeforeUnwritable(){
      return 0;
    }
    @Override public long bytesBeforeWritable(){
      return 0;
    }
    @Override public Unsafe unsafe(){
      return null;
    }
    @Override public ChannelPipeline pipeline(){
      return null;
    }
    @Override public ByteBufAllocator alloc(){
      return null;
    }
    @Override public Channel read(){
      return null;
    }
    @Override public Channel flush(){
      return null;
    }
    @Override public ChannelFuture bind(    SocketAddress localAddress){
      return null;
    }
    @Override public ChannelFuture connect(    SocketAddress remoteAddress){
      return null;
    }
    @Override public ChannelFuture connect(    SocketAddress remoteAddress,    SocketAddress localAddress){
      return null;
    }
    @Override public ChannelFuture disconnect(){
      return null;
    }
    @Override public ChannelFuture close(){
      return null;
    }
    @Override public ChannelFuture deregister(){
      return null;
    }
    @Override public ChannelFuture bind(    SocketAddress localAddress,    ChannelPromise promise){
      return null;
    }
    @Override public ChannelFuture connect(    SocketAddress remoteAddress,    ChannelPromise promise){
      return null;
    }
    @Override public ChannelFuture connect(    SocketAddress remoteAddress,    SocketAddress localAddress,    ChannelPromise promise){
      return null;
    }
    @Override public ChannelFuture disconnect(    ChannelPromise promise){
      return null;
    }
    @Override public ChannelFuture close(    ChannelPromise promise){
      return null;
    }
    @Override public ChannelFuture deregister(    ChannelPromise promise){
      return null;
    }
    @Override public ChannelFuture write(    Object msg){
      writtenObjects.add(msg);
      return null;
    }
    @Override public ChannelFuture write(    Object msg,    ChannelPromise promise){
      writtenObjects.add(msg);
      return null;
    }
    @Override public ChannelFuture writeAndFlush(    Object msg,    ChannelPromise promise){
      writtenObjects.add(msg);
      return null;
    }
    @Override public ChannelFuture writeAndFlush(    Object msg){
      writtenObjects.add(msg);
      return null;
    }
    @Override public ChannelPromise newPromise(){
      return null;
    }
    @Override public ChannelProgressivePromise newProgressivePromise(){
      return null;
    }
    @Override public ChannelFuture newSucceededFuture(){
      return null;
    }
    @Override public ChannelFuture newFailedFuture(    Throwable cause){
      return null;
    }
    @Override public ChannelPromise voidPromise(){
      return null;
    }
    @Override public <T>Attribute<T> attr(    AttributeKey<T> key){
      return null;
    }
    @Override public <T>boolean hasAttr(    AttributeKey<T> key){
      return false;
    }
    @Override public int compareTo(    Channel o){
      return 0;
    }
    List<Object> getWrittenObjects(){
      return writtenObjects;
    }
  }
private static class TestResponse extends RestResponse {
    private final BytesReference reference;
    TestResponse(){
      reference=Netty4Utils.toBytesReference(Unpooled.copiedBuffer("content",StandardCharsets.UTF_8));
    }
    TestResponse(    final BigArrays bigArrays){
      final byte[] bytes;
      try {
        bytes="content".getBytes("UTF-8");
      }
 catch (      final UnsupportedEncodingException e) {
        throw new AssertionError(e);
      }
      final ByteArray bigArray=bigArrays.newByteArray(bytes.length);
      bigArray.set(0,bytes,0,bytes.length);
      reference=new ReleasablePagedBytesReference(bigArrays,bigArray,bytes.length,Releasables.releaseOnce(bigArray));
    }
    @Override public String contentType(){
      return "text";
    }
    @Override public BytesReference content(){
      return reference;
    }
    @Override public RestStatus status(){
      return RestStatus.OK;
    }
  }
}
