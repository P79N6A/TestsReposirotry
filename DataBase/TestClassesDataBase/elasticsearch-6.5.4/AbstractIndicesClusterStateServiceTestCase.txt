/** 
 * Abstract base class for tests against  {@link IndicesClusterStateService}
 */
public abstract class AbstractIndicesClusterStateServiceTestCase extends ESTestCase {
  private boolean enableRandomFailures;
  @Before public void injectRandomFailures(){
    enableRandomFailures=randomBoolean();
  }
  protected void disableRandomFailures(){
    enableRandomFailures=false;
  }
  protected void failRandomly(){
    if (enableRandomFailures && rarely()) {
      throw new RuntimeException("dummy test failure");
    }
  }
  /** 
 * Checks if cluster state matches internal state of IndicesClusterStateService instance
 * @param state cluster state used for matching
 */
  public void assertClusterStateMatchesNodeState(  ClusterState state,  IndicesClusterStateService indicesClusterStateService){
    MockIndicesService indicesService=(MockIndicesService)indicesClusterStateService.indicesService;
    ConcurrentMap<ShardId,ShardRouting> failedShardsCache=indicesClusterStateService.failedShardsCache;
    RoutingNode localRoutingNode=state.getRoutingNodes().node(state.getNodes().getLocalNodeId());
    if (localRoutingNode != null) {
      if (enableRandomFailures == false) {
        if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {
          fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values());
        }
      }
      for (      ShardRouting shardRouting : localRoutingNode) {
        Index index=shardRouting.index();
        IndexMetaData indexMetaData=state.metaData().getIndexSafe(index);
        MockIndexShard shard=indicesService.getShardOrNull(shardRouting.shardId());
        ShardRouting failedShard=failedShardsCache.get(shardRouting.shardId());
        if (state.blocks().disableStatePersistence()) {
          if (shard != null) {
            fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence");
          }
        }
 else {
          if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {
            fail("Shard cache has not been properly cleaned for " + failedShard);
          }
          if (shard == null && failedShard == null) {
            fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache");
          }
          if (enableRandomFailures == false) {
            if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {
              fail("Shard with id " + shardRouting + " expected but missing in indicesService "+ failedShard);
            }
          }
          if (shard != null) {
            AllocatedIndex<? extends Shard> indexService=indicesService.indexService(index);
            assertTrue("Index " + index + " expected but missing in indicesService",indexService != null);
            assertThat(indexService.getIndexSettings().getIndexMetaData(),equalTo(indexMetaData));
            if (enableRandomFailures == false || failedShard == null) {
              assertTrue("Shard with id " + shardRouting + " expected but missing in indexService",shard != null);
              assertThat(shard.routingEntry(),equalTo(shardRouting));
            }
            if (shard.routingEntry().primary() && shard.routingEntry().active()) {
              IndexShardRoutingTable shardRoutingTable=state.routingTable().shardRoutingTable(shard.shardId());
              Set<String> inSyncIds=state.metaData().index(shard.shardId().getIndex()).inSyncAllocationIds(shard.shardId().id());
              assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs",shard.inSyncAllocationIds,equalTo(inSyncIds));
              assertThat(shard.routingEntry() + " isn't updated with routing table",shard.routingTable,equalTo(shardRoutingTable));
            }
          }
        }
      }
    }
    for (    AllocatedIndex<? extends Shard> indexService : indicesService) {
      if (state.blocks().disableStatePersistence()) {
        fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence");
      }
      assertTrue(state.metaData().getIndexSafe(indexService.index()) != null);
      boolean shardsFound=false;
      for (      Shard shard : indexService) {
        shardsFound=true;
        ShardRouting persistedShardRouting=shard.routingEntry();
        ShardRouting shardRouting=localRoutingNode.getByShardId(persistedShardRouting.shardId());
        if (shardRouting == null) {
          fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table");
        }
        if (shardRouting.equals(persistedShardRouting) == false) {
          fail("Local shard " + persistedShardRouting + " has stale routing"+ shardRouting);
        }
      }
      if (shardsFound == false) {
        assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())));
      }
    }
  }
  /** 
 * Mock for  {@link IndicesService}
 */
protected class MockIndicesService implements AllocatedIndices<MockIndexShard,MockIndexService> {
    private volatile Map<String,MockIndexService> indices=emptyMap();
    @Override public synchronized MockIndexService createIndex(    IndexMetaData indexMetaData,    List<IndexEventListener> buildInIndexListener) throws IOException {
      MockIndexService indexService=new MockIndexService(new IndexSettings(indexMetaData,Settings.EMPTY));
      indices=newMapBuilder(indices).put(indexMetaData.getIndexUUID(),indexService).immutableMap();
      return indexService;
    }
    @Override public IndexMetaData verifyIndexIsDeleted(    Index index,    ClusterState state){
      return null;
    }
    @Override public void deleteUnassignedIndex(    String reason,    IndexMetaData metaData,    ClusterState clusterState){
    }
    @Override public synchronized void removeIndex(    Index index,    IndexRemovalReason reason,    String extraInfo){
      if (hasIndex(index)) {
        Map<String,MockIndexService> newIndices=new HashMap<>(indices);
        newIndices.remove(index.getUUID());
        indices=unmodifiableMap(newIndices);
      }
    }
    @Override @Nullable public MockIndexService indexService(    Index index){
      return indices.get(index.getUUID());
    }
    @Override public MockIndexShard createShard(    ShardRouting shardRouting,    RecoveryState recoveryState,    PeerRecoveryTargetService recoveryTargetService,    PeerRecoveryTargetService.RecoveryListener recoveryListener,    RepositoriesService repositoriesService,    Consumer<IndexShard.ShardFailure> onShardFailure,    Consumer<ShardId> globalCheckpointSyncer) throws IOException {
      failRandomly();
      MockIndexService indexService=indexService(recoveryState.getShardId().getIndex());
      MockIndexShard indexShard=indexService.createShard(shardRouting);
      indexShard.recoveryState=recoveryState;
      return indexShard;
    }
    @Override public void processPendingDeletes(    Index index,    IndexSettings indexSettings,    TimeValue timeValue) throws IOException, InterruptedException {
    }
    private boolean hasIndex(    Index index){
      return indices.containsKey(index.getUUID());
    }
    @Override public Iterator<MockIndexService> iterator(){
      return indices.values().iterator();
    }
  }
  /** 
 * Mock for  {@link IndexService}
 */
protected class MockIndexService implements AllocatedIndex<MockIndexShard> {
    private volatile Map<Integer,MockIndexShard> shards=emptyMap();
    private final IndexSettings indexSettings;
    public MockIndexService(    IndexSettings indexSettings){
      this.indexSettings=indexSettings;
    }
    @Override public IndexSettings getIndexSettings(){
      return indexSettings;
    }
    @Override public boolean updateMapping(    final IndexMetaData currentIndexMetaData,    final IndexMetaData newIndexMetaData) throws IOException {
      failRandomly();
      return false;
    }
    @Override public void updateMetaData(    final IndexMetaData currentIndexMetaData,    final IndexMetaData newIndexMetaData){
      indexSettings.updateIndexMetaData(newIndexMetaData);
      for (      MockIndexShard shard : shards.values()) {
        shard.updateTerm(newIndexMetaData.primaryTerm(shard.shardId().id()));
      }
    }
    @Override public MockIndexShard getShardOrNull(    int shardId){
      return shards.get(shardId);
    }
    public synchronized MockIndexShard createShard(    ShardRouting routing) throws IOException {
      failRandomly();
      MockIndexShard shard=new MockIndexShard(routing,indexSettings.getIndexMetaData().primaryTerm(routing.shardId().id()));
      shards=newMapBuilder(shards).put(routing.id(),shard).immutableMap();
      return shard;
    }
    @Override public synchronized void removeShard(    int shardId,    String reason){
      if (shards.containsKey(shardId) == false) {
        return;
      }
      HashMap<Integer,MockIndexShard> newShards=new HashMap<>(shards);
      MockIndexShard indexShard=newShards.remove(shardId);
      assert indexShard != null;
      shards=unmodifiableMap(newShards);
    }
    @Override public Iterator<MockIndexShard> iterator(){
      return shards.values().iterator();
    }
    @Override public Index index(){
      return indexSettings.getIndex();
    }
  }
  /** 
 * Mock for  {@link IndexShard}
 */
protected class MockIndexShard implements IndicesClusterStateService.Shard {
    private volatile long clusterStateVersion;
    private volatile ShardRouting shardRouting;
    private volatile RecoveryState recoveryState;
    private volatile Set<String> inSyncAllocationIds;
    private volatile IndexShardRoutingTable routingTable;
    private volatile long term;
    public MockIndexShard(    ShardRouting shardRouting,    long term){
      this.shardRouting=shardRouting;
      this.term=term;
    }
    @Override public ShardId shardId(){
      return shardRouting.shardId();
    }
    @Override public RecoveryState recoveryState(){
      return recoveryState;
    }
    @Override public void updateShardState(    ShardRouting shardRouting,    long newPrimaryTerm,    BiConsumer<IndexShard,ActionListener<ResyncTask>> primaryReplicaSyncer,    long applyingClusterStateVersion,    Set<String> inSyncAllocationIds,    IndexShardRoutingTable routingTable,    Set<String> pre60AllocationIds) throws IOException {
      failRandomly();
      assertThat(this.shardId(),equalTo(shardRouting.shardId()));
      assertTrue("current: " + this.shardRouting + ", got: "+ shardRouting,this.shardRouting.isSameAllocation(shardRouting));
      if (this.shardRouting.active()) {
        assertTrue("and active shard must stay active, current: " + this.shardRouting + ", got: "+ shardRouting,shardRouting.active());
      }
      if (this.shardRouting.primary()) {
        assertTrue("a primary shard can't be demoted",shardRouting.primary());
      }
 else       if (shardRouting.primary()) {
        assertTrue("a replica can only be promoted when active. current: " + this.shardRouting + " new: "+ shardRouting,shardRouting.active());
      }
      this.shardRouting=shardRouting;
      if (shardRouting.primary()) {
        term=newPrimaryTerm;
        this.clusterStateVersion=applyingClusterStateVersion;
        this.inSyncAllocationIds=inSyncAllocationIds;
        this.routingTable=routingTable;
      }
    }
    @Override public ShardRouting routingEntry(){
      return shardRouting;
    }
    @Override public IndexShardState state(){
      return null;
    }
    public void updateTerm(    long newTerm){
      assertThat("term can only be incremented: " + shardRouting,newTerm,greaterThanOrEqualTo(term));
      if (shardRouting.primary() && shardRouting.active()) {
        assertThat("term can not be changed on an active primary shard: " + shardRouting,newTerm,equalTo(term));
      }
      this.term=newTerm;
    }
  }
}
