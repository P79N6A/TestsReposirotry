public class DatafeedJobsIT extends MlNativeAutodetectIntegTestCase {
  @After public void cleanup() throws Exception {
    cleanUp();
  }
  public void testLookbackOnly() throws Exception {
    client().admin().indices().prepareCreate("data-1").addMapping("type","time","type=date").get();
    long numDocs=randomIntBetween(32,2048);
    long now=System.currentTimeMillis();
    long oneWeekAgo=now - 604800000;
    long twoWeeksAgo=oneWeekAgo - 604800000;
    indexDocs(logger,"data-1",numDocs,twoWeeksAgo,oneWeekAgo);
    client().admin().indices().prepareCreate("data-2").addMapping("type","time","type=date").get();
    client().admin().cluster().prepareHealth("data-1","data-2").setWaitForYellowStatus().get();
    long numDocs2=randomIntBetween(32,2048);
    indexDocs(logger,"data-2",numDocs2,oneWeekAgo,now);
    Job.Builder job=createScheduledJob("lookback-job");
    registerJob(job);
    PutJobAction.Response putJobResponse=putJob(job);
    assertThat(putJobResponse.getResponse().getJobVersion(),equalTo(Version.CURRENT));
    openJob(job.getId());
    assertBusy(() -> assertEquals(getJobStats(job.getId()).get(0).getState(),JobState.OPENED));
    List<String> t=new ArrayList<>(2);
    t.add("data-1");
    t.add("data-2");
    DatafeedConfig datafeedConfig=createDatafeed(job.getId() + "-datafeed",job.getId(),t);
    registerDatafeed(datafeedConfig);
    putDatafeed(datafeedConfig);
    startDatafeed(datafeedConfig.getId(),0L,now);
    assertBusy(() -> {
      DataCounts dataCounts=getDataCounts(job.getId());
      assertThat(dataCounts.getProcessedRecordCount(),equalTo(numDocs + numDocs2));
      assertThat(dataCounts.getOutOfOrderTimeStampCount(),equalTo(0L));
      GetDatafeedsStatsAction.Request request=new GetDatafeedsStatsAction.Request(datafeedConfig.getId());
      GetDatafeedsStatsAction.Response response=client().execute(GetDatafeedsStatsAction.INSTANCE,request).actionGet();
      assertThat(response.getResponse().results().get(0).getDatafeedState(),equalTo(DatafeedState.STOPPED));
    }
,60,TimeUnit.SECONDS);
    waitUntilJobIsClosed(job.getId());
    assertBusy(() -> {
      GetJobsStatsAction.Response.JobStats jobStats=getJobStats(job.getId()).get(0);
      ModelSizeStats modelSizeStats=jobStats.getModelSizeStats();
      Job updatedJob=getJob(job.getId()).get(0);
      assertThat(updatedJob.getEstablishedModelMemory(),equalTo(modelSizeStats.getModelBytes()));
    }
);
  }
  public void testRealtime() throws Exception {
    String jobId="realtime-job";
    String datafeedId=jobId + "-datafeed";
    startRealtime(jobId);
    try {
      StopDatafeedAction.Response stopJobResponse=stopDatafeed(datafeedId);
      assertTrue(stopJobResponse.isStopped());
    }
 catch (    Exception e) {
      NodesHotThreadsResponse nodesHotThreadsResponse=client().admin().cluster().prepareNodesHotThreads().get();
      int i=0;
      for (      NodeHotThreads nodeHotThreads : nodesHotThreadsResponse.getNodes()) {
        logger.info(i++ + ":\n" + nodeHotThreads.getHotThreads());
      }
      throw e;
    }
    assertBusy(() -> {
      GetDatafeedsStatsAction.Request request=new GetDatafeedsStatsAction.Request(datafeedId);
      GetDatafeedsStatsAction.Response response=client().execute(GetDatafeedsStatsAction.INSTANCE,request).actionGet();
      assertThat(response.getResponse().results().get(0).getDatafeedState(),equalTo(DatafeedState.STOPPED));
    }
);
  }
  public void testRealtime_multipleStopCalls() throws Exception {
    String jobId="realtime-job-multiple-stop";
    final String datafeedId=jobId + "-datafeed";
    startRealtime(jobId);
    ConcurrentMapLong<AssertionError> exceptions=ConcurrentCollections.newConcurrentMapLong();
    Runnable stopDataFeed=() -> {
      StopDatafeedAction.Response stopJobResponse=stopDatafeed(datafeedId);
      if (stopJobResponse.isStopped() == false) {
        exceptions.put(Thread.currentThread().getId(),new AssertionError("Job is not stopped"));
      }
      GetDatafeedsStatsAction.Request request=new GetDatafeedsStatsAction.Request(datafeedId);
      GetDatafeedsStatsAction.Response response=client().execute(GetDatafeedsStatsAction.INSTANCE,request).actionGet();
      if (response.getResponse().results().get(0).getDatafeedState() != DatafeedState.STOPPED) {
        exceptions.put(Thread.currentThread().getId(),new AssertionError("Expected STOPPED datafeed state got " + response.getResponse().results().get(0).getDatafeedState()));
      }
    }
;
    int numThreads=5;
    Thread[] threads=new Thread[numThreads];
    for (int i=0; i < numThreads; i++) {
      threads[i]=new Thread(stopDataFeed);
    }
    for (int i=0; i < numThreads; i++) {
      threads[i].start();
    }
    for (int i=0; i < numThreads; i++) {
      threads[i].join();
    }
    if (exceptions.isEmpty() == false) {
      throw exceptions.values().iterator().next();
    }
  }
  public void testRealtime_givenSimultaneousStopAndForceDelete() throws Throwable {
    String jobId="realtime-job-stop-and-force-delete";
    final String datafeedId=jobId + "-datafeed";
    startRealtime(jobId);
    AtomicReference<Throwable> exception=new AtomicReference<>();
    Thread deleteDatafeedThread=new Thread(() -> {
      try {
        DeleteDatafeedAction.Request request=new DeleteDatafeedAction.Request(datafeedId);
        request.setForce(true);
        AcknowledgedResponse response=client().execute(DeleteDatafeedAction.INSTANCE,request).actionGet();
        if (response.isAcknowledged()) {
          GetDatafeedsStatsAction.Request statsRequest=new GetDatafeedsStatsAction.Request(datafeedId);
          expectThrows(ResourceNotFoundException.class,() -> client().execute(GetDatafeedsStatsAction.INSTANCE,statsRequest).actionGet());
        }
 else {
          exception.set(new AssertionError("Job is not deleted"));
        }
      }
 catch (      AssertionError|Exception e) {
        exception.set(e);
      }
    }
);
    deleteDatafeedThread.start();
    try {
      stopDatafeed(datafeedId);
    }
 catch (    ResourceNotFoundException e) {
    }
 finally {
      deleteDatafeedThread.join();
    }
    if (exception.get() != null) {
      throw exception.get();
    }
  }
  public void testRealtime_GivenProcessIsKilled() throws Exception {
    String jobId="realtime-job-given-process-is-killed";
    String datafeedId=jobId + "-datafeed";
    startRealtime(jobId);
    KillProcessAction.Request killRequest=new KillProcessAction.Request(jobId);
    client().execute(KillProcessAction.INSTANCE,killRequest).actionGet();
    assertBusy(() -> {
      GetDatafeedsStatsAction.Request request=new GetDatafeedsStatsAction.Request(datafeedId);
      GetDatafeedsStatsAction.Response response=client().execute(GetDatafeedsStatsAction.INSTANCE,request).actionGet();
      assertThat(response.getResponse().results().get(0).getDatafeedState(),equalTo(DatafeedState.STOPPED));
    }
);
  }
  /** 
 * Stopping a lookback closes the associated job _after_ the stop call returns. This test ensures that a kill request submitted during this close doesn't put the job into the "failed" state.
 */
  public void testStopLookbackFollowedByProcessKill() throws Exception {
    client().admin().indices().prepareCreate("data").addMapping("type","time","type=date").get();
    long numDocs=randomIntBetween(1024,2048);
    long now=System.currentTimeMillis();
    long oneWeekAgo=now - 604800000;
    long twoWeeksAgo=oneWeekAgo - 604800000;
    indexDocs(logger,"data",numDocs,twoWeeksAgo,oneWeekAgo);
    Job.Builder job=createScheduledJob("lookback-job-stopped-then-killed");
    registerJob(job);
    PutJobAction.Response putJobResponse=putJob(job);
    assertThat(putJobResponse.getResponse().getJobVersion(),equalTo(Version.CURRENT));
    openJob(job.getId());
    assertBusy(() -> assertEquals(getJobStats(job.getId()).get(0).getState(),JobState.OPENED));
    List<String> t=Collections.singletonList("data");
    DatafeedConfig.Builder datafeedConfigBuilder=createDatafeedBuilder(job.getId() + "-datafeed",job.getId(),t);
    datafeedConfigBuilder.setChunkingConfig(ChunkingConfig.newManual(new TimeValue(1,TimeUnit.SECONDS)));
    DatafeedConfig datafeedConfig=datafeedConfigBuilder.build();
    registerDatafeed(datafeedConfig);
    putDatafeed(datafeedConfig);
    startDatafeed(datafeedConfig.getId(),0L,now);
    assertBusy(() -> {
      DataCounts dataCounts=getDataCounts(job.getId());
      assertThat(dataCounts.getProcessedRecordCount(),greaterThan(0L));
    }
,60,TimeUnit.SECONDS);
    stopDatafeed(datafeedConfig.getId());
    Thread.sleep(randomIntBetween(1,9));
    KillProcessAction.Request killRequest=new KillProcessAction.Request(job.getId());
    client().execute(KillProcessAction.INSTANCE,killRequest).actionGet();
    waitUntilJobIsClosed(job.getId(),TimeValue.timeValueSeconds(2));
  }
  private void startRealtime(  String jobId) throws Exception {
    client().admin().indices().prepareCreate("data").addMapping("type","time","type=date").get();
    long numDocs1=randomIntBetween(32,2048);
    long now=System.currentTimeMillis();
    long lastWeek=now - 604800000;
    indexDocs(logger,"data",numDocs1,lastWeek,now);
    Job.Builder job=createScheduledJob(jobId);
    registerJob(job);
    putJob(job);
    openJob(job.getId());
    assertBusy(() -> assertEquals(getJobStats(job.getId()).get(0).getState(),JobState.OPENED));
    DatafeedConfig datafeedConfig=createDatafeed(job.getId() + "-datafeed",job.getId(),Collections.singletonList("data"));
    registerDatafeed(datafeedConfig);
    putDatafeed(datafeedConfig);
    startDatafeed(datafeedConfig.getId(),0L,null);
    assertBusy(() -> {
      DataCounts dataCounts=getDataCounts(job.getId());
      assertThat(dataCounts.getProcessedRecordCount(),equalTo(numDocs1));
      assertThat(dataCounts.getOutOfOrderTimeStampCount(),equalTo(0L));
    }
);
    long numDocs2=randomIntBetween(2,64);
    now=System.currentTimeMillis();
    indexDocs(logger,"data",numDocs2,now + 5000,now + 6000);
    assertBusy(() -> {
      DataCounts dataCounts=getDataCounts(job.getId());
      assertThat(dataCounts.getProcessedRecordCount(),equalTo(numDocs1 + numDocs2));
      assertThat(dataCounts.getOutOfOrderTimeStampCount(),equalTo(0L));
    }
,30,TimeUnit.SECONDS);
  }
}
