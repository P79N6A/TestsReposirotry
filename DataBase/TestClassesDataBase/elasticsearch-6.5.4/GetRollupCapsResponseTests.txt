public class GetRollupCapsResponseTests extends AbstractXContentTestCase<GetRollupCapsResponse> {
  private Map<String,RollableIndexCaps> indices;
  @Before private void setupIndices() throws IOException {
    int numIndices=randomIntBetween(1,5);
    indices=new HashMap<>(numIndices);
    for (int i=0; i < numIndices; i++) {
      String indexName="index_" + randomAlphaOfLength(10);
      int numJobs=randomIntBetween(1,5);
      List<RollupJobCaps> jobs=new ArrayList<>(numJobs);
      for (int j=0; j < numJobs; j++) {
        RollupJobConfig config=RollupJobConfigTests.randomRollupJobConfig(randomAlphaOfLength(10));
        jobs.add(new RollupJobCaps(config.getId(),config.getIndexPattern(),config.getRollupIndex(),createRollupFieldCaps(config)));
      }
      RollableIndexCaps cap=new RollableIndexCaps(indexName,jobs);
      indices.put(indexName,cap);
    }
  }
  @Override protected GetRollupCapsResponse createTestInstance(){
    return new GetRollupCapsResponse(indices);
  }
  @Override protected boolean supportsUnknownFields(){
    return false;
  }
  @Override protected GetRollupCapsResponse doParseInstance(  final XContentParser parser) throws IOException {
    return GetRollupCapsResponse.fromXContent(parser);
  }
  /** 
 * Lifted from core's RollupJobCaps, so that we can test without having to include this actual logic in the request
 */
  private static Map<String,RollupJobCaps.RollupFieldCaps> createRollupFieldCaps(  final RollupJobConfig rollupJobConfig){
    final Map<String,List<Map<String,Object>>> tempFieldCaps=new HashMap<>();
    final GroupConfig groupConfig=rollupJobConfig.getGroupConfig();
    if (groupConfig != null) {
      final DateHistogramGroupConfig dateHistogram=groupConfig.getDateHistogram();
      final Map<String,Object> dateHistogramAggCap=new HashMap<>();
      dateHistogramAggCap.put("agg",DateHistogramAggregationBuilder.NAME);
      dateHistogramAggCap.put("interval",dateHistogram.getInterval().toString());
      if (dateHistogram.getDelay() != null) {
        dateHistogramAggCap.put("delay",dateHistogram.getDelay().toString());
      }
      dateHistogramAggCap.put("time_zone",dateHistogram.getTimeZone());
      List<Map<String,Object>> dateAggCaps=tempFieldCaps.getOrDefault(dateHistogram.getField(),new ArrayList<>());
      dateAggCaps.add(dateHistogramAggCap);
      tempFieldCaps.put(dateHistogram.getField(),dateAggCaps);
      final HistogramGroupConfig histogram=groupConfig.getHistogram();
      if (histogram != null) {
        final Map<String,Object> histogramAggCap=new HashMap<>();
        histogramAggCap.put("agg",HistogramAggregationBuilder.NAME);
        histogramAggCap.put("interval",histogram.getInterval());
        Arrays.stream(rollupJobConfig.getGroupConfig().getHistogram().getFields()).forEach(field -> {
          List<Map<String,Object>> caps=tempFieldCaps.getOrDefault(field,new ArrayList<>());
          caps.add(histogramAggCap);
          tempFieldCaps.put(field,caps);
        }
);
      }
      final TermsGroupConfig terms=groupConfig.getTerms();
      if (terms != null) {
        final Map<String,Object> termsAggCap=singletonMap("agg",TermsAggregationBuilder.NAME);
        Arrays.stream(rollupJobConfig.getGroupConfig().getTerms().getFields()).forEach(field -> {
          List<Map<String,Object>> caps=tempFieldCaps.getOrDefault(field,new ArrayList<>());
          caps.add(termsAggCap);
          tempFieldCaps.put(field,caps);
        }
);
      }
    }
    final List<MetricConfig> metricsConfig=rollupJobConfig.getMetricsConfig();
    if (metricsConfig.size() > 0) {
      rollupJobConfig.getMetricsConfig().forEach(metricConfig -> {
        final List<Map<String,Object>> metrics=metricConfig.getMetrics().stream().map(metric -> singletonMap("agg",(Object)metric)).collect(Collectors.toList());
        metrics.forEach(m -> {
          List<Map<String,Object>> caps=tempFieldCaps.getOrDefault(metricConfig.getField(),new ArrayList<>());
          caps.add(m);
          tempFieldCaps.put(metricConfig.getField(),caps);
        }
);
      }
);
    }
    return Collections.unmodifiableMap(tempFieldCaps.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,e -> new RollupJobCaps.RollupFieldCaps(e.getValue()))));
  }
}
