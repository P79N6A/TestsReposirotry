public class FieldAliasMapperTests extends ESSingleNodeTestCase {
  private MapperService mapperService;
  private DocumentMapperParser parser;
  @Before public void setup(){
    IndexService indexService=createIndex("test");
    mapperService=indexService.mapperService();
    parser=mapperService.documentMapperParser();
  }
  public void testParsing() throws IOException {
    String mapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("alias-field").field("type","alias").field("path","concrete-field").endObject().startObject("concrete-field").field("type","keyword").endObject().endObject().endObject().endObject());
    DocumentMapper mapper=parser.parse("type",new CompressedXContent(mapping));
    assertEquals(mapping,mapper.mappingSource().toString());
  }
  public void testParsingWithMissingPath() throws IOException {
    String mapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("alias-field").field("type","alias").endObject().endObject().endObject().endObject());
    MapperParsingException exception=expectThrows(MapperParsingException.class,() -> parser.parse("type",new CompressedXContent(mapping)));
    assertEquals("The [path] property must be specified for field [alias-field].",exception.getMessage());
  }
  public void testParsingWithExtraArgument() throws IOException {
    String mapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("alias-field").field("type","alias").field("path","concrete-field").field("extra-field","extra-value").endObject().endObject().endObject().endObject());
    MapperParsingException exception=expectThrows(MapperParsingException.class,() -> parser.parse("type",new CompressedXContent(mapping)));
    assertEquals("Mapping definition for [alias-field] has unsupported parameters:  [extra-field : extra-value]",exception.getMessage());
  }
  public void testMerge() throws IOException {
    String mapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("first-field").field("type","keyword").endObject().startObject("alias-field").field("type","alias").field("path","first-field").endObject().endObject().endObject().endObject());
    mapperService.merge("type",new CompressedXContent(mapping),MergeReason.MAPPING_UPDATE,false);
    MappedFieldType firstFieldType=mapperService.fullName("alias-field");
    assertEquals("first-field",firstFieldType.name());
    assertTrue(firstFieldType instanceof KeywordFieldMapper.KeywordFieldType);
    String newMapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("second-field").field("type","text").endObject().startObject("alias-field").field("type","alias").field("path","second-field").endObject().endObject().endObject().endObject());
    mapperService.merge("type",new CompressedXContent(newMapping),MergeReason.MAPPING_UPDATE,false);
    MappedFieldType secondFieldType=mapperService.fullName("alias-field");
    assertEquals("second-field",secondFieldType.name());
    assertTrue(secondFieldType instanceof TextFieldMapper.TextFieldType);
  }
  public void testMergeFailure() throws IOException {
    String mapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("concrete-field").field("type","text").endObject().startObject("alias-field").field("type","alias").field("path","concrete-field").endObject().endObject().endObject().endObject());
    mapperService.merge("type",new CompressedXContent(mapping),MergeReason.MAPPING_UPDATE,false);
    String newMapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("alias-field").field("type","keyword").endObject().endObject().endObject().endObject());
    IllegalArgumentException exception=expectThrows(IllegalArgumentException.class,() -> mapperService.merge("type",new CompressedXContent(newMapping),MergeReason.MAPPING_UPDATE,false));
    assertEquals("Cannot merge a field alias mapping [alias-field] with a mapping that is not for a field alias.",exception.getMessage());
  }
}
