public class ScriptedMetricAggregatorTests extends AggregatorTestCase {
  private static final String AGG_NAME="scriptedMetric";
  private static final Script INIT_SCRIPT=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"initScript",Collections.emptyMap());
  private static final Script MAP_SCRIPT=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"mapScript",Collections.emptyMap());
  private static final Script COMBINE_SCRIPT=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"combineScript",Collections.emptyMap());
  private static final Script INIT_SCRIPT_SCORE=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"initScriptScore",Collections.emptyMap());
  private static final Script MAP_SCRIPT_SCORE=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"mapScriptScore",Collections.emptyMap());
  private static final Script COMBINE_SCRIPT_SCORE=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"combineScriptScore",Collections.emptyMap());
  private static final Script INIT_SCRIPT_PARAMS=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"initScriptParams",Collections.singletonMap("initialValue",24));
  private static final Script MAP_SCRIPT_PARAMS=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"mapScriptParams",Collections.singletonMap("itemValue",12));
  private static final Script COMBINE_SCRIPT_PARAMS=new Script(ScriptType.INLINE,MockScriptEngine.NAME,"combineScriptParams",Collections.singletonMap("divisor",4));
  private static final String CONFLICTING_PARAM_NAME="initialValue";
  private static final Map<String,Function<Map<String,Object>,Object>> SCRIPTS=new HashMap<>();
  @BeforeClass @SuppressWarnings("unchecked") public static void initMockScripts(){
    SCRIPTS.put("initScript",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      state.put("collector",new ArrayList<Integer>());
      return state;
    }
);
    SCRIPTS.put("mapScript",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      ((List<Integer>)state.get("collector")).add(1);
      return state;
    }
);
    SCRIPTS.put("combineScript",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      return ((List<Integer>)state.get("collector")).stream().mapToInt(Integer::intValue).sum();
    }
);
    SCRIPTS.put("initScriptScore",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      state.put("collector",new ArrayList<Double>());
      return state;
    }
);
    SCRIPTS.put("mapScriptScore",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      ((List<Double>)state.get("collector")).add(((Number)params.get("_score")).doubleValue());
      return state;
    }
);
    SCRIPTS.put("combineScriptScore",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      return ((List<Double>)state.get("collector")).stream().mapToDouble(Double::doubleValue).sum();
    }
);
    SCRIPTS.put("initScriptParams",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      Integer initialValue=(Integer)((Map<String,Object>)params.get("params")).get("initialValue");
      ArrayList<Integer> collector=new ArrayList();
      collector.add(initialValue);
      state.put("collector",collector);
      return state;
    }
);
    SCRIPTS.put("mapScriptParams",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      Integer itemValue=(Integer)((Map<String,Object>)params.get("params")).get("itemValue");
      ((List<Integer>)state.get("collector")).add(itemValue);
      return state;
    }
);
    SCRIPTS.put("combineScriptParams",params -> {
      Map<String,Object> state=(Map<String,Object>)params.get("state");
      int divisor=((Integer)((Map<String,Object>)params.get("params")).get("divisor"));
      return ((List<Integer>)state.get("collector")).stream().mapToInt(Integer::intValue).map(i -> i / divisor).sum();
    }
);
  }
  @SuppressWarnings("unchecked") public void testNoDocs() throws IOException {
    try (Directory directory=newDirectory()){
      try (RandomIndexWriter indexWriter=new RandomIndexWriter(random(),directory)){
      }
       try (IndexReader indexReader=DirectoryReader.open(directory)){
        ScriptedMetricAggregationBuilder aggregationBuilder=new ScriptedMetricAggregationBuilder(AGG_NAME);
        aggregationBuilder.mapScript(MAP_SCRIPT);
        ScriptedMetric scriptedMetric=search(newSearcher(indexReader,true,true),new MatchAllDocsQuery(),aggregationBuilder);
        assertEquals(AGG_NAME,scriptedMetric.getName());
        assertNotNull(scriptedMetric.aggregation());
        assertEquals(0,((HashMap<Object,String>)scriptedMetric.aggregation()).size());
      }
  finally {
        assertWarnings("[combineScript] must be provided for metric aggregations.","[reduceScript] must be provided for metric aggregations.");
      }
    }
   }
  /** 
 * without combine script, the "states" map should contain a list of the size of the number of documents matched
 */
  @SuppressWarnings("unchecked") public void testScriptedMetricWithoutCombine() throws IOException {
    try (Directory directory=newDirectory()){
      int numDocs=randomInt(100);
      try (RandomIndexWriter indexWriter=new RandomIndexWriter(random(),directory)){
        for (int i=0; i < numDocs; i++) {
          indexWriter.addDocument(singleton(new SortedNumericDocValuesField("number",i)));
        }
      }
       try (IndexReader indexReader=DirectoryReader.open(directory)){
        ScriptedMetricAggregationBuilder aggregationBuilder=new ScriptedMetricAggregationBuilder(AGG_NAME);
        aggregationBuilder.initScript(INIT_SCRIPT).mapScript(MAP_SCRIPT);
        ScriptedMetric scriptedMetric=search(newSearcher(indexReader,true,true),new MatchAllDocsQuery(),aggregationBuilder);
        assertEquals(AGG_NAME,scriptedMetric.getName());
        assertNotNull(scriptedMetric.aggregation());
        Map<String,Object> agg=(Map<String,Object>)scriptedMetric.aggregation();
        assertEquals(numDocs,((List<Integer>)agg.get("collector")).size());
      }
  finally {
        assertWarnings("[combineScript] must be provided for metric aggregations.","[reduceScript] must be provided for metric aggregations.");
      }
    }
   }
  /** 
 * test that combine script sums the list produced by the "mapScript"
 */
  public void testScriptedMetricWithCombine() throws IOException {
    try (Directory directory=newDirectory()){
      Integer numDocs=randomInt(100);
      try (RandomIndexWriter indexWriter=new RandomIndexWriter(random(),directory)){
        for (int i=0; i < numDocs; i++) {
          indexWriter.addDocument(singleton(new SortedNumericDocValuesField("number",i)));
        }
      }
       try (IndexReader indexReader=DirectoryReader.open(directory)){
        ScriptedMetricAggregationBuilder aggregationBuilder=new ScriptedMetricAggregationBuilder(AGG_NAME);
        aggregationBuilder.initScript(INIT_SCRIPT).mapScript(MAP_SCRIPT).combineScript(COMBINE_SCRIPT);
        ScriptedMetric scriptedMetric=search(newSearcher(indexReader,true,true),new MatchAllDocsQuery(),aggregationBuilder);
        assertEquals(AGG_NAME,scriptedMetric.getName());
        assertNotNull(scriptedMetric.aggregation());
        assertEquals(numDocs,scriptedMetric.aggregation());
      }
  finally {
        assertWarnings("[reduceScript] must be provided for metric aggregations.");
      }
    }
   }
  /** 
 * test that uses the score of the documents
 */
  public void testScriptedMetricWithCombineAccessesScores() throws IOException {
    try (Directory directory=newDirectory()){
      Integer numDocs=randomInt(100);
      try (RandomIndexWriter indexWriter=new RandomIndexWriter(random(),directory)){
        for (int i=0; i < numDocs; i++) {
          indexWriter.addDocument(singleton(new SortedNumericDocValuesField("number",i)));
        }
      }
       try (IndexReader indexReader=DirectoryReader.open(directory)){
        ScriptedMetricAggregationBuilder aggregationBuilder=new ScriptedMetricAggregationBuilder(AGG_NAME);
        aggregationBuilder.initScript(INIT_SCRIPT_SCORE).mapScript(MAP_SCRIPT_SCORE).combineScript(COMBINE_SCRIPT_SCORE);
        ScriptedMetric scriptedMetric=search(newSearcher(indexReader,true,true),new MatchAllDocsQuery(),aggregationBuilder);
        assertEquals(AGG_NAME,scriptedMetric.getName());
        assertNotNull(scriptedMetric.aggregation());
        assertEquals((double)numDocs,scriptedMetric.aggregation());
      }
  finally {
        assertWarnings("[reduceScript] must be provided for metric aggregations.");
      }
    }
   }
  public void testScriptParamsPassedThrough() throws IOException {
    try (Directory directory=newDirectory()){
      try (RandomIndexWriter indexWriter=new RandomIndexWriter(random(),directory)){
        for (int i=0; i < 100; i++) {
          indexWriter.addDocument(singleton(new SortedNumericDocValuesField("number",i)));
        }
      }
       try (IndexReader indexReader=DirectoryReader.open(directory)){
        ScriptedMetricAggregationBuilder aggregationBuilder=new ScriptedMetricAggregationBuilder(AGG_NAME);
        aggregationBuilder.initScript(INIT_SCRIPT_PARAMS).mapScript(MAP_SCRIPT_PARAMS).combineScript(COMBINE_SCRIPT_PARAMS);
        ScriptedMetric scriptedMetric=search(newSearcher(indexReader,true,true),new MatchAllDocsQuery(),aggregationBuilder);
        assertEquals(306,scriptedMetric.aggregation());
      }
  finally {
        assertWarnings("[reduceScript] must be provided for metric aggregations.");
      }
    }
   }
  public void testConflictingAggAndScriptParams() throws IOException {
    try (Directory directory=newDirectory()){
      try (RandomIndexWriter indexWriter=new RandomIndexWriter(random(),directory)){
        for (int i=0; i < 100; i++) {
          indexWriter.addDocument(singleton(new SortedNumericDocValuesField("number",i)));
        }
      }
       try (IndexReader indexReader=DirectoryReader.open(directory)){
        ScriptedMetricAggregationBuilder aggregationBuilder=new ScriptedMetricAggregationBuilder(AGG_NAME);
        Map<String,Object> aggParams=Collections.singletonMap(CONFLICTING_PARAM_NAME,"blah");
        aggregationBuilder.params(aggParams).initScript(INIT_SCRIPT_PARAMS).mapScript(MAP_SCRIPT_PARAMS).combineScript(COMBINE_SCRIPT_PARAMS);
        IllegalArgumentException ex=expectThrows(IllegalArgumentException.class,() -> search(newSearcher(indexReader,true,true),new MatchAllDocsQuery(),aggregationBuilder));
        assertEquals("Parameter name \"" + CONFLICTING_PARAM_NAME + "\" used in both aggregation and script parameters",ex.getMessage());
      }
  finally {
        assertWarnings("[reduceScript] must be provided for metric aggregations.");
      }
    }
   }
  /** 
 * We cannot use Mockito for mocking QueryShardContext in this case because script-related methods (e.g. QueryShardContext#getLazyExecutableScript) is final and cannot be mocked
 */
  @Override protected QueryShardContext queryShardContextMock(  MapperService mapperService){
    MockScriptEngine scriptEngine=new MockScriptEngine(MockScriptEngine.NAME,SCRIPTS,Collections.emptyMap());
    Map<String,ScriptEngine> engines=Collections.singletonMap(scriptEngine.getType(),scriptEngine);
    ScriptService scriptService=new ScriptService(Settings.EMPTY,engines,ScriptModule.CORE_CONTEXTS);
    return new QueryShardContext(0,mapperService.getIndexSettings(),null,null,mapperService,null,scriptService,xContentRegistry(),writableRegistry(),null,null,System::currentTimeMillis,null);
  }
}
