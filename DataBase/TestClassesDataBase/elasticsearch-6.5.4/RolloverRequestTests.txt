public class RolloverRequestTests extends ESTestCase {
  private NamedWriteableRegistry writeableRegistry;
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    writeableRegistry=new NamedWriteableRegistry(new IndicesModule(Collections.emptyList()).getNamedWriteables());
  }
  public void testConditionsParsing() throws Exception {
    final RolloverRequest request=new RolloverRequest(randomAlphaOfLength(10),randomAlphaOfLength(10));
    final XContentBuilder builder=XContentFactory.jsonBuilder().startObject().startObject("conditions").field("max_age","10d").field("max_docs",100).field("max_size","45gb").endObject().endObject();
    request.fromXContent(createParser(builder));
    Map<String,Condition> conditions=request.getConditions();
    assertThat(conditions.size(),equalTo(3));
    MaxAgeCondition maxAgeCondition=(MaxAgeCondition)conditions.get(MaxAgeCondition.NAME);
    assertThat(maxAgeCondition.value.getMillis(),equalTo(TimeValue.timeValueHours(24 * 10).getMillis()));
    MaxDocsCondition maxDocsCondition=(MaxDocsCondition)conditions.get(MaxDocsCondition.NAME);
    assertThat(maxDocsCondition.value,equalTo(100L));
    MaxSizeCondition maxSizeCondition=(MaxSizeCondition)conditions.get(MaxSizeCondition.NAME);
    assertThat(maxSizeCondition.value.getBytes(),equalTo(ByteSizeUnit.GB.toBytes(45)));
  }
  public void testParsingWithIndexSettings() throws Exception {
    final RolloverRequest request=new RolloverRequest(randomAlphaOfLength(10),randomAlphaOfLength(10));
    final XContentBuilder builder=XContentFactory.jsonBuilder().startObject().startObject("conditions").field("max_age","10d").field("max_docs",100).endObject().startObject("mappings").startObject("type1").startObject("properties").startObject("field1").field("type","string").field("index","not_analyzed").endObject().endObject().endObject().endObject().startObject("settings").field("number_of_shards",10).endObject().startObject("aliases").startObject("alias1").endObject().endObject().endObject();
    request.fromXContent(createParser(builder));
    Map<String,Condition> conditions=request.getConditions();
    assertThat(conditions.size(),equalTo(2));
    assertThat(request.getCreateIndexRequest().mappings().size(),equalTo(1));
    assertThat(request.getCreateIndexRequest().aliases().size(),equalTo(1));
    assertThat(request.getCreateIndexRequest().settings().getAsInt("number_of_shards",0),equalTo(10));
  }
  public void testSerialize() throws Exception {
    RolloverRequest originalRequest=new RolloverRequest("alias-index","new-index-name");
    originalRequest.addMaxIndexDocsCondition(randomNonNegativeLong());
    originalRequest.addMaxIndexAgeCondition(TimeValue.timeValueNanos(randomNonNegativeLong()));
    originalRequest.addMaxIndexSizeCondition(new ByteSizeValue(randomNonNegativeLong()));
    try (BytesStreamOutput out=new BytesStreamOutput()){
      originalRequest.writeTo(out);
      BytesReference bytes=out.bytes();
      try (StreamInput in=new NamedWriteableAwareStreamInput(bytes.streamInput(),writeableRegistry)){
        RolloverRequest cloneRequest=new RolloverRequest();
        cloneRequest.readFrom(in);
        assertThat(cloneRequest.getNewIndexName(),equalTo(originalRequest.getNewIndexName()));
        assertThat(cloneRequest.getAlias(),equalTo(originalRequest.getAlias()));
        for (        Map.Entry<String,Condition> entry : cloneRequest.getConditions().entrySet()) {
          Condition condition=originalRequest.getConditions().get(entry.getKey());
          assertEquals(condition.toString(),entry.getValue().toString());
        }
      }
     }
   }
  public void testToAndFromXContent() throws IOException {
    RolloverRequest rolloverRequest=createTestItem();
    final XContentType xContentType=randomFrom(XContentType.values());
    boolean humanReadable=randomBoolean();
    BytesReference originalBytes=toShuffledXContent(rolloverRequest,xContentType,EMPTY_PARAMS,humanReadable);
    RolloverRequest parsedRolloverRequest=new RolloverRequest();
    parsedRolloverRequest.fromXContent(createParser(xContentType.xContent(),originalBytes));
    CreateIndexRequest createIndexRequest=rolloverRequest.getCreateIndexRequest();
    CreateIndexRequest parsedCreateIndexRequest=parsedRolloverRequest.getCreateIndexRequest();
    CreateIndexRequestTests.assertMappingsEqual(createIndexRequest.mappings(),parsedCreateIndexRequest.mappings());
    CreateIndexRequestTests.assertAliasesEqual(createIndexRequest.aliases(),parsedCreateIndexRequest.aliases());
    assertEquals(createIndexRequest.settings(),parsedCreateIndexRequest.settings());
    assertEquals(rolloverRequest.getConditions(),parsedRolloverRequest.getConditions());
    BytesReference finalBytes=toShuffledXContent(parsedRolloverRequest,xContentType,EMPTY_PARAMS,humanReadable);
    ElasticsearchAssertions.assertToXContentEquivalent(originalBytes,finalBytes,xContentType);
  }
  public void testUnknownFields() throws IOException {
    final RolloverRequest request=new RolloverRequest();
    XContentType xContentType=randomFrom(XContentType.values());
    final XContentBuilder builder=XContentFactory.contentBuilder(xContentType);
    builder.startObject();
{
      builder.startObject("conditions");
      builder.field("max_age","10d");
      builder.endObject();
    }
    builder.endObject();
    BytesReference mutated=XContentTestUtils.insertRandomFields(xContentType,BytesReference.bytes(builder),null,random());
    expectThrows(XContentParseException.class,() -> request.fromXContent(createParser(xContentType.xContent(),mutated)));
  }
  public void testSameConditionCanOnlyBeAddedOnce(){
    RolloverRequest rolloverRequest=new RolloverRequest();
    Consumer<RolloverRequest> rolloverRequestConsumer=randomFrom(conditionsGenerator);
    rolloverRequestConsumer.accept(rolloverRequest);
    expectThrows(IllegalArgumentException.class,() -> rolloverRequestConsumer.accept(rolloverRequest));
  }
  public void testValidation(){
    RolloverRequest rolloverRequest=new RolloverRequest();
    assertNotNull(rolloverRequest.getCreateIndexRequest());
    ActionRequestValidationException validationException=rolloverRequest.validate();
    assertNotNull(validationException);
    assertEquals(1,validationException.validationErrors().size());
    assertEquals("index alias is missing",validationException.validationErrors().get(0));
  }
  private static List<Consumer<RolloverRequest>> conditionsGenerator=new ArrayList<>();
static {
    conditionsGenerator.add((request) -> request.addMaxIndexDocsCondition(randomNonNegativeLong()));
    conditionsGenerator.add((request) -> request.addMaxIndexSizeCondition(new ByteSizeValue(randomNonNegativeLong())));
    conditionsGenerator.add((request) -> request.addMaxIndexAgeCondition(new TimeValue(randomNonNegativeLong())));
  }
  private static RolloverRequest createTestItem() throws IOException {
    RolloverRequest rolloverRequest=new RolloverRequest();
    if (randomBoolean()) {
      String type=randomAlphaOfLengthBetween(3,10);
      rolloverRequest.getCreateIndexRequest().mapping(type,RandomCreateIndexGenerator.randomMapping(type));
    }
    if (randomBoolean()) {
      RandomCreateIndexGenerator.randomAliases(rolloverRequest.getCreateIndexRequest());
    }
    if (randomBoolean()) {
      rolloverRequest.getCreateIndexRequest().settings(RandomCreateIndexGenerator.randomIndexSettings());
    }
    int numConditions=randomIntBetween(0,3);
    List<Consumer<RolloverRequest>> conditions=randomSubsetOf(numConditions,conditionsGenerator);
    for (    Consumer<RolloverRequest> consumer : conditions) {
      consumer.accept(rolloverRequest);
    }
    return rolloverRequest;
  }
}
