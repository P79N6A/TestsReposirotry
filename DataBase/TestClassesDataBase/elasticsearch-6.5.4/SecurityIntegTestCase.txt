/** 
 * Base class to run tests against a cluster with X-Pack installed and security enabled. The default  {@link org.elasticsearch.test.ESIntegTestCase.Scope} is {@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE}
 * @see SecuritySettingsSource
 */
public abstract class SecurityIntegTestCase extends ESIntegTestCase {
  private static SecuritySettingsSource SECURITY_DEFAULT_SETTINGS;
  protected static SecureString BOOTSTRAP_PASSWORD=null;
  /** 
 * Settings used when the  {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}so that some of the configuration parameters can be overridden through test instance methods, similarly to how  {@link #nodeSettings(int)} and {@link #transportClientSettings()} work.
 */
  private static CustomSecuritySettingsSource customSecuritySettingsSource=null;
  @BeforeClass public static void generateBootstrapPassword(){
    BOOTSTRAP_PASSWORD=TEST_PASSWORD_SECURE_STRING.clone();
  }
  protected static int defaultMaxNumberOfNodes(){
    ClusterScope clusterScope=SecurityIntegTestCase.class.getAnnotation(ClusterScope.class);
    if (clusterScope == null) {
      return InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES + InternalTestCluster.DEFAULT_MAX_NUM_DATA_NODES + InternalTestCluster.DEFAULT_MAX_NUM_CLIENT_NODES;
    }
 else {
      int clientNodes=clusterScope.numClientNodes();
      if (clientNodes < 0) {
        clientNodes=InternalTestCluster.DEFAULT_MAX_NUM_CLIENT_NODES;
      }
      int masterNodes=0;
      if (clusterScope.supportsDedicatedMasters()) {
        masterNodes=InternalTestCluster.DEFAULT_HIGH_NUM_MASTER_NODES;
      }
      int dataNodes=0;
      if (clusterScope.numDataNodes() < 0) {
        if (clusterScope.maxNumDataNodes() < 0) {
          dataNodes=InternalTestCluster.DEFAULT_MAX_NUM_DATA_NODES;
        }
 else {
          dataNodes=clusterScope.maxNumDataNodes();
        }
      }
 else {
        dataNodes=clusterScope.numDataNodes();
      }
      return masterNodes + dataNodes + clientNodes;
    }
  }
  private static ClusterScope getAnnotation(  Class<?> clazz){
    if (clazz == Object.class || clazz == SecurityIntegTestCase.class) {
      return null;
    }
    ClusterScope annotation=clazz.getAnnotation(ClusterScope.class);
    if (annotation != null) {
      return annotation;
    }
    return getAnnotation(clazz.getSuperclass());
  }
  Scope getCurrentClusterScope(){
    return getCurrentClusterScope(this.getClass());
  }
  private static Scope getCurrentClusterScope(  Class<?> clazz){
    ClusterScope annotation=getAnnotation(clazz);
    return annotation == null ? Scope.SUITE : annotation.scope();
  }
  @BeforeClass public static void initDefaultSettings(){
    if (SECURITY_DEFAULT_SETTINGS == null) {
      SECURITY_DEFAULT_SETTINGS=new SecuritySettingsSource(defaultMaxNumberOfNodes(),randomBoolean(),createTempDir(),Scope.SUITE);
    }
  }
  /** 
 * Set the static default settings to null to prevent a memory leak. The test framework also checks for memory leaks and computes the size, this can cause issues when running with the security manager as it tries to do reflection into protected sun packages.
 */
  @AfterClass public static void destroyDefaultSettings(){
    SECURITY_DEFAULT_SETTINGS=null;
    customSecuritySettingsSource=null;
  }
  @Rule public ExternalResource externalResource=new ExternalResource(){
    @Override protected void before() throws Throwable {
      Scope currentClusterScope=getCurrentClusterScope();
switch (currentClusterScope) {
case SUITE:
        if (customSecuritySettingsSource == null) {
          customSecuritySettingsSource=new CustomSecuritySettingsSource(transportSSLEnabled(),createTempDir(),currentClusterScope);
        }
      break;
case TEST:
    customSecuritySettingsSource=new CustomSecuritySettingsSource(transportSSLEnabled(),createTempDir(),currentClusterScope);
  break;
}
}
}
;
/** 
 * A JUnit class level rule that runs after the AfterClass method in  {@link ESIntegTestCase}, which stops the cluster. After the cluster is stopped, there are a few netty threads that can linger, so we wait for them to finish otherwise these lingering threads can intermittently trigger the thread leak detector
 */
@ClassRule public static final ExternalResource STOP_NETTY_RESOURCE=new ExternalResource(){
@Override protected void after(){
try {
GlobalEventExecutor.INSTANCE.awaitInactivity(5,TimeUnit.SECONDS);
}
 catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
catch (IllegalStateException e) {
if (e.getMessage().equals("thread was not started") == false) {
  throw e;
}
}
try {
ThreadDeathWatcher.awaitInactivity(5,TimeUnit.SECONDS);
}
 catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
}
}
;
@Before public void assertXPackIsInstalled(){
doAssertXPackIsInstalled();
}
protected void doAssertXPackIsInstalled(){
NodesInfoResponse nodeInfos=client().admin().cluster().prepareNodesInfo().clear().setPlugins(true).get();
for (NodeInfo nodeInfo : nodeInfos.getNodes()) {
Collection<String> pluginNames=nodeInfo.getPlugins().getPluginInfos().stream().map(p -> p.getClassname()).collect(Collectors.toList());
assertThat("plugin [" + LocalStateSecurity.class.getName() + "] not found in ["+ pluginNames+ "]",pluginNames,hasItem(LocalStateSecurity.class.getName()));
}
}
/** 
 * Should this test assert that x-pack is installed? You might want to skip this assertion if the test itself validates the installation <strong>and</strong> running the assertion would significantly affect the performance or function of the test. For example an AbstractOldXPackIndicesBackwardsCompatibilityTestCase disables the assertion because the assertion would force starting a node which it will then just shut down. That would slow the test down significantly and causes spurious failures because watcher needs to be shut down with kid gloves.
 */
protected boolean shouldAssertXPackIsInstalled(){
return true;
}
@Override protected Settings nodeSettings(int nodeOrdinal){
Settings.Builder builder=Settings.builder().put(super.nodeSettings(nodeOrdinal));
Settings customSettings=customSecuritySettingsSource.nodeSettings(nodeOrdinal);
builder.put(customSettings,false);
builder.put(LicenseService.SELF_GENERATED_LICENSE_TYPE.getKey(),"trial");
Settings.Builder customBuilder=Settings.builder().put(customSettings);
if (customBuilder.getSecureSettings() != null) {
SecuritySettingsSource.addSecureSettings(builder,secureSettings -> secureSettings.merge((MockSecureSettings)customBuilder.getSecureSettings()));
}
if (builder.getSecureSettings() == null) {
builder.setSecureSettings(new MockSecureSettings());
}
((MockSecureSettings)builder.getSecureSettings()).setString("bootstrap.password",BOOTSTRAP_PASSWORD.toString());
return builder.build();
}
@Override protected Path nodeConfigPath(int nodeOrdinal){
return customSecuritySettingsSource.nodeConfigPath(nodeOrdinal);
}
@Override protected Settings transportClientSettings(){
return Settings.builder().put(super.transportClientSettings()).put(customSecuritySettingsSource.transportClientSettings()).build();
}
@Override protected boolean addMockTransportService(){
return false;
}
@Override protected Collection<Class<? extends Plugin>> nodePlugins(){
return customSecuritySettingsSource.nodePlugins();
}
@Override protected Collection<Class<? extends Plugin>> transportClientPlugins(){
return customSecuritySettingsSource.transportClientPlugins();
}
@Override protected Settings externalClusterClientSettings(){
return Settings.builder().put(Security.USER_SETTING.getKey(),SecuritySettingsSource.TEST_USER_NAME + ":" + SecuritySettingsSourceField.TEST_PASSWORD).build();
}
/** 
 * Allows to override the users config file when the  {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}
 */
protected String configUsers(){
return SECURITY_DEFAULT_SETTINGS.configUsers();
}
/** 
 * Allows to override the users_roles config file when the  {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}
 */
protected String configUsersRoles(){
return SECURITY_DEFAULT_SETTINGS.configUsersRoles();
}
/** 
 * Allows to override the roles config file when the  {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}
 */
protected String configRoles(){
return SECURITY_DEFAULT_SETTINGS.configRoles();
}
/** 
 * Allows to override the node client username (used while sending requests to the test cluster) when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}
 */
protected String nodeClientUsername(){
return SECURITY_DEFAULT_SETTINGS.nodeClientUsername();
}
/** 
 * Allows to override the node client password (used while sending requests to the test cluster) when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}
 */
protected SecureString nodeClientPassword(){
return SECURITY_DEFAULT_SETTINGS.nodeClientPassword();
}
/** 
 * Allows to override the transport client username (used while sending requests to the test cluster) when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}
 */
protected String transportClientUsername(){
return SECURITY_DEFAULT_SETTINGS.transportClientUsername();
}
/** 
 * Allows to override the transport client password (used while sending requests to the test cluster) when the {@link org.elasticsearch.test.ESIntegTestCase.ClusterScope} is set to{@link org.elasticsearch.test.ESIntegTestCase.Scope#SUITE} or {@link org.elasticsearch.test.ESIntegTestCase.Scope#TEST}
 */
protected SecureString transportClientPassword(){
return SECURITY_DEFAULT_SETTINGS.transportClientPassword();
}
/** 
 * Allows to control whether ssl key information is auto generated or not on the transport layer
 */
protected boolean transportSSLEnabled(){
return randomBoolean();
}
protected int maxNumberOfNodes(){
return defaultMaxNumberOfNodes();
}
private class CustomSecuritySettingsSource extends SecuritySettingsSource {
private CustomSecuritySettingsSource(boolean sslEnabled,Path configDir,Scope scope){
super(maxNumberOfNodes(),sslEnabled,configDir,scope);
}
@Override protected String configUsers(){
return SecurityIntegTestCase.this.configUsers();
}
@Override protected String configUsersRoles(){
return SecurityIntegTestCase.this.configUsersRoles();
}
@Override protected String configRoles(){
return SecurityIntegTestCase.this.configRoles();
}
@Override protected String nodeClientUsername(){
return SecurityIntegTestCase.this.nodeClientUsername();
}
@Override protected SecureString nodeClientPassword(){
return SecurityIntegTestCase.this.nodeClientPassword();
}
@Override protected String transportClientUsername(){
return SecurityIntegTestCase.this.transportClientUsername();
}
@Override protected SecureString transportClientPassword(){
return SecurityIntegTestCase.this.transportClientPassword();
}
}
protected static void assertGreenClusterState(Client client){
ClusterHealthResponse clusterHealthResponse=client.admin().cluster().prepareHealth().get();
assertNoTimeout(clusterHealthResponse);
assertThat(clusterHealthResponse.getStatus(),is(ClusterHealthStatus.GREEN));
}
/** 
 * Creates the indices provided as argument, randomly associating them with aliases, indexes one dummy document per index and refreshes the new indices
 */
protected void createIndicesWithRandomAliases(String... indices){
createIndex(indices);
if (frequently()) {
boolean aliasAdded=false;
IndicesAliasesRequestBuilder builder=client().admin().indices().prepareAliases();
for (String index : indices) {
if (frequently()) {
  builder.addAlias(index,"alias-" + index);
  aliasAdded=true;
}
}
if (aliasAdded == false || randomBoolean()) {
for (String index : indices) {
  builder.addAlias(index,"alias");
}
}
assertAcked(builder);
}
for (String index : indices) {
client().prepareIndex(index,"type").setSource("field","value").get();
}
refresh(indices);
}
@Override protected Function<Client,Client> getClientWrapper(){
Map<String,String> headers=Collections.singletonMap("Authorization",basicAuthHeaderValue(nodeClientUsername(),nodeClientPassword()));
return client -> (client instanceof NodeClient) ? client.filterWithHeader(headers) : client;
}
protected SecurityClient securityClient(){
return securityClient(client());
}
public static SecurityClient securityClient(Client client){
return randomBoolean() ? new XPackClient(client).security() : new SecurityClient(client);
}
protected String getHttpURL(){
final NodesInfoResponse nodeInfos=client().admin().cluster().prepareNodesInfo().get();
final List<NodeInfo> nodes=nodeInfos.getNodes();
assertTrue("there is at least one node",nodes.size() > 0);
NodeInfo ni=randomFrom(nodes);
boolean useSSL=XPackSettings.HTTP_SSL_ENABLED.get(ni.getSettings());
TransportAddress publishAddress=ni.getHttp().address().publishAddress();
InetSocketAddress address=publishAddress.address();
return (useSSL ? "https://" : "http://") + NetworkAddress.format(address.getAddress()) + ":"+ address.getPort();
}
public void assertSecurityIndexActive() throws Exception {
assertSecurityIndexActive(cluster());
}
public void assertSecurityIndexActive(TestCluster testCluster) throws Exception {
for (Client client : testCluster.getClients()) {
assertBusy(() -> {
ClusterState clusterState=client.admin().cluster().prepareState().setLocal(true).get().getState();
assertFalse(clusterState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK));
XContentBuilder builder=JsonXContent.contentBuilder().prettyPrint().startObject();
assertTrue("security index mapping not sufficient to read:\n" + Strings.toString(clusterState.toXContent(builder,ToXContent.EMPTY_PARAMS).endObject()),SecurityIndexManager.checkIndexMappingVersionMatches(SECURITY_INDEX_NAME,clusterState,logger,Version.CURRENT.minimumIndexCompatibilityVersion()::onOrBefore));
Index securityIndex=resolveSecurityIndex(clusterState.metaData());
if (securityIndex != null) {
  IndexRoutingTable indexRoutingTable=clusterState.routingTable().index(securityIndex);
  if (indexRoutingTable != null) {
    assertTrue(indexRoutingTable.allPrimaryShardsActive());
  }
}
}
,30L,TimeUnit.SECONDS);
}
}
protected void deleteSecurityIndex(){
final Client client=client().filterWithHeader(Collections.singletonMap("Authorization",UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));
GetIndexRequest getIndexRequest=new GetIndexRequest();
getIndexRequest.indices(SECURITY_INDEX_NAME);
getIndexRequest.indicesOptions(IndicesOptions.lenientExpandOpen());
GetIndexResponse getIndexResponse=client.admin().indices().getIndex(getIndexRequest).actionGet();
if (getIndexResponse.getIndices().length > 0) {
DeleteIndexRequest deleteIndexRequest=new DeleteIndexRequest(getIndexResponse.getIndices());
client.admin().indices().delete(deleteIndexRequest).actionGet();
}
}
private static Index resolveSecurityIndex(MetaData metaData){
final AliasOrIndex aliasOrIndex=metaData.getAliasAndIndexLookup().get(SECURITY_INDEX_NAME);
if (aliasOrIndex != null) {
return aliasOrIndex.getIndices().get(0).getIndex();
}
return null;
}
protected boolean isTransportSSLEnabled(){
return customSecuritySettingsSource.isSslEnabled();
}
protected static Hasher getFastStoredHashAlgoForTests(){
return Hasher.resolve(randomFrom("pbkdf2","pbkdf2_1000","bcrypt","bcrypt9"));
}
}
