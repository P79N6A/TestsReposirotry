/** 
 * This test just tests, if he pipelining works in general with out any connection the Elasticsearch handler
 */
public class Netty4HttpServerPipeliningTests extends ESTestCase {
  private NetworkService networkService;
  private ThreadPool threadPool;
  private MockBigArrays bigArrays;
  @Before public void setup() throws Exception {
    networkService=new NetworkService(Collections.emptyList());
    threadPool=new TestThreadPool("test");
    bigArrays=new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY),new NoneCircuitBreakerService());
  }
  @After public void shutdown() throws Exception {
    if (threadPool != null) {
      threadPool.shutdownNow();
    }
  }
  public void testThatHttpPipeliningWorksWhenEnabled() throws Exception {
    final Settings settings=Settings.builder().put("http.pipelining",true).put("http.port","0").build();
    try (HttpServerTransport httpServerTransport=new CustomNettyHttpServerTransport(settings)){
      httpServerTransport.start();
      final TransportAddress transportAddress=randomFrom(httpServerTransport.boundAddress().boundAddresses());
      final int numberOfRequests=randomIntBetween(4,16);
      final List<String> requests=new ArrayList<>(numberOfRequests);
      for (int i=0; i < numberOfRequests; i++) {
        if (rarely()) {
          requests.add("/slow/" + i);
        }
 else {
          requests.add("/" + i);
        }
      }
      try (Netty4HttpClient nettyHttpClient=new Netty4HttpClient()){
        Collection<FullHttpResponse> responses=nettyHttpClient.get(transportAddress.address(),requests.toArray(new String[]{}));
        try {
          Collection<String> responseBodies=Netty4HttpClient.returnHttpResponseBodies(responses);
          assertThat(responseBodies,contains(requests.toArray()));
        }
  finally {
          responses.forEach(ReferenceCounted::release);
        }
      }
     }
     assertSettingDeprecationsAndWarnings(new Setting<?>[]{HttpTransportSettings.SETTING_PIPELINING});
  }
  public void testThatHttpPipeliningCanBeDisabled() throws Exception {
    final Settings settings=Settings.builder().put("http.pipelining",false).put("http.port","0").build();
    try (HttpServerTransport httpServerTransport=new CustomNettyHttpServerTransport(settings)){
      httpServerTransport.start();
      final TransportAddress transportAddress=randomFrom(httpServerTransport.boundAddress().boundAddresses());
      final int numberOfRequests=randomIntBetween(4,16);
      final Set<Integer> slowIds=new HashSet<>();
      final List<String> requests=new ArrayList<>(numberOfRequests);
      for (int i=0; i < numberOfRequests; i++) {
        if (rarely()) {
          requests.add("/slow/" + i);
          slowIds.add(i);
        }
 else {
          requests.add("/" + i);
        }
      }
      try (Netty4HttpClient nettyHttpClient=new Netty4HttpClient()){
        Collection<FullHttpResponse> responses=nettyHttpClient.get(transportAddress.address(),requests.toArray(new String[]{}));
        try {
          List<String> responseBodies=new ArrayList<>(Netty4HttpClient.returnHttpResponseBodies(responses));
          assertThat(responseBodies,hasSize(numberOfRequests));
          for (int i=0; i < numberOfRequests - slowIds.size(); i++) {
            assertThat(responseBodies.get(i),matches("/\\d+"));
          }
          final Set<Integer> ids=new HashSet<>();
          for (int i=0; i < slowIds.size(); i++) {
            final String response=responseBodies.get(numberOfRequests - slowIds.size() + i);
            assertThat(response,matches("/slow/\\d+"));
            assertTrue(ids.add(Integer.parseInt(response.split("/")[2])));
          }
          assertThat(slowIds,equalTo(ids));
        }
  finally {
          responses.forEach(ReferenceCounted::release);
        }
      }
     }
     assertSettingDeprecationsAndWarnings(new Setting<?>[]{HttpTransportSettings.SETTING_PIPELINING});
  }
class CustomNettyHttpServerTransport extends Netty4HttpServerTransport {
    private final ExecutorService executorService=Executors.newCachedThreadPool();
    CustomNettyHttpServerTransport(    final Settings settings){
      super(settings,Netty4HttpServerPipeliningTests.this.networkService,Netty4HttpServerPipeliningTests.this.bigArrays,Netty4HttpServerPipeliningTests.this.threadPool,xContentRegistry(),new NullDispatcher());
    }
    @Override public ChannelHandler configureServerChannelHandler(){
      return new CustomHttpChannelHandler(this,executorService,Netty4HttpServerPipeliningTests.this.threadPool.getThreadContext());
    }
    @Override protected void doClose(){
      executorService.shutdown();
      super.doClose();
    }
  }
private class CustomHttpChannelHandler extends Netty4HttpServerTransport.HttpChannelHandler {
    private final ExecutorService executorService;
    CustomHttpChannelHandler(    Netty4HttpServerTransport transport,    ExecutorService executorService,    ThreadContext threadContext){
      super(transport,randomBoolean(),threadContext);
      this.executorService=executorService;
    }
    @Override protected void initChannel(    Channel ch) throws Exception {
      super.initChannel(ch);
      ch.pipeline().replace("handler","handler",new PossiblySlowUpstreamHandler(executorService));
    }
  }
class PossiblySlowUpstreamHandler extends SimpleChannelInboundHandler<Object> {
    private final ExecutorService executorService;
    PossiblySlowUpstreamHandler(    ExecutorService executorService){
      this.executorService=executorService;
    }
    @Override protected void channelRead0(    ChannelHandlerContext ctx,    Object msg) throws Exception {
      executorService.submit(new PossiblySlowRunnable(ctx,msg));
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      logger.info("Caught exception",cause);
      ctx.channel().close().sync();
    }
  }
class PossiblySlowRunnable implements Runnable {
    private ChannelHandlerContext ctx;
    private HttpPipelinedRequest pipelinedRequest;
    private FullHttpRequest fullHttpRequest;
    PossiblySlowRunnable(    ChannelHandlerContext ctx,    Object msg){
      this.ctx=ctx;
      if (msg instanceof HttpPipelinedRequest) {
        this.pipelinedRequest=(HttpPipelinedRequest)msg;
      }
 else       if (msg instanceof FullHttpRequest) {
        this.fullHttpRequest=(FullHttpRequest)msg;
      }
    }
    @Override public void run(){
      try {
        final String uri;
        if (pipelinedRequest != null && pipelinedRequest.last() instanceof FullHttpRequest) {
          uri=((FullHttpRequest)pipelinedRequest.last()).uri();
        }
 else {
          uri=fullHttpRequest.uri();
        }
        final ByteBuf buffer=Unpooled.copiedBuffer(uri,StandardCharsets.UTF_8);
        final FullHttpResponse httpResponse=new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buffer);
        httpResponse.headers().add(HttpHeaderNames.CONTENT_LENGTH,buffer.readableBytes());
        final boolean slow=uri.matches("/slow/\\d+");
        if (slow) {
          try {
            Thread.sleep(scaledRandomIntBetween(500,1000));
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
 else {
          assert uri.matches("/\\d+");
        }
        final ChannelPromise promise=ctx.newPromise();
        final Object msg;
        if (pipelinedRequest != null) {
          msg=pipelinedRequest.createHttpResponse(httpResponse,promise);
        }
 else {
          msg=httpResponse;
        }
        ctx.writeAndFlush(msg,promise);
      }
  finally {
        if (pipelinedRequest != null) {
          pipelinedRequest.release();
        }
      }
    }
  }
}
