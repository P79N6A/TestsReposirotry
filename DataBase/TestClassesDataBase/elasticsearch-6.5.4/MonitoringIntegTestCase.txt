public abstract class MonitoringIntegTestCase extends ESIntegTestCase {
  protected static final String MONITORING_INDICES_PREFIX=".monitoring-";
  protected static final String ALL_MONITORING_INDICES=MONITORING_INDICES_PREFIX + "*";
  @Override protected Settings nodeSettings(  int nodeOrdinal){
    Settings.Builder builder=Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(MonitoringService.INTERVAL.getKey(),MonitoringService.MIN_INTERVAL).put("index.store.mock.check_index_on_close",false);
    return builder.build();
  }
  @Override protected Settings transportClientSettings(){
    return Settings.builder().put(super.transportClientSettings()).put(XPackSettings.WATCHER_ENABLED.getKey(),false).build();
  }
  @Override protected Collection<Class<? extends Plugin>> getMockPlugins(){
    Set<Class<? extends Plugin>> plugins=new HashSet<>(super.getMockPlugins());
    plugins.remove(MockTransportService.TestPlugin.class);
    plugins.add(MockFSIndexStore.TestPlugin.class);
    return plugins;
  }
  @Override protected Collection<Class<? extends Plugin>> nodePlugins(){
    return Arrays.asList(LocalStateMonitoring.class,MockPainlessScriptEngine.TestPlugin.class,MockIngestPlugin.class,CommonAnalysisPlugin.class);
  }
  @Override protected Collection<Class<? extends Plugin>> transportClientPlugins(){
    return nodePlugins();
  }
  protected MonitoringClient monitoringClient(){
    return randomBoolean() ? new XPackClient(client()).monitoring() : new MonitoringClient(client());
  }
  @Override protected Set<String> excludeTemplates(){
    return new HashSet<>(monitoringTemplateNames());
  }
  @Before public void setUp() throws Exception {
    super.setUp();
    startMonitoringService();
  }
  @After public void tearDown() throws Exception {
    stopMonitoringService();
    super.tearDown();
  }
  protected void startMonitoringService(){
    internalCluster().getInstances(MonitoringService.class).forEach(MonitoringService::start);
  }
  protected void stopMonitoringService(){
    internalCluster().getInstances(MonitoringService.class).forEach(MonitoringService::stop);
  }
  protected void wipeMonitoringIndices() throws Exception {
    CountDown retries=new CountDown(3);
    assertBusy(() -> {
      try {
        boolean exist=client().admin().indices().prepareExists(ALL_MONITORING_INDICES).get().isExists();
        if (exist) {
          deleteMonitoringIndices();
        }
 else {
          retries.countDown();
        }
      }
 catch (      IndexNotFoundException e) {
        retries.countDown();
      }
      assertThat(retries.isCountedDown(),is(true));
    }
);
  }
  protected void deleteMonitoringIndices(){
    assertAcked(client().admin().indices().prepareDelete(ALL_MONITORING_INDICES));
  }
  protected void awaitMonitoringDocsCountOnPrimary(  Matcher<Long> matcher,  String... types) throws Exception {
    assertBusy(() -> assertMonitoringDocsCountOnPrimary(matcher,types),30,TimeUnit.SECONDS);
  }
  protected void ensureMonitoringIndicesYellow(){
    ensureYellowAndNoInitializingShards(".monitoring-es-*");
  }
  protected void assertMonitoringDocsCountOnPrimary(  Matcher<Long> matcher,  String... types){
    flushAndRefresh(ALL_MONITORING_INDICES);
    long count=client().prepareSearch(ALL_MONITORING_INDICES).setSize(0).setQuery(QueryBuilders.termsQuery("type",types)).setPreference("_primary").get().getHits().getTotalHits();
    logger.trace("--> searched for [{}] documents on primary, found [{}]",Strings.arrayToCommaDelimitedString(types),count);
    assertThat(count,matcher);
  }
  protected List<Tuple<String,String>> monitoringTemplates(){
    return Arrays.stream(MonitoringTemplateUtils.TEMPLATE_IDS).map(id -> new Tuple<>(MonitoringTemplateUtils.templateName(id),MonitoringTemplateUtils.loadTemplate(id))).collect(Collectors.toList());
  }
  protected List<String> monitoringTemplateNames(){
    return Arrays.stream(MonitoringTemplateUtils.TEMPLATE_IDS).map(MonitoringTemplateUtils::templateName).collect(Collectors.toList());
  }
  private Tuple<String,String> monitoringPipeline(  final String pipelineId){
    final XContentType json=XContentType.JSON;
    return new Tuple<>(MonitoringTemplateUtils.pipelineName(pipelineId),Strings.toString(MonitoringTemplateUtils.loadPipeline(pipelineId,json)));
  }
  protected List<Tuple<String,String>> monitoringPipelines(){
    return Arrays.stream(MonitoringTemplateUtils.PIPELINE_IDS).map(this::monitoringPipeline).collect(Collectors.toList());
  }
  protected List<String> monitoringPipelineNames(){
    return Arrays.stream(MonitoringTemplateUtils.PIPELINE_IDS).map(MonitoringTemplateUtils::pipelineName).collect(Collectors.toList());
  }
  protected List<Tuple<String,String>> monitoringWatches(){
    final ClusterService clusterService=clusterService();
    return Arrays.stream(ClusterAlertsUtil.WATCH_IDS).map(id -> new Tuple<>(id,ClusterAlertsUtil.loadWatch(clusterService,id))).collect(Collectors.toList());
  }
  protected void assertTemplateInstalled(  String name){
    boolean found=false;
    for (    IndexTemplateMetaData template : client().admin().indices().prepareGetTemplates().get().getIndexTemplates()) {
      if (Regex.simpleMatch(name,template.getName())) {
        found=true;
      }
    }
    assertTrue("failed to find a template matching [" + name + "]",found);
  }
  protected void waitForMonitoringIndices() throws Exception {
    awaitIndexExists(ALL_MONITORING_INDICES);
    assertBusy(this::ensureMonitoringIndicesYellow);
  }
  private void awaitIndexExists(  final String index) throws Exception {
    assertBusy(() -> {
      assertIndicesExists(index);
    }
,30,TimeUnit.SECONDS);
  }
  private void assertIndicesExists(  String... indices){
    logger.trace("checking if index exists [{}]",Strings.arrayToCommaDelimitedString(indices));
    assertThat(client().admin().indices().prepareExists(indices).get().isExists(),is(true));
  }
  protected void enableMonitoringCollection(){
    assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put(MonitoringService.ENABLED.getKey(),true)));
  }
  protected void disableMonitoringCollection(){
    assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().putNull(MonitoringService.ENABLED.getKey())));
  }
}
