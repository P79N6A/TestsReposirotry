/** 
 * Creates two partitions with symmetric failures
 */
public static class TwoPartitions extends DisruptedLinks {
  protected final Set<String> nodesSideOne;
  protected final Set<String> nodesSideTwo;
  public TwoPartitions(  String node1,  String node2){
    this(Collections.singleton(node1),Collections.singleton(node2));
  }
  public TwoPartitions(  Set<String> nodesSideOne,  Set<String> nodesSideTwo){
    super(nodesSideOne,nodesSideTwo);
    this.nodesSideOne=nodesSideOne;
    this.nodesSideTwo=nodesSideTwo;
    assert nodesSideOne.isEmpty() == false;
    assert nodesSideTwo.isEmpty() == false;
    assert Sets.haveEmptyIntersection(nodesSideOne,nodesSideTwo);
  }
  public static TwoPartitions random(  Random random,  String... nodes){
    return random(random,Sets.newHashSet(nodes));
  }
  public static TwoPartitions random(  Random random,  Set<String> nodes){
    assert nodes.size() >= 2 : "two partitions topology requires at least 2 nodes";
    Set<String> nodesSideOne=new HashSet<>();
    Set<String> nodesSideTwo=new HashSet<>();
    for (    String node : nodes) {
      if (nodesSideOne.isEmpty()) {
        nodesSideOne.add(node);
      }
 else       if (nodesSideTwo.isEmpty()) {
        nodesSideTwo.add(node);
      }
 else       if (random.nextBoolean()) {
        nodesSideOne.add(node);
      }
 else {
        nodesSideTwo.add(node);
      }
    }
    return new TwoPartitions(nodesSideOne,nodesSideTwo);
  }
  @Override public boolean disrupt(  String node1,  String node2){
    if (nodesSideOne.contains(node1) && nodesSideTwo.contains(node2)) {
      return true;
    }
    if (nodesSideOne.contains(node2) && nodesSideTwo.contains(node1)) {
      return true;
    }
    return false;
  }
  public Set<String> getNodesSideOne(){
    return Collections.unmodifiableSet(nodesSideOne);
  }
  public Set<String> getNodesSideTwo(){
    return Collections.unmodifiableSet(nodesSideTwo);
  }
  public Collection<String> getMajoritySide(){
    if (nodesSideOne.size() >= nodesSideTwo.size()) {
      return getNodesSideOne();
    }
 else {
      return getNodesSideTwo();
    }
  }
  public Collection<String> getMinoritySide(){
    if (nodesSideOne.size() >= nodesSideTwo.size()) {
      return getNodesSideTwo();
    }
 else {
      return getNodesSideOne();
    }
  }
  @Override public String toString(){
    return "two partitions (partition 1: " + nodesSideOne + " and partition 2: "+ nodesSideTwo+ ")";
  }
}
