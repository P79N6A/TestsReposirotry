public class KeywordFieldTypeTests extends FieldTypeTestCase {
  @Before public void setupProperties(){
    addModifier(new Modifier("normalizer",false){
      @Override public void modify(      MappedFieldType type){
        ((KeywordFieldType)type).setNormalizer(Lucene.KEYWORD_ANALYZER);
      }
    }
);
    addModifier(new Modifier("split_queries_on_whitespace",true){
      @Override public void modify(      MappedFieldType type){
        KeywordFieldType keywordType=(KeywordFieldType)type;
        keywordType.setSplitQueriesOnWhitespace(!keywordType.splitQueriesOnWhitespace());
      }
    }
);
  }
  @Override protected MappedFieldType createDefaultFieldType(){
    return new KeywordFieldMapper.KeywordFieldType();
  }
  public void testIsFieldWithinQuery() throws IOException {
    KeywordFieldType ft=new KeywordFieldType();
    assertEquals(Relation.INTERSECTS,ft.isFieldWithinQuery(null,RandomStrings.randomAsciiOfLengthBetween(random(),0,5),RandomStrings.randomAsciiOfLengthBetween(random(),0,5),randomBoolean(),randomBoolean(),null,null,null));
  }
  public void testTermQuery(){
    MappedFieldType ft=createDefaultFieldType();
    ft.setName("field");
    ft.setIndexOptions(IndexOptions.DOCS);
    assertEquals(new TermQuery(new Term("field","foo")),ft.termQuery("foo",null));
    ft.setIndexOptions(IndexOptions.NONE);
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> ft.termQuery("bar",null));
    assertEquals("Cannot search on field [field] since it is not indexed.",e.getMessage());
  }
  public void testTermQueryWithNormalizer(){
    MappedFieldType ft=createDefaultFieldType();
    ft.setName("field");
    ft.setIndexOptions(IndexOptions.DOCS);
    Analyzer normalizer=new Analyzer(){
      @Override protected TokenStreamComponents createComponents(      String fieldName){
        Tokenizer in=new WhitespaceTokenizer();
        TokenFilter out=new LowerCaseFilter(in);
        return new TokenStreamComponents(in,out);
      }
      @Override protected TokenStream normalize(      String fieldName,      TokenStream in){
        return new LowerCaseFilter(in);
      }
    }
;
    ft.setSearchAnalyzer(new NamedAnalyzer("my_normalizer",AnalyzerScope.INDEX,normalizer));
    assertEquals(new TermQuery(new Term("field","foo bar")),ft.termQuery("fOo BaR",null));
    ft.setIndexOptions(IndexOptions.NONE);
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> ft.termQuery("bar",null));
    assertEquals("Cannot search on field [field] since it is not indexed.",e.getMessage());
  }
  public void testTermsQuery(){
    MappedFieldType ft=createDefaultFieldType();
    ft.setName("field");
    ft.setIndexOptions(IndexOptions.DOCS);
    List<BytesRef> terms=new ArrayList<>();
    terms.add(new BytesRef("foo"));
    terms.add(new BytesRef("bar"));
    assertEquals(new TermInSetQuery("field",terms),ft.termsQuery(Arrays.asList("foo","bar"),null));
    ft.setIndexOptions(IndexOptions.NONE);
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> ft.termsQuery(Arrays.asList("foo","bar"),null));
    assertEquals("Cannot search on field [field] since it is not indexed.",e.getMessage());
  }
  public void testExistsQuery(){
    MappedFieldType ft=createDefaultFieldType();
    ft.setName("field");
    ft.setHasDocValues(true);
    ft.setOmitNorms(true);
    assertEquals(new DocValuesFieldExistsQuery("field"),ft.existsQuery(null));
    ft.setHasDocValues(false);
    ft.setOmitNorms(false);
    assertEquals(new NormsFieldExistsQuery("field"),ft.existsQuery(null));
    ft.setHasDocValues(false);
    ft.setOmitNorms(true);
    assertEquals(new TermQuery(new Term(FieldNamesFieldMapper.NAME,"field")),ft.existsQuery(null));
  }
  public void testRegexpQuery(){
    MappedFieldType ft=createDefaultFieldType();
    ft.setName("field");
    ft.setIndexOptions(IndexOptions.DOCS);
    assertEquals(new RegexpQuery(new Term("field","foo.*")),ft.regexpQuery("foo.*",0,10,null,null));
    ft.setIndexOptions(IndexOptions.NONE);
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> ft.regexpQuery("foo.*",0,10,null,null));
    assertEquals("Cannot search on field [field] since it is not indexed.",e.getMessage());
  }
  public void testFuzzyQuery(){
    MappedFieldType ft=createDefaultFieldType();
    ft.setName("field");
    ft.setIndexOptions(IndexOptions.DOCS);
    assertEquals(new FuzzyQuery(new Term("field","foo"),2,1,50,true),ft.fuzzyQuery("foo",Fuzziness.fromEdits(2),1,50,true));
    ft.setIndexOptions(IndexOptions.NONE);
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> ft.fuzzyQuery("foo",Fuzziness.fromEdits(2),1,50,true));
    assertEquals("Cannot search on field [field] since it is not indexed.",e.getMessage());
  }
  public void testNormalizeQueries(){
    MappedFieldType ft=createDefaultFieldType();
    ft.setName("field");
    ft.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);
    assertEquals(new TermQuery(new Term("field",new BytesRef("FOO"))),ft.termQuery("FOO",null));
    ft.setSearchAnalyzer(Lucene.STANDARD_ANALYZER);
    assertEquals(new TermQuery(new Term("field",new BytesRef("foo"))),ft.termQuery("FOO",null));
  }
}
