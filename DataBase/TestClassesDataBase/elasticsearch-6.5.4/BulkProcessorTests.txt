public class BulkProcessorTests extends ESTestCase {
  private ThreadPool threadPool;
  @Before public void startThreadPool(){
    threadPool=new TestThreadPool("BulkProcessorTests");
  }
  @After public void stopThreadPool() throws InterruptedException {
    terminate(threadPool);
  }
  public void testBulkProcessorFlushPreservesContext() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    final String headerKey=randomAlphaOfLengthBetween(1,8);
    final String transientKey=randomAlphaOfLengthBetween(1,8);
    final String headerValue=randomAlphaOfLengthBetween(1,32);
    final Object transientValue=new Object();
    BiConsumer<BulkRequest,ActionListener<BulkResponse>> consumer=(request,listener) -> {
      ThreadContext threadContext=threadPool.getThreadContext();
      assertEquals(headerValue,threadContext.getHeader(headerKey));
      assertSame(transientValue,threadContext.getTransient(transientKey));
      latch.countDown();
    }
;
    final int bulkSize=randomIntBetween(2,32);
    final TimeValue flushInterval=TimeValue.timeValueSeconds(1L);
    final BulkProcessor bulkProcessor;
    assertNull(threadPool.getThreadContext().getHeader(headerKey));
    assertNull(threadPool.getThreadContext().getTransient(transientKey));
    try (ThreadContext.StoredContext ignore=threadPool.getThreadContext().stashContext()){
      threadPool.getThreadContext().putHeader(headerKey,headerValue);
      threadPool.getThreadContext().putTransient(transientKey,transientValue);
      bulkProcessor=new BulkProcessor(consumer,BackoffPolicy.noBackoff(),new BulkProcessor.Listener(){
        @Override public void beforeBulk(        long executionId,        BulkRequest request){
        }
        @Override public void afterBulk(        long executionId,        BulkRequest request,        BulkResponse response){
        }
        @Override public void afterBulk(        long executionId,        BulkRequest request,        Throwable failure){
        }
      }
,1,bulkSize,new ByteSizeValue(5,ByteSizeUnit.MB),flushInterval,threadPool,() -> {
      }
);
    }
     assertNull(threadPool.getThreadContext().getHeader(headerKey));
    assertNull(threadPool.getThreadContext().getTransient(transientKey));
    bulkProcessor.add(new IndexRequest());
    latch.await();
    assertNull(threadPool.getThreadContext().getHeader(headerKey));
    assertNull(threadPool.getThreadContext().getTransient(transientKey));
    bulkProcessor.close();
  }
  public void testAwaitOnCloseCallsOnClose() throws Exception {
    final AtomicBoolean called=new AtomicBoolean(false);
    BulkProcessor bulkProcessor=new BulkProcessor((request,listener) -> {
    }
,BackoffPolicy.noBackoff(),new BulkProcessor.Listener(){
      @Override public void beforeBulk(      long executionId,      BulkRequest request){
      }
      @Override public void afterBulk(      long executionId,      BulkRequest request,      BulkResponse response){
      }
      @Override public void afterBulk(      long executionId,      BulkRequest request,      Throwable failure){
      }
    }
,0,10,new ByteSizeValue(1000),null,(delay,executor,command) -> null,() -> called.set(true));
    assertFalse(called.get());
    bulkProcessor.awaitClose(100,TimeUnit.MILLISECONDS);
    assertTrue(called.get());
  }
}
