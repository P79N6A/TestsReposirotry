/** 
 * Base class for testing  {@link Aggregator} implementations.Provides helpers for constructing and searching an  {@link Aggregator} implementation based on a provided{@link AggregationBuilder} instance.
 */
public abstract class AggregatorTestCase extends ESTestCase {
  private static final String NESTEDFIELD_PREFIX="nested_";
  private List<Releasable> releasables=new ArrayList<>();
  private static final String TYPE_NAME="type";
  protected AggregatorFactory<?> createAggregatorFactory(  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  MappedFieldType... fieldTypes) throws IOException {
    return createAggregatorFactory(aggregationBuilder,indexSearcher,createIndexSettings(),new MultiBucketConsumer(DEFAULT_MAX_BUCKETS),fieldTypes);
  }
  protected AggregatorFactory<?> createAggregatorFactory(  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  IndexSettings indexSettings,  MultiBucketConsumer bucketConsumer,  MappedFieldType... fieldTypes) throws IOException {
    return createAggregatorFactory(null,aggregationBuilder,indexSearcher,indexSettings,bucketConsumer,fieldTypes);
  }
  /** 
 * Create a factory for the given aggregation builder. 
 */
  protected AggregatorFactory<?> createAggregatorFactory(  Query query,  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  IndexSettings indexSettings,  MultiBucketConsumer bucketConsumer,  MappedFieldType... fieldTypes) throws IOException {
    SearchContext searchContext=createSearchContext(indexSearcher,indexSettings);
    CircuitBreakerService circuitBreakerService=new NoneCircuitBreakerService();
    when(searchContext.aggregations()).thenReturn(new SearchContextAggregations(AggregatorFactories.EMPTY,bucketConsumer));
    when(searchContext.bigArrays()).thenReturn(new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY),circuitBreakerService));
    when(searchContext.query()).thenReturn(query);
    MapperService mapperService=mapperServiceMock();
    when(mapperService.getIndexSettings()).thenReturn(indexSettings);
    when(mapperService.hasNested()).thenReturn(false);
    when(mapperService.types()).thenReturn(Collections.singleton(TYPE_NAME));
    when(searchContext.mapperService()).thenReturn(mapperService);
    IndexFieldDataService ifds=new IndexFieldDataService(indexSettings,new IndicesFieldDataCache(Settings.EMPTY,new IndexFieldDataCache.Listener(){
    }
),circuitBreakerService,mapperService);
    when(searchContext.getForField(Mockito.any(MappedFieldType.class))).thenAnswer(invocationOnMock -> ifds.getForField((MappedFieldType)invocationOnMock.getArguments()[0]));
    SearchLookup searchLookup=new SearchLookup(mapperService,ifds::getForField,new String[]{TYPE_NAME});
    when(searchContext.lookup()).thenReturn(searchLookup);
    QueryShardContext queryShardContext=queryShardContextMock(mapperService);
    when(queryShardContext.getIndexSettings()).thenReturn(indexSettings);
    when(searchContext.getQueryShardContext()).thenReturn(queryShardContext);
    Map<String,MappedFieldType> fieldNameToType=new HashMap<>();
    fieldNameToType.putAll(Arrays.stream(fieldTypes).collect(Collectors.toMap(MappedFieldType::name,Function.identity())));
    fieldNameToType.putAll(getFieldAliases(fieldTypes));
    registerFieldTypes(queryShardContext,searchContext,mapperService,circuitBreakerService,fieldNameToType);
    return aggregationBuilder.build(searchContext,null);
  }
  /** 
 * Allows subclasses to provide alternate names for the provided field type, which can be useful when testing aggregations on field aliases.
 */
  protected Map<String,MappedFieldType> getFieldAliases(  MappedFieldType... fieldTypes){
    return Collections.emptyMap();
  }
  private void registerFieldTypes(  QueryShardContext queryShardContext,  SearchContext searchContext,  MapperService mapperService,  CircuitBreakerService circuitBreakerService,  Map<String,MappedFieldType> fieldNameToType){
    for (    Map.Entry<String,MappedFieldType> entry : fieldNameToType.entrySet()) {
      String fieldName=entry.getKey();
      MappedFieldType fieldType=entry.getValue();
      when(queryShardContext.fieldMapper(fieldName)).thenReturn(fieldType);
      when(searchContext.smartNameFieldType(fieldName)).thenReturn(fieldType);
    }
    for (    MappedFieldType fieldType : new HashSet<>(fieldNameToType.values())) {
      when(queryShardContext.getForField(fieldType)).then(invocation -> fieldType.fielddataBuilder(mapperService.getIndexSettings().getIndex().getName()).build(mapperService.getIndexSettings(),fieldType,new IndexFieldDataCache.None(),circuitBreakerService,mapperService));
    }
  }
  protected <A extends Aggregator>A createAggregator(  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  MappedFieldType... fieldTypes) throws IOException {
    return createAggregator(aggregationBuilder,indexSearcher,createIndexSettings(),new MultiBucketConsumer(DEFAULT_MAX_BUCKETS),fieldTypes);
  }
  protected <A extends Aggregator>A createAggregator(  Query query,  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  IndexSettings indexSettings,  MappedFieldType... fieldTypes) throws IOException {
    return createAggregator(query,aggregationBuilder,indexSearcher,indexSettings,new MultiBucketConsumer(DEFAULT_MAX_BUCKETS),fieldTypes);
  }
  protected <A extends Aggregator>A createAggregator(  Query query,  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  MultiBucketConsumer bucketConsumer,  MappedFieldType... fieldTypes) throws IOException {
    return createAggregator(query,aggregationBuilder,indexSearcher,createIndexSettings(),bucketConsumer,fieldTypes);
  }
  protected <A extends Aggregator>A createAggregator(  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  IndexSettings indexSettings,  MultiBucketConsumer bucketConsumer,  MappedFieldType... fieldTypes) throws IOException {
    return createAggregator(null,aggregationBuilder,indexSearcher,indexSettings,bucketConsumer,fieldTypes);
  }
  protected <A extends Aggregator>A createAggregator(  Query query,  AggregationBuilder aggregationBuilder,  IndexSearcher indexSearcher,  IndexSettings indexSettings,  MultiBucketConsumer bucketConsumer,  MappedFieldType... fieldTypes) throws IOException {
    @SuppressWarnings("unchecked") A aggregator=(A)createAggregatorFactory(query,aggregationBuilder,indexSearcher,indexSettings,bucketConsumer,fieldTypes).create(null,true);
    return aggregator;
  }
  protected SearchContext createSearchContext(  IndexSearcher indexSearcher,  IndexSettings indexSettings){
    Engine.Searcher searcher=new Engine.Searcher("aggregator_test",indexSearcher,() -> indexSearcher.getIndexReader().close());
    QueryCache queryCache=new DisabledQueryCache(indexSettings);
    QueryCachingPolicy queryCachingPolicy=new QueryCachingPolicy(){
      @Override public void onUse(      Query query){
      }
      @Override public boolean shouldCache(      Query query){
        return false;
      }
    }
;
    ContextIndexSearcher contextIndexSearcher=new ContextIndexSearcher(searcher,queryCache,queryCachingPolicy);
    SearchContext searchContext=mock(SearchContext.class);
    when(searchContext.numberOfShards()).thenReturn(1);
    when(searchContext.searcher()).thenReturn(contextIndexSearcher);
    when(searchContext.fetchPhase()).thenReturn(new FetchPhase(Arrays.asList(new FetchSourceSubPhase(),new DocValueFieldsFetchSubPhase())));
    when(searchContext.getObjectMapper(anyString())).thenAnswer(invocation -> {
      String fieldName=(String)invocation.getArguments()[0];
      if (fieldName.startsWith(NESTEDFIELD_PREFIX)) {
        BuilderContext context=new BuilderContext(indexSettings.getSettings(),new ContentPath());
        return new ObjectMapper.Builder<>(fieldName).nested(Nested.newNested(false,false)).build(context);
      }
      return null;
    }
);
    when(searchContext.bitsetFilterCache()).thenReturn(new BitsetFilterCache(indexSettings,mock(Listener.class)));
    doAnswer(invocation -> {
      releasables.add((Releasable)invocation.getArguments()[0]);
      return null;
    }
).when(searchContext).addReleasable(anyObject(),anyObject());
    return searchContext;
  }
  protected IndexSettings createIndexSettings(){
    return new IndexSettings(IndexMetaData.builder("_index").settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED,Version.CURRENT)).numberOfShards(1).numberOfReplicas(0).creationDate(System.currentTimeMillis()).build(),Settings.EMPTY);
  }
  /** 
 * sub-tests that need a more complex mock can overwrite this
 */
  protected MapperService mapperServiceMock(){
    return mock(MapperService.class);
  }
  /** 
 * sub-tests that need a more complex mock can overwrite this
 */
  protected QueryShardContext queryShardContextMock(  MapperService mapperService){
    QueryShardContext queryShardContext=mock(QueryShardContext.class);
    when(queryShardContext.getMapperService()).thenReturn(mapperService);
    NestedScope nestedScope=new NestedScope();
    when(queryShardContext.isFilter()).thenCallRealMethod();
    Mockito.doCallRealMethod().when(queryShardContext).setIsFilter(Matchers.anyBoolean());
    when(queryShardContext.nestedScope()).thenReturn(nestedScope);
    return queryShardContext;
  }
  protected <A extends InternalAggregation,C extends Aggregator>A search(  IndexSearcher searcher,  Query query,  AggregationBuilder builder,  MappedFieldType... fieldTypes) throws IOException {
    return search(searcher,query,builder,DEFAULT_MAX_BUCKETS,fieldTypes);
  }
  protected <A extends InternalAggregation,C extends Aggregator>A search(  IndexSearcher searcher,  Query query,  AggregationBuilder builder,  int maxBucket,  MappedFieldType... fieldTypes) throws IOException {
    MultiBucketConsumer bucketConsumer=new MultiBucketConsumer(maxBucket);
    C a=createAggregator(query,builder,searcher,bucketConsumer,fieldTypes);
    a.preCollection();
    searcher.search(query,a);
    a.postCollection();
    @SuppressWarnings("unchecked") A internalAgg=(A)a.buildAggregation(0L);
    InternalAggregationTestCase.assertMultiBucketConsumer(internalAgg,bucketConsumer);
    return internalAgg;
  }
  protected <A extends InternalAggregation,C extends Aggregator>A searchAndReduce(  IndexSearcher searcher,  Query query,  AggregationBuilder builder,  MappedFieldType... fieldTypes) throws IOException {
    return searchAndReduce(searcher,query,builder,DEFAULT_MAX_BUCKETS,null,fieldTypes);
  }
  /** 
 * Divides the provided  {@link IndexSearcher} in sub-searcher, one for each segment,builds an aggregator for each sub-searcher filtered by the provided  {@link Query} andreturns the reduced  {@link InternalAggregation}.
 */
  protected <A extends InternalAggregation,C extends Aggregator>A searchAndReduce(  IndexSearcher searcher,  Query query,  AggregationBuilder builder,  int maxBucket,  ScriptService scriptService,  MappedFieldType... fieldTypes) throws IOException {
    final IndexReaderContext ctx=searcher.getTopReaderContext();
    final ShardSearcher[] subSearchers;
    if (ctx instanceof LeafReaderContext) {
      subSearchers=new ShardSearcher[1];
      subSearchers[0]=new ShardSearcher((LeafReaderContext)ctx,ctx);
    }
 else {
      final CompositeReaderContext compCTX=(CompositeReaderContext)ctx;
      final int size=compCTX.leaves().size();
      subSearchers=new ShardSearcher[size];
      for (int searcherIDX=0; searcherIDX < subSearchers.length; searcherIDX++) {
        final LeafReaderContext leave=compCTX.leaves().get(searcherIDX);
        subSearchers[searcherIDX]=new ShardSearcher(leave,compCTX);
      }
    }
    List<InternalAggregation> aggs=new ArrayList<>();
    Query rewritten=searcher.rewrite(query);
    Weight weight=searcher.createWeight(rewritten,true,1f);
    MultiBucketConsumer bucketConsumer=new MultiBucketConsumer(maxBucket);
    C root=createAggregator(query,builder,searcher,bucketConsumer,fieldTypes);
    for (    ShardSearcher subSearcher : subSearchers) {
      MultiBucketConsumer shardBucketConsumer=new MultiBucketConsumer(maxBucket);
      C a=createAggregator(query,builder,subSearcher,shardBucketConsumer,fieldTypes);
      a.preCollection();
      subSearcher.search(weight,a);
      a.postCollection();
      InternalAggregation agg=a.buildAggregation(0L);
      aggs.add(agg);
      InternalAggregationTestCase.assertMultiBucketConsumer(agg,shardBucketConsumer);
    }
    if (aggs.isEmpty()) {
      return null;
    }
 else {
      if (randomBoolean() && aggs.size() > 1) {
        int toReduceSize=aggs.size();
        Collections.shuffle(aggs,random());
        int r=randomIntBetween(1,toReduceSize);
        List<InternalAggregation> toReduce=aggs.subList(0,r);
        MultiBucketConsumer reduceBucketConsumer=new MultiBucketConsumer(maxBucket);
        InternalAggregation.ReduceContext context=new InternalAggregation.ReduceContext(root.context().bigArrays(),null,reduceBucketConsumer,false);
        A reduced=(A)aggs.get(0).doReduce(toReduce,context);
        InternalAggregationTestCase.assertMultiBucketConsumer(reduced,reduceBucketConsumer);
        aggs=new ArrayList<>(aggs.subList(r,toReduceSize));
        aggs.add(reduced);
      }
      MultiBucketConsumer reduceBucketConsumer=new MultiBucketConsumer(maxBucket);
      InternalAggregation.ReduceContext context=new InternalAggregation.ReduceContext(root.context().bigArrays(),scriptService,reduceBucketConsumer,true);
      @SuppressWarnings("unchecked") A internalAgg=(A)aggs.get(0).doReduce(aggs,context);
      if (internalAgg.pipelineAggregators().size() > 0) {
        for (        PipelineAggregator pipelineAggregator : internalAgg.pipelineAggregators()) {
          internalAgg=(A)pipelineAggregator.reduce(internalAgg,context);
        }
      }
      InternalAggregationTestCase.assertMultiBucketConsumer(internalAgg,reduceBucketConsumer);
      return internalAgg;
    }
  }
private static class ShardSearcher extends IndexSearcher {
    private final List<LeafReaderContext> ctx;
    ShardSearcher(    LeafReaderContext ctx,    IndexReaderContext parent){
      super(parent);
      this.ctx=Collections.singletonList(ctx);
    }
    public void search(    Weight weight,    Collector collector) throws IOException {
      search(ctx,weight,collector);
    }
    @Override public String toString(){
      return "ShardSearcher(" + ctx.get(0) + ")";
    }
  }
  protected static DirectoryReader wrap(  DirectoryReader directoryReader) throws IOException {
    return ElasticsearchDirectoryReader.wrap(directoryReader,new ShardId(new Index("_index","_na_"),0));
  }
  /** 
 * Added to randomly run with more assertions on the index searcher level, like  {@link org.apache.lucene.util.LuceneTestCase#newSearcher(IndexReader)}, which can't be used because it also wraps in the IndexSearcher's IndexReader with other implementations that we can't handle. (e.g. ParallelCompositeReader)
 */
  protected static IndexSearcher newIndexSearcher(  IndexReader indexReader){
    if (randomBoolean()) {
      return new AssertingIndexSearcher(random(),indexReader);
    }
 else {
      return new IndexSearcher(indexReader);
    }
  }
  /** 
 * Added to randomly run with more assertions on the index reader level, like  {@link org.apache.lucene.util.LuceneTestCase#wrapReader(IndexReader)}, which can't be used because it also wraps in the IndexReader with other implementations that we can't handle. (e.g. ParallelCompositeReader)
 */
  protected static IndexReader maybeWrapReaderEs(  DirectoryReader reader) throws IOException {
    if (randomBoolean()) {
      return new AssertingDirectoryReader(reader);
    }
 else {
      return reader;
    }
  }
  @After private void cleanupReleasables(){
    Releasables.close(releasables);
    releasables.clear();
  }
}
