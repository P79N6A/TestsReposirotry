/** 
 * This class tests that aggregations parsing works properly. It checks that we can parse different aggregations and adds sub-aggregations where applicable.
 */
public class AggregationsTests extends ESTestCase {
  private static final List<InternalAggregationTestCase> aggsTests=getAggsTests();
  private static List<InternalAggregationTestCase> getAggsTests(){
    List<InternalAggregationTestCase> aggsTests=new ArrayList<>();
    aggsTests.add(new InternalCardinalityTests());
    aggsTests.add(new InternalTDigestPercentilesTests());
    aggsTests.add(new InternalTDigestPercentilesRanksTests());
    aggsTests.add(new InternalHDRPercentilesTests());
    aggsTests.add(new InternalHDRPercentilesRanksTests());
    aggsTests.add(new InternalPercentilesBucketTests());
    aggsTests.add(new InternalMinTests());
    aggsTests.add(new InternalMaxTests());
    aggsTests.add(new InternalAvgTests());
    aggsTests.add(new InternalSumTests());
    aggsTests.add(new InternalValueCountTests());
    aggsTests.add(new InternalSimpleValueTests());
    aggsTests.add(new InternalDerivativeTests());
    aggsTests.add(new InternalBucketMetricValueTests());
    aggsTests.add(new InternalStatsTests());
    aggsTests.add(new InternalStatsBucketTests());
    aggsTests.add(new InternalExtendedStatsTests());
    aggsTests.add(new InternalExtendedStatsBucketTests());
    aggsTests.add(new InternalGeoBoundsTests());
    aggsTests.add(new InternalGeoCentroidTests());
    aggsTests.add(new InternalHistogramTests());
    aggsTests.add(new InternalDateHistogramTests());
    aggsTests.add(new InternalAutoDateHistogramTests());
    aggsTests.add(new LongTermsTests());
    aggsTests.add(new DoubleTermsTests());
    aggsTests.add(new StringTermsTests());
    aggsTests.add(new InternalMissingTests());
    aggsTests.add(new InternalNestedTests());
    aggsTests.add(new InternalReverseNestedTests());
    aggsTests.add(new InternalGlobalTests());
    aggsTests.add(new InternalFilterTests());
    aggsTests.add(new InternalSamplerTests());
    aggsTests.add(new InternalGeoHashGridTests());
    aggsTests.add(new InternalRangeTests());
    aggsTests.add(new InternalDateRangeTests());
    aggsTests.add(new InternalGeoDistanceTests());
    aggsTests.add(new InternalFiltersTests());
    aggsTests.add(new InternalAdjacencyMatrixTests());
    aggsTests.add(new SignificantLongTermsTests());
    aggsTests.add(new SignificantStringTermsTests());
    aggsTests.add(new InternalScriptedMetricTests());
    aggsTests.add(new InternalBinaryRangeTests());
    aggsTests.add(new InternalTopHitsTests());
    aggsTests.add(new InternalCompositeTests());
    return Collections.unmodifiableList(aggsTests);
  }
  @Override protected NamedXContentRegistry xContentRegistry(){
    return new NamedXContentRegistry(InternalAggregationTestCase.getDefaultNamedXContents());
  }
  @Before public void init() throws Exception {
    for (    InternalAggregationTestCase aggsTest : aggsTests) {
      if (aggsTest instanceof InternalMultiBucketAggregationTestCase) {
        ((InternalMultiBucketAggregationTestCase)aggsTest).setMaxNumberOfBuckets(3);
      }
      aggsTest.setUp();
    }
  }
  @After public void cleanUp() throws Exception {
    for (    InternalAggregationTestCase aggsTest : aggsTests) {
      aggsTest.tearDown();
    }
  }
  public void testAllAggsAreBeingTested(){
    assertEquals(InternalAggregationTestCase.getDefaultNamedXContents().size(),aggsTests.size());
    Set<String> aggs=aggsTests.stream().map((testCase) -> testCase.createTestInstance().getType()).collect(Collectors.toSet());
    for (    NamedXContentRegistry.Entry entry : InternalAggregationTestCase.getDefaultNamedXContents()) {
      assertTrue(aggs.contains(entry.name.getPreferredName()));
    }
  }
  public void testFromXContent() throws IOException {
    parseAndAssert(false);
  }
  public void testFromXContentWithRandomFields() throws IOException {
    parseAndAssert(true);
  }
  /** 
 * Test that parsing works for a randomly created Aggregations object with a randomized aggregation tree. The test randomly chooses an {@link XContentType}, randomizes the order of the  {@link XContent} fieldsand randomly sets the `humanReadable` flag when rendering the {@link XContent}.
 * @param addRandomFields if set, this will also add random  {@link XContent} fields totests that the parsers are lenient to future additions to rest responses
 */
  private void parseAndAssert(  boolean addRandomFields) throws IOException {
    XContentType xContentType=randomFrom(XContentType.values());
    final ToXContent.Params params=new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM,"true"));
    Aggregations aggregations=createTestInstance();
    BytesReference originalBytes=toShuffledXContent(aggregations,xContentType,params,randomBoolean());
    BytesReference mutated;
    if (addRandomFields) {
      Predicate<String> excludes=path -> (path.isEmpty() || path.endsWith("aggregations") || path.endsWith(Aggregation.CommonFields.META.getPreferredName())|| path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())|| path.endsWith(CommonFields.VALUES.getPreferredName())|| path.endsWith("covariance")|| path.endsWith("correlation")|| path.contains(CommonFields.VALUE.getPreferredName())|| path.endsWith(CommonFields.KEY.getPreferredName()));
      mutated=insertRandomFields(xContentType,originalBytes,excludes,random());
    }
 else {
      mutated=originalBytes;
    }
    try (XContentParser parser=createParser(xContentType.xContent(),mutated)){
      assertEquals(XContentParser.Token.START_OBJECT,parser.nextToken());
      assertEquals(XContentParser.Token.FIELD_NAME,parser.nextToken());
      assertEquals(Aggregations.AGGREGATIONS_FIELD,parser.currentName());
      assertEquals(XContentParser.Token.START_OBJECT,parser.nextToken());
      Aggregations parsedAggregations=Aggregations.fromXContent(parser);
      BytesReference parsedBytes=XContentHelper.toXContent(parsedAggregations,xContentType,randomBoolean());
      ElasticsearchAssertions.assertToXContentEquivalent(originalBytes,parsedBytes,xContentType);
    }
   }
  public void testParsingExceptionOnUnknownAggregation() throws IOException {
    XContentBuilder builder=XContentFactory.jsonBuilder();
    builder.startObject();
{
      builder.startObject("unknownAggregation");
      builder.endObject();
    }
    builder.endObject();
    BytesReference originalBytes=BytesReference.bytes(builder);
    try (XContentParser parser=createParser(builder.contentType().xContent(),originalBytes)){
      assertEquals(XContentParser.Token.START_OBJECT,parser.nextToken());
      ParsingException ex=expectThrows(ParsingException.class,() -> Aggregations.fromXContent(parser));
      assertEquals("Could not parse aggregation keyed as [unknownAggregation]",ex.getMessage());
    }
   }
  public final InternalAggregations createTestInstance(){
    return createTestInstance(1,0,5);
  }
  private static InternalAggregations createTestInstance(  final int minNumAggs,  final int currentDepth,  final int maxDepth){
    int numAggs=randomIntBetween(minNumAggs,4);
    List<InternalAggregation> aggs=new ArrayList<>(numAggs);
    for (int i=0; i < numAggs; i++) {
      InternalAggregationTestCase testCase=randomFrom(aggsTests);
      if (testCase instanceof InternalMultiBucketAggregationTestCase) {
        InternalMultiBucketAggregationTestCase multiBucketAggTestCase=(InternalMultiBucketAggregationTestCase)testCase;
        if (currentDepth < maxDepth) {
          multiBucketAggTestCase.setSubAggregationsSupplier(() -> createTestInstance(0,currentDepth + 1,maxDepth));
        }
 else {
          multiBucketAggTestCase.setSubAggregationsSupplier(() -> InternalAggregations.EMPTY);
        }
      }
 else       if (testCase instanceof InternalSingleBucketAggregationTestCase) {
        InternalSingleBucketAggregationTestCase singleBucketAggTestCase=(InternalSingleBucketAggregationTestCase)testCase;
        if (currentDepth < maxDepth) {
          singleBucketAggTestCase.subAggregationsSupplier=() -> createTestInstance(0,currentDepth + 1,maxDepth);
        }
 else {
          singleBucketAggTestCase.subAggregationsSupplier=() -> InternalAggregations.EMPTY;
        }
      }
      aggs.add(testCase.createTestInstance());
    }
    return new InternalAggregations(aggs);
  }
}
