/** 
 * Mock for  {@link IndexService}
 */
protected class MockIndexService implements AllocatedIndex<MockIndexShard> {
  private volatile Map<Integer,MockIndexShard> shards=emptyMap();
  private final IndexSettings indexSettings;
  public MockIndexService(  IndexSettings indexSettings){
    this.indexSettings=indexSettings;
  }
  @Override public IndexSettings getIndexSettings(){
    return indexSettings;
  }
  @Override public boolean updateMapping(  final IndexMetaData currentIndexMetaData,  final IndexMetaData newIndexMetaData) throws IOException {
    failRandomly();
    return false;
  }
  @Override public void updateMetaData(  final IndexMetaData currentIndexMetaData,  final IndexMetaData newIndexMetaData){
    indexSettings.updateIndexMetaData(newIndexMetaData);
    for (    MockIndexShard shard : shards.values()) {
      shard.updateTerm(newIndexMetaData.primaryTerm(shard.shardId().id()));
    }
  }
  @Override public MockIndexShard getShardOrNull(  int shardId){
    return shards.get(shardId);
  }
  public synchronized MockIndexShard createShard(  ShardRouting routing) throws IOException {
    failRandomly();
    MockIndexShard shard=new MockIndexShard(routing,indexSettings.getIndexMetaData().primaryTerm(routing.shardId().id()));
    shards=newMapBuilder(shards).put(routing.id(),shard).immutableMap();
    return shard;
  }
  @Override public synchronized void removeShard(  int shardId,  String reason){
    if (shards.containsKey(shardId) == false) {
      return;
    }
    HashMap<Integer,MockIndexShard> newShards=new HashMap<>(shards);
    MockIndexShard indexShard=newShards.remove(shardId);
    assert indexShard != null;
    shards=unmodifiableMap(newShards);
  }
  @Override public Iterator<MockIndexShard> iterator(){
    return shards.values().iterator();
  }
  @Override public Index index(){
    return indexSettings.getIndex();
  }
}
