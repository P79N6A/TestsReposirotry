class PossiblySlowRunnable implements Runnable {
  private ChannelHandlerContext ctx;
  private HttpPipelinedRequest pipelinedRequest;
  private FullHttpRequest fullHttpRequest;
  PossiblySlowRunnable(  ChannelHandlerContext ctx,  Object msg){
    this.ctx=ctx;
    if (msg instanceof HttpPipelinedRequest) {
      this.pipelinedRequest=(HttpPipelinedRequest)msg;
    }
 else     if (msg instanceof FullHttpRequest) {
      this.fullHttpRequest=(FullHttpRequest)msg;
    }
  }
  @Override public void run(){
    try {
      final String uri;
      if (pipelinedRequest != null && pipelinedRequest.last() instanceof FullHttpRequest) {
        uri=((FullHttpRequest)pipelinedRequest.last()).uri();
      }
 else {
        uri=fullHttpRequest.uri();
      }
      final ByteBuf buffer=Unpooled.copiedBuffer(uri,StandardCharsets.UTF_8);
      final FullHttpResponse httpResponse=new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buffer);
      httpResponse.headers().add(HttpHeaderNames.CONTENT_LENGTH,buffer.readableBytes());
      final boolean slow=uri.matches("/slow/\\d+");
      if (slow) {
        try {
          Thread.sleep(scaledRandomIntBetween(500,1000));
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
 else {
        assert uri.matches("/\\d+");
      }
      final ChannelPromise promise=ctx.newPromise();
      final Object msg;
      if (pipelinedRequest != null) {
        msg=pipelinedRequest.createHttpResponse(httpResponse,promise);
      }
 else {
        msg=httpResponse;
      }
      ctx.writeAndFlush(msg,promise);
    }
  finally {
      if (pipelinedRequest != null) {
        pipelinedRequest.release();
      }
    }
  }
}
