public class SecurityCachePermissionTests extends SecurityIntegTestCase {
  private final String READ_ONE_IDX_USER="read_user";
  @Override public String configUsers(){
    return super.configUsers() + READ_ONE_IDX_USER + ":"+ SecuritySettingsSource.TEST_PASSWORD_HASHED+ "\n";
  }
  @Override public String configRoles(){
    return super.configRoles() + "\nread_one_idx:\n" + "  indices:\n"+ "    'data':\n"+ "      - read\n";
  }
  @Override public String configUsersRoles(){
    return super.configUsersRoles() + "read_one_idx:" + READ_ONE_IDX_USER+ "\n";
  }
  @Before public void loadData(){
    index("data","a","1","{ \"name\": \"John\", \"token\": \"token1\" }");
    index("tokens","tokens","1","{ \"group\": \"1\", \"tokens\": [\"token1\", \"token2\"] }");
    refresh();
  }
  public void testThatTermsFilterQueryDoesntLeakData(){
    SearchResponse response=client().prepareSearch("data").setTypes("a").setQuery(QueryBuilders.constantScoreQuery(QueryBuilders.termsLookupQuery("token",new TermsLookup("tokens","tokens","1","tokens")))).execute().actionGet();
    assertThat(response.isTimedOut(),is(false));
    assertThat(response.getHits().getHits().length,is(1));
    try {
      response=client().filterWithHeader(singletonMap("Authorization",basicAuthHeaderValue(READ_ONE_IDX_USER,SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING))).prepareSearch("data").setTypes("a").setQuery(QueryBuilders.constantScoreQuery(QueryBuilders.termsLookupQuery("token",new TermsLookup("tokens","tokens","1","tokens")))).execute().actionGet();
      fail("search phase exception should have been thrown! response was:\n" + response.toString());
    }
 catch (    ElasticsearchSecurityException e) {
      assertThat(e.toString(),containsString("ElasticsearchSecurityException[action"));
      assertThat(e.toString(),containsString("unauthorized"));
    }
  }
}
