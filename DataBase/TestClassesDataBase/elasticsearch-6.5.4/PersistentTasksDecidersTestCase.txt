public abstract class PersistentTasksDecidersTestCase extends ESTestCase {
  /** 
 * Needed by  {@link ClusterService} 
 */
  private static ThreadPool threadPool;
  /** 
 * Needed by  {@link PersistentTasksClusterService} 
 */
  private ClusterService clusterService;
  private PersistentTasksClusterService persistentTasksClusterService;
  @BeforeClass public static void setUpThreadPool(){
    threadPool=new TestThreadPool(getTestClass().getSimpleName());
  }
  @Before public void setUp() throws Exception {
    super.setUp();
    clusterService=createClusterService(threadPool);
    PersistentTasksExecutorRegistry registry=new PersistentTasksExecutorRegistry(clusterService.getSettings(),emptyList()){
      @Override public <Params extends PersistentTaskParams>PersistentTasksExecutor<Params> getPersistentTaskExecutorSafe(      String taskName){
        return new PersistentTasksExecutor<Params>(clusterService.getSettings(),taskName,null){
          @Override protected void nodeOperation(          AllocatedPersistentTask task,          Params params,          PersistentTaskState state){
            logger.debug("Executing task {}",task);
          }
        }
;
      }
    }
;
    persistentTasksClusterService=new PersistentTasksClusterService(clusterService.getSettings(),registry,clusterService);
  }
  @AfterClass public static void tearDownThreadPool() throws Exception {
    terminate(threadPool);
  }
  @After public void tearDown() throws Exception {
    super.tearDown();
    clusterService.close();
  }
  protected ClusterState reassign(  final ClusterState clusterState){
    return persistentTasksClusterService.reassignTasks(clusterState);
  }
  protected void updateSettings(  final Settings settings){
    ClusterSettings clusterSettings=clusterService.getClusterSettings();
    Settings.Builder updated=Settings.builder();
    clusterSettings.updateDynamicSettings(settings,updated,Settings.builder(),getTestClass().getName());
    clusterSettings.applySettings(updated.build());
  }
  protected static ClusterState createClusterStateWithTasks(  final int nbNodes,  final int nbTasks){
    DiscoveryNodes.Builder nodes=DiscoveryNodes.builder();
    for (int i=0; i < nbNodes; i++) {
      nodes.add(new DiscoveryNode("_node_" + i,buildNewFakeTransportAddress(),Version.CURRENT));
    }
    PersistentTasksCustomMetaData.Builder tasks=PersistentTasksCustomMetaData.builder();
    for (int i=0; i < nbTasks; i++) {
      tasks.addTask("_task_" + i,"test",null,new PersistentTasksCustomMetaData.Assignment(null,"initialized"));
    }
    MetaData metaData=MetaData.builder().putCustom(PersistentTasksCustomMetaData.TYPE,tasks.build()).build();
    return ClusterState.builder(ClusterName.DEFAULT).nodes(nodes).metaData(metaData).build();
  }
  /** 
 * Asserts that the given cluster state contains nbTasks tasks that are assigned 
 */
  protected static void assertNbAssignedTasks(  final long nbTasks,  final ClusterState clusterState){
    assertPersistentTasks(nbTasks,clusterState,PersistentTasksCustomMetaData.PersistentTask::isAssigned);
  }
  /** 
 * Asserts that the given cluster state contains nbTasks tasks that are NOT assigned 
 */
  protected static void assertNbUnassignedTasks(  final long nbTasks,  final ClusterState clusterState){
    assertPersistentTasks(nbTasks,clusterState,task -> task.isAssigned() == false);
  }
  /** 
 * Asserts that the cluster state contains nbTasks tasks that verify the given predicate 
 */
  protected static void assertPersistentTasks(  final long nbTasks,  final ClusterState clusterState,  final Predicate<PersistentTasksCustomMetaData.PersistentTask> predicate){
    PersistentTasksCustomMetaData tasks=clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE);
    assertNotNull("Persistent tasks must be not null",tasks);
    assertEquals(nbTasks,tasks.tasks().stream().filter(predicate).count());
  }
}
