public class MockFSDirectoryService extends FsDirectoryService {
  public static final Setting<Double> RANDOM_IO_EXCEPTION_RATE_ON_OPEN_SETTING=Setting.doubleSetting("index.store.mock.random.io_exception_rate_on_open",0.0d,0.0d,Property.IndexScope,Property.NodeScope);
  public static final Setting<Double> RANDOM_IO_EXCEPTION_RATE_SETTING=Setting.doubleSetting("index.store.mock.random.io_exception_rate",0.0d,0.0d,Property.IndexScope,Property.NodeScope);
  public static final Setting<Boolean> RANDOM_PREVENT_DOUBLE_WRITE_SETTING=Setting.boolSetting("index.store.mock.random.prevent_double_write",true,Property.IndexScope,Property.NodeScope);
  public static final Setting<Boolean> RANDOM_NO_DELETE_OPEN_FILE_SETTING=Setting.boolSetting("index.store.mock.random.no_delete_open_file",true,Property.IndexScope,Property.NodeScope);
  public static final Setting<Boolean> CRASH_INDEX_SETTING=Setting.boolSetting("index.store.mock.random.crash_index",true,Property.IndexScope,Property.NodeScope);
  private final FsDirectoryService delegateService;
  private final Random random;
  private final double randomIOExceptionRate;
  private final double randomIOExceptionRateOnOpen;
  private final MockDirectoryWrapper.Throttling throttle;
  private final boolean preventDoubleWrite;
  private final boolean noDeleteOpenFile;
  private final boolean crashIndex;
  @Inject public MockFSDirectoryService(  IndexSettings idxSettings,  IndexStore indexStore,  final ShardPath path){
    super(idxSettings,indexStore,path);
    Settings indexSettings=idxSettings.getSettings();
    final long seed=idxSettings.getValue(ESIntegTestCase.INDEX_TEST_SEED_SETTING);
    this.random=new Random(seed);
    randomIOExceptionRate=RANDOM_IO_EXCEPTION_RATE_SETTING.get(indexSettings);
    randomIOExceptionRateOnOpen=RANDOM_IO_EXCEPTION_RATE_ON_OPEN_SETTING.get(indexSettings);
    preventDoubleWrite=RANDOM_PREVENT_DOUBLE_WRITE_SETTING.get(indexSettings);
    noDeleteOpenFile=RANDOM_NO_DELETE_OPEN_FILE_SETTING.exists(indexSettings) ? RANDOM_NO_DELETE_OPEN_FILE_SETTING.get(indexSettings) : random.nextBoolean();
    random.nextInt(shardId.getId() + 1);
    throttle=MockDirectoryWrapper.Throttling.NEVER;
    crashIndex=CRASH_INDEX_SETTING.get(indexSettings);
    if (logger.isDebugEnabled()) {
      logger.debug("Using MockDirWrapper with seed [{}] throttle: [{}] crashIndex: [{}]",SeedUtils.formatSeed(seed),throttle,crashIndex);
    }
    delegateService=randomDirectoryService(indexStore,path);
  }
  @Override public Directory newDirectory() throws IOException {
    return wrap(delegateService.newDirectory());
  }
  @Override protected synchronized Directory newFSDirectory(  Path location,  LockFactory lockFactory) throws IOException {
    throw new UnsupportedOperationException();
  }
  public static void checkIndex(  Logger logger,  Store store,  ShardId shardId){
    if (store.tryIncRef()) {
      logger.info("start check index");
      try {
        Directory dir=store.directory();
        if (!Lucene.indexExists(dir)) {
          return;
        }
        try {
          BytesStreamOutput os=new BytesStreamOutput();
          PrintStream out=new PrintStream(os,false,StandardCharsets.UTF_8.name());
          CheckIndex.Status status=store.checkIndex(out);
          out.flush();
          if (!status.clean) {
            ESTestCase.checkIndexFailed=true;
            logger.warn("check index [failure] index files={}\n{}",Arrays.toString(dir.listAll()),os.bytes().utf8ToString());
            throw new IOException("index check failure");
          }
 else {
            if (logger.isDebugEnabled()) {
              logger.debug("check index [success]\n{}",os.bytes().utf8ToString());
            }
          }
        }
 catch (        LockObtainFailedException e) {
          ESTestCase.checkIndexFailed=true;
          throw new IllegalStateException("IndexWriter is still open on shard " + shardId,e);
        }
      }
 catch (      Exception e) {
        logger.warn("failed to check index",e);
      }
 finally {
        logger.info("end check index");
        store.decRef();
      }
    }
  }
  private Directory wrap(  Directory dir){
    final ElasticsearchMockDirectoryWrapper w=new ElasticsearchMockDirectoryWrapper(random,dir,this.crashIndex);
    w.setRandomIOExceptionRate(randomIOExceptionRate);
    w.setRandomIOExceptionRateOnOpen(randomIOExceptionRateOnOpen);
    w.setThrottling(throttle);
    w.setCheckIndexOnClose(false);
    w.setAssertNoDeleteOpenFile(false);
    w.setUseSlowOpenClosers(false);
    LuceneTestCase.closeAfterSuite(new CloseableDirectory(w));
    return w;
  }
  private FsDirectoryService randomDirectoryService(  IndexStore indexStore,  ShardPath path){
    final IndexSettings indexSettings=indexStore.getIndexSettings();
    final IndexMetaData build=IndexMetaData.builder(indexSettings.getIndexMetaData()).settings(Settings.builder().put(indexSettings.getIndexMetaData().getSettings()).put(IndexModule.INDEX_STORE_TYPE_SETTING.getKey(),RandomPicks.randomFrom(random,IndexModule.Type.values()).getSettingsKey())).build();
    final IndexSettings newIndexSettings=new IndexSettings(build,indexSettings.getNodeSettings());
    return new FsDirectoryService(newIndexSettings,indexStore,path);
  }
public static final class ElasticsearchMockDirectoryWrapper extends MockDirectoryWrapper {
    private final boolean crash;
    public ElasticsearchMockDirectoryWrapper(    Random random,    Directory delegate,    boolean crash){
      super(random,delegate);
      this.crash=crash;
    }
    @Override public synchronized void crash() throws IOException {
      if (crash) {
        super.crash();
      }
    }
  }
final class CloseableDirectory implements Closeable {
    private final BaseDirectoryWrapper dir;
    private final TestRuleMarkFailure failureMarker;
    CloseableDirectory(    BaseDirectoryWrapper dir){
      this.dir=dir;
      this.failureMarker=ESTestCase.getSuiteFailureMarker();
    }
    @Override public void close(){
      try {
        if (failureMarker.wasSuccessful() && dir.isOpen()) {
          Assert.fail("Directory not closed: " + dir);
        }
      }
  finally {
      }
    }
  }
}
