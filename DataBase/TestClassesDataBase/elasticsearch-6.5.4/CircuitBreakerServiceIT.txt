/** 
 * Integration tests for InternalCircuitBreakerService
 */
@ClusterScope(scope=TEST,numClientNodes=0,maxNumDataNodes=1) public class CircuitBreakerServiceIT extends ESIntegTestCase {
  /** 
 * Reset all breaker settings back to their defaults 
 */
  private void reset(){
    logger.info("--> resetting breaker settings");
    client().admin().indices().prepareClearCache().setFieldDataCache(true).setQueryCache(true).setRequestCache(true).get();
    Settings.Builder resetSettings=Settings.builder();
    Stream.of(HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING,HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING,HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING,HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_OVERHEAD_SETTING,HierarchyCircuitBreakerService.ACCOUNTING_CIRCUIT_BREAKER_LIMIT_SETTING,HierarchyCircuitBreakerService.ACCOUNTING_CIRCUIT_BREAKER_OVERHEAD_SETTING,HierarchyCircuitBreakerService.IN_FLIGHT_REQUESTS_CIRCUIT_BREAKER_LIMIT_SETTING,HierarchyCircuitBreakerService.IN_FLIGHT_REQUESTS_CIRCUIT_BREAKER_OVERHEAD_SETTING,HierarchyCircuitBreakerService.TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING).forEach(s -> resetSettings.putNull(s.getKey()));
    assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(resetSettings));
  }
  @Before public void setup(){
    reset();
  }
  @After public void teardown(){
    reset();
  }
  /** 
 * Returns true if any of the nodes used a noop breaker 
 */
  private boolean noopBreakerUsed(){
    NodesStatsResponse stats=client().admin().cluster().prepareNodesStats().setBreaker(true).get();
    for (    NodeStats nodeStats : stats.getNodes()) {
      if (nodeStats.getBreaker().getStats(CircuitBreaker.REQUEST).getLimit() == NoopCircuitBreaker.LIMIT) {
        return true;
      }
      if (nodeStats.getBreaker().getStats(CircuitBreaker.IN_FLIGHT_REQUESTS).getLimit() == NoopCircuitBreaker.LIMIT) {
        return true;
      }
      if (nodeStats.getBreaker().getStats(CircuitBreaker.FIELDDATA).getLimit() == NoopCircuitBreaker.LIMIT) {
        return true;
      }
    }
    return false;
  }
  public void testMemoryBreaker() throws Exception {
    if (noopBreakerUsed()) {
      logger.info("--> noop breakers used, skipping test");
      return;
    }
    assertAcked(prepareCreate("cb-test",1,Settings.builder().put(SETTING_NUMBER_OF_REPLICAS,between(0,1))).addMapping("type","test","type=text,fielddata=true"));
    final Client client=client();
    int docCount=scaledRandomIntBetween(300,1000);
    List<IndexRequestBuilder> reqs=new ArrayList<>();
    for (long id=0; id < docCount; id++) {
      reqs.add(client.prepareIndex("cb-test","type",Long.toString(id)).setSource("test","value" + id));
    }
    indexRandom(true,false,true,reqs);
    clearFieldData();
    Settings settings=Settings.builder().put(HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(),"100b").put(HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING.getKey(),1.05).build();
    assertAcked(client.admin().cluster().prepareUpdateSettings().setTransientSettings(settings));
    SearchRequestBuilder searchRequest=client.prepareSearch("cb-test").setQuery(matchAllQuery()).addSort("test",SortOrder.DESC);
    String errMsg="Data too large, data for [test] would be";
    assertFailures(searchRequest,RestStatus.INTERNAL_SERVER_ERROR,containsString(errMsg));
    errMsg="which is larger than the limit of [100/100b]";
    assertFailures(searchRequest,RestStatus.INTERNAL_SERVER_ERROR,containsString(errMsg));
    NodesStatsResponse stats=client.admin().cluster().prepareNodesStats().setBreaker(true).get();
    int breaks=0;
    for (    NodeStats stat : stats.getNodes()) {
      CircuitBreakerStats breakerStats=stat.getBreaker().getStats(CircuitBreaker.FIELDDATA);
      breaks+=breakerStats.getTrippedCount();
    }
    assertThat(breaks,greaterThanOrEqualTo(1));
  }
  public void testRamAccountingTermsEnum() throws Exception {
    if (noopBreakerUsed()) {
      logger.info("--> noop breakers used, skipping test");
      return;
    }
    final Client client=client();
    assertAcked(prepareCreate("ramtest").setSource("{\"mappings\": {\"type\": {\"properties\": {\"test\": " + "{\"type\": \"text\",\"fielddata\": true,\"fielddata_frequency_filter\": {\"max\": 10000}}}}}}",XContentType.JSON));
    ensureGreen("ramtest");
    int docCount=scaledRandomIntBetween(300,1000);
    List<IndexRequestBuilder> reqs=new ArrayList<>();
    for (long id=0; id < docCount; id++) {
      reqs.add(client.prepareIndex("ramtest","type",Long.toString(id)).setSource("test","value" + id));
    }
    indexRandom(true,false,true,reqs);
    client.prepareSearch("ramtest").setQuery(matchAllQuery()).addSort("test",SortOrder.DESC).get();
    clearFieldData();
    Settings settings=Settings.builder().put(HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(),"100b").put(HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING.getKey(),1.05).build();
    assertAcked(client.admin().cluster().prepareUpdateSettings().setTransientSettings(settings));
    SearchRequestBuilder searchRequest=client.prepareSearch("ramtest").setQuery(matchAllQuery()).addSort("test",SortOrder.DESC);
    String errMsg="Data too large, data for [test] would be";
    assertFailures(searchRequest,RestStatus.INTERNAL_SERVER_ERROR,containsString(errMsg));
    errMsg="which is larger than the limit of [100/100b]";
    assertFailures(searchRequest,RestStatus.INTERNAL_SERVER_ERROR,containsString(errMsg));
    NodesStatsResponse stats=client.admin().cluster().prepareNodesStats().setBreaker(true).get();
    int breaks=0;
    for (    NodeStats stat : stats.getNodes()) {
      CircuitBreakerStats breakerStats=stat.getBreaker().getStats(CircuitBreaker.FIELDDATA);
      breaks+=breakerStats.getTrippedCount();
    }
    assertThat(breaks,greaterThanOrEqualTo(1));
  }
  public void testRequestBreaker() throws Exception {
    if (noopBreakerUsed()) {
      logger.info("--> noop breakers used, skipping test");
      return;
    }
    assertAcked(prepareCreate("cb-test",1,Settings.builder().put(SETTING_NUMBER_OF_REPLICAS,between(0,1))));
    Client client=client();
    Settings resetSettings=Settings.builder().put(HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(),"10b").build();
    assertAcked(client.admin().cluster().prepareUpdateSettings().setTransientSettings(resetSettings));
    int docCount=scaledRandomIntBetween(300,1000);
    List<IndexRequestBuilder> reqs=new ArrayList<>();
    for (long id=0; id < docCount; id++) {
      reqs.add(client.prepareIndex("cb-test","type",Long.toString(id)).setSource("test",id));
    }
    indexRandom(true,reqs);
    try {
      client.prepareSearch("cb-test").setQuery(matchAllQuery()).addAggregation(cardinality("card").field("test")).get();
      fail("aggregation should have tripped the breaker");
    }
 catch (    Exception e) {
      String errMsg="CircuitBreakingException[[request] Data too large";
      assertThat("Exception: [" + e.toString() + "] should contain a CircuitBreakingException",e.toString(),containsString(errMsg));
      errMsg="which is larger than the limit of [10/10b]]";
      assertThat("Exception: [" + e.toString() + "] should contain a CircuitBreakingException",e.toString(),containsString(errMsg));
    }
  }
  public void testBucketBreaker() throws Exception {
    if (noopBreakerUsed()) {
      logger.info("--> noop breakers used, skipping test");
      return;
    }
    assertAcked(prepareCreate("cb-test",1,Settings.builder().put(SETTING_NUMBER_OF_REPLICAS,between(0,1))));
    Client client=client();
    Settings resetSettings=Settings.builder().put(HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(),"100b").build();
    assertAcked(client.admin().cluster().prepareUpdateSettings().setTransientSettings(resetSettings));
    int docCount=scaledRandomIntBetween(100,1000);
    List<IndexRequestBuilder> reqs=new ArrayList<>();
    for (long id=0; id < docCount; id++) {
      reqs.add(client.prepareIndex("cb-test","type",Long.toString(id)).setSource("test",id));
    }
    indexRandom(true,reqs);
    try {
      SearchResponse resp=client.prepareSearch("cb-test").setQuery(matchAllQuery()).addAggregation(terms("my_terms").field("test")).get();
      assertTrue("there should be shard failures",resp.getFailedShards() > 0);
      fail("aggregation should have tripped the breaker");
    }
 catch (    Exception e) {
      String errMsg="CircuitBreakingException[[request] Data too large, data for [<agg [my_terms]>] would be";
      assertThat("Exception: [" + e.toString() + "] should contain a CircuitBreakingException",e.toString(),containsString(errMsg));
      errMsg="which is larger than the limit of [100/100b]]";
      assertThat("Exception: [" + e.toString() + "] should contain a CircuitBreakingException",e.toString(),containsString(errMsg));
    }
  }
  /** 
 * Issues a cache clear and waits 30 seconds for the field data breaker to be cleared 
 */
  public void clearFieldData() throws Exception {
    client().admin().indices().prepareClearCache().setFieldDataCache(true).execute().actionGet();
    assertBusy(() -> {
      NodesStatsResponse resp=client().admin().cluster().prepareNodesStats().clear().setBreaker(true).get(new TimeValue(15,TimeUnit.SECONDS));
      for (      NodeStats nStats : resp.getNodes()) {
        assertThat("fielddata breaker never reset back to 0",nStats.getBreaker().getStats(CircuitBreaker.FIELDDATA).getEstimated(),equalTo(0L));
      }
    }
,30,TimeUnit.SECONDS);
  }
  public void testCustomCircuitBreakerRegistration() throws Exception {
    Iterable<CircuitBreakerService> serviceIter=internalCluster().getInstances(CircuitBreakerService.class);
    final String breakerName="customBreaker";
    BreakerSettings breakerSettings=new BreakerSettings(breakerName,8,1.03);
    CircuitBreaker breaker=null;
    for (    CircuitBreakerService s : serviceIter) {
      s.registerBreaker(breakerSettings);
      breaker=s.getBreaker(breakerSettings.getName());
    }
    if (breaker != null) {
      try {
        breaker.addEstimateBytesAndMaybeBreak(16,"test");
      }
 catch (      CircuitBreakingException e) {
      }
    }
    NodesStatsResponse stats=client().admin().cluster().prepareNodesStats().clear().setBreaker(true).get();
    int breaks=0;
    for (    NodeStats stat : stats.getNodes()) {
      CircuitBreakerStats breakerStats=stat.getBreaker().getStats(breakerName);
      breaks+=breakerStats.getTrippedCount();
    }
    assertThat(breaks,greaterThanOrEqualTo(1));
  }
  public void testCanResetUnreasonableSettings(){
    if (noopBreakerUsed()) {
      logger.info("--> noop breakers used, skipping test");
      return;
    }
    Settings insane=Settings.builder().put(HierarchyCircuitBreakerService.IN_FLIGHT_REQUESTS_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(),"5b").build();
    client().admin().cluster().prepareUpdateSettings().setTransientSettings(insane).get();
    reset();
    assertThat(client().admin().cluster().prepareState().get().getState().metaData().transientSettings().get(HierarchyCircuitBreakerService.TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING.getKey()),nullValue());
  }
  public void testLimitsRequestSize() throws Exception {
    ByteSizeValue inFlightRequestsLimit=new ByteSizeValue(8,ByteSizeUnit.KB);
    if (noopBreakerUsed()) {
      logger.info("--> noop breakers used, skipping test");
      return;
    }
    internalCluster().ensureAtLeastNumDataNodes(2);
    NodesStatsResponse nodeStats=client().admin().cluster().prepareNodesStats().get();
    List<NodeStats> dataNodeStats=new ArrayList<>();
    for (    NodeStats stat : nodeStats.getNodes()) {
      if (stat.getNode().isDataNode()) {
        dataNodeStats.add(stat);
      }
    }
    assertThat(dataNodeStats.size(),greaterThanOrEqualTo(2));
    Collections.shuffle(dataNodeStats,random());
    NodeStats targetNode=dataNodeStats.get(0);
    NodeStats sourceNode=dataNodeStats.get(1);
    assertAcked(prepareCreate("index").setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,0).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,1).put("index.routing.allocation.include._name",targetNode.getNode().getName()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(),EnableAllocationDecider.Rebalance.NONE)));
    Client client=client(sourceNode.getNode().getName());
    int numRequests=inFlightRequestsLimit.bytesAsInt();
    BulkRequest bulkRequest=new BulkRequest();
    for (int i=0; i < numRequests; i++) {
      IndexRequest indexRequest=new IndexRequest("index","type",Integer.toString(i));
      indexRequest.source(Requests.INDEX_CONTENT_TYPE,"field","value","num",i);
      bulkRequest.add(indexRequest);
    }
    Settings limitSettings=Settings.builder().put(HierarchyCircuitBreakerService.IN_FLIGHT_REQUESTS_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(),inFlightRequestsLimit).build();
    assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(limitSettings));
    try {
      BulkResponse response=client.bulk(bulkRequest).actionGet();
      if (!response.hasFailures()) {
        fail("Should have thrown CircuitBreakingException");
      }
 else {
        for (        BulkItemResponse bulkItemResponse : response) {
          Throwable cause=ExceptionsHelper.unwrapCause(bulkItemResponse.getFailure().getCause());
          assertThat(cause,instanceOf(CircuitBreakingException.class));
          assertEquals(((CircuitBreakingException)cause).getByteLimit(),inFlightRequestsLimit.getBytes());
        }
      }
    }
 catch (    CircuitBreakingException ex) {
      assertEquals(ex.getByteLimit(),inFlightRequestsLimit.getBytes());
    }
  }
}
