public class MonitoringServiceTests extends ESTestCase {
  private TestThreadPool threadPool;
  private MonitoringService monitoringService;
  private XPackLicenseState licenseState=mock(XPackLicenseState.class);
  private ClusterService clusterService;
  private ClusterSettings clusterSettings;
  @Before public void setUp() throws Exception {
    super.setUp();
    threadPool=new TestThreadPool(getTestName());
    clusterService=mock(ClusterService.class);
    Settings settings=Settings.builder().put("path.home",createTempDir()).build();
    final Monitoring monitoring=new Monitoring(settings){
      @Override protected XPackLicenseState getLicenseState(){
        return licenseState;
      }
    }
;
    clusterSettings=new ClusterSettings(Settings.EMPTY,new HashSet<>(monitoring.getSettings()));
    when(clusterService.getClusterSettings()).thenReturn(clusterSettings);
    when(clusterService.state()).thenReturn(mock(ClusterState.class));
  }
  @After public void terminate() throws Exception {
    if (monitoringService != null) {
      monitoringService.close();
    }
    terminate(threadPool);
  }
  public void testIsMonitoringActive() throws Exception {
    monitoringService=new MonitoringService(Settings.EMPTY,clusterService,threadPool,emptySet(),new CountingExporter());
    monitoringService.start();
    assertBusy(() -> assertTrue(monitoringService.isStarted()));
    assertFalse(monitoringService.isMonitoringActive());
    monitoringService.setMonitoringActive(true);
    assertTrue(monitoringService.isMonitoringActive());
    monitoringService.setInterval(TimeValue.MINUS_ONE);
    assertFalse(monitoringService.isMonitoringActive());
    monitoringService.setInterval(TimeValue.timeValueSeconds(10));
    assertTrue(monitoringService.isMonitoringActive());
    monitoringService.stop();
    assertBusy(() -> assertFalse(monitoringService.isStarted()));
    assertFalse(monitoringService.isMonitoringActive());
    monitoringService.start();
    assertBusy(() -> assertTrue(monitoringService.isStarted()));
    assertTrue(monitoringService.isMonitoringActive());
    monitoringService.close();
    assertBusy(() -> assertFalse(monitoringService.isStarted()));
    assertFalse(monitoringService.isMonitoringActive());
  }
  public void testInterval() throws Exception {
    final Settings settings=Settings.builder().put(MonitoringService.ENABLED.getKey(),true).put(MonitoringService.INTERVAL.getKey(),TimeValue.MINUS_ONE).build();
    CountingExporter exporter=new CountingExporter();
    monitoringService=new MonitoringService(settings,clusterService,threadPool,emptySet(),exporter);
    assertWarnings("Setting [xpack.monitoring.collection.interval] to [-1] has been deprecated as the way to disable collection. Use " + "[xpack.monitoring.collection.enabled] set to [false] instead.");
    monitoringService.start();
    assertBusy(() -> assertTrue(monitoringService.isStarted()));
    assertFalse("interval -1 does not start the monitoring execution",monitoringService.isMonitoringActive());
    assertEquals(0,exporter.getExportsCount());
    monitoringService.setInterval(TimeValue.timeValueSeconds(1));
    assertTrue(monitoringService.isMonitoringActive());
    assertBusy(() -> assertThat(exporter.getExportsCount(),greaterThan(0)));
    monitoringService.setInterval(TimeValue.timeValueMillis(100));
    assertFalse(monitoringService.isMonitoringActive());
    monitoringService.setInterval(TimeValue.MINUS_ONE);
    assertFalse(monitoringService.isMonitoringActive());
  }
  public void testSkipExecution() throws Exception {
    final CountDownLatch latch=new CountDownLatch(1);
    final BlockingExporter exporter=new BlockingExporter(latch);
    final Settings settings=Settings.builder().put(MonitoringService.ENABLED.getKey(),true).put(MonitoringService.INTERVAL.getKey(),MonitoringService.MIN_INTERVAL).build();
    monitoringService=new MonitoringService(settings,clusterService,threadPool,emptySet(),exporter);
    monitoringService.start();
    assertBusy(() -> assertTrue(monitoringService.isStarted()));
    assertBusy(() -> assertThat(exporter.getExportsCount(),equalTo(1)));
    monitoringService.cancelExecution();
    latch.countDown();
    assertThat(exporter.getExportsCount(),equalTo(1));
  }
class CountingExporter extends Exporters {
    private final AtomicInteger exports=new AtomicInteger(0);
    CountingExporter(){
      super(Settings.EMPTY,Collections.emptyMap(),clusterService,licenseState,threadPool.getThreadContext());
    }
    @Override public void export(    Collection<MonitoringDoc> docs,    ActionListener<Void> listener){
      exports.incrementAndGet();
      listener.onResponse(null);
    }
    int getExportsCount(){
      return exports.get();
    }
    @Override protected void doStart(){
    }
    @Override protected void doStop(){
    }
    @Override protected void doClose(){
    }
  }
class BlockingExporter extends CountingExporter {
    private final CountDownLatch latch;
    BlockingExporter(    CountDownLatch latch){
      super();
      this.latch=latch;
    }
    @Override public void export(    Collection<MonitoringDoc> docs,    ActionListener<Void> listener){
      super.export(docs,ActionListener.wrap(r -> {
        try {
          latch.await();
          listener.onResponse(null);
        }
 catch (        InterruptedException e) {
          listener.onFailure(new ExportException("BlockingExporter failed",e));
        }
      }
,listener::onFailure));
    }
    @Override protected void doStart(){
    }
    @Override protected void doStop(){
    }
    @Override protected void doClose(){
    }
  }
}
