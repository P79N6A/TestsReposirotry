public class CleanerServiceTests extends ESTestCase {
  @Rule public ExpectedException expectedException=ExpectedException.none();
  private final XPackLicenseState licenseState=mock(XPackLicenseState.class);
  private ClusterSettings clusterSettings;
  private ThreadPool threadPool;
  @Before public void start(){
    clusterSettings=new ClusterSettings(Settings.EMPTY,Collections.singleton(MonitoringField.HISTORY_DURATION));
    threadPool=new TestThreadPool("CleanerServiceTests");
  }
  @After public void stop() throws InterruptedException {
    terminate(threadPool);
  }
  public void testConstructorWithInvalidRetention(){
    expectedException.expect(IllegalArgumentException.class);
    TimeValue expected=TimeValue.timeValueHours(1);
    Settings settings=Settings.builder().put(MonitoringField.HISTORY_DURATION.getKey(),expected.getStringRep()).build();
    new CleanerService(settings,clusterSettings,threadPool,licenseState);
  }
  public void testGetRetentionWithSettingWithUpdatesAllowed(){
    TimeValue expected=TimeValue.timeValueHours(25);
    Settings settings=Settings.builder().put(MonitoringField.HISTORY_DURATION.getKey(),expected.getStringRep()).build();
    when(licenseState.isUpdateRetentionAllowed()).thenReturn(true);
    assertEquals(expected,new CleanerService(settings,clusterSettings,threadPool,licenseState).getRetention());
    verify(licenseState).isUpdateRetentionAllowed();
  }
  public void testGetRetentionDefaultValueWithNoSettings(){
    when(licenseState.isUpdateRetentionAllowed()).thenReturn(true);
    assertEquals(MonitoringField.HISTORY_DURATION.get(Settings.EMPTY),new CleanerService(Settings.EMPTY,clusterSettings,threadPool,licenseState).getRetention());
    verify(licenseState).isUpdateRetentionAllowed();
  }
  public void testGetRetentionDefaultValueWithSettingsButUpdatesNotAllowed(){
    TimeValue notExpected=TimeValue.timeValueHours(25);
    Settings settings=Settings.builder().put(MonitoringField.HISTORY_DURATION.getKey(),notExpected.getStringRep()).build();
    when(licenseState.isUpdateRetentionAllowed()).thenReturn(false);
    assertEquals(MonitoringField.HISTORY_DURATION.get(Settings.EMPTY),new CleanerService(settings,clusterSettings,threadPool,licenseState).getRetention());
    verify(licenseState).isUpdateRetentionAllowed();
  }
  public void testSetGlobalRetention(){
    TimeValue expected=TimeValue.timeValueHours(2);
    when(licenseState.isUpdateRetentionAllowed()).thenReturn(true);
    CleanerService service=new CleanerService(Settings.EMPTY,clusterSettings,threadPool,licenseState);
    service.setGlobalRetention(expected);
    assertEquals(expected,service.getRetention());
    verify(licenseState,times(2)).isUpdateRetentionAllowed();
  }
  public void testSetGlobalRetentionAppliesEvenIfLicenseDisallows(){
    TimeValue expected=TimeValue.timeValueHours(2);
    when(licenseState.isUpdateRetentionAllowed()).thenReturn(false).thenReturn(true);
    CleanerService service=new CleanerService(Settings.EMPTY,clusterSettings,threadPool,licenseState);
    service.setGlobalRetention(expected);
    assertEquals(expected,service.getRetention());
    verify(licenseState,times(2)).isUpdateRetentionAllowed();
  }
  public void testNextExecutionDelay(){
    CleanerService.ExecutionScheduler scheduler=new CleanerService.DefaultExecutionScheduler();
    DateTime now=new DateTime(2015,1,1,0,0,DateTimeZone.UTC);
    assertThat(scheduler.nextExecutionDelay(now).millis(),equalTo(TimeValue.timeValueHours(1).millis()));
    now=new DateTime(2015,1,1,1,0,DateTimeZone.UTC);
    assertThat(scheduler.nextExecutionDelay(now).millis(),equalTo(TimeValue.timeValueHours(24).millis()));
    now=new DateTime(2015,1,1,0,59,DateTimeZone.UTC);
    assertThat(scheduler.nextExecutionDelay(now).millis(),equalTo(TimeValue.timeValueMinutes(1).millis()));
    now=new DateTime(2015,1,1,23,59,DateTimeZone.UTC);
    assertThat(scheduler.nextExecutionDelay(now).millis(),equalTo(TimeValue.timeValueMinutes(60 + 1).millis()));
    now=new DateTime(2015,1,1,12,34,56);
    assertThat(scheduler.nextExecutionDelay(now).millis(),equalTo(new DateTime(2015,1,2,1,0,0).getMillis() - now.getMillis()));
  }
  public void testExecution() throws InterruptedException {
    final int nbExecutions=randomIntBetween(1,3);
    CountDownLatch latch=new CountDownLatch(nbExecutions);
    logger.debug("--> creates a cleaner service that cleans every second");
    XPackLicenseState licenseState=mock(XPackLicenseState.class);
    when(licenseState.isMonitoringAllowed()).thenReturn(true);
    CleanerService service=new CleanerService(Settings.EMPTY,clusterSettings,licenseState,threadPool,new TestExecutionScheduler(1_000));
    logger.debug("--> registers cleaning listener");
    TestListener listener=new TestListener(latch);
    service.add(listener);
    try {
      logger.debug("--> starts cleaning service");
      service.start();
      logger.debug("--> waits for listener to be executed");
      if (!latch.await(10,TimeUnit.SECONDS)) {
        fail("waiting too long for test to complete. Expected listener was not executed");
      }
    }
  finally {
      service.stop();
    }
    assertThat(latch.getCount(),equalTo(0L));
  }
class TestListener implements CleanerService.Listener {
    final CountDownLatch latch;
    TestListener(    CountDownLatch latch){
      this.latch=latch;
    }
    @Override public void onCleanUpIndices(    TimeValue retention){
      latch.countDown();
    }
  }
class TestExecutionScheduler implements CleanerService.ExecutionScheduler {
    final long offset;
    TestExecutionScheduler(    long offset){
      this.offset=offset;
    }
    @Override public TimeValue nextExecutionDelay(    DateTime now){
      return TimeValue.timeValueMillis(offset);
    }
  }
}
