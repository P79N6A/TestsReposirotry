public class GeoFilterIT extends ESIntegTestCase {
  @Override protected boolean forbidPrivateIndexSettings(){
    return false;
  }
  private static boolean intersectSupport;
  private static boolean disjointSupport;
  private static boolean withinSupport;
  @BeforeClass public static void createNodes() throws Exception {
    intersectSupport=testRelationSupport(SpatialOperation.Intersects);
    disjointSupport=testRelationSupport(SpatialOperation.IsDisjointTo);
    withinSupport=testRelationSupport(SpatialOperation.IsWithin);
  }
  private static byte[] unZipData(  String path) throws IOException {
    InputStream is=Streams.class.getResourceAsStream(path);
    if (is == null) {
      throw new FileNotFoundException("Resource [" + path + "] not found in classpath");
    }
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    GZIPInputStream in=new GZIPInputStream(is);
    Streams.copy(in,out);
    is.close();
    out.close();
    return out.toByteArray();
  }
  public void testShapeBuilders(){
    try {
      new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(10,10).coordinate(-10,10).coordinate(10,-10).close()).build();
      fail("Self intersection not detected");
    }
 catch (    InvalidShapeException e) {
    }
    new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(-10,10).coordinate(10,10).coordinate(10,-10).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-5,-5).coordinate(-5,5).coordinate(5,5).coordinate(5,-5).close())).build();
    try {
      new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(-10,10).coordinate(10,10).coordinate(10,-10).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-5,-5).coordinate(-5,11).coordinate(5,11).coordinate(5,-5).close())).build();
      fail("Self intersection not detected");
    }
 catch (    InvalidShapeException e) {
    }
    try {
      new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(-10,10).coordinate(10,10).coordinate(10,-10).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-5,-5).coordinate(-5,5).coordinate(5,5).coordinate(5,-5).close())).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-5,-6).coordinate(5,-6).coordinate(5,-4).coordinate(-5,-4).close())).build();
      fail("Intersection of holes not detected");
    }
 catch (    InvalidShapeException e) {
    }
    try {
      new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(-10,10).coordinate(-5,10).coordinate(-5,-5).coordinate(-5,20).coordinate(10,20).coordinate(10,-10).close()).build();
      fail("Self intersection not detected");
    }
 catch (    InvalidShapeException e) {
    }
    new MultiPolygonBuilder().polygon(new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(-10,10).coordinate(10,10).coordinate(10,-10).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-5,-5).coordinate(-5,5).coordinate(5,5).coordinate(5,-5).close()))).polygon(new PolygonBuilder(new CoordinatesBuilder().coordinate(-4,-4).coordinate(-4,4).coordinate(4,4).coordinate(4,-4).close())).build();
  }
  public void testShapeRelations() throws Exception {
    assertTrue("Intersect relation is not supported",intersectSupport);
    assertTrue("Disjoint relation is not supported",disjointSupport);
    assertTrue("within relation is not supported",withinSupport);
    String mapping=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("polygon").startObject("properties").startObject("area").field("type","geo_shape").field("tree","geohash").endObject().endObject().endObject().endObject());
    CreateIndexRequestBuilder mappingRequest=client().admin().indices().prepareCreate("shapes").addMapping("polygon",mapping,XContentType.JSON);
    mappingRequest.execute().actionGet();
    client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();
    MultiPolygonBuilder polygon=new MultiPolygonBuilder().polygon(new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(-10,10).coordinate(10,10).coordinate(10,-10).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-5,-5).coordinate(-5,5).coordinate(5,5).coordinate(5,-5).close()))).polygon(new PolygonBuilder(new CoordinatesBuilder().coordinate(-4,-4).coordinate(-4,4).coordinate(4,4).coordinate(4,-4).close()));
    BytesReference data=BytesReference.bytes(jsonBuilder().startObject().field("area",polygon).endObject());
    client().prepareIndex("shapes","polygon","1").setSource(data,XContentType.JSON).execute().actionGet();
    client().admin().indices().prepareRefresh().execute().actionGet();
    SearchResponse result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(3,3))).execute().actionGet();
    assertHitCount(result,1);
    assertFirstHit(result,hasId("1"));
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(4.5,4.5))).execute().actionGet();
    assertHitCount(result,0);
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(10.0,5.0))).execute().actionGet();
    assertHitCount(result,1);
    assertFirstHit(result,hasId("1"));
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(5.0,2.0))).execute().actionGet();
    assertHitCount(result,1);
    assertFirstHit(result,hasId("1"));
    if (disjointSupport) {
      result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoDisjointQuery("area",new PointBuilder(3,3))).execute().actionGet();
      assertHitCount(result,0);
      result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoDisjointQuery("area",new PointBuilder(4.5,4.5))).execute().actionGet();
      assertHitCount(result,1);
      assertFirstHit(result,hasId("1"));
    }
    PolygonBuilder inverse=new PolygonBuilder(new CoordinatesBuilder().coordinate(-5,-5).coordinate(-5,5).coordinate(5,5).coordinate(5,-5).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-4,-4).coordinate(-4,4).coordinate(4,4).coordinate(4,-4).close()));
    data=BytesReference.bytes(jsonBuilder().startObject().field("area",inverse).endObject());
    client().prepareIndex("shapes","polygon","2").setSource(data,XContentType.JSON).execute().actionGet();
    client().admin().indices().prepareRefresh().execute().actionGet();
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(4.5,4.5))).execute().actionGet();
    assertHitCount(result,1);
    assertFirstHit(result,hasId("2"));
    PolygonBuilder builder=new PolygonBuilder(new CoordinatesBuilder().coordinate(-10,-10).coordinate(-10,10).coordinate(10,10).coordinate(10,-10).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(-5,-5).coordinate(-5,5).coordinate(10,5).coordinate(10,-5).close()));
    if (withinSupport) {
      builder=new PolygonBuilder(new CoordinatesBuilder().coordinate(-30,-30).coordinate(-30,30).coordinate(30,30).coordinate(30,-30).close());
      result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoWithinQuery("area",builder)).execute().actionGet();
      assertHitCount(result,2);
    }
    builder=new PolygonBuilder(new CoordinatesBuilder().coordinate(170,-10).coordinate(190,-10).coordinate(190,10).coordinate(170,10).close());
    data=BytesReference.bytes(jsonBuilder().startObject().field("area",builder).endObject());
    client().prepareIndex("shapes","polygon","1").setSource(data,XContentType.JSON).execute().actionGet();
    client().admin().indices().prepareRefresh().execute().actionGet();
    builder=new PolygonBuilder(new CoordinatesBuilder().coordinate(170,-10).coordinate(190,-10).coordinate(190,10).coordinate(170,10).close()).hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(175,-5).coordinate(185,-5).coordinate(185,5).coordinate(175,5).close()));
    data=BytesReference.bytes(jsonBuilder().startObject().field("area",builder).endObject());
    client().prepareIndex("shapes","polygon","1").setSource(data,XContentType.JSON).execute().actionGet();
    client().admin().indices().prepareRefresh().execute().actionGet();
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(174,-4))).execute().actionGet();
    assertHitCount(result,1);
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(-174,-4))).execute().actionGet();
    assertHitCount(result,1);
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(180,-4))).execute().actionGet();
    assertHitCount(result,0);
    result=client().prepareSearch().setQuery(matchAllQuery()).setPostFilter(QueryBuilders.geoIntersectionQuery("area",new PointBuilder(180,-6))).execute().actionGet();
    assertHitCount(result,1);
  }
  public void testBulk() throws Exception {
    byte[] bulkAction=unZipData("/org/elasticsearch/search/geo/gzippedmap.gz");
    Version version=VersionUtils.randomVersionBetween(random(),Version.V_5_0_0,Version.CURRENT);
    Settings settings=Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED,version).build();
    XContentBuilder xContentBuilder=XContentFactory.jsonBuilder().startObject().startObject("country").startObject("properties").startObject("pin").field("type","geo_point");
    xContentBuilder.field("store",true).endObject().startObject("location").field("type","geo_shape").endObject().endObject().endObject().endObject();
    client().admin().indices().prepareCreate("countries").setSettings(settings).addMapping("country",xContentBuilder).execute().actionGet();
    BulkResponse bulk=client().prepareBulk().add(bulkAction,0,bulkAction.length,null,null,xContentBuilder.contentType()).get();
    for (    BulkItemResponse item : bulk.getItems()) {
      assertFalse("unable to index data",item.isFailed());
    }
    client().admin().indices().prepareRefresh().execute().actionGet();
    String key="DE";
    SearchResponse searchResponse=client().prepareSearch().setQuery(matchQuery("_id",key)).execute().actionGet();
    assertHitCount(searchResponse,1);
    for (    SearchHit hit : searchResponse.getHits()) {
      assertThat(hit.getId(),equalTo(key));
    }
    SearchResponse world=client().prepareSearch().addStoredField("pin").setQuery(geoBoundingBoxQuery("pin").setCorners(90,-179.99999,-90,179.99999)).execute().actionGet();
    assertHitCount(world,53);
    SearchResponse distance=client().prepareSearch().addStoredField("pin").setQuery(geoDistanceQuery("pin").distance("425km").point(51.11,9.851)).execute().actionGet();
    assertHitCount(distance,5);
    GeoPoint point=new GeoPoint();
    for (    SearchHit hit : distance.getHits()) {
      String name=hit.getId();
      point.resetFromString(hit.getFields().get("pin").getValue());
      double dist=distance(point.getLat(),point.getLon(),51.11,9.851);
      assertThat("distance to '" + name + "'",dist,lessThanOrEqualTo(425000d));
      assertThat(name,anyOf(equalTo("CZ"),equalTo("DE"),equalTo("BE"),equalTo("NL"),equalTo("LU")));
      if (key.equals(name)) {
        assertThat(dist,closeTo(0d,0.1d));
      }
    }
  }
  public void testNeighbors(){
    assertThat(GeoHashUtils.addNeighbors("7",new ArrayList<String>()),containsInAnyOrder("4","5","6","d","e","h","k","s"));
    assertThat(GeoHashUtils.addNeighbors("0",new ArrayList<String>()),containsInAnyOrder("1","2","3","p","r"));
    assertThat(GeoHashUtils.addNeighbors("b",new ArrayList<String>()),containsInAnyOrder("8","9","c","x","z"));
    assertThat(GeoHashUtils.addNeighbors("p",new ArrayList<String>()),containsInAnyOrder("n","q","r","0","2"));
    assertThat(GeoHashUtils.addNeighbors("z",new ArrayList<String>()),containsInAnyOrder("8","b","w","x","y"));
    assertThat(GeoHashUtils.addNeighbors("2",new ArrayList<String>()),containsInAnyOrder("0","1","3","8","9","p","r","x"));
    assertThat(GeoHashUtils.addNeighbors("r",new ArrayList<String>()),containsInAnyOrder("0","2","8","n","p","q","w","x"));
    assertThat(GeoHashUtils.addNeighbors("dk",new ArrayList<String>()),containsInAnyOrder("d5","d7","de","dh","dj","dm","ds","dt"));
    assertThat(GeoHashUtils.addNeighbors("d5",new ArrayList<String>()),containsInAnyOrder("d4","d6","d7","dh","dk","9f","9g","9u"));
    assertThat(GeoHashUtils.addNeighbors("d0",new ArrayList<String>()),containsInAnyOrder("d1","d2","d3","9b","9c","6p","6r","3z"));
  }
  public static double distance(  double lat1,  double lon1,  double lat2,  double lon2){
    return GeoUtils.EARTH_SEMI_MAJOR_AXIS * DistanceUtils.distHaversineRAD(DistanceUtils.toRadians(lat1),DistanceUtils.toRadians(lon1),DistanceUtils.toRadians(lat2),DistanceUtils.toRadians(lon2));
  }
  protected static boolean testRelationSupport(  SpatialOperation relation){
    if (relation == SpatialOperation.IsDisjointTo) {
      relation=SpatialOperation.Intersects;
    }
    try {
      GeohashPrefixTree tree=new GeohashPrefixTree(SpatialContext.GEO,3);
      RecursivePrefixTreeStrategy strategy=new RecursivePrefixTreeStrategy(tree,"area");
      Shape shape=SpatialContext.GEO.makePoint(0,0);
      SpatialArgs args=new SpatialArgs(relation,shape);
      strategy.makeQuery(args);
      return true;
    }
 catch (    UnsupportedSpatialOperation e) {
      final SpatialOperation finalRelation=relation;
      LogManager.getLogger(GeoFilterIT.class).info(() -> new ParameterizedMessage("Unsupported spatial operation {}",finalRelation),e);
      return false;
    }
  }
  protected static String randomhash(  int length){
    return randomhash(random(),length);
  }
  protected static String randomhash(  Random random){
    return randomhash(random,2 + random.nextInt(10));
  }
  protected static String randomhash(){
    return randomhash(random());
  }
  protected static String randomhash(  Random random,  int length){
    final char[] BASE_32={'0','1','2','3','4','5','6','7','8','9','b','c','d','e','f','g','h','j','k','m','n','p','q','r','s','t','u','v','w','x','y','z'};
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < length; i++) {
      sb.append(BASE_32[random.nextInt(BASE_32.length)]);
    }
    return sb.toString();
  }
}
