public class AutodetectResultProcessorIT extends MlSingleNodeTestCase {
  private static final String JOB_ID="autodetect-result-processor-it-job";
  private JobResultsProvider jobResultsProvider;
  private List<ModelSnapshot> capturedUpdateModelSnapshotOnJobRequests;
  private AutoDetectResultProcessor resultProcessor;
  private Renormalizer renormalizer;
  @Override protected Settings nodeSettings(){
    Settings.Builder newSettings=Settings.builder();
    newSettings.put(super.nodeSettings());
    newSettings.put(XPackSettings.SECURITY_ENABLED.getKey(),false);
    newSettings.put(XPackSettings.MONITORING_ENABLED.getKey(),false);
    newSettings.put(XPackSettings.WATCHER_ENABLED.getKey(),false);
    return newSettings.build();
  }
  @Override protected Collection<Class<? extends Plugin>> getPlugins(){
    return pluginList(LocalStateMachineLearning.class,ReindexPlugin.class);
  }
  @Before public void createComponents() throws Exception {
    Settings.Builder builder=Settings.builder().put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(),TimeValue.timeValueSeconds(1));
    Auditor auditor=new Auditor(client(),"test_node");
    jobResultsProvider=new JobResultsProvider(client(),builder.build());
    renormalizer=mock(Renormalizer.class);
    capturedUpdateModelSnapshotOnJobRequests=new ArrayList<>();
    resultProcessor=new AutoDetectResultProcessor(client(),auditor,JOB_ID,renormalizer,new JobResultsPersister(nodeSettings(),client()),jobResultsProvider,new ModelSizeStats.Builder(JOB_ID).build(),false){
      @Override protected void updateModelSnapshotIdOnJob(      ModelSnapshot modelSnapshot){
        capturedUpdateModelSnapshotOnJobRequests.add(modelSnapshot);
      }
    }
;
    putIndexTemplates();
    putJob();
  }
  @After public void deleteJob() throws Exception {
    DeleteJobAction.Request request=new DeleteJobAction.Request(JOB_ID);
    AcknowledgedResponse response=client().execute(DeleteJobAction.INSTANCE,request).actionGet();
    assertTrue(response.isAcknowledged());
  }
  public void testProcessResults() throws Exception {
    ResultsBuilder builder=new ResultsBuilder();
    Bucket bucket=createBucket(false);
    builder.addBucket(bucket);
    List<AnomalyRecord> records=createRecords(false);
    builder.addRecords(records);
    List<Influencer> influencers=createInfluencers(false);
    builder.addInfluencers(influencers);
    CategoryDefinition categoryDefinition=createCategoryDefinition();
    builder.addCategoryDefinition(categoryDefinition);
    ModelPlot modelPlot=createmodelPlot();
    builder.addmodelPlot(modelPlot);
    ModelSizeStats modelSizeStats=createModelSizeStats();
    builder.addModelSizeStats(modelSizeStats);
    ModelSnapshot modelSnapshot=createModelSnapshot();
    builder.addModelSnapshot(modelSnapshot);
    Quantiles quantiles=createQuantiles();
    builder.addQuantiles(quantiles);
    resultProcessor.process(builder.buildTestProcess());
    resultProcessor.awaitCompletion();
    BucketsQueryBuilder bucketsQuery=new BucketsQueryBuilder().includeInterim(true);
    QueryPage<Bucket> persistedBucket=getBucketQueryPage(bucketsQuery);
    assertEquals(1,persistedBucket.count());
    bucket.setRecords(Collections.emptyList());
    assertEquals(bucket,persistedBucket.results().get(0));
    QueryPage<AnomalyRecord> persistedRecords=getRecords(new RecordsQueryBuilder());
    assertResultsAreSame(records,persistedRecords);
    QueryPage<Influencer> persistedInfluencers=getInfluencers();
    assertResultsAreSame(influencers,persistedInfluencers);
    QueryPage<CategoryDefinition> persistedDefinition=getCategoryDefinition(categoryDefinition.getCategoryId());
    assertEquals(1,persistedDefinition.count());
    assertEquals(categoryDefinition,persistedDefinition.results().get(0));
    QueryPage<ModelPlot> persistedModelPlot=jobResultsProvider.modelPlot(JOB_ID,0,100);
    assertEquals(1,persistedModelPlot.count());
    assertEquals(modelPlot,persistedModelPlot.results().get(0));
    ModelSizeStats persistedModelSizeStats=getModelSizeStats();
    assertEquals(modelSizeStats,persistedModelSizeStats);
    QueryPage<ModelSnapshot> persistedModelSnapshot=getModelSnapshots();
    assertEquals(1,persistedModelSnapshot.count());
    assertEquals(modelSnapshot,persistedModelSnapshot.results().get(0));
    assertEquals(Collections.singletonList(modelSnapshot),capturedUpdateModelSnapshotOnJobRequests);
    Optional<Quantiles> persistedQuantiles=getQuantiles();
    assertTrue(persistedQuantiles.isPresent());
    assertEquals(quantiles,persistedQuantiles.get());
  }
  public void testParseQuantiles_GivenRenormalizationIsEnabled() throws Exception {
    when(renormalizer.isEnabled()).thenReturn(true);
    ResultsBuilder builder=new ResultsBuilder();
    Quantiles quantiles=createQuantiles();
    builder.addQuantiles(quantiles);
    resultProcessor.process(builder.buildTestProcess());
    resultProcessor.awaitCompletion();
    Optional<Quantiles> persistedQuantiles=getQuantiles();
    assertTrue(persistedQuantiles.isPresent());
    assertEquals(quantiles,persistedQuantiles.get());
    verify(renormalizer).renormalize(quantiles);
  }
  public void testParseQuantiles_GivenRenormalizationIsDisabled() throws Exception {
    when(renormalizer.isEnabled()).thenReturn(false);
    ResultsBuilder builder=new ResultsBuilder();
    Quantiles quantiles=createQuantiles();
    builder.addQuantiles(quantiles);
    resultProcessor.process(builder.buildTestProcess());
    resultProcessor.awaitCompletion();
    Optional<Quantiles> persistedQuantiles=getQuantiles();
    assertTrue(persistedQuantiles.isPresent());
    assertEquals(quantiles,persistedQuantiles.get());
    verify(renormalizer,never()).renormalize(quantiles);
  }
  public void testDeleteInterimResults() throws Exception {
    Bucket nonInterimBucket=createBucket(false);
    Bucket interimBucket=createBucket(true);
    ResultsBuilder resultBuilder=new ResultsBuilder().addRecords(createRecords(true)).addInfluencers(createInfluencers(true)).addBucket(interimBucket).addFlushAcknowledgement(createFlushAcknowledgement()).addBucket(nonInterimBucket);
    resultProcessor.process(resultBuilder.buildTestProcess());
    resultProcessor.awaitCompletion();
    QueryPage<Bucket> persistedBucket=getBucketQueryPage(new BucketsQueryBuilder().includeInterim(true));
    assertEquals(1,persistedBucket.count());
    nonInterimBucket.setRecords(Collections.emptyList());
    assertEquals(nonInterimBucket,persistedBucket.results().get(0));
    QueryPage<Influencer> persistedInfluencers=getInfluencers();
    assertEquals(0,persistedInfluencers.count());
    QueryPage<AnomalyRecord> persistedRecords=getRecords(new RecordsQueryBuilder().includeInterim(true));
    assertEquals(0,persistedRecords.count());
  }
  public void testMultipleFlushesBetweenPersisting() throws Exception {
    Bucket finalBucket=createBucket(true);
    List<AnomalyRecord> finalAnomalyRecords=createRecords(true);
    ResultsBuilder resultBuilder=new ResultsBuilder().addRecords(createRecords(true)).addInfluencers(createInfluencers(true)).addBucket(createBucket(true)).addFlushAcknowledgement(createFlushAcknowledgement()).addRecords(createRecords(true)).addBucket(createBucket(true)).addFlushAcknowledgement(createFlushAcknowledgement()).addRecords(finalAnomalyRecords).addBucket(finalBucket);
    resultProcessor.process(resultBuilder.buildTestProcess());
    resultProcessor.awaitCompletion();
    QueryPage<Bucket> persistedBucket=getBucketQueryPage(new BucketsQueryBuilder().includeInterim(true));
    assertEquals(1,persistedBucket.count());
    finalBucket.setRecords(Collections.emptyList());
    assertEquals(finalBucket,persistedBucket.results().get(0));
    QueryPage<AnomalyRecord> persistedRecords=getRecords(new RecordsQueryBuilder().includeInterim(true));
    assertResultsAreSame(finalAnomalyRecords,persistedRecords);
  }
  public void testEndOfStreamTriggersPersisting() throws Exception {
    Bucket bucket=createBucket(false);
    List<AnomalyRecord> firstSetOfRecords=createRecords(false);
    List<AnomalyRecord> secondSetOfRecords=createRecords(false);
    ResultsBuilder resultBuilder=new ResultsBuilder().addRecords(firstSetOfRecords).addBucket(bucket).addRecords(secondSetOfRecords);
    resultProcessor.process(resultBuilder.buildTestProcess());
    resultProcessor.awaitCompletion();
    QueryPage<Bucket> persistedBucket=getBucketQueryPage(new BucketsQueryBuilder().includeInterim(true));
    assertEquals(1,persistedBucket.count());
    QueryPage<AnomalyRecord> persistedRecords=getRecords(new RecordsQueryBuilder().size(200).includeInterim(true));
    List<AnomalyRecord> allRecords=new ArrayList<>(firstSetOfRecords);
    allRecords.addAll(secondSetOfRecords);
    assertResultsAreSame(allRecords,persistedRecords);
  }
  private void putIndexTemplates() throws Exception {
    assertBusy(() -> {
      ClusterState state=client().admin().cluster().prepareState().get().getState();
      assertTrue("Timed out waiting for the ML templates to be installed",MachineLearning.allTemplatesInstalled(state));
    }
);
  }
  private void putJob(){
    Detector detector=new Detector.Builder("dc","by_instance").build();
    Job.Builder jobBuilder=new Job.Builder(JOB_ID);
    jobBuilder.setDataDescription(new DataDescription.Builder());
    jobBuilder.setAnalysisConfig(new AnalysisConfig.Builder(Collections.singletonList(detector)));
    PutJobAction.Request request=new PutJobAction.Request(jobBuilder);
    client().execute(PutJobAction.INSTANCE,request).actionGet();
  }
  private Bucket createBucket(  boolean isInterim){
    Bucket bucket=new BucketTests().createTestInstance(JOB_ID);
    bucket.setInterim(isInterim);
    return bucket;
  }
  private List<AnomalyRecord> createRecords(  boolean isInterim){
    List<AnomalyRecord> records=new ArrayList<>();
    int count=randomIntBetween(0,100);
    Date now=new Date(randomNonNegativeLong());
    for (int i=0; i < count; i++) {
      AnomalyRecord r=new AnomalyRecord(JOB_ID,now,3600L);
      r.setByFieldName("by_instance");
      r.setByFieldValue(randomAlphaOfLength(8));
      r.setInterim(isInterim);
      records.add(r);
    }
    return records;
  }
  private List<Influencer> createInfluencers(  boolean isInterim){
    List<Influencer> influencers=new ArrayList<>();
    int count=randomIntBetween(0,100);
    Date now=new Date();
    for (int i=0; i < count; i++) {
      Influencer influencer=new Influencer(JOB_ID,"influence_field",randomAlphaOfLength(10),now,3600L);
      influencer.setInterim(isInterim);
      influencers.add(influencer);
    }
    return influencers;
  }
  private CategoryDefinition createCategoryDefinition(){
    return new CategoryDefinitionTests().createTestInstance(JOB_ID);
  }
  private ModelPlot createmodelPlot(){
    return new ModelPlotTests().createTestInstance(JOB_ID);
  }
  private ModelSizeStats createModelSizeStats(){
    ModelSizeStats.Builder builder=new ModelSizeStats.Builder(JOB_ID);
    builder.setTimestamp(new Date(randomNonNegativeLong()));
    builder.setLogTime(new Date(randomNonNegativeLong()));
    builder.setBucketAllocationFailuresCount(randomNonNegativeLong());
    builder.setModelBytes(randomNonNegativeLong());
    builder.setTotalByFieldCount(randomNonNegativeLong());
    builder.setTotalOverFieldCount(randomNonNegativeLong());
    builder.setTotalPartitionFieldCount(randomNonNegativeLong());
    builder.setMemoryStatus(randomFrom(EnumSet.allOf(ModelSizeStats.MemoryStatus.class)));
    return builder.build();
  }
  private ModelSnapshot createModelSnapshot(){
    return new ModelSnapshot.Builder(JOB_ID).setSnapshotId(randomAlphaOfLength(12)).build();
  }
  private Quantiles createQuantiles(){
    return new Quantiles(JOB_ID,new Date(randomNonNegativeLong()),randomAlphaOfLength(100));
  }
  private FlushAcknowledgement createFlushAcknowledgement(){
    return new FlushAcknowledgement(randomAlphaOfLength(5),new Date(randomNonNegativeLong()));
  }
private class ResultsBuilder {
    private List<AutodetectResult> results=new ArrayList<>();
    ResultsBuilder addBucket(    Bucket bucket){
      results.add(new AutodetectResult(Objects.requireNonNull(bucket),null,null,null,null,null,null,null,null,null,null));
      return this;
    }
    ResultsBuilder addRecords(    List<AnomalyRecord> records){
      results.add(new AutodetectResult(null,records,null,null,null,null,null,null,null,null,null));
      return this;
    }
    ResultsBuilder addInfluencers(    List<Influencer> influencers){
      results.add(new AutodetectResult(null,null,influencers,null,null,null,null,null,null,null,null));
      return this;
    }
    ResultsBuilder addCategoryDefinition(    CategoryDefinition categoryDefinition){
      results.add(new AutodetectResult(null,null,null,null,null,null,null,null,null,categoryDefinition,null));
      return this;
    }
    ResultsBuilder addmodelPlot(    ModelPlot modelPlot){
      results.add(new AutodetectResult(null,null,null,null,null,null,modelPlot,null,null,null,null));
      return this;
    }
    ResultsBuilder addModelSizeStats(    ModelSizeStats modelSizeStats){
      results.add(new AutodetectResult(null,null,null,null,null,modelSizeStats,null,null,null,null,null));
      return this;
    }
    ResultsBuilder addModelSnapshot(    ModelSnapshot modelSnapshot){
      results.add(new AutodetectResult(null,null,null,null,modelSnapshot,null,null,null,null,null,null));
      return this;
    }
    ResultsBuilder addQuantiles(    Quantiles quantiles){
      results.add(new AutodetectResult(null,null,null,quantiles,null,null,null,null,null,null,null));
      return this;
    }
    ResultsBuilder addFlushAcknowledgement(    FlushAcknowledgement flushAcknowledgement){
      results.add(new AutodetectResult(null,null,null,null,null,null,null,null,null,null,flushAcknowledgement));
      return this;
    }
    AutodetectProcess buildTestProcess(){
      AutodetectResult[] results=this.results.toArray(new AutodetectResult[0]);
      AutodetectProcess process=mock(AutodetectProcess.class);
      when(process.readAutodetectResults()).thenReturn(Arrays.asList(results).iterator());
      return process;
    }
  }
  private <T extends ToXContent & Writeable>void assertResultsAreSame(  List<T> expected,  QueryPage<T> actual){
    assertEquals(expected.size(),actual.count());
    assertEquals(actual.results().size(),actual.count());
    Set<T> expectedSet=new HashSet<>(expected);
    expectedSet.removeAll(actual.results());
    assertEquals(0,expectedSet.size());
  }
  private QueryPage<Bucket> getBucketQueryPage(  BucketsQueryBuilder bucketsQuery) throws Exception {
    AtomicReference<Exception> errorHolder=new AtomicReference<>();
    AtomicReference<QueryPage<Bucket>> resultHolder=new AtomicReference<>();
    CountDownLatch latch=new CountDownLatch(1);
    jobResultsProvider.buckets(JOB_ID,bucketsQuery,r -> {
      resultHolder.set(r);
      latch.countDown();
    }
,e -> {
      errorHolder.set(e);
      latch.countDown();
    }
,client());
    latch.await();
    if (errorHolder.get() != null) {
      throw errorHolder.get();
    }
    return resultHolder.get();
  }
  private QueryPage<CategoryDefinition> getCategoryDefinition(  long categoryId) throws Exception {
    AtomicReference<Exception> errorHolder=new AtomicReference<>();
    AtomicReference<QueryPage<CategoryDefinition>> resultHolder=new AtomicReference<>();
    CountDownLatch latch=new CountDownLatch(1);
    jobResultsProvider.categoryDefinitions(JOB_ID,categoryId,false,null,null,r -> {
      resultHolder.set(r);
      latch.countDown();
    }
,e -> {
      errorHolder.set(e);
      latch.countDown();
    }
,client());
    latch.await();
    if (errorHolder.get() != null) {
      throw errorHolder.get();
    }
    return resultHolder.get();
  }
  private ModelSizeStats getModelSizeStats() throws Exception {
    AtomicReference<Exception> errorHolder=new AtomicReference<>();
    AtomicReference<ModelSizeStats> resultHolder=new AtomicReference<>();
    CountDownLatch latch=new CountDownLatch(1);
    jobResultsProvider.modelSizeStats(JOB_ID,modelSizeStats -> {
      resultHolder.set(modelSizeStats);
      latch.countDown();
    }
,e -> {
      errorHolder.set(e);
      latch.countDown();
    }
);
    latch.await();
    if (errorHolder.get() != null) {
      throw errorHolder.get();
    }
    return resultHolder.get();
  }
  private QueryPage<Influencer> getInfluencers() throws Exception {
    AtomicReference<Exception> errorHolder=new AtomicReference<>();
    AtomicReference<QueryPage<Influencer>> resultHolder=new AtomicReference<>();
    CountDownLatch latch=new CountDownLatch(1);
    jobResultsProvider.influencers(JOB_ID,new InfluencersQueryBuilder().build(),page -> {
      resultHolder.set(page);
      latch.countDown();
    }
,e -> {
      errorHolder.set(e);
      latch.countDown();
    }
,client());
    latch.await();
    if (errorHolder.get() != null) {
      throw errorHolder.get();
    }
    return resultHolder.get();
  }
  private QueryPage<AnomalyRecord> getRecords(  RecordsQueryBuilder recordsQuery) throws Exception {
    AtomicReference<Exception> errorHolder=new AtomicReference<>();
    AtomicReference<QueryPage<AnomalyRecord>> resultHolder=new AtomicReference<>();
    CountDownLatch latch=new CountDownLatch(1);
    jobResultsProvider.records(JOB_ID,recordsQuery,page -> {
      resultHolder.set(page);
      latch.countDown();
    }
,e -> {
      errorHolder.set(e);
      latch.countDown();
    }
,client());
    latch.await();
    if (errorHolder.get() != null) {
      throw errorHolder.get();
    }
    return resultHolder.get();
  }
  private QueryPage<ModelSnapshot> getModelSnapshots() throws Exception {
    AtomicReference<Exception> errorHolder=new AtomicReference<>();
    AtomicReference<QueryPage<ModelSnapshot>> resultHolder=new AtomicReference<>();
    CountDownLatch latch=new CountDownLatch(1);
    jobResultsProvider.modelSnapshots(JOB_ID,0,100,page -> {
      resultHolder.set(page);
      latch.countDown();
    }
,e -> {
      errorHolder.set(e);
      latch.countDown();
    }
);
    latch.await();
    if (errorHolder.get() != null) {
      throw errorHolder.get();
    }
    return resultHolder.get();
  }
  private Optional<Quantiles> getQuantiles() throws Exception {
    AtomicReference<Exception> errorHolder=new AtomicReference<>();
    AtomicReference<Optional<Quantiles>> resultHolder=new AtomicReference<>();
    CountDownLatch latch=new CountDownLatch(1);
    jobResultsProvider.getAutodetectParams(JobTests.buildJobBuilder(JOB_ID).build(),params -> {
      resultHolder.set(Optional.ofNullable(params.quantiles()));
      latch.countDown();
    }
,e -> {
      errorHolder.set(e);
      latch.countDown();
    }
);
    latch.await();
    if (errorHolder.get() != null) {
      throw errorHolder.get();
    }
    return resultHolder.get();
  }
}
