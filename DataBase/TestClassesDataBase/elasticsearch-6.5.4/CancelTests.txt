/** 
 * Test that you can actually cancel a reindex/update-by-query/delete-by-query request and all the plumbing works. Doesn't test all of the different cancellation places - that is the responsibility of AsyncBulkByScrollActionTests which have more precise control to simulate failures but does not exercise important portion of the stack like transport and task management.
 */
@TestLogging("org.elasticsearch.index.reindex:DEBUG,org.elasticsearch.action.bulk:DEBUG") public class CancelTests extends ReindexTestCase {
  protected static final String INDEX="reindex-cancel-index";
  protected static final String TYPE="reindex-cancel-type";
  private static final Semaphore ALLOWED_OPERATIONS=new Semaphore(0);
  @Override protected Collection<Class<? extends Plugin>> nodePlugins(){
    Collection<Class<? extends Plugin>> plugins=new ArrayList<>(super.nodePlugins());
    plugins.add(IngestTestPlugin.class);
    plugins.add(ReindexCancellationPlugin.class);
    return plugins;
  }
  @Before public void clearAllowedOperations(){
    ALLOWED_OPERATIONS.drainPermits();
  }
  /** 
 * Executes the cancellation test
 */
  private void testCancel(  String action,  AbstractBulkByScrollRequestBuilder<?,?> builder,  CancelAssertion assertion,  Matcher<String> taskDescriptionMatcher) throws Exception {
    createIndex(INDEX);
    int numDocs=getNumShards(INDEX).numPrimaries * 10 * builder.request().getSlices();
    ALLOWED_OPERATIONS.release(numDocs);
    logger.debug("setting up [{}] docs",numDocs);
    indexRandom(true,false,true,IntStream.range(0,numDocs).mapToObj(i -> client().prepareIndex(INDEX,TYPE,String.valueOf(i)).setSource("n",i)).collect(Collectors.toList()));
    assertHitCount(client().prepareSearch(INDEX).setSize(0).get(),numDocs);
    assertThat(ALLOWED_OPERATIONS.drainPermits(),equalTo(0));
    builder.source().setSize(1);
    int numModifiedDocs=randomIntBetween(builder.request().getSlices() * 2,numDocs);
    logger.debug("chose to modify [{}] out of [{}] docs",numModifiedDocs,numDocs);
    ALLOWED_OPERATIONS.release(numModifiedDocs - builder.request().getSlices());
    ActionFuture<? extends BulkByScrollResponse> future=builder.execute();
    logger.debug("waiting for updates to be blocked");
    boolean blocked=awaitBusy(() -> ALLOWED_OPERATIONS.hasQueuedThreads() && ALLOWED_OPERATIONS.availablePermits() == 0,1,TimeUnit.MINUTES);
    assertTrue("updates blocked",blocked);
    TaskInfo mainTask=findTaskToCancel(action,builder.request().getSlices());
    BulkByScrollTask.Status status=(BulkByScrollTask.Status)mainTask.getStatus();
    assertNull(status.getReasonCancelled());
    assertThat(mainTask.getDescription(),taskDescriptionMatcher);
    ListTasksResponse cancelTasksResponse=client().admin().cluster().prepareCancelTasks().setTaskId(mainTask.getTaskId()).get();
    cancelTasksResponse.rethrowFailures("Cancel");
    assertThat(cancelTasksResponse.getTasks(),hasSize(1));
    mainTask=client().admin().cluster().prepareGetTask(mainTask.getTaskId()).get().getTask().getTask();
    status=(BulkByScrollTask.Status)mainTask.getStatus();
    logger.debug("asserting that parent is marked canceled {}",status);
    assertEquals(CancelTasksRequest.DEFAULT_REASON,status.getReasonCancelled());
    if (builder.request().getSlices() > 1) {
      boolean foundCancelled=false;
      ListTasksResponse sliceList=client().admin().cluster().prepareListTasks().setParentTaskId(mainTask.getTaskId()).setDetailed(true).get();
      sliceList.rethrowFailures("Fetch slice tasks");
      logger.debug("finding at least one canceled child among {}",sliceList.getTasks());
      for (      TaskInfo slice : sliceList.getTasks()) {
        BulkByScrollTask.Status sliceStatus=(BulkByScrollTask.Status)slice.getStatus();
        if (sliceStatus.getReasonCancelled() == null)         continue;
        assertEquals(CancelTasksRequest.DEFAULT_REASON,sliceStatus.getReasonCancelled());
        foundCancelled=true;
      }
      assertTrue("Didn't find at least one sub task that was cancelled",foundCancelled);
    }
    logger.debug("unblocking the blocked update");
    ALLOWED_OPERATIONS.release(builder.request().getSlices());
    assertBusy(() -> {
      if (builder.request().getSlices() == 1) {
        assertEquals(0,ALLOWED_OPERATIONS.availablePermits());
      }
      assertEquals(0,ALLOWED_OPERATIONS.getQueueLength());
    }
);
    BulkByScrollResponse response;
    try {
      response=future.get(30,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      String tasks=client().admin().cluster().prepareListTasks().setParentTaskId(mainTask.getTaskId()).setDetailed(true).get().toString();
      throw new RuntimeException("Exception while waiting for the response. Running tasks: " + tasks,e);
    }
    assertThat(response.getReasonCancelled(),equalTo("by user request"));
    assertThat(response.getBulkFailures(),emptyIterable());
    assertThat(response.getSearchFailures(),emptyIterable());
    if (builder.request().getSlices() >= 1) {
      numModifiedDocs-=ALLOWED_OPERATIONS.availablePermits();
    }
    flushAndRefresh(INDEX);
    assertion.assertThat(response,numDocs,numModifiedDocs);
  }
  private TaskInfo findTaskToCancel(  String actionName,  int workerCount){
    ListTasksResponse tasks;
    long start=System.nanoTime();
    do {
      tasks=client().admin().cluster().prepareListTasks().setActions(actionName).setDetailed(true).get();
      tasks.rethrowFailures("Find tasks to cancel");
      for (      TaskInfo taskInfo : tasks.getTasks()) {
        if (false == taskInfo.getParentTaskId().isSet()) {
          return taskInfo;
        }
      }
    }
 while (System.nanoTime() - start < TimeUnit.SECONDS.toNanos(10));
    throw new AssertionError("Couldn't find task to rethrottle after waiting tasks=" + tasks.getTasks());
  }
  public void testReindexCancel() throws Exception {
    testCancel(ReindexAction.NAME,reindex().source(INDEX).destination("dest",TYPE),(response,total,modified) -> {
      assertThat(response,matcher().created(modified).reasonCancelled(equalTo("by user request")));
      refresh("dest");
      assertHitCount(client().prepareSearch("dest").setTypes(TYPE).setSize(0).get(),modified);
    }
,equalTo("reindex from [" + INDEX + "] to [dest]["+ TYPE+ "]"));
  }
  public void testUpdateByQueryCancel() throws Exception {
    BytesReference pipeline=new BytesArray("{\n" + "  \"description\" : \"sets processed to true\",\n" + "  \"processors\" : [ {\n"+ "      \"test\" : {}\n"+ "  } ]\n"+ "}");
    assertAcked(client().admin().cluster().preparePutPipeline("set-processed",pipeline,XContentType.JSON).get());
    testCancel(UpdateByQueryAction.NAME,updateByQuery().setPipeline("set-processed").source(INDEX),(response,total,modified) -> {
      assertThat(response,matcher().updated(modified).reasonCancelled(equalTo("by user request")));
      assertHitCount(client().prepareSearch(INDEX).setSize(0).setQuery(termQuery("processed",true)).get(),modified);
    }
,equalTo("update-by-query [" + INDEX + "]"));
    assertAcked(client().admin().cluster().deletePipeline(new DeletePipelineRequest("set-processed")).get());
  }
  public void testDeleteByQueryCancel() throws Exception {
    testCancel(DeleteByQueryAction.NAME,deleteByQuery().source(INDEX).filter(QueryBuilders.matchAllQuery()),(response,total,modified) -> {
      assertThat(response,matcher().deleted(modified).reasonCancelled(equalTo("by user request")));
      assertHitCount(client().prepareSearch(INDEX).setSize(0).get(),total - modified);
    }
,equalTo("delete-by-query [" + INDEX + "]"));
  }
  public void testReindexCancelWithWorkers() throws Exception {
    testCancel(ReindexAction.NAME,reindex().source(INDEX).filter(QueryBuilders.matchAllQuery()).destination("dest",TYPE).setSlices(5),(response,total,modified) -> {
      assertThat(response,matcher().created(modified).reasonCancelled(equalTo("by user request")).slices(hasSize(5)));
      refresh("dest");
      assertHitCount(client().prepareSearch("dest").setTypes(TYPE).setSize(0).get(),modified);
    }
,equalTo("reindex from [" + INDEX + "] to [dest]["+ TYPE+ "]"));
  }
  public void testUpdateByQueryCancelWithWorkers() throws Exception {
    BytesReference pipeline=new BytesArray("{\n" + "  \"description\" : \"sets processed to true\",\n" + "  \"processors\" : [ {\n"+ "      \"test\" : {}\n"+ "  } ]\n"+ "}");
    assertAcked(client().admin().cluster().preparePutPipeline("set-processed",pipeline,XContentType.JSON).get());
    testCancel(UpdateByQueryAction.NAME,updateByQuery().setPipeline("set-processed").source(INDEX).setSlices(5),(response,total,modified) -> {
      assertThat(response,matcher().updated(modified).reasonCancelled(equalTo("by user request")).slices(hasSize(5)));
      assertHitCount(client().prepareSearch(INDEX).setSize(0).setQuery(termQuery("processed",true)).get(),modified);
    }
,equalTo("update-by-query [" + INDEX + "]"));
    assertAcked(client().admin().cluster().deletePipeline(new DeletePipelineRequest("set-processed")).get());
  }
  public void testDeleteByQueryCancelWithWorkers() throws Exception {
    testCancel(DeleteByQueryAction.NAME,deleteByQuery().source(INDEX).filter(QueryBuilders.matchAllQuery()).setSlices(5),(response,total,modified) -> {
      assertThat(response,matcher().deleted(modified).reasonCancelled(equalTo("by user request")).slices(hasSize(5)));
      assertHitCount(client().prepareSearch(INDEX).setSize(0).get(),total - modified);
    }
,equalTo("delete-by-query [" + INDEX + "]"));
  }
  /** 
 * Used to check the result of the cancel test.
 */
private interface CancelAssertion {
    void assertThat(    BulkByScrollResponse response,    int total,    int modified);
  }
public static class ReindexCancellationPlugin extends Plugin {
    @Override public void onIndexModule(    IndexModule indexModule){
      indexModule.addIndexOperationListener(new BlockingOperationListener());
    }
  }
public static class BlockingOperationListener implements IndexingOperationListener {
    private static final Logger log=Loggers.getLogger(CancelTests.class);
    @Override public Engine.Index preIndex(    ShardId shardId,    Engine.Index index){
      return preCheck(index,index.type());
    }
    @Override public Engine.Delete preDelete(    ShardId shardId,    Engine.Delete delete){
      return preCheck(delete,delete.type());
    }
    private <T extends Engine.Operation>T preCheck(    T operation,    String type){
      if ((TYPE.equals(type) == false) || (operation.origin() != Origin.PRIMARY)) {
        return operation;
      }
      try {
        log.debug("checking");
        if (ALLOWED_OPERATIONS.tryAcquire(30,TimeUnit.SECONDS)) {
          log.debug("passed");
          return operation;
        }
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
      throw new IllegalStateException("Something went wrong");
    }
  }
}
