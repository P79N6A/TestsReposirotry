class TaskExecutor implements ClusterStateTaskExecutor<Task> {
  private final List<Set<Task>> taskGroups;
  private AtomicInteger counter=new AtomicInteger();
  private AtomicInteger batches=new AtomicInteger();
  private AtomicInteger published=new AtomicInteger();
  TaskExecutor(  List<Set<Task>> taskGroups){
    this.taskGroups=taskGroups;
  }
  @Override public ClusterTasksResult<Task> execute(  ClusterState currentState,  List<Task> tasks) throws Exception {
    for (    Set<Task> expectedSet : taskGroups) {
      long count=tasks.stream().filter(expectedSet::contains).count();
      assertThat("batched set should be executed together or not at all. Expected " + expectedSet + "s. Executing "+ tasks,count,anyOf(equalTo(0L),equalTo((long)expectedSet.size())));
    }
    tasks.forEach(Task::execute);
    counter.addAndGet(tasks.size());
    ClusterState maybeUpdatedClusterState=currentState;
    if (randomBoolean()) {
      maybeUpdatedClusterState=ClusterState.builder(currentState).build();
      batches.incrementAndGet();
      semaphore.acquire();
    }
    return ClusterTasksResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState);
  }
  @Override public void clusterStatePublished(  ClusterChangedEvent clusterChangedEvent){
    published.incrementAndGet();
    semaphore.release();
  }
}
