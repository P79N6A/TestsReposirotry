public class TransportAckWatchActionTests extends ESTestCase {
  private TransportAckWatchAction action;
  private Client client;
  @Before public void setupAction(){
    TransportService transportService=mock(TransportService.class);
    ThreadPool threadPool=mock(ThreadPool.class);
    ThreadContext threadContext=new ThreadContext(Settings.EMPTY);
    when(threadPool.getThreadContext()).thenReturn(threadContext);
    WatchParser watchParser=mock(WatchParser.class);
    ClusterService clusterService=mock(ClusterService.class);
    client=mock(Client.class);
    when(client.threadPool()).thenReturn(threadPool);
    action=new TransportAckWatchAction(Settings.EMPTY,transportService,threadPool,new ActionFilters(Collections.emptySet()),new IndexNameExpressionResolver(Settings.EMPTY),Clock.systemUTC(),new XPackLicenseState(Settings.EMPTY),watchParser,client,clusterService);
    when(client.threadPool()).thenReturn(threadPool);
  }
  public void testWatchNotFound() throws Exception {
    String watchId="my_watch_id";
    doAnswer(invocation -> {
      ActionListener<GetResponse> listener=(ActionListener<GetResponse>)invocation.getArguments()[1];
      listener.onResponse(new GetResponse(new GetResult(Watch.INDEX,Watch.DOC_TYPE,watchId,-1,false,BytesArray.EMPTY,Collections.emptyMap())));
      return null;
    }
).when(client).get(anyObject(),anyObject());
    doAnswer(invocation -> {
      ContextPreservingActionListener listener=(ContextPreservingActionListener)invocation.getArguments()[2];
      listener.onResponse(new WatcherStatsResponse(new ClusterName("clusterName"),new WatcherMetaData(false),Collections.emptyList(),Collections.emptyList()));
      return null;
    }
).when(client).execute(eq(WatcherStatsAction.INSTANCE),anyObject(),anyObject());
    AckWatchRequest ackWatchRequest=new AckWatchRequest(watchId);
    PlainActionFuture<AckWatchResponse> listener=PlainActionFuture.newFuture();
    action.masterOperation(ackWatchRequest,null,listener);
    ExecutionException exception=expectThrows(ExecutionException.class,listener::get);
    ElasticsearchException e=(ElasticsearchException)exception.getCause();
    assertThat(e.getMessage(),is("Watch with id [" + watchId + "] does not exist"));
  }
  public void testThatWatchCannotBeAckedWhileRunning() throws Exception {
    String watchId="my_watch_id";
    doAnswer(invocation -> {
      ContextPreservingActionListener listener=(ContextPreservingActionListener)invocation.getArguments()[2];
      DiscoveryNode discoveryNode=new DiscoveryNode("node_2",buildNewFakeTransportAddress(),Version.CURRENT);
      WatcherStatsResponse.Node node=new WatcherStatsResponse.Node(discoveryNode);
      WatchExecutionSnapshot snapshot=mock(WatchExecutionSnapshot.class);
      when(snapshot.watchId()).thenReturn(watchId);
      node.setSnapshots(Collections.singletonList(snapshot));
      listener.onResponse(new WatcherStatsResponse(new ClusterName("clusterName"),new WatcherMetaData(false),Collections.singletonList(node),Collections.emptyList()));
      return null;
    }
).when(client).execute(eq(WatcherStatsAction.INSTANCE),anyObject(),anyObject());
    AckWatchRequest ackWatchRequest=new AckWatchRequest(watchId);
    PlainActionFuture<AckWatchResponse> listener=PlainActionFuture.newFuture();
    action.masterOperation(ackWatchRequest,null,listener);
    ExecutionException exception=expectThrows(ExecutionException.class,listener::get);
    ElasticsearchException e=(ElasticsearchException)exception.getCause();
    assertThat(e.getMessage(),is("watch[my_watch_id] is running currently, cannot ack until finished"));
    assertThat(e.status(),is(RestStatus.CONFLICT));
  }
}
