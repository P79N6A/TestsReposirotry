public class TermsQueryBuilderTests extends AbstractQueryTestCase<TermsQueryBuilder> {
  private List<Object> randomTerms;
  private String termsPath;
  @Before public void randomTerms(){
    List<Object> randomTerms=new ArrayList<>();
    String[] strings=generateRandomStringArray(10,10,false,true);
    for (    String string : strings) {
      randomTerms.add(string);
      if (rarely()) {
        randomTerms.add(null);
      }
    }
    this.randomTerms=randomTerms;
    termsPath=randomAlphaOfLength(10).replace('.','_');
  }
  @Override protected TermsQueryBuilder doCreateTestQueryBuilder(){
    TermsQueryBuilder query;
    if (randomBoolean()) {
      String fieldName=randomValueOtherThanMany(choice -> choice.equals(GEO_POINT_FIELD_NAME) || choice.equals(GEO_POINT_ALIAS_FIELD_NAME) || choice.equals(GEO_SHAPE_FIELD_NAME)|| choice.equals(INT_RANGE_FIELD_NAME)|| choice.equals(DATE_RANGE_FIELD_NAME),() -> getRandomFieldName());
      Object[] values=new Object[randomInt(5)];
      for (int i=0; i < values.length; i++) {
        values[i]=getRandomValueForFieldName(fieldName);
      }
      query=new TermsQueryBuilder(fieldName,values);
    }
 else {
      query=new TermsQueryBuilder(randomBoolean() ? randomAlphaOfLengthBetween(1,10) : STRING_FIELD_NAME,randomTermsLookup());
    }
    return query;
  }
  private TermsLookup randomTermsLookup(){
    return new TermsLookup(randomAlphaOfLength(10),randomAlphaOfLength(10),randomAlphaOfLength(10),termsPath).routing(randomBoolean() ? randomAlphaOfLength(10) : null);
  }
  @Override protected void doAssertLuceneQuery(  TermsQueryBuilder queryBuilder,  Query query,  SearchContext context) throws IOException {
    if (queryBuilder.termsLookup() == null && (queryBuilder.values() == null || queryBuilder.values().isEmpty())) {
      assertThat(query,instanceOf(MatchNoDocsQuery.class));
      MatchNoDocsQuery matchNoDocsQuery=(MatchNoDocsQuery)query;
      assertThat(matchNoDocsQuery.toString(),containsString("No terms supplied for \"terms\" query."));
    }
 else     if (queryBuilder.termsLookup() != null && randomTerms.size() == 0) {
      assertThat(query,instanceOf(MatchNoDocsQuery.class));
      MatchNoDocsQuery matchNoDocsQuery=(MatchNoDocsQuery)query;
      assertThat(matchNoDocsQuery.toString(),containsString("No terms supplied for \"terms\" query."));
    }
 else {
      assertThat(query,either(instanceOf(TermInSetQuery.class)).or(instanceOf(PointInSetQuery.class)).or(instanceOf(ConstantScoreQuery.class)));
      if (query instanceof ConstantScoreQuery) {
        assertThat(((ConstantScoreQuery)query).getQuery(),instanceOf(BooleanQuery.class));
      }
      if (queryBuilder.fieldName().equals(INT_FIELD_NAME) || queryBuilder.fieldName().equals(DOUBLE_FIELD_NAME) || queryBuilder.fieldName().equals(BOOLEAN_FIELD_NAME)|| queryBuilder.fieldName().equals(DATE_FIELD_NAME)) {
        return;
      }
      List<Object> terms;
      if (queryBuilder.termsLookup() != null) {
        terms=randomTerms;
      }
 else {
        terms=queryBuilder.values();
      }
      String fieldName=expectedFieldName(queryBuilder.fieldName());
      TermInSetQuery expected=new TermInSetQuery(fieldName,terms.stream().filter(Objects::nonNull).map(Object::toString).map(BytesRef::new).collect(Collectors.toList()));
      assertEquals(expected,query);
    }
  }
  public void testEmtpyFieldName(){
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder(null,"term"));
    assertEquals("field name cannot be null.",e.getMessage());
    e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("","term"));
    assertEquals("field name cannot be null.",e.getMessage());
  }
  public void testEmtpyTermsLookup(){
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(TermsLookup)null));
    assertEquals("No value or termsLookup specified for terms query",e.getMessage());
  }
  public void testNullValues(){
    IllegalArgumentException e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(String[])null));
    assertThat(e.getMessage(),containsString("No value specified for terms query"));
    e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(int[])null));
    assertThat(e.getMessage(),containsString("No value specified for terms query"));
    e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(long[])null));
    assertThat(e.getMessage(),containsString("No value specified for terms query"));
    e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(float[])null));
    assertThat(e.getMessage(),containsString("No value specified for terms query"));
    e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(double[])null));
    assertThat(e.getMessage(),containsString("No value specified for terms query"));
    e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(Object[])null));
    assertThat(e.getMessage(),containsString("No value specified for terms query"));
    e=expectThrows(IllegalArgumentException.class,() -> new TermsQueryBuilder("field",(Iterable<?>)null));
    assertThat(e.getMessage(),containsString("No value specified for terms query"));
  }
  public void testBothValuesAndLookupSet() throws IOException {
    String query="{\n" + "  \"terms\": {\n" + "    \"field\": [\n"+ "      \"blue\",\n"+ "      \"pill\"\n"+ "    ],\n"+ "    \"field_lookup\": {\n"+ "      \"index\": \"pills\",\n"+ "      \"type\": \"red\",\n"+ "      \"id\": \"3\",\n"+ "      \"path\": \"white rabbit\"\n"+ "    }\n"+ "  }\n"+ "}";
    ParsingException e=expectThrows(ParsingException.class,() -> parseQuery(query));
    assertThat(e.getMessage(),containsString("[" + TermsQueryBuilder.NAME + "] query does not support more than one field."));
  }
  @Override public GetResponse executeGet(  GetRequest getRequest){
    String json;
    try {
      XContentBuilder builder=XContentFactory.jsonBuilder().prettyPrint();
      builder.startObject();
      builder.array(termsPath,randomTerms.toArray(new Object[randomTerms.size()]));
      builder.endObject();
      json=Strings.toString(builder);
    }
 catch (    IOException ex) {
      throw new ElasticsearchException("boom",ex);
    }
    return new GetResponse(new GetResult(getRequest.index(),getRequest.type(),getRequest.id(),0,true,new BytesArray(json),null));
  }
  public void testNumeric() throws IOException {
{
      TermsQueryBuilder builder=new TermsQueryBuilder("foo",new int[]{1,3,4});
      TermsQueryBuilder copy=(TermsQueryBuilder)assertSerialization(builder);
      List<Object> values=copy.values();
      assertEquals(Arrays.asList(1L,3L,4L),values);
    }
{
      TermsQueryBuilder builder=new TermsQueryBuilder("foo",new double[]{1,3,4});
      TermsQueryBuilder copy=(TermsQueryBuilder)assertSerialization(builder);
      List<Object> values=copy.values();
      assertEquals(Arrays.asList(1d,3d,4d),values);
    }
{
      TermsQueryBuilder builder=new TermsQueryBuilder("foo",new float[]{1,3,4});
      TermsQueryBuilder copy=(TermsQueryBuilder)assertSerialization(builder);
      List<Object> values=copy.values();
      assertEquals(Arrays.asList(1f,3f,4f),values);
    }
{
      TermsQueryBuilder builder=new TermsQueryBuilder("foo",new long[]{1,3,4});
      TermsQueryBuilder copy=(TermsQueryBuilder)assertSerialization(builder);
      List<Object> values=copy.values();
      assertEquals(Arrays.asList(1L,3L,4L),values);
    }
  }
  public void testTermsQueryWithMultipleFields() throws IOException {
    String query=Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("terms").array("foo",123).array("bar",456).endObject().endObject());
    ParsingException e=expectThrows(ParsingException.class,() -> parseQuery(query));
    assertEquals("[" + TermsQueryBuilder.NAME + "] query does not support multiple fields",e.getMessage());
  }
  public void testFromJson() throws IOException {
    String json="{\n" + "  \"terms\" : {\n" + "    \"user\" : [ \"kimchy\", \"elasticsearch\" ],\n"+ "    \"boost\" : 1.0\n"+ "  }\n"+ "}";
    TermsQueryBuilder parsed=(TermsQueryBuilder)parseQuery(json);
    checkGeneratedJson(json,parsed);
    assertEquals(json,2,parsed.values().size());
  }
  @Override public void testMustRewrite() throws IOException {
    TermsQueryBuilder termsQueryBuilder=new TermsQueryBuilder(STRING_FIELD_NAME,randomTermsLookup());
    UnsupportedOperationException e=expectThrows(UnsupportedOperationException.class,() -> termsQueryBuilder.toQuery(createShardContext()));
    assertEquals("query must be rewritten first",e.getMessage());
    assertEquals(rewriteAndFetch(termsQueryBuilder,createShardContext()),new TermsQueryBuilder(STRING_FIELD_NAME,randomTerms.stream().filter(x -> x != null).collect(Collectors.toList())));
  }
  public void testGeo() throws Exception {
    assumeTrue("test runs only when at least a type is registered",getCurrentTypes().length > 0);
    TermsQueryBuilder query=new TermsQueryBuilder(GEO_POINT_FIELD_NAME,"2,3");
    QueryShardContext context=createShardContext();
    QueryShardException e=expectThrows(QueryShardException.class,() -> query.toQuery(context));
    assertEquals("Geo fields do not support exact searching, use dedicated geo queries instead: [mapped_geo_point]",e.getMessage());
  }
  @Override protected boolean isCachable(  TermsQueryBuilder queryBuilder){
    return super.isCachable(queryBuilder);
  }
  public void testSerializationFailsUnlessFetched() throws IOException {
    QueryBuilder builder=new TermsQueryBuilder(STRING_FIELD_NAME,randomTermsLookup());
    QueryBuilder termsQueryBuilder=Rewriteable.rewrite(builder,createShardContext());
    IllegalStateException ise=expectThrows(IllegalStateException.class,() -> termsQueryBuilder.writeTo(new BytesStreamOutput(10)));
    assertEquals(ise.getMessage(),"supplier must be null, can't serialize suppliers, missing a rewriteAndFetch?");
    builder=rewriteAndFetch(builder,createShardContext());
    builder.writeTo(new BytesStreamOutput(10));
  }
  public void testConversion(){
    List<Object> list=Arrays.asList();
    assertSame(Collections.emptyList(),TermsQueryBuilder.convert(list));
    assertEquals(list,TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list)));
    list=Arrays.asList("abc");
    assertEquals(Arrays.asList(new BytesRef("abc")),TermsQueryBuilder.convert(list));
    assertEquals(list,TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list)));
    list=Arrays.asList("abc",new BytesRef("def"));
    assertEquals(Arrays.asList(new BytesRef("abc"),new BytesRef("def")),TermsQueryBuilder.convert(list));
    assertEquals(Arrays.asList("abc","def"),TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list)));
    list=Arrays.asList(5,42L);
    assertEquals(Arrays.asList(5L,42L),TermsQueryBuilder.convert(list));
    assertEquals(Arrays.asList(5L,42L),TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list)));
    list=Arrays.asList(5,42d);
    assertEquals(Arrays.asList(5,42d),TermsQueryBuilder.convert(list));
    assertEquals(Arrays.asList(5,42d),TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list)));
  }
}
