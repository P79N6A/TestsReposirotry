/** 
 * Tests for the  {@link Netty4HttpServerTransport} class.
 */
public class Netty4HttpServerTransportTests extends ESTestCase {
  private NetworkService networkService;
  private ThreadPool threadPool;
  private MockBigArrays bigArrays;
  @Before public void setup() throws Exception {
    networkService=new NetworkService(Collections.emptyList());
    threadPool=new TestThreadPool("test");
    bigArrays=new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY),new NoneCircuitBreakerService());
  }
  @After public void shutdown() throws Exception {
    if (threadPool != null) {
      threadPool.shutdownNow();
    }
    threadPool=null;
    networkService=null;
    bigArrays=null;
  }
  public void testCorsConfig(){
    final Set<String> methods=new HashSet<>(Arrays.asList("get","options","post"));
    final Set<String> headers=new HashSet<>(Arrays.asList("Content-Type","Content-Length"));
    final String prefix=randomBoolean() ? " " : "";
    final Settings settings=Settings.builder().put(SETTING_CORS_ENABLED.getKey(),true).put(SETTING_CORS_ALLOW_ORIGIN.getKey(),"*").put(SETTING_CORS_ALLOW_METHODS.getKey(),collectionToDelimitedString(methods,",",prefix,"")).put(SETTING_CORS_ALLOW_HEADERS.getKey(),collectionToDelimitedString(headers,",",prefix,"")).put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(),true).build();
    final Netty4CorsConfig corsConfig=Netty4HttpServerTransport.buildCorsConfig(settings);
    assertTrue(corsConfig.isAnyOriginSupported());
    assertEquals(headers,corsConfig.allowedRequestHeaders());
    assertEquals(methods,corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet()));
  }
  public void testCorsConfigWithDefaults(){
    final Set<String> methods=Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_METHODS.getDefault(Settings.EMPTY));
    final Set<String> headers=Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_HEADERS.getDefault(Settings.EMPTY));
    final long maxAge=SETTING_CORS_MAX_AGE.getDefault(Settings.EMPTY);
    final Settings settings=Settings.builder().put(SETTING_CORS_ENABLED.getKey(),true).build();
    final Netty4CorsConfig corsConfig=Netty4HttpServerTransport.buildCorsConfig(settings);
    assertFalse(corsConfig.isAnyOriginSupported());
    assertEquals(Collections.emptySet(),corsConfig.origins().get());
    assertEquals(headers,corsConfig.allowedRequestHeaders());
    assertEquals(methods,corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet()));
    assertEquals(maxAge,corsConfig.maxAge());
    assertFalse(corsConfig.isCredentialsAllowed());
  }
  public void testCorsConfigWithBadRegex(){
    final Settings settings=Settings.builder().put(SETTING_CORS_ENABLED.getKey(),true).put(SETTING_CORS_ALLOW_ORIGIN.getKey(),"/[*/").put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(),true).build();
    SettingsException e=expectThrows(SettingsException.class,() -> Netty4HttpServerTransport.buildCorsConfig(settings));
    assertThat(e.getMessage(),containsString("Bad regex in [http.cors.allow-origin]: [/[*/]"));
    assertThat(e.getCause(),instanceOf(PatternSyntaxException.class));
  }
  /** 
 * Test that  {@link Netty4HttpServerTransport} supports the "Expect: 100-continue" HTTP header
 * @throws InterruptedException if the client communication with the server is interrupted
 */
  public void testExpectContinueHeader() throws InterruptedException {
    final Settings settings=Settings.EMPTY;
    final int contentLength=randomIntBetween(1,HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.get(settings).bytesAsInt());
    runExpectHeaderTest(settings,HttpHeaderValues.CONTINUE.toString(),contentLength,HttpResponseStatus.CONTINUE);
  }
  /** 
 * Test that  {@link Netty4HttpServerTransport} responds to a100-continue expectation with too large a content-length with a 413 status.
 * @throws InterruptedException if the client communication with the server is interrupted
 */
  public void testExpectContinueHeaderContentLengthTooLong() throws InterruptedException {
    final String key=HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.getKey();
    final int maxContentLength=randomIntBetween(1,104857600);
    final Settings settings=Settings.builder().put(key,maxContentLength + "b").build();
    final int contentLength=randomIntBetween(maxContentLength + 1,Integer.MAX_VALUE);
    runExpectHeaderTest(settings,HttpHeaderValues.CONTINUE.toString(),contentLength,HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE);
  }
  /** 
 * Test that  {@link Netty4HttpServerTransport} responds to an unsupported expectation with a 417 status.
 * @throws InterruptedException if the client communication with the server is interrupted
 */
  public void testExpectUnsupportedExpectation() throws InterruptedException {
    runExpectHeaderTest(Settings.EMPTY,"chocolate=yummy",0,HttpResponseStatus.EXPECTATION_FAILED);
  }
  private void runExpectHeaderTest(  final Settings settings,  final String expectation,  final int contentLength,  final HttpResponseStatus expectedStatus) throws InterruptedException {
    final HttpServerTransport.Dispatcher dispatcher=new HttpServerTransport.Dispatcher(){
      @Override public void dispatchRequest(      RestRequest request,      RestChannel channel,      ThreadContext threadContext){
        channel.sendResponse(new BytesRestResponse(OK,BytesRestResponse.TEXT_CONTENT_TYPE,new BytesArray("done")));
      }
      @Override public void dispatchBadRequest(      RestRequest request,      RestChannel channel,      ThreadContext threadContext,      Throwable cause){
        throw new AssertionError();
      }
    }
;
    try (Netty4HttpServerTransport transport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,xContentRegistry(),dispatcher)){
      transport.start();
      final TransportAddress remoteAddress=randomFrom(transport.boundAddress().boundAddresses());
      try (Netty4HttpClient client=new Netty4HttpClient()){
        final FullHttpRequest request=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.POST,"/");
        request.headers().set(HttpHeaderNames.EXPECT,expectation);
        HttpUtil.setContentLength(request,contentLength);
        final FullHttpResponse response=client.post(remoteAddress.address(),request);
        try {
          assertThat(response.status(),equalTo(expectedStatus));
          if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) {
            final FullHttpRequest continuationRequest=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.POST,"/",Unpooled.EMPTY_BUFFER);
            final FullHttpResponse continuationResponse=client.post(remoteAddress.address(),continuationRequest);
            try {
              assertThat(continuationResponse.status(),is(HttpResponseStatus.OK));
              assertThat(new String(ByteBufUtil.getBytes(continuationResponse.content()),StandardCharsets.UTF_8),is("done"));
            }
  finally {
              continuationResponse.release();
            }
          }
        }
  finally {
          response.release();
        }
      }
     }
   }
  public void testBindUnavailableAddress(){
    try (Netty4HttpServerTransport transport=new Netty4HttpServerTransport(Settings.EMPTY,networkService,bigArrays,threadPool,xContentRegistry(),new NullDispatcher())){
      transport.start();
      TransportAddress remoteAddress=randomFrom(transport.boundAddress().boundAddresses());
      Settings settings=Settings.builder().put("http.port",remoteAddress.getPort()).build();
      try (Netty4HttpServerTransport otherTransport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,xContentRegistry(),new NullDispatcher())){
        BindHttpException bindHttpException=expectThrows(BindHttpException.class,() -> otherTransport.start());
        assertEquals("Failed to bind to [" + remoteAddress.getPort() + "]",bindHttpException.getMessage());
      }
     }
   }
  public void testBadRequest() throws InterruptedException {
    final AtomicReference<Throwable> causeReference=new AtomicReference<>();
    final HttpServerTransport.Dispatcher dispatcher=new HttpServerTransport.Dispatcher(){
      @Override public void dispatchRequest(      final RestRequest request,      final RestChannel channel,      final ThreadContext threadContext){
        throw new AssertionError();
      }
      @Override public void dispatchBadRequest(      final RestRequest request,      final RestChannel channel,      final ThreadContext threadContext,      final Throwable cause){
        causeReference.set(cause);
        try {
          final ElasticsearchException e=new ElasticsearchException("you sent a bad request and you should feel bad");
          channel.sendResponse(new BytesRestResponse(channel,BAD_REQUEST,e));
        }
 catch (        final IOException e) {
          throw new AssertionError(e);
        }
      }
    }
;
    final Settings settings;
    final int maxInitialLineLength;
    final Setting<ByteSizeValue> httpMaxInitialLineLengthSetting=HttpTransportSettings.SETTING_HTTP_MAX_INITIAL_LINE_LENGTH;
    if (randomBoolean()) {
      maxInitialLineLength=httpMaxInitialLineLengthSetting.getDefault(Settings.EMPTY).bytesAsInt();
      settings=Settings.EMPTY;
    }
 else {
      maxInitialLineLength=randomIntBetween(1,8192);
      settings=Settings.builder().put(httpMaxInitialLineLengthSetting.getKey(),maxInitialLineLength + "b").build();
    }
    try (Netty4HttpServerTransport transport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,xContentRegistry(),dispatcher)){
      transport.start();
      final TransportAddress remoteAddress=randomFrom(transport.boundAddress.boundAddresses());
      try (Netty4HttpClient client=new Netty4HttpClient()){
        final String url="/" + new String(new byte[maxInitialLineLength],Charset.forName("UTF-8"));
        final FullHttpRequest request=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,url);
        final FullHttpResponse response=client.post(remoteAddress.address(),request);
        try {
          assertThat(response.status(),equalTo(HttpResponseStatus.BAD_REQUEST));
          assertThat(new String(response.content().array(),Charset.forName("UTF-8")),containsString("you sent a bad request and you should feel bad"));
        }
  finally {
          response.release();
        }
      }
     }
     assertNotNull(causeReference.get());
    assertThat(causeReference.get(),instanceOf(TooLongFrameException.class));
  }
  public void testDispatchDoesNotModifyThreadContext() throws InterruptedException {
    final HttpServerTransport.Dispatcher dispatcher=new HttpServerTransport.Dispatcher(){
      @Override public void dispatchRequest(      final RestRequest request,      final RestChannel channel,      final ThreadContext threadContext){
        threadContext.putHeader("foo","bar");
        threadContext.putTransient("bar","baz");
      }
      @Override public void dispatchBadRequest(      final RestRequest request,      final RestChannel channel,      final ThreadContext threadContext,      final Throwable cause){
        threadContext.putHeader("foo_bad","bar");
        threadContext.putTransient("bar_bad","baz");
      }
    }
;
    try (Netty4HttpServerTransport transport=new Netty4HttpServerTransport(Settings.EMPTY,networkService,bigArrays,threadPool,xContentRegistry(),dispatcher)){
      transport.start();
      transport.dispatchRequest(null,null);
      assertNull(threadPool.getThreadContext().getHeader("foo"));
      assertNull(threadPool.getThreadContext().getTransient("bar"));
      transport.dispatchBadRequest(null,null,null);
      assertNull(threadPool.getThreadContext().getHeader("foo_bad"));
      assertNull(threadPool.getThreadContext().getTransient("bar_bad"));
    }
   }
  public void testReadTimeout() throws Exception {
    final HttpServerTransport.Dispatcher dispatcher=new HttpServerTransport.Dispatcher(){
      @Override public void dispatchRequest(      final RestRequest request,      final RestChannel channel,      final ThreadContext threadContext){
        throw new AssertionError("Should not have received a dispatched request");
      }
      @Override public void dispatchBadRequest(      final RestRequest request,      final RestChannel channel,      final ThreadContext threadContext,      final Throwable cause){
        throw new AssertionError("Should not have received a dispatched request");
      }
    }
;
    Settings settings=Settings.builder().put(HttpTransportSettings.SETTING_HTTP_READ_TIMEOUT.getKey(),new TimeValue(randomIntBetween(100,300))).build();
    NioEventLoopGroup group=new NioEventLoopGroup();
    try (Netty4HttpServerTransport transport=new Netty4HttpServerTransport(settings,networkService,bigArrays,threadPool,xContentRegistry(),dispatcher)){
      transport.start();
      final TransportAddress remoteAddress=randomFrom(transport.boundAddress.boundAddresses());
      AtomicBoolean channelClosed=new AtomicBoolean(false);
      Bootstrap clientBootstrap=new Bootstrap().channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>(){
        @Override protected void initChannel(        SocketChannel ch){
          ch.pipeline().addLast(new ChannelHandlerAdapter(){
          }
);
        }
      }
).group(group);
      ChannelFuture connect=clientBootstrap.connect(remoteAddress.address());
      connect.channel().closeFuture().addListener(future -> channelClosed.set(true));
      assertBusy(() -> assertTrue("Channel should be closed due to read timeout",channelClosed.get()),5,TimeUnit.SECONDS);
    }
  finally {
      group.shutdownGracefully().await();
    }
  }
}
