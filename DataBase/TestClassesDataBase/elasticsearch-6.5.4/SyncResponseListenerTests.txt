public class SyncResponseListenerTests extends RestClientTestCase {
  /** 
 * Asserts that the provided  {@linkplain Exception} contains the methodthat called this <strong>somewhere</strong> on its stack. This is normally the case for synchronous calls but  {@link RestClient} performssynchronous calls by performing asynchronous calls and blocking the current thread until the call returns so it has to take special care to make sure that the caller shows up in the exception. We use this assertion to make sure that we don't break that "special care".
 */
  static void assertExceptionStackContainsCallingMethod(  Exception e){
    StackTraceElement myMethod=Thread.currentThread().getStackTrace()[2];
    for (    StackTraceElement se : e.getStackTrace()) {
      if (se.getClassName().equals(myMethod.getClassName()) && se.getMethodName().equals(myMethod.getMethodName())) {
        return;
      }
    }
    StringWriter stack=new StringWriter();
    e.printStackTrace(new PrintWriter(stack));
    fail("didn't find the calling method (looks like " + myMethod + ") in:\n"+ stack);
  }
  public void testOnSuccessNullResponse(){
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    try {
      syncResponseListener.onSuccess(null);
      fail("onSuccess should have failed");
    }
 catch (    NullPointerException e) {
      assertEquals("response must not be null",e.getMessage());
    }
  }
  public void testOnFailureNullException(){
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    try {
      syncResponseListener.onFailure(null);
      fail("onFailure should have failed");
    }
 catch (    NullPointerException e) {
      assertEquals("exception must not be null",e.getMessage());
    }
  }
  public void testOnSuccess() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    Response mockResponse=mockResponse();
    syncResponseListener.onSuccess(mockResponse);
    Response response=syncResponseListener.get();
    assertSame(response,mockResponse);
    try {
      syncResponseListener.onSuccess(mockResponse);
      fail("get should have failed");
    }
 catch (    IllegalStateException e) {
      assertEquals(e.getMessage(),"response is already set");
    }
    response=syncResponseListener.get();
    assertSame(response,mockResponse);
  }
  public void testOnFailure() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    RuntimeException firstException=new RuntimeException("first-test");
    syncResponseListener.onFailure(firstException);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    RuntimeException e) {
      assertEquals(firstException.getMessage(),e.getMessage());
      assertSame(firstException,e.getCause());
    }
    RuntimeException secondException=new RuntimeException("second-test");
    try {
      syncResponseListener.onFailure(secondException);
    }
 catch (    IllegalStateException e) {
      assertEquals(e.getMessage(),"exception is already set");
    }
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    RuntimeException e) {
      assertEquals(firstException.getMessage(),e.getMessage());
      assertSame(firstException,e.getCause());
    }
    Response response=mockResponse();
    syncResponseListener.onSuccess(response);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    IllegalStateException e) {
      assertEquals("response and exception are unexpectedly set at the same time",e.getMessage());
      assertNotNull(e.getSuppressed());
      assertEquals(1,e.getSuppressed().length);
      assertSame(firstException,e.getSuppressed()[0]);
    }
  }
  public void testRuntimeIsBuiltCorrectly() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    RuntimeException runtimeException=new RuntimeException();
    syncResponseListener.onFailure(runtimeException);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    RuntimeException e) {
      assertSame(runtimeException,e.getCause());
      assertEquals(runtimeException.getMessage(),e.getMessage());
      assertExceptionStackContainsCallingMethod(e);
    }
  }
  public void testConnectTimeoutExceptionIsBuiltCorrectly() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    ConnectTimeoutException timeoutException=new ConnectTimeoutException();
    syncResponseListener.onFailure(timeoutException);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    IOException e) {
      assertSame(timeoutException,e.getCause());
      assertEquals(timeoutException.getMessage(),e.getMessage());
      assertExceptionStackContainsCallingMethod(e);
    }
  }
  public void testSocketTimeoutExceptionIsBuiltCorrectly() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    SocketTimeoutException timeoutException=new SocketTimeoutException();
    syncResponseListener.onFailure(timeoutException);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    IOException e) {
      assertSame(timeoutException,e.getCause());
      assertEquals(timeoutException.getMessage(),e.getMessage());
      assertExceptionStackContainsCallingMethod(e);
    }
  }
  public void testConnectionClosedExceptionIsWrapped() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    ConnectionClosedException closedException=new ConnectionClosedException(randomAsciiAlphanumOfLength(5));
    syncResponseListener.onFailure(closedException);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    ConnectionClosedException e) {
      assertSame(closedException,e.getCause());
      assertEquals(closedException.getMessage(),e.getMessage());
      assertExceptionStackContainsCallingMethod(e);
    }
  }
  public void testSSLHandshakeExceptionIsWrapped() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    SSLHandshakeException exception=new SSLHandshakeException(randomAsciiAlphanumOfLength(5));
    syncResponseListener.onFailure(exception);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    SSLHandshakeException e) {
      assertSame(exception,e.getCause());
      assertEquals(exception.getMessage(),e.getMessage());
      assertExceptionStackContainsCallingMethod(e);
    }
  }
  public void testIOExceptionIsBuiltCorrectly() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    IOException ioException=new IOException();
    syncResponseListener.onFailure(ioException);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    IOException e) {
      assertSame(ioException,e.getCause());
      assertEquals(ioException.getMessage(),e.getMessage());
      assertExceptionStackContainsCallingMethod(e);
    }
  }
  public void testExceptionIsWrapped() throws Exception {
    RestClient.SyncResponseListener syncResponseListener=new RestClient.SyncResponseListener(10000);
    URISyntaxException exception=new URISyntaxException("test","test");
    syncResponseListener.onFailure(exception);
    try {
      syncResponseListener.get();
      fail("get should have failed");
    }
 catch (    RuntimeException e) {
      assertEquals("error while performing request",e.getMessage());
      assertSame(exception,e.getCause());
      assertExceptionStackContainsCallingMethod(e);
    }
  }
  private static Response mockResponse(){
    ProtocolVersion protocolVersion=new ProtocolVersion("HTTP",1,1);
    RequestLine requestLine=new BasicRequestLine("GET","/",protocolVersion);
    StatusLine statusLine=new BasicStatusLine(protocolVersion,200,"OK");
    HttpResponse httpResponse=new BasicHttpResponse(statusLine);
    return new Response(requestLine,new HttpHost("localhost",9200),httpResponse);
  }
}
