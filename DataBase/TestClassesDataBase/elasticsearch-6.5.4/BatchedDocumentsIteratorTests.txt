public class BatchedDocumentsIteratorTests extends ESTestCase {
  private static final String INDEX_NAME=".ml-anomalies-foo";
  private static final String SCROLL_ID="someScrollId";
  private Client client;
  private boolean wasScrollCleared;
  private TestIterator testIterator;
  private ArgumentCaptor<SearchRequest> searchRequestCaptor=ArgumentCaptor.forClass(SearchRequest.class);
  private ArgumentCaptor<SearchScrollRequest> searchScrollRequestCaptor=ArgumentCaptor.forClass(SearchScrollRequest.class);
  @Before public void setUpMocks(){
    client=Mockito.mock(Client.class);
    wasScrollCleared=false;
    testIterator=new TestIterator(client,INDEX_NAME);
    givenClearScrollRequest();
  }
  public void testQueryReturnsNoResults(){
    new ScrollResponsesMocker().finishMock();
    assertTrue(testIterator.hasNext());
    assertTrue(testIterator.next().isEmpty());
    assertFalse(testIterator.hasNext());
    assertTrue(wasScrollCleared);
    assertSearchRequest();
    assertSearchScrollRequests(0);
  }
  public void testCallingNextWhenHasNextIsFalseThrows(){
    new ScrollResponsesMocker().addBatch(createJsonDoc("a"),createJsonDoc("b"),createJsonDoc("c")).finishMock();
    testIterator.next();
    assertFalse(testIterator.hasNext());
    ESTestCase.expectThrows(NoSuchElementException.class,() -> testIterator.next());
  }
  public void testQueryReturnsSingleBatch(){
    new ScrollResponsesMocker().addBatch(createJsonDoc("a"),createJsonDoc("b"),createJsonDoc("c")).finishMock();
    assertTrue(testIterator.hasNext());
    Deque<String> batch=testIterator.next();
    assertEquals(3,batch.size());
    assertTrue(batch.containsAll(Arrays.asList(createJsonDoc("a"),createJsonDoc("b"),createJsonDoc("c"))));
    assertFalse(testIterator.hasNext());
    assertTrue(wasScrollCleared);
    assertSearchRequest();
    assertSearchScrollRequests(0);
  }
  public void testQueryReturnsThreeBatches(){
    new ScrollResponsesMocker().addBatch(createJsonDoc("a"),createJsonDoc("b"),createJsonDoc("c")).addBatch(createJsonDoc("d"),createJsonDoc("e")).addBatch(createJsonDoc("f")).finishMock();
    assertTrue(testIterator.hasNext());
    Deque<String> batch=testIterator.next();
    assertEquals(3,batch.size());
    assertTrue(batch.containsAll(Arrays.asList(createJsonDoc("a"),createJsonDoc("b"),createJsonDoc("c"))));
    batch=testIterator.next();
    assertEquals(2,batch.size());
    assertTrue(batch.containsAll(Arrays.asList(createJsonDoc("d"),createJsonDoc("e"))));
    batch=testIterator.next();
    assertEquals(1,batch.size());
    assertTrue(batch.containsAll(Collections.singletonList(createJsonDoc("f"))));
    assertFalse(testIterator.hasNext());
    assertTrue(wasScrollCleared);
    assertSearchRequest();
    assertSearchScrollRequests(2);
  }
  private String createJsonDoc(  String value){
    return "{\"foo\":\"" + value + "\"}";
  }
  private void givenClearScrollRequest(){
    ClearScrollRequestBuilder requestBuilder=mock(ClearScrollRequestBuilder.class);
    when(client.prepareClearScroll()).thenReturn(requestBuilder);
    when(requestBuilder.setScrollIds(Collections.singletonList(SCROLL_ID))).thenReturn(requestBuilder);
    when(requestBuilder.get()).thenAnswer((invocation) -> {
      wasScrollCleared=true;
      return null;
    }
);
  }
  private void assertSearchRequest(){
    List<SearchRequest> searchRequests=searchRequestCaptor.getAllValues();
    assertThat(searchRequests.size(),equalTo(1));
    SearchRequest searchRequest=searchRequests.get(0);
    assertThat(searchRequest.indices(),equalTo(new String[]{INDEX_NAME}));
    assertThat(searchRequest.scroll().keepAlive(),equalTo(TimeValue.timeValueMinutes(5)));
    assertThat(searchRequest.types().length,equalTo(0));
    assertThat(searchRequest.source().query(),equalTo(QueryBuilders.matchAllQuery()));
  }
  private void assertSearchScrollRequests(  int expectedCount){
    List<SearchScrollRequest> searchScrollRequests=searchScrollRequestCaptor.getAllValues();
    assertThat(searchScrollRequests.size(),equalTo(expectedCount));
    for (    SearchScrollRequest request : searchScrollRequests) {
      assertThat(request.scrollId(),equalTo(SCROLL_ID));
      assertThat(request.scroll().keepAlive(),equalTo(TimeValue.timeValueMinutes(5)));
    }
  }
private class ScrollResponsesMocker {
    private List<String[]> batches=new ArrayList<>();
    private long totalHits=0;
    private List<SearchResponse> responses=new ArrayList<>();
    ScrollResponsesMocker addBatch(    String... hits){
      totalHits+=hits.length;
      batches.add(hits);
      return this;
    }
    @SuppressWarnings("unchecked") void finishMock(){
      if (batches.isEmpty()) {
        givenInitialResponse();
        return;
      }
      givenInitialResponse(batches.get(0));
      for (int i=1; i < batches.size(); ++i) {
        givenNextResponse(batches.get(i));
      }
      if (responses.size() > 0) {
        ActionFuture<SearchResponse> first=wrapResponse(responses.get(0));
        if (responses.size() > 1) {
          List<ActionFuture> rest=new ArrayList<>();
          for (int i=1; i < responses.size(); ++i) {
            rest.add(wrapResponse(responses.get(i)));
          }
          when(client.searchScroll(searchScrollRequestCaptor.capture())).thenReturn(first,rest.toArray(new ActionFuture[rest.size() - 1]));
        }
 else {
          when(client.searchScroll(searchScrollRequestCaptor.capture())).thenReturn(first);
        }
      }
    }
    private void givenInitialResponse(    String... hits){
      SearchResponse searchResponse=createSearchResponseWithHits(hits);
      ActionFuture<SearchResponse> future=wrapResponse(searchResponse);
      when(future.actionGet()).thenReturn(searchResponse);
      when(client.search(searchRequestCaptor.capture())).thenReturn(future);
    }
    @SuppressWarnings("unchecked") private ActionFuture<SearchResponse> wrapResponse(    SearchResponse searchResponse){
      ActionFuture<SearchResponse> future=mock(ActionFuture.class);
      when(future.actionGet()).thenReturn(searchResponse);
      return future;
    }
    private void givenNextResponse(    String... hits){
      responses.add(createSearchResponseWithHits(hits));
    }
    private SearchResponse createSearchResponseWithHits(    String... hits){
      SearchHits searchHits=createHits(hits);
      SearchResponse searchResponse=mock(SearchResponse.class);
      when(searchResponse.getScrollId()).thenReturn(SCROLL_ID);
      when(searchResponse.getHits()).thenReturn(searchHits);
      return searchResponse;
    }
    private SearchHits createHits(    String... values){
      List<SearchHit> hits=new ArrayList<>();
      for (      String value : values) {
        hits.add(new SearchHitBuilder(randomInt()).setSource(value).build());
      }
      return new SearchHits(hits.toArray(new SearchHit[hits.size()]),totalHits,1.0f);
    }
  }
private static class TestIterator extends BatchedDocumentsIterator<String> {
    TestIterator(    Client client,    String jobId){
      super(client,jobId);
    }
    @Override protected QueryBuilder getQuery(){
      return QueryBuilders.matchAllQuery();
    }
    @Override protected String map(    SearchHit hit){
      return hit.getSourceAsString();
    }
  }
}
