/** 
 * Tests  {@link ClusterAlertsUtil}.
 */
public class ClusterAlertsUtilTests extends ESTestCase {
  private final ClusterService clusterService=mock(ClusterService.class);
  private final ClusterState clusterState=mock(ClusterState.class);
  private final MetaData metaData=mock(MetaData.class);
  private final String clusterUuid=randomAlphaOfLength(16);
  @Before public void setup(){
    when(clusterService.state()).thenReturn(clusterState);
    when(clusterState.metaData()).thenReturn(metaData);
    when(metaData.clusterUUID()).thenReturn(clusterUuid);
  }
  public void testWatchIdsAreAllUnique(){
    final List<String> watchIds=Arrays.asList(ClusterAlertsUtil.WATCH_IDS);
    assertThat(watchIds,hasSize(new HashSet<>(watchIds).size()));
  }
  public void testCreateUniqueWatchId(){
    final String watchId=randomFrom(ClusterAlertsUtil.WATCH_IDS);
    final String uniqueWatchId=ClusterAlertsUtil.createUniqueWatchId(clusterService,watchId);
    assertThat(uniqueWatchId,equalTo(clusterUuid + "_" + watchId));
  }
  public void testLoadWatch(){
    for (    final String watchId : ClusterAlertsUtil.WATCH_IDS) {
      final String watch=ClusterAlertsUtil.loadWatch(clusterService,watchId);
      assertThat(watch,notNullValue());
      assertThat(watch,containsString(clusterUuid));
      assertThat(watch,containsString(watchId));
      if ("elasticsearch_nodes".equals(watchId) == false) {
        assertThat(watch,containsString(clusterUuid + "_" + watchId));
      }
      assertThat(XContentHelper.convertToMap(XContentType.JSON.xContent(),watch,false),notNullValue());
    }
  }
  public void testLoadWatchFails(){
    expectThrows(RuntimeException.class,() -> ClusterAlertsUtil.loadWatch(clusterService,"watch-does-not-exist"));
  }
  public void testGetClusterAlertsBlacklistThrowsForUnknownWatchId(){
    final List<String> watchIds=Arrays.asList(ClusterAlertsUtil.WATCH_IDS);
    final List<String> blacklist=randomSubsetOf(watchIds);
    blacklist.add("fake1");
    if (randomBoolean()) {
      blacklist.add("fake2");
      if (rarely()) {
        blacklist.add("fake3");
      }
    }
    final Set<String> unknownIds=blacklist.stream().filter(id -> watchIds.contains(id) == false).collect(Collectors.toSet());
    final String unknownIdsString=String.join(", ",unknownIds);
    final SettingsException exception=expectThrows(SettingsException.class,() -> ClusterAlertsUtil.getClusterAlertsBlacklist(createConfigWithBlacklist("_random",blacklist)));
    assertThat(exception.getMessage(),equalTo("[xpack.monitoring.exporters._random.cluster_alerts.management.blacklist] contains unrecognized Cluster " + "Alert IDs [" + unknownIdsString + "]"));
  }
  public void testGetClusterAlertsBlacklist(){
    final List<String> blacklist=randomSubsetOf(Arrays.asList(ClusterAlertsUtil.WATCH_IDS));
    assertThat(blacklist,equalTo(ClusterAlertsUtil.getClusterAlertsBlacklist(createConfigWithBlacklist("any",blacklist))));
  }
  private Exporter.Config createConfigWithBlacklist(  final String name,  final List<String> blacklist){
    final Settings settings=Settings.builder().putList("xpack.monitoring.exporters." + name + ".cluster_alerts.management.blacklist",blacklist).build();
    final ClusterService clusterService=mock(ClusterService.class);
    final XPackLicenseState licenseState=mock(XPackLicenseState.class);
    return new Exporter.Config(name,"local",settings,clusterService,licenseState);
  }
}
