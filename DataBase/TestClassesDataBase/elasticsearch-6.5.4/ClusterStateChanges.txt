public class ClusterStateChanges extends AbstractComponent {
  private final AllocationService allocationService;
  private final ClusterService clusterService;
  private final ShardStateAction.ShardFailedClusterStateTaskExecutor shardFailedClusterStateTaskExecutor;
  private final ShardStateAction.ShardStartedClusterStateTaskExecutor shardStartedClusterStateTaskExecutor;
  private final TransportCloseIndexAction transportCloseIndexAction;
  private final TransportOpenIndexAction transportOpenIndexAction;
  private final TransportDeleteIndexAction transportDeleteIndexAction;
  private final TransportUpdateSettingsAction transportUpdateSettingsAction;
  private final TransportClusterRerouteAction transportClusterRerouteAction;
  private final TransportCreateIndexAction transportCreateIndexAction;
  private final ZenDiscovery.NodeRemovalClusterStateTaskExecutor nodeRemovalExecutor;
  private final NodeJoinController.JoinTaskExecutor joinTaskExecutor;
  public ClusterStateChanges(  NamedXContentRegistry xContentRegistry,  ThreadPool threadPool){
    super(Settings.builder().put(PATH_HOME_SETTING.getKey(),"dummy").build());
    ClusterSettings clusterSettings=new ClusterSettings(settings,ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
    allocationService=new AllocationService(settings,new AllocationDeciders(settings,new HashSet<>(Arrays.asList(new SameShardAllocationDecider(settings,clusterSettings),new ReplicaAfterPrimaryActiveAllocationDecider(settings),new RandomAllocationDeciderTests.RandomAllocationDecider(getRandom())))),new TestGatewayAllocator(),new BalancedShardsAllocator(settings),EmptyClusterInfoService.INSTANCE);
    shardFailedClusterStateTaskExecutor=new ShardStateAction.ShardFailedClusterStateTaskExecutor(allocationService,null,logger);
    shardStartedClusterStateTaskExecutor=new ShardStateAction.ShardStartedClusterStateTaskExecutor(allocationService,logger);
    ActionFilters actionFilters=new ActionFilters(Collections.emptySet());
    IndexNameExpressionResolver indexNameExpressionResolver=new IndexNameExpressionResolver(settings);
    DestructiveOperations destructiveOperations=new DestructiveOperations(settings,clusterSettings);
    Environment environment=TestEnvironment.newEnvironment(settings);
    Transport transport=mock(Transport.class);
    clusterService=mock(ClusterService.class);
    when(clusterService.getClusterSettings()).thenReturn(clusterSettings);
    IndicesService indicesService=mock(IndicesService.class);
    try {
      @SuppressWarnings("unchecked") final List<IndexEventListener> listeners=anyList();
      when(indicesService.createIndex(any(IndexMetaData.class),listeners)).then(invocationOnMock -> {
        IndexService indexService=mock(IndexService.class);
        IndexMetaData indexMetaData=(IndexMetaData)invocationOnMock.getArguments()[0];
        when(indexService.index()).thenReturn(indexMetaData.getIndex());
        MapperService mapperService=mock(MapperService.class);
        when(indexService.mapperService()).thenReturn(mapperService);
        when(mapperService.docMappers(anyBoolean())).thenReturn(Collections.emptyList());
        when(indexService.getIndexEventListener()).thenReturn(new IndexEventListener(){
        }
);
        when(indexService.getIndexSortSupplier()).thenReturn(() -> null);
        return indexService;
      }
);
    }
 catch (    IOException e) {
      throw new IllegalStateException(e);
    }
    TransportService transportService=new TransportService(settings,transport,threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,boundAddress -> DiscoveryNode.createLocal(settings,boundAddress.publishAddress(),UUIDs.randomBase64UUID()),clusterSettings,Collections.emptySet());
    MetaDataIndexUpgradeService metaDataIndexUpgradeService=new MetaDataIndexUpgradeService(settings,xContentRegistry,null,null,null){
      @Override public IndexMetaData upgradeIndexMetaData(      IndexMetaData indexMetaData,      Version minimumIndexCompatibilityVersion){
        return indexMetaData;
      }
    }
;
    MetaDataIndexStateService indexStateService=new MetaDataIndexStateService(settings,clusterService,allocationService,metaDataIndexUpgradeService,indicesService,threadPool);
    MetaDataDeleteIndexService deleteIndexService=new MetaDataDeleteIndexService(settings,clusterService,allocationService);
    MetaDataUpdateSettingsService metaDataUpdateSettingsService=new MetaDataUpdateSettingsService(settings,clusterService,allocationService,IndexScopedSettings.DEFAULT_SCOPED_SETTINGS,indicesService,threadPool);
    MetaDataCreateIndexService createIndexService=new MetaDataCreateIndexService(settings,clusterService,indicesService,allocationService,new AliasValidator(settings),environment,IndexScopedSettings.DEFAULT_SCOPED_SETTINGS,threadPool,xContentRegistry,true);
    transportCloseIndexAction=new TransportCloseIndexAction(settings,transportService,clusterService,threadPool,indexStateService,clusterSettings,actionFilters,indexNameExpressionResolver,destructiveOperations);
    transportOpenIndexAction=new TransportOpenIndexAction(settings,transportService,clusterService,threadPool,indexStateService,actionFilters,indexNameExpressionResolver,destructiveOperations);
    transportDeleteIndexAction=new TransportDeleteIndexAction(settings,transportService,clusterService,threadPool,deleteIndexService,actionFilters,indexNameExpressionResolver,destructiveOperations);
    transportUpdateSettingsAction=new TransportUpdateSettingsAction(settings,transportService,clusterService,threadPool,metaDataUpdateSettingsService,actionFilters,indexNameExpressionResolver);
    transportClusterRerouteAction=new TransportClusterRerouteAction(settings,transportService,clusterService,threadPool,allocationService,actionFilters,indexNameExpressionResolver);
    transportCreateIndexAction=new TransportCreateIndexAction(settings,transportService,clusterService,threadPool,createIndexService,actionFilters,indexNameExpressionResolver);
    ElectMasterService electMasterService=new ElectMasterService(settings);
    nodeRemovalExecutor=new ZenDiscovery.NodeRemovalClusterStateTaskExecutor(allocationService,electMasterService,s -> {
      throw new AssertionError("rejoin not implemented");
    }
,logger);
    joinTaskExecutor=new NodeJoinController.JoinTaskExecutor(allocationService,electMasterService,logger);
  }
  public ClusterState createIndex(  ClusterState state,  CreateIndexRequest request){
    return execute(transportCreateIndexAction,request,state);
  }
  public ClusterState closeIndices(  ClusterState state,  CloseIndexRequest request){
    return execute(transportCloseIndexAction,request,state);
  }
  public ClusterState openIndices(  ClusterState state,  OpenIndexRequest request){
    return execute(transportOpenIndexAction,request,state);
  }
  public ClusterState deleteIndices(  ClusterState state,  DeleteIndexRequest request){
    return execute(transportDeleteIndexAction,request,state);
  }
  public ClusterState updateSettings(  ClusterState state,  UpdateSettingsRequest request){
    return execute(transportUpdateSettingsAction,request,state);
  }
  public ClusterState reroute(  ClusterState state,  ClusterRerouteRequest request){
    return execute(transportClusterRerouteAction,request,state);
  }
  public ClusterState addNodes(  ClusterState clusterState,  List<DiscoveryNode> nodes){
    return runTasks(joinTaskExecutor,clusterState,nodes);
  }
  public ClusterState joinNodesAndBecomeMaster(  ClusterState clusterState,  List<DiscoveryNode> nodes){
    List<DiscoveryNode> joinNodes=new ArrayList<>();
    joinNodes.add(NodeJoinController.BECOME_MASTER_TASK);
    joinNodes.add(NodeJoinController.FINISH_ELECTION_TASK);
    joinNodes.addAll(nodes);
    return runTasks(joinTaskExecutor,clusterState,joinNodes);
  }
  public ClusterState removeNodes(  ClusterState clusterState,  List<DiscoveryNode> nodes){
    return runTasks(nodeRemovalExecutor,clusterState,nodes.stream().map(n -> new ZenDiscovery.NodeRemovalClusterStateTaskExecutor.Task(n,"dummy reason")).collect(Collectors.toList()));
  }
  public ClusterState applyFailedShards(  ClusterState clusterState,  List<FailedShard> failedShards){
    List<FailedShardEntry> entries=failedShards.stream().map(failedShard -> new FailedShardEntry(failedShard.getRoutingEntry().shardId(),failedShard.getRoutingEntry().allocationId().getId(),0L,failedShard.getMessage(),failedShard.getFailure(),failedShard.markAsStale())).collect(Collectors.toList());
    return runTasks(shardFailedClusterStateTaskExecutor,clusterState,entries);
  }
  public ClusterState applyStartedShards(  ClusterState clusterState,  List<ShardRouting> startedShards){
    List<StartedShardEntry> entries=startedShards.stream().map(startedShard -> new StartedShardEntry(startedShard.shardId(),startedShard.allocationId().getId(),"shard started")).collect(Collectors.toList());
    return runTasks(shardStartedClusterStateTaskExecutor,clusterState,entries);
  }
  private <T>ClusterState runTasks(  ClusterStateTaskExecutor<T> executor,  ClusterState clusterState,  List<T> entries){
    try {
      ClusterTasksResult<T> result=executor.execute(clusterState,entries);
      for (      ClusterStateTaskExecutor.TaskResult taskResult : result.executionResults.values()) {
        if (taskResult.isSuccess() == false) {
          throw taskResult.getFailure();
        }
      }
      return result.resultingState;
    }
 catch (    Exception e) {
      throw ExceptionsHelper.convertToRuntime(e);
    }
  }
  private <Request extends MasterNodeRequest<Request>,Response extends ActionResponse>ClusterState execute(  TransportMasterNodeAction<Request,Response> masterNodeAction,  Request request,  ClusterState clusterState){
    return executeClusterStateUpdateTask(clusterState,() -> {
      try {
        TransportMasterNodeActionUtils.runMasterOperation(masterNodeAction,request,clusterState,new PlainActionFuture<>());
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
);
  }
  private ClusterState executeClusterStateUpdateTask(  ClusterState state,  Runnable runnable){
    ClusterState[] result=new ClusterState[1];
    doAnswer(invocationOnMock -> {
      ClusterStateUpdateTask task=(ClusterStateUpdateTask)invocationOnMock.getArguments()[1];
      result[0]=task.execute(state);
      return null;
    }
).when(clusterService).submitStateUpdateTask(anyString(),any(ClusterStateUpdateTask.class));
    runnable.run();
    assertThat(result[0],notNullValue());
    return result[0];
  }
}
