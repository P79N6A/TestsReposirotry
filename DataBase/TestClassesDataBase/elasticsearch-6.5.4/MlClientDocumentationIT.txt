public class MlClientDocumentationIT extends ESRestHighLevelClientTestCase {
  @After public void cleanUp() throws IOException {
    new MlTestStateCleaner(logger,highLevelClient().machineLearning()).clearMlMetadata();
  }
  public void testCreateJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Detector.Builder detectorBuilder=new Detector.Builder().setFunction("sum").setFieldName("total").setDetectorDescription("Sum of total");
    List<Detector> detectors=Collections.singletonList(detectorBuilder.build());
    AnalysisConfig.Builder analysisConfigBuilder=new AnalysisConfig.Builder(detectors).setBucketSpan(TimeValue.timeValueMinutes(10));
    DataDescription.Builder dataDescriptionBuilder=new DataDescription.Builder().setTimeField("timestamp");
{
      String id="job_1";
      Job.Builder jobBuilder=new Job.Builder(id).setAnalysisConfig(analysisConfigBuilder).setDataDescription(dataDescriptionBuilder).setDescription("Total sum of requests");
      PutJobRequest request=new PutJobRequest(jobBuilder.build());
      PutJobResponse response=client.machineLearning().putJob(request,RequestOptions.DEFAULT);
      Date createTime=response.getResponse().getCreateTime();
      assertThat(createTime.getTime(),greaterThan(0L));
    }
{
      String id="job_2";
      Job.Builder jobBuilder=new Job.Builder(id).setAnalysisConfig(analysisConfigBuilder).setDataDescription(dataDescriptionBuilder).setDescription("Total sum of requests");
      PutJobRequest request=new PutJobRequest(jobBuilder.build());
      ActionListener<PutJobResponse> listener=new ActionListener<PutJobResponse>(){
        @Override public void onResponse(        PutJobResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().putJobAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("get-machine-learning-job1");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    Job secondJob=MachineLearningIT.buildJob("get-machine-learning-job2");
    client.machineLearning().putJob(new PutJobRequest(secondJob),RequestOptions.DEFAULT);
{
      GetJobRequest request=new GetJobRequest("get-machine-learning-job1","get-machine-learning-job*");
      request.setAllowNoJobs(true);
      GetJobResponse response=client.machineLearning().getJob(request,RequestOptions.DEFAULT);
      long numberOfJobs=response.count();
      List<Job> jobs=response.jobs();
      assertEquals(2,response.count());
      assertThat(response.jobs(),hasSize(2));
      assertThat(response.jobs().stream().map(Job::getId).collect(Collectors.toList()),containsInAnyOrder(job.getId(),secondJob.getId()));
    }
{
      GetJobRequest request=new GetJobRequest("get-machine-learning-job1","get-machine-learning-job*");
      ActionListener<GetJobResponse> listener=new ActionListener<GetJobResponse>(){
        @Override public void onResponse(        GetJobResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getJobAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testDeleteJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
    String jobId="my-first-machine-learning-job";
    Job job=MachineLearningIT.buildJob(jobId);
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    Job secondJob=MachineLearningIT.buildJob("my-second-machine-learning-job");
    client.machineLearning().putJob(new PutJobRequest(secondJob),RequestOptions.DEFAULT);
{
      DeleteJobRequest deleteJobRequest=new DeleteJobRequest("my-first-machine-learning-job");
      deleteJobRequest.setForce(false);
      deleteJobRequest.setWaitForCompletion(true);
      DeleteJobResponse deleteJobResponse=client.machineLearning().deleteJob(deleteJobRequest,RequestOptions.DEFAULT);
      Boolean isAcknowledged=deleteJobResponse.getAcknowledged();
      TaskId task=deleteJobResponse.getTask();
      assertTrue(isAcknowledged);
      assertNull(task);
    }
{
      ActionListener<DeleteJobResponse> listener=new ActionListener<DeleteJobResponse>(){
        @Override public void onResponse(        DeleteJobResponse deleteJobResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      DeleteJobRequest deleteJobRequest=new DeleteJobRequest("my-second-machine-learning-job");
      client.machineLearning().deleteJobAsync(deleteJobRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testOpenJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("opening-my-first-machine-learning-job");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    Job secondJob=MachineLearningIT.buildJob("opening-my-second-machine-learning-job");
    client.machineLearning().putJob(new PutJobRequest(secondJob),RequestOptions.DEFAULT);
{
      OpenJobRequest openJobRequest=new OpenJobRequest("opening-my-first-machine-learning-job");
      openJobRequest.setTimeout(TimeValue.timeValueMinutes(10));
      OpenJobResponse openJobResponse=client.machineLearning().openJob(openJobRequest,RequestOptions.DEFAULT);
      boolean isOpened=openJobResponse.isOpened();
    }
{
      ActionListener<OpenJobResponse> listener=new ActionListener<OpenJobResponse>(){
        @Override public void onResponse(        OpenJobResponse openJobResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      OpenJobRequest openJobRequest=new OpenJobRequest("opening-my-second-machine-learning-job");
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().openJobAsync(openJobRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testCloseJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
{
      Job job=MachineLearningIT.buildJob("closing-my-first-machine-learning-job");
      client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
      client.machineLearning().openJob(new OpenJobRequest(job.getId()),RequestOptions.DEFAULT);
      CloseJobRequest closeJobRequest=new CloseJobRequest("closing-my-first-machine-learning-job","otherjobs*");
      closeJobRequest.setForce(false);
      closeJobRequest.setAllowNoJobs(true);
      closeJobRequest.setTimeout(TimeValue.timeValueMinutes(10));
      CloseJobResponse closeJobResponse=client.machineLearning().closeJob(closeJobRequest,RequestOptions.DEFAULT);
      boolean isClosed=closeJobResponse.isClosed();
    }
{
      Job job=MachineLearningIT.buildJob("closing-my-second-machine-learning-job");
      client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
      client.machineLearning().openJob(new OpenJobRequest(job.getId()),RequestOptions.DEFAULT);
      ActionListener<CloseJobResponse> listener=new ActionListener<CloseJobResponse>(){
        @Override public void onResponse(        CloseJobResponse closeJobResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      CloseJobRequest closeJobRequest=new CloseJobRequest("closing-my-second-machine-learning-job");
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().closeJobAsync(closeJobRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testUpdateJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
    String jobId="test-update-job";
    Job tempJob=MachineLearningIT.buildJob(jobId);
    Job job=new Job.Builder(tempJob).setAnalysisConfig(new AnalysisConfig.Builder(tempJob.getAnalysisConfig()).setCategorizationFieldName("categorization-field").setDetector(0,new Detector.Builder().setFieldName("total").setFunction("sum").setPartitionFieldName("mlcategory").setDetectorDescription(randomAlphaOfLength(10)).build())).build();
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
{
      List<DetectionRule> detectionRules=Arrays.asList(new DetectionRule.Builder(Arrays.asList(RuleCondition.createTime(Operator.GT,100L))).build());
      Map<String,Object> customSettings=new HashMap<>();
      customSettings.put("custom-setting-1","custom-value");
      JobUpdate.DetectorUpdate detectorUpdate=new JobUpdate.DetectorUpdate(0,"detector description",detectionRules);
      JobUpdate update=new JobUpdate.Builder(jobId).setDescription("My description").setAnalysisLimits(new AnalysisLimits(1000L,null)).setBackgroundPersistInterval(TimeValue.timeValueHours(3)).setCategorizationFilters(Arrays.asList("categorization-filter")).setDetectorUpdates(Arrays.asList(detectorUpdate)).setGroups(Arrays.asList("job-group-1")).setResultsRetentionDays(10L).setModelPlotConfig(new ModelPlotConfig(true,null)).setModelSnapshotRetentionDays(7L).setCustomSettings(customSettings).setRenormalizationWindowDays(3L).build();
      UpdateJobRequest updateJobRequest=new UpdateJobRequest(update);
      PutJobResponse updateJobResponse=client.machineLearning().updateJob(updateJobRequest,RequestOptions.DEFAULT);
      Job updatedJob=updateJobResponse.getResponse();
      assertEquals(update.getDescription(),updatedJob.getDescription());
    }
{
      ActionListener<PutJobResponse> listener=new ActionListener<PutJobResponse>(){
        @Override public void onResponse(        PutJobResponse updateJobResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      UpdateJobRequest updateJobRequest=new UpdateJobRequest(new JobUpdate.Builder(jobId).build());
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().updateJobAsync(updateJobRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testPutDatafeed() throws Exception {
    RestHighLevelClient client=highLevelClient();
{
      String jobId="put-datafeed-job-1";
      Job job=MachineLearningIT.buildJob(jobId);
      client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
      String id="datafeed-1";
      DatafeedConfig.Builder datafeedBuilder=new DatafeedConfig.Builder(id,jobId).setIndices("index_1","index_2");
      AggregatorFactories.Builder aggs=AggregatorFactories.builder();
      datafeedBuilder.setAggregations(aggs);
      datafeedBuilder.setAggregations((String)null);
      datafeedBuilder.setChunkingConfig(ChunkingConfig.newAuto());
      datafeedBuilder.setFrequency(TimeValue.timeValueSeconds(30));
      datafeedBuilder.setQuery(QueryBuilders.matchAllQuery());
      datafeedBuilder.setQueryDelay(TimeValue.timeValueMinutes(1));
      List<SearchSourceBuilder.ScriptField> scriptFields=Collections.emptyList();
      datafeedBuilder.setScriptFields(scriptFields);
      datafeedBuilder.setScrollSize(1000);
      PutDatafeedRequest request=new PutDatafeedRequest(datafeedBuilder.build());
      PutDatafeedResponse response=client.machineLearning().putDatafeed(request,RequestOptions.DEFAULT);
      DatafeedConfig datafeed=response.getResponse();
      assertThat(datafeed.getId(),equalTo("datafeed-1"));
    }
{
      String jobId="put-datafeed-job-2";
      Job job=MachineLearningIT.buildJob(jobId);
      client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
      String id="datafeed-2";
      DatafeedConfig datafeed=new DatafeedConfig.Builder(id,jobId).setIndices("index_1","index_2").build();
      PutDatafeedRequest request=new PutDatafeedRequest(datafeed);
      ActionListener<PutDatafeedResponse> listener=new ActionListener<PutDatafeedResponse>(){
        @Override public void onResponse(        PutDatafeedResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().putDatafeedAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetDatafeed() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("get-datafeed-job");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    String datafeedId=job.getId() + "-feed";
    DatafeedConfig datafeed=DatafeedConfig.builder(datafeedId,job.getId()).setIndices("foo").build();
    client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed),RequestOptions.DEFAULT);
{
      GetDatafeedRequest request=new GetDatafeedRequest(datafeedId);
      request.setAllowNoDatafeeds(true);
      GetDatafeedResponse response=client.machineLearning().getDatafeed(request,RequestOptions.DEFAULT);
      long numberOfDatafeeds=response.count();
      List<DatafeedConfig> datafeeds=response.datafeeds();
      assertEquals(1,numberOfDatafeeds);
      assertEquals(1,datafeeds.size());
    }
{
      GetDatafeedRequest request=new GetDatafeedRequest(datafeedId);
      ActionListener<GetDatafeedResponse> listener=new ActionListener<GetDatafeedResponse>(){
        @Override public void onResponse(        GetDatafeedResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getDatafeedAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testDeleteDatafeed() throws Exception {
    RestHighLevelClient client=highLevelClient();
    String jobId="test-delete-datafeed-job";
    Job job=MachineLearningIT.buildJob(jobId);
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    String datafeedId="test-delete-datafeed";
    DatafeedConfig datafeed=DatafeedConfig.builder(datafeedId,jobId).setIndices("foo").build();
    client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed),RequestOptions.DEFAULT);
{
      DeleteDatafeedRequest deleteDatafeedRequest=new DeleteDatafeedRequest(datafeedId);
      deleteDatafeedRequest.setForce(false);
      AcknowledgedResponse deleteDatafeedResponse=client.machineLearning().deleteDatafeed(deleteDatafeedRequest,RequestOptions.DEFAULT);
      boolean isAcknowledged=deleteDatafeedResponse.isAcknowledged();
    }
    client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed),RequestOptions.DEFAULT);
{
      ActionListener<AcknowledgedResponse> listener=new ActionListener<AcknowledgedResponse>(){
        @Override public void onResponse(        AcknowledgedResponse acknowledgedResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      DeleteDatafeedRequest deleteDatafeedRequest=new DeleteDatafeedRequest(datafeedId);
      client.machineLearning().deleteDatafeedAsync(deleteDatafeedRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testPreviewDatafeed() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("preview-datafeed-job");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    String datafeedId=job.getId() + "-feed";
    String indexName="preview_data_2";
    CreateIndexRequest createIndexRequest=new CreateIndexRequest(indexName);
    createIndexRequest.mapping("doc","timestamp","type=date","total","type=long");
    highLevelClient().indices().create(createIndexRequest,RequestOptions.DEFAULT);
    DatafeedConfig datafeed=DatafeedConfig.builder(datafeedId,job.getId()).setTypes(Arrays.asList("doc")).setIndices(indexName).build();
    client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed),RequestOptions.DEFAULT);
{
      PreviewDatafeedRequest request=new PreviewDatafeedRequest(datafeedId);
      PreviewDatafeedResponse response=client.machineLearning().previewDatafeed(request,RequestOptions.DEFAULT);
      BytesReference rawPreview=response.getPreview();
      List<Map<String,Object>> semiParsedPreview=response.getDataList();
      assertTrue(semiParsedPreview.isEmpty());
    }
{
      PreviewDatafeedRequest request=new PreviewDatafeedRequest(datafeedId);
      ActionListener<PreviewDatafeedResponse> listener=new ActionListener<PreviewDatafeedResponse>(){
        @Override public void onResponse(        PreviewDatafeedResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().previewDatafeedAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testStartDatafeed() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("start-datafeed-job");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    String datafeedId=job.getId() + "-feed";
    String indexName="start_data_2";
    CreateIndexRequest createIndexRequest=new CreateIndexRequest(indexName);
    createIndexRequest.mapping("doc","timestamp","type=date","total","type=long");
    highLevelClient().indices().create(createIndexRequest,RequestOptions.DEFAULT);
    DatafeedConfig datafeed=DatafeedConfig.builder(datafeedId,job.getId()).setTypes(Arrays.asList("doc")).setIndices(indexName).build();
    client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed),RequestOptions.DEFAULT);
    client.machineLearning().openJob(new OpenJobRequest(job.getId()),RequestOptions.DEFAULT);
{
      StartDatafeedRequest request=new StartDatafeedRequest(datafeedId);
      request.setEnd("2018-08-21T00:00:00Z");
      request.setStart("2018-08-20T00:00:00Z");
      request.setTimeout(TimeValue.timeValueMinutes(10));
      StartDatafeedResponse response=client.machineLearning().startDatafeed(request,RequestOptions.DEFAULT);
      boolean started=response.isStarted();
      assertTrue(started);
    }
{
      StartDatafeedRequest request=new StartDatafeedRequest(datafeedId);
      ActionListener<StartDatafeedResponse> listener=new ActionListener<StartDatafeedResponse>(){
        @Override public void onResponse(        StartDatafeedResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().startDatafeedAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testStopDatafeed() throws Exception {
    RestHighLevelClient client=highLevelClient();
{
      StopDatafeedRequest request=new StopDatafeedRequest("datafeed_id1","datafeed_id*");
      request=StopDatafeedRequest.stopAllDatafeedsRequest();
      request.setAllowNoDatafeeds(true);
      request.setForce(true);
      request.setTimeout(TimeValue.timeValueMinutes(10));
      StopDatafeedResponse response=client.machineLearning().stopDatafeed(request,RequestOptions.DEFAULT);
      boolean stopped=response.isStopped();
      assertTrue(stopped);
    }
{
      StopDatafeedRequest request=StopDatafeedRequest.stopAllDatafeedsRequest();
      ActionListener<StopDatafeedResponse> listener=new ActionListener<StopDatafeedResponse>(){
        @Override public void onResponse(        StopDatafeedResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().stopDatafeedAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetDatafeedStats() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("get-machine-learning-datafeed-stats1");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    Job secondJob=MachineLearningIT.buildJob("get-machine-learning-datafeed-stats2");
    client.machineLearning().putJob(new PutJobRequest(secondJob),RequestOptions.DEFAULT);
    String datafeedId1=job.getId() + "-feed";
    String indexName="datafeed_stats_data_2";
    CreateIndexRequest createIndexRequest=new CreateIndexRequest(indexName);
    createIndexRequest.mapping("doc","timestamp","type=date","total","type=long");
    highLevelClient().indices().create(createIndexRequest,RequestOptions.DEFAULT);
    DatafeedConfig datafeed=DatafeedConfig.builder(datafeedId1,job.getId()).setTypes(Arrays.asList("doc")).setIndices(indexName).build();
    client.machineLearning().putDatafeed(new PutDatafeedRequest(datafeed),RequestOptions.DEFAULT);
    String datafeedId2=secondJob.getId() + "-feed";
    DatafeedConfig secondDatafeed=DatafeedConfig.builder(datafeedId2,secondJob.getId()).setTypes(Arrays.asList("doc")).setIndices(indexName).build();
    client.machineLearning().putDatafeed(new PutDatafeedRequest(secondDatafeed),RequestOptions.DEFAULT);
{
      GetDatafeedStatsRequest request=new GetDatafeedStatsRequest("get-machine-learning-datafeed-stats1-feed","get-machine-learning-datafeed*");
      request.setAllowNoDatafeeds(true);
      GetDatafeedStatsResponse response=client.machineLearning().getDatafeedStats(request,RequestOptions.DEFAULT);
      long numberOfDatafeedStats=response.count();
      List<DatafeedStats> datafeedStats=response.datafeedStats();
      assertEquals(2,response.count());
      assertThat(response.datafeedStats(),hasSize(2));
      assertThat(response.datafeedStats().stream().map(DatafeedStats::getDatafeedId).collect(Collectors.toList()),containsInAnyOrder(datafeed.getId(),secondDatafeed.getId()));
    }
{
      GetDatafeedStatsRequest request=new GetDatafeedStatsRequest("*");
      ActionListener<GetDatafeedStatsResponse> listener=new ActionListener<GetDatafeedStatsResponse>(){
        @Override public void onResponse(        GetDatafeedStatsResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getDatafeedStatsAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetBuckets() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    String jobId="test-get-buckets";
    Job job=MachineLearningIT.buildJob(jobId);
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    IndexRequest indexRequest=new IndexRequest(".ml-anomalies-shared","doc");
    indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);
    indexRequest.source("{\"job_id\":\"test-get-buckets\", \"result_type\":\"bucket\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"anomaly_score\": 80.0}",XContentType.JSON);
    client.index(indexRequest,RequestOptions.DEFAULT);
{
      GetBucketsRequest request=new GetBucketsRequest(jobId);
      request.setTimestamp("2018-08-17T00:00:00Z");
      request.setTimestamp(null);
      request.setAnomalyScore(75.0);
      request.setDescending(true);
      request.setEnd("2018-08-21T00:00:00Z");
      request.setExcludeInterim(true);
      request.setExpand(true);
      request.setPageParams(new PageParams(100,200));
      request.setPageParams(null);
      request.setSort("anomaly_score");
      request.setStart("2018-08-01T00:00:00Z");
      GetBucketsResponse response=client.machineLearning().getBuckets(request,RequestOptions.DEFAULT);
      long count=response.count();
      List<Bucket> buckets=response.buckets();
      assertEquals(1,buckets.size());
    }
{
      GetBucketsRequest request=new GetBucketsRequest(jobId);
      ActionListener<GetBucketsResponse> listener=new ActionListener<GetBucketsResponse>(){
        @Override public void onResponse(        GetBucketsResponse getBucketsResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getBucketsAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testFlushJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("flushing-my-first-machine-learning-job");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    client.machineLearning().openJob(new OpenJobRequest(job.getId()),RequestOptions.DEFAULT);
    Job secondJob=MachineLearningIT.buildJob("flushing-my-second-machine-learning-job");
    client.machineLearning().putJob(new PutJobRequest(secondJob),RequestOptions.DEFAULT);
    client.machineLearning().openJob(new OpenJobRequest(secondJob.getId()),RequestOptions.DEFAULT);
{
      FlushJobRequest flushJobRequest=new FlushJobRequest("flushing-my-first-machine-learning-job");
      flushJobRequest.setCalcInterim(true);
      flushJobRequest.setAdvanceTime("2018-08-31T16:35:07+00:00");
      flushJobRequest.setStart("2018-08-31T16:35:17+00:00");
      flushJobRequest.setEnd("2018-08-31T16:35:27+00:00");
      flushJobRequest.setSkipTime("2018-08-31T16:35:00+00:00");
      FlushJobResponse flushJobResponse=client.machineLearning().flushJob(flushJobRequest,RequestOptions.DEFAULT);
      boolean isFlushed=flushJobResponse.isFlushed();
      Date lastFinalizedBucketEnd=flushJobResponse.getLastFinalizedBucketEnd();
    }
{
      ActionListener<FlushJobResponse> listener=new ActionListener<FlushJobResponse>(){
        @Override public void onResponse(        FlushJobResponse FlushJobResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      FlushJobRequest flushJobRequest=new FlushJobRequest("flushing-my-second-machine-learning-job");
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().flushJobAsync(flushJobRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testDeleteForecast() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("deleting-forecast-for-job");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    client.machineLearning().openJob(new OpenJobRequest(job.getId()),RequestOptions.DEFAULT);
    PostDataRequest.JsonBuilder builder=new PostDataRequest.JsonBuilder();
    for (int i=0; i < 30; i++) {
      Map<String,Object> hashMap=new HashMap<>();
      hashMap.put("total",randomInt(1000));
      hashMap.put("timestamp",(i + 1) * 1000);
      builder.addDoc(hashMap);
    }
    PostDataRequest postDataRequest=new PostDataRequest(job.getId(),builder);
    client.machineLearning().postData(postDataRequest,RequestOptions.DEFAULT);
    client.machineLearning().flushJob(new FlushJobRequest(job.getId()),RequestOptions.DEFAULT);
    ForecastJobResponse forecastJobResponse=client.machineLearning().forecastJob(new ForecastJobRequest(job.getId()),RequestOptions.DEFAULT);
    String forecastId=forecastJobResponse.getForecastId();
    GetRequest request=new GetRequest(".ml-anomalies-" + job.getId());
    request.id(job.getId() + "_model_forecast_request_stats_" + forecastId);
    assertBusy(() -> {
      GetResponse getResponse=highLevelClient().get(request,RequestOptions.DEFAULT);
      assertTrue(getResponse.isExists());
      assertTrue(getResponse.getSourceAsString().contains("finished"));
    }
,30,TimeUnit.SECONDS);
{
      DeleteForecastRequest deleteForecastRequest=new DeleteForecastRequest("deleting-forecast-for-job");
      deleteForecastRequest.setForecastIds(forecastId);
      deleteForecastRequest.timeout("30s");
      deleteForecastRequest.setAllowNoForecasts(true);
      AcknowledgedResponse deleteForecastResponse=client.machineLearning().deleteForecast(deleteForecastRequest,RequestOptions.DEFAULT);
      boolean isAcknowledged=deleteForecastResponse.isAcknowledged();
    }
{
      ActionListener<AcknowledgedResponse> listener=new ActionListener<AcknowledgedResponse>(){
        @Override public void onResponse(        AcknowledgedResponse DeleteForecastResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      DeleteForecastRequest deleteForecastRequest=DeleteForecastRequest.deleteAllForecasts(job.getId());
      deleteForecastRequest.setAllowNoForecasts(true);
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().deleteForecastAsync(deleteForecastRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetJobStats() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("get-machine-learning-job-stats1");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    Job secondJob=MachineLearningIT.buildJob("get-machine-learning-job-stats2");
    client.machineLearning().putJob(new PutJobRequest(secondJob),RequestOptions.DEFAULT);
{
      GetJobStatsRequest request=new GetJobStatsRequest("get-machine-learning-job-stats1","get-machine-learning-job-*");
      request.setAllowNoJobs(true);
      GetJobStatsResponse response=client.machineLearning().getJobStats(request,RequestOptions.DEFAULT);
      long numberOfJobStats=response.count();
      List<JobStats> jobStats=response.jobStats();
      assertEquals(2,response.count());
      assertThat(response.jobStats(),hasSize(2));
      assertThat(response.jobStats().stream().map(JobStats::getJobId).collect(Collectors.toList()),containsInAnyOrder(job.getId(),secondJob.getId()));
    }
{
      GetJobStatsRequest request=new GetJobStatsRequest("get-machine-learning-job-stats1","get-machine-learning-job-*");
      ActionListener<GetJobStatsResponse> listener=new ActionListener<GetJobStatsResponse>(){
        @Override public void onResponse(        GetJobStatsResponse response){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getJobStatsAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testForecastJob() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("forecasting-my-first-machine-learning-job");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    client.machineLearning().openJob(new OpenJobRequest(job.getId()),RequestOptions.DEFAULT);
    PostDataRequest.JsonBuilder builder=new PostDataRequest.JsonBuilder();
    for (int i=0; i < 30; i++) {
      Map<String,Object> hashMap=new HashMap<>();
      hashMap.put("total",randomInt(1000));
      hashMap.put("timestamp",(i + 1) * 1000);
      builder.addDoc(hashMap);
    }
    PostDataRequest postDataRequest=new PostDataRequest(job.getId(),builder);
    client.machineLearning().postData(postDataRequest,RequestOptions.DEFAULT);
    client.machineLearning().flushJob(new FlushJobRequest(job.getId()),RequestOptions.DEFAULT);
{
      ForecastJobRequest forecastJobRequest=new ForecastJobRequest("forecasting-my-first-machine-learning-job");
      forecastJobRequest.setExpiresIn(TimeValue.timeValueHours(48));
      forecastJobRequest.setDuration(TimeValue.timeValueHours(24));
      ForecastJobResponse forecastJobResponse=client.machineLearning().forecastJob(forecastJobRequest,RequestOptions.DEFAULT);
      boolean isAcknowledged=forecastJobResponse.isAcknowledged();
      String forecastId=forecastJobResponse.getForecastId();
      assertTrue(isAcknowledged);
      assertNotNull(forecastId);
    }
{
      ActionListener<ForecastJobResponse> listener=new ActionListener<ForecastJobResponse>(){
        @Override public void onResponse(        ForecastJobResponse forecastJobResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      ForecastJobRequest forecastJobRequest=new ForecastJobRequest("forecasting-my-first-machine-learning-job");
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().forecastJobAsync(forecastJobRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetOverallBuckets() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    String jobId1="test-get-overall-buckets-1";
    String jobId2="test-get-overall-buckets-2";
    Job job1=MachineLearningGetResultsIT.buildJob(jobId1);
    Job job2=MachineLearningGetResultsIT.buildJob(jobId2);
    client.machineLearning().putJob(new PutJobRequest(job1),RequestOptions.DEFAULT);
    client.machineLearning().putJob(new PutJobRequest(job2),RequestOptions.DEFAULT);
    BulkRequest bulkRequest=new BulkRequest();
    bulkRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);
{
      IndexRequest indexRequest=new IndexRequest(".ml-anomalies-shared","doc");
      indexRequest.source("{\"job_id\":\"test-get-overall-buckets-1\", \"result_type\":\"bucket\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"anomaly_score\": 60.0}",XContentType.JSON);
      bulkRequest.add(indexRequest);
    }
{
      IndexRequest indexRequest=new IndexRequest(".ml-anomalies-shared","doc");
      indexRequest.source("{\"job_id\":\"test-get-overall-buckets-2\", \"result_type\":\"bucket\", \"timestamp\": 1533081600000," + "\"bucket_span\": 3600,\"is_interim\": false, \"anomaly_score\": 100.0}",XContentType.JSON);
      bulkRequest.add(indexRequest);
    }
    client.bulk(bulkRequest,RequestOptions.DEFAULT);
{
      GetOverallBucketsRequest request=new GetOverallBucketsRequest(jobId1,jobId2);
      request.setBucketSpan(TimeValue.timeValueHours(24));
      request.setEnd("2018-08-21T00:00:00Z");
      request.setExcludeInterim(true);
      request.setOverallScore(75.0);
      request.setStart("2018-08-01T00:00:00Z");
      request.setTopN(2);
      GetOverallBucketsResponse response=client.machineLearning().getOverallBuckets(request,RequestOptions.DEFAULT);
      long count=response.count();
      List<OverallBucket> overallBuckets=response.overallBuckets();
      assertEquals(1,overallBuckets.size());
      assertThat(overallBuckets.get(0).getOverallScore(),is(closeTo(80.0,0.001)));
    }
{
      GetOverallBucketsRequest request=new GetOverallBucketsRequest(jobId1,jobId2);
      ActionListener<GetOverallBucketsResponse> listener=new ActionListener<GetOverallBucketsResponse>(){
        @Override public void onResponse(        GetOverallBucketsResponse getOverallBucketsResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getOverallBucketsAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetRecords() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    String jobId="test-get-records";
    Job job=MachineLearningIT.buildJob(jobId);
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    IndexRequest indexRequest=new IndexRequest(".ml-anomalies-shared","doc");
    indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);
    indexRequest.source("{\"job_id\":\"test-get-records\", \"result_type\":\"record\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"record_score\": 80.0}",XContentType.JSON);
    client.index(indexRequest,RequestOptions.DEFAULT);
{
      GetRecordsRequest request=new GetRecordsRequest(jobId);
      request.setDescending(true);
      request.setEnd("2018-08-21T00:00:00Z");
      request.setExcludeInterim(true);
      request.setPageParams(new PageParams(100,200));
      request.setPageParams(null);
      request.setRecordScore(75.0);
      request.setSort("probability");
      request.setStart("2018-08-01T00:00:00Z");
      GetRecordsResponse response=client.machineLearning().getRecords(request,RequestOptions.DEFAULT);
      long count=response.count();
      List<AnomalyRecord> records=response.records();
      assertEquals(1,records.size());
    }
{
      GetRecordsRequest request=new GetRecordsRequest(jobId);
      ActionListener<GetRecordsResponse> listener=new ActionListener<GetRecordsResponse>(){
        @Override public void onResponse(        GetRecordsResponse getRecordsResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getRecordsAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testPostData() throws Exception {
    RestHighLevelClient client=highLevelClient();
    Job job=MachineLearningIT.buildJob("test-post-data");
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    client.machineLearning().openJob(new OpenJobRequest(job.getId()),RequestOptions.DEFAULT);
{
      PostDataRequest.JsonBuilder jsonBuilder=new PostDataRequest.JsonBuilder();
      Map<String,Object> mapData=new HashMap<>();
      mapData.put("total",109);
      jsonBuilder.addDoc(mapData);
      jsonBuilder.addDoc("{\"total\":1000}");
      PostDataRequest postDataRequest=new PostDataRequest("test-post-data",jsonBuilder);
      postDataRequest.setResetStart("2018-08-31T16:35:07+00:00");
      postDataRequest.setResetEnd("2018-08-31T16:35:17+00:00");
      postDataRequest.setResetEnd(null);
      postDataRequest.setResetStart(null);
      PostDataResponse postDataResponse=client.machineLearning().postData(postDataRequest,RequestOptions.DEFAULT);
      DataCounts dataCounts=postDataResponse.getDataCounts();
      assertEquals(2,dataCounts.getInputRecordCount());
    }
{
      ActionListener<PostDataResponse> listener=new ActionListener<PostDataResponse>(){
        @Override public void onResponse(        PostDataResponse postDataResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      PostDataRequest.JsonBuilder jsonBuilder=new PostDataRequest.JsonBuilder();
      Map<String,Object> mapData=new HashMap<>();
      mapData.put("total",109);
      jsonBuilder.addDoc(mapData);
      PostDataRequest postDataRequest=new PostDataRequest("test-post-data",jsonBuilder);
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().postDataAsync(postDataRequest,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetInfluencers() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    String jobId="test-get-influencers";
    Job job=MachineLearningIT.buildJob(jobId);
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    IndexRequest indexRequest=new IndexRequest(".ml-anomalies-shared","doc");
    indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);
    indexRequest.source("{\"job_id\":\"test-get-influencers\", \"result_type\":\"influencer\", \"timestamp\": 1533081600000," + "\"bucket_span\": 600,\"is_interim\": false, \"influencer_score\": 80.0, \"influencer_field_name\": \"my_influencer\"," + "\"influencer_field_value\":\"foo\"}",XContentType.JSON);
    client.index(indexRequest,RequestOptions.DEFAULT);
{
      GetInfluencersRequest request=new GetInfluencersRequest(jobId);
      request.setDescending(true);
      request.setEnd("2018-08-21T00:00:00Z");
      request.setExcludeInterim(true);
      request.setInfluencerScore(75.0);
      request.setPageParams(new PageParams(100,200));
      request.setPageParams(null);
      request.setSort("probability");
      request.setStart("2018-08-01T00:00:00Z");
      GetInfluencersResponse response=client.machineLearning().getInfluencers(request,RequestOptions.DEFAULT);
      long count=response.count();
      List<Influencer> influencers=response.influencers();
      assertEquals(1,influencers.size());
    }
{
      GetInfluencersRequest request=new GetInfluencersRequest(jobId);
      ActionListener<GetInfluencersResponse> listener=new ActionListener<GetInfluencersResponse>(){
        @Override public void onResponse(        GetInfluencersResponse getInfluencersResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getInfluencersAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testGetCategories() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    String jobId="test-get-categories";
    Job job=MachineLearningIT.buildJob(jobId);
    client.machineLearning().putJob(new PutJobRequest(job),RequestOptions.DEFAULT);
    IndexRequest indexRequest=new IndexRequest(".ml-anomalies-shared","doc");
    indexRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);
    indexRequest.source("{\"job_id\": \"test-get-categories\", \"category_id\": 1, \"terms\": \"AAL\"," + " \"regex\": \".*?AAL.*\", \"max_matching_length\": 3, \"examples\": [\"AAL\"]}",XContentType.JSON);
    client.index(indexRequest,RequestOptions.DEFAULT);
{
      GetCategoriesRequest request=new GetCategoriesRequest(jobId);
      request.setCategoryId(1L);
      request.setPageParams(new PageParams(100,200));
      request.setPageParams(null);
      GetCategoriesResponse response=client.machineLearning().getCategories(request,RequestOptions.DEFAULT);
      long count=response.count();
      List<CategoryDefinition> categories=response.categories();
      assertEquals(1,categories.size());
    }
{
      GetCategoriesRequest request=new GetCategoriesRequest(jobId);
      ActionListener<GetCategoriesResponse> listener=new ActionListener<GetCategoriesResponse>(){
        @Override public void onResponse(        GetCategoriesResponse getcategoriesResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getCategoriesAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testPutCalendar() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    Calendar calendar=new Calendar("public_holidays",Collections.singletonList("job_1"),"A calendar for public holidays");
    PutCalendarRequest request=new PutCalendarRequest(calendar);
    PutCalendarResponse response=client.machineLearning().putCalendar(request,RequestOptions.DEFAULT);
    Calendar newCalendar=response.getCalendar();
    assertThat(newCalendar.getId(),equalTo("public_holidays"));
    ActionListener<PutCalendarResponse> listener=new ActionListener<PutCalendarResponse>(){
      @Override public void onResponse(      PutCalendarResponse response){
      }
      @Override public void onFailure(      Exception e){
      }
    }
;
    final CountDownLatch latch=new CountDownLatch(1);
    listener=new LatchedActionListener<>(listener,latch);
    client.machineLearning().putCalendarAsync(request,RequestOptions.DEFAULT,listener);
    assertTrue(latch.await(30L,TimeUnit.SECONDS));
  }
  public void testGetCalendar() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    Calendar calendar=new Calendar("holidays",Collections.singletonList("job_1"),"A calendar for public holidays");
    PutCalendarRequest putRequest=new PutCalendarRequest(calendar);
    client.machineLearning().putCalendar(putRequest,RequestOptions.DEFAULT);
{
      GetCalendarsRequest request=new GetCalendarsRequest();
      request.setCalendarId("holidays");
      request.setPageParams(new PageParams(10,20));
      request.setPageParams(null);
      GetCalendarsResponse response=client.machineLearning().getCalendars(request,RequestOptions.DEFAULT);
      long count=response.count();
      List<Calendar> calendars=response.calendars();
      assertEquals(1,calendars.size());
    }
{
      GetCalendarsRequest request=new GetCalendarsRequest("holidays");
      ActionListener<GetCalendarsResponse> listener=new ActionListener<GetCalendarsResponse>(){
        @Override public void onResponse(        GetCalendarsResponse getCalendarsResponse){
        }
        @Override public void onFailure(        Exception e){
        }
      }
;
      final CountDownLatch latch=new CountDownLatch(1);
      listener=new LatchedActionListener<>(listener,latch);
      client.machineLearning().getCalendarsAsync(request,RequestOptions.DEFAULT,listener);
      assertTrue(latch.await(30L,TimeUnit.SECONDS));
    }
  }
  public void testDeleteCalendar() throws IOException, InterruptedException {
    RestHighLevelClient client=highLevelClient();
    Calendar calendar=new Calendar("holidays",Collections.singletonList("job_1"),"A calendar for public holidays");
    PutCalendarRequest putCalendarRequest=new PutCalendarRequest(calendar);
    client.machineLearning().putCalendar(putCalendarRequest,RequestOptions.DEFAULT);
    DeleteCalendarRequest request=new DeleteCalendarRequest("holidays");
    AcknowledgedResponse response=client.machineLearning().deleteCalendar(request,RequestOptions.DEFAULT);
    boolean isAcknowledged=response.isAcknowledged();
    assertTrue(isAcknowledged);
    ActionListener<AcknowledgedResponse> listener=new ActionListener<AcknowledgedResponse>(){
      @Override public void onResponse(      AcknowledgedResponse response){
      }
      @Override public void onFailure(      Exception e){
      }
    }
;
    final CountDownLatch latch=new CountDownLatch(1);
    listener=new LatchedActionListener<>(listener,latch);
    client.machineLearning().deleteCalendarAsync(request,RequestOptions.DEFAULT,listener);
    assertTrue(latch.await(30L,TimeUnit.SECONDS));
  }
}
