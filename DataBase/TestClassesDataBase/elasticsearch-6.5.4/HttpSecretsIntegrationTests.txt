public class HttpSecretsIntegrationTests extends AbstractWatcherIntegrationTestCase {
  private static final String USERNAME="_user";
  private static final String PASSWORD="_passwd";
  private MockWebServer webServer=new MockWebServer();
  private static Boolean encryptSensitiveData=null;
  private static final byte[] encryptionKey=CryptoServiceTests.generateKey();
  @Before public void init() throws Exception {
    webServer.start();
  }
  @After public void cleanup(){
    webServer.close();
  }
  @Override protected Settings nodeSettings(  int nodeOrdinal){
    if (encryptSensitiveData == null) {
      encryptSensitiveData=randomBoolean();
    }
    if (encryptSensitiveData) {
      MockSecureSettings secureSettings=new MockSecureSettings();
      secureSettings.setFile(WatcherField.ENCRYPTION_KEY_SETTING.getKey(),encryptionKey);
      return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put("xpack.watcher.encrypt_sensitive_data",encryptSensitiveData).setSecureSettings(secureSettings).build();
    }
    return super.nodeSettings(nodeOrdinal);
  }
  public void testHttpInput() throws Exception {
    WatcherClient watcherClient=watcherClient();
    watcherClient.preparePutWatch("_id").setSource(watchBuilder().trigger(schedule(cron("0 0 0 1 * ? 2020"))).input(httpInput(HttpRequestTemplate.builder(webServer.getHostName(),webServer.getPort()).path("/").auth(new BasicAuth(USERNAME,PASSWORD.toCharArray())))).condition(InternalAlwaysCondition.INSTANCE).addAction("_logging",loggingAction("executed"))).get();
    GetResponse response=client().prepareGet(Watch.INDEX,Watch.DOC_TYPE,"_id").get();
    assertThat(response,notNullValue());
    assertThat(response.getId(),is("_id"));
    Map<String,Object> source=response.getSource();
    Object value=XContentMapValues.extractValue("input.http.request.auth.basic.password",source);
    assertThat(value,notNullValue());
    if (encryptSensitiveData) {
      assertThat(value.toString(),startsWith("::es_encrypted::"));
      MockSecureSettings mockSecureSettings=new MockSecureSettings();
      mockSecureSettings.setFile(WatcherField.ENCRYPTION_KEY_SETTING.getKey(),encryptionKey);
      Settings settings=Settings.builder().setSecureSettings(mockSecureSettings).build();
      CryptoService cryptoService=new CryptoService(settings);
      assertThat(new String(cryptoService.decrypt(((String)value).toCharArray())),is(PASSWORD));
    }
 else {
      assertThat(value,is(PASSWORD));
    }
    GetWatchResponse watchResponse=watcherClient.prepareGetWatch("_id").get();
    assertThat(watchResponse,notNullValue());
    assertThat(watchResponse.getId(),is("_id"));
    XContentSource contentSource=watchResponse.getSource();
    value=contentSource.getValue("input.http.request.auth.basic");
    assertThat(value,notNullValue());
    value=contentSource.getValue("input.http.request.auth.basic.password");
    if (encryptSensitiveData) {
      assertThat(value.toString(),startsWith("::es_encrypted::"));
    }
 else {
      assertThat(value,is("::es_redacted::"));
    }
    stopWatcher();
    startWatcher();
    webServer.enqueue(new MockResponse().setResponseCode(200).setBody(BytesReference.bytes(jsonBuilder().startObject().field("key","value").endObject()).utf8ToString()));
    TriggerEvent triggerEvent=new ScheduleTriggerEvent(new DateTime(UTC),new DateTime(UTC));
    ExecuteWatchResponse executeResponse=watcherClient.prepareExecuteWatch("_id").setRecordExecution(false).setTriggerEvent(triggerEvent).setActionMode("_all",ActionExecutionMode.FORCE_EXECUTE).get();
    assertThat(executeResponse,notNullValue());
    contentSource=executeResponse.getRecordSource();
    value=contentSource.getValue("result.input.http.status_code");
    assertThat(value,notNullValue());
    assertThat(value,is((Object)200));
    assertThat(webServer.requests(),hasSize(1));
    assertThat(webServer.requests().get(0).getHeader("Authorization"),is(headerValue(USERNAME,PASSWORD.toCharArray())));
    webServer.enqueue(new MockResponse().setResponseCode(200).setBody(BytesReference.bytes(jsonBuilder().startObject().field("key","value").endObject()).utf8ToString()));
    timeWarp().trigger("_id");
    assertThat(webServer.requests(),hasSize(2));
    assertThat(webServer.requests().get(1).getHeader("Authorization"),is(headerValue(USERNAME,PASSWORD.toCharArray())));
  }
  @AwaitsFix(bugUrl="https://github.com/elastic/elasticsearch/issues/30094") public void testWebhookAction() throws Exception {
    WatcherClient watcherClient=watcherClient();
    watcherClient.preparePutWatch("_id").setSource(watchBuilder().trigger(schedule(cron("0 0 0 1 * ? 2020"))).input(simpleInput()).condition(InternalAlwaysCondition.INSTANCE).addAction("_webhook",webhookAction(HttpRequestTemplate.builder(webServer.getHostName(),webServer.getPort()).path("/").auth(new BasicAuth(USERNAME,PASSWORD.toCharArray()))))).get();
    GetResponse response=client().prepareGet(Watch.INDEX,Watch.DOC_TYPE,"_id").get();
    assertThat(response,notNullValue());
    assertThat(response.getId(),is("_id"));
    Map<String,Object> source=response.getSource();
    Object value=XContentMapValues.extractValue("actions._webhook.webhook.auth.basic.password",source);
    assertThat(value,notNullValue());
    if (encryptSensitiveData) {
      assertThat(value,not(is((Object)PASSWORD)));
      MockSecureSettings mockSecureSettings=new MockSecureSettings();
      mockSecureSettings.setFile(WatcherField.ENCRYPTION_KEY_SETTING.getKey(),encryptionKey);
      Settings settings=Settings.builder().setSecureSettings(mockSecureSettings).build();
      CryptoService cryptoService=new CryptoService(settings);
      assertThat(new String(cryptoService.decrypt(((String)value).toCharArray())),is(PASSWORD));
    }
 else {
      assertThat(value,is((Object)PASSWORD));
    }
    GetWatchResponse watchResponse=watcherClient.prepareGetWatch("_id").get();
    assertThat(watchResponse,notNullValue());
    assertThat(watchResponse.getId(),is("_id"));
    XContentSource contentSource=watchResponse.getSource();
    value=contentSource.getValue("actions._webhook.webhook.auth.basic");
    assertThat(value,notNullValue());
    value=contentSource.getValue("actions._webhook.webhook.auth.basic.password");
    if (encryptSensitiveData) {
      assertThat(value.toString(),startsWith("::es_encrypted::"));
    }
 else {
      assertThat(value,is("::es_redacted::"));
    }
    stopWatcher();
    startWatcher();
    webServer.enqueue(new MockResponse().setResponseCode(200).setBody(BytesReference.bytes(jsonBuilder().startObject().field("key","value").endObject()).utf8ToString()));
    TriggerEvent triggerEvent=new ScheduleTriggerEvent(new DateTime(UTC),new DateTime(UTC));
    ExecuteWatchResponse executeResponse=watcherClient.prepareExecuteWatch("_id").setRecordExecution(false).setActionMode("_all",ActionExecutionMode.FORCE_EXECUTE).setTriggerEvent(triggerEvent).get();
    assertThat(executeResponse,notNullValue());
    contentSource=executeResponse.getRecordSource();
    assertThat(contentSource.getValue("result.actions.0.status"),is("success"));
    value=contentSource.getValue("result.actions.0.webhook.response.status");
    assertThat(value,notNullValue());
    assertThat(value,instanceOf(Number.class));
    assertThat(((Number)value).intValue(),is(200));
    value=contentSource.getValue("result.actions.0.webhook.request.auth.basic.username");
    assertThat(value,notNullValue());
    assertThat(value,instanceOf(String.class));
    assertThat(value,is(USERNAME));
    value=contentSource.getValue("result.actions.0.webhook.request.auth.basic.password");
    if (encryptSensitiveData) {
      assertThat(value.toString(),startsWith("::es_encrypted::"));
    }
 else {
      assertThat(value.toString(),is("::es_redacted::"));
    }
    assertThat(webServer.requests(),hasSize(1));
    assertThat(webServer.requests().get(0).getHeader("Authorization"),is(headerValue(USERNAME,PASSWORD.toCharArray())));
  }
  private String headerValue(  String username,  char[] password){
    return "Basic " + Base64.getEncoder().encodeToString((username + ":" + new String(password)).getBytes(StandardCharsets.UTF_8));
  }
}
