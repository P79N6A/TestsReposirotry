/** 
 * Integration tests for SSL trust restrictions
 * @see RestrictedTrustManager
 */
@ESIntegTestCase.ClusterScope(numDataNodes=1,numClientNodes=0,supportsDedicatedMasters=false) @TestLogging("org.elasticsearch.xpack.ssl.RestrictedTrustManager:DEBUG") public class SSLTrustRestrictionsTests extends SecurityIntegTestCase {
  private static final TimeValue MAX_WAIT_RELOAD=TimeValue.timeValueSeconds(1);
  private static Path configPath;
  private static Settings nodeSSL;
  private static CertificateInfo ca;
  private static CertificateInfo trustedCert;
  private static CertificateInfo untrustedCert;
  private static Path restrictionsPath;
  private static Path restrictionsTmpPath;
  @Override protected int maxNumberOfNodes(){
    return 1;
  }
  @BeforeClass public static void setupCertificates() throws Exception {
    assumeFalse("Can't run in a FIPS JVM, custom TrustManager implementations cannot be used.",inFipsJvm());
    configPath=createTempDir();
    Path caCertPath=PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/ca.crt").toURI());
    X509Certificate caCert=CertParsingUtils.readX509Certificates(Collections.singletonList(caCertPath))[0];
    Path caKeyPath=PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/ca.key").toURI());
    PrivateKey caKey=PemUtils.readPrivateKey(caKeyPath,""::toCharArray);
    ca=new CertificateInfo(caKey,caKeyPath,caCert,caCertPath);
    Path trustedCertPath=PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/trusted.crt").toURI());
    X509Certificate trustedX509Certificate=CertParsingUtils.readX509Certificates(Collections.singletonList(trustedCertPath))[0];
    Path trustedKeyPath=PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/trusted.key").toURI());
    PrivateKey trustedKey=PemUtils.readPrivateKey(trustedKeyPath,""::toCharArray);
    trustedCert=new CertificateInfo(trustedKey,trustedKeyPath,trustedX509Certificate,trustedCertPath);
    Path untrustedCertPath=PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/untrusted.crt").toURI());
    X509Certificate untrustedX509Certificate=CertParsingUtils.readX509Certificates(Collections.singletonList(untrustedCertPath))[0];
    Path untrustedKeyPath=PathUtils.get(SSLTrustRestrictionsTests.class.getResource("/org/elasticsearch/xpack/security/transport/ssl/certs/simple/nodes/untrusted.key").toURI());
    PrivateKey untrustedKey=PemUtils.readPrivateKey(untrustedKeyPath,""::toCharArray);
    untrustedCert=new CertificateInfo(untrustedKey,untrustedKeyPath,untrustedX509Certificate,untrustedCertPath);
    nodeSSL=Settings.builder().put("xpack.security.transport.ssl.enabled",true).put("xpack.security.transport.ssl.verification_mode","certificate").putList("xpack.ssl.certificate_authorities",ca.getCertPath().toString()).put("xpack.ssl.key",trustedCert.getKeyPath()).put("xpack.ssl.certificate",trustedCert.getCertPath()).build();
  }
  @AfterClass public static void cleanup(){
    configPath=null;
    nodeSSL=null;
    ca=null;
    trustedCert=null;
    untrustedCert=null;
  }
  @Override public Settings nodeSettings(  int nodeOrdinal){
    Settings parentSettings=super.nodeSettings(nodeOrdinal);
    Settings.Builder builder=Settings.builder().put(parentSettings.filter((s) -> s.startsWith("xpack.ssl.") == false)).put(nodeSSL);
    restrictionsPath=configPath.resolve("trust_restrictions.yml");
    restrictionsTmpPath=configPath.resolve("trust_restrictions.tmp");
    writeRestrictions("*.trusted");
    builder.put("xpack.ssl.trust_restrictions.path",restrictionsPath);
    return builder.build();
  }
  private void writeRestrictions(  String trustedPattern){
    try {
      Files.write(restrictionsTmpPath,Collections.singleton("trust.subject_name: \"" + trustedPattern + "\""));
      try {
        Files.move(restrictionsTmpPath,restrictionsPath,REPLACE_EXISTING,ATOMIC_MOVE);
      }
 catch (      final AtomicMoveNotSupportedException e) {
        Files.move(restrictionsTmpPath,restrictionsPath,REPLACE_EXISTING);
      }
    }
 catch (    IOException e) {
      throw new ElasticsearchException("failed to write restrictions",e);
    }
    runResourceWatcher();
  }
  @Override protected Settings transportClientSettings(){
    Settings parentSettings=super.transportClientSettings();
    Settings.Builder builder=Settings.builder().put(parentSettings.filter((s) -> s.startsWith("xpack.ssl.") == false)).put(nodeSSL);
    return builder.build();
  }
  @Override protected boolean transportSSLEnabled(){
    return true;
  }
  public void testCertificateWithTrustedNameIsAccepted() throws Exception {
    writeRestrictions("*.trusted");
    try {
      tryConnect(trustedCert);
    }
 catch (    SSLException|SocketException ex) {
      logger.warn(new ParameterizedMessage("unexpected handshake failure with certificate [{}] [{}]",trustedCert.certificate.getSubjectDN(),trustedCert.certificate.getSubjectAlternativeNames()),ex);
      fail("handshake should have been successful, but failed with " + ex);
    }
  }
  public void testCertificateWithUntrustedNameFails() throws Exception {
    writeRestrictions("*.trusted");
    try {
      tryConnect(untrustedCert);
      fail("handshake should have failed, but was successful");
    }
 catch (    SSLException|SocketException ex) {
    }
  }
  public void testRestrictionsAreReloaded() throws Exception {
    writeRestrictions("*");
    assertBusy(() -> {
      try {
        tryConnect(untrustedCert);
      }
 catch (      SSLException|SocketException ex) {
        fail("handshake should have been successful, but failed with " + ex);
      }
    }
,MAX_WAIT_RELOAD.millis(),TimeUnit.MILLISECONDS);
    writeRestrictions("*.trusted");
    assertBusy(() -> {
      try {
        tryConnect(untrustedCert);
        fail("handshake should have failed, but was successful");
      }
 catch (      SSLException|SocketException ex) {
      }
    }
,MAX_WAIT_RELOAD.millis(),TimeUnit.MILLISECONDS);
  }
  /** 
 * Force the file watch to be updated. Ideally we'd just left the service do its thing, but that means waiting for 5sec We can drop the 5s down, but then we run into resource contention issues. This method just tells the  {@link ResourceWatcherService} to run its check at a time that suits the tests. In all other respectsit works just like normal - the usual file checks apply for detecting it as "changed", and only the previously configured files are checked.
 */
  private void runResourceWatcher(){
    final InternalTestCluster cluster=internalCluster();
    if (cluster.size() > 0) {
      final ResourceWatcherService service=cluster.getInstance(ResourceWatcherService.class);
      logger.info("Triggering a reload of watched resources");
      service.notifyNow(ResourceWatcherService.Frequency.HIGH);
    }
  }
  private void tryConnect(  CertificateInfo certificate) throws Exception {
    Settings settings=Settings.builder().put("path.home",createTempDir()).put("xpack.ssl.key",certificate.getKeyPath()).put("xpack.ssl.certificate",certificate.getCertPath()).putList("xpack.ssl.certificate_authorities",ca.getCertPath().toString()).put("xpack.ssl.verification_mode","certificate").build();
    String node=randomFrom(internalCluster().getNodeNames());
    SSLService sslService=new SSLService(settings,TestEnvironment.newEnvironment(settings));
    SSLConfiguration sslConfiguration=sslService.getSSLConfiguration("xpack.ssl");
    SSLSocketFactory sslSocketFactory=sslService.sslSocketFactory(sslConfiguration);
    TransportAddress address=internalCluster().getInstance(Transport.class,node).boundAddress().publishAddress();
    try (SSLSocket socket=(SSLSocket)sslSocketFactory.createSocket(address.getAddress(),address.getPort())){
      assertThat(socket.isConnected(),is(true));
      socket.startHandshake();
    }
   }
private static class CertificateInfo {
    private final PrivateKey key;
    private final Path keyPath;
    private final X509Certificate certificate;
    private final Path certPath;
    private CertificateInfo(    PrivateKey key,    Path keyPath,    X509Certificate certificate,    Path certPath){
      this.key=key;
      this.keyPath=keyPath;
      this.certificate=certificate;
      this.certPath=certPath;
    }
    private PrivateKey getKey(){
      return key;
    }
    private Path getKeyPath(){
      return keyPath;
    }
    private X509Certificate getCertificate(){
      return certificate;
    }
    private Path getCertPath(){
      return certPath;
    }
  }
}
