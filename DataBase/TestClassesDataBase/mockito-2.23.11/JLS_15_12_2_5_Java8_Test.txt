/** 
 * The JLS §15.12.2.5 states that the compiler must chose the most specific overload in Java 8, however the Java 8 compiler perform a type inference before selecting https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2 <blockquote> <p>Deciding whether a method is applicable will, in the case of generic methods (§8.4.4), require an analysis of the type arguments. Type arguments may be passed explicitly or implicitly. If they are passed implicitly, bounds of the type arguments must be inferred (§18 (Type Inference)) from the argument expressions.</p> <p>If several applicable methods have been identified during one of the three phases of applicability testing, then the most specific one is chosen, as specified in section §15.12.2.5.</p> </blockquote> https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.1 <blockquote> <p>The definition of potential applicability goes beyond a basic arity check to also take into account the presence and "shape" of functional interface target types. In some cases involving type argument inference, a lambda expression appearing as a method invocation argument cannot be properly typed until after overload resolution. These rules allow the form of the lambda expression to still be taken into account, discarding obviously incorrect target types that might otherwise cause ambiguity errors.</p> </blockquote> https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5 <blockquote> <p>One applicable method m1 is more specific than another applicable method m2, for an invocation with argument expressions e1, ..., ek, if any of the following are true: <ul> <li>m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by §18.5.4.</li> <li>m2 is not generic, and m1 and m2 are applicable by strict or loose invocation, and where m1 has formal parameter types S1, ..., Sn and m2 has formal parameter types T1, ..., Tn, the type Si is more specific than Ti for argument ei for all i (1 ≤ i ≤ n, n = k).</li> <li>m2 is not generic, and m1 and m2 are applicable by variable arity invocation, and where the first k variable arity parameter types of m1 are S1, ..., Sk and the first k variable arity parameter types of m2 are T1, ..., Tk, the type Si is more specific than Ti for argument ei for all i (1 ≤ i ≤ k). Additionally, if m2 has k+1 parameters, then the k+1'th variable arity parameter type of m1 is a subtype of the k+1'th variable arity parameter type of m2.</li> </ul></p> <p>The above conditions are the only circumstances under which one method may be more specific than another.</p> <p>A type S is more specific than a type T for any expression if S <: T (§4.10).</p> </blockquote>
 */
public static class JLS_15_12_2_5_Java8_Test {
  @Before public void setUp() throws Exception {
    Assume.assumeTrue(ClassFileVersion.of(JLS_15_12_2_5_Java8_Test.class).isAtLeast(JAVA_V8));
  }
  @Test public void with_single_arg() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.oneArg(isNull())).thenReturn("ok");
    assertThat(mock.oneArg(null)).describedAs("Most specific method chosen for matcher and for null").isEqualTo("ok");
  }
  @Test public void with_single_arg_and_null_Object_reference() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.oneArg(isNull())).thenReturn("ok");
    Object arg=null;
    assertThat(mock.oneArg(arg)).describedAs("not the stubbed method").isEqualTo(null);
  }
  @Test public void with_variable_arg() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs(isNull())).thenReturn("ok");
    assertThat(mock.varargs(null)).describedAs("Most specific method chosen for matcher and for null").isEqualTo("ok");
  }
  @Test public void with_variable_arg_and_null_Object_array() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs(isNull())).thenReturn("ok");
    Object[] args=null;
    assertThat(mock.varargs(args)).describedAs("Most specific method chosen for matcher").isEqualTo(null);
  }
  @Test public void with_variable_arg_and_null_Object_arg() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs(isNull())).thenReturn("ok");
    Object arg=null;
    assertThat(mock.varargs(arg)).describedAs("Most specific method chosen for matcher").isEqualTo(null);
  }
}
