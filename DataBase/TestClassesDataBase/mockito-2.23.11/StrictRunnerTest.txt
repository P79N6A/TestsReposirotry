public class StrictRunnerTest extends TestBase {
  JUnitCore runner=new JUnitCore();
  @Test public void succeeds_when_all_stubs_were_used(){
    Result result=runner.run(StubbingInConstructorUsed.class,StubbingInBeforeUsed.class,StubbingInTestUsed.class);
    JUnitResultAssert.assertThat(result).isSuccessful();
  }
  @Test public void fails_when_stubs_were_not_used(){
    Class[] tests={StubbingInConstructorUnused.class,StubbingInBeforeUnused.class,StubbingInTestUnused.class};
    Result result=runner.run(tests);
    JUnitResultAssert.assertThat(result).fails(3,UnnecessaryStubbingException.class);
  }
  @Test public void does_not_report_unused_stubs_when_different_failure_is_present(){
    Result result=runner.run(WithUnrelatedAssertionFailure.class);
    JUnitResultAssert.assertThat(result).fails(1,MyAssertionError.class);
  }
  @Test public void runner_can_coexist_with_rule(){
    Result result=runner.run(RunnerAndRule.class);
    JUnitResultAssert.assertThat(result).fails(1,UnnecessaryStubbingException.class);
  }
  @Test public void runner_in_multi_threaded_tests(){
    Result result=runner.run(StubUsedFromDifferentThread.class);
    JUnitResultAssert.assertThat(result).isSuccessful();
  }
@RunWith(MockitoJUnitRunner.class) public static class StubbingInConstructorUsed extends StubbingInConstructorUnused {
    @Test public void test(){
      assertEquals("1",mock.simpleMethod(1));
    }
  }
@RunWith(MockitoJUnitRunner.Strict.class) public static class StubbingInConstructorUnused {
    IMethods mock=when(mock(IMethods.class).simpleMethod(1)).thenReturn("1").getMock();
    @Test public void dummy(){
    }
  }
@RunWith(MockitoJUnitRunner.class) public static class StubbingInBeforeUsed extends StubbingInBeforeUnused {
    @Test public void test(){
      assertEquals("1",mock.simpleMethod(1));
    }
  }
@RunWith(MockitoJUnitRunner.class) public static class StubbingInBeforeUnused {
    @Mock IMethods mock;
    @Before public void before(){
      when(mock.simpleMethod(1)).thenReturn("1");
    }
    @Test public void dummy(){
    }
  }
@RunWith(MockitoJUnitRunner.class) public static class StubbingInTestUsed {
    @Test public void test(){
      IMethods mock=mock(IMethods.class);
      when(mock.simpleMethod(1)).thenReturn("1");
      assertEquals("1",mock.simpleMethod(1));
    }
  }
@RunWith(MockitoJUnitRunner.class) public static class StubbingInTestUnused {
    @Test public void test(){
      IMethods mock=mock(IMethods.class);
      when(mock.simpleMethod(1)).thenReturn("1");
      mock.simpleMethod(2);
    }
  }
private static class MyAssertionError extends AssertionError {
  }
@RunWith(MockitoJUnitRunner.class) public static class WithUnrelatedAssertionFailure {
    IMethods mock=mock(IMethods.class);
    IMethods mock2=mock(IMethods.class);
    @Before public void before(){
      when(mock2.simpleMethod("unused stubbing")).thenReturn("");
    }
    @Test public void passing_test(){
      when(mock.simpleMethod(1)).thenReturn("1");
      assertEquals("1",mock.simpleMethod(1));
    }
    @Test public void failing_test(){
      throw new MyAssertionError();
    }
  }
@RunWith(MockitoJUnitRunner.class) public static class RunnerAndRule {
    public @Rule MockitoRule rule=MockitoJUnit.rule();
    IMethods mock=mock(IMethods.class);
    @Test public void passing_test(){
      when(mock.simpleMethod(1)).thenReturn("1");
      mock.simpleMethod(2);
    }
  }
@RunWith(MockitoJUnitRunner.class) public static class StubUsedFromDifferentThread {
    IMethods mock=mock(IMethods.class);
    @Test public void passing_test() throws Exception {
      when(mock.simpleMethod(1)).thenReturn("1");
      Thread t=new Thread(){
        public void run(){
          mock.simpleMethod(1);
        }
      }
;
      t.start();
      t.join();
    }
  }
}
