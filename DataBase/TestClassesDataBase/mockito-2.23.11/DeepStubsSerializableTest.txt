public class DeepStubsSerializableTest {
  @Test public void should_serialize_and_deserialize_mock_created_with_deep_stubs() throws Exception {
    SampleClass sampleClass=mock(SampleClass.class,withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
    when(sampleClass.getSample().isFalse()).thenReturn(true);
    when(sampleClass.getSample().number()).thenReturn(999);
    SampleClass deserializedSample=serializeAndBack(sampleClass);
    assertThat(deserializedSample.getSample().isFalse()).isEqualTo(true);
    assertThat(deserializedSample.getSample().number()).isEqualTo(999);
  }
  @Test public void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs() throws Exception {
    ListContainer deep_stubbed=mock(ListContainer.class,withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
    when(deep_stubbed.iterator().next().add("yes")).thenReturn(true);
    ListContainer deserialized_deep_stub=serializeAndBack(deep_stubbed);
    assertThat(deserialized_deep_stub.iterator().next().add("not stubbed but mock already previously resolved")).isEqualTo(false);
    assertThat(deserialized_deep_stub.iterator().next().add("yes")).isEqualTo(true);
  }
  @Test(expected=ClassCastException.class) public void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {
    ListContainer deep_stubbed=mock(ListContainer.class,withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
    when(deep_stubbed.iterator().hasNext()).thenReturn(true);
    ListContainer deserialized_deep_stub=serializeAndBack(deep_stubbed);
    when(deserialized_deep_stub.iterator().next().get(42)).thenReturn("no");
  }
static class SampleClass implements Serializable {
    SampleClass2 getSample(){
      return new SampleClass2();
    }
  }
static class SampleClass2 implements Serializable {
    boolean isFalse(){
      return false;
    }
    int number(){
      return 100;
    }
  }
static class Container<E> implements Iterable<E>, Serializable {
    private E e;
    public Container(    E e){
      this.e=e;
    }
    public E get(){
      return e;
    }
    public Iterator<E> iterator(){
      return new Iterator<E>(){
        public boolean hasNext(){
          return true;
        }
        public E next(){
          return e;
        }
        public void remove(){
        }
      }
;
    }
  }
static class ListContainer extends Container<List<String>> {
    public ListContainer(    List<String> list){
      super(list);
    }
  }
}
