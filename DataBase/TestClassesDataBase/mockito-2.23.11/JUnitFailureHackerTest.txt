public class JUnitFailureHackerTest extends TestBase {
  JUnitFailureHacker hacker=new JUnitFailureHacker();
  @Test public void shouldReplaceException() throws Exception {
    RuntimeException actualExc=new RuntimeException("foo");
    Failure failure=new Failure(Description.EMPTY,actualExc);
    hacker.appendWarnings(failure,"unused stubbing");
    assertEquals(ExceptionIncludingMockitoWarnings.class,failure.getException().getClass());
    assertEquals(actualExc,failure.getException().getCause());
    Assertions.assertThat(actualExc.getStackTrace()).isEqualTo(failure.getException().getStackTrace());
  }
  @Test public void shouldAppendWarning() throws Exception {
    Failure failure=new Failure(Description.EMPTY,new RuntimeException("foo"));
    hacker.appendWarnings(failure,"unused stubbing blah");
    assertThat(failure.getException()).hasMessageContaining("unused stubbing blah");
  }
  @Test public void shouldNotAppendWhenNoWarnings() throws Exception {
    RuntimeException ex=new RuntimeException("foo");
    Failure failure=new Failure(Description.EMPTY,ex);
    hacker.appendWarnings(failure,"");
    assertEquals(ex,failure.getException());
  }
  @Test public void shouldNotAppendWhenNullWarnings() throws Exception {
    RuntimeException ex=new RuntimeException("foo");
    Failure failure=new Failure(Description.EMPTY,ex);
    hacker.appendWarnings(failure,null);
    assertEquals(ex,failure.getException());
  }
  @Test public void shouldPrintTheWarningSoICanSeeIt() throws Exception {
    Failure failure=new Failure(Description.EMPTY,new RuntimeException("foo"));
    hacker.appendWarnings(failure,"unused stubbing blah");
    System.out.println(failure.getException());
  }
}
