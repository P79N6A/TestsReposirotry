public class StrictnessPerStubbingTest {
  MockitoSession mockito;
  @Mock IMethods mock;
  @Before public void before(){
    mockito=Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
  }
  @Test public void potential_stubbing_problem(){
    when(mock.simpleMethod("1")).thenReturn("1");
    lenient().when(mock.differentMethod("2")).thenReturn("2");
    mock.differentMethod("200");
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call() throws Throwable {
        ProductionCode.simpleMethod(mock,"100");
      }
    }
).isInstanceOf(PotentialStubbingProblem.class);
  }
  @Test public void doReturn_syntax(){
    lenient().doReturn("2").doReturn("3").when(mock).simpleMethod(1);
    mock.simpleMethod(200);
    assertEquals("2",mock.simpleMethod(1));
    assertEquals("3",mock.simpleMethod(1));
  }
  @Test public void doReturn_varargs_syntax(){
    lenient().doReturn("2","3").when(mock).simpleMethod(1);
    mock.simpleMethod(200);
    assertEquals("2",mock.simpleMethod(1));
    assertEquals("3",mock.simpleMethod(1));
  }
  @Test public void doThrow_syntax(){
    lenient().doThrow(IllegalArgumentException.class).doThrow(IllegalStateException.class).when(mock).simpleMethod(1);
    mock.simpleMethod(200);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call() throws Throwable {
        mock.simpleMethod(1);
      }
    }
).isInstanceOf(IllegalArgumentException.class);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call() throws Throwable {
        mock.simpleMethod(1);
      }
    }
).isInstanceOf(IllegalStateException.class);
  }
  @Test public void doThrow_vararg_syntax(){
    lenient().doThrow(IllegalArgumentException.class,IllegalStateException.class).when(mock).simpleMethod(1);
    mock.simpleMethod(200);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call() throws Throwable {
        mock.simpleMethod(1);
      }
    }
).isInstanceOf(IllegalArgumentException.class);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call() throws Throwable {
        mock.simpleMethod(1);
      }
    }
).isInstanceOf(IllegalStateException.class);
  }
  @Test public void doThrow_instance_vararg_syntax(){
    lenient().doThrow(new IllegalArgumentException(),new IllegalStateException()).when(mock).simpleMethod(1);
    mock.simpleMethod(200);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call() throws Throwable {
        mock.simpleMethod(1);
      }
    }
).isInstanceOf(IllegalArgumentException.class);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call() throws Throwable {
        mock.simpleMethod(1);
      }
    }
).isInstanceOf(IllegalStateException.class);
  }
static class Counter {
    int increment(    int x){
      return x + 1;
    }
    void scream(    String message){
      throw new RuntimeException(message);
    }
  }
  @Test public void doCallRealMethod_syntax(){
    Counter mock=mock(Counter.class);
    lenient().doCallRealMethod().when(mock).increment(1);
    assertEquals(0,mock.increment(0));
    assertEquals(2,mock.increment(1));
  }
  @Test public void doNothing_syntax(){
    final Counter spy=spy(Counter.class);
    lenient().doNothing().when(spy).scream("1");
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call() throws Throwable {
        spy.scream("2");
      }
    }
).hasMessage("2");
    spy.scream("1");
  }
  @Test public void doAnswer_syntax(){
    lenient().doAnswer(AdditionalAnswers.returnsFirstArg()).when(mock).simpleMethod("1");
    mock.simpleMethod("200");
    assertEquals("1",mock.simpleMethod("1"));
  }
  @Test public void unnecessary_stubbing(){
    when(mock.simpleMethod("1")).thenReturn("1");
    lenient().when(mock.differentMethod("2")).thenReturn("2");
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call() throws Throwable {
        mockito.finishMocking();
      }
    }
).isInstanceOf(UnnecessaryStubbingException.class).hasMessageContaining("1. -> ").isNot(TestBase.hasMessageContaining("2. ->"));
  }
  @Test public void unnecessary_stubbing_with_doReturn(){
    lenient().doReturn("2").when(mock).differentMethod("2");
    mockito.finishMocking();
  }
  @Test public void verify_no_more_invocations(){
    when(mock.simpleMethod("1")).thenReturn("1");
    lenient().when(mock.differentMethod("2")).thenReturn("2");
    mock.simpleMethod("1");
    mock.differentMethod("200");
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call() throws Throwable {
        verifyNoMoreInteractions(mock);
      }
    }
).isInstanceOf(NoInteractionsWanted.class).hasMessageContaining("1. ->").hasMessageContaining("2. [?]->");
  }
  @After public void after(){
    mockito.finishMocking();
  }
}
