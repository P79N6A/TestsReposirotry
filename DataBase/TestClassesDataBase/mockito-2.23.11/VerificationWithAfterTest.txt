public class VerificationWithAfterTest {
  @Rule public MockitoRule mockito=rule();
  @Mock private IMethods mock;
  private Runnable callMock=new Runnable(){
    public void run(){
      mock.oneArg('1');
    }
  }
;
  private AsyncTesting async=new AsyncTesting();
  private Stopwatch watch=createNotStarted();
  @After public void tearDown(){
    async.cleanUp();
  }
  @Test public void should_verify_with_after(){
    async.runAfter(10,callMock);
    async.runAfter(1000,callMock);
    verify(mock,after(300)).oneArg('1');
  }
  @Test public void should_verify_with_after_and_fail(){
    async.runAfter(10,callMock);
    async.runAfter(40,callMock);
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,after(600)).oneArg('1');
      }
    }
).isInstanceOf(TooManyActualInvocations.class);
  }
  @Test public void should_verify_with_time_x(){
    async.runAfter(10,callMock);
    async.runAfter(50,callMock);
    async.runAfter(600,callMock);
    verify(mock,after(300).times(2)).oneArg('1');
  }
  @Test public void should_verify_with_time_x_and_fail(){
    async.runAfter(10,callMock);
    async.runAfter(40,callMock);
    async.runAfter(80,callMock);
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,after(300).times(2)).oneArg('1');
      }
    }
).isInstanceOf(TooManyActualInvocations.class);
  }
  @Test public void should_verify_with_at_least(){
    async.runAfter(10,callMock);
    async.runAfter(50,callMock);
    verify(mock,after(300).atLeastOnce()).oneArg('1');
  }
  @Test public void should_verify_with_at_least_and_fail(){
    async.runAfter(10,callMock);
    async.runAfter(50,callMock);
    async.runAfter(600,callMock);
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,after(300).atLeast(3)).oneArg('1');
      }
    }
).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted *at least* 3 times");
  }
  @Test public void should_verify_with_at_most(){
    async.runAfter(10,callMock);
    async.runAfter(50,callMock);
    async.runAfter(600,callMock);
    verify(mock,after(300).atMost(2)).oneArg('1');
  }
  @Test public void should_verify_with_at_most_and_fail(){
    async.runAfter(10,callMock);
    async.runAfter(50,callMock);
    async.runAfter(600,callMock);
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,after(300).atMost(1)).oneArg('1');
      }
    }
).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted at most 1 time but was 2");
  }
  @Test public void should_verify_with_never(){
    async.runAfter(500,callMock);
    verify(mock,after(50).never()).oneArg('1');
  }
  @Test public void should_verify_with_never_and_fail(){
    async.runAfter(10,callMock);
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,after(300).never()).oneArg('1');
      }
    }
).isInstanceOf(MoreThanAllowedActualInvocations.class).hasMessageContaining("Wanted at most 0 times but was 1");
  }
  @Test public void should_verify_with_only(){
    async.runAfter(10,callMock);
    async.runAfter(600,callMock);
    verify(mock,after(300).only()).oneArg('1');
  }
  @Test public void should_verify_with_only_and_fail(){
    async.runAfter(10,callMock);
    async.runAfter(50,callMock);
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,after(300).only()).oneArg('1');
      }
    }
).isInstanceOf(AssertionError.class).hasMessageContaining("No interactions wanted here");
  }
  @Test public void should_fail_early_when_at_most_is_used(){
    watch.start();
    async.runAfter(50,callMock);
    async.runAfter(100,callMock);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call(){
        verify(mock,after(10000).atMost(1)).oneArg('1');
      }
    }
).isInstanceOf(MoreThanAllowedActualInvocations.class);
    watch.assertElapsedTimeIsLessThan(2000,MILLISECONDS);
  }
  @Test public void should_fail_early_when_never_is_used(){
    watch.start();
    async.runAfter(50,callMock);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call(){
        verify(mock,after(10000).never()).oneArg('1');
      }
    }
).isInstanceOf(MoreThanAllowedActualInvocations.class);
    watch.assertElapsedTimeIsLessThan(2000,MILLISECONDS);
  }
  @Test @Ignore public void should_fail_early_when_only_is_used(){
    watch.start();
    async.runAfter(50,callMock);
    async.runAfter(100,callMock);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call(){
        verify(mock,after(10000).only()).oneArg('1');
      }
    }
).isInstanceOf(NoInteractionsWanted.class);
    watch.assertElapsedTimeIsLessThan(2000,MILLISECONDS);
  }
  @Test @Ignore public void should_fail_early_when_time_x_is_used(){
    watch.start();
    async.runAfter(50,callMock);
    async.runAfter(100,callMock);
    assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call(){
        verify(mock,after(10000).times(1)).oneArg('1');
      }
    }
).isInstanceOf(NoInteractionsWanted.class);
    watch.assertElapsedTimeIsLessThan(2000,MILLISECONDS);
  }
}
