@SuppressWarnings("unchecked") public class MocksCreationTest extends TestBase {
private class HasPrivateConstructor {
  }
  @Test public void should_create_mock_when_constructor_is_private(){
    assertNotNull(Mockito.mock(HasPrivateConstructor.class));
  }
  @Test public void should_combine_mock_name_and_smart_nulls(){
    IMethods mock=mock(IMethods.class,withSettings().defaultAnswer(RETURNS_SMART_NULLS).name("great mockie"));
    IMethods smartNull=mock.iMethodsReturningMethod();
    String name=mock.toString();
    assertThat(name).contains("great mockie");
    try {
      smartNull.simpleMethod();
      fail();
    }
 catch (    SmartNullPointerException e) {
    }
  }
  @Test public void should_combine_mock_name_and_extra_interfaces(){
    IMethods mock=mock(IMethods.class,withSettings().extraInterfaces(List.class).name("great mockie"));
    String name=mock.toString();
    assertThat(name).contains("great mockie");
    assertTrue(mock instanceof List);
  }
  @Test public void should_specify_mock_name_via_settings(){
    IMethods mock=mock(IMethods.class,withSettings().name("great mockie"));
    String name=mock.toString();
    assertThat(name).contains("great mockie");
  }
  @Test public void should_scream_when_spy_created_with_wrong_type(){
    List list=new LinkedList();
    try {
      mock(List.class,withSettings().spiedInstance(list));
      fail();
    }
 catch (    MockitoException e) {
    }
  }
  @SuppressWarnings({"CheckReturnValue","MockitoUsage"}) @Test public void should_allow_creating_spies_with_correct_type(){
    List list=new LinkedList();
    mock(LinkedList.class,withSettings().spiedInstance(list));
  }
  @Test public void should_allow_inline_mock_creation(){
    when(mock(Set.class).isEmpty()).thenReturn(false);
  }
  @Retention(RetentionPolicy.RUNTIME) @interface SomeAnnotation {}
@SomeAnnotation static class Foo {
  }
  @Test public void should_strip_annotations(){
    Foo withAnnotations=mock(Foo.class);
    Foo withoutAnnotations=mock(Foo.class,withSettings().withoutAnnotations());
    assertTrue(withAnnotations.getClass().isAnnotationPresent(SomeAnnotation.class));
    assertFalse(withoutAnnotations.getClass().isAnnotationPresent(SomeAnnotation.class));
  }
}
