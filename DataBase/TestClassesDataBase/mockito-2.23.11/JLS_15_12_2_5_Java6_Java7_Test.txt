/** 
 * The JLS ยง15.12.2.5 states that the compiler must chose the most specific overload in Java 6 or Java 7, but with generics in the matcher, <strong>javac</strong> selects the upper bound, which is  {@code Object}, as such javac selects the most generic method. https://docs.oracle.com/javase/specs/jls/se6/html/expressions.html#15.12.2.5 https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5 <blockquote> <p>If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run-time method dispatch. The Java programming language uses the rule that the most specific method is chosen.</p> <p>The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time type error.</p> </blockquote>
 */
public static class JLS_15_12_2_5_Java6_Java7_Test {
  @Before public void setUp() throws Exception {
    Assume.assumeTrue(ClassFileVersion.of(JLS_15_12_2_5_Java6_Java7_Test.class).equals(JAVA_V6) || ClassFileVersion.of(JLS_15_12_2_5_Java6_Java7_Test.class).equals(JAVA_V7));
  }
  @Test public void with_single_arg() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.oneArg(isNull())).thenReturn("ok");
    assertThat(mock.oneArg(null)).describedAs("Most generic method chosen for matcher " + "(isNull generic upper bound is Object), but null applies " + "to select most specific method").isEqualTo(null);
  }
  @Test public void with_single_arg_and_matcher_cast() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.oneArg((String)isNull())).thenReturn("ok");
    assertThat(mock.oneArg(null)).describedAs("Most specific method enforced for matcher via cast").isEqualTo("ok");
  }
  @Test public void with_single_arg_and_null_Object_reference() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.oneArg(isNull())).thenReturn("ok");
    Object arg=null;
    assertThat(mock.oneArg(arg)).describedAs("Most generic method chosen for matcher").isEqualTo("ok");
  }
  @Test public void with_variable_arg() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs(isNull())).thenReturn("ok");
    assertThat(mock.varargs(null)).describedAs("Most generic method chosen for matcher " + "(isNull generic upper bound is Object), but null applies " + "to select most specific method").isEqualTo(null);
  }
  @Test public void with_variable_arg_and_matcher_String_cast() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs((String)isNull())).thenReturn("ok");
    assertThat(mock.varargs(null)).describedAs("Most specific method enforced for matcher via String cast").isEqualTo("ok");
  }
  @Test public void with_variable_arg_and_matcher_String_array_cast() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs((String[])isNull())).thenReturn("ok");
    assertThat(mock.varargs(null)).describedAs("Most specific method enforced for matcher via String[] cast").isEqualTo("ok");
  }
  @Test public void with_variable_arg_and_null_Object_array() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs(isNull())).thenReturn("ok");
    Object[] args=null;
    assertThat(mock.varargs(args)).describedAs("isNull matcher generic upper bound is Object").isEqualTo("ok");
  }
  @Test public void with_variable_arg_and_null_Object_arg() throws Exception {
    SingleOverload mock=mock(SingleOverload.class);
    when(mock.varargs(isNull())).thenReturn("ok");
    Object arg=null;
    assertThat(mock.varargs(arg)).describedAs("isNull matcher generic upper bound is Object").isEqualTo("ok");
  }
}
