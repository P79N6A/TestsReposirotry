/** 
 * This test is an experimental use of Mockito API to simulate static mocking. Other frameworks can use it to build good support for static mocking. Keep in mind that clean code never needs to mock static methods. This test is a documentation how it can be done using current public API of Mockito. This test is not only an experiment it also provides coverage for some of the advanced public API exposed for framework integrators. <p> For more rationale behind this experimental test <a href="https://www.linkedin.com/pulse/mockito-vs-powermock-opinionated-dogmatic-static-mocking-faber">see the article</a>.
 */
public class StaticMockingExperimentTest extends TestBase {
  Foo mock=Mockito.mock(Foo.class);
  MockHandler handler=Mockito.mockingDetails(mock).getMockHandler();
  Method staticMethod;
  InvocationFactory.RealMethodBehavior realMethod=new InvocationFactory.RealMethodBehavior(){
    @Override public Object call() throws Throwable {
      return null;
    }
  }
;
  @Before public void before() throws Throwable {
    staticMethod=Foo.class.getDeclaredMethod("staticMethod",String.class);
  }
  @SuppressWarnings({"CheckReturnValue","MockitoUsage"}) @Test public void verify_static_method() throws Throwable {
    Invocation invocation=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"some arg");
    handler.handle(invocation);
    verify(mock);
    Invocation verification=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"some arg");
    handler.handle(verification);
    verify(mock,times(0));
    Invocation differentArg=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"different arg");
    handler.handle(differentArg);
  }
  @SuppressWarnings({"CheckReturnValue","MockitoUsage"}) @Test public void verification_failure_static_method() throws Throwable {
    Invocation invocation=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"foo");
    handler.handle(invocation);
    verify(mock);
    Invocation differentArg=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"different arg");
    try {
      handler.handle(differentArg);
      fail();
    }
 catch (    ArgumentsAreDifferent e) {
    }
  }
  @Test public void stubbing_static_method() throws Throwable {
    Invocation invocation=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"foo");
    handler.handle(invocation);
    when(null).thenReturn("hey");
    assertEquals("hey",handler.handle(invocation));
    assertEquals("hey",handler.handle(invocation));
    Invocation differentArg=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"different arg");
    assertEquals(null,handler.handle(differentArg));
  }
  @Test public void do_answer_stubbing_static_method() throws Throwable {
    doReturn("hey").when(mock);
    Invocation invocation=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"foo");
    handler.handle(invocation);
    assertEquals("hey",handler.handle(invocation));
    assertEquals("hey",handler.handle(invocation));
    Invocation differentArg=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"different arg");
    assertEquals(null,handler.handle(differentArg));
  }
  @Test public void verify_no_more_interactions() throws Throwable {
    verifyNoMoreInteractions(mock);
    Invocation invocation=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),staticMethod,realMethod,"foo");
    handler.handle(invocation);
    try {
      verifyNoMoreInteractions(mock);
      fail();
    }
 catch (    NoInteractionsWanted e) {
    }
  }
  @Test public void stubbing_new() throws Throwable {
    Constructor<Foo> ctr=Foo.class.getConstructor(String.class);
    Method adapter=ConstructorMethodAdapter.class.getDeclaredMethods()[0];
    doReturn(new Foo("hey!")).when(mock);
    Invocation constructor=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),adapter,realMethod,ctr,"foo");
    handler.handle(constructor);
    Object result=handler.handle(constructor);
    assertEquals("foo:hey!",result.toString());
    Invocation differentArg=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),adapter,realMethod,ctr,"different arg");
    Object result2=handler.handle(differentArg);
    assertEquals(null,result2);
  }
  @SuppressWarnings({"CheckReturnValue","MockitoUsage"}) @Test public void verifying_new() throws Throwable {
    Constructor<Foo> ctr=Foo.class.getConstructor(String.class);
    Method adapter=ConstructorMethodAdapter.class.getDeclaredMethods()[0];
    Invocation constructor=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),adapter,realMethod,ctr,"matching arg");
    handler.handle(constructor);
    verify(mock);
    handler.handle(constructor);
    verify(mock);
    Invocation differentArg=Mockito.framework().getInvocationFactory().createInvocation(mock,withSettings().build(Foo.class),adapter,realMethod,ctr,"different arg");
    try {
      handler.handle(differentArg);
      fail();
    }
 catch (    WantedButNotInvoked e) {
      assertThat(e.getMessage()).contains("matching arg").contains("different arg");
    }
  }
static class Foo {
    private final String arg;
    public Foo(    String arg){
      this.arg=arg;
    }
    public static String staticMethod(    String arg){
      return "";
    }
    @Override public String toString(){
      return "foo:" + arg;
    }
  }
  /** 
 * Adapts constructor to method calls needed to work with Mockito API.
 */
interface ConstructorMethodAdapter {
    Object construct(    Constructor constructor,    Object... args);
  }
}
