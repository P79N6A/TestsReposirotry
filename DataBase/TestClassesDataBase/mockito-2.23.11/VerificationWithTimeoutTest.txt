public class VerificationWithTimeoutTest {
  @Rule public MockitoRule mockito=rule();
  private Stopwatch watch=createNotStarted();
  @Mock private IMethods mock;
  private AsyncTesting async;
  @Before public void setUp(){
    async=new AsyncTesting();
  }
  @After public void tearDown(){
    async.cleanUp();
  }
  @Test public void should_verify_with_timeout(){
    async.runAfter(50,callMock('c'));
    async.runAfter(500,callMock('c'));
    verify(mock,timeout(200).only()).oneArg('c');
    verify(mock).oneArg('c');
  }
  @Test public void should_verify_with_timeout_and_fail(){
    async.runAfter(200,callMock('c'));
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,timeout(50).only()).oneArg('c');
      }
    }
).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted but not invoked");
  }
  @Test @Ignore public void should_verify_with_timeout_and_fail_early(){
    callMock('c');
    callMock('c');
    watch.start();
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,timeout(2000)).oneArg('c');
      }
    }
).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted but not invoked");
    watch.assertElapsedTimeIsLessThan(1000,TimeUnit.MILLISECONDS);
  }
  @Test public void should_verify_with_times_x(){
    async.runAfter(50,callMock('c'));
    async.runAfter(100,callMock('c'));
    async.runAfter(600,callMock('c'));
    verify(mock,timeout(300).times(2)).oneArg('c');
  }
  @Test public void should_verify_with_times_x_and_fail(){
    async.runAfter(10,callMock('c'));
    async.runAfter(200,callMock('c'));
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,timeout(100).times(2)).oneArg('c');
      }
    }
).isInstanceOf(TooLittleActualInvocations.class);
  }
  @Test public void should_verify_with_at_least(){
    async.runAfter(10,callMock('c'));
    async.runAfter(50,callMock('c'));
    verify(mock,timeout(200).atLeast(2)).oneArg('c');
  }
  @Test public void should_verify_with_at_least_once(){
    async.runAfter(10,callMock('c'));
    async.runAfter(50,callMock('c'));
    verify(mock,timeout(200).atLeastOnce()).oneArg('c');
  }
  @Test public void should_verify_with_at_least_and_fail(){
    async.runAfter(10,callMock('c'));
    async.runAfter(50,callMock('c'));
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      public void call(){
        verify(mock,timeout(100).atLeast(3)).oneArg('c');
      }
    }
).isInstanceOf(TooLittleActualInvocations.class);
  }
  @Test public void should_verify_with_only(){
    async.runAfter(10,callMock('c'));
    async.runAfter(300,callMock('c'));
    verify(mock,timeout(100).only()).oneArg('c');
  }
  @Test @Ignore("not testable, probably timeout().only() does not make sense") public void should_verify_with_only_and_fail(){
    async.runAfter(10,callMock('c'));
    async.runAfter(50,callMock('c'));
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,after(200).only()).oneArg('c');
      }
    }
).isInstanceOf(AssertionError.class);
  }
  @Test @Ignore public void should_verify_with_only_and_fail_early(){
    callMock('c');
    callMock('c');
    watch.start();
    Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable(){
      @Override public void call(){
        verify(mock,timeout(2000).only()).oneArg('c');
      }
    }
).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted but not invoked");
    watch.assertElapsedTimeIsLessThan(1000,TimeUnit.MILLISECONDS);
  }
  private Runnable callMock(  final char c){
    return new Runnable(){
      @Override public void run(){
        mock.oneArg(c);
      }
    }
;
  }
}
