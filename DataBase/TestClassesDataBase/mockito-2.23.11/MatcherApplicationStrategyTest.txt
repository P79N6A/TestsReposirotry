@SuppressWarnings("unchecked") public class MatcherApplicationStrategyTest extends TestBase {
  @Mock IMethods mock;
  private Invocation invocation;
  private List matchers;
  private RecordingAction recordAction;
  @Before public void before(){
    recordAction=new RecordingAction();
  }
  @Test public void shouldKnowWhenActualArgsSizeIsDifferent1(){
    invocation=varargs("1");
    matchers=asList(new Equals("1"));
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(RETURN_ALWAYS_FALSE);
    assertFalse(match);
  }
  @Test public void shouldKnowWhenActualArgsSizeIsDifferent2(){
    invocation=varargs("1");
    matchers=asList(new Equals("1"));
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
    assertTrue(match);
  }
  @Test public void shouldKnowWhenActualArgsSizeIsDifferent(){
    invocation=varargs("1","2");
    matchers=asList(new Equals("1"));
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
    assertFalse(match);
  }
  @Test public void shouldKnowWhenMatchersSizeIsDifferent(){
    invocation=varargs("1");
    matchers=asList(new Equals("1"),new Equals("2"));
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
    assertFalse(match);
  }
  @Test public void shouldKnowWhenVarargsMatch(){
    invocation=varargs("1","2","3");
    matchers=asList(new Equals("1"),Any.ANY,new InstanceOf(String.class));
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    assertTrue(match);
  }
  @Test public void shouldAllowAnyVarargMatchEntireVararg(){
    invocation=varargs("1","2");
    matchers=asList(ANY);
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    assertTrue(match);
  }
  @Test public void shouldNotAllowAnyObjectWithMixedVarargs(){
    invocation=mixedVarargs(1,"1","2");
    matchers=asList(new Equals(1));
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    assertFalse(match);
  }
  @Test public void shouldAllowAnyObjectWithMixedVarargs(){
    invocation=mixedVarargs(1,"1","2");
    matchers=asList(new Equals(1),ANY);
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    assertTrue(match);
  }
  @Test public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs(){
    invocation=mixedVarargs(1,"1","2");
    matchers=asList(new Equals(1));
    boolean match=getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    assertFalse(match);
    recordAction.assertIsEmpty();
  }
  @Test public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull(){
    invocation=mixedVarargs(null,null,"2");
    matchers=asList(new Equals(null),ANY);
    getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    recordAction.assertContainsExactly(new Equals(null),ANY,ANY);
  }
  @Test public void shouldMatchAnyVarargEvenIfMatcherIsDecorated(){
    invocation=varargs("1","2");
    matchers=asList(ANY);
    getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    recordAction.assertContainsExactly(ANY,ANY);
  }
  @Test public void shouldMatchAnyVarargEvenIfMatcherIsWrappedInHamcrestMatcher(){
    invocation=varargs("1","2");
    HamcrestArgumentMatcher argumentMatcher=new HamcrestArgumentMatcher(new IntMatcher());
    matchers=asList(argumentMatcher);
    getMatcherApplicationStrategyFor(invocation,matchers).forEachMatcherAndArgument(recordAction);
    recordAction.assertContainsExactly(argumentMatcher,argumentMatcher);
  }
class IntMatcher extends BaseMatcher<Integer> implements VarargMatcher {
    public boolean matches(    Object o){
      return true;
    }
    public void describeTo(    Description description){
    }
  }
  private Invocation mixedVarargs(  Object a,  String... s){
    mock.mixedVarargs(a,s);
    return getLastInvocation();
  }
  private Invocation varargs(  String... s){
    mock.varargs(s);
    return getLastInvocation();
  }
private class RecordingAction implements ArgumentMatcherAction {
    private List<ArgumentMatcher<?>> matchers=new ArrayList<ArgumentMatcher<?>>();
    @Override public boolean apply(    ArgumentMatcher<?> matcher,    Object argument){
      matchers.add(matcher);
      return true;
    }
    public void assertIsEmpty(){
      assertThat(matchers).isEmpty();
    }
    public void assertContainsExactly(    ArgumentMatcher<?>... matchers){
      assertThat(this.matchers).containsExactly(matchers);
    }
  }
  private static final ArgumentMatcherAction RETURN_ALWAYS_TRUE=new ArgumentMatcherAction(){
    @Override public boolean apply(    ArgumentMatcher<?> matcher,    Object argument){
      return true;
    }
  }
;
  private static final ArgumentMatcherAction RETURN_ALWAYS_FALSE=new ArgumentMatcherAction(){
    @Override public boolean apply(    ArgumentMatcher<?> matcher,    Object argument){
      return false;
    }
  }
;
}
