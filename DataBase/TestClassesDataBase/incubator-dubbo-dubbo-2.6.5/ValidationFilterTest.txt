public class ValidationFilterTest {
  private Invoker<?> invoker=mock(Invoker.class);
  private Validation validation=mock(Validation.class);
  private Validator validator=mock(Validator.class);
  private RpcInvocation invocation=mock(RpcInvocation.class);
  private ValidationFilter validationFilter;
  @Before public void setUp() throws Exception {
    this.validationFilter=new ValidationFilter();
  }
  @Test public void testItWithNotExistClass() throws Exception {
    URL url=URL.valueOf("test://test:11/test?default.validation=true");
    given(validation.getValidator(url)).willThrow(new IllegalStateException("Not found class test, cause: test"));
    given(invoker.invoke(invocation)).willReturn(new RpcResult("success"));
    given(invoker.getUrl()).willReturn(url);
    given(invocation.getMethodName()).willReturn("echo1");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[]{String.class});
    given(invocation.getArguments()).willReturn(new Object[]{"arg1"});
    validationFilter.setValidation(validation);
    Result result=validationFilter.invoke(invoker,invocation);
    assertThat(result.getException().getMessage(),is("Not found class test, cause: test"));
  }
  @Test public void testItWithExistClass() throws Exception {
    URL url=URL.valueOf("test://test:11/test?default.validation=true");
    given(validation.getValidator(url)).willReturn(validator);
    given(invoker.invoke(invocation)).willReturn(new RpcResult("success"));
    given(invoker.getUrl()).willReturn(url);
    given(invocation.getMethodName()).willReturn("echo1");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[]{String.class});
    given(invocation.getArguments()).willReturn(new Object[]{"arg1"});
    validationFilter.setValidation(validation);
    Result result=validationFilter.invoke(invoker,invocation);
    assertThat(String.valueOf(result.getValue()),is("success"));
  }
  @Test public void testItWithoutUrlParameters() throws Exception {
    URL url=URL.valueOf("test://test:11/test");
    given(validation.getValidator(url)).willReturn(validator);
    given(invoker.invoke(invocation)).willReturn(new RpcResult("success"));
    given(invoker.getUrl()).willReturn(url);
    given(invocation.getMethodName()).willReturn("echo1");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[]{String.class});
    given(invocation.getArguments()).willReturn(new Object[]{"arg1"});
    validationFilter.setValidation(validation);
    Result result=validationFilter.invoke(invoker,invocation);
    assertThat(String.valueOf(result.getValue()),is("success"));
  }
  @Test public void testItWhileMethodNameStartWithDollar() throws Exception {
    URL url=URL.valueOf("test://test:11/test");
    given(validation.getValidator(url)).willReturn(validator);
    given(invoker.invoke(invocation)).willReturn(new RpcResult("success"));
    given(invoker.getUrl()).willReturn(url);
    given(invocation.getMethodName()).willReturn("$echo1");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[]{String.class});
    given(invocation.getArguments()).willReturn(new Object[]{"arg1"});
    validationFilter.setValidation(validation);
    Result result=validationFilter.invoke(invoker,invocation);
    assertThat(String.valueOf(result.getValue()),is("success"));
  }
  @Test(expected=RpcException.class) public void testItWhileThrowoutRpcException() throws Exception {
    URL url=URL.valueOf("test://test:11/test?default.validation=true");
    given(validation.getValidator(url)).willThrow(new RpcException("rpc exception"));
    given(invoker.invoke(invocation)).willReturn(new RpcResult("success"));
    given(invoker.getUrl()).willReturn(url);
    given(invocation.getMethodName()).willReturn("echo1");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[]{String.class});
    given(invocation.getArguments()).willReturn(new Object[]{"arg1"});
    validationFilter.setValidation(validation);
    validationFilter.invoke(invoker,invocation);
  }
}
