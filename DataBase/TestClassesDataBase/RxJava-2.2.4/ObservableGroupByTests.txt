public class ObservableGroupByTests {
  @Test public void testTakeUnsubscribesOnGroupBy() throws Exception {
    Observable.merge(ObservableEventStream.getEventStream("HTTP-ClusterA",50),ObservableEventStream.getEventStream("HTTP-ClusterB",20)).groupBy(new Function<Event,String>(){
      @Override public String apply(      Event event){
        return event.type;
      }
    }
).take(1).blockingForEach(new Consumer<GroupedObservable<String,Event>>(){
      @Override public void accept(      GroupedObservable<String,Event> v){
        System.out.println(v);
        v.take(1).subscribe();
      }
    }
);
    System.out.println("**** finished");
    Thread.sleep(200);
  }
  @Test public void testTakeUnsubscribesOnFlatMapOfGroupBy() throws Exception {
    Observable.merge(ObservableEventStream.getEventStream("HTTP-ClusterA",50),ObservableEventStream.getEventStream("HTTP-ClusterB",20)).groupBy(new Function<Event,String>(){
      @Override public String apply(      Event event){
        return event.type;
      }
    }
).flatMap(new Function<GroupedObservable<String,Event>,Observable<Object>>(){
      @Override public Observable<Object> apply(      GroupedObservable<String,Event> g){
        return g.map(new Function<Event,Object>(){
          @Override public Object apply(          Event event){
            return event.instanceId + " - " + event.values.get("count200");
          }
        }
);
      }
    }
).take(20).blockingForEach(new Consumer<Object>(){
      @Override public void accept(      Object pv){
        System.out.println(pv);
      }
    }
);
    System.out.println("**** finished");
    Thread.sleep(200);
  }
}
