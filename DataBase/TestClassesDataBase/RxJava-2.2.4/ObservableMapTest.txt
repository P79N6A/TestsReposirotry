public class ObservableMapTest {
  Observer<String> stringObserver;
  Observer<String> stringObserver2;
  static final BiFunction<String,Integer,String> APPEND_INDEX=new BiFunction<String,Integer,String>(){
    @Override public String apply(    String value,    Integer index){
      return value + index;
    }
  }
;
  @Before public void before(){
    stringObserver=TestHelper.mockObserver();
    stringObserver2=TestHelper.mockObserver();
  }
  @Test public void testMap(){
    Map<String,String> m1=getMap("One");
    Map<String,String> m2=getMap("Two");
    Observable<Map<String,String>> o=Observable.just(m1,m2);
    Observable<String> m=o.map(new Function<Map<String,String>,String>(){
      @Override public String apply(      Map<String,String> map){
        return map.get("firstName");
      }
    }
);
    m.subscribe(stringObserver);
    verify(stringObserver,never()).onError(any(Throwable.class));
    verify(stringObserver,times(1)).onNext("OneFirst");
    verify(stringObserver,times(1)).onNext("TwoFirst");
    verify(stringObserver,times(1)).onComplete();
  }
  @Test public void testMapMany(){
    Observable<Integer> ids=Observable.just(1,2);
    Observable<String> m=ids.flatMap(new Function<Integer,Observable<String>>(){
      @Override public Observable<String> apply(      Integer id){
        Observable<Map<String,String>> subObservable=null;
        if (id == 1) {
          Map<String,String> m1=getMap("One");
          Map<String,String> m2=getMap("Two");
          subObservable=Observable.just(m1,m2);
        }
 else {
          Map<String,String> m3=getMap("Three");
          Map<String,String> m4=getMap("Four");
          subObservable=Observable.just(m3,m4);
        }
        return subObservable.map(new Function<Map<String,String>,String>(){
          @Override public String apply(          Map<String,String> map){
            return map.get("firstName");
          }
        }
);
      }
    }
);
    m.subscribe(stringObserver);
    verify(stringObserver,never()).onError(any(Throwable.class));
    verify(stringObserver,times(1)).onNext("OneFirst");
    verify(stringObserver,times(1)).onNext("TwoFirst");
    verify(stringObserver,times(1)).onNext("ThreeFirst");
    verify(stringObserver,times(1)).onNext("FourFirst");
    verify(stringObserver,times(1)).onComplete();
  }
  @Test public void testMapMany2(){
    Map<String,String> m1=getMap("One");
    Map<String,String> m2=getMap("Two");
    Observable<Map<String,String>> observable1=Observable.just(m1,m2);
    Map<String,String> m3=getMap("Three");
    Map<String,String> m4=getMap("Four");
    Observable<Map<String,String>> observable2=Observable.just(m3,m4);
    Observable<Observable<Map<String,String>>> o=Observable.just(observable1,observable2);
    Observable<String> m=o.flatMap(new Function<Observable<Map<String,String>>,Observable<String>>(){
      @Override public Observable<String> apply(      Observable<Map<String,String>> o){
        return o.map(new Function<Map<String,String>,String>(){
          @Override public String apply(          Map<String,String> map){
            return map.get("firstName");
          }
        }
);
      }
    }
);
    m.subscribe(stringObserver);
    verify(stringObserver,never()).onError(any(Throwable.class));
    verify(stringObserver,times(1)).onNext("OneFirst");
    verify(stringObserver,times(1)).onNext("TwoFirst");
    verify(stringObserver,times(1)).onNext("ThreeFirst");
    verify(stringObserver,times(1)).onNext("FourFirst");
    verify(stringObserver,times(1)).onComplete();
  }
  @Test public void testMapWithError(){
    Observable<String> w=Observable.just("one","fail","two","three","fail");
    Observable<String> m=w.map(new Function<String,String>(){
      @Override public String apply(      String s){
        if ("fail".equals(s)) {
          throw new RuntimeException("Forced Failure");
        }
        return s;
      }
    }
).doOnError(new Consumer<Throwable>(){
      @Override public void accept(      Throwable t1){
        t1.printStackTrace();
      }
    }
);
    m.subscribe(stringObserver);
    verify(stringObserver,times(1)).onNext("one");
    verify(stringObserver,never()).onNext("two");
    verify(stringObserver,never()).onNext("three");
    verify(stringObserver,never()).onComplete();
    verify(stringObserver,times(1)).onError(any(Throwable.class));
  }
  @Test(expected=IllegalArgumentException.class) public void testMapWithIssue417(){
    Observable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer,Integer>(){
      @Override public Integer apply(      Integer arg0){
        throw new IllegalArgumentException("any error");
      }
    }
).blockingSingle();
  }
  @Test(expected=IllegalArgumentException.class) public void testMapWithErrorInFuncAndThreadPoolScheduler() throws InterruptedException {
    Observable<String> m=Observable.just("one").observeOn(Schedulers.computation()).map(new Function<String,String>(){
      @Override public String apply(      String arg0){
        throw new IllegalArgumentException("any error");
      }
    }
);
    m.blockingLast();
  }
  /** 
 * While mapping over range(1,0).last() we expect NoSuchElementException since the sequence is empty.
 */
  @Test public void testErrorPassesThruMap(){
    assertNull(Observable.range(1,0).lastElement().map(new Function<Integer,Integer>(){
      @Override public Integer apply(      Integer i){
        return i;
      }
    }
).blockingGet());
  }
  /** 
 * We expect IllegalStateException to pass thru map.
 */
  @Test(expected=IllegalStateException.class) public void testErrorPassesThruMap2(){
    Observable.error(new IllegalStateException()).map(new Function<Object,Object>(){
      @Override public Object apply(      Object i){
        return i;
      }
    }
).blockingSingle();
  }
  /** 
 * We expect an ArithmeticException exception here because last() emits a single value but then we divide by 0.
 */
  @Test(expected=ArithmeticException.class) public void testMapWithErrorInFunc(){
    Observable.range(1,1).lastElement().map(new Function<Integer,Integer>(){
      @Override public Integer apply(      Integer i){
        return i / 0;
      }
    }
).blockingGet();
  }
  private static Map<String,String> getMap(  String prefix){
    Map<String,String> m=new HashMap<String,String>();
    m.put("firstName",prefix + "First");
    m.put("lastName",prefix + "Last");
    return m;
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(Observable.range(1,5).map(Functions.identity()));
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>,ObservableSource<Object>>(){
      @Override public ObservableSource<Object> apply(      Observable<Object> o) throws Exception {
        return o.map(Functions.identity());
      }
    }
);
  }
  @Test public void fusedSync(){
    TestObserver<Integer> to=ObserverFusion.newTest(QueueFuseable.ANY);
    Observable.range(1,5).map(Functions.<Integer>identity()).subscribe(to);
    ObserverFusion.assertFusion(to,QueueFuseable.SYNC).assertResult(1,2,3,4,5);
  }
  @Test public void fusedAsync(){
    TestObserver<Integer> to=ObserverFusion.newTest(QueueFuseable.ANY);
    UnicastSubject<Integer> us=UnicastSubject.create();
    us.map(Functions.<Integer>identity()).subscribe(to);
    TestHelper.emit(us,1,2,3,4,5);
    ObserverFusion.assertFusion(to,QueueFuseable.ASYNC).assertResult(1,2,3,4,5);
  }
  @Test public void fusedReject(){
    TestObserver<Integer> to=ObserverFusion.newTest(QueueFuseable.ANY | QueueFuseable.BOUNDARY);
    Observable.range(1,5).map(Functions.<Integer>identity()).subscribe(to);
    ObserverFusion.assertFusion(to,QueueFuseable.NONE).assertResult(1,2,3,4,5);
  }
  @Test public void badSource(){
    TestHelper.checkBadSourceObservable(new Function<Observable<Object>,Object>(){
      @Override public Object apply(      Observable<Object> o) throws Exception {
        return o.map(Functions.identity());
      }
    }
,false,1,1,1);
  }
}
