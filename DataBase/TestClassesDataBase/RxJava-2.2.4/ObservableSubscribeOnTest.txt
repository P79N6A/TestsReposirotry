public class ObservableSubscribeOnTest {
  @Test(timeout=2000) public void testIssue813() throws InterruptedException {
    final CountDownLatch scheduled=new CountDownLatch(1);
    final CountDownLatch latch=new CountDownLatch(1);
    final CountDownLatch doneLatch=new CountDownLatch(1);
    TestObserver<Integer> to=new TestObserver<Integer>();
    Observable.unsafeCreate(new ObservableSource<Integer>(){
      @Override public void subscribe(      final Observer<? super Integer> observer){
        observer.onSubscribe(Disposables.empty());
        scheduled.countDown();
        try {
          try {
            latch.await();
          }
 catch (          InterruptedException e) {
          }
          observer.onComplete();
        }
 catch (        Throwable e) {
          observer.onError(e);
        }
 finally {
          doneLatch.countDown();
        }
      }
    }
).subscribeOn(Schedulers.computation()).subscribe(to);
    scheduled.await();
    to.dispose();
    latch.countDown();
    doneLatch.await();
    to.assertNoErrors();
    to.assertComplete();
  }
  @Test @Ignore("ObservableSource.subscribe can't throw") public void testThrownErrorHandling(){
    TestObserver<String> to=new TestObserver<String>();
    Observable.unsafeCreate(new ObservableSource<String>(){
      @Override public void subscribe(      Observer<? super String> observer){
        throw new RuntimeException("fail");
      }
    }
).subscribeOn(Schedulers.computation()).subscribe(to);
    to.awaitTerminalEvent(1000,TimeUnit.MILLISECONDS);
    to.assertTerminated();
  }
  @Test public void testOnError(){
    TestObserver<String> to=new TestObserver<String>();
    Observable.unsafeCreate(new ObservableSource<String>(){
      @Override public void subscribe(      Observer<? super String> observer){
        observer.onSubscribe(Disposables.empty());
        observer.onError(new RuntimeException("fail"));
      }
    }
).subscribeOn(Schedulers.computation()).subscribe(to);
    to.awaitTerminalEvent(1000,TimeUnit.MILLISECONDS);
    to.assertTerminated();
  }
public static class SlowScheduler extends Scheduler {
    final Scheduler actual;
    final long delay;
    final TimeUnit unit;
    public SlowScheduler(){
      this(Schedulers.computation(),2,TimeUnit.SECONDS);
    }
    public SlowScheduler(    Scheduler actual,    long delay,    TimeUnit unit){
      this.actual=actual;
      this.delay=delay;
      this.unit=unit;
    }
    @NonNull @Override public Worker createWorker(){
      return new SlowInner(actual.createWorker());
    }
private final class SlowInner extends Worker {
      private final Scheduler.Worker actualInner;
      private SlowInner(      Worker actual){
        this.actualInner=actual;
      }
      @Override public void dispose(){
        actualInner.dispose();
      }
      @Override public boolean isDisposed(){
        return actualInner.isDisposed();
      }
      @NonNull @Override public Disposable schedule(      @NonNull final Runnable action){
        return actualInner.schedule(action,delay,unit);
      }
      @NonNull @Override public Disposable schedule(      @NonNull final Runnable action,      final long delayTime,      @NonNull final TimeUnit delayUnit){
        TimeUnit common=delayUnit.compareTo(unit) < 0 ? delayUnit : unit;
        long t=common.convert(delayTime,delayUnit) + common.convert(delay,unit);
        return actualInner.schedule(action,t,common);
      }
    }
  }
  @Test(timeout=5000) public void testUnsubscribeInfiniteStream() throws InterruptedException {
    TestObserver<Integer> to=new TestObserver<Integer>();
    final AtomicInteger count=new AtomicInteger();
    Observable.unsafeCreate(new ObservableSource<Integer>(){
      @Override public void subscribe(      Observer<? super Integer> sub){
        Disposable d=Disposables.empty();
        sub.onSubscribe(d);
        for (int i=1; !d.isDisposed(); i++) {
          count.incrementAndGet();
          sub.onNext(i);
        }
      }
    }
).subscribeOn(Schedulers.newThread()).take(10).subscribe(to);
    to.awaitTerminalEvent(1000,TimeUnit.MILLISECONDS);
    to.dispose();
    Thread.sleep(200);
    to.assertValues(1,2,3,4,5,6,7,8,9,10);
    assertEquals(10,count.get());
  }
  @Test public void cancelBeforeActualSubscribe(){
    TestScheduler test=new TestScheduler();
    TestObserver<Integer> to=new TestObserver<Integer>();
    Observable.just(1).hide().subscribeOn(test).subscribe(to);
    to.dispose();
    test.advanceTimeBy(1,TimeUnit.SECONDS);
    to.assertSubscribed().assertNoValues().assertNotTerminated();
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(Observable.just(1).subscribeOn(Schedulers.single()));
  }
}
