private static class TestConcurrencySubscriber extends DefaultObserver<String> {
  /** 
 * used to store the order and number of events received.
 */
  private final LinkedBlockingQueue<TestConcurrencySubscriberEvent> events=new LinkedBlockingQueue<TestConcurrencySubscriberEvent>();
  private final int waitTime;
  @SuppressWarnings("unused") TestConcurrencySubscriber(  int waitTimeInNext){
    this.waitTime=waitTimeInNext;
  }
  TestConcurrencySubscriber(){
    this.waitTime=0;
  }
  @Override public void onComplete(){
    events.add(TestConcurrencySubscriberEvent.onComplete);
  }
  @Override public void onError(  Throwable e){
    events.add(TestConcurrencySubscriberEvent.onError);
  }
  @Override public void onNext(  String args){
    events.add(TestConcurrencySubscriberEvent.onNext);
    int s=0;
    for (int i=0; i < 20; i++) {
      s+=s * i;
    }
    if (waitTime > 0) {
      try {
        Thread.sleep(waitTime);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  /** 
 * Assert the order of events is correct and return the number of onNext executions.
 * @param expectedEndingEvent the expected last event
 * @return int count of onNext calls
 * @throws IllegalStateException If order of events was invalid.
 */
  public int assertEvents(  TestConcurrencySubscriberEvent expectedEndingEvent) throws IllegalStateException {
    int nextCount=0;
    boolean finished=false;
    for (    TestConcurrencySubscriberEvent e : events) {
      if (e == TestConcurrencySubscriberEvent.onNext) {
        if (finished) {
          throw new IllegalStateException("Received onNext but we're already finished.");
        }
        nextCount++;
      }
 else       if (e == TestConcurrencySubscriberEvent.onError) {
        if (finished) {
          throw new IllegalStateException("Received onError but we're already finished.");
        }
        if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onError != expectedEndingEvent) {
          throw new IllegalStateException("Received onError ending event but expected " + expectedEndingEvent);
        }
        finished=true;
      }
 else       if (e == TestConcurrencySubscriberEvent.onComplete) {
        if (finished) {
          throw new IllegalStateException("Received onComplete but we're already finished.");
        }
        if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onComplete != expectedEndingEvent) {
          throw new IllegalStateException("Received onComplete ending event but expected " + expectedEndingEvent);
        }
        finished=true;
      }
    }
    return nextCount;
  }
}
