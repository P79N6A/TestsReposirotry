public class FlowableTimeIntervalTest {
  private static final TimeUnit TIME_UNIT=TimeUnit.MILLISECONDS;
  private Subscriber<Timed<Integer>> subscriber;
  private TestScheduler testScheduler;
  private PublishProcessor<Integer> processor;
  private Flowable<Timed<Integer>> flowable;
  @Before public void setUp(){
    subscriber=TestHelper.mockSubscriber();
    testScheduler=new TestScheduler();
    processor=PublishProcessor.create();
    flowable=processor.timeInterval(testScheduler);
  }
  @Test public void testTimeInterval(){
    InOrder inOrder=inOrder(subscriber);
    flowable.subscribe(subscriber);
    testScheduler.advanceTimeBy(1000,TIME_UNIT);
    processor.onNext(1);
    testScheduler.advanceTimeBy(2000,TIME_UNIT);
    processor.onNext(2);
    testScheduler.advanceTimeBy(3000,TIME_UNIT);
    processor.onNext(3);
    processor.onComplete();
    inOrder.verify(subscriber,times(1)).onNext(new Timed<Integer>(1,1000,TIME_UNIT));
    inOrder.verify(subscriber,times(1)).onNext(new Timed<Integer>(2,2000,TIME_UNIT));
    inOrder.verify(subscriber,times(1)).onNext(new Timed<Integer>(3,3000,TIME_UNIT));
    inOrder.verify(subscriber,times(1)).onComplete();
    inOrder.verifyNoMoreInteractions();
  }
  @Test public void timeIntervalDefault(){
    final TestScheduler scheduler=new TestScheduler();
    RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler,Scheduler>(){
      @Override public Scheduler apply(      Scheduler v) throws Exception {
        return scheduler;
      }
    }
);
    try {
      Flowable.range(1,5).timeInterval().map(new Function<Timed<Integer>,Long>(){
        @Override public Long apply(        Timed<Integer> v) throws Exception {
          return v.time();
        }
      }
).test().assertResult(0L,0L,0L,0L,0L);
    }
  finally {
      RxJavaPlugins.reset();
    }
  }
  @Test public void timeIntervalDefaultSchedulerCustomUnit(){
    final TestScheduler scheduler=new TestScheduler();
    RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler,Scheduler>(){
      @Override public Scheduler apply(      Scheduler v) throws Exception {
        return scheduler;
      }
    }
);
    try {
      Flowable.range(1,5).timeInterval(TimeUnit.SECONDS).map(new Function<Timed<Integer>,Long>(){
        @Override public Long apply(        Timed<Integer> v) throws Exception {
          return v.time();
        }
      }
).test().assertResult(0L,0L,0L,0L,0L);
    }
  finally {
      RxJavaPlugins.reset();
    }
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(Flowable.just(1).timeInterval());
  }
  @SuppressWarnings("unchecked") @Test public void error(){
    Flowable.error(new TestException()).timeInterval().test().assertFailure(TestException.class);
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>,Publisher<Timed<Object>>>(){
      @Override public Publisher<Timed<Object>> apply(      Flowable<Object> f) throws Exception {
        return f.timeInterval();
      }
    }
);
  }
}
