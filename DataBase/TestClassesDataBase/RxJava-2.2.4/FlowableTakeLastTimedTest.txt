public class FlowableTakeLastTimedTest {
  @Test(expected=IndexOutOfBoundsException.class) public void testTakeLastTimedWithNegativeCount(){
    Flowable.just("one").takeLast(-1,1,TimeUnit.SECONDS);
  }
  @Test public void takeLastTimed(){
    TestScheduler scheduler=new TestScheduler();
    PublishProcessor<Object> source=PublishProcessor.create();
    Flowable<Object> result=source.takeLast(1000,TimeUnit.MILLISECONDS,scheduler);
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    InOrder inOrder=inOrder(subscriber);
    result.subscribe(subscriber);
    source.onNext(1);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(2);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(3);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(4);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(5);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onComplete();
    inOrder.verify(subscriber,times(1)).onNext(2);
    inOrder.verify(subscriber,times(1)).onNext(3);
    inOrder.verify(subscriber,times(1)).onNext(4);
    inOrder.verify(subscriber,times(1)).onNext(5);
    inOrder.verify(subscriber,times(1)).onComplete();
    verify(subscriber,never()).onError(any(Throwable.class));
  }
  @Test public void takeLastTimedDelayCompletion(){
    TestScheduler scheduler=new TestScheduler();
    PublishProcessor<Object> source=PublishProcessor.create();
    Flowable<Object> result=source.takeLast(1000,TimeUnit.MILLISECONDS,scheduler);
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    InOrder inOrder=inOrder(subscriber);
    result.subscribe(subscriber);
    source.onNext(1);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(2);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(3);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(4);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(5);
    scheduler.advanceTimeBy(1250,TimeUnit.MILLISECONDS);
    source.onComplete();
    inOrder.verify(subscriber,times(1)).onComplete();
    verify(subscriber,never()).onNext(any());
    verify(subscriber,never()).onError(any(Throwable.class));
  }
  @Test public void takeLastTimedWithCapacity(){
    TestScheduler scheduler=new TestScheduler();
    PublishProcessor<Object> source=PublishProcessor.create();
    Flowable<Object> result=source.takeLast(2,1000,TimeUnit.MILLISECONDS,scheduler);
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    InOrder inOrder=inOrder(subscriber);
    result.subscribe(subscriber);
    source.onNext(1);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(2);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(3);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(4);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(5);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onComplete();
    inOrder.verify(subscriber,times(1)).onNext(4);
    inOrder.verify(subscriber,times(1)).onNext(5);
    inOrder.verify(subscriber,times(1)).onComplete();
    verify(subscriber,never()).onError(any(Throwable.class));
  }
  @Test public void takeLastTimedThrowingSource(){
    TestScheduler scheduler=new TestScheduler();
    PublishProcessor<Object> source=PublishProcessor.create();
    Flowable<Object> result=source.takeLast(1,TimeUnit.SECONDS,scheduler);
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    InOrder inOrder=inOrder(subscriber);
    result.subscribe(subscriber);
    source.onNext(1);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(2);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(3);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(4);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(5);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onError(new TestException());
    inOrder.verify(subscriber,times(1)).onError(any(TestException.class));
    verify(subscriber,never()).onNext(any());
    verify(subscriber,never()).onComplete();
  }
  @Test public void takeLastTimedWithZeroCapacity(){
    TestScheduler scheduler=new TestScheduler();
    PublishProcessor<Object> source=PublishProcessor.create();
    Flowable<Object> result=source.takeLast(0,1,TimeUnit.SECONDS,scheduler);
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    InOrder inOrder=inOrder(subscriber);
    result.subscribe(subscriber);
    source.onNext(1);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(2);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(3);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(4);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onNext(5);
    scheduler.advanceTimeBy(250,TimeUnit.MILLISECONDS);
    source.onComplete();
    inOrder.verify(subscriber,times(1)).onComplete();
    verify(subscriber,never()).onNext(any());
    verify(subscriber,never()).onError(any(Throwable.class));
  }
  @Test public void testContinuousDelivery(){
    TestScheduler scheduler=new TestScheduler();
    TestSubscriber<Integer> ts=new TestSubscriber<Integer>(0L);
    PublishProcessor<Integer> pp=PublishProcessor.create();
    pp.takeLast(1000,TimeUnit.MILLISECONDS,scheduler).subscribe(ts);
    pp.onNext(1);
    scheduler.advanceTimeBy(500,TimeUnit.MILLISECONDS);
    pp.onNext(2);
    scheduler.advanceTimeBy(500,TimeUnit.MILLISECONDS);
    pp.onNext(3);
    scheduler.advanceTimeBy(500,TimeUnit.MILLISECONDS);
    pp.onNext(4);
    scheduler.advanceTimeBy(500,TimeUnit.MILLISECONDS);
    pp.onComplete();
    scheduler.advanceTimeBy(500,TimeUnit.MILLISECONDS);
    ts.assertNoValues();
    ts.request(1);
    ts.assertValue(3);
    scheduler.advanceTimeBy(500,TimeUnit.MILLISECONDS);
    ts.request(1);
    ts.assertValues(3,4);
    ts.assertComplete();
    ts.assertNoErrors();
  }
  @Test public void takeLastTimeAndSize(){
    Flowable.just(1,2).takeLast(1,1,TimeUnit.MINUTES).test().assertResult(2);
  }
  @Test public void takeLastTime(){
    Flowable.just(1,2).takeLast(1,TimeUnit.MINUTES).test().assertResult(1,2);
  }
  @Test public void takeLastTimeDelayError(){
    Flowable.just(1,2).concatWith(Flowable.<Integer>error(new TestException())).takeLast(1,TimeUnit.MINUTES,true).test().assertFailure(TestException.class,1,2);
  }
  @Test public void takeLastTimeDelayErrorCustomScheduler(){
    Flowable.just(1,2).concatWith(Flowable.<Integer>error(new TestException())).takeLast(1,TimeUnit.MINUTES,Schedulers.io(),true).test().assertFailure(TestException.class,1,2);
  }
  @Test public void disposed(){
    TestHelper.checkDisposed(PublishProcessor.create().takeLast(1,TimeUnit.MINUTES));
  }
  @Test public void observeOn(){
    Observable.range(1,1000).takeLast(1,TimeUnit.DAYS).take(500).observeOn(Schedulers.single(),true,1).test().awaitDone(5,TimeUnit.SECONDS).assertSubscribed().assertValueCount(500).assertNoErrors().assertComplete();
  }
  @Test public void cancelCompleteRace(){
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final PublishProcessor<Integer> pp=PublishProcessor.create();
      final TestSubscriber<Integer> ts=pp.takeLast(1,TimeUnit.DAYS).test();
      Runnable r1=new Runnable(){
        @Override public void run(){
          pp.onComplete();
        }
      }
;
      Runnable r2=new Runnable(){
        @Override public void run(){
          ts.cancel();
        }
      }
;
      TestHelper.race(r1,r2);
    }
  }
  @Test public void emptyDelayError(){
    Flowable.empty().takeLast(1,TimeUnit.DAYS,true).test().assertResult();
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>,Publisher<Object>>(){
      @Override public Publisher<Object> apply(      Flowable<Object> f) throws Exception {
        return f.takeLast(1,TimeUnit.SECONDS);
      }
    }
);
  }
  @Test public void badRequest(){
    TestHelper.assertBadRequestReported(PublishProcessor.create().takeLast(1,TimeUnit.SECONDS));
  }
}
