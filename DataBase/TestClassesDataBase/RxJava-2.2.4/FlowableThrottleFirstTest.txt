public class FlowableThrottleFirstTest {
  private TestScheduler scheduler;
  private Scheduler.Worker innerScheduler;
  private Subscriber<String> subscriber;
  @Before public void before(){
    scheduler=new TestScheduler();
    innerScheduler=scheduler.createWorker();
    subscriber=TestHelper.mockSubscriber();
  }
  @Test public void testThrottlingWithCompleted(){
    Flowable<String> source=Flowable.unsafeCreate(new Publisher<String>(){
      @Override public void subscribe(      Subscriber<? super String> subscriber){
        subscriber.onSubscribe(new BooleanSubscription());
        publishNext(subscriber,100,"one");
        publishNext(subscriber,300,"two");
        publishNext(subscriber,900,"three");
        publishNext(subscriber,905,"four");
        publishCompleted(subscriber,1000);
      }
    }
);
    Flowable<String> sampled=source.throttleFirst(400,TimeUnit.MILLISECONDS,scheduler);
    sampled.subscribe(subscriber);
    InOrder inOrder=inOrder(subscriber);
    scheduler.advanceTimeTo(1000,TimeUnit.MILLISECONDS);
    inOrder.verify(subscriber,times(1)).onNext("one");
    inOrder.verify(subscriber,times(0)).onNext("two");
    inOrder.verify(subscriber,times(1)).onNext("three");
    inOrder.verify(subscriber,times(0)).onNext("four");
    inOrder.verify(subscriber,times(1)).onComplete();
    inOrder.verifyNoMoreInteractions();
  }
  @Test public void testThrottlingWithError(){
    Flowable<String> source=Flowable.unsafeCreate(new Publisher<String>(){
      @Override public void subscribe(      Subscriber<? super String> subscriber){
        subscriber.onSubscribe(new BooleanSubscription());
        Exception error=new TestException();
        publishNext(subscriber,100,"one");
        publishNext(subscriber,200,"two");
        publishError(subscriber,300,error);
      }
    }
);
    Flowable<String> sampled=source.throttleFirst(400,TimeUnit.MILLISECONDS,scheduler);
    sampled.subscribe(subscriber);
    InOrder inOrder=inOrder(subscriber);
    scheduler.advanceTimeTo(400,TimeUnit.MILLISECONDS);
    inOrder.verify(subscriber).onNext("one");
    inOrder.verify(subscriber).onError(any(TestException.class));
    inOrder.verifyNoMoreInteractions();
  }
  private <T>void publishCompleted(  final Subscriber<T> subscriber,  long delay){
    innerScheduler.schedule(new Runnable(){
      @Override public void run(){
        subscriber.onComplete();
      }
    }
,delay,TimeUnit.MILLISECONDS);
  }
  private <T>void publishError(  final Subscriber<T> subscriber,  long delay,  final Exception error){
    innerScheduler.schedule(new Runnable(){
      @Override public void run(){
        subscriber.onError(error);
      }
    }
,delay,TimeUnit.MILLISECONDS);
  }
  private <T>void publishNext(  final Subscriber<T> subscriber,  long delay,  final T value){
    innerScheduler.schedule(new Runnable(){
      @Override public void run(){
        subscriber.onNext(value);
      }
    }
,delay,TimeUnit.MILLISECONDS);
  }
  @Test public void testThrottle(){
    Subscriber<Integer> subscriber=TestHelper.mockSubscriber();
    TestScheduler s=new TestScheduler();
    PublishProcessor<Integer> o=PublishProcessor.create();
    o.throttleFirst(500,TimeUnit.MILLISECONDS,s).subscribe(subscriber);
    s.advanceTimeTo(0,TimeUnit.MILLISECONDS);
    o.onNext(1);
    o.onNext(2);
    s.advanceTimeTo(501,TimeUnit.MILLISECONDS);
    o.onNext(3);
    s.advanceTimeTo(600,TimeUnit.MILLISECONDS);
    o.onNext(4);
    s.advanceTimeTo(700,TimeUnit.MILLISECONDS);
    o.onNext(5);
    o.onNext(6);
    s.advanceTimeTo(1001,TimeUnit.MILLISECONDS);
    o.onNext(7);
    s.advanceTimeTo(1501,TimeUnit.MILLISECONDS);
    o.onComplete();
    InOrder inOrder=inOrder(subscriber);
    inOrder.verify(subscriber).onNext(1);
    inOrder.verify(subscriber).onNext(3);
    inOrder.verify(subscriber).onNext(7);
    inOrder.verify(subscriber).onComplete();
    inOrder.verifyNoMoreInteractions();
  }
  @Test public void throttleFirstDefaultScheduler(){
    Flowable.just(1).throttleFirst(100,TimeUnit.MILLISECONDS).test().awaitDone(5,TimeUnit.SECONDS).assertResult(1);
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(Flowable.just(1).throttleFirst(1,TimeUnit.DAYS));
  }
  @Test public void badSource(){
    List<Throwable> errors=TestHelper.trackPluginErrors();
    try {
      new Flowable<Integer>(){
        @Override protected void subscribeActual(        Subscriber<? super Integer> subscriber){
          subscriber.onSubscribe(new BooleanSubscription());
          subscriber.onNext(1);
          subscriber.onNext(2);
          subscriber.onComplete();
          subscriber.onNext(3);
          subscriber.onError(new TestException());
          subscriber.onComplete();
        }
      }
.throttleFirst(1,TimeUnit.DAYS).test().assertResult(1);
      TestHelper.assertUndeliverable(errors,0,TestException.class);
    }
  finally {
      RxJavaPlugins.reset();
    }
  }
  @Test public void backpressureNoRequest(){
    Flowable.range(1,3).throttleFirst(1,TimeUnit.MINUTES).test(0L).assertFailure(MissingBackpressureException.class);
  }
}
