/** 
 * This spawns a thread for the subscription, then a separate thread for each onNext call.
 */
private static class TestMultiThreadedObservable implements ObservableSource<String> {
  final String[] values;
  Thread t;
  AtomicInteger threadsRunning=new AtomicInteger();
  AtomicInteger maxConcurrentThreads=new AtomicInteger();
  ExecutorService threadPool;
  TestMultiThreadedObservable(  String... values){
    this.values=values;
    this.threadPool=Executors.newCachedThreadPool();
  }
  @Override public void subscribe(  final Observer<? super String> observer){
    observer.onSubscribe(Disposables.empty());
    final NullPointerException npe=new NullPointerException();
    System.out.println("TestMultiThreadedObservable subscribed to ...");
    t=new Thread(new Runnable(){
      @Override public void run(){
        try {
          System.out.println("running TestMultiThreadedObservable thread");
          int j=0;
          for (          final String s : values) {
            final int fj=++j;
            threadPool.execute(new Runnable(){
              @Override public void run(){
                threadsRunning.incrementAndGet();
                try {
                  System.out.println("TestMultiThreadedObservable onNext: " + s + " on thread "+ Thread.currentThread().getName());
                  if (s == null) {
                    throw npe;
                  }
 else {
                    int sleep=(fj % 3) * 10;
                    if (sleep != 0) {
                      Thread.sleep(sleep);
                    }
                  }
                  observer.onNext(s);
                  int concurrentThreads=threadsRunning.get();
                  int maxThreads=maxConcurrentThreads.get();
                  if (concurrentThreads > maxThreads) {
                    maxConcurrentThreads.compareAndSet(maxThreads,concurrentThreads);
                  }
                }
 catch (                Throwable e) {
                  observer.onError(e);
                }
 finally {
                  threadsRunning.decrementAndGet();
                }
              }
            }
);
          }
          threadPool.shutdown();
        }
 catch (        Throwable e) {
          throw new RuntimeException(e);
        }
        try {
          if (!threadPool.awaitTermination(5,TimeUnit.SECONDS)) {
            System.out.println("Threadpool did not terminate in time.");
          }
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
        observer.onComplete();
      }
    }
);
    System.out.println("starting TestMultiThreadedObservable thread");
    t.start();
    System.out.println("done starting TestMultiThreadedObservable thread");
  }
  public void waitToFinish(){
    try {
      t.join();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
}
