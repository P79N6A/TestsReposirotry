public class ObservableOnErrorReturnTest {
  @Test public void testResumeNext(){
    TestObservable f=new TestObservable("one");
    Observable<String> w=Observable.unsafeCreate(f);
    final AtomicReference<Throwable> capturedException=new AtomicReference<Throwable>();
    Observable<String> observable=w.onErrorReturn(new Function<Throwable,String>(){
      @Override public String apply(      Throwable e){
        capturedException.set(e);
        return "failure";
      }
    }
);
    Observer<String> observer=TestHelper.mockObserver();
    observable.subscribe(observer);
    try {
      f.t.join();
    }
 catch (    InterruptedException e) {
      fail(e.getMessage());
    }
    verify(observer,Mockito.never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
    verify(observer,times(1)).onNext("one");
    verify(observer,times(1)).onNext("failure");
    assertNotNull(capturedException.get());
  }
  /** 
 * Test that when a function throws an exception this is propagated through onError.
 */
  @Test public void testFunctionThrowsError(){
    TestObservable f=new TestObservable("one");
    Observable<String> w=Observable.unsafeCreate(f);
    final AtomicReference<Throwable> capturedException=new AtomicReference<Throwable>();
    Observable<String> observable=w.onErrorReturn(new Function<Throwable,String>(){
      @Override public String apply(      Throwable e){
        capturedException.set(e);
        throw new RuntimeException("exception from function");
      }
    }
);
    Observer<String> observer=TestHelper.mockObserver();
    observable.subscribe(observer);
    try {
      f.t.join();
    }
 catch (    InterruptedException e) {
      fail(e.getMessage());
    }
    verify(observer,times(1)).onNext("one");
    verify(observer,times(1)).onError(any(Throwable.class));
    verify(observer,times(0)).onComplete();
    assertNotNull(capturedException.get());
  }
  @Test public void testMapResumeAsyncNext(){
    Observable<String> w=Observable.just("one","fail","two","three","fail");
    w=w.map(new Function<String,String>(){
      @Override public String apply(      String s){
        if ("fail".equals(s)) {
          throw new RuntimeException("Forced Failure");
        }
        System.out.println("BadMapper:" + s);
        return s;
      }
    }
);
    Observable<String> observable=w.onErrorReturn(new Function<Throwable,String>(){
      @Override public String apply(      Throwable t1){
        return "resume";
      }
    }
);
    Observer<String> observer=TestHelper.mockObserver();
    TestObserver<String> to=new TestObserver<String>(observer);
    observable.subscribe(to);
    to.awaitTerminalEvent();
    verify(observer,Mockito.never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
    verify(observer,times(1)).onNext("one");
    verify(observer,Mockito.never()).onNext("two");
    verify(observer,Mockito.never()).onNext("three");
    verify(observer,times(1)).onNext("resume");
  }
  @Test public void testBackpressure(){
    TestObserver<Integer> to=new TestObserver<Integer>();
    Observable.range(0,100000).onErrorReturn(new Function<Throwable,Integer>(){
      @Override public Integer apply(      Throwable t1){
        return 1;
      }
    }
).observeOn(Schedulers.computation()).map(new Function<Integer,Integer>(){
      int c;
      @Override public Integer apply(      Integer t1){
        if (c++ <= 1) {
          try {
            Thread.sleep(500);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
        return t1;
      }
    }
).subscribe(to);
    to.awaitTerminalEvent();
    to.assertNoErrors();
  }
private static class TestObservable implements ObservableSource<String> {
    final String[] values;
    Thread t;
    TestObservable(    String... values){
      this.values=values;
    }
    @Override public void subscribe(    final Observer<? super String> observer){
      observer.onSubscribe(Disposables.empty());
      System.out.println("TestObservable subscribed to ...");
      t=new Thread(new Runnable(){
        @Override public void run(){
          try {
            System.out.println("running TestObservable thread");
            for (            String s : values) {
              System.out.println("TestObservable onNext: " + s);
              observer.onNext(s);
            }
            throw new RuntimeException("Forced Failure");
          }
 catch (          Throwable e) {
            observer.onError(e);
          }
        }
      }
);
      System.out.println("starting TestObservable thread");
      t.start();
      System.out.println("done starting TestObservable thread");
    }
  }
  @Test public void returnItem(){
    Observable.error(new TestException()).onErrorReturnItem(1).test().assertResult(1);
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(Observable.just(1).onErrorReturnItem(1));
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>,ObservableSource<Object>>(){
      @Override public ObservableSource<Object> apply(      Observable<Object> f) throws Exception {
        return f.onErrorReturnItem(1);
      }
    }
);
  }
}
