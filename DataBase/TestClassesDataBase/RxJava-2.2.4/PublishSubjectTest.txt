public class PublishSubjectTest extends SubjectTest<Integer> {
  @Override protected Subject<Integer> create(){
    return PublishSubject.create();
  }
  @Test public void testCompleted(){
    PublishSubject<String> subject=PublishSubject.create();
    Observer<String> observer=TestHelper.mockObserver();
    subject.subscribe(observer);
    subject.onNext("one");
    subject.onNext("two");
    subject.onNext("three");
    subject.onComplete();
    Observer<String> anotherSubscriber=TestHelper.mockObserver();
    subject.subscribe(anotherSubscriber);
    subject.onNext("four");
    subject.onComplete();
    subject.onError(new Throwable());
    assertCompletedSubscriber(observer);
  }
  @Test public void testCompletedStopsEmittingData(){
    PublishSubject<Object> channel=PublishSubject.create();
    Observer<Object> observerA=TestHelper.mockObserver();
    Observer<Object> observerB=TestHelper.mockObserver();
    Observer<Object> observerC=TestHelper.mockObserver();
    TestObserver<Object> to=new TestObserver<Object>(observerA);
    channel.subscribe(to);
    channel.subscribe(observerB);
    InOrder inOrderA=inOrder(observerA);
    InOrder inOrderB=inOrder(observerB);
    InOrder inOrderC=inOrder(observerC);
    channel.onNext(42);
    inOrderA.verify(observerA).onNext(42);
    inOrderB.verify(observerB).onNext(42);
    to.dispose();
    inOrderA.verifyNoMoreInteractions();
    channel.onNext(4711);
    inOrderB.verify(observerB).onNext(4711);
    channel.onComplete();
    inOrderB.verify(observerB).onComplete();
    channel.subscribe(observerC);
    inOrderC.verify(observerC).onComplete();
    channel.onNext(13);
    inOrderB.verifyNoMoreInteractions();
    inOrderC.verifyNoMoreInteractions();
  }
  private void assertCompletedSubscriber(  Observer<String> observer){
    verify(observer,times(1)).onNext("one");
    verify(observer,times(1)).onNext("two");
    verify(observer,times(1)).onNext("three");
    verify(observer,Mockito.never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
  }
  @Test public void testError(){
    PublishSubject<String> subject=PublishSubject.create();
    Observer<String> observer=TestHelper.mockObserver();
    subject.subscribe(observer);
    subject.onNext("one");
    subject.onNext("two");
    subject.onNext("three");
    subject.onError(testException);
    Observer<String> anotherSubscriber=TestHelper.mockObserver();
    subject.subscribe(anotherSubscriber);
    subject.onNext("four");
    subject.onError(new Throwable());
    subject.onComplete();
    assertErrorSubscriber(observer);
  }
  private void assertErrorSubscriber(  Observer<String> observer){
    verify(observer,times(1)).onNext("one");
    verify(observer,times(1)).onNext("two");
    verify(observer,times(1)).onNext("three");
    verify(observer,times(1)).onError(testException);
    verify(observer,Mockito.never()).onComplete();
  }
  @Test public void testSubscribeMidSequence(){
    PublishSubject<String> subject=PublishSubject.create();
    Observer<String> observer=TestHelper.mockObserver();
    subject.subscribe(observer);
    subject.onNext("one");
    subject.onNext("two");
    assertObservedUntilTwo(observer);
    Observer<String> anotherSubscriber=TestHelper.mockObserver();
    subject.subscribe(anotherSubscriber);
    subject.onNext("three");
    subject.onComplete();
    assertCompletedSubscriber(observer);
    assertCompletedStartingWithThreeSubscriber(anotherSubscriber);
  }
  private void assertCompletedStartingWithThreeSubscriber(  Observer<String> observer){
    verify(observer,Mockito.never()).onNext("one");
    verify(observer,Mockito.never()).onNext("two");
    verify(observer,times(1)).onNext("three");
    verify(observer,Mockito.never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
  }
  @Test public void testUnsubscribeFirstSubscriber(){
    PublishSubject<String> subject=PublishSubject.create();
    Observer<String> observer=TestHelper.mockObserver();
    TestObserver<String> to=new TestObserver<String>(observer);
    subject.subscribe(to);
    subject.onNext("one");
    subject.onNext("two");
    to.dispose();
    assertObservedUntilTwo(observer);
    Observer<String> anotherSubscriber=TestHelper.mockObserver();
    subject.subscribe(anotherSubscriber);
    subject.onNext("three");
    subject.onComplete();
    assertObservedUntilTwo(observer);
    assertCompletedStartingWithThreeSubscriber(anotherSubscriber);
  }
  private void assertObservedUntilTwo(  Observer<String> observer){
    verify(observer,times(1)).onNext("one");
    verify(observer,times(1)).onNext("two");
    verify(observer,Mockito.never()).onNext("three");
    verify(observer,Mockito.never()).onError(any(Throwable.class));
    verify(observer,Mockito.never()).onComplete();
  }
  @Test public void testNestedSubscribe(){
    final PublishSubject<Integer> s=PublishSubject.create();
    final AtomicInteger countParent=new AtomicInteger();
    final AtomicInteger countChildren=new AtomicInteger();
    final AtomicInteger countTotal=new AtomicInteger();
    final ArrayList<String> list=new ArrayList<String>();
    s.flatMap(new Function<Integer,Observable<String>>(){
      @Override public Observable<String> apply(      final Integer v){
        countParent.incrementAndGet();
        return s.map(new Function<Integer,String>(){
          @Override public String apply(          Integer v2){
            countChildren.incrementAndGet();
            return "Parent: " + v + " Child: "+ v2;
          }
        }
);
      }
    }
).subscribe(new Consumer<String>(){
      @Override public void accept(      String v){
        countTotal.incrementAndGet();
        list.add(v);
      }
    }
);
    for (int i=0; i < 10; i++) {
      s.onNext(i);
    }
    s.onComplete();
    assertEquals(45,list.size());
  }
  /** 
 * Should be able to unsubscribe all Subscribers, have it stop emitting, then subscribe new ones and it start emitting again.
 */
  @Test public void testReSubscribe(){
    final PublishSubject<Integer> ps=PublishSubject.create();
    Observer<Integer> o1=TestHelper.mockObserver();
    TestObserver<Integer> to=new TestObserver<Integer>(o1);
    ps.subscribe(to);
    ps.onNext(1);
    InOrder inOrder1=inOrder(o1);
    inOrder1.verify(o1,times(1)).onNext(1);
    inOrder1.verifyNoMoreInteractions();
    to.dispose();
    ps.onNext(2);
    Observer<Integer> o2=TestHelper.mockObserver();
    TestObserver<Integer> to2=new TestObserver<Integer>(o2);
    ps.subscribe(to2);
    ps.onNext(3);
    InOrder inOrder2=inOrder(o2);
    inOrder2.verify(o2,times(1)).onNext(3);
    inOrder2.verifyNoMoreInteractions();
    to2.dispose();
  }
  private final Throwable testException=new Throwable();
  @Test(timeout=1000) public void testUnsubscriptionCase(){
    PublishSubject<String> src=PublishSubject.create();
    for (int i=0; i < 10; i++) {
      final Observer<Object> o=TestHelper.mockObserver();
      InOrder inOrder=inOrder(o);
      String v="" + i;
      System.out.printf("Turn: %d%n",i);
      src.firstElement().toObservable().flatMap(new Function<String,Observable<String>>(){
        @Override public Observable<String> apply(        String t1){
          return Observable.just(t1 + ", " + t1);
        }
      }
).subscribe(new DefaultObserver<String>(){
        @Override public void onNext(        String t){
          o.onNext(t);
        }
        @Override public void onError(        Throwable e){
          o.onError(e);
        }
        @Override public void onComplete(){
          o.onComplete();
        }
      }
);
      src.onNext(v);
      inOrder.verify(o).onNext(v + ", " + v);
      inOrder.verify(o).onComplete();
      verify(o,never()).onError(any(Throwable.class));
    }
  }
  @Test public void testCurrentStateMethodsNormal(){
    PublishSubject<Object> as=PublishSubject.create();
    assertFalse(as.hasThrowable());
    assertFalse(as.hasComplete());
    assertNull(as.getThrowable());
    as.onNext(1);
    assertFalse(as.hasThrowable());
    assertFalse(as.hasComplete());
    assertNull(as.getThrowable());
    as.onComplete();
    assertFalse(as.hasThrowable());
    assertTrue(as.hasComplete());
    assertNull(as.getThrowable());
  }
  @Test public void testCurrentStateMethodsEmpty(){
    PublishSubject<Object> as=PublishSubject.create();
    assertFalse(as.hasThrowable());
    assertFalse(as.hasComplete());
    assertNull(as.getThrowable());
    as.onComplete();
    assertFalse(as.hasThrowable());
    assertTrue(as.hasComplete());
    assertNull(as.getThrowable());
  }
  @Test public void testCurrentStateMethodsError(){
    PublishSubject<Object> as=PublishSubject.create();
    assertFalse(as.hasThrowable());
    assertFalse(as.hasComplete());
    assertNull(as.getThrowable());
    as.onError(new TestException());
    assertTrue(as.hasThrowable());
    assertFalse(as.hasComplete());
    assertTrue(as.getThrowable() instanceof TestException);
  }
  @Ignore("Observable doesn't do backpressure") @Test public void requestValidation(){
  }
  @Test public void crossCancel(){
    final TestObserver<Integer> to1=new TestObserver<Integer>();
    TestObserver<Integer> to2=new TestObserver<Integer>(){
      @Override public void onNext(      Integer t){
        super.onNext(t);
        to1.cancel();
      }
    }
;
    PublishSubject<Integer> ps=PublishSubject.create();
    ps.subscribe(to2);
    ps.subscribe(to1);
    ps.onNext(1);
    to2.assertValue(1);
    to1.assertNoValues();
  }
  @Test public void crossCancelOnError(){
    final TestObserver<Integer> to1=new TestObserver<Integer>();
    TestObserver<Integer> to2=new TestObserver<Integer>(){
      @Override public void onError(      Throwable t){
        super.onError(t);
        to1.cancel();
      }
    }
;
    PublishSubject<Integer> ps=PublishSubject.create();
    ps.subscribe(to2);
    ps.subscribe(to1);
    ps.onError(new TestException());
    to2.assertError(TestException.class);
    to1.assertNoErrors();
  }
  @Test public void crossCancelOnComplete(){
    final TestObserver<Integer> to1=new TestObserver<Integer>();
    TestObserver<Integer> to2=new TestObserver<Integer>(){
      @Override public void onComplete(){
        super.onComplete();
        to1.cancel();
      }
    }
;
    PublishSubject<Integer> ps=PublishSubject.create();
    ps.subscribe(to2);
    ps.subscribe(to1);
    ps.onComplete();
    to2.assertComplete();
    to1.assertNotComplete();
  }
  @Test @Ignore("Observable doesn't do backpressure") public void backpressureOverflow(){
  }
  @Test public void onSubscribeCancelsImmediately(){
    PublishSubject<Integer> ps=PublishSubject.create();
    TestObserver<Integer> to=ps.test();
    ps.subscribe(new Observer<Integer>(){
      @Override public void onSubscribe(      Disposable d){
        d.dispose();
        d.dispose();
      }
      @Override public void onNext(      Integer t){
      }
      @Override public void onError(      Throwable t){
      }
      @Override public void onComplete(){
      }
    }
);
    to.cancel();
    assertFalse(ps.hasObservers());
  }
  @Test public void terminateRace() throws Exception {
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final PublishSubject<Integer> ps=PublishSubject.create();
      TestObserver<Integer> to=ps.test();
      Runnable task=new Runnable(){
        @Override public void run(){
          ps.onComplete();
        }
      }
;
      TestHelper.race(task,task);
      to.awaitDone(5,TimeUnit.SECONDS).assertResult();
    }
  }
  @Test public void addRemoveRance() throws Exception {
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final PublishSubject<Integer> ps=PublishSubject.create();
      final TestObserver<Integer> to=ps.test();
      Runnable r1=new Runnable(){
        @Override public void run(){
          ps.subscribe();
        }
      }
;
      Runnable r2=new Runnable(){
        @Override public void run(){
          to.cancel();
        }
      }
;
      TestHelper.race(r1,r2);
    }
  }
  @Test public void addTerminateRance() throws Exception {
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final PublishSubject<Integer> ps=PublishSubject.create();
      Runnable r1=new Runnable(){
        @Override public void run(){
          ps.subscribe();
        }
      }
;
      Runnable r2=new Runnable(){
        @Override public void run(){
          ps.onComplete();
        }
      }
;
      TestHelper.race(r1,r2);
    }
  }
  @Test public void addCompleteRance() throws Exception {
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final PublishSubject<Integer> ps=PublishSubject.create();
      final TestObserver<Integer> to=new TestObserver<Integer>();
      Runnable r1=new Runnable(){
        @Override public void run(){
          ps.subscribe(to);
        }
      }
;
      Runnable r2=new Runnable(){
        @Override public void run(){
          ps.onComplete();
        }
      }
;
      TestHelper.race(r1,r2);
      to.awaitDone(5,TimeUnit.SECONDS).assertResult();
    }
  }
  @Test public void subscribeToAfterComplete(){
    PublishSubject<Integer> ps=PublishSubject.create();
    ps.onComplete();
    PublishSubject<Integer> ps2=PublishSubject.create();
    ps2.subscribe(ps);
    assertFalse(ps2.hasObservers());
  }
  @Test public void subscribedTo(){
    PublishSubject<Integer> ps=PublishSubject.create();
    PublishSubject<Integer> ps2=PublishSubject.create();
    ps.subscribe(ps2);
    TestObserver<Integer> to=ps2.test();
    ps.onNext(1);
    ps.onNext(2);
    ps.onComplete();
    to.assertResult(1,2);
  }
}
