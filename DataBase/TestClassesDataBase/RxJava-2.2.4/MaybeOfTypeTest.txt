public class MaybeOfTypeTest {
  @Test public void normal(){
    Maybe.just(1).ofType(Integer.class).test().assertResult(1);
  }
  @Test public void normalDowncast(){
    TestObserver<Number> to=Maybe.just(1).ofType(Number.class).test();
    to.assertResult((Number)1);
  }
  @Test public void notInstance(){
    TestObserver<String> to=Maybe.just(1).ofType(String.class).test();
    to.assertResult();
  }
  @Test public void error(){
    TestObserver<Number> to=Maybe.<Integer>error(new TestException()).ofType(Number.class).test();
    to.assertFailure(TestException.class);
  }
  @Test public void errorNotInstance(){
    TestObserver<String> to=Maybe.<Integer>error(new TestException()).ofType(String.class).test();
    to.assertFailure(TestException.class);
  }
  @Test public void dispose(){
    TestHelper.checkDisposedMaybe(new Function<Maybe<Object>,Maybe<Object>>(){
      @Override public Maybe<Object> apply(      Maybe<Object> m) throws Exception {
        return m.ofType(Object.class);
      }
    }
);
  }
  @Test public void isDisposed(){
    PublishProcessor<Integer> pp=PublishProcessor.create();
    TestHelper.checkDisposed(pp.singleElement().ofType(Object.class));
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Object>,Maybe<Object>>(){
      @Override public Maybe<Object> apply(      Maybe<Object> f) throws Exception {
        return f.ofType(Object.class);
      }
    }
);
  }
}
