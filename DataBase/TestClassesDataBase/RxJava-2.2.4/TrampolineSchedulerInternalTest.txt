public class TrampolineSchedulerInternalTest {
  @Test public void scheduleDirectInterrupt(){
    Thread.currentThread().interrupt();
    final int[] calls={0};
    assertSame(EmptyDisposable.INSTANCE,Schedulers.trampoline().scheduleDirect(new Runnable(){
      @Override public void run(){
        calls[0]++;
      }
    }
,1,TimeUnit.SECONDS));
    assertTrue(Thread.interrupted());
    assertEquals(0,calls[0]);
  }
  @Test public void dispose(){
    Worker w=Schedulers.trampoline().createWorker();
    assertFalse(w.isDisposed());
    w.dispose();
    assertTrue(w.isDisposed());
    assertEquals(EmptyDisposable.INSTANCE,w.schedule(Functions.EMPTY_RUNNABLE));
  }
  @Test public void reentrantScheduleDispose(){
    final Worker w=Schedulers.trampoline().createWorker();
    try {
      final int[] calls={0,0};
      w.schedule(new Runnable(){
        @Override public void run(){
          calls[0]++;
          w.schedule(new Runnable(){
            @Override public void run(){
              calls[1]++;
            }
          }
).dispose();
        }
      }
);
      assertEquals(1,calls[0]);
      assertEquals(0,calls[1]);
    }
  finally {
      w.dispose();
    }
  }
  @Test public void reentrantScheduleShutdown(){
    final Worker w=Schedulers.trampoline().createWorker();
    try {
      final int[] calls={0,0};
      w.schedule(new Runnable(){
        @Override public void run(){
          calls[0]++;
          w.schedule(new Runnable(){
            @Override public void run(){
              calls[1]++;
            }
          }
,1,TimeUnit.MILLISECONDS);
          w.dispose();
        }
      }
);
      assertEquals(1,calls[0]);
      assertEquals(0,calls[1]);
    }
  finally {
      w.dispose();
    }
  }
  @Test public void reentrantScheduleShutdown2(){
    final Worker w=Schedulers.trampoline().createWorker();
    try {
      final int[] calls={0,0};
      w.schedule(new Runnable(){
        @Override public void run(){
          calls[0]++;
          w.dispose();
          assertSame(EmptyDisposable.INSTANCE,w.schedule(new Runnable(){
            @Override public void run(){
              calls[1]++;
            }
          }
,1,TimeUnit.MILLISECONDS));
        }
      }
);
      assertEquals(1,calls[0]);
      assertEquals(0,calls[1]);
    }
  finally {
      w.dispose();
    }
  }
  @Test(timeout=5000) public void reentrantScheduleInterrupt(){
    final Worker w=Schedulers.trampoline().createWorker();
    try {
      final int[] calls={0};
      Thread.currentThread().interrupt();
      w.schedule(new Runnable(){
        @Override public void run(){
          calls[0]++;
        }
      }
,1,TimeUnit.DAYS);
      assertTrue(Thread.interrupted());
      assertEquals(0,calls[0]);
    }
  finally {
      w.dispose();
    }
  }
  @Test public void sleepingRunnableDisposedOnRun(){
    TrampolineWorker w=new TrampolineWorker();
    Runnable r=mock(Runnable.class);
    SleepingRunnable run=new SleepingRunnable(r,w,0);
    w.dispose();
    run.run();
    verify(r,never()).run();
  }
  @Test public void sleepingRunnableNoDelayRun(){
    TrampolineWorker w=new TrampolineWorker();
    Runnable r=mock(Runnable.class);
    SleepingRunnable run=new SleepingRunnable(r,w,0);
    run.run();
    verify(r).run();
  }
  @Test public void sleepingRunnableDisposedOnDelayedRun(){
    final TrampolineWorker w=new TrampolineWorker();
    Runnable r=mock(Runnable.class);
    SleepingRunnable run=new SleepingRunnable(r,w,System.currentTimeMillis() + 200);
    Schedulers.single().scheduleDirect(new Runnable(){
      @Override public void run(){
        w.dispose();
      }
    }
,100,TimeUnit.MILLISECONDS);
    run.run();
    verify(r,never()).run();
  }
}
