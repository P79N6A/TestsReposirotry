public class FutureSingleObserverTest {
  @Test public void cancel(){
    final Future<?> f=Single.never().toFuture();
    assertFalse(f.isCancelled());
    assertFalse(f.isDone());
    f.cancel(true);
    assertTrue(f.isCancelled());
    assertTrue(f.isDone());
    try {
      f.get();
      fail("Should have thrown!");
    }
 catch (    CancellationException ex) {
    }
catch (    InterruptedException ex) {
      throw new AssertionError(ex);
    }
catch (    ExecutionException ex) {
      throw new AssertionError(ex);
    }
    try {
      f.get(5,TimeUnit.SECONDS);
      fail("Should have thrown!");
    }
 catch (    CancellationException ex) {
    }
catch (    InterruptedException ex) {
      throw new AssertionError(ex);
    }
catch (    ExecutionException ex) {
      throw new AssertionError(ex);
    }
catch (    TimeoutException ex) {
      throw new AssertionError(ex);
    }
  }
  @Test public void cancelRace(){
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final Future<?> f=Single.never().toFuture();
      Runnable r=new Runnable(){
        @Override public void run(){
          f.cancel(true);
        }
      }
;
      TestHelper.race(r,r);
    }
  }
  @Test public void timeout() throws Exception {
    Future<?> f=Single.never().toFuture();
    try {
      f.get(100,TimeUnit.MILLISECONDS);
      fail("Should have thrown");
    }
 catch (    TimeoutException expected) {
      assertEquals(timeoutMessage(100,TimeUnit.MILLISECONDS),expected.getMessage());
    }
  }
  @Test public void dispose(){
    Future<Integer> f=Single.just(1).toFuture();
    ((Disposable)f).dispose();
    assertTrue(((Disposable)f).isDisposed());
  }
  @Test public void errorGetWithTimeout() throws Exception {
    Future<?> f=Single.error(new TestException()).toFuture();
    try {
      f.get(5,TimeUnit.SECONDS);
      fail("Should have thrown");
    }
 catch (    ExecutionException ex) {
      assertTrue(ex.toString(),ex.getCause() instanceof TestException);
    }
  }
  @Test public void normalGetWitHTimeout() throws Exception {
    Future<Integer> f=Single.just(1).toFuture();
    assertEquals(1,f.get(5,TimeUnit.SECONDS).intValue());
  }
  @Test public void getAwait() throws Exception {
    Future<Integer> f=Single.just(1).delay(100,TimeUnit.MILLISECONDS).toFuture();
    assertEquals(1,f.get(5,TimeUnit.SECONDS).intValue());
  }
  @Test public void onSuccessCancelRace(){
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final PublishSubject<Integer> ps=PublishSubject.create();
      final Future<?> f=ps.single(-99).toFuture();
      ps.onNext(1);
      Runnable r1=new Runnable(){
        @Override public void run(){
          f.cancel(true);
        }
      }
;
      Runnable r2=new Runnable(){
        @Override public void run(){
          ps.onComplete();
        }
      }
;
      TestHelper.race(r1,r2);
    }
  }
  @Test public void onErrorCancelRace(){
    RxJavaPlugins.setErrorHandler(Functions.emptyConsumer());
    try {
      for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
        final PublishSubject<Integer> ps=PublishSubject.create();
        final Future<?> f=ps.single(-99).toFuture();
        final TestException ex=new TestException();
        Runnable r1=new Runnable(){
          @Override public void run(){
            f.cancel(true);
          }
        }
;
        Runnable r2=new Runnable(){
          @Override public void run(){
            ps.onError(ex);
          }
        }
;
        TestHelper.race(r1,r2);
      }
    }
  finally {
      RxJavaPlugins.reset();
    }
  }
}
