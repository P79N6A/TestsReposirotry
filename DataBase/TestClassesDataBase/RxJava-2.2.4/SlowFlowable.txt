static final class SlowFlowable implements Publisher<Long> {
  final AtomicInteger efforts=new AtomicInteger(0);
  final AtomicInteger active=new AtomicInteger(0);
  final AtomicInteger maxActive=new AtomicInteger(0);
  final AtomicInteger nextBeforeFailure;
  final String context;
  private final int emitDelay;
  SlowFlowable(  int emitDelay,  int countNext,  String context){
    this.emitDelay=emitDelay;
    this.nextBeforeFailure=new AtomicInteger(countNext);
    this.context=context;
  }
  @Override public void subscribe(  final Subscriber<? super Long> subscriber){
    final AtomicBoolean terminate=new AtomicBoolean(false);
    subscriber.onSubscribe(new Subscription(){
      @Override public void request(      long n){
      }
      @Override public void cancel(){
        terminate.set(true);
        active.decrementAndGet();
      }
    }
);
    efforts.getAndIncrement();
    active.getAndIncrement();
    maxActive.set(Math.max(active.get(),maxActive.get()));
    final Thread thread=new Thread(context){
      @Override public void run(){
        long nr=0;
        try {
          while (!terminate.get()) {
            Thread.sleep(emitDelay);
            if (nextBeforeFailure.getAndDecrement() > 0) {
              subscriber.onNext(nr++);
            }
 else {
              active.decrementAndGet();
              subscriber.onError(new RuntimeException("expected-failed"));
              break;
            }
          }
        }
 catch (        InterruptedException t) {
        }
      }
    }
;
    thread.start();
  }
}
