public class ObservableDoOnUnsubscribeTest {
  @Test public void testDoOnUnsubscribe() throws Exception {
    int subCount=3;
    final CountDownLatch upperLatch=new CountDownLatch(subCount);
    final CountDownLatch lowerLatch=new CountDownLatch(subCount);
    final CountDownLatch onNextLatch=new CountDownLatch(subCount);
    final AtomicInteger upperCount=new AtomicInteger();
    final AtomicInteger lowerCount=new AtomicInteger();
    Observable<Long> longs=Observable.interval(50,TimeUnit.MILLISECONDS).doOnDispose(new Action(){
      @Override public void run(){
        upperLatch.countDown();
        upperCount.incrementAndGet();
      }
    }
).doOnNext(new Consumer<Long>(){
      @Override public void accept(      Long aLong){
        onNextLatch.countDown();
      }
    }
).doOnDispose(new Action(){
      @Override public void run(){
        lowerLatch.countDown();
        lowerCount.incrementAndGet();
      }
    }
);
    List<Disposable> subscriptions=new ArrayList<Disposable>();
    List<TestObserver<Long>> subscribers=new ArrayList<TestObserver<Long>>();
    for (int i=0; i < subCount; ++i) {
      TestObserver<Long> observer=new TestObserver<Long>();
      subscriptions.add(observer);
      longs.subscribe(observer);
      subscribers.add(observer);
    }
    onNextLatch.await();
    for (int i=0; i < subCount; ++i) {
      subscriptions.get(i).dispose();
    }
    upperLatch.await();
    lowerLatch.await();
    assertEquals(String.format("There should exactly %d un-subscription events for upper stream",subCount),subCount,upperCount.get());
    assertEquals(String.format("There should exactly %d un-subscription events for lower stream",subCount),subCount,lowerCount.get());
  }
  @Test public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
    int subCount=3;
    final CountDownLatch upperLatch=new CountDownLatch(1);
    final CountDownLatch lowerLatch=new CountDownLatch(1);
    final CountDownLatch onNextLatch=new CountDownLatch(subCount);
    final AtomicInteger upperCount=new AtomicInteger();
    final AtomicInteger lowerCount=new AtomicInteger();
    Observable<Long> longs=Observable.interval(50,TimeUnit.MILLISECONDS).doOnDispose(new Action(){
      @Override public void run(){
        upperLatch.countDown();
        upperCount.incrementAndGet();
      }
    }
).doOnNext(new Consumer<Long>(){
      @Override public void accept(      Long aLong){
        onNextLatch.countDown();
      }
    }
).doOnDispose(new Action(){
      @Override public void run(){
        lowerLatch.countDown();
        lowerCount.incrementAndGet();
      }
    }
).publish().refCount();
    List<Disposable> subscriptions=new ArrayList<Disposable>();
    List<TestObserver<Long>> subscribers=new ArrayList<TestObserver<Long>>();
    for (int i=0; i < subCount; ++i) {
      TestObserver<Long> observer=new TestObserver<Long>();
      longs.subscribe(observer);
      subscriptions.add(observer);
      subscribers.add(observer);
    }
    onNextLatch.await();
    for (int i=0; i < subCount; ++i) {
      subscriptions.get(i).dispose();
    }
    upperLatch.await();
    lowerLatch.await();
    assertEquals("There should exactly 1 un-subscription events for upper stream",1,upperCount.get());
    assertEquals("There should exactly 1 un-subscription events for lower stream",1,lowerCount.get());
  }
  @Test public void noReentrantDispose(){
    final AtomicInteger disposeCalled=new AtomicInteger();
    final BehaviorSubject<Integer> s=BehaviorSubject.create();
    s.doOnDispose(new Action(){
      @Override public void run() throws Exception {
        disposeCalled.incrementAndGet();
        s.onNext(2);
      }
    }
).firstOrError().subscribe().dispose();
    assertEquals(1,disposeCalled.get());
  }
}
