public class FlowableTakeUntilPredicateTest {
  @Test public void takeEmpty(){
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    Flowable.empty().takeUntil(new Predicate<Object>(){
      @Override public boolean test(      Object v){
        return true;
      }
    }
).subscribe(subscriber);
    verify(subscriber,never()).onNext(any());
    verify(subscriber,never()).onError(any(Throwable.class));
    verify(subscriber).onComplete();
  }
  @Test public void takeAll(){
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    Flowable.just(1,2).takeUntil(new Predicate<Integer>(){
      @Override public boolean test(      Integer v){
        return false;
      }
    }
).subscribe(subscriber);
    verify(subscriber).onNext(1);
    verify(subscriber).onNext(2);
    verify(subscriber,never()).onError(any(Throwable.class));
    verify(subscriber).onComplete();
  }
  @Test public void takeFirst(){
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    Flowable.just(1,2).takeUntil(new Predicate<Integer>(){
      @Override public boolean test(      Integer v){
        return true;
      }
    }
).subscribe(subscriber);
    verify(subscriber).onNext(1);
    verify(subscriber,never()).onNext(2);
    verify(subscriber,never()).onError(any(Throwable.class));
    verify(subscriber).onComplete();
  }
  @Test public void takeSome(){
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    Flowable.just(1,2,3).takeUntil(new Predicate<Integer>(){
      @Override public boolean test(      Integer t1){
        return t1 == 2;
      }
    }
).subscribe(subscriber);
    verify(subscriber).onNext(1);
    verify(subscriber).onNext(2);
    verify(subscriber,never()).onNext(3);
    verify(subscriber,never()).onError(any(Throwable.class));
    verify(subscriber).onComplete();
  }
  @Test public void functionThrows(){
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    Predicate<Integer> predicate=new Predicate<Integer>(){
      @Override public boolean test(      Integer t1){
        throw new TestException("Forced failure");
      }
    }
;
    Flowable.just(1,2,3).takeUntil(predicate).subscribe(subscriber);
    verify(subscriber).onNext(1);
    verify(subscriber,never()).onNext(2);
    verify(subscriber,never()).onNext(3);
    verify(subscriber).onError(any(TestException.class));
    verify(subscriber,never()).onComplete();
  }
  @Test public void sourceThrows(){
    Subscriber<Object> subscriber=TestHelper.mockSubscriber();
    Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException())).concatWith(Flowable.just(2)).takeUntil(new Predicate<Integer>(){
      @Override public boolean test(      Integer v){
        return false;
      }
    }
).subscribe(subscriber);
    verify(subscriber).onNext(1);
    verify(subscriber,never()).onNext(2);
    verify(subscriber).onError(any(TestException.class));
    verify(subscriber,never()).onComplete();
  }
  @Test public void backpressure(){
    TestSubscriber<Integer> ts=new TestSubscriber<Integer>(5L);
    Flowable.range(1,1000).takeUntil(new Predicate<Integer>(){
      @Override public boolean test(      Integer v){
        return false;
      }
    }
).subscribe(ts);
    ts.assertNoErrors();
    ts.assertValues(1,2,3,4,5);
    ts.assertNotComplete();
  }
  @Test public void testErrorIncludesLastValueAsCause(){
    TestSubscriber<String> ts=new TestSubscriber<String>();
    final TestException e=new TestException("Forced failure");
    Predicate<String> predicate=new Predicate<String>(){
      @Override public boolean test(      String t){
        throw e;
      }
    }
;
    Flowable.just("abc").takeUntil(predicate).subscribe(ts);
    ts.assertTerminated();
    ts.assertNotComplete();
    ts.assertError(TestException.class);
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(PublishProcessor.create().takeUntil(Functions.alwaysFalse()));
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>,Flowable<Object>>(){
      @Override public Flowable<Object> apply(      Flowable<Object> f) throws Exception {
        return f.takeUntil(Functions.alwaysFalse());
      }
    }
);
  }
  @Test public void badSource(){
    List<Throwable> errors=TestHelper.trackPluginErrors();
    try {
      new Flowable<Integer>(){
        @Override protected void subscribeActual(        Subscriber<? super Integer> subscriber){
          subscriber.onSubscribe(new BooleanSubscription());
          subscriber.onComplete();
          subscriber.onNext(1);
          subscriber.onError(new TestException());
          subscriber.onComplete();
        }
      }
.takeUntil(Functions.alwaysFalse()).test().assertResult();
      TestHelper.assertUndeliverable(errors,0,TestException.class);
    }
  finally {
      RxJavaPlugins.reset();
    }
  }
}
