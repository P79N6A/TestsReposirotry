private static final class SingleThreadEvictingHashMap<K,V> implements Map<K,V> {
  private final List<K> list=new ArrayList<K>();
  private final Map<K,V> map=new HashMap<K,V>();
  private final int maxSize;
  private final Consumer<V> evictedListener;
  SingleThreadEvictingHashMap(  int maxSize,  Consumer<V> evictedListener){
    this.maxSize=maxSize;
    this.evictedListener=evictedListener;
  }
  @Override public int size(){
    return map.size();
  }
  @Override public boolean isEmpty(){
    return map.isEmpty();
  }
  @Override public boolean containsKey(  Object key){
    return map.containsKey(key);
  }
  @Override public boolean containsValue(  Object value){
    return map.containsValue(value);
  }
  @Override public V get(  Object key){
    return map.get(key);
  }
  @Override public V put(  K key,  V value){
    list.remove(key);
    V v;
    if (maxSize > 0 && list.size() == maxSize) {
      K k=list.get(0);
      list.remove(0);
      v=map.remove(k);
    }
 else {
      v=null;
    }
    list.add(key);
    V result=map.put(key,value);
    if (v != null) {
      try {
        evictedListener.accept(v);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
    return result;
  }
  @Override public V remove(  Object key){
    list.remove(key);
    return map.remove(key);
  }
  @Override public void putAll(  Map<? extends K,? extends V> m){
    for (    Entry<? extends K,? extends V> entry : m.entrySet()) {
      put(entry.getKey(),entry.getValue());
    }
  }
  @Override public void clear(){
    list.clear();
    map.clear();
  }
  @Override public Set<K> keySet(){
    return map.keySet();
  }
  @Override public Collection<V> values(){
    return map.values();
  }
  @Override public Set<Entry<K,V>> entrySet(){
    return map.entrySet();
  }
}
