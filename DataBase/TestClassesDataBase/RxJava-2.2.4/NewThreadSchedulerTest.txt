public class NewThreadSchedulerTest extends AbstractSchedulerConcurrencyTests {
  @Override protected Scheduler getScheduler(){
    return Schedulers.newThread();
  }
  @Test @Ignore("Unhandled errors are no longer thrown") public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
    SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
  }
  @Test public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
    SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
  }
  @Test public void shutdownRejects(){
    final int[] calls={0};
    Runnable r=new Runnable(){
      @Override public void run(){
        calls[0]++;
      }
    }
;
    Scheduler s=getScheduler();
    Worker w=s.createWorker();
    w.dispose();
    assertTrue(w.isDisposed());
    assertEquals(Disposables.disposed(),w.schedule(r));
    assertEquals(Disposables.disposed(),w.schedule(r,1,TimeUnit.SECONDS));
    assertEquals(Disposables.disposed(),w.schedulePeriodically(r,1,1,TimeUnit.SECONDS));
    NewThreadWorker actual=(NewThreadWorker)w;
    CompositeDisposable cd=new CompositeDisposable();
    actual.scheduleActual(r,1,TimeUnit.SECONDS,cd);
    assertEquals(0,cd.size());
    assertEquals(0,calls[0]);
  }
  /** 
 * Regression test to ensure there is no NPE when the worker has been disposed.
 * @throws Exception on error
 */
  @Test public void npeRegression() throws Exception {
    Scheduler s=getScheduler();
    NewThreadWorker w=(NewThreadWorker)s.createWorker();
    w.dispose();
    w.scheduleActual(new Runnable(){
      @Override public void run(){
      }
    }
,0,TimeUnit.MILLISECONDS,null);
  }
}
