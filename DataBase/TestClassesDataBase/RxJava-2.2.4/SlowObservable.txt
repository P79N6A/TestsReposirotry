static final class SlowObservable implements ObservableSource<Long> {
  final AtomicInteger efforts=new AtomicInteger(0);
  final AtomicInteger active=new AtomicInteger(0), maxActive=new AtomicInteger(0);
  final AtomicInteger nextBeforeFailure;
  final String context;
  private final int emitDelay;
  SlowObservable(  int emitDelay,  int countNext,  String context){
    this.emitDelay=emitDelay;
    this.nextBeforeFailure=new AtomicInteger(countNext);
    this.context=context;
  }
  @Override public void subscribe(  final Observer<? super Long> observer){
    final AtomicBoolean terminate=new AtomicBoolean(false);
    observer.onSubscribe(Disposables.fromRunnable(new Runnable(){
      @Override public void run(){
        terminate.set(true);
        active.decrementAndGet();
      }
    }
));
    efforts.getAndIncrement();
    active.getAndIncrement();
    maxActive.set(Math.max(active.get(),maxActive.get()));
    final Thread thread=new Thread(context){
      @Override public void run(){
        long nr=0;
        try {
          while (!terminate.get()) {
            Thread.sleep(emitDelay);
            if (nextBeforeFailure.getAndDecrement() > 0) {
              observer.onNext(nr++);
            }
 else {
              active.decrementAndGet();
              observer.onError(new RuntimeException("expected-failed"));
              break;
            }
          }
        }
 catch (        InterruptedException t) {
        }
      }
    }
;
    thread.start();
  }
}
