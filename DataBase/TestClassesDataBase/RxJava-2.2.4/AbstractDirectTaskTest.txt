public class AbstractDirectTaskTest {
  @Test public void cancelSetFuture(){
    AbstractDirectTask task=new AbstractDirectTask(Functions.EMPTY_RUNNABLE){
      private static final long serialVersionUID=208585707945686116L;
    }
;
    final Boolean[] interrupted={null};
    assertFalse(task.isDisposed());
    task.dispose();
    assertTrue(task.isDisposed());
    task.dispose();
    assertTrue(task.isDisposed());
    FutureTask<Void> ft=new FutureTask<Void>(Functions.EMPTY_RUNNABLE,null){
      @Override public boolean cancel(      boolean mayInterruptIfRunning){
        interrupted[0]=mayInterruptIfRunning;
        return super.cancel(mayInterruptIfRunning);
      }
    }
;
    task.setFuture(ft);
    assertTrue(interrupted[0]);
    assertTrue(task.isDisposed());
  }
  @Test public void cancelSetFutureCurrentThread(){
    AbstractDirectTask task=new AbstractDirectTask(Functions.EMPTY_RUNNABLE){
      private static final long serialVersionUID=208585707945686116L;
    }
;
    final Boolean[] interrupted={null};
    assertFalse(task.isDisposed());
    task.runner=Thread.currentThread();
    task.dispose();
    assertTrue(task.isDisposed());
    task.dispose();
    assertTrue(task.isDisposed());
    FutureTask<Void> ft=new FutureTask<Void>(Functions.EMPTY_RUNNABLE,null){
      @Override public boolean cancel(      boolean mayInterruptIfRunning){
        interrupted[0]=mayInterruptIfRunning;
        return super.cancel(mayInterruptIfRunning);
      }
    }
;
    task.setFuture(ft);
    assertFalse(interrupted[0]);
    assertTrue(task.isDisposed());
  }
  @Test public void setFutureCancel(){
    AbstractDirectTask task=new AbstractDirectTask(Functions.EMPTY_RUNNABLE){
      private static final long serialVersionUID=208585707945686116L;
    }
;
    final Boolean[] interrupted={null};
    FutureTask<Void> ft=new FutureTask<Void>(Functions.EMPTY_RUNNABLE,null){
      @Override public boolean cancel(      boolean mayInterruptIfRunning){
        interrupted[0]=mayInterruptIfRunning;
        return super.cancel(mayInterruptIfRunning);
      }
    }
;
    assertFalse(task.isDisposed());
    task.setFuture(ft);
    assertFalse(task.isDisposed());
    task.dispose();
    assertTrue(task.isDisposed());
    assertTrue(interrupted[0]);
  }
  @Test public void setFutureCancelSameThread(){
    AbstractDirectTask task=new AbstractDirectTask(Functions.EMPTY_RUNNABLE){
      private static final long serialVersionUID=208585707945686116L;
    }
;
    final Boolean[] interrupted={null};
    FutureTask<Void> ft=new FutureTask<Void>(Functions.EMPTY_RUNNABLE,null){
      @Override public boolean cancel(      boolean mayInterruptIfRunning){
        interrupted[0]=mayInterruptIfRunning;
        return super.cancel(mayInterruptIfRunning);
      }
    }
;
    assertFalse(task.isDisposed());
    task.setFuture(ft);
    task.runner=Thread.currentThread();
    assertFalse(task.isDisposed());
    task.dispose();
    assertTrue(task.isDisposed());
    assertFalse(interrupted[0]);
  }
  @Test public void finished(){
    AbstractDirectTask task=new AbstractDirectTask(Functions.EMPTY_RUNNABLE){
      private static final long serialVersionUID=208585707945686116L;
    }
;
    final Boolean[] interrupted={null};
    FutureTask<Void> ft=new FutureTask<Void>(Functions.EMPTY_RUNNABLE,null){
      @Override public boolean cancel(      boolean mayInterruptIfRunning){
        interrupted[0]=mayInterruptIfRunning;
        return super.cancel(mayInterruptIfRunning);
      }
    }
;
    task.set(AbstractDirectTask.FINISHED);
    task.setFuture(ft);
    assertTrue(task.isDisposed());
    assertNull(interrupted[0]);
    task.dispose();
    assertTrue(task.isDisposed());
    assertNull(interrupted[0]);
  }
  @Test public void finishedCancel(){
    AbstractDirectTask task=new AbstractDirectTask(Functions.EMPTY_RUNNABLE){
      private static final long serialVersionUID=208585707945686116L;
    }
;
    final Boolean[] interrupted={null};
    FutureTask<Void> ft=new FutureTask<Void>(Functions.EMPTY_RUNNABLE,null){
      @Override public boolean cancel(      boolean mayInterruptIfRunning){
        interrupted[0]=mayInterruptIfRunning;
        return super.cancel(mayInterruptIfRunning);
      }
    }
;
    task.set(AbstractDirectTask.FINISHED);
    assertTrue(task.isDisposed());
    task.dispose();
    assertTrue(task.isDisposed());
    task.setFuture(ft);
    assertTrue(task.isDisposed());
    assertNull(interrupted[0]);
    assertTrue(task.isDisposed());
    assertNull(interrupted[0]);
  }
  @Test public void disposeSetFutureRace(){
    for (int i=0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
      final AbstractDirectTask task=new AbstractDirectTask(Functions.EMPTY_RUNNABLE){
        private static final long serialVersionUID=208585707945686116L;
      }
;
      final Boolean[] interrupted={null};
      final FutureTask<Void> ft=new FutureTask<Void>(Functions.EMPTY_RUNNABLE,null){
        @Override public boolean cancel(        boolean mayInterruptIfRunning){
          interrupted[0]=mayInterruptIfRunning;
          return super.cancel(mayInterruptIfRunning);
        }
      }
;
      Runnable r1=new Runnable(){
        @Override public void run(){
          task.dispose();
        }
      }
;
      Runnable r2=new Runnable(){
        @Override public void run(){
          task.setFuture(ft);
        }
      }
;
      TestHelper.race(r1,r2);
    }
  }
}
