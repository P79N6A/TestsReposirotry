public class FlowableToSortedListTest {
  @Test public void testSortedListFlowable(){
    Flowable<Integer> w=Flowable.just(1,3,2,5,4);
    Flowable<List<Integer>> flowable=w.toSortedList().toFlowable();
    Subscriber<List<Integer>> subscriber=TestHelper.mockSubscriber();
    flowable.subscribe(subscriber);
    verify(subscriber,times(1)).onNext(Arrays.asList(1,2,3,4,5));
    verify(subscriber,Mockito.never()).onError(any(Throwable.class));
    verify(subscriber,times(1)).onComplete();
  }
  @Test public void testSortedListWithCustomFunctionFlowable(){
    Flowable<Integer> w=Flowable.just(1,3,2,5,4);
    Flowable<List<Integer>> flowable=w.toSortedList(new Comparator<Integer>(){
      @Override public int compare(      Integer t1,      Integer t2){
        return t2 - t1;
      }
    }
).toFlowable();
    Subscriber<List<Integer>> subscriber=TestHelper.mockSubscriber();
    flowable.subscribe(subscriber);
    verify(subscriber,times(1)).onNext(Arrays.asList(5,4,3,2,1));
    verify(subscriber,Mockito.never()).onError(any(Throwable.class));
    verify(subscriber,times(1)).onComplete();
  }
  @Test public void testWithFollowingFirstFlowable(){
    Flowable<Integer> f=Flowable.just(1,3,2,5,4);
    assertEquals(Arrays.asList(1,2,3,4,5),f.toSortedList().toFlowable().blockingFirst());
  }
  @Test public void testBackpressureHonoredFlowable(){
    Flowable<List<Integer>> w=Flowable.just(1,3,2,5,4).toSortedList().toFlowable();
    TestSubscriber<List<Integer>> ts=new TestSubscriber<List<Integer>>(0L);
    w.subscribe(ts);
    ts.assertNoValues();
    ts.assertNoErrors();
    ts.assertNotComplete();
    ts.request(1);
    ts.assertValue(Arrays.asList(1,2,3,4,5));
    ts.assertNoErrors();
    ts.assertComplete();
    ts.request(1);
    ts.assertValue(Arrays.asList(1,2,3,4,5));
    ts.assertNoErrors();
    ts.assertComplete();
  }
  @Test(timeout=2000) @Ignore("PublishProcessor no longer emits without requests so this test fails due to the race of onComplete and request") public void testAsyncRequestedFlowable(){
    Scheduler.Worker w=Schedulers.newThread().createWorker();
    try {
      for (int i=0; i < 1000; i++) {
        if (i % 50 == 0) {
          System.out.println("testAsyncRequested -> " + i);
        }
        PublishProcessor<Integer> source=PublishProcessor.create();
        Flowable<List<Integer>> sorted=source.toSortedList().toFlowable();
        final CyclicBarrier cb=new CyclicBarrier(2);
        final TestSubscriber<List<Integer>> ts=new TestSubscriber<List<Integer>>(0L);
        sorted.subscribe(ts);
        w.schedule(new Runnable(){
          @Override public void run(){
            await(cb);
            ts.request(1);
          }
        }
);
        source.onNext(1);
        await(cb);
        source.onComplete();
        ts.awaitTerminalEvent(1,TimeUnit.SECONDS);
        ts.assertTerminated();
        ts.assertNoErrors();
        ts.assertValue(Arrays.asList(1));
      }
    }
  finally {
      w.dispose();
    }
  }
  @Test public void sorted(){
    Flowable.just(5,1,2,4,3).sorted().test().assertResult(1,2,3,4,5);
  }
  @Test public void sortedComparator(){
    Flowable.just(5,1,2,4,3).sorted(new Comparator<Integer>(){
      @Override public int compare(      Integer a,      Integer b){
        return b - a;
      }
    }
).test().assertResult(5,4,3,2,1);
  }
  @SuppressWarnings("unchecked") @Test public void toSortedListCapacityFlowable(){
    Flowable.just(5,1,2,4,3).toSortedList(4).toFlowable().test().assertResult(Arrays.asList(1,2,3,4,5));
  }
  @SuppressWarnings("unchecked") @Test public void toSortedListComparatorCapacityFlowable(){
    Flowable.just(5,1,2,4,3).toSortedList(new Comparator<Integer>(){
      @Override public int compare(      Integer a,      Integer b){
        return b - a;
      }
    }
,4).toFlowable().test().assertResult(Arrays.asList(5,4,3,2,1));
  }
  @Test public void testSortedList(){
    Flowable<Integer> w=Flowable.just(1,3,2,5,4);
    Single<List<Integer>> single=w.toSortedList();
    SingleObserver<List<Integer>> observer=TestHelper.mockSingleObserver();
    single.subscribe(observer);
    verify(observer,times(1)).onSuccess(Arrays.asList(1,2,3,4,5));
    verify(observer,Mockito.never()).onError(any(Throwable.class));
  }
  @Test public void testSortedListWithCustomFunction(){
    Flowable<Integer> w=Flowable.just(1,3,2,5,4);
    Single<List<Integer>> single=w.toSortedList(new Comparator<Integer>(){
      @Override public int compare(      Integer t1,      Integer t2){
        return t2 - t1;
      }
    }
);
    SingleObserver<List<Integer>> observer=TestHelper.mockSingleObserver();
    single.subscribe(observer);
    verify(observer,times(1)).onSuccess(Arrays.asList(5,4,3,2,1));
    verify(observer,Mockito.never()).onError(any(Throwable.class));
  }
  @Test public void testWithFollowingFirst(){
    Flowable<Integer> f=Flowable.just(1,3,2,5,4);
    assertEquals(Arrays.asList(1,2,3,4,5),f.toSortedList().blockingGet());
  }
  @Test @Ignore("Single doesn't do backpressure") public void testBackpressureHonored(){
    Single<List<Integer>> w=Flowable.just(1,3,2,5,4).toSortedList();
    TestObserver<List<Integer>> to=new TestObserver<List<Integer>>();
    w.subscribe(to);
    to.assertNoValues();
    to.assertNoErrors();
    to.assertNotComplete();
    to.assertValue(Arrays.asList(1,2,3,4,5));
    to.assertNoErrors();
    to.assertComplete();
    to.assertValue(Arrays.asList(1,2,3,4,5));
    to.assertNoErrors();
    to.assertComplete();
  }
  @Test(timeout=2000) @Ignore("PublishProcessor no longer emits without requests so this test fails due to the race of onComplete and request") public void testAsyncRequested(){
    Scheduler.Worker w=Schedulers.newThread().createWorker();
    try {
      for (int i=0; i < 1000; i++) {
        if (i % 50 == 0) {
          System.out.println("testAsyncRequested -> " + i);
        }
        PublishProcessor<Integer> source=PublishProcessor.create();
        Single<List<Integer>> sorted=source.toSortedList();
        final CyclicBarrier cb=new CyclicBarrier(2);
        final TestObserver<List<Integer>> to=new TestObserver<List<Integer>>();
        sorted.subscribe(to);
        w.schedule(new Runnable(){
          @Override public void run(){
            await(cb);
          }
        }
);
        source.onNext(1);
        await(cb);
        source.onComplete();
        to.awaitTerminalEvent(1,TimeUnit.SECONDS);
        to.assertTerminated();
        to.assertNoErrors();
        to.assertValue(Arrays.asList(1));
      }
    }
  finally {
      w.dispose();
    }
  }
  static void await(  CyclicBarrier cb){
    try {
      cb.await();
    }
 catch (    InterruptedException ex) {
      ex.printStackTrace();
    }
catch (    BrokenBarrierException ex) {
      ex.printStackTrace();
    }
  }
  @SuppressWarnings("unchecked") @Test public void toSortedListCapacity(){
    Flowable.just(5,1,2,4,3).toSortedList(4).test().assertResult(Arrays.asList(1,2,3,4,5));
  }
  @SuppressWarnings("unchecked") @Test public void toSortedListComparatorCapacity(){
    Flowable.just(5,1,2,4,3).toSortedList(new Comparator<Integer>(){
      @Override public int compare(      Integer a,      Integer b){
        return b - a;
      }
    }
,4).test().assertResult(Arrays.asList(5,4,3,2,1));
  }
}
