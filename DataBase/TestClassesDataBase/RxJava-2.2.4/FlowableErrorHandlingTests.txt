public class FlowableErrorHandlingTests {
  /** 
 * Test that an error from a user provided Observer.onNext is handled and emitted to the onError.
 * @throws InterruptedException if the test is interrupted
 */
  @Test public void testOnNextError() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicReference<Throwable> caughtError=new AtomicReference<Throwable>();
    Flowable<Long> f=Flowable.interval(50,TimeUnit.MILLISECONDS);
    Subscriber<Long> subscriber=new DefaultSubscriber<Long>(){
      @Override public void onComplete(){
        System.out.println("completed");
        latch.countDown();
      }
      @Override public void onError(      Throwable e){
        System.out.println("error: " + e);
        caughtError.set(e);
        latch.countDown();
      }
      @Override public void onNext(      Long args){
        throw new RuntimeException("forced failure");
      }
    }
;
    f.safeSubscribe(subscriber);
    latch.await(2000,TimeUnit.MILLISECONDS);
    assertNotNull(caughtError.get());
  }
  /** 
 * Test that an error from a user provided Observer.onNext is handled and emitted to the onError. even when done across thread boundaries with observeOn
 * @throws InterruptedException if the test is interrupted
 */
  @Test public void testOnNextErrorAcrossThread() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicReference<Throwable> caughtError=new AtomicReference<Throwable>();
    Flowable<Long> f=Flowable.interval(50,TimeUnit.MILLISECONDS);
    Subscriber<Long> subscriber=new DefaultSubscriber<Long>(){
      @Override public void onComplete(){
        System.out.println("completed");
        latch.countDown();
      }
      @Override public void onError(      Throwable e){
        System.out.println("error: " + e);
        caughtError.set(e);
        latch.countDown();
      }
      @Override public void onNext(      Long args){
        throw new RuntimeException("forced failure");
      }
    }
;
    f.observeOn(Schedulers.newThread()).safeSubscribe(subscriber);
    latch.await(2000,TimeUnit.MILLISECONDS);
    assertNotNull(caughtError.get());
  }
}
