static final class FlowableStripBoundary<T> extends Flowable<T> implements FlowableTransformer<T,T> {
  final Flowable<T> source;
  FlowableStripBoundary(  Flowable<T> source){
    this.source=source;
  }
  @Override public Flowable<T> apply(  Flowable<T> upstream){
    return new FlowableStripBoundary<T>(upstream);
  }
  @Override protected void subscribeActual(  Subscriber<? super T> s){
    source.subscribe(new StripBoundarySubscriber<T>(s));
  }
static final class StripBoundarySubscriber<T> implements FlowableSubscriber<T>, QueueSubscription<T> {
    final Subscriber<? super T> downstream;
    Subscription upstream;
    QueueSubscription<T> qs;
    StripBoundarySubscriber(    Subscriber<? super T> downstream){
      this.downstream=downstream;
    }
    @SuppressWarnings("unchecked") @Override public void onSubscribe(    Subscription subscription){
      this.upstream=subscription;
      if (subscription instanceof QueueSubscription) {
        qs=(QueueSubscription<T>)subscription;
      }
      downstream.onSubscribe(this);
    }
    @Override public void onNext(    T t){
      downstream.onNext(t);
    }
    @Override public void onError(    Throwable throwable){
      downstream.onError(throwable);
    }
    @Override public void onComplete(){
      downstream.onComplete();
    }
    @Override public int requestFusion(    int mode){
      QueueSubscription<T> fs=qs;
      if (fs != null) {
        return fs.requestFusion(mode & ~BOUNDARY);
      }
      return NONE;
    }
    @Override public boolean offer(    T value){
      throw new UnsupportedOperationException("Should not be called");
    }
    @Override public boolean offer(    T v1,    T v2){
      throw new UnsupportedOperationException("Should not be called");
    }
    @Override public T poll() throws Exception {
      return qs.poll();
    }
    @Override public void clear(){
      qs.clear();
    }
    @Override public boolean isEmpty(){
      return qs.isEmpty();
    }
    @Override public void request(    long n){
      upstream.request(n);
    }
    @Override public void cancel(){
      upstream.cancel();
    }
  }
}
