public class ObservableSkipLastTest {
  @Test public void testSkipLastEmpty(){
    Observable<String> o=Observable.<String>empty().skipLast(2);
    Observer<String> observer=TestHelper.mockObserver();
    o.subscribe(observer);
    verify(observer,never()).onNext(any(String.class));
    verify(observer,never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
  }
  @Test public void testSkipLast1(){
    Observable<String> o=Observable.fromIterable(Arrays.asList("one","two","three")).skipLast(2);
    Observer<String> observer=TestHelper.mockObserver();
    InOrder inOrder=inOrder(observer);
    o.subscribe(observer);
    inOrder.verify(observer,never()).onNext("two");
    inOrder.verify(observer,never()).onNext("three");
    verify(observer,times(1)).onNext("one");
    verify(observer,never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
  }
  @Test public void testSkipLast2(){
    Observable<String> o=Observable.fromIterable(Arrays.asList("one","two")).skipLast(2);
    Observer<String> observer=TestHelper.mockObserver();
    o.subscribe(observer);
    verify(observer,never()).onNext(any(String.class));
    verify(observer,never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
  }
  @Test public void testSkipLastWithZeroCount(){
    Observable<String> w=Observable.just("one","two");
    Observable<String> observable=w.skipLast(0);
    Observer<String> observer=TestHelper.mockObserver();
    observable.subscribe(observer);
    verify(observer,times(1)).onNext("one");
    verify(observer,times(1)).onNext("two");
    verify(observer,never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
  }
  @Test @Ignore("Null values not allowed") public void testSkipLastWithNull(){
    Observable<String> o=Observable.fromIterable(Arrays.asList("one",null,"two")).skipLast(1);
    Observer<String> observer=TestHelper.mockObserver();
    o.subscribe(observer);
    verify(observer,times(1)).onNext("one");
    verify(observer,times(1)).onNext(null);
    verify(observer,never()).onNext("two");
    verify(observer,never()).onError(any(Throwable.class));
    verify(observer,times(1)).onComplete();
  }
  @Test public void testSkipLastWithBackpressure(){
    Observable<Integer> o=Observable.range(0,Flowable.bufferSize() * 2).skipLast(Flowable.bufferSize() + 10);
    TestObserver<Integer> to=new TestObserver<Integer>();
    o.observeOn(Schedulers.computation()).subscribe(to);
    to.awaitTerminalEvent();
    to.assertNoErrors();
    assertEquals((Flowable.bufferSize()) - 10,to.valueCount());
  }
  @Test(expected=IndexOutOfBoundsException.class) public void testSkipLastWithNegativeCount(){
    Observable.just("one").skipLast(-1);
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(Observable.just(1).skipLast(1));
  }
  @Test public void error(){
    Observable.error(new TestException()).skipLast(1).test().assertFailure(TestException.class);
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>,Observable<Object>>(){
      @Override public Observable<Object> apply(      Observable<Object> o) throws Exception {
        return o.skipLast(1);
      }
    }
);
  }
}
