public class FlowableDistinctTest {
  Subscriber<String> w;
  final Function<String,String> TO_UPPER_WITH_EXCEPTION=new Function<String,String>(){
    @Override public String apply(    String s){
      if (s.equals("x")) {
        return "XX";
      }
      return s.toUpperCase();
    }
  }
;
  @Before public void before(){
    w=TestHelper.mockSubscriber();
  }
  @Test public void testDistinctOfNone(){
    Flowable<String> src=Flowable.empty();
    src.distinct().subscribe(w);
    verify(w,never()).onNext(anyString());
    verify(w,never()).onError(any(Throwable.class));
    verify(w,times(1)).onComplete();
  }
  @Test public void testDistinctOfNoneWithKeySelector(){
    Flowable<String> src=Flowable.empty();
    src.distinct(TO_UPPER_WITH_EXCEPTION).subscribe(w);
    verify(w,never()).onNext(anyString());
    verify(w,never()).onError(any(Throwable.class));
    verify(w,times(1)).onComplete();
  }
  @Test public void testDistinctOfNormalSource(){
    Flowable<String> src=Flowable.just("a","b","c","c","c","b","b","a","e");
    src.distinct().subscribe(w);
    InOrder inOrder=inOrder(w);
    inOrder.verify(w,times(1)).onNext("a");
    inOrder.verify(w,times(1)).onNext("b");
    inOrder.verify(w,times(1)).onNext("c");
    inOrder.verify(w,times(1)).onNext("e");
    inOrder.verify(w,times(1)).onComplete();
    inOrder.verify(w,never()).onNext(anyString());
    verify(w,never()).onError(any(Throwable.class));
  }
  @Test public void testDistinctOfNormalSourceWithKeySelector(){
    Flowable<String> src=Flowable.just("a","B","c","C","c","B","b","a","E");
    src.distinct(TO_UPPER_WITH_EXCEPTION).subscribe(w);
    InOrder inOrder=inOrder(w);
    inOrder.verify(w,times(1)).onNext("a");
    inOrder.verify(w,times(1)).onNext("B");
    inOrder.verify(w,times(1)).onNext("c");
    inOrder.verify(w,times(1)).onNext("E");
    inOrder.verify(w,times(1)).onComplete();
    inOrder.verify(w,never()).onNext(anyString());
    verify(w,never()).onError(any(Throwable.class));
  }
  @Test @Ignore("Null values no longer allowed") public void testDistinctOfSourceWithNulls(){
    Flowable<String> src=Flowable.just(null,"a","a",null,null,"b",null);
    src.distinct().subscribe(w);
    InOrder inOrder=inOrder(w);
    inOrder.verify(w,times(1)).onNext(null);
    inOrder.verify(w,times(1)).onNext("a");
    inOrder.verify(w,times(1)).onNext("b");
    inOrder.verify(w,times(1)).onComplete();
    inOrder.verify(w,never()).onNext(anyString());
    verify(w,never()).onError(any(Throwable.class));
  }
  @Test @Ignore("Null values no longer allowed") public void testDistinctOfSourceWithExceptionsFromKeySelector(){
    Flowable<String> src=Flowable.just("a","b",null,"c");
    src.distinct(TO_UPPER_WITH_EXCEPTION).subscribe(w);
    InOrder inOrder=inOrder(w);
    inOrder.verify(w,times(1)).onNext("a");
    inOrder.verify(w,times(1)).onNext("b");
    inOrder.verify(w,times(1)).onError(any(NullPointerException.class));
    inOrder.verify(w,never()).onNext(anyString());
    inOrder.verify(w,never()).onComplete();
  }
  @Test public void error(){
    Flowable.error(new TestException()).distinct().test().assertFailure(TestException.class);
  }
  @Test public void fusedSync(){
    TestSubscriber<Integer> ts=SubscriberFusion.newTest(QueueFuseable.ANY);
    Flowable.just(1,1,2,1,3,2,4,5,4).distinct().subscribe(ts);
    SubscriberFusion.assertFusion(ts,QueueFuseable.SYNC).assertResult(1,2,3,4,5);
  }
  @Test public void fusedAsync(){
    TestSubscriber<Integer> ts=SubscriberFusion.newTest(QueueFuseable.ANY);
    UnicastProcessor<Integer> us=UnicastProcessor.create();
    us.distinct().subscribe(ts);
    TestHelper.emit(us,1,1,2,1,3,2,4,5,4);
    SubscriberFusion.assertFusion(ts,QueueFuseable.ASYNC).assertResult(1,2,3,4,5);
  }
  @Test public void fusedClear(){
    Flowable.just(1,1,2,1,3,2,4,5,4).distinct().subscribe(new FlowableSubscriber<Integer>(){
      @Override public void onSubscribe(      Subscription s){
        QueueSubscription<?> qs=(QueueSubscription<?>)s;
        assertFalse(qs.isEmpty());
        qs.clear();
        assertTrue(qs.isEmpty());
      }
      @Override public void onNext(      Integer value){
      }
      @Override public void onError(      Throwable e){
      }
      @Override public void onComplete(){
      }
    }
);
  }
  @Test public void collectionSupplierThrows(){
    Flowable.just(1).distinct(Functions.identity(),new Callable<Collection<Object>>(){
      @Override public Collection<Object> call() throws Exception {
        throw new TestException();
      }
    }
).test().assertFailure(TestException.class);
  }
  @Test public void collectionSupplierIsNull(){
    Flowable.just(1).distinct(Functions.identity(),new Callable<Collection<Object>>(){
      @Override public Collection<Object> call() throws Exception {
        return null;
      }
    }
).test().assertFailure(NullPointerException.class).assertErrorMessage("The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");
  }
  @Test public void badSource(){
    List<Throwable> errors=TestHelper.trackPluginErrors();
    try {
      new Flowable<Integer>(){
        @Override protected void subscribeActual(        Subscriber<? super Integer> subscriber){
          subscriber.onSubscribe(new BooleanSubscription());
          subscriber.onNext(1);
          subscriber.onComplete();
          subscriber.onNext(2);
          subscriber.onError(new TestException());
          subscriber.onComplete();
        }
      }
.distinct().test().assertResult(1);
      TestHelper.assertUndeliverable(errors,0,TestException.class);
    }
  finally {
      RxJavaPlugins.reset();
    }
  }
}
