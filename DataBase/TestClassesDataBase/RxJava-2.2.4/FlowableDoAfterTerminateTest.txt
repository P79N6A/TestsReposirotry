public class FlowableDoAfterTerminateTest {
  private Action aAction0;
  private Subscriber<String> subscriber;
  @Before public void before(){
    aAction0=Mockito.mock(Action.class);
    subscriber=TestHelper.mockSubscriber();
  }
  private void checkActionCalled(  Flowable<String> input){
    input.doAfterTerminate(aAction0).subscribe(subscriber);
    try {
      verify(aAction0,times(1)).run();
    }
 catch (    Throwable ex) {
      throw ExceptionHelper.wrapOrThrow(ex);
    }
  }
  @Test public void testDoAfterTerminateCalledOnComplete(){
    checkActionCalled(Flowable.fromArray("1","2","3"));
  }
  @Test public void testDoAfterTerminateCalledOnError(){
    checkActionCalled(Flowable.<String>error(new RuntimeException("expected")));
  }
  @Test public void nullActionShouldBeCheckedInConstructor(){
    try {
      Flowable.empty().doAfterTerminate(null);
      fail("Should have thrown NullPointerException");
    }
 catch (    NullPointerException expected) {
      assertEquals("onAfterTerminate is null",expected.getMessage());
    }
  }
  @Test public void nullFinallyActionShouldBeCheckedASAP(){
    try {
      Flowable.just("value").doAfterTerminate(null);
      fail();
    }
 catch (    NullPointerException expected) {
    }
  }
  @Test public void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() throws Exception {
    List<Throwable> errors=TestHelper.trackPluginErrors();
    try {
      Action finallyAction=Mockito.mock(Action.class);
      doThrow(new IllegalStateException()).when(finallyAction).run();
      TestSubscriber<String> testSubscriber=new TestSubscriber<String>();
      Flowable.just("value").doAfterTerminate(finallyAction).subscribe(testSubscriber);
      testSubscriber.assertValue("value");
      verify(finallyAction).run();
      TestHelper.assertError(errors,0,IllegalStateException.class);
    }
  finally {
      RxJavaPlugins.reset();
    }
  }
}
