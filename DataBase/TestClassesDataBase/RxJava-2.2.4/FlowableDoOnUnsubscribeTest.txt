public class FlowableDoOnUnsubscribeTest {
  @Test public void testDoOnUnsubscribe() throws Exception {
    int subCount=3;
    final CountDownLatch upperLatch=new CountDownLatch(subCount);
    final CountDownLatch lowerLatch=new CountDownLatch(subCount);
    final CountDownLatch onNextLatch=new CountDownLatch(subCount);
    final AtomicInteger upperCount=new AtomicInteger();
    final AtomicInteger lowerCount=new AtomicInteger();
    Flowable<Long> longs=Flowable.interval(50,TimeUnit.MILLISECONDS).doOnCancel(new Action(){
      @Override public void run(){
        upperLatch.countDown();
        upperCount.incrementAndGet();
      }
    }
).doOnNext(new Consumer<Long>(){
      @Override public void accept(      Long aLong){
        onNextLatch.countDown();
      }
    }
).doOnCancel(new Action(){
      @Override public void run(){
        lowerLatch.countDown();
        lowerCount.incrementAndGet();
      }
    }
);
    List<Disposable> subscriptions=new ArrayList<Disposable>();
    List<TestSubscriber<Long>> subscribers=new ArrayList<TestSubscriber<Long>>();
    for (int i=0; i < subCount; ++i) {
      TestSubscriber<Long> subscriber=new TestSubscriber<Long>();
      subscriptions.add(subscriber);
      longs.subscribe(subscriber);
      subscribers.add(subscriber);
    }
    onNextLatch.await();
    for (int i=0; i < subCount; ++i) {
      subscriptions.get(i).dispose();
    }
    upperLatch.await();
    lowerLatch.await();
    assertEquals(String.format("There should exactly %d un-subscription events for upper stream",subCount),subCount,upperCount.get());
    assertEquals(String.format("There should exactly %d un-subscription events for lower stream",subCount),subCount,lowerCount.get());
  }
  @Test public void testDoOnUnSubscribeWorksWithRefCount() throws Exception {
    int subCount=3;
    final CountDownLatch upperLatch=new CountDownLatch(1);
    final CountDownLatch lowerLatch=new CountDownLatch(1);
    final CountDownLatch onNextLatch=new CountDownLatch(subCount);
    final AtomicInteger upperCount=new AtomicInteger();
    final AtomicInteger lowerCount=new AtomicInteger();
    Flowable<Long> longs=Flowable.interval(50,TimeUnit.MILLISECONDS).doOnCancel(new Action(){
      @Override public void run(){
        upperLatch.countDown();
        upperCount.incrementAndGet();
      }
    }
).doOnNext(new Consumer<Long>(){
      @Override public void accept(      Long aLong){
        onNextLatch.countDown();
      }
    }
).doOnCancel(new Action(){
      @Override public void run(){
        lowerLatch.countDown();
        lowerCount.incrementAndGet();
      }
    }
).publish().refCount();
    List<Disposable> subscriptions=new ArrayList<Disposable>();
    List<TestSubscriber<Long>> subscribers=new ArrayList<TestSubscriber<Long>>();
    for (int i=0; i < subCount; ++i) {
      TestSubscriber<Long> subscriber=new TestSubscriber<Long>();
      longs.subscribe(subscriber);
      subscriptions.add(subscriber);
      subscribers.add(subscriber);
    }
    onNextLatch.await();
    for (int i=0; i < subCount; ++i) {
      subscriptions.get(i).dispose();
    }
    upperLatch.await();
    lowerLatch.await();
    assertEquals("There should exactly 1 un-subscription events for upper stream",1,upperCount.get());
    assertEquals("There should exactly 1 un-subscription events for lower stream",1,lowerCount.get());
  }
  @Test public void noReentrantDispose(){
    final AtomicInteger cancelCalled=new AtomicInteger();
    final BehaviorProcessor<Integer> p=BehaviorProcessor.create();
    p.doOnCancel(new Action(){
      @Override public void run() throws Exception {
        cancelCalled.incrementAndGet();
        p.onNext(2);
      }
    }
).firstOrError().subscribe().dispose();
    assertEquals(1,cancelCalled.get());
  }
}
