static class BusyObserver extends DefaultObserver<String> {
  volatile boolean onComplete;
  volatile boolean onError;
  AtomicInteger onNextCount=new AtomicInteger();
  AtomicInteger threadsRunning=new AtomicInteger();
  AtomicInteger maxConcurrentThreads=new AtomicInteger();
  final CountDownLatch terminalEvent=new CountDownLatch(1);
  @Override public void onComplete(){
    threadsRunning.incrementAndGet();
    try {
      onComplete=true;
    }
  finally {
      captureMaxThreads();
      threadsRunning.decrementAndGet();
      terminalEvent.countDown();
    }
  }
  @Override public void onError(  Throwable e){
    System.out.println(">>>>>>>>>>>>>>>>>>>> onError received: " + e);
    threadsRunning.incrementAndGet();
    try {
      onError=true;
    }
  finally {
      captureMaxThreads();
      threadsRunning.decrementAndGet();
      terminalEvent.countDown();
    }
  }
  @Override public void onNext(  String args){
    threadsRunning.incrementAndGet();
    try {
      onNextCount.incrementAndGet();
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  finally {
      captureMaxThreads();
      threadsRunning.decrementAndGet();
    }
  }
  protected void captureMaxThreads(){
    int concurrentThreads=threadsRunning.get();
    int maxThreads=maxConcurrentThreads.get();
    if (concurrentThreads > maxThreads) {
      maxConcurrentThreads.compareAndSet(maxThreads,concurrentThreads);
      if (concurrentThreads > 1) {
        new RuntimeException("should not be greater than 1").printStackTrace();
      }
    }
  }
}
