public class PooledDataSourceTest extends BaseDataTest {
  @Test public void shouldProperlyMaintainPoolOf3ActiveAnd2IdleConnections() throws Exception {
    PooledDataSource ds=createPooledDataSource(JPETSTORE_PROPERTIES);
    try {
      runScript(ds,JPETSTORE_DDL);
      ds.setDefaultAutoCommit(false);
      ds.setDriverProperties(new Properties(){
{
          setProperty("username","sa");
          setProperty("password","");
        }
      }
);
      ds.setPoolMaximumActiveConnections(3);
      ds.setPoolMaximumIdleConnections(2);
      ds.setPoolMaximumCheckoutTime(10000);
      ds.setPoolPingConnectionsNotUsedFor(1);
      ds.setPoolPingEnabled(true);
      ds.setPoolPingQuery("SELECT * FROM PRODUCT");
      ds.setPoolTimeToWait(10000);
      ds.setLogWriter(null);
      List<Connection> connections=new ArrayList<Connection>();
      for (int i=0; i < 3; i++) {
        connections.add(ds.getConnection());
      }
      assertEquals(3,ds.getPoolState().getActiveConnectionCount());
      for (      Connection c : connections) {
        c.close();
      }
      assertEquals(2,ds.getPoolState().getIdleConnectionCount());
      assertEquals(4,ds.getPoolState().getRequestCount());
      assertEquals(0,ds.getPoolState().getBadConnectionCount());
      assertEquals(0,ds.getPoolState().getHadToWaitCount());
      assertEquals(0,ds.getPoolState().getAverageOverdueCheckoutTime());
      assertEquals(0,ds.getPoolState().getClaimedOverdueConnectionCount());
      assertEquals(0,ds.getPoolState().getAverageWaitTime());
      assertNotNull(ds.getPoolState().toString());
    }
  finally {
      ds.forceCloseAll();
    }
  }
  @Test public void shouldNotFailCallingToStringOverAnInvalidConnection() throws Exception {
    PooledDataSource ds=createPooledDataSource(JPETSTORE_PROPERTIES);
    Connection c=ds.getConnection();
    c.close();
    c.toString();
  }
  @Test public void ShouldReturnRealConnection() throws Exception {
    PooledDataSource ds=createPooledDataSource(JPETSTORE_PROPERTIES);
    Connection c=ds.getConnection();
    JDBCConnection realConnection=(JDBCConnection)PooledDataSource.unwrapConnection(c);
    c.close();
  }
  @Ignore("See the comments") @Test public void shouldReconnectWhenServerKilledLeakedConnection() throws Exception {
    final String URL="jdbc:mysql://localhost:3306/test";
    final String USERNAME="admin";
    final String PASSWORD="";
    PooledDataSource ds=new PooledDataSource();
    ds.setDriver("com.mysql.jdbc.Driver");
    ds.setUrl(URL);
    ds.setUsername(USERNAME);
    ds.setPassword(PASSWORD);
    ds.setPoolMaximumActiveConnections(1);
    ds.setPoolMaximumIdleConnections(1);
    ds.setPoolTimeToWait(1000);
    ds.setPoolMaximumCheckoutTime(2000);
    ds.setPoolPingEnabled(true);
    ds.setPoolPingQuery("select 1");
    ds.setDefaultAutoCommit(true);
    ds.setPoolPingConnectionsNotUsedFor(1000);
    Connection con=ds.getConnection();
    exexuteQuery(con);
    Thread.sleep(TimeUnit.SECONDS.toMillis(3));
    con.close();
    con=ds.getConnection();
    exexuteQuery(con);
    con.close();
  }
  private void exexuteQuery(  Connection con) throws SQLException {
    PreparedStatement st=con.prepareStatement("select 1");
    ResultSet rs=st.executeQuery();
    while (rs.next()) {
      assertEquals(1,rs.getInt(1));
    }
    rs.close();
    st.close();
  }
}
