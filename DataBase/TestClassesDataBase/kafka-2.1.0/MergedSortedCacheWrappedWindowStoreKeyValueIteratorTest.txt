public class MergedSortedCacheWrappedWindowStoreKeyValueIteratorTest {
  private static final SegmentedCacheFunction SINGLE_SEGMENT_CACHE_FUNCTION=new SegmentedCacheFunction(null,-1){
    @Override public long segmentId(    final Bytes key){
      return 0;
    }
  }
;
  private static final int WINDOW_SIZE=10;
  private final String storeKey="a";
  private final String cacheKey="b";
  private final TimeWindow storeWindow=new TimeWindow(0,1);
  private final Iterator<KeyValue<Windowed<Bytes>,byte[]>> storeKvs=Collections.singleton(KeyValue.pair(new Windowed<>(Bytes.wrap(storeKey.getBytes()),storeWindow),storeKey.getBytes())).iterator();
  private final TimeWindow cacheWindow=new TimeWindow(10,20);
  private final Iterator<KeyValue<Bytes,LRUCacheEntry>> cacheKvs=Collections.singleton(KeyValue.pair(SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowKeySchema.toStoreKeyBinary(new Windowed<>(cacheKey,cacheWindow),0,new StateSerdes<>("dummy",Serdes.String(),Serdes.ByteArray()))),new LRUCacheEntry(cacheKey.getBytes()))).iterator();
  private Deserializer<String> deserializer=Serdes.String().deserializer();
  @Test public void shouldHaveNextFromStore(){
    final MergedSortedCacheWindowStoreKeyValueIterator mergeIterator=createIterator(storeKvs,Collections.<KeyValue<Bytes,LRUCacheEntry>>emptyIterator());
    assertTrue(mergeIterator.hasNext());
  }
  @Test public void shouldGetNextFromStore(){
    final MergedSortedCacheWindowStoreKeyValueIterator mergeIterator=createIterator(storeKvs,Collections.<KeyValue<Bytes,LRUCacheEntry>>emptyIterator());
    assertThat(convertKeyValuePair(mergeIterator.next()),equalTo(KeyValue.pair(new Windowed<>(storeKey,storeWindow),storeKey)));
  }
  @Test public void shouldPeekNextKeyFromStore(){
    final MergedSortedCacheWindowStoreKeyValueIterator mergeIterator=createIterator(storeKvs,Collections.<KeyValue<Bytes,LRUCacheEntry>>emptyIterator());
    assertThat(convertWindowedKey(mergeIterator.peekNextKey()),equalTo(new Windowed<>(storeKey,storeWindow)));
  }
  @Test public void shouldHaveNextFromCache(){
    final MergedSortedCacheWindowStoreKeyValueIterator mergeIterator=createIterator(Collections.<KeyValue<Windowed<Bytes>,byte[]>>emptyIterator(),cacheKvs);
    assertTrue(mergeIterator.hasNext());
  }
  @Test public void shouldGetNextFromCache(){
    final MergedSortedCacheWindowStoreKeyValueIterator mergeIterator=createIterator(Collections.<KeyValue<Windowed<Bytes>,byte[]>>emptyIterator(),cacheKvs);
    assertThat(convertKeyValuePair(mergeIterator.next()),equalTo(KeyValue.pair(new Windowed<>(cacheKey,cacheWindow),cacheKey)));
  }
  @Test public void shouldPeekNextKeyFromCache(){
    final MergedSortedCacheWindowStoreKeyValueIterator mergeIterator=createIterator(Collections.<KeyValue<Windowed<Bytes>,byte[]>>emptyIterator(),cacheKvs);
    assertThat(convertWindowedKey(mergeIterator.peekNextKey()),equalTo(new Windowed<>(cacheKey,cacheWindow)));
  }
  @Test public void shouldIterateBothStoreAndCache(){
    final MergedSortedCacheWindowStoreKeyValueIterator iterator=createIterator(storeKvs,cacheKvs);
    assertThat(convertKeyValuePair(iterator.next()),equalTo(KeyValue.pair(new Windowed<>(storeKey,storeWindow),storeKey)));
    assertThat(convertKeyValuePair(iterator.next()),equalTo(KeyValue.pair(new Windowed<>(cacheKey,cacheWindow),cacheKey)));
    assertFalse(iterator.hasNext());
  }
  private KeyValue<Windowed<String>,String> convertKeyValuePair(  final KeyValue<Windowed<Bytes>,byte[]> next){
    final String value=deserializer.deserialize("",next.value);
    return KeyValue.pair(convertWindowedKey(next.key),value);
  }
  private Windowed<String> convertWindowedKey(  final Windowed<Bytes> bytesWindowed){
    final String key=deserializer.deserialize("",bytesWindowed.key().get());
    return new Windowed<>(key,bytesWindowed.window());
  }
  private MergedSortedCacheWindowStoreKeyValueIterator createIterator(  final Iterator<KeyValue<Windowed<Bytes>,byte[]>> storeKvs,  final Iterator<KeyValue<Bytes,LRUCacheEntry>> cacheKvs){
    final DelegatingPeekingKeyValueIterator<Windowed<Bytes>,byte[]> storeIterator=new DelegatingPeekingKeyValueIterator<>("store",new KeyValueIteratorStub<>(storeKvs));
    final PeekingKeyValueIterator<Bytes,LRUCacheEntry> cacheIterator=new DelegatingPeekingKeyValueIterator<>("cache",new KeyValueIteratorStub<>(cacheKvs));
    return new MergedSortedCacheWindowStoreKeyValueIterator(cacheIterator,storeIterator,new StateSerdes<>("name",Serdes.Bytes(),Serdes.ByteArray()),WINDOW_SIZE,SINGLE_SEGMENT_CACHE_FUNCTION);
  }
}
