public class DefaultPartitionGrouperTest {
  private final List<PartitionInfo> infos=Arrays.asList(new PartitionInfo("topic1",0,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo("topic1",1,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo("topic1",2,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo("topic2",0,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo("topic2",1,Node.noNode(),new Node[0],new Node[0]));
  private final Cluster metadata=new Cluster("cluster",Collections.singletonList(Node.noNode()),infos,Collections.<String>emptySet(),Collections.<String>emptySet());
  @Test public void shouldComputeGroupingForTwoGroups(){
    final PartitionGrouper grouper=new DefaultPartitionGrouper();
    final Map<TaskId,Set<TopicPartition>> expectedPartitionsForTask=new HashMap<>();
    final Map<Integer,Set<String>> topicGroups=new HashMap<>();
    int topicGroupId=0;
    topicGroups.put(topicGroupId,mkSet("topic1"));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,0),mkSet(new TopicPartition("topic1",0)));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,1),mkSet(new TopicPartition("topic1",1)));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,2),mkSet(new TopicPartition("topic1",2)));
    topicGroups.put(++topicGroupId,mkSet("topic2"));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,0),mkSet(new TopicPartition("topic2",0)));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,1),mkSet(new TopicPartition("topic2",1)));
    assertEquals(expectedPartitionsForTask,grouper.partitionGroups(topicGroups,metadata));
  }
  @Test public void shouldComputeGroupingForSingleGroupWithMultipleTopics(){
    final PartitionGrouper grouper=new DefaultPartitionGrouper();
    final Map<TaskId,Set<TopicPartition>> expectedPartitionsForTask=new HashMap<>();
    final Map<Integer,Set<String>> topicGroups=new HashMap<>();
    final int topicGroupId=0;
    topicGroups.put(topicGroupId,mkSet("topic1","topic2"));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,0),mkSet(new TopicPartition("topic1",0),new TopicPartition("topic2",0)));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,1),mkSet(new TopicPartition("topic1",1),new TopicPartition("topic2",1)));
    expectedPartitionsForTask.put(new TaskId(topicGroupId,2),mkSet(new TopicPartition("topic1",2)));
    assertEquals(expectedPartitionsForTask,grouper.partitionGroups(topicGroups,metadata));
  }
  @Test(expected=RuntimeException.class) public void shouldNotCreateAnyTasksBecauseOneTopicHasUnknownPartitions(){
    final PartitionGrouper grouper=new DefaultPartitionGrouper();
    final Map<Integer,Set<String>> topicGroups=new HashMap<>();
    final int topicGroupId=0;
    topicGroups.put(topicGroupId,mkSet("topic1","unknownTopic","topic2"));
    grouper.partitionGroups(topicGroups,metadata);
  }
}
