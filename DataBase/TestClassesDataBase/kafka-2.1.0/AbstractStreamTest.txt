public class AbstractStreamTest {
  @Test public void testToInternlValueTransformerSupplierSuppliesNewTransformers(){
    final ValueTransformerSupplier valueTransformerSupplier=createMock(ValueTransformerSupplier.class);
    expect(valueTransformerSupplier.get()).andReturn(null).times(3);
    final ValueTransformerWithKeySupplier valueTransformerWithKeySupplier=AbstractStream.toValueTransformerWithKeySupplier(valueTransformerSupplier);
    replay(valueTransformerSupplier);
    valueTransformerWithKeySupplier.get();
    valueTransformerWithKeySupplier.get();
    valueTransformerWithKeySupplier.get();
    verify(valueTransformerSupplier);
  }
  @Test public void testToInternalValueTransformerSupplierSuppliesNewTransformers(){
    final ValueTransformerWithKeySupplier valueTransformerWithKeySupplier=createMock(ValueTransformerWithKeySupplier.class);
    expect(valueTransformerWithKeySupplier.get()).andReturn(null).times(3);
    replay(valueTransformerWithKeySupplier);
    valueTransformerWithKeySupplier.get();
    valueTransformerWithKeySupplier.get();
    valueTransformerWithKeySupplier.get();
    verify(valueTransformerWithKeySupplier);
  }
  @Test public void testShouldBeExtensible(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{1,2,3,4,5,6,7};
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    final String topicName="topic";
    final ExtendedKStream<Integer,String> stream=new ExtendedKStream<>(builder.stream(topicName,Consumed.with(Serdes.Integer(),Serdes.String())));
    stream.randomFilter().process(supplier);
    final Properties props=new Properties();
    props.setProperty(StreamsConfig.APPLICATION_ID_CONFIG,"abstract-stream-test");
    props.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,"localhost:9091");
    props.setProperty(StreamsConfig.STATE_DIR_CONFIG,TestUtils.tempDirectory().getAbsolutePath());
    final ConsumerRecordFactory<Integer,String> recordFactory=new ConsumerRecordFactory<>(new IntegerSerializer(),new StringSerializer());
    final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props);
    for (    final int expectedKey : expectedKeys) {
      driver.pipeInput(recordFactory.create(topicName,expectedKey,"V" + expectedKey));
    }
    assertTrue(supplier.theCapturedProcessor().processed.size() <= expectedKeys.length);
  }
private class ExtendedKStream<K,V> extends AbstractStream<K,V> {
    ExtendedKStream(    final KStream<K,V> stream){
      super((KStreamImpl<K,V>)stream);
    }
    KStream<K,V> randomFilter(){
      final String name=builder.newProcessorName("RANDOM-FILTER-");
      final ProcessorGraphNode<K,V> processorNode=new ProcessorGraphNode<>(name,new ProcessorParameters<>(new ExtendedKStreamDummy<>(),name),false);
      builder.addGraphNode(this.streamsGraphNode,processorNode);
      return new KStreamImpl<K,V>(name,null,null,sourceNodes,false,processorNode,builder);
    }
  }
private class ExtendedKStreamDummy<K,V> implements ProcessorSupplier<K,V> {
    private Random rand;
    ExtendedKStreamDummy(){
      rand=new Random();
    }
    @Override public Processor<K,V> get(){
      return new ExtendedKStreamDummyProcessor();
    }
private class ExtendedKStreamDummyProcessor extends AbstractProcessor<K,V> {
      @Override public void process(      final K key,      final V value){
        if (rand.nextBoolean())         context().forward(key,value);
      }
    }
  }
}
