public class WindowedStreamPartitionerTest {
  private String topicName="topic";
  private IntegerSerializer intSerializer=new IntegerSerializer();
  private StringSerializer stringSerializer=new StringSerializer();
  private List<PartitionInfo> infos=Arrays.asList(new PartitionInfo(topicName,0,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo(topicName,1,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo(topicName,2,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo(topicName,3,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo(topicName,4,Node.noNode(),new Node[0],new Node[0]),new PartitionInfo(topicName,5,Node.noNode(),new Node[0],new Node[0]));
  private Cluster cluster=new Cluster("cluster",Collections.singletonList(Node.noNode()),infos,Collections.<String>emptySet(),Collections.<String>emptySet());
  @Test public void testCopartitioning(){
    final Random rand=new Random();
    final DefaultPartitioner defaultPartitioner=new DefaultPartitioner();
    final WindowedSerializer<Integer> timeWindowedSerializer=new TimeWindowedSerializer<>(intSerializer);
    final WindowedStreamPartitioner<Integer,String> streamPartitioner=new WindowedStreamPartitioner<>(timeWindowedSerializer);
    for (int k=0; k < 10; k++) {
      final Integer key=rand.nextInt();
      final byte[] keyBytes=intSerializer.serialize(topicName,key);
      final String value=key.toString();
      final byte[] valueBytes=stringSerializer.serialize(topicName,value);
      final Integer expected=defaultPartitioner.partition("topic",key,keyBytes,value,valueBytes,cluster);
      for (int w=1; w < 10; w++) {
        final TimeWindow window=new TimeWindow(10 * w,20 * w);
        final Windowed<Integer> windowedKey=new Windowed<>(key,window);
        final Integer actual=streamPartitioner.partition(topicName,windowedKey,value,infos.size());
        assertEquals(expected,actual);
      }
    }
    defaultPartitioner.close();
  }
}
