private static class TestSslChannelBuilder extends SslChannelBuilder {
  private Integer netReadBufSizeOverride;
  private Integer netWriteBufSizeOverride;
  private Integer appBufSizeOverride;
  private long failureIndex=Long.MAX_VALUE;
  FailureAction readFailureAction=FailureAction.NO_OP;
  FailureAction flushFailureAction=FailureAction.NO_OP;
  int flushDelayCount=0;
  public TestSslChannelBuilder(  Mode mode){
    super(mode,null,false);
  }
  public void configureBufferSizes(  Integer netReadBufSize,  Integer netWriteBufSize,  Integer appBufSize){
    this.netReadBufSizeOverride=netReadBufSize;
    this.netWriteBufSizeOverride=netWriteBufSize;
    this.appBufSizeOverride=appBufSize;
  }
  @Override protected SslTransportLayer buildTransportLayer(  SslFactory sslFactory,  String id,  SelectionKey key,  String host) throws IOException {
    SocketChannel socketChannel=(SocketChannel)key.channel();
    SSLEngine sslEngine=sslFactory.createSslEngine(host,socketChannel.socket().getPort());
    TestSslTransportLayer transportLayer=newTransportLayer(id,key,sslEngine);
    return transportLayer;
  }
  protected TestSslTransportLayer newTransportLayer(  String id,  SelectionKey key,  SSLEngine sslEngine) throws IOException {
    return new TestSslTransportLayer(id,key,sslEngine);
  }
  /** 
 * SSLTransportLayer with overrides for testing including: <ul> <li>Overrides for packet and application buffer size to test buffer resize code path. The overridden buffer size starts with a small value and increases in size when the buffer size is retrieved to handle overflow/underflow, until the actual session buffer size is reached.</li> <li>IOException injection for reads and writes for testing exception handling during handshakes.</li> <li>Delayed writes to test handshake failure notifications to peer</li> </ul>
 */
class TestSslTransportLayer extends SslTransportLayer {
    private final ResizeableBufferSize netReadBufSize;
    private final ResizeableBufferSize netWriteBufSize;
    private final ResizeableBufferSize appBufSize;
    private final AtomicLong numReadsRemaining;
    private final AtomicLong numFlushesRemaining;
    private final AtomicInteger numDelayedFlushesRemaining;
    public TestSslTransportLayer(    String channelId,    SelectionKey key,    SSLEngine sslEngine) throws IOException {
      super(channelId,key,sslEngine);
      this.netReadBufSize=new ResizeableBufferSize(netReadBufSizeOverride);
      this.netWriteBufSize=new ResizeableBufferSize(netWriteBufSizeOverride);
      this.appBufSize=new ResizeableBufferSize(appBufSizeOverride);
      numReadsRemaining=new AtomicLong(failureIndex);
      numFlushesRemaining=new AtomicLong(failureIndex);
      numDelayedFlushesRemaining=new AtomicInteger(flushDelayCount);
    }
    @Override protected int netReadBufferSize(){
      ByteBuffer netReadBuffer=netReadBuffer();
      boolean updateBufSize=netReadBuffer != null && !netReadBuffer().hasRemaining();
      return netReadBufSize.updateAndGet(super.netReadBufferSize(),updateBufSize);
    }
    @Override protected int netWriteBufferSize(){
      return netWriteBufSize.updateAndGet(super.netWriteBufferSize(),true);
    }
    @Override protected int applicationBufferSize(){
      return appBufSize.updateAndGet(super.applicationBufferSize(),true);
    }
    @Override protected int readFromSocketChannel() throws IOException {
      if (numReadsRemaining.decrementAndGet() == 0 && !ready())       readFailureAction.run();
      return super.readFromSocketChannel();
    }
    @Override protected boolean flush(    ByteBuffer buf) throws IOException {
      if (numFlushesRemaining.decrementAndGet() == 0 && !ready())       flushFailureAction.run();
 else       if (numDelayedFlushesRemaining.getAndDecrement() != 0)       return false;
      resetDelayedFlush();
      return super.flush(buf);
    }
    @Override protected void startHandshake() throws IOException {
      assertTrue("SSL handshake initialized too early",socketChannel().isConnected());
      super.startHandshake();
    }
    private void resetDelayedFlush(){
      numDelayedFlushesRemaining.set(flushDelayCount);
    }
  }
private static class ResizeableBufferSize {
    private Integer bufSizeOverride;
    ResizeableBufferSize(    Integer bufSizeOverride){
      this.bufSizeOverride=bufSizeOverride;
    }
    int updateAndGet(    int actualSize,    boolean update){
      int size=actualSize;
      if (bufSizeOverride != null) {
        if (update)         bufSizeOverride=Math.min(bufSizeOverride * 2,size);
        size=bufSizeOverride;
      }
      return size;
    }
  }
}
