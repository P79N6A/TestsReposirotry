public class MergedSortedCacheWrappedWindowStoreIteratorTest {
  private static final SegmentedCacheFunction SINGLE_SEGMENT_CACHE_FUNCTION=new SegmentedCacheFunction(null,-1){
    @Override public long segmentId(    final Bytes key){
      return 0;
    }
  }
;
  private final List<KeyValue<Long,byte[]>> windowStoreKvPairs=new ArrayList<>();
  private final ThreadCache cache=new ThreadCache(new LogContext("testCache "),1000000L,new MockStreamsMetrics(new Metrics()));
  private final String namespace="0.0-one";
  private final StateSerdes<String,String> stateSerdes=new StateSerdes<>("foo",Serdes.String(),Serdes.String());
  @Test public void shouldIterateOverValueFromBothIterators(){
    final List<KeyValue<Long,byte[]>> expectedKvPairs=new ArrayList<>();
    for (long t=0; t < 100; t+=20) {
      final byte[] v1Bytes=String.valueOf(t).getBytes();
      final KeyValue<Long,byte[]> v1=KeyValue.pair(t,v1Bytes);
      windowStoreKvPairs.add(v1);
      expectedKvPairs.add(KeyValue.pair(t,v1Bytes));
      final Bytes keyBytes=WindowKeySchema.toStoreKeyBinary("a",t + 10,0,stateSerdes);
      final byte[] valBytes=String.valueOf(t + 10).getBytes();
      expectedKvPairs.add(KeyValue.pair(t + 10,valBytes));
      cache.put(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(keyBytes),new LRUCacheEntry(valBytes));
    }
    final Bytes fromBytes=WindowKeySchema.toStoreKeyBinary("a",0,0,stateSerdes);
    final Bytes toBytes=WindowKeySchema.toStoreKeyBinary("a",100,0,stateSerdes);
    final KeyValueIterator<Long,byte[]> storeIterator=new DelegatingPeekingKeyValueIterator<>("store",new KeyValueIteratorStub<>(windowStoreKvPairs.iterator()));
    final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator=cache.range(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(fromBytes),SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(toBytes));
    final MergedSortedCacheWindowStoreIterator iterator=new MergedSortedCacheWindowStoreIterator(cacheIterator,storeIterator);
    int index=0;
    while (iterator.hasNext()) {
      final KeyValue<Long,byte[]> next=iterator.next();
      final KeyValue<Long,byte[]> expected=expectedKvPairs.get(index++);
      assertArrayEquals(expected.value,next.value);
      assertEquals(expected.key,next.key);
    }
    iterator.close();
  }
  @Test public void shouldPeekNextStoreKey(){
    windowStoreKvPairs.add(KeyValue.pair(10L,"a".getBytes()));
    cache.put(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowKeySchema.toStoreKeyBinary("a",0,0,stateSerdes)),new LRUCacheEntry("b".getBytes()));
    final Bytes fromBytes=WindowKeySchema.toStoreKeyBinary("a",0,0,stateSerdes);
    final Bytes toBytes=WindowKeySchema.toStoreKeyBinary("a",100,0,stateSerdes);
    final KeyValueIterator<Long,byte[]> storeIterator=new DelegatingPeekingKeyValueIterator<>("store",new KeyValueIteratorStub<>(windowStoreKvPairs.iterator()));
    final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator=cache.range(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(fromBytes),SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(toBytes));
    final MergedSortedCacheWindowStoreIterator iterator=new MergedSortedCacheWindowStoreIterator(cacheIterator,storeIterator);
    assertThat(iterator.peekNextKey(),equalTo(0L));
    iterator.next();
    assertThat(iterator.peekNextKey(),equalTo(10L));
    iterator.close();
  }
  @Test public void shouldPeekNextCacheKey(){
    windowStoreKvPairs.add(KeyValue.pair(0L,"a".getBytes()));
    cache.put(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowKeySchema.toStoreKeyBinary("a",10L,0,stateSerdes)),new LRUCacheEntry("b".getBytes()));
    final Bytes fromBytes=WindowKeySchema.toStoreKeyBinary("a",0,0,stateSerdes);
    final Bytes toBytes=WindowKeySchema.toStoreKeyBinary("a",100,0,stateSerdes);
    final KeyValueIterator<Long,byte[]> storeIterator=new DelegatingPeekingKeyValueIterator<>("store",new KeyValueIteratorStub<>(windowStoreKvPairs.iterator()));
    final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator=cache.range(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(fromBytes),SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(toBytes));
    final MergedSortedCacheWindowStoreIterator iterator=new MergedSortedCacheWindowStoreIterator(cacheIterator,storeIterator);
    assertThat(iterator.peekNextKey(),equalTo(0L));
    iterator.next();
    assertThat(iterator.peekNextKey(),equalTo(10L));
    iterator.close();
  }
}
