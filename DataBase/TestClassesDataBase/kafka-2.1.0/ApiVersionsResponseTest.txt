public class ApiVersionsResponseTest {
  @Test public void shouldCreateApiResponseOnlyWithKeysSupportedByMagicValue(){
    final ApiVersionsResponse response=ApiVersionsResponse.apiVersionsResponse(10,RecordBatch.MAGIC_VALUE_V1);
    verifyApiKeysForMagic(response,RecordBatch.MAGIC_VALUE_V1);
    assertEquals(10,response.throttleTimeMs());
  }
  @Test public void shouldCreateApiResponseThatHasAllApiKeysSupportedByBroker(){
    assertEquals(apiKeysInResponse(ApiVersionsResponse.defaultApiVersionsResponse()),Utils.mkSet(ApiKeys.values()));
  }
  @Test public void shouldReturnAllKeysWhenMagicIsCurrentValueAndThrottleMsIsDefaultThrottle(){
    ApiVersionsResponse response=ApiVersionsResponse.apiVersionsResponse(AbstractResponse.DEFAULT_THROTTLE_TIME,RecordBatch.CURRENT_MAGIC_VALUE);
    assertEquals(Utils.mkSet(ApiKeys.values()),apiKeysInResponse(response));
    assertEquals(AbstractResponse.DEFAULT_THROTTLE_TIME,response.throttleTimeMs());
  }
  @Test public void shouldHaveCorrectDefaultApiVersionsResponse(){
    Collection<ApiVersionsResponse.ApiVersion> apiVersions=ApiVersionsResponse.defaultApiVersionsResponse().apiVersions();
    assertEquals("API versions for all API keys must be maintained.",apiVersions.size(),ApiKeys.values().length);
    for (    ApiKeys key : ApiKeys.values()) {
      ApiVersionsResponse.ApiVersion version=ApiVersionsResponse.defaultApiVersionsResponse().apiVersion(key.id);
      assertNotNull("Could not find ApiVersion for API " + key.name,version);
      assertEquals("Incorrect min version for Api " + key.name,version.minVersion,key.oldestVersion());
      assertEquals("Incorrect max version for Api " + key.name,version.maxVersion,key.latestVersion());
      for (int i=0; i < version.minVersion; ++i) {
        assertNull("Request version " + i + " for API "+ version.apiKey+ " must be null",key.requestSchemas[i]);
        assertNull("Response version " + i + " for API "+ version.apiKey+ " must be null",key.responseSchemas[i]);
      }
      for (int i=version.minVersion; i <= version.maxVersion; ++i) {
        assertNotNull("Request version " + i + " for API "+ version.apiKey+ " must not be null",key.requestSchemas[i]);
        assertNotNull("Response version " + i + " for API "+ version.apiKey+ " must not be null",key.responseSchemas[i]);
      }
    }
  }
  private void verifyApiKeysForMagic(  final ApiVersionsResponse response,  final byte maxMagic){
    for (    final ApiVersionsResponse.ApiVersion version : response.apiVersions()) {
      assertTrue(ApiKeys.forId(version.apiKey).minRequiredInterBrokerMagic <= maxMagic);
    }
  }
  private Set<ApiKeys> apiKeysInResponse(  final ApiVersionsResponse apiVersions){
    final Set<ApiKeys> apiKeys=new HashSet<>();
    for (    final ApiVersionsResponse.ApiVersion version : apiVersions.apiVersions()) {
      apiKeys.add(ApiKeys.forId(version.apiKey));
    }
    return apiKeys;
  }
}
