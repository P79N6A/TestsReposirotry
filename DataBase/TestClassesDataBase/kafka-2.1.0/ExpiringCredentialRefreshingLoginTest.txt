public class ExpiringCredentialRefreshingLoginTest {
  private static final Configuration EMPTY_WILDCARD_CONFIGURATION;
static {
    EMPTY_WILDCARD_CONFIGURATION=new Configuration(){
      @Override public AppConfigurationEntry[] getAppConfigurationEntry(      String name){
        return new AppConfigurationEntry[0];
      }
    }
;
  }
private static class TestExpiringCredentialRefreshingLogin extends ExpiringCredentialRefreshingLogin {
    private ExpiringCredential expiringCredential;
    private ExpiringCredential tmpExpiringCredential;
    private final Time time;
    private final long lifetimeMillis;
    private final long absoluteLastRefreshTimeMs;
    private final boolean clientReloginAllowedBeforeLogout;
    public TestExpiringCredentialRefreshingLogin(    ExpiringCredentialRefreshConfig refreshConfig,    LoginContextFactory loginContextFactory,    Time time,    final long lifetimeMillis,    final long absoluteLastRefreshMs,    boolean clientReloginAllowedBeforeLogout){
      super("contextName",EMPTY_WILDCARD_CONFIGURATION,refreshConfig,null,TestExpiringCredentialRefreshingLogin.class,loginContextFactory,Objects.requireNonNull(time));
      this.time=time;
      this.lifetimeMillis=lifetimeMillis;
      this.absoluteLastRefreshTimeMs=absoluteLastRefreshMs;
      this.clientReloginAllowedBeforeLogout=clientReloginAllowedBeforeLogout;
    }
    public void createNewExpiringCredential(){
      if (!clientReloginAllowedBeforeLogout)       expiringCredential=internalNewExpiringCredential();
 else {
        boolean initialLogin=expiringCredential == null;
        if (initialLogin)         this.expiringCredential=internalNewExpiringCredential();
 else         this.tmpExpiringCredential=internalNewExpiringCredential();
      }
    }
    public void clearExpiringCredential(){
      if (!clientReloginAllowedBeforeLogout)       expiringCredential=null;
 else       expiringCredential=tmpExpiringCredential;
    }
    @Override public ExpiringCredential expiringCredential(){
      return expiringCredential;
    }
    private ExpiringCredential internalNewExpiringCredential(){
      return new ExpiringCredential(){
        private final long createMs=time.milliseconds();
        private final long expireTimeMs=createMs + lifetimeMillis;
        @Override public String principalName(){
          return "Created at " + new Date(createMs);
        }
        @Override public Long startTimeMs(){
          return createMs;
        }
        @Override public long expireTimeMs(){
          return expireTimeMs;
        }
        @Override public Long absoluteLastRefreshTimeMs(){
          return absoluteLastRefreshTimeMs;
        }
        @Override public String toString(){
          return String.format("startTimeMs=%d, expireTimeMs=%d, absoluteLastRefreshTimeMs=%s",startTimeMs(),expireTimeMs(),absoluteLastRefreshTimeMs());
        }
      }
;
    }
  }
private static class TestLoginContext extends LoginContext {
    private final TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin;
    private final LoginContext mockLoginContext;
    public TestLoginContext(    TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin,    LoginContext mockLoginContext) throws LoginException {
      super("contextName",null,null,EMPTY_WILDCARD_CONFIGURATION);
      this.testExpiringCredentialRefreshingLogin=Objects.requireNonNull(testExpiringCredentialRefreshingLogin);
      if (Objects.requireNonNull(mockLoginContext).getClass().equals(LoginContext.class) || mockLoginContext.getClass().equals(getClass()))       throw new IllegalArgumentException();
      this.mockLoginContext=mockLoginContext;
    }
    @Override public void login() throws LoginException {
      mockLoginContext.login();
      testExpiringCredentialRefreshingLogin.createNewExpiringCredential();
    }
    @Override public void logout() throws LoginException {
      mockLoginContext.logout();
      testExpiringCredentialRefreshingLogin.clearExpiringCredential();
    }
    @Override public Subject getSubject(){
      return mockLoginContext.getSubject();
    }
  }
private static class TestLoginContextFactory extends LoginContextFactory {
    private final KafkaFutureImpl<Object> refresherThreadStartedFuture=new KafkaFutureImpl<>();
    private final KafkaFutureImpl<Object> refresherThreadDoneFuture=new KafkaFutureImpl<>();
    private TestLoginContext testLoginContext;
    public void configure(    LoginContext mockLoginContext,    TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin) throws LoginException {
      if (Objects.requireNonNull(mockLoginContext).getClass().equals(LoginContext.class) || mockLoginContext.getClass().equals(TestLoginContext.class))       throw new IllegalArgumentException();
      this.testLoginContext=new TestLoginContext(Objects.requireNonNull(testExpiringCredentialRefreshingLogin),mockLoginContext);
    }
    @Override public LoginContext createLoginContext(    ExpiringCredentialRefreshingLogin expiringCredentialRefreshingLogin){
      return testLoginContext;
    }
    @Override public void refresherThreadStarted(){
      refresherThreadStartedFuture.complete(null);
    }
    @Override public void refresherThreadDone(){
      refresherThreadDoneFuture.complete(null);
    }
    public Future<?> refresherThreadStartedFuture(){
      return refresherThreadStartedFuture;
    }
    public Future<?> refresherThreadDoneFuture(){
      return refresherThreadDoneFuture;
    }
  }
  @Test public void testRefresh() throws Exception {
    for (    int numExpectedRefreshes : new int[]{0,1,2}) {
      for (      boolean clientReloginAllowedBeforeLogout : new boolean[]{true,false}) {
        Subject subject=new Subject();
        final LoginContext mockLoginContext=mock(LoginContext.class);
        when(mockLoginContext.getSubject()).thenReturn(subject);
        MockTime mockTime=new MockTime();
        long startMs=mockTime.milliseconds();
        long lifetimeMinutes=100L;
        long refreshEveryMinutes=80L;
        long absoluteLastRefreshMs=startMs + (1 + numExpectedRefreshes) * 1000 * 60* refreshEveryMinutes - 1000 * 60 * refreshEveryMinutes / 2;
        short minPeriodSeconds=(short)0;
        short bufferSeconds=minPeriodSeconds;
        MockScheduler mockScheduler=new MockScheduler(mockTime);
        List<KafkaFutureImpl<Long>> waiters=addWaiters(mockScheduler,1000 * 60 * refreshEveryMinutes,numExpectedRefreshes + 1);
        TestLoginContextFactory testLoginContextFactory=new TestLoginContextFactory();
        TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin=new TestExpiringCredentialRefreshingLogin(refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(1.0 * refreshEveryMinutes / lifetimeMinutes,minPeriodSeconds,bufferSeconds,clientReloginAllowedBeforeLogout),testLoginContextFactory,mockTime,1000 * 60 * lifetimeMinutes,absoluteLastRefreshMs,clientReloginAllowedBeforeLogout);
        testLoginContextFactory.configure(mockLoginContext,testExpiringCredentialRefreshingLogin);
        long expectedFinalMs=startMs + numExpectedRefreshes * 1000 * 60* refreshEveryMinutes;
        assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());
        assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());
        testExpiringCredentialRefreshingLogin.login();
        assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());
        testLoginContextFactory.refresherThreadDoneFuture().get(1L,TimeUnit.SECONDS);
        assertEquals(expectedFinalMs,mockTime.milliseconds());
        for (int i=0; i < numExpectedRefreshes; ++i) {
          KafkaFutureImpl<Long> waiter=waiters.get(i);
          assertTrue(waiter.isDone());
          assertEquals((i + 1) * 1000 * 60* refreshEveryMinutes,waiter.get().longValue() - startMs);
        }
        assertFalse(waiters.get(numExpectedRefreshes).isDone());
        InOrder inOrder=inOrder(mockLoginContext);
        inOrder.verify(mockLoginContext).login();
        inOrder.verify(mockLoginContext).getSubject();
        for (int i=0; i < numExpectedRefreshes; ++i) {
          if (clientReloginAllowedBeforeLogout) {
            inOrder.verify(mockLoginContext).login();
            inOrder.verify(mockLoginContext).logout();
          }
 else {
            inOrder.verify(mockLoginContext).logout();
            inOrder.verify(mockLoginContext).login();
          }
        }
      }
    }
  }
  @Test public void testRefreshWithExpirationSmallerThanConfiguredBuffers() throws Exception {
    int numExpectedRefreshes=1;
    boolean clientReloginAllowedBeforeLogout=true;
    final LoginContext mockLoginContext=mock(LoginContext.class);
    Subject subject=new Subject();
    when(mockLoginContext.getSubject()).thenReturn(subject);
    MockTime mockTime=new MockTime();
    long startMs=mockTime.milliseconds();
    long lifetimeMinutes=10L;
    long refreshEveryMinutes=8L;
    long absoluteLastRefreshMs=startMs + (1 + numExpectedRefreshes) * 1000 * 60* refreshEveryMinutes - 1000 * 60 * refreshEveryMinutes / 2;
    short minPeriodSeconds=(short)(1 + lifetimeMinutes * 60 / 2);
    short bufferSeconds=minPeriodSeconds;
    MockScheduler mockScheduler=new MockScheduler(mockTime);
    List<KafkaFutureImpl<Long>> waiters=addWaiters(mockScheduler,1000 * 60 * refreshEveryMinutes,numExpectedRefreshes + 1);
    TestLoginContextFactory testLoginContextFactory=new TestLoginContextFactory();
    TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin=new TestExpiringCredentialRefreshingLogin(refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(1.0 * refreshEveryMinutes / lifetimeMinutes,minPeriodSeconds,bufferSeconds,clientReloginAllowedBeforeLogout),testLoginContextFactory,mockTime,1000 * 60 * lifetimeMinutes,absoluteLastRefreshMs,clientReloginAllowedBeforeLogout);
    testLoginContextFactory.configure(mockLoginContext,testExpiringCredentialRefreshingLogin);
    long expectedFinalMs=startMs + numExpectedRefreshes * 1000 * 60* refreshEveryMinutes;
    assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());
    assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());
    testExpiringCredentialRefreshingLogin.login();
    assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());
    testLoginContextFactory.refresherThreadDoneFuture().get(1L,TimeUnit.SECONDS);
    assertEquals(expectedFinalMs,mockTime.milliseconds());
    for (int i=0; i < numExpectedRefreshes; ++i) {
      KafkaFutureImpl<Long> waiter=waiters.get(i);
      assertTrue(waiter.isDone());
      assertEquals((i + 1) * 1000 * 60* refreshEveryMinutes,waiter.get().longValue() - startMs);
    }
    assertFalse(waiters.get(numExpectedRefreshes).isDone());
    InOrder inOrder=inOrder(mockLoginContext);
    inOrder.verify(mockLoginContext).login();
    for (int i=0; i < numExpectedRefreshes; ++i) {
      inOrder.verify(mockLoginContext).login();
      inOrder.verify(mockLoginContext).logout();
    }
  }
  @Test public void testRefreshWithMinPeriodIntrusion() throws Exception {
    int numExpectedRefreshes=1;
    boolean clientReloginAllowedBeforeLogout=true;
    Subject subject=new Subject();
    final LoginContext mockLoginContext=mock(LoginContext.class);
    when(mockLoginContext.getSubject()).thenReturn(subject);
    MockTime mockTime=new MockTime();
    long startMs=mockTime.milliseconds();
    long lifetimeMinutes=10L;
    long refreshEveryMinutes=8L;
    long absoluteLastRefreshMs=startMs + (1 + numExpectedRefreshes) * 1000 * 60* refreshEveryMinutes - 1000 * 60 * refreshEveryMinutes / 2;
    int bufferIntrusionSeconds=1;
    short minPeriodSeconds=(short)(refreshEveryMinutes * 60 + bufferIntrusionSeconds);
    short bufferSeconds=(short)0;
    MockScheduler mockScheduler=new MockScheduler(mockTime);
    List<KafkaFutureImpl<Long>> waiters=addWaiters(mockScheduler,1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds),numExpectedRefreshes + 1);
    TestLoginContextFactory testLoginContextFactory=new TestLoginContextFactory();
    TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin=new TestExpiringCredentialRefreshingLogin(refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(1.0 * refreshEveryMinutes / lifetimeMinutes,minPeriodSeconds,bufferSeconds,clientReloginAllowedBeforeLogout),testLoginContextFactory,mockTime,1000 * 60 * lifetimeMinutes,absoluteLastRefreshMs,clientReloginAllowedBeforeLogout);
    testLoginContextFactory.configure(mockLoginContext,testExpiringCredentialRefreshingLogin);
    long expectedFinalMs=startMs + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds);
    assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());
    assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());
    testExpiringCredentialRefreshingLogin.login();
    assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());
    testLoginContextFactory.refresherThreadDoneFuture().get(1L,TimeUnit.SECONDS);
    assertEquals(expectedFinalMs,mockTime.milliseconds());
    for (int i=0; i < numExpectedRefreshes; ++i) {
      KafkaFutureImpl<Long> waiter=waiters.get(i);
      assertTrue(waiter.isDone());
      assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes + bufferIntrusionSeconds),waiter.get().longValue() - startMs);
    }
    assertFalse(waiters.get(numExpectedRefreshes).isDone());
    InOrder inOrder=inOrder(mockLoginContext);
    inOrder.verify(mockLoginContext).login();
    for (int i=0; i < numExpectedRefreshes; ++i) {
      inOrder.verify(mockLoginContext).login();
      inOrder.verify(mockLoginContext).logout();
    }
  }
  @Test public void testRefreshWithPreExpirationBufferIntrusion() throws Exception {
    int numExpectedRefreshes=1;
    boolean clientReloginAllowedBeforeLogout=true;
    Subject subject=new Subject();
    final LoginContext mockLoginContext=mock(LoginContext.class);
    when(mockLoginContext.getSubject()).thenReturn(subject);
    MockTime mockTime=new MockTime();
    long startMs=mockTime.milliseconds();
    long lifetimeMinutes=10L;
    long refreshEveryMinutes=8L;
    long absoluteLastRefreshMs=startMs + (1 + numExpectedRefreshes) * 1000 * 60* refreshEveryMinutes - 1000 * 60 * refreshEveryMinutes / 2;
    int bufferIntrusionSeconds=1;
    short bufferSeconds=(short)((lifetimeMinutes - refreshEveryMinutes) * 60 + bufferIntrusionSeconds);
    short minPeriodSeconds=(short)0;
    MockScheduler mockScheduler=new MockScheduler(mockTime);
    List<KafkaFutureImpl<Long>> waiters=addWaiters(mockScheduler,1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds),numExpectedRefreshes + 1);
    TestLoginContextFactory testLoginContextFactory=new TestLoginContextFactory();
    TestExpiringCredentialRefreshingLogin testExpiringCredentialRefreshingLogin=new TestExpiringCredentialRefreshingLogin(refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(1.0 * refreshEveryMinutes / lifetimeMinutes,minPeriodSeconds,bufferSeconds,clientReloginAllowedBeforeLogout),testLoginContextFactory,mockTime,1000 * 60 * lifetimeMinutes,absoluteLastRefreshMs,clientReloginAllowedBeforeLogout);
    testLoginContextFactory.configure(mockLoginContext,testExpiringCredentialRefreshingLogin);
    long expectedFinalMs=startMs + numExpectedRefreshes * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds);
    assertFalse(testLoginContextFactory.refresherThreadStartedFuture().isDone());
    assertFalse(testLoginContextFactory.refresherThreadDoneFuture().isDone());
    testExpiringCredentialRefreshingLogin.login();
    assertTrue(testLoginContextFactory.refresherThreadStartedFuture().isDone());
    testLoginContextFactory.refresherThreadDoneFuture().get(1L,TimeUnit.SECONDS);
    assertEquals(expectedFinalMs,mockTime.milliseconds());
    for (int i=0; i < numExpectedRefreshes; ++i) {
      KafkaFutureImpl<Long> waiter=waiters.get(i);
      assertTrue(waiter.isDone());
      assertEquals((i + 1) * 1000 * (60 * refreshEveryMinutes - bufferIntrusionSeconds),waiter.get().longValue() - startMs);
    }
    assertFalse(waiters.get(numExpectedRefreshes).isDone());
    InOrder inOrder=inOrder(mockLoginContext);
    inOrder.verify(mockLoginContext).login();
    for (int i=0; i < numExpectedRefreshes; ++i) {
      inOrder.verify(mockLoginContext).login();
      inOrder.verify(mockLoginContext).logout();
    }
  }
  private static List<KafkaFutureImpl<Long>> addWaiters(  MockScheduler mockScheduler,  long refreshEveryMillis,  int numWaiters){
    List<KafkaFutureImpl<Long>> retvalWaiters=new ArrayList<>(numWaiters);
    for (int i=1; i <= numWaiters; ++i) {
      KafkaFutureImpl<Long> waiter=new KafkaFutureImpl<Long>();
      mockScheduler.addWaiter(i * refreshEveryMillis,waiter);
      retvalWaiters.add(waiter);
    }
    return retvalWaiters;
  }
  private static ExpiringCredentialRefreshConfig refreshConfigThatPerformsReloginEveryGivenPercentageOfLifetime(  double refreshWindowFactor,  short minPeriodSeconds,  short bufferSeconds,  boolean clientReloginAllowedBeforeLogout){
    Map<Object,Object> configs=new HashMap<>();
    configs.put(SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR,refreshWindowFactor);
    configs.put(SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER,0);
    configs.put(SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,minPeriodSeconds);
    configs.put(SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,bufferSeconds);
    return new ExpiringCredentialRefreshConfig(new ConfigDef().withClientSaslSupport().parse(configs),clientReloginAllowedBeforeLogout);
  }
}
