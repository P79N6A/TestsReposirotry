@RunWith(value=Parameterized.class) public static class ParameterizedConversionTest {
  private final CompressionType compressionType;
  private final byte toMagic;
  public ParameterizedConversionTest(  CompressionType compressionType,  byte toMagic){
    this.compressionType=compressionType;
    this.toMagic=toMagic;
  }
  @Parameterized.Parameters(name="compressionType={0}, toMagic={1}") public static Collection<Object[]> data(){
    List<Object[]> values=new ArrayList<>();
    for (byte toMagic=RecordBatch.MAGIC_VALUE_V0; toMagic <= RecordBatch.CURRENT_MAGIC_VALUE; toMagic++) {
      values.add(new Object[]{CompressionType.NONE,toMagic});
      values.add(new Object[]{CompressionType.GZIP,toMagic});
    }
    return values;
  }
  /** 
 * Test the lazy down-conversion path.
 */
  @Test public void testConversion() throws IOException {
    doTestConversion(false);
  }
  /** 
 * Test the lazy down-conversion path where the number of bytes we want to convert is much larger than the number of bytes we get after conversion. This causes overflow message batch(es) to be appended towards the end of the converted output.
 */
  @Test public void testConversionWithOverflow() throws IOException {
    doTestConversion(true);
  }
  private void doTestConversion(  boolean testConversionOverflow) throws IOException {
    List<Long> offsets=asList(0L,2L,3L,9L,11L,15L,16L,17L,22L,24L);
    Header[] headers={new RecordHeader("headerKey1","headerValue1".getBytes()),new RecordHeader("headerKey2","headerValue2".getBytes()),new RecordHeader("headerKey3","headerValue3".getBytes())};
    List<SimpleRecord> records=asList(new SimpleRecord(1L,"k1".getBytes(),"hello".getBytes()),new SimpleRecord(2L,"k2".getBytes(),"goodbye".getBytes()),new SimpleRecord(3L,"k3".getBytes(),"hello again".getBytes()),new SimpleRecord(4L,"k4".getBytes(),"goodbye for now".getBytes()),new SimpleRecord(5L,"k5".getBytes(),"hello again".getBytes()),new SimpleRecord(6L,"k6".getBytes(),"I sense indecision".getBytes()),new SimpleRecord(7L,"k7".getBytes(),"what now".getBytes()),new SimpleRecord(8L,"k8".getBytes(),"running out".getBytes(),headers),new SimpleRecord(9L,"k9".getBytes(),"ok, almost done".getBytes()),new SimpleRecord(10L,"k10".getBytes(),"finally".getBytes(),headers));
    assertEquals("incorrect test setup",offsets.size(),records.size());
    ByteBuffer buffer=ByteBuffer.allocate(1024);
    MemoryRecordsBuilder builder=MemoryRecords.builder(buffer,RecordBatch.CURRENT_MAGIC_VALUE,compressionType,TimestampType.CREATE_TIME,0L);
    for (int i=0; i < 3; i++)     builder.appendWithOffset(offsets.get(i),records.get(i));
    builder.close();
    builder=MemoryRecords.builder(buffer,RecordBatch.CURRENT_MAGIC_VALUE,compressionType,TimestampType.CREATE_TIME,0L);
    for (int i=3; i < 6; i++)     builder.appendWithOffset(offsets.get(i),records.get(i));
    builder.close();
    builder=MemoryRecords.builder(buffer,RecordBatch.CURRENT_MAGIC_VALUE,compressionType,TimestampType.CREATE_TIME,0L);
    for (int i=6; i < 10; i++)     builder.appendWithOffset(offsets.get(i),records.get(i));
    builder.close();
    buffer.flip();
    MemoryRecords recordsToConvert=MemoryRecords.readableRecords(buffer);
    int numBytesToConvert=recordsToConvert.sizeInBytes();
    if (testConversionOverflow)     numBytesToConvert*=2;
    MemoryRecords convertedRecords=convertRecords(recordsToConvert,toMagic,numBytesToConvert);
    verifyDownConvertedRecords(records,offsets,convertedRecords,compressionType,toMagic);
  }
}
