public class PrintedTest {
  private final PrintStream originalSysOut=System.out;
  private final ByteArrayOutputStream sysOut=new ByteArrayOutputStream();
  private Printed<String,Integer> sysOutPrinter;
  @Before public void before(){
    System.setOut(new PrintStream(sysOut));
    sysOutPrinter=Printed.toSysOut();
  }
  @After public void after(){
    System.setOut(originalSysOut);
  }
  @Test public void shouldCreateProcessorThatPrintsToFile() throws IOException {
    final File file=TestUtils.tempFile();
    final ProcessorSupplier<String,Integer> processorSupplier=new PrintedInternal<>(Printed.<String,Integer>toFile(file.getPath())).build("processor");
    final Processor<String,Integer> processor=processorSupplier.get();
    processor.process("hi",1);
    processor.close();
    try (final InputStream stream=Files.newInputStream(file.toPath())){
      final byte[] data=new byte[stream.available()];
      stream.read(data);
      assertThat(new String(data,StandardCharsets.UTF_8.name()),equalTo("[processor]: hi, 1\n"));
    }
   }
  @Test public void shouldCreateProcessorThatPrintsToStdOut() throws UnsupportedEncodingException {
    final ProcessorSupplier<String,Integer> supplier=new PrintedInternal<>(sysOutPrinter).build("processor");
    final Processor<String,Integer> processor=supplier.get();
    processor.process("good",2);
    processor.close();
    assertThat(sysOut.toString(StandardCharsets.UTF_8.name()),equalTo("[processor]: good, 2\n"));
  }
  @Test public void shouldPrintWithLabel() throws UnsupportedEncodingException {
    final Processor<String,Integer> processor=new PrintedInternal<>(sysOutPrinter.withLabel("label")).build("processor").get();
    processor.process("hello",3);
    processor.close();
    assertThat(sysOut.toString(StandardCharsets.UTF_8.name()),equalTo("[label]: hello, 3\n"));
  }
  @Test public void shouldPrintWithKeyValueMapper() throws UnsupportedEncodingException {
    final Processor<String,Integer> processor=new PrintedInternal<>(sysOutPrinter.withKeyValueMapper(new KeyValueMapper<String,Integer,String>(){
      @Override public String apply(      final String key,      final Integer value){
        return String.format("%s -> %d",key,value);
      }
    }
)).build("processor").get();
    processor.process("hello",1);
    processor.close();
    assertThat(sysOut.toString(StandardCharsets.UTF_8.name()),equalTo("[processor]: hello -> 1\n"));
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerExceptionIfFilePathIsNull(){
    Printed.toFile(null);
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerExceptionIfMapperIsNull(){
    sysOutPrinter.withKeyValueMapper(null);
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerExceptionIfLabelIsNull(){
    sysOutPrinter.withLabel(null);
  }
  @Test(expected=TopologyException.class) public void shouldThrowTopologyExceptionIfFilePathIsEmpty(){
    Printed.toFile("");
  }
  @Test(expected=TopologyException.class) public void shouldThrowTopologyExceptionIfFilePathDoesntExist(){
    Printed.toFile("/this/should/not/exist");
  }
}
