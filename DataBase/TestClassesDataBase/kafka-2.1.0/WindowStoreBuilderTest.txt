@RunWith(EasyMockRunner.class) public class WindowStoreBuilderTest {
  @Mock(type=MockType.NICE) private WindowBytesStoreSupplier supplier;
  @Mock(type=MockType.NICE) private WindowStore<Bytes,byte[]> inner;
  private WindowStoreBuilder<String,String> builder;
  @Before public void setUp() throws Exception {
    EasyMock.expect(supplier.get()).andReturn(inner);
    EasyMock.expect(supplier.name()).andReturn("name");
    EasyMock.replay(supplier);
    builder=new WindowStoreBuilder<>(supplier,Serdes.String(),Serdes.String(),new MockTime());
  }
  @Test public void shouldHaveMeteredStoreAsOuterStore(){
    final WindowStore<String,String> store=builder.build();
    assertThat(store,instanceOf(MeteredWindowStore.class));
  }
  @Test public void shouldHaveChangeLoggingStoreByDefault(){
    final WindowStore<String,String> store=builder.build();
    final StateStore next=((WrappedStateStore)store).wrappedStore();
    assertThat(next,instanceOf(ChangeLoggingWindowBytesStore.class));
  }
  @Test public void shouldNotHaveChangeLoggingStoreWhenDisabled(){
    final WindowStore<String,String> store=builder.withLoggingDisabled().build();
    final StateStore next=((WrappedStateStore)store).wrappedStore();
    assertThat(next,CoreMatchers.<StateStore>equalTo(inner));
  }
  @Test public void shouldHaveCachingStoreWhenEnabled(){
    final WindowStore<String,String> store=builder.withCachingEnabled().build();
    final StateStore wrapped=((WrappedStateStore)store).wrappedStore();
    assertThat(store,instanceOf(MeteredWindowStore.class));
    assertThat(wrapped,instanceOf(CachingWindowStore.class));
  }
  @Test public void shouldHaveChangeLoggingStoreWhenLoggingEnabled(){
    final WindowStore<String,String> store=builder.withLoggingEnabled(Collections.<String,String>emptyMap()).build();
    final StateStore wrapped=((WrappedStateStore)store).wrappedStore();
    assertThat(store,instanceOf(MeteredWindowStore.class));
    assertThat(wrapped,instanceOf(ChangeLoggingWindowBytesStore.class));
    assertThat(((WrappedStateStore)wrapped).wrappedStore(),CoreMatchers.<StateStore>equalTo(inner));
  }
  @Test public void shouldHaveCachingAndChangeLoggingWhenBothEnabled(){
    final WindowStore<String,String> store=builder.withLoggingEnabled(Collections.<String,String>emptyMap()).withCachingEnabled().build();
    final WrappedStateStore caching=(WrappedStateStore)((WrappedStateStore)store).wrappedStore();
    final WrappedStateStore changeLogging=(WrappedStateStore)caching.wrappedStore();
    assertThat(store,instanceOf(MeteredWindowStore.class));
    assertThat(caching,instanceOf(CachingWindowStore.class));
    assertThat(changeLogging,instanceOf(ChangeLoggingWindowBytesStore.class));
    assertThat(changeLogging.wrappedStore(),CoreMatchers.<StateStore>equalTo(inner));
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfInnerIsNull(){
    new WindowStoreBuilder<>(null,Serdes.String(),Serdes.String(),new MockTime());
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfKeySerdeIsNull(){
    new WindowStoreBuilder<>(supplier,null,Serdes.String(),new MockTime());
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfValueSerdeIsNull(){
    new WindowStoreBuilder<>(supplier,Serdes.String(),null,new MockTime());
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfTimeIsNull(){
    new WindowStoreBuilder<>(supplier,Serdes.String(),Serdes.String(),null);
  }
}
