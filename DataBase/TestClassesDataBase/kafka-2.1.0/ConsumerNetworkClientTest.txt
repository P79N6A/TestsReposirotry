public class ConsumerNetworkClientTest {
  private String topicName="test";
  private MockTime time=new MockTime(1);
  private MockClient client=new MockClient(time);
  private Cluster cluster=TestUtils.singletonCluster(topicName,1);
  private Node node=cluster.nodes().get(0);
  private Metadata metadata=new Metadata(0,Long.MAX_VALUE,true);
  private ConsumerNetworkClient consumerClient=new ConsumerNetworkClient(new LogContext(),client,metadata,time,100,1000,Integer.MAX_VALUE);
  @Test public void send(){
    client.prepareResponse(heartbeatResponse(Errors.NONE));
    RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat());
    assertEquals(1,consumerClient.pendingRequestCount());
    assertEquals(1,consumerClient.pendingRequestCount(node));
    assertFalse(future.isDone());
    consumerClient.poll(future);
    assertTrue(future.isDone());
    assertTrue(future.succeeded());
    ClientResponse clientResponse=future.value();
    HeartbeatResponse response=(HeartbeatResponse)clientResponse.responseBody();
    assertEquals(Errors.NONE,response.error());
  }
  @Test public void sendWithinBlackoutPeriodAfterAuthenticationFailure() throws InterruptedException {
    client.authenticationFailed(node,300);
    client.prepareResponse(heartbeatResponse(Errors.NONE));
    final RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat());
    consumerClient.poll(future);
    assertTrue(future.failed());
    assertTrue("Expected only an authentication error.",future.exception() instanceof AuthenticationException);
    time.sleep(30);
    assertTrue(client.connectionFailed(node));
    final RequestFuture<ClientResponse> future2=consumerClient.send(node,heartbeat());
    consumerClient.poll(future2);
    assertTrue(future2.failed());
    assertTrue("Expected only an authentication error.",future2.exception() instanceof AuthenticationException);
  }
  @Test public void multiSend(){
    client.prepareResponse(heartbeatResponse(Errors.NONE));
    client.prepareResponse(heartbeatResponse(Errors.NONE));
    RequestFuture<ClientResponse> future1=consumerClient.send(node,heartbeat());
    RequestFuture<ClientResponse> future2=consumerClient.send(node,heartbeat());
    assertEquals(2,consumerClient.pendingRequestCount());
    assertEquals(2,consumerClient.pendingRequestCount(node));
    consumerClient.awaitPendingRequests(node,time.timer(Long.MAX_VALUE));
    assertTrue(future1.succeeded());
    assertTrue(future2.succeeded());
  }
  @Test public void testDisconnectWithUnsentRequests(){
    RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat());
    assertTrue(consumerClient.hasPendingRequests(node));
    assertFalse(client.hasInFlightRequests(node.idString()));
    consumerClient.disconnectAsync(node);
    consumerClient.pollNoWakeup();
    assertTrue(future.failed());
    assertTrue(future.exception() instanceof DisconnectException);
  }
  @Test public void testDisconnectWithInFlightRequests(){
    RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat());
    consumerClient.pollNoWakeup();
    assertTrue(consumerClient.hasPendingRequests(node));
    assertTrue(client.hasInFlightRequests(node.idString()));
    consumerClient.disconnectAsync(node);
    consumerClient.pollNoWakeup();
    assertTrue(future.failed());
    assertTrue(future.exception() instanceof DisconnectException);
  }
  @Test public void testTimeoutUnsentRequest(){
    client.delayReady(node,1000);
    RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat(),500);
    consumerClient.pollNoWakeup();
    assertTrue(consumerClient.hasPendingRequests());
    assertFalse(client.hasInFlightRequests());
    time.sleep(501);
    consumerClient.pollNoWakeup();
    assertFalse(consumerClient.hasPendingRequests());
    assertTrue(future.failed());
    assertTrue(future.exception() instanceof TimeoutException);
  }
  @Test public void doNotBlockIfPollConditionIsSatisfied(){
    NetworkClient mockNetworkClient=mock(NetworkClient.class);
    ConsumerNetworkClient consumerClient=new ConsumerNetworkClient(new LogContext(),mockNetworkClient,metadata,time,100,1000,Integer.MAX_VALUE);
    consumerClient.poll(time.timer(Long.MAX_VALUE),() -> false);
    verify(mockNetworkClient).poll(eq(0L),anyLong());
  }
  @Test public void blockWhenPollConditionNotSatisfied(){
    long timeout=4000L;
    NetworkClient mockNetworkClient=mock(NetworkClient.class);
    ConsumerNetworkClient consumerClient=new ConsumerNetworkClient(new LogContext(),mockNetworkClient,metadata,time,100,1000,Integer.MAX_VALUE);
    when(mockNetworkClient.inFlightRequestCount()).thenReturn(1);
    consumerClient.poll(time.timer(timeout),() -> true);
    verify(mockNetworkClient).poll(eq(timeout),anyLong());
  }
  @Test public void blockOnlyForRetryBackoffIfNoInflightRequests(){
    long retryBackoffMs=100L;
    NetworkClient mockNetworkClient=mock(NetworkClient.class);
    ConsumerNetworkClient consumerClient=new ConsumerNetworkClient(new LogContext(),mockNetworkClient,metadata,time,retryBackoffMs,1000,Integer.MAX_VALUE);
    when(mockNetworkClient.inFlightRequestCount()).thenReturn(0);
    consumerClient.poll(time.timer(Long.MAX_VALUE),() -> true);
    verify(mockNetworkClient).poll(eq(retryBackoffMs),anyLong());
  }
  @Test public void wakeup(){
    RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat());
    consumerClient.wakeup();
    try {
      consumerClient.poll(time.timer(0));
      fail();
    }
 catch (    WakeupException e) {
    }
    client.respond(heartbeatResponse(Errors.NONE));
    consumerClient.poll(future);
    assertTrue(future.isDone());
  }
  @Test public void testDisconnectWakesUpPoll() throws Exception {
    final RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat());
    client.enableBlockingUntilWakeup(1);
    Thread t=new Thread(){
      @Override public void run(){
        consumerClient.poll(future);
      }
    }
;
    t.start();
    consumerClient.disconnectAsync(node);
    t.join();
    assertTrue(future.failed());
    assertTrue(future.exception() instanceof DisconnectException);
  }
  @Test public void testFutureCompletionOutsidePoll() throws Exception {
    final RequestFuture<ClientResponse> future=consumerClient.send(node,heartbeat());
    consumerClient.pollNoWakeup();
    client.enableBlockingUntilWakeup(2);
    Thread t1=new Thread(){
      @Override public void run(){
        consumerClient.pollNoWakeup();
      }
    }
;
    t1.start();
    Thread.sleep(50);
    Thread t2=new Thread(){
      @Override public void run(){
        consumerClient.poll(future);
      }
    }
;
    t2.start();
    Thread.sleep(50);
    client.respond(heartbeatResponse(Errors.NONE));
    client.wakeup();
    t1.join();
    t2.join();
    assertTrue(future.succeeded());
  }
  @Test public void testAwaitForMetadataUpdateWithTimeout(){
    assertFalse(consumerClient.awaitMetadataUpdate(time.timer(10L)));
  }
  @Test public void sendExpiry(){
    int requestTimeoutMs=10;
    final AtomicBoolean isReady=new AtomicBoolean();
    final AtomicBoolean disconnected=new AtomicBoolean();
    client=new MockClient(time){
      @Override public boolean ready(      Node node,      long now){
        if (isReady.get())         return super.ready(node,now);
 else         return false;
      }
      @Override public boolean connectionFailed(      Node node){
        return disconnected.get();
      }
    }
;
    consumerClient=new ConsumerNetworkClient(new LogContext(),client,metadata,time,100,requestTimeoutMs,Integer.MAX_VALUE);
    RequestFuture<ClientResponse> future1=consumerClient.send(node,heartbeat());
    assertEquals(1,consumerClient.pendingRequestCount());
    assertEquals(1,consumerClient.pendingRequestCount(node));
    assertFalse(future1.isDone());
    time.sleep(requestTimeoutMs + 1);
    RequestFuture<ClientResponse> future2=consumerClient.send(node,heartbeat());
    assertEquals(2,consumerClient.pendingRequestCount());
    assertEquals(2,consumerClient.pendingRequestCount(node));
    assertFalse(future2.isDone());
    consumerClient.poll(time.timer(0));
    assertTrue(future1.isDone());
    assertFalse(future1.succeeded());
    assertEquals(1,consumerClient.pendingRequestCount());
    assertEquals(1,consumerClient.pendingRequestCount(node));
    assertFalse(future2.isDone());
    isReady.set(true);
    client.prepareResponse(heartbeatResponse(Errors.NONE));
    consumerClient.poll(future2);
    ClientResponse clientResponse=future2.value();
    HeartbeatResponse response=(HeartbeatResponse)clientResponse.responseBody();
    assertEquals(Errors.NONE,response.error());
    isReady.set(false);
    RequestFuture<ClientResponse> future3=consumerClient.send(node,heartbeat());
    assertEquals(1,consumerClient.pendingRequestCount());
    assertEquals(1,consumerClient.pendingRequestCount(node));
    disconnected.set(true);
    consumerClient.poll(time.timer(0));
    assertTrue(future3.isDone());
    assertFalse(future3.succeeded());
    assertEquals(0,consumerClient.pendingRequestCount());
    assertEquals(0,consumerClient.pendingRequestCount(node));
  }
  private HeartbeatRequest.Builder heartbeat(){
    return new HeartbeatRequest.Builder("group",1,"memberId");
  }
  private HeartbeatResponse heartbeatResponse(  Errors error){
    return new HeartbeatResponse(error);
  }
}
