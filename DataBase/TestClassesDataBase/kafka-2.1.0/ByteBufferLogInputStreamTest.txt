public class ByteBufferLogInputStreamTest {
  @Test public void iteratorIgnoresIncompleteEntries(){
    ByteBuffer buffer=ByteBuffer.allocate(1024);
    MemoryRecordsBuilder builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,0L);
    builder.append(15L,"a".getBytes(),"1".getBytes());
    builder.append(20L,"b".getBytes(),"2".getBytes());
    builder.close();
    builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,2L);
    builder.append(30L,"c".getBytes(),"3".getBytes());
    builder.append(40L,"d".getBytes(),"4".getBytes());
    builder.close();
    buffer.flip();
    buffer.limit(buffer.limit() - 5);
    MemoryRecords records=MemoryRecords.readableRecords(buffer);
    Iterator<MutableRecordBatch> iterator=records.batches().iterator();
    assertTrue(iterator.hasNext());
    MutableRecordBatch first=iterator.next();
    assertEquals(1L,first.lastOffset());
    assertFalse(iterator.hasNext());
  }
  @Test(expected=CorruptRecordException.class) public void iteratorRaisesOnTooSmallRecords() throws IOException {
    ByteBuffer buffer=ByteBuffer.allocate(1024);
    MemoryRecordsBuilder builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,0L);
    builder.append(15L,"a".getBytes(),"1".getBytes());
    builder.append(20L,"b".getBytes(),"2".getBytes());
    builder.close();
    int position=buffer.position();
    builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,2L);
    builder.append(30L,"c".getBytes(),"3".getBytes());
    builder.append(40L,"d".getBytes(),"4".getBytes());
    builder.close();
    buffer.flip();
    buffer.putInt(position + DefaultRecordBatch.LENGTH_OFFSET,9);
    ByteBufferLogInputStream logInputStream=new ByteBufferLogInputStream(buffer,Integer.MAX_VALUE);
    assertNotNull(logInputStream.nextBatch());
    logInputStream.nextBatch();
  }
  @Test(expected=CorruptRecordException.class) public void iteratorRaisesOnInvalidMagic() throws IOException {
    ByteBuffer buffer=ByteBuffer.allocate(1024);
    MemoryRecordsBuilder builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,0L);
    builder.append(15L,"a".getBytes(),"1".getBytes());
    builder.append(20L,"b".getBytes(),"2".getBytes());
    builder.close();
    int position=buffer.position();
    builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,2L);
    builder.append(30L,"c".getBytes(),"3".getBytes());
    builder.append(40L,"d".getBytes(),"4".getBytes());
    builder.close();
    buffer.flip();
    buffer.put(position + DefaultRecordBatch.MAGIC_OFFSET,(byte)37);
    ByteBufferLogInputStream logInputStream=new ByteBufferLogInputStream(buffer,Integer.MAX_VALUE);
    assertNotNull(logInputStream.nextBatch());
    logInputStream.nextBatch();
  }
  @Test(expected=CorruptRecordException.class) public void iteratorRaisesOnTooLargeRecords() throws IOException {
    ByteBuffer buffer=ByteBuffer.allocate(1024);
    MemoryRecordsBuilder builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,0L);
    builder.append(15L,"a".getBytes(),"1".getBytes());
    builder.append(20L,"b".getBytes(),"2".getBytes());
    builder.close();
    builder=MemoryRecords.builder(buffer,CompressionType.NONE,TimestampType.CREATE_TIME,2L);
    builder.append(30L,"c".getBytes(),"3".getBytes());
    builder.append(40L,"d".getBytes(),"4".getBytes());
    builder.close();
    buffer.flip();
    ByteBufferLogInputStream logInputStream=new ByteBufferLogInputStream(buffer,25);
    assertNotNull(logInputStream.nextBatch());
    logInputStream.nextBatch();
  }
}
