public class RecordSendTest {
  private final TopicPartition topicPartition=new TopicPartition("test",0);
  private final long baseOffset=45;
  private final long relOffset=5;
  /** 
 * Test that waiting on a request that never completes times out
 */
  @Test public void testTimeout() throws Exception {
    ProduceRequestResult request=new ProduceRequestResult(topicPartition);
    FutureRecordMetadata future=new FutureRecordMetadata(request,relOffset,RecordBatch.NO_TIMESTAMP,0L,0,0);
    assertFalse("Request is not completed",future.isDone());
    try {
      future.get(5,TimeUnit.MILLISECONDS);
      fail("Should have thrown exception.");
    }
 catch (    TimeoutException e) {
    }
    request.set(baseOffset,RecordBatch.NO_TIMESTAMP,null);
    request.done();
    assertTrue(future.isDone());
    assertEquals(baseOffset + relOffset,future.get().offset());
  }
  /** 
 * Test that an asynchronous request will eventually throw the right exception
 */
  @Test(expected=ExecutionException.class) public void testError() throws Exception {
    FutureRecordMetadata future=new FutureRecordMetadata(asyncRequest(baseOffset,new CorruptRecordException(),50L),relOffset,RecordBatch.NO_TIMESTAMP,0L,0,0);
    future.get();
  }
  /** 
 * Test that an asynchronous request will eventually return the right offset
 */
  @Test public void testBlocking() throws Exception {
    FutureRecordMetadata future=new FutureRecordMetadata(asyncRequest(baseOffset,null,50L),relOffset,RecordBatch.NO_TIMESTAMP,0L,0,0);
    assertEquals(baseOffset + relOffset,future.get().offset());
  }
  public ProduceRequestResult asyncRequest(  final long baseOffset,  final RuntimeException error,  final long timeout){
    final ProduceRequestResult request=new ProduceRequestResult(topicPartition);
    Thread thread=new Thread(){
      public void run(){
        try {
          sleep(timeout);
          request.set(baseOffset,RecordBatch.NO_TIMESTAMP,error);
          request.done();
        }
 catch (        InterruptedException e) {
        }
      }
    }
;
    thread.start();
    return request;
  }
}
