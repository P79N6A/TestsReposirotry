public class TransactionManagerTest {
  private static final int MAX_REQUEST_SIZE=1024 * 1024;
  private static final short ACKS_ALL=-1;
  private static final int MAX_RETRIES=Integer.MAX_VALUE;
  private static final String CLIENT_ID="clientId";
  private static final int MAX_BLOCK_TIMEOUT=1000;
  private static final int REQUEST_TIMEOUT=1000;
  private static final long DEFAULT_RETRY_BACKOFF_MS=100L;
  private final String transactionalId="foobar";
  private final int transactionTimeoutMs=1121;
  private final String topic="test";
  private TopicPartition tp0=new TopicPartition(topic,0);
  private TopicPartition tp1=new TopicPartition(topic,1);
  private MockTime time=new MockTime();
  private MockClient client=new MockClient(time);
  private Metadata metadata=new Metadata(0,Long.MAX_VALUE,true,true,new ClusterResourceListeners());
  private ApiVersions apiVersions=new ApiVersions();
  private Cluster cluster=TestUtils.singletonCluster("test",2);
  private RecordAccumulator accumulator=null;
  private Sender sender=null;
  private TransactionManager transactionManager=null;
  private Node brokerNode=null;
  private final LogContext logContext=new LogContext();
  @Before public void setup(){
    Map<String,String> metricTags=new LinkedHashMap<>();
    metricTags.put("client-id",CLIENT_ID);
    int batchSize=16 * 1024;
    long deliveryTimeoutMs=3000L;
    long totalSize=1024 * 1024;
    String metricGrpName="producer-metrics";
    MetricConfig metricConfig=new MetricConfig().tags(metricTags);
    this.brokerNode=new Node(0,"localhost",2211);
    this.transactionManager=new TransactionManager(logContext,transactionalId,transactionTimeoutMs,DEFAULT_RETRY_BACKOFF_MS);
    Metrics metrics=new Metrics(metricConfig,time);
    SenderMetricsRegistry senderMetrics=new SenderMetricsRegistry(metrics);
    this.accumulator=new RecordAccumulator(logContext,batchSize,CompressionType.NONE,0L,0L,deliveryTimeoutMs,metrics,metricGrpName,time,apiVersions,transactionManager,new BufferPool(totalSize,batchSize,metrics,time,metricGrpName));
    this.sender=new Sender(logContext,this.client,this.metadata,this.accumulator,true,MAX_REQUEST_SIZE,ACKS_ALL,MAX_RETRIES,senderMetrics,this.time,REQUEST_TIMEOUT,50,transactionManager,apiVersions);
    this.metadata.update(this.cluster,Collections.<String>emptySet(),time.milliseconds());
    client.setNode(brokerNode);
  }
  @Test public void testSenderShutdownWithPendingAddPartitions() throws Exception {
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    FutureRecordMetadata sendFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(tp0,Errors.NONE);
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.initiateClose();
    sender.run();
    assertTrue(sendFuture.isDone());
  }
  @Test public void testEndTxnNotSentIfIncompleteBatches(){
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxn(tp0,Errors.NONE);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    transactionManager.beginCommit();
    assertNull(transactionManager.nextRequestHandler(true));
    assertTrue(transactionManager.nextRequestHandler(false).isEndTxn());
  }
  @Test(expected=IllegalStateException.class) public void testFailIfNotReadyForSendNoProducerId(){
    transactionManager.failIfNotReadyForSend();
  }
  @Test public void testFailIfNotReadyForSendIdempotentProducer(){
    TransactionManager idempotentTransactionManager=new TransactionManager();
    idempotentTransactionManager.failIfNotReadyForSend();
  }
  @Test(expected=KafkaException.class) public void testFailIfNotReadyForSendIdempotentProducerFatalError(){
    TransactionManager idempotentTransactionManager=new TransactionManager();
    idempotentTransactionManager.transitionToFatalError(new KafkaException());
    idempotentTransactionManager.failIfNotReadyForSend();
  }
  @Test(expected=IllegalStateException.class) public void testFailIfNotReadyForSendNoOngoingTransaction(){
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.failIfNotReadyForSend();
  }
  @Test(expected=KafkaException.class) public void testFailIfNotReadyForSendAfterAbortableError(){
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.transitionToAbortableError(new KafkaException());
    transactionManager.failIfNotReadyForSend();
  }
  @Test(expected=KafkaException.class) public void testFailIfNotReadyForSendAfterFatalError(){
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.transitionToFatalError(new KafkaException());
    transactionManager.failIfNotReadyForSend();
  }
  @Test public void testHasOngoingTransactionSuccessfulAbort(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    assertFalse(transactionManager.hasOngoingTransaction());
    doInitTransactions(pid,epoch);
    assertFalse(transactionManager.hasOngoingTransaction());
    transactionManager.beginTransaction();
    assertTrue(transactionManager.hasOngoingTransaction());
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasOngoingTransaction());
    prepareAddPartitionsToTxn(partition,Errors.NONE);
    sender.run(time.milliseconds());
    transactionManager.beginAbort();
    assertTrue(transactionManager.hasOngoingTransaction());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasOngoingTransaction());
  }
  @Test public void testHasOngoingTransactionSuccessfulCommit(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    assertFalse(transactionManager.hasOngoingTransaction());
    doInitTransactions(pid,epoch);
    assertFalse(transactionManager.hasOngoingTransaction());
    transactionManager.beginTransaction();
    assertTrue(transactionManager.hasOngoingTransaction());
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasOngoingTransaction());
    prepareAddPartitionsToTxn(partition,Errors.NONE);
    sender.run(time.milliseconds());
    transactionManager.beginCommit();
    assertTrue(transactionManager.hasOngoingTransaction());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasOngoingTransaction());
  }
  @Test public void testHasOngoingTransactionAbortableError(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    assertFalse(transactionManager.hasOngoingTransaction());
    doInitTransactions(pid,epoch);
    assertFalse(transactionManager.hasOngoingTransaction());
    transactionManager.beginTransaction();
    assertTrue(transactionManager.hasOngoingTransaction());
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasOngoingTransaction());
    prepareAddPartitionsToTxn(partition,Errors.NONE);
    sender.run(time.milliseconds());
    transactionManager.transitionToAbortableError(new KafkaException());
    assertTrue(transactionManager.hasOngoingTransaction());
    transactionManager.beginAbort();
    assertTrue(transactionManager.hasOngoingTransaction());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasOngoingTransaction());
  }
  @Test public void testHasOngoingTransactionFatalError(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    assertFalse(transactionManager.hasOngoingTransaction());
    doInitTransactions(pid,epoch);
    assertFalse(transactionManager.hasOngoingTransaction());
    transactionManager.beginTransaction();
    assertTrue(transactionManager.hasOngoingTransaction());
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasOngoingTransaction());
    prepareAddPartitionsToTxn(partition,Errors.NONE);
    sender.run(time.milliseconds());
    transactionManager.transitionToFatalError(new KafkaException());
    assertFalse(transactionManager.hasOngoingTransaction());
  }
  @Test public void testMaybeAddPartitionToTransaction(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasPartitionsToAdd());
    assertFalse(transactionManager.isPartitionAdded(partition));
    assertTrue(transactionManager.isPartitionPendingAdd(partition));
    prepareAddPartitionsToTxn(partition,Errors.NONE);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasPartitionsToAdd());
    assertTrue(transactionManager.isPartitionAdded(partition));
    assertFalse(transactionManager.isPartitionPendingAdd(partition));
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertFalse(transactionManager.hasPartitionsToAdd());
    assertTrue(transactionManager.isPartitionAdded(partition));
    assertFalse(transactionManager.isPartitionPendingAdd(partition));
  }
  @Test public void testAddPartitionToTransactionOverridesRetryBackoffForConcurrentTransactions(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasPartitionsToAdd());
    assertFalse(transactionManager.isPartitionAdded(partition));
    assertTrue(transactionManager.isPartitionPendingAdd(partition));
    prepareAddPartitionsToTxn(partition,Errors.CONCURRENT_TRANSACTIONS);
    sender.run(time.milliseconds());
    TransactionManager.TxnRequestHandler handler=transactionManager.nextRequestHandler(false);
    assertNotNull(handler);
    assertEquals(20,handler.retryBackoffMs());
  }
  @Test public void testAddPartitionToTransactionRetainsRetryBackoffForRegularRetriableError(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasPartitionsToAdd());
    assertFalse(transactionManager.isPartitionAdded(partition));
    assertTrue(transactionManager.isPartitionPendingAdd(partition));
    prepareAddPartitionsToTxn(partition,Errors.COORDINATOR_NOT_AVAILABLE);
    sender.run(time.milliseconds());
    TransactionManager.TxnRequestHandler handler=transactionManager.nextRequestHandler(false);
    assertNotNull(handler);
    assertEquals(DEFAULT_RETRY_BACKOFF_MS,handler.retryBackoffMs());
  }
  @Test public void testAddPartitionToTransactionRetainsRetryBackoffWhenPartitionsAlreadyAdded(){
    long pid=13131L;
    short epoch=1;
    TopicPartition partition=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(partition);
    assertTrue(transactionManager.hasPartitionsToAdd());
    assertFalse(transactionManager.isPartitionAdded(partition));
    assertTrue(transactionManager.isPartitionPendingAdd(partition));
    prepareAddPartitionsToTxn(partition,Errors.NONE);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isPartitionAdded(partition));
    TopicPartition otherPartition=new TopicPartition("foo",1);
    transactionManager.maybeAddPartitionToTransaction(otherPartition);
    prepareAddPartitionsToTxn(otherPartition,Errors.CONCURRENT_TRANSACTIONS);
    TransactionManager.TxnRequestHandler handler=transactionManager.nextRequestHandler(false);
    assertNotNull(handler);
    assertEquals(DEFAULT_RETRY_BACKOFF_MS,handler.retryBackoffMs());
  }
  @Test(expected=IllegalStateException.class) public void testMaybeAddPartitionToTransactionBeforeInitTransactions(){
    transactionManager.maybeAddPartitionToTransaction(new TopicPartition("foo",0));
  }
  @Test(expected=IllegalStateException.class) public void testMaybeAddPartitionToTransactionBeforeBeginTransaction(){
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.maybeAddPartitionToTransaction(new TopicPartition("foo",0));
  }
  @Test(expected=KafkaException.class) public void testMaybeAddPartitionToTransactionAfterAbortableError(){
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.transitionToAbortableError(new KafkaException());
    transactionManager.maybeAddPartitionToTransaction(new TopicPartition("foo",0));
  }
  @Test(expected=KafkaException.class) public void testMaybeAddPartitionToTransactionAfterFatalError(){
    long pid=13131L;
    short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.transitionToFatalError(new KafkaException());
    transactionManager.maybeAddPartitionToTransaction(new TopicPartition("foo",0));
  }
  @Test public void testIsSendToPartitionAllowedWithPendingPartitionAfterAbortableError(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    transactionManager.transitionToAbortableError(new KafkaException());
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    assertTrue(transactionManager.hasAbortableError());
  }
  @Test public void testIsSendToPartitionAllowedWithInFlightPartitionAddAfterAbortableError(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    sender.run(time.milliseconds());
    transactionManager.transitionToAbortableError(new KafkaException());
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    assertTrue(transactionManager.hasAbortableError());
  }
  @Test public void testIsSendToPartitionAllowedWithPendingPartitionAfterFatalError(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    transactionManager.transitionToFatalError(new KafkaException());
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    assertTrue(transactionManager.hasFatalError());
  }
  @Test public void testIsSendToPartitionAllowedWithInFlightPartitionAddAfterFatalError(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    sender.run(time.milliseconds());
    transactionManager.transitionToFatalError(new KafkaException());
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    assertTrue(transactionManager.hasFatalError());
  }
  @Test public void testIsSendToPartitionAllowedWithAddedPartitionAfterAbortableError(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasPartitionsToAdd());
    transactionManager.transitionToAbortableError(new KafkaException());
    assertTrue(transactionManager.isSendToPartitionAllowed(tp0));
    assertTrue(transactionManager.hasAbortableError());
  }
  @Test public void testIsSendToPartitionAllowedWithAddedPartitionAfterFatalError(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasPartitionsToAdd());
    transactionManager.transitionToFatalError(new KafkaException());
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    assertTrue(transactionManager.hasFatalError());
  }
  @Test public void testIsSendToPartitionAllowedWithPartitionNotAdded(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
  }
  @Test(expected=IllegalStateException.class) public void testInvalidSequenceIncrement(){
    TransactionManager transactionManager=new TransactionManager();
    transactionManager.incrementSequenceNumber(tp0,3333);
  }
  @Test public void testDefaultSequenceNumber(){
    TransactionManager transactionManager=new TransactionManager();
    assertEquals((int)transactionManager.sequenceNumber(tp0),0);
    transactionManager.incrementSequenceNumber(tp0,3);
    assertEquals((int)transactionManager.sequenceNumber(tp0),3);
  }
  @Test public void testProducerIdReset(){
    TransactionManager transactionManager=new TransactionManager();
    assertEquals((int)transactionManager.sequenceNumber(tp0),0);
    transactionManager.incrementSequenceNumber(tp0,3);
    assertEquals((int)transactionManager.sequenceNumber(tp0),3);
    transactionManager.resetProducerId();
    assertEquals((int)transactionManager.sequenceNumber(tp0),0);
  }
  @Test public void testBasicTransaction() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    prepareProduceResponse(Errors.NONE,pid,epoch);
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    assertTrue(transactionManager.isSendToPartitionAllowed(tp0));
    assertFalse(responseFuture.isDone());
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    Map<TopicPartition,OffsetAndMetadata> offsets=new HashMap<>();
    offsets.put(tp1,new OffsetAndMetadata(1));
    final String consumerGroupId="myconsumergroup";
    TransactionalRequestResult addOffsetsResult=transactionManager.sendOffsetsToTransaction(offsets,consumerGroupId);
    assertFalse(transactionManager.hasPendingOffsetCommits());
    prepareAddOffsetsToTxnResponse(Errors.NONE,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasPendingOffsetCommits());
    assertFalse(addOffsetsResult.isCompleted());
    Map<TopicPartition,Errors> txnOffsetCommitResponse=new HashMap<>();
    txnOffsetCommitResponse.put(tp1,Errors.NONE);
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.GROUP,consumerGroupId);
    prepareTxnOffsetCommitResponse(consumerGroupId,pid,epoch,txnOffsetCommitResponse);
    assertEquals(null,transactionManager.coordinator(CoordinatorType.GROUP));
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertNotNull(transactionManager.coordinator(CoordinatorType.GROUP));
    assertTrue(transactionManager.hasPendingOffsetCommits());
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasPendingOffsetCommits());
    assertTrue(addOffsetsResult.isCompleted());
    transactionManager.beginCommit();
    prepareEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasOngoingTransaction());
    assertFalse(transactionManager.isCompleting());
    assertFalse(transactionManager.transactionContainsPartition(tp0));
  }
  @Test public void testDisconnectAndRetry(){
    transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.NONE,true,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
  }
  @Test public void testUnsupportedFindCoordinator(){
    transactionManager.initializeTransactions();
    client.prepareUnsupportedVersionResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        FindCoordinatorRequest findCoordinatorRequest=(FindCoordinatorRequest)body;
        assertEquals(findCoordinatorRequest.coordinatorType(),CoordinatorType.TRANSACTION);
        assertEquals(findCoordinatorRequest.coordinatorKey(),transactionalId);
        return true;
      }
    }
);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasFatalError());
    assertTrue(transactionManager.lastError() instanceof UnsupportedVersionException);
  }
  @Test public void testUnsupportedInitTransactions(){
    transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasError());
    assertNotNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));
    client.prepareUnsupportedVersionResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        InitProducerIdRequest initProducerIdRequest=(InitProducerIdRequest)body;
        assertEquals(initProducerIdRequest.transactionalId(),transactionalId);
        assertEquals(initProducerIdRequest.transactionTimeoutMs(),transactionTimeoutMs);
        return true;
      }
    }
);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasFatalError());
    assertTrue(transactionManager.lastError() instanceof UnsupportedVersionException);
  }
  @Test public void testUnsupportedForMessageFormatInTxnOffsetCommit(){
    final String consumerGroupId="consumer";
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition tp=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    TransactionalRequestResult sendOffsetsResult=transactionManager.sendOffsetsToTransaction(singletonMap(tp,new OffsetAndMetadata(39L)),consumerGroupId);
    prepareAddOffsetsToTxnResponse(Errors.NONE,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.GROUP,consumerGroupId);
    sender.run(time.milliseconds());
    prepareTxnOffsetCommitResponse(consumerGroupId,pid,epoch,singletonMap(tp,Errors.UNSUPPORTED_FOR_MESSAGE_FORMAT));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof UnsupportedForMessageFormatException);
    assertTrue(sendOffsetsResult.isCompleted());
    assertFalse(sendOffsetsResult.isSuccessful());
    assertTrue(sendOffsetsResult.error() instanceof UnsupportedForMessageFormatException);
    assertFatalError(UnsupportedForMessageFormatException.class);
  }
  @Test public void testLookupCoordinatorOnDisconnectAfterSend(){
    final long pid=13131L;
    final short epoch=1;
    TransactionalRequestResult initPidResult=transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    prepareInitPidResponse(Errors.NONE,true,pid,epoch);
    sender.run(time.milliseconds());
    assertEquals(null,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    assertFalse(initPidResult.isCompleted());
    assertFalse(transactionManager.hasProducerId());
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    assertFalse(initPidResult.isCompleted());
    prepareInitPidResponse(Errors.NONE,false,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(initPidResult.isCompleted());
    assertTrue(transactionManager.hasProducerId());
    assertEquals(pid,transactionManager.producerIdAndEpoch().producerId);
    assertEquals(epoch,transactionManager.producerIdAndEpoch().epoch);
  }
  @Test public void testLookupCoordinatorOnDisconnectBeforeSend(){
    final long pid=13131L;
    final short epoch=1;
    TransactionalRequestResult initPidResult=transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    client.disconnect(brokerNode.idString());
    client.blackout(brokerNode,100);
    sender.run(time.milliseconds());
    time.sleep(110);
    assertEquals(null,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    assertFalse(initPidResult.isCompleted());
    assertFalse(transactionManager.hasProducerId());
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    assertFalse(initPidResult.isCompleted());
    prepareInitPidResponse(Errors.NONE,false,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(initPidResult.isCompleted());
    assertTrue(transactionManager.hasProducerId());
    assertEquals(pid,transactionManager.producerIdAndEpoch().producerId);
    assertEquals(epoch,transactionManager.producerIdAndEpoch().epoch);
  }
  @Test public void testLookupCoordinatorOnNotCoordinatorError(){
    final long pid=13131L;
    final short epoch=1;
    TransactionalRequestResult initPidResult=transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    prepareInitPidResponse(Errors.NOT_COORDINATOR,false,pid,epoch);
    sender.run(time.milliseconds());
    assertEquals(null,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    assertFalse(initPidResult.isCompleted());
    assertFalse(transactionManager.hasProducerId());
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    assertFalse(initPidResult.isCompleted());
    prepareInitPidResponse(Errors.NONE,false,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(initPidResult.isCompleted());
    assertTrue(transactionManager.hasProducerId());
    assertEquals(pid,transactionManager.producerIdAndEpoch().producerId);
    assertEquals(epoch,transactionManager.producerIdAndEpoch().epoch);
  }
  @Test public void testTransactionalIdAuthorizationFailureInFindCoordinator(){
    TransactionalRequestResult initPidResult=transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof TransactionalIdAuthorizationException);
    sender.run(time.milliseconds());
    assertTrue(initPidResult.isCompleted());
    assertFalse(initPidResult.isSuccessful());
    assertTrue(initPidResult.error() instanceof TransactionalIdAuthorizationException);
    assertFatalError(TransactionalIdAuthorizationException.class);
  }
  @Test public void testTransactionalIdAuthorizationFailureInInitProducerId(){
    final long pid=13131L;
    TransactionalRequestResult initPidResult=transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    prepareInitPidResponse(Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED,false,pid,RecordBatch.NO_PRODUCER_EPOCH);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(initPidResult.isCompleted());
    assertFalse(initPidResult.isSuccessful());
    assertTrue(initPidResult.error() instanceof TransactionalIdAuthorizationException);
    assertFatalError(TransactionalIdAuthorizationException.class);
  }
  @Test public void testGroupAuthorizationFailureInFindCoordinator(){
    final String consumerGroupId="consumer";
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    TransactionalRequestResult sendOffsetsResult=transactionManager.sendOffsetsToTransaction(singletonMap(new TopicPartition("foo",0),new OffsetAndMetadata(39L)),consumerGroupId);
    prepareAddOffsetsToTxnResponse(Errors.NONE,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    prepareFindCoordinatorResponse(Errors.GROUP_AUTHORIZATION_FAILED,false,CoordinatorType.GROUP,consumerGroupId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof GroupAuthorizationException);
    assertTrue(sendOffsetsResult.isCompleted());
    assertFalse(sendOffsetsResult.isSuccessful());
    assertTrue(sendOffsetsResult.error() instanceof GroupAuthorizationException);
    GroupAuthorizationException exception=(GroupAuthorizationException)sendOffsetsResult.error();
    assertEquals(consumerGroupId,exception.groupId());
    assertAbortableError(GroupAuthorizationException.class);
  }
  @Test public void testGroupAuthorizationFailureInTxnOffsetCommit(){
    final String consumerGroupId="consumer";
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition tp1=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    TransactionalRequestResult sendOffsetsResult=transactionManager.sendOffsetsToTransaction(singletonMap(tp1,new OffsetAndMetadata(39L)),consumerGroupId);
    prepareAddOffsetsToTxnResponse(Errors.NONE,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.GROUP,consumerGroupId);
    sender.run(time.milliseconds());
    prepareTxnOffsetCommitResponse(consumerGroupId,pid,epoch,singletonMap(tp1,Errors.GROUP_AUTHORIZATION_FAILED));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof GroupAuthorizationException);
    assertTrue(sendOffsetsResult.isCompleted());
    assertFalse(sendOffsetsResult.isSuccessful());
    assertTrue(sendOffsetsResult.error() instanceof GroupAuthorizationException);
    assertFalse(transactionManager.hasPendingOffsetCommits());
    GroupAuthorizationException exception=(GroupAuthorizationException)sendOffsetsResult.error();
    assertEquals(consumerGroupId,exception.groupId());
    assertAbortableError(GroupAuthorizationException.class);
  }
  @Test public void testTransactionalIdAuthorizationFailureInAddOffsetsToTxn(){
    final String consumerGroupId="consumer";
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition tp=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    TransactionalRequestResult sendOffsetsResult=transactionManager.sendOffsetsToTransaction(singletonMap(tp,new OffsetAndMetadata(39L)),consumerGroupId);
    prepareAddOffsetsToTxnResponse(Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof TransactionalIdAuthorizationException);
    assertTrue(sendOffsetsResult.isCompleted());
    assertFalse(sendOffsetsResult.isSuccessful());
    assertTrue(sendOffsetsResult.error() instanceof TransactionalIdAuthorizationException);
    assertFatalError(TransactionalIdAuthorizationException.class);
  }
  @Test public void testTransactionalIdAuthorizationFailureInTxnOffsetCommit(){
    final String consumerGroupId="consumer";
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition tp=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    TransactionalRequestResult sendOffsetsResult=transactionManager.sendOffsetsToTransaction(singletonMap(tp,new OffsetAndMetadata(39L)),consumerGroupId);
    prepareAddOffsetsToTxnResponse(Errors.NONE,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.GROUP,consumerGroupId);
    sender.run(time.milliseconds());
    prepareTxnOffsetCommitResponse(consumerGroupId,pid,epoch,singletonMap(tp,Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof TransactionalIdAuthorizationException);
    assertTrue(sendOffsetsResult.isCompleted());
    assertFalse(sendOffsetsResult.isSuccessful());
    assertTrue(sendOffsetsResult.error() instanceof TransactionalIdAuthorizationException);
    assertFatalError(TransactionalIdAuthorizationException.class);
  }
  @Test public void testTopicAuthorizationFailureInAddPartitions(){
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition tp0=new TopicPartition("foo",0);
    final TopicPartition tp1=new TopicPartition("bar",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    transactionManager.maybeAddPartitionToTransaction(tp1);
    Map<TopicPartition,Errors> errors=new HashMap<>();
    errors.put(tp0,Errors.TOPIC_AUTHORIZATION_FAILED);
    errors.put(tp1,Errors.OPERATION_NOT_ATTEMPTED);
    prepareAddPartitionsToTxn(errors);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof TopicAuthorizationException);
    assertFalse(transactionManager.isPartitionPendingAdd(tp0));
    assertFalse(transactionManager.isPartitionPendingAdd(tp1));
    assertFalse(transactionManager.isPartitionAdded(tp0));
    assertFalse(transactionManager.isPartitionAdded(tp1));
    assertFalse(transactionManager.hasPartitionsToAdd());
    TopicAuthorizationException exception=(TopicAuthorizationException)transactionManager.lastError();
    assertEquals(singleton(tp0.topic()),exception.unauthorizedTopics());
    assertAbortableError(TopicAuthorizationException.class);
  }
  @Test public void testRecoveryFromAbortableErrorTransactionNotStarted() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition unauthorizedPartition=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);
    Future<RecordMetadata> responseFuture=accumulator.append(unauthorizedPartition,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition,Errors.TOPIC_AUTHORIZATION_FAILED));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasAbortableError());
    transactionManager.beginAbort();
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    assertFutureFailed(responseFuture);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isReady());
    assertFalse(transactionManager.hasPartitionsToAdd());
    assertFalse(accumulator.hasIncomplete());
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(singletonMap(tp0,Errors.NONE));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    assertFalse(transactionManager.hasPartitionsToAdd());
    transactionManager.beginCommit();
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    assertNotNull(responseFuture.get());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testRecoveryFromAbortableErrorTransactionStarted() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition unauthorizedPartition=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxn(tp0,Errors.NONE);
    Future<RecordMetadata> authorizedTopicProduceFuture=accumulator.append(unauthorizedPartition,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);
    Future<RecordMetadata> unauthorizedTopicProduceFuture=accumulator.append(unauthorizedPartition,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition,Errors.TOPIC_AUTHORIZATION_FAILED));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasAbortableError());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));
    assertFalse(authorizedTopicProduceFuture.isDone());
    assertFalse(unauthorizedTopicProduceFuture.isDone());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    transactionManager.beginAbort();
    sender.run(time.milliseconds());
    assertFutureFailed(authorizedTopicProduceFuture);
    assertFutureFailed(unauthorizedTopicProduceFuture);
    assertTrue(transactionManager.isReady());
    assertFalse(transactionManager.hasPartitionsToAdd());
    assertFalse(accumulator.hasIncomplete());
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    FutureRecordMetadata nextTransactionFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(singletonMap(tp0,Errors.NONE));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    assertFalse(transactionManager.hasPartitionsToAdd());
    transactionManager.beginCommit();
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(nextTransactionFuture.isDone());
    assertNotNull(nextTransactionFuture.get());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testRecoveryFromAbortableErrorProduceRequestInRetry() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition unauthorizedPartition=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxn(tp0,Errors.NONE);
    Future<RecordMetadata> authorizedTopicProduceFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    accumulator.beginFlush();
    prepareProduceResponse(Errors.REQUEST_TIMED_OUT,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(authorizedTopicProduceFuture.isDone());
    assertTrue(accumulator.hasIncomplete());
    transactionManager.maybeAddPartitionToTransaction(unauthorizedPartition);
    Future<RecordMetadata> unauthorizedTopicProduceFuture=accumulator.append(unauthorizedPartition,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(singletonMap(unauthorizedPartition,Errors.TOPIC_AUTHORIZATION_FAILED));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasAbortableError());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    assertFalse(transactionManager.isPartitionAdded(unauthorizedPartition));
    assertFalse(authorizedTopicProduceFuture.isDone());
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertFutureFailed(unauthorizedTopicProduceFuture);
    assertTrue(authorizedTopicProduceFuture.isDone());
    assertNotNull(authorizedTopicProduceFuture.get());
    assertTrue(authorizedTopicProduceFuture.isDone());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    transactionManager.beginAbort();
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isReady());
    assertFalse(transactionManager.hasPartitionsToAdd());
    assertFalse(accumulator.hasIncomplete());
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    FutureRecordMetadata nextTransactionFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(singletonMap(tp0,Errors.NONE));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isPartitionAdded(tp0));
    assertFalse(transactionManager.hasPartitionsToAdd());
    transactionManager.beginCommit();
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(nextTransactionFuture.isDone());
    assertNotNull(nextTransactionFuture.get());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testTransactionalIdAuthorizationFailureInAddPartitions(){
    final long pid=13131L;
    final short epoch=1;
    final TopicPartition tp=new TopicPartition("foo",0);
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp);
    prepareAddPartitionsToTxn(tp,Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertTrue(transactionManager.lastError() instanceof TransactionalIdAuthorizationException);
    assertFatalError(TransactionalIdAuthorizationException.class);
  }
  @Test public void testFlushPendingPartitionsOnCommit() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    TransactionalRequestResult commitResult=transactionManager.beginCommit();
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    assertFalse(responseFuture.isDone());
    assertFalse(commitResult.isCompleted());
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    prepareEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    assertFalse(commitResult.isCompleted());
    assertTrue(transactionManager.hasOngoingTransaction());
    assertTrue(transactionManager.isCompleting());
    sender.run(time.milliseconds());
    assertTrue(commitResult.isCompleted());
    assertFalse(transactionManager.hasOngoingTransaction());
  }
  @Test public void testMultipleAddPartitionsPerForOneProduce() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    transactionManager.maybeAddPartitionToTransaction(tp1);
    Future<RecordMetadata> secondResponseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp1,epoch,pid);
    prepareProduceResponse(Errors.NONE,pid,epoch);
    assertFalse(transactionManager.transactionContainsPartition(tp1));
    assertFalse(responseFuture.isDone());
    assertFalse(secondResponseFuture.isDone());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp1));
    assertFalse(responseFuture.isDone());
    assertFalse(secondResponseFuture.isDone());
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    assertTrue(secondResponseFuture.isDone());
  }
  @Test(expected=ExecutionException.class) public void testProducerFencedException() throws InterruptedException, ExecutionException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    prepareProduceResponse(Errors.INVALID_PRODUCER_EPOCH,pid,epoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    assertTrue(transactionManager.hasError());
    responseFuture.get();
  }
  @Test public void testDisallowCommitOnProduceFailure() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    TransactionalRequestResult commitResult=transactionManager.beginCommit();
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    prepareProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(commitResult.isCompleted());
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(commitResult.isCompleted());
    try {
      commitResult.await();
      fail();
    }
 catch (    KafkaException e) {
    }
    try {
      responseFuture.get();
      fail("Expected produce future to raise an exception");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof OutOfOrderSequenceException);
    }
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testAllowAbortOnProduceFailure() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    prepareProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER,pid,epoch);
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testAbortableErrorWhileAbortInProgress() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    assertTrue(transactionManager.isAborting());
    assertFalse(transactionManager.hasError());
    sendProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER,pid,epoch);
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isAborting());
    assertFalse(transactionManager.hasError());
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testCommitTransactionWithUnsentProduceRequest() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(tp0,Errors.NONE);
    sender.run(time.milliseconds());
    assertTrue(accumulator.hasUndrained());
    transactionManager.beginCommit();
    sender.run(time.milliseconds());
    assertFalse(accumulator.hasUndrained());
    assertTrue(accumulator.hasIncomplete());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    assertFalse(responseFuture.isDone());
    sender.run(time.milliseconds());
    assertFalse(accumulator.hasUndrained());
    assertTrue(accumulator.hasIncomplete());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    assertFalse(responseFuture.isDone());
    sendProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    assertFalse(accumulator.hasUndrained());
    assertFalse(accumulator.hasIncomplete());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasInFlightTransactionalRequest());
    sendEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testCommitTransactionWithInFlightProduceRequest() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxn(tp0,Errors.NONE);
    sender.run(time.milliseconds());
    assertTrue(accumulator.hasUndrained());
    accumulator.beginFlush();
    sender.run(time.milliseconds());
    assertFalse(accumulator.hasUndrained());
    assertTrue(accumulator.hasIncomplete());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    transactionManager.beginCommit();
    sender.run(time.milliseconds());
    assertFalse(accumulator.hasUndrained());
    assertTrue(accumulator.hasIncomplete());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    assertFalse(responseFuture.isDone());
    sender.run(time.milliseconds());
    assertFalse(accumulator.hasUndrained());
    assertTrue(accumulator.hasIncomplete());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    assertFalse(responseFuture.isDone());
    sendProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    assertFalse(accumulator.hasUndrained());
    assertFalse(accumulator.hasIncomplete());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasInFlightTransactionalRequest());
    sendEndTxnResponse(Errors.NONE,TransactionResult.COMMIT,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.hasInFlightTransactionalRequest());
    assertTrue(transactionManager.isReady());
  }
  @Test public void testFindCoordinatorAllowedInAbortableErrorState() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    sender.run(time.milliseconds());
    transactionManager.transitionToAbortableError(new KafkaException());
    sendAddPartitionsToTxnResponse(Errors.NOT_COORDINATOR,tp0,epoch,pid);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasAbortableError());
    assertNull(transactionManager.coordinator(CoordinatorType.TRANSACTION));
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    assertTrue(transactionManager.hasAbortableError());
  }
  @Test public void testCancelUnsentAddPartitionsAndProduceOnAbort() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
    assertTrue(transactionManager.isReady());
    try {
      responseFuture.get();
      fail("Expected produce future to raise an exception");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof KafkaException);
    }
  }
  @Test public void testAbortResendsAddPartitionErrorIfRetried() throws InterruptedException {
    final long producerId=13131L;
    final short producerEpoch=1;
    doInitTransactions(producerId,producerEpoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxnResponse(Errors.UNKNOWN_TOPIC_OR_PARTITION,tp0,producerEpoch,producerId);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    sender.run(time.milliseconds());
    assertFalse(responseFuture.isDone());
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,producerEpoch,producerId);
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,producerId,producerEpoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
    assertTrue(transactionManager.isReady());
    try {
      responseFuture.get();
      fail("Expected produce future to raise an exception");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof KafkaException);
    }
  }
  @Test public void testAbortResendsProduceRequestIfRetried() throws Exception {
    final long producerId=13131L;
    final short producerEpoch=1;
    doInitTransactions(producerId,producerEpoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,producerEpoch,producerId);
    prepareProduceResponse(Errors.REQUEST_TIMED_OUT,producerId,producerEpoch);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertFalse(responseFuture.isDone());
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    prepareProduceResponse(Errors.NONE,producerId,producerEpoch);
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,producerId,producerEpoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
    assertTrue(transactionManager.isReady());
    RecordMetadata recordMetadata=responseFuture.get();
    assertEquals(tp0.topic(),recordMetadata.topic());
  }
  @Test public void testHandlingOfUnknownTopicPartitionErrorOnAddPartitions() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.UNKNOWN_TOPIC_OR_PARTITION,tp0,epoch,pid);
    sender.run(time.milliseconds());
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
  }
  @Test public void testHandlingOfUnknownTopicPartitionErrorOnTxnOffsetCommit(){
    testRetriableErrorInTxnOffsetCommit(Errors.UNKNOWN_TOPIC_OR_PARTITION);
  }
  @Test public void testHandlingOfCoordinatorLoadingErrorOnTxnOffsetCommit(){
    testRetriableErrorInTxnOffsetCommit(Errors.COORDINATOR_LOAD_IN_PROGRESS);
  }
  private void testRetriableErrorInTxnOffsetCommit(  Errors error){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    Map<TopicPartition,OffsetAndMetadata> offsets=new HashMap<>();
    offsets.put(tp0,new OffsetAndMetadata(1));
    offsets.put(tp1,new OffsetAndMetadata(1));
    final String consumerGroupId="myconsumergroup";
    TransactionalRequestResult addOffsetsResult=transactionManager.sendOffsetsToTransaction(offsets,consumerGroupId);
    prepareAddOffsetsToTxnResponse(Errors.NONE,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(addOffsetsResult.isCompleted());
    Map<TopicPartition,Errors> txnOffsetCommitResponse=new HashMap<>();
    txnOffsetCommitResponse.put(tp0,Errors.NONE);
    txnOffsetCommitResponse.put(tp1,error);
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.GROUP,consumerGroupId);
    prepareTxnOffsetCommitResponse(consumerGroupId,pid,epoch,txnOffsetCommitResponse);
    assertNull(transactionManager.coordinator(CoordinatorType.GROUP));
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertNotNull(transactionManager.coordinator(CoordinatorType.GROUP));
    assertTrue(transactionManager.hasPendingOffsetCommits());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasPendingOffsetCommits());
    assertFalse(addOffsetsResult.isCompleted());
    txnOffsetCommitResponse.put(tp1,Errors.NONE);
    prepareTxnOffsetCommitResponse(consumerGroupId,pid,epoch,txnOffsetCommitResponse);
    sender.run(time.milliseconds());
    assertTrue(addOffsetsResult.isCompleted());
    assertTrue(addOffsetsResult.isSuccessful());
  }
  @Test public void shouldNotAddPartitionsToTransactionWhenTopicAuthorizationFailed() throws Exception {
    verifyAddPartitionsFailsWithPartitionLevelError(Errors.TOPIC_AUTHORIZATION_FAILED);
  }
  @Test public void shouldNotSendAbortTxnRequestWhenOnlyAddPartitionsRequestFailed(){
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxnResponse(Errors.TOPIC_AUTHORIZATION_FAILED,tp0,epoch,pid);
    sender.run(time.milliseconds());
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    assertFalse(abortResult.isCompleted());
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
  }
  @Test public void shouldNotSendAbortTxnRequestWhenOnlyAddOffsetsRequestFailed() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    Map<TopicPartition,OffsetAndMetadata> offsets=new HashMap<>();
    offsets.put(tp1,new OffsetAndMetadata(1));
    final String consumerGroupId="myconsumergroup";
    transactionManager.sendOffsetsToTransaction(offsets,consumerGroupId);
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    prepareAddOffsetsToTxnResponse(Errors.GROUP_AUTHORIZATION_FAILED,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(abortResult.isCompleted());
    sender.run(time.milliseconds());
    assertTrue(transactionManager.isReady());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
  }
  @Test public void shouldFailAbortIfAddOffsetsFailsWithFatalError() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    Map<TopicPartition,OffsetAndMetadata> offsets=new HashMap<>();
    offsets.put(tp1,new OffsetAndMetadata(1));
    final String consumerGroupId="myconsumergroup";
    transactionManager.sendOffsetsToTransaction(offsets,consumerGroupId);
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    prepareAddOffsetsToTxnResponse(Errors.UNKNOWN_SERVER_ERROR,consumerGroupId,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(abortResult.isCompleted());
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertFalse(abortResult.isSuccessful());
    assertTrue(transactionManager.hasFatalError());
  }
  @Test public void testNoDrainWhenPartitionsPending() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT);
    transactionManager.maybeAddPartitionToTransaction(tp1);
    accumulator.append(tp1,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT);
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    assertFalse(transactionManager.isSendToPartitionAllowed(tp1));
    Node node1=new Node(0,"localhost",1111);
    Node node2=new Node(1,"localhost",1112);
    PartitionInfo part1=new PartitionInfo(topic,0,node1,null,null);
    PartitionInfo part2=new PartitionInfo(topic,1,node2,null,null);
    Cluster cluster=new Cluster(null,Arrays.asList(node1,node2),Arrays.asList(part1,part2),Collections.<String>emptySet(),Collections.<String>emptySet());
    Set<Node> nodes=new HashSet<>();
    nodes.add(node1);
    nodes.add(node2);
    Map<Integer,List<ProducerBatch>> drainedBatches=accumulator.drain(cluster,nodes,Integer.MAX_VALUE,time.milliseconds());
    assertTrue(drainedBatches.containsKey(node1.id()));
    assertTrue(drainedBatches.get(node1.id()).isEmpty());
    assertTrue(drainedBatches.containsKey(node2.id()));
    assertTrue(drainedBatches.get(node2.id()).isEmpty());
    assertFalse(transactionManager.hasError());
  }
  @Test public void testAllowDrainInAbortableErrorState() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp1);
    prepareAddPartitionsToTxn(tp1,Errors.NONE);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp1));
    transactionManager.maybeAddPartitionToTransaction(tp0);
    prepareAddPartitionsToTxn(tp0,Errors.TOPIC_AUTHORIZATION_FAILED);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasAbortableError());
    assertTrue(transactionManager.isSendToPartitionAllowed(tp1));
    Node node1=new Node(1,"localhost",1112);
    PartitionInfo part1=new PartitionInfo(topic,1,node1,null,null);
    Cluster cluster=new Cluster(null,Arrays.asList(node1),Arrays.asList(part1),Collections.<String>emptySet(),Collections.<String>emptySet());
    accumulator.append(tp1,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT);
    Map<Integer,List<ProducerBatch>> drainedBatches=accumulator.drain(cluster,Collections.singleton(node1),Integer.MAX_VALUE,time.milliseconds());
    assertTrue(drainedBatches.containsKey(node1.id()));
    assertEquals(1,drainedBatches.get(node1.id()).size());
    assertTrue(transactionManager.hasAbortableError());
  }
  @Test public void testRaiseErrorWhenNoPartitionsPendingOnDrain() throws InterruptedException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT);
    Node node1=new Node(0,"localhost",1111);
    PartitionInfo part1=new PartitionInfo(topic,0,node1,null,null);
    Cluster cluster=new Cluster(null,Arrays.asList(node1),Arrays.asList(part1),Collections.<String>emptySet(),Collections.<String>emptySet());
    Set<Node> nodes=new HashSet<>();
    nodes.add(node1);
    Map<Integer,List<ProducerBatch>> drainedBatches=accumulator.drain(cluster,nodes,Integer.MAX_VALUE,time.milliseconds());
    assertTrue(drainedBatches.containsKey(node1.id()));
    assertTrue(drainedBatches.get(node1.id()).isEmpty());
  }
  @Test public void resendFailedProduceRequestAfterAbortableError() throws Exception {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    prepareProduceResponse(Errors.NOT_LEADER_FOR_PARTITION,pid,epoch);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertFalse(responseFuture.isDone());
    transactionManager.transitionToAbortableError(new KafkaException());
    prepareProduceResponse(Errors.NONE,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    assertNotNull(responseFuture.get());
  }
  @Test public void testTransitionToAbortableErrorOnBatchExpiry() throws InterruptedException, ExecutionException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    assertTrue(transactionManager.isSendToPartitionAllowed(tp0));
    assertFalse(responseFuture.isDone());
    time.sleep(10000);
    Node clusterNode=this.cluster.nodes().get(0);
    client.disconnect(clusterNode.idString());
    client.blackout(clusterNode,100);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    try {
      responseFuture.get();
      fail("Expected to get a TimeoutException since the queued ProducerBatch should have been expired");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof TimeoutException);
    }
    assertTrue(transactionManager.hasAbortableError());
  }
  @Test public void testTransitionToAbortableErrorOnMultipleBatchExpiry() throws InterruptedException, ExecutionException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    transactionManager.maybeAddPartitionToTransaction(tp1);
    Future<RecordMetadata> firstBatchResponse=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    Future<RecordMetadata> secondBatchResponse=accumulator.append(tp1,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(firstBatchResponse.isDone());
    assertFalse(secondBatchResponse.isDone());
    Map<TopicPartition,Errors> partitionErrors=new HashMap<>();
    partitionErrors.put(tp0,Errors.NONE);
    partitionErrors.put(tp1,Errors.NONE);
    prepareAddPartitionsToTxn(partitionErrors);
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    assertTrue(transactionManager.transactionContainsPartition(tp1));
    assertTrue(transactionManager.isSendToPartitionAllowed(tp1));
    assertTrue(transactionManager.isSendToPartitionAllowed(tp1));
    assertFalse(firstBatchResponse.isDone());
    assertFalse(secondBatchResponse.isDone());
    time.sleep(10000);
    Node clusterNode=this.cluster.nodes().get(0);
    client.disconnect(clusterNode.idString());
    client.blackout(clusterNode,100);
    sender.run(time.milliseconds());
    assertTrue(firstBatchResponse.isDone());
    assertTrue(secondBatchResponse.isDone());
    try {
      firstBatchResponse.get();
      fail("Expected to get a TimeoutException since the queued ProducerBatch should have been expired");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof TimeoutException);
    }
    try {
      secondBatchResponse.get();
      fail("Expected to get a TimeoutException since the queued ProducerBatch should have been expired");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof TimeoutException);
    }
    assertTrue(transactionManager.hasAbortableError());
  }
  @Test public void testDropCommitOnBatchExpiry() throws InterruptedException, ExecutionException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    assertTrue(transactionManager.isSendToPartitionAllowed(tp0));
    assertFalse(responseFuture.isDone());
    TransactionalRequestResult commitResult=transactionManager.beginCommit();
    time.sleep(10000);
    Node clusterNode=this.cluster.nodes().get(0);
    client.disconnect(clusterNode.idString());
    client.blackout(clusterNode,100);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    try {
      responseFuture.get();
      fail("Expected to get a TimeoutException since the queued ProducerBatch should have been expired");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof TimeoutException);
    }
    sender.run(time.milliseconds());
    assertTrue(commitResult.isCompleted());
    assertFalse(commitResult.isSuccessful());
    assertTrue(transactionManager.hasAbortableError());
    assertTrue(transactionManager.hasOngoingTransaction());
    assertFalse(transactionManager.isCompleting());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    TransactionalRequestResult abortResult=transactionManager.beginAbort();
    prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(abortResult.isCompleted());
    assertTrue(abortResult.isSuccessful());
    assertFalse(transactionManager.hasOngoingTransaction());
    assertFalse(transactionManager.transactionContainsPartition(tp0));
  }
  @Test public void testTransitionToFatalErrorWhenRetriedBatchIsExpired() throws InterruptedException, ExecutionException {
    final long pid=13131L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
    assertFalse(transactionManager.transactionContainsPartition(tp0));
    assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
    sender.run(time.milliseconds());
    assertTrue(transactionManager.transactionContainsPartition(tp0));
    assertTrue(transactionManager.isSendToPartitionAllowed(tp0));
    prepareProduceResponse(Errors.NOT_LEADER_FOR_PARTITION,pid,epoch);
    sender.run(time.milliseconds());
    assertFalse(responseFuture.isDone());
    TransactionalRequestResult commitResult=transactionManager.beginCommit();
    time.sleep(10000);
    Node clusterNode=this.cluster.nodes().get(0);
    client.disconnect(clusterNode.idString());
    client.blackout(clusterNode,100);
    sender.run(time.milliseconds());
    assertTrue(responseFuture.isDone());
    try {
      responseFuture.get();
      fail("Expected to get a TimeoutException since the queued ProducerBatch should have been expired");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof TimeoutException);
    }
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertTrue(commitResult.isCompleted());
    assertFalse(commitResult.isSuccessful());
    assertTrue(transactionManager.hasFatalError());
    assertFalse(transactionManager.hasOngoingTransaction());
  }
  @Test public void testShouldResetProducerStateAfterResolvingSequences() throws InterruptedException, ExecutionException {
    TransactionManager manager=new TransactionManager(logContext,null,transactionTimeoutMs,DEFAULT_RETRY_BACKOFF_MS);
    assertFalse(manager.shouldResetProducerStateAfterResolvingSequences());
    TopicPartition tp0=new TopicPartition("foo",0);
    TopicPartition tp1=new TopicPartition("foo",1);
    assertEquals(Integer.valueOf(0),manager.sequenceNumber(tp0));
    assertEquals(Integer.valueOf(0),manager.sequenceNumber(tp1));
    manager.incrementSequenceNumber(tp0,1);
    manager.incrementSequenceNumber(tp1,1);
    manager.maybeUpdateLastAckedSequence(tp0,0);
    manager.maybeUpdateLastAckedSequence(tp1,0);
    manager.markSequenceUnresolved(tp0);
    manager.markSequenceUnresolved(tp1);
    assertFalse(manager.shouldResetProducerStateAfterResolvingSequences());
    manager.maybeUpdateLastAckedSequence(tp0,5);
    manager.incrementSequenceNumber(tp0,1);
    manager.markSequenceUnresolved(tp0);
    manager.markSequenceUnresolved(tp1);
    assertTrue(manager.shouldResetProducerStateAfterResolvingSequences());
  }
  private void verifyAddPartitionsFailsWithPartitionLevelError(  final Errors error) throws InterruptedException {
    final long pid=1L;
    final short epoch=1;
    doInitTransactions(pid,epoch);
    transactionManager.beginTransaction();
    transactionManager.maybeAddPartitionToTransaction(tp0);
    Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
    assertFalse(responseFuture.isDone());
    prepareAddPartitionsToTxn(tp0,error);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasError());
    assertFalse(transactionManager.transactionContainsPartition(tp0));
  }
  private void prepareAddPartitionsToTxn(  final Map<TopicPartition,Errors> errors){
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        AddPartitionsToTxnRequest request=(AddPartitionsToTxnRequest)body;
        assertEquals(new HashSet<>(request.partitions()),new HashSet<>(errors.keySet()));
        return true;
      }
    }
,new AddPartitionsToTxnResponse(0,errors));
  }
  private void prepareAddPartitionsToTxn(  final TopicPartition tp,  final Errors error){
    prepareAddPartitionsToTxn(Collections.singletonMap(tp,error));
  }
  private void prepareFindCoordinatorResponse(  Errors error,  boolean shouldDisconnect,  final CoordinatorType coordinatorType,  final String coordinatorKey){
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        FindCoordinatorRequest findCoordinatorRequest=(FindCoordinatorRequest)body;
        assertEquals(findCoordinatorRequest.coordinatorType(),coordinatorType);
        assertEquals(findCoordinatorRequest.coordinatorKey(),coordinatorKey);
        return true;
      }
    }
,new FindCoordinatorResponse(error,brokerNode),shouldDisconnect);
  }
  private void prepareInitPidResponse(  Errors error,  boolean shouldDisconnect,  long pid,  short epoch){
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        InitProducerIdRequest initProducerIdRequest=(InitProducerIdRequest)body;
        assertEquals(initProducerIdRequest.transactionalId(),transactionalId);
        assertEquals(initProducerIdRequest.transactionTimeoutMs(),transactionTimeoutMs);
        return true;
      }
    }
,new InitProducerIdResponse(0,error,pid,epoch),shouldDisconnect);
  }
  private void sendProduceResponse(  Errors error,  final long pid,  final short epoch){
    client.respond(produceRequestMatcher(pid,epoch),produceResponse(tp0,0,error,0));
  }
  private void prepareProduceResponse(  Errors error,  final long pid,  final short epoch){
    client.prepareResponse(produceRequestMatcher(pid,epoch),produceResponse(tp0,0,error,0));
  }
  private MockClient.RequestMatcher produceRequestMatcher(  final long pid,  final short epoch){
    return new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        ProduceRequest produceRequest=(ProduceRequest)body;
        MemoryRecords records=produceRequest.partitionRecordsOrFail().get(tp0);
        assertNotNull(records);
        Iterator<MutableRecordBatch> batchIterator=records.batches().iterator();
        assertTrue(batchIterator.hasNext());
        MutableRecordBatch batch=batchIterator.next();
        assertFalse(batchIterator.hasNext());
        assertTrue(batch.isTransactional());
        assertEquals(pid,batch.producerId());
        assertEquals(epoch,batch.producerEpoch());
        assertEquals(transactionalId,produceRequest.transactionalId());
        return true;
      }
    }
;
  }
  private void prepareAddPartitionsToTxnResponse(  Errors error,  final TopicPartition topicPartition,  final short epoch,  final long pid){
    client.prepareResponse(addPartitionsRequestMatcher(topicPartition,epoch,pid),new AddPartitionsToTxnResponse(0,singletonMap(topicPartition,error)));
  }
  private void sendAddPartitionsToTxnResponse(  Errors error,  final TopicPartition topicPartition,  final short epoch,  final long pid){
    client.respond(addPartitionsRequestMatcher(topicPartition,epoch,pid),new AddPartitionsToTxnResponse(0,singletonMap(topicPartition,error)));
  }
  private MockClient.RequestMatcher addPartitionsRequestMatcher(  final TopicPartition topicPartition,  final short epoch,  final long pid){
    return new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        AddPartitionsToTxnRequest addPartitionsToTxnRequest=(AddPartitionsToTxnRequest)body;
        assertEquals(pid,addPartitionsToTxnRequest.producerId());
        assertEquals(epoch,addPartitionsToTxnRequest.producerEpoch());
        assertEquals(singletonList(topicPartition),addPartitionsToTxnRequest.partitions());
        assertEquals(transactionalId,addPartitionsToTxnRequest.transactionalId());
        return true;
      }
    }
;
  }
  private void prepareEndTxnResponse(  Errors error,  final TransactionResult result,  final long pid,  final short epoch){
    client.prepareResponse(endTxnMatcher(result,pid,epoch),new EndTxnResponse(0,error));
  }
  private void sendEndTxnResponse(  Errors error,  final TransactionResult result,  final long pid,  final short epoch){
    client.respond(endTxnMatcher(result,pid,epoch),new EndTxnResponse(0,error));
  }
  private MockClient.RequestMatcher endTxnMatcher(  final TransactionResult result,  final long pid,  final short epoch){
    return new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        EndTxnRequest endTxnRequest=(EndTxnRequest)body;
        assertEquals(transactionalId,endTxnRequest.transactionalId());
        assertEquals(pid,endTxnRequest.producerId());
        assertEquals(epoch,endTxnRequest.producerEpoch());
        assertEquals(result,endTxnRequest.command());
        return true;
      }
    }
;
  }
  private void prepareAddOffsetsToTxnResponse(  final Errors error,  final String consumerGroupId,  final long producerId,  final short producerEpoch){
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        AddOffsetsToTxnRequest addOffsetsToTxnRequest=(AddOffsetsToTxnRequest)body;
        assertEquals(consumerGroupId,addOffsetsToTxnRequest.consumerGroupId());
        assertEquals(transactionalId,addOffsetsToTxnRequest.transactionalId());
        assertEquals(producerId,addOffsetsToTxnRequest.producerId());
        assertEquals(producerEpoch,addOffsetsToTxnRequest.producerEpoch());
        return true;
      }
    }
,new AddOffsetsToTxnResponse(0,error));
  }
  private void prepareTxnOffsetCommitResponse(  final String consumerGroupId,  final long producerId,  final short producerEpoch,  Map<TopicPartition,Errors> txnOffsetCommitResponse){
    client.prepareResponse(request -> {
      TxnOffsetCommitRequest txnOffsetCommitRequest=(TxnOffsetCommitRequest)request;
      assertEquals(consumerGroupId,txnOffsetCommitRequest.consumerGroupId());
      assertEquals(producerId,txnOffsetCommitRequest.producerId());
      assertEquals(producerEpoch,txnOffsetCommitRequest.producerEpoch());
      return true;
    }
,new TxnOffsetCommitResponse(0,txnOffsetCommitResponse));
  }
  private ProduceResponse produceResponse(  TopicPartition tp,  long offset,  Errors error,  int throttleTimeMs){
    ProduceResponse.PartitionResponse resp=new ProduceResponse.PartitionResponse(error,offset,RecordBatch.NO_TIMESTAMP,10);
    Map<TopicPartition,ProduceResponse.PartitionResponse> partResp=singletonMap(tp,resp);
    return new ProduceResponse(partResp,throttleTimeMs);
  }
  private void doInitTransactions(  long pid,  short epoch){
    transactionManager.initializeTransactions();
    prepareFindCoordinatorResponse(Errors.NONE,false,CoordinatorType.TRANSACTION,transactionalId);
    sender.run(time.milliseconds());
    sender.run(time.milliseconds());
    assertEquals(brokerNode,transactionManager.coordinator(CoordinatorType.TRANSACTION));
    prepareInitPidResponse(Errors.NONE,false,pid,epoch);
    sender.run(time.milliseconds());
    assertTrue(transactionManager.hasProducerId());
  }
  private void assertAbortableError(  Class<? extends RuntimeException> cause){
    try {
      transactionManager.beginCommit();
      fail("Should have raised " + cause.getSimpleName());
    }
 catch (    KafkaException e) {
      assertTrue(cause.isAssignableFrom(e.getCause().getClass()));
      assertTrue(transactionManager.hasError());
    }
    assertTrue(transactionManager.hasError());
    transactionManager.beginAbort();
    assertFalse(transactionManager.hasError());
  }
  private void assertFatalError(  Class<? extends RuntimeException> cause){
    assertTrue(transactionManager.hasError());
    try {
      transactionManager.beginAbort();
      fail("Should have raised " + cause.getSimpleName());
    }
 catch (    KafkaException e) {
      assertTrue(cause.isAssignableFrom(e.getCause().getClass()));
      assertTrue(transactionManager.hasError());
    }
    try {
      transactionManager.beginAbort();
      fail("Should have raised " + cause.getSimpleName());
    }
 catch (    KafkaException e) {
      assertTrue(cause.isAssignableFrom(e.getCause().getClass()));
      assertTrue(transactionManager.hasError());
    }
  }
  private void assertFutureFailed(  Future<RecordMetadata> future) throws InterruptedException {
    assertTrue(future.isDone());
    try {
      future.get();
      fail("Expected produce future to throw");
    }
 catch (    ExecutionException e) {
    }
  }
}
