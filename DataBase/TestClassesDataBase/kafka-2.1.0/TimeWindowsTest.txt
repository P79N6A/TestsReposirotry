public class TimeWindowsTest {
  private static final long ANY_SIZE=123L;
  @Test public void shouldSetWindowSize(){
    assertEquals(ANY_SIZE,TimeWindows.of(ofMillis(ANY_SIZE)).sizeMs);
  }
  @Test public void shouldSetWindowAdvance(){
    final long anyAdvance=4;
    assertEquals(anyAdvance,TimeWindows.of(ofMillis(ANY_SIZE)).advanceBy(ofMillis(anyAdvance)).advanceMs);
  }
  @SuppressWarnings("deprecation") @Test public void shouldSetWindowRetentionTime(){
    assertEquals(ANY_SIZE,TimeWindows.of(ofMillis(ANY_SIZE)).until(ANY_SIZE).maintainMs());
  }
  @SuppressWarnings("deprecation") @Test public void shouldUseWindowSizeAsRentitionTimeIfWindowSizeIsLargerThanDefaultRetentionTime(){
    final long windowSize=2 * TimeWindows.of(ofMillis(1)).maintainMs();
    assertEquals(windowSize,TimeWindows.of(ofMillis(windowSize)).maintainMs());
  }
  @Test(expected=IllegalArgumentException.class) public void windowSizeMustNotBeZero(){
    TimeWindows.of(ofMillis(0));
  }
  @Test(expected=IllegalArgumentException.class) public void windowSizeMustNotBeNegative(){
    TimeWindows.of(ofMillis(-1));
  }
  @Test public void advanceIntervalMustNotBeZero(){
    final TimeWindows windowSpec=TimeWindows.of(ofMillis(ANY_SIZE));
    try {
      windowSpec.advanceBy(ofMillis(0));
      fail("should not accept zero advance parameter");
    }
 catch (    final IllegalArgumentException e) {
    }
  }
  @Test public void advanceIntervalMustNotBeNegative(){
    final TimeWindows windowSpec=TimeWindows.of(ofMillis(ANY_SIZE));
    try {
      windowSpec.advanceBy(ofMillis(-1));
      fail("should not accept negative advance parameter");
    }
 catch (    final IllegalArgumentException e) {
    }
  }
  @Deprecated @Test public void advanceIntervalMustNotBeLargerThanWindowSize(){
    final TimeWindows windowSpec=TimeWindows.of(ofMillis(ANY_SIZE));
    try {
      windowSpec.advanceBy(ofMillis(ANY_SIZE + 1));
      fail("should not accept advance greater than window size");
    }
 catch (    final IllegalArgumentException e) {
    }
  }
  @Deprecated @Test public void retentionTimeMustNoBeSmallerThanWindowSize(){
    final TimeWindows windowSpec=TimeWindows.of(ofMillis(ANY_SIZE));
    try {
      windowSpec.until(ANY_SIZE - 1);
      fail("should not accept retention time smaller than window size");
    }
 catch (    final IllegalArgumentException e) {
    }
  }
  @Test public void gracePeriodShouldEnforceBoundaries(){
    TimeWindows.of(ofMillis(3L)).grace(ofMillis(0L));
    try {
      TimeWindows.of(ofMillis(3L)).grace(ofMillis(-1L));
      fail("should not accept negatives");
    }
 catch (    final IllegalArgumentException e) {
    }
  }
  @Test public void shouldComputeWindowsForHoppingWindows(){
    final TimeWindows windows=TimeWindows.of(ofMillis(12L)).advanceBy(ofMillis(5L));
    final Map<Long,TimeWindow> matched=windows.windowsFor(21L);
    assertEquals(12L / 5L + 1,matched.size());
    assertEquals(new TimeWindow(10L,22L),matched.get(10L));
    assertEquals(new TimeWindow(15L,27L),matched.get(15L));
    assertEquals(new TimeWindow(20L,32L),matched.get(20L));
  }
  @Test public void shouldComputeWindowsForBarelyOverlappingHoppingWindows(){
    final TimeWindows windows=TimeWindows.of(ofMillis(6L)).advanceBy(ofMillis(5L));
    final Map<Long,TimeWindow> matched=windows.windowsFor(7L);
    assertEquals(1,matched.size());
    assertEquals(new TimeWindow(5L,11L),matched.get(5L));
  }
  @Test public void shouldComputeWindowsForTumblingWindows(){
    final TimeWindows windows=TimeWindows.of(ofMillis(12L));
    final Map<Long,TimeWindow> matched=windows.windowsFor(21L);
    assertEquals(1,matched.size());
    assertEquals(new TimeWindow(12L,24L),matched.get(12L));
  }
  @Test public void equalsAndHashcodeShouldBeValidForPositiveCases(){
    verifyEquality(TimeWindows.of(ofMillis(3)),TimeWindows.of(ofMillis(3)));
    verifyEquality(TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(1)),TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(1)));
    verifyEquality(TimeWindows.of(ofMillis(3)).grace(ofMillis(1)),TimeWindows.of(ofMillis(3)).grace(ofMillis(1)));
    verifyEquality(TimeWindows.of(ofMillis(3)).until(4),TimeWindows.of(ofMillis(3)).until(4));
    verifyEquality(TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(1)).grace(ofMillis(1)).until(4),TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(1)).grace(ofMillis(1)).until(4));
  }
  @Test public void equalsAndHashcodeShouldBeValidForNegativeCases(){
    verifyInEquality(TimeWindows.of(ofMillis(9)),TimeWindows.of(ofMillis(3)));
    verifyInEquality(TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(2)),TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(1)));
    verifyInEquality(TimeWindows.of(ofMillis(3)).grace(ofMillis(2)),TimeWindows.of(ofMillis(3)).grace(ofMillis(1)));
    verifyInEquality(TimeWindows.of(ofMillis(3)).until(9),TimeWindows.of(ofMillis(3)).until(4));
    verifyInEquality(TimeWindows.of(ofMillis(4)).advanceBy(ofMillis(2)).grace(ofMillis(2)).until(4),TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(2)).grace(ofMillis(2)).until(4));
    verifyInEquality(TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(1)).grace(ofMillis(2)).until(4),TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(2)).grace(ofMillis(2)).until(4));
    assertNotEquals(TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(2)).grace(ofMillis(1)).until(4),TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(2)).grace(ofMillis(2)).until(4));
    assertNotEquals(TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(2)).grace(ofMillis(2)).until(9),TimeWindows.of(ofMillis(3)).advanceBy(ofMillis(2)).grace(ofMillis(2)).until(4));
  }
}
