public class KTableKTableInnerJoinTest {
  private final String topic1="topic1";
  private final String topic2="topic2";
  private final Serde<Integer> intSerde=Serdes.Integer();
  private final Serde<String> stringSerde=Serdes.String();
  private final Consumed<Integer,String> consumed=Consumed.with(intSerde,stringSerde);
  private final Materialized<Integer,String,KeyValueStore<Bytes,byte[]>> materialized=Materialized.with(intSerde,stringSerde);
  private File stateDir=null;
  @Rule public final KStreamTestDriver driver=new KStreamTestDriver();
  @Before public void setUp(){
    stateDir=TestUtils.tempDirectory("kafka-test");
  }
  private void doTestJoin(  final StreamsBuilder builder,  final int[] expectedKeys,  final MockProcessorSupplier<Integer,String> supplier,  final KTable<Integer,String> joined){
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals(1,copartitionGroups.size());
    assertEquals(new HashSet<>(Arrays.asList(topic1,topic2)),copartitionGroups.iterator().next());
    final KTableValueGetterSupplier<Integer,String> getterSupplier=((KTableImpl<Integer,String,String>)joined).valueGetterSupplier();
    driver.setUp(builder,stateDir,Serdes.Integer(),Serdes.String());
    driver.setTime(0L);
    final MockProcessor<Integer,String> processor=supplier.theCapturedProcessor();
    final KTableValueGetter<Integer,String> getter=getterSupplier.get();
    getter.init(driver.context());
    for (int i=0; i < 2; i++) {
      driver.process(topic1,expectedKeys[i],"X" + expectedKeys[i]);
    }
    driver.process(topic1,null,"SomeVal");
    driver.flushState();
    processor.checkAndClearProcessResult();
    for (int i=0; i < 2; i++) {
      driver.process(topic2,expectedKeys[i],"Y" + expectedKeys[i]);
    }
    driver.process(topic2,null,"AnotherVal");
    driver.flushState();
    processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1");
    checkJoinedValues(getter,kv(0,"X0+Y0"),kv(1,"X1+Y1"));
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic1,expectedKey,"XX" + expectedKey);
    }
    driver.flushState();
    processor.checkAndClearProcessResult("0:XX0+Y0","1:XX1+Y1");
    checkJoinedValues(getter,kv(0,"XX0+Y0"),kv(1,"XX1+Y1"));
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic2,expectedKey,"YY" + expectedKey);
    }
    driver.flushState();
    processor.checkAndClearProcessResult("0:XX0+YY0","1:XX1+YY1","2:XX2+YY2","3:XX3+YY3");
    checkJoinedValues(getter,kv(0,"XX0+YY0"),kv(1,"XX1+YY1"),kv(2,"XX2+YY2"),kv(3,"XX3+YY3"));
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic1,expectedKey,"X" + expectedKey);
    }
    driver.flushState();
    processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
    checkJoinedValues(getter,kv(0,"X0+YY0"),kv(1,"X1+YY1"),kv(2,"X2+YY2"),kv(3,"X3+YY3"));
    for (int i=0; i < 2; i++) {
      driver.process(topic2,expectedKeys[i],null);
    }
    driver.flushState();
    processor.checkAndClearProcessResult("0:null","1:null");
    checkJoinedValues(getter,kv(0,null),kv(1,null));
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic1,expectedKey,"XX" + expectedKey);
    }
    driver.flushState();
    processor.checkAndClearProcessResult("2:XX2+YY2","3:XX3+YY3");
    checkJoinedValues(getter,kv(2,"XX2+YY2"),kv(3,"XX3+YY3"));
    driver.process(topic1,null,"XX" + 1);
    checkJoinedValues(getter,kv(2,"XX2+YY2"),kv(3,"XX3+YY3"));
  }
  @Test public void testJoin(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KTable<Integer,String> table1;
    final KTable<Integer,String> table2;
    final KTable<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    table1=builder.table(topic1,consumed);
    table2=builder.table(topic2,consumed);
    joined=table1.join(table2,MockValueJoiner.TOSTRING_JOINER);
    joined.toStream().process(supplier);
    doTestJoin(builder,expectedKeys,supplier,joined);
  }
  @Test public void testQueryableJoin(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KTable<Integer,String> table1;
    final KTable<Integer,String> table2;
    final KTable<Integer,String> table3;
    final MockProcessorSupplier<Integer,String> processor;
    processor=new MockProcessorSupplier<>();
    table1=builder.table(topic1,consumed);
    table2=builder.table(topic2,consumed);
    table3=table1.join(table2,MockValueJoiner.TOSTRING_JOINER,materialized);
    table3.toStream().process(processor);
    doTestJoin(builder,expectedKeys,processor,table3);
  }
  private void doTestSendingOldValues(  final StreamsBuilder builder,  final int[] expectedKeys,  final KTable<Integer,String> table1,  final KTable<Integer,String> table2,  final MockProcessorSupplier<Integer,String> supplier,  final KTable<Integer,String> joined,  final boolean sendOldValues){
    driver.setUp(builder,stateDir,Serdes.Integer(),Serdes.String());
    driver.setTime(0L);
    final MockProcessor<Integer,String> proc=supplier.theCapturedProcessor();
    if (!sendOldValues) {
      assertFalse(((KTableImpl<?,?,?>)table1).sendingOldValueEnabled());
      assertFalse(((KTableImpl<?,?,?>)table2).sendingOldValueEnabled());
      assertFalse(((KTableImpl<?,?,?>)joined).sendingOldValueEnabled());
    }
 else {
      ((KTableImpl<?,?,?>)joined).enableSendingOldValues();
      assertTrue(((KTableImpl<?,?,?>)table1).sendingOldValueEnabled());
      assertTrue(((KTableImpl<?,?,?>)table2).sendingOldValueEnabled());
      assertTrue(((KTableImpl<?,?,?>)joined).sendingOldValueEnabled());
    }
    for (int i=0; i < 2; i++) {
      driver.process(topic1,expectedKeys[i],"X" + expectedKeys[i]);
    }
    driver.flushState();
    proc.checkAndClearProcessResult();
    for (int i=0; i < 2; i++) {
      driver.process(topic2,expectedKeys[i],"Y" + expectedKeys[i]);
    }
    driver.flushState();
    proc.checkAndClearProcessResult("0:(X0+Y0<-null)","1:(X1+Y1<-null)");
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic1,expectedKey,"XX" + expectedKey);
    }
    driver.flushState();
    proc.checkAndClearProcessResult("0:(XX0+Y0<-null)","1:(XX1+Y1<-null)");
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic2,expectedKey,"YY" + expectedKey);
    }
    driver.flushState();
    proc.checkAndClearProcessResult("0:(XX0+YY0<-null)","1:(XX1+YY1<-null)","2:(XX2+YY2<-null)","3:(XX3+YY3<-null)");
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic1,expectedKey,"X" + expectedKey);
    }
    driver.flushState();
    proc.checkAndClearProcessResult("0:(X0+YY0<-null)","1:(X1+YY1<-null)","2:(X2+YY2<-null)","3:(X3+YY3<-null)");
    for (int i=0; i < 2; i++) {
      driver.process(topic2,expectedKeys[i],null);
    }
    driver.flushState();
    proc.checkAndClearProcessResult("0:(null<-null)","1:(null<-null)");
    for (    final int expectedKey : expectedKeys) {
      driver.process(topic1,expectedKey,"XX" + expectedKey);
    }
    driver.flushState();
    proc.checkAndClearProcessResult("2:(XX2+YY2<-null)","3:(XX3+YY3<-null)");
  }
  @Test public void testNotSendingOldValues(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KTable<Integer,String> table1;
    final KTable<Integer,String> table2;
    final KTable<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier;
    table1=builder.table(topic1,consumed);
    table2=builder.table(topic2,consumed);
    joined=table1.join(table2,MockValueJoiner.TOSTRING_JOINER);
    supplier=new MockProcessorSupplier<>();
    builder.build().addProcessor("proc",supplier,((KTableImpl<?,?,?>)joined).name);
    doTestSendingOldValues(builder,expectedKeys,table1,table2,supplier,joined,false);
  }
  @Test public void testQueryableNotSendingOldValues(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KTable<Integer,String> table1;
    final KTable<Integer,String> table2;
    final KTable<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier;
    table1=builder.table(topic1,consumed);
    table2=builder.table(topic2,consumed);
    joined=table1.join(table2,MockValueJoiner.TOSTRING_JOINER,materialized);
    supplier=new MockProcessorSupplier<>();
    builder.build().addProcessor("proc",supplier,((KTableImpl<?,?,?>)joined).name);
    doTestSendingOldValues(builder,expectedKeys,table1,table2,supplier,joined,false);
  }
  @Test public void testSendingOldValues(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KTable<Integer,String> table1;
    final KTable<Integer,String> table2;
    final KTable<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier;
    table1=builder.table(topic1,consumed);
    table2=builder.table(topic2,consumed);
    joined=table1.join(table2,MockValueJoiner.TOSTRING_JOINER);
    supplier=new MockProcessorSupplier<>();
    builder.build().addProcessor("proc",supplier,((KTableImpl<?,?,?>)joined).name);
    doTestSendingOldValues(builder,expectedKeys,table1,table2,supplier,joined,true);
  }
  @Test public void shouldLogAndMeterSkippedRecordsDueToNullLeftKey(){
    final StreamsBuilder builder=new StreamsBuilder();
    final Processor<String,Change<String>> join=new KTableKTableInnerJoin<>((KTableImpl<String,String,String>)builder.table("left",Consumed.with(stringSerde,stringSerde)),(KTableImpl<String,String,String>)builder.table("right",Consumed.with(stringSerde,stringSerde)),null).get();
    final MockProcessorContext context=new MockProcessorContext();
    context.setRecordMetadata("left",-1,-2,null,-3);
    join.init(context);
    final LogCaptureAppender appender=LogCaptureAppender.createAndRegister();
    join.process(null,new Change<>("new","old"));
    LogCaptureAppender.unregister(appender);
    assertEquals(1.0,getMetricByName(context.metrics().metrics(),"skipped-records-total","stream-metrics").metricValue());
    assertThat(appender.getMessages(),hasItem("Skipping record due to null key. change=[(new<-old)] topic=[left] partition=[-1] offset=[-2]"));
  }
  private KeyValue<Integer,String> kv(  final Integer key,  final String value){
    return new KeyValue<>(key,value);
  }
  @SafeVarargs private final void checkJoinedValues(  final KTableValueGetter<Integer,String> getter,  final KeyValue<Integer,String>... expected){
    for (    final KeyValue<Integer,String> kv : expected) {
      final String value=getter.get(kv.key);
      if (kv.value == null) {
        assertNull(value);
      }
 else {
        assertEquals(kv.value,value);
      }
    }
  }
}
