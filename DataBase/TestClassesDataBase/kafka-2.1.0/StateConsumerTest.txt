public class StateConsumerTest {
  private static final long FLUSH_INTERVAL=1000L;
  private final TopicPartition topicOne=new TopicPartition("topic-one",1);
  private final TopicPartition topicTwo=new TopicPartition("topic-two",1);
  private final MockTime time=new MockTime();
  private final MockConsumer<byte[],byte[]> consumer=new MockConsumer<>(OffsetResetStrategy.EARLIEST);
  private final Map<TopicPartition,Long> partitionOffsets=new HashMap<>();
  private final LogContext logContext=new LogContext("test ");
  private GlobalStreamThread.StateConsumer stateConsumer;
  private StateMaintainerStub stateMaintainer;
  @Before public void setUp(){
    partitionOffsets.put(topicOne,20L);
    partitionOffsets.put(topicTwo,30L);
    stateMaintainer=new StateMaintainerStub(partitionOffsets);
    stateConsumer=new GlobalStreamThread.StateConsumer(logContext,consumer,stateMaintainer,time,Duration.ofMillis(10L),FLUSH_INTERVAL);
  }
  @Test public void shouldAssignPartitionsToConsumer(){
    stateConsumer.initialize();
    assertEquals(Utils.mkSet(topicOne,topicTwo),consumer.assignment());
  }
  @Test public void shouldSeekToInitialOffsets(){
    stateConsumer.initialize();
    assertEquals(20L,consumer.position(topicOne));
    assertEquals(30L,consumer.position(topicTwo));
  }
  @Test public void shouldUpdateStateWithReceivedRecordsForPartition(){
    stateConsumer.initialize();
    consumer.addRecord(new ConsumerRecord<>("topic-one",1,20L,new byte[0],new byte[0]));
    consumer.addRecord(new ConsumerRecord<>("topic-one",1,21L,new byte[0],new byte[0]));
    stateConsumer.pollAndUpdate();
    assertEquals(2,stateMaintainer.updatedPartitions.get(topicOne).intValue());
  }
  @Test public void shouldUpdateStateWithReceivedRecordsForAllTopicPartition(){
    stateConsumer.initialize();
    consumer.addRecord(new ConsumerRecord<>("topic-one",1,20L,new byte[0],new byte[0]));
    consumer.addRecord(new ConsumerRecord<>("topic-two",1,31L,new byte[0],new byte[0]));
    consumer.addRecord(new ConsumerRecord<>("topic-two",1,32L,new byte[0],new byte[0]));
    stateConsumer.pollAndUpdate();
    assertEquals(1,stateMaintainer.updatedPartitions.get(topicOne).intValue());
    assertEquals(2,stateMaintainer.updatedPartitions.get(topicTwo).intValue());
  }
  @Test public void shouldFlushStoreWhenFlushIntervalHasLapsed(){
    stateConsumer.initialize();
    consumer.addRecord(new ConsumerRecord<>("topic-one",1,20L,new byte[0],new byte[0]));
    time.sleep(FLUSH_INTERVAL);
    stateConsumer.pollAndUpdate();
    assertTrue(stateMaintainer.flushed);
  }
  @Test public void shouldNotFlushOffsetsWhenFlushIntervalHasNotLapsed(){
    stateConsumer.initialize();
    consumer.addRecord(new ConsumerRecord<>("topic-one",1,20L,new byte[0],new byte[0]));
    time.sleep(FLUSH_INTERVAL / 2);
    stateConsumer.pollAndUpdate();
    assertFalse(stateMaintainer.flushed);
  }
  @Test public void shouldNotFlushWhenFlushIntervalIsZero(){
    stateConsumer=new GlobalStreamThread.StateConsumer(logContext,consumer,stateMaintainer,time,Duration.ofMillis(10L),-1);
    stateConsumer.initialize();
    time.sleep(100);
    stateConsumer.pollAndUpdate();
    assertFalse(stateMaintainer.flushed);
  }
  @Test public void shouldCloseConsumer() throws IOException {
    stateConsumer.close();
    assertTrue(consumer.closed());
  }
  @Test public void shouldCloseStateMaintainer() throws IOException {
    stateConsumer.close();
    assertTrue(stateMaintainer.closed);
  }
private static class StateMaintainerStub implements GlobalStateMaintainer {
    private final Map<TopicPartition,Long> partitionOffsets;
    private final Map<TopicPartition,Integer> updatedPartitions=new HashMap<>();
    private boolean flushed;
    private boolean closed;
    StateMaintainerStub(    final Map<TopicPartition,Long> partitionOffsets){
      this.partitionOffsets=partitionOffsets;
    }
    @Override public Map<TopicPartition,Long> initialize(){
      return partitionOffsets;
    }
    public void flushState(){
      flushed=true;
    }
    @Override public void close(){
      closed=true;
    }
    @Override public void update(    final ConsumerRecord<byte[],byte[]> record){
      final TopicPartition tp=new TopicPartition(record.topic(),record.partition());
      if (!updatedPartitions.containsKey(tp)) {
        updatedPartitions.put(tp,0);
      }
      updatedPartitions.put(tp,updatedPartitions.get(tp) + 1);
    }
  }
}
