@SuppressWarnings("unchecked") public class KafkaStatusBackingStoreTest extends EasyMockSupport {
  private static final String STATUS_TOPIC="status-topic";
  private static final String WORKER_ID="localhost:8083";
  private static final String CONNECTOR="conn";
  private static final ConnectorTaskId TASK=new ConnectorTaskId(CONNECTOR,0);
  @Test public void putConnectorState(){
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    byte[] value=new byte[0];
    expect(converter.fromConnectData(eq(STATUS_TOPIC),anyObject(Schema.class),anyObject(Struct.class))).andStubReturn(value);
    final Capture<Callback> callbackCapture=newCapture();
    kafkaBasedLog.send(eq("status-connector-conn"),eq(value),capture(callbackCapture));
    expectLastCall().andAnswer(new IAnswer<Void>(){
      @Override public Void answer() throws Throwable {
        callbackCapture.getValue().onCompletion(null,null);
        return null;
      }
    }
);
    replayAll();
    ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.RUNNING,WORKER_ID,0);
    store.put(status);
    assertEquals(null,store.get(CONNECTOR));
    verifyAll();
  }
  @Test public void putConnectorStateRetriableFailure(){
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    byte[] value=new byte[0];
    expect(converter.fromConnectData(eq(STATUS_TOPIC),anyObject(Schema.class),anyObject(Struct.class))).andStubReturn(value);
    final Capture<Callback> callbackCapture=newCapture();
    kafkaBasedLog.send(eq("status-connector-conn"),eq(value),capture(callbackCapture));
    expectLastCall().andAnswer(new IAnswer<Void>(){
      @Override public Void answer() throws Throwable {
        callbackCapture.getValue().onCompletion(null,new TimeoutException());
        return null;
      }
    }
).andAnswer(new IAnswer<Void>(){
      @Override public Void answer() throws Throwable {
        callbackCapture.getValue().onCompletion(null,null);
        return null;
      }
    }
);
    replayAll();
    ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.RUNNING,WORKER_ID,0);
    store.put(status);
    assertEquals(null,store.get(CONNECTOR));
    verifyAll();
  }
  @Test public void putConnectorStateNonRetriableFailure(){
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    byte[] value=new byte[0];
    expect(converter.fromConnectData(eq(STATUS_TOPIC),anyObject(Schema.class),anyObject(Struct.class))).andStubReturn(value);
    final Capture<Callback> callbackCapture=newCapture();
    kafkaBasedLog.send(eq("status-connector-conn"),eq(value),capture(callbackCapture));
    expectLastCall().andAnswer(new IAnswer<Void>(){
      @Override public Void answer() throws Throwable {
        callbackCapture.getValue().onCompletion(null,new UnknownServerException());
        return null;
      }
    }
);
    replayAll();
    ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.RUNNING,WORKER_ID,0);
    store.put(status);
    assertEquals(null,store.get(CONNECTOR));
    verifyAll();
  }
  @Test public void putSafeConnectorIgnoresStaleStatus(){
    byte[] value=new byte[0];
    String otherWorkerId="anotherhost:8083";
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    Map<String,Object> statusMap=new HashMap<>();
    statusMap.put("worker_id",otherWorkerId);
    statusMap.put("state","RUNNING");
    statusMap.put("generation",1L);
    expect(converter.toConnectData(STATUS_TOPIC,value)).andReturn(new SchemaAndValue(null,statusMap));
    replayAll();
    store.read(consumerRecord(0,"status-connector-conn",value));
    store.putSafe(new ConnectorStatus(CONNECTOR,ConnectorStatus.State.UNASSIGNED,WORKER_ID,0));
    ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.RUNNING,otherWorkerId,1);
    assertEquals(status,store.get(CONNECTOR));
    verifyAll();
  }
  @Test public void putSafeWithNoPreviousValueIsPropagated(){
    final Converter converter=mock(Converter.class);
    final KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    final KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    final byte[] value=new byte[0];
    final Capture<Struct> statusValueStruct=newCapture();
    converter.fromConnectData(eq(STATUS_TOPIC),anyObject(Schema.class),capture(statusValueStruct));
    EasyMock.expectLastCall().andReturn(value);
    kafkaBasedLog.send(eq("status-connector-" + CONNECTOR),eq(value),anyObject(Callback.class));
    expectLastCall();
    replayAll();
    final ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.FAILED,WORKER_ID,0);
    store.putSafe(status);
    verifyAll();
    assertEquals(status.state().toString(),statusValueStruct.getValue().get(KafkaStatusBackingStore.STATE_KEY_NAME));
    assertEquals(status.workerId(),statusValueStruct.getValue().get(KafkaStatusBackingStore.WORKER_ID_KEY_NAME));
    assertEquals(status.generation(),statusValueStruct.getValue().get(KafkaStatusBackingStore.GENERATION_KEY_NAME));
  }
  @Test public void putSafeOverridesValueSetBySameWorker(){
    final byte[] value=new byte[0];
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    final KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    Map<String,Object> firstStatusRead=new HashMap<>();
    firstStatusRead.put("worker_id",WORKER_ID);
    firstStatusRead.put("state","RUNNING");
    firstStatusRead.put("generation",1L);
    Map<String,Object> secondStatusRead=new HashMap<>();
    secondStatusRead.put("worker_id",WORKER_ID);
    secondStatusRead.put("state","UNASSIGNED");
    secondStatusRead.put("generation",0L);
    expect(converter.toConnectData(STATUS_TOPIC,value)).andReturn(new SchemaAndValue(null,firstStatusRead)).andReturn(new SchemaAndValue(null,secondStatusRead));
    expect(converter.fromConnectData(eq(STATUS_TOPIC),anyObject(Schema.class),anyObject(Struct.class))).andStubReturn(value);
    final Capture<Callback> callbackCapture=newCapture();
    kafkaBasedLog.send(eq("status-connector-conn"),eq(value),capture(callbackCapture));
    expectLastCall().andAnswer(new IAnswer<Void>(){
      @Override public Void answer() throws Throwable {
        callbackCapture.getValue().onCompletion(null,null);
        store.read(consumerRecord(1,"status-connector-conn",value));
        return null;
      }
    }
);
    replayAll();
    store.read(consumerRecord(0,"status-connector-conn",value));
    store.putSafe(new ConnectorStatus(CONNECTOR,ConnectorStatus.State.UNASSIGNED,WORKER_ID,0));
    ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.UNASSIGNED,WORKER_ID,0);
    assertEquals(status,store.get(CONNECTOR));
    verifyAll();
  }
  @Test public void putConnectorStateShouldOverride(){
    final byte[] value=new byte[0];
    String otherWorkerId="anotherhost:8083";
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    final KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    Map<String,Object> firstStatusRead=new HashMap<>();
    firstStatusRead.put("worker_id",otherWorkerId);
    firstStatusRead.put("state","RUNNING");
    firstStatusRead.put("generation",1L);
    Map<String,Object> secondStatusRead=new HashMap<>();
    secondStatusRead.put("worker_id",WORKER_ID);
    secondStatusRead.put("state","UNASSIGNED");
    secondStatusRead.put("generation",0L);
    expect(converter.toConnectData(STATUS_TOPIC,value)).andReturn(new SchemaAndValue(null,firstStatusRead)).andReturn(new SchemaAndValue(null,secondStatusRead));
    expect(converter.fromConnectData(eq(STATUS_TOPIC),anyObject(Schema.class),anyObject(Struct.class))).andStubReturn(value);
    final Capture<Callback> callbackCapture=newCapture();
    kafkaBasedLog.send(eq("status-connector-conn"),eq(value),capture(callbackCapture));
    expectLastCall().andAnswer(new IAnswer<Void>(){
      @Override public Void answer() throws Throwable {
        callbackCapture.getValue().onCompletion(null,null);
        store.read(consumerRecord(1,"status-connector-conn",value));
        return null;
      }
    }
);
    replayAll();
    store.read(consumerRecord(0,"status-connector-conn",value));
    ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.UNASSIGNED,WORKER_ID,0);
    store.put(status);
    assertEquals(status,store.get(CONNECTOR));
    verifyAll();
  }
  @Test public void readConnectorState(){
    byte[] value=new byte[0];
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    Map<String,Object> statusMap=new HashMap<>();
    statusMap.put("worker_id",WORKER_ID);
    statusMap.put("state","RUNNING");
    statusMap.put("generation",0L);
    expect(converter.toConnectData(STATUS_TOPIC,value)).andReturn(new SchemaAndValue(null,statusMap));
    replayAll();
    store.read(consumerRecord(0,"status-connector-conn",value));
    ConnectorStatus status=new ConnectorStatus(CONNECTOR,ConnectorStatus.State.RUNNING,WORKER_ID,0);
    assertEquals(status,store.get(CONNECTOR));
    verifyAll();
  }
  @Test public void putTaskState(){
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    byte[] value=new byte[0];
    expect(converter.fromConnectData(eq(STATUS_TOPIC),anyObject(Schema.class),anyObject(Struct.class))).andStubReturn(value);
    final Capture<Callback> callbackCapture=newCapture();
    kafkaBasedLog.send(eq("status-task-conn-0"),eq(value),capture(callbackCapture));
    expectLastCall().andAnswer(new IAnswer<Void>(){
      @Override public Void answer() throws Throwable {
        callbackCapture.getValue().onCompletion(null,null);
        return null;
      }
    }
);
    replayAll();
    TaskStatus status=new TaskStatus(TASK,TaskStatus.State.RUNNING,WORKER_ID,0);
    store.put(status);
    assertEquals(null,store.get(TASK));
    verifyAll();
  }
  @Test public void readTaskState(){
    byte[] value=new byte[0];
    KafkaBasedLog<String,byte[]> kafkaBasedLog=mock(KafkaBasedLog.class);
    Converter converter=mock(Converter.class);
    KafkaStatusBackingStore store=new KafkaStatusBackingStore(new MockTime(),converter,STATUS_TOPIC,kafkaBasedLog);
    Map<String,Object> statusMap=new HashMap<>();
    statusMap.put("worker_id",WORKER_ID);
    statusMap.put("state","RUNNING");
    statusMap.put("generation",0L);
    expect(converter.toConnectData(STATUS_TOPIC,value)).andReturn(new SchemaAndValue(null,statusMap));
    replayAll();
    store.read(consumerRecord(0,"status-task-conn-0",value));
    TaskStatus status=new TaskStatus(TASK,TaskStatus.State.RUNNING,WORKER_ID,0);
    assertEquals(status,store.get(TASK));
    verifyAll();
  }
  private static ConsumerRecord<String,byte[]> consumerRecord(  long offset,  String key,  byte[] value){
    return new ConsumerRecord<>(STATUS_TOPIC,0,offset,System.currentTimeMillis(),TimestampType.CREATE_TIME,0L,0,0,key,value);
  }
}
