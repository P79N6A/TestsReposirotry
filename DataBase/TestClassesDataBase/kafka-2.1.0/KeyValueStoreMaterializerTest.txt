@RunWith(EasyMockRunner.class) public class KeyValueStoreMaterializerTest {
  private final String storePrefix="prefix";
  @Mock(type=MockType.NICE) private InternalNameProvider nameProvider;
  @Test public void shouldCreateBuilderThatBuildsMeteredStoreWithCachingAndLoggingEnabled(){
    final MaterializedInternal<String,String,KeyValueStore<Bytes,byte[]>> materialized=new MaterializedInternal<>(Materialized.as("store"));
    materialized.generateStoreNameIfNeeded(nameProvider,storePrefix);
    final KeyValueStoreMaterializer<String,String> materializer=new KeyValueStoreMaterializer<>(materialized);
    final StoreBuilder<KeyValueStore<String,String>> builder=materializer.materialize();
    final KeyValueStore<String,String> store=builder.build();
    final WrappedStateStore caching=(WrappedStateStore)((WrappedStateStore)store).wrappedStore();
    final StateStore logging=caching.wrappedStore();
    assertThat(store,instanceOf(MeteredKeyValueStore.class));
    assertThat(caching,instanceOf(CachedStateStore.class));
    assertThat(logging,instanceOf(ChangeLoggingKeyValueBytesStore.class));
  }
  @Test public void shouldCreateBuilderThatBuildsStoreWithCachingDisabled(){
    final MaterializedInternal<String,String,KeyValueStore<Bytes,byte[]>> materialized=new MaterializedInternal<>(Materialized.<String,String,KeyValueStore<Bytes,byte[]>>as("store").withCachingDisabled());
    materialized.generateStoreNameIfNeeded(nameProvider,storePrefix);
    final KeyValueStoreMaterializer<String,String> materializer=new KeyValueStoreMaterializer<>(materialized);
    final StoreBuilder<KeyValueStore<String,String>> builder=materializer.materialize();
    final KeyValueStore<String,String> store=builder.build();
    final WrappedStateStore logging=(WrappedStateStore)((WrappedStateStore)store).wrappedStore();
    assertThat(logging,instanceOf(ChangeLoggingKeyValueBytesStore.class));
  }
  @Test public void shouldCreateBuilderThatBuildsStoreWithLoggingDisabled(){
    final MaterializedInternal<String,String,KeyValueStore<Bytes,byte[]>> materialized=new MaterializedInternal<>(Materialized.<String,String,KeyValueStore<Bytes,byte[]>>as("store").withLoggingDisabled());
    materialized.generateStoreNameIfNeeded(nameProvider,storePrefix);
    final KeyValueStoreMaterializer<String,String> materializer=new KeyValueStoreMaterializer<>(materialized);
    final StoreBuilder<KeyValueStore<String,String>> builder=materializer.materialize();
    final KeyValueStore<String,String> store=builder.build();
    final WrappedStateStore caching=(WrappedStateStore)((WrappedStateStore)store).wrappedStore();
    assertThat(caching,instanceOf(CachedStateStore.class));
    assertThat(caching.wrappedStore(),not(instanceOf(ChangeLoggingKeyValueBytesStore.class)));
  }
  @Test public void shouldCreateBuilderThatBuildsStoreWithCachingAndLoggingDisabled(){
    final MaterializedInternal<String,String,KeyValueStore<Bytes,byte[]>> materialized=new MaterializedInternal<>(Materialized.<String,String,KeyValueStore<Bytes,byte[]>>as("store").withCachingDisabled().withLoggingDisabled());
    materialized.generateStoreNameIfNeeded(nameProvider,storePrefix);
    final KeyValueStoreMaterializer<String,String> materializer=new KeyValueStoreMaterializer<>(materialized);
    final StoreBuilder<KeyValueStore<String,String>> builder=materializer.materialize();
    final KeyValueStore<String,String> store=builder.build();
    final StateStore wrapped=((WrappedStateStore)store).wrappedStore();
    assertThat(wrapped,not(instanceOf(CachedStateStore.class)));
    assertThat(wrapped,not(instanceOf(ChangeLoggingKeyValueBytesStore.class)));
  }
  @Test public void shouldCreateKeyValueStoreWithTheProvidedInnerStore(){
    final KeyValueBytesStoreSupplier supplier=EasyMock.createNiceMock(KeyValueBytesStoreSupplier.class);
    final InMemoryKeyValueStore<Bytes,byte[]> store=new InMemoryKeyValueStore<>("name",Serdes.Bytes(),Serdes.ByteArray());
    EasyMock.expect(supplier.name()).andReturn("name").anyTimes();
    EasyMock.expect(supplier.get()).andReturn(store);
    EasyMock.replay(supplier);
    final MaterializedInternal<String,Integer,KeyValueStore<Bytes,byte[]>> materialized=new MaterializedInternal<>(Materialized.as(supplier));
    materialized.generateStoreNameIfNeeded(nameProvider,storePrefix);
    final KeyValueStoreMaterializer<String,Integer> materializer=new KeyValueStoreMaterializer<>(materialized);
    final StoreBuilder<KeyValueStore<String,Integer>> builder=materializer.materialize();
    final KeyValueStore<String,Integer> built=builder.build();
    final StateStore inner=((WrappedStateStore)built).inner();
    assertThat(inner,CoreMatchers.<StateStore>equalTo(store));
  }
}
