public class SegmentsTest {
  private static final int NUM_SEGMENTS=5;
  private static final long SEGMENT_INTERVAL=100L;
  private static final long RETENTION_PERIOD=4 * SEGMENT_INTERVAL;
  private InternalMockProcessorContext context;
  private Segments segments;
  private File stateDirectory;
  private final String storeName="test";
  @Before public void createContext(){
    stateDirectory=TestUtils.tempDirectory();
    context=new InternalMockProcessorContext(stateDirectory,Serdes.String(),Serdes.Long(),new NoOpRecordCollector(),new ThreadCache(new LogContext("testCache "),0,new MockStreamsMetrics(new Metrics())));
    segments=new Segments(storeName,RETENTION_PERIOD,SEGMENT_INTERVAL);
  }
  @After public void close(){
    segments.close();
  }
  @Test public void shouldGetSegmentIdsFromTimestamp(){
    assertEquals(0,segments.segmentId(0));
    assertEquals(1,segments.segmentId(SEGMENT_INTERVAL));
    assertEquals(2,segments.segmentId(2 * SEGMENT_INTERVAL));
    assertEquals(3,segments.segmentId(3 * SEGMENT_INTERVAL));
  }
  @Test public void shouldBaseSegmentIntervalOnRetentionAndNumSegments(){
    final Segments segments=new Segments("test",8 * SEGMENT_INTERVAL,2 * SEGMENT_INTERVAL);
    assertEquals(0,segments.segmentId(0));
    assertEquals(0,segments.segmentId(SEGMENT_INTERVAL));
    assertEquals(1,segments.segmentId(2 * SEGMENT_INTERVAL));
  }
  @Test public void shouldGetSegmentNameFromId(){
    assertEquals("test.0",segments.segmentName(0));
    assertEquals("test." + SEGMENT_INTERVAL,segments.segmentName(1));
    assertEquals("test." + 2 * SEGMENT_INTERVAL,segments.segmentName(2));
  }
  @Test public void shouldCreateSegments(){
    final Segment segment1=segments.getOrCreateSegmentIfLive(0,context);
    final Segment segment2=segments.getOrCreateSegmentIfLive(1,context);
    final Segment segment3=segments.getOrCreateSegmentIfLive(2,context);
    assertTrue(new File(context.stateDir(),"test/test.0").isDirectory());
    assertTrue(new File(context.stateDir(),"test/test." + SEGMENT_INTERVAL).isDirectory());
    assertTrue(new File(context.stateDir(),"test/test." + 2 * SEGMENT_INTERVAL).isDirectory());
    assertTrue(segment1.isOpen());
    assertTrue(segment2.isOpen());
    assertTrue(segment3.isOpen());
  }
  @Test public void shouldNotCreateSegmentThatIsAlreadyExpired(){
    updateStreamTimeAndCreateSegment(7);
    assertNull(segments.getOrCreateSegmentIfLive(0,context));
    assertFalse(new File(context.stateDir(),"test/test.0").exists());
  }
  @Test public void shouldCleanupSegmentsThatHaveExpired(){
    final Segment segment1=segments.getOrCreateSegmentIfLive(0,context);
    final Segment segment2=segments.getOrCreateSegmentIfLive(1,context);
    context.setStreamTime(SEGMENT_INTERVAL * 7);
    final Segment segment3=segments.getOrCreateSegmentIfLive(7,context);
    assertFalse(segment1.isOpen());
    assertFalse(segment2.isOpen());
    assertTrue(segment3.isOpen());
    assertFalse(new File(context.stateDir(),"test/test.0").exists());
    assertFalse(new File(context.stateDir(),"test/test." + SEGMENT_INTERVAL).exists());
    assertTrue(new File(context.stateDir(),"test/test." + 7 * SEGMENT_INTERVAL).exists());
  }
  @Test public void shouldGetSegmentForTimestamp(){
    final Segment segment=segments.getOrCreateSegmentIfLive(0,context);
    segments.getOrCreateSegmentIfLive(1,context);
    assertEquals(segment,segments.getSegmentForTimestamp(0L));
  }
  @Test public void shouldGetCorrectSegmentString(){
    final Segment segment=segments.getOrCreateSegmentIfLive(0,context);
    assertEquals("Segment(id=0, name=test.0)",segment.toString());
  }
  @Test public void shouldCloseAllOpenSegments(){
    final Segment first=segments.getOrCreateSegmentIfLive(0,context);
    final Segment second=segments.getOrCreateSegmentIfLive(1,context);
    final Segment third=segments.getOrCreateSegmentIfLive(2,context);
    segments.close();
    assertFalse(first.isOpen());
    assertFalse(second.isOpen());
    assertFalse(third.isOpen());
  }
  @Test public void shouldOpenExistingSegments(){
    segments=new Segments("test",4,1);
    segments.getOrCreateSegmentIfLive(0,context);
    segments.getOrCreateSegmentIfLive(1,context);
    segments.getOrCreateSegmentIfLive(2,context);
    segments.getOrCreateSegmentIfLive(3,context);
    segments.getOrCreateSegmentIfLive(4,context);
    segments.close();
    segments=new Segments("test",4,1);
    segments.openExisting(context);
    assertTrue(segments.getSegmentForTimestamp(0).isOpen());
    assertTrue(segments.getSegmentForTimestamp(1).isOpen());
    assertTrue(segments.getSegmentForTimestamp(2).isOpen());
    assertTrue(segments.getSegmentForTimestamp(3).isOpen());
    assertTrue(segments.getSegmentForTimestamp(4).isOpen());
  }
  @Test public void shouldGetSegmentsWithinTimeRange(){
    updateStreamTimeAndCreateSegment(0);
    updateStreamTimeAndCreateSegment(1);
    updateStreamTimeAndCreateSegment(2);
    updateStreamTimeAndCreateSegment(3);
    updateStreamTimeAndCreateSegment(4);
    segments.getOrCreateSegmentIfLive(0,context);
    segments.getOrCreateSegmentIfLive(1,context);
    segments.getOrCreateSegmentIfLive(2,context);
    segments.getOrCreateSegmentIfLive(3,context);
    segments.getOrCreateSegmentIfLive(4,context);
    final List<Segment> segments=this.segments.segments(0,2 * SEGMENT_INTERVAL);
    assertEquals(3,segments.size());
    assertEquals(0,segments.get(0).id);
    assertEquals(1,segments.get(1).id);
    assertEquals(2,segments.get(2).id);
  }
  @Test public void shouldGetSegmentsWithinTimeRangeOutOfOrder(){
    updateStreamTimeAndCreateSegment(4);
    updateStreamTimeAndCreateSegment(2);
    updateStreamTimeAndCreateSegment(0);
    updateStreamTimeAndCreateSegment(1);
    updateStreamTimeAndCreateSegment(3);
    final List<Segment> segments=this.segments.segments(0,2 * SEGMENT_INTERVAL);
    assertEquals(3,segments.size());
    assertEquals(0,segments.get(0).id);
    assertEquals(1,segments.get(1).id);
    assertEquals(2,segments.get(2).id);
  }
  @Test public void shouldRollSegments(){
    updateStreamTimeAndCreateSegment(0);
    verifyCorrectSegments(0,1);
    updateStreamTimeAndCreateSegment(1);
    verifyCorrectSegments(0,2);
    updateStreamTimeAndCreateSegment(2);
    verifyCorrectSegments(0,3);
    updateStreamTimeAndCreateSegment(3);
    verifyCorrectSegments(0,4);
    updateStreamTimeAndCreateSegment(4);
    verifyCorrectSegments(0,5);
    updateStreamTimeAndCreateSegment(5);
    verifyCorrectSegments(1,5);
    updateStreamTimeAndCreateSegment(6);
    verifyCorrectSegments(2,5);
  }
  @Test public void futureEventsShouldNotCauseSegmentRoll(){
    updateStreamTimeAndCreateSegment(0);
    verifyCorrectSegments(0,1);
    updateStreamTimeAndCreateSegment(1);
    verifyCorrectSegments(0,2);
    updateStreamTimeAndCreateSegment(2);
    verifyCorrectSegments(0,3);
    updateStreamTimeAndCreateSegment(3);
    verifyCorrectSegments(0,4);
    updateStreamTimeAndCreateSegment(4);
    verifyCorrectSegments(0,5);
    segments.getOrCreateSegmentIfLive(5,context);
    verifyCorrectSegments(0,6);
    segments.getOrCreateSegmentIfLive(6,context);
    verifyCorrectSegments(0,7);
  }
  private void updateStreamTimeAndCreateSegment(  final int segment){
    context.setStreamTime(SEGMENT_INTERVAL * segment);
    segments.getOrCreateSegmentIfLive(segment,context);
  }
  @Test public void shouldUpdateSegmentFileNameFromOldDateFormatToNewFormat() throws Exception {
    final long segmentInterval=60_000L;
    segments=new Segments(storeName,NUM_SEGMENTS * segmentInterval,segmentInterval);
    final String storeDirectoryPath=stateDirectory.getAbsolutePath() + File.separator + storeName;
    final File storeDirectory=new File(storeDirectoryPath);
    storeDirectory.mkdirs();
    final SimpleDateFormat formatter=new SimpleDateFormat("yyyyMMddHHmm");
    formatter.setTimeZone(new SimpleTimeZone(0,"UTC"));
    for (int segmentId=0; segmentId < NUM_SEGMENTS; ++segmentId) {
      final File oldSegment=new File(storeDirectoryPath + File.separator + storeName+ "-"+ formatter.format(new Date(segmentId * segmentInterval)));
      oldSegment.createNewFile();
    }
    segments.openExisting(context);
    for (int segmentId=0; segmentId < NUM_SEGMENTS; ++segmentId) {
      final String segmentName=storeName + "." + (long)segmentId * segmentInterval;
      final File newSegment=new File(storeDirectoryPath + File.separator + segmentName);
      assertTrue(newSegment.exists());
    }
  }
  @Test public void shouldUpdateSegmentFileNameFromOldColonFormatToNewFormat() throws Exception {
    final String storeDirectoryPath=stateDirectory.getAbsolutePath() + File.separator + storeName;
    final File storeDirectory=new File(storeDirectoryPath);
    storeDirectory.mkdirs();
    for (int segmentId=0; segmentId < NUM_SEGMENTS; ++segmentId) {
      final File oldSegment=new File(storeDirectoryPath + File.separator + storeName+ ":"+ segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1)));
      oldSegment.createNewFile();
    }
    segments.openExisting(context);
    for (int segmentId=0; segmentId < NUM_SEGMENTS; ++segmentId) {
      final File newSegment=new File(storeDirectoryPath + File.separator + storeName+ "."+ segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1)));
      assertTrue(newSegment.exists());
    }
  }
  @Test public void shouldClearSegmentsOnClose(){
    segments.getOrCreateSegmentIfLive(0,context);
    segments.close();
    assertThat(segments.getSegmentForTimestamp(0),is(nullValue()));
  }
  private void verifyCorrectSegments(  final long first,  final int numSegments){
    final List<Segment> result=this.segments.segments(0,Long.MAX_VALUE);
    assertEquals(numSegments,result.size());
    for (int i=0; i < numSegments; i++) {
      assertEquals(i + first,result.get(i).id);
    }
  }
}
