public class KStreamTransformTest {
  private String topicName="topic";
  private final ConsumerRecordFactory<Integer,Integer> recordFactory=new ConsumerRecordFactory<>(new IntegerSerializer(),new IntegerSerializer());
  private final Properties props=StreamsTestUtils.getStreamsConfig(Serdes.Integer(),Serdes.Integer());
  @Rule public final KStreamTestDriver kstreamDriver=new KStreamTestDriver();
  @Test public void testTransform(){
    final StreamsBuilder builder=new StreamsBuilder();
    final TransformerSupplier<Number,Number,KeyValue<Integer,Integer>> transformerSupplier=new TransformerSupplier<Number,Number,KeyValue<Integer,Integer>>(){
      public Transformer<Number,Number,KeyValue<Integer,Integer>> get(){
        return new Transformer<Number,Number,KeyValue<Integer,Integer>>(){
          private int total=0;
          @Override public void init(          final ProcessorContext context){
          }
          @Override public KeyValue<Integer,Integer> transform(          final Number key,          final Number value){
            total+=value.intValue();
            return KeyValue.pair(key.intValue() * 2,total);
          }
          @Override public void close(){
          }
        }
;
      }
    }
;
    final int[] expectedKeys={1,10,100,1000};
    final MockProcessorSupplier<Integer,Integer> processor=new MockProcessorSupplier<>();
    final KStream<Integer,Integer> stream=builder.stream(topicName,Consumed.with(Serdes.Integer(),Serdes.Integer()));
    stream.transform(transformerSupplier).process(processor);
    kstreamDriver.setUp(builder);
    for (    final int expectedKey : expectedKeys) {
      kstreamDriver.process(topicName,expectedKey,expectedKey * 10);
    }
    final String[] expected={"2:10","20:110","200:1110","2000:11110"};
    for (int i=0; i < expected.length; i++) {
      assertEquals(expected[i],processor.theCapturedProcessor().processed.get(i));
    }
  }
  @Test public void testTransformWithNewDriverAndPunctuator(){
    final StreamsBuilder builder=new StreamsBuilder();
    final TransformerSupplier<Number,Number,KeyValue<Integer,Integer>> transformerSupplier=new TransformerSupplier<Number,Number,KeyValue<Integer,Integer>>(){
      public Transformer<Number,Number,KeyValue<Integer,Integer>> get(){
        return new Transformer<Number,Number,KeyValue<Integer,Integer>>(){
          private int total=0;
          @Override public void init(          final ProcessorContext context){
            context.schedule(Duration.ofMillis(1),PunctuationType.WALL_CLOCK_TIME,new Punctuator(){
              @Override public void punctuate(              final long timestamp){
                context.forward(-1,(int)timestamp);
              }
            }
);
          }
          @Override public KeyValue<Integer,Integer> transform(          final Number key,          final Number value){
            total+=value.intValue();
            return KeyValue.pair(key.intValue() * 2,total);
          }
          @Override public void close(){
          }
        }
;
      }
    }
;
    final int[] expectedKeys={1,10,100,1000};
    final MockProcessorSupplier<Integer,Integer> processor=new MockProcessorSupplier<>();
    final KStream<Integer,Integer> stream=builder.stream(topicName,Consumed.with(Serdes.Integer(),Serdes.Integer()));
    stream.transform(transformerSupplier).process(processor);
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props,0L)){
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topicName,expectedKey,expectedKey * 10,0L));
      }
      driver.advanceWallClockTime(2);
      driver.advanceWallClockTime(1);
    }
     assertEquals(6,processor.theCapturedProcessor().processed.size());
    final String[] expected={"2:10","20:110","200:1110","2000:11110","-1:2","-1:3"};
    for (int i=0; i < expected.length; i++) {
      assertEquals(expected[i],processor.theCapturedProcessor().processed.get(i));
    }
  }
}
