public class MergedSortedCacheWrappedSessionStoreIteratorTest {
  private static final SegmentedCacheFunction SINGLE_SEGMENT_CACHE_FUNCTION=new SegmentedCacheFunction(null,-1){
    @Override public long segmentId(    final Bytes key){
      return 0;
    }
  }
;
  private final Bytes storeKey=Bytes.wrap("a".getBytes());
  private final Bytes cacheKey=Bytes.wrap("b".getBytes());
  private final SessionWindow storeWindow=new SessionWindow(0,1);
  private final Iterator<KeyValue<Windowed<Bytes>,byte[]>> storeKvs=Collections.singleton(KeyValue.pair(new Windowed<>(storeKey,storeWindow),storeKey.get())).iterator();
  private final SessionWindow cacheWindow=new SessionWindow(10,20);
  private final Iterator<KeyValue<Bytes,LRUCacheEntry>> cacheKvs=Collections.singleton(KeyValue.pair(SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(Bytes.wrap(SessionKeySchema.toBinary(new Windowed<>(cacheKey,cacheWindow)))),new LRUCacheEntry(cacheKey.get()))).iterator();
  @Test public void shouldHaveNextFromStore(){
    final MergedSortedCacheSessionStoreIterator mergeIterator=createIterator(storeKvs,Collections.<KeyValue<Bytes,LRUCacheEntry>>emptyIterator());
    assertTrue(mergeIterator.hasNext());
  }
  @Test public void shouldGetNextFromStore(){
    final MergedSortedCacheSessionStoreIterator mergeIterator=createIterator(storeKvs,Collections.<KeyValue<Bytes,LRUCacheEntry>>emptyIterator());
    assertThat(mergeIterator.next(),equalTo(KeyValue.pair(new Windowed<>(storeKey,storeWindow),storeKey.get())));
  }
  @Test public void shouldPeekNextKeyFromStore(){
    final MergedSortedCacheSessionStoreIterator mergeIterator=createIterator(storeKvs,Collections.<KeyValue<Bytes,LRUCacheEntry>>emptyIterator());
    assertThat(mergeIterator.peekNextKey(),equalTo(new Windowed<>(storeKey,storeWindow)));
  }
  @Test public void shouldHaveNextFromCache(){
    final MergedSortedCacheSessionStoreIterator mergeIterator=createIterator(Collections.<KeyValue<Windowed<Bytes>,byte[]>>emptyIterator(),cacheKvs);
    assertTrue(mergeIterator.hasNext());
  }
  @Test public void shouldGetNextFromCache(){
    final MergedSortedCacheSessionStoreIterator mergeIterator=createIterator(Collections.<KeyValue<Windowed<Bytes>,byte[]>>emptyIterator(),cacheKvs);
    assertThat(mergeIterator.next(),equalTo(KeyValue.pair(new Windowed<>(cacheKey,cacheWindow),cacheKey.get())));
  }
  @Test public void shouldPeekNextKeyFromCache(){
    final MergedSortedCacheSessionStoreIterator mergeIterator=createIterator(Collections.<KeyValue<Windowed<Bytes>,byte[]>>emptyIterator(),cacheKvs);
    assertThat(mergeIterator.peekNextKey(),equalTo(new Windowed<>(cacheKey,cacheWindow)));
  }
  @Test public void shouldIterateBothStoreAndCache(){
    final MergedSortedCacheSessionStoreIterator iterator=createIterator(storeKvs,cacheKvs);
    assertThat(iterator.next(),equalTo(KeyValue.pair(new Windowed<>(storeKey,storeWindow),storeKey.get())));
    assertThat(iterator.next(),equalTo(KeyValue.pair(new Windowed<>(cacheKey,cacheWindow),cacheKey.get())));
    assertFalse(iterator.hasNext());
  }
  private MergedSortedCacheSessionStoreIterator createIterator(  final Iterator<KeyValue<Windowed<Bytes>,byte[]>> storeKvs,  final Iterator<KeyValue<Bytes,LRUCacheEntry>> cacheKvs){
    final DelegatingPeekingKeyValueIterator<Windowed<Bytes>,byte[]> storeIterator=new DelegatingPeekingKeyValueIterator<>("store",new KeyValueIteratorStub<>(storeKvs));
    final PeekingKeyValueIterator<Bytes,LRUCacheEntry> cacheIterator=new DelegatingPeekingKeyValueIterator<>("cache",new KeyValueIteratorStub<>(cacheKvs));
    return new MergedSortedCacheSessionStoreIterator(cacheIterator,storeIterator,SINGLE_SEGMENT_CACHE_FUNCTION);
  }
}
