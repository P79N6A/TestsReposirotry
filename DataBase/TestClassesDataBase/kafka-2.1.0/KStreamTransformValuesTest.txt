@RunWith(EasyMockRunner.class) public class KStreamTransformValuesTest {
  private String topicName="topic";
  private final MockProcessorSupplier<Integer,Integer> supplier=new MockProcessorSupplier<>();
  private final ConsumerRecordFactory<Integer,Integer> recordFactory=new ConsumerRecordFactory<>(new IntegerSerializer(),new IntegerSerializer());
  private final Properties props=StreamsTestUtils.getStreamsConfig(Serdes.Integer(),Serdes.Integer());
  @Mock(MockType.NICE) private ProcessorContext context;
  @Test public void testTransform(){
    final StreamsBuilder builder=new StreamsBuilder();
    final ValueTransformerSupplier<Number,Integer> valueTransformerSupplier=new ValueTransformerSupplier<Number,Integer>(){
      public ValueTransformer<Number,Integer> get(){
        return new ValueTransformer<Number,Integer>(){
          private int total=0;
          @Override public void init(          final ProcessorContext context){
          }
          @Override public Integer transform(          final Number value){
            total+=value.intValue();
            return total;
          }
          @Override public void close(){
          }
        }
;
      }
    }
;
    final int[] expectedKeys={1,10,100,1000};
    final KStream<Integer,Integer> stream;
    stream=builder.stream(topicName,Consumed.with(Serdes.Integer(),Serdes.Integer()));
    stream.transformValues(valueTransformerSupplier).process(supplier);
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props,0L)){
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topicName,expectedKey,expectedKey * 10,0L));
      }
    }
     final String[] expected={"1:10","10:110","100:1110","1000:11110"};
    assertArrayEquals(expected,supplier.theCapturedProcessor().processed.toArray());
  }
  @Test public void testTransformWithKey(){
    final StreamsBuilder builder=new StreamsBuilder();
    final ValueTransformerWithKeySupplier<Integer,Number,Integer> valueTransformerSupplier=new ValueTransformerWithKeySupplier<Integer,Number,Integer>(){
      public ValueTransformerWithKey<Integer,Number,Integer> get(){
        return new ValueTransformerWithKey<Integer,Number,Integer>(){
          private int total=0;
          @Override public void init(          final ProcessorContext context){
          }
          @Override public Integer transform(          final Integer readOnlyKey,          final Number value){
            total+=value.intValue() + readOnlyKey;
            return total;
          }
          @Override public void close(){
          }
        }
;
      }
    }
;
    final int[] expectedKeys={1,10,100,1000};
    final KStream<Integer,Integer> stream;
    stream=builder.stream(topicName,Consumed.with(Serdes.Integer(),Serdes.Integer()));
    stream.transformValues(valueTransformerSupplier).process(supplier);
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props,0L)){
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topicName,expectedKey,expectedKey * 10,0L));
      }
    }
     final String[] expected={"1:11","10:121","100:1221","1000:12221"};
    assertArrayEquals(expected,supplier.theCapturedProcessor().processed.toArray());
  }
  @Test public void shouldInitializeTransformerWithForwardDisabledProcessorContext(){
    final SingletonNoOpValueTransformer<String,String> transformer=new SingletonNoOpValueTransformer<>();
    final KStreamTransformValues<String,String,String> transformValues=new KStreamTransformValues<>(transformer);
    final Processor<String,String> processor=transformValues.get();
    processor.init(context);
    assertThat(transformer.context,isA((Class)ForwardingDisabledProcessorContext.class));
  }
}
