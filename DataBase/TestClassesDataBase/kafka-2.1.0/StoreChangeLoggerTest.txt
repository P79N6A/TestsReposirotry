public class StoreChangeLoggerTest {
  private final String topic="topic";
  private final Map<Integer,String> logged=new HashMap<>();
  private final Map<Integer,Headers> loggedHeaders=new HashMap<>();
  private final InternalMockProcessorContext context=new InternalMockProcessorContext(StateSerdes.withBuiltinTypes(topic,Integer.class,String.class),new RecordCollectorImpl("StoreChangeLoggerTest",new LogContext("StoreChangeLoggerTest "),new DefaultProductionExceptionHandler(),new Metrics().sensor("skipped-records")){
    @Override public <K1,V1>void send(    final String topic,    final K1 key,    final V1 value,    final Headers headers,    final Integer partition,    final Long timestamp,    final Serializer<K1> keySerializer,    final Serializer<V1> valueSerializer){
      logged.put((Integer)key,(String)value);
      loggedHeaders.put((Integer)key,headers);
    }
    @Override public <K1,V1>void send(    final String topic,    final K1 key,    final V1 value,    final Headers headers,    final Long timestamp,    final Serializer<K1> keySerializer,    final Serializer<V1> valueSerializer,    final StreamPartitioner<? super K1,? super V1> partitioner){
      throw new UnsupportedOperationException();
    }
  }
);
  private final StoreChangeLogger<Integer,String> changeLogger=new StoreChangeLogger<>(topic,context,StateSerdes.withBuiltinTypes(topic,Integer.class,String.class));
  @Test public void testAddRemove(){
    context.setTime(1);
    changeLogger.logChange(0,"zero");
    changeLogger.logChange(1,"one");
    changeLogger.logChange(2,"two");
    assertEquals("zero",logged.get(0));
    assertEquals("one",logged.get(1));
    assertEquals("two",logged.get(2));
    changeLogger.logChange(0,null);
    assertNull(logged.get(0));
  }
  @Test public void shouldNotSendRecordHeadersToChangelogTopic(){
    context.headers().add(new RecordHeader("key","value".getBytes()));
    changeLogger.logChange(0,"zero");
    assertNull(loggedHeaders.get(0));
  }
}
