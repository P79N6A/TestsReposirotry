public class ConsumerCoordinatorTest {
  private final String topic1="test1";
  private final String topic2="test2";
  private final TopicPartition t1p=new TopicPartition(topic1,0);
  private final TopicPartition t2p=new TopicPartition(topic2,0);
  private final String groupId="test-group";
  private final int rebalanceTimeoutMs=60000;
  private final int sessionTimeoutMs=10000;
  private final int heartbeatIntervalMs=5000;
  private final long retryBackoffMs=100;
  private final int autoCommitIntervalMs=2000;
  private final int requestTimeoutMs=30000;
  private final MockTime time=new MockTime();
  private final Heartbeat heartbeat=new Heartbeat(time,sessionTimeoutMs,heartbeatIntervalMs,rebalanceTimeoutMs,retryBackoffMs);
  private MockPartitionAssignor partitionAssignor=new MockPartitionAssignor();
  private List<PartitionAssignor> assignors=Collections.singletonList(partitionAssignor);
  private MockClient client;
  private Cluster cluster=TestUtils.clusterWith(1,new HashMap<String,Integer>(){
{
      put(topic1,1);
      put(topic2,1);
    }
  }
);
  private Node node=cluster.nodes().get(0);
  private SubscriptionState subscriptions;
  private Metadata metadata;
  private Metrics metrics;
  private ConsumerNetworkClient consumerClient;
  private MockRebalanceListener rebalanceListener;
  private MockCommitCallback mockOffsetCommitCallback;
  private ConsumerCoordinator coordinator;
  @Before public void setup(){
    this.subscriptions=new SubscriptionState(OffsetResetStrategy.EARLIEST);
    this.metadata=new Metadata(0,Long.MAX_VALUE,true);
    this.metadata.update(cluster,Collections.<String>emptySet(),time.milliseconds());
    this.client=new MockClient(time,metadata);
    this.consumerClient=new ConsumerNetworkClient(new LogContext(),client,metadata,time,100,requestTimeoutMs,Integer.MAX_VALUE);
    this.metrics=new Metrics(time);
    this.rebalanceListener=new MockRebalanceListener();
    this.mockOffsetCommitCallback=new MockCommitCallback();
    this.partitionAssignor.clear();
    client.setNode(node);
    this.coordinator=buildCoordinator(metrics,assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,false,true);
  }
  @After public void teardown(){
    this.metrics.close();
    this.coordinator.close(time.timer(0));
  }
  @Test public void testNormalHeartbeat(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    time.sleep(sessionTimeoutMs);
    RequestFuture<Void> future=coordinator.sendHeartbeatRequest();
    assertEquals(1,consumerClient.pendingRequestCount());
    assertFalse(future.isDone());
    client.prepareResponse(heartbeatResponse(Errors.NONE));
    consumerClient.poll(time.timer(0));
    assertTrue(future.isDone());
    assertTrue(future.succeeded());
  }
  @Test(expected=GroupAuthorizationException.class) public void testGroupDescribeUnauthorized(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.GROUP_AUTHORIZATION_FAILED));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
  }
  @Test(expected=GroupAuthorizationException.class) public void testGroupReadUnauthorized(){
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupLeaderResponse(0,"memberId",Collections.<String,List<String>>emptyMap(),Errors.GROUP_AUTHORIZATION_FAILED));
    coordinator.poll(time.timer(Long.MAX_VALUE));
  }
  @Test public void testCoordinatorNotAvailable(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    time.sleep(sessionTimeoutMs);
    RequestFuture<Void> future=coordinator.sendHeartbeatRequest();
    assertEquals(1,consumerClient.pendingRequestCount());
    assertFalse(future.isDone());
    client.prepareResponse(heartbeatResponse(Errors.COORDINATOR_NOT_AVAILABLE));
    time.sleep(sessionTimeoutMs);
    consumerClient.poll(time.timer(0));
    assertTrue(future.isDone());
    assertTrue(future.failed());
    assertEquals(Errors.COORDINATOR_NOT_AVAILABLE.exception(),future.exception());
    assertTrue(coordinator.coordinatorUnknown());
  }
  @Test public void testManyInFlightAsyncCommitsWithCoordinatorDisconnect() throws Exception {
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    int numRequests=1000;
    TopicPartition tp=new TopicPartition("foo",0);
    final AtomicInteger responses=new AtomicInteger(0);
    for (int i=0; i < numRequests; i++) {
      Map<TopicPartition,OffsetAndMetadata> offsets=singletonMap(tp,new OffsetAndMetadata(i));
      coordinator.commitOffsetsAsync(offsets,new OffsetCommitCallback(){
        @Override public void onComplete(        Map<TopicPartition,OffsetAndMetadata> offsets,        Exception exception){
          responses.incrementAndGet();
          Throwable cause=exception.getCause();
          assertTrue("Unexpected exception cause type: " + (cause == null ? null : cause.getClass()),cause instanceof DisconnectException);
        }
      }
);
    }
    coordinator.markCoordinatorUnknown();
    consumerClient.pollNoWakeup();
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertEquals(numRequests,responses.get());
  }
  @Test public void testCoordinatorUnknownInUnsentCallbacksAfterCoordinatorDead() throws Exception {
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    final AtomicBoolean asyncCallbackInvoked=new AtomicBoolean(false);
    Map<TopicPartition,OffsetCommitRequest.PartitionData> offsets=singletonMap(new TopicPartition("foo",0),new OffsetCommitRequest.PartitionData(13L,RecordBatch.NO_PARTITION_LEADER_EPOCH,""));
    consumerClient.send(coordinator.checkAndGetCoordinator(),new OffsetCommitRequest.Builder(groupId,offsets)).compose(new RequestFutureAdapter<ClientResponse,Object>(){
      @Override public void onSuccess(      ClientResponse value,      RequestFuture<Object> future){
      }
      @Override public void onFailure(      RuntimeException e,      RequestFuture<Object> future){
        assertTrue("Unexpected exception type: " + e.getClass(),e instanceof DisconnectException);
        assertTrue(coordinator.coordinatorUnknown());
        asyncCallbackInvoked.set(true);
      }
    }
);
    coordinator.markCoordinatorUnknown();
    consumerClient.pollNoWakeup();
    assertTrue(asyncCallbackInvoked.get());
  }
  @Test public void testNotCoordinator(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    time.sleep(sessionTimeoutMs);
    RequestFuture<Void> future=coordinator.sendHeartbeatRequest();
    assertEquals(1,consumerClient.pendingRequestCount());
    assertFalse(future.isDone());
    client.prepareResponse(heartbeatResponse(Errors.NOT_COORDINATOR));
    time.sleep(sessionTimeoutMs);
    consumerClient.poll(time.timer(0));
    assertTrue(future.isDone());
    assertTrue(future.failed());
    assertEquals(Errors.NOT_COORDINATOR.exception(),future.exception());
    assertTrue(coordinator.coordinatorUnknown());
  }
  @Test public void testIllegalGeneration(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    subscriptions.assignFromSubscribed(Collections.singletonList(t1p));
    time.sleep(sessionTimeoutMs);
    RequestFuture<Void> future=coordinator.sendHeartbeatRequest();
    assertEquals(1,consumerClient.pendingRequestCount());
    assertFalse(future.isDone());
    client.prepareResponse(heartbeatResponse(Errors.ILLEGAL_GENERATION));
    time.sleep(sessionTimeoutMs);
    consumerClient.poll(time.timer(0));
    assertTrue(future.isDone());
    assertTrue(future.failed());
    assertEquals(Errors.ILLEGAL_GENERATION.exception(),future.exception());
    assertTrue(coordinator.rejoinNeededOrPending());
  }
  @Test public void testUnknownConsumerId(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    subscriptions.assignFromSubscribed(Collections.singletonList(t1p));
    time.sleep(sessionTimeoutMs);
    RequestFuture<Void> future=coordinator.sendHeartbeatRequest();
    assertEquals(1,consumerClient.pendingRequestCount());
    assertFalse(future.isDone());
    client.prepareResponse(heartbeatResponse(Errors.UNKNOWN_MEMBER_ID));
    time.sleep(sessionTimeoutMs);
    consumerClient.poll(time.timer(0));
    assertTrue(future.isDone());
    assertTrue(future.failed());
    assertEquals(Errors.UNKNOWN_MEMBER_ID.exception(),future.exception());
    assertTrue(coordinator.rejoinNeededOrPending());
  }
  @Test public void testCoordinatorDisconnect(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    time.sleep(sessionTimeoutMs);
    RequestFuture<Void> future=coordinator.sendHeartbeatRequest();
    assertEquals(1,consumerClient.pendingRequestCount());
    assertFalse(future.isDone());
    client.prepareResponse(heartbeatResponse(Errors.NONE),true);
    time.sleep(sessionTimeoutMs);
    consumerClient.poll(time.timer(0));
    assertTrue(future.isDone());
    assertTrue(future.failed());
    assertTrue(future.exception() instanceof DisconnectException);
    assertTrue(coordinator.coordinatorUnknown());
  }
  @Test(expected=ApiException.class) public void testJoinGroupInvalidGroupId(){
    final String consumerId="leader";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    metadata.setTopics(singletonList(topic1));
    metadata.update(cluster,Collections.<String>emptySet(),time.milliseconds());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupLeaderResponse(0,consumerId,Collections.<String,List<String>>emptyMap(),Errors.INVALID_GROUP_ID));
    coordinator.poll(time.timer(Long.MAX_VALUE));
  }
  @Test public void testNormalJoinGroupLeader(){
    final String consumerId="leader";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    metadata.setTopics(singletonList(topic1));
    metadata.update(cluster,Collections.<String>emptySet(),time.milliseconds());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Map<String,List<String>> memberSubscriptions=singletonMap(consumerId,singletonList(topic1));
    partitionAssignor.prepare(singletonMap(consumerId,singletonList(t1p)));
    client.prepareResponse(joinGroupLeaderResponse(1,consumerId,memberSubscriptions,Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        SyncGroupRequest sync=(SyncGroupRequest)body;
        return sync.memberId().equals(consumerId) && sync.generationId() == 1 && sync.groupAssignment().containsKey(consumerId);
      }
    }
,syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(singleton(t1p),subscriptions.assignedPartitions());
    assertEquals(singleton(topic1),subscriptions.groupSubscription());
    assertEquals(1,rebalanceListener.revokedCount);
    assertEquals(Collections.emptySet(),rebalanceListener.revoked);
    assertEquals(1,rebalanceListener.assignedCount);
    assertEquals(singleton(t1p),rebalanceListener.assigned);
  }
  @Test public void testPatternJoinGroupLeader(){
    final String consumerId="leader";
    subscriptions.subscribe(Pattern.compile("test.*"),rebalanceListener);
    metadata.setTopics(singletonList(topic1));
    metadata.update(TestUtils.singletonCluster(topic1,1),Collections.<String>emptySet(),time.milliseconds());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Map<String,List<String>> memberSubscriptions=singletonMap(consumerId,singletonList(topic1));
    partitionAssignor.prepare(singletonMap(consumerId,Arrays.asList(t1p,t2p)));
    client.prepareResponse(joinGroupLeaderResponse(1,consumerId,memberSubscriptions,Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        SyncGroupRequest sync=(SyncGroupRequest)body;
        return sync.memberId().equals(consumerId) && sync.generationId() == 1 && sync.groupAssignment().containsKey(consumerId);
      }
    }
,syncGroupResponse(Arrays.asList(t1p,t2p),Errors.NONE));
    client.prepareMetadataUpdate(cluster,Collections.<String>emptySet());
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(2,subscriptions.numAssignedPartitions());
    assertEquals(2,subscriptions.groupSubscription().size());
    assertEquals(2,subscriptions.subscription().size());
    assertEquals(1,rebalanceListener.revokedCount);
    assertEquals(Collections.emptySet(),rebalanceListener.revoked);
    assertEquals(1,rebalanceListener.assignedCount);
    assertEquals(2,rebalanceListener.assigned.size());
  }
  @Test public void testMetadataRefreshDuringRebalance(){
    final String consumerId="leader";
    subscriptions.subscribe(Pattern.compile(".*"),rebalanceListener);
    metadata.needMetadataForAllTopics(true);
    metadata.update(TestUtils.singletonCluster(topic1,1),Collections.<String>emptySet(),time.milliseconds());
    assertEquals(singleton(topic1),subscriptions.subscription());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Map<String,List<String>> initialSubscription=singletonMap(consumerId,singletonList(topic1));
    partitionAssignor.prepare(singletonMap(consumerId,singletonList(t1p)));
    final List<String> updatedSubscription=Arrays.asList(topic1,topic2);
    final Set<String> updatedSubscriptionSet=new HashSet<>(updatedSubscription);
    client.prepareResponse(joinGroupLeaderResponse(1,consumerId,initialSubscription,Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        final Map<String,Integer> updatedPartitions=new HashMap<>();
        for (        String topic : updatedSubscription)         updatedPartitions.put(topic,1);
        metadata.update(TestUtils.clusterWith(1,updatedPartitions),Collections.<String>emptySet(),time.milliseconds());
        return true;
      }
    }
,syncGroupResponse(singletonList(t1p),Errors.NONE));
    List<TopicPartition> newAssignment=Arrays.asList(t1p,t2p);
    Set<TopicPartition> newAssignmentSet=new HashSet<>(newAssignment);
    Map<String,List<String>> updatedSubscriptions=singletonMap(consumerId,Arrays.asList(topic1,topic2));
    partitionAssignor.prepare(singletonMap(consumerId,newAssignment));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        JoinGroupRequest join=(JoinGroupRequest)body;
        ProtocolMetadata protocolMetadata=join.groupProtocols().iterator().next();
        PartitionAssignor.Subscription subscription=ConsumerProtocol.deserializeSubscription(protocolMetadata.metadata());
        protocolMetadata.metadata().rewind();
        return subscription.topics().containsAll(updatedSubscriptionSet);
      }
    }
,joinGroupLeaderResponse(2,consumerId,updatedSubscriptions,Errors.NONE));
    client.prepareResponse(syncGroupResponse(newAssignment,Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(updatedSubscriptionSet,subscriptions.subscription());
    assertEquals(newAssignmentSet,subscriptions.assignedPartitions());
    assertEquals(2,rebalanceListener.revokedCount);
    assertEquals(singleton(t1p),rebalanceListener.revoked);
    assertEquals(2,rebalanceListener.assignedCount);
    assertEquals(newAssignmentSet,rebalanceListener.assigned);
  }
  @Test public void testForceMetadataRefreshForPatternSubscriptionDuringRebalance(){
    final String consumerId="consumer";
    subscriptions.subscribe(Pattern.compile(".*"),rebalanceListener);
    metadata.update(TestUtils.singletonCluster(topic1,1),Collections.<String>emptySet(),time.milliseconds());
    assertEquals(singleton(topic1),subscriptions.subscription());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareMetadataUpdate(cluster,Collections.emptySet());
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        SyncGroupRequest sync=(SyncGroupRequest)body;
        return sync.memberId().equals(consumerId) && sync.generationId() == 1 && sync.groupAssignment().isEmpty();
      }
    }
,syncGroupResponse(singletonList(t1p),Errors.NONE));
    partitionAssignor.prepare(singletonMap(consumerId,singletonList(t1p)));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    final Set<String> updatedSubscriptionSet=new HashSet<>(Arrays.asList(topic1,topic2));
    assertEquals(updatedSubscriptionSet,subscriptions.subscription());
    metadata.requestUpdate();
    client.poll(Long.MAX_VALUE,time.milliseconds());
    assertFalse(coordinator.rejoinNeededOrPending());
  }
  @Test public void testWakeupDuringJoin(){
    final String consumerId="leader";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    metadata.setTopics(singletonList(topic1));
    metadata.update(cluster,Collections.<String>emptySet(),time.milliseconds());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Map<String,List<String>> memberSubscriptions=singletonMap(consumerId,singletonList(topic1));
    partitionAssignor.prepare(singletonMap(consumerId,singletonList(t1p)));
    client.prepareResponse(joinGroupLeaderResponse(1,consumerId,memberSubscriptions,Errors.NONE));
    consumerClient.wakeup();
    try {
      coordinator.poll(time.timer(Long.MAX_VALUE));
    }
 catch (    WakeupException e) {
    }
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(singleton(t1p),subscriptions.assignedPartitions());
    assertEquals(1,rebalanceListener.revokedCount);
    assertEquals(Collections.emptySet(),rebalanceListener.revoked);
    assertEquals(1,rebalanceListener.assignedCount);
    assertEquals(singleton(t1p),rebalanceListener.assigned);
  }
  @Test public void testNormalJoinGroupFollower(){
    final String consumerId="consumer";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        SyncGroupRequest sync=(SyncGroupRequest)body;
        return sync.memberId().equals(consumerId) && sync.generationId() == 1 && sync.groupAssignment().isEmpty();
      }
    }
,syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(singleton(t1p),subscriptions.assignedPartitions());
    assertEquals(singleton(topic1),subscriptions.groupSubscription());
    assertEquals(1,rebalanceListener.revokedCount);
    assertEquals(Collections.emptySet(),rebalanceListener.revoked);
    assertEquals(1,rebalanceListener.assignedCount);
    assertEquals(singleton(t1p),rebalanceListener.assigned);
  }
  @Test public void testUpdateLastHeartbeatPollWhenCoordinatorUnknown() throws Exception {
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,"consumer","leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    client.prepareResponse(heartbeatResponse(Errors.NOT_COORDINATOR));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    time.sleep(heartbeatIntervalMs);
    TestUtils.waitForCondition(() -> !client.hasPendingResponses(),"Failed to observe expected heartbeat from background thread");
    assertTrue(coordinator.coordinatorUnknown());
    assertFalse(coordinator.poll(time.timer(0)));
    assertEquals(time.milliseconds(),heartbeat.lastPollTime());
    time.sleep(rebalanceTimeoutMs - 1);
    assertFalse(heartbeat.pollTimeoutExpired(time.milliseconds()));
  }
  @Test public void testPatternJoinGroupFollower(){
    final String consumerId="consumer";
    subscriptions.subscribe(Pattern.compile("test.*"),rebalanceListener);
    metadata.setTopics(singletonList(topic1));
    metadata.update(TestUtils.singletonCluster(topic1,1),Collections.<String>emptySet(),time.milliseconds());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        SyncGroupRequest sync=(SyncGroupRequest)body;
        return sync.memberId().equals(consumerId) && sync.generationId() == 1 && sync.groupAssignment().isEmpty();
      }
    }
,syncGroupResponse(Arrays.asList(t1p,t2p),Errors.NONE));
    client.prepareMetadataUpdate(cluster,Collections.emptySet());
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(2,subscriptions.numAssignedPartitions());
    assertEquals(2,subscriptions.subscription().size());
    assertEquals(1,rebalanceListener.revokedCount);
    assertEquals(1,rebalanceListener.assignedCount);
    assertEquals(2,rebalanceListener.assigned.size());
  }
  @Test public void testLeaveGroupOnClose(){
    final String consumerId="consumer";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    joinAsFollowerAndReceiveAssignment(consumerId,coordinator,singletonList(t1p));
    final AtomicBoolean received=new AtomicBoolean(false);
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        received.set(true);
        LeaveGroupRequest leaveRequest=(LeaveGroupRequest)body;
        return leaveRequest.memberId().equals(consumerId) && leaveRequest.groupId().equals(groupId);
      }
    }
,new LeaveGroupResponse(Errors.NONE));
    coordinator.close(time.timer(0));
    assertTrue(received.get());
  }
  @Test public void testMaybeLeaveGroup(){
    final String consumerId="consumer";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    joinAsFollowerAndReceiveAssignment(consumerId,coordinator,singletonList(t1p));
    final AtomicBoolean received=new AtomicBoolean(false);
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        received.set(true);
        LeaveGroupRequest leaveRequest=(LeaveGroupRequest)body;
        return leaveRequest.memberId().equals(consumerId) && leaveRequest.groupId().equals(groupId);
      }
    }
,new LeaveGroupResponse(Errors.NONE));
    coordinator.maybeLeaveGroup();
    assertTrue(received.get());
    AbstractCoordinator.Generation generation=coordinator.generation();
    assertNull(generation);
  }
  @Test(expected=KafkaException.class) public void testUnexpectedErrorOnSyncGroup(){
    final String consumerId="consumer";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(Collections.emptyList(),Errors.UNKNOWN_SERVER_ERROR));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
  }
  @Test public void testUnknownMemberIdOnSyncGroup(){
    final String consumerId="consumer";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(Collections.<TopicPartition>emptyList(),Errors.UNKNOWN_MEMBER_ID));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        JoinGroupRequest joinRequest=(JoinGroupRequest)body;
        return joinRequest.memberId().equals(JoinGroupRequest.UNKNOWN_MEMBER_ID);
      }
    }
,joinGroupFollowerResponse(2,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(singleton(t1p),subscriptions.assignedPartitions());
  }
  @Test public void testRebalanceInProgressOnSyncGroup(){
    final String consumerId="consumer";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(Collections.<TopicPartition>emptyList(),Errors.REBALANCE_IN_PROGRESS));
    client.prepareResponse(joinGroupFollowerResponse(2,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(singleton(t1p),subscriptions.assignedPartitions());
  }
  @Test public void testIllegalGenerationOnSyncGroup(){
    final String consumerId="consumer";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(Collections.<TopicPartition>emptyList(),Errors.ILLEGAL_GENERATION));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        JoinGroupRequest joinRequest=(JoinGroupRequest)body;
        return joinRequest.memberId().equals(JoinGroupRequest.UNKNOWN_MEMBER_ID);
      }
    }
,joinGroupFollowerResponse(2,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(singleton(t1p),subscriptions.assignedPartitions());
  }
  @Test public void testMetadataChangeTriggersRebalance(){
    final String consumerId="consumer";
    metadata.setTopics(singletonList(topic1));
    metadata.update(cluster,Collections.<String>emptySet(),time.milliseconds());
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Map<String,List<String>> memberSubscriptions=singletonMap(consumerId,singletonList(topic1));
    partitionAssignor.prepare(singletonMap(consumerId,singletonList(t1p)));
    client.prepareResponse(joinGroupLeaderResponse(1,consumerId,memberSubscriptions,Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    metadata.update(TestUtils.singletonCluster(topic1,2),Collections.<String>emptySet(),time.milliseconds());
    assertTrue(coordinator.rejoinNeededOrPending());
  }
  @Test public void testUpdateMetadataDuringRebalance(){
    final String topic1="topic1";
    final String topic2="topic2";
    TopicPartition tp1=new TopicPartition(topic1,0);
    TopicPartition tp2=new TopicPartition(topic2,0);
    final String consumerId="leader";
    List<String> topics=Arrays.asList(topic1,topic2);
    subscriptions.subscribe(new HashSet<>(topics),rebalanceListener);
    metadata.setTopics(topics);
    metadata.update(TestUtils.singletonCluster(topic1,1),Collections.<String>emptySet(),time.milliseconds());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Map<String,List<String>> memberSubscriptions=singletonMap(consumerId,topics);
    partitionAssignor.prepare(singletonMap(consumerId,Collections.singletonList(tp1)));
    client.prepareResponse(joinGroupLeaderResponse(1,consumerId,memberSubscriptions,Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        SyncGroupRequest sync=(SyncGroupRequest)body;
        if (sync.memberId().equals(consumerId) && sync.generationId() == 1 && sync.groupAssignment().containsKey(consumerId)) {
          Map<String,Integer> topicPartitionCounts=new HashMap<>();
          topicPartitionCounts.put(topic1,1);
          topicPartitionCounts.put(topic2,1);
          metadata.update(TestUtils.singletonCluster(topicPartitionCounts),Collections.<String>emptySet(),time.milliseconds());
          return true;
        }
        return false;
      }
    }
,syncGroupResponse(Collections.singletonList(tp1),Errors.NONE));
    client.prepareResponse(joinGroupLeaderResponse(2,consumerId,memberSubscriptions,Errors.NONE));
    client.prepareResponse(syncGroupResponse(Arrays.asList(tp1,tp2),Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(new HashSet<>(Arrays.asList(tp1,tp2)),subscriptions.assignedPartitions());
  }
  @Test public void testWakeupFromAssignmentCallback(){
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,false,true);
    final String topic="topic1";
    TopicPartition partition=new TopicPartition(topic,0);
    final String consumerId="follower";
    Set<String> topics=Collections.singleton(topic);
    MockRebalanceListener rebalanceListener=new MockRebalanceListener(){
      @Override public void onPartitionsAssigned(      Collection<TopicPartition> partitions){
        boolean raiseWakeup=this.assignedCount == 0;
        super.onPartitionsAssigned(partitions);
        if (raiseWakeup)         throw new WakeupException();
      }
    }
;
    subscriptions.subscribe(topics,rebalanceListener);
    metadata.setTopics(topics);
    metadata.update(TestUtils.singletonCluster(topic,1),Collections.emptySet(),time.milliseconds());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    partitionAssignor.prepare(singletonMap(consumerId,Collections.singletonList(partition)));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(Collections.singletonList(partition),Errors.NONE));
    try {
      coordinator.poll(time.timer(Long.MAX_VALUE));
      fail("Expected exception thrown from assignment callback");
    }
 catch (    WakeupException e) {
    }
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(1,rebalanceListener.revokedCount);
    assertEquals(2,rebalanceListener.assignedCount);
  }
  @Test public void testRebalanceAfterTopicUnavailableWithSubscribe(){
    unavailableTopicTest(false,false,Collections.<String>emptySet());
  }
  @Test public void testRebalanceAfterTopicUnavailableWithPatternSubscribe(){
    unavailableTopicTest(true,false,Collections.<String>emptySet());
  }
  @Test public void testRebalanceAfterNotMatchingTopicUnavailableWithPatternSSubscribe(){
    unavailableTopicTest(true,false,Collections.singleton("notmatching"));
  }
  @Test public void testAssignWithTopicUnavailable(){
    unavailableTopicTest(true,false,Collections.<String>emptySet());
  }
  private void unavailableTopicTest(  boolean patternSubscribe,  boolean assign,  Set<String> unavailableTopicsInLastMetadata){
    final String consumerId="consumer";
    metadata.setTopics(singletonList(topic1));
    client.prepareMetadataUpdate(Cluster.empty(),Collections.singleton("test1"));
    if (assign)     subscriptions.assignFromUser(singleton(t1p));
 else     if (patternSubscribe)     subscriptions.subscribe(Pattern.compile("test.*"),rebalanceListener);
 else     subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Map<String,List<String>> memberSubscriptions=singletonMap(consumerId,singletonList(topic1));
    partitionAssignor.prepare(Collections.<String,List<TopicPartition>>emptyMap());
    client.prepareResponse(joinGroupLeaderResponse(1,consumerId,memberSubscriptions,Errors.NONE));
    client.prepareResponse(syncGroupResponse(Collections.<TopicPartition>emptyList(),Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    if (!assign) {
      assertFalse(coordinator.rejoinNeededOrPending());
      assertEquals(Collections.<TopicPartition>emptySet(),rebalanceListener.assigned);
    }
    assertTrue("Metadata refresh not requested for unavailable partitions",metadata.updateRequested());
    client.prepareMetadataUpdate(cluster,unavailableTopicsInLastMetadata);
    client.poll(0,time.milliseconds());
    client.prepareResponse(joinGroupLeaderResponse(2,consumerId,memberSubscriptions,Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse("Metadata refresh requested unnecessarily",metadata.updateRequested());
    if (!assign) {
      assertFalse(coordinator.rejoinNeededOrPending());
      assertEquals(singleton(t1p),rebalanceListener.assigned);
    }
  }
  @Test public void testExcludeInternalTopicsConfigOption(){
    subscriptions.subscribe(Pattern.compile(".*"),rebalanceListener);
    metadata.update(TestUtils.singletonCluster(TestUtils.GROUP_METADATA_TOPIC_NAME,2),Collections.<String>emptySet(),time.milliseconds());
    assertFalse(subscriptions.subscription().contains(TestUtils.GROUP_METADATA_TOPIC_NAME));
  }
  @Test public void testIncludeInternalTopicsConfigOption(){
    coordinator=buildCoordinator(new Metrics(),assignors,false,false,true);
    subscriptions.subscribe(Pattern.compile(".*"),rebalanceListener);
    metadata.update(TestUtils.singletonCluster(TestUtils.GROUP_METADATA_TOPIC_NAME,2),Collections.<String>emptySet(),time.milliseconds());
    assertTrue(subscriptions.subscription().contains(TestUtils.GROUP_METADATA_TOPIC_NAME));
  }
  @Test public void testRejoinGroup(){
    String otherTopic="otherTopic";
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    joinAsFollowerAndReceiveAssignment("consumer",coordinator,singletonList(t1p));
    assertEquals(1,rebalanceListener.revokedCount);
    assertTrue(rebalanceListener.revoked.isEmpty());
    assertEquals(1,rebalanceListener.assignedCount);
    assertEquals(singleton(t1p),rebalanceListener.assigned);
    subscriptions.subscribe(new HashSet<>(Arrays.asList(topic1,otherTopic)),rebalanceListener);
    client.prepareResponse(joinGroupFollowerResponse(2,"consumer","leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    assertEquals(2,rebalanceListener.revokedCount);
    assertEquals(singleton(t1p),rebalanceListener.revoked);
    assertEquals(2,rebalanceListener.assignedCount);
    assertEquals(singleton(t1p),rebalanceListener.assigned);
  }
  @Test public void testDisconnectInJoin(){
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,"consumer","leader",Errors.NONE),true);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    client.prepareResponse(joinGroupFollowerResponse(1,"consumer","leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.rejoinNeededOrPending());
    assertEquals(singleton(t1p),subscriptions.assignedPartitions());
    assertEquals(1,rebalanceListener.revokedCount);
    assertEquals(1,rebalanceListener.assignedCount);
    assertEquals(singleton(t1p),rebalanceListener.assigned);
  }
  @Test(expected=ApiException.class) public void testInvalidSessionTimeout(){
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(0,"consumer","",Errors.INVALID_SESSION_TIMEOUT));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
  }
  @Test public void testCommitOffsetOnly(){
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    AtomicBoolean success=new AtomicBoolean(false);
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),callback(success));
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertTrue(success.get());
  }
  @Test public void testCoordinatorDisconnectAfterNotCoordinatorError(){
    testInFlightRequestsFailedAfterCoordinatorMarkedDead(Errors.NOT_COORDINATOR);
  }
  @Test public void testCoordinatorDisconnectAfterCoordinatorNotAvailableError(){
    testInFlightRequestsFailedAfterCoordinatorMarkedDead(Errors.COORDINATOR_NOT_AVAILABLE);
  }
  private void testInFlightRequestsFailedAfterCoordinatorMarkedDead(  Errors error){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    MockCommitCallback firstCommitCallback=new MockCommitCallback();
    MockCommitCallback secondCommitCallback=new MockCommitCallback();
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),firstCommitCallback);
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),secondCommitCallback);
    respondToOffsetCommitRequest(singletonMap(t1p,100L),error);
    consumerClient.pollNoWakeup();
    consumerClient.pollNoWakeup();
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertTrue(coordinator.coordinatorUnknown());
    assertTrue(firstCommitCallback.exception instanceof RetriableCommitFailedException);
    assertTrue(secondCommitCallback.exception instanceof RetriableCommitFailedException);
  }
  @Test public void testAutoCommitDynamicAssignment(){
    final String consumerId="consumer";
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,true,true);
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    joinAsFollowerAndReceiveAssignment(consumerId,coordinator,singletonList(t1p));
    subscriptions.seek(t1p,100);
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    time.sleep(autoCommitIntervalMs);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(client.hasPendingResponses());
  }
  @Test public void testAutoCommitRetryBackoff(){
    final String consumerId="consumer";
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,true,true);
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    joinAsFollowerAndReceiveAssignment(consumerId,coordinator,singletonList(t1p));
    subscriptions.seek(t1p,100);
    time.sleep(autoCommitIntervalMs);
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NOT_COORDINATOR);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertTrue(coordinator.coordinatorUnknown());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    subscriptions.seek(t1p,200);
    time.sleep(retryBackoffMs / 2);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertEquals(0,client.inFlightRequestCount());
    time.sleep(retryBackoffMs / 2);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertEquals(1,client.inFlightRequestCount());
    respondToOffsetCommitRequest(singletonMap(t1p,200L),Errors.NONE);
  }
  @Test public void testAutoCommitAwaitsInterval(){
    final String consumerId="consumer";
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,true,true);
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    joinAsFollowerAndReceiveAssignment(consumerId,coordinator,singletonList(t1p));
    subscriptions.seek(t1p,100);
    time.sleep(autoCommitIntervalMs);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertEquals(1,client.inFlightRequestCount());
    time.sleep(autoCommitIntervalMs / 2);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertEquals(1,client.inFlightRequestCount());
    respondToOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertEquals(0,client.inFlightRequestCount());
    subscriptions.seek(t1p,200);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertEquals(0,client.inFlightRequestCount());
    time.sleep(autoCommitIntervalMs / 2);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertEquals(1,client.inFlightRequestCount());
    respondToOffsetCommitRequest(singletonMap(t1p,200L),Errors.NONE);
  }
  @Test public void testAutoCommitDynamicAssignmentRebalance(){
    final String consumerId="consumer";
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,true,true);
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    time.sleep(autoCommitIntervalMs);
    consumerClient.poll(time.timer(0));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    subscriptions.seek(t1p,100);
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    time.sleep(autoCommitIntervalMs);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(client.hasPendingResponses());
  }
  @Test public void testAutoCommitManualAssignment(){
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,true,true);
    subscriptions.assignFromUser(singleton(t1p));
    subscriptions.seek(t1p,100);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    time.sleep(autoCommitIntervalMs);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(client.hasPendingResponses());
  }
  @Test public void testAutoCommitManualAssignmentCoordinatorUnknown(){
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,true,true);
    subscriptions.assignFromUser(singleton(t1p));
    subscriptions.seek(t1p,100);
    consumerClient.poll(time.timer(0));
    time.sleep(autoCommitIntervalMs);
    consumerClient.poll(time.timer(0));
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    time.sleep(retryBackoffMs);
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    assertFalse(client.hasPendingResponses());
  }
  @Test public void testCommitOffsetMetadata(){
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    AtomicBoolean success=new AtomicBoolean(false);
    Map<TopicPartition,OffsetAndMetadata> offsets=singletonMap(t1p,new OffsetAndMetadata(100L,"hello"));
    coordinator.commitOffsetsAsync(offsets,callback(offsets,success));
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertTrue(success.get());
  }
  @Test public void testCommitOffsetAsyncWithDefaultCallback(){
    int invokedBeforeTest=mockOffsetCommitCallback.invoked;
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),mockOffsetCommitCallback);
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertEquals(invokedBeforeTest + 1,mockOffsetCommitCallback.invoked);
    assertNull(mockOffsetCommitCallback.exception);
  }
  @Test public void testCommitAfterLeaveGroup(){
    subscriptions.subscribe(singleton(topic1),rebalanceListener);
    joinAsFollowerAndReceiveAssignment("consumer",coordinator,singletonList(t1p));
    client.prepareResponse(new LeaveGroupResponse(Errors.NONE));
    subscriptions.unsubscribe();
    coordinator.maybeLeaveGroup();
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        OffsetCommitRequest commitRequest=(OffsetCommitRequest)body;
        return commitRequest.memberId().equals(OffsetCommitRequest.DEFAULT_MEMBER_ID) && commitRequest.generationId() == OffsetCommitRequest.DEFAULT_GENERATION_ID;
      }
    }
,offsetCommitResponse(singletonMap(t1p,Errors.NONE)));
    AtomicBoolean success=new AtomicBoolean(false);
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),callback(success));
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertTrue(success.get());
  }
  @Test public void testCommitOffsetAsyncFailedWithDefaultCallback(){
    int invokedBeforeTest=mockOffsetCommitCallback.invoked;
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.COORDINATOR_NOT_AVAILABLE);
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),mockOffsetCommitCallback);
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertEquals(invokedBeforeTest + 1,mockOffsetCommitCallback.invoked);
    assertTrue(mockOffsetCommitCallback.exception instanceof RetriableCommitFailedException);
  }
  @Test public void testCommitOffsetAsyncCoordinatorNotAvailable(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    MockCommitCallback cb=new MockCommitCallback();
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.COORDINATOR_NOT_AVAILABLE);
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),cb);
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertTrue(coordinator.coordinatorUnknown());
    assertEquals(1,cb.invoked);
    assertTrue(cb.exception instanceof RetriableCommitFailedException);
  }
  @Test public void testCommitOffsetAsyncNotCoordinator(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    MockCommitCallback cb=new MockCommitCallback();
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.COORDINATOR_NOT_AVAILABLE);
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),cb);
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertTrue(coordinator.coordinatorUnknown());
    assertEquals(1,cb.invoked);
    assertTrue(cb.exception instanceof RetriableCommitFailedException);
  }
  @Test public void testCommitOffsetAsyncDisconnected(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    MockCommitCallback cb=new MockCommitCallback();
    prepareOffsetCommitRequestDisconnect(singletonMap(t1p,100L));
    coordinator.commitOffsetsAsync(singletonMap(t1p,new OffsetAndMetadata(100L)),cb);
    coordinator.invokeCompletedOffsetCommitCallbacks();
    assertTrue(coordinator.coordinatorUnknown());
    assertEquals(1,cb.invoked);
    assertTrue(cb.exception instanceof RetriableCommitFailedException);
  }
  @Test public void testCommitOffsetSyncNotCoordinator(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NOT_COORDINATOR);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L)),time.timer(Long.MAX_VALUE));
  }
  @Test public void testCommitOffsetSyncCoordinatorNotAvailable(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.COORDINATOR_NOT_AVAILABLE);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L)),time.timer(Long.MAX_VALUE));
  }
  @Test public void testCommitOffsetSyncCoordinatorDisconnected(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequestDisconnect(singletonMap(t1p,100L));
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L)),time.timer(Long.MAX_VALUE));
  }
  @Test public void testAsyncCommitCallbacksInvokedPriorToSyncCommitCompletion() throws Exception {
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    final List<OffsetAndMetadata> committedOffsets=Collections.synchronizedList(new ArrayList<OffsetAndMetadata>());
    final OffsetAndMetadata firstOffset=new OffsetAndMetadata(0L);
    final OffsetAndMetadata secondOffset=new OffsetAndMetadata(1L);
    coordinator.commitOffsetsAsync(singletonMap(t1p,firstOffset),new OffsetCommitCallback(){
      @Override public void onComplete(      Map<TopicPartition,OffsetAndMetadata> offsets,      Exception exception){
        committedOffsets.add(firstOffset);
      }
    }
);
    Thread thread=new Thread(){
      @Override public void run(){
        coordinator.commitOffsetsSync(singletonMap(t1p,secondOffset),time.timer(10000));
        committedOffsets.add(secondOffset);
      }
    }
;
    thread.start();
    client.waitForRequests(2,5000);
    respondToOffsetCommitRequest(singletonMap(t1p,firstOffset.offset()),Errors.NONE);
    respondToOffsetCommitRequest(singletonMap(t1p,secondOffset.offset()),Errors.NONE);
    thread.join();
    assertEquals(Arrays.asList(firstOffset,secondOffset),committedOffsets);
  }
  @Test public void testRetryCommitUnknownTopicOrPartition(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(offsetCommitResponse(singletonMap(t1p,Errors.UNKNOWN_TOPIC_OR_PARTITION)));
    client.prepareResponse(offsetCommitResponse(singletonMap(t1p,Errors.NONE)));
    assertTrue(coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L,"metadata")),time.timer(10000)));
  }
  @Test(expected=OffsetMetadataTooLarge.class) public void testCommitOffsetMetadataTooLarge(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.OFFSET_METADATA_TOO_LARGE);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L,"metadata")),time.timer(Long.MAX_VALUE));
  }
  @Test(expected=CommitFailedException.class) public void testCommitOffsetIllegalGeneration(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.ILLEGAL_GENERATION);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L,"metadata")),time.timer(Long.MAX_VALUE));
  }
  @Test(expected=CommitFailedException.class) public void testCommitOffsetUnknownMemberId(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.UNKNOWN_MEMBER_ID);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L,"metadata")),time.timer(Long.MAX_VALUE));
  }
  @Test(expected=CommitFailedException.class) public void testCommitOffsetRebalanceInProgress(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.REBALANCE_IN_PROGRESS);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L,"metadata")),time.timer(Long.MAX_VALUE));
  }
  @Test(expected=KafkaException.class) public void testCommitOffsetSyncCallbackWithNonRetriableException(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.UNKNOWN_SERVER_ERROR);
    coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L)),time.timer(Long.MAX_VALUE));
  }
  @Test public void testCommitOffsetSyncWithoutFutureGetsCompleted(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    assertFalse(coordinator.commitOffsetsSync(singletonMap(t1p,new OffsetAndMetadata(100L)),time.timer(0)));
  }
  @Test public void testRefreshOffset(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(offsetFetchResponse(t1p,Errors.NONE,"",100L));
    coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
    assertEquals(Collections.emptySet(),subscriptions.missingFetchPositions());
    assertTrue(subscriptions.hasAllFetchPositions());
    assertEquals(100L,subscriptions.position(t1p).longValue());
  }
  @Test public void testFetchCommittedOffsets(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    long offset=500L;
    String metadata="blahblah";
    Optional<Integer> leaderEpoch=Optional.of(15);
    OffsetFetchResponse.PartitionData data=new OffsetFetchResponse.PartitionData(offset,leaderEpoch,metadata,Errors.NONE);
    client.prepareResponse(new OffsetFetchResponse(Errors.NONE,singletonMap(t1p,data)));
    Map<TopicPartition,OffsetAndMetadata> fetchedOffsets=coordinator.fetchCommittedOffsets(singleton(t1p),time.timer(Long.MAX_VALUE));
    assertNotNull(fetchedOffsets);
    assertEquals(new OffsetAndMetadata(offset,leaderEpoch,metadata),fetchedOffsets.get(t1p));
  }
  @Test public void testRefreshOffsetLoadInProgress(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(offsetFetchResponse(Errors.COORDINATOR_LOAD_IN_PROGRESS));
    client.prepareResponse(offsetFetchResponse(t1p,Errors.NONE,"",100L));
    coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
    assertEquals(Collections.emptySet(),subscriptions.missingFetchPositions());
    assertTrue(subscriptions.hasAllFetchPositions());
    assertEquals(100L,subscriptions.position(t1p).longValue());
  }
  @Test public void testRefreshOffsetsGroupNotAuthorized(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(offsetFetchResponse(Errors.GROUP_AUTHORIZATION_FAILED));
    try {
      coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
      fail("Expected group authorization error");
    }
 catch (    GroupAuthorizationException e) {
      assertEquals(groupId,e.groupId());
    }
  }
  @Test(expected=KafkaException.class) public void testRefreshOffsetUnknownTopicOrPartition(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(offsetFetchResponse(t1p,Errors.UNKNOWN_TOPIC_OR_PARTITION,"",100L));
    coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
  }
  @Test public void testRefreshOffsetNotCoordinatorForConsumer(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(offsetFetchResponse(Errors.NOT_COORDINATOR));
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    client.prepareResponse(offsetFetchResponse(t1p,Errors.NONE,"",100L));
    coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
    assertEquals(Collections.emptySet(),subscriptions.missingFetchPositions());
    assertTrue(subscriptions.hasAllFetchPositions());
    assertEquals(100L,subscriptions.position(t1p).longValue());
  }
  @Test public void testRefreshOffsetWithNoFetchableOffsets(){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    subscriptions.assignFromUser(singleton(t1p));
    client.prepareResponse(offsetFetchResponse(t1p,Errors.NONE,"",-1L));
    coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
    assertEquals(Collections.singleton(t1p),subscriptions.missingFetchPositions());
    assertEquals(Collections.emptySet(),subscriptions.partitionsNeedingReset(time.milliseconds()));
    assertFalse(subscriptions.hasAllFetchPositions());
    assertEquals(null,subscriptions.position(t1p));
  }
  @Test public void testNoCoordinatorDiscoveryIfPositionsKnown(){
    assertTrue(coordinator.coordinatorUnknown());
    subscriptions.assignFromUser(singleton(t1p));
    subscriptions.seek(t1p,500L);
    coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
    assertEquals(Collections.emptySet(),subscriptions.missingFetchPositions());
    assertTrue(subscriptions.hasAllFetchPositions());
    assertEquals(500L,subscriptions.position(t1p).longValue());
    assertTrue(coordinator.coordinatorUnknown());
  }
  @Test public void testNoCoordinatorDiscoveryIfPartitionAwaitingReset(){
    assertTrue(coordinator.coordinatorUnknown());
    subscriptions.assignFromUser(singleton(t1p));
    subscriptions.requestOffsetReset(t1p,OffsetResetStrategy.EARLIEST);
    coordinator.refreshCommittedOffsetsIfNeeded(time.timer(Long.MAX_VALUE));
    assertEquals(Collections.emptySet(),subscriptions.missingFetchPositions());
    assertFalse(subscriptions.hasAllFetchPositions());
    assertEquals(Collections.singleton(t1p),subscriptions.partitionsNeedingReset(time.milliseconds()));
    assertEquals(OffsetResetStrategy.EARLIEST,subscriptions.resetStrategy(t1p));
    assertTrue(coordinator.coordinatorUnknown());
  }
  @Test public void testAuthenticationFailureInEnsureActiveGroup(){
    client.createPendingAuthenticationError(node,300);
    try {
      coordinator.ensureActiveGroup();
      fail("Expected an authentication error.");
    }
 catch (    AuthenticationException e) {
    }
  }
  @Test public void testProtocolMetadataOrder(){
    RoundRobinAssignor roundRobin=new RoundRobinAssignor();
    RangeAssignor range=new RangeAssignor();
    try (Metrics metrics=new Metrics(time)){
      ConsumerCoordinator coordinator=buildCoordinator(metrics,Arrays.<PartitionAssignor>asList(roundRobin,range),ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,false,true);
      List<ProtocolMetadata> metadata=coordinator.metadata();
      assertEquals(2,metadata.size());
      assertEquals(roundRobin.name(),metadata.get(0).name());
      assertEquals(range.name(),metadata.get(1).name());
    }
     try (Metrics metrics=new Metrics(time)){
      ConsumerCoordinator coordinator=buildCoordinator(metrics,Arrays.<PartitionAssignor>asList(range,roundRobin),ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,false,true);
      List<ProtocolMetadata> metadata=coordinator.metadata();
      assertEquals(2,metadata.size());
      assertEquals(range.name(),metadata.get(0).name());
      assertEquals(roundRobin.name(),metadata.get(1).name());
    }
   }
  @Test public void testThreadSafeAssignedPartitionsMetric() throws Exception {
    final Metric metric=metrics.metric(new MetricName("assigned-partitions","consumer" + groupId + "-coordinator-metrics","",Collections.<String,String>emptyMap()));
    final AtomicBoolean doStop=new AtomicBoolean();
    final AtomicReference<Exception> exceptionHolder=new AtomicReference<>();
    final AtomicInteger observedSize=new AtomicInteger();
    Thread poller=new Thread(){
      @Override public void run(){
        while (!doStop.get()) {
          try {
            int size=((Double)metric.metricValue()).intValue();
            observedSize.set(size);
          }
 catch (          Exception e) {
            exceptionHolder.set(e);
            return;
          }
        }
      }
    }
;
    poller.start();
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    Set<TopicPartition> partitions=new HashSet<>();
    int totalPartitions=10;
    for (int partition=0; partition < totalPartitions; partition++) {
      partitions.add(new TopicPartition(topic1,partition));
      subscriptions.assignFromUser(partitions);
    }
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return observedSize.get() == totalPartitions || exceptionHolder.get() != null;
      }
    }
,"Failed to observe expected assignment change");
    doStop.set(true);
    poller.join();
    assertNull("Failed fetching the metric at least once",exceptionHolder.get());
  }
  @Test public void testCloseDynamicAssignment() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,true);
    gracefulCloseTest(coordinator,true);
  }
  @Test public void testCloseManualAssignment() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(false,true,true);
    gracefulCloseTest(coordinator,false);
  }
  @Test public void shouldNotLeaveGroupWhenLeaveGroupFlagIsFalse() throws Exception {
    final ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,false);
    gracefulCloseTest(coordinator,false);
  }
  @Test public void testCloseCoordinatorNotKnownManualAssignment() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(false,true,true);
    makeCoordinatorUnknown(coordinator,Errors.NOT_COORDINATOR);
    time.sleep(autoCommitIntervalMs);
    closeVerifyTimeout(coordinator,1000,1000,1000);
  }
  @Test public void testCloseCoordinatorNotKnownNoCommits() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,false,true);
    makeCoordinatorUnknown(coordinator,Errors.NOT_COORDINATOR);
    closeVerifyTimeout(coordinator,1000,0,0);
  }
  @Test public void testCloseCoordinatorNotKnownWithCommits() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,true);
    makeCoordinatorUnknown(coordinator,Errors.NOT_COORDINATOR);
    time.sleep(autoCommitIntervalMs);
    closeVerifyTimeout(coordinator,1000,1000,1000);
  }
  @Test public void testCloseCoordinatorUnavailableNoCommits() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,false,true);
    makeCoordinatorUnknown(coordinator,Errors.COORDINATOR_NOT_AVAILABLE);
    closeVerifyTimeout(coordinator,1000,0,0);
  }
  @Test public void testCloseTimeoutCoordinatorUnavailableForCommit() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,true);
    makeCoordinatorUnknown(coordinator,Errors.COORDINATOR_NOT_AVAILABLE);
    time.sleep(autoCommitIntervalMs);
    closeVerifyTimeout(coordinator,1000,1000,1000);
  }
  @Test public void testCloseMaxWaitCoordinatorUnavailableForCommit() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,true);
    makeCoordinatorUnknown(coordinator,Errors.COORDINATOR_NOT_AVAILABLE);
    time.sleep(autoCommitIntervalMs);
    closeVerifyTimeout(coordinator,Long.MAX_VALUE,requestTimeoutMs,requestTimeoutMs);
  }
  @Test public void testCloseNoResponseForCommit() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,true);
    time.sleep(autoCommitIntervalMs);
    closeVerifyTimeout(coordinator,Long.MAX_VALUE,requestTimeoutMs,requestTimeoutMs);
  }
  @Test public void testCloseNoResponseForLeaveGroup() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,false,true);
    closeVerifyTimeout(coordinator,Long.MAX_VALUE,requestTimeoutMs,requestTimeoutMs);
  }
  @Test public void testCloseNoWait() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,true);
    time.sleep(autoCommitIntervalMs);
    closeVerifyTimeout(coordinator,0,0,0);
  }
  @Test public void testHeartbeatThreadClose() throws Exception {
    ConsumerCoordinator coordinator=prepareCoordinatorForCloseTest(true,true,true);
    coordinator.ensureActiveGroup();
    time.sleep(heartbeatIntervalMs + 100);
    Thread.yield();
    closeVerifyTimeout(coordinator,Long.MAX_VALUE,requestTimeoutMs,requestTimeoutMs);
    Thread[] threads=new Thread[Thread.activeCount()];
    int threadCount=Thread.enumerate(threads);
    for (int i=0; i < threadCount; i++)     assertFalse("Heartbeat thread active after close",threads[i].getName().contains(groupId));
  }
  @Test public void testAutoCommitAfterCoordinatorBackToService(){
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,true,true);
    subscriptions.assignFromUser(Collections.singleton(t1p));
    subscriptions.seek(t1p,100L);
    coordinator.markCoordinatorUnknown();
    assertTrue(coordinator.coordinatorUnknown());
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    prepareOffsetCommitRequest(singletonMap(t1p,100L),Errors.NONE);
    time.sleep(autoCommitIntervalMs);
    coordinator.maybeAutoCommitOffsetsAsync(time.milliseconds());
    assertFalse(coordinator.coordinatorUnknown());
    assertEquals(100L,subscriptions.position(t1p).longValue());
  }
  private ConsumerCoordinator prepareCoordinatorForCloseTest(  final boolean useGroupManagement,  final boolean autoCommit,  final boolean leaveGroup){
    final String consumerId="consumer";
    ConsumerCoordinator coordinator=buildCoordinator(new Metrics(),assignors,ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS,autoCommit,leaveGroup);
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    if (useGroupManagement) {
      subscriptions.subscribe(singleton(topic1),rebalanceListener);
      client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
      client.prepareResponse(syncGroupResponse(singletonList(t1p),Errors.NONE));
      coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
    }
 else     subscriptions.assignFromUser(singleton(t1p));
    subscriptions.seek(t1p,100);
    coordinator.poll(time.timer(Long.MAX_VALUE));
    return coordinator;
  }
  private void makeCoordinatorUnknown(  ConsumerCoordinator coordinator,  Errors error){
    time.sleep(sessionTimeoutMs);
    coordinator.sendHeartbeatRequest();
    client.prepareResponse(heartbeatResponse(error));
    time.sleep(sessionTimeoutMs);
    consumerClient.poll(time.timer(0));
    assertTrue(coordinator.coordinatorUnknown());
  }
  private void closeVerifyTimeout(  final ConsumerCoordinator coordinator,  final long closeTimeoutMs,  final long expectedMinTimeMs,  final long expectedMaxTimeMs) throws Exception {
    ExecutorService executor=Executors.newSingleThreadExecutor();
    try {
      boolean coordinatorUnknown=coordinator.coordinatorUnknown();
      Future<?> future=executor.submit(new Runnable(){
        @Override public void run(){
          coordinator.close(time.timer(Math.min(closeTimeoutMs,requestTimeoutMs)));
        }
      }
);
      if (!coordinatorUnknown)       client.waitForRequests(1,1000);
 else       Thread.sleep(200);
      if (expectedMinTimeMs > 0) {
        time.sleep(expectedMinTimeMs - 1);
        try {
          future.get(500,TimeUnit.MILLISECONDS);
          fail("Close completed ungracefully without waiting for timeout");
        }
 catch (        TimeoutException e) {
        }
      }
      if (expectedMaxTimeMs >= 0)       time.sleep(expectedMaxTimeMs - expectedMinTimeMs + 2);
      future.get(2000,TimeUnit.MILLISECONDS);
    }
  finally {
      executor.shutdownNow();
    }
  }
  private void gracefulCloseTest(  ConsumerCoordinator coordinator,  boolean shouldLeaveGroup) throws Exception {
    final AtomicBoolean commitRequested=new AtomicBoolean();
    final AtomicBoolean leaveGroupRequested=new AtomicBoolean();
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        commitRequested.set(true);
        OffsetCommitRequest commitRequest=(OffsetCommitRequest)body;
        return commitRequest.groupId().equals(groupId);
      }
    }
,new OffsetCommitResponse(new HashMap<TopicPartition,Errors>()));
    client.prepareResponse(new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        leaveGroupRequested.set(true);
        LeaveGroupRequest leaveRequest=(LeaveGroupRequest)body;
        return leaveRequest.groupId().equals(groupId);
      }
    }
,new LeaveGroupResponse(Errors.NONE));
    coordinator.close();
    assertTrue("Commit not requested",commitRequested.get());
    assertEquals("leaveGroupRequested should be " + shouldLeaveGroup,shouldLeaveGroup,leaveGroupRequested.get());
  }
  private ConsumerCoordinator buildCoordinator(  final Metrics metrics,  final List<PartitionAssignor> assignors,  final boolean excludeInternalTopics,  final boolean autoCommitEnabled,  final boolean leaveGroup){
    return new ConsumerCoordinator(new LogContext(),consumerClient,groupId,rebalanceTimeoutMs,sessionTimeoutMs,heartbeat,assignors,metadata,subscriptions,metrics,"consumer" + groupId,time,retryBackoffMs,autoCommitEnabled,autoCommitIntervalMs,null,excludeInternalTopics,leaveGroup);
  }
  private FindCoordinatorResponse groupCoordinatorResponse(  Node node,  Errors error){
    return new FindCoordinatorResponse(error,node);
  }
  private HeartbeatResponse heartbeatResponse(  Errors error){
    return new HeartbeatResponse(error);
  }
  private JoinGroupResponse joinGroupLeaderResponse(  int generationId,  String memberId,  Map<String,List<String>> subscriptions,  Errors error){
    Map<String,ByteBuffer> metadata=new HashMap<>();
    for (    Map.Entry<String,List<String>> subscriptionEntry : subscriptions.entrySet()) {
      PartitionAssignor.Subscription subscription=new PartitionAssignor.Subscription(subscriptionEntry.getValue());
      ByteBuffer buf=ConsumerProtocol.serializeSubscription(subscription);
      metadata.put(subscriptionEntry.getKey(),buf);
    }
    return new JoinGroupResponse(error,generationId,partitionAssignor.name(),memberId,memberId,metadata);
  }
  private JoinGroupResponse joinGroupFollowerResponse(  int generationId,  String memberId,  String leaderId,  Errors error){
    return new JoinGroupResponse(error,generationId,partitionAssignor.name(),memberId,leaderId,Collections.emptyMap());
  }
  private SyncGroupResponse syncGroupResponse(  List<TopicPartition> partitions,  Errors error){
    ByteBuffer buf=ConsumerProtocol.serializeAssignment(new PartitionAssignor.Assignment(partitions));
    return new SyncGroupResponse(error,buf);
  }
  private OffsetCommitResponse offsetCommitResponse(  Map<TopicPartition,Errors> responseData){
    return new OffsetCommitResponse(responseData);
  }
  private OffsetFetchResponse offsetFetchResponse(  Errors topLevelError){
    return new OffsetFetchResponse(topLevelError,Collections.emptyMap());
  }
  private OffsetFetchResponse offsetFetchResponse(  TopicPartition tp,  Errors partitionLevelError,  String metadata,  long offset){
    OffsetFetchResponse.PartitionData data=new OffsetFetchResponse.PartitionData(offset,Optional.empty(),metadata,partitionLevelError);
    return new OffsetFetchResponse(Errors.NONE,singletonMap(tp,data));
  }
  private OffsetCommitCallback callback(  final AtomicBoolean success){
    return new OffsetCommitCallback(){
      @Override public void onComplete(      Map<TopicPartition,OffsetAndMetadata> offsets,      Exception exception){
        if (exception == null)         success.set(true);
      }
    }
;
  }
  private void joinAsFollowerAndReceiveAssignment(  String consumerId,  ConsumerCoordinator coordinator,  List<TopicPartition> assignment){
    client.prepareResponse(groupCoordinatorResponse(node,Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareResponse(joinGroupFollowerResponse(1,consumerId,"leader",Errors.NONE));
    client.prepareResponse(syncGroupResponse(assignment,Errors.NONE));
    coordinator.joinGroupIfNeeded(time.timer(Long.MAX_VALUE));
  }
  private void prepareOffsetCommitRequest(  Map<TopicPartition,Long> expectedOffsets,  Errors error){
    prepareOffsetCommitRequest(expectedOffsets,error,false);
  }
  private void prepareOffsetCommitRequestDisconnect(  Map<TopicPartition,Long> expectedOffsets){
    prepareOffsetCommitRequest(expectedOffsets,Errors.NONE,true);
  }
  private void prepareOffsetCommitRequest(  final Map<TopicPartition,Long> expectedOffsets,  Errors error,  boolean disconnected){
    Map<TopicPartition,Errors> errors=partitionErrors(expectedOffsets.keySet(),error);
    client.prepareResponse(offsetCommitRequestMatcher(expectedOffsets),offsetCommitResponse(errors),disconnected);
  }
  private Map<TopicPartition,Errors> partitionErrors(  Collection<TopicPartition> partitions,  Errors error){
    final Map<TopicPartition,Errors> errors=new HashMap<>();
    for (    TopicPartition partition : partitions) {
      errors.put(partition,error);
    }
    return errors;
  }
  private void respondToOffsetCommitRequest(  final Map<TopicPartition,Long> expectedOffsets,  Errors error){
    Map<TopicPartition,Errors> errors=partitionErrors(expectedOffsets.keySet(),error);
    client.respond(offsetCommitRequestMatcher(expectedOffsets),offsetCommitResponse(errors));
  }
  private MockClient.RequestMatcher offsetCommitRequestMatcher(  final Map<TopicPartition,Long> expectedOffsets){
    return new MockClient.RequestMatcher(){
      @Override public boolean matches(      AbstractRequest body){
        OffsetCommitRequest req=(OffsetCommitRequest)body;
        Map<TopicPartition,OffsetCommitRequest.PartitionData> offsets=req.offsetData();
        if (offsets.size() != expectedOffsets.size())         return false;
        for (        Map.Entry<TopicPartition,Long> expectedOffset : expectedOffsets.entrySet()) {
          if (!offsets.containsKey(expectedOffset.getKey()))           return false;
          OffsetCommitRequest.PartitionData offsetCommitData=offsets.get(expectedOffset.getKey());
          if (offsetCommitData.offset != expectedOffset.getValue())           return false;
        }
        return true;
      }
    }
;
  }
  private OffsetCommitCallback callback(  final Map<TopicPartition,OffsetAndMetadata> expectedOffsets,  final AtomicBoolean success){
    return new OffsetCommitCallback(){
      @Override public void onComplete(      Map<TopicPartition,OffsetAndMetadata> offsets,      Exception exception){
        if (expectedOffsets.equals(offsets) && exception == null)         success.set(true);
      }
    }
;
  }
private static class MockCommitCallback implements OffsetCommitCallback {
    public int invoked=0;
    public Exception exception=null;
    @Override public void onComplete(    Map<TopicPartition,OffsetAndMetadata> offsets,    Exception exception){
      invoked++;
      this.exception=exception;
    }
  }
private static class MockRebalanceListener implements ConsumerRebalanceListener {
    public Collection<TopicPartition> revoked;
    public Collection<TopicPartition> assigned;
    public int revokedCount=0;
    public int assignedCount=0;
    @Override public void onPartitionsAssigned(    Collection<TopicPartition> partitions){
      this.assigned=partitions;
      assignedCount++;
    }
    @Override public void onPartitionsRevoked(    Collection<TopicPartition> partitions){
      this.revoked=partitions;
      revokedCount++;
    }
  }
}
