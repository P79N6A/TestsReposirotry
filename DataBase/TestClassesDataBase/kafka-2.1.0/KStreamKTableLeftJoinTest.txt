public class KStreamKTableLeftJoinTest {
  final private String streamTopic="streamTopic";
  final private String tableTopic="tableTopic";
  private final ConsumerRecordFactory<Integer,String> recordFactory=new ConsumerRecordFactory<>(new IntegerSerializer(),new StringSerializer());
  private TopologyTestDriver driver;
  private MockProcessor<Integer,String> processor;
  private final int[] expectedKeys={0,1,2,3};
  private StreamsBuilder builder;
  @Before public void setUp(){
    builder=new StreamsBuilder();
    final KStream<Integer,String> stream;
    final KTable<Integer,String> table;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    final Consumed<Integer,String> consumed=Consumed.with(Serdes.Integer(),Serdes.String());
    stream=builder.stream(streamTopic,consumed);
    table=builder.table(tableTopic,consumed);
    stream.leftJoin(table,MockValueJoiner.TOSTRING_JOINER).process(supplier);
    final Properties props=StreamsTestUtils.getStreamsConfig(Serdes.Integer(),Serdes.String());
    driver=new TopologyTestDriver(builder.build(),props,0L);
    processor=supplier.theCapturedProcessor();
  }
  @After public void cleanup(){
    driver.close();
  }
  private void pushToStream(  final int messageCount,  final String valuePrefix){
    for (int i=0; i < messageCount; i++) {
      driver.pipeInput(recordFactory.create(streamTopic,expectedKeys[i],valuePrefix + expectedKeys[i]));
    }
  }
  private void pushToTable(  final int messageCount,  final String valuePrefix){
    for (int i=0; i < messageCount; i++) {
      driver.pipeInput(recordFactory.create(tableTopic,expectedKeys[i],valuePrefix + expectedKeys[i]));
    }
  }
  private void pushNullValueToTable(  final int messageCount){
    for (int i=0; i < messageCount; i++) {
      driver.pipeInput(recordFactory.create(tableTopic,expectedKeys[i],(String)null));
    }
  }
  @Test public void shouldRequireCopartitionedStreams(){
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals(1,copartitionGroups.size());
    assertEquals(new HashSet<>(Arrays.asList(streamTopic,tableTopic)),copartitionGroups.iterator().next());
  }
  @Test public void shouldJoinWithEmptyTableOnStreamUpdates(){
    pushToStream(2,"X");
    processor.checkAndClearProcessResult("0:X0+null","1:X1+null");
  }
  @Test public void shouldNotJoinOnTableUpdates(){
    pushToStream(2,"X");
    processor.checkAndClearProcessResult("0:X0+null","1:X1+null");
    pushToTable(2,"Y");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X");
    processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1","2:X2+null","3:X3+null");
    pushToTable(4,"YY");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X");
    processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
    pushToTable(4,"YYY");
    processor.checkAndClearProcessResult();
  }
  @Test public void shouldJoinRegardlessIfMatchFoundOnStreamUpdates(){
    pushToTable(2,"Y");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X");
    processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1","2:X2+null","3:X3+null");
  }
  @Test public void shouldClearTableEntryOnNullValueUpdates(){
    pushToTable(4,"Y");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X");
    processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1","2:X2+Y2","3:X3+Y3");
    pushNullValueToTable(2);
    processor.checkAndClearProcessResult();
    pushToStream(4,"XX");
    processor.checkAndClearProcessResult("0:XX0+null","1:XX1+null","2:XX2+Y2","3:XX3+Y3");
  }
}
