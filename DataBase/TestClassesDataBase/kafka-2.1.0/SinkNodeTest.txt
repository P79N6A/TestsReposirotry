public class SinkNodeTest {
  private final Serializer<byte[]> anySerializer=Serdes.ByteArray().serializer();
  private final StateSerdes<Bytes,Bytes> anyStateSerde=StateSerdes.withBuiltinTypes("anyName",Bytes.class,Bytes.class);
  private final RecordCollector recordCollector=new RecordCollectorImpl(null,new LogContext("sinknode-test "),new DefaultProductionExceptionHandler(),new Metrics().sensor("skipped-records"));
  private final InternalMockProcessorContext context=new InternalMockProcessorContext(anyStateSerde,recordCollector);
  private final SinkNode sink=new SinkNode<>("anyNodeName",new StaticTopicNameExtractor("any-output-topic"),anySerializer,anySerializer,null);
  @Before public void before(){
    recordCollector.init(new MockProducer<>(true,anySerializer,anySerializer));
    sink.init(context);
  }
  @Test @SuppressWarnings("unchecked") public void shouldThrowStreamsExceptionOnInputRecordWithInvalidTimestamp(){
    final Bytes anyKey=new Bytes("any key".getBytes());
    final Bytes anyValue=new Bytes("any value".getBytes());
    context.setTime(-1);
    try {
      sink.process(anyKey,anyValue);
      fail("Should have thrown StreamsException");
    }
 catch (    final StreamsException ignored) {
    }
  }
  @Test @SuppressWarnings("unchecked") public void shouldThrowStreamsExceptionOnKeyValueTypeSerializerMismatch(){
    final String keyOfDifferentTypeThanSerializer="key with different type";
    final String valueOfDifferentTypeThanSerializer="value with different type";
    context.setTime(0);
    try {
      sink.process(keyOfDifferentTypeThanSerializer,valueOfDifferentTypeThanSerializer);
      fail("Should have thrown StreamsException");
    }
 catch (    final StreamsException e) {
      assertThat(e.getCause(),instanceOf(ClassCastException.class));
    }
  }
  @Test @SuppressWarnings("unchecked") public void shouldHandleNullKeysWhenThrowingStreamsExceptionOnKeyValueTypeSerializerMismatch(){
    final String invalidValueToTriggerSerializerMismatch="";
    context.setTime(1);
    try {
      sink.process(null,invalidValueToTriggerSerializerMismatch);
      fail("Should have thrown StreamsException");
    }
 catch (    final StreamsException e) {
      assertThat(e.getCause(),instanceOf(ClassCastException.class));
      assertThat(e.getMessage(),containsString("unknown because key is null"));
    }
  }
  @Test @SuppressWarnings("unchecked") public void shouldHandleNullValuesWhenThrowingStreamsExceptionOnKeyValueTypeSerializerMismatch(){
    final String invalidKeyToTriggerSerializerMismatch="";
    context.setTime(1);
    try {
      sink.process(invalidKeyToTriggerSerializerMismatch,null);
      fail("Should have thrown StreamsException");
    }
 catch (    final StreamsException e) {
      assertThat(e.getCause(),instanceOf(ClassCastException.class));
      assertThat(e.getMessage(),containsString("unknown because value is null"));
    }
  }
}
