public class KStreamKStreamJoinTest {
  final private String topic1="topic1";
  final private String topic2="topic2";
  private final Consumed<Integer,String> consumed=Consumed.with(Serdes.Integer(),Serdes.String());
  private final ConsumerRecordFactory<Integer,String> recordFactory=new ConsumerRecordFactory<>(new IntegerSerializer(),new StringSerializer());
  private final Properties props=StreamsTestUtils.getStreamsConfig(Serdes.String(),Serdes.String());
  @Test public void shouldLogAndMeterOnSkippedRecordsWithNullValue(){
    final StreamsBuilder builder=new StreamsBuilder();
    final KStream<String,Integer> left=builder.stream("left",Consumed.with(Serdes.String(),Serdes.Integer()));
    final KStream<String,Integer> right=builder.stream("right",Consumed.with(Serdes.String(),Serdes.Integer()));
    final ConsumerRecordFactory<String,Integer> recordFactory=new ConsumerRecordFactory<>(new StringSerializer(),new IntegerSerializer());
    left.join(right,new ValueJoiner<Integer,Integer,Integer>(){
      @Override public Integer apply(      final Integer value1,      final Integer value2){
        return value1 + value2;
      }
    }
,JoinWindows.of(ofMillis(100)),Joined.with(Serdes.String(),Serdes.Integer(),Serdes.Integer()));
    final LogCaptureAppender appender=LogCaptureAppender.createAndRegister();
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props)){
      driver.pipeInput(recordFactory.create("left","A",null));
      LogCaptureAppender.unregister(appender);
      assertThat(appender.getMessages(),hasItem("Skipping record due to null key or value. key=[A] value=[null] topic=[left] partition=[0] offset=[0]"));
      assertEquals(1.0,getMetricByName(driver.metrics(),"skipped-records-total","stream-metrics").metricValue());
    }
   }
  @Test public void testJoin(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KStream<Integer,String> stream1;
    final KStream<Integer,String> stream2;
    final KStream<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    stream1=builder.stream(topic1,consumed);
    stream2=builder.stream(topic2,consumed);
    joined=stream1.join(stream2,MockValueJoiner.TOSTRING_JOINER,JoinWindows.of(ofMillis(100)),Joined.with(Serdes.Integer(),Serdes.String(),Serdes.String()));
    joined.process(supplier);
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals(1,copartitionGroups.size());
    assertEquals(new HashSet<>(Arrays.asList(topic1,topic2)),copartitionGroups.iterator().next());
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props)){
      final MockProcessor<Integer,String> processor=supplier.theCapturedProcessor();
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic1,expectedKeys[i],"X" + expectedKeys[i]));
      }
      processor.checkAndClearProcessResult();
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic2,expectedKeys[i],"Y" + expectedKeys[i]));
      }
      processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1");
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"X" + expectedKey));
      }
      processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1");
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","0:X0+YY0","1:X1+YY1","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey));
      }
      processor.checkAndClearProcessResult("0:XX0+Y0","0:XX0+YY0","1:XX1+Y1","1:XX1+YY1","2:XX2+YY2","3:XX3+YY3");
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic2,expectedKeys[i],"YYY" + expectedKeys[i]));
      }
      processor.checkAndClearProcessResult("0:X0+YYY0","0:X0+YYY0","0:XX0+YYY0","1:X1+YYY1","1:X1+YYY1","1:XX1+YYY1");
    }
   }
  @Test public void testOuterJoin(){
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KStream<Integer,String> stream1;
    final KStream<Integer,String> stream2;
    final KStream<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    stream1=builder.stream(topic1,consumed);
    stream2=builder.stream(topic2,consumed);
    joined=stream1.outerJoin(stream2,MockValueJoiner.TOSTRING_JOINER,JoinWindows.of(ofMillis(100)),Joined.with(Serdes.Integer(),Serdes.String(),Serdes.String()));
    joined.process(supplier);
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals(1,copartitionGroups.size());
    assertEquals(new HashSet<>(Arrays.asList(topic1,topic2)),copartitionGroups.iterator().next());
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props,0L)){
      final MockProcessor<Integer,String> processor=supplier.theCapturedProcessor();
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic1,expectedKeys[i],"X" + expectedKeys[i]));
      }
      processor.checkAndClearProcessResult("0:X0+null","1:X1+null");
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic2,expectedKeys[i],"Y" + expectedKeys[i]));
      }
      processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1");
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"X" + expectedKey));
      }
      processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1","2:X2+null","3:X3+null");
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","0:X0+YY0","1:X1+YY1","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey));
      }
      processor.checkAndClearProcessResult("0:XX0+Y0","0:XX0+YY0","1:XX1+Y1","1:XX1+YY1","2:XX2+YY2","3:XX3+YY3");
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic2,expectedKeys[i],"YYY" + expectedKeys[i]));
      }
      processor.checkAndClearProcessResult("0:X0+YYY0","0:X0+YYY0","0:XX0+YYY0","1:X1+YYY1","1:X1+YYY1","1:XX1+YYY1");
    }
   }
  @Test public void testWindowing(){
    long time=0L;
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KStream<Integer,String> stream1;
    final KStream<Integer,String> stream2;
    final KStream<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    stream1=builder.stream(topic1,consumed);
    stream2=builder.stream(topic2,consumed);
    joined=stream1.join(stream2,MockValueJoiner.TOSTRING_JOINER,JoinWindows.of(ofMillis(100)),Joined.with(Serdes.Integer(),Serdes.String(),Serdes.String()));
    joined.process(supplier);
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals(1,copartitionGroups.size());
    assertEquals(new HashSet<>(Arrays.asList(topic1,topic2)),copartitionGroups.iterator().next());
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props,time)){
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic1,expectedKeys[i],"X" + expectedKeys[i],time));
      }
      final MockProcessor<Integer,String> processor=supplier.theCapturedProcessor();
      processor.checkAndClearProcessResult();
      for (int i=0; i < 2; i++) {
        driver.pipeInput(recordFactory.create(topic2,expectedKeys[i],"Y" + expectedKeys[i],time));
      }
      processor.checkAndClearProcessResult("0:X0+Y0","1:X1+Y1");
      time=1000L;
      for (int i=0; i < expectedKeys.length; i++) {
        driver.pipeInput(recordFactory.create(topic1,expectedKeys[i],"X" + expectedKeys[i],time + i));
      }
      processor.checkAndClearProcessResult();
      time+=100L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
      time=1000L - 100L - 1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1");
      time+=1;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2");
      time+=1;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time=2000L;
      for (int i=0; i < expectedKeys.length; i++) {
        driver.pipeInput(recordFactory.create(topic2,expectedKeys[i],"Y" + expectedKeys[i],time + i));
      }
      processor.checkAndClearProcessResult();
      time=2000L + 100L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:XX0+Y0","1:XX1+Y1","2:XX2+Y2","3:XX3+Y3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("1:XX1+Y1","2:XX2+Y2","3:XX3+Y3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("2:XX2+Y2","3:XX3+Y3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("3:XX3+Y3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
      time=2000L - 100L - 1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:XX0+Y0");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:XX0+Y0","1:XX1+Y1");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:XX0+Y0","1:XX1+Y1","2:XX2+Y2");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic1,expectedKey,"XX" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:XX0+Y0","1:XX1+Y1","2:XX2+Y2","3:XX3+Y3");
    }
   }
  @Test public void testAsymmetricWindowingAfter(){
    long time=1000L;
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KStream<Integer,String> stream1;
    final KStream<Integer,String> stream2;
    final KStream<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    stream1=builder.stream(topic1,consumed);
    stream2=builder.stream(topic2,consumed);
    joined=stream1.join(stream2,MockValueJoiner.TOSTRING_JOINER,JoinWindows.of(ofMillis(0)).after(ofMillis(100)),Joined.with(Serdes.Integer(),Serdes.String(),Serdes.String()));
    joined.process(supplier);
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals(1,copartitionGroups.size());
    assertEquals(new HashSet<>(Arrays.asList(topic1,topic2)),copartitionGroups.iterator().next());
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props,time)){
      final MockProcessor<Integer,String> processor=supplier.theCapturedProcessor();
      for (int i=0; i < expectedKeys.length; i++) {
        driver.pipeInput(recordFactory.create(topic1,expectedKeys[i],"X" + expectedKeys[i],time + i));
      }
      processor.checkAndClearProcessResult();
      time=1000L - 1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time=1000 + 100L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
    }
   }
  @Test public void testAsymmetricWindowingBefore(){
    long time=1000L;
    final StreamsBuilder builder=new StreamsBuilder();
    final int[] expectedKeys=new int[]{0,1,2,3};
    final KStream<Integer,String> stream1;
    final KStream<Integer,String> stream2;
    final KStream<Integer,String> joined;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    stream1=builder.stream(topic1,consumed);
    stream2=builder.stream(topic2,consumed);
    joined=stream1.join(stream2,MockValueJoiner.TOSTRING_JOINER,JoinWindows.of(ofMillis(0)).before(ofMillis(100)),Joined.with(Serdes.Integer(),Serdes.String(),Serdes.String()));
    joined.process(supplier);
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals(1,copartitionGroups.size());
    assertEquals(new HashSet<>(Arrays.asList(topic1,topic2)),copartitionGroups.iterator().next());
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props,time)){
      final MockProcessor<Integer,String> processor=supplier.theCapturedProcessor();
      for (int i=0; i < expectedKeys.length; i++) {
        driver.pipeInput(recordFactory.create(topic1,expectedKeys[i],"X" + expectedKeys[i],time + i));
      }
      processor.checkAndClearProcessResult();
      time=1000L - 100L - 1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time=1000L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("0:X0+YY0","1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("1:X1+YY1","2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("2:X2+YY2","3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult("3:X3+YY3");
      time+=1L;
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topic2,expectedKey,"YY" + expectedKey,time));
      }
      processor.checkAndClearProcessResult();
    }
   }
}
