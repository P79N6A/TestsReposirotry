@RunWith(EasyMockRunner.class) public class KeyValueStoreBuilderTest {
  @Mock(type=MockType.NICE) private KeyValueBytesStoreSupplier supplier;
  @Mock(type=MockType.NICE) private KeyValueStore<Bytes,byte[]> inner;
  private KeyValueStoreBuilder<String,String> builder;
  @Before public void setUp(){
    EasyMock.expect(supplier.get()).andReturn(inner);
    EasyMock.expect(supplier.name()).andReturn("name");
    EasyMock.replay(supplier);
    builder=new KeyValueStoreBuilder<>(supplier,Serdes.String(),Serdes.String(),new MockTime());
  }
  @Test public void shouldHaveMeteredStoreAsOuterStore(){
    final KeyValueStore<String,String> store=builder.build();
    assertThat(store,instanceOf(MeteredKeyValueStore.class));
  }
  @Test public void shouldHaveChangeLoggingStoreByDefault(){
    final KeyValueStore<String,String> store=builder.build();
    assertThat(store,instanceOf(MeteredKeyValueStore.class));
    final StateStore next=((WrappedStateStore)store).wrappedStore();
    assertThat(next,instanceOf(ChangeLoggingKeyValueBytesStore.class));
  }
  @Test public void shouldNotHaveChangeLoggingStoreWhenDisabled(){
    final KeyValueStore<String,String> store=builder.withLoggingDisabled().build();
    final StateStore next=((WrappedStateStore)store).wrappedStore();
    assertThat(next,CoreMatchers.equalTo(inner));
  }
  @Test public void shouldHaveCachingStoreWhenEnabled(){
    final KeyValueStore<String,String> store=builder.withCachingEnabled().build();
    final StateStore wrapped=((WrappedStateStore)store).wrappedStore();
    assertThat(store,instanceOf(MeteredKeyValueStore.class));
    assertThat(wrapped,instanceOf(CachingKeyValueStore.class));
  }
  @Test public void shouldHaveChangeLoggingStoreWhenLoggingEnabled(){
    final KeyValueStore<String,String> store=builder.withLoggingEnabled(Collections.emptyMap()).build();
    final StateStore wrapped=((WrappedStateStore)store).wrappedStore();
    assertThat(store,instanceOf(MeteredKeyValueStore.class));
    assertThat(wrapped,instanceOf(ChangeLoggingKeyValueBytesStore.class));
    assertThat(((WrappedStateStore)wrapped).wrappedStore(),CoreMatchers.equalTo(inner));
  }
  @Test public void shouldHaveCachingAndChangeLoggingWhenBothEnabled(){
    final KeyValueStore<String,String> store=builder.withLoggingEnabled(Collections.emptyMap()).withCachingEnabled().build();
    final WrappedStateStore caching=(WrappedStateStore)((WrappedStateStore)store).wrappedStore();
    final WrappedStateStore changeLogging=(WrappedStateStore)caching.wrappedStore();
    assertThat(store,instanceOf(MeteredKeyValueStore.class));
    assertThat(caching,instanceOf(CachingKeyValueStore.class));
    assertThat(changeLogging,instanceOf(ChangeLoggingKeyValueBytesStore.class));
    assertThat(changeLogging.wrappedStore(),CoreMatchers.equalTo(inner));
  }
  @SuppressWarnings("all") @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfInnerIsNull(){
    new KeyValueStoreBuilder<>(null,Serdes.String(),Serdes.String(),new MockTime());
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfKeySerdeIsNull(){
    new KeyValueStoreBuilder<>(supplier,null,Serdes.String(),new MockTime());
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfValueSerdeIsNull(){
    new KeyValueStoreBuilder<>(supplier,Serdes.String(),null,new MockTime());
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfTimeIsNull(){
    new KeyValueStoreBuilder<>(supplier,Serdes.String(),Serdes.String(),null);
  }
  @Test(expected=NullPointerException.class) public void shouldThrowNullPointerIfMetricsScopeIsNull(){
    new KeyValueStoreBuilder<>(supplier,Serdes.String(),Serdes.String(),new MockTime());
  }
}
