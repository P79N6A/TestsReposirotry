@Category({IntegrationTest.class}) public class GlobalThreadShutDownOrderTest {
  private static final int NUM_BROKERS=1;
  private static final Properties BROKER_CONFIG;
static {
    BROKER_CONFIG=new Properties();
    BROKER_CONFIG.put("transaction.state.log.replication.factor",(short)1);
    BROKER_CONFIG.put("transaction.state.log.min.isr",1);
  }
  @ClassRule public static final EmbeddedKafkaCluster CLUSTER=new EmbeddedKafkaCluster(NUM_BROKERS,BROKER_CONFIG);
  private final MockTime mockTime=CLUSTER.time;
  private final String globalStore="globalStore";
  private StreamsBuilder builder;
  private Properties streamsConfiguration;
  private KafkaStreams kafkaStreams;
  private String globalStoreTopic;
  private String streamTopic;
  private KStream<String,Long> stream;
  private List<Long> retrievedValuesList=new ArrayList<>();
  private boolean firstRecordProcessed;
  @Before public void before() throws InterruptedException {
    builder=new StreamsBuilder();
    createTopics();
    streamsConfiguration=new Properties();
    final String applicationId="global-thread-shutdown-test";
    streamsConfiguration.put(StreamsConfig.APPLICATION_ID_CONFIG,applicationId);
    streamsConfiguration.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,CLUSTER.bootstrapServers());
    streamsConfiguration.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,"earliest");
    streamsConfiguration.put(StreamsConfig.STATE_DIR_CONFIG,TestUtils.tempDirectory().getPath());
    streamsConfiguration.put(StreamsConfig.CACHE_MAX_BYTES_BUFFERING_CONFIG,0);
    streamsConfiguration.put(IntegrationTestUtils.INTERNAL_LEAVE_GROUP_ON_CLOSE,true);
    streamsConfiguration.put(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG,100);
    final Consumed<String,Long> stringLongConsumed=Consumed.with(Serdes.String(),Serdes.Long());
    final KeyValueStoreBuilder<String,Long> storeBuilder=new KeyValueStoreBuilder<>(Stores.persistentKeyValueStore(globalStore),Serdes.String(),Serdes.Long(),mockTime);
    builder.addGlobalStore(storeBuilder,globalStoreTopic,Consumed.with(Serdes.String(),Serdes.Long()),new MockProcessorSupplier());
    stream=builder.stream(streamTopic,stringLongConsumed);
    stream.process(new ProcessorSupplier<String,Long>(){
      @Override public Processor<String,Long> get(){
        return new GlobalStoreProcessor(globalStore);
      }
    }
);
  }
  @After public void whenShuttingDown() throws IOException {
    if (kafkaStreams != null) {
      kafkaStreams.close();
    }
    IntegrationTestUtils.purgeLocalStreamsState(streamsConfiguration);
  }
  @Test public void shouldFinishGlobalStoreOperationOnShutDown() throws Exception {
    kafkaStreams=new KafkaStreams(builder.build(),streamsConfiguration);
    populateTopics(globalStoreTopic);
    populateTopics(streamTopic);
    kafkaStreams.start();
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return firstRecordProcessed;
      }
    }
,30000,"Has not processed record within 30 seconds");
    kafkaStreams.close(Duration.ofSeconds(30));
    final List<Long> expectedRetrievedValues=Arrays.asList(1L,2L,3L,4L);
    assertEquals(expectedRetrievedValues,retrievedValuesList);
  }
  private void createTopics() throws InterruptedException {
    streamTopic="stream-topic";
    globalStoreTopic="global-store-topic";
    CLUSTER.createTopics(streamTopic);
    CLUSTER.createTopic(globalStoreTopic);
  }
  private void populateTopics(  final String topicName) throws Exception {
    IntegrationTestUtils.produceKeyValuesSynchronously(topicName,Arrays.asList(new KeyValue<>("A",1L),new KeyValue<>("B",2L),new KeyValue<>("C",3L),new KeyValue<>("D",4L)),TestUtils.producerConfig(CLUSTER.bootstrapServers(),StringSerializer.class,LongSerializer.class,new Properties()),mockTime);
  }
private class GlobalStoreProcessor extends AbstractProcessor<String,Long> {
    private KeyValueStore<String,Long> store;
    private final String storeName;
    GlobalStoreProcessor(    final String storeName){
      this.storeName=storeName;
    }
    @Override @SuppressWarnings("unchecked") public void init(    final ProcessorContext context){
      super.init(context);
      store=(KeyValueStore<String,Long>)context.getStateStore(storeName);
    }
    @Override public void process(    final String key,    final Long value){
      firstRecordProcessed=true;
    }
    @Override public void close(){
      final List<String> keys=Arrays.asList("A","B","C","D");
      for (      final String key : keys) {
        Utils.sleep(1000);
        retrievedValuesList.add(store.get(key));
      }
    }
  }
}
