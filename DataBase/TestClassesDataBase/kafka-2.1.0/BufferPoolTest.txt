public class BufferPoolTest {
  private final MockTime time=new MockTime();
  private final Metrics metrics=new Metrics(time);
  private final long maxBlockTimeMs=2000;
  private final String metricGroup="TestMetrics";
  @After public void teardown(){
    this.metrics.close();
  }
  /** 
 * Test the simple non-blocking allocation paths
 */
  @Test public void testSimple() throws Exception {
    long totalMemory=64 * 1024;
    int size=1024;
    BufferPool pool=new BufferPool(totalMemory,size,metrics,time,metricGroup);
    ByteBuffer buffer=pool.allocate(size,maxBlockTimeMs);
    assertEquals("Buffer size should equal requested size.",size,buffer.limit());
    assertEquals("Unallocated memory should have shrunk",totalMemory - size,pool.unallocatedMemory());
    assertEquals("Available memory should have shrunk",totalMemory - size,pool.availableMemory());
    buffer.putInt(1);
    buffer.flip();
    pool.deallocate(buffer);
    assertEquals("All memory should be available",totalMemory,pool.availableMemory());
    assertEquals("But now some is on the free list",totalMemory - size,pool.unallocatedMemory());
    buffer=pool.allocate(size,maxBlockTimeMs);
    assertEquals("Recycled buffer should be cleared.",0,buffer.position());
    assertEquals("Recycled buffer should be cleared.",buffer.capacity(),buffer.limit());
    pool.deallocate(buffer);
    assertEquals("All memory should be available",totalMemory,pool.availableMemory());
    assertEquals("Still a single buffer on the free list",totalMemory - size,pool.unallocatedMemory());
    buffer=pool.allocate(2 * size,maxBlockTimeMs);
    pool.deallocate(buffer);
    assertEquals("All memory should be available",totalMemory,pool.availableMemory());
    assertEquals("Non-standard size didn't go to the free list.",totalMemory - size,pool.unallocatedMemory());
  }
  /** 
 * Test that we cannot try to allocate more memory then we have in the whole pool
 */
  @Test(expected=IllegalArgumentException.class) public void testCantAllocateMoreMemoryThanWeHave() throws Exception {
    BufferPool pool=new BufferPool(1024,512,metrics,time,metricGroup);
    ByteBuffer buffer=pool.allocate(1024,maxBlockTimeMs);
    assertEquals(1024,buffer.limit());
    pool.deallocate(buffer);
    pool.allocate(1025,maxBlockTimeMs);
  }
  /** 
 * Test that delayed allocation blocks
 */
  @Test public void testDelayedAllocation() throws Exception {
    BufferPool pool=new BufferPool(5 * 1024,1024,metrics,time,metricGroup);
    ByteBuffer buffer=pool.allocate(1024,maxBlockTimeMs);
    CountDownLatch doDealloc=asyncDeallocate(pool,buffer);
    CountDownLatch allocation=asyncAllocate(pool,5 * 1024);
    assertEquals("Allocation shouldn't have happened yet, waiting on memory.",1L,allocation.getCount());
    doDealloc.countDown();
    assertTrue("Allocation should succeed soon after de-allocation",allocation.await(1,TimeUnit.SECONDS));
  }
  private CountDownLatch asyncDeallocate(  final BufferPool pool,  final ByteBuffer buffer){
    final CountDownLatch latch=new CountDownLatch(1);
    Thread thread=new Thread(){
      public void run(){
        try {
          latch.await();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        pool.deallocate(buffer);
      }
    }
;
    thread.start();
    return latch;
  }
  private void delayedDeallocate(  final BufferPool pool,  final ByteBuffer buffer,  final long delayMs){
    Thread thread=new Thread(){
      public void run(){
        Time.SYSTEM.sleep(delayMs);
        pool.deallocate(buffer);
      }
    }
;
    thread.start();
  }
  private CountDownLatch asyncAllocate(  final BufferPool pool,  final int size){
    final CountDownLatch completed=new CountDownLatch(1);
    Thread thread=new Thread(){
      public void run(){
        try {
          pool.allocate(size,maxBlockTimeMs);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
 finally {
          completed.countDown();
        }
      }
    }
;
    thread.start();
    return completed;
  }
  /** 
 * Test if Timeout exception is thrown when there is not enough memory to allocate and the elapsed time is greater than the max specified block time. And verify that the allocation attempt finishes soon after the maxBlockTimeMs.
 */
  @Test public void testBlockTimeout() throws Exception {
    BufferPool pool=new BufferPool(10,1,metrics,Time.SYSTEM,metricGroup);
    ByteBuffer buffer1=pool.allocate(1,maxBlockTimeMs);
    ByteBuffer buffer2=pool.allocate(1,maxBlockTimeMs);
    ByteBuffer buffer3=pool.allocate(1,maxBlockTimeMs);
    delayedDeallocate(pool,buffer1,maxBlockTimeMs / 2);
    delayedDeallocate(pool,buffer2,maxBlockTimeMs);
    delayedDeallocate(pool,buffer3,maxBlockTimeMs / 2 * 5);
    long beginTimeMs=Time.SYSTEM.milliseconds();
    try {
      pool.allocate(10,maxBlockTimeMs);
      fail("The buffer allocated more memory than its maximum value 10");
    }
 catch (    TimeoutException e) {
    }
    assertTrue("available memory " + pool.availableMemory(),pool.availableMemory() >= 8 && pool.availableMemory() <= 10);
    long durationMs=Time.SYSTEM.milliseconds() - beginTimeMs;
    assertTrue("TimeoutException should not throw before maxBlockTimeMs",durationMs >= maxBlockTimeMs);
    assertTrue("TimeoutException should throw soon after maxBlockTimeMs",durationMs < maxBlockTimeMs + 1000);
  }
  /** 
 * Test if the  waiter that is waiting on availability of more memory is cleaned up when a timeout occurs
 */
  @Test public void testCleanupMemoryAvailabilityWaiterOnBlockTimeout() throws Exception {
    BufferPool pool=new BufferPool(2,1,metrics,time,metricGroup);
    pool.allocate(1,maxBlockTimeMs);
    try {
      pool.allocate(2,maxBlockTimeMs);
      fail("The buffer allocated more memory than its maximum value 2");
    }
 catch (    TimeoutException e) {
    }
    assertEquals(0,pool.queued());
    assertEquals(1,pool.availableMemory());
  }
  /** 
 * Test if the  waiter that is waiting on availability of more memory is cleaned up when an interruption occurs
 */
  @Test public void testCleanupMemoryAvailabilityWaiterOnInterruption() throws Exception {
    BufferPool pool=new BufferPool(2,1,metrics,time,metricGroup);
    long blockTime=5000;
    pool.allocate(1,maxBlockTimeMs);
    Thread t1=new Thread(new BufferPoolAllocator(pool,blockTime));
    Thread t2=new Thread(new BufferPoolAllocator(pool,blockTime));
    t1.start();
    Thread.sleep(500);
    Deque<Condition> waiters=pool.waiters();
    Condition c1=waiters.getFirst();
    t2.start();
    Thread.sleep(500);
    t1.interrupt();
    Thread.sleep(500);
    Condition c2=waiters.getLast();
    t2.interrupt();
    assertNotEquals(c1,c2);
    t1.join();
    t2.join();
    assertEquals(pool.queued(),0);
  }
  @Test public void testCleanupMemoryAvailabilityOnMetricsException() throws Exception {
    BufferPool bufferPool=spy(new BufferPool(2,1,new Metrics(),time,metricGroup));
    doThrow(new OutOfMemoryError()).when(bufferPool).recordWaitTime(anyLong());
    bufferPool.allocate(1,0);
    try {
      bufferPool.allocate(2,1000);
      fail("Expected oom.");
    }
 catch (    OutOfMemoryError expected) {
    }
    assertEquals(1,bufferPool.availableMemory());
    assertEquals(0,bufferPool.queued());
    assertEquals(1,bufferPool.unallocatedMemory());
    bufferPool.allocate(1,0);
    verify(bufferPool).recordWaitTime(anyLong());
  }
private static class BufferPoolAllocator implements Runnable {
    BufferPool pool;
    long maxBlockTimeMs;
    BufferPoolAllocator(    BufferPool pool,    long maxBlockTimeMs){
      this.pool=pool;
      this.maxBlockTimeMs=maxBlockTimeMs;
    }
    @Override public void run(){
      try {
        pool.allocate(2,maxBlockTimeMs);
        fail("The buffer allocated more memory than its maximum value 2");
      }
 catch (      TimeoutException e) {
      }
catch (      InterruptedException e) {
      }
    }
  }
  /** 
 * This test creates lots of threads that hammer on the pool
 */
  @Test public void testStressfulSituation() throws Exception {
    int numThreads=10;
    final int iterations=50000;
    final int poolableSize=1024;
    final long totalMemory=numThreads / 2 * poolableSize;
    final BufferPool pool=new BufferPool(totalMemory,poolableSize,metrics,time,metricGroup);
    List<StressTestThread> threads=new ArrayList<StressTestThread>();
    for (int i=0; i < numThreads; i++)     threads.add(new StressTestThread(pool,iterations));
    for (    StressTestThread thread : threads)     thread.start();
    for (    StressTestThread thread : threads)     thread.join();
    for (    StressTestThread thread : threads)     assertTrue("Thread should have completed all iterations successfully.",thread.success.get());
    assertEquals(totalMemory,pool.availableMemory());
  }
  @Test public void testLargeAvailableMemory() throws Exception {
    long memory=20_000_000_000L;
    int poolableSize=2_000_000_000;
    final AtomicInteger freeSize=new AtomicInteger(0);
    BufferPool pool=new BufferPool(memory,poolableSize,metrics,time,metricGroup){
      @Override protected ByteBuffer allocateByteBuffer(      int size){
        return ByteBuffer.allocate(0);
      }
      @Override protected int freeSize(){
        return freeSize.get();
      }
    }
;
    pool.allocate(poolableSize,0);
    assertEquals(18_000_000_000L,pool.availableMemory());
    pool.allocate(poolableSize,0);
    assertEquals(16_000_000_000L,pool.availableMemory());
    freeSize.incrementAndGet();
    assertEquals(18_000_000_000L,pool.availableMemory());
    freeSize.incrementAndGet();
    assertEquals(20_000_000_000L,pool.availableMemory());
  }
  @Test public void outOfMemoryOnAllocation(){
    BufferPool bufferPool=new BufferPool(1024,1024,metrics,time,metricGroup){
      @Override protected ByteBuffer allocateByteBuffer(      int size){
        throw new OutOfMemoryError();
      }
    }
;
    try {
      bufferPool.allocateByteBuffer(1024);
      fail("Should have thrown OutOfMemoryError");
    }
 catch (    OutOfMemoryError ignored) {
    }
    assertEquals(bufferPool.availableMemory(),1024);
  }
public static class StressTestThread extends Thread {
    private final int iterations;
    private final BufferPool pool;
    private final long maxBlockTimeMs=20_000;
    public final AtomicBoolean success=new AtomicBoolean(false);
    public StressTestThread(    BufferPool pool,    int iterations){
      this.iterations=iterations;
      this.pool=pool;
    }
    public void run(){
      try {
        for (int i=0; i < iterations; i++) {
          int size;
          if (TestUtils.RANDOM.nextBoolean())           size=pool.poolableSize();
 else           size=TestUtils.RANDOM.nextInt((int)pool.totalMemory());
          ByteBuffer buffer=pool.allocate(size,maxBlockTimeMs);
          pool.deallocate(buffer);
        }
        success.set(true);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}
