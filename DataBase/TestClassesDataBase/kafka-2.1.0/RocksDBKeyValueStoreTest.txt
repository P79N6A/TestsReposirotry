public class RocksDBKeyValueStoreTest extends AbstractKeyValueStoreTest {
  @SuppressWarnings("unchecked") @Override protected <K,V>KeyValueStore<K,V> createKeyValueStore(  final ProcessorContext context){
    final StoreBuilder storeBuilder=Stores.keyValueStoreBuilder(Stores.persistentKeyValueStore("my-store"),(Serde<K>)context.keySerde(),(Serde<V>)context.valueSerde());
    final StateStore store=storeBuilder.build();
    store.init(context,store);
    return (KeyValueStore<K,V>)store;
  }
public static class TheRocksDbConfigSetter implements RocksDBConfigSetter {
    static boolean called=false;
    @Override public void setConfig(    final String storeName,    final Options options,    final Map<String,Object> configs){
      called=true;
    }
  }
  @Test public void shouldUseCustomRocksDbConfigSetter(){
    assertTrue(TheRocksDbConfigSetter.called);
  }
  @Test public void shouldPerformRangeQueriesWithCachingDisabled(){
    context.setTime(1L);
    store.put(1,"hi");
    store.put(2,"goodbye");
    final KeyValueIterator<Integer,String> range=store.range(1,2);
    assertEquals("hi",range.next().value);
    assertEquals("goodbye",range.next().value);
    assertFalse(range.hasNext());
  }
  @Test public void shouldPerformAllQueriesWithCachingDisabled(){
    context.setTime(1L);
    store.put(1,"hi");
    store.put(2,"goodbye");
    final KeyValueIterator<Integer,String> range=store.all();
    assertEquals("hi",range.next().value);
    assertEquals("goodbye",range.next().value);
    assertFalse(range.hasNext());
  }
  @Test public void shouldCloseOpenIteratorsWhenStoreClosedAndThrowInvalidStateStoreOnHasNextAndNext(){
    context.setTime(1L);
    store.put(1,"hi");
    store.put(2,"goodbye");
    final KeyValueIterator<Integer,String> iteratorOne=store.range(1,5);
    final KeyValueIterator<Integer,String> iteratorTwo=store.range(1,4);
    assertTrue(iteratorOne.hasNext());
    assertTrue(iteratorTwo.hasNext());
    store.close();
    try {
      iteratorOne.hasNext();
      fail("should have thrown InvalidStateStoreException on closed store");
    }
 catch (    final InvalidStateStoreException e) {
    }
    try {
      iteratorOne.next();
      fail("should have thrown InvalidStateStoreException on closed store");
    }
 catch (    final InvalidStateStoreException e) {
    }
    try {
      iteratorTwo.hasNext();
      fail("should have thrown InvalidStateStoreException on closed store");
    }
 catch (    final InvalidStateStoreException e) {
    }
    try {
      iteratorTwo.next();
      fail("should have thrown InvalidStateStoreException on closed store");
    }
 catch (    final InvalidStateStoreException e) {
    }
  }
}
