public class KStreamGlobalKTableJoinTest {
  private final String streamTopic="streamTopic";
  private final String globalTableTopic="globalTableTopic";
  private TopologyTestDriver driver;
  private MockProcessor<Integer,String> processor;
  private final int[] expectedKeys={0,1,2,3};
  private StreamsBuilder builder;
  @Before public void setUp(){
    builder=new StreamsBuilder();
    final KStream<Integer,String> stream;
    final GlobalKTable<String,String> table;
    final KeyValueMapper<Integer,String,String> keyMapper;
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    final Consumed<Integer,String> streamConsumed=Consumed.with(Serdes.Integer(),Serdes.String());
    final Consumed<String,String> tableConsumed=Consumed.with(Serdes.String(),Serdes.String());
    stream=builder.stream(streamTopic,streamConsumed);
    table=builder.globalTable(globalTableTopic,tableConsumed);
    keyMapper=new KeyValueMapper<Integer,String,String>(){
      @Override public String apply(      final Integer key,      final String value){
        final String[] tokens=value.split(",");
        return tokens.length > 1 ? tokens[1] : null;
      }
    }
;
    stream.join(table,keyMapper,MockValueJoiner.TOSTRING_JOINER).process(supplier);
    final Properties props=StreamsTestUtils.getStreamsConfig(Serdes.Integer(),Serdes.String());
    driver=new TopologyTestDriver(builder.build(),props);
    processor=supplier.theCapturedProcessor();
  }
  @After public void cleanup(){
    driver.close();
  }
  private void pushToStream(  final int messageCount,  final String valuePrefix,  final boolean includeForeignKey){
    final ConsumerRecordFactory<Integer,String> recordFactory=new ConsumerRecordFactory<>(new IntegerSerializer(),new StringSerializer());
    for (int i=0; i < messageCount; i++) {
      String value=valuePrefix + expectedKeys[i];
      if (includeForeignKey) {
        value=value + ",FKey" + expectedKeys[i];
      }
      driver.pipeInput(recordFactory.create(streamTopic,expectedKeys[i],value));
    }
  }
  private void pushToGlobalTable(  final int messageCount,  final String valuePrefix){
    final ConsumerRecordFactory<String,String> recordFactory=new ConsumerRecordFactory<>(new StringSerializer(),new StringSerializer());
    for (int i=0; i < messageCount; i++) {
      driver.pipeInput(recordFactory.create(globalTableTopic,"FKey" + expectedKeys[i],valuePrefix + expectedKeys[i]));
    }
  }
  private void pushNullValueToGlobalTable(  final int messageCount){
    final ConsumerRecordFactory<String,String> recordFactory=new ConsumerRecordFactory<>(new StringSerializer(),new StringSerializer());
    for (int i=0; i < messageCount; i++) {
      driver.pipeInput(recordFactory.create(globalTableTopic,"FKey" + expectedKeys[i],(String)null));
    }
  }
  @Test public void shouldNotRequireCopartitioning(){
    final Collection<Set<String>> copartitionGroups=TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();
    assertEquals("KStream-GlobalKTable joins do not need to be co-partitioned",0,copartitionGroups.size());
  }
  @Test public void shouldNotJoinWithEmptyGlobalTableOnStreamUpdates(){
    pushToStream(2,"X",true);
    processor.checkAndClearProcessResult();
  }
  @Test public void shouldNotJoinOnGlobalTableUpdates(){
    pushToStream(2,"X",true);
    processor.checkAndClearProcessResult();
    pushToGlobalTable(2,"Y");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X",true);
    processor.checkAndClearProcessResult("0:X0,FKey0+Y0","1:X1,FKey1+Y1");
    pushToGlobalTable(4,"YY");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X",true);
    processor.checkAndClearProcessResult("0:X0,FKey0+YY0","1:X1,FKey1+YY1","2:X2,FKey2+YY2","3:X3,FKey3+YY3");
    pushToGlobalTable(4,"YYY");
    processor.checkAndClearProcessResult();
  }
  @Test public void shouldJoinOnlyIfMatchFoundOnStreamUpdates(){
    pushToGlobalTable(2,"Y");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X",true);
    processor.checkAndClearProcessResult("0:X0,FKey0+Y0","1:X1,FKey1+Y1");
  }
  @Test public void shouldClearGlobalTableEntryOnNullValueUpdates(){
    pushToGlobalTable(4,"Y");
    processor.checkAndClearProcessResult();
    pushToStream(4,"X",true);
    processor.checkAndClearProcessResult("0:X0,FKey0+Y0","1:X1,FKey1+Y1","2:X2,FKey2+Y2","3:X3,FKey3+Y3");
    pushNullValueToGlobalTable(2);
    processor.checkAndClearProcessResult();
    pushToStream(4,"XX",true);
    processor.checkAndClearProcessResult("2:XX2,FKey2+Y2","3:XX3,FKey3+Y3");
  }
  @Test public void shouldNotJoinOnNullKeyMapperValues(){
    pushToGlobalTable(4,"Y");
    processor.checkAndClearProcessResult();
    pushToStream(4,"XXX",false);
    processor.checkAndClearProcessResult();
  }
}
