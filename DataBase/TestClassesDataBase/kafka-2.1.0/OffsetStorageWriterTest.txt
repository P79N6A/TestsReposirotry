@RunWith(PowerMockRunner.class) public class OffsetStorageWriterTest {
  private static final String NAMESPACE="namespace";
  private static final Map<String,String> OFFSET_KEY=Collections.singletonMap("key","key");
  private static final Map<String,Integer> OFFSET_VALUE=Collections.singletonMap("key",12);
  private static final byte[] OFFSET_KEY_SERIALIZED="key-serialized".getBytes();
  private static final byte[] OFFSET_VALUE_SERIALIZED="value-serialized".getBytes();
  @Mock private OffsetBackingStore store;
  @Mock private Converter keyConverter;
  @Mock private Converter valueConverter;
  private OffsetStorageWriter writer;
  private static Exception exception=new RuntimeException("error");
  private ExecutorService service;
  @Before public void setup(){
    writer=new OffsetStorageWriter(store,NAMESPACE,keyConverter,valueConverter);
    service=Executors.newFixedThreadPool(1);
  }
  @After public void teardown(){
    service.shutdownNow();
  }
  @Test public void testWriteFlush() throws Exception {
    @SuppressWarnings("unchecked") Callback<Void> callback=PowerMock.createMock(Callback.class);
    expectStore(OFFSET_KEY,OFFSET_KEY_SERIALIZED,OFFSET_VALUE,OFFSET_VALUE_SERIALIZED,callback,false,null);
    PowerMock.replayAll();
    writer.offset(OFFSET_KEY,OFFSET_VALUE);
    assertTrue(writer.beginFlush());
    writer.doFlush(callback).get(1000,TimeUnit.MILLISECONDS);
    PowerMock.verifyAll();
  }
  @Test public void testWriteNullValueFlush() throws Exception {
    @SuppressWarnings("unchecked") Callback<Void> callback=PowerMock.createMock(Callback.class);
    expectStore(OFFSET_KEY,OFFSET_KEY_SERIALIZED,null,null,callback,false,null);
    PowerMock.replayAll();
    writer.offset(OFFSET_KEY,null);
    assertTrue(writer.beginFlush());
    writer.doFlush(callback).get(1000,TimeUnit.MILLISECONDS);
    PowerMock.verifyAll();
  }
  @Test public void testWriteNullKeyFlush() throws Exception {
    @SuppressWarnings("unchecked") Callback<Void> callback=PowerMock.createMock(Callback.class);
    expectStore(null,null,OFFSET_VALUE,OFFSET_VALUE_SERIALIZED,callback,false,null);
    PowerMock.replayAll();
    writer.offset(null,OFFSET_VALUE);
    assertTrue(writer.beginFlush());
    writer.doFlush(callback).get(1000,TimeUnit.MILLISECONDS);
    PowerMock.verifyAll();
  }
  @Test public void testNoOffsetsToFlush(){
    PowerMock.replayAll();
    assertFalse(writer.beginFlush());
    PowerMock.verifyAll();
  }
  @Test public void testFlushFailureReplacesOffsets() throws Exception {
    @SuppressWarnings("unchecked") final Callback<Void> callback=PowerMock.createMock(Callback.class);
    expectStore(OFFSET_KEY,OFFSET_KEY_SERIALIZED,OFFSET_VALUE,OFFSET_VALUE_SERIALIZED,callback,true,null);
    expectStore(OFFSET_KEY,OFFSET_KEY_SERIALIZED,OFFSET_VALUE,OFFSET_VALUE_SERIALIZED,callback,false,null);
    PowerMock.replayAll();
    writer.offset(OFFSET_KEY,OFFSET_VALUE);
    assertTrue(writer.beginFlush());
    writer.doFlush(callback).get(1000,TimeUnit.MILLISECONDS);
    assertTrue(writer.beginFlush());
    writer.doFlush(callback).get(1000,TimeUnit.MILLISECONDS);
    assertFalse(writer.beginFlush());
    PowerMock.verifyAll();
  }
  @Test(expected=ConnectException.class) public void testAlreadyFlushing() throws Exception {
    @SuppressWarnings("unchecked") final Callback<Void> callback=PowerMock.createMock(Callback.class);
    CountDownLatch allowStoreCompleteCountdown=new CountDownLatch(1);
    expectStore(OFFSET_KEY,OFFSET_KEY_SERIALIZED,OFFSET_VALUE,OFFSET_VALUE_SERIALIZED,null,false,allowStoreCompleteCountdown);
    PowerMock.replayAll();
    writer.offset(OFFSET_KEY,OFFSET_VALUE);
    assertTrue(writer.beginFlush());
    writer.doFlush(callback);
    assertTrue(writer.beginFlush());
    PowerMock.verifyAll();
  }
  @Test public void testCancelBeforeAwaitFlush(){
    PowerMock.replayAll();
    writer.offset(OFFSET_KEY,OFFSET_VALUE);
    assertTrue(writer.beginFlush());
    writer.cancelFlush();
    PowerMock.verifyAll();
  }
  @Test public void testCancelAfterAwaitFlush() throws Exception {
    @SuppressWarnings("unchecked") Callback<Void> callback=PowerMock.createMock(Callback.class);
    CountDownLatch allowStoreCompleteCountdown=new CountDownLatch(1);
    expectStore(OFFSET_KEY,OFFSET_KEY_SERIALIZED,OFFSET_VALUE,OFFSET_VALUE_SERIALIZED,null,false,allowStoreCompleteCountdown);
    PowerMock.replayAll();
    writer.offset(OFFSET_KEY,OFFSET_VALUE);
    assertTrue(writer.beginFlush());
    Future<Void> flushFuture=writer.doFlush(callback);
    writer.cancelFlush();
    allowStoreCompleteCountdown.countDown();
    flushFuture.get(1000,TimeUnit.MILLISECONDS);
    PowerMock.verifyAll();
  }
  /** 
 * Expect a request to store data to the underlying OffsetBackingStore.
 * @param key the key for the offset
 * @param keySerialized serialized version of the key
 * @param value the value for the offset
 * @param valueSerialized serialized version of the value
 * @param callback the callback to invoke when completed, or null if the callback isn'texpected to be invoked
 * @param fail if true, treat
 * @param waitForCompletion if non-null, a CountDownLatch that should be awaited on beforeinvoking the callback. A (generous) timeout is still imposed to ensure tests complete.
 * @return the captured set of ByteBuffer key-value pairs passed to the storage layer
 */
  private void expectStore(  Map<String,String> key,  byte[] keySerialized,  Map<String,Integer> value,  byte[] valueSerialized,  final Callback<Void> callback,  final boolean fail,  final CountDownLatch waitForCompletion){
    List<Object> keyWrapped=Arrays.asList(NAMESPACE,key);
    EasyMock.expect(keyConverter.fromConnectData(NAMESPACE,null,keyWrapped)).andReturn(keySerialized);
    EasyMock.expect(valueConverter.fromConnectData(NAMESPACE,null,value)).andReturn(valueSerialized);
    final Capture<Callback<Void>> storeCallback=Capture.newInstance();
    final Map<ByteBuffer,ByteBuffer> offsetsSerialized=Collections.singletonMap(keySerialized == null ? null : ByteBuffer.wrap(keySerialized),valueSerialized == null ? null : ByteBuffer.wrap(valueSerialized));
    EasyMock.expect(store.set(EasyMock.eq(offsetsSerialized),EasyMock.capture(storeCallback))).andAnswer(new IAnswer<Future<Void>>(){
      @Override public Future<Void> answer() throws Throwable {
        return service.submit(new Callable<Void>(){
          @Override public Void call() throws Exception {
            if (waitForCompletion != null)             assertTrue(waitForCompletion.await(10000,TimeUnit.MILLISECONDS));
            if (fail) {
              storeCallback.getValue().onCompletion(exception,null);
            }
 else {
              storeCallback.getValue().onCompletion(null,null);
            }
            return null;
          }
        }
);
      }
    }
);
    if (callback != null) {
      if (fail) {
        callback.onCompletion(EasyMock.eq(exception),EasyMock.eq((Void)null));
      }
 else {
        callback.onCompletion(null,null);
      }
    }
    PowerMock.expectLastCall();
  }
}
