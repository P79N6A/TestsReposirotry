public class CopartitionedTopicsValidatorTest {
  private final StreamsPartitionAssignor.CopartitionedTopicsValidator validator=new StreamsPartitionAssignor.CopartitionedTopicsValidator("thread");
  private final Map<TopicPartition,PartitionInfo> partitions=new HashMap<>();
  private final Cluster cluster=Cluster.empty();
  @Before public void before(){
    partitions.put(new TopicPartition("first",0),new PartitionInfo("first",0,null,null,null));
    partitions.put(new TopicPartition("first",1),new PartitionInfo("first",1,null,null,null));
    partitions.put(new TopicPartition("second",0),new PartitionInfo("second",0,null,null,null));
    partitions.put(new TopicPartition("second",1),new PartitionInfo("second",1,null,null,null));
  }
  @Test(expected=IllegalStateException.class) public void shouldThrowTopologyBuilderExceptionIfNoPartitionsFoundForCoPartitionedTopic(){
    validator.validate(Collections.singleton("topic"),Collections.<String,StreamsPartitionAssignor.InternalTopicMetadata>emptyMap(),cluster);
  }
  @Test(expected=TopologyException.class) public void shouldThrowTopologyBuilderExceptionIfPartitionCountsForCoPartitionedTopicsDontMatch(){
    partitions.remove(new TopicPartition("second",0));
    validator.validate(Utils.mkSet("first","second"),Collections.<String,StreamsPartitionAssignor.InternalTopicMetadata>emptyMap(),cluster.withPartitions(partitions));
  }
  @Test public void shouldEnforceCopartitioningOnRepartitionTopics(){
    final StreamsPartitionAssignor.InternalTopicMetadata metadata=createTopicMetadata("repartitioned",10);
    validator.validate(Utils.mkSet("first","second",metadata.config.name()),Collections.singletonMap(metadata.config.name(),metadata),cluster.withPartitions(partitions));
    assertThat(metadata.numPartitions,equalTo(2));
  }
  @Test public void shouldSetNumPartitionsToMaximumPartitionsWhenAllTopicsAreRepartitionTopics(){
    final StreamsPartitionAssignor.InternalTopicMetadata one=createTopicMetadata("one",1);
    final StreamsPartitionAssignor.InternalTopicMetadata two=createTopicMetadata("two",15);
    final StreamsPartitionAssignor.InternalTopicMetadata three=createTopicMetadata("three",5);
    final Map<String,StreamsPartitionAssignor.InternalTopicMetadata> repartitionTopicConfig=new HashMap<>();
    repartitionTopicConfig.put(one.config.name(),one);
    repartitionTopicConfig.put(two.config.name(),two);
    repartitionTopicConfig.put(three.config.name(),three);
    validator.validate(Utils.mkSet(one.config.name(),two.config.name(),three.config.name()),repartitionTopicConfig,cluster);
    assertThat(one.numPartitions,equalTo(15));
    assertThat(two.numPartitions,equalTo(15));
    assertThat(three.numPartitions,equalTo(15));
  }
  private StreamsPartitionAssignor.InternalTopicMetadata createTopicMetadata(  final String repartitionTopic,  final int partitions){
    final InternalTopicConfig repartitionTopicConfig=new RepartitionTopicConfig(repartitionTopic,Collections.<String,String>emptyMap());
    final StreamsPartitionAssignor.InternalTopicMetadata metadata=new StreamsPartitionAssignor.InternalTopicMetadata(repartitionTopicConfig);
    metadata.numPartitions=partitions;
    return metadata;
  }
}
