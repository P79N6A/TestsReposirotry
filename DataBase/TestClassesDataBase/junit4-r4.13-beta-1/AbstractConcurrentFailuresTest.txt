private abstract class AbstractConcurrentFailuresTest {
  protected abstract void addListener(  ExaminedListener listener);
  public void test() throws Exception {
    int totalListenersFailures=0;
    Random random=new Random(42);
    ExaminedListener[] examinedListeners=new ExaminedListener[1000];
    for (int i=0; i < examinedListeners.length; ++i) {
      boolean fail=random.nextDouble() >= 0.5d;
      if (fail) {
        ++totalListenersFailures;
      }
      examinedListeners[i]=new ExaminedListener(fail);
    }
    final AtomicBoolean condition=new AtomicBoolean(true);
    final CyclicBarrier trigger=new CyclicBarrier(2);
    final CountDownLatch latch=new CountDownLatch(10);
    ExecutorService notificationsPool=Executors.newFixedThreadPool(4);
    notificationsPool.submit(new Callable<Void>(){
      public Void call() throws Exception {
        trigger.await();
        while (condition.get()) {
          fNotifier.fireTestStarted(null);
          latch.countDown();
        }
        fNotifier.fireTestStarted(null);
        return null;
      }
    }
);
    trigger.await(TIMEOUT,TimeUnit.SECONDS);
    latch.await(TIMEOUT,TimeUnit.SECONDS);
    for (    ExaminedListener examinedListener : examinedListeners) {
      addListener(examinedListener);
    }
    notificationsPool.shutdown();
    condition.set(false);
    assertTrue(notificationsPool.awaitTermination(TIMEOUT,TimeUnit.SECONDS));
    if (totalListenersFailures != 0) {
      int countTestFailures=examinedListeners.length - countReportedTestFailures(examinedListeners);
      assertThat(totalListenersFailures,is(countTestFailures));
    }
  }
}
