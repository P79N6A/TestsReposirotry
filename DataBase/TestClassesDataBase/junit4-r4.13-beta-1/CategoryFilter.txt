public static class CategoryFilter extends Filter {
  private final Set<Class<?>> included;
  private final Set<Class<?>> excluded;
  private final boolean includedAny;
  private final boolean excludedAny;
  public static CategoryFilter include(  boolean matchAny,  Class<?>... categories){
    return new CategoryFilter(matchAny,categories,true,null);
  }
  public static CategoryFilter include(  Class<?> category){
    return include(true,category);
  }
  public static CategoryFilter include(  Class<?>... categories){
    return include(true,categories);
  }
  public static CategoryFilter exclude(  boolean matchAny,  Class<?>... categories){
    return new CategoryFilter(true,null,matchAny,categories);
  }
  public static CategoryFilter exclude(  Class<?> category){
    return exclude(true,category);
  }
  public static CategoryFilter exclude(  Class<?>... categories){
    return exclude(true,categories);
  }
  public static CategoryFilter categoryFilter(  boolean matchAnyInclusions,  Set<Class<?>> inclusions,  boolean matchAnyExclusions,  Set<Class<?>> exclusions){
    return new CategoryFilter(matchAnyInclusions,inclusions,matchAnyExclusions,exclusions);
  }
  @Deprecated public CategoryFilter(  Class<?> includedCategory,  Class<?> excludedCategory){
    includedAny=true;
    excludedAny=true;
    included=nullableClassToSet(includedCategory);
    excluded=nullableClassToSet(excludedCategory);
  }
  protected CategoryFilter(  boolean matchAnyIncludes,  Set<Class<?>> includes,  boolean matchAnyExcludes,  Set<Class<?>> excludes){
    includedAny=matchAnyIncludes;
    excludedAny=matchAnyExcludes;
    included=copyAndRefine(includes);
    excluded=copyAndRefine(excludes);
  }
  private CategoryFilter(  boolean matchAnyIncludes,  Class<?>[] inclusions,  boolean matchAnyExcludes,  Class<?>[] exclusions){
    includedAny=matchAnyIncludes;
    excludedAny=matchAnyExcludes;
    included=createSet(inclusions);
    excluded=createSet(exclusions);
  }
  /** 
 * @see #toString()
 */
  @Override public String describe(){
    return toString();
  }
  /** 
 * Returns string in the form <tt>&quot;[included categories] - [excluded categories]&quot;</tt>, where both sets have comma separated names of categories.
 * @return string representation for the relative complement of excluded categories setin the set of included categories. Examples: <ul> <li> <tt>&quot;categories [all]&quot;</tt> for all included categories and no excluded ones; <li> <tt>&quot;categories [all] - [A, B]&quot;</tt> for all included categories and given excluded ones; <li> <tt>&quot;categories [A, B] - [C, D]&quot;</tt> for given included categories and given excluded ones. </ul>
 * @see Class#toString() name of category
 */
  @Override public String toString(){
    StringBuilder description=new StringBuilder("categories ").append(included.isEmpty() ? "[all]" : included);
    if (!excluded.isEmpty()) {
      description.append(" - ").append(excluded);
    }
    return description.toString();
  }
  @Override public boolean shouldRun(  Description description){
    if (hasCorrectCategoryAnnotation(description)) {
      return true;
    }
    for (    Description each : description.getChildren()) {
      if (shouldRun(each)) {
        return true;
      }
    }
    return false;
  }
  private boolean hasCorrectCategoryAnnotation(  Description description){
    final Set<Class<?>> childCategories=categories(description);
    if (childCategories.isEmpty()) {
      return included.isEmpty();
    }
    if (!excluded.isEmpty()) {
      if (excludedAny) {
        if (matchesAnyParentCategories(childCategories,excluded)) {
          return false;
        }
      }
 else {
        if (matchesAllParentCategories(childCategories,excluded)) {
          return false;
        }
      }
    }
    if (included.isEmpty()) {
      return true;
    }
 else {
      if (includedAny) {
        return matchesAnyParentCategories(childCategories,included);
      }
 else {
        return matchesAllParentCategories(childCategories,included);
      }
    }
  }
  /** 
 * @return <tt>true</tt> if at least one (any) parent category match a child, otherwise <tt>false</tt>.If empty <tt>parentCategories</tt>, returns <tt>false</tt>.
 */
  private boolean matchesAnyParentCategories(  Set<Class<?>> childCategories,  Set<Class<?>> parentCategories){
    for (    Class<?> parentCategory : parentCategories) {
      if (hasAssignableTo(childCategories,parentCategory)) {
        return true;
      }
    }
    return false;
  }
  /** 
 * @return <tt>false</tt> if at least one parent category does not match children, otherwise <tt>true</tt>.If empty <tt>parentCategories</tt>, returns <tt>true</tt>.
 */
  private boolean matchesAllParentCategories(  Set<Class<?>> childCategories,  Set<Class<?>> parentCategories){
    for (    Class<?> parentCategory : parentCategories) {
      if (!hasAssignableTo(childCategories,parentCategory)) {
        return false;
      }
    }
    return true;
  }
  private static Set<Class<?>> categories(  Description description){
    Set<Class<?>> categories=new HashSet<Class<?>>();
    Collections.addAll(categories,directCategories(description));
    Collections.addAll(categories,directCategories(parentDescription(description)));
    return categories;
  }
  private static Description parentDescription(  Description description){
    Class<?> testClass=description.getTestClass();
    return testClass == null ? null : Description.createSuiteDescription(testClass);
  }
  private static Class<?>[] directCategories(  Description description){
    if (description == null) {
      return new Class<?>[0];
    }
    Category annotation=description.getAnnotation(Category.class);
    return annotation == null ? new Class<?>[0] : annotation.value();
  }
  private static Set<Class<?>> copyAndRefine(  Set<Class<?>> classes){
    Set<Class<?>> c=new LinkedHashSet<Class<?>>();
    if (classes != null) {
      c.addAll(classes);
    }
    c.remove(null);
    return c;
  }
}
