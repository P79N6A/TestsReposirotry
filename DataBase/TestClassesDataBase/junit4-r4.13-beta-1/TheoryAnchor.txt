public static class TheoryAnchor extends Statement {
  private int successes=0;
  private final FrameworkMethod testMethod;
  private final TestClass testClass;
  private List<AssumptionViolatedException> fInvalidParameters=new ArrayList<AssumptionViolatedException>();
  public TheoryAnchor(  FrameworkMethod testMethod,  TestClass testClass){
    this.testMethod=testMethod;
    this.testClass=testClass;
  }
  private TestClass getTestClass(){
    return testClass;
  }
  @Override public void evaluate() throws Throwable {
    runWithAssignment(Assignments.allUnassigned(testMethod.getMethod(),getTestClass()));
    boolean hasTheoryAnnotation=testMethod.getAnnotation(Theory.class) != null;
    if (successes == 0 && hasTheoryAnnotation) {
      Assert.fail("Never found parameters that satisfied method assumptions.  Violated assumptions: " + fInvalidParameters);
    }
  }
  protected void runWithAssignment(  Assignments parameterAssignment) throws Throwable {
    if (!parameterAssignment.isComplete()) {
      runWithIncompleteAssignment(parameterAssignment);
    }
 else {
      runWithCompleteAssignment(parameterAssignment);
    }
  }
  protected void runWithIncompleteAssignment(  Assignments incomplete) throws Throwable {
    for (    PotentialAssignment source : incomplete.potentialsForNextUnassigned()) {
      runWithAssignment(incomplete.assignNext(source));
    }
  }
  protected void runWithCompleteAssignment(  final Assignments complete) throws Throwable {
    new BlockJUnit4ClassRunner(getTestClass()){
      @Override protected void collectInitializationErrors(      List<Throwable> errors){
      }
      @Override public Statement methodBlock(      FrameworkMethod method){
        final Statement statement=super.methodBlock(method);
        return new Statement(){
          @Override public void evaluate() throws Throwable {
            try {
              statement.evaluate();
              handleDataPointSuccess();
            }
 catch (            AssumptionViolatedException e) {
              handleAssumptionViolation(e);
            }
catch (            Throwable e) {
              reportParameterizedError(e,complete.getArgumentStrings(nullsOk()));
            }
          }
        }
;
      }
      @Override protected Statement methodInvoker(      FrameworkMethod method,      Object test){
        return methodCompletesWithParameters(method,complete,test);
      }
      @Override public Object createTest() throws Exception {
        Object[] params=complete.getConstructorArguments();
        if (!nullsOk()) {
          Assume.assumeNotNull(params);
        }
        return getTestClass().getOnlyConstructor().newInstance(params);
      }
    }
.methodBlock(testMethod).evaluate();
  }
  private Statement methodCompletesWithParameters(  final FrameworkMethod method,  final Assignments complete,  final Object freshInstance){
    return new Statement(){
      @Override public void evaluate() throws Throwable {
        final Object[] values=complete.getMethodArguments();
        if (!nullsOk()) {
          Assume.assumeNotNull(values);
        }
        method.invokeExplosively(freshInstance,values);
      }
    }
;
  }
  protected void handleAssumptionViolation(  AssumptionViolatedException e){
    fInvalidParameters.add(e);
  }
  protected void reportParameterizedError(  Throwable e,  Object... params) throws Throwable {
    if (params.length == 0) {
      throw e;
    }
    throw new ParameterizedAssertionError(e,testMethod.getName(),params);
  }
  private boolean nullsOk(){
    Theory annotation=testMethod.getMethod().getAnnotation(Theory.class);
    if (annotation == null) {
      return false;
    }
    return annotation.nullsAccepted();
  }
  protected void handleDataPointSuccess(){
    successes++;
  }
}
