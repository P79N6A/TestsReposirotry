@RunWith(Parameterized.class) public static class Callbacks {
  @Parameters(name="{0}") public static Object[][] parameters(){
    return new Object[][]{{FailingTest.class,"starting failed finished ",asList("starting failed","test failed","failed failed","finished failed")},{InternalViolatedAssumptionTest.class,"starting deprecated skipped finished ",asList("starting failed","don't run","deprecated skipped failed","finished failed")},{SuccessfulTest.class,"starting succeeded finished ",asList("starting failed","succeeded failed","finished failed")},{ViolatedAssumptionTest.class,"starting skipped finished ",asList("starting failed","Test could not be skipped due to other failures","skipped failed","finished failed")}};
  }
  @Parameter(0) public Class<?> testClass;
  @Parameter(1) public String expectedCallbacks;
  @Parameter(2) public List<String> expectedFailures;
  private static TestRule selectedRule;
  @Test public void correctCallbacksCalled(){
    StringBuilder log=new StringBuilder();
    selectedRule=new LoggingTestWatcher(log);
    JUnitCore.runClasses(testClass);
    assertEquals(expectedCallbacks,log.toString());
  }
  @Test public void resultHasAllFailuresThrownByCallbacks(){
    selectedRule=new ErroneousTestWatcher();
    PrintableResult result=testResult(testClass);
    assertThat(result,failureCountIs(expectedFailures.size()));
    for (    String expectedFailure : expectedFailures) {
      assertThat(result,hasFailureContaining(expectedFailure));
    }
  }
  @Test public void testWatcherDoesNotModifyResult(){
    selectedRule=new NoOpRule();
    Result resultNoOpRule=JUnitCore.runClasses(testClass);
    selectedRule=new LoggingTestWatcher(new StringBuilder());
    Result resultTestWatcher=JUnitCore.runClasses(testClass);
    assertEquals("was successful",resultNoOpRule.wasSuccessful(),resultTestWatcher.wasSuccessful());
    assertEquals("failure count",resultNoOpRule.getFailureCount(),resultTestWatcher.getFailureCount());
    assertEquals("ignore count",resultNoOpRule.getIgnoreCount(),resultTestWatcher.getIgnoreCount());
    assertEquals("run count",resultNoOpRule.getRunCount(),resultTestWatcher.getRunCount());
  }
private static class NoOpRule implements TestRule {
    public Statement apply(    Statement base,    Description description){
      return base;
    }
  }
private static class ErroneousTestWatcher extends TestWatcher {
    @Override protected void succeeded(    Description description){
      throw new RuntimeException("succeeded failed");
    }
    @Override protected void failed(    Throwable e,    Description description){
      throw new RuntimeException("failed failed");
    }
    @Override protected void skipped(    org.junit.AssumptionViolatedException e,    Description description){
      throw new RuntimeException("skipped failed");
    }
    @Override @SuppressWarnings("deprecation") protected void skipped(    AssumptionViolatedException e,    Description description){
      throw new RuntimeException("deprecated skipped failed");
    }
    @Override protected void starting(    Description description){
      throw new RuntimeException("starting failed");
    }
    @Override protected void finished(    Description description){
      throw new RuntimeException("finished failed");
    }
  }
public static class FailingTest {
    @Rule public TestRule rule=selectedRule;
    @Test public void test(){
      fail("test failed");
    }
  }
public static class InternalViolatedAssumptionTest {
    @Rule public TestRule watcher=selectedRule;
    @SuppressWarnings("deprecation") @Test public void test(){
      throw new AssumptionViolatedException("don't run");
    }
  }
public static class SuccessfulTest {
    @Rule public TestRule watcher=selectedRule;
    @Test public void test(){
    }
  }
public static class ViolatedAssumptionTest {
    @Rule public TestRule watcher=selectedRule;
    @Test public void test(){
      assumeTrue(false);
    }
  }
}
