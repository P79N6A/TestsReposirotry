public class WithDataPointMethod {
@RunWith(Theories.class) public static class HasDataPointMethod {
    @DataPoint public static int oneHundred(){
      return 100;
    }
    @Theory public void allIntsOk(    int x){
    }
  }
  @Test public void pickUpDataPointMethods(){
    assertThat(testResult(HasDataPointMethod.class),isSuccessful());
  }
@RunWith(Theories.class) public static class DataPointMethodReturnsMutableObject {
    @DataPoint public static List<Object> empty(){
      return new ArrayList<Object>();
    }
    @DataPoint public static int ONE=1;
    @DataPoint public static int TWO=2;
    @Theory public void everythingsEmpty(    List<Object> first,    int number){
      assertThat(first.size(),is(0));
      first.add("a");
    }
  }
  @Test public void mutableObjectsAreCreatedAfresh(){
    assertThat(failures(DataPointMethodReturnsMutableObject.class),empty());
  }
@RunWith(Theories.class) public static class HasDateMethod {
    @DataPoint public static int oneHundred(){
      return 100;
    }
    public static Date notADataPoint(){
      return new Date();
    }
    @Theory public void allIntsOk(    int x){
    }
    @Theory public void onlyStringsOk(    String s){
    }
    @Theory public void onlyDatesOk(    Date d){
    }
  }
  @Test public void ignoreDataPointMethodsWithWrongTypes() throws Throwable {
    assertThat(potentialAssignments(HasDateMethod.class.getMethod("onlyStringsOk",String.class)).toString(),not(containsString("100")));
  }
  @Test public void ignoreDataPointMethodsWithoutAnnotation() throws Throwable {
    assertThat(potentialAssignments(HasDateMethod.class.getMethod("onlyDatesOk",Date.class)).size(),is(0));
  }
  private List<Failure> failures(  Class<?> type){
    return JUnitCore.runClasses(type).getFailures();
  }
  private Matcher<Iterable<Failure>> empty(){
    return everyItem(nullValue(Failure.class));
  }
}
