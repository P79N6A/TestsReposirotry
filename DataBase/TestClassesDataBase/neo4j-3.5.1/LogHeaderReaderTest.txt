public class LogHeaderReaderTest {
  private final long expectedLogVersion=CURRENT_LOG_VERSION;
  private final long expectedTxId=42;
  @Rule public final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  @Test public void shouldReadALogHeaderFromAByteChannel() throws IOException {
    final ByteBuffer buffer=ByteBuffer.allocate(LOG_HEADER_SIZE);
    final ReadableByteChannel channel=mock(ReadableByteChannel.class);
    when(channel.read(buffer)).thenAnswer(invocation -> {
      buffer.putLong(encodeLogVersion(expectedLogVersion));
      buffer.putLong(expectedTxId);
      return 8 + 8;
    }
);
    final LogHeader result=readLogHeader(buffer,channel,true,null);
    assertEquals(new LogHeader(CURRENT_LOG_VERSION,expectedLogVersion,expectedTxId),result);
  }
  @Test public void shouldFailWhenUnableToReadALogHeaderFromAChannel() throws IOException {
    final ByteBuffer buffer=ByteBuffer.allocate(LOG_HEADER_SIZE);
    final ReadableByteChannel channel=mock(ReadableByteChannel.class);
    when(channel.read(buffer)).thenReturn(1);
    try {
      readLogHeader(buffer,channel,true,null);
      fail("should have thrown");
    }
 catch (    IncompleteLogHeaderException ex) {
    }
  }
  @Test public void shouldReadALogHeaderFromAFile() throws IOException {
    final File file=testDirectory.file("ReadLogHeader");
    final ByteBuffer buffer=ByteBuffer.allocate(LOG_HEADER_SIZE);
    buffer.putLong(encodeLogVersion(expectedLogVersion));
    buffer.putLong(expectedTxId);
    try (OutputStream stream=fileSystemRule.get().openAsOutputStream(file,false)){
      stream.write(buffer.array());
    }
     final LogHeader result=readLogHeader(fileSystemRule.get(),file);
    assertEquals(new LogHeader(CURRENT_LOG_VERSION,expectedLogVersion,expectedTxId),result);
  }
  @Test public void shouldFailWhenUnableToReadALogHeaderFromAFile() throws IOException {
    final File file=testDirectory.file("ReadLogHeader");
    fileSystemRule.create(file).close();
    try {
      readLogHeader(fileSystemRule.get(),file);
      fail("should have thrown");
    }
 catch (    IncompleteLogHeaderException ex) {
      assertTrue(ex.getMessage(),ex.getMessage().contains(file.getName()));
    }
  }
  @Test public void shouldReadALongString() throws IOException {
    int stringSize=32 * 1024 + 1;
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < stringSize; i++) {
      sb.append("x");
    }
    String lengthyString=sb.toString();
    InMemoryClosableChannel channel=new InMemoryClosableChannel(stringSize + 3);
    IoPrimitiveUtils.write3bLengthAndString(channel,lengthyString);
    String stringFromChannel=IoPrimitiveUtils.read3bLengthAndString(channel);
    assertEquals(lengthyString,stringFromChannel);
  }
}
