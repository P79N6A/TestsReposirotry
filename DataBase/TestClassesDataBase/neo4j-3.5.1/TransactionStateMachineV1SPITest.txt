public class TransactionStateMachineV1SPITest {
  @Rule public final OtherThreadRule<Void> otherThread=new OtherThreadRule<>();
  @Test public void throwsWhenTxAwaitDurationExpires(){
    long lastClosedTransactionId=100;
    Supplier<TransactionIdStore> txIdStore=() -> fixedTxIdStore(lastClosedTransactionId);
    Duration txAwaitDuration=Duration.ofSeconds(42);
    FakeClock clock=new FakeClock();
    DatabaseAvailabilityGuard databaseAvailabilityGuard=spy(new DatabaseAvailabilityGuard(DEFAULT_DATABASE_NAME,clock,NullLog.getInstance()));
    when(databaseAvailabilityGuard.isAvailable()).then(invocation -> {
      boolean available=(boolean)invocation.callRealMethod();
      clock.forward(txAwaitDuration.getSeconds() + 1,SECONDS);
      return available;
    }
);
    TransactionStateMachineV1SPI txSpi=createTxSpi(txIdStore,txAwaitDuration,databaseAvailabilityGuard,clock);
    Future<Void> result=otherThread.execute(state -> {
      txSpi.awaitUpToDate(lastClosedTransactionId + 42);
      return null;
    }
);
    try {
      result.get(20,SECONDS);
    }
 catch (    Exception e) {
      assertThat(e,instanceOf(ExecutionException.class));
      assertThat(e.getCause(),instanceOf(TransactionFailureException.class));
    }
  }
  @Test public void doesNotWaitWhenTxIdUpToDate() throws Exception {
    long lastClosedTransactionId=100;
    Supplier<TransactionIdStore> txIdStore=() -> fixedTxIdStore(lastClosedTransactionId);
    TransactionStateMachineV1SPI txSpi=createTxSpi(txIdStore,Duration.ZERO,Clock.systemUTC());
    Future<Void> result=otherThread.execute(state -> {
      txSpi.awaitUpToDate(lastClosedTransactionId - 42);
      return null;
    }
);
    assertNull(result.get(20,SECONDS));
  }
  private static TransactionIdStore fixedTxIdStore(  long lastClosedTransactionId){
    TransactionIdStore txIdStore=mock(TransactionIdStore.class);
    when(txIdStore.getLastClosedTransactionId()).thenReturn(lastClosedTransactionId);
    return txIdStore;
  }
  private static TransactionStateMachineV1SPI createTxSpi(  Supplier<TransactionIdStore> txIdStore,  Duration txAwaitDuration,  Clock clock){
    DatabaseAvailabilityGuard databaseAvailabilityGuard=new DatabaseAvailabilityGuard(DEFAULT_DATABASE_NAME,clock,NullLog.getInstance());
    return createTxSpi(txIdStore,txAwaitDuration,databaseAvailabilityGuard,clock);
  }
  private static TransactionStateMachineV1SPI createTxSpi(  Supplier<TransactionIdStore> txIdStore,  Duration txAwaitDuration,  DatabaseAvailabilityGuard availabilityGuard,  Clock clock){
    QueryExecutionEngine queryExecutionEngine=mock(QueryExecutionEngine.class);
    DependencyResolver dependencyResolver=mock(DependencyResolver.class);
    ThreadToStatementContextBridge bridge=new ThreadToStatementContextBridge(availabilityGuard);
    when(dependencyResolver.resolveDependency(ThreadToStatementContextBridge.class)).thenReturn(bridge);
    when(dependencyResolver.resolveDependency(QueryExecutionEngine.class)).thenReturn(queryExecutionEngine);
    when(dependencyResolver.resolveDependency(DatabaseAvailabilityGuard.class)).thenReturn(availabilityGuard);
    when(dependencyResolver.provideDependency(TransactionIdStore.class)).thenReturn(txIdStore);
    GraphDatabaseAPI db=mock(GraphDatabaseAPI.class);
    when(db.getDependencyResolver()).thenReturn(dependencyResolver);
    GraphDatabaseQueryService queryService=mock(GraphDatabaseQueryService.class);
    when(queryService.getDependencyResolver()).thenReturn(dependencyResolver);
    when(dependencyResolver.resolveDependency(GraphDatabaseQueryService.class)).thenReturn(queryService);
    BoltChannel boltChannel=new BoltChannel("bolt-42","bolt",new EmbeddedChannel());
    return new TransactionStateMachineV1SPI(db,boltChannel,txAwaitDuration,clock);
  }
}
