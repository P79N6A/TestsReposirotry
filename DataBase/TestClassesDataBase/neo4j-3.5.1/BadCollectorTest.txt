public class BadCollectorTest {
  @Rule public final EphemeralFileSystemRule fs=new EphemeralFileSystemRule();
  @Test public void shouldCollectBadRelationshipsEvenIfThresholdNeverReached() throws IOException {
    int tolerance=5;
    try (BadCollector badCollector=new BadCollector(badOutputFile(),tolerance,BadCollector.COLLECT_ALL)){
      badCollector.collectBadRelationship("1","a","T","2","b","1");
      assertEquals(1,badCollector.badEntries());
    }
   }
  @Test public void shouldThrowExceptionIfDuplicateNodeTipsUsOverTheToleranceEdge() throws IOException {
    int tolerance=1;
    try (BadCollector badCollector=new BadCollector(badOutputFile(),tolerance,BadCollector.COLLECT_ALL)){
      collectBadRelationship(badCollector);
      try {
        badCollector.collectDuplicateNode(1,1,"group");
        fail("Should have thrown an InputException");
      }
 catch (      InputException ignored) {
      }
    }
   }
  @Test public void shouldThrowExceptionIfBadRelationshipsTipsUsOverTheToleranceEdge() throws IOException {
    int tolerance=1;
    try (BadCollector badCollector=new BadCollector(badOutputFile(),tolerance,BadCollector.COLLECT_ALL)){
      badCollector.collectDuplicateNode(1,1,"group");
      try {
        collectBadRelationship(badCollector);
        fail("Should have thrown an InputException");
      }
 catch (      InputException ignored) {
      }
    }
   }
  @Test public void shouldNotCollectBadRelationshipsIfWeShouldOnlyBeCollectingNodes() throws IOException {
    int tolerance=1;
    try (BadCollector badCollector=new BadCollector(badOutputFile(),tolerance,BadCollector.DUPLICATE_NODES)){
      badCollector.collectDuplicateNode(1,1,"group");
      try {
        collectBadRelationship(badCollector);
      }
 catch (      InputException ignored) {
        assertEquals(1,badCollector.badEntries());
      }
    }
   }
  @Test public void shouldNotCollectBadNodesIfWeShouldOnlyBeCollectingRelationships() throws IOException {
    int tolerance=1;
    try (BadCollector badCollector=new BadCollector(badOutputFile(),tolerance,BadCollector.BAD_RELATIONSHIPS)){
      collectBadRelationship(badCollector);
      try {
        badCollector.collectDuplicateNode(1,1,"group");
      }
 catch (      InputException ignored) {
        assertEquals(1,badCollector.badEntries());
      }
    }
   }
  @Test public void shouldCollectUnlimitedNumberOfBadEntriesIfToldTo(){
    try (BadCollector collector=new BadCollector(NullOutputStream.NULL_OUTPUT_STREAM,UNLIMITED_TOLERANCE,COLLECT_ALL)){
      int count=10_000;
      for (int i=0; i < count; i++) {
        collector.collectDuplicateNode(i,i,"group");
      }
      assertEquals(count,collector.badEntries());
    }
   }
  @Test public void skipBadEntriesLogging(){
    ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
    try (BadCollector badCollector=new BadCollector(outputStream,100,COLLECT_ALL,true)){
      collectBadRelationship(badCollector);
      for (int i=0; i < 2; i++) {
        badCollector.collectDuplicateNode(i,i,"group");
      }
      collectBadRelationship(badCollector);
      badCollector.collectExtraColumns("a,b,c",1,"a");
      assertEquals("Output stream should not have any reported entries",0,outputStream.size());
    }
   }
  private void collectBadRelationship(  Collector collector){
    collector.collectBadRelationship("A",Group.GLOBAL.name(),"TYPE","B",Group.GLOBAL.name(),"A");
  }
  private OutputStream badOutputFile() throws IOException {
    File badDataPath=new File("/tmp/foo2").getAbsoluteFile();
    FileSystemAbstraction fileSystem=fs.get();
    File badDataFile=badDataFile(fileSystem,badDataPath);
    return fileSystem.openAsOutputStream(badDataFile,true);
  }
  private File badDataFile(  FileSystemAbstraction fileSystem,  File badDataPath) throws IOException {
    fileSystem.mkdir(badDataPath.getParentFile());
    fileSystem.create(badDataPath);
    return badDataPath;
  }
}
