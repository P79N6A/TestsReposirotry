public class AuthTokenUtil {
  @SuppressWarnings("unchecked") public static boolean matches(  Map<String,Object> expected,  Object actualObject){
    if (expected == null || actualObject == null) {
      return expected == actualObject;
    }
    if (!(actualObject instanceof Map<?,?>)) {
      return false;
    }
    Map<String,Object> actual=(Map<String,Object>)actualObject;
    if (expected.size() != actual.size()) {
      return false;
    }
    for (    Map.Entry<String,Object> expectedEntry : expected.entrySet()) {
      String key=expectedEntry.getKey();
      Object expectedValue=expectedEntry.getValue();
      Object actualValue=actual.get(key);
      if (AuthToken.containsSensitiveInformation(key)) {
        byte[] expectedByteArray=expectedValue instanceof byte[] ? (byte[])expectedValue : expectedValue != null ? UTF8.encode((String)expectedValue) : null;
        if (!Arrays.equals(expectedByteArray,(byte[])actualValue)) {
          return false;
        }
      }
 else       if (expectedValue == null || actualValue == null) {
        return expectedValue == actualValue;
      }
 else       if (!expectedValue.equals(actualValue)) {
        return false;
      }
    }
    return true;
  }
  public static void assertAuthTokenMatches(  Map<String,Object> expected,  Map<String,Object> actual){
    assertFalse(expected == null ^ actual == null);
    assertEquals(expected.keySet(),actual.keySet());
    expected.forEach((key,expectedValue) -> {
      Object actualValue=actual.get(key);
      if (AuthToken.containsSensitiveInformation(key)) {
        byte[] expectedByteArray=expectedValue != null ? UTF8.encode((String)expectedValue) : null;
        assertTrue(Arrays.equals(expectedByteArray,(byte[])actualValue));
      }
 else {
        assertEquals(expectedValue,actualValue);
      }
    }
);
  }
public static class AuthTokenMatcher extends BaseMatcher<Map<String,Object>> {
    private final Map<String,Object> expectedValue;
    public AuthTokenMatcher(    Map<String,Object> expectedValue){
      this.expectedValue=expectedValue;
    }
    @Override public boolean matches(    Object o){
      return AuthTokenUtil.matches(expectedValue,o);
    }
    @Override public void describeTo(    Description description){
      description.appendValue(this.expectedValue);
    }
  }
  public static AuthTokenMatcher authTokenMatcher(  Map<String,Object> authToken){
    return new AuthTokenMatcher(authToken);
  }
public static class AuthTokenArgumentMatcher implements ArgumentMatcher<Map<String,Object>>, Serializable {
    private Map<String,Object> wanted;
    public AuthTokenArgumentMatcher(    Map<String,Object> authToken){
      this.wanted=authToken;
    }
    public boolean matches(    Map<String,Object> actual){
      return AuthTokenUtil.matches(wanted,actual);
    }
    public String toString(){
      return "authTokenArgumentMatcher(" + wanted + ")";
    }
  }
  public static Map<String,Object> authTokenArgumentMatcher(  Map<String,Object> authToken){
    mockingProgress().getArgumentMatcherStorage().reportMatcher(new AuthTokenArgumentMatcher(authToken));
    return null;
  }
}
