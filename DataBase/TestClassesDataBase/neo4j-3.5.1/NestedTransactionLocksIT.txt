/** 
 * Confirms that a nested  {@link Transaction} can grab locks with itsexplicit methods:  {@link Transaction#acquireReadLock(org.neo4j.graphdb.PropertyContainer) acquireReadLock}and  {@link Transaction#acquireWriteLock(org.neo4j.graphdb.PropertyContainer) acquireWriteLock}.
 */
public class NestedTransactionLocksIT {
  private GraphDatabaseService db;
  @Before public void before(){
    db=new TestGraphDatabaseFactory().newImpermanentDatabase();
  }
  @After public void after(){
    db.shutdown();
  }
  private WorkerCommand<Void,Lock> acquireWriteLock(  final Node resource){
    return state -> {
      try (Transaction tx=db.beginTx()){
        return tx.acquireWriteLock(resource);
      }
     }
;
  }
  @Test public void nestedTransactionCanAcquireLocksFromTransactionObject() throws Exception {
    Node resource=createNode();
    try (Transaction outerTx=db.beginTx();Transaction nestedTx=db.beginTx()){
      assertNotSame(outerTx,nestedTx);
      try (OtherThreadExecutor<Void> otherThread=new OtherThreadExecutor<>("other thread",null)){
        Lock lock=nestedTx.acquireWriteLock(resource);
        Future<Lock> future=tryToAcquireSameLockOnAnotherThread(resource,otherThread);
        acquireOnOtherThreadTimesOut(future);
        lock.release();
        assertNotNull(future.get());
      }
     }
   }
  private void acquireOnOtherThreadTimesOut(  Future<Lock> future) throws InterruptedException, ExecutionException {
    try {
      future.get(1,SECONDS);
      fail("The nested transaction seems to not have acquired the lock");
    }
 catch (    TimeoutException e) {
    }
  }
  private Future<Lock> tryToAcquireSameLockOnAnotherThread(  Node resource,  OtherThreadExecutor<Void> otherThread) throws Exception {
    Future<Lock> future=otherThread.executeDontWait(acquireWriteLock(resource));
    otherThread.waitUntilWaiting();
    return future;
  }
  private Node createNode(){
    try (Transaction tx=db.beginTx()){
      Node n=db.createNode();
      tx.success();
      return n;
    }
   }
}
