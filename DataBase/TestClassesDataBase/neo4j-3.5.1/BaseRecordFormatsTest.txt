public class BaseRecordFormatsTest {
  private static final Capability[] CAPABILITIES=Capability.values();
  private static final CapabilityType[] CAPABILITY_TYPES=CapabilityType.values();
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldReportCompatibilityBetweenTwoEqualSetsOfCapabilities(){
    Capability[] capabilities=random.selection(CAPABILITIES,CAPABILITIES.length / 2,CAPABILITIES.length,false);
    assertCompatibility(capabilities,capabilities,true,CAPABILITY_TYPES);
  }
  @Test public void shouldReportCompatibilityForAdditiveAdditionalCapabilities(){
    Capability[] from=array(Capability.SCHEMA);
    Capability[] to=array(Capability.SCHEMA,Capability.POINT_PROPERTIES,Capability.TEMPORAL_PROPERTIES);
    assertCompatibility(from,to,true,CAPABILITY_TYPES);
  }
  @Test public void shouldReportIncompatibilityForChangingAdditionalCapabilities(){
    Capability[] from=array(Capability.SCHEMA);
    Capability[] to=array(Capability.SCHEMA,Capability.DENSE_NODES);
    assertCompatibility(from,to,false,CapabilityType.STORE);
  }
  @Test public void shouldReportIncompatibilityForAdditiveRemovedCapabilities(){
    Capability[] from=array(Capability.SCHEMA,Capability.POINT_PROPERTIES,Capability.TEMPORAL_PROPERTIES);
    Capability[] to=array(Capability.SCHEMA);
    assertCompatibility(from,to,false,CapabilityType.STORE);
  }
  private void assertCompatibility(  Capability[] from,  Capability[] to,  boolean compatible,  CapabilityType... capabilityTypes){
    for (    CapabilityType type : capabilityTypes) {
      assertEquals(compatible,format(from).hasCompatibleCapabilities(format(to),type));
    }
  }
  private RecordFormats format(  Capability... capabilities){
    RecordFormats formats=mock(BaseRecordFormats.class);
    when(formats.capabilities()).thenReturn(capabilities);
    when(formats.hasCompatibleCapabilities(any(RecordFormats.class),any(CapabilityType.class))).thenCallRealMethod();
    return formats;
  }
}
