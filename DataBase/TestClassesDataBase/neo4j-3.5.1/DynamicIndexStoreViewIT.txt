public class DynamicIndexStoreViewIT {
  private final SuppressOutput suppressOutput=SuppressOutput.suppressAll();
  private final TestDirectory testDirectory=TestDirectory.testDirectory();
  @Rule public RuleChain ruleChain=RuleChain.outerRule(testDirectory).around(suppressOutput);
  @Test public void populateDbWithConcurrentUpdates() throws Exception {
    GraphDatabaseService database=new TestGraphDatabaseFactory().newEmbeddedDatabase(testDirectory.databaseDir());
    try {
      RandomValues randomValues=RandomValues.create();
      int counter=1;
      for (int j=0; j < 100; j++) {
        try (Transaction transaction=database.beginTx()){
          for (int i=0; i < 5; i++) {
            Node node=database.createNode(Label.label("label" + counter));
            node.setProperty("property",randomValues.nextValue().asObject());
          }
          transaction.success();
        }
         counter++;
      }
      int populatorCount=5;
      ExecutorService executor=Executors.newFixedThreadPool(populatorCount);
      CountDownLatch startSignal=new CountDownLatch(1);
      AtomicBoolean endSignal=new AtomicBoolean();
      for (int i=0; i < populatorCount; i++) {
        executor.submit(new Populator(database,counter,startSignal,endSignal));
      }
      try {
        try (Transaction transaction=database.beginTx()){
          database.schema().indexFor(Label.label("label10")).on("property").create();
          transaction.success();
        }
         startSignal.countDown();
        try (Transaction transaction=database.beginTx()){
          database.schema().awaitIndexesOnline(populatorCount,TimeUnit.MINUTES);
          transaction.success();
        }
       }
  finally {
        endSignal.set(true);
        executor.shutdown();
      }
    }
  finally {
      database.shutdown();
      ConsistencyCheckService consistencyCheckService=new ConsistencyCheckService();
      Config config=Config.defaults(GraphDatabaseSettings.pagecache_memory,"8m");
      consistencyCheckService.runFullConsistencyCheck(testDirectory.databaseLayout(),config,ProgressMonitorFactory.NONE,FormattedLogProvider.toOutputStream(System.out),false);
    }
  }
private class Populator implements Runnable {
    private final GraphDatabaseService databaseService;
    private final long totalNodes;
    private final CountDownLatch startSignal;
    private final AtomicBoolean endSignal;
    Populator(    GraphDatabaseService databaseService,    long totalNodes,    CountDownLatch startSignal,    AtomicBoolean endSignal){
      this.databaseService=databaseService;
      this.totalNodes=totalNodes;
      this.startSignal=startSignal;
      this.endSignal=endSignal;
    }
    @Override public void run(){
      RandomValues randomValues=RandomValues.create();
      awaitLatch(startSignal);
      while (!endSignal.get()) {
        try (Transaction transaction=databaseService.beginTx()){
          try {
            int operationType=randomValues.nextIntValue(3).value();
switch (operationType) {
case 0:
              long targetNodeId=randomValues.nextLongValue(totalNodes).value();
            databaseService.getNodeById(targetNodeId).delete();
          break;
case 1:
        long nodeId=randomValues.nextLongValue(totalNodes).value();
      Node node=databaseService.getNodeById(nodeId);
    Map<String,Object> allProperties=node.getAllProperties();
  for (  String key : allProperties.keySet()) {
    node.setProperty(key,randomValues.nextValue().asObject());
  }
break;
case 2:
Node nodeToUpdate=databaseService.createNode(Label.label("label10"));
nodeToUpdate.setProperty("property",randomValues.nextValue().asObject());
break;
default :
throw new UnsupportedOperationException("Unknown type of index operation");
}
transaction.success();
}
 catch (Exception e) {
transaction.failure();
}
}
 }
}
}
}
