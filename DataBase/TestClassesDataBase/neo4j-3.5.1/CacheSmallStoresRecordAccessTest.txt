class CacheSmallStoresRecordAccessTest {
  @Test void shouldDelegateLookupForMostStores(){
    RecordAccess delegate=mock(RecordAccess.class);
    CacheSmallStoresRecordAccess recordAccess=new CacheSmallStoresRecordAccess(delegate,null,null,null);
    recordAccess.node(42);
    recordAccess.relationship(2001);
    recordAccess.property(2468);
    recordAccess.string(666);
    recordAccess.array(11);
    verify(delegate).node(42);
    verify(delegate).relationship(2001);
    verify(delegate).property(2468);
    verify(delegate).string(666);
    verify(delegate).array(11);
  }
  @Test void shouldServePropertyKeysAndRelationshipLabelsFromSuppliedArrayCaches(){
    RecordAccess delegate=mock(RecordAccess.class);
    PropertyKeyTokenRecord propertyKey0=new PropertyKeyTokenRecord(0);
    PropertyKeyTokenRecord propertyKey2=new PropertyKeyTokenRecord(2);
    PropertyKeyTokenRecord propertyKey1=new PropertyKeyTokenRecord(1);
    RelationshipTypeTokenRecord relationshipType0=new RelationshipTypeTokenRecord(0);
    RelationshipTypeTokenRecord relationshipType1=new RelationshipTypeTokenRecord(1);
    RelationshipTypeTokenRecord relationshipType2=new RelationshipTypeTokenRecord(2);
    LabelTokenRecord label0=new LabelTokenRecord(0);
    LabelTokenRecord label1=new LabelTokenRecord(1);
    LabelTokenRecord label2=new LabelTokenRecord(2);
    CacheSmallStoresRecordAccess recordAccess=new CacheSmallStoresRecordAccess(delegate,new PropertyKeyTokenRecord[]{propertyKey0,propertyKey1,propertyKey2},new RelationshipTypeTokenRecord[]{relationshipType0,relationshipType1,relationshipType2},new LabelTokenRecord[]{label0,label1,label2});
    assertThat(recordAccess.propertyKey(0),isDirectReferenceTo(propertyKey0));
    assertThat(recordAccess.propertyKey(1),isDirectReferenceTo(propertyKey1));
    assertThat(recordAccess.propertyKey(2),isDirectReferenceTo(propertyKey2));
    assertThat(recordAccess.relationshipType(0),isDirectReferenceTo(relationshipType0));
    assertThat(recordAccess.relationshipType(1),isDirectReferenceTo(relationshipType1));
    assertThat(recordAccess.relationshipType(2),isDirectReferenceTo(relationshipType2));
    assertThat(recordAccess.label(0),isDirectReferenceTo(label0));
    assertThat(recordAccess.label(1),isDirectReferenceTo(label1));
    assertThat(recordAccess.label(2),isDirectReferenceTo(label2));
    verifyZeroInteractions(delegate);
  }
  @SuppressWarnings("unchecked") private static <T extends AbstractBaseRecord>Matcher<RecordReference<T>> isDirectReferenceTo(  T record){
    return (Matcher)new DirectReferenceMatcher<>(record);
  }
private static class DirectReferenceMatcher<T extends AbstractBaseRecord> extends TypeSafeMatcher<DirectRecordReference<T>> {
    private final T record;
    @SuppressWarnings("unchecked") DirectReferenceMatcher(    T record){
      super(DirectRecordReference.class);
      this.record=record;
    }
    @Override public boolean matchesSafely(    DirectRecordReference<T> reference){
      return record == reference.record();
    }
    @Override public void describeTo(    Description description){
      description.appendText(DirectRecordReference.class.getName()).appendText("( ").appendValue(record).appendText(" )");
    }
  }
}
