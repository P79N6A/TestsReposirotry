public class SchemaAcceptanceTest {
  @Rule public ImpermanentDatabaseRule dbRule=new ImpermanentDatabaseRule();
  private GraphDatabaseService db;
  private Label label=Labels.MY_LABEL;
  private String propertyKey="my_property_key";
  private String secondPropertyKey="my_second_property_key";
  private enum Labels implements Label {  MY_LABEL,   MY_OTHER_LABEL}
  @Before public void init(){
    db=dbRule.getGraphDatabaseAPI();
  }
  @Test public void addingAnIndexingRuleShouldSucceed(){
    IndexDefinition index=createIndex(db,label,propertyKey);
    assertThat(getIndexes(db,label),containsOnly(index));
  }
  @Test public void addingACompositeIndexingRuleShouldSucceed(){
    IndexDefinition index=createIndex(db,label,propertyKey,secondPropertyKey);
    assertThat(getIndexes(db,label),containsOnly(index));
  }
  @Test public void addingAnIndexingRuleInNestedTxShouldSucceed(){
    IndexDefinition index;
    IndexDefinition indexDef;
    try (Transaction tx=db.beginTx()){
      try (Transaction nestedTransaction=db.beginTx()){
        indexDef=db.schema().indexFor(label).on(propertyKey).create();
        nestedTransaction.success();
      }
       index=indexDef;
      tx.success();
    }
     waitForIndex(db,indexDef);
    assertThat(getIndexes(db,label),containsOnly(index));
  }
  @Test public void shouldThrowConstraintViolationIfAskedToIndexSamePropertyAndLabelTwiceInSameTx(){
    try (Transaction tx=db.beginTx()){
      Schema schema=db.schema();
      schema.indexFor(label).on(propertyKey).create();
      try {
        schema.indexFor(label).on(propertyKey).create();
        fail("Should not have validated");
      }
 catch (      ConstraintViolationException e) {
        assertEquals("There already exists an index :MY_LABEL(my_property_key).",e.getMessage());
      }
      tx.success();
    }
   }
  @Test public void shouldThrowConstraintViolationIfAskedToIndexPropertyThatIsAlreadyIndexed(){
    Schema schema;
    try (Transaction tx=db.beginTx()){
      schema=db.schema();
      schema.indexFor(label).on(propertyKey).create();
      tx.success();
    }
     ConstraintViolationException caught=null;
    try (Transaction tx=db.beginTx()){
      schema.indexFor(label).on(propertyKey).create();
      tx.success();
    }
 catch (    ConstraintViolationException e) {
      caught=e;
    }
    assertThat(caught,not(nullValue()));
  }
  @Test public void shouldThrowConstraintViolationIfAskedToCreateCompoundConstraint(){
    try (Transaction tx=db.beginTx()){
      Schema schema=db.schema();
      schema.constraintFor(label).assertPropertyIsUnique("my_property_key").assertPropertyIsUnique("other_property").create();
      tx.success();
      fail("Should not be able to create constraint on multiple propertyKey keys");
    }
 catch (    UnsupportedOperationException e) {
      assertThat(e.getMessage(),containsString("can only create one unique constraint"));
    }
  }
  @Test public void droppingExistingIndexRuleShouldSucceed(){
    IndexDefinition index=createIndex(db,label,propertyKey);
    dropIndex(index);
    assertThat(getIndexes(db,label),isEmpty());
  }
  @Test public void droppingAnUnexistingIndexShouldGiveHelpfulExceptionInSameTransaction(){
    IndexDefinition index=createIndex(db,label,propertyKey);
    try (Transaction tx=db.beginTx()){
      index.drop();
      try {
        index.drop();
        fail("Should not be able to drop index twice");
      }
 catch (      ConstraintViolationException e) {
        assertThat(e.getMessage(),containsString("No such INDEX ON :MY_LABEL(my_property_key)."));
      }
      tx.success();
    }
     assertThat("Index should have been deleted",getIndexes(db,label),not(contains(index)));
  }
  @Test public void droppingAnUnexistingIndexShouldGiveHelpfulExceptionInSeparateTransactions(){
    IndexDefinition index=createIndex(db,label,propertyKey);
    dropIndex(index);
    try {
      dropIndex(index);
      fail("Should not be able to drop index twice");
    }
 catch (    ConstraintViolationException e) {
      assertThat(e.getMessage(),containsString("No such INDEX ON :MY_LABEL(my_property_key)."));
    }
    assertThat("Index should have been deleted",getIndexes(db,label),not(contains(index)));
  }
  @Test public void awaitingIndexComingOnlineWorks(){
    IndexDefinition index=createIndex(db,label,propertyKey);
    try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexOnline(index,1L,TimeUnit.MINUTES);
      assertEquals(Schema.IndexState.ONLINE,db.schema().getIndexState(index));
    }
   }
  @Test public void awaitingAllIndexesComingOnlineWorks(){
    IndexDefinition index=createIndex(db,label,propertyKey);
    createIndex(db,label,"other_property");
    waitForIndex(db,index);
    try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(1L,TimeUnit.MINUTES);
      assertEquals(Schema.IndexState.ONLINE,db.schema().getIndexState(index));
    }
   }
  @Test public void shouldPopulateIndex(){
    Node node=createNode(db,propertyKey,"Neo",label);
    IndexDefinition index=createIndex(db,label,propertyKey);
    waitForIndex(db,index);
    assertThat(findNodesByLabelAndProperty(label,propertyKey,"Neo",db),containsOnly(node));
  }
  @Test public void shouldRecreateDroppedIndex(){
    Node node=createNode(db,propertyKey,"Neo",label);
    IndexDefinition index=createIndex(db,label,propertyKey);
    waitForIndex(db,index);
    dropIndex(index);
    createIndex(db,label,propertyKey);
    waitForIndex(db,index);
    assertThat(getIndexes(db,label),contains(index));
    assertThat(findNodesByLabelAndProperty(label,propertyKey,"Neo",db),containsOnly(node));
  }
  @Test public void shouldCreateUniquenessConstraint(){
    ConstraintDefinition constraint=createUniquenessConstraint(label,propertyKey);
    try (Transaction tx=db.beginTx()){
      assertEquals(ConstraintType.UNIQUENESS,constraint.getConstraintType());
      assertEquals(label.name(),constraint.getLabel().name());
      assertEquals(asSet(propertyKey),Iterables.asSet(constraint.getPropertyKeys()));
      tx.success();
    }
   }
  @Test public void shouldListAddedConstraintsByLabel(){
    ConstraintDefinition constraint1=createUniquenessConstraint(label,propertyKey);
    createUniquenessConstraint(Labels.MY_OTHER_LABEL,propertyKey);
    assertThat(getConstraints(db,label),containsOnly(constraint1));
  }
  @Test public void shouldListAddedConstraints(){
    ConstraintDefinition constraint1=createUniquenessConstraint(Labels.MY_LABEL,propertyKey);
    ConstraintDefinition constraint2=createUniquenessConstraint(Labels.MY_OTHER_LABEL,propertyKey);
    assertThat(getConstraints(db),containsOnly(constraint1,constraint2));
  }
  @Test public void shouldDropUniquenessConstraint(){
    ConstraintDefinition constraint=createUniquenessConstraint(label,propertyKey);
    dropConstraint(db,constraint);
    assertThat(getConstraints(db,label),isEmpty());
  }
  @Test public void addingConstraintWhenIndexAlreadyExistsGivesNiceError(){
    createIndex(db,label,propertyKey);
    try {
      createUniquenessConstraint(label,propertyKey);
      fail("Expected exception to be thrown");
    }
 catch (    ConstraintViolationException e) {
      assertEquals("There already exists an index :MY_LABEL(my_property_key). A constraint cannot be created " + "until the index has been dropped.",e.getMessage());
    }
  }
  @Test public void addingUniquenessConstraintWhenDuplicateDataExistsGivesNiceError(){
    try (Transaction transaction=db.beginTx()){
      db.createNode(label).setProperty(propertyKey,"value1");
      db.createNode(label).setProperty(propertyKey,"value1");
      transaction.success();
    }
     try {
      createUniquenessConstraint(label,propertyKey);
      fail("Expected exception to be thrown");
    }
 catch (    ConstraintViolationException e) {
      assertThat(e.getMessage(),containsString("Unable to create CONSTRAINT ON ( my_label:MY_LABEL ) ASSERT my_label.my_property_key IS UNIQUE"));
    }
  }
  @Test public void addingConstraintWhenAlreadyConstrainedGivesNiceError(){
    createUniquenessConstraint(label,propertyKey);
    try {
      createUniquenessConstraint(label,propertyKey);
      fail("Expected exception to be thrown");
    }
 catch (    ConstraintViolationException e) {
      assertEquals("Constraint already exists: CONSTRAINT ON ( my_label:MY_LABEL ) ASSERT my_label.my_property_key " + "IS UNIQUE",e.getMessage());
    }
  }
  @Test public void addingIndexWhenAlreadyConstrained(){
    createUniquenessConstraint(label,propertyKey);
    try {
      createIndex(db,label,propertyKey);
      fail("Expected exception to be thrown");
    }
 catch (    ConstraintViolationException e) {
      assertEquals("There is a uniqueness constraint on :MY_LABEL(my_property_key), so an index is already " + "created that matches this.",e.getMessage());
    }
  }
  @Test public void addingIndexWhenAlreadyIndexed(){
    createIndex(db,label,propertyKey);
    try {
      createIndex(db,label,propertyKey);
      fail("Expected exception to be thrown");
    }
 catch (    ConstraintViolationException e) {
      assertEquals("There already exists an index :MY_LABEL(my_property_key).",e.getMessage());
    }
  }
  @Test public void addedUncommittedIndexesShouldBeVisibleWithinTheTransaction(){
    IndexDefinition indexA=createIndex(db,label,"a");
    createUniquenessConstraint(label,"b");
    try (Transaction tx=db.beginTx()){
      assertThat(count(db.schema().getIndexes(label)),is(2L));
      IndexDefinition indexC=db.schema().indexFor(label).on("c").create();
      assertThat(count(db.schema().getIndexes(label)),is(3L));
      assertThat(db.schema().getIndexState(indexA),is(Schema.IndexState.ONLINE));
      assertThat(db.schema().getIndexState(indexC),is(Schema.IndexState.POPULATING));
    }
   }
  private void dropConstraint(  GraphDatabaseService db,  ConstraintDefinition constraint){
    try (Transaction tx=db.beginTx()){
      constraint.drop();
      tx.success();
    }
   }
  private ConstraintDefinition createUniquenessConstraint(  Label label,  String prop){
    try (Transaction tx=db.beginTx()){
      ConstraintDefinition constraint=db.schema().constraintFor(label).assertPropertyIsUnique(prop).create();
      tx.success();
      return constraint;
    }
   }
  private void dropIndex(  IndexDefinition index){
    try (Transaction tx=db.beginTx()){
      index.drop();
      tx.success();
    }
   }
  private Node createNode(  GraphDatabaseService db,  String key,  Object value,  Label label){
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode(label);
      node.setProperty(key,value);
      tx.success();
      return node;
    }
   }
}
