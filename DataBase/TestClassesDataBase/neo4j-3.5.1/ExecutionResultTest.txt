public class ExecutionResultTest {
  @Rule public final ImpermanentDatabaseRule db=new ImpermanentDatabaseRule();
  @Test public void shouldCloseTransactionsWhenIteratingResults(){
    createNode();
    createNode();
    Result executionResult=db.execute("CYPHER runtime=interpreted MATCH (n) RETURN n");
    executionResult.next();
    assertThat(activeTransaction(),is(notNullValue()));
    executionResult.close();
    assertThat(activeTransaction(),is(nullValue()));
  }
  @Test public void shouldCloseTransactionsWhenIteratingOverSingleColumn(){
    createNode();
    createNode();
    Result executionResult=db.execute("CYPHER runtime=interpreted MATCH (n) RETURN n");
    ResourceIterator<Node> resultIterator=executionResult.columnAs("n");
    resultIterator.next();
    assertThat(activeTransaction(),is(notNullValue()));
    resultIterator.close();
    assertThat(activeTransaction(),is(nullValue()));
  }
  @Test public void shouldThrowAppropriateException(){
    try {
      db.execute("RETURN rand()/0").next();
    }
 catch (    QueryExecutionException ex) {
      assertThat(ex.getCause(),instanceOf(QueryExecutionKernelException.class));
      assertThat(ex.getCause().getCause(),instanceOf(ArithmeticException.class));
    }
  }
  @Test(expected=ArithmeticException.class) public void shouldThrowAppropriateExceptionAlsoWhenVisiting(){
    db.execute("RETURN rand()/0").accept(row -> true);
  }
  private void createNode(){
    try (Transaction tx=db.beginTx()){
      db.createNode();
      tx.success();
    }
   }
  @Test public void shouldHandleListsOfPointsAsInput(){
    Point point1=(Point)db.execute("RETURN point({latitude: 12.78, longitude: 56.7}) as point").next().get("point");
    Point point2=(Point)db.execute("RETURN point({latitude: 12.18, longitude: 56.2}) as point").next().get("point");
    double distance=(double)db.execute("RETURN distance({points}[0], {points}[1]) as dist",map("points",asList(point1,point2))).next().get("dist");
    assertThat(Math.round(distance),equalTo(86107L));
  }
  @Test public void shouldHandleMapWithPointsAsInput(){
    Point point1=(Point)db.execute("RETURN point({latitude: 12.78, longitude: 56.7}) as point").next().get("point");
    Point point2=(Point)db.execute("RETURN point({latitude: 12.18, longitude: 56.2}) as point").next().get("point");
    double distance=(double)db.execute("RETURN distance({points}['p1'], {points}['p2']) as dist",map("points",map("p1",point1,"p2",point2))).next().get("dist");
    assertThat(Math.round(distance),equalTo(86107L));
  }
  @Test public void shouldHandleColumnAsWithNull(){
    assertThat(db.execute("RETURN toLower(null) AS lower").<String>columnAs("lower").next(),nullValue());
  }
  private TopLevelTransaction activeTransaction(){
    ThreadToStatementContextBridge bridge=db.getDependencyResolver().resolveDependency(ThreadToStatementContextBridge.class);
    KernelTransaction kernelTransaction=bridge.getKernelTransactionBoundToThisThread(false);
    return kernelTransaction == null ? null : new TopLevelTransaction(kernelTransaction);
  }
}
