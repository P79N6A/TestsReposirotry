public class StoreLockerTest {
  @Rule public final TestDirectory target=TestDirectory.testDirectory();
  @Rule public final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Test public void shouldUseAlreadyOpenedFileChannel() throws Exception {
    StoreChannel channel=Mockito.mock(StoreChannel.class);
    CustomChannelFileSystemAbstraction fileSystemAbstraction=new CustomChannelFileSystemAbstraction(fileSystemRule.get(),channel);
    int numberOfCallesToOpen=0;
    try (StoreLocker storeLocker=new StoreLocker(fileSystemAbstraction,target.storeLayout())){
      try {
        storeLocker.checkLock();
        fail();
      }
 catch (      StoreLockException e) {
        numberOfCallesToOpen=fileSystemAbstraction.getNumberOfCallsToOpen();
        storeLocker.checkLock();
      }
    }
 catch (    StoreLockException e) {
    }
    assertEquals("Expect that number of open channels will remain the same for ",numberOfCallesToOpen,fileSystemAbstraction.getNumberOfCallsToOpen());
  }
  @Test public void shouldAllowMultipleCallsToCheckLock() throws Exception {
    try (StoreLocker storeLocker=new StoreLocker(fileSystemRule.get(),target.storeLayout())){
      storeLocker.checkLock();
      storeLocker.checkLock();
    }
   }
  @Test public void keepLockWhenOtherTryToTakeLock() throws Exception {
    StoreLayout storeLayout=target.storeLayout();
    DefaultFileSystemAbstraction fileSystemAbstraction=fileSystemRule.get();
    StoreLocker storeLocker=new StoreLocker(fileSystemAbstraction,storeLayout);
    storeLocker.checkLock();
    try (StoreLocker storeLocker1=new StoreLocker(fileSystemAbstraction,storeLayout)){
      storeLocker1.checkLock();
      fail();
    }
 catch (    StoreLockException e) {
    }
    try (StoreLocker storeLocker1=new StoreLocker(fileSystemAbstraction,storeLayout)){
      storeLocker1.checkLock();
      fail();
    }
 catch (    StoreLockException e) {
    }
    storeLocker.close();
  }
  @Test public void shouldObtainLockWhenStoreFileNotLocked() throws Exception {
    FileSystemAbstraction fileSystemAbstraction=new DelegatingFileSystemAbstraction(fileSystemRule.get()){
      @Override public boolean fileExists(      File file){
        return true;
      }
    }
;
    try (StoreLocker storeLocker=new StoreLocker(fileSystemAbstraction,target.storeLayout())){
      storeLocker.checkLock();
    }
 catch (    StoreLockException e) {
      fail();
    }
  }
  @Test public void shouldCreateStoreDirAndObtainLockWhenStoreDirDoesNotExist() throws Exception {
    FileSystemAbstraction fileSystemAbstraction=new DelegatingFileSystemAbstraction(fileSystemRule.get()){
      @Override public boolean fileExists(      File file){
        return false;
      }
    }
;
    try (StoreLocker storeLocker=new StoreLocker(fileSystemAbstraction,target.storeLayout())){
      storeLocker.checkLock();
    }
   }
  @Test public void shouldNotObtainLockWhenStoreDirCannotBeCreated() throws Exception {
    FileSystemAbstraction fileSystemAbstraction=new DelegatingFileSystemAbstraction(fileSystemRule.get()){
      @Override public void mkdirs(      File fileName) throws IOException {
        throw new IOException("store dir could not be created");
      }
      @Override public boolean fileExists(      File file){
        return false;
      }
    }
;
    StoreLayout storeLayout=target.storeLayout();
    try (StoreLocker storeLocker=new StoreLocker(fileSystemAbstraction,storeLayout)){
      storeLocker.checkLock();
      fail();
    }
 catch (    StoreLockException e) {
      String msg=format("Unable to create path for store dir: %s. " + "Please ensure no other process is using this database, and that " + "the directory is writable (required even for read-only access)",storeLayout);
      assertThat(e.getMessage(),is(msg));
    }
  }
  @Test public void shouldNotObtainLockWhenUnableToOpenLockFile() throws Exception {
    FileSystemAbstraction fileSystemAbstraction=new DelegatingFileSystemAbstraction(fileSystemRule.get()){
      @Override public StoreChannel open(      File fileName,      OpenMode openMode) throws IOException {
        throw new IOException("cannot open lock file");
      }
      @Override public boolean fileExists(      File file){
        return false;
      }
    }
;
    StoreLayout storeLayout=target.storeLayout();
    try (StoreLocker storeLocker=new StoreLocker(fileSystemAbstraction,storeLayout)){
      storeLocker.checkLock();
      fail();
    }
 catch (    StoreLockException e) {
      String msg=format("Unable to obtain lock on store lock file: %s. " + "Please ensure no other process is using this database, and that the " + "directory is writable (required even for read-only access)",storeLayout.storeLockFile());
      assertThat(e.getMessage(),is(msg));
    }
  }
  @Test public void shouldNotObtainLockWhenStoreAlreadyInUse() throws Exception {
    FileSystemAbstraction fileSystemAbstraction=new DelegatingFileSystemAbstraction(fileSystemRule.get()){
      @Override public boolean fileExists(      File file){
        return false;
      }
      @Override public StoreChannel open(      File fileName,      OpenMode openMode) throws IOException {
        return new DelegatingStoreChannel(super.open(fileName,openMode)){
          @Override public FileLock tryLock(){
            return null;
          }
        }
;
      }
    }
;
    try (StoreLocker storeLocker=new StoreLocker(fileSystemAbstraction,target.storeLayout())){
      storeLocker.checkLock();
      fail();
    }
 catch (    StoreLockException e) {
      assertThat(e.getMessage(),containsString("Store and its lock file has been locked by another process"));
    }
  }
  @Test public void mustPreventMultipleInstancesFromStartingOnSameStore(){
    File storeDir=target.storeDir();
    GraphDatabaseService db=new TestGraphDatabaseFactory().newEmbeddedDatabase(storeDir);
    try (Transaction tx=db.beginTx()){
      db.createNode();
      tx.success();
    }
     try {
      new TestGraphDatabaseFactory().newEmbeddedDatabase(storeDir);
      fail("Should not be able to start up another db in the same dir");
    }
 catch (    Exception e) {
    }
 finally {
      db.shutdown();
    }
  }
private class CustomChannelFileSystemAbstraction extends DelegatingFileSystemAbstraction {
    private final StoreChannel channel;
    private int numberOfCallsToOpen;
    CustomChannelFileSystemAbstraction(    DefaultFileSystemAbstraction delegate,    StoreChannel channel){
      super(delegate);
      this.channel=channel;
    }
    @Override public StoreChannel open(    File fileName,    OpenMode openMode){
      numberOfCallsToOpen++;
      return channel;
    }
    public int getNumberOfCallsToOpen(){
      return numberOfCallsToOpen;
    }
  }
}
