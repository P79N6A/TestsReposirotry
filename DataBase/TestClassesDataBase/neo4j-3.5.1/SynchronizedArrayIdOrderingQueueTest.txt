public class SynchronizedArrayIdOrderingQueueTest {
  @Rule public final CleanupRule cleanup=new CleanupRule();
  @Test public void shouldOfferQueueABunchOfIds() throws Exception {
    IdOrderingQueue queue=new SynchronizedArrayIdOrderingQueue(5);
    for (int i=0; i < 7; i++) {
      queue.offer(i);
    }
    for (int i=0; i < 7; i++) {
      assertFalse(queue.isEmpty());
      queue.waitFor(i);
      queue.removeChecked(i);
    }
    assertTrue(queue.isEmpty());
  }
  @Test public void shouldOfferAwaitAndRemoveRoundAndRound() throws Exception {
    IdOrderingQueue queue=new SynchronizedArrayIdOrderingQueue(5);
    long offeredId=0;
    long awaitedId=0;
    queue.offer(offeredId++);
    queue.offer(offeredId++);
    for (int i=0; i < 20; i++) {
      queue.waitFor(awaitedId);
      queue.removeChecked(awaitedId++);
      queue.offer(offeredId++);
      assertFalse(queue.isEmpty());
    }
    queue.removeChecked(awaitedId++);
    queue.removeChecked(awaitedId);
    assertTrue(queue.isEmpty());
  }
  @Test public void shouldHaveOneThreadWaitForARemoval() throws Exception {
    IdOrderingQueue queue=new SynchronizedArrayIdOrderingQueue(5);
    queue.offer(3);
    queue.offer(5);
    OtherThreadExecutor<Void> t2=cleanup.add(new OtherThreadExecutor<Void>("T2",null));
    Future<Object> await5=t2.executeDontWait(awaitHead(queue,5));
    t2.waitUntilWaiting();
    queue.removeChecked(3);
    await5.get();
  }
  @Test public void shouldExtendArrayWhenIdsAreWrappingAround(){
    IdOrderingQueue queue=new SynchronizedArrayIdOrderingQueue(5);
    for (int i=0; i < 3; i++) {
      queue.offer(i);
      queue.removeChecked(i);
    }
    for (int i=3; i < 8; i++) {
      queue.offer(i);
    }
    queue.offer(8);
    for (int i=3; i <= 8; i++) {
      assertFalse(queue.isEmpty());
      queue.removeChecked(i);
    }
    assertTrue(queue.isEmpty());
  }
  private WorkerCommand<Void,Object> awaitHead(  final IdOrderingQueue queue,  final long id){
    return state -> {
      queue.waitFor(id);
      return null;
    }
;
  }
}
