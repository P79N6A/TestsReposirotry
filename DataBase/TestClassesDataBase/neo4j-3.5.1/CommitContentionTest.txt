public class CommitContentionTest {
  @Rule public final TestDirectory storeLocation=TestDirectory.testDirectory();
  final Semaphore semaphore1=new Semaphore(1);
  final Semaphore semaphore2=new Semaphore(1);
  final AtomicReference<Exception> reference=new AtomicReference<>();
  private GraphDatabaseService db;
  @Before public void before() throws Exception {
    semaphore1.acquire();
    semaphore2.acquire();
    db=createDb();
  }
  @After public void after(){
    db.shutdown();
  }
  @Test public void shouldNotContendOnCommitWhenPushingUpdates() throws Exception {
    Thread thread=startFirstTransactionWhichBlocksDuringPushUntilSecondTransactionFinishes();
    runAndFinishSecondTransaction();
    thread.join();
    assertNoFailures();
  }
  private void assertNoFailures(){
    Exception e=reference.get();
    if (e != null) {
      throw new AssertionError(e);
    }
  }
  private void runAndFinishSecondTransaction(){
    createNode();
    signalSecondTransactionFinished();
  }
  private void createNode(){
    try (Transaction transaction=db.beginTx()){
      db.createNode();
      transaction.success();
    }
   }
  private Thread startFirstTransactionWhichBlocksDuringPushUntilSecondTransactionFinishes() throws InterruptedException {
    Thread thread=new Thread(this::createNode);
    thread.start();
    waitForFirstTransactionToStartPushing();
    return thread;
  }
  private GraphDatabaseService createDb(){
    GraphDatabaseFactoryState state=new GraphDatabaseFactoryState();
    return new GraphDatabaseFacadeFactory(DatabaseInfo.COMMUNITY,platformModule -> new CommunityEditionModule(platformModule){
      @Override public DatabaseTransactionStats createTransactionMonitor(){
        return new SkipTransactionDatabaseStats();
      }
    }
).newFacade(storeLocation.storeDir(),Config.defaults(),state.databaseDependencies());
  }
  private void waitForFirstTransactionToStartPushing() throws InterruptedException {
    if (!semaphore1.tryAcquire(10,SECONDS)) {
      throw new IllegalStateException("First transaction never started pushing");
    }
  }
  private void signalFirstTransactionStartedPushing(){
    semaphore1.release();
  }
  private void signalSecondTransactionFinished(){
    semaphore2.release();
  }
  private void waitForSecondTransactionToFinish(){
    try {
      boolean acquired=semaphore2.tryAcquire(10,SECONDS);
      if (!acquired) {
        reference.set(new IllegalStateException("Second transaction never finished"));
      }
    }
 catch (    InterruptedException e) {
      reference.set(e);
    }
  }
private class SkipTransactionDatabaseStats extends DatabaseTransactionStats {
    boolean skip;
    @Override public void transactionFinished(    boolean committed,    boolean write){
      super.transactionFinished(committed,write);
      if (committed) {
        if (skip) {
          return;
        }
        skip=true;
        signalFirstTransactionStartedPushing();
        waitForSecondTransactionToFinish();
      }
    }
  }
}
