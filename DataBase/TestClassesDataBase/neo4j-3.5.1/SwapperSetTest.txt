class SwapperSetTest {
  private SwapperSet set;
  @BeforeEach void setUp(){
    set=new SwapperSet();
  }
  @Test void mustReturnAllocationWithSwapper(){
    DummyPageSwapper a=new DummyPageSwapper("a",42);
    DummyPageSwapper b=new DummyPageSwapper("b",43);
    int idA=set.allocate(a);
    int idB=set.allocate(b);
    SwapperSet.SwapperMapping allocA=set.getAllocation(idA);
    SwapperSet.SwapperMapping allocB=set.getAllocation(idB);
    assertThat(allocA.swapper,is(a));
    assertThat(allocB.swapper,is(b));
  }
  @Test void accessingFreedAllocationMustReturnNull(){
    int id=set.allocate(new DummyPageSwapper("a",42));
    set.free(id);
    assertNull(set.getAllocation(id));
  }
  @Test void doubleFreeMustThrow(){
    int id=set.allocate(new DummyPageSwapper("a",42));
    set.free(id);
    IllegalStateException exception=assertThrows(IllegalStateException.class,() -> set.free(id));
    assertThat(exception.getMessage(),containsString("double free"));
  }
  @Test void freedIdsMustNotBeReusedBeforeVacuum(){
    PageSwapper swapper=new DummyPageSwapper("a",42);
    MutableIntSet ids=new IntHashSet(10_000);
    for (int i=0; i < 10_000; i++) {
      allocateFreeAndAssertNotReused(swapper,ids,i);
    }
  }
  private void allocateFreeAndAssertNotReused(  PageSwapper swapper,  MutableIntSet ids,  int i){
    int id=set.allocate(swapper);
    set.free(id);
    if (!ids.add(id)) {
      fail("Expected ids.add( id ) to return true for id " + id + " in iteration "+ i+ " but it instead returned false");
    }
  }
  @Test void freedAllocationsMustBecomeAvailableAfterVacuum(){
    MutableIntSet allocated=new IntHashSet();
    MutableIntSet freed=new IntHashSet();
    MutableIntSet vacuumed=new IntHashSet();
    MutableIntSet reused=new IntHashSet();
    PageSwapper swapper=new DummyPageSwapper("a",42);
    allocateAndAddTenThousand(allocated,swapper);
    allocated.forEach(id -> {
      set.free(id);
      freed.add(id);
    }
);
    set.vacuum(vacuumed::addAll);
    allocateAndAddTenThousand(reused,swapper);
    assertThat(allocated,is(equalTo(freed)));
    assertThat(allocated,is(equalTo(vacuumed)));
    assertThat(allocated,is(equalTo(reused)));
  }
  private void allocateAndAddTenThousand(  MutableIntSet allocated,  PageSwapper swapper){
    for (int i=0; i < 10_000; i++) {
      allocateAndAdd(allocated,swapper);
    }
  }
  private void allocateAndAdd(  MutableIntSet allocated,  PageSwapper swapper){
    int id=set.allocate(swapper);
    allocated.add(id);
  }
  @Test void vacuumMustNotDustOffAnyIdsWhenNoneHaveBeenFreed(){
    PageSwapper swapper=new DummyPageSwapper("a",42);
    for (int i=0; i < 100; i++) {
      set.allocate(swapper);
    }
    MutableIntSet vacuumedIds=new IntHashSet();
    set.vacuum(vacuumedIds::addAll);
    if (!vacuumedIds.isEmpty()) {
      throw new AssertionError("Vacuum found id " + vacuumedIds + " when it should have found nothing");
    }
  }
  @Test void mustNotUseZeroAsSwapperId(){
    PageSwapper swapper=new DummyPageSwapper("a",42);
    Matcher<Integer> isNotZero=is(not(0));
    for (int i=0; i < 10_000; i++) {
      assertThat(set.allocate(swapper),isNotZero);
    }
  }
  @Test void gettingAllocationZeroMustThrow(){
    assertThrows(IllegalArgumentException.class,() -> set.getAllocation((short)0));
  }
  @Test void freeOfIdZeroMustThrow(){
    assertThrows(IllegalArgumentException.class,() -> set.free(0));
  }
  @Test void mustKeepTrackOfAvailableSwapperIds(){
    PageSwapper swapper=new DummyPageSwapper("a",42);
    int initial=(1 << 21) - 2;
    assertThat(set.countAvailableIds(),is(initial));
    int id=set.allocate(swapper);
    assertThat(set.countAvailableIds(),is(initial - 1));
    set.free(id);
    assertThat(set.countAvailableIds(),is(initial - 1));
    set.vacuum(x -> {
    }
);
    assertThat(set.countAvailableIds(),is(initial));
  }
}
