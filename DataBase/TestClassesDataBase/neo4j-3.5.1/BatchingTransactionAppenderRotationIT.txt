public class BatchingTransactionAppenderRotationIT {
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  @Rule public final DefaultFileSystemRule fileSystem=new DefaultFileSystemRule();
  @Rule public final LifeRule life=new LifeRule(true);
  private final SimpleLogVersionRepository logVersionRepository=new SimpleLogVersionRepository();
  private final SimpleTransactionIdStore transactionIdStore=new SimpleTransactionIdStore();
  private final Monitors monitors=new Monitors();
  @Test public void correctLastAppliedToPreviousLogTransactionInHeaderOnLogFileRotation() throws IOException {
    LogFiles logFiles=getLogFiles(logVersionRepository,transactionIdStore);
    life.add(logFiles);
    DatabaseHealth databaseHealth=getDatabaseHealth();
    LogRotationImpl logRotation=new LogRotationImpl(monitors.newMonitor(LogRotation.Monitor.class),logFiles,databaseHealth);
    TransactionMetadataCache transactionMetadataCache=new TransactionMetadataCache();
    SynchronizedArrayIdOrderingQueue idOrderingQueue=new SynchronizedArrayIdOrderingQueue();
    BatchingTransactionAppender transactionAppender=new BatchingTransactionAppender(logFiles,logRotation,transactionMetadataCache,transactionIdStore,idOrderingQueue,databaseHealth);
    life.add(transactionAppender);
    LogAppendEvent logAppendEvent=new RotationLogAppendEvent(logRotation);
    TransactionToApply transactionToApply=prepareTransaction();
    transactionAppender.append(transactionToApply,logAppendEvent);
    assertEquals(1,logFiles.getHighestLogVersion());
    File highestLogFile=logFiles.getHighestLogFile();
    LogHeader logHeader=LogHeaderReader.readLogHeader(fileSystem,highestLogFile);
    assertEquals(2,logHeader.lastCommittedTxId);
  }
  private static TransactionToApply prepareTransaction(){
    List<StorageCommand> commands=createCommands();
    PhysicalTransactionRepresentation transactionRepresentation=new PhysicalTransactionRepresentation(commands);
    transactionRepresentation.setHeader(new byte[0],0,0,0,0,0,0);
    return new TransactionToApply(transactionRepresentation);
  }
  private static List<StorageCommand> createCommands(){
    return singletonList(new Command.NodeCommand(new NodeRecord(1L),new NodeRecord(2L)));
  }
  private LogFiles getLogFiles(  SimpleLogVersionRepository logVersionRepository,  SimpleTransactionIdStore transactionIdStore) throws IOException {
    return LogFilesBuilder.builder(testDirectory.databaseLayout(),fileSystem.get()).withLogVersionRepository(logVersionRepository).withTransactionIdStore(transactionIdStore).build();
  }
  private static DatabaseHealth getDatabaseHealth(){
    DatabasePanicEventGenerator databasePanicEventGenerator=new DatabasePanicEventGenerator(new KernelEventHandlers(NullLog.getInstance()));
    return new DatabaseHealth(databasePanicEventGenerator,NullLog.getInstance());
  }
private static class RotationLogAppendEvent implements LogAppendEvent {
    private final LogRotationImpl logRotation;
    RotationLogAppendEvent(    LogRotationImpl logRotation){
      this.logRotation=logRotation;
    }
    @Override public LogForceWaitEvent beginLogForceWait(){
      return null;
    }
    @Override public LogForceEvent beginLogForce(){
      return null;
    }
    @Override public void close(){
    }
    @Override public void setLogRotated(    boolean logRotated){
    }
    @Override public LogRotateEvent beginLogRotate(){
      return null;
    }
    @Override public SerializeTransactionEvent beginSerializeTransaction(){
      return () -> {
        try {
          logRotation.rotateLogFile();
        }
 catch (        IOException e) {
          throw new RuntimeException("Should be able to rotate file",e);
        }
      }
;
    }
  }
}
