public class ProcessorStepTest {
  @Rule public final OtherThreadRule<Void> t2=new OtherThreadRule<>();
  @Test public void shouldUpholdProcessOrderingGuarantee() throws Exception {
    StageControl control=mock(StageControl.class);
    MyProcessorStep step=new MyProcessorStep(control,0);
    step.start(ORDER_SEND_DOWNSTREAM);
    step.processors(4);
    int batches=10;
    for (int i=0; i < batches; i++) {
      step.receive(i,i);
    }
    step.endOfUpstream();
    step.awaitCompleted();
    assertEquals(batches,step.nextExpected.get());
    step.close();
  }
  @Test public void shouldHaveTaskQueueSizeEqualToMaxNumberOfProcessors() throws Exception {
    StageControl control=mock(StageControl.class);
    final CountDownLatch latch=new CountDownLatch(1);
    final int processors=2;
    int maxProcessors=5;
    Configuration configuration=new Configuration(){
      @Override public int maxNumberOfProcessors(){
        return maxProcessors;
      }
    }
;
    final ProcessorStep<Void> step=new BlockingProcessorStep(control,configuration,processors,latch);
    step.start(ORDER_SEND_DOWNSTREAM);
    step.processors(1);
    for (int i=0; i < processors + maxProcessors; i++) {
      step.receive(i,null);
    }
    Future<Void> receiveFuture=t2.execute(receive(processors,step));
    t2.get().waitUntilThreadState(Thread.State.TIMED_WAITING);
    latch.countDown();
    receiveFuture.get();
  }
  @Test public void shouldRecycleDoneBatches() throws Exception {
    StageControl control=mock(StageControl.class);
    MyProcessorStep step=new MyProcessorStep(control,0);
    step.start(ORDER_SEND_DOWNSTREAM);
    int batches=10;
    for (int i=0; i < batches; i++) {
      step.receive(i,i);
    }
    step.endOfUpstream();
    step.awaitCompleted();
    verify(control,times(batches)).recycle(any());
    step.close();
  }
private static class BlockingProcessorStep extends ProcessorStep<Void> {
    private final CountDownLatch latch;
    BlockingProcessorStep(    StageControl control,    Configuration configuration,    int maxProcessors,    CountDownLatch latch){
      super(control,"test",configuration,maxProcessors);
      this.latch=latch;
    }
    @Override protected void process(    Void batch,    BatchSender sender) throws Throwable {
      latch.await();
    }
  }
private static class MyProcessorStep extends ProcessorStep<Integer> {
    private final AtomicInteger nextExpected=new AtomicInteger();
    private MyProcessorStep(    StageControl control,    int maxProcessors){
      super(control,"test",Configuration.DEFAULT,maxProcessors);
    }
    @Override protected void process(    Integer batch,    BatchSender sender){
      nextExpected.incrementAndGet();
    }
  }
  private WorkerCommand<Void,Void> receive(  final int processors,  final ProcessorStep<Void> step){
    return state -> {
      step.receive(processors,null);
      return null;
    }
;
  }
}
