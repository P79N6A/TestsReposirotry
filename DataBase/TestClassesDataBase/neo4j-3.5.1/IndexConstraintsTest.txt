public class IndexConstraintsTest {
  private static final Label LABEL=Label.label("Label");
  private static final String PROPERTY_KEY="x";
  private GraphDatabaseService graphDb;
  @Before public void setup(){
    graphDb=new TestGraphDatabaseFactory().newImpermanentDatabase();
  }
  @After public void shutdown(){
    graphDb.shutdown();
  }
  @Test public void testMultipleCreate() throws InterruptedException {
    final int numThreads=25;
    final String uuid=UUID.randomUUID().toString();
    final Node commonNode;
    try (Transaction tx=graphDb.beginTx()){
      commonNode=graphDb.createNode();
      tx.success();
    }
     ExecutorCompletionService<Node> ecs=new ExecutorCompletionService<>(Executors.newFixedThreadPool(numThreads));
    for (int i=0; i < numThreads; i++) {
      ecs.submit(() -> {
        try (Transaction tx=graphDb.beginTx()){
          final Node node=graphDb.createNode();
          tx.acquireWriteLock(commonNode);
          Index<Node> index=graphDb.index().forNodes("uuids");
          final Node existing=index.get("uuid",uuid).getSingle();
          if (existing != null) {
            throw new RuntimeException("Node already exists");
          }
          node.setProperty("uuid",uuid);
          index.add(node,"uuid",uuid);
          tx.success();
          return node;
        }
       }
);
    }
    int numSucceeded=0;
    for (int i=0; i < numThreads; i++) {
      try {
        ecs.take().get();
        ++numSucceeded;
      }
 catch (      ExecutionException ignored) {
      }
    }
    assertEquals(1,numSucceeded);
  }
  @Test public void convertIndexToConstraint(){
    try (Transaction tx=graphDb.beginTx()){
      graphDb.schema().indexFor(LABEL).on(PROPERTY_KEY).create();
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      IndexDefinition index=firstOrNull(graphDb.schema().getIndexes(LABEL));
      index.drop();
      graphDb.schema().constraintFor(LABEL).assertPropertyIsUnique(PROPERTY_KEY).create();
      tx.success();
    }
   }
  @Test public void convertIndexToConstraintWithExistingData(){
    try (Transaction tx=graphDb.beginTx()){
      for (int i=0; i < 2000; i++) {
        Node node=graphDb.createNode(LABEL);
        node.setProperty(PROPERTY_KEY,i);
      }
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      graphDb.schema().indexFor(LABEL).on(PROPERTY_KEY).create();
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      IndexDefinition index=firstOrNull(graphDb.schema().getIndexes(LABEL));
      index.drop();
      graphDb.schema().constraintFor(LABEL).assertPropertyIsUnique(PROPERTY_KEY).create();
      tx.success();
    }
   }
  @Test public void convertConstraintToIndex(){
    try (Transaction tx=graphDb.beginTx()){
      graphDb.schema().constraintFor(LABEL).assertPropertyIsUnique(PROPERTY_KEY).create();
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      ConstraintDefinition constraint=firstOrNull(graphDb.schema().getConstraints(LABEL));
      constraint.drop();
      graphDb.schema().indexFor(LABEL).on(PROPERTY_KEY).create();
      tx.success();
    }
   }
  @Test public void creatingAndDroppingAndCreatingIndexInSameTransaction(){
    for (int times=1; times <= 4; times++) {
      try {
        try (Transaction tx=graphDb.beginTx()){
          recreate(graphDb.schema().indexFor(LABEL).on(PROPERTY_KEY).create(),times);
          tx.success();
        }
         assertNotNull("Index should exist",getIndex(LABEL,PROPERTY_KEY));
        try (Transaction tx=graphDb.beginTx()){
          recreate(getIndex(LABEL,PROPERTY_KEY),times);
          tx.success();
        }
         assertNotNull("Index should exist",getIndex(LABEL,PROPERTY_KEY));
        try (Transaction tx=graphDb.beginTx()){
          recreate(getIndex(LABEL,PROPERTY_KEY),times).drop();
          tx.success();
        }
         assertNull("Index should be removed",getIndex(LABEL,PROPERTY_KEY));
      }
 catch (      Throwable e) {
        throw new AssertionError("times=" + times,e);
      }
    }
  }
  private IndexDefinition recreate(  IndexDefinition index,  int times){
    for (int i=0; i < times; i++) {
      index.drop();
      index=graphDb.schema().indexFor(single(index.getLabels())).on(single(index.getPropertyKeys())).create();
    }
    return index;
  }
  private IndexDefinition getIndex(  Label label,  String propertyKey){
    try (Transaction tx=graphDb.beginTx()){
      IndexDefinition found=null;
      for (      IndexDefinition index : graphDb.schema().getIndexes(label)) {
        if (propertyKey.equals(single(index.getPropertyKeys()))) {
          assertNull("Found multiple indexes.",found);
          found=index;
        }
      }
      tx.success();
      return found;
    }
   }
  @Test public void shouldRemoveIndexForConstraintEvenIfDroppedInCreatingTransaction(){
    try (Transaction tx=graphDb.beginTx()){
      graphDb.schema().constraintFor(LABEL).assertPropertyIsUnique(PROPERTY_KEY).create().drop();
      tx.failure();
    }
     assertNull("Should not have constraint index",getIndex(LABEL,PROPERTY_KEY));
  }
  @Test public void creatingAndDroppingAndCreatingConstraintInSameTransaction(){
    for (int times=1; times <= 4; times++) {
      try {
        try (Transaction tx=graphDb.beginTx()){
          recreate(graphDb.schema().constraintFor(LABEL).assertPropertyIsUnique(PROPERTY_KEY).create(),times);
          tx.success();
        }
         assertNotNull("Constraint should exist",getConstraint(LABEL,PROPERTY_KEY));
        assertNotNull("Should have constraint index",getIndex(LABEL,PROPERTY_KEY));
        try (Transaction tx=graphDb.beginTx()){
          recreate(getConstraint(LABEL,PROPERTY_KEY),times);
          tx.success();
        }
         assertNotNull("Constraint should exist",getConstraint(LABEL,PROPERTY_KEY));
        assertNotNull("Should have constraint index",getIndex(LABEL,PROPERTY_KEY));
        try (Transaction tx=graphDb.beginTx()){
          recreate(getConstraint(LABEL,PROPERTY_KEY),times).drop();
          tx.success();
        }
         assertNull("Constraint should be removed",getConstraint(LABEL,PROPERTY_KEY));
        assertNull("Should not have constraint index",getIndex(LABEL,PROPERTY_KEY));
      }
 catch (      Throwable e) {
        throw new AssertionError("times=" + times,e);
      }
    }
  }
  private ConstraintDefinition recreate(  ConstraintDefinition constraint,  int times){
    for (int i=0; i < times; i++) {
      constraint.drop();
      constraint=graphDb.schema().constraintFor(constraint.getLabel()).assertPropertyIsUnique(single(constraint.getPropertyKeys())).create();
    }
    return constraint;
  }
  private ConstraintDefinition getConstraint(  Label label,  String propertyKey){
    try (Transaction tx=graphDb.beginTx()){
      ConstraintDefinition found=null;
      for (      ConstraintDefinition constraint : graphDb.schema().getConstraints(label)) {
        if (propertyKey.equals(single(constraint.getPropertyKeys()))) {
          assertNull("Found multiple constraints.",found);
          found=constraint;
        }
      }
      tx.success();
      return found;
    }
   }
}
