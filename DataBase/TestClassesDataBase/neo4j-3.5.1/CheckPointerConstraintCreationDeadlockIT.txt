/** 
 * The scenario, which takes place on database instance applying constraint creation as an external transaction, looks like this: <ol> <li> Transaction T1 creates the constraint index and population P starts </li> <li> Transaction T2 which activates the constraint starts applying and now has a read lock on the counts store </li> <li> Check point triggers, wants to rotate counts store and so acquires its write lock. It will have to block, but doing so will also blocks further read lock requests </li> <li> T2 moves on to activate the constraint. Doing so means first waiting for the index to come online </li> <li> P moves on to flip after population, something which includes initializing some sample data in counts store for this index. Will block on the counts store read lock, completing the deadlock </li> </ol>
 */
public class CheckPointerConstraintCreationDeadlockIT {
  private static final Label LABEL=TestLabels.LABEL_ONE;
  private static final String KEY="key";
  @Rule public final VerboseTimeout timeout=VerboseTimeout.builder().withTimeout(30,SECONDS).build();
  @Rule public final EphemeralFileSystemRule fs=new EphemeralFileSystemRule();
  @Rule public final OtherThreadRule<Void> t2=new OtherThreadRule<>("T2");
  @Rule public final OtherThreadRule<Void> t3=new OtherThreadRule<>("T3");
  @Test public void shouldNotDeadlock() throws Exception {
    List<TransactionRepresentation> transactions=createConstraintCreatingTransactions();
    Monitors monitors=new Monitors();
    GraphDatabaseAPI db=(GraphDatabaseAPI)new TestGraphDatabaseFactory().setMonitors(monitors).newImpermanentDatabase();
    Barrier.Control controller=new Barrier.Control();
    boolean success=false;
    try {
      IndexingService.Monitor monitor=new IndexingService.MonitorAdapter(){
        @Override public void indexPopulationScanComplete(){
          controller.reached();
        }
      }
;
      monitors.addMonitorListener(monitor);
      Future<Object> applier=applyInT2(db,transactions);
      controller.await();
      Future<Object> checkPointer=t3.execute(state -> db.getDependencyResolver().resolveDependency(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("MANUAL")));
      try {
        t3.get().waitUntilWaiting(details -> details.isAt(LockWrapper.class,"writeLock"));
      }
 catch (      IllegalStateException e) {
        checkPointer.get();
      }
      controller.release();
      applier.get(10,SECONDS);
      checkPointer.get(10,SECONDS);
      success=true;
      try (Transaction tx=db.beginTx()){
        ConstraintDefinition constraint=single(db.schema().getConstraints(LABEL));
        assertEquals(KEY,single(constraint.getPropertyKeys()));
        tx.success();
      }
       createNode(db,"A");
      try {
        createNode(db,"A");
        fail("Should have failed");
      }
 catch (      ConstraintViolationException e) {
      }
    }
  finally {
      if (!success) {
        t2.interrupt();
        t3.interrupt();
      }
      db.shutdown();
    }
  }
  private void createNode(  GraphDatabaseAPI db,  String name){
    try (Transaction tx=db.beginTx()){
      db.createNode(LABEL).setProperty(KEY,name);
      tx.success();
    }
   }
  private Future<Object> applyInT2(  GraphDatabaseAPI db,  List<TransactionRepresentation> transactions){
    TransactionCommitProcess commitProcess=db.getDependencyResolver().resolveDependency(TransactionCommitProcess.class);
    return t2.execute(state -> {
      transactions.forEach(tx -> {
        try {
          commitProcess.commit(new TransactionToApply(tx),NULL,EXTERNAL);
        }
 catch (        TransactionFailureException e) {
          throw new RuntimeException(e);
        }
      }
);
      return null;
    }
);
  }
  private static List<TransactionRepresentation> createConstraintCreatingTransactions() throws Exception {
    GraphDatabaseAPI db=(GraphDatabaseAPI)new TestGraphDatabaseFactory().newImpermanentDatabase();
    try {
      try (Transaction tx=db.beginTx()){
        db.schema().constraintFor(LABEL).assertPropertyIsUnique(KEY).create();
        tx.success();
      }
       LogicalTransactionStore txStore=db.getDependencyResolver().resolveDependency(LogicalTransactionStore.class);
      List<TransactionRepresentation> result=new ArrayList<>();
      try (TransactionCursor cursor=txStore.getTransactions(TransactionIdStore.BASE_TX_ID + 1)){
        while (cursor.next()) {
          result.add(cursor.get().getTransactionRepresentation());
        }
      }
       return result;
    }
  finally {
      db.shutdown();
    }
  }
}
