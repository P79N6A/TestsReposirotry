public class DataStatisticsTest {
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldSumCounts() throws Throwable {
    DataStatistics stats=new DataStatistics(1,2,new RelationshipTypeCount[0]);
    Race race=new Race();
    int types=10;
    long[] expected=new long[types];
    int threads=Runtime.getRuntime().availableProcessors();
    for (int i=0; i < threads; i++) {
      long[] local=new long[types];
      for (int j=0; j < types; j++) {
        local[j]=random.nextInt(1_000,2_000);
        expected[j]+=local[j];
      }
      race.addContestant(() -> {
        try (DataStatistics.Client client=stats.newClient()){
          for (int typeId=0; typeId < types; typeId++) {
            while (local[typeId]-- > 0) {
              client.increment(typeId);
            }
          }
        }
       }
);
    }
    race.go();
    stats.forEach(count -> assertEquals(expected[count.getTypeId()],count.getCount()));
  }
  @Test public void shouldGrowArrayProperly(){
    DataStatistics stats=new DataStatistics(1,1,new RelationshipTypeCount[0]);
    int typeId=1_000;
    try (Client client=stats.newClient()){
      client.increment(typeId);
    }
     RelationshipTypeCount count=typeCount(stats.iterator(),typeId);
    assertEquals(1,count.getCount());
    assertEquals(typeId,count.getTypeId());
  }
  private RelationshipTypeCount typeCount(  Iterator<RelationshipTypeCount> iterator,  int typeId){
    while (iterator.hasNext()) {
      RelationshipTypeCount count=iterator.next();
      if (count.getTypeId() == typeId) {
        return count;
      }
    }
    throw new IllegalStateException("Couldn't find " + typeId);
  }
}
