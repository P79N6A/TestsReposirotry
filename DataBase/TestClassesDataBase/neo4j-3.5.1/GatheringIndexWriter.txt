private static class GatheringIndexWriter extends IndexAccessor.Adapter implements IndexPopulator {
  private final Set<IndexEntryUpdate<?>> updatesCommitted=new HashSet<>();
  private final Map<Object,Set<Long>> indexSamples=new HashMap<>();
  @Override public void create(){
  }
  @Override public void add(  Collection<? extends IndexEntryUpdate<?>> updates){
    updatesCommitted.addAll(updates);
  }
  @Override public void verifyDeferredConstraints(  NodePropertyAccessor nodePropertyAccessor){
  }
  @Override public IndexUpdater newPopulatingUpdater(  NodePropertyAccessor nodePropertyAccessor){
    return newUpdater(IndexUpdateMode.ONLINE);
  }
  @Override public IndexUpdater newUpdater(  final IndexUpdateMode mode){
    return new CollectingIndexUpdater(updatesCommitted::addAll);
  }
  @Override public void close(  boolean populationCompletedSuccessfully){
  }
  @Override public void markAsFailed(  String failure){
  }
  @Override public void includeSample(  IndexEntryUpdate<?> update){
    addValueToSample(update.getEntityId(),update.values()[0]);
  }
  @Override public IndexSample sampleResult(){
    long indexSize=0;
    for (    Set<Long> nodeIds : indexSamples.values()) {
      indexSize+=nodeIds.size();
    }
    return new IndexSample(indexSize,indexSamples.size(),indexSize);
  }
  private void addValueToSample(  long nodeId,  Object propertyValue){
    Set<Long> nodeIds=indexSamples.computeIfAbsent(propertyValue,k -> new HashSet<>());
    nodeIds.add(nodeId);
  }
}
