/** 
 * This set of tests is mainly made to test the "backwards" argument to the CostEvaluator sent to a Dijkstra.
 * @author Patrik Larsson
 * @see CostEvaluator
 */
public class DijkstraDirectionTest extends Neo4jAlgoTestCase {
  @Test public void testDijkstraDirection1(){
    graph.makeEdge("s","e");
    Dijkstra<Double> dijkstra=new Dijkstra<>((double)0,graph.getNode("s"),graph.getNode("e"),(relationship,direction) -> {
      assertEquals(Direction.OUTGOING,direction);
      return 1.0;
    }
,new org.neo4j.graphalgo.impl.util.DoubleAdder(),Double::compareTo,Direction.OUTGOING,MyRelTypes.R1);
    dijkstra.getCost();
    dijkstra=new Dijkstra<>((double)0,graph.getNode("s"),graph.getNode("e"),(relationship,direction) -> {
      assertEquals(Direction.INCOMING,direction);
      return 1.0;
    }
,new org.neo4j.graphalgo.impl.util.DoubleAdder(),Double::compareTo,Direction.INCOMING,MyRelTypes.R1);
    dijkstra.getCost();
  }
  @Test public void testDijkstraDirection2(){
    graph.makeEdge("a","b");
    graph.makeEdge("b","c");
    graph.makeEdge("c","d");
    graph.makeEdge("d","a");
    graph.makeEdge("s","a");
    graph.makeEdge("b","s");
    graph.makeEdge("e","c");
    graph.makeEdge("d","e");
    Dijkstra<Double> dijkstra=new Dijkstra<>((double)0,graph.getNode("s"),graph.getNode("e"),(relationship,direction) -> {
      assertEquals(Direction.OUTGOING,direction);
      return 1.0;
    }
,new org.neo4j.graphalgo.impl.util.DoubleAdder(),Double::compareTo,Direction.OUTGOING,MyRelTypes.R1);
    dijkstra.getCost();
    dijkstra=new Dijkstra<>((double)0,graph.getNode("s"),graph.getNode("e"),(relationship,direction) -> {
      assertEquals(Direction.INCOMING,direction);
      return 1.0;
    }
,new org.neo4j.graphalgo.impl.util.DoubleAdder(),Double::compareTo,Direction.INCOMING,MyRelTypes.R1);
    dijkstra.getCost();
  }
class directionSavingCostEvaluator implements CostEvaluator<Double> {
    HashMap<Relationship,Direction> dirs;
    directionSavingCostEvaluator(    HashMap<Relationship,Direction> dirs){
      super();
      this.dirs=dirs;
    }
    @Override public Double getCost(    Relationship relationship,    Direction direction){
      if (!dirs.containsKey(relationship)) {
        dirs.put(relationship,direction);
      }
      return 1.0;
    }
  }
  @Test public void testDijkstraDirection3(){
    Relationship r1=graph.makeEdge("start","b");
    Relationship r2=graph.makeEdge("c","b");
    Relationship r3=graph.makeEdge("c","d");
    Relationship r4=graph.makeEdge("e","d");
    Relationship r5=graph.makeEdge("e","f");
    Relationship r6=graph.makeEdge("g","f");
    Relationship r7=graph.makeEdge("g","end");
    HashMap<Relationship,Direction> dirs=new HashMap<>();
    Dijkstra<Double> dijkstra=new Dijkstra<>((double)0,graph.getNode("start"),graph.getNode("end"),new directionSavingCostEvaluator(dirs),new org.neo4j.graphalgo.impl.util.DoubleAdder(),Double::compareTo,Direction.BOTH,MyRelTypes.R1);
    dijkstra.getCost();
    assertEquals(Direction.OUTGOING,dirs.get(r1));
    assertEquals(Direction.INCOMING,dirs.get(r2));
    assertEquals(Direction.OUTGOING,dirs.get(r3));
    assertEquals(Direction.INCOMING,dirs.get(r4));
    assertEquals(Direction.OUTGOING,dirs.get(r5));
    assertEquals(Direction.INCOMING,dirs.get(r6));
    assertEquals(Direction.OUTGOING,dirs.get(r7));
  }
}
