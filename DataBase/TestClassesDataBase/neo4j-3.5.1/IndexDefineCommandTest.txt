public class IndexDefineCommandTest {
  @Test public void testIndexCommandCreationEnforcesLimit(){
    IndexDefineCommand idc=new IndexDefineCommand();
    int count=IndexDefineCommand.HIGHEST_POSSIBLE_ID;
    for (int i=0; i < count; i++) {
      idc.getOrAssignKeyId("key" + i);
      idc.getOrAssignIndexNameId("index" + i);
    }
    try {
      idc.getOrAssignKeyId("dropThatOverflows");
      fail("IndexDefineCommand should not allow more than " + count + " indexes per transaction");
    }
 catch (    IllegalStateException e) {
    }
    try {
      idc.getOrAssignIndexNameId("dropThatOverflows");
      fail("IndexDefineCommand should not allow more than " + count + " keys per transaction");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void shouldWriteIndexDefineCommandIfMapWithinShortRange() throws IOException {
    InMemoryClosableChannel channel=new InMemoryClosableChannel(10_000);
    IndexDefineCommand command=initIndexDefineCommand(300);
    command.serialize(channel);
    CommandReader commandReader=new RecordStorageCommandReaderFactory().byVersion(LogEntryVersion.CURRENT.byteCode());
    IndexDefineCommand read=(IndexDefineCommand)commandReader.read(channel);
    assertEquals(command.getIndexNameIdRange(),read.getIndexNameIdRange());
    assertEquals(command.getKeyIdRange(),read.getKeyIdRange());
  }
  @Test public void shouldFailToWriteIndexDefineCommandIfMapIsLargerThanShort() throws IOException {
    InMemoryClosableChannel channel=new InMemoryClosableChannel(1000);
    IndexDefineCommand command=new IndexDefineCommand();
    MutableObjectIntMap<String> largeMap=initMap(0xFFFF + 1);
    command.init(largeMap,largeMap);
    assertTrue(serialize(channel,command));
  }
  private boolean serialize(  InMemoryClosableChannel channel,  IndexDefineCommand command) throws IOException {
    try {
      command.serialize(channel);
    }
 catch (    AssertionError e) {
      return true;
    }
    return false;
  }
  private IndexDefineCommand initIndexDefineCommand(  int nbrOfEntries){
    IndexDefineCommand command=new IndexDefineCommand();
    MutableObjectIntMap<String> indexNames=initMap(nbrOfEntries);
    MutableObjectIntMap<String> keys=initMap(nbrOfEntries);
    command.init(indexNames,keys);
    return command;
  }
  private MutableObjectIntMap<String> initMap(  int nbrOfEntries){
    MutableObjectIntMap<String> toReturn=new ObjectIntHashMap<>();
    while (nbrOfEntries-- > 0) {
      toReturn.put("key" + nbrOfEntries,nbrOfEntries);
    }
    return toReturn;
  }
}
