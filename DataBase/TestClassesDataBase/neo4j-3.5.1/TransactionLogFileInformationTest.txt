public class TransactionLogFileInformationTest {
  private LogFiles logFiles=mock(TransactionLogFiles.class);
  private LogHeaderCache logHeaderCache=mock(LogHeaderCache.class);
  private TransactionLogFilesContext context=mock(TransactionLogFilesContext.class);
  @Test public void shouldReadAndCacheFirstCommittedTransactionIdForAGivenVersionWhenNotCached() throws Exception {
    TransactionLogFileInformation info=new TransactionLogFileInformation(logFiles,logHeaderCache,context);
    long expected=5;
    long version=10L;
    when(logHeaderCache.getLogHeader(version)).thenReturn(null);
    when(logFiles.versionExists(version)).thenReturn(true);
    when(logFiles.extractHeader(version)).thenReturn(new LogHeader((byte)-1,-1L,expected - 1L));
    long firstCommittedTxId=info.getFirstEntryId(version);
    assertEquals(expected,firstCommittedTxId);
    verify(logHeaderCache,times(1)).putHeader(version,expected - 1);
  }
  @Test public void shouldReadFirstCommittedTransactionIdForAGivenVersionWhenCached() throws Exception {
    TransactionLogFileInformation info=new TransactionLogFileInformation(logFiles,logHeaderCache,context);
    long expected=5;
    long version=10L;
    when(logHeaderCache.getLogHeader(version)).thenReturn(expected - 1);
    long firstCommittedTxId=info.getFirstEntryId(version);
    assertEquals(expected,firstCommittedTxId);
  }
  @Test public void shouldReadAndCacheFirstCommittedTransactionIdWhenNotCached() throws Exception {
    TransactionLogFileInformation info=new TransactionLogFileInformation(logFiles,logHeaderCache,context);
    long expected=5;
    long version=10L;
    when(logFiles.getHighestLogVersion()).thenReturn(version);
    when(logHeaderCache.getLogHeader(version)).thenReturn(null);
    when(logFiles.versionExists(version)).thenReturn(true);
    when(logFiles.extractHeader(version)).thenReturn(new LogHeader((byte)-1,-1L,expected - 1L));
    when(logFiles.hasAnyEntries(version)).thenReturn(true);
    long firstCommittedTxId=info.getFirstExistingEntryId();
    assertEquals(expected,firstCommittedTxId);
    verify(logHeaderCache,times(1)).putHeader(version,expected - 1);
  }
  @Test public void shouldReadFirstCommittedTransactionIdWhenCached() throws Exception {
    TransactionLogFileInformation info=new TransactionLogFileInformation(logFiles,logHeaderCache,context);
    long expected=5;
    long version=10L;
    when(logFiles.getHighestLogVersion()).thenReturn(version);
    when(logFiles.versionExists(version)).thenReturn(true);
    when(logHeaderCache.getLogHeader(version)).thenReturn(expected - 1);
    when(logFiles.hasAnyEntries(version)).thenReturn(true);
    long firstCommittedTxId=info.getFirstExistingEntryId();
    assertEquals(expected,firstCommittedTxId);
  }
  @Test public void shouldReturnNothingWhenThereAreNoTransactions() throws Exception {
    TransactionLogFileInformation info=new TransactionLogFileInformation(logFiles,logHeaderCache,context);
    long version=10L;
    when(logFiles.getHighestLogVersion()).thenReturn(version);
    when(logFiles.hasAnyEntries(version)).thenReturn(false);
    long firstCommittedTxId=info.getFirstExistingEntryId();
    assertEquals(-1,firstCommittedTxId);
  }
}
