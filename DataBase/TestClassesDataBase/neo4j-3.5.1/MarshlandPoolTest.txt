class MarshlandPoolTest {
  @Test void shouldNotLooseObjectsWhenThreadsDie() throws Exception {
    Pool<Object> delegatePool=mock(Pool.class);
    when(delegatePool.acquire()).thenReturn(1337,-1);
    final MarshlandPool<Object> pool=new MarshlandPool<>(delegatePool);
    claimAndReleaseInSeparateThread(pool);
    verify(delegatePool).acquire();
    verifyNoMoreInteractions(delegatePool);
    assertPoolEventuallyReturns(pool,1337);
  }
  @Test void shouldReturnToDelegatePoolIfLocalPoolIsFull(){
    Pool<Object> delegatePool=mock(Pool.class);
    when(delegatePool.acquire()).thenReturn(1337);
    final MarshlandPool<Object> pool=new MarshlandPool<>(delegatePool);
    Object first=pool.acquire();
    Object second=pool.acquire();
    Object third=pool.acquire();
    pool.release(first);
    pool.release(second);
    pool.release(third);
    verify(delegatePool,times(3)).acquire();
    verify(delegatePool,times(2)).release(any());
    verifyNoMoreInteractions(delegatePool);
  }
  @Test void shouldReleaseAllSlotsOnClose(){
    Pool<Object> delegatePool=mock(Pool.class);
    when(delegatePool.acquire()).thenReturn(1337);
    final MarshlandPool<Object> pool=new MarshlandPool<>(delegatePool);
    Object first=pool.acquire();
    pool.release(first);
    pool.close();
    verify(delegatePool,times(1)).acquire();
    verify(delegatePool,times(1)).release(any());
    verifyNoMoreInteractions(delegatePool);
  }
  private void assertPoolEventuallyReturns(  Pool<Object> pool,  int expected){
    long maxTime=System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(100);
    while (System.currentTimeMillis() < maxTime) {
      if (pool.acquire().equals(expected)) {
        return;
      }
    }
    fail("Waited 100 seconds for pool to return object from dead thread, but it was never returned.");
  }
  private void claimAndReleaseInSeparateThread(  final MarshlandPool<Object> pool) throws InterruptedException {
    Thread thread=new Thread(() -> {
      Object obj=pool.acquire();
      pool.release(obj);
    }
);
    thread.start();
    thread.join();
  }
}
