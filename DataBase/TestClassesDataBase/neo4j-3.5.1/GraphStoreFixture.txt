public abstract class GraphStoreFixture extends ConfigurablePageCacheRule implements TestRule {
  private DirectStoreAccess directStoreAccess;
  private Statistics statistics;
  private final boolean keepStatistics;
  private NeoStores neoStore;
  private TestDirectory directory;
  private long schemaId;
  private long nodeId;
  private int labelId;
  private long nodeLabelsId;
  private long relId;
  private long relGroupId;
  private int propId;
  private long stringPropId;
  private long arrayPropId;
  private int relTypeId;
  private int propKeyId;
  private DefaultFileSystemAbstraction fileSystem;
  private final LifeSupport life=new LifeSupport();
  /** 
 * Record format used to generate initial database.
 */
  private String formatName;
  private GraphStoreFixture(  boolean keepStatistics,  String formatName){
    this.keepStatistics=keepStatistics;
    this.formatName=formatName;
  }
  protected GraphStoreFixture(  String formatName){
    this(false,formatName);
  }
  @Override protected void after(  boolean success){
    super.after(success);
    life.shutdown();
    if (fileSystem != null) {
      try {
        fileSystem.close();
      }
 catch (      IOException e) {
        throw new AssertionError("Failed to stop file system after test",e);
      }
    }
  }
  public void apply(  Transaction transaction) throws TransactionFailureException {
    applyTransaction(transaction);
  }
  public DirectStoreAccess directStoreAccess(){
    if (directStoreAccess == null) {
      life.start();
      JobScheduler scheduler=life.add(JobSchedulerFactory.createInitialisedScheduler());
      fileSystem=new DefaultFileSystemAbstraction();
      PageCache pageCache=getPageCache(fileSystem);
      LogProvider logProvider=NullLogProvider.getInstance();
      Config config=Config.defaults();
      DefaultIdGeneratorFactory idGeneratorFactory=new DefaultIdGeneratorFactory(fileSystem);
      StoreFactory storeFactory=new StoreFactory(directory.databaseLayout(),config,idGeneratorFactory,pageCache,fileSystem,logProvider,EmptyVersionContextSupplier.EMPTY);
      neoStore=storeFactory.openAllNeoStores();
      StoreAccess nativeStores;
      if (keepStatistics) {
        AccessStatistics accessStatistics=new AccessStatistics();
        statistics=new VerboseStatistics(accessStatistics,new DefaultCounts(defaultConsistencyCheckThreadsNumber()),NullLog.getInstance());
        nativeStores=new AccessStatsKeepingStoreAccess(neoStore,accessStatistics);
      }
 else {
        statistics=Statistics.NONE;
        nativeStores=new StoreAccess(neoStore);
      }
      nativeStores.initialize();
      IndexStoreView indexStoreView=new NeoStoreIndexStoreView(LockService.NO_LOCK_SERVICE,nativeStores.getRawNeoStores());
      Monitors monitors=new Monitors();
      LabelScanStore labelScanStore=startLabelScanStore(pageCache,indexStoreView,monitors);
      IndexProviderMap indexes=createIndexes(pageCache,fileSystem,directory.databaseDir(),config,scheduler,logProvider,monitors);
      directStoreAccess=new DirectStoreAccess(nativeStores,labelScanStore,indexes);
    }
    return directStoreAccess;
  }
  private LabelScanStore startLabelScanStore(  PageCache pageCache,  IndexStoreView indexStoreView,  Monitors monitors){
    NativeLabelScanStore labelScanStore=new NativeLabelScanStore(pageCache,directory.databaseLayout(),fileSystem,new FullLabelStream(indexStoreView),false,monitors,RecoveryCleanupWorkCollector.immediate());
    try {
      labelScanStore.init();
      labelScanStore.start();
    }
 catch (    IOException e) {
      throw new UncheckedIOException(e);
    }
    return labelScanStore;
  }
  private IndexProviderMap createIndexes(  PageCache pageCache,  FileSystemAbstraction fileSystem,  File storeDir,  Config config,  JobScheduler scheduler,  LogProvider logProvider,  Monitors monitors){
    LogService logService=new SimpleLogService(logProvider,logProvider);
    TokenHolders tokenHolders=new TokenHolders(new DelegatingTokenHolder(new ReadOnlyTokenCreator(),TokenHolder.TYPE_PROPERTY_KEY),new DelegatingTokenHolder(new ReadOnlyTokenCreator(),TokenHolder.TYPE_LABEL),new DelegatingTokenHolder(new ReadOnlyTokenCreator(),TokenHolder.TYPE_RELATIONSHIP_TYPE));
    DatabaseKernelExtensions extensions=life.add(instantiateKernelExtensions(storeDir,fileSystem,config,logService,pageCache,scheduler,RecoveryCleanupWorkCollector.ignore(),DatabaseInfo.COMMUNITY,monitors,tokenHolders));
    return life.add(new DefaultIndexProviderMap(extensions,config));
  }
  public DatabaseLayout databaseLayout(){
    return directory.databaseLayout();
  }
  public Statistics getAccessStatistics(){
    return statistics;
  }
public abstract static class Transaction {
    final long startTimestamp=currentTimeMillis();
    protected abstract void transactionData(    TransactionDataBuilder tx,    IdGenerator next);
    public TransactionRepresentation representation(    IdGenerator idGenerator,    int masterId,    int authorId,    long lastCommittedTx,    NeoStores neoStores){
      TransactionWriter writer=new TransactionWriter(neoStores);
      transactionData(new TransactionDataBuilder(writer,neoStores.getNodeStore()),idGenerator);
      idGenerator.updateCorrespondingIdGenerators(neoStores);
      return writer.representation(new byte[0],masterId,authorId,startTimestamp,lastCommittedTx,currentTimeMillis());
    }
  }
  public IdGenerator idGenerator(){
    return new IdGenerator();
  }
public class IdGenerator {
    public long schema(){
      return schemaId++;
    }
    public long node(){
      return nodeId++;
    }
    public int label(){
      return labelId++;
    }
    public long nodeLabel(){
      return nodeLabelsId++;
    }
    public long relationship(){
      return relId++;
    }
    public long relationshipGroup(){
      return relGroupId++;
    }
    public long property(){
      return propId++;
    }
    public long stringProperty(){
      return stringPropId++;
    }
    public long arrayProperty(){
      return arrayPropId++;
    }
    public int relationshipType(){
      return relTypeId++;
    }
    public int propertyKey(){
      return propKeyId++;
    }
    void updateCorrespondingIdGenerators(    NeoStores neoStores){
      neoStores.getNodeStore().setHighestPossibleIdInUse(nodeId);
      neoStores.getRelationshipStore().setHighestPossibleIdInUse(relId);
      neoStores.getRelationshipGroupStore().setHighestPossibleIdInUse(relGroupId);
    }
  }
public static final class TransactionDataBuilder {
    private final TransactionWriter writer;
    private final NodeStore nodes;
    TransactionDataBuilder(    TransactionWriter writer,    NodeStore nodes){
      this.writer=writer;
      this.nodes=nodes;
    }
    public void createSchema(    Collection<DynamicRecord> beforeRecords,    Collection<DynamicRecord> afterRecords,    SchemaRule rule){
      writer.createSchema(beforeRecords,afterRecords,rule);
    }
    public void propertyKey(    int id,    String key){
      writer.propertyKey(id,key,id + 1);
    }
    public void nodeLabel(    int id,    String name){
      writer.label(id,name,id + 1);
    }
    public void relationshipType(    int id,    String relationshipType){
      writer.relationshipType(id,relationshipType,id + 1);
    }
    public void update(    NeoStoreRecord before,    NeoStoreRecord after){
      writer.update(before,after);
    }
    public void create(    NodeRecord node){
      updateCounts(node,1);
      writer.create(node);
    }
    public void update(    NodeRecord before,    NodeRecord after){
      updateCounts(before,-1);
      updateCounts(after,1);
      writer.update(before,after);
    }
    public void delete(    NodeRecord node){
      updateCounts(node,-1);
      writer.delete(node);
    }
    public void create(    RelationshipRecord relationship){
      writer.create(relationship);
    }
    public void update(    RelationshipRecord before,    RelationshipRecord after){
      writer.update(before,after);
    }
    public void delete(    RelationshipRecord relationship){
      writer.delete(relationship);
    }
    public void create(    RelationshipGroupRecord group){
      writer.create(group);
    }
    public void update(    RelationshipGroupRecord before,    RelationshipGroupRecord after){
      writer.update(before,after);
    }
    public void delete(    RelationshipGroupRecord group){
      writer.delete(group);
    }
    public void create(    PropertyRecord property){
      writer.create(property);
    }
    public void update(    PropertyRecord before,    PropertyRecord property){
      writer.update(before,property);
    }
    public void delete(    PropertyRecord before,    PropertyRecord property){
      writer.delete(before,property);
    }
    private void updateCounts(    NodeRecord node,    int delta){
      writer.incrementNodeCount(StatementConstants.ANY_LABEL,delta);
      for (      long label : NodeLabelsField.parseLabelsField(node).get(nodes)) {
        writer.incrementNodeCount((int)label,delta);
      }
    }
    public void incrementNodeCount(    int labelId,    long delta){
      writer.incrementNodeCount(labelId,delta);
    }
    public void incrementRelationshipCount(    int startLabelId,    int typeId,    int endLabelId,    long delta){
      writer.incrementRelationshipCount(startLabelId,typeId,endLabelId,delta);
    }
  }
  protected abstract void generateInitialData(  GraphDatabaseService graphDb);
  protected void start(  @SuppressWarnings("UnusedParameters") File storeDir){
  }
  protected void stop() throws Throwable {
    if (directStoreAccess != null) {
      neoStore.close();
      directStoreAccess.close();
      directStoreAccess=null;
    }
  }
  private int myId(){
    return 1;
  }
  private int masterId(){
    return -1;
  }
public class Applier implements AutoCloseable {
    private final GraphDatabaseAPI database;
    private final TransactionRepresentationCommitProcess commitProcess;
    private final TransactionIdStore transactionIdStore;
    private final NeoStores neoStores;
    Applier(){
      database=(GraphDatabaseAPI)new TestGraphDatabaseFactory().newEmbeddedDatabaseBuilder(directory.databaseDir()).setConfig("dbms.backup.enabled","false").newGraphDatabase();
      DependencyResolver dependencyResolver=database.getDependencyResolver();
      commitProcess=new TransactionRepresentationCommitProcess(dependencyResolver.resolveDependency(TransactionAppender.class),dependencyResolver.resolveDependency(StorageEngine.class));
      transactionIdStore=database.getDependencyResolver().resolveDependency(TransactionIdStore.class);
      neoStores=database.getDependencyResolver().resolveDependency(RecordStorageEngine.class).testAccessNeoStores();
    }
    public void apply(    Transaction transaction) throws TransactionFailureException {
      TransactionRepresentation representation=transaction.representation(idGenerator(),masterId(),myId(),transactionIdStore.getLastCommittedTransactionId(),neoStores);
      commitProcess.commit(new TransactionToApply(representation),CommitEvent.NULL,TransactionApplicationMode.EXTERNAL);
    }
    @Override public void close(){
      database.shutdown();
    }
  }
  public Applier createApplier(){
    return new Applier();
  }
  private void applyTransaction(  Transaction transaction) throws TransactionFailureException {
    try (Applier applier=createApplier()){
      applier.apply(transaction);
    }
   }
  private void generateInitialData(){
    GraphDatabaseBuilder builder=new TestGraphDatabaseFactory().newEmbeddedDatabaseBuilder(directory.databaseDir());
    GraphDatabaseAPI graphDb=(GraphDatabaseAPI)builder.setConfig(GraphDatabaseSettings.record_format,formatName).setConfig(GraphDatabaseSettings.label_block_size,"60").setConfig("dbms.backup.enabled","false").newGraphDatabase();
    try {
      generateInitialData(graphDb);
      StoreAccess stores=new StoreAccess(graphDb.getDependencyResolver().resolveDependency(RecordStorageEngine.class).testAccessNeoStores()).initialize();
      schemaId=stores.getSchemaStore().getHighId();
      nodeId=stores.getNodeStore().getHighId();
      labelId=(int)stores.getLabelTokenStore().getHighId();
      nodeLabelsId=stores.getNodeDynamicLabelStore().getHighId();
      relId=stores.getRelationshipStore().getHighId();
      relGroupId=stores.getRelationshipGroupStore().getHighId();
      propId=(int)stores.getPropertyStore().getHighId();
      stringPropId=stores.getStringStore().getHighId();
      arrayPropId=stores.getArrayStore().getHighId();
      relTypeId=(int)stores.getRelationshipTypeTokenStore().getHighId();
      propKeyId=(int)stores.getPropertyKeyNameStore().getHighId();
    }
  finally {
      graphDb.shutdown();
    }
  }
  @Override public Statement apply(  final Statement base,  Description description){
    final TestDirectory directory=TestDirectory.testDirectory(description.getTestClass());
    return super.apply(directory.apply(new Statement(){
      @Override public void evaluate() throws Throwable {
        GraphStoreFixture.this.directory=directory;
        try {
          generateInitialData();
          start(GraphStoreFixture.this.directory.databaseDir());
          try {
            base.evaluate();
          }
  finally {
            stop();
          }
        }
  finally {
          GraphStoreFixture.this.directory=null;
        }
      }
    }
,description),description);
  }
}
