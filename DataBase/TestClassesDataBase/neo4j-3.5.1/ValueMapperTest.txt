class ValueMapperTest {
  private static Stream<AnyValue> parameters(){
    NodeValue node1=nodeValue(1,stringArray(),emptyMap());
    NodeValue node2=nodeValue(2,stringArray(),emptyMap());
    NodeValue node3=nodeValue(3,stringArray(),emptyMap());
    RelationshipValue relationship1=relationshipValue(100,node1,node2,stringValue("ONE"),emptyMap());
    RelationshipValue relationship2=relationshipValue(200,node2,node2,stringValue("TWO"),emptyMap());
    return Stream.of(node1,relationship1,path(new NodeValue[]{node1,node2,node3},new RelationshipValue[]{relationship1,relationship2}),map(new String[]{"alpha","beta"},new AnyValue[]{stringValue("one"),numberValue(2)}),NO_VALUE,list(numberValue(1),stringValue("fine"),node2),stringValue("hello world"),stringArray("hello","brave","new","world"),booleanValue(false),booleanArray(new boolean[]{true,false,true}),charValue('\n'),charArray(new char[]{'h','e','l','l','o'}),byteValue((byte)3),byteArray(new byte[]{0x00,(byte)0x99,(byte)0xcc}),shortValue((short)42),shortArray(new short[]{1337,(short)0xcafe,(short)0xbabe}),intValue(987654321),intArray(new int[]{42,11}),longValue(9876543210L),longArray(new long[]{0xcafebabe,0x1ee7}),floatValue(Float.MAX_VALUE),floatArray(new float[]{Float.NEGATIVE_INFINITY,Float.MIN_VALUE}),doubleValue(Double.MIN_NORMAL),doubleArray(new double[]{Double.POSITIVE_INFINITY,Double.MAX_VALUE}),datetime(2018,1,16,10,36,43,123456788,ZoneId.of("Europe/Stockholm")),localDateTime(2018,1,16,10,36,43,123456788),date(2018,1,16),time(10,36,43,123456788,ZoneOffset.ofHours(1)),localTime(10,36,43,123456788),duration(399,4,48424,133701337),pointValue(Cartesian,11,32),pointArray(new Point[]{pointValue(Cartesian,11,32),pointValue(WGS84,13,56)}));
  }
  @ParameterizedTest @MethodSource("parameters") void shouldMapToJavaObject(  AnyValue value){
    ValueMapper<Object> mapper=new Mapper();
    Object mapped=value.map(mapper);
    assertEquals(value,valueOf(mapped));
  }
  private static AnyValue valueOf(  Object obj){
    if (obj instanceof MappedGraphType) {
      return ((MappedGraphType)obj).value;
    }
    Value value=Values.unsafeOf(obj,true);
    if (value != null) {
      return value;
    }
    if (obj instanceof List<?>) {
      return fromList(((List<?>)obj).stream().map(ValueMapperTest::valueOf).collect(toList()));
    }
    if (obj instanceof Map<?,?>) {
      @SuppressWarnings("unchecked") Map<String,?> map=(Map<String,?>)obj;
      MapValueBuilder builder=new MapValueBuilder(map.size());
      for (      Map.Entry<String,?> entry : map.entrySet()) {
        builder.add(entry.getKey(),valueOf(entry.getValue()));
      }
      return builder.build();
    }
    throw new AssertionError("cannot convert: " + obj + " (a "+ obj.getClass().getName()+ ")");
  }
private static class Mapper extends ValueMapper.JavaMapper {
    @Override public Object mapPath(    PathValue value){
      return new MappedGraphType(value);
    }
    @Override public Object mapNode(    VirtualNodeValue value){
      return new MappedGraphType(value);
    }
    @Override public Object mapRelationship(    VirtualRelationshipValue value){
      return new MappedGraphType(value);
    }
  }
private static class MappedGraphType {
    private final VirtualValue value;
    MappedGraphType(    VirtualValue value){
      this.value=value;
    }
  }
}
