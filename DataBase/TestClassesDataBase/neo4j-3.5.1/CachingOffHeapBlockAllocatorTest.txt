class CachingOffHeapBlockAllocatorTest {
  private static final int CACHE_SIZE=4;
  private static final int MAX_CACHEABLE_BLOCK_SIZE=128;
  private final MemoryAllocationTracker memoryTracker=new LocalMemoryTracker();
  private final CachingOffHeapBlockAllocator allocator=spy(new CachingOffHeapBlockAllocator(MAX_CACHEABLE_BLOCK_SIZE,CACHE_SIZE));
  @AfterEach void afterEach(){
    allocator.release();
    assertEquals(0,memoryTracker.usedDirectMemory(),"Native memory is leaking");
  }
  @Test void allocateAfterRelease(){
    allocator.release();
    assertThrows(IllegalStateException.class,() -> allocator.allocate(128,memoryTracker));
  }
  @Test void freeAfterRelease(){
    final MemoryBlock block=allocator.allocate(128,memoryTracker);
    allocator.release();
    allocator.free(block,memoryTracker);
    verify(allocator).doFree(eq(block),any());
  }
  @Test void allocateAndFree(){
    final MemoryBlock block1=allocator.allocate(128,memoryTracker);
    assertEquals(block1.size,128);
    assertEquals(128 + Long.BYTES - 1,block1.unalignedSize);
    assertEquals(block1.unalignedSize,memoryTracker.usedDirectMemory());
    final MemoryBlock block2=allocator.allocate(256,memoryTracker);
    assertEquals(block2.size,256);
    assertEquals(256 + Long.BYTES - 1,block2.unalignedSize);
    assertEquals(block1.unalignedSize + block2.unalignedSize,memoryTracker.usedDirectMemory());
    allocator.free(block1,memoryTracker);
    allocator.free(block2,memoryTracker);
    assertEquals(0,memoryTracker.usedDirectMemory());
  }
  @ParameterizedTest @ValueSource(longs={10,100,256}) void allocateNonCacheableSize(  long bytes){
    final MemoryBlock block1=allocator.allocate(bytes,memoryTracker);
    allocator.free(block1,memoryTracker);
    final MemoryBlock block2=allocator.allocate(bytes,memoryTracker);
    allocator.free(block2,memoryTracker);
    verify(allocator,times(2)).allocateNew(eq(bytes),any());
    verify(allocator).doFree(eq(block1),any());
    verify(allocator).doFree(eq(block2),any());
    assertEquals(0,memoryTracker.usedDirectMemory());
  }
  @ParameterizedTest @ValueSource(longs={8,64,128}) void allocateCacheableSize(  long bytes){
    final MemoryBlock block1=allocator.allocate(bytes,memoryTracker);
    allocator.free(block1,memoryTracker);
    final MemoryBlock block2=allocator.allocate(bytes,memoryTracker);
    allocator.free(block2,memoryTracker);
    verify(allocator).allocateNew(eq(bytes),any());
    verify(allocator,never()).doFree(any(),any());
    assertEquals(0,memoryTracker.usedDirectMemory());
  }
  @Test void cacheCapacityPerBlockSize(){
    final int EXTRA=3;
    final List<MemoryBlock> blocks64=new ArrayList<>();
    final List<MemoryBlock> blocks128=new ArrayList<>();
    for (int i=0; i < CACHE_SIZE + EXTRA; i++) {
      blocks64.add(allocator.allocate(64,memoryTracker));
      blocks128.add(allocator.allocate(128,memoryTracker));
    }
    verify(allocator,times(CACHE_SIZE + EXTRA)).allocateNew(eq(64L),any());
    verify(allocator,times(CACHE_SIZE + EXTRA)).allocateNew(eq(128L),any());
    assertEquals((CACHE_SIZE + EXTRA) * (64 + 128 + 2 * (Long.BYTES - 1)),memoryTracker.usedDirectMemory());
    blocks64.forEach(it -> allocator.free(it,memoryTracker));
    assertEquals((CACHE_SIZE + EXTRA) * (128 + Long.BYTES - 1),memoryTracker.usedDirectMemory());
    blocks128.forEach(it -> allocator.free(it,memoryTracker));
    assertEquals(0,memoryTracker.usedDirectMemory());
    verify(allocator,times(EXTRA * 2)).doFree(any(),any());
  }
}
