public class DijkstraIncreasingWeightTest extends Neo4jAlgoTestCase {
  @Test public void canFetchLongerPaths(){
    Node s=graph.makeNode("s");
    Node a=graph.makeNode("a");
    Node b=graph.makeNode("b");
    Node c=graph.makeNode("c");
    Node d=graph.makeNode("d");
    Node t=graph.makeNode("t");
    graph.makeEdge("s","a","length",1);
    graph.makeEdge("a","c","length",1);
    graph.makeEdge("s","b","length",1);
    graph.makeEdge("b","a","length",1);
    graph.makeEdge("c","d","length",10);
    graph.makeEdge("d","t","length",10);
    PathExpander expander=PathExpanders.allTypesAndDirections();
    Dijkstra algo=new Dijkstra(expander,CommonEvaluators.doubleCostEvaluator("length"),PathInterestFactory.all(NoneStrictMath.EPSILON));
    Iterator<WeightedPath> paths=algo.findAllPaths(s,t).iterator();
    assertTrue("Expected at least one path.",paths.hasNext());
    assertPath(paths.next(),s,a,c,d,t);
    assertTrue("Expected two paths",paths.hasNext());
    assertPath(paths.next(),s,b,a,c,d,t);
  }
  @Test public void shouldReturnPathsInIncreasingOrderOfCost(){
    Node s=graph.makeNode("s");
    Node t=graph.makeNode("t");
    graph.makeEdgeChain("s,e,f","length",1.0);
    graph.makeEdge("f","t","length",2);
    graph.makeEdge("s","a","length",2);
    graph.makeEdge("a","t","length",0);
    graph.makeEdge("s","c","length",1);
    graph.makeEdge("c","d","length",1);
    graph.makeEdge("s","b","length",1);
    graph.makeEdge("b","d","length",1);
    graph.makeEdge("d","a","length",0);
    graph.makeEdge("d","t","length",1);
    PathExpander expander=PathExpanders.allTypesAndDirections();
    Dijkstra algo=new Dijkstra(expander,CommonEvaluators.doubleCostEvaluator("length"),PathInterestFactory.all(NoneStrictMath.EPSILON));
    Iterator<WeightedPath> paths=algo.findAllPaths(s,t).iterator();
    for (int i=1; i <= 3; i++) {
      assertTrue("Expected at least " + i + " path(s)",paths.hasNext());
      assertTrue("Expected 3 paths of cost 2",NoneStrictMath.equals(paths.next().weight(),2));
    }
    for (int i=1; i <= 3; i++) {
      assertTrue("Expected at least " + i + " path(s)",paths.hasNext());
      assertTrue("Expected 3 paths of cost 3",NoneStrictMath.equals(paths.next().weight(),3));
    }
    assertTrue("Expected at least 7 paths",paths.hasNext());
    assertTrue("Expected 1 path of cost 4",NoneStrictMath.equals(paths.next().weight(),4));
    assertFalse("Expected exactly 7 paths",paths.hasNext());
  }
  @Test(timeout=5000) public void testForLoops(){
    try (Transaction tx=graphDb.beginTx()){
      Node s=graph.makeNode("s");
      Node t=graph.makeNode("t");
      graph.makeEdge("s","a1","length",1);
      graph.makeEdge("a1","b","length",0);
      graph.makeEdge("b","a1","length",0);
      graph.makeEdge("a1","a2","length",1);
      graph.makeEdge("a2","a2","length",0);
      graph.makeEdge("a2","a3","length",1);
      graph.makeEdge("a3","c1","length",0);
      graph.makeEdge("a3","c2","length",0);
      graph.makeEdge("c1","a4","length",0);
      graph.makeEdge("c1","a4","length",0);
      graph.makeEdge("a4","t","length",1);
      PathExpander expander=PathExpanders.allTypesAndDirections();
      Dijkstra algo=new Dijkstra(expander,CommonEvaluators.doubleCostEvaluator("length"),PathInterestFactory.all(NoneStrictMath.EPSILON));
      Iterator<WeightedPath> paths=algo.findAllPaths(s,t).iterator();
      assertTrue("Expected at least one path",paths.hasNext());
      assertEquals("Expected first path of length 6",6,paths.next().length());
      assertTrue("Expected at least two paths",paths.hasNext());
      assertEquals("Expected second path of length 6",6,paths.next().length());
      assertFalse("Expected exactly two paths",paths.hasNext());
      tx.success();
    }
   }
  @Test public void testKShortestPaths(){
    Node s=graph.makeNode("s");
    Node t=graph.makeNode("t");
    graph.makeEdge("s","a","length",2);
    graph.makeEdge("s","b","length",1);
    graph.makeEdge("s","c","length",1);
    graph.makeEdge("s","e","length",3);
    graph.makeEdge("a","t","length",0);
    graph.makeEdge("b","d","length",1);
    graph.makeEdge("c","d","length",1);
    graph.makeEdge("d","a","length",0);
    graph.makeEdge("d","t","length",1);
    graph.makeEdge("e","f","length",3);
    graph.makeEdge("f","t","length",3);
    PathExpander expander=PathExpanders.allTypesAndDirections();
    PathFinder<WeightedPath> algo=new Dijkstra(expander,CommonEvaluators.doubleCostEvaluator("length"),PathInterestFactory.numberOfShortest(NoneStrictMath.EPSILON,6));
    Iterator<WeightedPath> paths=algo.findAllPaths(s,t).iterator();
    int count=0;
    while (paths.hasNext()) {
      count++;
      WeightedPath path=paths.next();
      double expectedWeight;
      if (count <= 3) {
        expectedWeight=2.0;
      }
 else {
        expectedWeight=3.0;
      }
      assertTrue("Expected path number " + count + " to have weight of "+ expectedWeight,NoneStrictMath.equals(path.weight(),expectedWeight));
    }
    assertEquals("Expected exactly 6 returned paths",6,count);
  }
  @Test public void withState(){
    graph.makeEdgeChain("a,b,c,d");
    setWeight("a","b",1);
    setWeight("b","c",2);
    setWeight("c","d",5);
    InitialBranchState<Integer> state=new InitialBranchState.State<>(0,0);
    final Map<Node,Integer> encounteredState=new HashMap<>();
    PathExpander<Integer> expander=new PathExpander<Integer>(){
      @Override public Iterable<Relationship> expand(      Path path,      BranchState<Integer> state){
        if (path.length() > 0) {
          int newState=state.getState() + ((Number)path.lastRelationship().getProperty("weight")).intValue();
          state.setState(newState);
          encounteredState.put(path.endNode(),newState);
        }
        return path.endNode().getRelationships();
      }
      @Override public PathExpander<Integer> reverse(){
        return this;
      }
    }
;
    PathFinder<WeightedPath> finder=new Dijkstra(expander,state,CommonEvaluators.doubleCostEvaluator("weight"));
    assertPaths(finder.findAllPaths(graph.getNode("a"),graph.getNode("d")),"a,b,c,d");
    assertEquals(1,encounteredState.get(graph.getNode("b")).intValue());
    assertEquals(3,encounteredState.get(graph.getNode("c")).intValue());
    assertEquals(8,encounteredState.get(graph.getNode("d")).intValue());
  }
  private void setWeight(  String start,  String end,  double weight){
    Node startNode=graph.getNode(start);
    Node endNode=graph.getNode(end);
    ResourceIterable<Relationship> relationships=Iterables.asResourceIterable(startNode.getRelationships());
    try (ResourceIterator<Relationship> resourceIterator=relationships.iterator()){
      while (resourceIterator.hasNext()) {
        Relationship rel=resourceIterator.next();
        if (rel.getOtherNode(startNode).equals(endNode)) {
          rel.setProperty("weight",weight);
          return;
        }
      }
    }
     throw new RuntimeException("No relationship between nodes " + start + " and "+ end);
  }
}
