public class SchemaRuleCommandTest {
  private final int labelId=2;
  private final int propertyKey=8;
  private final long id=0;
  private final long txId=1337L;
  private final NeoStores neoStores=mock(NeoStores.class);
  private final MetaDataStore metaDataStore=mock(MetaDataStore.class);
  private final SchemaStore schemaStore=mock(SchemaStore.class);
  private final IndexingService indexes=mock(IndexingService.class);
  @SuppressWarnings("unchecked") private final Supplier<LabelScanWriter> labelScanStore=mock(Supplier.class);
  private final NeoStoreBatchTransactionApplier storeApplier=new NeoStoreBatchTransactionApplier(neoStores,mock(CacheAccessBackDoor.class),LockService.NO_LOCK_SERVICE);
  private final WorkSync<Supplier<LabelScanWriter>,LabelUpdateWork> labelScanStoreSynchronizer=new WorkSync<>(labelScanStore);
  private final WorkSync<IndexingUpdateService,IndexUpdatesWork> indexUpdatesSync=new WorkSync<>(indexes);
  private final PropertyStore propertyStore=mock(PropertyStore.class);
  private final IndexBatchTransactionApplier indexApplier=new IndexBatchTransactionApplier(indexes,labelScanStoreSynchronizer,indexUpdatesSync,mock(NodeStore.class),neoStores.getRelationshipStore(),new PropertyPhysicalToLogicalConverter(propertyStore));
  private final BaseCommandReader reader=new PhysicalLogCommandReaderV3_0_2();
  private final StoreIndexDescriptor rule=TestIndexDescriptorFactory.forLabel(labelId,propertyKey).withId(id);
  @Test public void shouldWriteCreatedSchemaRuleToStore() throws Exception {
    SchemaRecord beforeRecords=serialize(rule,id,false,false);
    SchemaRecord afterRecords=serialize(rule,id,true,true);
    when(neoStores.getSchemaStore()).thenReturn(schemaStore);
    visitSchemaRuleCommand(storeApplier,new SchemaRuleCommand(beforeRecords,afterRecords,rule));
    verify(schemaStore).updateRecord(Iterables.first(afterRecords));
  }
  @Test public void shouldCreateIndexForCreatedSchemaRule() throws Exception {
    SchemaRecord beforeRecords=serialize(rule,id,false,false);
    SchemaRecord afterRecords=serialize(rule,id,true,true);
    when(neoStores.getSchemaStore()).thenReturn(schemaStore);
    visitSchemaRuleCommand(indexApplier,new SchemaRuleCommand(beforeRecords,afterRecords,rule));
    verify(indexes).createIndexes(rule);
  }
  @Test public void shouldSetLatestConstraintRule() throws Exception {
    SchemaRecord beforeRecords=serialize(rule,id,true,true);
    SchemaRecord afterRecords=serialize(rule,id,true,false);
    when(neoStores.getSchemaStore()).thenReturn(schemaStore);
    when(neoStores.getMetaDataStore()).thenReturn(metaDataStore);
    ConstraintRule schemaRule=ConstraintRule.constraintRule(id,ConstraintDescriptorFactory.uniqueForLabel(labelId,propertyKey),0);
    visitSchemaRuleCommand(storeApplier,new SchemaRuleCommand(beforeRecords,afterRecords,schemaRule));
    verify(schemaStore).updateRecord(Iterables.first(afterRecords));
    verify(metaDataStore).setLatestConstraintIntroducingTx(txId);
  }
  @Test public void shouldDropSchemaRuleFromStore() throws Exception {
    SchemaRecord beforeRecords=serialize(rule,id,true,true);
    SchemaRecord afterRecords=serialize(rule,id,false,false);
    when(neoStores.getSchemaStore()).thenReturn(schemaStore);
    visitSchemaRuleCommand(storeApplier,new SchemaRuleCommand(beforeRecords,afterRecords,rule));
    verify(schemaStore).updateRecord(Iterables.first(afterRecords));
  }
  @Test public void shouldDropSchemaRuleFromIndex() throws Exception {
    SchemaRecord beforeRecords=serialize(rule,id,true,true);
    SchemaRecord afterRecords=serialize(rule,id,false,false);
    when(neoStores.getSchemaStore()).thenReturn(schemaStore);
    visitSchemaRuleCommand(indexApplier,new SchemaRuleCommand(beforeRecords,afterRecords,rule));
    verify(indexes).dropIndex(rule);
  }
  @Test public void shouldWriteSchemaRuleToLog() throws Exception {
    SchemaRecord beforeRecords=serialize(rule,id,false,false);
    SchemaRecord afterRecords=serialize(rule,id,true,true);
    SchemaRuleCommand command=new SchemaRuleCommand(beforeRecords,afterRecords,rule);
    InMemoryClosableChannel buffer=new InMemoryClosableChannel();
    when(neoStores.getSchemaStore()).thenReturn(schemaStore);
    command.serialize(buffer);
    Command readCommand=reader.read(buffer);
    assertThat(readCommand,instanceOf(SchemaRuleCommand.class));
    assertSchemaRule((SchemaRuleCommand)readCommand);
  }
  @Test public void shouldRecreateSchemaRuleWhenDeleteCommandReadFromDisk() throws Exception {
    SchemaRecord beforeRecords=serialize(rule,id,true,true);
    SchemaRecord afterRecords=serialize(rule,id,false,false);
    SchemaRuleCommand command=new SchemaRuleCommand(beforeRecords,afterRecords,rule);
    InMemoryClosableChannel buffer=new InMemoryClosableChannel();
    when(neoStores.getSchemaStore()).thenReturn(schemaStore);
    command.serialize(buffer);
    Command readCommand=reader.read(buffer);
    assertThat(readCommand,instanceOf(SchemaRuleCommand.class));
    assertSchemaRule((SchemaRuleCommand)readCommand);
  }
  private SchemaRecord serialize(  SchemaRule rule,  long id,  boolean inUse,  boolean created){
    DynamicRecord record=new DynamicRecord(id);
    record.setData(SchemaRuleSerialization.serialize(rule));
    if (created) {
      record.setCreated();
    }
    if (inUse) {
      record.setInUse(true);
    }
    return new SchemaRecord(singletonList(record));
  }
  private void assertSchemaRule(  SchemaRuleCommand readSchemaCommand){
    assertEquals(id,readSchemaCommand.getKey());
    assertTrue(SchemaDescriptorPredicates.hasLabel(readSchemaCommand.getSchemaRule(),labelId));
    assertTrue(SchemaDescriptorPredicates.hasProperty(readSchemaCommand.getSchemaRule(),propertyKey));
  }
  private void visitSchemaRuleCommand(  BatchTransactionApplier applier,  SchemaRuleCommand command) throws Exception {
    TransactionToApply tx=new TransactionToApply(new PhysicalTransactionRepresentation(singletonList(command)),txId);
    CommandHandlerContract.apply(applier,tx);
  }
}
