public class IndexIT extends KernelIntegrationTest {
  private static final String LABEL="Label";
  private static final String LABEL2="Label2";
  private static final String REL_TYPE="RelType";
  private static final String REL_TYPE2="RelType2";
  private static final String PROPERTY_KEY="prop";
  private static final String PROPERTY_KEY2="prop2";
  private int labelId;
  private int labelId2;
  private int relType;
  private int relType2;
  private int propertyKeyId;
  private int propertyKeyId2;
  private LabelSchemaDescriptor descriptor;
  private LabelSchemaDescriptor descriptor2;
  private ExecutorService executorService;
  @Before public void createLabelAndProperty() throws Exception {
    TokenWrite tokenWrites=tokenWriteInNewTransaction();
    labelId=tokenWrites.labelGetOrCreateForName(LABEL);
    labelId2=tokenWrites.labelGetOrCreateForName(LABEL2);
    relType=tokenWrites.relationshipTypeGetOrCreateForName(REL_TYPE);
    relType2=tokenWrites.relationshipTypeGetOrCreateForName(REL_TYPE2);
    propertyKeyId=tokenWrites.propertyKeyGetOrCreateForName(PROPERTY_KEY);
    propertyKeyId2=tokenWrites.propertyKeyGetOrCreateForName(PROPERTY_KEY2);
    descriptor=SchemaDescriptorFactory.forLabel(labelId,propertyKeyId);
    descriptor2=SchemaDescriptorFactory.forLabel(labelId,propertyKeyId2);
    commit();
    executorService=Executors.newCachedThreadPool();
  }
  @After public void tearDown(){
    executorService.shutdown();
  }
  @Test public void createIndexForAnotherLabelWhileHoldingSharedLockOnOtherLabel() throws KernelException {
    TokenWrite tokenWrite=tokenWriteInNewTransaction();
    int label2=tokenWrite.labelGetOrCreateForName("Label2");
    Write write=dataWriteInNewTransaction();
    long nodeId=write.nodeCreate();
    write.nodeAddLabel(nodeId,label2);
    schemaWriteInNewTransaction().indexCreate(descriptor);
    commit();
  }
  @Test(timeout=10_000) public void createIndexesForDifferentLabelsConcurrently() throws Throwable {
    TokenWrite tokenWrite=tokenWriteInNewTransaction();
    int label2=tokenWrite.labelGetOrCreateForName("Label2");
    LabelSchemaDescriptor anotherLabelDescriptor=SchemaDescriptorFactory.forLabel(label2,propertyKeyId);
    schemaWriteInNewTransaction().indexCreate(anotherLabelDescriptor);
    Future<?> indexFuture=executorService.submit(createIndex(db,label(LABEL),PROPERTY_KEY));
    indexFuture.get();
    commit();
  }
  @Test public void addIndexRuleInATransaction() throws Exception {
    SchemaWrite schemaWriteOperations=schemaWriteInNewTransaction();
    IndexReference expectedRule=schemaWriteOperations.indexCreate(descriptor);
    commit();
    SchemaRead schemaRead=newTransaction().schemaRead();
    assertEquals(asSet(expectedRule),asSet(schemaRead.indexesGetForLabel(labelId)));
    assertEquals(expectedRule,schemaRead.index(descriptor.getLabelId(),descriptor.getPropertyIds()));
    commit();
  }
  @Test public void committedAndTransactionalIndexRulesShouldBeMerged() throws Exception {
    SchemaWrite schemaWriteOperations=schemaWriteInNewTransaction();
    IndexReference existingRule=schemaWriteOperations.indexCreate(descriptor);
    commit();
    Transaction transaction=newTransaction(AUTH_DISABLED);
    IndexReference addedRule=transaction.schemaWrite().indexCreate(SchemaDescriptorFactory.forLabel(labelId,10));
    Set<IndexReference> indexRulesInTx=asSet(transaction.schemaRead().indexesGetForLabel(labelId));
    commit();
    assertEquals(asSet(existingRule,addedRule),indexRulesInTx);
  }
  @Test public void rollBackIndexRuleShouldNotBeCommitted() throws Exception {
    SchemaWrite schemaWrite=schemaWriteInNewTransaction();
    schemaWrite.indexCreate(descriptor);
    rollback();
    Transaction transaction=newTransaction();
    assertEquals(emptySet(),asSet(transaction.schemaRead().indexesGetForLabel(labelId)));
    commit();
  }
  @Test public void shouldBeAbleToRemoveAConstraintIndexWithoutOwner() throws Exception {
    NodePropertyAccessor propertyAccessor=mock(NodePropertyAccessor.class);
    AssertableLogProvider logProvider=new AssertableLogProvider();
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,propertyAccessor,logProvider);
    String defaultProvider=Config.defaults().get(default_schema_provider);
    IndexDescriptor constraintIndex=creator.createConstraintIndex(descriptor,defaultProvider);
    Transaction transaction=newTransaction();
    assertEquals(emptySet(),asSet(transaction.schemaRead().constraintsGetForLabel(labelId)));
    commit();
    SchemaWrite schemaWrite=schemaWriteInNewTransaction();
    schemaWrite.indexDrop(constraintIndex);
    commit();
    transaction=newTransaction();
    assertEquals(emptySet(),asSet(transaction.schemaRead().indexesGetForLabel(labelId)));
    commit();
  }
  @Test public void shouldDisallowDroppingIndexThatDoesNotExist() throws Exception {
    IndexReference index;
{
      SchemaWrite statement=schemaWriteInNewTransaction();
      index=statement.indexCreate(descriptor);
      commit();
    }
{
      SchemaWrite statement=schemaWriteInNewTransaction();
      statement.indexDrop(index);
      commit();
    }
    try {
      SchemaWrite statement=schemaWriteInNewTransaction();
      statement.indexDrop(index);
      commit();
    }
 catch (    SchemaKernelException e) {
      assertEquals("Unable to drop index on :label[" + labelId + "](property["+ propertyKeyId+ "]): "+ "No such INDEX ON :label["+ labelId+ "](property["+ propertyKeyId+ "]).",e.getMessage());
    }
    commit();
  }
  @Test public void shouldFailToCreateIndexWhereAConstraintAlreadyExists() throws Exception {
{
      SchemaWrite statement=schemaWriteInNewTransaction();
      statement.uniquePropertyConstraintCreate(descriptor);
      commit();
    }
    try {
      SchemaWrite statement=schemaWriteInNewTransaction();
      statement.indexCreate(descriptor);
      commit();
      fail("expected exception");
    }
 catch (    SchemaKernelException e) {
      assertEquals("There is a uniqueness constraint on :" + LABEL + "("+ PROPERTY_KEY+ "), so an index is "+ "already created that matches this.",e.getMessage());
    }
    commit();
  }
  @Test public void shouldListConstraintIndexesInTheCoreAPI() throws Exception {
    Transaction transaction=newTransaction(AUTH_DISABLED);
    transaction.schemaWrite().uniquePropertyConstraintCreate(SchemaDescriptorFactory.forLabel(transaction.tokenWrite().labelGetOrCreateForName("Label1"),transaction.tokenWrite().propertyKeyGetOrCreateForName("property1")));
    commit();
    try (org.neo4j.graphdb.Transaction ignore=db.beginTx()){
      Set<IndexDefinition> indexes=Iterables.asSet(db.schema().getIndexes());
      assertEquals(1,indexes.size());
      IndexDefinition index=indexes.iterator().next();
      assertEquals("Label1",single(index.getLabels()).name());
      assertEquals(asSet("property1"),Iterables.asSet(index.getPropertyKeys()));
      assertTrue("index should be a constraint index",index.isConstraintIndex());
      try {
        index.drop();
        fail("expected exception");
      }
 catch (      IllegalStateException e) {
        assertEquals("Constraint indexes cannot be dropped directly, " + "instead drop the owning uniqueness constraint.",e.getMessage());
      }
    }
   }
  @Test public void shouldListMultiTokenIndexesInTheCoreAPI() throws Exception {
    Transaction transaction=newTransaction(AUTH_DISABLED);
    MultiTokenSchemaDescriptor descriptor=SchemaDescriptorFactory.multiToken(new int[]{labelId,labelId2},EntityType.NODE,propertyKeyId);
    transaction.schemaWrite().indexCreate(descriptor);
    commit();
    try (@SuppressWarnings("unused") org.neo4j.graphdb.Transaction tx=db.beginTx()){
      Set<IndexDefinition> indexes=Iterables.asSet(db.schema().getIndexes());
      assertEquals(1,indexes.size());
      IndexDefinition index=indexes.iterator().next();
      try {
        index.getLabel();
        fail("index.getLabel() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      try {
        index.getRelationshipType();
        fail("index.getRelationshipType() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      try {
        index.getRelationshipTypes();
        fail("index.getRelationshipTypes() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      assertThat(index.getLabels(),containsInAnyOrder(label(LABEL),label(LABEL2)));
      assertFalse("should not be a constraint index",index.isConstraintIndex());
      assertTrue("should be a multi-token index",index.isMultiTokenIndex());
      assertFalse("should not be a composite index",index.isCompositeIndex());
      assertTrue("should be a node index",index.isNodeIndex());
      assertFalse("should not be a relationship index",index.isRelationshipIndex());
      assertEquals(asSet(PROPERTY_KEY),Iterables.asSet(index.getPropertyKeys()));
    }
   }
  @Test public void shouldListCompositeIndexesInTheCoreAPI() throws Exception {
    Transaction transaction=newTransaction(AUTH_DISABLED);
    SchemaDescriptor descriptor=SchemaDescriptorFactory.forLabel(labelId,propertyKeyId,propertyKeyId2);
    transaction.schemaWrite().indexCreate(descriptor);
    commit();
    try (@SuppressWarnings("unused") org.neo4j.graphdb.Transaction tx=db.beginTx()){
      Set<IndexDefinition> indexes=Iterables.asSet(db.schema().getIndexes());
      assertEquals(1,indexes.size());
      IndexDefinition index=indexes.iterator().next();
      assertEquals(LABEL,single(index.getLabels()).name());
      assertThat(index.getLabels(),containsInAnyOrder(label(LABEL)));
      try {
        index.getRelationshipType();
        fail("index.getRelationshipType() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      try {
        index.getRelationshipTypes();
        fail("index.getRelationshipTypes() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      assertFalse("should not be a constraint index",index.isConstraintIndex());
      assertFalse("should not be a multi-token index",index.isMultiTokenIndex());
      assertTrue("should be a composite index",index.isCompositeIndex());
      assertTrue("should be a node index",index.isNodeIndex());
      assertFalse("should not be a relationship index",index.isRelationshipIndex());
      assertEquals(asSet(PROPERTY_KEY,PROPERTY_KEY2),Iterables.asSet(index.getPropertyKeys()));
    }
   }
  @Test public void shouldListRelationshipIndexesInTheCoreAPI() throws Exception {
    Transaction transaction=newTransaction(AUTH_DISABLED);
    SchemaDescriptor descriptor=SchemaDescriptorFactory.forRelType(relType,propertyKeyId);
    transaction.schemaWrite().indexCreate(descriptor);
    commit();
    try (org.neo4j.graphdb.Transaction tx=db.beginTx()){
      Set<IndexDefinition> indexes=Iterables.asSet(db.schema().getIndexes());
      assertEquals(1,indexes.size());
      IndexDefinition index=indexes.iterator().next();
      try {
        index.getLabel();
        fail("index.getLabel() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      try {
        index.getLabels();
        fail("index.getLabels() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      assertEquals(REL_TYPE,index.getRelationshipType().name());
      assertEquals(singletonList(withName(REL_TYPE)),index.getRelationshipTypes());
      assertFalse("should not be a constraint index",index.isConstraintIndex());
      assertFalse("should not be a multi-token index",index.isMultiTokenIndex());
      assertFalse("should not be a composite index",index.isCompositeIndex());
      assertFalse("should not be a node index",index.isNodeIndex());
      assertTrue("should be a relationship index",index.isRelationshipIndex());
      assertEquals(asSet(PROPERTY_KEY),Iterables.asSet(index.getPropertyKeys()));
    }
   }
  @Test public void shouldListCompositeMultiTokenRelationshipIndexesInTheCoreAPI() throws Exception {
    Transaction transaction=newTransaction(AUTH_DISABLED);
    SchemaDescriptor descriptor=SchemaDescriptorFactory.multiToken(new int[]{relType,relType2},EntityType.RELATIONSHIP,propertyKeyId,propertyKeyId2);
    transaction.schemaWrite().indexCreate(descriptor);
    commit();
    try (org.neo4j.graphdb.Transaction tx=db.beginTx()){
      Set<IndexDefinition> indexes=Iterables.asSet(db.schema().getIndexes());
      assertEquals(1,indexes.size());
      IndexDefinition index=indexes.iterator().next();
      try {
        index.getLabel();
        fail("index.getLabel() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      try {
        index.getLabels();
        fail("index.getLabels() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      try {
        index.getRelationshipType();
        fail("index.getRelationshipType() should have thrown. ");
      }
 catch (      IllegalStateException ignore) {
      }
      assertThat(index.getRelationshipTypes(),containsInAnyOrder(withName(REL_TYPE),withName(REL_TYPE2)));
      assertFalse("should not be a constraint index",index.isConstraintIndex());
      assertTrue("should be a multi-token index",index.isMultiTokenIndex());
      assertTrue("should be a composite index",index.isCompositeIndex());
      assertFalse("should not be a node index",index.isNodeIndex());
      assertTrue("should be a relationship index",index.isRelationshipIndex());
      assertEquals(asSet(PROPERTY_KEY,PROPERTY_KEY2),Iterables.asSet(index.getPropertyKeys()));
    }
   }
  @Test public void shouldListAll() throws Exception {
    SchemaWrite schemaWrite=schemaWriteInNewTransaction();
    IndexReference index1=schemaWrite.indexCreate(descriptor);
    IndexReference index2=((IndexBackedConstraintDescriptor)schemaWrite.uniquePropertyConstraintCreate(descriptor2)).ownedIndexDescriptor();
    commit();
    SchemaRead schemaRead=newTransaction().schemaRead();
    List<IndexReference> indexes=Iterators.asList(schemaRead.indexesGetAll());
    assertThat(indexes,containsInAnyOrder(index1,index2));
    commit();
  }
  private Runnable createIndex(  GraphDatabaseAPI db,  Label label,  String propertyKey){
    return () -> {
      try (org.neo4j.graphdb.Transaction transaction=db.beginTx()){
        db.schema().indexFor(label).on(propertyKey).create();
        transaction.success();
      }
       try (org.neo4j.graphdb.Transaction transaction=db.beginTx()){
        db.schema().awaitIndexesOnline(1,TimeUnit.MINUTES);
        transaction.success();
      }
     }
;
  }
}
