public class StringLengthIndexValidationIT {
  @Rule public DatabaseRule db=new EmbeddedDatabaseRule().withSetting(GraphDatabaseSettings.default_schema_provider,GraphDatabaseSettings.SchemaIndex.NATIVE20.providerName());
  private static final String propKey="largeString";
  private static final int keySizeLimit=TreeNodeDynamicSize.keyValueSizeCapFromPageSize(PageCache.PAGE_SIZE) - Long.BYTES;
  @Test public void shouldSuccessfullyWriteAndReadWithinIndexKeySizeLimit(){
    createIndex();
    String propValue=getString(keySizeLimit);
    long expectedNodeId;
    expectedNodeId=createNode(propValue);
    assertReadNode(propValue,expectedNodeId);
  }
  @Test public void shouldSuccessfullyPopulateIndexWithinIndexKeySizeLimit(){
    String propValue=getString(keySizeLimit);
    long expectedNodeId;
    expectedNodeId=createNode(propValue);
    createIndex();
    assertReadNode(propValue,expectedNodeId);
  }
  @Test public void txMustFailIfExceedingIndexKeySizeLimit(){
    createIndex();
    try (Transaction tx=db.beginTx()){
      String propValue=getString(keySizeLimit + 1);
      db.createNode(LABEL_ONE).setProperty(propKey,propValue);
      tx.success();
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.getMessage(),Matchers.containsString("Property value size is too large for index. Please see index documentation for limitations."));
    }
  }
  @Test public void indexPopulationMustFailIfExceedingIndexKeySizeLimit(){
    String propValue=getString(keySizeLimit + 1);
    createNode(propValue);
    try (Transaction tx=db.beginTx()){
      db.schema().indexFor(LABEL_ONE).on(propKey).create();
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(1,TimeUnit.MINUTES);
      tx.success();
    }
 catch (    IllegalStateException e) {
      assertThat(e.getMessage(),Matchers.containsString("Index entered a FAILED state."));
    }
    try (Transaction tx=db.beginTx()){
      Iterator<IndexDefinition> iterator=db.schema().getIndexes(LABEL_ONE).iterator();
      assertTrue(iterator.hasNext());
      IndexDefinition next=iterator.next();
      assertEquals("state is FAILED",Schema.IndexState.FAILED,db.schema().getIndexState(next));
      assertThat(db.schema().getIndexFailure(next),Matchers.containsString("Index key-value size it to large. Please see index documentation for limitations."));
      tx.success();
    }
   }
  private String getString(  int byteArraySize){
    return RandomStringUtils.randomAlphabetic(byteArraySize);
  }
  private void createIndex(){
    try (Transaction tx=db.beginTx()){
      db.schema().indexFor(LABEL_ONE).on(propKey).create();
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(1,TimeUnit.MINUTES);
      tx.success();
    }
   }
  private long createNode(  String propValue){
    long expectedNodeId;
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode(LABEL_ONE);
      node.setProperty(propKey,propValue);
      expectedNodeId=node.getId();
      tx.success();
    }
     return expectedNodeId;
  }
  private void assertReadNode(  String propValue,  long expectedNodeId){
    try (Transaction tx=db.beginTx()){
      Node node=db.findNode(LABEL_ONE,propKey,propValue);
      assertNotNull(node);
      assertEquals("node id",expectedNodeId,node.getId());
      tx.success();
    }
   }
}
