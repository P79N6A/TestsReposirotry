public class NativeLabelScanStoreIT {
  private final TestDirectory directory=TestDirectory.testDirectory();
  private final PageCacheRule pageCacheRule=new PageCacheRule();
  private final LifeRule life=new LifeRule(true);
  private final RandomRule random=new RandomRule();
  @Rule public final RuleChain rules=outerRule(directory).around(pageCacheRule).around(life).around(random);
  private NativeLabelScanStore store;
  private static final int NODE_COUNT=10_000;
  private static final int LABEL_COUNT=12;
  @Before public void before(){
    DefaultFileSystemAbstraction fileSystem=new DefaultFileSystemAbstraction();
    PageCache pageCache=pageCacheRule.getPageCache(fileSystem);
    store=life.add(new NativeLabelScanStore(pageCache,directory.databaseLayout(),fileSystem,FullStoreChangeStream.EMPTY,false,new Monitors(),RecoveryCleanupWorkCollector.immediate(),Math.min(pageCache.pageSize(),256 << random.nextInt(5))));
  }
  @Test public void shouldRandomlyTestIt() throws Exception {
    long[] expected=new long[NODE_COUNT];
    randomModifications(expected,NODE_COUNT);
    for (int i=0; i < 100; i++) {
      verifyReads(expected);
      randomModifications(expected,NODE_COUNT / 10);
    }
  }
  private void verifyReads(  long[] expected){
    try (LabelScanReader reader=store.newReader()){
      for (int i=0; i < LABEL_COUNT; i++) {
        long[] actualNodes=asArray(reader.nodesWithLabel(i));
        long[] expectedNodes=nodesWithLabel(expected,i);
        assertArrayEquals(expectedNodes,actualNodes);
      }
    }
   }
  public static long[] nodesWithLabel(  long[] expected,  int labelId){
    int mask=1 << labelId;
    int count=0;
    for (    long labels : expected) {
      if ((labels & mask) != 0) {
        count++;
      }
    }
    long[] result=new long[count];
    int cursor=0;
    for (int nodeId=0; nodeId < expected.length; nodeId++) {
      long labels=expected[nodeId];
      if ((labels & mask) != 0) {
        result[cursor++]=nodeId;
      }
    }
    return result;
  }
  private void randomModifications(  long[] expected,  int count) throws IOException {
    BitSet editedNodes=new BitSet();
    try (LabelScanWriter writer=store.newWriter()){
      for (int i=0; i < count; i++) {
        int nodeId=random.nextInt(NODE_COUNT);
        if (editedNodes.get(nodeId)) {
          i--;
          continue;
        }
        int changeSize=random.nextInt(3) + 1;
        long labels=expected[nodeId];
        long[] labelsBefore=getLabels(labels);
        for (int j=0; j < changeSize; j++) {
          labels=flipRandom(labels,LABEL_COUNT,random.random());
        }
        long[] labelsAfter=getLabels(labels);
        editedNodes.set(nodeId);
        NodeLabelUpdate labelChanges=labelChanges(nodeId,labelsBefore,labelsAfter);
        writer.write(labelChanges);
        expected[nodeId]=labels;
      }
    }
   }
  public static long flipRandom(  long existingLabels,  int highLabelId,  Random random){
    return existingLabels ^ (1 << random.nextInt(highLabelId));
  }
  public static long[] getLabels(  long bits){
    long[] result=new long[Long.bitCount(bits)];
    for (int labelId=0, c=0; labelId < LABEL_COUNT; labelId++) {
      int mask=1 << labelId;
      if ((bits & mask) != 0) {
        result[c++]=labelId;
      }
    }
    return result;
  }
}
