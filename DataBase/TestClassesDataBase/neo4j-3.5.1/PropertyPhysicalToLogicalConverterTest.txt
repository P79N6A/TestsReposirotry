public class PropertyPhysicalToLogicalConverterTest {
  @ClassRule public static PageCacheRule pageCacheRule=new PageCacheRule();
  private final EphemeralFileSystemRule fs=new EphemeralFileSystemRule();
  private final TestDirectory testDirectory=TestDirectory.testDirectory(fs);
  @Rule public final RuleChain ruleChain=RuleChain.outerRule(fs).around(testDirectory);
  private NeoStores neoStores;
  private PropertyStore store;
  private final Value longString=Values.of("my super looooooooooooooooooooooooooooooooooooooong striiiiiiiiiiiiiiiiiiiiiiing");
  private final Value longerString=Values.of("my super looooooooooooooooooooooooooooooooooooooong striiiiiiiiiiiiiiiiiiiiiiingdd");
  private PropertyPhysicalToLogicalConverter converter;
  private final long[] none=new long[0];
  @Before public void before(){
    StoreFactory storeFactory=new StoreFactory(testDirectory.databaseLayout(),Config.defaults(),new DefaultIdGeneratorFactory(fs.get()),pageCacheRule.getPageCache(fs.get()),fs.get(),NullLogProvider.getInstance(),EmptyVersionContextSupplier.EMPTY);
    neoStores=storeFactory.openAllNeoStores(true);
    store=neoStores.getPropertyStore();
    converter=new PropertyPhysicalToLogicalConverter(store);
  }
  @After public void after(){
    neoStores.close();
  }
  @Test public void shouldConvertInlinedAddedProperty(){
    int key=10;
    Value value=Values.of(12345);
    PropertyRecord before=propertyRecord();
    PropertyRecord after=propertyRecord(property(key,value));
    assertThat(convert(none,none,change(before,after)),equalTo(EntityUpdates.forEntity(0).added(key,value).build()));
  }
  @Test public void shouldConvertInlinedChangedProperty(){
    int key=10;
    Value valueBefore=Values.of(12341);
    Value valueAfter=Values.of(738);
    PropertyRecord before=propertyRecord(property(key,valueBefore));
    PropertyRecord after=propertyRecord(property(key,valueAfter));
    EntityUpdates update=convert(none,none,change(before,after));
    EntityUpdates expected=EntityUpdates.forEntity(0).changed(key,valueBefore,valueAfter).build();
    assertEquals(expected,update);
  }
  @Test public void shouldIgnoreInlinedUnchangedProperty(){
    int key=10;
    Value value=Values.of(12341);
    PropertyRecord before=propertyRecord(property(key,value));
    PropertyRecord after=propertyRecord(property(key,value));
    assertThat(convert(none,none,change(before,after)),equalTo(EntityUpdates.forEntity(0).build()));
  }
  @Test public void shouldConvertInlinedRemovedProperty(){
    int key=10;
    Value value=Values.of(12341);
    PropertyRecord before=propertyRecord(property(key,value));
    PropertyRecord after=propertyRecord();
    EntityUpdates update=convert(none,none,change(before,after));
    EntityUpdates expected=EntityUpdates.forEntity(0).removed(key,value).build();
    assertEquals(expected,update);
  }
  @Test public void shouldConvertDynamicAddedProperty(){
    int key=10;
    PropertyRecord before=propertyRecord();
    PropertyRecord after=propertyRecord(property(key,longString));
    assertThat(convert(none,none,change(before,after)),equalTo(EntityUpdates.forEntity(0).added(key,longString).build()));
  }
  @Test public void shouldConvertDynamicChangedProperty(){
    int key=10;
    PropertyRecord before=propertyRecord(property(key,longString));
    PropertyRecord after=propertyRecord(property(key,longerString));
    EntityUpdates update=convert(none,none,change(before,after));
    EntityUpdates expected=EntityUpdates.forEntity(0).changed(key,longString,longerString).build();
    assertEquals(expected,update);
  }
  @Test public void shouldConvertDynamicInlinedRemovedProperty(){
    int key=10;
    PropertyRecord before=propertyRecord(property(key,longString));
    PropertyRecord after=propertyRecord();
    EntityUpdates update=convert(none,none,change(before,after));
    EntityUpdates expected=EntityUpdates.forEntity(0).removed(key,longString).build();
    assertEquals(expected,update);
  }
  @Test public void shouldTreatPropertyThatMovedToAnotherRecordAsChange(){
    int key=12;
    Value oldValue=Values.of("value1");
    Value newValue=Values.of("value two");
    PropertyRecordChange movedFrom=change(propertyRecord(property(key,oldValue)),propertyRecord());
    PropertyRecordChange movedTo=change(propertyRecord(),propertyRecord(property(key,newValue)));
    EntityUpdates update=convert(none,none,movedFrom,movedTo);
    EntityUpdates expected=EntityUpdates.forEntity(0).changed(key,oldValue,newValue).build();
    assertEquals(expected,update);
  }
  private static PropertyRecord propertyRecord(  PropertyBlock... propertyBlocks){
    PropertyRecord record=new PropertyRecord(0);
    if (propertyBlocks != null) {
      record.setInUse(true);
      for (      PropertyBlock propertyBlock : propertyBlocks) {
        record.addPropertyBlock(propertyBlock);
      }
    }
    record.setNodeId(0);
    return record;
  }
  private PropertyBlock property(  long key,  Value value){
    PropertyBlock block=new PropertyBlock();
    store.encodeValue(block,(int)key,value);
    return block;
  }
  private EntityUpdates convert(  long[] labelsBefore,  long[] labelsAfter,  PropertyRecordChange change){
    return convert(labelsBefore,labelsAfter,new PropertyRecordChange[]{change});
  }
  private EntityUpdates convert(  long[] labelsBefore,  long[] labelsAfter,  PropertyRecordChange... changes){
    EntityUpdates.Builder updates=EntityUpdates.forEntity((long)0).withTokens(labelsBefore).withTokensAfter(labelsAfter);
    converter.convertPropertyRecord(0,Iterables.iterable(changes),updates);
    return updates.build();
  }
  private PropertyRecordChange change(  final PropertyRecord before,  final PropertyRecord after){
    return new PropertyRecordChange(){
      @Override public PropertyRecord getBefore(){
        return before;
      }
      @Override public PropertyRecord getAfter(){
        return after;
      }
    }
;
  }
}
