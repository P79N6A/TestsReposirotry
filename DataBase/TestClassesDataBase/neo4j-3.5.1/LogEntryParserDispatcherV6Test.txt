public class LogEntryParserDispatcherV6Test {
  private final LogEntryVersion version=LogEntryVersion.CURRENT;
  private final CommandReaderFactory commandReader=new RecordStorageCommandReaderFactory();
  private final LogPositionMarker marker=new LogPositionMarker();
  private final LogPosition position=new LogPosition(0,29);
  @Test public void shouldParserStartEntry() throws IOException {
    final LogEntryStart start=new LogEntryStart(version,1,2,3,4,new byte[]{5},position);
    final InMemoryClosableChannel channel=new InMemoryClosableChannel();
    channel.putInt(start.getMasterId());
    channel.putInt(start.getLocalId());
    channel.putLong(start.getTimeWritten());
    channel.putLong(start.getLastCommittedTxWhenTransactionStarted());
    channel.putInt(start.getAdditionalHeader().length);
    channel.put(start.getAdditionalHeader(),start.getAdditionalHeader().length);
    channel.getCurrentPosition(marker);
    final LogEntryParser parser=version.entryParser(LogEntryByteCodes.TX_START);
    final LogEntry logEntry=parser.parse(version,channel,marker,commandReader);
    assertEquals(start,logEntry);
    assertFalse(parser.skip());
  }
  @Test public void shouldParserOnePhaseCommitEntry() throws IOException {
    final LogEntryCommit commit=new LogEntryCommit(version,42,21);
    final InMemoryClosableChannel channel=new InMemoryClosableChannel();
    channel.putLong(commit.getTxId());
    channel.putLong(commit.getTimeWritten());
    channel.getCurrentPosition(marker);
    final LogEntryParser parser=version.entryParser(LogEntryByteCodes.TX_COMMIT);
    final LogEntry logEntry=parser.parse(version,channel,marker,commandReader);
    assertEquals(commit,logEntry);
    assertFalse(parser.skip());
  }
  @Test public void shouldParserCommandsUsingAGivenFactory() throws IOException {
    NodeRecord theRecord=new NodeRecord(1);
    Command.NodeCommand nodeCommand=new Command.NodeCommand(theRecord,theRecord);
    final LogEntryCommand command=new LogEntryCommand(version,nodeCommand);
    final InMemoryClosableChannel channel=new InMemoryClosableChannel();
    channel.put(NeoCommandType.NODE_COMMAND);
    channel.putLong(theRecord.getId());
    channel.put((byte)0);
    channel.putInt(0);
    channel.put((byte)0);
    channel.putInt(0);
    channel.getCurrentPosition(marker);
    final LogEntryParser parser=version.entryParser(LogEntryByteCodes.COMMAND);
    final LogEntry logEntry=parser.parse(version,channel,marker,commandReader);
    assertEquals(command,logEntry);
    assertFalse(parser.skip());
  }
  @Test public void shouldParseCheckPointEntry() throws IOException {
    final CheckPoint checkPoint=new CheckPoint(new LogPosition(43,44));
    final InMemoryClosableChannel channel=new InMemoryClosableChannel();
    channel.putLong(checkPoint.getLogPosition().getLogVersion());
    channel.putLong(checkPoint.getLogPosition().getByteOffset());
    channel.getCurrentPosition(marker);
    final LogEntryParser parser=version.entryParser(LogEntryByteCodes.CHECK_POINT);
    final LogEntry logEntry=parser.parse(version,channel,marker,commandReader);
    assertEquals(checkPoint,logEntry);
    assertFalse(parser.skip());
  }
  @Test(expected=IllegalArgumentException.class) public void shouldThrowWhenParsingUnknownEntry(){
    version.entryParser((byte)42);
  }
}
