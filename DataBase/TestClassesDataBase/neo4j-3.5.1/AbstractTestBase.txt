public abstract class AbstractTestBase {
  private static GraphDatabaseService graphdb;
  @BeforeClass public static void beforeSuite(){
    graphdb=new TestGraphDatabaseFactory().newImpermanentDatabase();
  }
  @AfterClass public static void afterSuite(){
    graphdb.shutdown();
    graphdb=null;
  }
  protected static Node getNode(  long id){
    return graphdb.getNodeById(id);
  }
  protected static Transaction beginTx(){
    return graphdb.beginTx();
  }
protected interface Representation<T> {
    String represent(    T item);
  }
protected static final class RelationshipRepresentation implements Representation<Relationship> {
    private final Representation<? super Node> nodes;
    private final Representation<? super Relationship> rel;
    public RelationshipRepresentation(    Representation<? super Node> nodes,    Representation<? super Relationship> rel){
      this.nodes=nodes;
      this.rel=rel;
    }
    @Override public String represent(    Relationship item){
      return nodes.represent(item.getStartNode()) + " " + rel.represent(item)+ " "+ nodes.represent(item.getEndNode());
    }
  }
  protected static <T>void expect(  Iterable<? extends T> items,  Representation<T> representation,  String... expected){
    expect(items,representation,new HashSet<>(Arrays.asList(expected)));
  }
  protected static <T>void expect(  Iterable<? extends T> items,  Representation<T> representation,  Set<String> expected){
    try (Transaction tx=beginTx()){
      for (      T item : items) {
        String repr=representation.represent(item);
        assertTrue(repr + " not expected ",expected.remove(repr));
      }
      tx.success();
    }
     if (!expected.isEmpty()) {
      fail("The expected elements " + expected + " were not returned.");
    }
  }
}
