/** 
 * Concurrent updates and index changes should result in valid state, and not create conflicts or exceptions during commit.
 */
public class ConcurrentLuceneFulltextUpdaterTest extends LuceneFulltextTestSupport {
  private final int aliceThreads=1;
  private final int bobThreads=1;
  private final int nodesCreatedPerThread=500;
  private Race race;
  private CountDownLatch aliceLatch=new CountDownLatch(2);
  private CountDownLatch bobLatch=new CountDownLatch(2);
  private JobHandle handle;
  private OutputStream logFile;
  private AsyncEvents<AsyncLogEvent> events;
  private Log log;
  @Override protected RepeatRule createRepeatRule(){
    return new RepeatRule(false,1);
  }
  @Before public void createRace() throws Exception {
    race=new Race();
    JobScheduler scheduler=db.resolveDependency(JobScheduler.class);
    logFile=new FileOutputStream(db.databaseLayout().file("fts-events.txt"));
    FormattedLogProvider logProvider=FormattedLogProvider.withDefaultLogLevel(Level.DEBUG).toOutputStream(logFile);
    events=new AsyncEvents<>(AsyncLogEvent::process,AsyncEvents.Monitor.NONE);
    handle=scheduler.schedule(Group.FILE_IO_HELPER,events);
    events.awaitStartup();
    AsyncLogProvider asyncLogProvider=new AsyncLogProvider(events,logProvider);
    log=asyncLogProvider.getLog(ConcurrentLuceneFulltextUpdaterTest.class);
    FulltextIndexAccessor.TRACE_LOG=asyncLogProvider.getLog(FulltextIndexAccessor.class);
    FulltextIndexPopulator.TRACE_LOG=asyncLogProvider.getLog(FulltextIndexPopulator.class);
  }
  @After public void stopLogger() throws IOException {
    handle.cancel(false);
    events.shutdown();
    events.awaitTermination();
    logFile.flush();
    logFile.close();
  }
  private SchemaDescriptor getNewDescriptor(  String[] entityTokens){
    return fulltextAdapter.schemaFor(NODE,entityTokens,settings,"otherProp");
  }
  private SchemaDescriptor getExistingDescriptor(  String[] entityTokens){
    return fulltextAdapter.schemaFor(NODE,entityTokens,settings,PROP);
  }
  private IndexReference createInitialIndex(  SchemaDescriptor descriptor) throws Exception {
    IndexReference index;
    try (KernelTransactionImplementation transaction=getKernelTransaction()){
      SchemaWrite schemaWrite=transaction.schemaWrite();
      index=schemaWrite.indexCreate(descriptor,FulltextIndexProviderFactory.DESCRIPTOR.name(),Optional.of("nodes"));
      transaction.success();
    }
     await(index);
    return index;
  }
  private void raceContestantsAndVerifyResults(  SchemaDescriptor newDescriptor,  Runnable aliceWork,  Runnable changeConfig,  Runnable bobWork) throws Throwable {
    race.addContestants(aliceThreads,aliceWork);
    race.addContestant(changeConfig);
    race.addContestants(bobThreads,bobWork);
    race.go();
    await(IndexDescriptorFactory.forSchema(newDescriptor,Optional.of("nodes"),FulltextIndexProviderFactory.DESCRIPTOR));
    try (Transaction tx=db.beginTx()){
      KernelTransaction ktx=kernelTransaction(tx);
      ScoreEntityIterator bob=fulltextAdapter.query(ktx,"nodes","bob");
      List<ScoreEntityIterator.ScoreEntry> list=bob.stream().collect(Collectors.toList());
      try {
        assertEquals(bobThreads * nodesCreatedPerThread,list.size());
      }
 catch (      Throwable e) {
        log.debug("Nodes found in query for bob:");
        for (        ScoreEntityIterator.ScoreEntry entry : list) {
          log.debug("\t" + db.getNodeById(entry.entityId()));
        }
        throw e;
      }
      ScoreEntityIterator alice=fulltextAdapter.query(ktx,"nodes","alice");
      assertEquals(0,alice.stream().count());
    }
   }
  private Runnable work(  int iterations,  ThrowingAction<Exception> work){
    return () -> {
      try {
        for (int i=0; i < iterations; i++) {
          Thread.yield();
          try (Transaction tx=db.beginTx()){
            Thread.yield();
            work.apply();
            Thread.yield();
            tx.success();
          }
         }
      }
 catch (      Exception e) {
        throw new AssertionError(e);
      }
    }
;
  }
  private ThrowingAction<Exception> dropAndReCreateIndex(  IndexReference descriptor,  SchemaDescriptor newDescriptor){
    return () -> {
      aliceLatch.await();
      bobLatch.await();
      try (KernelTransactionImplementation transaction=getKernelTransaction()){
        SchemaWrite schemaWrite=transaction.schemaWrite();
        schemaWrite.indexDrop(descriptor);
        schemaWrite.indexCreate(newDescriptor,FulltextIndexProviderFactory.DESCRIPTOR.name(),Optional.of("nodes"));
        transaction.success();
        log.debug("drop an recreate");
      }
     }
;
  }
  @Test public void labelledNodesCoreAPI() throws Throwable {
    String[] entityTokens={LABEL.name()};
    SchemaDescriptor descriptor=getExistingDescriptor(entityTokens);
    SchemaDescriptor newDescriptor=getNewDescriptor(entityTokens);
    IndexReference initialIndex=createInitialIndex(descriptor);
    Runnable aliceWork=work(nodesCreatedPerThread,() -> {
      db.getNodeById(createNodeIndexableByPropertyValue(LABEL,"alice"));
      log.debug("core api created an alice");
      aliceLatch.countDown();
    }
);
    Runnable bobWork=work(nodesCreatedPerThread,() -> {
      db.getNodeById(createNodeWithProperty(LABEL,"otherProp","bob"));
      log.debug("core api created a bob");
      bobLatch.countDown();
    }
);
    Runnable changeConfig=work(1,dropAndReCreateIndex(initialIndex,newDescriptor));
    raceContestantsAndVerifyResults(newDescriptor,aliceWork,changeConfig,bobWork);
  }
  @Test public void labelledNodesCypherCurrent() throws Throwable {
    String[] entityTokens={LABEL.name()};
    SchemaDescriptor descriptor=getExistingDescriptor(entityTokens);
    SchemaDescriptor newDescriptor=getNewDescriptor(entityTokens);
    IndexReference initialIndex=createInitialIndex(descriptor);
    Runnable aliceWork=work(nodesCreatedPerThread,() -> {
      db.execute("create (:LABEL {" + PROP + ": \"alice\"})").close();
      log.debug("cypher current created an alice");
      aliceLatch.countDown();
    }
);
    Runnable bobWork=work(nodesCreatedPerThread,() -> {
      db.execute("create (:LABEL {otherProp: \"bob\"})").close();
      log.debug("cypher current created a bob");
      bobLatch.countDown();
    }
);
    Runnable changeConfig=work(1,dropAndReCreateIndex(initialIndex,newDescriptor));
    raceContestantsAndVerifyResults(newDescriptor,aliceWork,changeConfig,bobWork);
  }
  @Test public void labelledNodesCypher31() throws Throwable {
    String[] entityTokens={LABEL.name()};
    SchemaDescriptor descriptor=getExistingDescriptor(entityTokens);
    SchemaDescriptor newDescriptor=getNewDescriptor(entityTokens);
    IndexReference initialIndex=createInitialIndex(descriptor);
    Runnable aliceWork=work(nodesCreatedPerThread,() -> {
      db.execute("CYPHER 3.1 create (:LABEL {" + PROP + ": \"alice\"})").close();
      log.debug("cypher 3.1 created an alice");
      aliceLatch.countDown();
    }
);
    Runnable bobWork=work(nodesCreatedPerThread,() -> {
      db.execute("CYPHER 3.1 create (:LABEL {otherProp: \"bob\"})").close();
      log.debug("cypher 3.1 created a bob");
      bobLatch.countDown();
    }
);
    Runnable changeConfig=work(1,dropAndReCreateIndex(initialIndex,newDescriptor));
    raceContestantsAndVerifyResults(newDescriptor,aliceWork,changeConfig,bobWork);
  }
  @Test public void labelledNodesCypher23() throws Throwable {
    String[] entityTokens={LABEL.name()};
    SchemaDescriptor descriptor=getExistingDescriptor(entityTokens);
    SchemaDescriptor newDescriptor=getNewDescriptor(entityTokens);
    IndexReference initialIndex=createInitialIndex(descriptor);
    Runnable aliceWork=work(nodesCreatedPerThread,() -> {
      db.execute("CYPHER 2.3 create (:LABEL {" + PROP + ": \"alice\"})").close();
      log.debug("cypher 2.3 created an alice");
      aliceLatch.countDown();
    }
);
    Runnable bobWork=work(nodesCreatedPerThread,() -> {
      db.execute("CYPHER 2.3 create (:LABEL {otherProp: \"bob\"})").close();
      log.debug("cypher 2.3 created a bob");
      bobLatch.countDown();
    }
);
    Runnable changeConfig=work(1,dropAndReCreateIndex(initialIndex,newDescriptor));
    raceContestantsAndVerifyResults(newDescriptor,aliceWork,changeConfig,bobWork);
  }
  @Test public void labelledNodesCypherRule() throws Throwable {
    String[] entityTokens={LABEL.name()};
    SchemaDescriptor descriptor=getExistingDescriptor(entityTokens);
    SchemaDescriptor newDescriptor=getNewDescriptor(entityTokens);
    IndexReference initialIndex=createInitialIndex(descriptor);
    Runnable aliceWork=work(nodesCreatedPerThread,() -> {
      db.execute("CYPHER planner=rule create (:LABEL {" + PROP + ": \"alice\"})").close();
      log.debug("cypher rule created an alice");
      aliceLatch.countDown();
    }
);
    Runnable bobWork=work(nodesCreatedPerThread,() -> {
      db.execute("CYPHER planner=rule create (:LABEL {otherProp: \"bob\"})").close();
      log.debug("cypher rule created a bob");
      bobLatch.countDown();
    }
);
    Runnable changeConfig=work(1,dropAndReCreateIndex(initialIndex,newDescriptor));
    raceContestantsAndVerifyResults(newDescriptor,aliceWork,changeConfig,bobWork);
  }
}
