public class LabelsAcceptanceTest {
  @Rule public final ImpermanentDatabaseRule dbRule=new ImpermanentDatabaseRule();
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  private enum Labels implements Label {  MY_LABEL,   MY_OTHER_LABEL}
  /** 
 * https://github.com/neo4j/neo4j/issues/1279 
 */
  @Test public void shouldInsertLabelsWithoutDuplicatingThem(){
    final Node node=dbRule.executeAndCommit((Function<GraphDatabaseService,Node>)GraphDatabaseService::createNode);
    dbRule.executeAndCommit(db -> {
      node.addLabel(label("FOOBAR"));
    }
);
    dbRule.executeAndCommit(db -> {
      node.addLabel(label("BAZQUX"));
    }
);
    dbRule.executeAndCommit(db -> {
      for (      Label label : node.getLabels()) {
        node.removeLabel(label);
      }
      node.addLabel(label("BAZQUX"));
    }
);
    List<Label> labels=dbRule.executeAndCommit(db -> {
      List<Label> labels1=new ArrayList<>();
      for (      Label label : node.getLabels()) {
        labels1.add(label);
      }
      return labels1;
    }
);
    assertEquals(labels.toString(),1,labels.size());
    assertEquals("BAZQUX",labels.get(0).name());
  }
  @Test public void addingALabelUsingAValidIdentifierShouldSucceed(){
    GraphDatabaseService graphDatabase=dbRule.getGraphDatabaseAPI();
    Node myNode=null;
    try (Transaction tx=graphDatabase.beginTx()){
      myNode=graphDatabase.createNode();
      myNode.addLabel(Labels.MY_LABEL);
      tx.success();
    }
     assertThat("Label should have been added to node",myNode,inTx(graphDatabase,hasLabel(Labels.MY_LABEL)));
  }
  @Test public void addingALabelUsingAnInvalidIdentifierShouldFail(){
    GraphDatabaseService graphDatabase=dbRule.getGraphDatabaseAPI();
    try (Transaction tx=graphDatabase.beginTx()){
      graphDatabase.createNode().addLabel(label(""));
      fail("Should have thrown exception");
    }
 catch (    ConstraintViolationException ex) {
    }
    try (Transaction tx2=graphDatabase.beginTx()){
      graphDatabase.createNode().addLabel(() -> null);
      fail("Should have thrown exception");
    }
 catch (    ConstraintViolationException ex) {
    }
  }
  @Test public void addingALabelThatAlreadyExistsBehavesAsNoOp(){
    GraphDatabaseService graphDatabase=dbRule.getGraphDatabaseAPI();
    Node myNode=null;
    try (Transaction tx=graphDatabase.beginTx()){
      myNode=graphDatabase.createNode();
      myNode.addLabel(Labels.MY_LABEL);
      myNode.addLabel(Labels.MY_LABEL);
      tx.success();
    }
     assertThat("Label should have been added to node",myNode,inTx(graphDatabase,hasLabel(Labels.MY_LABEL)));
  }
  @Test public void oversteppingMaxNumberOfLabelsShouldFailGracefully(){
    GraphDatabaseService graphDatabase=beansAPIWithNoMoreLabelIds();
    try (Transaction tx=graphDatabase.beginTx()){
      graphDatabase.createNode().addLabel(Labels.MY_LABEL);
      fail("Should have thrown exception");
    }
 catch (    ConstraintViolationException ex) {
    }
    graphDatabase.shutdown();
  }
  @Test public void removingCommittedLabel(){
    GraphDatabaseService graphDatabase=dbRule.getGraphDatabaseAPI();
    Label label=Labels.MY_LABEL;
    Node myNode=createNode(graphDatabase,label);
    try (Transaction tx=graphDatabase.beginTx()){
      myNode.removeLabel(label);
      tx.success();
    }
     assertThat(myNode,not(inTx(graphDatabase,hasLabel(label))));
  }
  @Test public void createNodeWithLabels(){
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    Node node=null;
    try (Transaction tx=db.beginTx()){
      node=db.createNode(Labels.values());
      tx.success();
    }
     Set<String> names=Stream.of(Labels.values()).map(Labels::name).collect(toSet());
    assertThat(node,inTx(db,hasLabels(names)));
  }
  @Test public void removingNonExistentLabel(){
    GraphDatabaseService beansAPI=dbRule.getGraphDatabaseAPI();
    Label label=Labels.MY_LABEL;
    Node myNode;
    try (Transaction tx=beansAPI.beginTx()){
      myNode=beansAPI.createNode();
      myNode.removeLabel(label);
      tx.success();
    }
     assertThat(myNode,not(inTx(beansAPI,hasLabel(label))));
  }
  @Test public void removingExistingLabelFromUnlabeledNode(){
    GraphDatabaseService beansAPI=dbRule.getGraphDatabaseAPI();
    Label label=Labels.MY_LABEL;
    createNode(beansAPI,label);
    Node myNode=createNode(beansAPI);
    try (Transaction tx=beansAPI.beginTx()){
      myNode.removeLabel(label);
      tx.success();
    }
     assertThat(myNode,not(inTx(beansAPI,hasLabel(label))));
  }
  @Test public void removingUncommittedLabel(){
    GraphDatabaseService beansAPI=dbRule.getGraphDatabaseAPI();
    Label label=Labels.MY_LABEL;
    Node myNode;
    try (Transaction tx=beansAPI.beginTx()){
      myNode=beansAPI.createNode();
      myNode.addLabel(label);
      myNode.removeLabel(label);
      assertFalse(myNode.hasLabel(label));
      tx.success();
    }
   }
  @Test public void shouldBeAbleToListLabelsForANode(){
    GraphDatabaseService beansAPI=dbRule.getGraphDatabaseAPI();
    Node node=null;
    Set<String> expected=asSet(Labels.MY_LABEL.name(),Labels.MY_OTHER_LABEL.name());
    try (Transaction tx=beansAPI.beginTx()){
      node=beansAPI.createNode();
      for (      String label : expected) {
        node.addLabel(label(label));
      }
      tx.success();
    }
     assertThat(node,inTx(beansAPI,hasLabels(expected)));
  }
  @Test public void shouldReturnEmptyListIfNoLabels(){
    GraphDatabaseService beansAPI=dbRule.getGraphDatabaseAPI();
    Node node=createNode(beansAPI);
    assertThat(node,inTx(beansAPI,hasNoLabels()));
  }
  @Test public void getNodesWithLabelCommitted(){
    GraphDatabaseService beansAPI=dbRule.getGraphDatabaseAPI();
    Node node=null;
    try (Transaction tx=beansAPI.beginTx()){
      node=beansAPI.createNode();
      node.addLabel(Labels.MY_LABEL);
      tx.success();
    }
     assertThat(beansAPI,inTx(beansAPI,hasNodes(Labels.MY_LABEL,node)));
    assertThat(beansAPI,inTx(beansAPI,hasNoNodes(Labels.MY_OTHER_LABEL)));
  }
  @Test public void getNodesWithLabelsWithTxAddsAndRemoves(){
    GraphDatabaseService beansAPI=dbRule.getGraphDatabaseAPI();
    Node node1=createNode(beansAPI,Labels.MY_LABEL,Labels.MY_OTHER_LABEL);
    Node node2=createNode(beansAPI,Labels.MY_LABEL,Labels.MY_OTHER_LABEL);
    Node node3;
    Set<Node> nodesWithMyLabel;
    Set<Node> nodesWithMyOtherLabel;
    try (Transaction tx=beansAPI.beginTx()){
      node3=beansAPI.createNode(Labels.MY_LABEL);
      node2.removeLabel(Labels.MY_LABEL);
      nodesWithMyLabel=asSet(beansAPI.findNodes(Labels.MY_LABEL));
      nodesWithMyOtherLabel=asSet(beansAPI.findNodes(Labels.MY_OTHER_LABEL));
      tx.success();
    }
     assertEquals(asSet(node1,node3),nodesWithMyLabel);
    assertEquals(asSet(node1,node2),nodesWithMyOtherLabel);
  }
  @Test public void shouldListAllExistingLabels(){
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    createNode(db,Labels.MY_LABEL,Labels.MY_OTHER_LABEL);
    List<Label> labels=null;
    try (Transaction tx=db.beginTx()){
      labels=asList(db.getAllLabels());
    }
     assertEquals(2,labels.size());
    assertThat(map(Label::name,labels),hasItems(Labels.MY_LABEL.name(),Labels.MY_OTHER_LABEL.name()));
  }
  @Test public void shouldListAllLabelsInUse(){
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    createNode(db,Labels.MY_LABEL);
    Node node=createNode(db,Labels.MY_OTHER_LABEL);
    try (Transaction tx=db.beginTx()){
      node.delete();
      tx.success();
    }
     List<Label> labels=null;
    try (Transaction tx=db.beginTx()){
      labels=asList(db.getAllLabelsInUse());
    }
     assertEquals(1,labels.size());
    assertThat(map(Label::name,labels),hasItems(Labels.MY_LABEL.name()));
  }
  @Test public void deleteAllNodesAndTheirLabels(){
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    final Label label=label("A");
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode();
      node.addLabel(label);
      node.setProperty("name","bla");
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      for (      final Node node : db.getAllNodes()) {
        node.removeLabel(label);
        node.delete();
      }
      tx.success();
    }
     try (Transaction transaction=db.beginTx()){
      assertEquals(0,Iterables.count(db.getAllNodes()));
    }
   }
  @Test public void removingLabelDoesNotBreakPreviouslyCreatedLabelsIterator(){
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    Label label1=label("A");
    Label label2=label("B");
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode(label1,label2);
      for (      Label next : node.getLabels()) {
        node.removeLabel(next);
      }
      tx.success();
    }
   }
  @Test public void removingPropertyDoesNotBreakPreviouslyCreatedNodePropertyKeysIterator(){
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode();
      node.setProperty("name","Horst");
      node.setProperty("age","72");
      Iterator<String> iterator=node.getPropertyKeys().iterator();
      while (iterator.hasNext()) {
        node.removeProperty(iterator.next());
      }
      tx.success();
    }
   }
  @Test public void shouldCreateNodeWithLotsOfLabelsAndThenRemoveMostOfThem(){
    final int TOTAL_NUMBER_OF_LABELS=200;
    final int NUMBER_OF_PRESERVED_LABELS=20;
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    Node node;
    try (Transaction tx=db.beginTx()){
      node=db.createNode();
      for (int i=0; i < TOTAL_NUMBER_OF_LABELS; i++) {
        node.addLabel(label("label:" + i));
      }
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      for (int i=NUMBER_OF_PRESERVED_LABELS; i < TOTAL_NUMBER_OF_LABELS; i++) {
        node.removeLabel(label("label:" + i));
      }
      tx.success();
    }
     try (Transaction transaction=db.beginTx()){
      List<String> labels=new ArrayList<>();
      for (      Label label : node.getLabels()) {
        labels.add(label.name());
      }
      assertEquals("labels on node: " + labels,NUMBER_OF_PRESERVED_LABELS,labels.size());
    }
   }
  @Test public void shouldAllowManyLabelsAndPropertyCursor() throws Exception {
    int propertyCount=10;
    int labelCount=15;
    GraphDatabaseAPI db=dbRule.getGraphDatabaseAPI();
    Node node;
    try (Transaction tx=db.beginTx()){
      node=db.createNode();
      for (int i=0; i < propertyCount; i++) {
        node.setProperty("foo" + i,"bar");
      }
      for (int i=0; i < labelCount; i++) {
        node.addLabel(label("label" + i));
      }
      tx.success();
    }
     Set<Integer> seenProperties=new HashSet<>();
    Set<Integer> seenLabels=new HashSet<>();
    try (Transaction tx=db.beginTx()){
      DependencyResolver resolver=db.getDependencyResolver();
      ThreadToStatementContextBridge bridge=resolver.resolveDependency(ThreadToStatementContextBridge.class);
      KernelTransaction ktx=bridge.getKernelTransactionBoundToThisThread(true);
      try (NodeCursor nodes=ktx.cursors().allocateNodeCursor();PropertyCursor propertyCursor=ktx.cursors().allocatePropertyCursor()){
        ktx.dataRead().singleNode(node.getId(),nodes);
        while (nodes.next()) {
          nodes.properties(propertyCursor);
          while (propertyCursor.next()) {
            seenProperties.add(propertyCursor.propertyKey());
          }
          LabelSet labels=nodes.labels();
          for (int i=0; i < labels.numberOfLabels(); i++) {
            seenLabels.add(labels.label(i));
          }
        }
      }
       tx.success();
    }
     assertEquals(propertyCount,seenProperties.size());
    assertEquals(labelCount,seenLabels.size());
  }
  @Test public void nodeWithManyLabels(){
    int labels=500;
    int halveLabels=labels / 2;
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    long nodeId=createNode(db).getId();
    addLabels(nodeId,0,halveLabels);
    addLabels(nodeId,halveLabels,halveLabels);
    verifyLabels(nodeId,0,labels);
    removeLabels(nodeId,halveLabels,halveLabels);
    verifyLabels(nodeId,0,halveLabels);
    removeLabels(nodeId,0,halveLabels - 2);
    verifyLabels(nodeId,halveLabels - 2,2);
  }
  private void addLabels(  long nodeId,  int startLabelIndex,  int count){
    try (Transaction tx=dbRule.beginTx()){
      Node node=dbRule.getNodeById(nodeId);
      int endLabelIndex=startLabelIndex + count;
      for (int i=startLabelIndex; i < endLabelIndex; i++) {
        node.addLabel(labelWithIndex(i));
      }
      tx.success();
    }
   }
  private void verifyLabels(  long nodeId,  int startLabelIndex,  int count){
    try (Transaction tx=dbRule.beginTx()){
      Node node=dbRule.getNodeById(nodeId);
      Set<String> labelNames=Iterables.asList(node.getLabels()).stream().map(Label::name).sorted().collect(toSet());
      assertEquals(count,labelNames.size());
      int endLabelIndex=startLabelIndex + count;
      for (int i=startLabelIndex; i < endLabelIndex; i++) {
        assertTrue(labelNames.contains(labelName(i)));
      }
      tx.success();
    }
   }
  private void removeLabels(  long nodeId,  int startLabelIndex,  int count){
    try (Transaction tx=dbRule.beginTx()){
      Node node=dbRule.getNodeById(nodeId);
      int endLabelIndex=startLabelIndex + count;
      for (int i=startLabelIndex; i < endLabelIndex; i++) {
        node.removeLabel(labelWithIndex(i));
      }
      tx.success();
    }
   }
  private static Label labelWithIndex(  int index){
    return label(labelName(index));
  }
  private static String labelName(  int index){
    return "Label-" + index;
  }
  @SuppressWarnings("deprecation") private GraphDatabaseService beansAPIWithNoMoreLabelIds(){
    final EphemeralIdGenerator.Factory idFactory=new EphemeralIdGenerator.Factory(){
      private IdTypeConfigurationProvider idTypeConfigurationProvider=new CommunityIdTypeConfigurationProvider();
      @Override public IdGenerator open(      File fileName,      int grabSize,      IdType idType,      LongSupplier highId,      long maxId){
        if (idType == IdType.LABEL_TOKEN) {
          IdGenerator generator=generators.get(idType);
          if (generator == null) {
            IdTypeConfiguration idTypeConfiguration=idTypeConfigurationProvider.getIdTypeConfiguration(idType);
            generator=new EphemeralIdGenerator(idType,idTypeConfiguration){
              @Override public long nextId(){
                throw new UnderlyingStorageException("Id capacity exceeded");
              }
            }
;
            generators.put(idType,generator);
          }
          return generator;
        }
        return super.open(fileName,grabSize,idType,() -> Long.MAX_VALUE,Long.MAX_VALUE);
      }
    }
;
    TestGraphDatabaseFactory dbFactory=new TestGraphDatabaseFactory(){
      @Override protected GraphDatabaseBuilder.DatabaseCreator createImpermanentDatabaseCreator(      final File storeDir,      final TestGraphDatabaseFactoryState state){
        return new GraphDatabaseBuilder.DatabaseCreator(){
          @Override public GraphDatabaseService newDatabase(          @Nonnull Config config){
            return new ImpermanentGraphDatabase(storeDir,config,GraphDatabaseDependencies.newDependencies(state.databaseDependencies())){
              @Override protected void create(              File storeDir,              Config config,              GraphDatabaseFacadeFactory.Dependencies dependencies){
                Function<PlatformModule,AbstractEditionModule> factory=platformModule -> new CommunityEditionModuleWithCustomIdContextFactory(platformModule,idFactory);
                new GraphDatabaseFacadeFactory(DatabaseInfo.COMMUNITY,factory){
                  @Override protected PlatformModule createPlatform(                  File storeDir,                  Config config,                  Dependencies dependencies){
                    return new ImpermanentPlatformModule(storeDir,config,databaseInfo,dependencies);
                  }
                }
.initFacade(storeDir,config,dependencies,this);
              }
            }
;
          }
        }
;
      }
    }
;
    return dbFactory.newImpermanentDatabase(testDirectory.directory("impermanent-directory"));
  }
  private Node createNode(  GraphDatabaseService db,  Label... labels){
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode(labels);
      tx.success();
      return node;
    }
   }
private static class CommunityEditionModuleWithCustomIdContextFactory extends CommunityEditionModule {
    CommunityEditionModuleWithCustomIdContextFactory(    PlatformModule platformModule,    EphemeralIdGenerator.Factory idFactory){
      super(platformModule);
      idContextFactory=IdContextFactoryBuilder.of(platformModule.fileSystem,platformModule.jobScheduler).withIdGenerationFactoryProvider(any -> idFactory).build();
    }
  }
}
