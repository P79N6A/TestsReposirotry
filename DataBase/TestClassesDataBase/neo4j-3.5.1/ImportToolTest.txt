public class ImportToolTest {
  private static final int MAX_LABEL_ID=4;
  private static final int RELATIONSHIP_COUNT=10_000;
  private static final int NODE_COUNT=100;
  private static final IntPredicate TRUE=i -> true;
  @Rule public final EmbeddedDatabaseRule dbRule=new EmbeddedDatabaseRule().startLazily();
  @Rule public final RandomRule random=new RandomRule();
  @Rule public final SuppressOutput suppressOutput=SuppressOutput.suppressAll();
  private int dataIndex;
  @Test public void usageMessageIncludeExample() throws Exception {
    SuppressOutput.Voice outputVoice=suppressOutput.getOutputVoice();
    importTool("?");
    assertTrue("Usage message should include example section, but was:" + outputVoice,outputVoice.containsMessage("Example:"));
  }
  @Test public void usageMessagePrintedOnEmptyInputParameters() throws Exception {
    SuppressOutput.Voice outputVoice=suppressOutput.getOutputVoice();
    importTool();
    assertTrue("Output should include usage section, but was:" + outputVoice,outputVoice.containsMessage("Example:"));
  }
  @Test public void shouldImportWithAsManyDefaultsAsAvailable() throws Exception {
    List<String> nodeIds=nodeIds();
    Configuration config=Configuration.COMMAS;
    importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),"--relationships",relationshipData(true,config,nodeIds,TRUE,true).getAbsolutePath());
    verifyData();
  }
  @Test public void shouldImportWithHeadersBeingInSeparateFiles() throws Exception {
    List<String> nodeIds=nodeIds();
    Configuration config=Configuration.TABS;
    importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--delimiter","TAB","--array-delimiter",String.valueOf(config.arrayDelimiter()),"--nodes",nodeHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,nodeIds,TRUE).getAbsolutePath(),"--relationships",relationshipHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + relationshipData(false,config,nodeIds,TRUE,true).getAbsolutePath());
    verifyData();
  }
  @Test public void import4097Labels() throws Exception {
    File header=file(fileName("4097labels-header.csv"));
    try (PrintStream writer=new PrintStream(header)){
      writer.println(":LABEL");
    }
     File data=file(fileName("4097labels.csv"));
    try (PrintStream writer=new PrintStream(data)){
      for (int i=0; i < 4096; i++) {
        writer.println("SIMPLE" + i);
      }
      writer.println("FIRST 4096|SECOND 4096|THIRD 4096");
    }
     importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--delimiter","TAB","--array-delimiter","|","--nodes",header.getAbsolutePath() + MULTI_FILE_DELIMITER + data.getAbsolutePath());
    try (Transaction tx=dbRule.beginTx()){
      long nodeCount=Iterables.count(dbRule.getAllNodes());
      assertEquals(4097,nodeCount);
      tx.success();
      ResourceIterator<Node> nodes=dbRule.findNodes(label("FIRST 4096"));
      assertEquals(1,Iterators.asList(nodes).size());
      nodes=dbRule.findNodes(label("SECOND 4096"));
      assertEquals(1,Iterators.asList(nodes).size());
    }
   }
  @Test public void shouldIgnoreWhitespaceAroundIntegers() throws Exception {
    List<String> values=Arrays.asList("17","    21","99   ","  34  ","-34","        -12","-92 ");
    File data=file(fileName("whitespace.csv"));
    try (PrintStream writer=new PrintStream(data)){
      writer.println(":LABEL,name,s:short,b:byte,i:int,l:long,f:float,d:double");
      for (      String value : values) {
        writer.print("PERSON,'" + value + "'");
        for (int j=0; j < 6; j++) {
          writer.print("," + value);
        }
        writer.println();
      }
    }
     importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
    int nodeCount=0;
    try (Transaction tx=dbRule.beginTx()){
      for (      Node node : dbRule.getAllNodes()) {
        nodeCount++;
        String name=(String)node.getProperty("name");
        String expected=name.trim();
        assertEquals(7,node.getAllProperties().size());
        for (        String key : node.getPropertyKeys()) {
          if (key.equals("name")) {
            continue;
          }
 else           if (key.equals("f") || key.equals("d")) {
            expected=String.valueOf(Double.parseDouble(expected));
          }
          assertEquals("Wrong value for " + key,expected,node.getProperty(key).toString());
        }
      }
      tx.success();
    }
     assertEquals(values.size(),nodeCount);
  }
  @Test public void shouldIgnoreWhitespaceAroundDecimalNumbers() throws Exception {
    List<String> values=Arrays.asList("1.0","   3.5","45.153    ","   925.12   ","-2.121","   -3.745","-412.153    ","   -5.12   ");
    File data=file(fileName("whitespace.csv"));
    try (PrintStream writer=new PrintStream(data)){
      writer.println(":LABEL,name,f:float,d:double");
      for (      String value : values) {
        writer.print("PERSON,'" + value + "'");
        for (int j=0; j < 2; j++) {
          writer.print("," + value);
        }
        writer.println();
      }
    }
     importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
    int nodeCount=0;
    try (Transaction tx=dbRule.beginTx()){
      for (      Node node : dbRule.getAllNodes()) {
        nodeCount++;
        String name=(String)node.getProperty("name");
        double expected=Double.parseDouble(name.trim());
        assertEquals(3,node.getAllProperties().size());
        for (        String key : node.getPropertyKeys()) {
          if (key.equals("name")) {
            continue;
          }
          assertEquals("Wrong value for " + key,expected,Double.valueOf(node.getProperty(key).toString()),0.0);
        }
      }
      tx.success();
    }
     assertEquals(values.size(),nodeCount);
  }
  @Test public void shouldIgnoreWhitespaceAroundBooleans() throws Exception {
    File data=file(fileName("whitespace.csv"));
    try (PrintStream writer=new PrintStream(data)){
      writer.println(":LABEL,name,adult:boolean");
      writer.println("PERSON,'t1',true");
      writer.println("PERSON,'t2',  true");
      writer.println("PERSON,'t3',true  ");
      writer.println("PERSON,'t4',  true  ");
      writer.println("PERSON,'f1',false");
      writer.println("PERSON,'f2',  false");
      writer.println("PERSON,'f3',false  ");
      writer.println("PERSON,'f4',  false  ");
      writer.println("PERSON,'f5',  truebutactuallyfalse  ");
      writer.println("PERSON,'f6',  non true things are interpreted as false  ");
    }
     importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
    try (Transaction tx=dbRule.beginTx()){
      for (      Node node : dbRule.getAllNodes()) {
        String name=(String)node.getProperty("name");
        if (name.startsWith("t")) {
          assertTrue("Wrong value on " + name,(boolean)node.getProperty("adult"));
        }
 else {
          assertFalse("Wrong value on " + name,(boolean)node.getProperty("adult"));
        }
      }
      long nodeCount=Iterables.count(dbRule.getAllNodes());
      assertEquals(10,nodeCount);
      tx.success();
    }
   }
  @Test public void shouldIgnoreWhitespaceInAndAroundIntegerArrays() throws Exception {
    String[] values=new String[]{"   17","21","99   ","  34  ","-34","        -12","-92 "};
    File data=writeArrayCsv(new String[]{"s:short[]","b:byte[]","i:int[]","l:long[]","f:float[]","d:double[]"},values);
    importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
    String iExpected=joinStringArray(values);
    String fExpected=Arrays.stream(values).map(String::trim).map(Double::valueOf).map(String::valueOf).collect(joining(", ","[","]"));
    int nodeCount=0;
    try (Transaction tx=dbRule.beginTx()){
      for (      Node node : dbRule.getAllNodes()) {
        nodeCount++;
        assertEquals(6,node.getAllProperties().size());
        for (        String key : node.getPropertyKeys()) {
          Object things=node.getProperty(key);
          String result="";
          String expected=iExpected;
switch (key) {
case "s":
            result=Arrays.toString((short[])things);
          break;
case "b":
        result=Arrays.toString((byte[])things);
      break;
case "i":
    result=Arrays.toString((int[])things);
  break;
case "l":
result=Arrays.toString((long[])things);
break;
case "f":
result=Arrays.toString((float[])things);
expected=fExpected;
break;
case "d":
result=Arrays.toString((double[])things);
expected=fExpected;
break;
default :
break;
}
assertEquals(expected,result);
}
}
tx.success();
}
 assertEquals(1,nodeCount);
}
@Test public void shouldIgnoreWhitespaceInAndAroundDecimalArrays() throws Exception {
String[] values=new String[]{"1.0","   3.5","45.153    ","   925.12   ","-2.121","   -3.745","-412.153    ","   -5.12   "};
File data=writeArrayCsv(new String[]{"f:float[]","d:double[]"},values);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
String expected=joinStringArray(values);
int nodeCount=0;
try (Transaction tx=dbRule.beginTx()){
for (Node node : dbRule.getAllNodes()) {
nodeCount++;
assertEquals(2,node.getAllProperties().size());
for (String key : node.getPropertyKeys()) {
Object things=node.getProperty(key);
String result="";
switch (key) {
case "f":
result=Arrays.toString((float[])things);
break;
case "d":
result=Arrays.toString((double[])things);
break;
default :
break;
}
assertEquals(expected,result);
}
}
tx.success();
}
 assertEquals(1,nodeCount);
}
@Test public void shouldIgnoreWhitespaceInAndAroundBooleanArrays() throws Exception {
String[] values=new String[]{"true","  true","true   ","  true  "," false ","false "," false","false "," false"};
String expected=joinStringArray(values);
File data=writeArrayCsv(new String[]{"b:boolean[]"},values);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
int nodeCount=0;
try (Transaction tx=dbRule.beginTx()){
for (Node node : dbRule.getAllNodes()) {
nodeCount++;
assertEquals(1,node.getAllProperties().size());
for (String key : node.getPropertyKeys()) {
Object things=node.getProperty(key);
String result=Arrays.toString((boolean[])things);
assertEquals(expected,result);
}
}
tx.success();
}
 assertEquals(1,nodeCount);
}
@Test public void shouldFailIfHeaderHasLessColumnsThanData() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.TABS;
int extraColumns=3;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--delimiter","TAB","--array-delimiter",String.valueOf(config.arrayDelimiter()),"--nodes",nodeHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,nodeIds,TRUE,Charset.defaultCharset(),extraColumns).getAbsolutePath(),"--relationships",relationshipHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + relationshipData(false,config,nodeIds,TRUE,true).getAbsolutePath());
fail("Should have thrown exception");
}
 catch (InputException e) {
assertFalse(suppressOutput.getErrorVoice().containsMessage(e.getClass().getName()));
assertTrue(e.getMessage().contains("Extra column not present in header on line"));
}
}
@Test public void shouldWarnIfHeaderHasLessColumnsThanDataWhenToldTo() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.TABS;
File bad=badFile();
int extraColumns=3;
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--bad",bad.getAbsolutePath(),"--bad-tolerance",Integer.toString(nodeIds.size() * extraColumns),"--ignore-extra-columns","--delimiter","TAB","--array-delimiter",String.valueOf(config.arrayDelimiter()),"--nodes",nodeHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,nodeIds,TRUE,Charset.defaultCharset(),extraColumns).getAbsolutePath(),"--relationships",relationshipHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + relationshipData(false,config,nodeIds,TRUE,true).getAbsolutePath());
String badContents=FileUtils.readTextFile(bad,Charset.defaultCharset());
assertTrue(badContents.contains("Extra column not present in header on line"));
}
@Test public void shouldImportSplitInputFiles() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,nodeIds,lines(0,NODE_COUNT / 2)).getAbsolutePath(),"--nodes",nodeData(true,config,nodeIds,lines(NODE_COUNT / 2,NODE_COUNT * 3 / 4)).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,nodeIds,lines(NODE_COUNT * 3 / 4,NODE_COUNT)).getAbsolutePath(),"--relationships",relationshipHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + relationshipData(false,config,nodeIds,TRUE,true).getAbsolutePath());
verifyData();
}
@Test public void shouldImportMultipleInputsWithAddedLabelsAndDefaultRelationshipType() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
final String[] firstLabels={"AddedOne","AddedTwo"};
final String[] secondLabels={"AddedThree"};
final String firstType="TYPE_1";
final String secondType="TYPE_2";
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes:" + join(firstLabels,":"),nodeData(true,config,nodeIds,lines(0,NODE_COUNT / 2)).getAbsolutePath(),"--nodes:" + join(secondLabels,":"),nodeData(true,config,nodeIds,lines(NODE_COUNT / 2,NODE_COUNT)).getAbsolutePath(),"--relationships:" + firstType,relationshipData(true,config,nodeIds,lines(0,RELATIONSHIP_COUNT / 2),false).getAbsolutePath(),"--relationships:" + secondType,relationshipData(true,config,nodeIds,lines(RELATIONSHIP_COUNT / 2,RELATIONSHIP_COUNT),false).getAbsolutePath());
MutableInt numberOfNodesWithFirstSetOfLabels=new MutableInt();
MutableInt numberOfNodesWithSecondSetOfLabels=new MutableInt();
MutableInt numberOfRelationshipsWithFirstType=new MutableInt();
MutableInt numberOfRelationshipsWithSecondType=new MutableInt();
verifyData(node -> {
if (nodeHasLabels(node,firstLabels)) {
numberOfNodesWithFirstSetOfLabels.increment();
}
 else if (nodeHasLabels(node,secondLabels)) {
numberOfNodesWithSecondSetOfLabels.increment();
}
 else {
fail(node + " has neither set of labels, it has " + labelsOf(node));
}
}
,relationship -> {
if (relationship.isType(RelationshipType.withName(firstType))) {
numberOfRelationshipsWithFirstType.increment();
}
 else if (relationship.isType(RelationshipType.withName(secondType))) {
numberOfRelationshipsWithSecondType.increment();
}
 else {
fail(relationship + " didn't have either type, it has " + relationship.getType().name());
}
}
);
assertEquals(NODE_COUNT / 2,numberOfNodesWithFirstSetOfLabels.intValue());
assertEquals(NODE_COUNT / 2,numberOfNodesWithSecondSetOfLabels.intValue());
assertEquals(RELATIONSHIP_COUNT / 2,numberOfRelationshipsWithFirstType.intValue());
assertEquals(RELATIONSHIP_COUNT / 2,numberOfRelationshipsWithSecondType.intValue());
}
private static String labelsOf(Node node){
StringBuilder builder=new StringBuilder();
for (Label label : node.getLabels()) {
builder.append(label.name() + " ");
}
return builder.toString();
}
private boolean nodeHasLabels(Node node,String[] labels){
for (String name : labels) {
if (!node.hasLabel(Label.label(name))) {
return false;
}
}
return true;
}
@Test public void shouldImportOnlyNodes() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,config,nodeIds,TRUE).getAbsolutePath());
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
int nodeCount=0;
for (Node node : db.getAllNodes()) {
assertTrue(node.hasProperty("name"));
nodeCount++;
assertFalse(node.hasRelationship());
}
assertEquals(NODE_COUNT,nodeCount);
tx.success();
}
 }
@Test public void shouldImportGroupsOfOverlappingIds() throws Exception {
List<String> groupOneNodeIds=asList("1","2","3");
List<String> groupTwoNodeIds=asList("4","5","2");
List<RelationshipDataLine> rels=asList(relationship("1","4","TYPE"),relationship("2","5","TYPE"),relationship("3","2","TYPE"));
Configuration config=Configuration.COMMAS;
String groupOne="Actor";
String groupTwo="Movie";
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeHeader(config,groupOne) + MULTI_FILE_DELIMITER + nodeData(false,config,groupOneNodeIds,TRUE),"--nodes",nodeHeader(config,groupTwo) + MULTI_FILE_DELIMITER + nodeData(false,config,groupTwoNodeIds,TRUE),"--relationships",relationshipHeader(config,groupOne,groupTwo,true) + MULTI_FILE_DELIMITER + relationshipData(false,config,rels.iterator(),TRUE,true));
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
int nodeCount=0;
for (Node node : db.getAllNodes()) {
assertTrue(node.hasProperty("name"));
nodeCount++;
assertEquals(1,Iterables.count(node.getRelationships()));
}
assertEquals(6,nodeCount);
tx.success();
}
 }
@Test public void shouldBeAbleToMixSpecifiedAndUnspecifiedGroups() throws Exception {
List<String> groupOneNodeIds=asList("1","2","3");
List<String> groupTwoNodeIds=asList("4","5","2");
Configuration config=Configuration.COMMAS;
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeHeader(config,"MyGroup").getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,groupOneNodeIds,TRUE).getAbsolutePath(),"--nodes",nodeHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,groupTwoNodeIds,TRUE).getAbsolutePath());
verifyData(6,0,Validators.emptyValidator(),Validators.emptyValidator());
}
@Test public void shouldImportWithoutTypeSpecifiedInRelationshipHeaderbutWithDefaultTypeInArgument() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
String type=randomType();
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),"--relationships:" + type,relationshipData(true,config,nodeIds,TRUE,false).getAbsolutePath());
verifyData();
}
@Test public void shouldIncludeSourceInformationInNodeIdCollisionError() throws Exception {
List<String> nodeIds=asList("a","b","c","d","e","f","a","g");
Configuration config=Configuration.COMMAS;
File nodeHeaderFile=nodeHeader(config);
File nodeData1=nodeData(false,config,nodeIds,lines(0,4));
File nodeData2=nodeData(false,config,nodeIds,lines(4,nodeIds.size()));
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeHeaderFile.getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData1.getAbsolutePath()+ MULTI_FILE_DELIMITER+ nodeData2.getAbsolutePath());
fail("Should have failed with duplicate node IDs");
}
 catch (Exception e) {
assertExceptionContains(e,"'a' is defined more than once",DuplicateInputIdException.class);
}
}
@Test public void shouldSkipDuplicateNodesIfToldTo() throws Exception {
List<String> nodeIds=asList("a","b","c","d","e","f","a","g");
Configuration config=Configuration.COMMAS;
File nodeHeaderFile=nodeHeader(config);
File nodeData1=nodeData(false,config,nodeIds,lines(0,4));
File nodeData2=nodeData(false,config,nodeIds,lines(4,nodeIds.size()));
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--skip-duplicate-nodes","--nodes",nodeHeaderFile.getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData1.getAbsolutePath()+ MULTI_FILE_DELIMITER+ nodeData2.getAbsolutePath());
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
Set<String> expectedNodeIds=new HashSet<>(nodeIds);
try (Transaction tx=db.beginTx()){
Set<String> foundNodesIds=new HashSet<>();
for (Node node : db.getAllNodes()) {
String id=(String)node.getProperty("id");
assertTrue(id + ", " + foundNodesIds,foundNodesIds.add(id));
assertTrue(expectedNodeIds.contains(id));
}
assertEquals(expectedNodeIds,foundNodesIds);
for (int i=0; i < MAX_LABEL_ID; i++) {
Label label=label(labelName(i));
try (ResourceIterator<Node> nodesByLabel=db.findNodes(label)){
while (nodesByLabel.hasNext()) {
Node node=nodesByLabel.next();
if (!node.hasLabel(label)) {
fail("Expected " + node + " to have label "+ label.name()+ ", but instead had "+ asList(node.getLabels()));
}
}
}
 }
tx.success();
}
  finally {
db.shutdown();
}
}
@Test public void shouldLogRelationshipsReferringToMissingNode() throws Exception {
List<String> nodeIds=asList("a","b","c");
Configuration config=Configuration.COMMAS;
File nodeData=nodeData(true,config,nodeIds,TRUE);
List<RelationshipDataLine> relationships=Arrays.asList(relationship("a","b","TYPE","aa"),relationship("c","bogus","TYPE","bb"),relationship("b","c","KNOWS","cc"),relationship("c","a","KNOWS","dd"),relationship("missing","a","KNOWS","ee"));
File relationshipData1=relationshipData(true,config,relationships.iterator(),lines(0,2),true);
File relationshipData2=relationshipData(false,config,relationships.iterator(),lines(2,5),true);
File bad=badFile();
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData.getAbsolutePath(),"--bad",bad.getAbsolutePath(),"--bad-tolerance","2","--relationships",relationshipData1.getAbsolutePath() + MULTI_FILE_DELIMITER + relationshipData2.getAbsolutePath());
String badContents=FileUtils.readTextFile(bad,Charset.defaultCharset());
assertTrue("Didn't contain first bad relationship",badContents.contains("bogus"));
assertTrue("Didn't contain second bad relationship",badContents.contains("missing"));
verifyRelationships(relationships);
}
@Test public void skipLoggingOfBadEntries() throws Exception {
List<String> nodeIds=asList("a","b","c");
Configuration config=Configuration.COMMAS;
File nodeData=nodeData(true,config,nodeIds,TRUE);
List<RelationshipDataLine> relationships=Arrays.asList(relationship("a","b","TYPE","aa"),relationship("c","bogus","TYPE","bb"),relationship("b","c","KNOWS","cc"),relationship("c","a","KNOWS","dd"),relationship("missing","a","KNOWS","ee"));
File relationshipData1=relationshipData(true,config,relationships.iterator(),lines(0,2),true);
File relationshipData2=relationshipData(false,config,relationships.iterator(),lines(2,5),true);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData.getAbsolutePath(),"--bad-tolerance","2","--skip-bad-entries-logging","true","--relationships",relationshipData1.getAbsolutePath() + MULTI_FILE_DELIMITER + relationshipData2.getAbsolutePath());
assertFalse(badFile().exists());
verifyRelationships(relationships);
}
@Test public void shouldFailIfTooManyBadRelationships() throws Exception {
List<String> nodeIds=asList("a","b","c");
Configuration config=Configuration.COMMAS;
File nodeData=nodeData(true,config,nodeIds,TRUE);
List<RelationshipDataLine> relationships=Arrays.asList(relationship("a","b","TYPE"),relationship("c","bogus","TYPE"),relationship("b","c","KNOWS"),relationship("c","a","KNOWS"),relationship("missing","a","KNOWS"));
File relationshipData=relationshipData(true,config,relationships.iterator(),TRUE,true);
File bad=badFile();
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData.getAbsolutePath(),"--bad",bad.getAbsolutePath(),"--bad-tolerance","1","--relationships",relationshipData.getAbsolutePath());
fail();
}
 catch (Exception e) {
assertExceptionContains(e,relationshipData.getAbsolutePath(),InputException.class);
}
}
@Test public void shouldBeAbleToDisableSkippingOfBadRelationships() throws Exception {
List<String> nodeIds=asList("a","b","c");
Configuration config=Configuration.COMMAS;
File nodeData=nodeData(true,config,nodeIds,TRUE);
List<RelationshipDataLine> relationships=Arrays.asList(relationship("a","b","TYPE"),relationship("c","bogus","TYPE"));
File relationshipData1=relationshipData(true,config,relationships.iterator(),lines(0,2),true);
File relationshipData2=relationshipData(false,config,relationships.iterator(),lines(2,5),true);
File bad=badFile();
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData.getAbsolutePath(),"--bad",bad.getAbsolutePath(),"--stacktrace","--skip-bad-relationships","false","--relationships",relationshipData1.getAbsolutePath() + MULTI_FILE_DELIMITER + relationshipData2.getAbsolutePath());
fail();
}
 catch (Exception e) {
assertExceptionContains(e,relationshipData1.getAbsolutePath(),InputException.class);
}
}
@Test public void shouldHandleAdditiveLabelsWithSpaces() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
final Label label1=label("My First Label");
final Label label2=label("My Other Label");
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes:My First Label:My Other Label",nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),"--relationships",relationshipData(true,config,nodeIds,TRUE,true).getAbsolutePath());
verifyData(node -> {
assertTrue(node.hasLabel(label1));
assertTrue(node.hasLabel(label2));
}
,Validators.emptyValidator());
}
@Test public void shouldImportFromInputDataEncodedWithSpecificCharset() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
Charset charset=StandardCharsets.UTF_16;
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--input-encoding",charset.name(),"--nodes",nodeData(true,config,nodeIds,TRUE,charset).getAbsolutePath(),"--relationships",relationshipData(true,config,nodeIds,TRUE,true,charset).getAbsolutePath());
verifyData();
}
@Test public void shouldDisallowImportWithoutNodesInput() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--relationships",relationshipData(true,config,nodeIds,TRUE,true).getAbsolutePath());
fail("Should have failed");
}
 catch (IllegalArgumentException e) {
assertThat(e.getMessage(),containsString("No node input"));
}
}
@Test public void shouldBeAbleToImportAnonymousNodes() throws Exception {
List<String> nodeIds=asList("1","","","","3","","","","","","5");
Configuration config=Configuration.COMMAS;
List<RelationshipDataLine> relationshipData=asList(relationship("1","3","KNOWS"));
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),"--relationships",relationshipData(true,config,relationshipData.iterator(),TRUE,true).getAbsolutePath());
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
Iterable<Node> allNodes=db.getAllNodes();
int anonymousCount=0;
for (final String id : nodeIds) {
if (id.isEmpty()) {
anonymousCount++;
}
 else {
assertNotNull(Iterators.single(Iterators.filter(nodeFilter(id),allNodes.iterator())));
}
}
assertEquals(anonymousCount,count(Iterators.filter(nodeFilter(""),allNodes.iterator())));
tx.success();
}
 }
@Test public void shouldDisallowMultilineFieldsByDefault() throws Exception {
File data=data(":ID,name","1,\"This is a line with\nnewlines in\"");
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath());
fail();
}
 catch (Exception e) {
assertExceptionContains(e,"Multi-line",IllegalMultilineFieldException.class);
}
}
@Test public void shouldNotTrimStringsByDefault() throws Exception {
String name="  This is a line with leading and trailing whitespaces   ";
File data=data(":ID,name","1,\"" + name + "\"");
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath());
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
ResourceIterator<Node> allNodes=db.getAllNodes().iterator();
Node node=Iterators.single(allNodes);
allNodes.close();
assertEquals(name,node.getProperty("name"));
tx.success();
}
 }
@Test public void shouldTrimStringsIfConfiguredTo() throws Exception {
String name="  This is a line with leading and trailing whitespaces   ";
File data=data(":ID,name","1,\"" + name + "\"","2," + name);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--trim-strings","true");
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx();ResourceIterator<Node> allNodes=db.getAllNodes().iterator()){
Set<String> names=new HashSet<>();
while (allNodes.hasNext()) {
names.add(allNodes.next().getProperty("name").toString());
}
assertTrue(names.remove(name));
assertTrue(names.remove(name.trim()));
assertTrue(names.isEmpty());
tx.success();
}
 }
@Test public void shouldPrintReferenceLinkOnDataImportErrors(){
String[] versionParts=Version.getNeo4jVersion().split("-");
versionParts[0]=versionParts[0].substring(0,3);
String docsVersion=String.join("-",versionParts);
shouldPrintReferenceLinkAsPartOfErrorMessage(nodeIds(),Iterators.iterator(new RelationshipDataLine("1","","type","name")),"Relationship missing mandatory field 'END_ID', read more about relationship " + "format in the manual:  https://neo4j.com/docs/operations-manual/" + docsVersion + "/tools/import/file-header-format/#import-tool-header-format-rels");
shouldPrintReferenceLinkAsPartOfErrorMessage(nodeIds(),Iterators.iterator(new RelationshipDataLine("","1","type","name")),"Relationship missing mandatory field 'START_ID', read more about relationship " + "format in the manual:  https://neo4j.com/docs/operations-manual/" + docsVersion + "/tools/import/file-header-format/#import-tool-header-format-rels");
shouldPrintReferenceLinkAsPartOfErrorMessage(nodeIds(),Iterators.iterator(new RelationshipDataLine("1","2","","name")),"Relationship missing mandatory field 'TYPE', read more about relationship " + "format in the manual:  https://neo4j.com/docs/operations-manual/" + docsVersion + "/tools/import/file-header-format/#import-tool-header-format-rels");
shouldPrintReferenceLinkAsPartOfErrorMessage(Arrays.asList("1","1"),Iterators.iterator(new RelationshipDataLine("1","2","type","name")),"Duplicate input ids that would otherwise clash can be put into separate id space, read more " + "about how to use id spaces in the manual: https://neo4j.com/docs/operations-manual/" + docsVersion + "/tools/import/file-header-format/#import-tool-id-spaces");
}
@Test public void shouldCollectUnlimitedNumberOfBadEntries() throws Exception {
List<String> nodeIds=Collections.nCopies(10_000,"A");
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,Configuration.COMMAS,nodeIds,TRUE).getAbsolutePath(),"--skip-duplicate-nodes","--bad-tolerance","true");
}
private void shouldPrintReferenceLinkAsPartOfErrorMessage(List<String> nodeIds,Iterator<RelationshipDataLine> relationshipDataLines,String message){
Configuration config=Configuration.COMMAS;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),"--skip-bad-relationships","false","--relationships",relationshipData(true,config,relationshipDataLines,TRUE,true).getAbsolutePath());
fail(" Should fail during import.");
}
 catch (Exception e) {
assertTrue(suppressOutput.getErrorVoice().containsMessage(message));
}
for (StoreType storeType : StoreType.values()) {
if (storeType.isRecordStore()) {
dbRule.databaseLayout().file(storeType.getDatabaseFile()).forEach(File::delete);
}
}
}
@Test public void shouldAllowMultilineFieldsWhenEnabled() throws Exception {
File data=data(":ID,name","1,\"This is a line with\nnewlines in\"");
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--multiline-fields","true");
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
ResourceIterator<Node> allNodes=db.getAllNodes().iterator();
Node node=Iterators.single(allNodes);
allNodes.close();
assertEquals("This is a line with\nnewlines in",node.getProperty("name"));
tx.success();
}
 }
@Test public void shouldSkipEmptyFiles() throws Exception {
File data=data("");
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath());
GraphDatabaseService graphDatabaseService=dbRule.getGraphDatabaseAPI();
try (Transaction tx=graphDatabaseService.beginTx()){
ResourceIterator<Node> allNodes=graphDatabaseService.getAllNodes().iterator();
assertFalse("Expected database to be empty",allNodes.hasNext());
tx.success();
}
 }
@Test public void shouldIgnoreEmptyQuotedStringsIfConfiguredTo() throws Exception {
File data=data(":ID,one,two,three","1,\"\",,value");
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--ignore-empty-strings","true");
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
Node node=Iterables.single(db.getAllNodes());
assertFalse(node.hasProperty("one"));
assertFalse(node.hasProperty("two"));
assertEquals("value",node.getProperty("three"));
tx.success();
}
 }
@Test public void shouldPrintUserFriendlyMessageAboutUnsupportedMultilineFields() throws Exception {
File data=data(":ID,name","1,\"one\ntwo\nthree\"","2,four");
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--multiline-fields","false");
fail("Should have failed");
}
 catch (InputException e) {
assertTrue(suppressOutput.getErrorVoice().containsMessage("Detected field which spanned multiple lines"));
assertTrue(suppressOutput.getErrorVoice().containsMessage("multiline-fields"));
}
}
@Test public void shouldAcceptRawAsciiCharacterCodeAsQuoteConfiguration() throws Exception {
char weirdDelimiter=1;
String name1=weirdDelimiter + "Weird" + weirdDelimiter;
String name2="Start " + weirdDelimiter + "middle thing"+ weirdDelimiter+ " end!";
File data=data(":ID,name","1," + name1,"2," + name2);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--quote",String.valueOf(weirdDelimiter));
Set<String> names=asSet("Weird",name2);
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
for (Node node : db.getAllNodes()) {
String name=(String)node.getProperty("name");
assertTrue("Didn't expect node with name '" + name + "'",names.remove(name));
}
assertTrue(names.isEmpty());
tx.success();
}
 }
@Test public void shouldAcceptSpecialTabCharacterAsDelimiterConfiguration() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.TABS;
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--delimiter","\\t","--array-delimiter",String.valueOf(config.arrayDelimiter()),"--nodes",nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),"--relationships",relationshipData(true,config,nodeIds,TRUE,true).getAbsolutePath());
verifyData();
}
@Test public void shouldReportBadDelimiterConfiguration() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.TABS;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--delimiter","\\bogus","--array-delimiter",String.valueOf(config.arrayDelimiter()),"--nodes",nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),"--relationships",relationshipData(true,config,nodeIds,TRUE,true).getAbsolutePath());
fail("Should have failed");
}
 catch (IllegalArgumentException e) {
assertThat(e.getMessage(),containsString("bogus"));
}
}
@Test public void shouldFailAndReportStartingLineForUnbalancedQuoteInMiddle() throws Exception {
int unbalancedStartLine=10;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeDataWithMissingQuote(2 * unbalancedStartLine,unbalancedStartLine).getAbsolutePath());
fail("Should have failed");
}
 catch (InputException e) {
assertThat(e.getMessage(),containsString(String.format("Multi-line fields are illegal",unbalancedStartLine)));
}
}
@Test public void shouldAcceptRawEscapedAsciiCodeAsQuoteConfiguration() throws Exception {
char weirdDelimiter=1;
String name1=weirdDelimiter + "Weird" + weirdDelimiter;
String name2="Start " + weirdDelimiter + "middle thing"+ weirdDelimiter+ " end!";
File data=data(":ID,name","1," + name1,"2," + name2);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--quote","\\1");
Set<String> names=asSet("Weird",name2);
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
for (Node node : db.getAllNodes()) {
String name=(String)node.getProperty("name");
assertTrue("Didn't expect node with name '" + name + "'",names.remove(name));
}
assertTrue(names.isEmpty());
tx.success();
}
 }
@Test public void shouldFailAndReportStartingLineForUnbalancedQuoteAtEnd() throws Exception {
int unbalancedStartLine=10;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeDataWithMissingQuote(unbalancedStartLine,unbalancedStartLine).getAbsolutePath());
fail("Should have failed");
}
 catch (InputException e) {
assertThat(e.getMessage(),containsString(String.format("Multi-line fields")));
}
}
@Test public void shouldBeEquivalentToUseRawAsciiOrCharacterAsQuoteConfiguration1() throws Exception {
char weirdDelimiter=126;
String weirdStringDelimiter="\\126";
String name1=weirdDelimiter + "Weird" + weirdDelimiter;
String name2="Start " + weirdDelimiter + "middle thing"+ weirdDelimiter+ " end!";
File data=data(":ID,name","1," + name1,"2," + name2);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--quote",weirdStringDelimiter);
assertEquals("~","" + weirdDelimiter);
assertEquals("~".charAt(0),weirdDelimiter);
Set<String> names=asSet("Weird",name2);
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
for (Node node : db.getAllNodes()) {
String name=(String)node.getProperty("name");
assertTrue("Didn't expect node with name '" + name + "'",names.remove(name));
}
assertTrue(names.isEmpty());
tx.success();
}
 }
@Test public void shouldFailOnUnbalancedQuoteWithMultilinesEnabled() throws Exception {
int unbalancedStartLine=10;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--multiline-fields","true","--nodes",nodeDataWithMissingQuote(2 * unbalancedStartLine,unbalancedStartLine).getAbsolutePath());
fail("Should have failed");
}
 catch (InputException e) {
}
}
private File nodeDataWithMissingQuote(int totalLines,int unbalancedStartLine) throws Exception {
String[] lines=new String[totalLines + 1];
lines[0]="ID,:LABEL";
for (int i=1; i <= totalLines; i++) {
StringBuilder line=new StringBuilder(String.format("%d,",i));
if (i == unbalancedStartLine) {
line.append("\"Secret Agent");
}
 else {
line.append("Agent");
}
lines[i]=line.toString();
}
return data(lines);
}
@Test public void shouldBeEquivalentToUseRawAsciiOrCharacterAsQuoteConfiguration2() throws Exception {
char weirdDelimiter=126;
String weirdStringDelimiter="~";
String name1=weirdDelimiter + "Weird" + weirdDelimiter;
String name2="Start " + weirdDelimiter + "middle thing"+ weirdDelimiter+ " end!";
File data=data(":ID,name","1," + name1,"2," + name2);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data.getAbsolutePath(),"--quote",weirdStringDelimiter);
assertEquals(weirdStringDelimiter,"" + weirdDelimiter);
assertEquals(weirdStringDelimiter.charAt(0),weirdDelimiter);
Set<String> names=asSet("Weird",name2);
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
for (Node node : db.getAllNodes()) {
String name=(String)node.getProperty("name");
assertTrue("Didn't expect node with name '" + name + "'",names.remove(name));
}
assertTrue(names.isEmpty());
tx.success();
}
 }
@Test public void shouldRespectDbConfig() throws Exception {
int arrayBlockSize=10;
int stringBlockSize=12;
File dbConfig=file("neo4j.properties");
store(stringMap(GraphDatabaseSettings.array_block_size.name(),String.valueOf(arrayBlockSize),GraphDatabaseSettings.string_block_size.name(),String.valueOf(stringBlockSize)),dbConfig);
List<String> nodeIds=nodeIds();
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--db-config",dbConfig.getAbsolutePath(),"--nodes",nodeData(true,Configuration.COMMAS,nodeIds,value -> true).getAbsolutePath());
NeoStores stores=dbRule.getGraphDatabaseAPI().getDependencyResolver().resolveDependency(RecordStorageEngine.class).testAccessNeoStores();
int headerSize=Standard.LATEST_RECORD_FORMATS.dynamic().getRecordHeaderSize();
assertEquals(arrayBlockSize + headerSize,stores.getPropertyStore().getArrayStore().getRecordSize());
assertEquals(stringBlockSize + headerSize,stores.getPropertyStore().getStringStore().getRecordSize());
}
@Test public void useProvidedAdditionalConfig() throws Exception {
int arrayBlockSize=10;
int stringBlockSize=12;
File dbConfig=file("neo4j.properties");
store(stringMap(GraphDatabaseSettings.array_block_size.name(),String.valueOf(arrayBlockSize),GraphDatabaseSettings.string_block_size.name(),String.valueOf(stringBlockSize)),dbConfig);
List<String> nodeIds=nodeIds();
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--additional-config",dbConfig.getAbsolutePath(),"--nodes",nodeData(true,Configuration.COMMAS,nodeIds,value -> true).getAbsolutePath());
NeoStores stores=dbRule.getGraphDatabaseAPI().getDependencyResolver().resolveDependency(RecordStorageEngine.class).testAccessNeoStores();
int headerSize=Standard.LATEST_RECORD_FORMATS.dynamic().getRecordHeaderSize();
assertEquals(arrayBlockSize + headerSize,stores.getPropertyStore().getArrayStore().getRecordSize());
assertEquals(stringBlockSize + headerSize,stores.getPropertyStore().getStringStore().getRecordSize());
}
@Test public void combineProvidedDbAndAdditionalConfig() throws Exception {
int arrayBlockSize=10;
int stringBlockSize=12;
File dbConfig=file("neo4j.properties");
File additionalConfig=file("additional.properties");
store(stringMap(GraphDatabaseSettings.string_block_size.name(),String.valueOf(stringBlockSize)),dbConfig);
store(stringMap(GraphDatabaseSettings.array_block_size.name(),String.valueOf(arrayBlockSize)),additionalConfig);
List<String> nodeIds=nodeIds();
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--db-config",dbConfig.getAbsolutePath(),"--additional-config",additionalConfig.getAbsolutePath(),"--nodes",nodeData(true,Configuration.COMMAS,nodeIds,value -> true).getAbsolutePath());
NeoStores stores=dbRule.getGraphDatabaseAPI().getDependencyResolver().resolveDependency(RecordStorageEngine.class).testAccessNeoStores();
int headerSize=Standard.LATEST_RECORD_FORMATS.dynamic().getRecordHeaderSize();
assertEquals(arrayBlockSize + headerSize,stores.getPropertyStore().getArrayStore().getRecordSize());
assertEquals(stringBlockSize + headerSize,stores.getPropertyStore().getStringStore().getRecordSize());
}
@Test public void shouldPrintStackTraceOnInputExceptionIfToldTo() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
int extraColumns=3;
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,nodeIds,TRUE,Charset.defaultCharset(),extraColumns).getAbsolutePath(),"--stacktrace");
fail("Should have thrown exception");
}
 catch (InputException e) {
assertTrue(suppressOutput.getErrorVoice().containsMessage(e.getClass().getName()));
assertTrue(e.getMessage().contains("Extra column not present in header on line"));
}
}
@Test public void shouldDisableLegacyStyleQuotingIfToldTo() throws Exception {
String nodeId="me";
String labelName="Alive";
List<String> lines=new ArrayList<>();
lines.add(":ID,name,:LABEL");
lines.add(nodeId + "," + "\"abc\"\"def\\\"\"ghi\""+ ","+ labelName);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data(lines.toArray(new String[lines.size()])).getAbsolutePath(),"--legacy-style-quoting","false","--stacktrace");
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
assertNotNull(db.findNode(label(labelName),"name","abc\"def\\\"ghi"));
}
 }
@Test public void shouldRespectBufferSizeSetting() throws Exception {
List<String> lines=new ArrayList<>();
lines.add(":ID,name,:LABEL");
lines.add("id," + repeat('l',2_000) + ",Person");
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",data(lines.toArray(new String[lines.size()])).getAbsolutePath(),"--read-buffer-size","1k");
fail("Should've failed");
}
 catch (IllegalStateException e) {
assertThat(e.getMessage(),containsString("input data"));
}
}
@Test public void shouldRespectMaxMemoryPercentageSetting() throws Exception {
List<String> nodeIds=nodeIds(10);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,Configuration.COMMAS,nodeIds,TRUE).getAbsolutePath(),"--max-memory","60%");
}
@Test public void shouldFailOnInvalidMaxMemoryPercentageSetting() throws Exception {
List<String> nodeIds=nodeIds(10);
try {
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,Configuration.COMMAS,nodeIds,TRUE).getAbsolutePath(),"--max-memory","110%");
fail("Should have failed");
}
 catch (IllegalArgumentException e) {
assertThat(e.getMessage(),containsString("percent"));
}
}
@Test public void shouldRespectMaxMemorySuffixedSetting() throws Exception {
List<String> nodeIds=nodeIds(10);
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData(true,Configuration.COMMAS,nodeIds,TRUE).getAbsolutePath(),"--max-memory","100M");
}
@Test public void shouldTreatRelationshipWithMissingStartOrEndIdOrTypeAsBadRelationship() throws Exception {
List<String> nodeIds=asList("a","b","c");
Configuration config=Configuration.COMMAS;
File nodeData=nodeData(true,config,nodeIds,TRUE);
List<RelationshipDataLine> relationships=Arrays.asList(relationship("a",null,"TYPE"),relationship(null,"b","TYPE"),relationship("a","b",null));
File relationshipData=relationshipData(true,config,relationships.iterator(),TRUE,true);
File bad=badFile();
importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--nodes",nodeData.getAbsolutePath(),"--bad",bad.getAbsolutePath(),"--skip-bad-relationships","true","--relationships",relationshipData.getAbsolutePath());
String badContents=FileUtils.readTextFile(bad,Charset.defaultCharset());
assertEquals(badContents,3,occurencesOf(badContents,"is missing data"));
}
@Test public void shouldKeepStoreFilesAfterFailedImport() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
int extraColumns=3;
String databaseDir=dbRule.getDatabaseDirAbsolutePath();
try {
importTool("--into",databaseDir,"--nodes",nodeHeader(config).getAbsolutePath() + MULTI_FILE_DELIMITER + nodeData(false,config,nodeIds,TRUE,Charset.defaultCharset(),extraColumns).getAbsolutePath());
fail("Should have thrown exception");
}
 catch (InputException e) {
for (StoreType storeType : StoreType.values()) {
if (storeType.isRecordStore()) {
dbRule.databaseLayout().file(storeType.getDatabaseFile()).forEach(f -> assertTrue(f.exists()));
}
}
List<String> errorLines=suppressOutput.getErrorVoice().lines();
assertContains(errorLines,"Starting a database on these store files will likely fail or observe inconsistent records");
}
}
@Test public void shouldSupplyArgumentsAsFile() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
File argumentFile=file("args");
String nodesEscapedSpaces=escapePath(nodeData(true,config,nodeIds,TRUE).getAbsolutePath());
String relationshipsEscapedSpaced=escapePath(relationshipData(true,config,nodeIds,TRUE,true).getAbsolutePath());
String arguments=format("--into %s%n" + "--nodes %s --relationships %s",escapePath(dbRule.getDatabaseDirAbsolutePath()),nodesEscapedSpaces,relationshipsEscapedSpaced);
writeToFile(argumentFile,arguments,false);
importTool("-f",argumentFile.getAbsolutePath());
verifyData();
}
@Test public void shouldFailIfSupplyingBothFileArgumentAndAnyOtherArgument() throws Exception {
List<String> nodeIds=nodeIds();
Configuration config=Configuration.COMMAS;
File argumentFile=file("args");
String arguments=format("--into %s%n" + "--nodes %s --relationships %s",dbRule.getDatabaseDirAbsolutePath(),nodeData(true,config,nodeIds,TRUE).getAbsolutePath(),relationshipData(true,config,nodeIds,TRUE,true).getAbsolutePath());
writeToFile(argumentFile,arguments,false);
try {
importTool("-f",argumentFile.getAbsolutePath(),"--into",dbRule.getDatabaseDirAbsolutePath());
fail("Should have failed");
}
 catch (IllegalArgumentException e) {
assertThat(e.getMessage(),containsString("in addition to"));
assertThat(e.getMessage(),containsString(ImportTool.Options.FILE.argument()));
}
}
private static void assertContains(List<String> errorLines,String string){
for (String line : errorLines) {
if (line.contains(string)) {
return;
}
}
fail("Expected error lines " + join(errorLines.toArray(new String[errorLines.size()]),format("%n")) + " to have at least one line containing the string '"+ string+ "'");
}
private static int occurencesOf(String text,String lookFor){
int index=-1;
int count=-1;
do {
count++;
index=text.indexOf(lookFor,index + 1);
}
 while (index != -1);
return count;
}
private File writeArrayCsv(String[] headers,String[] values) throws FileNotFoundException {
File data=file(fileName("whitespace.csv"));
try (PrintStream writer=new PrintStream(data)){
writer.print(":LABEL");
for (String header : headers) {
writer.print("," + header);
}
writer.println();
writer.print("PERSON");
for (String ignored : headers) {
boolean comma=true;
for (String value : values) {
if (comma) {
writer.print(",");
comma=false;
}
 else {
writer.print(";");
}
writer.print(value);
}
}
writer.println();
}
 return data;
}
private String joinStringArray(String[] values){
return Arrays.stream(values).map(String::trim).collect(joining(", ","[","]"));
}
private File data(String... lines) throws Exception {
File file=file(fileName("data.csv"));
try (PrintStream writer=writer(file,Charset.defaultCharset())){
for (String line : lines) {
writer.println(line);
}
}
 return file;
}
private Predicate<Node> nodeFilter(final String id){
return node -> node.getProperty("id","").equals(id);
}
private void verifyData(){
verifyData(Validators.emptyValidator(),Validators.emptyValidator());
}
private void verifyData(Validator<Node> nodeAdditionalValidation,Validator<Relationship> relationshipAdditionalValidation){
verifyData(NODE_COUNT,RELATIONSHIP_COUNT,nodeAdditionalValidation,relationshipAdditionalValidation);
}
private void verifyData(int expectedNodeCount,int expectedRelationshipCount,Validator<Node> nodeAdditionalValidation,Validator<Relationship> relationshipAdditionalValidation){
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
try (Transaction tx=db.beginTx()){
int nodeCount=0;
int relationshipCount=0;
for (Node node : db.getAllNodes()) {
assertTrue(node.hasProperty("name"));
nodeAdditionalValidation.validate(node);
nodeCount++;
}
assertEquals(expectedNodeCount,nodeCount);
for (Relationship relationship : db.getAllRelationships()) {
assertTrue(relationship.hasProperty("created"));
relationshipAdditionalValidation.validate(relationship);
relationshipCount++;
}
assertEquals(expectedRelationshipCount,relationshipCount);
tx.success();
}
 }
private void verifyRelationships(List<RelationshipDataLine> relationships){
GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
Map<String,Node> nodesById=allNodesById(db);
try (Transaction tx=db.beginTx()){
for (RelationshipDataLine relationship : relationships) {
Node startNode=nodesById.get(relationship.startNodeId);
Node endNode=nodesById.get(relationship.endNodeId);
if (startNode == null || endNode == null) {
continue;
}
assertNotNull(relationship.toString(),findRelationship(startNode,endNode,relationship));
}
tx.success();
}
 }
private Relationship findRelationship(Node startNode,final Node endNode,final RelationshipDataLine relationship){
return Iterators.singleOrNull(Iterators.filter(item -> item.getEndNode().equals(endNode) && item.getProperty("name").equals(relationship.name),startNode.getRelationships(withName(relationship.type)).iterator()));
}
private Map<String,Node> allNodesById(GraphDatabaseService db){
try (Transaction tx=db.beginTx()){
Map<String,Node> nodes=new HashMap<>();
for (Node node : db.getAllNodes()) {
nodes.put(idOf(node),node);
}
tx.success();
return nodes;
}
 }
private String idOf(Node node){
return (String)node.getProperty("id");
}
private List<String> nodeIds(){
return nodeIds(NODE_COUNT);
}
private List<String> nodeIds(int count){
List<String> ids=new ArrayList<>();
for (int i=0; i < count; i++) {
ids.add(randomNodeId());
}
return ids;
}
private String randomNodeId(){
return UUID.randomUUID().toString();
}
private File nodeData(boolean includeHeader,Configuration config,List<String> nodeIds,IntPredicate linePredicate) throws Exception {
return nodeData(includeHeader,config,nodeIds,linePredicate,Charset.defaultCharset());
}
private File nodeData(boolean includeHeader,Configuration config,List<String> nodeIds,IntPredicate linePredicate,Charset encoding) throws Exception {
return nodeData(includeHeader,config,nodeIds,linePredicate,encoding,0);
}
private File nodeData(boolean includeHeader,Configuration config,List<String> nodeIds,IntPredicate linePredicate,Charset encoding,int extraColumns) throws Exception {
File file=file(fileName("nodes.csv"));
try (PrintStream writer=writer(file,encoding)){
if (includeHeader) {
writeNodeHeader(writer,config,null);
}
writeNodeData(writer,config,nodeIds,linePredicate,extraColumns);
}
 return file;
}
private PrintStream writer(File file,Charset encoding) throws Exception {
return new PrintStream(file,encoding.name());
}
private File nodeHeader(Configuration config) throws Exception {
return nodeHeader(config,null);
}
private File nodeHeader(Configuration config,String idGroup) throws Exception {
return nodeHeader(config,idGroup,Charset.defaultCharset());
}
private File nodeHeader(Configuration config,String idGroup,Charset encoding) throws Exception {
File file=file(fileName("nodes-header.csv"));
try (PrintStream writer=writer(file,encoding)){
writeNodeHeader(writer,config,idGroup);
}
 return file;
}
private void writeNodeHeader(PrintStream writer,Configuration config,String idGroup){
char delimiter=config.delimiter();
writer.println(idEntry("id",Type.ID,idGroup) + delimiter + "name"+ delimiter+ "labels:LABEL");
}
private String idEntry(String name,Type type,String idGroup){
return (name != null ? name : "") + ":" + type.name()+ (idGroup != null ? "(" + idGroup + ")" : "");
}
private void writeNodeData(PrintStream writer,Configuration config,List<String> nodeIds,IntPredicate linePredicate,int extraColumns){
char delimiter=config.delimiter();
char arrayDelimiter=config.arrayDelimiter();
for (int i=0; i < nodeIds.size(); i++) {
if (linePredicate.test(i)) {
writer.println(getLine(nodeIds.get(i),delimiter,arrayDelimiter,extraColumns));
}
}
}
private String getLine(String nodeId,char delimiter,char arrayDelimiter,int extraColumns){
StringBuilder stringBuilder=new StringBuilder().append(nodeId).append(delimiter).append(randomName()).append(delimiter).append(randomLabels(arrayDelimiter));
for (int i=0; i < extraColumns; i++) {
stringBuilder.append(delimiter).append("ExtraColumn").append(i);
}
return stringBuilder.toString();
}
private String randomLabels(char arrayDelimiter){
int length=random.nextInt(3);
StringBuilder builder=new StringBuilder();
for (int i=0; i < length; i++) {
if (i > 0) {
builder.append(arrayDelimiter);
}
builder.append(labelName(random.nextInt(MAX_LABEL_ID)));
}
return builder.toString();
}
private String labelName(int number){
return "LABEL_" + number;
}
private String randomName(){
int length=random.nextInt(10) + 5;
StringBuilder builder=new StringBuilder();
for (int i=0; i < length; i++) {
builder.append((char)('a' + random.nextInt(20)));
}
return builder.toString();
}
private File relationshipData(boolean includeHeader,Configuration config,List<String> nodeIds,IntPredicate linePredicate,boolean specifyType) throws Exception {
return relationshipData(includeHeader,config,nodeIds,linePredicate,specifyType,Charset.defaultCharset());
}
private File relationshipData(boolean includeHeader,Configuration config,List<String> nodeIds,IntPredicate linePredicate,boolean specifyType,Charset encoding) throws Exception {
return relationshipData(includeHeader,config,randomRelationships(nodeIds),linePredicate,specifyType,encoding);
}
private File relationshipData(boolean includeHeader,Configuration config,Iterator<RelationshipDataLine> data,IntPredicate linePredicate,boolean specifyType) throws Exception {
return relationshipData(includeHeader,config,data,linePredicate,specifyType,Charset.defaultCharset());
}
private File relationshipData(boolean includeHeader,Configuration config,Iterator<RelationshipDataLine> data,IntPredicate linePredicate,boolean specifyType,Charset encoding) throws Exception {
File file=file(fileName("relationships.csv"));
try (PrintStream writer=writer(file,encoding)){
if (includeHeader) {
writeRelationshipHeader(writer,config,null,null,specifyType);
}
writeRelationshipData(writer,config,data,linePredicate,specifyType);
}
 return file;
}
private File relationshipHeader(Configuration config) throws Exception {
return relationshipHeader(config,Charset.defaultCharset());
}
private File relationshipHeader(Configuration config,Charset encoding) throws Exception {
return relationshipHeader(config,null,null,true,encoding);
}
private File relationshipHeader(Configuration config,String startIdGroup,String endIdGroup,boolean specifyType) throws Exception {
return relationshipHeader(config,startIdGroup,endIdGroup,specifyType,Charset.defaultCharset());
}
private File relationshipHeader(Configuration config,String startIdGroup,String endIdGroup,boolean specifyType,Charset encoding) throws Exception {
File file=file(fileName("relationships-header.csv"));
try (PrintStream writer=writer(file,encoding)){
writeRelationshipHeader(writer,config,startIdGroup,endIdGroup,specifyType);
}
 return file;
}
private String fileName(String name){
return dataIndex++ + "-" + name;
}
private File file(String localname){
return dbRule.databaseLayout().file(localname);
}
private File badFile(){
return dbRule.databaseLayout().file(BAD_FILE_NAME);
}
private void writeRelationshipHeader(PrintStream writer,Configuration config,String startIdGroup,String endIdGroup,boolean specifyType){
char delimiter=config.delimiter();
writer.println(idEntry(null,Type.START_ID,startIdGroup) + delimiter + idEntry(null,Type.END_ID,endIdGroup)+ (specifyType ? (delimiter + ":" + Type.TYPE) : "")+ delimiter+ "created:long"+ delimiter+ "name:String");
}
private static class RelationshipDataLine {
private final String startNodeId;
private final String endNodeId;
private final String type;
private final String name;
RelationshipDataLine(String startNodeId,String endNodeId,String type,String name){
this.startNodeId=startNodeId;
this.endNodeId=endNodeId;
this.type=type;
this.name=name;
}
@Override public String toString(){
return "RelationshipDataLine [startNodeId=" + startNodeId + ", endNodeId="+ endNodeId+ ", type="+ type+ ", name="+ name+ "]";
}
}
private static RelationshipDataLine relationship(String startNodeId,String endNodeId,String type){
return relationship(startNodeId,endNodeId,type,null);
}
private static RelationshipDataLine relationship(String startNodeId,String endNodeId,String type,String name){
return new RelationshipDataLine(startNodeId,endNodeId,type,name);
}
private void writeRelationshipData(PrintStream writer,Configuration config,Iterator<RelationshipDataLine> data,IntPredicate linePredicate,boolean specifyType){
char delimiter=config.delimiter();
for (int i=0; i < RELATIONSHIP_COUNT; i++) {
if (!data.hasNext()) {
break;
}
RelationshipDataLine entry=data.next();
if (linePredicate.test(i)) {
writer.println(nullSafeString(entry.startNodeId) + delimiter + nullSafeString(entry.endNodeId)+ (specifyType ? (delimiter + nullSafeString(entry.type)) : "")+ delimiter+ currentTimeMillis()+ delimiter+ (entry.name != null ? entry.name : ""));
}
}
}
private static String nullSafeString(String endNodeId){
return endNodeId != null ? endNodeId : "";
}
private Iterator<RelationshipDataLine> randomRelationships(final List<String> nodeIds){
return new PrefetchingIterator<RelationshipDataLine>(){
@Override protected RelationshipDataLine fetchNextOrNull(){
return new RelationshipDataLine(nodeIds.get(random.nextInt(nodeIds.size())),nodeIds.get(random.nextInt(nodeIds.size())),randomType(),null);
}
}
;
}
static void assertExceptionContains(Exception e,String message,Class<? extends Exception> type) throws Exception {
if (!contains(e,message,type)) {
throw withMessage(e,format("Expected exception to contain cause '%s', %s. but was %s",message,type,e));
}
}
private String randomType(){
return "TYPE_" + random.nextInt(4);
}
private IntPredicate lines(final int startingAt,final int endingAt){
return line -> line >= startingAt && line < endingAt;
}
private static String escapePath(String path){
return path.replaceAll(" ","\\\\ ");
}
static void importTool(String... arguments) throws IOException {
ImportTool.main(arguments,true);
}
}
