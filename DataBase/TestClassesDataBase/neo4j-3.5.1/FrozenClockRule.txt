public class FrozenClockRule extends Clock implements TestRule, Function<String,Clock>, Supplier<ZoneId> {
  @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface TimeZone {  String[] value();
}
  public static final TemporalAdjuster SECOND_PRECISION=temporal -> temporal.with(ChronoField.NANO_OF_SECOND,0);
  public static final TemporalAdjuster MILLISECOND_PRECISION=temporal -> temporal.with(ChronoField.NANO_OF_SECOND,temporal.get(ChronoField.MILLI_OF_SECOND) * 1000_000);
  private Instant instant;
  private ZoneId zone;
  @Override public ZoneId getZone(){
    return zone;
  }
  public Clock withZone(  String zoneId){
    return withZone(ZoneId.of(zoneId));
  }
  @Override public Clock withZone(  ZoneId zone){
    return fixed(instant,zone);
  }
  @Override public Instant instant(){
    return instant;
  }
  @Override public long millis(){
    return instant.toEpochMilli();
  }
  public Clock at(  LocalDateTime datetime){
    return at(datetime.atZone(zone));
  }
  public Clock at(  OffsetDateTime datetime){
    return fixed(datetime.toInstant(),datetime.getOffset());
  }
  public Clock at(  ZonedDateTime datetime){
    return fixed(datetime.toInstant(),datetime.getZone());
  }
  public Clock with(  TemporalAdjuster adjuster){
    return fixed(instant.with(adjuster),zone);
  }
  public Clock with(  TemporalField field,  long newValue){
    return fixed(instant.with(field,newValue),zone);
  }
  @Override public Clock apply(  String when){
    return this;
  }
  @Override public ZoneId get(){
    return zone;
  }
  @Override public Statement apply(  Statement base,  Description description){
    return new Statement(){
      @Override public void evaluate() throws Throwable {
        try {
          for (          ZoneId zoneId : zonesOf(description)) {
            instant=Instant.now();
            zone=zoneId;
            base.evaluate();
          }
        }
  finally {
          instant=null;
          zone=null;
        }
      }
      private ZoneId[] zonesOf(      Description description){
        TimeZone zone=description.getAnnotation(TimeZone.class);
        String[] ids=zone == null ? null : zone.value();
        if (ids == null || ids.length == 0) {
          return new ZoneId[]{UTC};
        }
 else {
          ZoneId[] zones=new ZoneId[ids.length];
          for (int i=0; i < zones.length; i++) {
            zones[i]=ZoneId.of(ids[i]);
          }
          return zones;
        }
      }
    }
;
  }
  static <V extends TemporalValue<?,V>>void assertEqualTemporal(  V expected,  V actual){
    assertThat(actual,allOf(equalTo(expected),equalOn("timezone",FrozenClockRule::timezone,expected),equalOn("temporal",TemporalValue::temporal,expected)));
  }
  private static ZoneId timezone(  TemporalValue<?,?> temporal){
    if (temporal instanceof DateTimeValue) {
      return ((DateTimeValue)temporal).temporal().getZone();
    }
    if (temporal instanceof TimeValue) {
      return ((TimeValue)temporal).temporal().getOffset();
    }
    return null;
  }
  private static <T,U>Matcher<T> equalOn(  String trait,  Function<T,U> mapping,  T expected){
    return new TypeSafeDiagnosingMatcher<T>(expected.getClass()){
      @Override protected boolean matchesSafely(      T actual,      org.hamcrest.Description mismatchDescription){
        U e=mapping.apply(expected);
        U a=mapping.apply(actual);
        if (Objects.equals(e,a)) {
          return true;
        }
        mismatchDescription.appendText("- ");
        mismatchDescription.appendText("expected: ").appendValue(e);
        mismatchDescription.appendText(" but was: ").appendValue(a);
        return false;
      }
      @Override public void describeTo(      org.hamcrest.Description description){
        description.appendText(trait).appendText(" should be equal");
      }
    }
;
  }
}
