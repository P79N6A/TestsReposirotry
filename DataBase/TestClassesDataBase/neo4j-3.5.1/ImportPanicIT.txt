public class ImportPanicIT {
  private static final int BUFFER_SIZE=1000;
  private final FileSystemAbstraction fs=new DefaultFileSystemAbstraction();
  private final TestDirectory directory=TestDirectory.testDirectory();
  private final RandomRule random=new RandomRule();
  @Rule public final RuleChain rules=RuleChain.outerRule(random).around(directory);
  /** 
 * There was this problem where some steps and in particular parallel CSV input parsing that paniced would hang the import entirely.
 */
  @Test public void shouldExitAndThrowExceptionOnPanic() throws Exception {
    try (JobScheduler jobScheduler=new ThreadPoolJobScheduler()){
      BatchImporter importer=new ParallelBatchImporter(directory.databaseLayout(),fs,null,Configuration.DEFAULT,NullLogService.getInstance(),ExecutionMonitors.invisible(),AdditionalInitialIds.EMPTY,Config.defaults(),StandardV3_0.RECORD_FORMATS,NO_MONITOR,jobScheduler);
      Iterable<DataFactory> nodeData=datas(data(NO_DECORATOR,fileAsCharReadable(nodeCsvFileWithBrokenEntries())));
      Input brokenCsvInput=new CsvInput(nodeData,defaultFormatNodeFileHeader(),datas(),defaultFormatRelationshipFileHeader(),IdType.ACTUAL,csvConfigurationWithLowBufferSize(),new BadCollector(NullOutputStream.NULL_OUTPUT_STREAM,0,0));
      importer.doImport(brokenCsvInput);
      fail("Should have failed properly");
    }
 catch (    InputException e) {
      assertTrue(e.getCause() instanceof DataAfterQuoteException);
    }
  }
  private static org.neo4j.unsafe.impl.batchimport.input.csv.Configuration csvConfigurationWithLowBufferSize(){
    return new org.neo4j.unsafe.impl.batchimport.input.csv.Configuration.Overridden(COMMAS){
      @Override public int bufferSize(){
        return BUFFER_SIZE;
      }
    }
;
  }
  private static Supplier<CharReadable> fileAsCharReadable(  File file){
    return () -> {
      try {
        return Readables.files(StandardCharsets.UTF_8,file);
      }
 catch (      IOException e) {
        throw new UncheckedIOException(e);
      }
    }
;
  }
  private File nodeCsvFileWithBrokenEntries() throws IOException {
    File file=directory.file("broken-node-data.csv");
    try (PrintWriter writer=new PrintWriter(fs.openAsWriter(file,StandardCharsets.UTF_8,false))){
      writer.println(":ID,name");
      int numberOfLines=BUFFER_SIZE * 10;
      int brokenLine=random.nextInt(numberOfLines);
      for (int i=0; i < numberOfLines; i++) {
        if (i == brokenLine) {
          writer.println(i + ",\"broken\"line");
        }
 else {
          writer.println(i + ",name" + i);
        }
      }
    }
     return file;
  }
}
