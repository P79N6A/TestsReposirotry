public class CorruptedLogsTruncatorTest {
  private static final int SINGLE_LOG_FILE_SIZE=25;
  private static final int TOTAL_NUMBER_OF_LOG_FILES=12;
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  @Rule public final FileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public final LifeRule life=new LifeRule();
  private File databaseDirectory;
  private LogFiles logFiles;
  private CorruptedLogsTruncator logPruner;
  @Before public void setUp() throws Exception {
    databaseDirectory=testDirectory.databaseDir();
    SimpleLogVersionRepository logVersionRepository=new SimpleLogVersionRepository();
    SimpleTransactionIdStore transactionIdStore=new SimpleTransactionIdStore();
    logFiles=LogFilesBuilder.logFilesBasedOnlyBuilder(databaseDirectory,fileSystemRule).withRotationThreshold(LogHeader.LOG_HEADER_SIZE + 9L).withLogVersionRepository(logVersionRepository).withTransactionIdStore(transactionIdStore).build();
    life.add(logFiles);
    logPruner=new CorruptedLogsTruncator(databaseDirectory,logFiles,fileSystemRule);
  }
  @Test public void doNotPruneEmptyLogs() throws IOException {
    logPruner.truncate(LogPosition.start(0));
    assertTrue(FileUtils.isEmptyDirectory(databaseDirectory));
  }
  @Test public void doNotPruneNonCorruptedLogs() throws IOException {
    life.start();
    generateTransactionLogFiles(logFiles);
    long highestLogVersion=logFiles.getHighestLogVersion();
    long fileSizeBeforePrune=logFiles.getHighestLogFile().length();
    LogPosition endOfLogsPosition=new LogPosition(highestLogVersion,fileSizeBeforePrune);
    assertEquals(TOTAL_NUMBER_OF_LOG_FILES - 1,highestLogVersion);
    logPruner.truncate(endOfLogsPosition);
    assertEquals(TOTAL_NUMBER_OF_LOG_FILES,logFiles.logFiles().length);
    assertEquals(fileSizeBeforePrune,logFiles.getHighestLogFile().length());
    assertTrue(ArrayUtil.isEmpty(databaseDirectory.listFiles(File::isDirectory)));
  }
  @Test public void pruneAndArchiveLastLog() throws IOException {
    life.start();
    generateTransactionLogFiles(logFiles);
    long highestLogVersion=logFiles.getHighestLogVersion();
    File highestLogFile=logFiles.getHighestLogFile();
    long fileSizeBeforePrune=highestLogFile.length();
    int bytesToPrune=5;
    long byteOffset=fileSizeBeforePrune - bytesToPrune;
    LogPosition prunePosition=new LogPosition(highestLogVersion,byteOffset);
    logPruner.truncate(prunePosition);
    assertEquals(TOTAL_NUMBER_OF_LOG_FILES,logFiles.logFiles().length);
    assertEquals(byteOffset,highestLogFile.length());
    File corruptedLogsDirectory=new File(databaseDirectory,CorruptedLogsTruncator.CORRUPTED_TX_LOGS_BASE_NAME);
    assertTrue(corruptedLogsDirectory.exists());
    File[] files=corruptedLogsDirectory.listFiles();
    assertEquals(1,files.length);
    File corruptedLogsArchive=files[0];
    checkArchiveName(highestLogVersion,byteOffset,corruptedLogsArchive);
    try (ZipFile zipFile=new ZipFile(corruptedLogsArchive)){
      assertEquals(1,zipFile.size());
      checkEntryNameAndSize(zipFile,highestLogFile.getName(),bytesToPrune);
    }
   }
  @Test public void pruneAndArchiveMultipleLogs() throws IOException {
    life.start();
    generateTransactionLogFiles(logFiles);
    long highestCorrectLogFileIndex=5;
    File highestCorrectLogFile=logFiles.getLogFileForVersion(highestCorrectLogFileIndex);
    long fileSizeBeforePrune=highestCorrectLogFile.length();
    int bytesToPrune=7;
    long byteOffset=fileSizeBeforePrune - bytesToPrune;
    LogPosition prunePosition=new LogPosition(highestCorrectLogFileIndex,byteOffset);
    life.shutdown();
    logPruner.truncate(prunePosition);
    life.start();
    assertEquals(6,logFiles.logFiles().length);
    assertEquals(byteOffset,highestCorrectLogFile.length());
    File corruptedLogsDirectory=new File(databaseDirectory,CorruptedLogsTruncator.CORRUPTED_TX_LOGS_BASE_NAME);
    assertTrue(corruptedLogsDirectory.exists());
    File[] files=corruptedLogsDirectory.listFiles();
    assertEquals(1,files.length);
    File corruptedLogsArchive=files[0];
    checkArchiveName(highestCorrectLogFileIndex,byteOffset,corruptedLogsArchive);
    try (ZipFile zipFile=new ZipFile(corruptedLogsArchive)){
      assertEquals(7,zipFile.size());
      checkEntryNameAndSize(zipFile,highestCorrectLogFile.getName(),bytesToPrune);
      long nextLogFileIndex=highestCorrectLogFileIndex + 1;
      int lastFileIndex=TOTAL_NUMBER_OF_LOG_FILES - 1;
      for (long index=nextLogFileIndex; index < lastFileIndex; index++) {
        checkEntryNameAndSize(zipFile,TransactionLogFiles.DEFAULT_NAME + "." + index,SINGLE_LOG_FILE_SIZE);
      }
      checkEntryNameAndSize(zipFile,TransactionLogFiles.DEFAULT_NAME + "." + lastFileIndex,SINGLE_LOG_FILE_SIZE - 1);
    }
   }
  private void checkEntryNameAndSize(  ZipFile zipFile,  String entryName,  int expectedSize) throws IOException {
    ZipEntry entry=zipFile.getEntry(entryName);
    InputStream inputStream=zipFile.getInputStream(entry);
    int entryBytes=0;
    while (inputStream.read() >= 0) {
      entryBytes++;
    }
    assertEquals(expectedSize,entryBytes);
  }
  private void checkArchiveName(  long highestLogVersion,  long byteOffset,  File corruptedLogsArchive){
    String name=corruptedLogsArchive.getName();
    assertTrue(name.startsWith("corrupted-neostore.transaction.db-" + highestLogVersion + "-"+ byteOffset));
    assertTrue(FilenameUtils.isExtension(name,"zip"));
  }
  private void generateTransactionLogFiles(  LogFiles logFiles) throws IOException {
    LogFile logFile=logFiles.getLogFile();
    FlushablePositionAwareChannel writer=logFile.getWriter();
    for (byte i=0; i < 107; i++) {
      writer.put(i);
      writer.prepareForFlush();
      if (logFile.rotationNeeded()) {
        logFile.rotate();
      }
    }
  }
}
