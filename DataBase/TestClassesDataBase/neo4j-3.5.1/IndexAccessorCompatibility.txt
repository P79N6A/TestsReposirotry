public abstract class IndexAccessorCompatibility extends IndexProviderCompatibilityTestSuite.Compatibility {
  protected IndexAccessor accessor;
  private Map<Long,Value[]> committedValues=new HashMap<>();
  public IndexAccessorCompatibility(  IndexProviderCompatibilityTestSuite testSuite,  IndexDescriptor descriptor){
    super(testSuite,descriptor);
  }
  @Before public void before() throws Exception {
    IndexSamplingConfig indexSamplingConfig=new IndexSamplingConfig(Config.defaults());
    IndexPopulator populator=indexProvider.getPopulator(descriptor,indexSamplingConfig);
    populator.create();
    populator.close(true);
    accessor=indexProvider.getOnlineAccessor(descriptor,indexSamplingConfig);
  }
  @After public void after(){
    try {
      testSuite.consistencyCheck(accessor);
    }
  finally {
      accessor.drop();
      accessor.close();
    }
  }
  ValueType[] randomSetOfSupportedTypes(){
    ValueType[] supportedTypes=testSuite.supportedValueTypes();
    return random.randomValues().selection(supportedTypes,2,supportedTypes.length,false);
  }
  ValueType[] randomSetOfSupportedAndSortableTypes(){
    ValueType[] types=testSuite.supportedValueTypes();
    types=removeSpatialTypes(types);
    types=RandomValues.excluding(types,ValueType.STRING,ValueType.STRING_ARRAY);
    types=random.randomValues().selection(types,2,types.length,false);
    return types;
  }
  private ValueType[] removeSpatialTypes(  ValueType[] types){
    return Arrays.stream(types).filter(t -> !t.name().contains("POINT")).toArray(ValueType[]::new);
  }
  protected List<Long> query(  IndexQuery... predicates) throws Exception {
    try (IndexReader reader=accessor.newReader()){
      SimpleNodeValueClient nodeValueClient=new SimpleNodeValueClient();
      reader.query(nodeValueClient,IndexOrder.NONE,false,predicates);
      List<Long> list=new LinkedList<>();
      while (nodeValueClient.next()) {
        long entityId=nodeValueClient.reference;
        if (passesFilter(entityId,predicates)) {
          list.add(entityId);
        }
      }
      Collections.sort(list);
      return list;
    }
   }
  protected AutoCloseable query(  SimpleNodeValueClient client,  IndexOrder order,  IndexQuery... predicates) throws Exception {
    IndexReader reader=accessor.newReader();
    reader.query(client,order,false,predicates);
    return reader;
  }
  List<Long> assertInOrder(  IndexOrder order,  IndexQuery... predicates) throws Exception {
    List<Long> actualIds;
    if (order == IndexOrder.NONE) {
      actualIds=query(predicates);
    }
 else {
      SimpleNodeValueClient client=new SimpleNodeValueClient();
      try (AutoCloseable ignore=query(client,order,predicates)){
        actualIds=assertClientReturnValuesInOrder(client,order);
      }
     }
    return actualIds;
  }
  List<Long> assertClientReturnValuesInOrder(  SimpleNodeValueClient client,  IndexOrder order){
    List<Long> seenIds=new ArrayList<>();
    Value[] prevValues=null;
    Value[] values;
    int count=0;
    while (client.next()) {
      count++;
      seenIds.add(client.reference);
      values=client.values;
      if (order == IndexOrder.ASCENDING) {
        assertLessThanOrEqualTo(prevValues,values);
      }
 else       if (order == IndexOrder.DESCENDING) {
        assertLessThanOrEqualTo(values,prevValues);
      }
 else {
        Assert.fail("Unexpected order " + order);
      }
      prevValues=values;
    }
    return seenIds;
  }
  IndexOrder[] orderCapability(  IndexQuery... predicates){
    ValueCategory[] categories=new ValueCategory[predicates.length];
    for (int i=0; i < predicates.length; i++) {
      categories[i]=predicates[i].valueGroup().category();
    }
    return indexProvider.getCapability(descriptor).orderCapability(categories);
  }
  private void assertLessThanOrEqualTo(  Value[] o1,  Value[] o2){
    if (o1 == null || o2 == null) {
      return;
    }
    int length=Math.min(o1.length,o2.length);
    for (int i=0; i < length; i++) {
      int compare=Values.COMPARATOR.compare(o1[i],o2[i]);
      assertThat("expected less than or equal to but was " + Arrays.toString(o1) + " and "+ Arrays.toString(o2),compare,lessThanOrEqualTo(0));
      if (compare != 0) {
        return;
      }
    }
  }
  /** 
 * Run the Value[] from a particular entityId through the list of IndexQuery[] predicates to see if they all accept the value.
 */
  private boolean passesFilter(  long entityId,  IndexQuery[] predicates){
    if (predicates.length == 1 && predicates[0] instanceof IndexQuery.ExistsPredicate) {
      return true;
    }
    Value[] values=committedValues.get(entityId);
    for (int i=0; i < values.length; i++) {
      IndexQuery predicate=predicates[i];
      if (predicate.valueGroup() == ValueGroup.GEOMETRY || predicate.valueGroup() == ValueGroup.GEOMETRY_ARRAY || (predicate.valueGroup() == ValueGroup.NUMBER && !testSuite.supportFullValuePrecisionForNumbers())) {
        if (!predicates[i].acceptsValue(values[i])) {
          return false;
        }
      }
    }
    return true;
  }
  /** 
 * Commit these updates to the index. Also store the values, which currently are stored for all types except geometry, so therefore it's done explicitly here so that we can filter on them later.
 */
  void updateAndCommit(  Collection<IndexEntryUpdate<?>> updates) throws IndexEntryConflictException {
    try (IndexUpdater updater=accessor.newUpdater(IndexUpdateMode.ONLINE)){
      for (      IndexEntryUpdate<?> update : updates) {
        updater.process(update);
switch (update.updateMode()) {
case ADDED:
case CHANGED:
          committedValues.put(update.getEntityId(),update.values());
        break;
case REMOVED:
      committedValues.remove(update.getEntityId());
    break;
default :
  throw new IllegalArgumentException("Unknown update mode of " + update);
}
}
}
 }
}
