public class LargeDynamicKeysIT {
  @Rule public final PageCacheAndDependenciesRule storage=new PageCacheAndDependenciesRule().with(new DefaultFileSystemRule());
  @Rule public final RandomRule random=new RandomRule();
  @Test public void mustStayCorrectWhenInsertingValuesOfIncreasingLength() throws IOException {
    Layout<RawBytes,RawBytes> layout=layout();
    try (GBPTree<RawBytes,RawBytes> index=createIndex(layout);Writer<RawBytes,RawBytes> writer=index.writer()){
      RawBytes emptyValue=layout.newValue();
      emptyValue.bytes=new byte[0];
      for (int keySize=1; keySize < index.keyValueSizeCap(); keySize++) {
        RawBytes key=layout.newKey();
        key.bytes=new byte[keySize];
        writer.put(key,emptyValue);
      }
    }
   }
  @Test public void shouldWriteAndReadSmallToSemiLargeEntries() throws IOException {
    int keyValueSizeCap=keyValueSizeCapFromPageSize(PAGE_SIZE);
    int minValueSize=0;
    int maxValueSize=random.nextInt(200);
    int minKeySize=4;
    int maxKeySize=keyValueSizeCap / 5;
    shouldWriteAndReadEntriesOfRandomSizes(minKeySize,maxKeySize,minValueSize,maxValueSize);
  }
  @Test public void shouldWriteAndReadSmallToLargeEntries() throws IOException {
    int keyValueSizeCap=keyValueSizeCapFromPageSize(PAGE_SIZE);
    int minValueSize=0;
    int maxValueSize=random.nextInt(200);
    int minKeySize=4;
    int maxKeySize=keyValueSizeCap - maxValueSize;
    shouldWriteAndReadEntriesOfRandomSizes(minKeySize,maxKeySize,minValueSize,maxValueSize);
  }
  @Test public void shouldWriteAndReadSemiLargeToLargeEntries() throws IOException {
    int keyValueSizeCap=keyValueSizeCapFromPageSize(PAGE_SIZE);
    int minValueSize=0;
    int maxValueSize=random.nextInt(200);
    int minKeySize=keyValueSizeCap / 5;
    int maxKeySize=keyValueSizeCap - maxValueSize;
    shouldWriteAndReadEntriesOfRandomSizes(minKeySize,maxKeySize,minValueSize,maxValueSize);
  }
  private void shouldWriteAndReadEntriesOfRandomSizes(  int minKeySize,  int maxKeySize,  int minValueSize,  int maxValueSize) throws IOException {
    try (GBPTree<RawBytes,RawBytes> tree=createIndex(layout())){
      Set<String> generatedStrings=new HashSet<>();
      List<Pair<RawBytes,RawBytes>> entries=new ArrayList<>();
      try (Writer<RawBytes,RawBytes> writer=tree.writer()){
        for (int i=0; i < 1_000; i++) {
          RawBytes value=new RawBytes();
          value.bytes=new byte[random.nextInt(minValueSize,maxValueSize)];
          random.nextBytes(value.bytes);
          String string;
          do {
            string=random.nextAlphaNumericString(minKeySize,maxKeySize);
          }
 while (!generatedStrings.add(string));
          RawBytes key=new RawBytes();
          key.bytes=UTF8.encode(string);
          entries.add(Pair.of(key,value));
          writer.put(key,value);
        }
      }
       for (      Pair<RawBytes,RawBytes> entry : entries) {
        try (RawCursor<Hit<RawBytes,RawBytes>,IOException> seek=tree.seek(entry.first(),entry.first())){
          assertTrue(seek.next());
          assertArrayEquals(entry.first().bytes,seek.get().key().bytes);
          assertArrayEquals(entry.other().bytes,seek.get().value().bytes);
          assertFalse(seek.next());
        }
       }
    }
   }
  private SimpleByteArrayLayout layout(){
    return new SimpleByteArrayLayout(false);
  }
  private GBPTree<RawBytes,RawBytes> createIndex(  Layout<RawBytes,RawBytes> layout) throws IOException {
    PageCache pageCache=storage.pageCacheRule().getPageCache(storage.fileSystem(),config().withAccessChecks(true));
    return new GBPTreeBuilder<>(pageCache,storage.directory().file("index"),layout).build();
  }
}
