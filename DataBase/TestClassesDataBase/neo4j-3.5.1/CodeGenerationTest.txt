@RunWith(Parameterized.class) public class CodeGenerationTest {
  private static final MethodReference RUN=createMethod(Runnable.class,void.class,"run");
  @Parameterized.Parameters(name="{0}") public static Collection<Object[]> generators(){
    return Arrays.asList(new Object[]{SourceCode.SOURCECODE},new Object[]{ByteCode.BYTECODE});
  }
  @Parameterized.Parameter() public CodeGenerationStrategy<?> strategy;
  @Before public void createGenerator(){
    try {
      generator=CodeGenerator.generateCode(strategy);
    }
 catch (    CodeGenerationNotSupportedException e) {
      throw new AssertionError("Cannot compile code.",e);
    }
  }
  @Test public void shouldGenerateClass() throws Exception {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      handle=simple.handle();
    }
     Class<?> aClass=handle.loadClass();
    assertNotNull("null class loaded",aClass);
    assertNotNull("null package of: " + aClass.getName(),aClass.getPackage());
    assertEquals(PACKAGE,aClass.getPackage().getName());
    assertEquals("SimpleClass",aClass.getSimpleName());
  }
  @Test public void shouldGenerateTwoClassesInTheSamePackage() throws Exception {
    ClassHandle one;
    ClassHandle two;
    try (ClassGenerator simple=generateClass("One")){
      one=simple.handle();
    }
     try (ClassGenerator simple=generateClass("Two")){
      two=simple.handle();
    }
     Class<?> classOne=one.loadClass();
    Class<?> classTwo=two.loadClass();
    assertNotNull(classOne.getPackage());
    assertSame(classOne.getPackage(),classTwo.getPackage());
    assertEquals("One",classOne.getSimpleName());
    assertEquals("Two",classTwo.getSimpleName());
  }
  @Test public void shouldGenerateDefaultConstructor() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass(NamedBase.class,"SimpleClass")){
      handle=simple.handle();
    }
     Object instance=constructor(handle.loadClass()).invoke();
    Object constructorCalled=instanceMethod(instance,"defaultConstructorCalled").invoke();
    assertTrue((Boolean)constructorCalled);
  }
  @Test public void shouldGenerateField() throws Exception {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      simple.field(String.class,"theField");
      handle=simple.handle();
    }
     Class<?> clazz=handle.loadClass();
    Field theField=clazz.getDeclaredField("theField");
    assertSame(String.class,theField.getType());
  }
  @Test public void shouldGenerateParameterizedTypeField() throws Exception {
    ClassHandle handle;
    TypeReference stringList=TypeReference.parameterizedType(List.class,String.class);
    try (ClassGenerator simple=generateClass("SimpleClass")){
      simple.field(stringList,"theField");
      handle=simple.handle();
    }
     Class<?> clazz=handle.loadClass();
    Field theField=clazz.getDeclaredField("theField");
    assertSame(List.class,theField.getType());
  }
  @Test public void shouldGenerateMethodReturningFieldValue() throws Throwable {
    assertMethodReturningField(byte.class,(byte)42);
    assertMethodReturningField(short.class,(short)42);
    assertMethodReturningField(char.class,(char)42);
    assertMethodReturningField(int.class,42);
    assertMethodReturningField(long.class,42L);
    assertMethodReturningField(float.class,42F);
    assertMethodReturningField(double.class,42D);
    assertMethodReturningField(String.class,"42");
    assertMethodReturningField(int[].class,new int[]{42});
    assertMethodReturningField(Map.Entry[].class,Collections.singletonMap(42,"42").entrySet().toArray(new Map.Entry[0]));
  }
  @Test public void shouldGenerateMethodReturningArrayValue() throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      simple.generate(MethodTemplate.method(int[].class,"value").returns(newArray(typeReference(int.class),constant(1),constant(2),constant(3))).build());
      handle=simple.handle();
    }
     Object instance=constructor(handle.loadClass()).invoke();
    assertArrayEquals(new int[]{1,2,3},(int[])instanceMethod(instance,"value").invoke());
  }
  @Test public void shouldGenerateMethodReturningParameterizedTypeValue() throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      TypeReference stringList=parameterizedType(List.class,String.class);
      simple.generate(MethodTemplate.method(stringList,"value").returns(Expression.invoke(methodReference(Arrays.class,stringList,"asList",Object[].class),newArray(typeReference(String.class),constant("a"),constant("b")))).build());
      handle=simple.handle();
    }
     Object instance=constructor(handle.loadClass()).invoke();
    assertEquals(Arrays.asList("a","b"),instanceMethod(instance,"value").invoke());
  }
  @Test public void shouldGenerateStaticPrimitiveField() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      FieldReference foo=simple.staticField(int.class,"FOO",constant(42));
      try (CodeBlock get=simple.generateMethod(int.class,"get")){
        get.returns(Expression.getStatic(foo));
      }
       handle=simple.handle();
    }
     Object foo=instanceMethod(handle.newInstance(),"get").invoke();
    assertEquals(42,foo);
  }
  @Test public void shouldGenerateStaticReferenceTypeField() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      FieldReference foo=simple.staticField(String.class,"FOO",constant("42"));
      try (CodeBlock get=simple.generateMethod(String.class,"get")){
        get.returns(Expression.getStatic(foo));
      }
       handle=simple.handle();
    }
     Object foo=instanceMethod(handle.newInstance(),"get").invoke();
    assertEquals("42",foo);
  }
  @Test public void shouldGenerateStaticParameterizedTypeField() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      TypeReference stringList=TypeReference.parameterizedType(List.class,String.class);
      FieldReference foo=simple.staticField(stringList,"FOO",Expression.invoke(methodReference(Arrays.class,stringList,"asList",Object[].class),newArray(typeReference(String.class),constant("FOO"),constant("BAR"),constant("BAZ"))));
      try (CodeBlock get=simple.generateMethod(stringList,"get")){
        get.returns(Expression.getStatic(foo));
      }
       handle=simple.handle();
    }
     Object foo=instanceMethod(handle.newInstance(),"get").invoke();
    assertEquals(Arrays.asList("FOO","BAR","BAZ"),foo);
  }
public interface Thrower<E extends Exception> {
    void doThrow() throws E ;
  }
  @Test public void shouldThrowParameterizedCheckedException() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock fail=simple.generate(MethodDeclaration.method(void.class,"fail",param(TypeReference.parameterizedType(Thrower.class,typeParameter("E")),"thrower")).parameterizedWith("E",extending(Exception.class)).throwsException(typeParameter("E")))){
        fail.expression(invoke(fail.load("thrower"),methodReference(Thrower.class,void.class,"doThrow")));
      }
       handle=simple.handle();
    }
     try {
      instanceMethod(handle.newInstance(),"fail",Thrower.class).invoke((Thrower<IOException>)() -> {
        throw new IOException("Hello from the inside");
      }
);
      fail("expected exception");
    }
 catch (    IOException e) {
      assertEquals("Hello from the inside",e.getMessage());
    }
  }
  @Test public void shouldAssignLocalVariable() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock create=simple.generateMethod(SomeBean.class,"createBean",param(String.class,"foo"),param(String.class,"bar"))){
        create.assign(SomeBean.class,"bean",invoke(newInstance(SomeBean.class),constructorReference(SomeBean.class)));
        create.expression(invoke(create.load("bean"),methodReference(SomeBean.class,void.class,"setFoo",String.class),create.load("foo")));
        create.expression(invoke(create.load("bean"),methodReference(SomeBean.class,void.class,"setBar",String.class),create.load("bar")));
        create.returns(create.load("bean"));
      }
       handle=simple.handle();
    }
     MethodHandle method=instanceMethod(handle.newInstance(),"createBean",String.class,String.class);
    SomeBean bean=(SomeBean)method.invoke("hello","world");
    assertEquals("hello",bean.foo);
    assertEquals("world",bean.bar);
  }
  @Test public void shouldDeclareAndAssignLocalVariable() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock create=simple.generateMethod(SomeBean.class,"createBean",param(String.class,"foo"),param(String.class,"bar"))){
        LocalVariable localVariable=create.declare(typeReference(SomeBean.class),"bean");
        create.assign(localVariable,invoke(newInstance(SomeBean.class),constructorReference(SomeBean.class)));
        create.expression(invoke(create.load("bean"),methodReference(SomeBean.class,void.class,"setFoo",String.class),create.load("foo")));
        create.expression(invoke(create.load("bean"),methodReference(SomeBean.class,void.class,"setBar",String.class),create.load("bar")));
        create.returns(create.load("bean"));
      }
       handle=simple.handle();
    }
     MethodHandle method=instanceMethod(handle.newInstance(),"createBean",String.class,String.class);
    SomeBean bean=(SomeBean)method.invoke("hello","world");
    assertEquals("hello",bean.foo);
    assertEquals("world",bean.bar);
  }
  @Test public void shouldGenerateWhileLoop() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterator.class,Runnable.class),"targets"))){
        try (CodeBlock loop=callEach.whileLoop(invoke(callEach.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
          loop.expression(invoke(Expression.cast(Runnable.class,invoke(callEach.load("targets"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Runnable.class,void.class,"run")));
        }
       }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterator.class);
    callEach.invoke(Arrays.asList(a,b,c).iterator());
    InOrder order=inOrder(a,b,c);
    order.verify(a).run();
    order.verify(b).run();
    order.verify(c).run();
    verifyNoMoreInteractions(a,b,c);
  }
  @Test public void shouldGenerateWhileLoopWithMultipleTestExpressions() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"check",param(boolean.class,"a"),param(boolean.class,"b"),param(Runnable.class,"runner"))){
        try (CodeBlock loop=callEach.whileLoop(and(callEach.load("a"),callEach.load("b")))){
          loop.expression(invoke(loop.load("runner"),methodReference(Runnable.class,void.class,"run")));
          loop.returns();
        }
       }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    Runnable d=mock(Runnable.class);
    MethodHandle callEach=instanceMethod(handle.newInstance(),"check",boolean.class,boolean.class,Runnable.class);
    callEach.invoke(true,true,a);
    callEach.invoke(true,false,b);
    callEach.invoke(false,true,c);
    callEach.invoke(false,false,d);
    verify(a).run();
    verifyNoMoreInteractions(a);
    verifyZeroInteractions(b);
    verifyZeroInteractions(c);
    verifyZeroInteractions(d);
  }
  @Test public void shouldGenerateNestedWhileLoop() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterator.class,Runnable.class),"targets"))){
        try (CodeBlock loop=callEach.whileLoop(invoke(callEach.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
          try (CodeBlock inner=loop.whileLoop(invoke(callEach.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
            inner.expression(invoke(Expression.cast(Runnable.class,invoke(callEach.load("targets"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Runnable.class,void.class,"run")));
          }
         }
       }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterator.class);
    callEach.invoke(Arrays.asList(a,b,c).iterator());
    InOrder order=inOrder(a,b,c);
    order.verify(a).run();
    order.verify(b).run();
    order.verify(c).run();
    verifyNoMoreInteractions(a,b,c);
  }
  @Test public void shouldGenerateWhileLoopContinue() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterator.class,Runnable.class),"targets"),param(TypeReference.parameterizedType(Iterator.class,Boolean.class),"skipTargets"))){
        try (CodeBlock loop=callEach.whileLoop(invoke(callEach.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
          loop.declare(TypeReference.typeReference(Runnable.class),"target");
          loop.assign(loop.local("target"),Expression.cast(Runnable.class,invoke(callEach.load("targets"),methodReference(Iterator.class,Object.class,"next"))));
          loop.declare(TypeReference.BOOLEAN,"skip");
          loop.assign(loop.local("skip"),invoke(Expression.cast(Boolean.class,invoke(callEach.load("skipTargets"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Boolean.class,boolean.class,"booleanValue")));
          try (CodeBlock ifBlock=loop.ifStatement(loop.load("skip"))){
            ifBlock.continueIfPossible();
          }
           loop.expression(invoke(loop.load("target"),methodReference(Runnable.class,void.class,"run")));
        }
       }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterator.class,Iterator.class);
    callEach.invoke(Arrays.asList(a,b,c).iterator(),Arrays.asList(false,true,false).iterator());
    InOrder order=inOrder(a,b,c);
    order.verify(a).run();
    order.verify(c).run();
    verifyNoMoreInteractions(a,b,c);
  }
  @Test public void shouldGenerateNestedWhileLoopInnerContinue() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterator.class,Runnable.class),"targetTargets"),param(TypeReference.parameterizedType(Iterator.class,Boolean.class),"skipTargets"))){
        try (CodeBlock outer=callEach.whileLoop(invoke(callEach.load("targetTargets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
          outer.declare(TypeReference.typeReference(Iterator.class),"targets");
          outer.assign(outer.local("targets"),Expression.cast(Iterator.class,invoke(callEach.load("targetTargets"),methodReference(Iterator.class,Object.class,"next"))));
          try (CodeBlock inner=outer.whileLoop(invoke(outer.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
            inner.declare(TypeReference.typeReference(Runnable.class),"target");
            inner.assign(inner.local("target"),Expression.cast(Runnable.class,invoke(outer.load("targets"),methodReference(Iterator.class,Object.class,"next"))));
            inner.declare(TypeReference.BOOLEAN,"skip");
            inner.assign(inner.local("skip"),invoke(Expression.cast(Boolean.class,invoke(callEach.load("skipTargets"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Boolean.class,boolean.class,"booleanValue")));
            try (CodeBlock ifBlock=inner.ifStatement(inner.load("skip"))){
              ifBlock.continueIfPossible();
            }
             inner.expression(invoke(inner.load("target"),methodReference(Runnable.class,void.class,"run")));
          }
         }
       }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    Runnable d=mock(Runnable.class);
    Runnable e=mock(Runnable.class);
    Runnable f=mock(Runnable.class);
    Iterator<Iterator<Runnable>> input=Arrays.asList(Arrays.asList(a,b).iterator(),Arrays.asList(c,d).iterator(),Arrays.asList(e,f).iterator()).iterator();
    Iterator<Boolean> skips=Arrays.asList(false,true,true,false,false,true).iterator();
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterator.class,Iterator.class);
    callEach.invoke(input,skips);
    InOrder order=inOrder(a,b,c,d,e,f);
    order.verify(a).run();
    order.verify(d).run();
    order.verify(e).run();
    verifyNoMoreInteractions(a,b,c,d,e,f);
  }
  @Test public void shouldGenerateNestedWhileLoopDoubleContinue() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterator.class,Runnable.class),"targetTargets"),param(TypeReference.parameterizedType(Iterator.class,Boolean.class),"skipOuters"),param(TypeReference.parameterizedType(Iterator.class,Boolean.class),"skipInners"))){
        try (CodeBlock outer=callEach.whileLoop(invoke(callEach.load("targetTargets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
          outer.declare(TypeReference.typeReference(Iterator.class),"targets");
          outer.assign(outer.local("targets"),Expression.cast(Iterator.class,invoke(callEach.load("targetTargets"),methodReference(Iterator.class,Object.class,"next"))));
          outer.declare(TypeReference.BOOLEAN,"skipOuter");
          outer.assign(outer.local("skipOuter"),invoke(Expression.cast(Boolean.class,invoke(callEach.load("skipOuters"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Boolean.class,boolean.class,"booleanValue")));
          try (CodeBlock ifBlock=outer.ifStatement(outer.load("skipOuter"))){
            ifBlock.continueIfPossible();
          }
           try (CodeBlock inner=outer.whileLoop(invoke(outer.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
            inner.declare(TypeReference.typeReference(Runnable.class),"target");
            inner.assign(inner.local("target"),Expression.cast(Runnable.class,invoke(outer.load("targets"),methodReference(Iterator.class,Object.class,"next"))));
            inner.declare(TypeReference.BOOLEAN,"skipInner");
            inner.assign(inner.local("skipInner"),invoke(Expression.cast(Boolean.class,invoke(callEach.load("skipInners"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Boolean.class,boolean.class,"booleanValue")));
            try (CodeBlock ifBlock=inner.ifStatement(inner.load("skipInner"))){
              ifBlock.continueIfPossible();
            }
             inner.expression(invoke(inner.load("target"),methodReference(Runnable.class,void.class,"run")));
          }
         }
       }
       handle=simple.handle();
    }
     Runnable a1=mock(Runnable.class);
    Runnable a2=mock(Runnable.class);
    Runnable b1=mock(Runnable.class);
    Runnable b2=mock(Runnable.class);
    Runnable b3=mock(Runnable.class);
    Runnable b4=mock(Runnable.class);
    Runnable c1=mock(Runnable.class);
    Iterator<Iterator<Runnable>> input=Arrays.asList(Arrays.asList(a1,a2).iterator(),Arrays.asList(b1,b2,b3,b4).iterator(),Arrays.asList(c1).iterator()).iterator();
    Iterator<Boolean> skipOuter=Arrays.asList(true,false,true).iterator();
    Iterator<Boolean> skipInner=Arrays.asList(false,true,false,true).iterator();
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterator.class,Iterator.class,Iterator.class);
    callEach.invoke(input,skipOuter,skipInner);
    InOrder order=inOrder(a1,a2,b1,b2,b3,b4,c1);
    order.verify(b1).run();
    order.verify(b3).run();
    verifyNoMoreInteractions(a1,a2,b1,b2,b3,b4,c1);
  }
  @Test public void shouldGenerateForEachLoop() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterable.class,Runnable.class),"targets"))){
        try (CodeBlock loop=callEach.forEach(param(Runnable.class,"runner"),callEach.load("targets"))){
          loop.expression(invoke(loop.load("runner"),methodReference(Runnable.class,void.class,"run")));
        }
       }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterable.class);
    callEach.invoke(Arrays.asList(a,b,c));
    InOrder order=inOrder(a,b,c);
    order.verify(a).run();
    order.verify(b).run();
    order.verify(c).run();
    verifyNoMoreInteractions(a,b,c);
  }
  @Test public void shouldGenerateIfStatement() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(boolean.class,"test"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(conditional.load("test"))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,Runnable.class);
    conditional.invoke(true,runner1);
    conditional.invoke(false,runner2);
    verify(runner1).run();
    verifyZeroInteractions(runner2);
  }
  @Test public void shouldGenerateIfEqualsStatement() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(Object.class,"lhs"),param(Object.class,"rhs"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(equal(conditional.load("lhs"),conditional.load("rhs")))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    Object a="a";
    Object b="b";
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",Object.class,Object.class,Runnable.class);
    conditional.invoke(a,b,runner1);
    conditional.invoke(a,a,runner2);
    verify(runner2).run();
    verifyZeroInteractions(runner1);
  }
  @Test public void shouldGenerateIfNotEqualsStatement() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(Object.class,"lhs"),param(Object.class,"rhs"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(not(equal(conditional.load("lhs"),conditional.load("rhs"))))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    Object a="a";
    Object b="b";
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",Object.class,Object.class,Runnable.class);
    conditional.invoke(a,a,runner1);
    conditional.invoke(a,b,runner2);
    verify(runner2).run();
    verifyZeroInteractions(runner1);
  }
  @Test public void shouldGenerateIfNotExpressionStatement() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(boolean.class,"test"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(not(conditional.load("test")))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,Runnable.class);
    conditional.invoke(true,runner1);
    conditional.invoke(false,runner2);
    verify(runner2).run();
    verifyZeroInteractions(runner1);
  }
  @Test public void shouldGenerateIfNullStatement() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(Object.class,"test"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(isNull(conditional.load("test")))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",Object.class,Runnable.class);
    conditional.invoke(null,runner1);
    conditional.invoke(new Object(),runner2);
    verify(runner1).run();
    verifyZeroInteractions(runner2);
  }
  @Test public void shouldGenerateIfNonNullStatement() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(Object.class,"test"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(notNull(conditional.load("test")))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",Object.class,Runnable.class);
    conditional.invoke(new Object(),runner1);
    conditional.invoke(null,runner2);
    verify(runner1).run();
    verifyZeroInteractions(runner2);
  }
  @Test public void shouldGenerateTryWithNestedWhileIfLoop() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterator.class,Runnable.class),"targets"),param(boolean.class,"test"),param(Runnable.class,"runner"))){
        callEach.tryCatch(tryBlock -> {
          try (CodeBlock loop=tryBlock.whileLoop(invoke(callEach.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
            try (CodeBlock doStuff=loop.ifStatement(not(callEach.load("test")))){
              doStuff.expression(invoke(doStuff.load("runner"),RUN));
            }
             loop.expression(invoke(Expression.cast(Runnable.class,invoke(callEach.load("targets"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Runnable.class,void.class,"run")));
          }
         }
,catchBlock -> catchBlock.expression(invoke(catchBlock.load("runner"),RUN)),param(RuntimeException.class,"e"));
      }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterator.class,boolean.class,Runnable.class);
    callEach.invoke(Arrays.asList(a,b,c).iterator(),false,runner1);
    callEach.invoke(Arrays.asList(a,b,c).iterator(),true,runner2);
    verify(runner1,times(3)).run();
    verify(runner2,never()).run();
  }
  @Test public void shouldGenerateWhileWithNestedIfLoop() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock callEach=simple.generateMethod(void.class,"callEach",param(TypeReference.parameterizedType(Iterator.class,Runnable.class),"targets"),param(boolean.class,"test"),param(Runnable.class,"runner"))){
        try (CodeBlock loop=callEach.whileLoop(invoke(callEach.load("targets"),methodReference(Iterator.class,boolean.class,"hasNext")))){
          try (CodeBlock doStuff=loop.ifStatement(not(callEach.load("test")))){
            doStuff.expression(invoke(doStuff.load("runner"),RUN));
          }
           loop.expression(invoke(Expression.cast(Runnable.class,invoke(callEach.load("targets"),methodReference(Iterator.class,Object.class,"next"))),methodReference(Runnable.class,void.class,"run")));
        }
       }
       handle=simple.handle();
    }
     Runnable a=mock(Runnable.class);
    Runnable b=mock(Runnable.class);
    Runnable c=mock(Runnable.class);
    Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    MethodHandle callEach=instanceMethod(handle.newInstance(),"callEach",Iterator.class,boolean.class,Runnable.class);
    callEach.invoke(Arrays.asList(a,b,c).iterator(),false,runner1);
    callEach.invoke(Arrays.asList(a,b,c).iterator(),true,runner2);
    verify(runner1,times(3)).run();
    verify(runner2,never()).run();
  }
  @Test public void shouldGenerateOr() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(Expression.or(conditional.load("test1"),conditional.load("test2")))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    Runnable runner3=mock(Runnable.class);
    Runnable runner4=mock(Runnable.class);
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class,Runnable.class);
    conditional.invoke(true,true,runner1);
    conditional.invoke(true,false,runner2);
    conditional.invoke(false,true,runner3);
    conditional.invoke(false,false,runner4);
    verify(runner1).run();
    verify(runner2).run();
    verify(runner3).run();
    verifyZeroInteractions(runner4);
  }
  @Test public void shouldGenerateMethodUsingOr() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"))){
        conditional.returns(or(conditional.load("test1"),conditional.load("test2")));
      }
       handle=simple.handle();
    }
     MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class);
    assertThat(conditional.invoke(true,true),equalTo(true));
    assertThat(conditional.invoke(true,false),equalTo(true));
    assertThat(conditional.invoke(false,true),equalTo(true));
    assertThat(conditional.invoke(false,false),equalTo(false));
  }
  @Test public void shouldGenerateAnd() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(void.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"),param(Runnable.class,"runner"))){
        try (CodeBlock doStuff=conditional.ifStatement(and(conditional.load("test1"),conditional.load("test2")))){
          doStuff.expression(invoke(doStuff.load("runner"),RUN));
        }
       }
       handle=simple.handle();
    }
     Runnable runner1=mock(Runnable.class);
    Runnable runner2=mock(Runnable.class);
    Runnable runner3=mock(Runnable.class);
    Runnable runner4=mock(Runnable.class);
    MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class,Runnable.class);
    conditional.invoke(true,true,runner1);
    conditional.invoke(true,false,runner2);
    conditional.invoke(false,true,runner3);
    conditional.invoke(false,false,runner4);
    verify(runner1).run();
    verifyZeroInteractions(runner2);
    verifyZeroInteractions(runner3);
    verifyZeroInteractions(runner4);
  }
  @Test public void shouldGenerateMethodUsingAnd() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"))){
        conditional.returns(and(conditional.load("test1"),conditional.load("test2")));
      }
       handle=simple.handle();
    }
     MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class);
    assertThat(conditional.invoke(true,true),equalTo(true));
    assertThat(conditional.invoke(true,false),equalTo(false));
    assertThat(conditional.invoke(false,true),equalTo(false));
    assertThat(conditional.invoke(false,false),equalTo(false));
  }
  @Test public void shouldGenerateMethodUsingMultipleAnds() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"),param(boolean.class,"test3"))){
        conditional.returns(and(conditional.load("test1"),and(conditional.load("test2"),conditional.load("test3"))));
      }
       handle=simple.handle();
    }
     MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class,boolean.class);
    assertThat(conditional.invoke(true,true,true),equalTo(true));
    assertThat(conditional.invoke(true,false,true),equalTo(false));
    assertThat(conditional.invoke(false,true,true),equalTo(false));
    assertThat(conditional.invoke(false,false,true),equalTo(false));
    assertThat(conditional.invoke(true,true,false),equalTo(false));
    assertThat(conditional.invoke(true,false,false),equalTo(false));
    assertThat(conditional.invoke(false,true,false),equalTo(false));
    assertThat(conditional.invoke(false,false,false),equalTo(false));
  }
  @Test public void shouldGenerateMethodUsingMultipleAnds2() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"),param(boolean.class,"test3"))){
        conditional.returns(and(and(conditional.load("test1"),conditional.load("test2")),conditional.load("test3")));
      }
       handle=simple.handle();
    }
     MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class,boolean.class);
    assertThat(conditional.invoke(true,true,true),equalTo(true));
    assertThat(conditional.invoke(true,false,true),equalTo(false));
    assertThat(conditional.invoke(false,true,true),equalTo(false));
    assertThat(conditional.invoke(false,false,true),equalTo(false));
    assertThat(conditional.invoke(true,true,false),equalTo(false));
    assertThat(conditional.invoke(true,false,false),equalTo(false));
    assertThat(conditional.invoke(false,true,false),equalTo(false));
    assertThat(conditional.invoke(false,false,false),equalTo(false));
  }
  @Test public void shouldGenerateMethodUsingMultipleOrs() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"),param(boolean.class,"test3"))){
        conditional.returns(or(conditional.load("test1"),or(conditional.load("test2"),conditional.load("test3"))));
      }
       handle=simple.handle();
    }
     MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class,boolean.class);
    assertThat(conditional.invoke(true,true,true),equalTo(true));
    assertThat(conditional.invoke(true,false,true),equalTo(true));
    assertThat(conditional.invoke(false,true,true),equalTo(true));
    assertThat(conditional.invoke(false,false,true),equalTo(true));
    assertThat(conditional.invoke(true,true,false),equalTo(true));
    assertThat(conditional.invoke(true,false,false),equalTo(true));
    assertThat(conditional.invoke(false,true,false),equalTo(true));
    assertThat(conditional.invoke(false,false,false),equalTo(false));
  }
  @Test public void shouldGenerateMethodUsingMultipleOrs2() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"conditional",param(boolean.class,"test1"),param(boolean.class,"test2"),param(boolean.class,"test3"))){
        conditional.returns(or(or(conditional.load("test1"),conditional.load("test2")),conditional.load("test3")));
      }
       handle=simple.handle();
    }
     MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class,boolean.class,boolean.class);
    assertThat(conditional.invoke(true,true,true),equalTo(true));
    assertThat(conditional.invoke(true,false,true),equalTo(true));
    assertThat(conditional.invoke(false,true,true),equalTo(true));
    assertThat(conditional.invoke(false,false,true),equalTo(true));
    assertThat(conditional.invoke(true,true,false),equalTo(true));
    assertThat(conditional.invoke(true,false,false),equalTo(true));
    assertThat(conditional.invoke(false,true,false),equalTo(true));
    assertThat(conditional.invoke(false,false,false),equalTo(false));
  }
  @Test public void shouldHandleNot() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"conditional",param(boolean.class,"test"))){
        conditional.returns(not(conditional.load("test")));
      }
       handle=simple.handle();
    }
     MethodHandle conditional=instanceMethod(handle.newInstance(),"conditional",boolean.class);
    assertThat(conditional.invoke(true),equalTo(false));
    assertThat(conditional.invoke(false),equalTo(true));
  }
  @Test public void shouldHandleTernaryOperator() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock ternaryBlock=simple.generateMethod(String.class,"ternary",param(boolean.class,"test"),param(TernaryChecker.class,"check"))){
        ternaryBlock.returns(ternary(ternaryBlock.load("test"),invoke(ternaryBlock.load("check"),methodReference(TernaryChecker.class,String.class,"onTrue")),invoke(ternaryBlock.load("check"),methodReference(TernaryChecker.class,String.class,"onFalse"))));
      }
       handle=simple.handle();
    }
     MethodHandle ternary=instanceMethod(handle.newInstance(),"ternary",boolean.class,TernaryChecker.class);
    TernaryChecker checker1=new TernaryChecker();
    assertThat(ternary.invoke(true,checker1),equalTo("on true"));
    assertTrue(checker1.ranOnTrue);
    assertFalse(checker1.ranOnFalse);
    TernaryChecker checker2=new TernaryChecker();
    assertThat(ternary.invoke(false,checker2),equalTo("on false"));
    assertFalse(checker2.ranOnTrue);
    assertTrue(checker2.ranOnFalse);
  }
  @Test public void shouldHandleTernaryOnNullOperator() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock ternaryBlock=simple.generateMethod(String.class,"ternary",param(Object.class,"test"),param(TernaryChecker.class,"check"))){
        ternaryBlock.returns(ternary(isNull(ternaryBlock.load("test")),invoke(ternaryBlock.load("check"),methodReference(TernaryChecker.class,String.class,"onTrue")),invoke(ternaryBlock.load("check"),methodReference(TernaryChecker.class,String.class,"onFalse"))));
      }
       handle=simple.handle();
    }
     MethodHandle ternary=instanceMethod(handle.newInstance(),"ternary",Object.class,TernaryChecker.class);
    TernaryChecker checker1=new TernaryChecker();
    assertThat(ternary.invoke(null,checker1),equalTo("on true"));
    assertTrue(checker1.ranOnTrue);
    assertFalse(checker1.ranOnFalse);
    TernaryChecker checker2=new TernaryChecker();
    assertThat(ternary.invoke(new Object(),checker2),equalTo("on false"));
    assertFalse(checker2.ranOnTrue);
    assertTrue(checker2.ranOnFalse);
  }
  @Test public void shouldHandleTernaryOnNonNullOperator() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock ternaryBlock=simple.generateMethod(String.class,"ternary",param(Object.class,"test"),param(TernaryChecker.class,"check"))){
        ternaryBlock.returns(ternary(notNull(ternaryBlock.load("test")),invoke(ternaryBlock.load("check"),methodReference(TernaryChecker.class,String.class,"onTrue")),invoke(ternaryBlock.load("check"),methodReference(TernaryChecker.class,String.class,"onFalse"))));
      }
       handle=simple.handle();
    }
     MethodHandle ternary=instanceMethod(handle.newInstance(),"ternary",Object.class,TernaryChecker.class);
    TernaryChecker checker1=new TernaryChecker();
    assertThat(ternary.invoke(new Object(),checker1),equalTo("on true"));
    assertTrue(checker1.ranOnTrue);
    assertFalse(checker1.ranOnFalse);
    TernaryChecker checker2=new TernaryChecker();
    assertThat(ternary.invoke(null,checker2),equalTo("on false"));
    assertFalse(checker2.ranOnTrue);
    assertTrue(checker2.ranOnFalse);
  }
  @Test public void shouldHandleEquality() throws Throwable {
    assertTrue(compareForType(boolean.class,true,true,Expression::equal));
    assertTrue(compareForType(boolean.class,false,false,Expression::equal));
    assertFalse(compareForType(boolean.class,true,false,Expression::equal));
    assertFalse(compareForType(boolean.class,false,true,Expression::equal));
    assertTrue(compareForType(byte.class,(byte)42,(byte)42,Expression::equal));
    assertFalse(compareForType(byte.class,(byte)43,(byte)42,Expression::equal));
    assertFalse(compareForType(byte.class,(byte)42,(byte)43,Expression::equal));
    assertTrue(compareForType(short.class,(short)42,(short)42,Expression::equal));
    assertFalse(compareForType(short.class,(short)43,(short)42,Expression::equal));
    assertFalse(compareForType(short.class,(short)42,(short)43,Expression::equal));
    assertTrue(compareForType(char.class,(char)42,(char)42,Expression::equal));
    assertFalse(compareForType(char.class,(char)43,(char)42,Expression::equal));
    assertFalse(compareForType(char.class,(char)42,(char)43,Expression::equal));
    assertTrue(compareForType(int.class,42,42,Expression::equal));
    assertFalse(compareForType(int.class,43,42,Expression::equal));
    assertFalse(compareForType(int.class,42,43,Expression::equal));
    assertTrue(compareForType(long.class,42L,42L,Expression::equal));
    assertFalse(compareForType(long.class,43L,42L,Expression::equal));
    assertFalse(compareForType(long.class,42L,43L,Expression::equal));
    assertTrue(compareForType(float.class,42F,42F,Expression::equal));
    assertFalse(compareForType(float.class,43F,42F,Expression::equal));
    assertFalse(compareForType(float.class,42F,43F,Expression::equal));
    assertTrue(compareForType(double.class,42D,42D,Expression::equal));
    assertFalse(compareForType(double.class,43D,42D,Expression::equal));
    assertFalse(compareForType(double.class,42D,43D,Expression::equal));
    Object obj1=new Object();
    Object obj2=new Object();
    assertTrue(compareForType(Object.class,obj1,obj1,Expression::equal));
    assertFalse(compareForType(Object.class,obj1,obj2,Expression::equal));
    assertFalse(compareForType(Object.class,obj2,obj1,Expression::equal));
  }
  @Test public void shouldHandleGreaterThan() throws Throwable {
    assertTrue(compareForType(float.class,43F,42F,Expression::gt));
    assertTrue(compareForType(long.class,43L,42L,Expression::gt));
    assertTrue(compareForType(byte.class,(byte)43,(byte)42,Expression::gt));
    assertFalse(compareForType(byte.class,(byte)42,(byte)42,Expression::gt));
    assertFalse(compareForType(byte.class,(byte)42,(byte)43,Expression::gt));
    assertTrue(compareForType(short.class,(short)43,(short)42,Expression::gt));
    assertFalse(compareForType(short.class,(short)42,(short)42,Expression::gt));
    assertFalse(compareForType(short.class,(short)42,(short)43,Expression::gt));
    assertTrue(compareForType(char.class,(char)43,(char)42,Expression::gt));
    assertFalse(compareForType(char.class,(char)42,(char)42,Expression::gt));
    assertFalse(compareForType(char.class,(char)42,(char)43,Expression::gt));
    assertTrue(compareForType(int.class,43,42,Expression::gt));
    assertFalse(compareForType(int.class,42,42,Expression::gt));
    assertFalse(compareForType(int.class,42,43,Expression::gt));
    assertTrue(compareForType(long.class,43L,42L,Expression::gt));
    assertFalse(compareForType(long.class,42L,42L,Expression::gt));
    assertFalse(compareForType(long.class,42L,43L,Expression::gt));
    assertTrue(compareForType(float.class,43F,42F,Expression::gt));
    assertFalse(compareForType(float.class,42F,42F,Expression::gt));
    assertFalse(compareForType(float.class,42F,43F,Expression::gt));
    assertTrue(compareForType(double.class,43D,42D,Expression::gt));
    assertFalse(compareForType(double.class,42D,42D,Expression::gt));
    assertFalse(compareForType(double.class,42D,43D,Expression::gt));
  }
  @Test public void shouldHandleAddition() throws Throwable {
    assertThat(addForType(int.class,17,18),equalTo(35));
    assertThat(addForType(long.class,17L,18L),equalTo(35L));
    assertThat(addForType(double.class,17D,18D),equalTo(35D));
  }
  @Test public void shouldHandleSubtraction() throws Throwable {
    assertThat(subtractForType(int.class,19,18),equalTo(1));
    assertThat(subtractForType(long.class,19L,18L),equalTo(1L));
    assertThat(subtractForType(double.class,19D,18D),equalTo(1D));
  }
  @Test public void shouldHandleMultiplication() throws Throwable {
    assertThat(multiplyForType(int.class,17,18),equalTo(306));
    assertThat(multiplyForType(long.class,17L,18L),equalTo(306L));
    assertThat(multiplyForType(double.class,17D,18D),equalTo(306D));
  }
  @SuppressWarnings("unchecked") private <T>T addForType(  Class<T> clazz,  T lhs,  T rhs) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock block=simple.generateMethod(clazz,"add",param(clazz,"a"),param(clazz,"b"))){
        block.returns(add(block.load("a"),block.load("b")));
      }
       handle=simple.handle();
    }
     MethodHandle add=instanceMethod(handle.newInstance(),"add",clazz,clazz);
    return (T)add.invoke(lhs,rhs);
  }
  @SuppressWarnings("unchecked") private <T>T subtractForType(  Class<T> clazz,  T lhs,  T rhs) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock block=simple.generateMethod(clazz,"sub",param(clazz,"a"),param(clazz,"b"))){
        block.returns(subtract(block.load("a"),block.load("b")));
      }
       handle=simple.handle();
    }
     MethodHandle sub=instanceMethod(handle.newInstance(),"sub",clazz,clazz);
    return (T)sub.invoke(lhs,rhs);
  }
  @SuppressWarnings("unchecked") private <T>T multiplyForType(  Class<T> clazz,  T lhs,  T rhs) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock block=simple.generateMethod(clazz,"multiply",param(clazz,"a"),param(clazz,"b"))){
        block.returns(multiply(block.load("a"),block.load("b")));
      }
       handle=simple.handle();
    }
     MethodHandle sub=instanceMethod(handle.newInstance(),"multiply",clazz,clazz);
    return (T)sub.invoke(lhs,rhs);
  }
  private <T>boolean compareForType(  Class<T> clazz,  T lhs,  T rhs,  BiFunction<Expression,Expression,Expression> compare) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock block=simple.generateMethod(boolean.class,"compare",param(clazz,"a"),param(clazz,"b"))){
        block.returns(compare.apply(block.load("a"),block.load("b")));
      }
       handle=simple.handle();
    }
     MethodHandle compareFcn=instanceMethod(handle.newInstance(),"compare",clazz,clazz);
    return (boolean)compareFcn.invoke(lhs,rhs);
  }
public static class TernaryChecker {
    private boolean ranOnTrue;
    private boolean ranOnFalse;
    public String onTrue(){
      ranOnTrue=true;
      return "on true";
    }
    public String onFalse(){
      ranOnFalse=true;
      return "on false";
    }
  }
  @Test public void shouldGenerateTryCatch() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock run=simple.generateMethod(void.class,"run",param(Runnable.class,"body"),param(Runnable.class,"catcher"))){
        run.tryCatch(body -> body.expression(invoke(run.load("body"),RUN)),handler -> handler.expression(invoke(run.load("catcher"),RUN)),param(RuntimeException.class,"E"));
      }
       handle=simple.handle();
    }
     Runnable successBody=mock(Runnable.class);
    Runnable failBody=mock(Runnable.class);
    Runnable successCatch=mock(Runnable.class);
    Runnable failCatch=mock(Runnable.class);
    RuntimeException theFailure=new RuntimeException();
    doThrow(theFailure).when(failBody).run();
    MethodHandle run=instanceMethod(handle.newInstance(),"run",Runnable.class,Runnable.class);
    run.invoke(successBody,successCatch);
    verify(successBody).run();
    verify(successCatch,never()).run();
    run.invoke(failBody,failCatch);
    InOrder orderFailure=inOrder(failBody,failCatch);
    orderFailure.verify(failBody).run();
    orderFailure.verify(failCatch).run();
  }
  @Test public void shouldGenerateTryCatchWithNestedBlock() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock run=simple.generateMethod(void.class,"run",param(Runnable.class,"body"),param(Runnable.class,"catcher"),param(boolean.class,"test"))){
        run.tryCatch(tryBlock -> {
          try (CodeBlock ifBlock=tryBlock.ifStatement(run.load("test"))){
            ifBlock.expression(invoke(run.load("body"),RUN));
          }
         }
,catchBlock -> catchBlock.expression(invoke(run.load("catcher"),RUN)),param(RuntimeException.class,"E"));
      }
       handle=simple.handle();
    }
     Runnable runnable=mock(Runnable.class);
    MethodHandle run=instanceMethod(handle.newInstance(),"run",Runnable.class,Runnable.class,boolean.class);
    run.invoke(runnable,mock(Runnable.class),false);
    verify(runnable,never()).run();
    run.invoke(runnable,mock(Runnable.class),true);
    verify(runnable).run();
  }
  @Test public void shouldGenerateTryAndMultipleCatch() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock run=simple.generateMethod(void.class,"run",param(Runnable.class,"body"),param(Runnable.class,"catcher1"),param(Runnable.class,"catcher2"))){
        run.tryCatch(tryBlock -> tryBlock.tryCatch(innerTry -> innerTry.expression(invoke(run.load("body"),RUN)),catchBlock1 -> catchBlock1.expression(invoke(run.load("catcher1"),RUN)),param(MyFirstException.class,"E1")),catchBlock2 -> catchBlock2.expression(invoke(run.load("catcher2"),RUN)),param(MySecondException.class,"E2"));
      }
       handle=simple.handle();
    }
     Runnable body1=mock(Runnable.class);
    Runnable body2=mock(Runnable.class);
    Runnable catcher11=mock(Runnable.class);
    Runnable catcher12=mock(Runnable.class);
    Runnable catcher21=mock(Runnable.class);
    Runnable catcher22=mock(Runnable.class);
    doThrow(MyFirstException.class).when(body1).run();
    doThrow(MySecondException.class).when(body2).run();
    MethodHandle run=instanceMethod(handle.newInstance(),"run",Runnable.class,Runnable.class,Runnable.class);
    run.invoke(body1,catcher11,catcher12);
    verify(body1).run();
    verify(catcher11).run();
    verify(catcher12,never()).run();
    run.invoke(body2,catcher21,catcher22);
    verify(body2).run();
    verify(catcher22).run();
    verify(catcher21,never()).run();
  }
  @Test public void shouldThrowException() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock thrower=simple.generateMethod(void.class,"thrower")){
        thrower.throwException(invoke(newInstance(RuntimeException.class),constructorReference(RuntimeException.class,String.class),constant("hello world")));
      }
       handle=simple.handle();
    }
     try {
      instanceMethod(handle.newInstance(),"thrower").invoke();
      fail("expected exception");
    }
 catch (    RuntimeException exception) {
      assertEquals("hello world",exception.getMessage());
    }
  }
  @Test public void shouldBeAbleToCast() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass(NamedBase.class,"SimpleClass")){
      simple.field(String.class,"foo");
      simple.generate(MethodTemplate.constructor(param(String.class,"name"),param(Object.class,"foo")).invokeSuper(new ExpressionTemplate[]{load("name",typeReference(String.class))},new TypeReference[]{typeReference(String.class)}).put(self(simple.handle()),String.class,"foo",cast(String.class,load("foo",typeReference(Object.class)))).build());
      handle=simple.handle();
    }
     Object instance=constructor(handle.loadClass(),String.class,Object.class).invoke("Pontus","Tobias");
    assertEquals("SimpleClass",instance.getClass().getSimpleName());
    assertThat(instance,instanceOf(NamedBase.class));
    assertEquals("Pontus",((NamedBase)instance).name);
    assertEquals("Tobias",getField(instance,"foo"));
  }
  @Test public void shouldBeAbleToBox() throws Throwable {
    assertThat(boxTest(boolean.class,true),equalTo(Boolean.TRUE));
    assertThat(boxTest(boolean.class,false),equalTo(Boolean.FALSE));
    assertThat(boxTest(byte.class,(byte)12),equalTo((byte)12));
    assertThat(boxTest(short.class,(short)12),equalTo((short)12));
    assertThat(boxTest(int.class,12),equalTo(12));
    assertThat(boxTest(long.class,12L),equalTo(12L));
    assertThat(boxTest(float.class,12F),equalTo(12F));
    assertThat(boxTest(double.class,12D),equalTo(12D));
    assertThat(boxTest(char.class,'a'),equalTo('a'));
  }
  @Test public void shouldBeAbleToUnbox() throws Throwable {
    assertThat(unboxTest(Boolean.class,boolean.class,true),equalTo(true));
    assertThat(unboxTest(Boolean.class,boolean.class,false),equalTo(false));
    assertThat(unboxTest(Byte.class,byte.class,(byte)12),equalTo((byte)12));
    assertThat(unboxTest(Short.class,short.class,(short)12),equalTo((short)12));
    assertThat(unboxTest(Integer.class,int.class,12),equalTo(12));
    assertThat(unboxTest(Long.class,long.class,12L),equalTo(12L));
    assertThat(unboxTest(Float.class,float.class,12F),equalTo(12F));
    assertThat(unboxTest(Double.class,double.class,12D),equalTo(12D));
    assertThat(unboxTest(Character.class,char.class,'a'),equalTo('a'));
  }
  @Test public void shouldHandleInfinityAndNan() throws Throwable {
    assertTrue(Double.isInfinite(generateDoubleMethod(Double.POSITIVE_INFINITY).get()));
    assertTrue(Double.isInfinite(generateDoubleMethod(Double.NEGATIVE_INFINITY).get()));
    assertTrue(Double.isNaN(generateDoubleMethod(Double.NaN).get()));
  }
  @Test public void shouldGenerateInstanceOf() throws Throwable {
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock conditional=simple.generateMethod(boolean.class,"isString",param(Object.class,"test"))){
        conditional.returns(Expression.instanceOf(typeReference(String.class),conditional.load("test")));
      }
       handle=simple.handle();
    }
     MethodHandle isString=instanceMethod(handle.newInstance(),"isString",Object.class);
    assertTrue((Boolean)isString.invoke("this is surely a string"));
    assertFalse((Boolean)isString.invoke("this is surely a string".length()));
  }
  private Supplier<Double> generateDoubleMethod(  double toBeReturned) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      simple.generate(MethodTemplate.method(double.class,"value").returns(constant(toBeReturned)).build());
      handle=simple.handle();
    }
     Object instance=constructor(handle.loadClass()).invoke();
    MethodHandle method=instanceMethod(instance,"value");
    return () -> {
      try {
        return (Double)method.invoke();
      }
 catch (      Throwable throwable) {
        throw new AssertionError(throwable);
      }
    }
;
  }
  private <T>Object unboxTest(  Class<T> boxedType,  Class<?> unboxedType,  T value) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock method=simple.generateMethod(unboxedType,"unbox",param(boxedType,"test"))){
        method.returns(Expression.unbox(method.load("test")));
      }
       handle=simple.handle();
    }
     return instanceMethod(handle.newInstance(),"unbox",boxedType).invoke(value);
  }
  private <T>Object boxTest(  Class<T> unboxedType,  T value) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      try (CodeBlock method=simple.generateMethod(Object.class,"box",param(unboxedType,"test"))){
        method.returns(Expression.box(method.load("test")));
      }
       handle=simple.handle();
    }
     return instanceMethod(handle.newInstance(),"box",unboxedType).invoke(value);
  }
  private MethodHandle conditional(  Function<CodeBlock,Expression> test,  Parameter... params){
    throw new UnsupportedOperationException("not implemented");
  }
  private static MethodHandle method(  Class<?> target,  String name,  Class<?>... parameters) throws Exception {
    return MethodHandles.lookup().unreflect(target.getMethod(name,parameters));
  }
  private static MethodHandle instanceMethod(  Object instance,  String name,  Class<?>... parameters) throws Exception {
    return method(instance.getClass(),name,parameters).bindTo(instance);
  }
  private static Object getField(  Object instance,  String field) throws Exception {
    return instance.getClass().getField(field).get(instance);
  }
  private static MethodHandle constructor(  Class<?> target,  Class<?>... parameters) throws Exception {
    return MethodHandles.lookup().unreflectConstructor(target.getConstructor(parameters));
  }
  public static final String PACKAGE="org.neo4j.codegen.test";
  private CodeGenerator generator;
  ClassGenerator generateClass(  String name,  Class<?> firstInterface,  Class<?>... more){
    return generator.generateClass(PACKAGE,name,firstInterface,more);
  }
  private ClassGenerator generateClass(  Class<?> base,  String name,  Class<?>... interfaces){
    return generator.generateClass(base,PACKAGE,name,interfaces);
  }
  private ClassGenerator generateClass(  String name,  TypeReference... interfaces){
    return generator.generateClass(PACKAGE,name,interfaces);
  }
public static class NamedBase {
    final String name;
    private boolean defaultConstructorCalled;
    public NamedBase(){
      this.defaultConstructorCalled=true;
      this.name=null;
    }
    public NamedBase(    String name){
      this.name=name;
    }
    public boolean defaultConstructorCalled(){
      return defaultConstructorCalled;
    }
  }
public static class SomeBean {
    private String foo;
    private String bar;
    public void setFoo(    String foo){
      this.foo=foo;
    }
    public void setBar(    String bar){
      this.bar=bar;
    }
  }
  private <T>void assertMethodReturningField(  Class<T> clazz,  T argument) throws Throwable {
    createGenerator();
    ClassHandle handle;
    try (ClassGenerator simple=generateClass("SimpleClass")){
      FieldReference value=simple.field(clazz,"value");
      simple.generate(MethodTemplate.constructor(param(clazz,"value")).invokeSuper().put(self(simple.handle()),value.type(),value.name(),load("value",value.type())).build());
      simple.generate(MethodTemplate.method(clazz,"value").returns(ExpressionTemplate.get(self(simple.handle()),clazz,"value")).build());
      handle=simple.handle();
    }
     Object instance=constructor(handle.loadClass(),clazz).invoke(argument);
    assertEquals(argument,instanceMethod(instance,"value").invoke());
  }
  private static MethodReference createMethod(  Class<?> owner,  Class<?> returnType,  String name){
    return methodReference(Runnable.class,void.class,"run");
  }
public static class MyFirstException extends RuntimeException {
  }
public static class MySecondException extends RuntimeException {
  }
}
