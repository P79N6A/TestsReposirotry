@ExtendWith({EphemeralFileSystemExtension.class,TestDirectoryExtension.class}) class LuceneSchemaIndexCorruptionTest {
  @Inject private TestDirectory testDirectory;
  @Inject private EphemeralFileSystemAbstraction fs;
  private final AssertableLogProvider logProvider=new AssertableLogProvider();
  private final IndexProvider.Monitor monitor=new LoggingMonitor(logProvider.getLog("test"));
  @Test void shouldRequestIndexPopulationIfTheIndexIsCorrupt(){
    long faultyIndexId=1;
    CorruptIndexException error=new CorruptIndexException("It's broken.","");
    LuceneIndexProvider provider=newFaultyIndexProvider(faultyIndexId,error);
    StoreIndexDescriptor descriptor=forSchema(forLabel(1,1),provider.getProviderDescriptor()).withId(faultyIndexId);
    InternalIndexState initialState=provider.getInitialState(descriptor);
    assertThat(initialState,equalTo(InternalIndexState.POPULATING));
    logProvider.assertAtLeastOnce(loggedException(error));
  }
  @Test void shouldRequestIndexPopulationFailingWithFileNotFoundException(){
    long faultyIndexId=1;
    FileNotFoundException error=new FileNotFoundException("/some/path/somewhere");
    LuceneIndexProvider provider=newFaultyIndexProvider(faultyIndexId,error);
    StoreIndexDescriptor descriptor=forSchema(forLabel(1,1),provider.getProviderDescriptor()).withId(faultyIndexId);
    InternalIndexState initialState=provider.getInitialState(descriptor);
    assertThat(initialState,equalTo(InternalIndexState.POPULATING));
    logProvider.assertAtLeastOnce(loggedException(error));
  }
  @Test void shouldRequestIndexPopulationWhenFailingWithEOFException(){
    long faultyIndexId=1;
    EOFException error=new EOFException("/some/path/somewhere");
    LuceneIndexProvider provider=newFaultyIndexProvider(faultyIndexId,error);
    StoreIndexDescriptor descriptor=forSchema(forLabel(1,1),provider.getProviderDescriptor()).withId(faultyIndexId);
    InternalIndexState initialState=provider.getInitialState(descriptor);
    assertThat(initialState,equalTo(InternalIndexState.POPULATING));
    logProvider.assertAtLeastOnce(loggedException(error));
  }
  private LuceneIndexProvider newFaultyIndexProvider(  long faultyIndexId,  Exception error){
    DirectoryFactory directoryFactory=mock(DirectoryFactory.class);
    File indexRootFolder=testDirectory.databaseDir();
    AtomicReference<FaultyIndexStorageFactory> reference=new AtomicReference<>();
    return new LuceneIndexProvider(fs,directoryFactory,defaultDirectoryStructure(indexRootFolder),monitor,Config.defaults(),OperationalMode.single){
      @Override protected IndexStorageFactory buildIndexStorageFactory(      FileSystemAbstraction fileSystem,      DirectoryFactory directoryFactory){
        FaultyIndexStorageFactory storageFactory=new FaultyIndexStorageFactory(faultyIndexId,error,directoryFactory,directoryStructure());
        reference.set(storageFactory);
        return storageFactory;
      }
    }
;
  }
private class FaultyIndexStorageFactory extends IndexStorageFactory {
    final long faultyIndexId;
    final Exception error;
    FaultyIndexStorageFactory(    long faultyIndexId,    Exception error,    DirectoryFactory directoryFactory,    IndexDirectoryStructure directoryStructure){
      super(directoryFactory,fs,directoryStructure);
      this.faultyIndexId=faultyIndexId;
      this.error=error;
    }
    @Override public PartitionedIndexStorage indexStorageOf(    long indexId){
      return indexId == faultyIndexId ? newFaultyPartitionedIndexStorage() : super.indexStorageOf(indexId);
    }
    PartitionedIndexStorage newFaultyPartitionedIndexStorage(){
      try {
        PartitionedIndexStorage storage=mock(PartitionedIndexStorage.class);
        when(storage.listFolders()).thenReturn(singletonList(new File("/some/path/somewhere/1")));
        when(storage.openDirectory(any())).thenThrow(error);
        return storage;
      }
 catch (      IOException e) {
        throw new UncheckedIOException(e);
      }
    }
  }
  private static AssertableLogProvider.LogMatcher loggedException(  Throwable exception){
    return inLog(CoreMatchers.any(String.class)).error(CoreMatchers.any(String.class),sameInstance(exception));
  }
}
