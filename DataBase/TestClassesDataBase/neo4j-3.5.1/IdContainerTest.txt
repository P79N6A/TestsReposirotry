public class IdContainerTest {
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  @Rule public final FileSystemRule fileSystemRule=new DefaultFileSystemRule();
  private FileSystemAbstraction fs;
  private File file;
  @Before public void setUp(){
    fs=fileSystemRule.get();
    file=testDirectory.file("ids");
  }
  @Test public void shouldDeleteIfOpen(){
    createEmptyFile();
    IdContainer idContainer=new IdContainer(fs,file,100,false);
    idContainer.init();
    idContainer.delete();
    assertFalse(fs.fileExists(file));
    idContainer.close(0);
  }
  @Test public void shouldDeleteIfClosed(){
    createEmptyFile();
    IdContainer idContainer=new IdContainer(fs,file,100,false);
    idContainer.init();
    idContainer.close(0);
    idContainer.delete();
    assertFalse(fs.fileExists(file));
  }
  @Test public void shouldForceStickyMark() throws Exception {
    createEmptyFile();
    IdContainer idContainer=new IdContainer(fs,file,100,false);
    idContainer.init();
    try {
      IdContainer.readHighId(fs,file);
      fail("Should have thrown, saying something with sticky generator");
    }
 catch (    InvalidIdGeneratorException e) {
    }
 finally {
      idContainer.close(0);
    }
  }
  @Test public void shouldTruncateTheFileIfOverwriting() throws Exception {
    IdContainer.createEmptyIdFile(fs,file,30,false);
    IdContainer idContainer=new IdContainer(fs,file,5,false);
    idContainer.init();
    for (int i=0; i < 17; i++) {
      idContainer.freeId(i);
    }
    idContainer.close(30);
    assertThat((int)fs.getFileSize(file),greaterThan(IdContainer.HEADER_SIZE));
    IdContainer.createEmptyIdFile(fs,file,30,false);
    assertEquals(IdContainer.HEADER_SIZE,(int)fs.getFileSize(file));
    assertEquals(30,IdContainer.readHighId(fs,file));
    idContainer=new IdContainer(fs,file,5,false);
    idContainer.init();
    assertEquals(30,idContainer.getInitialHighId());
    idContainer.close(30);
  }
  @Test public void shouldReturnFalseOnInitIfTheFileWasCreated(){
    IdContainer idContainer=new IdContainer(fs,file,100,false);
    assertFalse(idContainer.init());
    idContainer.close(100);
  }
  @Test public void shouldReturnTrueOnInitIfAProperFileWasThere(){
    IdContainer idContainer=new IdContainer(fs,file,100,false);
    idContainer.init();
    idContainer.close(100);
    idContainer=new IdContainer(fs,file,100,false);
    assertTrue(idContainer.init());
    idContainer.close(100);
  }
  @Test public void idContainerReadWriteBySingleByte() throws IOException {
    SingleByteFileSystemAbstraction fileSystem=new SingleByteFileSystemAbstraction();
    IdContainer idContainer=new IdContainer(fileSystem,file,100,false);
    idContainer.init();
    idContainer.close(100);
    idContainer=new IdContainer(fileSystem,file,100,false);
    idContainer.init();
    assertEquals(100,idContainer.getInitialHighId());
    fileSystem.close();
    idContainer.close(100);
  }
  private void createEmptyFile(){
    IdContainer.createEmptyIdFile(fs,file,42,false);
  }
private static class SingleByteFileSystemAbstraction extends DefaultFileSystemAbstraction {
    @Override public StoreFileChannel open(    File fileName,    OpenMode mode) throws IOException {
      return new SingleByteBufferChannel(super.open(fileName,mode));
    }
  }
private static class SingleByteBufferChannel extends StoreFileChannel {
    SingleByteBufferChannel(    StoreFileChannel channel){
      super(channel);
    }
    @Override public int write(    ByteBuffer src) throws IOException {
      byte b=src.get();
      ByteBuffer byteBuffer=ByteBuffer.wrap(new byte[]{b});
      return super.write(byteBuffer);
    }
    @Override public int read(    ByteBuffer dst) throws IOException {
      ByteBuffer byteBuffer=ByteBuffer.allocate(1);
      int read=super.read(byteBuffer);
      if (read > 0) {
        byteBuffer.flip();
        dst.put(byteBuffer.get());
      }
      return read;
    }
  }
}
