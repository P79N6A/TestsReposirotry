@RunWith(Suite.class) @Suite.SuiteClasses({ConsistencyReporterTest.TestAllReportMessages.class,ConsistencyReporterTest.TestReportLifecycle.class}) public class ConsistencyReporterTest {
public static class TestReportLifecycle {
    @Rule public final TestName testName=new TestName();
    @Test public void shouldSummarizeStatisticsAfterCheck(){
      ConsistencySummaryStatistics summary=mock(ConsistencySummaryStatistics.class);
      @SuppressWarnings("unchecked") RecordAccess records=mock(RecordAccess.class);
      ConsistencyReporter.ReportHandler handler=new ConsistencyReporter.ReportHandler(new InconsistencyReport(mock(InconsistencyLogger.class),summary),mock(ConsistencyReporter.ProxyFactory.class),RecordType.PROPERTY,records,new PropertyRecord(0),NO_MONITOR);
      handler.updateSummary();
      verify(summary).update(RecordType.PROPERTY,0,0);
      verifyNoMoreInteractions(summary);
    }
    @Test @SuppressWarnings("unchecked") public void shouldOnlySummarizeStatisticsWhenAllReferencesAreChecked(){
      ConsistencySummaryStatistics summary=mock(ConsistencySummaryStatistics.class);
      RecordAccess records=mock(RecordAccess.class);
      ConsistencyReporter.ReportHandler handler=new ConsistencyReporter.ReportHandler(new InconsistencyReport(mock(InconsistencyLogger.class),summary),mock(ConsistencyReporter.ProxyFactory.class),RecordType.PROPERTY,records,new PropertyRecord(0),NO_MONITOR);
      RecordReference<PropertyRecord> reference=mock(RecordReference.class);
      ComparativeRecordChecker<PropertyRecord,PropertyRecord,ConsistencyReport.PropertyConsistencyReport> checker=mock(ComparativeRecordChecker.class);
      handler.comparativeCheck(reference,checker);
      ArgumentCaptor<PendingReferenceCheck<PropertyRecord>> captor=(ArgumentCaptor)ArgumentCaptor.forClass(PendingReferenceCheck.class);
      verify(reference).dispatch(captor.capture());
      PendingReferenceCheck pendingRefCheck=captor.getValue();
      handler.updateSummary();
      verifyZeroInteractions(summary);
      pendingRefCheck.skip();
      verify(summary).update(RecordType.PROPERTY,0,0);
      verifyNoMoreInteractions(summary);
    }
    @Test public void shouldIncludeStackTraceInUnexpectedCheckException(){
      ConsistencySummaryStatistics summary=mock(ConsistencySummaryStatistics.class);
      RecordAccess records=mock(RecordAccess.class);
      final AtomicReference<String> loggedError=new AtomicReference<>();
      InconsistencyLogger logger=new InconsistencyLogger(){
        @Override public void error(        RecordType recordType,        AbstractBaseRecord record,        String message,        Object[] args){
          assertTrue(loggedError.compareAndSet(null,message));
        }
        @Override public void error(        RecordType recordType,        AbstractBaseRecord oldRecord,        AbstractBaseRecord newRecord,        String message,        Object[] args){
          assertTrue(loggedError.compareAndSet(null,message));
        }
        @Override public void warning(        RecordType recordType,        AbstractBaseRecord record,        String message,        Object[] args){
        }
        @Override public void warning(        RecordType recordType,        AbstractBaseRecord oldRecord,        AbstractBaseRecord newRecord,        String message,        Object[] args){
        }
      }
;
      InconsistencyReport inconsistencyReport=new InconsistencyReport(logger,summary);
      ConsistencyReporter reporter=new ConsistencyReporter(records,inconsistencyReport);
      NodeRecord node=new NodeRecord(10);
      RecordCheck<NodeRecord,NodeConsistencyReport> checker=mock(RecordCheck.class);
      RuntimeException exception=new RuntimeException("My specific exception");
      doThrow(exception).when(checker).check(any(NodeRecord.class),any(CheckerEngine.class),any(RecordAccess.class));
      reporter.forNode(node,checker);
      assertNotNull(loggedError.get());
      String error=loggedError.get();
      assertThat(error,containsString("at "));
      assertThat(error,containsString(testName.getMethodName()));
    }
  }
@RunWith(Parameterized.class) public static class TestAllReportMessages implements Answer {
    @Test @SuppressWarnings("unchecked") public void shouldLogInconsistency() throws Exception {
      InconsistencyReport report=mock(InconsistencyReport.class);
      ConsistencyReport.Reporter reporter=new ConsistencyReporter(mock(RecordAccess.class),report);
      reportMethod.invoke(reporter,parameters(reportMethod));
      if (method.getAnnotation(ConsistencyReport.Warning.class) == null) {
        if (reportMethod.getName().endsWith("Change")) {
          verify(report).error(any(RecordType.class),any(AbstractBaseRecord.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),any(Object[].class));
        }
 else {
          verify(report).error(any(RecordType.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),nullSafeAny());
        }
      }
 else {
        if (reportMethod.getName().endsWith("Change")) {
          verify(report).warning(any(RecordType.class),any(AbstractBaseRecord.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),any(Object[].class));
        }
 else {
          verify(report).warning(any(RecordType.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),nullSafeAny());
        }
      }
    }
    private final Method reportMethod;
    private final Method method;
    public TestAllReportMessages(    Method reportMethod,    Method method){
      this.reportMethod=reportMethod;
      this.method=method;
    }
    @Parameterized.Parameters(name="{1}") public static List<Object[]> methods(){
      ArrayList<Object[]> methods=new ArrayList<>();
      for (      Method reporterMethod : ConsistencyReport.Reporter.class.getMethods()) {
        Type[] parameterTypes=reporterMethod.getGenericParameterTypes();
        ParameterizedType checkerParameter=(ParameterizedType)parameterTypes[parameterTypes.length - 1];
        Class reportType=(Class)checkerParameter.getActualTypeArguments()[1];
        for (        Method method : reportType.getMethods()) {
          methods.add(new Object[]{reporterMethod,method});
        }
      }
      return methods;
    }
    @Rule public final TestRule logFailure=(base,description) -> new Statement(){
      @Override public void evaluate() throws Throwable {
        try {
          base.evaluate();
        }
 catch (        Throwable failure) {
          System.err.println("Failure in " + TestAllReportMessages.this + ": "+ failure);
          throw failure;
        }
      }
    }
;
    @Override public String toString(){
      return format("report.%s( %s{ reporter.%s(); } )",reportMethod.getName(),signatureOf(reportMethod),method.getName());
    }
    private static String signatureOf(    Method reportMethod){
      if (reportMethod.getParameterTypes().length == 2) {
        return "record, RecordCheck( reporter )";
      }
 else {
        return "oldRecord, newRecord, RecordCheck( reporter )";
      }
    }
    private Object[] parameters(    Method method){
      Class<?>[] parameterTypes=method.getParameterTypes();
      Object[] parameters=new Object[parameterTypes.length];
      for (int i=0; i < parameters.length; i++) {
        parameters[i]=parameter(parameterTypes[i]);
      }
      return parameters;
    }
    private Object parameter(    Class<?> type){
      if (type == RecordType.class) {
        return RecordType.STRING_PROPERTY;
      }
      if (type == RecordCheck.class) {
        return mockChecker();
      }
      if (type == NodeRecord.class) {
        return new NodeRecord(0,false,1,2);
      }
      if (type == RelationshipRecord.class) {
        return new RelationshipRecord(0,1,2,3);
      }
      if (type == PropertyRecord.class) {
        return new PropertyRecord(0);
      }
      if (type == PropertyKeyTokenRecord.class) {
        return new PropertyKeyTokenRecord(0);
      }
      if (type == PropertyBlock.class) {
        return new PropertyBlock();
      }
      if (type == RelationshipTypeTokenRecord.class) {
        return new RelationshipTypeTokenRecord(0);
      }
      if (type == LabelTokenRecord.class) {
        return new LabelTokenRecord(0);
      }
      if (type == DynamicRecord.class) {
        return new DynamicRecord(0);
      }
      if (type == NeoStoreRecord.class) {
        return new NeoStoreRecord();
      }
      if (type == LabelScanDocument.class) {
        return new LabelScanDocument(new NodeLabelRange(0,new long[][]{}));
      }
      if (type == IndexEntry.class) {
        return new IndexEntry(0);
      }
      if (type == CountsEntry.class) {
        return new CountsEntry(nodeKey(7),42);
      }
      if (type == SchemaRule.Kind.class) {
        return SchemaRule.Kind.INDEX_RULE;
      }
      if (type == StoreIndexDescriptor.class) {
        return IndexDescriptorFactory.forSchema(forLabel(2,3),IndexProviderDescriptor.UNDECIDED).withId(1);
      }
      if (type == SchemaRule.class) {
        return simpleSchemaRule();
      }
      if (type == RelationshipGroupRecord.class) {
        return new RelationshipGroupRecord(0,1);
      }
      if (type == long.class) {
        return 12L;
      }
      if (type == Object.class) {
        return "object";
      }
      throw new IllegalArgumentException(format("Don't know how to provide parameter of type %s",type.getName()));
    }
    private static SchemaRule simpleSchemaRule(){
      return new SchemaRule(){
        @Override public long getId(){
          return 0;
        }
        @Override public String getName(){
          return null;
        }
        @Override public SchemaDescriptor schema(){
          return null;
        }
      }
;
    }
    @SuppressWarnings("unchecked") private RecordCheck mockChecker(){
      RecordCheck checker=mock(RecordCheck.class);
      doAnswer(this).when(checker).check(any(AbstractBaseRecord.class),any(CheckerEngine.class),any(RecordAccess.class));
      return checker;
    }
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Object[] arguments=invocation.getArguments();
      ConsistencyReport report=((CheckerEngine)arguments[arguments.length - 2]).report();
      try {
        return method.invoke(report,parameters(method));
      }
 catch (      IllegalArgumentException ex) {
        throw new IllegalArgumentException(format("%s.%s#%s(...)",report,method.getDeclaringClass().getSimpleName(),method.getName()),ex);
      }
    }
  }
  private static <T>T[] nullSafeAny(){
    return ArgumentMatchers.argThat(argument -> true);
  }
  private static Matcher<String> hasExpectedFormat(){
    return new TypeSafeMatcher<String>(){
      @Override public boolean matchesSafely(      String item){
        return item.trim().split(" ").length > 1;
      }
      @Override public void describeTo(      Description description){
        description.appendText("message of valid format");
      }
    }
;
  }
}
