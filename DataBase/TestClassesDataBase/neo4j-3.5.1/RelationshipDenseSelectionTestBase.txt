public abstract class RelationshipDenseSelectionTestBase<Traverser extends RelationshipDenseSelection> extends RelationshipSelectionTestBase {
  private TestRelationshipChain outA=new TestRelationshipChain(42L);
  private TestRelationshipChain inA=new TestRelationshipChain(42L).incoming(0,1,typeA).incoming(0,2,typeA);
  private TestRelationshipChain loopA=new TestRelationshipChain(42L).loop(0,typeA);
  private TestRelationshipChain outB=new TestRelationshipChain(42L).outgoing(0,10,typeB);
  private TestRelationshipChain inB=new TestRelationshipChain(42L);
  private TestRelationshipChain loopB=new TestRelationshipChain(42L).loop(0,typeB).loop(0,typeB);
  private TestRelationshipChain outC=new TestRelationshipChain(42L).outgoing(0,20,typeC).outgoing(0,21,typeC);
  private TestRelationshipChain inC=new TestRelationshipChain(42L).incoming(0,22,typeC);
  private TestRelationshipChain loopC=new TestRelationshipChain(42L);
  private List<TestRelationshipChain> store=new ArrayList<>();
  private StubGroupCursor innerGroupCursor=new StubGroupCursor(group(store,typeA,outA,inA,loopA),group(store,typeB,outB,inB,loopB),group(store,typeC,outC,inC,loopC));
  private StubRelationshipCursor innerRelationshipCursor=new StubRelationshipCursor(store);
  @Before public void rewindCursor(){
    innerGroupCursor.rewind();
  }
  protected abstract Traverser make();
  @Test public void shouldSelectOutgoing(){
    Traverser traverser=make();
    traverser.outgoing(innerGroupCursor,innerRelationshipCursor);
    assertLoop(traverser,typeA);
    assertOutgoing(traverser,10,typeB);
    assertLoop(traverser,typeB);
    assertLoop(traverser,typeB);
    assertOutgoing(traverser,20,typeC);
    assertOutgoing(traverser,21,typeC);
    assertEmptyAndClosed(traverser);
  }
  @Test public void shouldSelectIncoming(){
    Traverser traverser=make();
    traverser.incoming(innerGroupCursor,innerRelationshipCursor);
    assertIncoming(traverser,1,typeA);
    assertIncoming(traverser,2,typeA);
    assertLoop(traverser,typeA);
    assertLoop(traverser,typeB);
    assertLoop(traverser,typeB);
    assertIncoming(traverser,22,typeC);
    assertEmptyAndClosed(traverser);
  }
  @Test public void shouldSelectAll(){
    Traverser traverser=make();
    traverser.all(innerGroupCursor,innerRelationshipCursor);
    assertIncoming(traverser,1,typeA);
    assertIncoming(traverser,2,typeA);
    assertLoop(traverser,typeA);
    assertOutgoing(traverser,10,typeB);
    assertLoop(traverser,typeB);
    assertLoop(traverser,typeB);
    assertOutgoing(traverser,20,typeC);
    assertOutgoing(traverser,21,typeC);
    assertIncoming(traverser,22,typeC);
    assertEmptyAndClosed(traverser);
  }
  @Test public void shouldSelectOutgoingOfType(){
    Traverser traverser=make();
    traverser.outgoing(innerGroupCursor,innerRelationshipCursor,types(typeA,typeC));
    assertLoop(traverser,typeA);
    assertOutgoing(traverser,20,typeC);
    assertOutgoing(traverser,21,typeC);
    assertEmptyAndClosed(traverser);
  }
  @Test public void shouldSelectIncomingOfType(){
    Traverser traverser=make();
    traverser.incoming(innerGroupCursor,innerRelationshipCursor,types(typeA,typeC));
    assertIncoming(traverser,1,typeA);
    assertIncoming(traverser,2,typeA);
    assertLoop(traverser,typeA);
    assertIncoming(traverser,22,typeC);
    assertEmptyAndClosed(traverser);
  }
  @Test public void shouldSelectAllOfType(){
    Traverser traverser=make();
    traverser.all(innerGroupCursor,innerRelationshipCursor,types(typeA,typeC));
    assertIncoming(traverser,1,typeA);
    assertIncoming(traverser,2,typeA);
    assertLoop(traverser,typeA);
    assertOutgoing(traverser,20,typeC);
    assertOutgoing(traverser,21,typeC);
    assertIncoming(traverser,22,typeC);
    assertEmptyAndClosed(traverser);
  }
  abstract void assertOutgoing(  Traverser cursor,  int targetNode,  int type);
  abstract void assertIncoming(  Traverser cursor,  int sourceNode,  int type);
  abstract void assertLoop(  Traverser cursor,  int type);
  abstract void assertEmpty(  Traverser cursor);
public static class IteratorTest extends RelationshipDenseSelectionTestBase<RelationshipDenseSelectionIterator<R>> {
    @Override protected RelationshipDenseSelectionIterator<R> make(){
      return new RelationshipDenseSelectionIterator<>(R::new);
    }
    @Override void assertOutgoing(    RelationshipDenseSelectionIterator<R> iterator,    int targetNode,    int type){
      assertOutgoing((ResourceIterator<R>)iterator,targetNode,type);
    }
    @Override void assertIncoming(    RelationshipDenseSelectionIterator<R> iterator,    int sourceNode,    int type){
      assertIncoming((ResourceIterator<R>)iterator,sourceNode,type);
    }
    @Override void assertLoop(    RelationshipDenseSelectionIterator<R> iterator,    int type){
      assertLoop((ResourceIterator<R>)iterator,type);
    }
    @Override void assertEmpty(    RelationshipDenseSelectionIterator<R> iterator){
      assertEmpty((ResourceIterator<R>)iterator);
    }
  }
public static class CursorTest extends RelationshipDenseSelectionTestBase<RelationshipDenseSelectionCursor> {
    @Override protected RelationshipDenseSelectionCursor make(){
      return new RelationshipDenseSelectionCursor();
    }
    @Override void assertOutgoing(    RelationshipDenseSelectionCursor iterator,    int targetNode,    int type){
      assertOutgoing((RelationshipSelectionCursor)iterator,targetNode,type);
    }
    @Override void assertIncoming(    RelationshipDenseSelectionCursor iterator,    int sourceNode,    int type){
      assertIncoming((RelationshipSelectionCursor)iterator,sourceNode,type);
    }
    @Override void assertLoop(    RelationshipDenseSelectionCursor iterator,    int type){
      assertLoop((RelationshipSelectionCursor)iterator,type);
    }
    @Override void assertEmpty(    RelationshipDenseSelectionCursor iterator){
      assertEmpty((RelationshipSelectionCursor)iterator);
    }
  }
  private void assertEmptyAndClosed(  Traverser traverser){
    assertEmpty(traverser);
    assertTrue("close group cursor",innerGroupCursor.isClosed());
    assertTrue("close traversal cursor",innerRelationshipCursor.isClosed());
  }
  private StubGroupCursor.GroupData group(  List<TestRelationshipChain> store,  int type,  TestRelationshipChain out,  TestRelationshipChain in,  TestRelationshipChain loop){
    return new StubGroupCursor.GroupData(addToStore(store,out),addToStore(store,in),addToStore(store,loop),type);
  }
  private int addToStore(  List<TestRelationshipChain> store,  TestRelationshipChain chain){
    int ref=store.size();
    store.add(chain);
    return ref;
  }
}
