public abstract class NodeValueIndexCursorTestBase<G extends KernelAPIReadTestSupport> extends KernelAPIReadTestBase<G> {
  private static final int TOTAL_NODE_COUNT=37;
  private static long strOne, strTwo1, strTwo2, strThree1, strThree2, strThree3;
  private static long boolTrue, num5, num6, num12a, num12b;
  private static long strOneNoLabel;
  private static long joeDalton, williamDalton, jackDalton, averellDalton;
  private static long date891, date892, date86;
  private static long[] nodesOfAllPropertyTypes;
  private static long whateverPoint;
  @Override public void createTestGraph(  GraphDatabaseService graphDb){
    try (Transaction tx=graphDb.beginTx()){
      graphDb.schema().indexFor(label("Node")).on("prop").create();
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      graphDb.schema().indexFor(label("What")).on("ever").create();
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      createCompositeIndex(graphDb,"Person","firstname","surname");
      tx.success();
    }
 catch (    Exception e) {
      throw new AssertionError(e);
    }
    try (Transaction tx=graphDb.beginTx()){
      graphDb.schema().awaitIndexesOnline(5,MINUTES);
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      strOne=nodeWithProp(graphDb,"one");
      strTwo1=nodeWithProp(graphDb,"two");
      strTwo2=nodeWithProp(graphDb,"two");
      strThree1=nodeWithProp(graphDb,"three");
      strThree2=nodeWithProp(graphDb,"three");
      strThree3=nodeWithProp(graphDb,"three");
      nodeWithProp(graphDb,false);
      boolTrue=nodeWithProp(graphDb,true);
      nodeWithProp(graphDb,3);
      nodeWithProp(graphDb,3);
      nodeWithProp(graphDb,3);
      nodeWithProp(graphDb,2);
      nodeWithProp(graphDb,2);
      nodeWithProp(graphDb,1);
      nodeWithProp(graphDb,4);
      num5=nodeWithProp(graphDb,5);
      num6=nodeWithProp(graphDb,6);
      num12a=nodeWithProp(graphDb,12.0);
      num12b=nodeWithProp(graphDb,12.0);
      nodeWithProp(graphDb,18);
      nodeWithProp(graphDb,24);
      nodeWithProp(graphDb,30);
      nodeWithProp(graphDb,36);
      nodeWithProp(graphDb,42);
      strOneNoLabel=nodeWithNoLabel(graphDb,"one");
      joeDalton=person(graphDb,"Joe","Dalton");
      williamDalton=person(graphDb,"William","Dalton");
      jackDalton=person(graphDb,"Jack","Dalton");
      averellDalton=person(graphDb,"Averell","Dalton");
      nodeWithProp(graphDb,Values.pointValue(Cartesian,1,0));
      nodeWithProp(graphDb,Values.pointValue(Cartesian,0,0));
      nodeWithProp(graphDb,Values.pointValue(Cartesian,0,0));
      nodeWithProp(graphDb,Values.pointValue(Cartesian,0,0));
      nodeWithProp(graphDb,Values.pointValue(Cartesian,0,1));
      nodeWithProp(graphDb,Values.pointValue(Cartesian_3D,0,0,0));
      nodeWithProp(graphDb,Values.pointValue(WGS84,0,0));
      nodeWithProp(graphDb,Values.pointValue(WGS84_3D,0,0,0));
      date891=nodeWithProp(graphDb,DateValue.date(1989,3,24));
      date86=nodeWithProp(graphDb,DateValue.date(1986,11,18));
      date892=nodeWithProp(graphDb,DateValue.date(1989,3,24));
      nodeWithProp(graphDb,new String[]{"first","second","third"});
      nodeWithProp(graphDb,new String[]{"fourth","fifth","sixth","seventh"});
      MutableLongList listOfIds=LongLists.mutable.empty();
      listOfIds.add(nodeWithWhatever(graphDb,"string"));
      listOfIds.add(nodeWithWhatever(graphDb,false));
      listOfIds.add(nodeWithWhatever(graphDb,3));
      listOfIds.add(nodeWithWhatever(graphDb,13.0));
      whateverPoint=nodeWithWhatever(graphDb,Values.pointValue(Cartesian,1,0));
      listOfIds.add(whateverPoint);
      listOfIds.add(nodeWithWhatever(graphDb,DateValue.date(1989,3,24)));
      listOfIds.add(nodeWithWhatever(graphDb,new String[]{"first","second","third"}));
      nodesOfAllPropertyTypes=listOfIds.toArray();
      tx.success();
    }
   }
  protected abstract void createCompositeIndex(  GraphDatabaseService graphDb,  String label,  String... properties) throws Exception ;
  protected abstract String providerKey();
  protected abstract String providerVersion();
  protected boolean indexProvidesStringValues(){
    return false;
  }
  protected boolean indexProvidesNumericValues(){
    return false;
  }
  protected boolean indexProvidesArrayValues(){
    return false;
  }
  protected boolean indexProvidesBooleanValues(){
    return false;
  }
  protected boolean indexProvidesTemporalValues(){
    return true;
  }
  protected boolean indexProvidesSpatialValues(){
    return false;
  }
  protected boolean indexProvidesAllValues(){
    return false;
  }
  @Test public void shouldPerformExactLookup() throws Exception {
    boolean needsValues=false;
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"zero"));
      assertFoundNodesAndNoValue(node,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"one"));
      assertFoundNodesAndNoValue(node,uniqueIds,strOne);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"two"));
      assertFoundNodesAndNoValue(node,uniqueIds,strTwo1,strTwo2);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"three"));
      assertFoundNodesAndNoValue(node,uniqueIds,strThree1,strThree2,strThree3);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,1));
      assertFoundNodesAndNoValue(node,1,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,2));
      assertFoundNodesAndNoValue(node,2,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,3));
      assertFoundNodesAndNoValue(node,3,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,6));
      assertFoundNodesAndNoValue(node,uniqueIds,num6);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,12.0));
      assertFoundNodesAndNoValue(node,uniqueIds,num12a,num12b);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,true));
      assertFoundNodesAndNoValue(node,uniqueIds,boolTrue);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,Values.pointValue(Cartesian,0,0)));
      assertFoundNodesAndNoValue(node,3,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,Values.pointValue(Cartesian_3D,0,0,0)));
      assertFoundNodesAndNoValue(node,1,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,Values.pointValue(WGS84,0,0)));
      assertFoundNodesAndNoValue(node,1,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,Values.pointValue(WGS84_3D,0,0,0)));
      assertFoundNodesAndNoValue(node,1,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,DateValue.date(1989,3,24)));
      assertFoundNodesAndNoValue(node,2,uniqueIds);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,DateValue.date(1986,11,18)));
      assertFoundNodesAndNoValue(node,1,uniqueIds);
    }
   }
  @Test public void shouldPerformExactLookupInCompositeIndex() throws Exception {
    boolean needsValues=false;
    int label=token.nodeLabel("Person");
    int firstName=token.propertyKey("firstname");
    int surname=token.propertyKey("surname");
    IndexReference index=schemaRead.index(label,firstName,surname);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      IndexValueCapability valueCapability=index.valueCapability(ValueCategory.TEXT,ValueCategory.TEXT);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(firstName,"Joe"),IndexQuery.exact(surname,"Dalton"));
      assertThat(node.numberOfProperties(),equalTo(2));
      assertFoundNodesAndNoValue(node,1,uniqueIds);
    }
   }
  @Test public void shouldPerformStringPrefixSearch() throws Exception {
    boolean needsValues=indexProvidesStringValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability stringCapability=index.valueCapability(ValueCategory.TEXT);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringPrefix(prop,stringValue("t")));
      assertThat(node.numberOfProperties(),equalTo(1));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strTwo1,strTwo2,strThree1,strThree2,strThree3);
    }
   }
  @Test public void shouldPerformStringSuffixSearch() throws Exception {
    boolean needsValues=indexProvidesStringValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability stringCapability=index.valueCapability(ValueCategory.TEXT);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringSuffix(prop,stringValue("e")));
      assertThat(node.numberOfProperties(),equalTo(1));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strOne,strThree1,strThree2,strThree3);
    }
   }
  @Test public void shouldPerformStringContainmentSearch() throws Exception {
    boolean needsValues=indexProvidesStringValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability stringCapability=index.valueCapability(ValueCategory.TEXT);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringContains(prop,stringValue("o")));
      assertThat(node.numberOfProperties(),equalTo(1));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strOne,strTwo1,strTwo2);
    }
   }
  @Test public void shouldPerformStringRangeSearch() throws Exception {
    boolean needsValues=indexProvidesStringValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability stringCapability=index.valueCapability(ValueCategory.TEXT);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",true,"three",true));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strOne,strThree1,strThree2,strThree3);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",true,"three",false));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strOne);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",false,"three",true));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strThree1,strThree2,strThree3);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",false,"two",false));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strThree1,strThree2,strThree3);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",true,"two",true));
      assertFoundNodesAndValue(node,uniqueIds,stringCapability,needsValues,strOne,strThree1,strThree2,strThree3,strTwo1,strTwo2);
    }
   }
  @Test public void shouldPerformNumericRangeSearch() throws Exception {
    boolean needsValues=indexProvidesNumericValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability numberCapability=index.valueCapability(ValueCategory.NUMBER);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,5,true,12,true));
      assertFoundNodesAndValue(node,uniqueIds,numberCapability,needsValues,num5,num6,num12a,num12b);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,5,true,12,false));
      assertFoundNodesAndValue(node,uniqueIds,numberCapability,needsValues,num5,num6);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,5,false,12,true));
      assertFoundNodesAndValue(node,uniqueIds,numberCapability,needsValues,num6,num12a,num12b);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,5,false,12,false));
      assertFoundNodesAndValue(node,uniqueIds,numberCapability,needsValues,num6);
    }
   }
  @Test public void shouldPerformTemporalRangeSearch() throws KernelException {
    boolean needsValues=indexProvidesTemporalValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability temporalCapability=index.valueCapability(ValueCategory.TEMPORAL);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,DateValue.date(1986,11,18),true,DateValue.date(1989,3,24),true));
      assertFoundNodesAndValue(node,uniqueIds,temporalCapability,needsValues,date86,date891,date892);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,DateValue.date(1986,11,18),true,DateValue.date(1989,3,24),false));
      assertFoundNodesAndValue(node,uniqueIds,temporalCapability,needsValues,date86);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,DateValue.date(1986,11,18),false,DateValue.date(1989,3,24),true));
      assertFoundNodesAndValue(node,uniqueIds,temporalCapability,needsValues,date891,date892);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,DateValue.date(1986,11,18),false,DateValue.date(1989,3,24),false));
      assertFoundNodesAndValue(node,uniqueIds,temporalCapability,needsValues);
    }
   }
  @Test public void shouldPerformSpatialRangeSearch() throws KernelException {
    boolean needsValues=indexProvidesSpatialValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability spatialCapability=index.valueCapability(ValueCategory.GEOMETRY);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,Cartesian));
      assertFoundNodesAndValue(node,5,uniqueIds,spatialCapability,needsValues);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,Cartesian_3D));
      assertFoundNodesAndValue(node,1,uniqueIds,spatialCapability,needsValues);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,WGS84));
      assertFoundNodesAndValue(node,1,uniqueIds,spatialCapability,needsValues);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,WGS84_3D));
      assertFoundNodesAndValue(node,1,uniqueIds,spatialCapability,needsValues);
    }
   }
  @Test public void shouldPerformBooleanSearch() throws KernelException {
    boolean needsValues=indexProvidesBooleanValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability capability=index.valueCapability(ValueGroup.BOOLEAN.category());
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,false));
      assertFoundNodesAndValue(node,1,uniqueIds,capability,needsValues);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,true));
      assertFoundNodesAndValue(node,1,uniqueIds,capability,needsValues);
    }
   }
  @Test public void shouldPerformTextArraySearch() throws KernelException {
    boolean needsValues=indexProvidesArrayValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability capability=index.valueCapability(ValueGroup.TEXT_ARRAY.category());
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,new String[]{"first","second","third"}));
      assertFoundNodesAndValue(node,1,uniqueIds,capability,needsValues);
      read.nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,new String[]{"fourth","fifth","sixth","seventh"}));
      assertFoundNodesAndValue(node,1,uniqueIds,capability,needsValues);
    }
   }
  @Test public void shouldPerformIndexScan() throws Exception {
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexValueCapability wildcardCapability=index.valueCapability(ValueCategory.UNKNOWN);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexScan(index,node,IndexOrder.NONE,indexProvidesAllValues());
      assertThat(node.numberOfProperties(),equalTo(1));
      assertFoundNodesAndValue(node,TOTAL_NODE_COUNT,uniqueIds,wildcardCapability,indexProvidesAllValues());
    }
   }
  @Test public void shouldRespectOrderCapabilitiesForNumbers() throws Exception {
    boolean needsValues=indexProvidesNumericValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexOrder[] orderCapabilities=index.orderCapability(ValueCategory.NUMBER);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      for (      IndexOrder orderCapability : orderCapabilities) {
        read.nodeIndexSeek(index,node,orderCapability,needsValues,IndexQuery.range(prop,1,true,42,true));
        assertFoundNodesInOrder(node,orderCapability);
      }
    }
   }
  @Test public void shouldRespectOrderCapabilitiesForStrings() throws Exception {
    boolean needsValues=indexProvidesStringValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexOrder[] orderCapabilities=index.orderCapability(ValueCategory.TEXT);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      for (      IndexOrder orderCapability : orderCapabilities) {
        read.nodeIndexSeek(index,node,orderCapability,needsValues,IndexQuery.range(prop,"one",true,"two",true));
        assertFoundNodesInOrder(node,orderCapability);
      }
    }
   }
  @Test public void shouldRespectOrderCapabilitiesForTemporal() throws KernelException {
    boolean needsValues=indexProvidesTemporalValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexOrder[] orderCapabilities=index.orderCapability(ValueCategory.TEMPORAL);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      for (      IndexOrder orderCapability : orderCapabilities) {
        read.nodeIndexSeek(index,node,orderCapability,needsValues,IndexQuery.range(prop,DateValue.date(1986,11,18),true,DateValue.date(1989,3,24),true));
        assertFoundNodesInOrder(node,orderCapability);
      }
    }
   }
  @Test public void shouldRespectOrderCapabilitiesForSpatial() throws KernelException {
    boolean needsValues=indexProvidesSpatialValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexOrder[] orderCapabilities=index.orderCapability(ValueCategory.GEOMETRY);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      for (      IndexOrder orderCapability : orderCapabilities) {
        read.nodeIndexSeek(index,node,orderCapability,needsValues,IndexQuery.range(prop,CoordinateReferenceSystem.Cartesian));
        assertFoundNodesInOrder(node,orderCapability);
      }
    }
   }
  @Test public void shouldRespectOrderCapabilitiesForStringArray() throws KernelException {
    boolean needsValues=indexProvidesSpatialValues();
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexOrder[] orderCapabilities=index.orderCapability(ValueCategory.TEXT_ARRAY);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      for (      IndexOrder orderCapability : orderCapabilities) {
        read.nodeIndexSeek(index,node,orderCapability,needsValues,IndexQuery.range(prop,Values.of(new String[]{"first","second","third"}),true,Values.of(new String[]{"fourth","fifth","sixth","seventh"}),true));
        assertFoundNodesInOrder(node,orderCapability);
      }
    }
   }
  @Test public void shouldRespectOrderCapabilitiesForWildcard() throws Exception {
    boolean needsValues=false;
    int label=token.nodeLabel("Node");
    int prop=token.propertyKey("prop");
    IndexReference index=schemaRead.index(label,prop);
    IndexOrder[] orderCapabilities=index.orderCapability(ValueCategory.UNKNOWN);
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      for (      IndexOrder orderCapability : orderCapabilities) {
        read.nodeIndexSeek(index,node,orderCapability,needsValues,IndexQuery.exists(prop));
        assertFoundNodesInOrder(node,orderCapability);
      }
    }
   }
  @Test public void shouldProvideValuesForPoints() throws Exception {
    Assume.assumeTrue(indexProvidesAllValues());
    int label=token.nodeLabel("What");
    int prop=token.propertyKey("ever");
    IndexReference index=schemaRead.index(label,prop);
    assertEquals(IndexValueCapability.YES,index.valueCapability(ValueCategory.GEOMETRY));
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,true,IndexQuery.range(prop,Cartesian));
      assertFoundNodesAndValue(node,uniqueIds,index.valueCapability(ValueCategory.GEOMETRY),true,whateverPoint);
    }
   }
  @Test public void shouldProvideValuesForAllTypes() throws Exception {
    Assume.assumeTrue(indexProvidesAllValues());
    int label=token.nodeLabel("What");
    int prop=token.propertyKey("ever");
    IndexReference index=schemaRead.index(label,prop);
    assertEquals(IndexValueCapability.YES,index.valueCapability(ValueCategory.UNKNOWN));
    try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
      MutableLongSet uniqueIds=new LongHashSet();
      read.nodeIndexSeek(index,node,IndexOrder.NONE,true,IndexQuery.exists(prop));
      assertFoundNodesAndValue(node,uniqueIds,index.valueCapability(ValueCategory.UNKNOWN),true,nodesOfAllPropertyTypes);
    }
   }
  private void assertFoundNodesInOrder(  NodeValueIndexCursor node,  IndexOrder indexOrder){
    Value currentValue=null;
    while (node.next()) {
      long nodeReference=node.nodeReference();
      Value storedValue=getPropertyValueFromStore(nodeReference);
      if (currentValue != null) {
switch (indexOrder) {
case ASCENDING:
          assertTrue("Requested ordering " + indexOrder + " was not respected.",Values.COMPARATOR.compare(currentValue,storedValue) <= 0);
        break;
case DESCENDING:
      assertTrue("Requested ordering " + indexOrder + " was not respected.",Values.COMPARATOR.compare(currentValue,storedValue) >= 0);
    break;
case NONE:
  break;
default :
throw new UnsupportedOperationException("Can not verify ordering for " + indexOrder);
}
}
currentValue=storedValue;
}
}
private void assertFoundNodesAndValue(NodeValueIndexCursor node,int nodes,MutableLongSet uniqueIds,IndexValueCapability expectValue,boolean indexProvidesValues){
uniqueIds.clear();
for (int i=0; i < nodes; i++) {
assertTrue("at least " + nodes + " nodes, was "+ uniqueIds.size(),node.next());
long nodeReference=node.nodeReference();
assertTrue("all nodes are unique",uniqueIds.add(nodeReference));
if (IndexValueCapability.YES.equals(expectValue)) {
assertTrue("Value capability said index would have value for " + expectValue + ", but didn't",node.hasValue());
}
if (indexProvidesValues) {
assertTrue("Index did not provide values",node.hasValue());
Value storedValue=getPropertyValueFromStore(nodeReference);
assertThat("has correct value",node.propertyValue(0),is(storedValue));
}
}
assertFalse("no more than " + nodes + " nodes",node.next());
}
private void assertFoundNodesAndNoValue(NodeValueIndexCursor node,int nodes,MutableLongSet uniqueIds){
uniqueIds.clear();
for (int i=0; i < nodes; i++) {
assertTrue("at least " + nodes + " nodes, was "+ uniqueIds.size(),node.next());
long nodeReference=node.nodeReference();
assertTrue("all nodes are unique",uniqueIds.add(nodeReference));
}
assertFalse("no more than " + nodes + " nodes",node.next());
}
private void assertFoundNodesAndValue(NodeValueIndexCursor node,MutableLongSet uniqueIds,IndexValueCapability expectValue,boolean indexProvidesValues,long... expected){
assertFoundNodesAndValue(node,expected.length,uniqueIds,expectValue,indexProvidesValues);
for (long expectedNode : expected) {
assertTrue("expected node " + expectedNode,uniqueIds.contains(expectedNode));
}
}
private void assertFoundNodesAndNoValue(NodeValueIndexCursor node,MutableLongSet uniqueIds,long... expected){
assertFoundNodesAndNoValue(node,expected.length,uniqueIds);
for (long expectedNode : expected) {
assertTrue("expected node " + expectedNode,uniqueIds.contains(expectedNode));
}
}
private Value getPropertyValueFromStore(long nodeReference){
try (NodeCursor storeCursor=cursors.allocateNodeCursor();PropertyCursor propertyCursor=cursors.allocatePropertyCursor()){
read.singleNode(nodeReference,storeCursor);
storeCursor.next();
storeCursor.properties(propertyCursor);
propertyCursor.next();
return propertyCursor.propertyValue();
}
 }
@Test public void shouldGetNoIndexForMissingTokens(){
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
int badLabel=token.nodeLabel("BAD_LABEL");
int badProp=token.propertyKey("badProp");
assertEquals("bad label",IndexReference.NO_INDEX,schemaRead.index(badLabel,prop));
assertEquals("bad prop",IndexReference.NO_INDEX,schemaRead.index(label,badProp));
assertEquals("just bad",IndexReference.NO_INDEX,schemaRead.index(badLabel,badProp));
}
@Test public void shouldGetNoIndexForUnknownTokens(){
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
int badLabel=Integer.MAX_VALUE;
int badProp=Integer.MAX_VALUE;
assertEquals("bad label",IndexReference.NO_INDEX,schemaRead.index(badLabel,prop));
assertEquals("bad prop",IndexReference.NO_INDEX,schemaRead.index(label,badProp));
assertEquals("just bad",IndexReference.NO_INDEX,schemaRead.index(badLabel,badProp));
}
@Test public void shouldGetVersionAndKeyFromIndexReference(){
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
assertEquals(providerKey(),index.providerKey());
assertEquals(providerVersion(),index.providerVersion());
}
@Test public void shouldNotFindDeletedNodeInIndexScan() throws Exception {
boolean needsValues=indexProvidesAllValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
IndexValueCapability wildcardCapability=index.valueCapability(ValueCategory.UNKNOWN);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
MutableLongSet uniqueIds=new LongHashSet();
tx.dataRead().nodeIndexScan(index,node,IndexOrder.NONE,needsValues);
assertThat(node.numberOfProperties(),equalTo(1));
assertFoundNodesAndValue(node,TOTAL_NODE_COUNT,uniqueIds,wildcardCapability,needsValues);
tx.dataWrite().nodeDelete(strOne);
tx.dataRead().nodeIndexScan(index,node,IndexOrder.NONE,needsValues);
assertFoundNodesAndValue(node,TOTAL_NODE_COUNT - 1,uniqueIds,wildcardCapability,needsValues);
}
 }
@Test public void shouldNotFindDeletedNodeInIndexSeek() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeDelete(strOne);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"one"));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindDNodeWithRemovedLabelInIndexSeek() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(strOne,label);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"one"));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindUpdatedNodeInIndexSeek() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(strOne,prop,stringValue("ett"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"one"));
assertFalse(node.next());
}
 }
@Test public void shouldFindUpdatedNodeInIndexSeek() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(strOne,prop,stringValue("ett"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"ett"));
assertTrue(node.next());
assertEquals(strOne,node.nodeReference());
}
 }
@Test public void shouldFindSwappedNodeInIndexSeek() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(strOne,label);
tx.dataWrite().nodeAddLabel(strOneNoLabel,label);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(prop,"one"));
assertTrue(node.next());
assertEquals(strOneNoLabel,node.nodeReference());
}
 }
@Test public void shouldNotFindDeletedNodeInRangeSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeDelete(strOne);
tx.dataWrite().nodeDelete(strThree1);
tx.dataWrite().nodeDelete(strThree2);
tx.dataWrite().nodeDelete(strThree3);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",true,"three",true));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindNodeWithRemovedLabelInRangeSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(strOne,label);
tx.dataWrite().nodeRemoveLabel(strThree1,label);
tx.dataWrite().nodeRemoveLabel(strThree2,label);
tx.dataWrite().nodeRemoveLabel(strThree3,label);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",true,"three",true));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindUpdatedNodeInRangeSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(strOne,prop,stringValue("ett"));
tx.dataWrite().nodeSetProperty(strThree1,prop,stringValue("tre"));
tx.dataWrite().nodeSetProperty(strThree2,prop,stringValue("tre"));
tx.dataWrite().nodeSetProperty(strThree3,prop,stringValue("tre"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",true,"three",true));
assertFalse(node.next());
}
 }
@Test public void shouldFindUpdatedNodeInRangeSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(strOne,prop,stringValue("ett"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"ett",true,"tre",true));
assertTrue(node.next());
assertEquals(strOne,node.nodeReference());
}
 }
@Test public void shouldFindSwappedNodeInRangeSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(strOne,label);
tx.dataWrite().nodeAddLabel(strOneNoLabel,label);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.range(prop,"one",true,"ones",true));
assertTrue(node.next());
assertEquals(strOneNoLabel,node.nodeReference());
assertFalse(node.next());
}
 }
@Test public void shouldNotFindDeletedNodeInPrefixSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeDelete(strOne);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringPrefix(prop,stringValue("on")));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindNodeWithRemovedLabelInPrefixSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(strOne,label);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringPrefix(prop,stringValue("on")));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindUpdatedNodeInPrefixSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(strOne,prop,stringValue("ett"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringPrefix(prop,stringValue("on")));
assertFalse(node.next());
}
 }
@Test public void shouldFindUpdatedNodeInPrefixSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(strOne,prop,stringValue("ett"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringPrefix(prop,stringValue("et")));
assertTrue(node.next());
assertEquals(strOne,node.nodeReference());
}
 }
@Test public void shouldFindSwappedNodeInPrefixSearch() throws Exception {
boolean needsValues=indexProvidesStringValues();
int label=token.nodeLabel("Node");
int prop=token.propertyKey("prop");
IndexReference index=schemaRead.index(label,prop);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(strOne,label);
tx.dataWrite().nodeAddLabel(strOneNoLabel,label);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.stringPrefix(prop,stringValue("on")));
assertTrue(node.next());
assertEquals(strOneNoLabel,node.nodeReference());
}
 }
@Test public void shouldNotFindDeletedNodeInCompositeIndex() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Person");
int firstName=token.propertyKey("firstname");
int surname=token.propertyKey("surname");
IndexReference index=schemaRead.index(label,firstName,surname);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeDelete(jackDalton);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(firstName,"Jack"),IndexQuery.exact(surname,"Dalton"));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindNodeWithRemovedLabelInCompositeIndex() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Person");
int firstName=token.propertyKey("firstname");
int surname=token.propertyKey("surname");
IndexReference index=schemaRead.index(label,firstName,surname);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(joeDalton,label);
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(firstName,"Joe"),IndexQuery.exact(surname,"Dalton"));
assertFalse(node.next());
}
 }
@Test public void shouldNotFindUpdatedNodeInCompositeIndex() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Person");
int firstName=token.propertyKey("firstname");
int surname=token.propertyKey("surname");
IndexReference index=schemaRead.index(label,firstName,surname);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(jackDalton,firstName,stringValue("Jesse"));
tx.dataWrite().nodeSetProperty(jackDalton,surname,stringValue("James"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(firstName,"Jack"),IndexQuery.exact(surname,"Dalton"));
assertFalse(node.next());
}
 }
@Test public void shouldFindUpdatedNodeInCompositeIndex() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Person");
int firstName=token.propertyKey("firstname");
int surname=token.propertyKey("surname");
IndexReference index=schemaRead.index(label,firstName,surname);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeSetProperty(jackDalton,firstName,stringValue("Jesse"));
tx.dataWrite().nodeSetProperty(jackDalton,surname,stringValue("James"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(firstName,"Jesse"),IndexQuery.exact(surname,"James"));
assertTrue(node.next());
assertEquals(jackDalton,node.nodeReference());
}
 }
@Test public void shouldFindSwappedNodeInCompositeIndex() throws Exception {
boolean needsValues=false;
int label=token.nodeLabel("Person");
int firstName=token.propertyKey("firstname");
int surname=token.propertyKey("surname");
IndexReference index=schemaRead.index(label,firstName,surname);
try (org.neo4j.internal.kernel.api.Transaction tx=beginTransaction();NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
tx.dataWrite().nodeRemoveLabel(joeDalton,label);
tx.dataWrite().nodeAddLabel(strOneNoLabel,label);
tx.dataWrite().nodeSetProperty(strOneNoLabel,firstName,stringValue("Jesse"));
tx.dataWrite().nodeSetProperty(strOneNoLabel,surname,stringValue("James"));
tx.dataRead().nodeIndexSeek(index,node,IndexOrder.NONE,needsValues,IndexQuery.exact(firstName,"Jesse"),IndexQuery.exact(surname,"James"));
assertTrue(node.next());
assertEquals(strOneNoLabel,node.nodeReference());
}
 }
private long nodeWithProp(GraphDatabaseService graphDb,Object value){
Node node=graphDb.createNode(label("Node"));
node.setProperty("prop",value);
return node.getId();
}
private long nodeWithWhatever(GraphDatabaseService graphDb,Object value){
Node node=graphDb.createNode(label("What"));
node.setProperty("ever",value);
return node.getId();
}
private long nodeWithNoLabel(GraphDatabaseService graphDb,Object value){
Node node=graphDb.createNode();
node.setProperty("prop",value);
return node.getId();
}
private long person(GraphDatabaseService graphDb,String firstName,String surname){
Node node=graphDb.createNode(label("Person"));
node.setProperty("firstname",firstName);
node.setProperty("surname",surname);
return node.getId();
}
}
