@EnableRuleMigrationSupport public class PortRepositoryIT {
  @Rule public final TemporaryFolder temporaryFolder=new TemporaryFolder();
  @Test void shouldReservePorts() throws Exception {
    PortRepository portRepository1=new PortRepository(temporaryDirectory(),EphemeralPortMinimum);
    int port1=portRepository1.reserveNextPort("foo");
    int port2=portRepository1.reserveNextPort("foo");
    int port3=portRepository1.reserveNextPort("foo");
    assertThat(new HashSet<>(asList(port1,port2,port3)).size(),is(3));
  }
  @Test void shouldCoordinateUsingFileSystem() throws Exception {
    Path temporaryDirectory=temporaryDirectory();
    PortRepository portRepository1=new PortRepository(temporaryDirectory,EphemeralPortMinimum);
    PortRepository portRepository2=new PortRepository(temporaryDirectory,EphemeralPortMinimum);
    int port1=portRepository1.reserveNextPort("foo");
    int port2=portRepository1.reserveNextPort("foo");
    int port3=portRepository1.reserveNextPort("foo");
    int port4=portRepository2.reserveNextPort("foo");
    int port5=portRepository2.reserveNextPort("foo");
    int port6=portRepository1.reserveNextPort("foo");
    assertThat(new HashSet<>(asList(port1,port2,port3,port4,port5,port6)).size(),is(6));
  }
  @Test void shouldNotOverrun() throws Exception {
    PortRepository portRepository1=new PortRepository(temporaryDirectory(),65534);
    portRepository1.reserveNextPort("foo");
    portRepository1.reserveNextPort("foo");
    try {
      portRepository1.reserveNextPort("foo");
      fail("Failure was expected");
    }
 catch (    IllegalStateException e) {
      assertThat(e.getMessage(),is("There are no more ports available"));
    }
  }
  private Path temporaryDirectory() throws IOException {
    return temporaryFolder.newFolder("port-repository").toPath();
  }
}
