public class TreeNodeDynamicSizeTest extends TreeNodeTestBase<RawBytes,RawBytes> {
  private SimpleByteArrayLayout layout=new SimpleByteArrayLayout();
  @Override protected TestLayout<RawBytes,RawBytes> getLayout(){
    return layout;
  }
  @Override protected TreeNodeDynamicSize<RawBytes,RawBytes> getNode(  int pageSize,  Layout<RawBytes,RawBytes> layout){
    return new TreeNodeDynamicSize<>(pageSize,layout);
  }
  @Override void assertAdditionalHeader(  PageCursor cursor,  TreeNode<RawBytes,RawBytes> node,  int pageSize){
    int currentAllocSpace=((TreeNodeDynamicSize)node).getAllocOffset(cursor);
    assertEquals(pageSize,currentAllocSpace,"allocSpace point to end of page");
  }
  @Test void mustCompactKeyValueSizeHeader(){
    int oneByteKeyMax=DynamicSizeUtil.MASK_ONE_BYTE_KEY_SIZE;
    int oneByteValueMax=DynamicSizeUtil.MASK_ONE_BYTE_VALUE_SIZE;
    TreeNodeDynamicSize<RawBytes,RawBytes> node=getNode(PAGE_SIZE,layout);
    verifyOverhead(node,oneByteKeyMax,0,1);
    verifyOverhead(node,oneByteKeyMax,1,2);
    verifyOverhead(node,oneByteKeyMax,oneByteValueMax,2);
    verifyOverhead(node,oneByteKeyMax,oneByteValueMax + 1,3);
    verifyOverhead(node,oneByteKeyMax + 1,0,2);
    verifyOverhead(node,oneByteKeyMax + 1,1,3);
    verifyOverhead(node,oneByteKeyMax + 1,oneByteValueMax,3);
    verifyOverhead(node,oneByteKeyMax + 1,oneByteValueMax + 1,4);
  }
  private void verifyOverhead(  TreeNodeDynamicSize<RawBytes,RawBytes> node,  int keySize,  int valueSize,  int expectedOverhead){
    cursor.zapPage();
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    RawBytes key=layout.newKey();
    RawBytes value=layout.newValue();
    key.bytes=new byte[keySize];
    value.bytes=new byte[valueSize];
    int allocOffsetBefore=node.getAllocOffset(cursor);
    node.insertKeyValueAt(cursor,key,value,0,0);
    int allocOffsetAfter=node.getAllocOffset(cursor);
    assertEquals(allocOffsetBefore - keySize - valueSize- expectedOverhead,allocOffsetAfter);
  }
}
