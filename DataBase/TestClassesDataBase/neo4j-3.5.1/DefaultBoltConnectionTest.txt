public class DefaultBoltConnectionTest {
  private final AssertableLogProvider logProvider=new AssertableLogProvider();
  private final LogService logService=new SimpleLogService(logProvider);
  private final BoltConnectionLifetimeListener connectionListener=mock(BoltConnectionLifetimeListener.class);
  private final BoltConnectionQueueMonitor queueMonitor=mock(BoltConnectionQueueMonitor.class);
  private final EmbeddedChannel channel=new EmbeddedChannel();
  private BoltChannel boltChannel;
  private BoltStateMachine stateMachine;
  @Rule public OtherThreadRule<Boolean> otherThread=new OtherThreadRule<>();
  @Before public void setup(){
    boltChannel=new BoltChannel("bolt-1","bolt",channel);
    stateMachine=mock(BoltStateMachine.class);
    when(stateMachine.shouldStickOnThread()).thenReturn(false);
    when(stateMachine.hasOpenStatement()).thenReturn(false);
  }
  @After public void cleanup(){
    channel.finishAndReleaseAll();
  }
  @Test public void idShouldReturnBoltChannelId(){
    BoltConnection connection=newConnection();
    assertEquals(boltChannel.id(),connection.id());
  }
  @Test public void localAddressShouldReturnBoltServerAddress(){
    BoltConnection connection=newConnection();
    assertEquals(boltChannel.serverAddress(),connection.localAddress());
  }
  @Test public void remoteAddressShouldReturnBoltClientAddress(){
    BoltConnection connection=newConnection();
    assertEquals(boltChannel.clientAddress(),connection.remoteAddress());
  }
  @Test public void channelShouldReturnBoltRawChannel(){
    BoltConnection connection=newConnection();
    assertEquals(boltChannel.rawChannel(),connection.channel());
  }
  @Test public void hasPendingJobsShouldReportFalseWhenInitialised(){
    BoltConnection connection=newConnection();
    assertFalse(connection.hasPendingJobs());
  }
  @Test public void startShouldNotifyListener(){
    BoltConnection connection=newConnection();
    connection.start();
    verify(connectionListener).created(connection);
  }
  @Test public void stopShouldNotifyListenerOnTheNextBatch(){
    BoltConnection connection=newConnection();
    connection.start();
    connection.stop();
    connection.processNextBatch();
    verify(connectionListener).closed(connection);
  }
  @Test public void enqueuedShouldNotifyQueueMonitor(){
    Job job=Jobs.noop();
    BoltConnection connection=newConnection();
    connection.enqueue(job);
    verify(queueMonitor).enqueued(connection,job);
  }
  @Test public void enqueuedShouldQueueJob(){
    Job job=Jobs.noop();
    BoltConnection connection=newConnection();
    connection.enqueue(job);
    assertTrue(connection.hasPendingJobs());
  }
  @Test public void processNextBatchShouldDoNothingIfQueueIsEmptyAndConnectionNotClosed(){
    BoltConnection connection=newConnection();
    connection.processNextBatch();
    verify(queueMonitor,never()).drained(same(connection),anyCollection());
  }
  @Test public void processNextBatchShouldNotifyQueueMonitorAboutDrain(){
    List<Job> drainedJobs=new ArrayList<>();
    Job job=Jobs.noop();
    BoltConnection connection=newConnection();
    doAnswer(inv -> drainedJobs.addAll(inv.getArgument(1))).when(queueMonitor).drained(same(connection),anyCollection());
    connection.enqueue(job);
    connection.processNextBatch();
    verify(queueMonitor).drained(same(connection),anyCollection());
    assertTrue(drainedJobs.contains(job));
  }
  @Test public void processNextBatchShouldDrainMaxBatchSizeItemsOnEachCall(){
    List<Job> drainedJobs=new ArrayList<>();
    List<Job> pushedJobs=new ArrayList<>();
    BoltConnection connection=newConnection(10);
    doAnswer(inv -> drainedJobs.addAll(inv.getArgument(1))).when(queueMonitor).drained(same(connection),anyCollection());
    for (int i=0; i < 15; i++) {
      Job newJob=Jobs.noop();
      pushedJobs.add(newJob);
      connection.enqueue(newJob);
    }
    connection.processNextBatch();
    verify(queueMonitor).drained(same(connection),anyCollection());
    assertEquals(10,drainedJobs.size());
    assertTrue(drainedJobs.containsAll(pushedJobs.subList(0,10)));
    drainedJobs.clear();
    connection.processNextBatch();
    verify(queueMonitor,times(2)).drained(same(connection),anyCollection());
    assertEquals(5,drainedJobs.size());
    assertTrue(drainedJobs.containsAll(pushedJobs.subList(10,15)));
  }
  @Test public void interruptShouldInterruptStateMachine(){
    BoltConnection connection=newConnection();
    connection.interrupt();
    verify(stateMachine).interrupt();
  }
  @Test public void stopShouldFirstMarkStateMachineForTermination(){
    BoltConnection connection=newConnection();
    connection.stop();
    verify(stateMachine).markForTermination();
    verify(queueMonitor).enqueued(ArgumentMatchers.eq(connection),ArgumentMatchers.any(Job.class));
  }
  @Test public void stopShouldCloseStateMachineOnProcessNextBatch(){
    BoltConnection connection=newConnection();
    connection.stop();
    connection.processNextBatch();
    verify(queueMonitor).enqueued(ArgumentMatchers.eq(connection),ArgumentMatchers.any(Job.class));
    verify(stateMachine).markForTermination();
    verify(stateMachine).close();
  }
  @Test public void stopShouldCloseStateMachineIfEnqueueEndsWithRejectedExecutionException(){
    BoltConnection connection=newConnection();
    doAnswer(i -> {
      connection.handleSchedulingError(new RejectedExecutionException());
      return null;
    }
).when(queueMonitor).enqueued(ArgumentMatchers.eq(connection),ArgumentMatchers.any(Job.class));
    connection.stop();
    verify(stateMachine).markForTermination();
    verify(stateMachine).close();
  }
  @Test public void shouldLogBoltConnectionAuthFatalityError(){
    BoltConnection connection=newConnection();
    connection.enqueue(machine -> {
      throw new BoltConnectionAuthFatality(new AuthenticationException(Status.Security.Unauthorized,"inner error"));
    }
);
    connection.processNextBatch();
    verify(stateMachine).close();
    logProvider.assertExactly(AssertableLogProvider.inLog(containsString(BoltServer.class.getPackage().getName())).warn(containsString("inner error")));
  }
  @Test public void processNextBatchShouldCloseConnectionOnFatalAuthenticationError(){
    BoltConnection connection=newConnection();
    connection.enqueue(machine -> {
      throw new BoltConnectionAuthFatality("auth failure",new RuntimeException("inner error"));
    }
);
    connection.processNextBatch();
    verify(stateMachine).close();
    logProvider.assertNone(AssertableLogProvider.inLog(containsString(BoltServer.class.getPackage().getName())).warn(any(String.class)));
  }
  @Test public void processNextBatchShouldCloseConnectionAndLogOnFatalBoltError(){
    BoltConnectionFatality exception=new BoltProtocolBreachFatality("fatal bolt error");
    BoltConnection connection=newConnection();
    connection.enqueue(machine -> {
      throw exception;
    }
);
    connection.processNextBatch();
    verify(stateMachine).close();
    logProvider.assertExactly(AssertableLogProvider.inLog(containsString(BoltServer.class.getPackage().getName())).error(containsString("Protocol breach detected in bolt session"),is(exception)));
  }
  @Test public void processNextBatchShouldCloseConnectionAndLogOnUnexpectedException(){
    RuntimeException exception=new RuntimeException("unexpected exception");
    BoltConnection connection=newConnection();
    connection.enqueue(machine -> {
      throw exception;
    }
);
    connection.processNextBatch();
    verify(stateMachine).close();
    logProvider.assertExactly(AssertableLogProvider.inLog(containsString(BoltServer.class.getPackage().getName())).error(containsString("Unexpected error detected in bolt session"),is(exception)));
  }
  @Test public void processNextBatchShouldThrowAssertionErrorIfStatementOpen() throws Exception {
    BoltConnection connection=newConnection(1);
    connection.enqueue(Jobs.noop());
    connection.enqueue(Jobs.noop());
    when(stateMachine.hasOpenStatement()).thenReturn(true);
    connection.processNextBatch();
    logProvider.assertExactly(AssertableLogProvider.inLog(DefaultBoltConnection.class.getName()).error(startsWith("Unexpected error"),isA(AssertionError.class)));
  }
  @Test public void processNextBatchShouldNotThrowAssertionErrorIfStatementOpenButStopping() throws Exception {
    BoltConnection connection=newConnection(1);
    connection.enqueue(Jobs.noop());
    connection.enqueue(Jobs.noop());
    when(stateMachine.hasOpenStatement()).thenReturn(true);
    connection.stop();
    connection.processNextBatch();
    logProvider.assertNone(AssertableLogProvider.inLog(DefaultBoltConnection.class.getName()).error(startsWith("Unexpected error"),isA(AssertionError.class)));
  }
  @Test public void processNextBatchShouldReturnWhenConnectionIsStopped() throws Exception {
    BoltConnection connection=newConnection(1);
    connection.enqueue(Jobs.noop());
    connection.enqueue(Jobs.noop());
    when(stateMachine.shouldStickOnThread()).thenReturn(true);
    Future<Boolean> future=otherThread.execute(state -> connection.processNextBatch());
    connection.stop();
    otherThread.get().awaitFuture(future);
    verify(stateMachine).close();
  }
  private DefaultBoltConnection newConnection(){
    return newConnection(10);
  }
  private DefaultBoltConnection newConnection(  int maxBatchSize){
    return new DefaultBoltConnection(boltChannel,mock(PackOutput.class),stateMachine,logService,connectionListener,queueMonitor,maxBatchSize);
  }
}
