public class StageTest {
  @Test public void shouldReceiveBatchesInOrder(){
    Configuration config=new Configuration.Overridden(DEFAULT){
      @Override public int batchSize(){
        return 10;
      }
    }
;
    Stage stage=new Stage("Test stage",null,config,ORDER_SEND_DOWNSTREAM);
    long batches=1000;
    final long items=batches * config.batchSize();
    stage.add(new PullingProducerStep(stage.control(),config){
      private final Object theObject=new Object();
      private long i;
      @Override protected Object nextBatchOrNull(      long ticket,      int batchSize){
        if (i >= items) {
          return null;
        }
        Object[] batch=new Object[batchSize];
        Arrays.fill(batch,theObject);
        i+=batchSize;
        return batch;
      }
      @Override protected long position(){
        return 0;
      }
    }
);
    for (int i=0; i < 3; i++) {
      stage.add(new ReceiveOrderAssertingStep(stage.control(),"Step" + i,config,i,false));
    }
    stage.add(new ReceiveOrderAssertingStep(stage.control(),"Final step",config,0,true));
    StageExecution execution=stage.execute();
    for (    Step<?> step : execution.steps()) {
      step.processors(1);
    }
    new ExecutionSupervisor(ExecutionMonitors.invisible()).supervise(execution);
    for (    Step<?> step : execution.steps()) {
      assertEquals("For " + step,batches,step.stats().stat(Keys.done_batches).asLong());
    }
    stage.close();
  }
private static class ReceiveOrderAssertingStep extends ProcessorStep<Object> {
    private final AtomicLong lastTicket=new AtomicLong();
    private final long processingTime;
    private final boolean endOfLine;
    ReceiveOrderAssertingStep(    StageControl control,    String name,    Configuration config,    long processingTime,    boolean endOfLine){
      super(control,name,config,1);
      this.processingTime=processingTime;
      this.endOfLine=endOfLine;
    }
    @Override public long receive(    long ticket,    Object batch){
      assertEquals("For " + batch + " in "+ name(),lastTicket.getAndIncrement(),ticket);
      return super.receive(ticket,batch);
    }
    @Override protected void process(    Object batch,    BatchSender sender){
      try {
        Thread.sleep(processingTime);
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
      if (!endOfLine) {
        sender.send(batch);
      }
    }
  }
}
