public class CountsRotationTest {
  private final Label A=Label.label("A");
  private final Label B=Label.label("B");
  private final Label C=Label.label("C");
  private final PageCacheRule pcRule=new PageCacheRule();
  private final EphemeralFileSystemRule fsRule=new EphemeralFileSystemRule();
  private final TestDirectory testDir=TestDirectory.testDirectory(getClass(),fsRule.get());
  private final ThreadingRule threadingRule=new ThreadingRule();
  @Rule public RuleChain ruleChain=RuleChain.outerRule(threadingRule).around(pcRule).around(fsRule).around(testDir);
  private FileSystemAbstraction fs;
  private GraphDatabaseBuilder dbBuilder;
  private PageCache pageCache;
  @Before public void setup(){
    fs=fsRule.get();
    dbBuilder=new TestGraphDatabaseFactory().setFileSystem(new UncloseableDelegatingFileSystemAbstraction(fs)).newImpermanentDatabaseBuilder(testDir.databaseDir());
    pageCache=pcRule.getPageCache(fs);
  }
  @Test public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase(){
    GraphDatabaseAPI db=(GraphDatabaseAPI)dbBuilder.newGraphDatabase();
    db.shutdown();
    assertTrue(fs.fileExists(alphaStoreFile()));
    assertFalse(fs.fileExists(betaStoreFile()));
    try (Lifespan life=new Lifespan()){
      CountsTracker store=life.add(createCountsTracker(pageCache));
      assertEquals(BASE_TX_ID,store.txId());
      assertEquals(INITIAL_MINOR_VERSION,store.minorVersion());
      assertEquals(0,store.totalEntriesStored());
      assertEquals(0,allRecords(store).size());
    }
     try (Lifespan life=new Lifespan()){
      CountsTracker store=life.add(createCountsTracker(pageCache));
      assertEquals(BASE_TX_ID,store.txId());
      assertEquals(INITIAL_MINOR_VERSION,store.minorVersion());
      assertEquals(0,store.totalEntriesStored());
      assertEquals(0,allRecords(store).size());
    }
   }
  @Test public void shouldUnMapThePrestateFileWhenTimingOutOnRotationAndAllowForShutdownInTheFailedRotationState() throws Throwable {
    dbBuilder.newGraphDatabase().shutdown();
    CountsTracker store=createCountsTracker(pageCache,Config.defaults(GraphDatabaseSettings.counts_store_rotation_timeout,"100ms"));
    try (Lifespan lifespan=new Lifespan(store)){
      try (CountsAccessor.Updater updater=store.apply(2).get()){
        updater.incrementNodeCount(0,1);
      }
       try {
        store.rotate(3);
        fail("should have thrown");
      }
 catch (      RotationTimeoutException ex) {
      }
    }
     pageCache.close();
  }
  @Test public void rotationShouldNotCauseUnmappedFileProblem() throws IOException {
    GraphDatabaseAPI db=(GraphDatabaseAPI)dbBuilder.newGraphDatabase();
    DependencyResolver resolver=db.getDependencyResolver();
    RecordStorageEngine storageEngine=resolver.resolveDependency(RecordStorageEngine.class);
    CountsTracker countStore=storageEngine.testAccessNeoStores().getCounts();
    AtomicBoolean workerContinueFlag=new AtomicBoolean(true);
    AtomicLong lookupsCounter=new AtomicLong();
    int rotations=100;
    for (int i=0; i < 5; i++) {
      threadingRule.execute(countStoreLookup(workerContinueFlag,lookupsCounter),countStore);
    }
    long startTxId=countStore.txId();
    for (int i=1; (i < rotations) || (lookupsCounter.get() == 0); i++) {
      try (Transaction tx=db.beginTx()){
        db.createNode(B);
        tx.success();
      }
       checkPoint(db);
    }
    workerContinueFlag.set(false);
    assertEquals("Should perform at least 100 rotations.",rotations,Math.min(rotations,countStore.txId() - startTxId));
    assertTrue("Should perform more then 0 lookups without exceptions.",lookupsCounter.get() > 0);
    db.shutdown();
  }
  private static ThrowingFunction<CountsTracker,Void,RuntimeException> countStoreLookup(  AtomicBoolean workerContinueFlag,  AtomicLong lookups){
    return countsTracker -> {
      while (workerContinueFlag.get()) {
        Register.DoubleLongRegister register=Registers.newDoubleLongRegister();
        countsTracker.get(CountsKeyFactory.nodeKey(0),register);
        lookups.incrementAndGet();
      }
      return null;
    }
;
  }
  @Test public void shouldRotateCountsStoreWhenClosingTheDatabase(){
    GraphDatabaseAPI db=(GraphDatabaseAPI)dbBuilder.newGraphDatabase();
    try (Transaction tx=db.beginTx()){
      db.createNode(A);
      tx.success();
    }
     db.shutdown();
    assertTrue(fs.fileExists(alphaStoreFile()));
    assertTrue(fs.fileExists(betaStoreFile()));
    try (Lifespan life=new Lifespan()){
      CountsTracker store=life.add(createCountsTracker(pageCache));
      assertEquals(BASE_TX_ID + 1 + 1,store.txId());
      assertEquals(INITIAL_MINOR_VERSION,store.minorVersion());
      assertEquals(1 + 1,store.totalEntriesStored());
      assertEquals(1 + 1,allRecords(store).size());
    }
   }
  @Test public void shouldRotateCountsStoreWhenRotatingLog() throws IOException {
    GraphDatabaseAPI db=(GraphDatabaseAPI)dbBuilder.newGraphDatabase();
    try (Transaction tx=db.beginTx()){
      db.createNode(B);
      tx.success();
    }
     checkPoint(db);
    try (Transaction tx=db.beginTx()){
      db.createNode(C);
      tx.success();
    }
     assertTrue(fs.fileExists(alphaStoreFile()));
    assertTrue(fs.fileExists(betaStoreFile()));
    final PageCache pageCache=db.getDependencyResolver().resolveDependency(PageCache.class);
    try (Lifespan life=new Lifespan()){
      CountsTracker store=life.add(createCountsTracker(pageCache));
      assertEquals(BASE_TX_ID + 1 + 1,store.txId());
      assertEquals(INITIAL_MINOR_VERSION,store.minorVersion());
      assertEquals(1 + 1,store.totalEntriesStored());
      assertEquals(1 + 1,allRecords(store).size());
    }
     final CountsTracker tracker=db.getDependencyResolver().resolveDependency(RecordStorageEngine.class).testAccessNeoStores().getCounts();
    assertEquals(1 + 1,tracker.nodeCount(-1,newDoubleLongRegister()).readSecond());
    int labelId;
    try (Transaction tx=db.beginTx()){
      KernelTransaction transaction=db.getDependencyResolver().resolveDependency(ThreadToStatementContextBridge.class).getKernelTransactionBoundToThisThread(true);
      labelId=transaction.tokenRead().nodeLabel(C.name());
    }
     assertEquals(1,tracker.nodeCount(labelId,newDoubleLongRegister()).readSecond());
    db.shutdown();
  }
  @Test(timeout=60_000) public void possibleToShutdownDbWhenItIsNotHealthyAndNotAllTransactionsAreApplied() throws Exception {
    ClassGuardedAdversary adversary=new ClassGuardedAdversary(new CountingAdversary(1,true),NodeStore.class);
    adversary.disable();
    GraphDatabaseService db=AdversarialPageCacheGraphDatabaseFactory.create(fs,adversary).newEmbeddedDatabaseBuilder(testDir.databaseDir()).newGraphDatabase();
    CountDownLatch txStartLatch=new CountDownLatch(1);
    CountDownLatch txCommitLatch=new CountDownLatch(1);
    Future<?> result=ForkJoinPool.commonPool().submit(() -> {
      try (Transaction tx=db.beginTx()){
        txStartLatch.countDown();
        db.createNode();
        await(txCommitLatch);
        tx.success();
      }
     }
);
    await(txStartLatch);
    adversary.enable();
    txCommitLatch.countDown();
    try {
      result.get();
      fail("Exception expected");
    }
 catch (    ExecutionException ee) {
      assertThat(ee.getCause(),instanceOf(TransactionFailureException.class));
    }
    adversary.disable();
    db.shutdown();
  }
  private static void await(  CountDownLatch latch){
    try {
      boolean result=latch.await(30,TimeUnit.SECONDS);
      if (!result) {
        throw new RuntimeException("Count down did not happen. Current count: " + latch.getCount());
      }
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  private CountsTracker createCountsTracker(  PageCache pageCache){
    return createCountsTracker(pageCache,Config.defaults());
  }
  private CountsTracker createCountsTracker(  PageCache pageCache,  Config config){
    return new CountsTracker(NullLogProvider.getInstance(),fs,pageCache,config,testDir.databaseLayout(),EmptyVersionContextSupplier.EMPTY);
  }
  private static void checkPoint(  GraphDatabaseAPI db) throws IOException {
    TriggerInfo triggerInfo=new SimpleTriggerInfo("test");
    db.getDependencyResolver().resolveDependency(CheckPointer.class).forceCheckPoint(triggerInfo);
  }
  private File alphaStoreFile(){
    return testDir.databaseLayout().countStoreA();
  }
  private File betaStoreFile(){
    return testDir.databaseLayout().countStoreB();
  }
  private Collection<Pair<? extends CountsKey,Long>> allRecords(  CountsVisitor.Visitable store){
    final Collection<Pair<? extends CountsKey,Long>> records=new ArrayList<>();
    store.accept(new CountsVisitor(){
      @Override public void visitNodeCount(      int labelId,      long count){
        records.add(Pair.of(CountsKeyFactory.nodeKey(labelId),count));
      }
      @Override public void visitRelationshipCount(      int startLabelId,      int typeId,      int endLabelId,      long count){
        records.add(Pair.of(CountsKeyFactory.relationshipKey(startLabelId,typeId,endLabelId),count));
      }
      @Override public void visitIndexStatistics(      long indexId,      long updates,      long size){
        records.add(Pair.of(CountsKeyFactory.indexStatisticsKey(indexId),size));
      }
      @Override public void visitIndexSample(      long indexId,      long unique,      long size){
        records.add(Pair.of(CountsKeyFactory.indexSampleKey(indexId),size));
      }
    }
);
    return records;
  }
}
