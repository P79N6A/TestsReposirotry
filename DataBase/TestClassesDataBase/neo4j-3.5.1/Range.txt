@Ignore("Not a test. This is a compatibility suite") public static class Range extends CompositeRandomizedIndexAccessorCompatibility {
  public Range(  IndexProviderCompatibilityTestSuite testSuite){
    super(testSuite,TestIndexDescriptorFactory.forLabel(1000,100,101));
  }
  /** 
 * All entries in composite index look like (booleanValue, randomValue ). Range queries in composite only work if all predicates before it is exact. We use boolean values for exact part so that we get some real ranges to work on in second composite slot where the random values are.
 */
  @Test public void testRangeMatchOnRandomValues() throws Exception {
    Assume.assumeTrue("Assume support for granular composite queries",testSuite.supportsGranularCompositeQueries());
    ValueType[] types=randomSetOfSupportedAndSortableTypes();
    List<ValueTuple> values=generateValuesFromType(types);
    List<IndexEntryUpdate<?>> updates=generateUpdatesFromValues(values);
    updateAndCommit(updates);
    TreeSet<IndexEntryUpdate> sortedValues=new TreeSet<>((u1,u2) -> ValueTuple.COMPARATOR.compare(ValueTuple.of(u1.values()[0],u1.values()[1]),ValueTuple.of(u2.values()[0],u2.values()[1])));
    sortedValues.addAll(updates);
    for (int i=0; i < 100; i++) {
      Value booleanValue=random.randomValues().nextBooleanValue();
      ValueType type=random.among(types);
      Value from=random.randomValues().nextValueOfType(type);
      Value to=random.randomValues().nextValueOfType(type);
      if (Values.COMPARATOR.compare(from,to) > 0) {
        Value tmp=from;
        from=to;
        to=tmp;
      }
      boolean fromInclusive=random.nextBoolean();
      boolean toInclusive=random.nextBoolean();
      List<Long> expectedIds=expectedIds(sortedValues,booleanValue,from,to,fromInclusive,toInclusive);
      IndexQuery[] predicates=new IndexQuery[]{IndexQuery.exact(100,booleanValue),IndexQuery.range(101,from,fromInclusive,to,toInclusive)};
      ValueCategory[] valueCategories=getValueCategories(predicates);
      IndexOrder[] indexOrders=indexProvider.getCapability(descriptor).orderCapability(valueCategories);
      for (      IndexOrder order : indexOrders) {
        List<Long> actualIds=assertInOrder(order,predicates);
        actualIds.sort(Long::compare);
        assertThat(actualIds,equalTo(expectedIds));
      }
    }
  }
  public ValueCategory[] getValueCategories(  IndexQuery[] predicates){
    return Arrays.stream(predicates).map(iq -> iq.valueGroup().category()).toArray(ValueCategory[]::new);
  }
  public List<Long> expectedIds(  TreeSet<IndexEntryUpdate> sortedValues,  Value booleanValue,  Value from,  Value to,  boolean fromInclusive,  boolean toInclusive){
    return sortedValues.subSet(add(0,descriptor.schema(),booleanValue,from),fromInclusive,add(0,descriptor.schema(),booleanValue,to),toInclusive).stream().map(IndexEntryUpdate::getEntityId).sorted(Long::compare).collect(Collectors.toList());
  }
  private List<ValueTuple> generateValuesFromType(  ValueType[] types){
    List<ValueTuple> values=new ArrayList<>();
    Set<ValueTuple> duplicateChecker=new HashSet<>();
    for (long i=0; i < 30_000; i++) {
      ValueTuple value;
      do {
        value=ValueTuple.of(random.randomValues().nextBooleanValue(),random.randomValues().nextValueOfTypes(types));
      }
 while (!duplicateChecker.add(value));
      values.add(value);
    }
    return values;
  }
  private List<IndexEntryUpdate<?>> generateUpdatesFromValues(  List<ValueTuple> values){
    List<IndexEntryUpdate<?>> updates=new ArrayList<>();
    int id=0;
    for (    ValueTuple value : values) {
      updates.add(add(id++,descriptor.schema(),(Object[])value.getValues()));
    }
    return updates;
  }
}
