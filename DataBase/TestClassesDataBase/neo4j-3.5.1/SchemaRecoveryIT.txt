public class SchemaRecoveryIT {
  @Test public void schemaTransactionsShouldSurviveRecovery() throws Exception {
    File storeDir=testDirectory.absolutePath();
    Process process=new CreateConstraintButDoNotShutDown().start(storeDir);
    process.waitForSchemaTransactionCommitted();
    SubProcess.kill(process);
    GraphDatabaseService recoveredDatabase=new TestGraphDatabaseFactory().newEmbeddedDatabase(storeDir);
    assertEquals(1,constraints(recoveredDatabase).size());
    assertEquals(1,indexes(recoveredDatabase).size());
    recoveredDatabase.shutdown();
  }
  @Rule public TestDirectory testDirectory=TestDirectory.testDirectory();
  private List<ConstraintDefinition> constraints(  GraphDatabaseService database){
    try (Transaction ignored=database.beginTx()){
      return Iterables.asList(database.schema().getConstraints());
    }
   }
  private List<IndexDefinition> indexes(  GraphDatabaseService database){
    try (Transaction ignored=database.beginTx()){
      return Iterables.asList(database.schema().getIndexes());
    }
   }
public interface Process {
    void waitForSchemaTransactionCommitted() throws InterruptedException ;
  }
static class CreateConstraintButDoNotShutDown extends SubProcess<Process,File> implements Process {
    private volatile boolean started;
    @Override protected void startup(    File storeDir){
      GraphDatabaseService database=new TestGraphDatabaseFactory().newEmbeddedDatabase(storeDir);
      try (Transaction transaction=database.beginTx()){
        database.schema().constraintFor(label("User")).assertPropertyIsUnique("uuid").create();
        transaction.success();
      }
       started=true;
    }
    @Override public void waitForSchemaTransactionCommitted() throws InterruptedException {
      while (!started) {
        Thread.sleep(10);
      }
    }
  }
}
