@ExtendWith(RandomExtension.class) class GapFreeAllEntriesLabelScanReaderTest {
  private static final int EMPTY_RANGE=0;
  private static final int NON_EMPTY_RANGE=0b10101;
  private static final int RANGE_SIZE=10;
  private static final long[] LABEL_IDS=new long[]{1};
  @Inject private RandomRule random;
  @Test void shouldFillGapInBeginning(){
    int[] ranges=array(EMPTY_RANGE,EMPTY_RANGE,NON_EMPTY_RANGE);
    GapFreeAllEntriesLabelScanReader reader=newGapFreeAllEntriesLabelScanReader(ranges);
    Iterator<NodeLabelRange> iterator=reader.iterator();
    assertRanges(iterator,ranges);
  }
  @Test void shouldFillGapInEnd(){
    int[] ranges=array(NON_EMPTY_RANGE,EMPTY_RANGE,EMPTY_RANGE);
    GapFreeAllEntriesLabelScanReader reader=newGapFreeAllEntriesLabelScanReader(ranges);
    Iterator<NodeLabelRange> iterator=reader.iterator();
    assertRanges(iterator,ranges);
  }
  @Test void shouldFillGapInMiddle(){
    int[] ranges=array(EMPTY_RANGE,NON_EMPTY_RANGE,EMPTY_RANGE);
    GapFreeAllEntriesLabelScanReader reader=newGapFreeAllEntriesLabelScanReader(ranges);
    Iterator<NodeLabelRange> iterator=reader.iterator();
    assertRanges(iterator,ranges);
  }
  @Test void shouldFillRandomGaps(){
    int numberOfRanges=random.intBetween(50,100);
    int[] ranges=new int[numberOfRanges];
    for (int rangeId=0; rangeId < numberOfRanges; rangeId++) {
      ranges[rangeId]=random.nextInt(1 << RANGE_SIZE);
    }
    GapFreeAllEntriesLabelScanReader reader=newGapFreeAllEntriesLabelScanReader(ranges);
    Iterator<NodeLabelRange> iterator=reader.iterator();
    assertRanges(iterator,ranges);
  }
  private static void assertRanges(  Iterator<NodeLabelRange> iterator,  int[] expectedRanges){
    for (int expectedRangeId=0; expectedRangeId < expectedRanges.length; expectedRangeId++) {
      assertTrue(iterator.hasNext());
      NodeLabelRange actualRange=iterator.next();
      assertEquals(expectedRangeId,actualRange.id());
      int expectedRange=expectedRanges[expectedRangeId];
      long baseNodeId=expectedRangeId * RANGE_SIZE;
      for (int i=0; i < RANGE_SIZE; i++) {
        long nodeId=baseNodeId + i;
        long[] expectedLabelIds=(expectedRange & (1 << i)) == 0 ? EMPTY_LONG_ARRAY : LABEL_IDS;
        assertArrayEquals(expectedLabelIds,actualRange.labels(nodeId));
        assertEquals(nodeId,actualRange.nodes()[i]);
      }
    }
    assertFalse(iterator.hasNext());
  }
  private static GapFreeAllEntriesLabelScanReader newGapFreeAllEntriesLabelScanReader(  int... ranges){
    return new GapFreeAllEntriesLabelScanReader(ranges(RANGE_SIZE,ranges),RANGE_SIZE * ranges.length);
  }
  private static AllEntriesLabelScanReader ranges(  int rangeSize,  int... ranges){
    List<NodeLabelRange> rangeList=new ArrayList<>();
    for (int rangeId=0; rangeId < ranges.length; rangeId++) {
      rangeList.add(new NodeLabelRange(rangeId,labelsPerNode(ranges[rangeId])));
    }
    return new AllEntriesLabelScanReader(){
      @Override public void close(){
      }
      @Override public Iterator<NodeLabelRange> iterator(){
        return rangeList.iterator();
      }
      @Override public long maxCount(){
        return ranges.length * rangeSize;
      }
      @Override public int rangeSize(){
        return RANGE_SIZE;
      }
    }
;
  }
  private static long[][] labelsPerNode(  int relativeNodeIds){
    long[][] result=new long[RANGE_SIZE][];
    for (int i=0; i < RANGE_SIZE; i++) {
      if ((relativeNodeIds & (1 << i)) != 0) {
        result[i]=LABEL_IDS;
      }
    }
    return result;
  }
  private static int[] array(  int... relativeNodeIds){
    return relativeNodeIds;
  }
}
