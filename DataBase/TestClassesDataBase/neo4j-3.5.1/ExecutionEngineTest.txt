public class ExecutionEngineTest {
  private static final MapValue NO_PARAMS=VirtualValues.emptyMap();
  @Rule public DatabaseRule database=new ImpermanentDatabaseRule();
  @Test public void shouldConvertListsAndMapsWhenPassingFromScalaToJava() throws Exception {
    GraphDatabaseQueryService graph=new GraphDatabaseCypherService(this.database.getGraphDatabaseAPI());
    DependencyResolver resolver=graph.getDependencyResolver();
    Monitors monitors=resolver.resolveDependency(Monitors.class);
    NullLogProvider nullLogProvider=NullLogProvider.getInstance();
    Config config=resolver.resolveDependency(Config.class);
    CypherConfiguration cypherConfig=CypherConfiguration.fromConfig(config);
    CommunityCompilerFactory compilerFactory=new CommunityCompilerFactory(graph,monitors,nullLogProvider,cypherConfig.toCypherPlannerConfiguration(config),cypherConfig.toCypherRuntimeConfiguration());
    ExecutionEngine executionEngine=new ExecutionEngine(graph,nullLogProvider,compilerFactory);
    Result result;
    try (InternalTransaction tx=graph.beginTransaction(KernelTransaction.Type.implicit,LoginContext.AUTH_DISABLED)){
      String query="RETURN { key : 'Value' , collectionKey: [{ inner: 'Map1' }, { inner: 'Map2' }]}";
      TransactionalContext tc=createTransactionContext(graph,tx,query);
      result=executionEngine.executeQuery(query,NO_PARAMS,tc);
      verifyResult(result);
      result.close();
      tx.success();
    }
   }
  private void verifyResult(  Result result){
    Map firstRowValue=(Map)result.next().values().iterator().next();
    assertThat(firstRowValue.get("key"),is("Value"));
    List theList=(List)firstRowValue.get("collectionKey");
    assertThat(((Map)theList.get(0)).get("inner"),is("Map1"));
    assertThat(((Map)theList.get(1)).get("inner"),is("Map2"));
  }
  private TransactionalContext createTransactionContext(  GraphDatabaseQueryService graph,  InternalTransaction tx,  String query){
    PropertyContainerLocker locker=new PropertyContainerLocker();
    TransactionalContextFactory contextFactory=Neo4jTransactionalContextFactory.create(graph,locker);
    return contextFactory.newContext(ClientConnectionInfo.EMBEDDED_CONNECTION,tx,query,EMPTY_MAP);
  }
}
