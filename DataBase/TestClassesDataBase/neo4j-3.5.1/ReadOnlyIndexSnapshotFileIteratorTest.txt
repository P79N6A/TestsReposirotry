@ExtendWith(TestDirectoryExtension.class) public class ReadOnlyIndexSnapshotFileIteratorTest {
  @Inject private TestDirectory testDir;
  File indexDir;
  protected Directory dir;
  @BeforeEach void setUp() throws IOException {
    indexDir=testDir.databaseDir();
    dir=DirectoryFactory.PERSISTENT.open(indexDir);
  }
  @AfterEach public void tearDown() throws IOException {
    IOUtils.closeAll(dir);
  }
  @Test void shouldReturnRealSnapshotIfIndexAllowsIt() throws IOException {
    prepareIndex();
    Set<String> files=listDir(dir);
    assertFalse(files.isEmpty());
    try (ResourceIterator<File> snapshot=makeSnapshot()){
      Set<String> snapshotFiles=snapshot.stream().map(File::getName).collect(toSet());
      assertEquals(files,snapshotFiles);
    }
   }
  @Test void shouldReturnEmptyIteratorWhenNoCommitsHaveBeenMade() throws IOException {
    try (ResourceIterator<File> snapshot=makeSnapshot()){
      assertFalse(snapshot.hasNext());
    }
   }
  private void prepareIndex() throws IOException {
    try (IndexWriter writer=new IndexWriter(dir,IndexWriterConfigs.standard())){
      insertRandomDocuments(writer);
    }
   }
  protected ResourceIterator<File> makeSnapshot() throws IOException {
    return LuceneIndexSnapshots.forIndex(indexDir,dir);
  }
  private static void insertRandomDocuments(  IndexWriter writer) throws IOException {
    Document doc=new Document();
    doc.add(new StringField("a","b",Field.Store.YES));
    doc.add(new StringField("c","d",Field.Store.NO));
    writer.addDocument(doc);
    writer.commit();
  }
  private static Set<String> listDir(  Directory dir) throws IOException {
    String[] files=dir.listAll();
    return Stream.of(files).filter(file -> !IndexWriter.WRITE_LOCK_NAME.equals(file)).collect(toSet());
  }
}
