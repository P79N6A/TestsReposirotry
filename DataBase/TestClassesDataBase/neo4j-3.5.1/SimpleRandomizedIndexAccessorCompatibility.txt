@Ignore("Not a test. This is a compatibility suite that provides test cases for verifying" + " IndexProvider implementations. Each index provider that is to be tested by this suite" + " must create their own test class extending IndexProviderCompatibilityTestSuite."+ " The @Ignore annotation doesn't prevent these tests to run, it rather removes some annoying"+ " errors or warnings in some IDEs about test classes needing a public zero-arg constructor.") public class SimpleRandomizedIndexAccessorCompatibility extends IndexAccessorCompatibility {
  public SimpleRandomizedIndexAccessorCompatibility(  IndexProviderCompatibilityTestSuite testSuite){
    super(testSuite,TestIndexDescriptorFactory.forLabel(1000,100));
  }
  @Test public void testExactMatchOnRandomValues() throws Exception {
    ValueType[] types=randomSetOfSupportedTypes();
    List<Value> values=generateValuesFromType(types);
    List<IndexEntryUpdate<?>> updates=generateUpdatesFromValues(values);
    updateAndCommit(updates);
    for (    IndexEntryUpdate<?> update : updates) {
      List<Long> hits=query(IndexQuery.exact(0,update.values()[0]));
      assertEquals(hits.toString(),1,hits.size());
      assertThat(single(hits),equalTo(update.getEntityId()));
    }
  }
  @Test public void testRangeMatchInOrderOnRandomValues() throws Exception {
    Assume.assumeTrue("Assume support for granular composite queries",testSuite.supportsGranularCompositeQueries());
    ValueType[] types=randomSetOfSupportedAndSortableTypes();
    List<Value> values=generateValuesFromType(types);
    List<IndexEntryUpdate<?>> updates=generateUpdatesFromValues(values);
    updateAndCommit(updates);
    TreeSet<IndexEntryUpdate> sortedValues=new TreeSet<>((u1,u2) -> Values.COMPARATOR.compare(u1.values()[0],u2.values()[0]));
    sortedValues.addAll(updates);
    for (int i=0; i < 100; i++) {
      ValueType type=random.among(types);
      Value from=random.randomValues().nextValueOfType(type);
      Value to=random.randomValues().nextValueOfType(type);
      if (Values.COMPARATOR.compare(from,to) > 0) {
        Value tmp=from;
        from=to;
        to=tmp;
      }
      boolean fromInclusive=random.nextBoolean();
      boolean toInclusive=random.nextBoolean();
      IndexQuery.RangePredicate<?> predicate=IndexQuery.range(0,from,fromInclusive,to,toInclusive);
      List<Long> expectedIds=expectedIds(sortedValues,from,to,fromInclusive,toInclusive);
      IndexOrder[] indexOrders=indexProvider.getCapability(descriptor).orderCapability(predicate.valueGroup().category());
      for (      IndexOrder order : indexOrders) {
        List<Long> actualIds=assertInOrder(order,predicate);
        actualIds.sort(Long::compare);
        assertThat(actualIds,equalTo(expectedIds));
      }
    }
  }
  private List<Long> expectedIds(  TreeSet<IndexEntryUpdate> sortedValues,  Value from,  Value to,  boolean fromInclusive,  boolean toInclusive){
    return sortedValues.subSet(add(0,descriptor.schema(),from),fromInclusive,add(0,descriptor.schema(),to),toInclusive).stream().map(IndexEntryUpdate::getEntityId).sorted(Long::compare).collect(Collectors.toList());
  }
  private List<Value> generateValuesFromType(  ValueType[] types){
    List<Value> values=new ArrayList<>();
    Set<Value> duplicateChecker=new HashSet<>();
    for (long i=0; i < 30_000; i++) {
      Value value;
      do {
        value=random.randomValues().nextValueOfTypes(types);
      }
 while (!duplicateChecker.add(value));
      values.add(value);
    }
    return values;
  }
  private List<IndexEntryUpdate<?>> generateUpdatesFromValues(  List<Value> values){
    List<IndexEntryUpdate<?>> updates=new ArrayList<>();
    int id=0;
    for (    Value value : values) {
      updates.add(add(id++,descriptor.schema(),value));
    }
    return updates;
  }
}
