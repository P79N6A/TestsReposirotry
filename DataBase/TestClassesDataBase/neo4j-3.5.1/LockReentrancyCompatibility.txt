@Ignore("Not a test. This is a compatibility suite, run from LockingCompatibilityTestSuite.") public class LockReentrancyCompatibility extends LockingCompatibilityTestSuite.Compatibility {
  public LockReentrancyCompatibility(  LockingCompatibilityTestSuite suite){
    super(suite);
  }
  @Test public void shouldAcquireExclusiveIfClientIsOnlyOneHoldingShared(){
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireExclusive(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,1L);
    assertWaiting(clientB,clientBLock);
    clientA.releaseShared(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void shouldRetainExclusiveLockAfterReleasingSharedLock(){
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireShared(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseShared(NODE,1L);
    assertWaiting(clientB,clientBLock);
    clientA.releaseExclusive(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void shouldRetainSharedLockWhenAcquiredAfterExclusiveLock(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireExclusive(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,1L);
    assertWaiting(clientB,clientBLock);
    clientA.releaseShared(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void sharedLocksShouldStack(){
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireExclusive(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseShared(NODE,1L);
    clientA.releaseShared(NODE,1L);
    assertWaiting(clientB,clientBLock);
    clientA.releaseShared(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void exclusiveLocksShouldBeReentrantAndBlockOtherExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireExclusive(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,1L);
    clientA.releaseExclusive(NODE,1L);
    assertWaiting(clientB,clientBLock);
    clientA.releaseExclusive(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void exclusiveLocksShouldBeReentrantAndBlockOtherSharedLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientA.tryExclusiveLock(NODE,1L);
    Future<Object> clientBLock=acquireShared(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,1L);
    clientA.releaseShared(NODE,1L);
    assertWaiting(clientB,clientBLock);
    clientA.releaseExclusive(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void sharedLocksShouldNotReplaceExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireShared(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseShared(NODE,1L);
    assertWaiting(clientB,clientBLock);
    clientA.releaseExclusive(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void shouldUpgradeAndDowngradeSameSharedLock(){
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientB.acquireShared(LockTracer.NONE,NODE,1L);
    LockIdentityExplorer sharedLockExplorer=new LockIdentityExplorer(NODE,1L);
    locks.accept(sharedLockExplorer);
    Future<Object> exclusiveLockFuture=acquireExclusive(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseShared(NODE,1L);
    assertNotWaiting(clientB,exclusiveLockFuture);
    clientB.releaseExclusive(NODE,1L);
    LockIdentityExplorer releasedLockExplorer=new LockIdentityExplorer(NODE,1L);
    locks.accept(releasedLockExplorer);
    assertEquals(sharedLockExplorer.getLockIdentityHashCode(),releasedLockExplorer.getLockIdentityHashCode());
  }
private static class LockIdentityExplorer implements Locks.Visitor {
    private final ResourceType resourceType;
    private final long resourceId;
    private long lockIdentityHashCode;
    LockIdentityExplorer(    ResourceType resourceType,    long resourceId){
      this.resourceType=resourceType;
      this.resourceId=resourceId;
    }
    @Override public void visit(    ResourceType resourceType,    long resourceId,    String description,    long estimatedWaitTime,    long lockIdentityHashCode){
      if (this.resourceType.equals(resourceType) && this.resourceId == resourceId) {
        this.lockIdentityHashCode=lockIdentityHashCode;
      }
    }
    public long getLockIdentityHashCode(){
      return lockIdentityHashCode;
    }
  }
}
