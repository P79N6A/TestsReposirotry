public class DbStructureInvocationTracingAcceptanceTest {
  private final String packageName="org.neo4j.kernel.impl.util.data";
  private final String className="XXYYZZData";
  private final String classNameWithPackage=packageName + "." + className;
  @Test public void outputCompilesWithoutErrors() throws IOException {
    StringBuilder output=new StringBuilder();
    InvocationTracer<DbStructureVisitor> tracer=new InvocationTracer<>("Test",packageName,className,DbStructureVisitor.class,DbStructureArgumentFormatter.INSTANCE,output);
    DbStructureVisitor visitor=tracer.newProxy();
    exerciseVisitor(from -> visitor);
    tracer.close();
    assertCompiles(classNameWithPackage,output.toString());
  }
  @Test public void compiledOutputCreatesInputTrace() throws IOException {
    StringBuilder output=new StringBuilder();
    InvocationTracer<DbStructureVisitor> tracer=new InvocationTracer<>("Test",packageName,className,DbStructureVisitor.class,DbStructureArgumentFormatter.INSTANCE,output);
    exerciseVisitor(from -> tracer.newProxy());
    tracer.close();
    final Visitable<DbStructureVisitor> visitable=compileVisitable(classNameWithPackage,output.toString());
    final DbStructureVisitor visitor=mock(DbStructureVisitor.class);
    visitable.accept(visitor);
    exerciseVisitor(o -> verify(visitor));
    verifyNoMoreInteractions(visitor);
  }
  @Test public void compiledOutputProducesSameCompiledOutputIfCompiledAgain() throws IOException {
    StringBuilder output1=new StringBuilder();
    InvocationTracer<DbStructureVisitor> tracer1=new InvocationTracer<>("Test",packageName,className,DbStructureVisitor.class,DbStructureArgumentFormatter.INSTANCE,output1);
    DbStructureVisitor visitor1=tracer1.newProxy();
    exerciseVisitor(from -> visitor1);
    tracer1.close();
    String source1=output1.toString();
    Visitable<DbStructureVisitor> visitable=compileVisitable(classNameWithPackage,source1);
    StringBuilder output2=new StringBuilder();
    InvocationTracer<DbStructureVisitor> tracer2=new InvocationTracer<>("Test",packageName,className,DbStructureVisitor.class,DbStructureArgumentFormatter.INSTANCE,output2);
    DbStructureVisitor visitor2=tracer2.newProxy();
    visitable.accept(visitor2);
    tracer2.close();
    String source2=output2.toString();
    assertEquals(source1,source2);
  }
  private void exerciseVisitor(  Function<Object,DbStructureVisitor> visitor){
    visitor.apply(null).visitLabel(0,"Person");
    visitor.apply(null).visitLabel(1,"Party");
    visitor.apply(null).visitPropertyKey(0,"name");
    visitor.apply(null).visitPropertyKey(2,"lastName");
    visitor.apply(null).visitPropertyKey(1,"age");
    visitor.apply(null).visitRelationshipType(0,"ACCEPTS");
    visitor.apply(null).visitRelationshipType(1,"REJECTS");
    visitor.apply(null).visitIndex(TestIndexDescriptorFactory.forLabel(0,1),":Person(age)",0.5d,1L);
    visitor.apply(null).visitIndex(TestIndexDescriptorFactory.uniqueForLabel(0,0,2),":Person(name, lastName)",0.5d,1L);
    visitor.apply(null).visitUniqueConstraint(ConstraintDescriptorFactory.uniqueForLabel(1,0),":Party(name)");
    visitor.apply(null).visitNodeKeyConstraint(ConstraintDescriptorFactory.nodeKeyForLabel(0,1,2),":Person(name, lastName)");
    visitor.apply(null).visitAllNodesCount(55);
    visitor.apply(null).visitNodeCount(0,"Person",50);
    visitor.apply(null).visitNodeCount(0,"Party",5);
    visitor.apply(null).visitRelCount(0,1,-1,"MATCH (:Person)-[:REJECTS]->() RETURN count(*)",5);
  }
  private void assertCompiles(  final String className,  String source){
    compile(className,source,(success,manager,diagnostics) -> {
      assertSuccessfullyCompiled(success,diagnostics,className);
      return true;
    }
);
  }
  private Visitable<DbStructureVisitor> compileVisitable(  final String className,  String inputSource){
    return compile(className,inputSource,(success,manager,diagnostics) -> {
      assertSuccessfullyCompiled(success,diagnostics,className);
      Object instance;
      try {
        ClassLoader classLoader=manager.getClassLoader(null);
        Class<?> clazz=classLoader.loadClass(className);
        instance=clazz.getDeclaredField("INSTANCE").get(null);
      }
 catch (      IllegalAccessException|ClassNotFoundException|NoSuchFieldException e) {
        throw new AssertionError("Failed to instantiate compiled class",e);
      }
      return (Visitable<DbStructureVisitor>)instance;
    }
);
  }
  private void assertSuccessfullyCompiled(  Boolean success,  List<Diagnostic<? extends JavaFileObject>> diagnostics,  String className){
    if (success == null || !success) {
      StringBuilder builder=new StringBuilder();
      builder.append("Failed to compile: ");
      builder.append(className);
      builder.append("\n\n");
      for (      Diagnostic<?> diagnostic : diagnostics) {
        builder.append(diagnostic.toString());
        builder.append("\n");
      }
      throw new AssertionError(builder.toString());
    }
  }
  private <T>T compile(  String className,  String source,  CompilationListener<T> listener){
    JavaCompiler systemCompiler=ToolProvider.getSystemJavaCompiler();
    JavaFileManager manager=new InMemFileManager();
    DiagnosticCollector<JavaFileObject> diagnosticsCollector=new DiagnosticCollector<>();
    Iterable<? extends JavaFileObject> sources=Collections.singletonList(new InMemSource(className,source));
    CompilationTask task=systemCompiler.getTask(null,manager,diagnosticsCollector,null,null,sources);
    Boolean success=task.call();
    return listener.compiled(success,manager,diagnosticsCollector.getDiagnostics());
  }
private interface CompilationListener<T> {
    T compiled(    Boolean success,    JavaFileManager manager,    List<Diagnostic<? extends JavaFileObject>> diagnostics);
  }
private static class InMemSource extends SimpleJavaFileObject {
    final String javaSource;
    InMemSource(    String className,    String javaSource){
      super(URI.create("string:///" + className.replace('.','/') + Kind.SOURCE.extension),Kind.SOURCE);
      this.javaSource=javaSource;
    }
    @Override public CharSequence getCharContent(    boolean ignoreEncodingErrors){
      return javaSource;
    }
  }
private static class InMemSink extends SimpleJavaFileObject {
    private ByteArrayOutputStream byteCodeStream=new ByteArrayOutputStream();
    InMemSink(    String className){
      super(URI.create("mem:///" + className + Kind.CLASS.extension),Kind.CLASS);
    }
    public byte[] getBytes(){
      return byteCodeStream.toByteArray();
    }
    @Override public OutputStream openOutputStream(){
      return byteCodeStream;
    }
  }
private static class InMemFileManager extends ForwardingJavaFileManager {
    private final Map<String,InMemSink> classes=new HashMap<>();
    InMemFileManager(){
      super(ToolProvider.getSystemJavaCompiler().getStandardFileManager(null,null,null));
    }
    @Override public ClassLoader getClassLoader(    Location location){
      return new SecureClassLoader(){
        @Override protected Class<?> findClass(        String name){
          byte[] byteCode=classes.get(name).getBytes();
          return super.defineClass(name,byteCode,0,byteCode.length);
        }
      }
;
    }
    @Override public JavaFileObject getJavaFileForOutput(    Location location,    String className,    Kind kind,    FileObject sibling) throws IOException {
      if (StandardLocation.CLASS_OUTPUT == location && Kind.CLASS == kind) {
        InMemSink clazz=new InMemSink(className);
        classes.put(className,clazz);
        return clazz;
      }
 else {
        return super.getJavaFileForOutput(location,className,kind,sibling);
      }
    }
  }
}
