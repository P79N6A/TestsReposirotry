public class IndexTxStateUpdaterTest {
  private static final int labelId1=10;
  private static final int labelId2=11;
  private static final int unIndexedLabelId=12;
  private static final int propId1=20;
  private static final int propId2=21;
  private static final int propId3=22;
  private static final int newPropId=23;
  private static final int unIndexedPropId=24;
  private TransactionState txState;
  private IndexTxStateUpdater indexTxUpdater;
  private IndexDescriptor indexOn1_1=TestIndexDescriptorFactory.forLabel(labelId1,propId1);
  private IndexDescriptor indexOn2_new=TestIndexDescriptorFactory.forLabel(labelId2,newPropId);
  private IndexDescriptor uniqueOn1_2=TestIndexDescriptorFactory.uniqueForLabel(labelId1,propId2);
  private IndexDescriptor indexOn1_1_new=TestIndexDescriptorFactory.forLabel(labelId1,propId1,newPropId);
  private IndexDescriptor uniqueOn2_2_3=TestIndexDescriptorFactory.uniqueForLabel(labelId2,propId2,propId3);
  private List<IndexDescriptor> indexes=Arrays.asList(indexOn1_1,indexOn2_new,uniqueOn1_2,indexOn1_1_new,uniqueOn2_2_3);
  private StubNodeCursor node;
  private StubPropertyCursor propertyCursor;
  @Before public void setup() throws IndexNotFoundKernelException {
    txState=mock(TransactionState.class);
    StorageReader storageReader=mock(StorageReader.class);
    when(storageReader.indexesGetAll()).thenAnswer(x -> indexes.iterator());
    when(storageReader.indexesGetForLabel(anyInt())).thenAnswer(x -> {
      Integer argument=x.getArgument(0);
      return filter(hasLabel(argument),indexes.iterator());
    }
);
    when(storageReader.indexesGetRelatedToProperty(anyInt())).thenAnswer(x -> {
      Integer argument=x.getArgument(0);
      return filter(hasProperty(argument),indexes.iterator());
    }
);
    HashMap<Integer,Value> map=new HashMap<>();
    map.put(propId1,Values.of("hi1"));
    map.put(propId2,Values.of("hi2"));
    map.put(propId3,Values.of("hi3"));
    node=new StubNodeCursor().withNode(0,new long[]{labelId1,labelId2},map);
    node.next();
    propertyCursor=new StubPropertyCursor();
    Read readOps=mock(Read.class);
    when(readOps.txState()).thenReturn(txState);
    IndexingService indexingService=mock(IndexingService.class);
    IndexProxy indexProxy=mock(IndexProxy.class);
    when(indexingService.getIndexProxy(any(SchemaDescriptor.class))).thenReturn(indexProxy);
    indexTxUpdater=new IndexTxStateUpdater(storageReader,readOps,indexingService);
  }
  @Test public void shouldNotUpdateIndexesOnChangedIrrelevantLabel(){
    indexTxUpdater.onLabelChange(unIndexedLabelId,node,propertyCursor,ADDED_LABEL);
    indexTxUpdater.onLabelChange(unIndexedLabelId,node,propertyCursor,REMOVED_LABEL);
    verify(txState,never()).indexDoUpdateEntry(any(),anyInt(),any(),any());
  }
  @Test public void shouldUpdateIndexesOnAddedLabel(){
    indexTxUpdater.onLabelChange(labelId1,node,propertyCursor,ADDED_LABEL);
    verifyIndexUpdate(indexOn1_1.schema(),node.nodeReference(),null,values("hi1"));
    verifyIndexUpdate(uniqueOn1_2.schema(),node.nodeReference(),null,values("hi2"));
    verify(txState,times(2)).indexDoUpdateEntry(any(),anyLong(),isNull(),any());
  }
  @Test public void shouldUpdateIndexesOnRemovedLabel(){
    indexTxUpdater.onLabelChange(labelId2,node,propertyCursor,REMOVED_LABEL);
    verifyIndexUpdate(uniqueOn2_2_3.schema(),node.nodeReference(),values("hi2","hi3"),null);
    verify(txState,times(1)).indexDoUpdateEntry(any(),anyLong(),any(),isNull());
  }
  @Test public void shouldNotUpdateIndexesOnChangedIrrelevantProperty(){
    indexTxUpdater.onPropertyAdd(node,propertyCursor,unIndexedPropId,Values.of("whAt"));
    indexTxUpdater.onPropertyRemove(node,propertyCursor,unIndexedPropId,Values.of("whAt"));
    indexTxUpdater.onPropertyChange(node,propertyCursor,unIndexedPropId,Values.of("whAt"),Values.of("whAt2"));
    verify(txState,never()).indexDoUpdateEntry(any(),anyInt(),any(),any());
  }
  @Test public void shouldUpdateIndexesOnAddedProperty(){
    indexTxUpdater.onPropertyAdd(node,propertyCursor,newPropId,Values.of("newHi"));
    verifyIndexUpdate(indexOn2_new.schema(),node.nodeReference(),null,values("newHi"));
    verifyIndexUpdate(indexOn1_1_new.schema(),node.nodeReference(),null,values("hi1","newHi"));
    verify(txState,times(2)).indexDoUpdateEntry(any(),anyLong(),isNull(),any());
  }
  @Test public void shouldUpdateIndexesOnRemovedProperty(){
    indexTxUpdater.onPropertyRemove(node,propertyCursor,propId2,Values.of("hi2"));
    verifyIndexUpdate(uniqueOn1_2.schema(),node.nodeReference(),values("hi2"),null);
    verifyIndexUpdate(uniqueOn2_2_3.schema(),node.nodeReference(),values("hi2","hi3"),null);
    verify(txState,times(2)).indexDoUpdateEntry(any(),anyLong(),any(),isNull());
  }
  @Test public void shouldUpdateIndexesOnChangesProperty(){
    indexTxUpdater.onPropertyChange(node,propertyCursor,propId2,Values.of("hi2"),Values.of("new2"));
    verifyIndexUpdate(uniqueOn1_2.schema(),node.nodeReference(),values("hi2"),values("new2"));
    verifyIndexUpdate(uniqueOn2_2_3.schema(),node.nodeReference(),values("hi2","hi3"),values("new2","hi3"));
    verify(txState,times(2)).indexDoUpdateEntry(any(),anyLong(),any(),any());
  }
  private ValueTuple values(  Object... values){
    return ValueTuple.of(values);
  }
  private void verifyIndexUpdate(  SchemaDescriptor schema,  long nodeId,  ValueTuple before,  ValueTuple after){
    verify(txState).indexDoUpdateEntry(eq(schema),eq(nodeId),eq(before),eq(after));
  }
}
