/** 
 * Tests simple acquiring and releasing of single locks. For testing "stacking" locks on the same client, see  {@link LockReentrancyCompatibility}. 
 */
@Ignore("Not a test. This is a compatibility suite, run from LockingCompatibilityTestSuite.") public class AcquireAndReleaseLocksCompatibility extends LockingCompatibilityTestSuite.Compatibility {
  public AcquireAndReleaseLocksCompatibility(  LockingCompatibilityTestSuite suite){
    super(suite);
  }
  @Test public void exclusiveShouldWaitForExclusive(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireExclusive(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void exclusiveShouldWaitForShared(){
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientC.acquireShared(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireExclusive(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseShared(NODE,1L);
    clientC.releaseShared(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void sharedShouldWaitForExclusive(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    Future<Object> clientBLock=acquireShared(clientB,LockTracer.NONE,NODE,1L).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,1L);
    assertNotWaiting(clientB,clientBLock);
  }
  @Test public void shouldTrySharedLock(){
    assertTrue(clientA.trySharedLock(NODE,1L));
    assertFalse(clientB.tryExclusiveLock(NODE,1L));
    assertTrue(clientB.trySharedLock(NODE,1L));
  }
  @Test public void shouldTryExclusiveLock(){
    assertTrue(clientA.tryExclusiveLock(NODE,1L));
    assertFalse(clientB.tryExclusiveLock(NODE,1L));
    assertFalse(clientB.trySharedLock(NODE,1L));
  }
  @Test public void shouldTryUpgradeSharedToExclusive(){
    assertTrue(clientA.trySharedLock(NODE,1L));
    assertTrue(clientA.tryExclusiveLock(NODE,1L));
    assertFalse(clientB.trySharedLock(NODE,1L));
  }
  @Test public void shouldUpgradeExclusiveOnTry(){
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    assertTrue(clientA.tryExclusiveLock(NODE,1L));
    clientA.releaseExclusive(NODE,1L);
  }
  @Test public void shouldAcquireMultipleSharedLocks(){
    clientA.acquireShared(LockTracer.NONE,NODE,10,100,1000);
    assertFalse(clientB.tryExclusiveLock(NODE,10));
    assertFalse(clientB.tryExclusiveLock(NODE,100));
    assertFalse(clientB.tryExclusiveLock(NODE,1000));
    assertEquals(3,lockCount());
  }
  @Test public void shouldAcquireMultipleExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,10,100,1000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertEquals(3,lockCount());
  }
  @Test public void shouldAcquireMultipleAlreadyAcquiredSharedLocks(){
    clientA.acquireShared(LockTracer.NONE,NODE,10,100,1000);
    clientA.acquireShared(LockTracer.NONE,NODE,100,1000,10000);
    assertFalse(clientB.tryExclusiveLock(NODE,10));
    assertFalse(clientB.tryExclusiveLock(NODE,100));
    assertFalse(clientB.tryExclusiveLock(NODE,1000));
    assertFalse(clientB.tryExclusiveLock(NODE,10000));
    assertEquals(4,lockCount());
  }
  @Test public void shouldAcquireMultipleAlreadyAcquiredExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,10,100,1000);
    clientA.acquireExclusive(LockTracer.NONE,NODE,100,1000,10000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertFalse(clientB.trySharedLock(NODE,10000));
    assertEquals(4,lockCount());
  }
  @Test public void shouldAcquireMultipleSharedLocksWhileHavingSomeExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,10,100,1000);
    clientA.acquireShared(LockTracer.NONE,NODE,100,1000,10000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertFalse(clientB.tryExclusiveLock(NODE,10000));
    assertEquals(4,lockCount());
  }
  @Test public void shouldReleaseSharedLocksAcquiredInABatch(){
    clientA.acquireShared(LockTracer.NONE,NODE,1,10,100);
    assertEquals(3,lockCount());
    clientA.releaseShared(NODE,1);
    assertEquals(2,lockCount());
    clientA.releaseShared(NODE,10);
    assertEquals(1,lockCount());
    clientA.releaseShared(NODE,100);
    assertEquals(0,lockCount());
  }
  @Test public void shouldReleaseExclusiveLocksAcquiredInABatch(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1,10,100);
    assertEquals(3,lockCount());
    clientA.releaseExclusive(NODE,1);
    assertEquals(2,lockCount());
    clientA.releaseExclusive(NODE,10);
    assertEquals(1,lockCount());
    clientA.releaseExclusive(NODE,100);
    assertEquals(0,lockCount());
  }
  @Test public void releaseMultipleSharedLocks(){
    clientA.acquireShared(LockTracer.NONE,NODE,10,100,1000);
    assertEquals(3,lockCount());
    clientA.releaseShared(NODE,100,1000);
    assertEquals(1,lockCount());
    assertFalse(clientB.tryExclusiveLock(NODE,10));
    assertTrue(clientB.tryExclusiveLock(NODE,100));
    assertTrue(clientB.tryExclusiveLock(NODE,1000));
  }
  @Test public void releaseMultipleExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,10,100,1000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertEquals(3,lockCount());
    clientA.releaseExclusive(NODE,10,100);
    assertEquals(1,lockCount());
    assertTrue(clientB.trySharedLock(NODE,10));
    assertTrue(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
  }
  @Test public void releaseMultipleAlreadyAcquiredSharedLocks(){
    clientA.acquireShared(LockTracer.NONE,NODE,10,100,1000);
    clientA.acquireShared(LockTracer.NONE,NODE,100,1000,10000);
    clientA.releaseShared(NODE,100,1000);
    assertEquals(4,lockCount());
    assertFalse(clientB.tryExclusiveLock(NODE,100));
    assertFalse(clientB.tryExclusiveLock(NODE,1000));
    clientA.releaseShared(NODE,100,1000);
    assertEquals(2,lockCount());
  }
  @Test public void releaseMultipleAlreadyAcquiredExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,10,100,1000);
    clientA.acquireExclusive(LockTracer.NONE,NODE,100,1000,10000);
    clientA.releaseExclusive(NODE,100,1000);
    assertEquals(4,lockCount());
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertFalse(clientB.trySharedLock(NODE,10000));
    clientA.releaseExclusive(NODE,100,1000);
    assertEquals(2,lockCount());
  }
  @Test public void releaseSharedLocksAcquiredSeparately(){
    clientA.acquireShared(LockTracer.NONE,NODE,1);
    clientA.acquireShared(LockTracer.NONE,NODE,2);
    clientA.acquireShared(LockTracer.NONE,NODE,3);
    assertEquals(3,lockCount());
    assertFalse(clientB.tryExclusiveLock(NODE,1));
    assertFalse(clientB.tryExclusiveLock(NODE,2));
    assertFalse(clientB.tryExclusiveLock(NODE,3));
    clientA.releaseShared(NODE,1,2,3);
    assertEquals(0,lockCount());
    assertTrue(clientB.tryExclusiveLock(NODE,1));
    assertTrue(clientB.tryExclusiveLock(NODE,2));
    assertTrue(clientB.tryExclusiveLock(NODE,3));
  }
  @Test public void releaseExclusiveLocksAcquiredSeparately(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,1);
    clientA.acquireExclusive(LockTracer.NONE,NODE,2);
    clientA.acquireExclusive(LockTracer.NONE,NODE,3);
    assertEquals(3,lockCount());
    assertFalse(clientB.trySharedLock(NODE,1));
    assertFalse(clientB.trySharedLock(NODE,2));
    assertFalse(clientB.trySharedLock(NODE,3));
    clientA.releaseExclusive(NODE,1,2,3);
    assertEquals(0,lockCount());
    assertTrue(clientB.trySharedLock(NODE,1));
    assertTrue(clientB.trySharedLock(NODE,2));
    assertTrue(clientB.trySharedLock(NODE,3));
  }
  @Test public void releaseMultipleSharedLocksWhileHavingSomeExclusiveLocks(){
    clientA.acquireExclusive(LockTracer.NONE,NODE,10,100,1000);
    clientA.acquireShared(LockTracer.NONE,NODE,100,1000,10000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertFalse(clientB.tryExclusiveLock(NODE,10000));
    assertEquals(4,lockCount());
    clientA.releaseShared(NODE,100,1000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertFalse(clientB.tryExclusiveLock(NODE,10000));
    assertEquals(4,lockCount());
  }
  @Test public void releaseMultipleExclusiveLocksWhileHavingSomeSharedLocks(){
    clientA.acquireShared(LockTracer.NONE,NODE,100,1000,10000);
    clientA.acquireExclusive(LockTracer.NONE,NODE,10,100,1000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.trySharedLock(NODE,100));
    assertFalse(clientB.trySharedLock(NODE,1000));
    assertFalse(clientB.tryExclusiveLock(NODE,10000));
    assertEquals(4,lockCount());
    clientA.releaseExclusive(NODE,100,1000);
    assertFalse(clientB.trySharedLock(NODE,10));
    assertFalse(clientB.tryExclusiveLock(NODE,100));
    assertFalse(clientB.tryExclusiveLock(NODE,1000));
    assertFalse(clientB.tryExclusiveLock(NODE,10000));
    assertEquals(4,lockCount());
  }
  private int lockCount(){
    LockCountVisitor lockVisitor=new LockCountVisitor();
    locks.accept(lockVisitor);
    return lockVisitor.getLockCount();
  }
}
