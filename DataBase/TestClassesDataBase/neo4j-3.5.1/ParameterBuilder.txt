private static class ParameterBuilder extends RunnerBuilder {
  private final Map<Class<?>,Parameterization> parameterizations=new HashMap<>();
  private final Class<?> suiteClass;
  ParameterBuilder(  Class<?> suiteClass) throws InitializationError {
    this.suiteClass=suiteClass;
    boolean ok=false;
    for (    Constructor<?> suiteConstructor : suiteClass.getConstructors()) {
      if (suiteConstructor.getParameterTypes().length == 0) {
        if (Modifier.isPublic(suiteConstructor.getModifiers())) {
          ok=true;
        }
        break;
      }
    }
    List<Throwable> errors=new ArrayList<>();
    if (!ok) {
      errors.add(new IllegalArgumentException("Suite class (" + suiteClass.getName() + ") does not have a public zero-arg constructor."));
    }
    if (Modifier.isAbstract(suiteClass.getModifiers())) {
      errors.add(new IllegalArgumentException("Suite class (" + suiteClass.getName() + ") is abstract."));
    }
    buildParameterizations(parameterizations,suiteClass,errors);
    if (!errors.isEmpty()) {
      throw new InitializationError(errors);
    }
  }
  @Override public Runner runnerForClass(  Class<?> testClass) throws Throwable {
    if (testClass == this.suiteClass) {
      return new BlockJUnit4ClassRunner(testClass);
    }
    return parameterizations.get(testClass);
  }
  Class<?>[] suiteClasses(){
    ArrayList<Class<?>> classes=new ArrayList<>(parameterizations.keySet());
    for (    Method method : suiteClass.getMethods()) {
      if (method.getAnnotation(Test.class) != null) {
        classes.add(suiteClass);
      }
    }
    return classes.toArray(new Class[classes.size()]);
  }
  private void buildParameterizations(  Map<Class<?>,Parameterization> result,  Class<?> type,  List<Throwable> errors){
    if (type == Object.class) {
      return;
    }
    buildParameterizations(result,type.getSuperclass(),errors);
    SuiteClasses annotation=type.getAnnotation(SuiteClasses.class);
    if (annotation != null) {
      for (      Class<?> test : annotation.value()) {
        if (!result.containsKey(test)) {
          try {
            result.put(test,new Parameterization(this,test.getConstructor(type)));
          }
 catch (          InitializationError failure) {
            errors.addAll(failure.getCauses());
          }
catch (          NoSuchMethodException e) {
            errors.add(e);
          }
        }
      }
    }
  }
  Object newSuiteInstance() throws Exception {
    return suiteClass.newInstance();
  }
}
