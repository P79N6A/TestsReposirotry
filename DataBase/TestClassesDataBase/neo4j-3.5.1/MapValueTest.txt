class MapValueTest {
  @Test void shouldFilterOnKeys(){
    MapValue base=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"));
    MapValue filtered=base.filter((k,ignore) -> k.equals("k2"));
    assertMapValueEquals(filtered,mapValue("k2",stringValue("v2")));
  }
  @Test void shouldFilterOnValues(){
    MapValue base=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"));
    MapValue filtered=base.filter((ignore,v) -> v.equals(stringValue("v2")));
    assertMapValueEquals(filtered,mapValue("k2",stringValue("v2")));
  }
  @Test void shouldFilterOnKeysAndValues(){
    MapValue base=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"));
    MapValue filtered=base.filter((k,v) -> k.equals("k1") && v.equals(stringValue("v2")));
    assertMapValueEquals(filtered,EMPTY_MAP);
  }
  @Test void shouldUpdateWithIdenticalValues(){
    MapValue base=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"));
    MapValue updated=base.updatedWith("k3",stringValue("v3"));
    assertMapValueEquals(updated,base);
  }
  @Test void shouldUpdateWithExistingKey(){
    MapValue base=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"));
    MapValue updated=base.updatedWith("k3",stringValue("version3"));
    assertMapValueEquals(updated,mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("version3")));
  }
  @Test void shouldUpdateWithNewKey(){
    MapValue base=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"));
    MapValue updated=base.updatedWith("k4",stringValue("v4"));
    assertMapValueEquals(updated,mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"),"k4",stringValue("v4")));
  }
  @Test void shouldUpdateWithOtherMapValue(){
    MapValue a=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"),"k3",stringValue("v3"));
    MapValue b=mapValue("k1",stringValue("version1"),"k2",stringValue("version2"),"k4",stringValue("version4"));
    MapValue updated=a.updatedWith(b);
    assertMapValueEquals(updated,mapValue("k1",stringValue("version1"),"k2",stringValue("version2"),"k3",stringValue("v3"),"k4",stringValue("version4")));
  }
  @Test void shouldUpdateMultipleTimesMapValue(){
    MapValue a=mapValue("k1",stringValue("v1"),"k2",stringValue("v2"));
    MapValue b=mapValue("k1",stringValue("version1"),"k4",stringValue("version4"));
    MapValue c=mapValue("k3",stringValue("v3"));
    MapValue updated=a.updatedWith(b).updatedWith(c);
    assertMapValueEquals(updated,mapValue("k1",stringValue("version1"),"k2",stringValue("v2"),"k3",stringValue("v3"),"k4",stringValue("version4")));
  }
  private void assertMapValueEquals(  MapValue a,  MapValue b){
    assertThat(a,equalTo(b));
    assertThat(a.size(),equalTo(b.size()));
    assertThat(a.hashCode(),equalTo(b.hashCode()));
    assertThat(a.keySet(),containsInAnyOrder(Iterables.asArray(String.class,b.keySet())));
    assertThat(Arrays.asList(a.keys().asArray()),containsInAnyOrder(b.keys().asArray()));
    a.foreach((k,v) -> assertThat(b.get(k),equalTo(v)));
    b.foreach((k,v) -> assertThat(a.get(k),equalTo(v)));
  }
  private MapValue mapValue(  Object... kv){
    assert kv.length % 2 == 0;
    String[] keys=new String[kv.length / 2];
    AnyValue[] values=new AnyValue[kv.length / 2];
    for (int i=0; i < kv.length; i+=2) {
      keys[i / 2]=(String)kv[i];
      values[i / 2]=(AnyValue)kv[i + 1];
    }
    return map(keys,values);
  }
}
