public class TransportWriteThrottleTest {
  @Rule public OtherThreadRule<Void> otherThread=new OtherThreadRule<>(1,TimeUnit.MINUTES);
  private ChannelHandlerContext context;
  private Channel channel;
  private SocketChannelConfig config;
  private ThrottleLock lock;
  private Attribute lockAttribute;
  @Before public void setup() throws Exception {
    lock=newThrottleLockMock();
    config=mock(SocketChannelConfig.class);
    lockAttribute=mock(Attribute.class);
    when(lockAttribute.get()).thenReturn(lock);
    Attribute durationExceedAttribute=mock(Attribute.class);
    when(durationExceedAttribute.get()).thenReturn(null);
    channel=mock(SocketChannel.class,Answers.RETURNS_MOCKS);
    when(channel.config()).thenReturn(config);
    when(channel.isOpen()).thenReturn(true);
    when(channel.remoteAddress()).thenReturn(InetSocketAddress.createUnresolved("localhost",32000));
    when(channel.attr(TransportWriteThrottle.LOCK_KEY)).thenReturn(lockAttribute);
    when(channel.attr(TransportWriteThrottle.MAX_DURATION_EXCEEDED_KEY)).thenReturn(durationExceedAttribute);
    ChannelPipeline pipeline=channel.pipeline();
    when(channel.pipeline()).thenReturn(pipeline);
    context=mock(ChannelHandlerContext.class,Answers.RETURNS_MOCKS);
    when(context.channel()).thenReturn(channel);
  }
  @Test public void shouldSetWriteBufferWatermarkOnChannelConfigWhenInstalled(){
    TransportThrottle throttle=newThrottle();
    throttle.install(channel);
    ArgumentCaptor<WriteBufferWaterMark> argument=ArgumentCaptor.forClass(WriteBufferWaterMark.class);
    verify(config,times(1)).setWriteBufferWaterMark(argument.capture());
    assertEquals(64,argument.getValue().low());
    assertEquals(256,argument.getValue().high());
  }
  @Test public void shouldNotLockWhenWritable() throws Exception {
    TestThrottleLock lockOverride=new TestThrottleLock();
    TransportThrottle throttle=newThrottleAndInstall(channel,lockOverride);
    when(channel.isWritable()).thenReturn(true);
    Future future=otherThread.execute(state -> {
      throttle.acquire(channel);
      return null;
    }
);
    try {
      future.get(2000,TimeUnit.MILLISECONDS);
    }
 catch (    Throwable t) {
      fail("should not throw");
    }
    assertTrue(future.isDone());
    assertThat(lockOverride.lockCallCount(),is(0));
    assertThat(lockOverride.unlockCallCount(),is(0));
  }
  @Test public void shouldLockWhenNotWritable() throws Exception {
    TestThrottleLock lockOverride=new TestThrottleLock();
    TransportThrottle throttle=newThrottleAndInstall(channel,lockOverride);
    when(channel.isWritable()).thenReturn(false);
    Future<Void> future=otherThread.execute(state -> {
      throttle.acquire(channel);
      return null;
    }
);
    try {
      future.get(2000,TimeUnit.MILLISECONDS);
      fail("should timeout");
    }
 catch (    TimeoutException t) {
    }
    assertFalse(future.isDone());
    assertThat(lockOverride.lockCallCount(),greaterThan(0));
    assertThat(lockOverride.unlockCallCount(),is(0));
    future.cancel(true);
    try {
      otherThread.get().awaitFuture(future);
      fail("Exception expected");
    }
 catch (    CancellationException ignore) {
    }
  }
  @Test public void shouldResumeWhenWritableOnceAgain() throws Exception {
    TransportThrottle throttle=newThrottleAndInstall(channel);
    when(channel.isWritable()).thenReturn(false).thenReturn(true);
    throttle.acquire(channel);
    verify(lock,atLeast(1)).lock(any(),anyLong());
    verify(lock,never()).unlock(any());
  }
  @Test public void shouldResumeWhenWritabilityChanged() throws Exception {
    TestThrottleLock lockOverride=new TestThrottleLock();
    TransportThrottle throttle=newThrottleAndInstall(channel,lockOverride);
    when(channel.isWritable()).thenReturn(false);
    Future<Void> completionFuture=otherThread.execute(state -> {
      throttle.acquire(channel);
      return null;
    }
);
    otherThread.get().waitUntilWaiting();
    when(channel.isWritable()).thenReturn(true);
    ArgumentCaptor<ChannelInboundHandler> captor=ArgumentCaptor.forClass(ChannelInboundHandler.class);
    verify(channel.pipeline()).addLast(captor.capture());
    captor.getValue().channelWritabilityChanged(context);
    otherThread.get().awaitFuture(completionFuture);
    assertThat(lockOverride.lockCallCount(),greaterThan(0));
    assertThat(lockOverride.unlockCallCount(),is(1));
  }
  @Test public void shouldThrowThrottleExceptionWhenMaxDurationIsReached() throws Exception {
    TestThrottleLock lockOverride=new TestThrottleLock();
    FakeClock clock=Clocks.fakeClock(1,TimeUnit.SECONDS);
    TransportThrottle throttle=newThrottleAndInstall(channel,lockOverride,clock,Duration.ofSeconds(5));
    when(channel.isWritable()).thenReturn(false);
    Future<Void> future=otherThread.execute(state -> {
      throttle.acquire(channel);
      return null;
    }
);
    otherThread.get().waitUntilWaiting();
    clock.forward(6,TimeUnit.SECONDS);
    try {
      future.get(1,TimeUnit.MINUTES);
      fail("expecting ExecutionException");
    }
 catch (    ExecutionException ex) {
      assertThat(ex.getCause(),instanceOf(TransportThrottleException.class));
      assertThat(ex.getMessage(),containsString("will be closed because the client did not consume outgoing buffers for"));
    }
  }
  private TransportThrottle newThrottle(){
    return newThrottle(null,Clocks.systemClock(),Duration.ZERO);
  }
  private TransportThrottle newThrottle(  ThrottleLock lockOverride,  Clock clock,  Duration maxLockDuration){
    if (lockOverride != null) {
      lock=lockOverride;
      when(lockAttribute.get()).thenReturn(lockOverride);
    }
    return new TransportWriteThrottle(64,256,clock,maxLockDuration,() -> lock);
  }
  private TransportThrottle newThrottleAndInstall(  Channel channel){
    return newThrottleAndInstall(channel,null);
  }
  private TransportThrottle newThrottleAndInstall(  Channel channel,  ThrottleLock lockOverride){
    return newThrottleAndInstall(channel,lockOverride,Clocks.systemClock(),Duration.ZERO);
  }
  private TransportThrottle newThrottleAndInstall(  Channel channel,  ThrottleLock lockOverride,  Clock clock,  Duration maxLockDuration){
    TransportThrottle throttle=newThrottle(lockOverride,clock,maxLockDuration);
    throttle.install(channel);
    return throttle;
  }
  private static ThrottleLock newThrottleLockMock() throws InterruptedException {
    ThrottleLock lock=mock(ThrottleLock.class);
    doAnswer(invocation -> {
      Thread.sleep(500);
      return null;
    }
).when(lock).lock(any(),anyLong());
    return lock;
  }
private static class TestThrottleLock implements ThrottleLock {
    private AtomicInteger lockCount=new AtomicInteger(0);
    private AtomicInteger unlockCount=new AtomicInteger(0);
    private ThrottleLock actualLock=new DefaultThrottleLock();
    @Override public void lock(    Channel channel,    long timeout) throws InterruptedException {
      actualLock.lock(channel,timeout);
      lockCount.incrementAndGet();
    }
    @Override public void unlock(    Channel channel){
      actualLock.unlock(channel);
      unlockCount.incrementAndGet();
    }
    public int lockCallCount(){
      return lockCount.get();
    }
    public int unlockCallCount(){
      return unlockCount.get();
    }
  }
}
