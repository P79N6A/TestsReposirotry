private abstract static class UpdateWorker implements Callable<UpdateResult> {
  final int threadId;
  final int filePages;
  final AtomicBoolean shouldStop;
  final PagedFile pagedFile;
  final int[] pageCounts;
  final int offset;
  UpdateWorker(  int threadId,  int filePages,  AtomicBoolean shouldStop,  PagedFile pagedFile){
    this.threadId=threadId;
    this.filePages=filePages;
    this.shouldStop=shouldStop;
    this.pagedFile=pagedFile;
    pageCounts=new int[filePages];
    offset=threadId * 4;
  }
  @Override public UpdateResult call() throws Exception {
    ThreadLocalRandom rng=ThreadLocalRandom.current();
    while (!shouldStop.get()) {
      boolean updateCounter=rng.nextBoolean();
      int pfFlags=updateCounter ? PF_SHARED_WRITE_LOCK : PF_SHARED_READ_LOCK;
      performReadOrUpdate(rng,updateCounter,pfFlags);
    }
    return new UpdateResult(threadId,pageCounts);
  }
  protected abstract void performReadOrUpdate(  ThreadLocalRandom rng,  boolean updateCounter,  int pf_flags) throws IOException ;
}
