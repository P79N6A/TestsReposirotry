public class PhysicalTransactionCursorTest {
  private final ReadableLogChannel channel=mock(ReadableLogChannel.class,RETURNS_MOCKS);
  private final LogEntryReader<ReadableLogChannel> entryReader=mock(LogEntryReader.class);
  private static final LogEntry NULL_ENTRY=null;
  private static final CheckPoint A_CHECK_POINT_ENTRY=new CheckPoint(LogPosition.UNSPECIFIED);
  private static final LogEntryStart A_START_ENTRY=new LogEntryStart(0,0,0L,0L,null,LogPosition.UNSPECIFIED);
  private static final LogEntryCommit A_COMMIT_ENTRY=new LogEntryCommit(42,0);
  private static final LogEntryCommand A_COMMAND_ENTRY=new LogEntryCommand(new Command.NodeCommand(new NodeRecord(42),new NodeRecord(42)));
  private PhysicalTransactionCursor<ReadableLogChannel> cursor;
  @Before public void setup() throws IOException {
    cursor=new PhysicalTransactionCursor<>(channel,entryReader);
  }
  @Test public void shouldCloseTheUnderlyingChannel() throws IOException {
    cursor.close();
    verify(channel,times(1)).close();
  }
  @Test public void shouldReturnFalseWhenThereAreNoEntries() throws IOException {
    when(entryReader.readLogEntry(channel)).thenReturn(NULL_ENTRY);
    final boolean result=cursor.next();
    assertFalse(result);
    assertNull(cursor.get());
  }
  @Test public void shouldReturnFalseWhenThereIsAStartEntryButNoCommitEntries() throws IOException {
    when(entryReader.readLogEntry(channel)).thenReturn(A_START_ENTRY,NULL_ENTRY);
    final boolean result=cursor.next();
    assertFalse(result);
    assertNull(cursor.get());
  }
  @Test public void shouldCallTheVisitorWithTheFoundTransaction() throws IOException {
    when(entryReader.readLogEntry(channel)).thenReturn(A_START_ENTRY,A_COMMAND_ENTRY,A_COMMIT_ENTRY);
    cursor.next();
    PhysicalTransactionRepresentation txRepresentation=new PhysicalTransactionRepresentation(singletonList(A_COMMAND_ENTRY.getCommand()));
    assertEquals(new CommittedTransactionRepresentation(A_START_ENTRY,txRepresentation,A_COMMIT_ENTRY),cursor.get());
  }
  @Test public void shouldSkipCheckPoints() throws IOException {
    when(entryReader.readLogEntry(channel)).thenReturn(A_CHECK_POINT_ENTRY,A_START_ENTRY,A_COMMAND_ENTRY,A_COMMIT_ENTRY,A_CHECK_POINT_ENTRY);
    cursor.next();
    PhysicalTransactionRepresentation txRepresentation=new PhysicalTransactionRepresentation(singletonList(A_COMMAND_ENTRY.getCommand()));
    assertEquals(new CommittedTransactionRepresentation(A_START_ENTRY,txRepresentation,A_COMMIT_ENTRY),cursor.get());
  }
}
