class PathImplTest {
  private final EmbeddedProxySPI spi=mock(EmbeddedProxySPI.class);
  @Test void singularNodeWorksForwardsAndBackwards(){
    Node node=createNode(1337L);
    Path path=PathImpl.singular(node);
    assertEquals(node,path.startNode());
    assertEquals(node,path.endNode());
    Iterator<Node> forwardIterator=path.nodes().iterator();
    assertTrue(forwardIterator.hasNext());
    assertEquals(node,forwardIterator.next());
    assertFalse(forwardIterator.hasNext());
    Iterator<Node> reverseIterator=path.reverseNodes().iterator();
    assertTrue(reverseIterator.hasNext());
    assertEquals(node,reverseIterator.next());
    assertFalse(reverseIterator.hasNext());
  }
  @Test void pathsWithTheSameContentsShouldBeEqual(){
    Node node=createNode(1337L);
    Relationship relationship=createRelationship(1337L,7331L);
    Path firstPath=new PathImpl.Builder(node).push(relationship).build();
    Path secondPath=new PathImpl.Builder(node).push(relationship).build();
    assertEquals(firstPath,secondPath);
    assertEquals(secondPath,firstPath);
  }
  @Test void pathsWithDifferentLengthAreNotEqual(){
    Node node=createNode(1337L);
    Relationship relationship=createRelationship(1337L,7331L);
    Path firstPath=new PathImpl.Builder(node).push(relationship).build();
    Path secondPath=new PathImpl.Builder(node).push(relationship).push(createRelationship(1337L,7331L)).build();
    assertThat(firstPath,not(equalTo(secondPath)));
    assertThat(secondPath,not(equalTo(firstPath)));
  }
  @Test void testPathReverseNodes(){
    when(spi.newNodeProxy(Mockito.anyLong())).thenAnswer(new NodeProxyAnswer());
    Path path=new PathImpl.Builder(createNodeProxy(1)).push(createRelationshipProxy(1,2)).push(createRelationshipProxy(2,3)).build(new PathImpl.Builder(createNodeProxy(3)));
    Iterable<Node> nodes=path.reverseNodes();
    List<Node> nodeList=Iterables.asList(nodes);
    assertEquals(3,nodeList.size());
    assertEquals(3,nodeList.get(0).getId());
    assertEquals(2,nodeList.get(1).getId());
    assertEquals(1,nodeList.get(2).getId());
  }
  @Test void testPathNodes(){
    when(spi.newNodeProxy(Mockito.anyLong())).thenAnswer(new NodeProxyAnswer());
    Path path=new PathImpl.Builder(createNodeProxy(1)).push(createRelationshipProxy(1,2)).push(createRelationshipProxy(2,3)).build(new PathImpl.Builder(createNodeProxy(3)));
    Iterable<Node> nodes=path.nodes();
    List<Node> nodeList=Iterables.asList(nodes);
    assertEquals(3,nodeList.size());
    assertEquals(1,nodeList.get(0).getId());
    assertEquals(2,nodeList.get(1).getId());
    assertEquals(3,nodeList.get(2).getId());
  }
  private RelationshipProxy createRelationshipProxy(  int startNodeId,  int endNodeId){
    return new RelationshipProxy(spi,1L,startNodeId,1,endNodeId);
  }
  private NodeProxy createNodeProxy(  int nodeId){
    return new NodeProxy(spi,nodeId);
  }
  private static Node createNode(  long nodeId){
    Node node=mock(Node.class);
    when(node.getId()).thenReturn(nodeId);
    return node;
  }
  private static Relationship createRelationship(  long startNodeId,  long endNodeId){
    Relationship relationship=mock(Relationship.class);
    Node startNode=createNode(startNodeId);
    Node endNode=createNode(endNodeId);
    when(relationship.getStartNode()).thenReturn(startNode);
    when(relationship.getEndNode()).thenReturn(endNode);
    return relationship;
  }
private class NodeProxyAnswer implements Answer<NodeProxy> {
    @Override public NodeProxy answer(    InvocationOnMock invocation){
      return createNodeProxy(((Number)invocation.getArgument(0)).intValue());
    }
  }
}
