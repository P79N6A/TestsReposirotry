public class AbstractCheckPointThresholdTest {
  @Test public void shouldCallConsumerProvidingTheDescriptionWhenThresholdIsTrue(){
    String description="description";
    AbstractCheckPointThreshold threshold=new TheAbstractCheckPointThreshold(true,description);
    final AtomicReference<String> calledWith=new AtomicReference<>();
    threshold.isCheckPointingNeeded(42,calledWith::set);
    assertEquals(description,calledWith.get());
  }
  @Test public void shouldNotCallConsumerProvidingTheDescriptionWhenThresholdIsFalse(){
    AbstractCheckPointThreshold threshold=new TheAbstractCheckPointThreshold(false,null);
    threshold.isCheckPointingNeeded(42,s -> {
      throw new IllegalStateException("nooooooooo!");
    }
);
  }
private static class TheAbstractCheckPointThreshold extends AbstractCheckPointThreshold {
    private final boolean reached;
    TheAbstractCheckPointThreshold(    boolean reached,    String description){
      super(description);
      this.reached=reached;
    }
    @Override public void initialize(    long transactionId){
    }
    @Override public void checkPointHappened(    long transactionId){
    }
    @Override public long checkFrequencyMillis(){
      return DEFAULT_CHECKING_FREQUENCY_MILLIS;
    }
    @Override protected boolean thresholdReached(    long lastCommittedTransactionId){
      return reached;
    }
  }
}
