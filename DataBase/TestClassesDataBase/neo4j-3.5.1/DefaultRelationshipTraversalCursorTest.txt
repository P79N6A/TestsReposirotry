public class DefaultRelationshipTraversalCursorTest {
  private DefaultCursors pool=mock(DefaultCursors.class);
  private long node=42;
  private int type=9999;
  private int type2=9998;
  private long relationship=100;
  private long relationshipGroup=313;
  @Test public void regularSparseTraversal(){
    regularTraversal(relationship);
  }
  @Test public void regularSparseTraversalWithTxState(){
    regularTraversalWithTxState(relationship);
  }
  @Test public void regularDenseTraversal(){
    regularTraversal(RelationshipReferenceEncoding.encodeGroup(relationshipGroup));
  }
  @Test public void regularDenseTraversalWithTxState(){
    regularTraversalWithTxState(RelationshipReferenceEncoding.encodeGroup(relationshipGroup));
  }
  @Test public void sparseTraversalWithTxStateFiltering(){
    StorageRelationshipTraversalCursor storeCursor=storeCursor(rel(100,node,50,type),rel(102,node,51,type),rel(104,node,52,type));
    DefaultRelationshipTraversalCursor cursor=new DefaultRelationshipTraversalCursor(pool,storeCursor);
    Read read=txState(rel(3,node,50,type),rel(4,50,node,type),rel(5,node,50,type2),rel(6,node,node,type),rel(7,node,52,type));
    cursor.init(node,RelationshipReferenceEncoding.encodeForTxStateFiltering(relationship),read);
    assertRelationships(cursor,100,3,7,102,104);
  }
  @Test public void sparseTraversalWithFiltering(){
    StorageRelationshipTraversalCursor storeCursor=storeCursor(rel(100,50,node,type),rel(101,node,50,type),rel(102,50,node,type2),rel(103,51,node,type),rel(104,node,node,type));
    DefaultRelationshipTraversalCursor cursor=new DefaultRelationshipTraversalCursor(pool,storeCursor);
    Read read=txState(rel(3,node,50,type),rel(4,50,node,type),rel(5,node,50,type2),rel(6,node,node,type),rel(7,node,52,type));
    cursor.init(node,RelationshipReferenceEncoding.encodeForFiltering(relationship),read);
    assertRelationships(cursor,100,4,103);
  }
  @Test public void emptyStoreOutgoingOfType(){
    StorageRelationshipTraversalCursor storeCursor=emptyStoreCursor();
    DefaultRelationshipTraversalCursor cursor=new DefaultRelationshipTraversalCursor(pool,storeCursor);
    Read read=txState(rel(3,node,50,type),rel(4,50,node,type),rel(5,node,50,type2),rel(6,node,node,type),rel(7,node,52,type));
    cursor.init(node,RelationshipReferenceEncoding.encodeNoOutgoingRels(type),read);
    assertRelationships(cursor,3,7);
  }
  @Test public void emptyStoreIncomingOfType(){
    StorageRelationshipTraversalCursor storeCursor=emptyStoreCursor();
    DefaultRelationshipTraversalCursor cursor=new DefaultRelationshipTraversalCursor(pool,storeCursor);
    Read read=txState(rel(3,node,50,type),rel(4,50,node,type),rel(5,50,node,type2),rel(6,node,node,type),rel(7,56,node,type),rel(8,node,52,type));
    cursor.init(node,RelationshipReferenceEncoding.encodeNoIncomingRels(type),read);
    assertRelationships(cursor,4,7);
  }
  @Test public void emptyStoreLoopsOfType(){
    StorageRelationshipTraversalCursor storeCursor=emptyStoreCursor();
    DefaultRelationshipTraversalCursor cursor=new DefaultRelationshipTraversalCursor(pool,storeCursor);
    Read read=txState(rel(3,node,50,type),rel(2,node,node,type),rel(5,50,node,type2),rel(6,node,node,type),rel(7,56,node,type),rel(8,node,52,type));
    cursor.init(node,RelationshipReferenceEncoding.encodeNoLoopRels(type),read);
    assertRelationships(cursor,2,6);
  }
  private void regularTraversal(  long reference){
    StorageRelationshipTraversalCursor storeCursor=storeCursor(100,102,104);
    DefaultRelationshipTraversalCursor cursor=new DefaultRelationshipTraversalCursor(pool,storeCursor);
    Read read=emptyTxState();
    cursor.init(node,reference,read);
    assertRelationships(cursor,100,102,104);
  }
  private void regularTraversalWithTxState(  long reference){
    StorageRelationshipTraversalCursor storeCursor=storeCursor(100,102,104);
    DefaultRelationshipTraversalCursor cursor=new DefaultRelationshipTraversalCursor(pool,storeCursor);
    Read read=txState(3,4);
    cursor.init(node,reference,read);
    assertRelationships(cursor,3,4,100,102,104);
  }
  private Read emptyTxState(){
    return mock(Read.class);
  }
  private Read txState(  long... ids){
    return txState(LongStream.of(ids).mapToObj(id -> rel(id,node,node,type)).toArray(Rel[]::new));
  }
  private Read txState(  Rel... rels){
    Read read=mock(Read.class);
    if (rels.length > 0) {
      TxState txState=new TxState();
      for (      Rel rel : rels) {
        txState.relationshipDoCreate(rel.relId,rel.type,rel.sourceId,rel.targetId);
      }
      when(read.hasTxStateWithChanges()).thenReturn(true);
      when(read.txState()).thenReturn(txState);
    }
    return read;
  }
  private void assertRelationships(  DefaultRelationshipTraversalCursor cursor,  long... expected){
    for (    long expectedId : expected) {
      assertTrue(cursor.next(),"Expected relationship " + expectedId + " but got none");
      assertEquals(expectedId,cursor.relationshipReference(),"Expected relationship " + expectedId + " got "+ cursor.relationshipReference());
    }
    assertFalse(cursor.next(),"Expected no more relationships, but got " + cursor.relationshipReference());
  }
  private Rel rel(  long relId,  long startId,  long endId,  int type){
    return new Rel(relId,startId,endId,type);
  }
  private Rel NO_REL=rel(-1L,-1L,-1L,-1);
private class Rel {
    final long relId;
    final long sourceId;
    final long targetId;
    final int type;
    Rel(    long relId,    long sourceId,    long targetId,    int type){
      this.relId=relId;
      this.sourceId=sourceId;
      this.targetId=targetId;
      this.type=type;
    }
  }
  private StorageRelationshipTraversalCursor emptyStoreCursor(  long... ids){
    return storeCursor(new Rel[0]);
  }
  private StorageRelationshipTraversalCursor storeCursor(  long... ids){
    return storeCursor(LongStream.of(ids).mapToObj(id -> rel(id,-1L,-1L,-1)).toArray(Rel[]::new));
  }
  private StorageRelationshipTraversalCursor storeCursor(  Rel... rels){
    return new StorageRelationshipTraversalCursor(){
      private int i=-1;
      private Rel rel=NO_REL;
      @Override public long neighbourNodeReference(){
        return rel.sourceId == node ? rel.targetId : rel.sourceId;
      }
      @Override public long originNodeReference(){
        return node;
      }
      @Override public void init(      long nodeReference,      long reference){
      }
      @Override public int type(){
        return rel.type;
      }
      @Override public long sourceNodeReference(){
        return rel.sourceId;
      }
      @Override public long targetNodeReference(){
        return rel.targetId;
      }
      @Override public void visit(      long relationshipId,      int typeId,      long startNodeId,      long endNodeId){
        rel=rel(relationshipId,startNodeId,endNodeId,typeId);
      }
      @Override public boolean hasProperties(){
        throw new UnsupportedOperationException("not implemented");
      }
      @Override public long propertiesReference(){
        throw new UnsupportedOperationException("not implemented");
      }
      @Override public long entityReference(){
        return rel.relId;
      }
      @Override public boolean next(){
        i++;
        if (i < 0 || i >= rels.length) {
          rel=NO_REL;
          return false;
        }
 else {
          rel=rels[i];
          return true;
        }
      }
      @Override public void reset(){
      }
      @Override public void close(){
      }
    }
;
  }
}
