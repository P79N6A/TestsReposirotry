/** 
 * Asserts that pure read operations does not write records to logical or transaction logs.
 */
public class ReadTransactionLogWritingTest {
  @Rule public final DatabaseRule dbr=new ImpermanentDatabaseRule();
  private final Label label=label("Test");
  private Node node;
  private Relationship relationship;
  private long logEntriesWrittenBeforeReadOperations;
  @Before public void createDataset(){
    GraphDatabaseAPI db=dbr.getGraphDatabaseAPI();
    try (Transaction tx=db.beginTx()){
      node=db.createNode(label);
      node.setProperty("short",123);
      node.setProperty("long",longString(300));
      relationship=node.createRelationshipTo(db.createNode(),MyRelTypes.TEST);
      relationship.setProperty("short",123);
      relationship.setProperty("long",longString(300));
      tx.success();
    }
     logEntriesWrittenBeforeReadOperations=countLogEntries();
  }
  @Test public void shouldNotWriteAnyLogCommandInPureReadTransaction(){
    executeTransaction(getRelationships());
    executeTransaction(getProperties());
    executeTransaction(getById());
    executeTransaction(getNodesFromRelationship());
    long actualCount=countLogEntries();
    assertEquals("There were " + (actualCount - logEntriesWrittenBeforeReadOperations) + " log entries written during one or more pure read transactions",logEntriesWrittenBeforeReadOperations,actualCount);
  }
  private long countLogEntries(){
    GraphDatabaseAPI db=dbr.getGraphDatabaseAPI();
    FileSystemAbstraction fs=db.getDependencyResolver().resolveDependency(FileSystemAbstraction.class);
    LogFiles logFiles=db.getDependencyResolver().resolveDependency(LogFiles.class);
    try {
      CountingLogHook<LogEntry> logicalLogCounter=new CountingLogHook<>();
      filterNeostoreLogicalLog(logFiles,fs,logicalLogCounter);
      long txLogRecordCount=logFiles.getLogFileInformation().getLastEntryId();
      return logicalLogCounter.getCount() + txLogRecordCount;
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  private String longString(  int length){
    char[] characters=new char[length];
    for (int i=0; i < length; i++) {
      characters[i]=(char)('a' + i % 10);
    }
    return new String(characters);
  }
  private void executeTransaction(  Runnable runnable){
    executeTransaction(runnable,true);
    executeTransaction(runnable,false);
  }
  private void executeTransaction(  Runnable runnable,  boolean success){
    try (Transaction tx=dbr.getGraphDatabaseAPI().beginTx()){
      runnable.run();
      if (success) {
        tx.success();
      }
    }
   }
  private Runnable getRelationships(){
    return () -> assertEquals(1,Iterables.count(node.getRelationships()));
  }
  private Runnable getNodesFromRelationship(){
    return () -> {
      relationship.getEndNode();
      relationship.getStartNode();
      relationship.getNodes();
      relationship.getOtherNode(node);
    }
;
  }
  private Runnable getById(){
    return () -> {
      dbr.getGraphDatabaseAPI().getNodeById(node.getId());
      dbr.getGraphDatabaseAPI().getRelationshipById(relationship.getId());
    }
;
  }
  private Runnable getProperties(){
    return new Runnable(){
      @Override public void run(){
        getAllProperties(node);
        getAllProperties(relationship);
      }
      private void getAllProperties(      PropertyContainer entity){
        for (        String key : entity.getPropertyKeys()) {
          entity.getProperty(key);
        }
      }
    }
;
  }
}
