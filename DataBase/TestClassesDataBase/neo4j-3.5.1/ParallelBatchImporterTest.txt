@RunWith(Parameterized.class) public class ParallelBatchImporterTest {
  private static final int NUMBER_OF_ID_GROUPS=5;
  private final TestDirectory directory=TestDirectory.testDirectory();
  private final RandomRule random=new RandomRule();
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  private final SuppressOutput suppressOutput=SuppressOutput.suppressAll();
  @Rule public RuleChain ruleChain=RuleChain.outerRule(directory).around(random).around(fileSystemRule).around(suppressOutput);
  private static final int NODE_COUNT=10_000;
  private static final int RELATIONSHIPS_PER_NODE=5;
  private static final int RELATIONSHIP_COUNT=NODE_COUNT * RELATIONSHIPS_PER_NODE;
  private static final int RELATIONSHIP_TYPES=3;
  protected final Configuration config=new Configuration(){
    @Override public int batchSize(){
      return 100;
    }
    @Override public int denseNodeThreshold(){
      return RELATIONSHIPS_PER_NODE * 2;
    }
    @Override public int maxNumberOfProcessors(){
      int cores=Runtime.getRuntime().availableProcessors();
      return random.intBetween(cores,cores + 100);
    }
    @Override public long maxMemoryUsage(){
      double ratio=NODE_COUNT / 1_000D;
      long mebi=mebiBytes(1);
      return random.nextInt((int)(ratio * mebi / 2),(int)(ratio * mebi));
    }
  }
;
  private final InputIdGenerator inputIdGenerator;
  private final Function<Groups,IdMapper> idMapper;
  @Parameterized.Parameters(name="{0},{1},{3}") public static Collection<Object[]> data(){
    return Arrays.asList(new Object[]{new LongInputIdGenerator(),(Function<Groups,IdMapper>)groups -> longs(AUTO_WITHOUT_PAGECACHE,groups)},new Object[]{new StringInputIdGenerator(),(Function<Groups,IdMapper>)groups -> strings(AUTO_WITHOUT_PAGECACHE,groups)});
  }
  public ParallelBatchImporterTest(  InputIdGenerator inputIdGenerator,  Function<Groups,IdMapper> idMapper){
    this.inputIdGenerator=inputIdGenerator;
    this.idMapper=idMapper;
  }
  @Test public void shouldImportCsvData() throws Exception {
    ExecutionMonitor processorAssigner=eagerRandomSaturation(config.maxNumberOfProcessors());
    DatabaseLayout databaseLayout=directory.databaseLayout("dir" + random.nextAlphaNumericString(8,8));
    boolean successful=false;
    Groups groups=new Groups();
    IdGroupDistribution groupDistribution=new IdGroupDistribution(NODE_COUNT,NUMBER_OF_ID_GROUPS,random.random(),groups);
    long nodeRandomSeed=random.nextLong();
    long relationshipRandomSeed=random.nextLong();
    JobScheduler jobScheduler=new ThreadPoolJobScheduler();
    final BatchImporter inserter=new ParallelBatchImporter(databaseLayout,fileSystemRule.get(),null,config,NullLogService.getInstance(),processorAssigner,EMPTY,Config.defaults(),getFormat(),NO_MONITOR,jobScheduler);
    try {
      inserter.doImport(Inputs.input(nodes(nodeRandomSeed,NODE_COUNT,config.batchSize(),inputIdGenerator,groupDistribution),relationships(relationshipRandomSeed,RELATIONSHIP_COUNT,config.batchSize(),inputIdGenerator,groupDistribution),idMapper.apply(groups),silentBadCollector(RELATIONSHIP_COUNT),knownEstimates(NODE_COUNT,RELATIONSHIP_COUNT,NODE_COUNT * TOKENS.length / 2,RELATIONSHIP_COUNT * TOKENS.length / 2,NODE_COUNT * TOKENS.length / 2 * Long.BYTES,RELATIONSHIP_COUNT * TOKENS.length / 2 * Long.BYTES,NODE_COUNT * TOKENS.length / 2)));
      GraphDatabaseService db=new TestGraphDatabaseFactory().newEmbeddedDatabaseBuilder(databaseLayout.databaseDirectory()).setConfig("dbms.backup.enabled","false").newGraphDatabase();
      try (Transaction tx=db.beginTx()){
        inputIdGenerator.reset();
        verifyData(NODE_COUNT,RELATIONSHIP_COUNT,db,groupDistribution,nodeRandomSeed,relationshipRandomSeed);
        tx.success();
      }
  finally {
        db.shutdown();
      }
      assertConsistent(databaseLayout);
      successful=true;
    }
  finally {
      jobScheduler.close();
      if (!successful) {
        File failureFile=new File(databaseLayout.databaseDirectory(),"input");
        try (PrintStream out=new PrintStream(failureFile)){
          out.println("Seed used in this failing run: " + random.seed());
          out.println(inputIdGenerator);
          inputIdGenerator.reset();
          out.println();
          out.println("Processor assignments");
          out.println(processorAssigner.toString());
        }
         System.err.println("Additional debug information stored in " + failureFile);
      }
    }
  }
  protected void assertConsistent(  DatabaseLayout databaseLayout) throws ConsistencyCheckIncompleteException {
    ConsistencyCheckService consistencyChecker=new ConsistencyCheckService();
    Result result=consistencyChecker.runFullConsistencyCheck(databaseLayout,Config.defaults(GraphDatabaseSettings.pagecache_memory,"8m"),ProgressMonitorFactory.NONE,NullLogProvider.getInstance(),false);
    assertTrue("Database contains inconsistencies, there should be a report in " + databaseLayout.databaseDirectory(),result.isSuccessful());
  }
  protected RecordFormats getFormat(){
    return Standard.LATEST_RECORD_FORMATS;
  }
private static class ExistingId {
    private final Object id;
    private final long nodeIndex;
    ExistingId(    Object id,    long nodeIndex){
      this.id=id;
      this.nodeIndex=nodeIndex;
    }
  }
public abstract static class InputIdGenerator {
    abstract void reset();
    abstract Object nextNodeId(    RandomValues random,    long item);
    abstract ExistingId randomExisting(    RandomValues random);
    abstract Object miss(    RandomValues random,    Object id,    float chance);
    abstract boolean isMiss(    Object id);
    String randomType(    RandomValues random){
      return "TYPE" + random.nextInt(RELATIONSHIP_TYPES);
    }
    @Override public String toString(){
      return getClass().getSimpleName();
    }
  }
private static class LongInputIdGenerator extends InputIdGenerator {
    @Override void reset(){
    }
    @Override synchronized Object nextNodeId(    RandomValues random,    long item){
      return item;
    }
    @Override ExistingId randomExisting(    RandomValues random){
      long index=random.nextInt(NODE_COUNT);
      return new ExistingId(index,index);
    }
    @Override Object miss(    RandomValues random,    Object id,    float chance){
      return random.nextFloat() < chance ? (Long)id + 100_000_000 : id;
    }
    @Override boolean isMiss(    Object id){
      return (Long)id >= 100_000_000;
    }
  }
private static class StringInputIdGenerator extends InputIdGenerator {
    private final String[] strings=new String[NODE_COUNT];
    @Override void reset(){
      Arrays.fill(strings,null);
    }
    @Override Object nextNodeId(    RandomValues random,    long item){
      byte[] randomBytes=random.nextByteArray(10,10).asObjectCopy();
      String result=UUID.nameUUIDFromBytes(randomBytes).toString();
      strings[toIntExact(item)]=result;
      return result;
    }
    @Override ExistingId randomExisting(    RandomValues random){
      int index=random.nextInt(strings.length);
      return new ExistingId(strings[index],index);
    }
    @Override Object miss(    RandomValues random,    Object id,    float chance){
      return random.nextFloat() < chance ? "_" + id : id;
    }
    @Override boolean isMiss(    Object id){
      return ((String)id).startsWith("_");
    }
  }
  private void verifyData(  int nodeCount,  int relationshipCount,  GraphDatabaseService db,  IdGroupDistribution groups,  long nodeRandomSeed,  long relationshipRandomSeed) throws IOException {
    try (InputIterator nodes=nodes(nodeRandomSeed,nodeCount,config.batchSize(),inputIdGenerator,groups).iterator();InputIterator relationships=relationships(relationshipRandomSeed,relationshipCount,config.batchSize(),inputIdGenerator,groups).iterator();ResourceIterator<Node> dbNodes=db.getAllNodes().iterator()){
      Map<String,Node> nodeByInputId=new HashMap<>(nodeCount);
      while (dbNodes.hasNext()) {
        Node node=dbNodes.next();
        String id=(String)node.getProperty("id");
        assertNull(nodeByInputId.put(id,node));
      }
      int verifiedNodes=0;
      long allNodesScanLabelCount=0;
      InputChunk chunk=nodes.newChunk();
      InputEntity input=new InputEntity();
      while (nodes.next(chunk)) {
        while (chunk.next(input)) {
          String iid=uniqueId(input.idGroup,input.objectId);
          Node node=nodeByInputId.get(iid);
          assertNodeEquals(input,node);
          verifiedNodes++;
          assertDegrees(node);
          allNodesScanLabelCount+=Iterables.count(node.getLabels());
        }
      }
      assertEquals(nodeCount,verifiedNodes);
      long labelScanStoreEntryCount=db.getAllLabels().stream().flatMap(l -> db.findNodes(l).stream()).count();
      assertEquals(format("Expected label scan store and node store to have same number labels. But %n" + "#labelsInNodeStore=%d%n" + "#labelsInLabelScanStore=%d%n",allNodesScanLabelCount,labelScanStoreEntryCount),allNodesScanLabelCount,labelScanStoreEntryCount);
      chunk=relationships.newChunk();
      Map<String,Relationship> relationshipByName=new HashMap<>();
      for (      Relationship relationship : db.getAllRelationships()) {
        relationshipByName.put((String)relationship.getProperty("id"),relationship);
      }
      int verifiedRelationships=0;
      while (relationships.next(chunk)) {
        while (chunk.next(input)) {
          if (!inputIdGenerator.isMiss(input.objectStartId) && !inputIdGenerator.isMiss(input.objectEndId)) {
            String name=(String)propertyOf(input,"id");
            Relationship relationship=relationshipByName.get(name);
            assertNotNull("Expected there to be a relationship with name '" + name + "'",relationship);
            assertEquals(nodeByInputId.get(uniqueId(input.startIdGroup,input.objectStartId)),relationship.getStartNode());
            assertEquals(nodeByInputId.get(uniqueId(input.endIdGroup,input.objectEndId)),relationship.getEndNode());
            assertRelationshipEquals(input,relationship);
          }
          verifiedRelationships++;
        }
      }
      assertEquals(relationshipCount,verifiedRelationships);
    }
   }
  private void assertDegrees(  Node node){
    for (    RelationshipType type : node.getRelationshipTypes()) {
      for (      Direction direction : Direction.values()) {
        long degree=node.getDegree(type,direction);
        long actualDegree=count(node.getRelationships(type,direction));
        assertEquals(actualDegree,degree);
      }
    }
  }
  private String uniqueId(  Group group,  PropertyContainer entity){
    return uniqueId(group,entity.getProperty("id"));
  }
  private String uniqueId(  Group group,  Object id){
    return group.name() + "_" + id;
  }
  private Object propertyOf(  InputEntity input,  String key){
    Object[] properties=input.properties();
    for (int i=0; i < properties.length; i++) {
      if (properties[i++].equals(key)) {
        return properties[i];
      }
    }
    throw new IllegalStateException(key + " not found on " + input);
  }
  private void assertRelationshipEquals(  InputEntity input,  Relationship relationship){
    assertPropertiesEquals(input,relationship);
    assertEquals(input.stringType,relationship.getType().name());
  }
  private void assertNodeEquals(  InputEntity input,  Node node){
    assertPropertiesEquals(input,node);
    Set<String> expectedLabels=asSet(input.labels());
    for (    Label label : node.getLabels()) {
      assertTrue(expectedLabels.remove(label.name()));
    }
    assertTrue(expectedLabels.isEmpty());
  }
  private void assertPropertiesEquals(  InputEntity input,  PropertyContainer entity){
    Object[] properties=input.properties();
    for (int i=0; i < properties.length; i++) {
      String key=(String)properties[i++];
      Object value=properties[i];
      assertPropertyValueEquals(input,entity,key,value,entity.getProperty(key));
    }
  }
  private void assertPropertyValueEquals(  InputEntity input,  PropertyContainer entity,  String key,  Object expected,  Object array){
    if (expected.getClass().isArray()) {
      int length=Array.getLength(expected);
      assertEquals(input + ", " + entity,length,Array.getLength(array));
      for (int i=0; i < length; i++) {
        assertPropertyValueEquals(input,entity,key,Array.get(expected,i),Array.get(array,i));
      }
    }
 else {
      assertEquals(input + ", " + entity+ " for key:"+ key,Values.of(expected),Values.of(array));
    }
  }
  private InputIterable relationships(  final long randomSeed,  final long count,  int batchSize,  final InputIdGenerator idGenerator,  final IdGroupDistribution groups){
    return () -> new GeneratingInputIterator<>(count,batchSize,new RandomsStates(randomSeed),(randoms,visitor,id) -> {
      randomProperties(randoms,"Name " + id,visitor);
      ExistingId startNodeExistingId=idGenerator.randomExisting(randoms);
      Group startNodeGroup=groups.groupOf(startNodeExistingId.nodeIndex);
      ExistingId endNodeExistingId=idGenerator.randomExisting(randoms);
      Group endNodeGroup=groups.groupOf(endNodeExistingId.nodeIndex);
      Object startNode=idGenerator.miss(randoms,startNodeExistingId.id,0.001f);
      Object endNode=idGenerator.miss(randoms,endNodeExistingId.id,0.001f);
      visitor.startId(startNode,startNodeGroup);
      visitor.endId(endNode,endNodeGroup);
      String type=idGenerator.randomType(randoms);
      if (randoms.nextFloat() < 0.00005) {
        type+="_odd";
      }
      visitor.type(type);
    }
,0);
  }
  private InputIterable nodes(  final long randomSeed,  final long count,  int batchSize,  final InputIdGenerator inputIdGenerator,  final IdGroupDistribution groups){
    return () -> new GeneratingInputIterator<>(count,batchSize,new RandomsStates(randomSeed),(randoms,visitor,id) -> {
      Object nodeId=inputIdGenerator.nextNodeId(randoms,id);
      Group group=groups.groupOf(id);
      visitor.id(nodeId,group);
      randomProperties(randoms,uniqueId(group,nodeId),visitor);
      visitor.labels(randoms.selection(TOKENS,0,TOKENS.length,true));
    }
,0);
  }
  private static final String[] TOKENS={"token1","token2","token3","token4","token5","token6","token7"};
  private void randomProperties(  RandomValues randoms,  Object id,  InputEntityVisitor visitor){
    String[] keys=randoms.selection(TOKENS,0,TOKENS.length,false);
    for (    String key : keys) {
      visitor.property(key,randoms.nextValue().asObject());
    }
    visitor.property("id",id);
  }
}
