public class RecordPropertyCursorTest {
  @Rule public final PageCacheAndDependenciesRule storage=new PageCacheAndDependenciesRule();
  @Rule public final RandomRule random=new RandomRule().withConfiguration(new RandomValues.Default(){
    @Override public int stringMaxLength(){
      return 10_000;
    }
  }
);
  private NeoStores neoStores;
  private PropertyCreator creator;
  private NodeRecord owner;
  @Before public void setup(){
    neoStores=new StoreFactory(storage.directory().databaseLayout(),Config.defaults(),new DefaultIdGeneratorFactory(storage.fileSystem()),storage.pageCache(),storage.fileSystem(),NullLogProvider.getInstance(),EmptyVersionContextSupplier.EMPTY).openAllNeoStores(true);
    creator=new PropertyCreator(neoStores.getPropertyStore(),new PropertyTraverser());
    owner=neoStores.getNodeStore().newRecord();
  }
  @After public void closeStore(){
    neoStores.close();
  }
  @Test public void shouldReadPropertyChain(){
    Value[] values=createValues();
    long firstPropertyId=storeValuesAsPropertyChain(creator,owner,values);
    assertPropertyChain(values,firstPropertyId,createCursor());
  }
  @Test public void shouldReuseCursor(){
    Value[] valuesA=createValues();
    long firstPropertyIdA=storeValuesAsPropertyChain(creator,owner,valuesA);
    Value[] valuesB=createValues();
    long firstPropertyIdB=storeValuesAsPropertyChain(creator,owner,valuesB);
    RecordPropertyCursor cursor=createCursor();
    assertPropertyChain(valuesA,firstPropertyIdA,cursor);
    assertPropertyChain(valuesB,firstPropertyIdB,cursor);
  }
  @Test public void closeShouldBeIdempotent(){
    RecordPropertyCursor cursor=createCursor();
    cursor.close();
    cursor.close();
  }
  private RecordPropertyCursor createCursor(){
    return new RecordPropertyCursor(neoStores.getPropertyStore());
  }
  private void assertPropertyChain(  Value[] values,  long firstPropertyId,  RecordPropertyCursor cursor){
    Map<Integer,Value> expectedValues=asMap(values);
    cursor.init(firstPropertyId);
    while (cursor.next()) {
      assertEquals(expectedValues.remove(cursor.propertyKey()),cursor.propertyValue());
    }
    assertTrue(expectedValues.isEmpty());
  }
  private Value[] createValues(){
    int numberOfProperties=random.nextInt(1,20);
    Value[] values=new Value[numberOfProperties];
    for (int key=0; key < numberOfProperties; key++) {
      values[key]=random.nextValue();
    }
    return values;
  }
  private long storeValuesAsPropertyChain(  PropertyCreator creator,  NodeRecord owner,  Value[] values){
    DirectRecordAccessSet access=new DirectRecordAccessSet(neoStores);
    long firstPropertyId=creator.createPropertyChain(owner,blocksOf(creator,values),access.getPropertyRecords());
    access.close();
    return firstPropertyId;
  }
  private Map<Integer,Value> asMap(  Value[] values){
    Map<Integer,Value> map=new HashMap<>();
    for (int key=0; key < values.length; key++) {
      map.put(key,values[key]);
    }
    return map;
  }
  private Iterator<PropertyBlock> blocksOf(  PropertyCreator creator,  Value[] values){
    return new IteratorWrapper<PropertyBlock,Value>(iterator(values)){
      int key;
      @Override protected PropertyBlock underlyingObjectToObject(      Value value){
        return creator.encodePropertyValue(key++,value);
      }
    }
;
  }
}
