public class ConcurrentTransactionAccessTest {
  @Test public void shouldThrowSpecificExceptionOnConcurrentTransactionAccess() throws Exception {
    TransactionRegistry registry=new TransactionHandleRegistry(mock(Clock.class),0,NullLogProvider.getInstance());
    TransitionalPeriodTransactionMessContainer kernel=mock(TransitionalPeriodTransactionMessContainer.class);
    GraphDatabaseQueryService queryService=mock(GraphDatabaseQueryService.class);
    TransitionalTxManagementKernelTransaction kernelTransaction=mock(TransitionalTxManagementKernelTransaction.class);
    when(kernel.newTransaction(any(KernelTransaction.Type.class),any(LoginContext.class),anyLong())).thenReturn(kernelTransaction);
    TransactionFacade actions=new TransactionFacade(kernel,null,queryService,registry,NullLogProvider.getInstance());
    final TransactionHandle transactionHandle=actions.newTransactionHandle(new DisgustingUriScheme(),true,LoginContext.AUTH_DISABLED,-1);
    final DoubleLatch latch=new DoubleLatch();
    final StatementDeserializer statements=mock(StatementDeserializer.class);
    when(statements.hasNext()).thenAnswer(invocation -> {
      latch.startAndWaitForAllToStartAndFinish();
      return false;
    }
);
    new Thread(() -> {
      transactionHandle.execute(statements,mock(ExecutionResultSerializer.class),mock(HttpServletRequest.class));
    }
).start();
    latch.waitForAllToStart();
    try {
      actions.findTransactionHandle(DisgustingUriScheme.parseTxId(transactionHandle.uri()));
      fail("should have thrown exception");
    }
 catch (    InvalidConcurrentTransactionAccess neo4jError) {
    }
 finally {
      latch.finish();
    }
  }
private static class DisgustingUriScheme implements TransactionUriScheme {
    private static long parseTxId(    URI txUri){
      return parseLong(txUri.toString());
    }
    @Override public URI txUri(    long id){
      return URI.create(String.valueOf(id));
    }
    @Override public URI txCommitUri(    long id){
      return txUri(id);
    }
  }
}
