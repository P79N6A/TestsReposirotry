public class MultiExecutionMonitorTest {
  @Rule public final CleanupRule cleanup=new CleanupRule();
  @Test public void shouldCheckMultipleMonitors(){
    FakeClock clock=Clocks.fakeClock();
    TestableMonitor first=new TestableMonitor(clock,100,MILLISECONDS,"first");
    TestableMonitor other=new TestableMonitor(clock,250,MILLISECONDS,"other");
    MultiExecutionMonitor multiMonitor=new MultiExecutionMonitor(clock,first,other);
    clock.forward(110,MILLISECONDS);
    expectCallsToCheck(multiMonitor,first,1,other,0);
    clock.forward(100,MILLISECONDS);
    expectCallsToCheck(multiMonitor,first,2,other,0);
    clock.forward(45,MILLISECONDS);
    expectCallsToCheck(multiMonitor,first,2,other,1);
  }
  private void expectCallsToCheck(  ExecutionMonitor multiMonitor,  Object... alternatingMonitorAndCount){
    multiMonitor.check(null);
    for (int i=0; i < alternatingMonitorAndCount.length; i++) {
      TestableMonitor monitor=(TestableMonitor)alternatingMonitorAndCount[i++];
      int count=(Integer)alternatingMonitorAndCount[i];
      assertThat(monitor.timesPolled,lessThanOrEqualTo(count));
      if (monitor.timesPolled < count) {
        fail("Polls didn't occur, expected " + Arrays.toString(alternatingMonitorAndCount));
      }
    }
  }
private static class TestableMonitor extends ExecutionMonitor.Adapter {
    private int timesPolled;
    private final String name;
    TestableMonitor(    Clock clock,    long interval,    TimeUnit unit,    String name){
      super(clock,interval,unit);
      this.name=name;
    }
    @Override public void check(    StageExecution execution){
      timesPolled++;
    }
    @Override public String toString(){
      return "[" + name + ":"+ timesPolled+ "]";
    }
  }
}
