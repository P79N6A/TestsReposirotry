public class TwoPhaseNodeForRelationshipLockingTest {
  private final Transaction transaction=mock(Transaction.class);
  private final Locks.Client locks=mock(Locks.Client.class);
  private final long nodeId=42L;
  private static int TYPE=77;
  @Test public void shouldLockNodesInOrderAndConsumeTheRelationships() throws Throwable {
    Collector collector=new Collector();
    TwoPhaseNodeForRelationshipLocking locking=new TwoPhaseNodeForRelationshipLocking(collector,locks,NONE);
    returnRelationships(transaction,false,new TestRelationshipChain(nodeId).outgoing(21L,43L,0).incoming(22L,40L,TYPE).outgoing(23L,41L,TYPE).outgoing(2L,3L,TYPE).incoming(3L,49L,TYPE).outgoing(50L,41L,TYPE));
    InOrder inOrder=inOrder(locks);
    locking.lockAllNodesAndConsumeRelationships(nodeId,transaction,new StubNodeCursor(false));
    inOrder.verify(locks).acquireExclusive(NONE,NODE,3L,40L,41L,nodeId,43L,49L);
    assertEquals(set(21L,22L,23L,2L,3L,50L),collector.set);
  }
  @Test public void shouldLockNodesInOrderAndConsumeTheRelationshipsAndRetryIfTheNewRelationshipsAreCreated() throws Throwable {
    Collector collector=new Collector();
    TwoPhaseNodeForRelationshipLocking locking=new TwoPhaseNodeForRelationshipLocking(collector,locks,NONE);
    TestRelationshipChain chain=new TestRelationshipChain(nodeId).outgoing(21L,43L,TYPE).incoming(22L,40,TYPE).outgoing(23L,41L,TYPE);
    returnRelationships(transaction,true,chain);
    InOrder inOrder=inOrder(locks);
    locking.lockAllNodesAndConsumeRelationships(nodeId,transaction,new StubNodeCursor(false));
    inOrder.verify(locks).acquireExclusive(NONE,NODE,40L,41L,nodeId);
    inOrder.verify(locks).releaseExclusive(NODE,40L,41L,nodeId);
    inOrder.verify(locks).acquireExclusive(NONE,NODE,40L,41L,nodeId,43L);
    assertEquals(set(21L,22L,23L),collector.set);
  }
  @Test public void lockNodeWithoutRelationships() throws Exception {
    Collector collector=new Collector();
    TwoPhaseNodeForRelationshipLocking locking=new TwoPhaseNodeForRelationshipLocking(collector,locks,NONE);
    returnRelationships(transaction,false,new TestRelationshipChain(42));
    locking.lockAllNodesAndConsumeRelationships(nodeId,transaction,new StubNodeCursor(false));
    verify(locks).acquireExclusive(NONE,NODE,nodeId);
    verifyNoMoreInteractions(locks);
  }
  static void returnRelationships(  Transaction transaction,  final boolean skipFirst,  final TestRelationshipChain relIds) throws EntityNotFoundException {
    StubRead read=new StubRead();
    when(transaction.dataRead()).thenReturn(read);
    StubCursorFactory cursorFactory=new StubCursorFactory(true);
    if (skipFirst) {
      cursorFactory.withRelationshipTraversalCursors(new StubRelationshipCursor(relIds.tail()),new StubRelationshipCursor(relIds));
    }
 else {
      cursorFactory.withRelationshipTraversalCursors(new StubRelationshipCursor(relIds));
    }
    when(transaction.cursors()).thenReturn(cursorFactory);
  }
private static class Collector implements ThrowingConsumer<Long,KernelException> {
    public final Set<Long> set=new HashSet<>();
    @Override public void accept(    Long input) throws KernelException {
      assertNotNull(input);
      set.add(input);
    }
  }
}
