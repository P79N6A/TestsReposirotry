public class NeoStoreIndexStoreViewTest {
  @Rule public EmbeddedDatabaseRule dbRule=new EmbeddedDatabaseRule();
  private final Map<Long,Lock> lockMocks=new HashMap<>();
  private final Label label=Label.label("Person");
  private final RelationshipType relationshipType=RelationshipType.withName("Knows");
  private GraphDatabaseAPI graphDb;
  private NeoStoreIndexStoreView storeView;
  private int labelId;
  private int relTypeId;
  private int propertyKeyId;
  private int relPropertyKeyId;
  private Node alistair;
  private Node stefan;
  private LockService locks;
  private NeoStores neoStores;
  private Relationship aKnowsS;
  private Relationship sKnowsA;
  private StorageReader reader;
  @Before public void before() throws KernelException {
    graphDb=dbRule.getGraphDatabaseAPI();
    createAlistairAndStefanNodes();
    getOrCreateIds();
    neoStores=graphDb.getDependencyResolver().resolveDependency(RecordStorageEngine.class).testAccessNeoStores();
    locks=mock(LockService.class);
    when(locks.acquireNodeLock(anyLong(),any())).thenAnswer(invocation -> {
      Long nodeId=invocation.getArgument(0);
      return lockMocks.computeIfAbsent(nodeId,k -> mock(Lock.class));
    }
);
    when(locks.acquireRelationshipLock(anyLong(),any())).thenAnswer(invocation -> {
      Long nodeId=invocation.getArgument(0);
      return lockMocks.computeIfAbsent(nodeId,k -> mock(Lock.class));
    }
);
    storeView=new NeoStoreIndexStoreView(locks,neoStores);
    reader=new RecordStorageReader(neoStores);
  }
  @After public void after(){
    reader.close();
  }
  @Test public void shouldScanExistingNodesForALabel() throws Exception {
    EntityUpdateCollectingVisitor visitor=new EntityUpdateCollectingVisitor();
    @SuppressWarnings("unchecked") Visitor<NodeLabelUpdate,Exception> labelVisitor=mock(Visitor.class);
    StoreScan<Exception> storeScan=storeView.visitNodes(new int[]{labelId},id -> id == propertyKeyId,visitor,labelVisitor,false);
    storeScan.run();
    assertEquals(asSet(add(alistair.getId(),propertyKeyId,"Alistair",new long[]{labelId}),add(stefan.getId(),propertyKeyId,"Stefan",new long[]{labelId})),visitor.getUpdates());
  }
  @Test public void shouldScanExistingRelationshipsForARelationshiptype() throws Exception {
    EntityUpdateCollectingVisitor visitor=new EntityUpdateCollectingVisitor();
    @SuppressWarnings("unchecked") StoreScan<Exception> storeScan=storeView.visitRelationships(new int[]{relTypeId},id -> id == relPropertyKeyId,visitor);
    storeScan.run();
    assertEquals(asSet(add(aKnowsS.getId(),relPropertyKeyId,"long",new long[]{relTypeId}),add(sKnowsA.getId(),relPropertyKeyId,"lengthy",new long[]{relTypeId})),visitor.getUpdates());
  }
  @Test public void shouldIgnoreDeletedNodesDuringScan() throws Exception {
    deleteAlistairAndStefanNodes();
    EntityUpdateCollectingVisitor visitor=new EntityUpdateCollectingVisitor();
    @SuppressWarnings("unchecked") Visitor<NodeLabelUpdate,Exception> labelVisitor=mock(Visitor.class);
    StoreScan<Exception> storeScan=storeView.visitNodes(new int[]{labelId},id -> id == propertyKeyId,visitor,labelVisitor,false);
    storeScan.run();
    assertEquals(emptySet(),visitor.getUpdates());
  }
  @Test public void shouldIgnoreDeletedRelationshipsDuringScan() throws Exception {
    deleteAlistairAndStefanNodes();
    EntityUpdateCollectingVisitor visitor=new EntityUpdateCollectingVisitor();
    @SuppressWarnings("unchecked") StoreScan<Exception> storeScan=storeView.visitRelationships(new int[]{relTypeId},id -> id == relPropertyKeyId,visitor);
    storeScan.run();
    assertEquals(emptySet(),visitor.getUpdates());
  }
  @Test public void shouldLockNodesWhileReadingThem() throws Exception {
    @SuppressWarnings("unchecked") Visitor<EntityUpdates,Exception> visitor=mock(Visitor.class);
    StoreScan<Exception> storeScan=storeView.visitNodes(new int[]{labelId},id -> id == propertyKeyId,visitor,null,false);
    storeScan.run();
    assertThat("allocated locks: " + lockMocks.keySet(),lockMocks.size(),greaterThanOrEqualTo(2));
    Lock lock0=lockMocks.get(0L);
    Lock lock1=lockMocks.get(1L);
    assertNotNull("Lock[node=0] never acquired",lock0);
    assertNotNull("Lock[node=1] never acquired",lock1);
    InOrder order=inOrder(locks,lock0,lock1);
    order.verify(locks).acquireNodeLock(0,LockService.LockType.READ_LOCK);
    order.verify(lock0).release();
    order.verify(locks).acquireNodeLock(1,LockService.LockType.READ_LOCK);
    order.verify(lock1).release();
  }
  @Test public void shouldLockRelationshipsWhileReadingThem() throws Exception {
    @SuppressWarnings("unchecked") Visitor<EntityUpdates,Exception> visitor=mock(Visitor.class);
    StoreScan<Exception> storeScan=storeView.visitRelationships(new int[]{relTypeId},id -> id == relPropertyKeyId,visitor);
    storeScan.run();
    assertThat("allocated locks: " + lockMocks.keySet(),lockMocks.size(),greaterThanOrEqualTo(2));
    Lock lock0=lockMocks.get(0L);
    Lock lock1=lockMocks.get(1L);
    assertNotNull("Lock[relationship=0] never acquired",lock0);
    assertNotNull("Lock[relationship=1] never acquired",lock1);
    InOrder order=inOrder(locks,lock0,lock1);
    order.verify(locks).acquireRelationshipLock(0,LockService.LockType.READ_LOCK);
    order.verify(lock0).release();
    order.verify(locks).acquireRelationshipLock(1,LockService.LockType.READ_LOCK);
    order.verify(lock1).release();
  }
  @Test public void shouldReadProperties() throws EntityNotFoundException {
    Value value=storeView.getNodePropertyValue(alistair.getId(),propertyKeyId);
    assertTrue(value.equals(Values.of("Alistair")));
  }
  @Test public void processAllNodeProperties() throws Exception {
    CopyUpdateVisitor propertyUpdateVisitor=new CopyUpdateVisitor();
    StoreViewNodeStoreScan storeViewNodeStoreScan=new StoreViewNodeStoreScan(new RecordStorageReader(neoStores),locks,null,propertyUpdateVisitor,new int[]{labelId},id -> true);
    try (StorageNodeCursor nodeCursor=reader.allocateNodeCursor()){
      nodeCursor.single(1);
      nodeCursor.next();
      storeViewNodeStoreScan.process(nodeCursor);
    }
     EntityUpdates propertyUpdates=propertyUpdateVisitor.getPropertyUpdates();
    assertNotNull("Visitor should contain container with updates.",propertyUpdates);
    LabelSchemaDescriptor index1=SchemaDescriptorFactory.forLabel(0,0);
    LabelSchemaDescriptor index2=SchemaDescriptorFactory.forLabel(0,1);
    LabelSchemaDescriptor index3=SchemaDescriptorFactory.forLabel(0,0,1);
    LabelSchemaDescriptor index4=SchemaDescriptorFactory.forLabel(1,1);
    List<LabelSchemaDescriptor> indexes=Arrays.asList(index1,index2,index3,index4);
    assertThat(Iterables.map(IndexEntryUpdate::indexKey,propertyUpdates.forIndexKeys(indexes)),containsInAnyOrder(index1,index2,index3));
  }
  @Test public void processAllRelationshipProperties() throws Exception {
    createAlistairAndStefanNodes();
    CopyUpdateVisitor propertyUpdateVisitor=new CopyUpdateVisitor();
    RelationshipStoreScan relationshipStoreScan=new RelationshipStoreScan(new RecordStorageReader(neoStores),locks,propertyUpdateVisitor,new int[]{relTypeId},id -> true);
    try (StorageRelationshipScanCursor relationshipScanCursor=reader.allocateRelationshipScanCursor()){
      relationshipScanCursor.single(1);
      relationshipScanCursor.next();
      relationshipStoreScan.process(relationshipScanCursor);
    }
     EntityUpdates propertyUpdates=propertyUpdateVisitor.getPropertyUpdates();
    assertNotNull("Visitor should contain container with updates.",propertyUpdates);
    RelationTypeSchemaDescriptor index1=SchemaDescriptorFactory.forRelType(0,2);
    RelationTypeSchemaDescriptor index2=SchemaDescriptorFactory.forRelType(0,3);
    RelationTypeSchemaDescriptor index3=SchemaDescriptorFactory.forRelType(0,2,3);
    RelationTypeSchemaDescriptor index4=SchemaDescriptorFactory.forRelType(1,3);
    List<RelationTypeSchemaDescriptor> indexes=Arrays.asList(index1,index2,index3,index4);
    assertThat(Iterables.map(IndexEntryUpdate::indexKey,propertyUpdates.forIndexKeys(indexes)),containsInAnyOrder(index1,index2,index3));
  }
  EntityUpdates add(  long nodeId,  int propertyKeyId,  Object value,  long[] labels){
    return EntityUpdates.forEntity(nodeId).withTokens(labels).added(propertyKeyId,Values.of(value)).build();
  }
  private void createAlistairAndStefanNodes(){
    try (Transaction tx=graphDb.beginTx()){
      alistair=graphDb.createNode(label);
      alistair.setProperty("name","Alistair");
      alistair.setProperty("country","UK");
      stefan=graphDb.createNode(label);
      stefan.setProperty("name","Stefan");
      stefan.setProperty("country","Deutschland");
      aKnowsS=alistair.createRelationshipTo(stefan,relationshipType);
      aKnowsS.setProperty("duration","long");
      aKnowsS.setProperty("irrelevant","prop");
      sKnowsA=stefan.createRelationshipTo(alistair,relationshipType);
      sKnowsA.setProperty("duration","lengthy");
      sKnowsA.setProperty("irrelevant","prop");
      tx.success();
    }
   }
  private void deleteAlistairAndStefanNodes(){
    try (Transaction tx=graphDb.beginTx()){
      aKnowsS.delete();
      sKnowsA.delete();
      alistair.delete();
      stefan.delete();
      tx.success();
    }
   }
  private void getOrCreateIds() throws KernelException {
    try (Transaction tx=graphDb.beginTx()){
      ThreadToStatementContextBridge bridge=graphDb.getDependencyResolver().resolveDependency(ThreadToStatementContextBridge.class);
      TokenWrite tokenWrite=bridge.getKernelTransactionBoundToThisThread(true).tokenWrite();
      labelId=tokenWrite.labelGetOrCreateForName("Person");
      relTypeId=tokenWrite.relationshipTypeGetOrCreateForName("Knows");
      propertyKeyId=tokenWrite.propertyKeyGetOrCreateForName("name");
      relPropertyKeyId=tokenWrite.propertyKeyGetOrCreateForName("duration");
      tx.success();
    }
   }
private static class CopyUpdateVisitor implements Visitor<EntityUpdates,RuntimeException> {
    private EntityUpdates propertyUpdates;
    @Override public boolean visit(    EntityUpdates element) throws RuntimeException {
      propertyUpdates=element;
      return true;
    }
    public EntityUpdates getPropertyUpdates(){
      return propertyUpdates;
    }
  }
class EntityUpdateCollectingVisitor implements Visitor<EntityUpdates,Exception> {
    private final Set<EntityUpdates> updates=new HashSet<>();
    @Override public boolean visit(    EntityUpdates propertyUpdates){
      updates.add(propertyUpdates);
      return false;
    }
    Set<EntityUpdates> getUpdates(){
      return updates;
    }
  }
}
