public abstract class RecordCheckTestBase<RECORD extends AbstractBaseRecord,REPORT extends ConsistencyReport,CHECKER extends RecordCheck<RECORD,REPORT>> {
  public static final int NONE=-1;
  protected final CHECKER checker;
  private final Class<REPORT> reportClass;
  protected RecordAccessStub records;
  private Stage stage;
  RecordCheckTestBase(  CHECKER checker,  Class<REPORT> reportClass,  int[] cacheFields,  MultiPassStore... storesToCheck){
    this(checker,reportClass,new Stage.Adapter(false,true,"Test stage",cacheFields),storesToCheck);
  }
  RecordCheckTestBase(  CHECKER checker,  Class<REPORT> reportClass,  Stage stage,  MultiPassStore... storesToCheck){
    this.checker=checker;
    this.reportClass=reportClass;
    this.stage=stage;
    initialize(storesToCheck);
  }
  protected void initialize(  MultiPassStore... storesToCheck){
    this.records=new RecordAccessStub(stage,storesToCheck);
    if (stage.getCacheSlotSizes().length > 0) {
      records.cacheAccess().setCacheSlotSizes(stage.getCacheSlotSizes());
    }
  }
  public static PrimitiveRecordCheck<NodeRecord,NodeConsistencyReport> dummyNodeCheck(){
    return new NodeRecordCheck(){
      @Override public void check(      NodeRecord record,      CheckerEngine<NodeRecord,NodeConsistencyReport> engine,      RecordAccess records){
      }
    }
;
  }
  public static PrimitiveRecordCheck<RelationshipRecord,RelationshipConsistencyReport> dummyRelationshipChecker(){
    return new RelationshipRecordCheck(){
      @Override public void check(      RelationshipRecord record,      CheckerEngine<RelationshipRecord,RelationshipConsistencyReport> engine,      RecordAccess records){
      }
    }
;
  }
  public static RecordCheck<PropertyRecord,PropertyConsistencyReport> dummyPropertyChecker(){
    return (record,engine,records) -> {
    }
;
  }
  public static PrimitiveRecordCheck<NeoStoreRecord,NeoStoreConsistencyReport> dummyNeoStoreCheck(){
    return new NeoStoreCheck(new PropertyChain<>(from -> null)){
      @Override public void check(      NeoStoreRecord record,      CheckerEngine<NeoStoreRecord,NeoStoreConsistencyReport> engine,      RecordAccess records){
      }
    }
;
  }
  public static RecordCheck<DynamicRecord,DynamicConsistencyReport> dummyDynamicCheck(  RecordStore<DynamicRecord> store,  DynamicStore dereference){
    return new DynamicRecordCheck(store,dereference){
      @Override public void check(      DynamicRecord record,      CheckerEngine<DynamicRecord,DynamicConsistencyReport> engine,      RecordAccess records){
      }
    }
;
  }
  public static RecordCheck<PropertyKeyTokenRecord,PropertyKeyTokenConsistencyReport> dummyPropertyKeyCheck(){
    return new PropertyKeyTokenRecordCheck(){
      @Override public void check(      PropertyKeyTokenRecord record,      CheckerEngine<PropertyKeyTokenRecord,PropertyKeyTokenConsistencyReport> engine,      RecordAccess records){
      }
    }
;
  }
  public static RecordCheck<RelationshipTypeTokenRecord,RelationshipTypeConsistencyReport> dummyRelationshipLabelCheck(){
    return new RelationshipTypeTokenRecordCheck(){
      @Override public void check(      RelationshipTypeTokenRecord record,      CheckerEngine<RelationshipTypeTokenRecord,RelationshipTypeConsistencyReport> engine,      RecordAccess records){
      }
    }
;
  }
  REPORT check(  RECORD record){
    return check(reportClass,checker,record,records);
  }
  void check(  REPORT report,  RECORD record){
    check(report,checker,record,records);
  }
  final REPORT check(  CHECKER externalChecker,  RECORD record){
    return check(reportClass,externalChecker,record,records);
  }
  public static <RECORD extends AbstractBaseRecord,REPORT extends ConsistencyReport>REPORT check(  Class<REPORT> reportClass,  RecordCheck<RECORD,REPORT> checker,  RECORD record,  final RecordAccessStub records){
    REPORT report=mock(reportClass);
    check(report,checker,record,records);
    return report;
  }
  public static <RECORD extends AbstractBaseRecord,REPORT extends ConsistencyReport>void check(  REPORT report,  RecordCheck<RECORD,REPORT> checker,  RECORD record,  final RecordAccessStub records){
    checker.check(record,records.engine(record,report),records);
    records.checkDeferred();
  }
  <R extends AbstractBaseRecord>R addChange(  R oldRecord,  R newRecord){
    return records.addChange(oldRecord,newRecord);
  }
  <R extends AbstractBaseRecord>R add(  R record){
    return records.add(record);
  }
  DynamicRecord addNodeDynamicLabels(  DynamicRecord labels){
    return records.addNodeDynamicLabels(labels);
  }
  DynamicRecord addKeyName(  DynamicRecord name){
    return records.addPropertyKeyName(name);
  }
  DynamicRecord addRelationshipTypeName(  DynamicRecord name){
    return records.addRelationshipTypeName(name);
  }
  DynamicRecord addLabelName(  DynamicRecord name){
    return records.addLabelName(name);
  }
  public static DynamicRecord string(  DynamicRecord record){
    record.setType(PropertyType.STRING.intValue());
    return record;
  }
  public static DynamicRecord array(  DynamicRecord record){
    record.setType(PropertyType.ARRAY.intValue());
    return record;
  }
  static PropertyBlock propertyBlock(  PropertyKeyTokenRecord key,  DynamicRecord value){
    PropertyType type=value.getType();
    if (value.getType() != PropertyType.STRING && value.getType() != PropertyType.ARRAY) {
      fail("Dynamic record must be either STRING or ARRAY");
      return null;
    }
    return propertyBlock(key,type,value.getId());
  }
  public static PropertyBlock propertyBlock(  PropertyKeyTokenRecord key,  PropertyType type,  long value){
    PropertyBlock block=new PropertyBlock();
    block.setSingleBlock(key.getId() | (((long)type.intValue()) << 24) | (value << 28));
    return block;
  }
  public static <R extends AbstractBaseRecord>R inUse(  R record){
    record.setInUse(true);
    return record;
  }
  public static <R extends AbstractBaseRecord>R notInUse(  R record){
    record.setInUse(false);
    return record;
  }
  protected CHECKER checker(){
    return checker;
  }
}
