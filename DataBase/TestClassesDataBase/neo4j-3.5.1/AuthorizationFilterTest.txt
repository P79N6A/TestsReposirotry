public class AuthorizationFilterTest {
  private final BasicAuthManager authManager=mock(BasicAuthManager.class);
  private final AssertableLogProvider logProvider=new AssertableLogProvider();
  private final ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  private final HttpServletRequest servletRequest=mock(HttpServletRequest.class);
  private final HttpServletResponse servletResponse=mock(HttpServletResponse.class);
  private final FilterChain filterChain=mock(FilterChain.class);
  @Before public void setUp() throws Exception {
    when(servletResponse.getOutputStream()).thenReturn(new ServletOutputStream(){
      @Override public void write(      int b){
        outputStream.write(b);
      }
      @Override public boolean isReady(){
        return true;
      }
      @Override public void setWriteListener(      WriteListener writeListener){
        throw new UnsupportedOperationException();
      }
    }
);
  }
  @Test public void shouldAllowOptionsRequests() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider);
    when(servletRequest.getMethod()).thenReturn("OPTIONS");
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verify(filterChain).doFilter(same(servletRequest),same(servletResponse));
  }
  @Test public void shouldWhitelistMatchingUris() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider,Pattern.compile("/"),Pattern.compile("/browser.*"));
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/","/browser/index.html");
    filter.doFilter(servletRequest,servletResponse,filterChain);
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verify(filterChain,times(2)).doFilter(same(servletRequest),same(servletResponse));
  }
  @Test public void shouldRequireAuthorizationForNonWhitelistedUris() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider,Pattern.compile("/"),Pattern.compile("/browser.*"));
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/db/data");
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verifyNoMoreInteractions(filterChain);
    verify(servletResponse).setStatus(401);
    verify(servletResponse).addHeader(HttpHeaders.WWW_AUTHENTICATE,"Basic realm=\"Neo4j\"");
    verify(servletResponse).addHeader(HttpHeaders.CONTENT_TYPE,"application/json; charset=UTF-8");
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"code\" : \"Neo" + ".ClientError.Security.Unauthorized\""));
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"message\" : \"No authentication header supplied.\""));
  }
  @Test public void shouldRequireValidAuthorizationHeader() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider);
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/db/data");
    when(servletRequest.getHeader(HttpHeaders.AUTHORIZATION)).thenReturn("NOT A VALID VALUE");
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verifyNoMoreInteractions(filterChain);
    verify(servletResponse).setStatus(400);
    verify(servletResponse).addHeader(HttpHeaders.CONTENT_TYPE,"application/json; charset=UTF-8");
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"code\" : \"Neo.ClientError.Request.InvalidFormat\""));
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"message\" : \"Invalid authentication header.\""));
  }
  @Test public void shouldNotAuthorizeInvalidCredentials() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider);
    String credentials=Base64.encodeBase64String("foo:bar".getBytes(StandardCharsets.UTF_8));
    BasicLoginContext loginContext=mock(BasicLoginContext.class);
    AuthSubject authSubject=mock(AuthSubject.class);
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/db/data");
    when(servletRequest.getHeader(HttpHeaders.AUTHORIZATION)).thenReturn("BASIC " + credentials);
    when(servletRequest.getRemoteAddr()).thenReturn("remote_ip_address");
    when(authManager.login(authTokenArgumentMatcher(authToken("foo","bar")))).thenReturn(loginContext);
    when(loginContext.subject()).thenReturn(authSubject);
    when(authSubject.getAuthenticationResult()).thenReturn(AuthenticationResult.FAILURE);
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verifyNoMoreInteractions(filterChain);
    logProvider.assertExactly(inLog(AuthorizationEnabledFilter.class).warn("Failed authentication attempt for '%s' from %s","foo","remote_ip_address"));
    verify(servletResponse).setStatus(401);
    verify(servletResponse).addHeader(HttpHeaders.CONTENT_TYPE,"application/json; charset=UTF-8");
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"code\" : \"Neo.ClientError.Security.Unauthorized\""));
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"message\" : \"Invalid username or password.\""));
  }
  @Test public void shouldAuthorizeWhenPasswordChangeRequiredForWhitelistedPath() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider);
    String credentials=Base64.encodeBase64String("foo:bar".getBytes(StandardCharsets.UTF_8));
    BasicLoginContext loginContext=mock(BasicLoginContext.class);
    AuthSubject authSubject=mock(AuthSubject.class);
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/user/foo");
    when(servletRequest.getHeader(HttpHeaders.AUTHORIZATION)).thenReturn("BASIC " + credentials);
    when(authManager.login(authTokenArgumentMatcher(authToken("foo","bar")))).thenReturn(loginContext);
    when(loginContext.subject()).thenReturn(authSubject);
    when(authSubject.getAuthenticationResult()).thenReturn(AuthenticationResult.PASSWORD_CHANGE_REQUIRED);
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verify(filterChain).doFilter(eq(new AuthorizedRequestWrapper(BASIC_AUTH,"foo",servletRequest,AUTH_DISABLED)),same(servletResponse));
  }
  @Test public void shouldNotAuthorizeWhenPasswordChangeRequired() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider);
    String credentials=Base64.encodeBase64String("foo:bar".getBytes(StandardCharsets.UTF_8));
    BasicLoginContext loginContext=mock(BasicLoginContext.class);
    AuthSubject authSubject=mock(AuthSubject.class);
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/db/data");
    when(servletRequest.getRequestURL()).thenReturn(new StringBuffer("http://bar.baz:7474/db/data/"));
    when(servletRequest.getRequestURI()).thenReturn("/db/data/");
    when(servletRequest.getHeader(HttpHeaders.AUTHORIZATION)).thenReturn("BASIC " + credentials);
    when(authManager.login(authTokenArgumentMatcher(authToken("foo","bar")))).thenReturn(loginContext);
    when(loginContext.subject()).thenReturn(authSubject);
    when(authSubject.getAuthenticationResult()).thenReturn(AuthenticationResult.PASSWORD_CHANGE_REQUIRED);
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verifyNoMoreInteractions(filterChain);
    verify(servletResponse).setStatus(403);
    verify(servletResponse).addHeader(HttpHeaders.CONTENT_TYPE,"application/json; charset=UTF-8");
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"password_change\" : \"http://bar.baz:7474/user/foo/password\""));
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"code\" : \"Neo.ClientError.Security.Forbidden\""));
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"message\" : \"User is required to change their password.\""));
  }
  @Test public void shouldNotAuthorizeWhenTooManyAttemptsMade() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider);
    String credentials=Base64.encodeBase64String("foo:bar".getBytes(StandardCharsets.UTF_8));
    BasicLoginContext loginContext=mock(BasicLoginContext.class);
    AuthSubject authSubject=mock(AuthSubject.class);
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/db/data");
    when(servletRequest.getHeader(HttpHeaders.AUTHORIZATION)).thenReturn("BASIC " + credentials);
    when(authManager.login(authTokenArgumentMatcher(authToken("foo","bar")))).thenReturn(loginContext);
    when(loginContext.subject()).thenReturn(authSubject);
    when(authSubject.getAuthenticationResult()).thenReturn(AuthenticationResult.TOO_MANY_ATTEMPTS);
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verifyNoMoreInteractions(filterChain);
    verify(servletResponse).setStatus(429);
    verify(servletResponse).addHeader(HttpHeaders.CONTENT_TYPE,"application/json; charset=UTF-8");
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"code\" : \"Neo.ClientError.Security.AuthenticationRateLimit\""));
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"message\" : \"Too many failed authentication requests. " + "Please wait 5 seconds and try again.\""));
  }
  @Test public void shouldAuthorizeWhenValidCredentialsSupplied() throws Exception {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider);
    String credentials=Base64.encodeBase64String("foo:bar".getBytes(StandardCharsets.UTF_8));
    BasicLoginContext loginContext=mock(BasicLoginContext.class);
    AuthSubject authSubject=mock(AuthSubject.class);
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/db/data");
    when(servletRequest.getHeader(HttpHeaders.AUTHORIZATION)).thenReturn("BASIC " + credentials);
    when(authManager.login(authTokenArgumentMatcher(authToken("foo","bar")))).thenReturn(loginContext);
    when(loginContext.subject()).thenReturn(authSubject);
    when(authSubject.getAuthenticationResult()).thenReturn(AuthenticationResult.SUCCESS);
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verify(filterChain).doFilter(eq(new AuthorizedRequestWrapper(BASIC_AUTH,"foo",servletRequest,AUTH_DISABLED)),same(servletResponse));
  }
  @Test public void shouldIncludeCrippledAuthHeaderIfBrowserIsTheOneCalling() throws Throwable {
    final AuthorizationEnabledFilter filter=new AuthorizationEnabledFilter(() -> authManager,logProvider,Pattern.compile("/"),Pattern.compile("/browser.*"));
    when(servletRequest.getMethod()).thenReturn("GET");
    when(servletRequest.getContextPath()).thenReturn("/db/data");
    when(servletRequest.getHeader("X-Ajax-Browser-Auth")).thenReturn("true");
    filter.doFilter(servletRequest,servletResponse,filterChain);
    verifyNoMoreInteractions(filterChain);
    verify(servletResponse).setStatus(401);
    verify(servletResponse).addHeader(HttpHeaders.WWW_AUTHENTICATE,"None");
    verify(servletResponse).addHeader(HttpHeaders.CONTENT_TYPE,"application/json; charset=UTF-8");
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"code\" : \"Neo.ClientError.Security.Unauthorized\""));
    assertThat(outputStream.toString(StandardCharsets.UTF_8.name()),containsString("\"message\" : \"No authentication header supplied.\""));
  }
}
