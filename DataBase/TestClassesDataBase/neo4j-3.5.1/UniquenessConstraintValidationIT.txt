public class UniquenessConstraintValidationIT extends KernelIntegrationTest {
  @Test public void shouldEnforceOnSetProperty() throws Exception {
    constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    long node=createLabeledNode(transaction,"Label1");
    try {
      int propertyKeyId=transaction.tokenWrite().propertyKeyGetOrCreateForName("key1");
      transaction.dataWrite().nodeSetProperty(node,propertyKeyId,Values.of("value1"));
      fail("should have thrown exception");
    }
 catch (    UniquePropertyValueValidationException e) {
      assertThat(e.getUserMessage(tokenLookup(transaction)),containsString("`key1` = 'value1'"));
    }
    commit();
  }
  @Test public void roundingErrorsFromLongToDoubleShouldNotPreventTxFromCommitting() throws Exception {
    long propertyValue=285414114323346805L;
    long firstNode=constrainedNode("label1","key1",propertyValue);
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    long node=createLabeledNode(transaction,"label1");
    assertNotEquals(firstNode,node);
    propertyValue++;
    int propertyKeyId=transaction.tokenWrite().propertyKeyGetOrCreateForName("key1");
    transaction.dataWrite().nodeSetProperty(node,propertyKeyId,Values.of(propertyValue));
    commit();
  }
  @Test public void shouldEnforceUniquenessConstraintOnAddLabelForNumberPropertyOnNodeNotFromTransaction() throws Exception {
    constrainedNode("Label1","key1",1);
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    long node=createNode(transaction,"key1",1);
    commit();
    transaction=newTransaction(AnonymousContext.writeToken());
    try {
      int label=transaction.tokenWrite().labelGetOrCreateForName("Label1");
      transaction.dataWrite().nodeAddLabel(node,label);
      fail("should have thrown exception");
    }
 catch (    UniquePropertyValueValidationException e) {
      assertThat(e.getUserMessage(tokenLookup(transaction)),containsString("`key1` = 1"));
    }
    commit();
  }
  @Test public void shouldEnforceUniquenessConstraintOnAddLabelForStringProperty() throws Exception {
    constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    long node=createNode(transaction,"key1","value1");
    try {
      int label=transaction.tokenWrite().labelGetOrCreateForName("Label1");
      transaction.dataWrite().nodeAddLabel(node,label);
      fail("should have thrown exception");
    }
 catch (    UniquePropertyValueValidationException e) {
      assertThat(e.getUserMessage(tokenLookup(transaction)),containsString("`key1` = 'value1'"));
    }
    commit();
  }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_DeleteNode() throws Exception {
    long node=constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    transaction.dataWrite().nodeDelete(node);
    createLabeledNode(transaction,"Label1","key1","value1");
    commit();
  }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveLabel() throws Exception {
    long node=constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    int label=transaction.tokenWrite().labelGetOrCreateForName("Label1");
    transaction.dataWrite().nodeRemoveLabel(node,label);
    createLabeledNode(transaction,"Label1","key1","value1");
    commit();
  }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveProperty() throws Exception {
    long node=constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    int key=transaction.tokenRead().propertyKey("key1");
    transaction.dataWrite().nodeRemoveProperty(node,key);
    createLabeledNode(transaction,"Label1","key1","value1");
    commit();
  }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_ChangeProperty() throws Exception {
    long node=constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    int propertyKeyId=transaction.tokenWrite().propertyKeyGetOrCreateForName("key1");
    transaction.dataWrite().nodeSetProperty(node,propertyKeyId,Values.of("value2"));
    createLabeledNode(transaction,"Label1","key1","value1");
    commit();
  }
  @Test public void shouldPreventConflictingDataInSameTransaction() throws Exception {
    constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    createLabeledNode(transaction,"Label1","key1","value2");
    try {
      createLabeledNode(transaction,"Label1","key1","value2");
      fail("expected exception");
    }
 catch (    UniquePropertyValueValidationException e) {
      assertThat(e.getUserMessage(tokenLookup(transaction)),containsString("`key1` = 'value2'"));
    }
    commit();
  }
  @Test public void shouldAllowNoopPropertyUpdate() throws KernelException {
    long node=constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    int key=transaction.tokenWrite().propertyKeyGetOrCreateForName("key1");
    transaction.dataWrite().nodeSetProperty(node,key,Values.of("value1"));
    commit();
  }
  @Test public void shouldAllowNoopLabelUpdate() throws KernelException {
    long node=constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    int label=transaction.tokenWrite().labelGetOrCreateForName("Label1");
    transaction.dataWrite().nodeAddLabel(node,label);
    commit();
  }
  @Test public void shouldAllowCreationOfNonConflictingData() throws Exception {
    constrainedNode("Label1","key1","value1");
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    createNode(transaction,"key1","value1");
    createLabeledNode(transaction,"Label2","key1","value1");
    createLabeledNode(transaction,"Label1","key1","value2");
    createLabeledNode(transaction,"Label1","key2","value1");
    commit();
    transaction=newTransaction(AnonymousContext.writeToken());
    assertEquals("number of nodes",5,countNodes(transaction));
    rollback();
  }
  @Test public void unrelatedNodesWithSamePropertyShouldNotInterfereWithUniquenessCheck() throws Exception {
    createConstraint("Person","id");
    long ourNode;
{
      Transaction transaction=newTransaction(AnonymousContext.writeToken());
      ourNode=createLabeledNode(transaction,"Person","id",1);
      createLabeledNode(transaction,"Item","id",2);
      commit();
    }
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    TokenRead tokenRead=transaction.tokenRead();
    int person=tokenRead.nodeLabel("Person");
    int propId=tokenRead.propertyKey("id");
    IndexReference idx=transaction.schemaRead().index(person,propId);
    createLabeledNode(transaction,"Item","id",2);
    assertThat(transaction.dataRead().lockingNodeUniqueIndexSeek(idx,exact(propId,Values.of(1))),equalTo(ourNode));
    commit();
  }
  @Test public void addingUniqueNodeWithUnrelatedValueShouldNotAffectLookup() throws Exception {
    createConstraint("Person","id");
    long ourNode;
{
      Transaction transaction=newTransaction(AnonymousContext.writeToken());
      ourNode=createLabeledNode(transaction,"Person","id",1);
      commit();
    }
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    TokenRead tokenRead=transaction.tokenRead();
    int person=tokenRead.nodeLabel("Person");
    int propId=tokenRead.propertyKey("id");
    IndexReference idx=transaction.schemaRead().index(person,propId);
    createLabeledNode(transaction,"Person","id",2);
    assertThat(transaction.dataRead().lockingNodeUniqueIndexSeek(idx,exact(propId,Values.of(1))),equalTo(ourNode));
    commit();
  }
  private TokenNameLookup tokenLookup(  Transaction transaction){
    return new SilentTokenNameLookup(transaction.tokenRead());
  }
  private long createLabeledNode(  Transaction transaction,  String label) throws KernelException {
    long node=transaction.dataWrite().nodeCreate();
    int labelId=transaction.tokenWrite().labelGetOrCreateForName(label);
    transaction.dataWrite().nodeAddLabel(node,labelId);
    return node;
  }
  private long createNode(  Transaction transaction,  String key,  Object value) throws KernelException {
    long node=transaction.dataWrite().nodeCreate();
    int propertyKeyId=transaction.tokenWrite().propertyKeyGetOrCreateForName(key);
    transaction.dataWrite().nodeSetProperty(node,propertyKeyId,Values.of(value));
    return node;
  }
  private long createLabeledNode(  Transaction transaction,  String label,  String key,  Object value) throws KernelException {
    long node=createLabeledNode(transaction,label);
    int propertyKeyId=transaction.tokenWrite().propertyKeyGetOrCreateForName(key);
    transaction.dataWrite().nodeSetProperty(node,propertyKeyId,Values.of(value));
    return node;
  }
  private long constrainedNode(  String labelName,  String propertyKey,  Object propertyValue) throws KernelException {
    long node;
{
      Transaction transaction=newTransaction(AnonymousContext.writeToken());
      int label=transaction.tokenWrite().labelGetOrCreateForName(labelName);
      node=transaction.dataWrite().nodeCreate();
      transaction.dataWrite().nodeAddLabel(node,label);
      int key=transaction.tokenWrite().propertyKeyGetOrCreateForName(propertyKey);
      transaction.dataWrite().nodeSetProperty(node,key,Values.of(propertyValue));
      commit();
    }
    createConstraint(labelName,propertyKey);
    return node;
  }
  private void createConstraint(  String label,  String propertyKey) throws KernelException {
    int labelId;
    int propertyKeyId;
    TokenWrite tokenWrite=tokenWriteInNewTransaction();
    labelId=tokenWrite.labelGetOrCreateForName(label);
    propertyKeyId=tokenWrite.propertyKeyGetOrCreateForName(propertyKey);
    commit();
    SchemaWrite schemaWrite=schemaWriteInNewTransaction();
    schemaWrite.uniquePropertyConstraintCreate(forLabel(labelId,propertyKeyId));
    commit();
  }
}
