class MemoryAllocatorTest {
  private static final String ONE_PAGE=PageCache.PAGE_SIZE + "";
  private static final String EIGHT_PAGES=(8 * PageCache.PAGE_SIZE) + "";
  private MemoryAllocator allocator;
  @AfterEach void tearDown(){
    closeAllocator();
  }
  @Test void allocatedPointerMustNotBeNull(){
    MemoryAllocator mman=createAllocator(EIGHT_PAGES);
    long address=mman.allocateAligned(PageCache.PAGE_SIZE,8);
    assertThat(address,is(not(0L)));
  }
  @Test void allocatedPointerMustBePageAligned(){
    MemoryAllocator mman=createAllocator(EIGHT_PAGES);
    long address=mman.allocateAligned(PageCache.PAGE_SIZE,UnsafeUtil.pageSize());
    assertThat(address % UnsafeUtil.pageSize(),is(0L));
  }
  @Test void allocatedPointerMustBeAlignedToArbitraryByte(){
    int pageSize=UnsafeUtil.pageSize();
    for (int initialOffset=0; initialOffset < 8; initialOffset++) {
      for (int i=0; i < pageSize - 1; i++) {
        MemoryAllocator mman=createAllocator(ONE_PAGE);
        mman.allocateAligned(initialOffset,1);
        long alignment=1 + i;
        long address=mman.allocateAligned(PageCache.PAGE_SIZE,alignment);
        assertThat("With initial offset " + initialOffset + ", iteration "+ i+ ", aligning to "+ alignment+ " and got address "+ address,address % alignment,is(0L));
      }
    }
  }
  @Test void mustBeAbleToAllocatePastMemoryLimit(){
    MemoryAllocator mman=createAllocator(ONE_PAGE);
    for (int i=0; i < 4100; i++) {
      assertThat(mman.allocateAligned(1,2) % 2,is(0L));
    }
  }
  @Test void allocatedPointersMustBeAlignedPastMemoryLimit(){
    MemoryAllocator mman=createAllocator(ONE_PAGE);
    for (int i=0; i < 4100; i++) {
      assertThat(mman.allocateAligned(1,2) % 2,is(0L));
    }
    int pageSize=UnsafeUtil.pageSize();
    for (int i=0; i < pageSize - 1; i++) {
      int alignment=pageSize - i;
      long address=mman.allocateAligned(PageCache.PAGE_SIZE,alignment);
      assertThat("iteration " + i + ", aligning to "+ alignment,address % alignment,is(0L));
    }
  }
  @Test void alignmentCannotBeZero(){
    assertThrows(IllegalArgumentException.class,() -> createAllocator(ONE_PAGE).allocateAligned(8,0));
  }
  @Test void mustBeAbleToAllocateSlabsLargerThanGrabSize(){
    MemoryAllocator mman=createAllocator("2 MiB");
    long page1=mman.allocateAligned(UnsafeUtil.pageSize(),1);
    long largeBlock=mman.allocateAligned(1024 * 1024,1);
    long page2=mman.allocateAligned(UnsafeUtil.pageSize(),1);
    assertThat(page1,is(not(0L)));
    assertThat(largeBlock,is(not(0L)));
    assertThat(page2,is(not(0L)));
  }
  @Test void allocatingMustIncreaseMemoryUsedAndDecreaseAvailableMemory(){
    MemoryAllocator mman=createAllocator(ONE_PAGE);
    assertThat(mman.usedMemory(),is(0L));
    assertThat(mman.availableMemory(),is((long)PageCache.PAGE_SIZE));
    mman.allocateAligned(32,1);
    assertThat(mman.usedMemory(),is(greaterThanOrEqualTo(32L)));
    assertThat(mman.availableMemory(),is(lessThanOrEqualTo(PageCache.PAGE_SIZE - 32L)));
    mman.allocateAligned(32,1);
    assertThat(mman.usedMemory(),is(greaterThanOrEqualTo(64L)));
    assertThat(mman.availableMemory(),is(lessThanOrEqualTo(PageCache.PAGE_SIZE - 64L)));
    mman.allocateAligned(1,1);
    mman.allocateAligned(32,16);
    assertThat(mman.usedMemory(),is(greaterThanOrEqualTo(97L)));
    assertThat(mman.availableMemory(),is(lessThanOrEqualTo(PageCache.PAGE_SIZE - 97L)));
  }
  @Test void trackMemoryAllocations(){
    LocalMemoryTracker memoryTracker=new LocalMemoryTracker();
    GrabAllocator allocator=(GrabAllocator)MemoryAllocator.createAllocator("2m",memoryTracker);
    assertEquals(0,memoryTracker.usedDirectMemory());
    long pointer=allocator.allocateAligned(ByteUnit.mebiBytes(1),1);
    assertEquals(ByteUnit.mebiBytes(1),memoryTracker.usedDirectMemory());
    allocator.close();
    assertEquals(0,memoryTracker.usedDirectMemory());
  }
  private void closeAllocator(){
    if (allocator != null) {
      allocator.close();
      allocator=null;
    }
  }
  private MemoryAllocator createAllocator(  String expectedMaxMemory){
    closeAllocator();
    allocator=MemoryAllocator.createAllocator(expectedMaxMemory,new LocalMemoryTracker());
    return allocator;
  }
}
