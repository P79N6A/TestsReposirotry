class ThreadAheadReadableTest {
  @Test void shouldReadAhead() throws Exception {
    TrackingReader actual=new TrackingReader(23);
    int bufferSize=5;
    CharReadable aheadReader=ThreadAheadReadable.threadAhead(actual,bufferSize);
    SectionedCharBuffer buffer=new SectionedCharBuffer(bufferSize);
    assertEquals(bufferSize,actual.awaitCompletedReadAttempts(1));
    int read=0;
    buffer=aheadReader.read(buffer,buffer.front());
    assertBuffer(chars(read,bufferSize),buffer,0,bufferSize);
    read+=buffer.available();
    buffer=aheadReader.read(buffer,buffer.front());
    assertBuffer(chars(read,bufferSize),buffer,0,bufferSize);
    read+=buffer.available();
    int keep=2;
    buffer=aheadReader.read(buffer,buffer.front() - keep);
    assertBuffer(chars(read - keep,bufferSize + keep),buffer,keep,bufferSize);
    read+=buffer.available();
    keep=3;
    buffer=aheadReader.read(buffer,buffer.front() - keep);
    assertBuffer(chars(read - keep,bufferSize + keep),buffer,keep,bufferSize);
    read+=buffer.available();
    keep=1;
    buffer=aheadReader.read(buffer,buffer.front() - keep);
    assertEquals(3,buffer.available());
    assertBuffer(chars(read - keep,buffer.available() + keep),buffer,keep,3);
    read+=buffer.available();
    assertEquals(23,read);
  }
  @Test void shouldHandleReadAheadEmptyData() throws Exception {
    TrackingReader actual=new TrackingReader(0);
    int bufferSize=10;
    CharReadable aheadReadable=ThreadAheadReadable.threadAhead(actual,bufferSize);
    actual.awaitCompletedReadAttempts(1);
    SectionedCharBuffer buffer=new SectionedCharBuffer(bufferSize);
    buffer=aheadReadable.read(buffer,buffer.front());
    assertEquals(buffer.pivot(),buffer.back());
    assertEquals(buffer.pivot(),buffer.front());
  }
  private static void assertBuffer(  char[] expectedChars,  SectionedCharBuffer buffer,  int charsInBack,  int charsInFront){
    assertEquals(buffer.pivot() - charsInBack,buffer.back());
    assertEquals(buffer.pivot() + charsInFront,buffer.front());
    assertArrayEquals(expectedChars,copyOfRange(buffer.array(),buffer.back(),buffer.front()));
  }
private static class TrackingReader extends CharReadable.Adapter {
    private int bytesRead;
    private volatile int readsCompleted;
    private final CharReadable actual;
    private final long bytes;
    TrackingReader(    int length){
      this.bytes=length * 2;
      this.actual=Readables.wrap(new CharArrayReader(chars(0,length)),length * 2);
    }
    @Override public SectionedCharBuffer read(    SectionedCharBuffer buffer,    int from) throws IOException {
      try {
        return registerBytesRead(actual.read(buffer,from));
      }
  finally {
        readsCompleted++;
      }
    }
    @Override public int read(    char[] into,    int offset,    int length){
      throw new UnsupportedOperationException();
    }
    private SectionedCharBuffer registerBytesRead(    SectionedCharBuffer buffer){
      bytesRead+=buffer.available();
      return buffer;
    }
    @Override public void close(){
    }
    private int awaitCompletedReadAttempts(    int ticket){
      while (readsCompleted < ticket) {
        LockSupport.parkNanos(10_000_000);
      }
      return bytesRead;
    }
    @Override public long position(){
      return actual.position();
    }
    @Override public String sourceDescription(){
      return getClass().getSimpleName();
    }
    @Override public long length(){
      return bytes;
    }
  }
  private static char[] chars(  int start,  int length){
    char[] result=new char[length];
    for (int i=0; i < length; i++) {
      result[i]=(char)(start + i);
    }
    return result;
  }
}
