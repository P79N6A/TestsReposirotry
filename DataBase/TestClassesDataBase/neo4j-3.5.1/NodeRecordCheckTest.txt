class NodeRecordCheckTest extends RecordCheckTestBase<NodeRecord,ConsistencyReport.NodeConsistencyReport,NodeRecordCheck> {
  NodeRecordCheckTest(){
    super(new NodeRecordCheck(RelationshipField.NEXT_REL,LabelsField.LABELS,new PropertyChain<>(from -> null)),ConsistencyReport.NodeConsistencyReport.class,new int[0]);
  }
  @Test void shouldNotReportAnythingForNodeNotInUse(){
    NodeRecord node=notInUse(new NodeRecord(42,false,0,0));
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldNotReportAnythingForNodeThatDoesNotReferenceOtherRecords(){
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldNotReportAnythingForNodeWithConsistentReferences(){
    NodeRecord node=inUse(new NodeRecord(42,false,7,11));
    add(inUse(new RelationshipRecord(7,42,0,0)));
    add(inUse(new PropertyRecord(11)));
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportRelationshipNotInUse(){
    NodeRecord node=inUse(new NodeRecord(42,false,7,11));
    RelationshipRecord relationship=add(notInUse(new RelationshipRecord(7,0,0,0)));
    add(inUse(new PropertyRecord(11)));
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).relationshipNotInUse(relationship);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportPropertyNotInUse(){
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,11));
    PropertyRecord property=add(notInUse(new PropertyRecord(11)));
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).propertyNotInUse(property);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportPropertyNotFirstInChain(){
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,11));
    PropertyRecord property=add(inUse(new PropertyRecord(11)));
    property.setPrevProp(6);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).propertyNotFirstInChain(property);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportRelationshipForOtherNodes(){
    NodeRecord node=inUse(new NodeRecord(42,false,7,NONE));
    RelationshipRecord relationship=add(inUse(new RelationshipRecord(7,1,2,0)));
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).relationshipForOtherNode(relationship);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportRelationshipNotFirstInSourceChain(){
    NodeRecord node=inUse(new NodeRecord(42,false,7,NONE));
    RelationshipRecord relationship=add(inUse(new RelationshipRecord(7,42,0,0)));
    relationship.setFirstPrevRel(6);
    relationship.setFirstInFirstChain(false);
    relationship.setSecondPrevRel(8);
    relationship.setFirstInSecondChain(false);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).relationshipNotFirstInSourceChain(relationship);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportRelationshipNotFirstInTargetChain(){
    NodeRecord node=inUse(new NodeRecord(42,false,7,NONE));
    RelationshipRecord relationship=add(inUse(new RelationshipRecord(7,0,42,0)));
    relationship.setFirstPrevRel(6);
    relationship.setFirstInFirstChain(false);
    relationship.setSecondPrevRel(8);
    relationship.setFirstInSecondChain(false);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).relationshipNotFirstInTargetChain(relationship);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportLoopRelationshipNotFirstInTargetAndSourceChains(){
    NodeRecord node=inUse(new NodeRecord(42,false,7,NONE));
    RelationshipRecord relationship=add(inUse(new RelationshipRecord(7,42,42,0)));
    relationship.setFirstPrevRel(8);
    relationship.setFirstInFirstChain(false);
    relationship.setSecondPrevRel(8);
    relationship.setFirstInSecondChain(false);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).relationshipNotFirstInSourceChain(relationship);
    verify(report).relationshipNotFirstInTargetChain(relationship);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportLabelNotInUse(){
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    new InlineNodeLabels(node).add(1,null,null);
    LabelTokenRecord labelRecordNotInUse=notInUse(new LabelTokenRecord(1));
    add(labelRecordNotInUse);
    add(node);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).labelNotInUse(labelRecordNotInUse);
  }
  @Test void shouldReportDynamicLabelsNotInUse(){
    long[] labelIds=createLabels(100);
    LabelTokenRecord labelRecordNotInUse=notInUse(new LabelTokenRecord(labelIds.length));
    add(labelRecordNotInUse);
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    add(node);
    DynamicRecord labelsRecord1=inUse(array(new DynamicRecord(1)));
    DynamicRecord labelsRecord2=inUse(array(new DynamicRecord(2)));
    Collection<DynamicRecord> labelRecords=asList(labelsRecord1,labelsRecord2);
    labelIds[12]=labelIds.length;
    DynamicArrayStore.allocateFromNumbers(new ArrayList<>(),labelIds,new ReusableRecordsAllocator(52,labelRecords));
    assertDynamicRecordChain(labelsRecord1,labelsRecord2);
    node.setLabelField(DynamicNodeLabels.dynamicPointer(labelRecords),labelRecords);
    addNodeDynamicLabels(labelsRecord1);
    addNodeDynamicLabels(labelsRecord2);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).labelNotInUse(labelRecordNotInUse);
  }
  @Test void shouldReportDuplicateLabels(){
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    new InlineNodeLabels(node).put(new long[]{1,2,1},null,null);
    LabelTokenRecord label1=inUse(new LabelTokenRecord(1));
    LabelTokenRecord label2=inUse(new LabelTokenRecord(2));
    add(label1);
    add(label2);
    add(node);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).labelDuplicate(1);
  }
  @Test void shouldReportDuplicateDynamicLabels(){
    long[] labelIds=createLabels(100);
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    add(node);
    DynamicRecord labelsRecord1=inUse(array(new DynamicRecord(1)));
    DynamicRecord labelsRecord2=inUse(array(new DynamicRecord(2)));
    Collection<DynamicRecord> labelRecords=asList(labelsRecord1,labelsRecord2);
    labelIds[12]=11;
    DynamicArrayStore.allocateFromNumbers(new ArrayList<>(),labelIds,new ReusableRecordsAllocator(52,labelRecords));
    assertDynamicRecordChain(labelsRecord1,labelsRecord2);
    node.setLabelField(DynamicNodeLabels.dynamicPointer(labelRecords),labelRecords);
    addNodeDynamicLabels(labelsRecord1);
    addNodeDynamicLabels(labelsRecord2);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).labelDuplicate(11);
  }
  @Test void shouldReportOutOfOrderLabels(){
    final NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    new InlineNodeLabels(node){
      @Override public Collection<DynamicRecord> put(      long[] labelIds,      NodeStore nodeStore,      DynamicRecordAllocator allocator){
        return putSorted(node,labelIds,nodeStore,allocator);
      }
    }
.put(new long[]{3,1,2},null,null);
    LabelTokenRecord label1=inUse(new LabelTokenRecord(1));
    LabelTokenRecord label2=inUse(new LabelTokenRecord(2));
    LabelTokenRecord label3=inUse(new LabelTokenRecord(3));
    add(label1);
    add(label2);
    add(label3);
    add(node);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).labelsOutOfOrder(3,1);
  }
  @Test void shouldProperlyReportOutOfOrderLabelsThatAreFarAway(){
    final NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    new InlineNodeLabels(node){
      @Override public Collection<DynamicRecord> put(      long[] labelIds,      NodeStore nodeStore,      DynamicRecordAllocator allocator){
        return putSorted(node,labelIds,nodeStore,allocator);
      }
    }
.put(new long[]{1,18,13,14,15,16,12},null,null);
    LabelTokenRecord label1=inUse(new LabelTokenRecord(1));
    LabelTokenRecord label12=inUse(new LabelTokenRecord(12));
    LabelTokenRecord label13=inUse(new LabelTokenRecord(13));
    LabelTokenRecord label14=inUse(new LabelTokenRecord(14));
    LabelTokenRecord label15=inUse(new LabelTokenRecord(15));
    LabelTokenRecord label16=inUse(new LabelTokenRecord(16));
    LabelTokenRecord label18=inUse(new LabelTokenRecord(18));
    add(label1);
    add(label12);
    add(label13);
    add(label14);
    add(label15);
    add(label16);
    add(label18);
    add(node);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).labelsOutOfOrder(18,13);
    verify(report).labelsOutOfOrder(16,12);
  }
  @Test void shouldReportOutOfOrderDynamicLabels(){
    long[] labelIds=createLabels(100);
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    add(node);
    DynamicRecord labelsRecord1=inUse(array(new DynamicRecord(1)));
    DynamicRecord labelsRecord2=inUse(array(new DynamicRecord(2)));
    Collection<DynamicRecord> labelRecords=asList(labelsRecord1,labelsRecord2);
    long temp=labelIds[12];
    labelIds[12]=labelIds[11];
    labelIds[11]=temp;
    DynamicArrayStore.allocateFromNumbers(new ArrayList<>(),labelIds,new ReusableRecordsAllocator(52,labelRecords));
    assertDynamicRecordChain(labelsRecord1,labelsRecord2);
    node.setLabelField(DynamicNodeLabels.dynamicPointer(labelRecords),labelRecords);
    addNodeDynamicLabels(labelsRecord1);
    addNodeDynamicLabels(labelsRecord2);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).labelsOutOfOrder(labelIds[11],labelIds[12]);
  }
  @Test void shouldDynamicLabelRecordsNotInUse(){
    long[] labelIds=createLabels(100);
    NodeRecord node=inUse(new NodeRecord(42,false,NONE,NONE));
    add(node);
    DynamicRecord labelsRecord1=notInUse(array(new DynamicRecord(1)));
    DynamicRecord labelsRecord2=notInUse(array(new DynamicRecord(2)));
    Collection<DynamicRecord> labelRecords=asList(labelsRecord1,labelsRecord2);
    DynamicArrayStore.allocateFromNumbers(new ArrayList<>(),labelIds,new NotUsedReusableRecordsAllocator(52,labelRecords));
    assertDynamicRecordChain(labelsRecord1,labelsRecord2);
    node.setLabelField(DynamicNodeLabels.dynamicPointer(labelRecords),labelRecords);
    addNodeDynamicLabels(labelsRecord1);
    addNodeDynamicLabels(labelsRecord2);
    ConsistencyReport.NodeConsistencyReport report=check(node);
    verify(report).dynamicLabelRecordNotInUse(labelsRecord1);
    verify(report).dynamicLabelRecordNotInUse(labelsRecord2);
  }
  private long[] createLabels(  int labelCount){
    long[] labelIds=new long[labelCount];
    for (int i=0; i < labelIds.length; i++) {
      labelIds[i]=i;
      add(inUse(new LabelTokenRecord(i)));
    }
    return labelIds;
  }
  private static void assertDynamicRecordChain(  DynamicRecord... records){
    if (records.length > 0) {
      for (int i=1; i < records.length; i++) {
        assertEquals(records[i].getId(),records[i - 1].getNextBlock());
      }
      assertTrue(Record.NO_NEXT_BLOCK.is(records[records.length - 1].getNextBlock()));
    }
  }
private class NotUsedReusableRecordsAllocator extends ReusableRecordsAllocator {
    NotUsedReusableRecordsAllocator(    int recordSize,    Collection<DynamicRecord> records){
      super(recordSize,records);
    }
    @Override public DynamicRecord nextRecord(){
      DynamicRecord record=super.nextRecord();
      record.setInUse(false);
      return record;
    }
  }
}
