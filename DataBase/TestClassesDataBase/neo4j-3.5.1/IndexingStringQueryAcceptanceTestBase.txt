public abstract class IndexingStringQueryAcceptanceTestBase {
  @ClassRule public static ImpermanentDatabaseRule dbRule=new ImpermanentDatabaseRule();
  @Rule public final TestName testName=new TestName();
  private final String template;
  private final String[] matching;
  private final String[] nonMatching;
  private final StringSearchMode searchMode;
  private final boolean withIndex;
  private Label LABEL;
  private String KEY="name";
  private GraphDatabaseService db;
  IndexingStringQueryAcceptanceTestBase(  String template,  String[] matching,  String[] nonMatching,  StringSearchMode searchMode,  boolean withIndex){
    this.template=template;
    this.matching=matching;
    this.nonMatching=nonMatching;
    this.searchMode=searchMode;
    this.withIndex=withIndex;
  }
  @Before public void setup(){
    LABEL=Label.label("LABEL1-" + testName.getMethodName());
    db=dbRule.getGraphDatabaseAPI();
    if (withIndex) {
      try (org.neo4j.graphdb.Transaction tx=db.beginTx()){
        db.schema().indexFor(LABEL).on(KEY).create();
        tx.success();
      }
       try (org.neo4j.graphdb.Transaction tx=db.beginTx()){
        db.schema().awaitIndexesOnline(5,TimeUnit.MINUTES);
        tx.success();
      }
     }
  }
  @Test public void shouldSupportIndexSeek(){
    createNodes(db,LABEL,nonMatching);
    LongSet expected=createNodes(db,LABEL,matching);
    MutableLongSet found=new LongHashSet();
    try (Transaction tx=db.beginTx()){
      collectNodes(found,db.findNodes(LABEL,KEY,template,searchMode));
    }
     assertThat(found,equalTo(expected));
  }
  @Test public void shouldIncludeNodesCreatedInSameTxInIndexSeek(){
    createNodes(db,LABEL,nonMatching[0],nonMatching[1]);
    MutableLongSet expected=createNodes(db,LABEL,matching[0],matching[1]);
    MutableLongSet found=new LongHashSet();
    try (Transaction tx=db.beginTx()){
      expected.add(createNode(db,map(KEY,matching[2]),LABEL).getId());
      createNode(db,map(KEY,nonMatching[2]),LABEL);
      collectNodes(found,db.findNodes(LABEL,KEY,template,searchMode));
    }
     assertThat(found,equalTo(expected));
  }
  @Test public void shouldNotIncludeNodesDeletedInSameTxInIndexSeek(){
    createNodes(db,LABEL,nonMatching[0]);
    LongSet toDelete=createNodes(db,LABEL,matching[0],nonMatching[1],matching[1],nonMatching[2]);
    MutableLongSet expected=createNodes(db,LABEL,matching[2]);
    MutableLongSet found=new LongHashSet();
    try (Transaction tx=db.beginTx()){
      LongIterator deleting=toDelete.longIterator();
      while (deleting.hasNext()) {
        long id=deleting.next();
        db.getNodeById(id).delete();
        expected.remove(id);
      }
      collectNodes(found,db.findNodes(LABEL,KEY,template,searchMode));
    }
     assertThat(found,equalTo(expected));
  }
  @Test public void shouldConsiderNodesChangedInSameTxInIndexSeek(){
    createNodes(db,LABEL,nonMatching[0]);
    LongSet toChangeToMatch=createNodes(db,LABEL,nonMatching[1]);
    MutableLongSet toChangeToNotMatch=createNodes(db,LABEL,matching[0]);
    MutableLongSet expected=createNodes(db,LABEL,matching[1]);
    MutableLongSet found=new LongHashSet();
    try (Transaction tx=db.beginTx()){
      LongIterator toMatching=toChangeToMatch.longIterator();
      while (toMatching.hasNext()) {
        long id=toMatching.next();
        db.getNodeById(id).setProperty(KEY,matching[2]);
        expected.add(id);
      }
      LongIterator toNotMatching=toChangeToNotMatch.longIterator();
      while (toNotMatching.hasNext()) {
        long id=toNotMatching.next();
        db.getNodeById(id).setProperty(KEY,nonMatching[2]);
        expected.remove(id);
      }
      collectNodes(found,db.findNodes(LABEL,KEY,template,searchMode));
    }
     assertThat(found,equalTo(expected));
  }
public abstract static class EXACT extends IndexingStringQueryAcceptanceTestBase {
    static String[] matching={"Johan","Johan","Johan"};
    static String[] nonMatching={"Johanna","Olivia","InteJohan"};
    EXACT(    boolean withIndex){
      super("Johan",matching,nonMatching,StringSearchMode.EXACT,withIndex);
    }
  }
public static class EXACT_WITH_INDEX extends EXACT {
    public EXACT_WITH_INDEX(){
      super(true);
    }
  }
public static class EXACT_WITHOUT_INDEX extends EXACT {
    public EXACT_WITHOUT_INDEX(){
      super(false);
    }
  }
public abstract static class PREFIX extends IndexingStringQueryAcceptanceTestBase {
    static String[] matching={"Olivia","Olivia2","OliviaYtterbrink"};
    static String[] nonMatching={"Johan","olivia","InteOlivia"};
    PREFIX(    boolean withIndex){
      super("Olivia",matching,nonMatching,StringSearchMode.PREFIX,withIndex);
    }
  }
public static class PREFIX_WITH_INDEX extends PREFIX {
    public PREFIX_WITH_INDEX(){
      super(true);
    }
  }
public static class PREFIX_WITHOUT_INDEX extends PREFIX {
    public PREFIX_WITHOUT_INDEX(){
      super(false);
    }
  }
public abstract static class SUFFIX extends IndexingStringQueryAcceptanceTestBase {
    static String[] matching={"Jansson","Hansson","Svensson"};
    static String[] nonMatching={"Taverner","Svensson-Averbuch","Taylor"};
    SUFFIX(    boolean withIndex){
      super("sson",matching,nonMatching,StringSearchMode.SUFFIX,withIndex);
    }
  }
public static class SUFFIX_WITH_INDEX extends SUFFIX {
    public SUFFIX_WITH_INDEX(){
      super(true);
    }
  }
public static class SUFFIX_WITHOUT_INDEX extends SUFFIX {
    public SUFFIX_WITHOUT_INDEX(){
      super(false);
    }
  }
public abstract static class CONTAINS extends IndexingStringQueryAcceptanceTestBase {
    static String[] matching={"good","fool","fooooood"};
    static String[] nonMatching={"evil","genius","hungry"};
    public CONTAINS(    boolean withIndex){
      super("oo",matching,nonMatching,StringSearchMode.CONTAINS,withIndex);
    }
  }
public static class CONTAINS_WITH_INDEX extends CONTAINS {
    public CONTAINS_WITH_INDEX(){
      super(true);
    }
  }
public static class CONTAINS_WITHOUT_INDEX extends CONTAINS {
    public CONTAINS_WITHOUT_INDEX(){
      super(false);
    }
  }
  private MutableLongSet createNodes(  GraphDatabaseService db,  Label label,  String... propertyValues){
    MutableLongSet expected=new LongHashSet();
    try (Transaction tx=db.beginTx()){
      for (      String value : propertyValues) {
        expected.add(createNode(db,map(KEY,value),label).getId());
      }
      tx.success();
    }
     return expected;
  }
  private void collectNodes(  MutableLongSet bucket,  ResourceIterator<Node> toCollect){
    while (toCollect.hasNext()) {
      bucket.add(toCollect.next().getId());
    }
  }
  private Node createNode(  GraphDatabaseService beansAPI,  Map<String,Object> properties,  Label... labels){
    try (Transaction tx=beansAPI.beginTx()){
      Node node=beansAPI.createNode(labels);
      for (      Map.Entry<String,Object> property : properties.entrySet()) {
        node.setProperty(property.getKey(),property.getValue());
      }
      tx.success();
      return node;
    }
   }
}
