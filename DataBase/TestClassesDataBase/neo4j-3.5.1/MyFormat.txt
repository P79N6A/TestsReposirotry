private class MyFormat extends BaseRecordFormat<IntRecord> implements StoreHeaderFormat<LongLongHeader> {
  MyFormat(  int recordHeaderSize){
    super(x -> 4,recordHeaderSize,32);
  }
  @Override public IntRecord newRecord(){
    return new IntRecord(0);
  }
  @Override public boolean isInUse(  PageCursor cursor){
    int offset=cursor.getOffset();
    long pageId=cursor.getCurrentPageId();
    long recordId=(offset + pageId * cursor.getCurrentPageSize()) / 4;
    boolean inUse=false;
    for (int i=0; i < intsPerRecord; i++) {
      inUse|=cursor.getInt() != 0;
    }
    maybeSetCursorError(cursor,recordId);
    return inUse;
  }
  @Override public void read(  IntRecord record,  PageCursor cursor,  RecordLoad mode,  int recordSize){
    for (int i=0; i < intsPerRecord; i++) {
      record.value=cursor.getInt();
    }
    record.setInUse(true);
    maybeSetCursorError(cursor,record.getId());
  }
  private void maybeSetCursorError(  PageCursor cursor,  long id){
    if (cursorErrorOnRecord == id) {
      cursor.setCursorException("boom");
    }
  }
  @Override public void write(  IntRecord record,  PageCursor cursor,  int recordSize){
    for (int i=0; i < intsPerRecord; i++) {
      cursor.putInt(record.value);
    }
  }
  @Override public int numberOfReservedRecords(){
    return 4;
  }
  @Override public void writeHeader(  PageCursor cursor){
    for (int i=0; i < getRecordHeaderSize(); i++) {
      cursor.putByte((byte)ThreadLocalRandom.current().nextInt());
    }
  }
  @Override public LongLongHeader readHeader(  PageCursor cursor){
    LongLongHeader header=new LongLongHeader();
    for (int i=0; i < getRecordHeaderSize(); i++) {
      cursor.getByte();
    }
    return header;
  }
}
