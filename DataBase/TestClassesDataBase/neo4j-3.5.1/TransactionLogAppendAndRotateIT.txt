public class TransactionLogAppendAndRotateIT {
  private final LifeRule life=new LifeRule(true);
  private final TestDirectory directory=TestDirectory.testDirectory();
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public final RuleChain chain=outerRule(directory).around(life).around(fileSystemRule);
  @Test public void shouldKeepTransactionsIntactWhenConcurrentlyRotationAndAppending() throws Throwable {
    LogVersionRepository logVersionRepository=new SimpleLogVersionRepository();
    LogFiles logFiles=LogFilesBuilder.builder(directory.databaseLayout(),fileSystemRule.get()).withLogVersionRepository(logVersionRepository).withRotationThreshold(ByteUnit.mebiBytes(1)).withTransactionIdStore(new SimpleTransactionIdStore()).build();
    life.add(logFiles);
    final AtomicBoolean end=new AtomicBoolean();
    AllTheMonitoring monitoring=new AllTheMonitoring(end,100);
    TransactionIdStore txIdStore=new SimpleTransactionIdStore();
    TransactionMetadataCache metadataCache=new TransactionMetadataCache();
    monitoring.setLogFile(logFiles.getLogFile());
    DatabaseHealth health=new DatabaseHealth(mock(DatabasePanicEventGenerator.class),NullLog.getInstance());
    LogRotation rotation=new LogRotationImpl(monitoring,logFiles,health);
    final TransactionAppender appender=life.add(new BatchingTransactionAppender(logFiles,rotation,metadataCache,txIdStore,BYPASS,health));
    Race race=new Race();
    for (int i=0; i < 10; i++) {
      race.addContestant(() -> {
        while (!end.get()) {
          try {
            appender.append(new TransactionToApply(sillyTransaction(1_000)),NULL);
          }
 catch (          Exception e) {
            e.printStackTrace(System.out);
            end.set(true);
            fail(e.getMessage());
          }
        }
      }
);
    }
    race.addContestant(endAfterMax(10,SECONDS,end));
    race.go();
    assertTrue(monitoring.numberOfRotations() > 0);
  }
  private Runnable endAfterMax(  final int time,  final TimeUnit unit,  final AtomicBoolean end){
    return () -> {
      long endTime=currentTimeMillis() + unit.toMillis(time);
      while (currentTimeMillis() < endTime && !end.get()) {
        parkNanos(MILLISECONDS.toNanos(50));
      }
      end.set(true);
    }
;
  }
  private static void assertWholeTransactionsIn(  LogFile logFile,  long logVersion) throws IOException {
    try (ReadableLogChannel reader=logFile.getReader(new LogPosition(logVersion,LOG_HEADER_SIZE))){
      VersionAwareLogEntryReader<ReadableLogChannel> entryReader=new VersionAwareLogEntryReader<>();
      LogEntry entry;
      boolean inTx=false;
      int transactions=0;
      while ((entry=entryReader.readLogEntry(reader)) != null) {
        if (!inTx) {
          assertTrue(entry instanceof LogEntryStart);
          inTx=true;
        }
 else {
          assertTrue(entry instanceof LogEntryCommand || entry instanceof LogEntryCommit);
          if (entry instanceof LogEntryCommit) {
            inTx=false;
            transactions++;
          }
        }
      }
      assertFalse(inTx);
      assertTrue(transactions > 0);
    }
   }
  private TransactionRepresentation sillyTransaction(  int size){
    Collection<StorageCommand> commands=new ArrayList<>(size);
    for (int i=0; i < size; i++) {
      commands.add(createNode(i));
      commands.add(createProperty(i,PropertyType.INT,0));
    }
    PhysicalTransactionRepresentation tx=new PhysicalTransactionRepresentation(commands);
    tx.setHeader(new byte[0],0,0,0,0,0,0);
    return tx;
  }
private static class AllTheMonitoring implements LogFileCreationMonitor, LogRotation.Monitor {
    private final AtomicBoolean end;
    private final int maxNumberOfRotations;
    private volatile LogFile logFile;
    private volatile int rotations;
    AllTheMonitoring(    AtomicBoolean end,    int maxNumberOfRotations){
      this.end=end;
      this.maxNumberOfRotations=maxNumberOfRotations;
    }
    void setLogFile(    LogFile logFile){
      this.logFile=logFile;
    }
    @Override public void startedRotating(    long currentVersion){
    }
    @Override public void finishedRotating(    long currentVersion){
      try {
        assertWholeTransactionsIn(logFile,currentVersion);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
 finally {
        if (rotations++ > maxNumberOfRotations) {
          end.set(true);
        }
      }
    }
    int numberOfRotations(){
      return rotations;
    }
    @Override public void created(    File logFile,    long logVersion,    long lastTransactionId){
    }
  }
}
