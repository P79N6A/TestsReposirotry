/** 
 * This test is for an issue with transaction batching where there would be a batch of transactions to be applied in the same batch; the batch containing a creation of node N with label L and property P. Later in that batch there would be a uniqueness constraint created for label L and property P. The number of nodes matching this constraint would be few and so the label scan store would be selected to drive the population of the index. Problem is that the label update for N would still sit in the batch state, to be applied at the end of the batch. Hence the node would be forgotten when the index was being built.
 */
public class LabelAndIndexUpdateBatchingIT {
  private static final String PROPERTY_KEY="key";
  private static final Label LABEL=Label.label("label");
  @Test public void indexShouldIncludeNodesCreatedPreviouslyInBatch() throws Exception {
    List<TransactionRepresentation> transactions;
    GraphDatabaseAPI db=(GraphDatabaseAPI)new TestGraphDatabaseFactory().newImpermanentDatabase();
    String nodeN="our guy";
    String otherNode="just to create the tokens";
    try {
      try (Transaction tx=db.beginTx()){
        db.createNode(LABEL).setProperty(PROPERTY_KEY,otherNode);
        for (int i=0; i < 10_000; i++) {
          db.createNode();
        }
        tx.success();
      }
       try (Transaction tx=db.beginTx()){
        db.createNode(LABEL).setProperty(PROPERTY_KEY,nodeN);
        tx.success();
      }
       try (Transaction tx=db.beginTx()){
        db.schema().constraintFor(LABEL).assertPropertyIsUnique(PROPERTY_KEY).create();
        tx.success();
      }
       transactions=extractTransactions(db);
    }
  finally {
      db.shutdown();
    }
    db=(GraphDatabaseAPI)new TestGraphDatabaseFactory().newImpermanentDatabase();
    TransactionCommitProcess commitProcess=db.getDependencyResolver().resolveDependency(TransactionCommitProcess.class);
    try {
      int cutoffIndex=findCutoffIndex(transactions);
      commitProcess.commit(toApply(transactions.subList(0,cutoffIndex)),NULL,EXTERNAL);
      commitProcess.commit(toApply(transactions.subList(cutoffIndex,transactions.size())),NULL,EXTERNAL);
      try (Transaction tx=db.beginTx()){
        assertNotNull("Verification node not found",singleOrNull(db.findNodes(LABEL,PROPERTY_KEY,otherNode)));
        assertNotNull("Node N not found",singleOrNull(db.findNodes(LABEL,PROPERTY_KEY,nodeN)));
        tx.success();
      }
     }
  finally {
      db.shutdown();
    }
  }
  private static int findCutoffIndex(  Collection<TransactionRepresentation> transactions) throws IOException {
    Iterator<TransactionRepresentation> iterator=transactions.iterator();
    for (int i=0; iterator.hasNext(); i++) {
      TransactionRepresentation tx=iterator.next();
      CommandExtractor extractor=new CommandExtractor();
      tx.accept(extractor);
      List<StorageCommand> commands=extractor.getCommands();
      List<StorageCommand> nodeCommands=commands.stream().filter(command -> command instanceof NodeCommand).collect(toList());
      if (nodeCommands.size() == 1) {
        return i;
      }
    }
    throw new AssertionError("Couldn't find the transaction which would be the cut-off point");
  }
  private static TransactionToApply toApply(  Collection<TransactionRepresentation> transactions){
    TransactionToApply first=null;
    TransactionToApply last=null;
    for (    TransactionRepresentation transactionRepresentation : transactions) {
      TransactionToApply transaction=new TransactionToApply(transactionRepresentation);
      if (first == null) {
        first=last=transaction;
      }
 else {
        last.next(transaction);
        last=transaction;
      }
    }
    return first;
  }
  private static List<TransactionRepresentation> extractTransactions(  GraphDatabaseAPI db) throws IOException {
    LogicalTransactionStore txStore=db.getDependencyResolver().resolveDependency(LogicalTransactionStore.class);
    List<TransactionRepresentation> transactions=new ArrayList<>();
    try (TransactionCursor cursor=txStore.getTransactions(TransactionIdStore.BASE_TX_ID + 1)){
      cursor.forAll(tx -> transactions.add(tx.getTransactionRepresentation()));
    }
     return transactions;
  }
}
