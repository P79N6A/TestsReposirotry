@ExtendWith({DefaultFileSystemExtension.class,TestDirectoryExtension.class}) class LuceneSchemaIndexPopulatorTest {
  @Inject private DefaultFileSystemAbstraction fs;
  @Inject private TestDirectory testDir;
  private IndexStoreView indexStoreView;
  private LuceneIndexProvider provider;
  private Directory directory;
  private IndexPopulator indexPopulator;
  private IndexReader reader;
  private IndexSearcher searcher;
  private static final int propertyKeyId=666;
  private StoreIndexDescriptor index;
  @BeforeEach void before() throws Exception {
    directory=new RAMDirectory();
    DirectoryFactory directoryFactory=new DirectoryFactory.Single(new DirectoryFactory.UncloseableDirectory(directory));
    provider=new LuceneIndexProvider(fs,directoryFactory,defaultDirectoryStructure(testDir.directory("folder")),IndexProvider.Monitor.EMPTY,Config.defaults(),OperationalMode.single);
    indexStoreView=mock(IndexStoreView.class);
    IndexSamplingConfig samplingConfig=new IndexSamplingConfig(Config.defaults());
    index=IndexDescriptorFactory.forSchema(forLabel(42,propertyKeyId),provider.getProviderDescriptor()).withId(0);
    indexPopulator=provider.getPopulator(index,samplingConfig);
    indexPopulator.create();
  }
  @AfterEach void after() throws Exception {
    if (reader != null) {
      reader.close();
    }
    directory.close();
  }
  @Test void addingValuesShouldPersistThem() throws Exception {
    addUpdate(indexPopulator,1,"First");
    addUpdate(indexPopulator,2,"Second");
    addUpdate(indexPopulator,3,(byte)1);
    addUpdate(indexPopulator,4,(short)2);
    addUpdate(indexPopulator,5,3);
    addUpdate(indexPopulator,6,4L);
    addUpdate(indexPopulator,7,5F);
    addUpdate(indexPopulator,8,6D);
    assertIndexedValues(hit("First",1),hit("Second",2),hit((byte)1,3),hit((short)2,4),hit(3,5),hit(4L,6),hit(5F,7),hit(6D,8));
  }
  @Test void multipleEqualValues() throws Exception {
    addUpdate(indexPopulator,1,"value");
    addUpdate(indexPopulator,2,"value");
    addUpdate(indexPopulator,3,"value");
    assertIndexedValues(hit("value",1L,2L,3L));
  }
  @Test void multipleEqualValuesWithUpdateThatRemovesOne() throws Exception {
    addUpdate(indexPopulator,1,"value");
    addUpdate(indexPopulator,2,"value");
    addUpdate(indexPopulator,3,"value");
    updatePopulator(indexPopulator,singletonList(remove(2,"value")),indexStoreView);
    assertIndexedValues(hit("value",1L,3L));
  }
  @Test void changeUpdatesInterleavedWithAdds() throws Exception {
    addUpdate(indexPopulator,1,"1");
    addUpdate(indexPopulator,2,"2");
    updatePopulator(indexPopulator,singletonList(change(1,"1","1a")),indexStoreView);
    addUpdate(indexPopulator,3,"3");
    assertIndexedValues(no("1"),hit("1a",1),hit("2",2),hit("3",3));
  }
  @Test void addUpdatesInterleavedWithAdds() throws Exception {
    addUpdate(indexPopulator,1,"1");
    addUpdate(indexPopulator,2,"2");
    updatePopulator(indexPopulator,asList(remove(1,"1"),add(1,"1a")),indexStoreView);
    addUpdate(indexPopulator,3,"3");
    assertIndexedValues(hit("1a",1),hit("2",2),hit("3",3),no("1"));
  }
  @Test void removeUpdatesInterleavedWithAdds() throws Exception {
    addUpdate(indexPopulator,1,"1");
    addUpdate(indexPopulator,2,"2");
    updatePopulator(indexPopulator,singletonList(remove(2,"2")),indexStoreView);
    addUpdate(indexPopulator,3,"3");
    assertIndexedValues(hit("1",1),no("2"),hit("3",3));
  }
  @Test void multipleInterleaves() throws Exception {
    addUpdate(indexPopulator,1,"1");
    addUpdate(indexPopulator,2,"2");
    updatePopulator(indexPopulator,asList(change(1,"1","1a"),change(2,"2","2a")),indexStoreView);
    addUpdate(indexPopulator,3,"3");
    addUpdate(indexPopulator,4,"4");
    updatePopulator(indexPopulator,asList(change(1,"1a","1b"),change(4,"4","4a")),indexStoreView);
    assertIndexedValues(no("1"),no("1a"),hit("1b",1),no("2"),hit("2a",2),hit("3",3),no("4"),hit("4a",4));
  }
  private Hit hit(  Object value,  Long... nodeIds){
    return new Hit(value,nodeIds);
  }
  private Hit hit(  Object value,  long nodeId){
    return new Hit(value,nodeId);
  }
  private Hit no(  Object value){
    return new Hit(value);
  }
private static class Hit {
    private final Value value;
    private final Long[] nodeIds;
    Hit(    Object value,    Long... nodeIds){
      this.value=Values.of(value);
      this.nodeIds=nodeIds;
    }
  }
  private IndexEntryUpdate<?> add(  long nodeId,  Object value){
    return IndexQueryHelper.add(nodeId,index.schema(),value);
  }
  private IndexEntryUpdate<?> change(  long nodeId,  Object valueBefore,  Object valueAfter){
    return IndexQueryHelper.change(nodeId,index.schema(),valueBefore,valueAfter);
  }
  private IndexEntryUpdate<?> remove(  long nodeId,  Object removedValue){
    return IndexQueryHelper.remove(nodeId,index.schema(),removedValue);
  }
  private void assertIndexedValues(  Hit... expectedHits) throws IOException {
    switchToVerification();
    for (    Hit hit : expectedHits) {
      TopDocs hits=searcher.search(LuceneDocumentStructure.newSeekQuery(hit.value),10);
      assertEquals(hit.nodeIds.length,hits.totalHits,"Unexpected number of index results from " + hit.value);
      Set<Long> foundNodeIds=new HashSet<>();
      for (int i=0; i < hits.totalHits; i++) {
        Document document=searcher.doc(hits.scoreDocs[i].doc);
        foundNodeIds.add(parseLong(document.get("id")));
      }
      assertEquals(asSet(hit.nodeIds),foundNodeIds);
    }
  }
  private void switchToVerification() throws IOException {
    indexPopulator.close(true);
    assertEquals(InternalIndexState.ONLINE,provider.getInitialState(index));
    reader=DirectoryReader.open(directory);
    searcher=new IndexSearcher(reader);
  }
  private void addUpdate(  IndexPopulator populator,  long nodeId,  Object value) throws IOException, IndexEntryConflictException {
    populator.add(singletonList(IndexQueryHelper.add(nodeId,index.schema(),value)));
  }
  private static void updatePopulator(  IndexPopulator populator,  Iterable<IndexEntryUpdate<?>> updates,  NodePropertyAccessor accessor) throws IOException, IndexEntryConflictException {
    try (IndexUpdater updater=populator.newPopulatingUpdater(accessor)){
      for (      IndexEntryUpdate<?> update : updates) {
        updater.process(update);
      }
    }
   }
}
