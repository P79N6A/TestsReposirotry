public class DelayedBufferTest {
  @Test public void shouldHandleTheWholeWorkloadShebang() throws Throwable {
    final int size=1_000;
    final long bufferTime=3;
    VerifyingConsumer consumer=new VerifyingConsumer(size);
    final Clock clock=Clocks.systemClock();
    Supplier<Long> chunkThreshold=clock::millis;
    Predicate<Long> safeThreshold=time -> clock.millis() - bufferTime >= time;
    final DelayedBuffer<Long> buffer=new DelayedBuffer<>(chunkThreshold,safeThreshold,10,consumer);
    MaintenanceThread maintenance=new MaintenanceThread(buffer,5);
    Race adders=new Race();
    final int numberOfAdders=20;
    final byte[] offeredIds=new byte[size];
    for (int i=0; i < numberOfAdders; i++) {
      final int finalI=i;
      adders.addContestant(() -> {
        for (int j=0; j < size; j++) {
          if (j % numberOfAdders == finalI) {
            buffer.offer(j);
            offeredIds[j]=1;
            parkNanos(MILLISECONDS.toNanos(current().nextInt(2)));
          }
        }
      }
);
    }
    adders.go();
    for (int i=0; i < size; i++) {
      assertEquals("ID " + i,(byte)1,offeredIds[i]);
    }
    maintenance.halt();
    buffer.close();
    consumer.assertHaveOnlySeenRange(0,size - 1);
  }
  @Test public void shouldNotReleaseValuesUntilCrossedThreshold(){
    VerifyingConsumer consumer=new VerifyingConsumer(30);
    final AtomicLong txOpened=new AtomicLong();
    final AtomicLong txClosed=new AtomicLong();
    Supplier<Long> chunkThreshold=txOpened::get;
    Predicate<Long> safeThreshold=value -> txClosed.get() >= value;
    DelayedBuffer<Long> buffer=new DelayedBuffer<>(chunkThreshold,safeThreshold,100,consumer);
    txOpened.incrementAndGet();
    buffer.offer(1);
    txOpened.incrementAndGet();
    buffer.offer(4);
    buffer.maintenance();
    assertEquals(0,consumer.chunksAccepted());
    buffer.offer(5);
    txOpened.incrementAndGet();
    txOpened.incrementAndGet();
    buffer.offer(7);
    buffer.maintenance();
    assertEquals(0,consumer.chunksAccepted());
    txOpened.incrementAndGet();
    buffer.offer(2);
    buffer.offer(8);
    buffer.maintenance();
    assertEquals(0,consumer.chunksAccepted());
    buffer.offer(6);
    txOpened.incrementAndGet();
    buffer.offer(9);
    buffer.offer(3);
    txOpened.incrementAndGet();
    buffer.offer(11);
    buffer.offer(12);
    txClosed.set(4);
    buffer.maintenance();
    consumer.assertHaveOnlySeen(1,4,5,7);
    buffer.offer(10);
    buffer.offer(13);
    txClosed.set(6);
    buffer.maintenance();
    consumer.assertHaveOnlySeen(1,2,4,5,7,8);
    buffer.offer(14);
    txClosed.set(7);
    buffer.maintenance();
    consumer.assertHaveOnlySeen(1,2,3,4,5,6,7,8,9,10,11,12,13,14);
  }
  @Test public void shouldClearCurrentChunk(){
    Consumer<long[]> consumer=mock(Consumer.class);
    DelayedBuffer<Long> buffer=new DelayedBuffer<>(singleton(0L),Predicates.alwaysTrue(),10,consumer);
    buffer.offer(0);
    buffer.offer(1);
    buffer.offer(2);
    buffer.clear();
    buffer.maintenance();
    verifyNoMoreInteractions(consumer);
  }
  @Test public void shouldClearPreviousChunks(){
    Consumer<long[]> consumer=mock(Consumer.class);
    final AtomicBoolean safeThreshold=new AtomicBoolean(false);
    DelayedBuffer<Long> buffer=new DelayedBuffer<>(singleton(0L),t -> safeThreshold.get(),10,consumer);
    buffer.offer(0);
    buffer.maintenance();
    buffer.offer(1);
    buffer.maintenance();
    buffer.offer(2);
    buffer.maintenance();
    safeThreshold.set(true);
    buffer.clear();
    buffer.maintenance();
    verifyNoMoreInteractions(consumer);
  }
private static class MaintenanceThread extends Thread {
    private final DelayedBuffer buffer;
    private final long nanoInterval;
    private volatile boolean end;
    MaintenanceThread(    DelayedBuffer buffer,    long nanoInterval){
      this.buffer=buffer;
      this.nanoInterval=nanoInterval;
      start();
    }
    @Override public void run(){
      while (!end) {
        buffer.maintenance();
        LockSupport.parkNanos(nanoInterval);
      }
    }
    void halt() throws InterruptedException {
      end=true;
      while (isAlive()) {
        Thread.sleep(1);
      }
    }
  }
private static class VerifyingConsumer implements Consumer<long[]> {
    private final boolean[] seenIds;
    private int chunkCount;
    VerifyingConsumer(    int size){
      seenIds=new boolean[size];
    }
    void assertHaveOnlySeenRange(    long low,    long high){
      long[] values=new long[(int)(high - low + 1)];
      for (long id=low, i=0; id <= high; id++, i++) {
        values[(int)i]=id;
      }
      assertHaveOnlySeen(values);
    }
    @Override public void accept(    long[] chunk){
      chunkCount++;
      for (      long id : chunk) {
        assertFalse(seenIds[safeCastLongToInt(id)]);
        seenIds[safeCastLongToInt(id)]=true;
      }
    }
    void assertHaveOnlySeen(    long... values){
      for (int i=0, vi=0; i < seenIds.length && vi < values.length; i++) {
        boolean expectedToBeSeen=values[vi] == i;
        if (expectedToBeSeen && !seenIds[i]) {
          fail("Expected to have seen " + i + ", but hasn't");
        }
 else         if (!expectedToBeSeen && seenIds[i]) {
          fail("Expected to NOT have seen " + i + ", but have");
        }
        if (expectedToBeSeen) {
          vi++;
        }
      }
    }
    int chunksAccepted(){
      return chunkCount;
    }
  }
}
