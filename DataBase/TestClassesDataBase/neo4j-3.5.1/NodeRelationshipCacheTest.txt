@RunWith(Parameterized.class) public class NodeRelationshipCacheTest {
  @Rule public final RandomRule random=new RandomRule();
  @Parameterized.Parameter(0) public long base;
  private NodeRelationshipCache cache;
  @After public void after(){
    cache.close();
  }
  @Parameterized.Parameters public static Collection<Object[]> data(){
    Collection<Object[]> data=new ArrayList<>();
    data.add(new Object[]{0L});
    data.add(new Object[]{(long)Integer.MAX_VALUE * 2});
    return data;
  }
  @Test public void shouldReportCorrectNumberOfDenseNodes(){
    cache=new NodeRelationshipCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,5,100,base);
    cache.setNodeCount(26);
    increment(cache,2,10);
    increment(cache,5,2);
    increment(cache,7,12);
    increment(cache,23,4);
    increment(cache,24,5);
    increment(cache,25,6);
    assertFalse(cache.isDense(0));
    assertTrue(cache.isDense(2));
    assertFalse(cache.isDense(5));
    assertTrue(cache.isDense(7));
    assertFalse(cache.isDense(23));
    assertTrue(cache.isDense(24));
    assertTrue(cache.isDense(25));
  }
  @Test public void shouldGoThroughThePhases(){
    int nodeCount=10;
    cache=new NodeRelationshipCache(NumberArrayFactory.OFF_HEAP,20,100,base);
    cache.setNodeCount(nodeCount);
    incrementRandomCounts(cache,nodeCount,nodeCount * 20);
{
      long node=findNode(cache,nodeCount,false);
      testNode(cache,node,null);
    }
{
      long node=findNode(cache,nodeCount,true);
      testNode(cache,node,Direction.OUTGOING);
      testNode(cache,node,Direction.INCOMING);
    }
  }
  @Test public void shouldObserveFirstRelationshipAsEmptyInEachDirection(){
    cache=new NodeRelationshipCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,1,100,base);
    int nodes=100;
    int typeId=5;
    Direction[] directions=Direction.values();
    GroupVisitor groupVisitor=mock(GroupVisitor.class);
    cache.setForwardScan(true,true);
    cache.setNodeCount(nodes + 1);
    for (int i=0; i < nodes; i++) {
      assertEquals(-1L,cache.getFirstRel(nodes,groupVisitor));
      cache.incrementCount(i);
      long previous=cache.getAndPutRelationship(i,typeId,directions[i % directions.length],random.nextInt(1_000_000),true);
      assertEquals(-1L,previous);
    }
    cache.setForwardScan(false,true);
    for (int i=0; i < nodes; i++) {
      long previous=cache.getAndPutRelationship(i,typeId,directions[i % directions.length],random.nextInt(1_000_000),false);
      assertEquals(-1L,previous);
    }
    cache.setForwardScan(true,true);
    for (int i=0; i < nodes; i++) {
      assertEquals(-1L,cache.getFirstRel(nodes,groupVisitor));
    }
  }
  @Test public void shouldResetCountAfterGetOnDenseNodes(){
    cache=new NodeRelationshipCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,1,100,base);
    long nodeId=0;
    int typeId=3;
    cache.setNodeCount(1);
    cache.incrementCount(nodeId);
    cache.incrementCount(nodeId);
    cache.getAndPutRelationship(nodeId,typeId,OUTGOING,10,true);
    cache.getAndPutRelationship(nodeId,typeId,OUTGOING,12,true);
    assertTrue(cache.isDense(nodeId));
    long count=cache.getCount(nodeId,typeId,OUTGOING);
    assertEquals(2,count);
    assertEquals(0,cache.getCount(nodeId,typeId,OUTGOING));
  }
  @Test public void shouldGetAndPutRelationshipAroundChunkEdge(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,10);
    long nodeId=1_000_000 - 1;
    int typeId=10;
    cache.setNodeCount(nodeId + 1);
    Direction direction=Direction.OUTGOING;
    long relId=10;
    cache.getAndPutRelationship(nodeId,typeId,direction,relId,false);
    assertEquals(relId,cache.getFirstRel(nodeId,mock(GroupVisitor.class)));
  }
  @Test public void shouldPutRandomStuff(){
    int typeId=10;
    int nodes=10_000;
    MutableLongObjectMap<long[]> key=new LongObjectHashMap<>(nodes);
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1,1000,base);
    cache.setNodeCount(nodes);
    for (long nodeId=0; nodeId < nodes; nodeId++) {
      if (random.nextBoolean()) {
        cache.incrementCount(nodeId);
      }
    }
    for (int i=0; i < 100_000; i++) {
      long nodeId=random.nextLong(nodes);
      boolean dense=cache.isDense(nodeId);
      Direction direction=random.among(Direction.values());
      long relationshipId=random.nextLong(1_000_000);
      long previousHead=cache.getAndPutRelationship(nodeId,typeId,direction,relationshipId,false);
      long[] keyIds=key.get(nodeId);
      int keyIndex=dense ? direction.ordinal() : 0;
      if (keyIds == null) {
        key.put(nodeId,keyIds=minusOneLongs(Direction.values().length));
      }
      assertEquals(keyIds[keyIndex],previousHead);
      keyIds[keyIndex]=relationshipId;
    }
  }
  @Test public void shouldPut6ByteRelationshipIds(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1,100,base);
    long sparseNode=0;
    long denseNode=1;
    long relationshipId=(1L << 48) - 2;
    int typeId=10;
    cache.setNodeCount(2);
    cache.incrementCount(denseNode);
    assertEquals(-1L,cache.getAndPutRelationship(sparseNode,typeId,OUTGOING,relationshipId,false));
    assertEquals(-1L,cache.getAndPutRelationship(denseNode,typeId,OUTGOING,relationshipId,false));
    assertEquals(relationshipId,cache.getAndPutRelationship(sparseNode,typeId,OUTGOING,1,false));
    assertEquals(relationshipId,cache.getAndPutRelationship(denseNode,typeId,OUTGOING,1,false));
  }
  @Test public void shouldFailFastIfTooBigRelationshipId(){
    int typeId=10;
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1,100,base);
    cache.setNodeCount(1);
    cache.getAndPutRelationship(0,typeId,OUTGOING,(1L << 48) - 2,false);
    try {
      cache.getAndPutRelationship(0,typeId,OUTGOING,(1L << 48) - 1,false);
      fail("Should fail");
    }
 catch (    IllegalArgumentException e) {
      assertTrue(e.getMessage().contains("max"));
    }
  }
  @Test public void shouldVisitChangedNodes(){
    int nodes=10;
    int typeId=10;
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,2,100,base);
    cache.setNodeCount(nodes);
    for (long nodeId=0; nodeId < nodes; nodeId++) {
      cache.incrementCount(nodeId);
      if (random.nextBoolean()) {
        cache.incrementCount(nodeId);
      }
    }
    MutableLongSet keySparseChanged=new LongHashSet();
    MutableLongSet keyDenseChanged=new LongHashSet();
    for (int i=0; i < nodes / 2; i++) {
      long nodeId=random.nextLong(nodes);
      cache.getAndPutRelationship(nodeId,typeId,Direction.OUTGOING,random.nextLong(1_000_000),false);
      boolean dense=cache.isDense(nodeId);
      (dense ? keyDenseChanged : keySparseChanged).add(nodeId);
    }
{
      NodeChangeVisitor visitor=(nodeId,array) -> {
        assertTrue("Unexpected sparse change reported for " + nodeId,keySparseChanged.remove(nodeId));
      }
;
      cache.visitChangedNodes(visitor,NodeType.NODE_TYPE_SPARSE);
      assertTrue("There was " + keySparseChanged.size() + " expected sparse changes that weren't reported",keySparseChanged.isEmpty());
    }
{
      NodeChangeVisitor visitor=(nodeId,array) -> {
        assertTrue("Unexpected dense change reported for " + nodeId,keyDenseChanged.remove(nodeId));
      }
;
      cache.visitChangedNodes(visitor,NodeType.NODE_TYPE_DENSE);
      assertTrue("There was " + keyDenseChanged.size() + " expected dense changes that weren reported",keyDenseChanged.isEmpty());
    }
  }
  @Test public void shouldFailFastOnTooHighCountOnNode(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,10,100,base);
    long nodeId=5;
    long count=NodeRelationshipCache.MAX_COUNT - 1;
    int typeId=10;
    cache.setNodeCount(10);
    cache.setCount(nodeId,count,typeId,OUTGOING);
    cache.incrementCount(nodeId);
    try {
      cache.incrementCount(nodeId);
      fail("Should have failed");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void shouldKeepNextGroupIdForNextRound(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1,100,base);
    long nodeId=0;
    int typeId=10;
    cache.setNodeCount(nodeId + 1);
    cache.incrementCount(nodeId);
    GroupVisitor groupVisitor=mock(GroupVisitor.class);
    when(groupVisitor.visit(anyLong(),anyInt(),anyLong(),anyLong(),anyLong())).thenReturn(1L,2L,3L);
    long firstRelationshipGroupId;
{
      long relationshipId=10;
      cache.getAndPutRelationship(nodeId,typeId,OUTGOING,relationshipId,true);
      firstRelationshipGroupId=cache.getFirstRel(nodeId,groupVisitor);
      assertEquals(1L,firstRelationshipGroupId);
      verify(groupVisitor).visit(nodeId,typeId,relationshipId,-1L,-1L);
      cache.setForwardScan(false,true);
      cache.getAndPutRelationship(nodeId,typeId,OUTGOING,relationshipId,false);
      cache.setForwardScan(true,true);
    }
    long secondRelationshipGroupId;
{
      long relationshipId=11;
      cache.getAndPutRelationship(nodeId,typeId,INCOMING,relationshipId,true);
      secondRelationshipGroupId=cache.getFirstRel(nodeId,groupVisitor);
      assertEquals(2L,secondRelationshipGroupId);
      verify(groupVisitor).visit(nodeId,typeId,-1,relationshipId,-1L);
      cache.setForwardScan(false,true);
      cache.getAndPutRelationship(nodeId,typeId,OUTGOING,relationshipId,false);
      cache.setForwardScan(true,true);
    }
{
      long relationshipId=10;
      cache.getAndPutRelationship(nodeId,typeId,BOTH,relationshipId,true);
      long thirdRelationshipGroupId=cache.getFirstRel(nodeId,groupVisitor);
      assertEquals(3L,thirdRelationshipGroupId);
      verify(groupVisitor).visit(nodeId,typeId,-1L,-1L,relationshipId);
    }
  }
  @Test public void shouldHaveDenseNodesWithBigCounts(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1,100,base);
    long nodeId=1;
    int typeId=10;
    cache.setNodeCount(nodeId + 1);
    cache.setCount(nodeId,2,typeId,OUTGOING);
    cache.getAndPutRelationship(nodeId,typeId,OUTGOING,1,true);
    cache.getAndPutRelationship(nodeId,typeId,INCOMING,2,true);
    long highCountOut=NodeRelationshipCache.MAX_COUNT - 100;
    long highCountIn=NodeRelationshipCache.MAX_COUNT - 50;
    cache.setCount(nodeId,highCountOut,typeId,OUTGOING);
    cache.setCount(nodeId,highCountIn,typeId,INCOMING);
    cache.getAndPutRelationship(nodeId,typeId,OUTGOING,1,true);
    cache.getAndPutRelationship(nodeId,typeId,INCOMING,2,true);
    assertEquals(highCountOut + 1,cache.getCount(nodeId,typeId,OUTGOING));
    assertEquals(highCountIn + 1,cache.getCount(nodeId,typeId,INCOMING));
  }
  @Test public void shouldCacheMultipleDenseNodeRelationshipHeads(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1);
    cache.setNodeCount(10);
    long nodeId=3;
    cache.setCount(nodeId,10,0,OUTGOING);
    Map<Pair<Integer,Direction>,Long> firstRelationshipIds=new HashMap<>();
    int typeCount=3;
    for (int typeId=0, relationshipId=0; typeId < typeCount; typeId++) {
      for (      Direction direction : Direction.values()) {
        long firstRelationshipId=relationshipId++;
        cache.getAndPutRelationship(nodeId,typeId,direction,firstRelationshipId,true);
        firstRelationshipIds.put(Pair.of(typeId,direction),firstRelationshipId);
      }
    }
    AtomicInteger visitCount=new AtomicInteger();
    GroupVisitor visitor=(nodeId1,typeId,out,in,loop) -> {
      visitCount.incrementAndGet();
      assertEquals(firstRelationshipIds.get(Pair.of(typeId,OUTGOING)).longValue(),out);
      assertEquals(firstRelationshipIds.get(Pair.of(typeId,INCOMING)).longValue(),in);
      assertEquals(firstRelationshipIds.get(Pair.of(typeId,BOTH)).longValue(),loop);
      return 0;
    }
;
    cache.getFirstRel(nodeId,visitor);
    assertEquals(typeCount,visitCount.get());
  }
  @Test public void shouldHaveSparseNodesWithBigCounts(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1,100,base);
    long nodeId=1;
    int typeId=10;
    cache.setNodeCount(nodeId + 1);
    long highCount=NodeRelationshipCache.MAX_COUNT - 100;
    cache.setCount(nodeId,highCount,typeId,OUTGOING);
    long nextHighCount=cache.incrementCount(nodeId);
    assertEquals(highCount + 1,nextHighCount);
  }
  @Test public void shouldFailFastOnTooHighNodeCount(){
    cache=new NodeRelationshipCache(NumberArrayFactory.HEAP,1);
    try {
      cache.setNodeCount(2L << (5 * Byte.SIZE));
      fail("Should have failed");
    }
 catch (    IllegalArgumentException e) {
    }
  }
  private void testNode(  NodeRelationshipCache link,  long node,  Direction direction){
    int typeId=0;
    long count=link.getCount(node,typeId,direction);
    assertEquals(-1,link.getAndPutRelationship(node,typeId,direction,5,false));
    assertEquals(5,link.getAndPutRelationship(node,typeId,direction,10,false));
    assertEquals(count,link.getCount(node,typeId,direction));
  }
  private long findNode(  NodeRelationshipCache link,  long nodeCount,  boolean isDense){
    for (long i=0; i < nodeCount; i++) {
      if (link.isDense(i) == isDense) {
        return i;
      }
    }
    throw new IllegalArgumentException("No dense node found");
  }
  private long incrementRandomCounts(  NodeRelationshipCache link,  int nodeCount,  int i){
    long highestSeenCount=0;
    while (i-- > 0) {
      long node=random.nextInt(nodeCount);
      highestSeenCount=max(highestSeenCount,link.incrementCount(node));
    }
    return highestSeenCount;
  }
  private void increment(  NodeRelationshipCache cache,  long node,  int count){
    for (int i=0; i < count; i++) {
      cache.incrementCount(node);
    }
  }
  private long[] minusOneLongs(  int length){
    long[] array=new long[length];
    Arrays.fill(array,-1);
    return array;
  }
}
