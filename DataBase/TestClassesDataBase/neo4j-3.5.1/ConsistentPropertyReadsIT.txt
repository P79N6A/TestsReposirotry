/** 
 * Test for how properties are read and that they should be read consistently, i.e. adhere to neo4j's interpretation of the ACID guarantees.
 */
public class ConsistentPropertyReadsIT {
  @Rule public DatabaseRule db=new EmbeddedDatabaseRule();
  @Test public void shouldReadConsistentPropertyValues() throws Throwable {
    final Node[] nodes=new Node[10];
    final String[] keys=new String[]{"1","2","3"};
    final String[] values=new String[]{longString('a'),longString('b'),longString('c')};
    try (Transaction tx=db.beginTx()){
      for (int i=0; i < nodes.length; i++) {
        nodes[i]=db.createNode();
        for (        String key : keys) {
          nodes[i].setProperty(key,values[0]);
        }
      }
      tx.success();
    }
     int updaters=10;
    final AtomicLong updatersDone=new AtomicLong(updaters);
    Race race=new Race();
    for (int i=0; i < updaters; i++) {
      race.addContestant(() -> {
        try {
          ThreadLocalRandom random=ThreadLocalRandom.current();
          for (int j=0; j < 100; j++) {
            Node node=nodes[random.nextInt(nodes.length)];
            String key=keys[random.nextInt(keys.length)];
            try (Transaction tx=db.beginTx()){
              node.removeProperty(key);
              tx.success();
            }
             try (Transaction tx=db.beginTx()){
              node.setProperty(key,values[random.nextInt(values.length)]);
              tx.success();
            }
           }
        }
  finally {
          updatersDone.decrementAndGet();
        }
      }
);
    }
    for (int i=0; i < 100; i++) {
      race.addContestant(() -> {
        ThreadLocalRandom random=ThreadLocalRandom.current();
        while (updatersDone.get() > 0) {
          try (Transaction tx=db.beginTx()){
            String value=(String)nodes[random.nextInt(nodes.length)].getProperty(keys[random.nextInt(keys.length)],null);
            assertTrue(value,value == null || ArrayUtil.contains(values,value));
            tx.success();
          }
         }
      }
);
    }
    race.go();
  }
  private String longString(  char c){
    char[] chars=new char[ThreadLocalRandom.current().nextInt(800,1000)];
    Arrays.fill(chars,c);
    return new String(chars);
  }
}
