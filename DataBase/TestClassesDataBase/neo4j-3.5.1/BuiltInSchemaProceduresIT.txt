public class BuiltInSchemaProceduresIT extends KernelIntegrationTest {
  private final String[] nodesProcedureName={"db","schema","nodeTypeProperties"};
  private final String[] relsProcedureName={"db","schema","relTypeProperties"};
  @Test public void testWeirdLabelName() throws Throwable {
    createNode(Arrays.asList("`This:is_a:label`"),Arrays.asList("color"),Arrays.asList(Values.stringValue("red")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":``This:is_a:label``",Arrays.asList("`This:is_a:label`"),"color",Arrays.asList("String"),true))));
  }
  @Test public void testNodePropertiesRegardlessOfCreationOrder1() throws Throwable {
    createNode(Arrays.asList("A"),Arrays.asList("color","size"),Arrays.asList(Values.stringValue("red"),Values.stringValue("M")));
    createNode(Arrays.asList("A"),Arrays.asList("origin"),Arrays.asList(Values.stringValue("Kenya")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":`A`",Arrays.asList("A"),"color",Arrays.asList("String"),false)),equalTo(nodeEntry(":`A`",Arrays.asList("A"),"size",Arrays.asList("String"),false)),equalTo(nodeEntry(":`A`",Arrays.asList("A"),"origin",Arrays.asList("String"),false))));
  }
  @Test public void testNodePropertiesRegardlessOfCreationOrder2() throws Throwable {
    createNode(Arrays.asList("B"),Arrays.asList("origin"),Arrays.asList(Values.stringValue("Kenya")));
    createNode(Arrays.asList("B"),Arrays.asList("color","size"),Arrays.asList(Values.stringValue("red"),Values.stringValue("M")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":`B`",Arrays.asList("B"),"color",Arrays.asList("String"),false)),equalTo(nodeEntry(":`B`",Arrays.asList("B"),"size",Arrays.asList("String"),false)),equalTo(nodeEntry(":`B`",Arrays.asList("B"),"origin",Arrays.asList("String"),false))));
  }
  @Test public void testNodePropertiesRegardlessOfCreationOrder3() throws Throwable {
    createNode(Arrays.asList("C"),Arrays.asList("color","size"),Arrays.asList(Values.stringValue("red"),Values.stringValue("M")));
    createNode(Arrays.asList("C"),Arrays.asList("origin","active"),Arrays.asList(Values.stringValue("Kenya"),Values.booleanValue(true)));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":`C`",Arrays.asList("C"),"color",Arrays.asList("String"),false)),equalTo(nodeEntry(":`C`",Arrays.asList("C"),"size",Arrays.asList("String"),false)),equalTo(nodeEntry(":`C`",Arrays.asList("C"),"origin",Arrays.asList("String"),false)),equalTo(nodeEntry(":`C`",Arrays.asList("C"),"active",Arrays.asList("Boolean"),false))));
  }
  @Test public void testRelsPropertiesRegardlessOfCreationOrder1() throws Throwable {
    long emptyNode=createEmptyNode();
    createRelationship(emptyNode,"R",emptyNode,Arrays.asList("color","size"),Arrays.asList(Values.stringValue("red"),Values.stringValue("M")));
    createRelationship(emptyNode,"R",emptyNode,Arrays.asList("origin"),Arrays.asList(Values.stringValue("Kenya")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","color",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","size",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","origin",Arrays.asList("String"),false))));
  }
  @Test public void testRelsPropertiesRegardlessOfCreationOrder2() throws Throwable {
    long emptyNode=createEmptyNode();
    createRelationship(emptyNode,"R",emptyNode,Arrays.asList("origin"),Arrays.asList(Values.stringValue("Kenya")));
    createRelationship(emptyNode,"R",emptyNode,Arrays.asList("color","size"),Arrays.asList(Values.stringValue("red"),Values.stringValue("M")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","color",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","size",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","origin",Arrays.asList("String"),false))));
  }
  @Test public void testRelsPropertiesRegardlessOfCreationOrder3() throws Throwable {
    long emptyNode=createEmptyNode();
    createRelationship(emptyNode,"R",emptyNode,Arrays.asList("color","size"),Arrays.asList(Values.stringValue("red"),Values.stringValue("M")));
    createRelationship(emptyNode,"R",emptyNode,Arrays.asList("origin","active"),Arrays.asList(Values.stringValue("Kenya"),Values.booleanValue(true)));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","color",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","size",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","origin",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","active",Arrays.asList("Boolean"),false))));
  }
  @Test public void testNodesShouldNotDependOnOrderOfCreationWithOverlap() throws Throwable {
    createNode(Arrays.asList("B"),Arrays.asList("type"),Arrays.asList(Values.stringValue("B1")));
    createNode(Arrays.asList("B"),Arrays.asList("type","size"),Arrays.asList(Values.stringValue("B2"),Values.intValue(5)));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":`B`",Arrays.asList("B"),"type",Arrays.asList("String"),true)),equalTo(nodeEntry(":`B`",Arrays.asList("B"),"size",Arrays.asList("Integer"),false))));
  }
  @Test public void testNodesShouldNotDependOnOrderOfCreationWithOverlap2() throws Throwable {
    createNode(Arrays.asList("B"),Arrays.asList("type","size"),Arrays.asList(Values.stringValue("B2"),Values.intValue(5)));
    createNode(Arrays.asList("B"),Arrays.asList("type"),Arrays.asList(Values.stringValue("B1")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":`B`",Arrays.asList("B"),"type",Arrays.asList("String"),true)),equalTo(nodeEntry(":`B`",Arrays.asList("B"),"size",Arrays.asList("Integer"),false))));
  }
  @Test public void testRelsShouldNotDependOnOrderOfCreationWithOverlap() throws Throwable {
    long nodeId1=createEmptyNode();
    createRelationship(nodeId1,"B",nodeId1,Arrays.asList("type"),Arrays.asList(Values.stringValue("B1")));
    createRelationship(nodeId1,"B",nodeId1,Arrays.asList("type","size"),Arrays.asList(Values.stringValue("B1"),Values.intValue(5)));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`B`","type",Arrays.asList("String"),true)),equalTo(relEntry(":`B`","size",Arrays.asList("Integer"),false))));
  }
  @Test public void testRelsShouldNotDependOnOrderOfCreationWithOverlap2() throws Throwable {
    long nodeId1=createEmptyNode();
    createRelationship(nodeId1,"B",nodeId1,Arrays.asList("type","size"),Arrays.asList(Values.stringValue("B1"),Values.intValue(5)));
    createRelationship(nodeId1,"B",nodeId1,Arrays.asList("type"),Arrays.asList(Values.stringValue("B1")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`B`","type",Arrays.asList("String"),true)),equalTo(relEntry(":`B`","size",Arrays.asList("Integer"),false))));
  }
  @Test public void testWithAllDifferentNodes() throws Throwable {
    createNode(Arrays.asList("A","B"),Arrays.asList("prop1","prop2"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12)));
    createNode(Arrays.asList("B"),Arrays.asList("prop1"),Arrays.asList(Values.booleanValue(true)));
    createEmptyNode();
    createNode(Arrays.asList("C"),Arrays.asList("prop1"),Arrays.asList(Values.stringArray("Test","Success")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":`A`:`B`",Arrays.asList("A","B"),"prop1",Arrays.asList("String"),true)),equalTo(nodeEntry(":`A`:`B`",Arrays.asList("A","B"),"prop2",Arrays.asList("Integer"),true)),equalTo(nodeEntry(":`B`",Arrays.asList("B"),"prop1",Arrays.asList("Boolean"),true)),equalTo(nodeEntry(":`C`",Arrays.asList("C"),"prop1",Arrays.asList("StringArray"),true)),equalTo(nodeEntry("",Arrays.asList(),null,null,false))));
  }
  @Test public void testWithSimilarNodes() throws Throwable {
    createNode(Arrays.asList("A"),Arrays.asList("prop1"),Arrays.asList(Values.stringValue("Test")));
    createNode(Arrays.asList("A"),Arrays.asList("prop1"),Arrays.asList(Values.stringValue("Test2")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),contains(equalTo(nodeEntry(":`A`",Arrays.asList("A"),"prop1",Arrays.asList("String"),true))));
  }
  @Test public void testWithSimilarNodesHavingDifferentPropertyValueTypes() throws Throwable {
    createNode(Arrays.asList(),Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12),Values.booleanValue(true)));
    createNode(Arrays.asList(),Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.floatValue(1.5f),Values.stringValue("Test")));
    createNode(Arrays.asList(),Arrays.asList("prop1"),Arrays.asList(Values.stringValue("Test")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry("",Arrays.asList(),"prop1",Arrays.asList("String"),true)),equalTo(nodeEntry("",Arrays.asList(),"prop2",Arrays.asList("Integer","Float"),false)),equalTo(nodeEntry("",Arrays.asList(),"prop3",Arrays.asList("String","Boolean"),false))));
  }
  @Test public void testWithSimilarNodesShouldNotDependOnOrderOfCreation() throws Throwable {
    createEmptyNode();
    createNode(Arrays.asList(),Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12),Values.booleanValue(true)));
    createNode(Arrays.asList(),Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.floatValue(1.5f),Values.stringValue("Test")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry("",Arrays.asList(),"prop1",Arrays.asList("String"),false)),equalTo(nodeEntry("",Arrays.asList(),"prop2",Arrays.asList("Integer","Float"),false)),equalTo(nodeEntry("",Arrays.asList(),"prop3",Arrays.asList("String","Boolean"),false))));
  }
  @Test public void testWithAllDifferentRelationships() throws Throwable {
    long nodeId1=createEmptyNode();
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1","prop2"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12)));
    createRelationship(nodeId1,"X",nodeId1,Arrays.asList("prop1"),Arrays.asList(Values.booleanValue(true)));
    createRelationship(nodeId1,"Z",nodeId1,Arrays.asList(),Arrays.asList());
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","prop1",Arrays.asList("String"),true)),equalTo(relEntry(":`R`","prop2",Arrays.asList("Integer"),true)),equalTo(relEntry(":`X`","prop1",Arrays.asList("Boolean"),true)),equalTo(relEntry(":`Z`",null,null,false))));
  }
  @Test public void testWithSimilarRelationships() throws Throwable {
    long nodeId1=createEmptyNode();
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1"),Arrays.asList(Values.stringValue("Test")));
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1"),Arrays.asList(Values.stringValue("Test2")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","prop1",Arrays.asList("String"),true))));
  }
  @Test public void testSchemaWithRelationshipWithoutProperties() throws Throwable {
    long nodeId1=createEmptyNode();
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12),Values.booleanValue(true)));
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList(),Arrays.asList());
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","prop1",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","prop2",Arrays.asList("Integer"),false)),equalTo(relEntry(":`R`","prop3",Arrays.asList("Boolean"),false))));
  }
  @Test public void testWithSimilarRelationshipsHavingDifferentPropertyValueTypes() throws Throwable {
    long nodeId1=createEmptyNode();
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12),Values.booleanValue(true)));
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.floatValue(1.5f),Values.stringValue("Test")));
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1"),Arrays.asList(Values.stringValue("Test")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","prop1",Arrays.asList("String"),true)),equalTo(relEntry(":`R`","prop2",Arrays.asList("Integer","Float"),false)),equalTo(relEntry(":`R`","prop3",Arrays.asList("String","Boolean"),false))));
  }
  @Test public void testWithSimilarRelationshipsShouldNotDependOnOrderOfCreation() throws Throwable {
    long nodeId1=createEmptyNode();
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList(),Arrays.asList());
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12),Values.booleanValue(true)));
    createRelationship(nodeId1,"R",nodeId1,Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.floatValue(1.5f),Values.stringValue("Test")));
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(relsProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(relEntry(":`R`","prop1",Arrays.asList("String"),false)),equalTo(relEntry(":`R`","prop2",Arrays.asList("Integer","Float"),false)),equalTo(relEntry(":`R`","prop3",Arrays.asList("String","Boolean"),false))));
  }
  @Test public void testWithNullableProperties() throws Throwable {
    createNode(Arrays.asList("A"),Arrays.asList("prop1","prop2","prop3"),Arrays.asList(Values.stringValue("Test"),Values.intValue(12),Values.booleanValue(true)));
    createNode(Arrays.asList("A"),Arrays.asList("prop1","prop3"),Arrays.asList(Values.stringValue("Test2"),Values.booleanValue(false)));
    createNode(Arrays.asList("A"),Arrays.asList("prop1","prop2"),Arrays.asList(Values.stringValue("Test3"),Values.intValue(42)));
    createNode(Arrays.asList("B"),Arrays.asList("prop1","prop2"),Arrays.asList(Values.stringValue("Test4"),Values.intValue(21)));
    createNode(Arrays.asList("B"),Arrays.asList(),Arrays.asList());
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(procedureName(nodesProcedureName)).id(),new Object[0]);
    assertThat(asList(stream),containsInAnyOrder(equalTo(nodeEntry(":`A`",Arrays.asList("A"),"prop1",Arrays.asList("String"),true)),equalTo(nodeEntry(":`A`",Arrays.asList("A"),"prop2",Arrays.asList("Integer"),false)),equalTo(nodeEntry(":`A`",Arrays.asList("A"),"prop3",Arrays.asList("Boolean"),false)),equalTo(nodeEntry(":`B`",Arrays.asList("B"),"prop1",Arrays.asList("String"),false)),equalTo(nodeEntry(":`B`",Arrays.asList("B"),"prop2",Arrays.asList("Integer"),false))));
  }
  private Object[] nodeEntry(  String escapedLabels,  List<String> labels,  String propertyName,  List<String> propertyValueTypes,  Boolean mandatory){
    return new Object[]{escapedLabels,labels,propertyName,propertyValueTypes,mandatory};
  }
  private Object[] relEntry(  String labelsOrRelType,  String propertyName,  List<String> propertyValueTypes,  Boolean mandatory){
    return new Object[]{labelsOrRelType,propertyName,propertyValueTypes,mandatory};
  }
  private long createEmptyNode() throws Throwable {
    return createNode(Arrays.asList(),Arrays.asList(),Arrays.asList());
  }
  private long createNode(  List<String> labels,  List<String> propKeys,  List<Value> propValues) throws Throwable {
    assert labels != null;
    assert propKeys.size() == propValues.size();
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    long nodeId=transaction.dataWrite().nodeCreate();
    for (    String labelname : labels) {
      int labelId=transaction.tokenWrite().labelGetOrCreateForName(labelname);
      transaction.dataWrite().nodeAddLabel(nodeId,labelId);
    }
    for (int i=0; i < propKeys.size(); i++) {
      String propKeyName=propKeys.get(i);
      Value propValue=propValues.get(i);
      int propKeyId=transaction.tokenWrite().propertyKeyGetOrCreateForName(propKeyName);
      transaction.dataWrite().nodeSetProperty(nodeId,propKeyId,propValue);
    }
    commit();
    return nodeId;
  }
  private void createRelationship(  long startNode,  String type,  long endNode,  List<String> propKeys,  List<Value> propValues) throws Throwable {
    assert type != null && !type.equals("");
    assert propKeys.size() == propValues.size();
    Transaction transaction=newTransaction(AnonymousContext.writeToken());
    int typeId=transaction.tokenWrite().relationshipTypeGetOrCreateForName(type);
    long relId=transaction.dataWrite().relationshipCreate(startNode,typeId,endNode);
    for (int i=0; i < propKeys.size(); i++) {
      String propKeyName=propKeys.get(i);
      Value propValue=propValues.get(i);
      int propKeyId=transaction.tokenWrite().propertyKeyGetOrCreateForName(propKeyName);
      transaction.dataWrite().relationshipSetProperty(relId,propKeyId,propValue);
    }
    commit();
  }
  @SuppressWarnings("unused") private void printStream(  RawIterator<Object[],ProcedureException> stream) throws Throwable {
    Iterator<Object[]> iterator=asList(stream).iterator();
    while (iterator.hasNext()) {
      Object[] row=iterator.next();
      for (      Object column : row) {
        System.out.println(column);
      }
      System.out.println();
    }
  }
}
