public class WriteTransactionCommandOrderingTest {
  private static NodeRecord missingNode(){
    return new NodeRecord(-1,false,-1,-1);
  }
  private static NodeRecord createdNode(){
    NodeRecord record=new NodeRecord(2,false,-1,-1);
    record.setInUse(true);
    record.setCreated();
    return record;
  }
  private static NodeRecord inUseNode(){
    NodeRecord record=new NodeRecord(1,false,-1,-1);
    record.setInUse(true);
    return record;
  }
  private static String commandActionToken(  AbstractBaseRecord record){
    if (!record.inUse()) {
      return "deleted";
    }
    if (record.isCreated()) {
      return "created";
    }
    return "updated";
  }
  @Test public void shouldExecuteCommandsInTheSameOrderRegardlessOfItBeingRecoveredOrNot() throws Exception {
    TransactionRecordState tx=injectAllPossibleCommands();
    PhysicalTransactionRepresentation commands=transactionRepresentationOf(tx);
    final OrderVerifyingCommandHandler orderVerifyingCommandHandler=new OrderVerifyingCommandHandler();
    commands.accept(element -> ((Command)element).handle(orderVerifyingCommandHandler));
  }
  private PhysicalTransactionRepresentation transactionRepresentationOf(  TransactionRecordState tx) throws TransactionFailureException {
    List<StorageCommand> commands=new ArrayList<>();
    tx.extractCommands(commands);
    return new PhysicalTransactionRepresentation(commands);
  }
  private TransactionRecordState injectAllPossibleCommands(){
    RecordChangeSet recordChangeSet=mock(RecordChangeSet.class);
    RecordChanges<LabelTokenRecord,Void> labelTokenChanges=mock(RecordChanges.class);
    RecordChanges<RelationshipTypeTokenRecord,Void> relationshipTypeTokenChanges=mock(RecordChanges.class);
    RecordChanges<PropertyKeyTokenRecord,Void> propertyKeyTokenChanges=mock(RecordChanges.class);
    RecordChanges<NodeRecord,Void> nodeRecordChanges=mock(RecordChanges.class);
    RecordChanges<RelationshipRecord,Void> relationshipRecordChanges=mock(RecordChanges.class);
    RecordChanges<PropertyRecord,PrimitiveRecord> propertyRecordChanges=mock(RecordChanges.class);
    RecordChanges<RelationshipGroupRecord,Integer> relationshipGroupChanges=mock(RecordChanges.class);
    RecordChanges<SchemaRecord,SchemaRule> schemaRuleChanges=mock(RecordChanges.class);
    when(recordChangeSet.getLabelTokenChanges()).thenReturn(labelTokenChanges);
    when(recordChangeSet.getRelationshipTypeTokenChanges()).thenReturn(relationshipTypeTokenChanges);
    when(recordChangeSet.getPropertyKeyTokenChanges()).thenReturn(propertyKeyTokenChanges);
    when(recordChangeSet.getNodeRecords()).thenReturn(nodeRecordChanges);
    when(recordChangeSet.getRelRecords()).thenReturn(relationshipRecordChanges);
    when(recordChangeSet.getPropertyRecords()).thenReturn(propertyRecordChanges);
    when(recordChangeSet.getRelGroupRecords()).thenReturn(relationshipGroupChanges);
    when(recordChangeSet.getSchemaRuleChanges()).thenReturn(schemaRuleChanges);
    List<RecordProxy<NodeRecord,Void>> nodeChanges=new LinkedList<>();
    RecordChange<NodeRecord,Void> deletedNode=mock(RecordChange.class);
    when(deletedNode.getBefore()).thenReturn(inUseNode());
    when(deletedNode.forReadingLinkage()).thenReturn(missingNode());
    nodeChanges.add(deletedNode);
    RecordChange<NodeRecord,Void> createdNode=mock(RecordChange.class);
    when(createdNode.getBefore()).thenReturn(missingNode());
    when(createdNode.forReadingLinkage()).thenReturn(createdNode());
    nodeChanges.add(createdNode);
    RecordChange<NodeRecord,Void> updatedNode=mock(RecordChange.class);
    when(updatedNode.getBefore()).thenReturn(inUseNode());
    when(updatedNode.forReadingLinkage()).thenReturn(inUseNode());
    nodeChanges.add(updatedNode);
    when(nodeRecordChanges.changes()).thenReturn(nodeChanges);
    when(nodeRecordChanges.changeSize()).thenReturn(3);
    when(recordChangeSet.changeSize()).thenReturn(3);
    when(labelTokenChanges.changes()).thenReturn(Collections.emptyList());
    when(relationshipTypeTokenChanges.changes()).thenReturn(Collections.emptyList());
    when(propertyKeyTokenChanges.changes()).thenReturn(Collections.emptyList());
    when(relationshipRecordChanges.changes()).thenReturn(Collections.emptyList());
    when(propertyRecordChanges.changes()).thenReturn(Collections.emptyList());
    when(relationshipGroupChanges.changes()).thenReturn(Collections.emptyList());
    when(schemaRuleChanges.changes()).thenReturn(Collections.emptyList());
    NeoStores neoStores=mock(NeoStores.class);
    NodeStore store=mock(NodeStore.class);
    when(neoStores.getNodeStore()).thenReturn(store);
    RelationshipGroupStore relationshipGroupStore=mock(RelationshipGroupStore.class);
    when(neoStores.getRelationshipGroupStore()).thenReturn(relationshipGroupStore);
    RelationshipStore relationshipStore=mock(RelationshipStore.class);
    when(neoStores.getRelationshipStore()).thenReturn(relationshipStore);
    return new TransactionRecordState(neoStores,mock(IntegrityValidator.class),recordChangeSet,0,null,null,null,null,null);
  }
private static class OrderVerifyingCommandHandler extends CommandVisitor.Adapter {
    private boolean nodeVisited;
    private boolean updated;
    private boolean deleted;
    @Override public boolean visitNodeCommand(    NodeCommand command){
      if (!nodeVisited) {
        updated=false;
        deleted=false;
      }
      nodeVisited=true;
switch (command.getMode()) {
case CREATE:
        assertFalse(updated);
      assertFalse(deleted);
    break;
case UPDATE:
  updated=true;
assertFalse(deleted);
break;
case DELETE:
deleted=true;
break;
default :
throw new IllegalStateException("Unknown command mode: " + command.getMode());
}
return false;
}
}
}
