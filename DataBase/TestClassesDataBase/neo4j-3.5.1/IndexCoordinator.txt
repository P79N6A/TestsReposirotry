private abstract static class IndexCoordinator {
  final int numberOfNodes=100;
  final Label indexLabel;
  final String numberProp1;
  final String numberProp2;
  final String stringProp1;
  final String stringProp2;
  Number[] numberProp1Values;
  Number[] numberProp2Values;
  String[] stringProp1Values;
  String[] stringProp2Values;
  int indexedLabelId;
  int numberPropId1;
  int numberPropId2;
  int stringPropId1;
  int stringPropId2;
  IndexDescriptor indexDescriptor;
  IndexCoordinator(  Label indexLabel,  String numberProp1,  String numberProp2,  String stringProp1,  String stringProp2){
    this.indexLabel=indexLabel;
    this.numberProp1=numberProp1;
    this.numberProp2=numberProp2;
    this.stringProp1=stringProp1;
    this.stringProp2=stringProp2;
    this.numberProp1Values=new Number[numberOfNodes];
    this.numberProp2Values=new Number[numberOfNodes];
    this.stringProp1Values=new String[numberOfNodes];
    this.stringProp2Values=new String[numberOfNodes];
    for (int i=0; i < numberOfNodes; i++) {
      numberProp1Values[i]=i;
      numberProp2Values[i]=i;
      stringProp1Values[i]="string-" + String.format("%02d",i);
      stringProp2Values[i]="string-" + String.format("%02d",i);
    }
  }
  void init(  DatabaseRule db){
    try (Transaction tx=db.beginTx()){
      for (int i=0; i < numberOfNodes; i++) {
        Node node=db.createNode(indexLabel);
        node.setProperty(numberProp1,numberProp1Values[i]);
        node.setProperty(numberProp2,numberProp2Values[i]);
        node.setProperty(stringProp1,stringProp1Values[i]);
        node.setProperty(stringProp2,stringProp2Values[i]);
      }
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      TokenRead tokenRead=db.transaction().tokenRead();
      indexedLabelId=tokenRead.nodeLabel(indexLabel.name());
      numberPropId1=tokenRead.propertyKey(numberProp1);
      numberPropId2=tokenRead.propertyKey(numberProp2);
      stringPropId1=tokenRead.propertyKey(stringProp1);
      stringPropId2=tokenRead.propertyKey(stringProp2);
      tx.success();
    }
     indexDescriptor=extractIndexDescriptor();
  }
  protected abstract IndexDescriptor extractIndexDescriptor();
  void createIndex(  DatabaseRule db){
    try (Transaction tx=db.beginTx()){
      doCreateIndex(db);
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(1,TimeUnit.MINUTES);
      tx.success();
    }
   }
  abstract boolean supportRangeQuery();
  abstract NodeValueIndexCursor queryRange(  KernelTransaction ktx) throws KernelException ;
  abstract NodeValueIndexCursor queryExists(  KernelTransaction ktx) throws KernelException ;
  abstract NodeValueIndexCursor queryExact(  KernelTransaction ktx) throws KernelException ;
  abstract void assertRangeResult(  List<Long> result);
  void assertExistsResult(  List<Long> actual){
    List<Long> expected=new ArrayList<>();
    for (long i=0; i < numberOfNodes; i++) {
      expected.add(i);
    }
    assertSameContent(actual,expected);
  }
  void assertSameContent(  List<Long> actual,  List<Long> expected){
    assertThat(actual,is(containsInAnyOrder(expected.toArray())));
  }
  abstract void assertExactResult(  List<Long> result);
  abstract void doCreateIndex(  DatabaseRule db);
  NodeValueIndexCursor indexQuery(  KernelTransaction ktx,  IndexDescriptor indexDescriptor,  IndexQuery... indexQueries) throws KernelException {
    NodeValueIndexCursor cursor=ktx.cursors().allocateNodeValueIndexCursor();
    ktx.dataRead().nodeIndexSeek(indexDescriptor,cursor,IndexOrder.NONE,false,indexQueries);
    return cursor;
  }
}
