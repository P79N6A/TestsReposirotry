public class TestNoFileDescriptorLeaks {
  private static final AtomicInteger counter=new AtomicInteger();
  @Rule public EmbeddedDatabaseRule db=new EmbeddedDatabaseRule();
  @BeforeClass public static void beforeClass(){
    Assume.assumeFalse(SystemUtils.IS_OS_WINDOWS);
    Assume.assumeThat(OsBeanUtil.getOpenFileDescriptors(),not(OsBeanUtil.VALUE_UNAVAILABLE));
  }
  @Test public void mustNotLeakFileDescriptorsFromMerge(){
    try (Transaction tx=db.beginTx()){
      db.execute("create constraint on (n:Node) assert n.id is unique");
      tx.success();
    }
     cycleMerge(1);
    long initialFDs=OsBeanUtil.getOpenFileDescriptors();
    cycleMerge(300);
    long finalFDs=OsBeanUtil.getOpenFileDescriptors();
    long upperBoundFDs=initialFDs + 50;
    assertThat(finalFDs,lessThan(upperBoundFDs));
  }
  private void cycleMerge(  int iterations){
    for (int i=0; i < iterations; i++) {
      try (Transaction tx=db.beginTx()){
        db.execute("MERGE (a:Node {id: {a}}) " + "MERGE (b:Node {id: {b}}) " + "MERGE (c:Node {id: {c}}) "+ "MERGE (d:Node {id: {d}}) "+ "MERGE (e:Node {id: {e}}) "+ "MERGE (f:Node {id: {f}}) ",map("a",nextId() % 100,"b",nextId() % 100,"c",nextId() % 100,"d",nextId(),"e",nextId(),"f",nextId()));
        db.execute("MERGE (n:Node {id: {a}}) ",map("a",nextId() % 100));
        db.execute("MERGE (n:Node {id: {a}}) ",map("a",nextId() % 100));
        db.execute("MERGE (n:Node {id: {a}}) ",map("a",nextId() % 100));
        db.execute("MERGE (n:Node {id: {a}}) ",map("a",nextId()));
        db.execute("MERGE (n:Node {id: {a}}) ",map("a",nextId()));
        db.execute("MERGE (n:Node {id: {a}}) ",map("a",nextId()));
        tx.success();
      }
     }
  }
  private static int nextId(){
    return counter.incrementAndGet();
  }
}
