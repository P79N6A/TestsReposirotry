public class IndexPopulationFlipRaceIT {
  private static final int NODES_PER_INDEX=10;
  @Rule public final DatabaseRule db=new EmbeddedDatabaseRule();
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldAtomicallyFlipMultipleIndexes() throws Exception {
    for (int i=0; i < 10; i++) {
      createIndexesButDontWaitForThemToFullyPopulate(i);
      Pair<long[],long[]> data=createDataThatGoesIntoToThoseIndexes(i);
      awaitIndexes();
      verifyThatThereAreExactlyOneIndexEntryPerNodeInTheIndexes(i,data);
    }
  }
  private void awaitIndexes(){
    try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(30,SECONDS);
      tx.success();
    }
   }
  private void createIndexesButDontWaitForThemToFullyPopulate(  int i){
    try (Transaction tx=db.beginTx()){
      db.schema().indexFor(labelA(i)).on(keyA(i)).create();
      if (random.nextBoolean()) {
        db.schema().indexFor(labelB(i)).on(keyB(i)).create();
      }
 else {
        db.schema().constraintFor(labelB(i)).assertPropertyIsUnique(keyB(i)).create();
      }
      tx.success();
    }
   }
  private static String keyB(  int i){
    return "key_b" + i;
  }
  private static Label labelB(  int i){
    return label("Label_b" + i);
  }
  private static String keyA(  int i){
    return "key_a" + i;
  }
  private static Label labelA(  int i){
    return label("Label_a" + i);
  }
  private Pair<long[],long[]> createDataThatGoesIntoToThoseIndexes(  int i){
    long[] dataA=new long[NODES_PER_INDEX];
    long[] dataB=new long[NODES_PER_INDEX];
    for (int t=0; t < NODES_PER_INDEX; t++) {
      try (Transaction tx=db.beginTx()){
        Node nodeA=db.createNode(labelA(i));
        nodeA.setProperty(keyA(i),dataA[t]=nodeA.getId());
        Node nodeB=db.createNode(labelB(i));
        nodeB.setProperty(keyB(i),dataB[t]=nodeB.getId());
        tx.success();
      }
     }
    return Pair.of(dataA,dataB);
  }
  private void verifyThatThereAreExactlyOneIndexEntryPerNodeInTheIndexes(  int i,  Pair<long[],long[]> data) throws Exception {
    Kernel kernel=db.getDependencyResolver().resolveDependency(Kernel.class);
    try (org.neo4j.internal.kernel.api.Transaction tx=kernel.beginTransaction(implicit,AnonymousContext.read())){
      int labelAId=tx.tokenRead().nodeLabel(labelA(i).name());
      int keyAId=tx.tokenRead().propertyKey(keyA(i));
      int labelBId=tx.tokenRead().nodeLabel(labelB(i).name());
      int keyBId=tx.tokenRead().propertyKey(keyB(i));
      IndexReference indexA=TestIndexDescriptorFactory.forLabel(labelAId,keyAId);
      IndexReference indexB=TestIndexDescriptorFactory.forLabel(labelBId,keyBId);
      for (int j=0; j < NODES_PER_INDEX; j++) {
        long nodeAId=data.first()[j];
        assertEquals(1,tx.schemaRead().nodesCountIndexed(indexA,nodeAId,keyAId,Values.of(nodeAId)));
        long nodeBId=data.other()[j];
        assertEquals(1,tx.schemaRead().nodesCountIndexed(indexB,nodeBId,keyBId,Values.of(nodeBId)));
      }
    }
   }
}
