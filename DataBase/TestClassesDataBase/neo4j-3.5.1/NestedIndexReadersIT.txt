public class NestedIndexReadersIT {
  private static final int NODE_PER_ID=3;
  private static final int IDS=5;
  private static final Label LABEL=Label.label("Label");
  private static final String KEY="key";
  @Rule public final ImpermanentDatabaseRule db=new ImpermanentDatabaseRule();
  @Rule public final OtherThreadRule<Void> t2=new OtherThreadRule<>();
  @Test public void shouldReadCorrectResultsFromMultipleNestedReaders(){
    createIndex();
    try (Transaction tx=db.beginTx()){
      for (int i=0; i < NODE_PER_ID; i++) {
        createRoundOfNodes();
      }
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      List<ResourceIterator<Node>> iterators=new ArrayList<>();
      for (int id=0; id < IDS; id++) {
        iterators.add(db.findNodes(LABEL,KEY,id));
      }
      for (int i=0; i < NODE_PER_ID; i++) {
        assertRoundOfNodes(iterators);
      }
      for (      ResourceIterator<Node> reader : iterators) {
        assertFalse(reader.hasNext());
        reader.close();
      }
      tx.success();
    }
   }
  @Test public void shouldReadCorrectResultsFromMultipleNestedReadersWhenConcurrentWriteHappens() throws Exception {
    createIndex();
    try (Transaction tx=db.beginTx()){
      for (int id=0; id < IDS; id++) {
        for (int i=0; i < NODE_PER_ID; i++) {
          db.createNode(LABEL).setProperty(KEY,id);
        }
      }
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      List<ResourceIterator<Node>> iterators=new ArrayList<>();
      for (int id=0; id < IDS; id++) {
        iterators.add(db.findNodes(LABEL,KEY,id));
      }
      for (int i=0; i < NODE_PER_ID; i++) {
        assertRoundOfNodes(iterators);
        if (i % 2 == 1) {
          t2.execute(nodeCreator()).get();
        }
      }
      assertRoundOfNodes(iterators);
      for (      ResourceIterator<Node> reader : iterators) {
        assertFalse(reader.hasNext());
        reader.close();
      }
      tx.success();
    }
   }
  private void createRoundOfNodes(){
    for (int id=0; id < IDS; id++) {
      db.createNode(LABEL).setProperty(KEY,id);
    }
  }
  private void assertRoundOfNodes(  List<ResourceIterator<Node>> iterators){
    for (int id=0; id < IDS; id++) {
      assertNode(iterators.get(id),id);
    }
  }
  private WorkerCommand<Void,Void> nodeCreator(){
    return state -> {
      try (Transaction tx=db.beginTx()){
        createRoundOfNodes();
        tx.success();
      }
       return null;
    }
;
  }
  private void assertNode(  ResourceIterator<Node> reader,  int id){
    assertTrue(reader.hasNext());
    Node node=reader.next();
    assertTrue(node.hasLabel(LABEL));
    assertEquals("Expected node " + node + " (returned by index reader) to have 'id' property w/ value "+ id,id,node.getProperty(KEY));
  }
  private void createIndex(){
    try (Transaction tx=db.beginTx()){
      db.schema().indexFor(LABEL).on(KEY).create();
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(10,SECONDS);
      tx.success();
    }
   }
}
