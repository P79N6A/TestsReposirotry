public abstract static class Unique<K extends NativeIndexKey<K>,V extends NativeIndexValue> extends NativeIndexPopulatorTests<K,V> {
  @Test public void addShouldThrowOnDuplicateValues(){
    populator.create();
    IndexEntryUpdate<IndexDescriptor>[] updates=valueCreatorUtil.someUpdatesWithDuplicateValues(random);
    try {
      populator.add(Arrays.asList(updates));
      fail("Updates should have conflicted");
    }
 catch (    IndexEntryConflictException e) {
    }
 finally {
      populator.close(true);
    }
  }
  @Test public void updaterShouldThrowOnDuplicateValues() throws Exception {
    populator.create();
    IndexEntryUpdate<IndexDescriptor>[] updates=valueCreatorUtil.someUpdatesWithDuplicateValues(random);
    IndexUpdater updater=populator.newPopulatingUpdater(null_property_accessor);
    for (    IndexEntryUpdate<IndexDescriptor> update : updates) {
      updater.process(update);
    }
    try {
      updater.close();
      fail("Updates should have conflicted");
    }
 catch (    Exception e) {
      assertTrue(e.getMessage(),Exceptions.contains(e,IndexEntryConflictException.class));
    }
 finally {
      populator.close(true);
    }
  }
  @Test public void shouldSampleUpdates() throws Exception {
    populator.create();
    IndexEntryUpdate<IndexDescriptor>[] updates=valueCreatorUtil.someUpdates(random);
    populator.add(asList(updates));
    for (    IndexEntryUpdate<IndexDescriptor> update : updates) {
      populator.includeSample(update);
    }
    IndexSample sample=populator.sampleResult();
    assertEquals(updates.length,sample.sampleSize());
    assertEquals(updates.length,sample.uniqueValues());
    assertEquals(updates.length,sample.indexSize());
    populator.close(true);
  }
}
