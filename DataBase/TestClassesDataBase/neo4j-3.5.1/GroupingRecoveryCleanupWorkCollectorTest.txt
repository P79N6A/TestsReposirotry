class GroupingRecoveryCleanupWorkCollectorTest {
  private final ImmediateJobScheduler jobScheduler=new ImmediateJobScheduler();
  private final GroupingRecoveryCleanupWorkCollector collector=new GroupingRecoveryCleanupWorkCollector(jobScheduler);
  @Test void mustNotScheduleAnyJobsBeforeStart(){
    List<DummyJob> allRuns=new ArrayList<>();
    List<DummyJob> expectedJobs=someJobs(allRuns);
    collector.init();
    addAll(expectedJobs);
    assertTrue(allRuns.isEmpty());
  }
  @Test void mustScheduleAllJobs(){
    List<DummyJob> allRuns=new ArrayList<>();
    List<DummyJob> expectedJobs=someJobs(allRuns);
    collector.init();
    addAll(expectedJobs);
    collector.start();
    assertSame(expectedJobs,allRuns);
  }
  @Test void mustThrowIfOldJobsDuringInit(){
    List<DummyJob> allRuns=new ArrayList<>();
    List<DummyJob> someJobs=someJobs(allRuns);
    addAll(someJobs);
    assertThrows(IllegalStateException.class,collector::init);
  }
  @Test void mustCloseOldJobsOnShutdown(){
    List<DummyJob> allRuns=new ArrayList<>();
    List<DummyJob> someJobs=someJobs(allRuns);
    collector.init();
    addAll(someJobs);
    collector.shutdown();
    assertTrue(allRuns.isEmpty(),"Expected no jobs to run");
    for (    DummyJob job : someJobs) {
      assertTrue(job.isClosed(),"Expected all jobs to be closed");
    }
  }
  @Test void mustNotScheduleOldJobsOnMultipleStart(){
    List<DummyJob> allRuns=new ArrayList<>();
    List<DummyJob> expectedJobs=someJobs(allRuns);
    collector.init();
    addAll(expectedJobs);
    collector.start();
    collector.start();
    assertSame(expectedJobs,allRuns);
  }
  @Test void mustNotScheduleOldJobsOnStartStopStart() throws Throwable {
    List<DummyJob> allRuns=new ArrayList<>();
    List<DummyJob> expectedJobs=someJobs(allRuns);
    collector.init();
    addAll(expectedJobs);
    collector.start();
    collector.stop();
    collector.start();
    assertSame(expectedJobs,allRuns);
  }
  @Test void executeAllTheJobsWhenSeparateJobFails(){
    List<DummyJob> allRuns=new ArrayList<>();
    collector.init();
    DummyJob firstJob=new DummyJob("first",allRuns);
    DummyJob thirdJob=new DummyJob("third",allRuns);
    DummyJob fourthJob=new DummyJob("fourth",allRuns);
    List<DummyJob> expectedJobs=Arrays.asList(firstJob,thirdJob,fourthJob);
    collector.add(firstJob);
    collector.add(new EvilJob());
    collector.add(thirdJob);
    collector.add(fourthJob);
    RuntimeException exception=assertThrows(RuntimeException.class,collector::start);
    assertTrue(Exceptions.contains(exception,"Resilient to run attempts",RuntimeException.class));
    assertSame(expectedJobs,allRuns);
  }
  @Test void throwOnAddingJobsAfterStart(){
    collector.init();
    collector.start();
    assertThrows(IllegalStateException.class,() -> collector.add(new DummyJob("first",new ArrayList<>())));
  }
  private void addAll(  Collection<DummyJob> jobs){
    jobs.forEach(collector::add);
  }
  private void assertSame(  List<DummyJob> someJobs,  List<DummyJob> actual){
    assertTrue(actual.containsAll(someJobs));
    assertTrue(someJobs.containsAll(actual));
  }
  private List<DummyJob> someJobs(  List<DummyJob> allRuns){
    return new ArrayList<>(Arrays.asList(new DummyJob("A",allRuns),new DummyJob("B",allRuns),new DummyJob("C",allRuns)));
  }
private class ImmediateJobScheduler extends JobSchedulerAdapter {
    @Override public JobHandle schedule(    Group group,    Runnable job){
      job.run();
      return super.schedule(group,job);
    }
  }
private class EvilJob implements CleanupJob {
    @Override public boolean needed(){
      return false;
    }
    @Override public boolean hasFailed(){
      return false;
    }
    @Override public Throwable getCause(){
      return null;
    }
    @Override public void close(){
    }
    @Override public void run(    ExecutorService executor){
      throw new RuntimeException("Resilient to run attempts");
    }
  }
private class DummyJob implements CleanupJob {
    private final String name;
    private final List<DummyJob> allRuns;
    private boolean closed;
    DummyJob(    String name,    List<DummyJob> allRuns){
      this.name=name;
      this.allRuns=allRuns;
    }
    @Override public String toString(){
      return name;
    }
    @Override public boolean needed(){
      return false;
    }
    @Override public boolean hasFailed(){
      return false;
    }
    @Override public Throwable getCause(){
      return null;
    }
    @Override public void close(){
      closed=true;
    }
    @Override public void run(    ExecutorService executor){
      allRuns.add(this);
    }
    public boolean isClosed(){
      return closed;
    }
  }
}
