class BinaryLatchTest {
  private static final ExecutorService executor=Executors.newCachedThreadPool();
  @AfterAll static void shutDownExecutor(){
    executor.shutdown();
  }
  @Test void releaseThenAwaitDoesNotBlock(){
    assertTimeout(ofSeconds(3),() -> {
      BinaryLatch latch=new BinaryLatch();
      latch.release();
      latch.await();
    }
);
  }
  @Test void releaseMustUnblockAwaiters(){
    assertTimeout(ofSeconds(10),() -> {
      final BinaryLatch latch=new BinaryLatch();
      Runnable awaiter=latch::await;
      int awaiters=24;
      Future<?>[] futures=new Future<?>[awaiters];
      for (int i=0; i < awaiters; i++) {
        futures[i]=executor.submit(awaiter);
      }
      assertThrows(TimeoutException.class,() -> futures[0].get(10,TimeUnit.MILLISECONDS));
      latch.release();
      for (      Future<?> future : futures) {
        future.get();
      }
    }
);
  }
  @Test void stressLatch(){
    assertTimeout(ofSeconds(60),() -> {
      final AtomicReference<BinaryLatch> latchRef=new AtomicReference<>(new BinaryLatch());
      Runnable awaiter=() -> {
        BinaryLatch latch;
        while ((latch=latchRef.get()) != null) {
          latch.await();
        }
      }
;
      int awaiters=6;
      Future<?>[] futures=new Future<?>[awaiters];
      for (int i=0; i < awaiters; i++) {
        futures[i]=executor.submit(awaiter);
      }
      ThreadLocalRandom rng=ThreadLocalRandom.current();
      for (int i=0; i < 500000; i++) {
        latchRef.getAndSet(new BinaryLatch()).release();
        spin(rng.nextLong(0,10));
      }
      latchRef.getAndSet(null).release();
      for (      Future<?> future : futures) {
        future.get();
      }
    }
);
  }
  private static void spin(  long micros){
    if (micros == 0) {
      return;
    }
    long now;
    long deadline=System.nanoTime() + TimeUnit.MICROSECONDS.toNanos(micros);
    do {
      now=System.nanoTime();
    }
 while (now < deadline);
  }
}
