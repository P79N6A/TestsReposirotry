public class IndexSamplingControllerTest {
  @Test public void shouldStartASamplingJobForEachIndexInTheDB(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(true);
    when(indexProxy.getState()).thenReturn(ONLINE);
    controller.sampleIndexes(BACKGROUND_REBUILD_UPDATED);
    verify(jobFactory).create(indexId,indexProxy);
    verify(tracker).scheduleSamplingJob(job);
    verify(tracker,times(2)).canExecuteMoreSamplingJobs();
    verifyNoMoreInteractions(jobFactory,tracker);
  }
  @Test public void shouldNotStartAJobIfTheIndexIsNotOnline(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(true);
    when(indexProxy.getState()).thenReturn(POPULATING);
    controller.sampleIndexes(BACKGROUND_REBUILD_UPDATED);
    verify(tracker,times(2)).canExecuteMoreSamplingJobs();
    verifyNoMoreInteractions(jobFactory,tracker);
  }
  @Test public void shouldNotStartAJobIfTheTrackerCannotHandleIt(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(false);
    when(indexProxy.getState()).thenReturn(ONLINE);
    controller.sampleIndexes(BACKGROUND_REBUILD_UPDATED);
    verify(tracker,times(1)).canExecuteMoreSamplingJobs();
    verifyNoMoreInteractions(jobFactory,tracker);
  }
  @Test public void shouldNotEmptyQueueConcurrently(){
    final AtomicInteger totalCount=new AtomicInteger(0);
    final AtomicInteger concurrentCount=new AtomicInteger(0);
    final DoubleLatch jobLatch=new DoubleLatch();
    final DoubleLatch testLatch=new DoubleLatch();
    final ThreadLocal<Boolean> hasRun=ThreadLocal.withInitial(() -> false);
    IndexSamplingJobFactory jobFactory=(indexId,proxy) -> {
      if (hasRun.get()) {
        return null;
      }
      hasRun.set(true);
      if (!concurrentCount.compareAndSet(0,1)) {
        throw new IllegalStateException("count !== 0 on create");
      }
      totalCount.incrementAndGet();
      jobLatch.waitForAllToStart();
      testLatch.startAndWaitForAllToStart();
      jobLatch.waitForAllToFinish();
      concurrentCount.decrementAndGet();
      testLatch.finish();
      return null;
    }
;
    final IndexSamplingController controller=new IndexSamplingController(samplingConfig,jobFactory,jobQueue,tracker,snapshotProvider,scheduler,always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(true);
    when(indexProxy.getState()).thenReturn(ONLINE);
    new Thread(runController(controller,BACKGROUND_REBUILD_UPDATED)).start();
    jobLatch.startAndWaitForAllToStart();
    testLatch.waitForAllToStart();
    assertEquals(1,concurrentCount.get());
    assertEquals(1,totalCount.get());
    controller.sampleIndexes(BACKGROUND_REBUILD_UPDATED);
    jobLatch.finish();
    testLatch.waitForAllToFinish();
    assertEquals(0,concurrentCount.get());
    assertEquals(1,totalCount.get());
  }
  @Test public void shouldSampleAllTheIndexes(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(true);
    when(indexProxy.getState()).thenReturn(ONLINE);
    when(anotherIndexProxy.getState()).thenReturn(ONLINE);
    indexMap.putIndexProxy(anotherIndexProxy);
    controller.sampleIndexes(TRIGGER_REBUILD_UPDATED);
    verify(jobFactory).create(indexId,indexProxy);
    verify(tracker).scheduleSamplingJob(job);
    verify(jobFactory).create(anotherIndexId,anotherIndexProxy);
    verify(tracker).scheduleSamplingJob(anotherJob);
    verify(tracker,times(2)).waitUntilCanExecuteMoreSamplingJobs();
    verifyNoMoreInteractions(jobFactory,tracker);
  }
  @Test public void shouldSampleAllTheOnlineIndexes(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(true);
    when(indexProxy.getState()).thenReturn(ONLINE);
    when(anotherIndexProxy.getState()).thenReturn(POPULATING);
    indexMap.putIndexProxy(anotherIndexProxy);
    controller.sampleIndexes(TRIGGER_REBUILD_UPDATED);
    verify(jobFactory).create(indexId,indexProxy);
    verify(tracker).scheduleSamplingJob(job);
    verify(tracker,times(2)).waitUntilCanExecuteMoreSamplingJobs();
    verifyNoMoreInteractions(jobFactory,tracker);
  }
  @Test public void shouldNotStartOtherSamplingWhenSamplingAllTheIndexes(){
    final AtomicInteger totalCount=new AtomicInteger(0);
    final AtomicInteger concurrentCount=new AtomicInteger(0);
    final DoubleLatch jobLatch=new DoubleLatch();
    final DoubleLatch testLatch=new DoubleLatch();
    IndexSamplingJobFactory jobFactory=(indexId,proxy) -> {
      if (!concurrentCount.compareAndSet(0,1)) {
        throw new IllegalStateException("count !== 0 on create");
      }
      totalCount.incrementAndGet();
      jobLatch.waitForAllToStart();
      testLatch.startAndWaitForAllToStart();
      jobLatch.waitForAllToFinish();
      concurrentCount.decrementAndGet();
      testLatch.finish();
      return null;
    }
;
    final IndexSamplingController controller=new IndexSamplingController(samplingConfig,jobFactory,jobQueue,tracker,snapshotProvider,scheduler,always(true));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(true);
    when(indexProxy.getState()).thenReturn(ONLINE);
    new Thread(runController(controller,TRIGGER_REBUILD_UPDATED)).start();
    jobLatch.startAndWaitForAllToStart();
    testLatch.waitForAllToStart();
    assertEquals(1,concurrentCount.get());
    controller.sampleIndexes(BACKGROUND_REBUILD_UPDATED);
    jobLatch.finish();
    testLatch.waitForAllToFinish();
    assertEquals(0,concurrentCount.get());
    assertEquals(1,totalCount.get());
  }
  @Test public void shouldRecoverOnlineIndex(){
    IndexSamplingController controller=newSamplingController(always(true));
    when(indexProxy.getState()).thenReturn(ONLINE);
    controller.recoverIndexSamples();
    verify(jobFactory).create(indexId,indexProxy);
    verify(job).run();
    verifyNoMoreInteractions(jobFactory,job,tracker);
  }
  @Test public void shouldNotRecoverOfflineIndex(){
    IndexSamplingController controller=newSamplingController(always(true));
    when(indexProxy.getState()).thenReturn(FAILED);
    controller.recoverIndexSamples();
    verifyNoMoreInteractions(jobFactory,job,tracker);
  }
  @Test public void shouldNotRecoverOnlineIndexIfNotNeeded(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(indexProxy.getState()).thenReturn(ONLINE);
    controller.recoverIndexSamples();
    verifyNoMoreInteractions(jobFactory,job,tracker);
  }
  @Test public void shouldSampleIndex(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(true);
    when(indexProxy.getState()).thenReturn(ONLINE);
    when(anotherIndexProxy.getState()).thenReturn(ONLINE);
    indexMap.putIndexProxy(anotherIndexProxy);
    controller.sampleIndex(indexId,TRIGGER_REBUILD_UPDATED);
    verify(jobFactory,times(1)).create(indexId,indexProxy);
    verify(tracker,times(1)).scheduleSamplingJob(job);
    verify(jobFactory,never()).create(anotherIndexId,anotherIndexProxy);
    verify(tracker,never()).scheduleSamplingJob(anotherJob);
    verify(tracker,times(1)).waitUntilCanExecuteMoreSamplingJobs();
    verifyNoMoreInteractions(jobFactory,tracker);
  }
  @Test public void shouldNotStartForSingleIndexAJobIfTheTrackerCannotHandleIt(){
    IndexSamplingController controller=newSamplingController(always(false));
    when(tracker.canExecuteMoreSamplingJobs()).thenReturn(false);
    when(indexProxy.getState()).thenReturn(ONLINE);
    controller.sampleIndex(indexId,BACKGROUND_REBUILD_UPDATED);
    verify(tracker,times(1)).canExecuteMoreSamplingJobs();
    verifyNoMoreInteractions(jobFactory,tracker);
  }
private static class Always implements IndexSamplingController.RecoveryCondition {
    private final boolean ans;
    Always(    boolean ans){
      this.ans=ans;
    }
    @Override public boolean test(    StoreIndexDescriptor descriptor){
      return ans;
    }
  }
  private final IndexSamplingConfig samplingConfig=mock(IndexSamplingConfig.class);
  private final IndexSamplingJobFactory jobFactory=mock(IndexSamplingJobFactory.class);
  private final IndexSamplingJobQueue<Long> jobQueue=new IndexSamplingJobQueue<>(Predicates.alwaysTrue());
  private final IndexSamplingJobTracker tracker=mock(IndexSamplingJobTracker.class);
  private final JobScheduler scheduler=mock(JobScheduler.class);
  private final IndexMapSnapshotProvider snapshotProvider=mock(IndexMapSnapshotProvider.class);
  private final IndexMap indexMap=new IndexMap();
  private final long indexId=2;
  private final long anotherIndexId=3;
  private final IndexProxy indexProxy=mock(IndexProxy.class);
  private final IndexProxy anotherIndexProxy=mock(IndexProxy.class);
  private final CapableIndexDescriptor descriptor=forSchema(forLabel(3,4),PROVIDER_DESCRIPTOR).withId(indexId).withoutCapabilities();
  private final CapableIndexDescriptor anotherDescriptor=forSchema(forLabel(5,6),PROVIDER_DESCRIPTOR).withId(anotherIndexId).withoutCapabilities();
  private final IndexSamplingJob job=mock(IndexSamplingJob.class);
  private final IndexSamplingJob anotherJob=mock(IndexSamplingJob.class);
{
    when(samplingConfig.backgroundSampling()).thenReturn(true);
    when(samplingConfig.jobLimit()).thenReturn(1);
    when(indexProxy.getDescriptor()).thenReturn(descriptor);
    when(anotherIndexProxy.getDescriptor()).thenReturn(anotherDescriptor);
    when(snapshotProvider.indexMapSnapshot()).thenReturn(indexMap);
    when(jobFactory.create(indexId,indexProxy)).thenReturn(job);
    when(jobFactory.create(anotherIndexId,anotherIndexProxy)).thenReturn(anotherJob);
    indexMap.putIndexProxy(indexProxy);
  }
  private IndexSamplingController.RecoveryCondition always(  boolean ans){
    return new Always(ans);
  }
  private IndexSamplingController newSamplingController(  IndexSamplingController.RecoveryCondition recoveryPredicate){
    return new IndexSamplingController(samplingConfig,jobFactory,jobQueue,tracker,snapshotProvider,scheduler,recoveryPredicate);
  }
  private Runnable runController(  final IndexSamplingController controller,  final IndexSamplingMode mode){
    return () -> controller.sampleIndexes(mode);
  }
}
