public class LazySingleReferenceTest {
  @Test public void shouldOnlyAllowSingleThreadToInitialize() throws Exception {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicInteger initCalls=new AtomicInteger();
    LazySingleReference<Integer> ref=new LazySingleReference<Integer>(){
      @Override protected Integer create(){
        awaitLatch(latch);
        return initCalls.incrementAndGet();
      }
    }
;
    Future<Integer> t1Evaluate=t1.executeDontWait(evaluate(ref));
    t1.waitUntilWaiting();
    Future<Integer> t2Evaluate=t2.executeDontWait(evaluate(ref));
    t2.waitUntilBlocked();
    latch.countDown();
    int e1=t1Evaluate.get();
    int e2=t2Evaluate.get();
    assertEquals("T1 evaluation",1,e1);
    assertEquals("T2 evaluation",1,e2);
  }
  @Test public void shouldMutexAccessBetweenInvalidateAndinstance() throws Exception {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicInteger initCalls=new AtomicInteger();
    LazySingleReference<Integer> ref=new LazySingleReference<Integer>(){
      @Override protected Integer create(){
        awaitLatch(latch);
        return initCalls.incrementAndGet();
      }
    }
;
    Future<Integer> t1Evaluate=t1.executeDontWait(evaluate(ref));
    t1.waitUntilWaiting();
    Future<Void> t2Invalidate=t2.executeDontWait(invalidate(ref));
    t2.waitUntilBlocked();
    latch.countDown();
    int e=t1Evaluate.get();
    t2Invalidate.get();
    assertEquals("Evaluation",1,e);
  }
  @Test public void shouldInitializeAgainAfterInvalidated(){
    final AtomicInteger initCalls=new AtomicInteger();
    LazySingleReference<Integer> ref=new LazySingleReference<Integer>(){
      @Override protected Integer create(){
        return initCalls.incrementAndGet();
      }
    }
;
    assertEquals("First evaluation",1,ref.get().intValue());
    ref.invalidate();
    int e2=ref.get();
    assertEquals("Second evaluation",2,e2);
  }
  @Test public void shouldRespondToIsInitialized(){
    LazySingleReference<Integer> ref=new LazySingleReference<Integer>(){
      @Override protected Integer create(){
        return 1;
      }
    }
;
    boolean firstResult=ref.isCreated();
    ref.get();
    boolean secondResult=ref.isCreated();
    ref.invalidate();
    boolean thirdResult=ref.isCreated();
    ref.get();
    boolean fourthResult=ref.isCreated();
    assertFalse("Should not start off as initialized",firstResult);
    assertTrue("Should be initialized after an evaluation",secondResult);
    assertFalse("Should not be initialized after invalidated",thirdResult);
    assertTrue("Should be initialized after a re-evaluation",fourthResult);
  }
  private OtherThreadExecutor<Void> t1;
  private OtherThreadExecutor<Void> t2;
  @Before public void before(){
    t1=new OtherThreadExecutor<>("T1",null);
    t2=new OtherThreadExecutor<>("T2",null);
  }
  @After public void after(){
    t2.close();
    t1.close();
  }
  private WorkerCommand<Void,Integer> evaluate(  final LazySingleReference<Integer> ref){
    return state -> ref.get();
  }
  private WorkerCommand<Void,Void> invalidate(  final LazySingleReference<Integer> ref){
    return state -> {
      ref.invalidate();
      return null;
    }
;
  }
}
