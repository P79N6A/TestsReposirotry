public class OtherThreadRule<STATE> implements TestRule {
  private final String name;
  private final long timeout;
  private final TimeUnit unit;
  private volatile OtherThreadExecutor<STATE> executor;
  public OtherThreadRule(){
    this(null);
  }
  public OtherThreadRule(  String name){
    this(name,60,SECONDS);
  }
  public OtherThreadRule(  long timeout,  TimeUnit unit){
    this(null,timeout,unit);
  }
  public OtherThreadRule(  String name,  long timeout,  TimeUnit unit){
    this.name=name;
    this.timeout=timeout;
    this.unit=unit;
  }
  public <RESULT>Future<RESULT> execute(  OtherThreadExecutor.WorkerCommand<STATE,RESULT> cmd){
    Future<RESULT> future=executor.executeDontWait(cmd);
    try {
      executor.awaitStartExecuting();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Interrupted while awaiting start of execution.",e);
    }
    return future;
  }
  protected STATE initialState(){
    return null;
  }
  public static Matcher<OtherThreadRule> isWaiting(){
    return isThreadState(Thread.State.WAITING,Thread.State.TIMED_WAITING);
  }
  public static Matcher<OtherThreadRule> isThreadState(  final Thread.State... eitherOfStates){
    return new TypeSafeMatcher<OtherThreadRule>(){
      @Override protected boolean matchesSafely(      OtherThreadRule rule){
        try {
          rule.executor.waitUntilThreadState(eitherOfStates);
          return true;
        }
 catch (        TimeoutException e) {
          rule.executor.printStackTrace(System.err);
          return false;
        }
      }
      @Override public void describeTo(      org.hamcrest.Description description){
        description.appendText("Thread blocked in state WAITING");
      }
    }
;
  }
  public OtherThreadExecutor<STATE> get(){
    return executor;
  }
  public void interrupt(){
    executor.interrupt();
  }
  @Override public String toString(){
    OtherThreadExecutor<STATE> otherThread=executor;
    if (otherThread == null) {
      return "OtherThreadRule[state=dead]";
    }
    return otherThread.toString();
  }
  @Override public Statement apply(  final Statement base,  final Description description){
    return new Statement(){
      @Override public void evaluate() throws Throwable {
        String threadName=name != null ? name + "-" + description.getDisplayName() : description.getDisplayName();
        executor=new OtherThreadExecutor<>(threadName,timeout,unit,initialState());
        try {
          base.evaluate();
        }
  finally {
          try {
            executor.close();
          }
  finally {
            executor=null;
          }
        }
      }
    }
;
  }
}
