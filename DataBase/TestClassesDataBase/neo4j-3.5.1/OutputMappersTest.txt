public class OutputMappersTest {
  @Rule public ExpectedException exception=ExpectedException.none();
public static class SingleStringFieldRecord {
    public String name;
    public SingleStringFieldRecord(    String name){
      this.name=name;
    }
  }
public static class UnmappableRecord {
    public UnmappableRecord wat;
  }
public static class RecordWithPrivateField {
    private String wat;
  }
public static class RecordWithNonStringKeyMap {
    public Map<RecordWithNonStringKeyMap,Object> wat;
  }
public static class RecordWithStaticFields {
    public static String skipMePublic;
    public String includeMe;
    private static String skipMePrivate;
    public RecordWithStaticFields(    String val){
      this.includeMe=val;
    }
  }
public static class RecordWithDeprecatedFields {
    @Deprecated public String deprecated;
    public String replacement;
    @Deprecated public String alsoDeprecated;
  }
  @Test public void shouldMapSimpleRecordWithString() throws Throwable {
    OutputMapper mapper=mapper(SingleStringFieldRecord.class);
    assertThat(mapper.signature(),contains(outputField("name",NTString)));
    assertThat(asList(mapper.apply(new SingleStringFieldRecord("hello, world!"))),contains("hello, world!"));
  }
  @Test public void shouldSkipStaticFields() throws Throwable {
    OutputMapper mapper=mapper(RecordWithStaticFields.class);
    assertThat(mapper.signature(),contains(outputField("includeMe",NTString)));
    assertThat(asList(mapper.apply(new RecordWithStaticFields("hello, world!"))),contains("hello, world!"));
  }
  @Test public void shouldNoteDeprecatedFields() throws Exception {
    OutputMapper mapper=mapper(RecordWithDeprecatedFields.class);
    assertThat(mapper.signature(),containsInAnyOrder(outputField("deprecated",NTString,true),outputField("alsoDeprecated",NTString,true),outputField("replacement",NTString,false)));
  }
  @Test public void shouldGiveHelpfulErrorOnUnmappable() throws Throwable {
    exception.expect(ProcedureException.class);
    exception.expectMessage("Field `wat` in record `UnmappableRecord` cannot be converted to a Neo4j type:" + " Don't know how to map `org.neo4j.kernel.impl.proc.OutputMappersTest$UnmappableRecord`");
    mapper(UnmappableRecord.class);
  }
  @Test public void shouldGiveHelpfulErrorOnPrivateField() throws Throwable {
    exception.expect(ProcedureException.class);
    exception.expectMessage("Field `wat` in record `RecordWithPrivateField` cannot be accessed. " + "Please ensure the field is marked as `public`.");
    mapper(RecordWithPrivateField.class);
  }
  @Test public void shouldGiveHelpfulErrorOnMapWithNonStringKeyMap() throws Throwable {
    exception.expect(ProcedureException.class);
    exception.expectMessage("Field `wat` in record `RecordWithNonStringKeyMap` cannot be converted " + "to a Neo4j type: Maps are required to have `String` keys - but this map " + "has `org.neo4j.kernel.impl.proc.OutputMappersTest$RecordWithNonStringKeyMap` keys.");
    mapper(RecordWithNonStringKeyMap.class);
  }
  @Test public void shouldWarnAgainstStdLibraryClassesSinceTheseIndicateUserError() throws Throwable {
    exception.expect(ProcedureException.class);
    exception.expectMessage(String.format("Procedures must return a Stream of records, where a record is a concrete class%n" + "that you define, with public non-final fields defining the fields in the record.%n" + "If you''d like your procedure to return `Long`, you could define a record class like:%n"+ "public class Output '{'%n"+ "    public Long out;%n"+ "'}'%n"+ "%n"+ "And then define your procedure as returning `Stream<Output>`."));
    mapper(Long.class);
  }
  private OutputMapper mapper(  Class<?> clazz) throws ProcedureException {
    return new OutputMappers(new TypeMappers()).mapper(clazz);
  }
}
