public class UserAggregationFunctionVisitorTest {
  @Rule public CompilationRule compilationRule=new CompilationRule();
  private ElementTestUtils elementTestUtils;
  private ElementVisitor<Stream<CompilationMessage>,Void> visitor;
  @Before public void prepare(){
    Types types=compilationRule.getTypes();
    Elements elements=compilationRule.getElements();
    elementTestUtils=new ElementTestUtils(compilationRule);
    final TypeMirrorUtils typeMirrorUtils=new TypeMirrorUtils(types,elements);
    visitor=new UserAggregationFunctionVisitor(new FunctionVisitor<>(UserAggregationFunction.class,types,elements,typeMirrorUtils,function -> CustomNameExtractor.getName(function::name,function::value),false),types);
  }
  @Test public void aggregation_functions_with_specified_name_cannot_be_in_root_namespace(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"functionWithName");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getElement,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,function,"Function <in_root_namespace> cannot be defined in the root namespace. Valid name example: com.acme.my_function"));
  }
  @Test public void aggregation_functions_with_specified_value_cannot_be_in_root_namespace(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"functionWithValue");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getElement,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,function,"Function <in_root_namespace_again> cannot be defined in the root namespace. Valid name example: com.acme.my_function"));
  }
  @Test public void aggregation_functions_in_non_root_namespace_are_valid(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"ok");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).isEmpty();
  }
  @Test public void aggregation_functions_with_unsupported_return_types_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"wrongReturnType");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getElement,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,function,"Unsupported return type <void> of aggregation function."));
  }
  @Test public void aggregation_functions_with_parameters_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"shouldNotHaveParameters");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getElement,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,function,"@UserAggregationFunction usage error: method should be public, non-static and without parameters."));
  }
  @Test public void aggregation_update_functions_with_unsupported_parameter_types_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"updateWithWrongParameterType");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,"Unsupported parameter type <java.lang.Thread> of procedure|function " + "StringAggregatorWithWrongUpdateParameterType#doSomething"));
  }
  @Test public void aggregation_functions_with_non_annotated_parameters_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"missingParameterAnnotation");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,"@org.neo4j.procedure.Name usage error: missing on parameter <foo>"));
  }
  @Test public void aggregation_result_functions_with_unsupported_return_types_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"resultWithWrongReturnType");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,"Unsupported return type <java.lang.Thread> of function defined in " + "<org.neo4j.tooling.procedure.visitors.examples.UserAggregationFunctionsExamples." + "StringAggregatorWithWrongResultReturnType#result>."));
  }
  @Test public void aggregation_result_functions_with_parameters_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserAggregationFunctionsExamples.class,"resultWithParams");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,"@UserAggregationUpdate usage error: method should be public, non-static and without parameters."));
  }
}
