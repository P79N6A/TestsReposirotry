@RunWith(MockitoJUnitRunner.class) public class MultipleIndexPopulatorUpdatesTest {
  @Mock(answer=Answers.RETURNS_MOCKS) private LogProvider logProvider;
  @Test public void updateForHigherNodeIgnoredWhenUsingFullNodeStoreScan() throws IndexPopulationFailedKernelException, IOException, IndexEntryConflictException {
    NeoStores neoStores=Mockito.mock(NeoStores.class);
    NodeStore nodeStore=mock(NodeStore.class);
    when(neoStores.getNodeStore()).thenReturn(nodeStore);
    ProcessListenableNeoStoreIndexView storeView=new ProcessListenableNeoStoreIndexView(LockService.NO_LOCK_SERVICE,neoStores);
    MultipleIndexPopulator indexPopulator=new MultipleIndexPopulator(storeView,logProvider,EntityType.NODE,mock(SchemaState.class));
    storeView.setProcessListener(new NodeUpdateProcessListener(indexPopulator));
    IndexPopulator populator=createIndexPopulator();
    IndexUpdater indexUpdater=mock(IndexUpdater.class);
    addPopulator(indexPopulator,populator,1,TestIndexDescriptorFactory.forLabel(1,1));
    indexPopulator.create();
    StoreScan<IndexPopulationFailedKernelException> storeScan=indexPopulator.indexAllEntities();
    storeScan.run();
    Mockito.verify(indexUpdater,never()).process(any(IndexEntryUpdate.class));
  }
  private NodeRecord getNodeRecord(){
    NodeRecord nodeRecord=new NodeRecord(1L);
    nodeRecord.initialize(true,0,false,1,0x0000000001L);
    InlineNodeLabels.putSorted(nodeRecord,new long[]{1},null,null);
    return nodeRecord;
  }
  private IndexPopulator createIndexPopulator(){
    return mock(IndexPopulator.class);
  }
  private MultipleIndexPopulator.IndexPopulation addPopulator(  MultipleIndexPopulator multipleIndexPopulator,  IndexPopulator indexPopulator,  long indexId,  IndexDescriptor descriptor){
    return addPopulator(multipleIndexPopulator,descriptor.withId(indexId),indexPopulator,mock(FlippableIndexProxy.class),mock(FailedIndexProxyFactory.class));
  }
  private MultipleIndexPopulator.IndexPopulation addPopulator(  MultipleIndexPopulator multipleIndexPopulator,  StoreIndexDescriptor descriptor,  IndexPopulator indexPopulator,  FlippableIndexProxy flippableIndexProxy,  FailedIndexProxyFactory failedIndexProxyFactory){
    return multipleIndexPopulator.addPopulator(indexPopulator,descriptor.withoutCapabilities(),flippableIndexProxy,failedIndexProxyFactory,"userIndexDescription");
  }
private static class NodeUpdateProcessListener implements Listener<StorageNodeCursor> {
    private final MultipleIndexPopulator indexPopulator;
    private final LabelSchemaDescriptor index;
    NodeUpdateProcessListener(    MultipleIndexPopulator indexPopulator){
      this.indexPopulator=indexPopulator;
      this.index=SchemaDescriptorFactory.forLabel(1,1);
    }
    @Override public void receive(    StorageNodeCursor node){
      if (node.entityReference() == 7) {
        indexPopulator.queueUpdate(IndexEntryUpdate.change(8L,index,Values.of("a"),Values.of("b")));
      }
    }
  }
private class ProcessListenableNeoStoreIndexView extends NeoStoreIndexStoreView {
    private Listener<StorageNodeCursor> processListener;
    private NeoStores neoStores;
    ProcessListenableNeoStoreIndexView(    LockService locks,    NeoStores neoStores){
      super(locks,neoStores);
      this.neoStores=neoStores;
    }
    @Override public <FAILURE extends Exception>StoreScan<FAILURE> visitNodes(    int[] labelIds,    IntPredicate propertyKeyIdFilter,    Visitor<EntityUpdates,FAILURE> propertyUpdatesVisitor,    Visitor<NodeLabelUpdate,FAILURE> labelUpdateVisitor,    boolean forceStoreScan){
      return new ListenableNodeScanViewNodeStoreScan<>(new RecordStorageReader(neoStores),locks,labelUpdateVisitor,propertyUpdatesVisitor,labelIds,propertyKeyIdFilter,processListener);
    }
    void setProcessListener(    Listener<StorageNodeCursor> processListener){
      this.processListener=processListener;
    }
  }
private class ListenableNodeScanViewNodeStoreScan<FAILURE extends Exception> extends StoreViewNodeStoreScan<FAILURE> {
    private final Listener<StorageNodeCursor> processListener;
    ListenableNodeScanViewNodeStoreScan(    StorageReader storageReader,    LockService locks,    Visitor<NodeLabelUpdate,FAILURE> labelUpdateVisitor,    Visitor<EntityUpdates,FAILURE> propertyUpdatesVisitor,    int[] labelIds,    IntPredicate propertyKeyIdFilter,    Listener<StorageNodeCursor> processListener){
      super(storageReader,locks,labelUpdateVisitor,propertyUpdatesVisitor,labelIds,propertyKeyIdFilter);
      this.processListener=processListener;
    }
    @Override public boolean process(    StorageNodeCursor cursor) throws FAILURE {
      processListener.receive(cursor);
      return super.process(cursor);
    }
  }
}
