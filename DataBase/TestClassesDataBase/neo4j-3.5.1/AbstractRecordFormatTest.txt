public abstract class AbstractRecordFormatTest {
  private static final int PAGE_SIZE=(int)kibiBytes(1);
  private static final long TEST_ITERATIONS=100_000;
  private static final long TEST_TIME=1000;
  private static final int DATA_SIZE=100;
  protected static final long NULL=Record.NULL_REFERENCE.intValue();
  private final RandomRule random=new RandomRule();
  private final EphemeralFileSystemRule fsRule=new EphemeralFileSystemRule();
  private final PageCacheRule pageCacheRule=new PageCacheRule();
  @Rule public final SuppressOutput suppressOutput=SuppressOutput.suppressAll();
  @Rule public final TestName name=new TestName();
  @Rule public final RuleChain ruleChain=RuleChain.outerRule(pageCacheRule).around(fsRule).around(random);
  private PageCache pageCache;
  public RecordKeys keys=FullyCoveringRecordKeys.INSTANCE;
  private final RecordFormats formats;
  private final int entityBits;
  private final int propertyBits;
  private RecordGenerators generators;
  protected AbstractRecordFormatTest(  RecordFormats formats,  int entityBits,  int propertyBits){
    this.formats=formats;
    this.entityBits=entityBits;
    this.propertyBits=propertyBits;
  }
  @Before public void setupPageCache(){
    pageCache=pageCacheRule.getPageCache(fsRule.get());
  }
  @Before public void before(){
    generators=new LimitedRecordGenerators(random.randomValues(),entityBits,propertyBits,40,16,-1);
  }
  @Test public void node() throws Exception {
    verifyWriteAndRead(formats::node,generators::node,keys::node,true);
  }
  @Test public void relationship() throws Exception {
    verifyWriteAndRead(formats::relationship,generators::relationship,keys::relationship,true);
  }
  @Test public void property() throws Exception {
    verifyWriteAndRead(formats::property,generators::property,keys::property,false);
  }
  @Test public void relationshipGroup() throws Exception {
    verifyWriteAndRead(formats::relationshipGroup,generators::relationshipGroup,keys::relationshipGroup,false);
  }
  @Test public void relationshipTypeToken() throws Exception {
    verifyWriteAndRead(formats::relationshipTypeToken,generators::relationshipTypeToken,keys::relationshipTypeToken,false);
  }
  @Test public void propertyKeyToken() throws Exception {
    verifyWriteAndRead(formats::propertyKeyToken,generators::propertyKeyToken,keys::propertyKeyToken,false);
  }
  @Test public void labelToken() throws Exception {
    verifyWriteAndRead(formats::labelToken,generators::labelToken,keys::labelToken,false);
  }
  @Test public void dynamic() throws Exception {
    verifyWriteAndRead(formats::dynamic,generators::dynamic,keys::dynamic,false);
  }
  private <R extends AbstractBaseRecord>void verifyWriteAndRead(  Supplier<RecordFormat<R>> formatSupplier,  Supplier<Generator<R>> generatorSupplier,  Supplier<RecordKey<R>> keySupplier,  boolean assertPostReadOffset) throws IOException {
    try (PagedFile storeFile=pageCache.map(new File("store-" + name.getMethodName()),PAGE_SIZE,CREATE)){
      RecordFormat<R> format=formatSupplier.get();
      RecordKey<R> key=keySupplier.get();
      Generator<R> generator=generatorSupplier.get();
      int recordSize=format.getRecordSize(new IntStoreHeader(DATA_SIZE));
      BatchingIdSequence idSequence=new BatchingIdSequence(random.nextBoolean() ? idSureToBeOnTheNextPage(PAGE_SIZE,recordSize) : 10);
      long time=currentTimeMillis();
      long endTime=time + TEST_TIME;
      long i=0;
      for (; i < TEST_ITERATIONS && currentTimeMillis() < endTime; i++) {
        R written=generator.get(recordSize,format,i % 5);
        R read=format.newRecord();
        try {
          writeRecord(written,format,storeFile,recordSize,idSequence);
          readAndVerifyRecord(written,read,format,key,storeFile,recordSize,assertPostReadOffset);
          idSequence.reset();
        }
 catch (        Throwable t) {
          Exceptions.setMessage(t,t.getMessage() + " : written:" + written+ ", read:"+ read+ ", seed:"+ random.seed()+ ", iteration:"+ i);
          throw t;
        }
      }
    }
   }
  private <R extends AbstractBaseRecord>void readAndVerifyRecord(  R written,  R read,  RecordFormat<R> format,  RecordKey<R> key,  PagedFile storeFile,  int recordSize,  boolean assertPostReadOffset) throws IOException {
    try (PageCursor cursor=storeFile.io(0,PagedFile.PF_SHARED_READ_LOCK)){
      assertedNext(cursor);
      read.setId(written.getId());
      int offset=Math.toIntExact(written.getId() * recordSize);
      do {
        cursor.setOffset(offset);
        format.read(read,cursor,NORMAL,recordSize);
      }
 while (cursor.shouldRetry());
      assertWithinBounds(written,cursor,"reading");
      if (assertPostReadOffset) {
        assertEquals("Cursor is positioned on first byte of next record after a read",offset + recordSize,cursor.getOffset());
      }
      cursor.checkAndClearCursorException();
      if (written.inUse()) {
        assertEquals(written.inUse(),read.inUse());
        assertEquals(written.getId(),read.getId());
        assertEquals(written.getSecondaryUnitId(),read.getSecondaryUnitId());
        key.assertRecordsEquals(written,read);
      }
 else {
        assertEquals(written.inUse(),read.inUse());
      }
    }
   }
  private <R extends AbstractBaseRecord>void writeRecord(  R record,  RecordFormat<R> format,  PagedFile storeFile,  int recordSize,  BatchingIdSequence idSequence) throws IOException {
    try (PageCursor cursor=storeFile.io(0,PagedFile.PF_SHARED_WRITE_LOCK)){
      assertedNext(cursor);
      if (record.inUse()) {
        format.prepare(record,recordSize,idSequence);
      }
      int offset=Math.toIntExact(record.getId() * recordSize);
      cursor.setOffset(offset);
      format.write(record,cursor,recordSize);
      assertWithinBounds(record,cursor,"writing");
    }
   }
  private <R extends AbstractBaseRecord>void assertWithinBounds(  R record,  PageCursor cursor,  String operation){
    if (cursor.checkAndClearBoundsFlag()) {
      fail("Out-of-bounds when " + operation + " record "+ record);
    }
  }
  private void assertedNext(  PageCursor cursor) throws IOException {
    assertTrue(cursor.next());
  }
  private long idSureToBeOnTheNextPage(  int pageSize,  int recordSize){
    return (pageSize + 100) / recordSize;
  }
}
