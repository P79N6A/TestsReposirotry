public class NeoTransactionIndexApplierTest {
  private static final IndexProviderDescriptor INDEX_DESCRIPTOR=new IndexProviderDescriptor("in-memory","1.0");
  private final IndexingService indexingService=mock(IndexingService.class);
  @SuppressWarnings("unchecked") private final Supplier<LabelScanWriter> labelScanStore=mock(Supplier.class);
  private final Collection<DynamicRecord> emptyDynamicRecords=Collections.emptySet();
  private final WorkSync<Supplier<LabelScanWriter>,LabelUpdateWork> labelScanStoreSynchronizer=new WorkSync<>(labelScanStore);
  private final WorkSync<IndexingUpdateService,IndexUpdatesWork> indexUpdatesSync=new WorkSync<>(indexingService);
  private final TransactionToApply transactionToApply=mock(TransactionToApply.class);
  @Before public void setup(){
    when(transactionToApply.transactionId()).thenReturn(1L);
    when(indexingService.convertToIndexUpdates(any(),eq(EntityType.NODE))).thenAnswer(o -> Iterables.empty());
  }
  @Test public void shouldUpdateLabelStoreScanOnNodeCommands() throws Exception {
    final IndexBatchTransactionApplier applier=newIndexTransactionApplier();
    final NodeRecord before=new NodeRecord(11);
    before.setLabelField(17,emptyDynamicRecords);
    final NodeRecord after=new NodeRecord(12);
    after.setLabelField(18,emptyDynamicRecords);
    final Command.NodeCommand command=new Command.NodeCommand(before,after);
    LabelScanWriter labelScanWriter=mock(LabelScanWriter.class);
    when(labelScanStore.get()).thenReturn(labelScanWriter);
    boolean result;
    try (TransactionApplier txApplier=applier.startTx(transactionToApply)){
      result=txApplier.visitNodeCommand(command);
    }
     assertFalse(result);
  }
  private IndexBatchTransactionApplier newIndexTransactionApplier(){
    PropertyStore propertyStore=mock(PropertyStore.class);
    return new IndexBatchTransactionApplier(indexingService,labelScanStoreSynchronizer,indexUpdatesSync,mock(NodeStore.class),mock(RelationshipStore.class),new PropertyPhysicalToLogicalConverter(propertyStore));
  }
  @Test public void shouldCreateIndexGivenCreateSchemaRuleCommand() throws Exception {
    final StoreIndexDescriptor indexRule=indexRule(1,42,42,INDEX_DESCRIPTOR);
    final IndexBatchTransactionApplier applier=newIndexTransactionApplier();
    final Command.SchemaRuleCommand command=new Command.SchemaRuleCommand(emptyDynamicRecords,singleton(createdDynamicRecord(1)),indexRule);
    boolean result;
    try (TransactionApplier txApplier=applier.startTx(transactionToApply)){
      result=txApplier.visitSchemaRuleCommand(command);
    }
     assertFalse(result);
    verify(indexingService).createIndexes(indexRule);
  }
  private StoreIndexDescriptor indexRule(  long ruleId,  int labelId,  int propertyId,  IndexProviderDescriptor descriptor){
    return IndexDescriptorFactory.forSchema(forLabel(labelId,propertyId),descriptor).withId(ruleId);
  }
  @Test public void shouldDropIndexGivenDropSchemaRuleCommand() throws Exception {
    final StoreIndexDescriptor indexRule=indexRule(1,42,42,INDEX_DESCRIPTOR);
    final IndexBatchTransactionApplier applier=newIndexTransactionApplier();
    final Command.SchemaRuleCommand command=new Command.SchemaRuleCommand(singleton(createdDynamicRecord(1)),singleton(dynamicRecord(1,false)),indexRule);
    boolean result;
    try (TransactionApplier txApplier=applier.startTx(transactionToApply)){
      result=txApplier.visitSchemaRuleCommand(command);
    }
     assertFalse(result);
    verify(indexingService).dropIndex(indexRule);
  }
  private static DynamicRecord createdDynamicRecord(  long id){
    DynamicRecord record=dynamicRecord(id,true);
    record.setCreated();
    return record;
  }
}
