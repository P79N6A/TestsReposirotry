public class IndexConsistencyIT {
  @Rule public final EmbeddedDatabaseRule db=new EmbeddedDatabaseRule();
  @Rule public final RandomRule random=new RandomRule();
  private final AssertableLogProvider log=new AssertableLogProvider();
  private static final Label[] LABELS=new Label[]{LABEL_ONE,LABEL_TWO,LABEL_THREE};
  private static final String PROPERTY_KEY="numericProperty";
  private static final double DELETE_RATIO=0.2;
  private static final double UPDATE_RATIO=0.2;
  private static final int NODE_COUNT_BASELINE=10;
  private final FileFilter SOURCE_COPY_FILE_FILTER=file -> file.isDirectory() || file.getName().startsWith("index");
  @Test public void reportNotCleanNativeIndex() throws IOException, ConsistencyCheckIncompleteException {
    DatabaseLayout databaseLayout=db.databaseLayout();
    someData();
    resolveComponent(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("forcedCheckpoint"));
    File indexesCopy=databaseLayout.file("indexesCopy");
    File indexSources=resolveComponent(DefaultIndexProviderMap.class).getDefaultProvider().directoryStructure().rootDirectory();
    copyRecursively(indexSources,indexesCopy,SOURCE_COPY_FILE_FILTER);
    try (Transaction tx=db.beginTx()){
      createNewNode(new Label[]{LABEL_ONE});
      tx.success();
    }
     db.shutdownAndKeepStore();
    copyRecursively(indexesCopy,indexSources);
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertFalse("Expected consistency check to fail",result.isSuccessful());
    assertThat(readReport(result),hasItem(containsString("WARN : Index was not properly shutdown and rebuild is required.")));
  }
  @Test public void reportNotCleanNativeIndexWithCorrectData() throws IOException, ConsistencyCheckIncompleteException {
    DatabaseLayout databaseLayout=db.databaseLayout();
    someData();
    resolveComponent(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("forcedCheckpoint"));
    File indexesCopy=databaseLayout.file("indexesCopy");
    File indexSources=resolveComponent(DefaultIndexProviderMap.class).getDefaultProvider().directoryStructure().rootDirectory();
    copyRecursively(indexSources,indexesCopy,SOURCE_COPY_FILE_FILTER);
    db.shutdownAndKeepStore();
    copyRecursively(indexesCopy,indexSources);
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertTrue("Expected consistency check to fail",result.isSuccessful());
    assertThat(readReport(result),hasItem(containsString("WARN : Index was not properly shutdown and rebuild is required.")));
  }
  private <T>T resolveComponent(  Class<T> clazz){
    return db.resolveDependency(clazz);
  }
  private List<String> readReport(  ConsistencyCheckService.Result result) throws IOException {
    return Files.readAllLines(result.reportFile().toPath());
  }
  List<Pair<Long,Label[]>> someData(){
    return someData(50);
  }
  List<Pair<Long,Label[]>> someData(  int numberOfModifications){
    List<Pair<Long,Label[]>> existingNodes;
    existingNodes=new ArrayList<>();
    try (Transaction tx=db.beginTx()){
      randomModifications(existingNodes,numberOfModifications);
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().indexFor(LABEL_ONE).on(PROPERTY_KEY).create();
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(1,TimeUnit.MINUTES);
      tx.success();
    }
     return existingNodes;
  }
  private List<Pair<Long,Label[]>> randomModifications(  List<Pair<Long,Label[]>> existingNodes,  int numberOfModifications){
    for (int i=0; i < numberOfModifications; i++) {
      double selectModification=random.nextDouble();
      if (existingNodes.size() < NODE_COUNT_BASELINE || selectModification >= DELETE_RATIO + UPDATE_RATIO) {
        createNewNode(existingNodes);
      }
 else       if (selectModification < DELETE_RATIO) {
        deleteExistingNode(existingNodes);
      }
 else {
        modifyLabelsOnExistingNode(existingNodes);
      }
    }
    return existingNodes;
  }
  private void createNewNode(  List<Pair<Long,Label[]>> existingNodes){
    Label[] labels=randomLabels();
    Node node=createNewNode(labels);
    existingNodes.add(Pair.of(node.getId(),labels));
  }
  private Node createNewNode(  Label[] labels){
    Node node=db.createNode(labels);
    node.setProperty(PROPERTY_KEY,random.nextInt());
    return node;
  }
  private void modifyLabelsOnExistingNode(  List<Pair<Long,Label[]>> existingNodes){
    int targetIndex=random.nextInt(existingNodes.size());
    Pair<Long,Label[]> existingPair=existingNodes.get(targetIndex);
    long nodeId=existingPair.first();
    Node node=db.getNodeById(nodeId);
    node.getLabels().forEach(node::removeLabel);
    Label[] newLabels=randomLabels();
    for (    Label label : newLabels) {
      node.addLabel(label);
    }
    existingNodes.remove(targetIndex);
    existingNodes.add(Pair.of(nodeId,newLabels));
  }
  private void deleteExistingNode(  List<Pair<Long,Label[]>> existingNodes){
    int targetIndex=random.nextInt(existingNodes.size());
    Pair<Long,Label[]> existingPair=existingNodes.get(targetIndex);
    Node node=db.getNodeById(existingPair.first());
    node.delete();
    existingNodes.remove(targetIndex);
  }
  private Label[] randomLabels(){
    List<Label> labels=new ArrayList<>(LABELS.length);
    for (    Label label : LABELS) {
      if (random.nextBoolean()) {
        labels.add(label);
      }
    }
    return labels.toArray(new Label[labels.size()]);
  }
  private ConsistencyCheckService.Result fullConsistencyCheck() throws ConsistencyCheckIncompleteException, IOException {
    try (FileSystemAbstraction fsa=new DefaultFileSystemAbstraction()){
      ConsistencyCheckService service=new ConsistencyCheckService();
      Config config=Config.defaults();
      return service.runFullConsistencyCheck(db.databaseLayout(),config,NONE,log,fsa,true);
    }
   }
}
