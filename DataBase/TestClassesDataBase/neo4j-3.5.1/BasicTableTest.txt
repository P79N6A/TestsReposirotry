@RunWith(Parameterized.class) public class BasicTableTest {
  private final TableFactory factory;
  private static final long seed=currentTimeMillis();
  private static final Random random=new Random(seed);
  @Parameterized.Parameters public static Collection<Object[]> data(){
    Collection<Object[]> result=new ArrayList<>();
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new IntKeyTable(capacity,VALUE_MARKER);
      }
      @Override public boolean supportsLongs(){
        return false;
      }
      @Override public Object sampleValue(){
        return null;
      }
    }
});
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new LongKeyTable(capacity,VALUE_MARKER);
      }
      @Override public boolean supportsLongs(){
        return true;
      }
      @Override public Object sampleValue(){
        return null;
      }
    }
});
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new IntKeyUnsafeTable(capacity,VALUE_MARKER,GlobalMemoryTracker.INSTANCE);
      }
      @Override public boolean supportsLongs(){
        return false;
      }
      @Override public Object sampleValue(){
        return null;
      }
    }
});
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new LongKeyUnsafeTable(capacity,VALUE_MARKER,GlobalMemoryTracker.INSTANCE);
      }
      @Override public boolean supportsLongs(){
        return true;
      }
      @Override public Object sampleValue(){
        return null;
      }
    }
});
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new LongKeyIntValueTable(capacity);
      }
      @Override public boolean supportsLongs(){
        return true;
      }
      @Override public Object sampleValue(){
        return new int[]{random.nextInt(Integer.MAX_VALUE)};
      }
    }
});
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new LongKeyLongValueTable(capacity);
      }
      @Override public boolean supportsLongs(){
        return true;
      }
      @Override public Object sampleValue(){
        return new long[]{Math.abs(random.nextLong())};
      }
    }
});
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new LongKeyObjectValueTable(capacity);
      }
      @Override public boolean supportsLongs(){
        return true;
      }
      @Override public Object sampleValue(){
        return new long[]{Math.abs(random.nextLong())};
      }
    }
});
    result.add(new Object[]{new TableFactory(){
      @Override public Table newTable(      int capacity){
        return new LongKeyLongValueUnsafeTable(capacity,GlobalMemoryTracker.INSTANCE);
      }
      @Override public boolean supportsLongs(){
        return true;
      }
      @Override public Object sampleValue(){
        return new long[]{Math.abs(random.nextLong())};
      }
    }
});
    return result;
  }
  public BasicTableTest(  TableFactory factory){
    this.factory=factory;
  }
  @Test public void shouldSetAndGetSmallKey(){
    try (Table table=factory.newTable(Primitive.DEFAULT_HEAP_CAPACITY)){
      long nullKey=table.nullKey();
      assertEquals(nullKey,table.key(0));
      long key=12345;
      int index=2;
      table.put(index,key,factory.sampleValue());
      assertEquals(key,table.key(index));
      table.remove(index);
      assertEquals(nullKey,table.key(index));
    }
   }
  @Test public void shouldSetAndGetBigKey(){
    assumeTrue(factory.supportsLongs());
    try (Table table=factory.newTable(Primitive.DEFAULT_HEAP_CAPACITY)){
      long nullKey=table.nullKey();
      assertEquals(nullKey,table.key(0));
      long key=0x24FCFF2FFL;
      int index=2;
      table.put(index,key,factory.sampleValue());
      assertEquals(key,table.key(index));
    }
   }
  @Test public void shouldRemoveBigKey(){
    assumeTrue(factory.supportsLongs());
    try (Table table=factory.newTable(Primitive.DEFAULT_HEAP_CAPACITY)){
      long nullKey=table.nullKey();
      long key=0x24F1FF3FEL;
      int index=5;
      table.put(index,key,factory.sampleValue());
      assertEquals(key,table.key(index));
      table.remove(index);
      assertEquals(nullKey,table.key(index));
    }
   }
  @Test public void shouldSetHopBits(){
    try (Table<?> table=factory.newTable(Primitive.DEFAULT_HEAP_CAPACITY)){
      int index=10;
      long hopBits=table.hopBits(index);
      assertEquals(0L,hopBits);
      table.putHopBit(index,2);
      table.putHopBit(index,11);
      assertEquals((1L << 2) | (1L << 11),table.hopBits(index));
    }
   }
  @Test public void shouldMoveHopBit(){
    try (Table<?> table=factory.newTable(Primitive.DEFAULT_HEAP_CAPACITY)){
      int index=10;
      table.putHopBit(index,2);
      table.putHopBit(index,11);
      table.moveHopBit(index,2,15);
      assertEquals((1L << 11) | (1L << 17),table.hopBits(index));
    }
   }
  @Test public void shouldClearTable(){
    try (Table table=factory.newTable(Primitive.DEFAULT_HEAP_CAPACITY)){
      int index=3;
      long key=123L;
      Object value=factory.sampleValue();
      table.put(index,key,value);
      assertEquals(key,table.key(index));
      table.clear();
      assertEquals(table.nullKey(),table.key(index));
    }
   }
private interface TableFactory {
    Table newTable(    int capacity);
    Object sampleValue();
    boolean supportsLongs();
  }
}
