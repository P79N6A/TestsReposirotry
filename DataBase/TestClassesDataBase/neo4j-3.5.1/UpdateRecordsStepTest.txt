public class UpdateRecordsStepTest {
  @Test public void ioThroughputStatDoesNotOverflow(){
    RecordStore<NodeRecord> store=mock(RecordStore.class);
    when(store.getRecordSize()).thenReturn(Integer.MAX_VALUE / 2);
    Configuration configuration=mock(Configuration.class);
    StageControl stageControl=mock(StageControl.class);
    UpdateRecordsStep<NodeRecord> step=new UpdateRecordsStep<>(stageControl,configuration,store,new StorePrepareIdSequence());
    NodeRecord record=new NodeRecord(1);
    record.setInUse(true);
    NodeRecord[] batch=new NodeRecord[11];
    Arrays.fill(batch,record);
    step.process(batch,mock(BatchSender.class));
    Stat stat=step.stat(Keys.io_throughput);
    assertThat(stat.asLong(),greaterThan(0L));
  }
  @Test public void recordWithReservedIdIsSkipped(){
    RecordStore<NodeRecord> store=mock(NodeStore.class);
    StageControl stageControl=mock(StageControl.class);
    UpdateRecordsStep<NodeRecord> step=new UpdateRecordsStep<>(stageControl,Configuration.DEFAULT,store,new StorePrepareIdSequence());
    NodeRecord node1=new NodeRecord(1);
    node1.setInUse(true);
    NodeRecord node2=new NodeRecord(2);
    node2.setInUse(true);
    NodeRecord nodeWithReservedId=new NodeRecord(IdGeneratorImpl.INTEGER_MINUS_ONE);
    NodeRecord[] batch={node1,node2,nodeWithReservedId};
    step.process(batch,mock(BatchSender.class));
    verify(store).prepareForCommit(eq(node1),any(IdSequence.class));
    verify(store).updateRecord(node1);
    verify(store).prepareForCommit(eq(node2),any(IdSequence.class));
    verify(store).updateRecord(node2);
    verify(store,never()).prepareForCommit(eq(nodeWithReservedId),any(IdSequence.class));
    verify(store,never()).updateRecord(nodeWithReservedId);
  }
}
