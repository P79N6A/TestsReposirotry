@Ignore("Not a test. This is a compatibility suite, run from LockingCompatibilityTestSuite.") public class AcquisitionTimeoutCompatibility extends LockingCompatibilityTestSuite.Compatibility {
  private final long TEST_TIMEOUT_SECONDS=30;
  private FakeClock clock;
  private Config customConfig;
  private Locks lockManager;
  private Locks.Client client;
  private Locks.Client client2;
  @Rule public VerboseTimeout timeout=VerboseTimeout.builder().withTimeout(TEST_TIMEOUT_SECONDS,TimeUnit.SECONDS).build();
  public AcquisitionTimeoutCompatibility(  LockingCompatibilityTestSuite suite){
    super(suite);
  }
  @Before public void setUp(){
    customConfig=Config.defaults(GraphDatabaseSettings.lock_acquisition_timeout,"100ms");
    clock=Clocks.fakeClock(100000,TimeUnit.MINUTES);
    lockManager=suite.createLockManager(customConfig,clock);
    client=lockManager.newClient();
    client2=lockManager.newClient();
  }
  @After public void tearDown(){
    client2.close();
    client.close();
    lockManager.close();
  }
  @Test public void terminateSharedLockAcquisition() throws InterruptedException {
    client.acquireExclusive(LockTracer.NONE,ResourceTypes.NODE,1);
    Future<Boolean> sharedLockAcquisition=threadB.execute(state -> {
      client2.acquireShared(LockTracer.NONE,ResourceTypes.NODE,1);
      return true;
    }
);
    assertThat(threadB,isWaiting());
    clock.forward(101,TimeUnit.MILLISECONDS);
    verifyAcquisitionFailure(sharedLockAcquisition);
  }
  @Test public void terminateExclusiveLockAcquisitionForExclusivelyLockedResource() throws InterruptedException {
    client.acquireExclusive(LockTracer.NONE,ResourceTypes.NODE,1);
    Future<Boolean> exclusiveLockAcquisition=threadB.execute(state -> {
      client2.acquireExclusive(LockTracer.NONE,ResourceTypes.NODE,1);
      return true;
    }
);
    assertThat(threadB,isWaiting());
    clock.forward(101,TimeUnit.MILLISECONDS);
    verifyAcquisitionFailure(exclusiveLockAcquisition);
  }
  @Test public void terminateExclusiveLockAcquisitionForSharedLockedResource() throws InterruptedException {
    client.acquireShared(LockTracer.NONE,ResourceTypes.NODE,1);
    Future<Boolean> exclusiveLockAcquisition=threadB.execute(state -> {
      client2.acquireExclusive(LockTracer.NONE,ResourceTypes.NODE,1);
      return true;
    }
);
    assertThat(threadB,isWaiting());
    clock.forward(101,TimeUnit.MILLISECONDS);
    verifyAcquisitionFailure(exclusiveLockAcquisition);
  }
  @Test public void terminateExclusiveLockAcquisitionForSharedLockedResourceWithSharedLockHeld() throws InterruptedException {
    client.acquireShared(LockTracer.NONE,ResourceTypes.NODE,1);
    client2.acquireShared(LockTracer.NONE,ResourceTypes.NODE,1);
    Future<Boolean> exclusiveLockAcquisition=threadB.execute(state -> {
      client2.acquireExclusive(LockTracer.NONE,ResourceTypes.NODE,1);
      return true;
    }
);
    assertThat(threadB,isWaiting());
    clock.forward(101,TimeUnit.MILLISECONDS);
    verifyAcquisitionFailure(exclusiveLockAcquisition);
  }
  private void verifyAcquisitionFailure(  Future<Boolean> lockAcquisition) throws InterruptedException {
    try {
      lockAcquisition.get();
      fail("Lock acquisition should fail.");
    }
 catch (    ExecutionException e) {
      assertThat(Exceptions.rootCause(e),instanceOf(LockAcquisitionTimeoutException.class));
    }
  }
}
