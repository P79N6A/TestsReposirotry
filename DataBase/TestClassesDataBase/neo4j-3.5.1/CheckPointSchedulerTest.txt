public class CheckPointSchedulerTest {
  private final IOLimiter ioLimiter=mock(IOLimiter.class);
  private final CheckPointer checkPointer=mock(CheckPointer.class);
  private final OnDemandJobScheduler jobScheduler=spy(new OnDemandJobScheduler());
  private final DatabaseHealth health=mock(DatabaseHealth.class);
  private static ExecutorService executor;
  @BeforeClass public static void setUpExecutor(){
    executor=Executors.newCachedThreadPool();
  }
  @AfterClass public static void tearDownExecutor() throws InterruptedException {
    executor.shutdown();
    executor.awaitTermination(30,TimeUnit.SECONDS);
  }
  @Test public void shouldScheduleTheCheckPointerJobOnStart(){
    CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,20L,health);
    assertNull(jobScheduler.getJob());
    scheduler.start();
    assertNotNull(jobScheduler.getJob());
    verify(jobScheduler,times(1)).schedule(eq(Group.CHECKPOINT),any(Runnable.class),eq(20L),eq(TimeUnit.MILLISECONDS));
  }
  @Test public void shouldRescheduleTheJobAfterARun() throws Throwable {
    CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,20L,health);
    assertNull(jobScheduler.getJob());
    scheduler.start();
    Runnable scheduledJob=jobScheduler.getJob();
    assertNotNull(scheduledJob);
    jobScheduler.runJob();
    verify(jobScheduler,times(2)).schedule(eq(Group.CHECKPOINT),any(Runnable.class),eq(20L),eq(TimeUnit.MILLISECONDS));
    verify(checkPointer,times(1)).checkPointIfNeeded(any(TriggerInfo.class));
    assertEquals(scheduledJob,jobScheduler.getJob());
  }
  @Test public void shouldNotRescheduleAJobWhenStopped(){
    CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,20L,health);
    assertNull(jobScheduler.getJob());
    scheduler.start();
    assertNotNull(jobScheduler.getJob());
    scheduler.stop();
    assertNull(jobScheduler.getJob());
  }
  @Test public void stoppedJobCantBeInvoked() throws Throwable {
    CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,10L,health);
    scheduler.start();
    jobScheduler.runJob();
    verify(checkPointer).checkPointIfNeeded(any(TriggerInfo.class));
    scheduler.stop();
    scheduler.start();
    jobScheduler.runJob();
    verifyNoMoreInteractions(checkPointer);
  }
  @Test(timeout=60_000) public void shouldWaitOnStopUntilTheRunningCheckpointIsDone() throws Throwable {
    final AtomicReference<Throwable> ex=new AtomicReference<>();
    final AtomicBoolean stoppedCompleted=new AtomicBoolean();
    final DoubleLatch checkPointerLatch=new DoubleLatch(1);
    OtherThreadExecutor<Void> otherThreadExecutor=new OtherThreadExecutor<>("scheduler stopper",null);
    CheckPointer checkPointer=new CheckPointer(){
      @Override public long checkPointIfNeeded(      TriggerInfo triggerInfo){
        checkPointerLatch.startAndWaitForAllToStart();
        checkPointerLatch.waitForAllToFinish();
        return 42;
      }
      @Override public long tryCheckPoint(      TriggerInfo triggerInfo){
        throw new RuntimeException("this should have not been called");
      }
      @Override public long forceCheckPoint(      TriggerInfo triggerInfo){
        throw new RuntimeException("this should have not been called");
      }
      @Override public long lastCheckPointedTransactionId(){
        return 42;
      }
    }
;
    final CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,20L,health);
    scheduler.start();
    Thread runCheckPointer=new Thread(jobScheduler::runJob);
    runCheckPointer.start();
    checkPointerLatch.waitForAllToStart();
    otherThreadExecutor.executeDontWait((WorkerCommand<Void,Void>)state -> {
      try {
        scheduler.stop();
        stoppedCompleted.set(true);
      }
 catch (      Throwable throwable) {
        ex.set(throwable);
      }
      return null;
    }
);
    otherThreadExecutor.waitUntilWaiting(details -> details.isAt(CheckPointScheduler.class,"waitOngoingCheckpointCompletion"));
    assertFalse(stoppedCompleted.get());
    checkPointerLatch.finish();
    runCheckPointer.join();
    while (!stoppedCompleted.get()) {
      Thread.sleep(1);
    }
    otherThreadExecutor.close();
    assertNull(ex.get());
  }
  @Test public void shouldContinueThroughSporadicFailures(){
    ControlledCheckPointer checkPointer=new ControlledCheckPointer();
    CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,1,health);
    scheduler.start();
    for (int i=0; i < CheckPointScheduler.MAX_CONSECUTIVE_FAILURES_TOLERANCE * 2; i++) {
      checkPointer.fail=true;
      jobScheduler.runJob();
      verifyZeroInteractions(health);
      checkPointer.fail=false;
      jobScheduler.runJob();
      verifyZeroInteractions(health);
    }
  }
  @Test(timeout=10_000) public void checkpointOnStopShouldFlushAsFastAsPossible() throws Throwable {
    CheckableIOLimiter ioLimiter=new CheckableIOLimiter();
    CountDownLatch checkPointerLatch=new CountDownLatch(1);
    WaitUnlimitedCheckPointer checkPointer=new WaitUnlimitedCheckPointer(ioLimiter,checkPointerLatch);
    CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,0L,health);
    scheduler.start();
    Future<?> checkpointerStarter=executor.submit(jobScheduler::runJob);
    checkPointerLatch.await();
    scheduler.stop();
    checkpointerStarter.get();
    assertTrue("Checkpointer should be created.",checkPointer.isCheckpointCreated());
    assertTrue("Limiter should be enabled in the end.",ioLimiter.isLimited());
  }
  @Test public void shouldCausePanicAfterSomeFailures() throws Throwable {
    RuntimeException[] failures=new RuntimeException[]{new RuntimeException("First"),new RuntimeException("Second"),new RuntimeException("Third")};
    when(checkPointer.checkPointIfNeeded(any(TriggerInfo.class))).thenThrow(failures);
    CheckPointScheduler scheduler=new CheckPointScheduler(checkPointer,ioLimiter,jobScheduler,1,health);
    scheduler.start();
    for (int i=0; i < CheckPointScheduler.MAX_CONSECUTIVE_FAILURES_TOLERANCE - 1; i++) {
      jobScheduler.runJob();
      verifyZeroInteractions(health);
    }
    try {
      jobScheduler.runJob();
      fail("Should have failed");
    }
 catch (    UnderlyingStorageException e) {
      assertEquals(Iterators.asSet(failures),Iterators.asSet(e.getSuppressed()));
      verify(health).panic(e);
    }
  }
private static class ControlledCheckPointer implements CheckPointer {
    volatile boolean fail;
    @Override public long checkPointIfNeeded(    TriggerInfo triggerInfo) throws IOException {
      if (fail) {
        throw new IOException("Just failing");
      }
      return 1;
    }
    @Override public long tryCheckPoint(    TriggerInfo triggerInfo){
      throw new UnsupportedOperationException();
    }
    @Override public long forceCheckPoint(    TriggerInfo triggerInfo){
      throw new UnsupportedOperationException();
    }
    @Override public long lastCheckPointedTransactionId(){
      throw new UnsupportedOperationException();
    }
  }
private static class CheckableIOLimiter implements IOLimiter {
    private volatile boolean limitEnabled;
    @Override public long maybeLimitIO(    long previousStamp,    int recentlyCompletedIOs,    Flushable flushable){
      return 0;
    }
    @Override public void disableLimit(){
      limitEnabled=false;
    }
    @Override public void enableLimit(){
      limitEnabled=true;
    }
    @Override public boolean isLimited(){
      return limitEnabled;
    }
  }
private static class WaitUnlimitedCheckPointer implements CheckPointer {
    private final CheckableIOLimiter ioLimiter;
    private final CountDownLatch latch;
    private volatile boolean checkpointCreated;
    WaitUnlimitedCheckPointer(    CheckableIOLimiter ioLimiter,    CountDownLatch latch){
      this.ioLimiter=ioLimiter;
      this.latch=latch;
      checkpointCreated=false;
    }
    @Override public long checkPointIfNeeded(    TriggerInfo triggerInfo){
      latch.countDown();
      while (ioLimiter.isLimited()) {
      }
      checkpointCreated=true;
      return 42;
    }
    @Override public long tryCheckPoint(    TriggerInfo triggerInfo){
      throw new UnsupportedOperationException("This should have not been called");
    }
    @Override public long forceCheckPoint(    TriggerInfo triggerInfo){
      throw new UnsupportedOperationException("This should have not been called");
    }
    @Override public long lastCheckPointedTransactionId(){
      return 0;
    }
    boolean isCheckpointCreated(){
      return checkpointCreated;
    }
  }
}
