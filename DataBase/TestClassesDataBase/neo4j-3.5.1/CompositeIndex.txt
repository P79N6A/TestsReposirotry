@Nested class CompositeIndex {
  private final IndexDescriptor compositeIndex=TestIndexDescriptorFactory.forLabel(1,1,2);
  @Test void shouldSeekOnAnEmptyTxState(){
    final ReadableTransactionState state=Mockito.mock(ReadableTransactionState.class);
    AddedAndRemoved changes=indexUpdatesForSeek(state,compositeIndex,ValueTuple.of("43value1","43value2"));
    assertTrue(changes.isEmpty());
  }
  @Test void shouldScanWhenThereAreNewNodes(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(42L,"42value1","42value2").withAdded(43L,"43value1","43value2").build();
    AddedAndRemoved changes=indexUpdatesForScan(state,compositeIndex,IndexOrder.NONE);
    AddedWithValuesAndRemoved changesWithValues=indexUpdatesWithValuesForScan(state,compositeIndex,IndexOrder.NONE);
    assertContains(changes.getAdded(),42L,43L);
    assertContains(changesWithValues.getAdded(),nodeWithPropertyValues(42L,"42value1","42value2"),nodeWithPropertyValues(43L,"43value1","43value2"));
  }
  @Test void shouldSeekWhenThereAreNewStringNodes(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(42L,"42value1","42value2").withAdded(43L,"43value1","43value2").build();
    AddedAndRemoved changes=indexUpdatesForSeek(state,compositeIndex,ValueTuple.of("43value1","43value2"));
    assertContains(changes.getAdded(),43L);
  }
  @Test void shouldSeekWhenThereAreNewNumberNodes(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(42L,42001.0,42002.0).withAdded(43L,43001.0,43002.0).build();
    AddedAndRemoved changes=indexUpdatesForSeek(state,compositeIndex,ValueTuple.of(43001.0,43002.0));
    assertContains(changes.getAdded(),43L);
  }
  @Test void shouldHandleMixedAddsAndRemovesEntry(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(42L,"42value1","42value2").withAdded(43L,"43value1","43value2").withRemoved(43L,"43value1","43value2").withRemoved(44L,"44value1","44value2").build();
    AddedAndRemoved changes=indexUpdatesForScan(state,compositeIndex,IndexOrder.NONE);
    AddedWithValuesAndRemoved changesWithValues=indexUpdatesWithValuesForScan(state,compositeIndex,IndexOrder.NONE);
    assertContains(changes.getAdded(),42L);
    assertContains(changesWithValues.getAdded(),nodeWithPropertyValues(42L,"42value1","42value2"));
    assertContains(changes.getRemoved(),44L);
    assertContains(changesWithValues.getRemoved(),44L);
  }
  @Test void shouldSeekWhenThereAreManyEntriesWithTheSameValues(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(42L,"42value1","42value2").withAdded(43L,"43value1","43value2").withAdded(44L,"43value1","43value2").build();
    AddedAndRemoved changes=indexUpdatesForSeek(state,compositeIndex,ValueTuple.of("43value1","43value2"));
    assertContains(changes.getAdded(),43L,44L);
  }
  @Test void shouldSeekInComplexMix(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(10L,"hi",3).withAdded(11L,9L,33L).withAdded(12L,"sneaker",false).withAdded(13L,new int[]{10,100},"array-buddy").withAdded(14L,40.1,40.2).build();
    assertContains(indexUpdatesForSeek(state,compositeIndex,ValueTuple.of("hi",3)).getAdded(),10L);
    assertContains(indexUpdatesForSeek(state,compositeIndex,ValueTuple.of(9L,33L)).getAdded(),11L);
    assertContains(indexUpdatesForSeek(state,compositeIndex,ValueTuple.of("sneaker",false)).getAdded(),12L);
    assertContains(indexUpdatesForSeek(state,compositeIndex,ValueTuple.of(new int[]{10,100},"array-buddy")).getAdded(),13L);
    assertContains(indexUpdatesForSeek(state,compositeIndex,ValueTuple.of(40.1,40.2)).getAdded(),14L);
  }
}
