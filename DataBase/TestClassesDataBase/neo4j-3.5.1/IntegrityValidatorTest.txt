public class IntegrityValidatorTest {
  @Test public void shouldValidateUniquenessIndexes() throws Exception {
    NeoStores store=mock(NeoStores.class);
    IndexingService indexes=mock(IndexingService.class);
    IntegrityValidator validator=new IntegrityValidator(store,indexes);
    UniquenessConstraintDescriptor constraint=ConstraintDescriptorFactory.uniqueForLabel(1,1);
    doThrow(new UniquePropertyValueValidationException(constraint,ConstraintValidationException.Phase.VERIFICATION,new RuntimeException())).when(indexes).validateIndex(2L);
    ConstraintRule record=ConstraintRule.constraintRule(1L,constraint,2L);
    try {
      validator.validateSchemaRule(record);
      fail("Should have thrown integrity error.");
    }
 catch (    Exception e) {
    }
  }
  @Test public void deletingNodeWithRelationshipsIsNotAllowed(){
    NeoStores store=mock(NeoStores.class);
    IndexingService indexes=mock(IndexingService.class);
    IntegrityValidator validator=new IntegrityValidator(store,indexes);
    NodeRecord record=new NodeRecord(1L,false,1L,-1L);
    record.setInUse(false);
    try {
      validator.validateNodeRecord(record);
      fail("Should have thrown integrity error.");
    }
 catch (    Exception e) {
    }
  }
  @Test public void transactionsStartedBeforeAConstraintWasCreatedAreDisallowed(){
    NeoStores store=mock(NeoStores.class);
    MetaDataStore metaDataStore=mock(MetaDataStore.class);
    when(store.getMetaDataStore()).thenReturn(metaDataStore);
    IndexingService indexes=mock(IndexingService.class);
    when(metaDataStore.getLatestConstraintIntroducingTx()).thenReturn(10L);
    IntegrityValidator validator=new IntegrityValidator(store,indexes);
    try {
      validator.validateTransactionStartKnowledge(1);
      fail("Should have thrown integrity error.");
    }
 catch (    Exception e) {
    }
  }
}
