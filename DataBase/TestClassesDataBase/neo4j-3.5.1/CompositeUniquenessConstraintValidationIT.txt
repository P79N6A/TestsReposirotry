@RunWith(Parameterized.class) public class CompositeUniquenessConstraintValidationIT {
  @ClassRule public static ImpermanentDatabaseRule dbRule=new ImpermanentDatabaseRule();
  @Rule public final TestName testName=new TestName();
  private final int numberOfProps;
  private final Object[] aValues;
  private final Object[] bValues;
  @Parameterized.Parameters(name="{index}: {0}") public static Iterable<TestParams> parameterValues(){
    return Arrays.asList(param(values(10),values(10d)),param(values(10,20),values(10,20)),param(values(10L,20L),values(10,20)),param(values(10,20),values(10L,20L)),param(values(10,20),values(10.0,20.0)),param(values(10,20),values(10.0,20.0)),param(values(new int[]{1,2},"v2"),values(new int[]{1,2},"v2")),param(values("a","b","c"),values("a","b","c")),param(values(285414114323346805L),values(285414114323346805L)),param(values(1,2,3,4,5,6,7,8,9,10),values(1d,2d,3d,4d,5d,6d,7d,8d,9d,10d)));
  }
  private static TestParams param(  Object[] l,  Object[] r){
    return new TestParams(l,r);
  }
  private static Object[] values(  Object... values){
    return values;
  }
  private static final int label=1;
  public CompositeUniquenessConstraintValidationIT(  TestParams params){
    assert params.lhs.length == params.rhs.length;
    aValues=params.lhs;
    bValues=params.rhs;
    numberOfProps=aValues.length;
  }
  private Transaction transaction;
  private GraphDatabaseAPI graphDatabaseAPI;
  protected Kernel kernel;
  @Before public void setup() throws Exception {
    graphDatabaseAPI=dbRule.getGraphDatabaseAPI();
    kernel=graphDatabaseAPI.getDependencyResolver().resolveDependency(Kernel.class);
    newTransaction();
    transaction.schemaWrite().uniquePropertyConstraintCreate(forLabel(label,propertyIds()));
    commit();
  }
  @After public void clean() throws Exception {
    if (transaction != null) {
      transaction.close();
    }
    newTransaction();
    transaction.schemaWrite().constraintDrop(ConstraintDescriptorFactory.uniqueForLabel(label,propertyIds()));
    commit();
    try (Transaction tx=kernel.beginTransaction(Transaction.Type.implicit,LoginContext.AUTH_DISABLED);NodeCursor node=tx.cursors().allocateNodeCursor()){
      tx.dataRead().allNodesScan(node);
      while (node.next()) {
        tx.dataWrite().nodeDelete(node.nodeReference());
      }
      tx.success();
    }
   }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_DeleteNode() throws Exception {
    long node=createNodeWithLabelAndProps(label,aValues);
    newTransaction();
    transaction.dataWrite().nodeDelete(node);
    long newNode=createLabeledNode(label);
    setProperties(newNode,aValues);
    commit();
  }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveLabel() throws Exception {
    long node=createNodeWithLabelAndProps(label,aValues);
    newTransaction();
    transaction.dataWrite().nodeRemoveLabel(node,label);
    long newNode=createLabeledNode(label);
    setProperties(newNode,aValues);
    commit();
  }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_RemoveProperty() throws Exception {
    long node=createNodeWithLabelAndProps(label,aValues);
    newTransaction();
    transaction.dataWrite().nodeRemoveProperty(node,0);
    long newNode=createLabeledNode(label);
    setProperties(newNode,aValues);
    commit();
  }
  @Test public void shouldAllowRemoveAndAddConflictingDataInOneTransaction_ChangeProperty() throws Exception {
    long node=createNodeWithLabelAndProps(label,aValues);
    newTransaction();
    transaction.dataWrite().nodeSetProperty(node,0,Values.of("Alive!"));
    long newNode=createLabeledNode(label);
    setProperties(newNode,aValues);
    commit();
  }
  @Test public void shouldPreventConflictingDataInTx() throws Throwable {
    newTransaction();
    long n1=createLabeledNode(label);
    long n2=createLabeledNode(label);
    setProperties(n1,aValues);
    int lastPropertyOffset=numberOfProps - 1;
    for (int prop=0; prop < lastPropertyOffset; prop++) {
      setProperty(n2,prop,aValues[prop]);
    }
    assertException(() -> {
      setProperty(n2,lastPropertyOffset,aValues[lastPropertyOffset]);
    }
,UniquePropertyValueValidationException.class);
    commit();
  }
  @Test public void shouldEnforceOnSetProperty() throws Exception {
    createNodeWithLabelAndProps(label,this.aValues);
    newTransaction();
    long node=createLabeledNode(label);
    int lastPropertyOffset=numberOfProps - 1;
    for (int prop=0; prop < lastPropertyOffset; prop++) {
      setProperty(node,prop,aValues[prop]);
    }
    assertException(() -> {
      setProperty(node,lastPropertyOffset,aValues[lastPropertyOffset]);
    }
,UniquePropertyValueValidationException.class);
    commit();
  }
  @Test public void shouldEnforceOnSetLabel() throws Exception {
    createNodeWithLabelAndProps(label,this.aValues);
    newTransaction();
    long node=createNode();
    setProperties(node,bValues);
    assertException(() -> {
      addLabel(node,label);
    }
,UniquePropertyValueValidationException.class);
    commit();
  }
  @Test public void shouldEnforceOnSetPropertyInTx() throws Exception {
    newTransaction();
    long aNode=createLabeledNode(label);
    setProperties(aNode,aValues);
    long nodeB=createLabeledNode(label);
    int lastPropertyOffset=numberOfProps - 1;
    for (int prop=0; prop < lastPropertyOffset; prop++) {
      setProperty(nodeB,prop,bValues[prop]);
    }
    assertException(() -> {
      setProperty(nodeB,lastPropertyOffset,bValues[lastPropertyOffset]);
    }
,UniquePropertyValueValidationException.class);
    commit();
  }
  @Test public void shouldEnforceOnSetLabelInTx() throws Exception {
    createNodeWithLabelAndProps(label,aValues);
    newTransaction();
    long nodeB=createNode();
    setProperties(nodeB,bValues);
    assertException(() -> {
      addLabel(nodeB,label);
    }
,UniquePropertyValueValidationException.class);
    commit();
  }
  private void newTransaction() throws KernelException {
    if (transaction != null) {
      fail("tx already opened");
    }
    transaction=kernel.beginTransaction(KernelTransaction.Type.implicit,LoginContext.AUTH_DISABLED);
  }
  protected void commit() throws TransactionFailureException {
    transaction.success();
    try {
      transaction.close();
    }
  finally {
      transaction=null;
    }
  }
  private long createLabeledNode(  int labelId) throws KernelException {
    long node=transaction.dataWrite().nodeCreate();
    transaction.dataWrite().nodeAddLabel(node,labelId);
    return node;
  }
  private void addLabel(  long nodeId,  int labelId) throws KernelException {
    transaction.dataWrite().nodeAddLabel(nodeId,labelId);
  }
  private void setProperty(  long nodeId,  int propertyId,  Object value) throws KernelException {
    transaction.dataWrite().nodeSetProperty(nodeId,propertyId,Values.of(value));
  }
  private long createNode() throws KernelException {
    return transaction.dataWrite().nodeCreate();
  }
  private long createNodeWithLabelAndProps(  int labelId,  Object[] propertyValues) throws KernelException {
    newTransaction();
    long nodeId=createNode();
    addLabel(nodeId,labelId);
    for (int prop=0; prop < numberOfProps; prop++) {
      setProperty(nodeId,prop,propertyValues[prop]);
    }
    commit();
    return nodeId;
  }
  private void setProperties(  long nodeId,  Object[] propertyValues) throws KernelException {
    for (int prop=0; prop < propertyValues.length; prop++) {
      setProperty(nodeId,prop,propertyValues[prop]);
    }
  }
  private int[] propertyIds(){
    int[] props=new int[numberOfProps];
    for (int i=0; i < numberOfProps; i++) {
      props[i]=i;
    }
    return props;
  }
static class TestParams {
    private final Object[] lhs;
    private final Object[] rhs;
    TestParams(    Object[] lhs,    Object[] rhs){
      this.lhs=lhs;
      this.rhs=rhs;
    }
    @Override public String toString(){
      return String.format("lhs=%s, rhs=%s",ArrayUtils.toString(lhs),ArrayUtils.toString(rhs));
    }
  }
}
