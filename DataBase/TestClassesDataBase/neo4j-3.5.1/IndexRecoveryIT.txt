public class IndexRecoveryIT {
  @Test public void shouldBeAbleToRecoverInTheMiddleOfPopulatingAnIndex() throws Exception {
    startDb();
    CountDownLatch latch=new CountDownLatch(1);
    when(mockedIndexProvider.getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(indexPopulatorWithControlledCompletionTiming(latch));
    createIndex(myLabel);
    Future<Void> killFuture=killDbInSeparateThread();
    latch.countDown();
    killFuture.get();
    when(mockedIndexProvider.getInitialState(any(StoreIndexDescriptor.class))).thenReturn(InternalIndexState.POPULATING);
    latch=new CountDownLatch(1);
    when(mockedIndexProvider.getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(indexPopulatorWithControlledCompletionTiming(latch));
    startDb();
    assertThat(getIndexes(db,myLabel),inTx(db,hasSize(1)));
    assertThat(getIndexes(db,myLabel),inTx(db,haveState(db,Schema.IndexState.POPULATING)));
    verify(mockedIndexProvider,times(2)).getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class));
    verify(mockedIndexProvider,never()).getOnlineAccessor(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class));
    latch.countDown();
  }
  @Test public void shouldBeAbleToRecoverInTheMiddleOfPopulatingAnIndexWhereLogHasRotated() throws Exception {
    startDb();
    CountDownLatch latch=new CountDownLatch(1);
    when(mockedIndexProvider.getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(indexPopulatorWithControlledCompletionTiming(latch));
    createIndex(myLabel);
    rotateLogsAndCheckPoint();
    Future<Void> killFuture=killDbInSeparateThread();
    latch.countDown();
    killFuture.get();
    latch=new CountDownLatch(1);
    when(mockedIndexProvider.getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(indexPopulatorWithControlledCompletionTiming(latch));
    when(mockedIndexProvider.getInitialState(any(StoreIndexDescriptor.class))).thenReturn(InternalIndexState.POPULATING);
    startDb();
    assertThat(getIndexes(db,myLabel),inTx(db,hasSize(1)));
    assertThat(getIndexes(db,myLabel),inTx(db,haveState(db,Schema.IndexState.POPULATING)));
    verify(mockedIndexProvider,times(2)).getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class));
    verify(mockedIndexProvider,never()).getOnlineAccessor(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class));
    latch.countDown();
  }
  @Test public void shouldBeAbleToRecoverAndUpdateOnlineIndex() throws Exception {
    startDb();
    IndexPopulator populator=mock(IndexPopulator.class);
    when(mockedIndexProvider.getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(populator);
    when(populator.sampleResult()).thenReturn(new IndexSample());
    IndexAccessor mockedAccessor=mock(IndexAccessor.class);
    when(mockedAccessor.newUpdater(any(IndexUpdateMode.class))).thenReturn(SwallowingIndexUpdater.INSTANCE);
    when(mockedIndexProvider.getOnlineAccessor(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(mockedAccessor);
    createIndexAndAwaitPopulation(myLabel);
    rotateLogsAndCheckPoint();
    Set<IndexEntryUpdate<?>> expectedUpdates=createSomeBananas(myLabel);
    killDb();
    when(mockedIndexProvider.getInitialState(any(StoreIndexDescriptor.class))).thenReturn(InternalIndexState.ONLINE);
    GatheringIndexWriter writer=new GatheringIndexWriter();
    when(mockedIndexProvider.getOnlineAccessor(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(writer);
    startDb();
    assertThat(getIndexes(db,myLabel),inTx(db,hasSize(1)));
    assertThat(getIndexes(db,myLabel),inTx(db,haveState(db,Schema.IndexState.ONLINE)));
    verify(mockedIndexProvider,times(1)).getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class));
    int onlineAccessorInvocationCount=2;
    verify(mockedIndexProvider,times(onlineAccessorInvocationCount)).getOnlineAccessor(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class));
    assertEquals(expectedUpdates,writer.batchedUpdates);
  }
  @Test public void shouldKeepFailedIndexesAsFailedAfterRestart() throws Exception {
    IndexPopulator indexPopulator=mock(IndexPopulator.class);
    when(mockedIndexProvider.getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(indexPopulator);
    IndexAccessor indexAccessor=mock(IndexAccessor.class);
    when(mockedIndexProvider.getOnlineAccessor(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class))).thenReturn(indexAccessor);
    startDb();
    createIndex(myLabel);
    rotateLogsAndCheckPoint();
    killDb();
    when(mockedIndexProvider.getInitialState(any(StoreIndexDescriptor.class))).thenReturn(InternalIndexState.FAILED);
    startDb();
    assertThat(getIndexes(db,myLabel),inTx(db,hasSize(1)));
    assertThat(getIndexes(db,myLabel),inTx(db,haveState(db,Schema.IndexState.FAILED)));
    verify(mockedIndexProvider,times(2)).getPopulator(any(StoreIndexDescriptor.class),any(IndexSamplingConfig.class));
  }
  private GraphDatabaseAPI db;
  @Rule public EphemeralFileSystemRule fs=new EphemeralFileSystemRule();
  private final IndexProvider mockedIndexProvider=mock(IndexProvider.class);
  private final KernelExtensionFactory<?> mockedIndexProviderFactory=singleInstanceIndexProviderFactory(PROVIDER_DESCRIPTOR.getKey(),mockedIndexProvider);
  private final String key="number_of_bananas_owned";
  private final Label myLabel=label("MyLabel");
  @Before public void setUp(){
    when(mockedIndexProvider.getProviderDescriptor()).thenReturn(PROVIDER_DESCRIPTOR);
    when(mockedIndexProvider.storeMigrationParticipant(any(FileSystemAbstraction.class),any(PageCache.class))).thenReturn(StoreMigrationParticipant.NOT_PARTICIPATING);
  }
  private void startDb(){
    if (db != null) {
      db.shutdown();
    }
    TestGraphDatabaseFactory factory=new TestGraphDatabaseFactory();
    factory.setFileSystem(fs.get());
    factory.setKernelExtensions(Arrays.asList(mockedIndexProviderFactory));
    db=(GraphDatabaseAPI)factory.newImpermanentDatabaseBuilder().setConfig(GraphDatabaseSettings.default_schema_provider,PROVIDER_DESCRIPTOR.name()).newGraphDatabase();
  }
  private void killDb() throws Exception {
    if (db != null) {
      fs.snapshot(() -> {
        db.shutdown();
        db=null;
      }
);
    }
  }
  private Future<Void> killDbInSeparateThread(){
    ExecutorService executor=newSingleThreadExecutor();
    Future<Void> result=executor.submit(() -> {
      killDb();
      return null;
    }
);
    executor.shutdown();
    return result;
  }
  @After public void after(){
    if (db != null) {
      db.shutdown();
    }
  }
  private void rotateLogsAndCheckPoint() throws IOException {
    db.getDependencyResolver().resolveDependency(LogRotation.class).rotateLogFile();
    db.getDependencyResolver().resolveDependency(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("test"));
  }
  private void createIndexAndAwaitPopulation(  Label label){
    IndexDefinition index=createIndex(label);
    try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexOnline(index,10,SECONDS);
      tx.success();
    }
   }
  private IndexDefinition createIndex(  Label label){
    try (Transaction tx=db.beginTx()){
      IndexDefinition index=db.schema().indexFor(label).on(key).create();
      tx.success();
      return index;
    }
   }
  private Set<IndexEntryUpdate<?>> createSomeBananas(  Label label){
    Set<IndexEntryUpdate<?>> updates=new HashSet<>();
    try (Transaction tx=db.beginTx()){
      ThreadToStatementContextBridge ctxSupplier=db.getDependencyResolver().resolveDependency(ThreadToStatementContextBridge.class);
      KernelTransaction ktx=ctxSupplier.getKernelTransactionBoundToThisThread(true);
      int labelId=ktx.tokenRead().nodeLabel(label.name());
      int propertyKeyId=ktx.tokenRead().propertyKey(key);
      LabelSchemaDescriptor schemaDescriptor=SchemaDescriptorFactory.forLabel(labelId,propertyKeyId);
      for (      int number : new int[]{4,10}) {
        Node node=db.createNode(label);
        node.setProperty(key,number);
        updates.add(IndexEntryUpdate.add(node.getId(),schemaDescriptor,Values.of(number)));
      }
      tx.success();
      return updates;
    }
   }
public static class GatheringIndexWriter extends IndexAccessor.Adapter {
    private final Set<IndexEntryUpdate<?>> regularUpdates=new HashSet<>();
    private final Set<IndexEntryUpdate<?>> batchedUpdates=new HashSet<>();
    @Override public IndexUpdater newUpdater(    final IndexUpdateMode mode){
      return new CollectingIndexUpdater(updates -> {
switch (mode) {
case ONLINE:
          regularUpdates.addAll(updates);
        break;
case RECOVERY:
      batchedUpdates.addAll(updates);
    break;
default :
  throw new UnsupportedOperationException();
}
}
);
}
}
private static IndexPopulator indexPopulatorWithControlledCompletionTiming(final CountDownLatch latch){
return new IndexPopulator.Adapter(){
@Override public void create(){
try {
latch.await();
}
 catch (InterruptedException e) {
}
throw new RuntimeException("this is expected");
}
}
;
}
}
