public class KernelStatementTest {
  @Test public void shouldReleaseStorageReaderWhenForceClosed(){
    StorageReader storeStatement=mock(StorageReader.class);
    KernelStatement statement=new KernelStatement(mock(KernelTransactionImplementation.class),null,storeStatement,LockTracer.NONE,mock(StatementOperationParts.class),new ClockContext(),EmptyVersionContextSupplier.EMPTY);
    statement.acquire();
    try {
      statement.forceClose();
    }
 catch (    KernelStatement.StatementNotClosedException ignored) {
    }
    verify(storeStatement).release();
  }
  @Test(expected=NotInTransactionException.class) public void assertStatementIsNotOpenWhileAcquireIsNotInvoked(){
    KernelTransactionImplementation transaction=mock(KernelTransactionImplementation.class);
    TxStateHolder txStateHolder=mock(TxStateHolder.class);
    StorageReader storeStatement=mock(StorageReader.class);
    KernelStatement statement=new KernelStatement(transaction,txStateHolder,storeStatement,LockTracer.NONE,mock(StatementOperationParts.class),new ClockContext(),EmptyVersionContextSupplier.EMPTY);
    statement.assertOpen();
  }
  @Test public void reportQueryWaitingTimeToTransactionStatisticWhenFinishQueryExecution(){
    KernelTransactionImplementation transaction=mock(KernelTransactionImplementation.class);
    TxStateHolder txStateHolder=mock(TxStateHolder.class);
    StorageReader storeStatement=mock(StorageReader.class);
    KernelTransactionImplementation.Statistics statistics=new KernelTransactionImplementation.Statistics(transaction,new AtomicReference<>(CpuClock.NOT_AVAILABLE),new AtomicReference<>(HeapAllocation.NOT_AVAILABLE));
    when(transaction.getStatistics()).thenReturn(statistics);
    when(transaction.executingQueries()).thenReturn(ExecutingQueryList.EMPTY);
    KernelStatement statement=new KernelStatement(transaction,txStateHolder,storeStatement,LockTracer.NONE,mock(StatementOperationParts.class),new ClockContext(),EmptyVersionContextSupplier.EMPTY);
    statement.acquire();
    ExecutingQuery query=getQueryWithWaitingTime();
    ExecutingQuery query2=getQueryWithWaitingTime();
    ExecutingQuery query3=getQueryWithWaitingTime();
    statement.stopQueryExecution(query);
    statement.stopQueryExecution(query2);
    statement.stopQueryExecution(query3);
    assertEquals(3,statistics.getWaitingTimeNanos(1));
  }
  private ExecutingQuery getQueryWithWaitingTime(){
    ExecutingQuery executingQuery=mock(ExecutingQuery.class);
    when(executingQuery.reportedWaitingTimeNanos()).thenReturn(1L);
    return executingQuery;
  }
}
