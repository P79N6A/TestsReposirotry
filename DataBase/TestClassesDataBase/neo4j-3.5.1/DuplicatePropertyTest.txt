class DuplicatePropertyTest {
  @Test void shouldReportDuplicatePropertyIndexesInPropertyRecordForNode(){
    ChainCheck check=new ChainCheck();
    RecordAccessStub records=new RecordAccessStub();
    NodeRecord master=records.add(inUse(new NodeRecord(1,false,-1,1)));
    PropertyRecord propertyRecord=inUse(new PropertyRecord(1));
    PropertyBlock firstBlock=new PropertyBlock();
    firstBlock.setSingleBlock(1);
    firstBlock.setKeyIndexId(1);
    PropertyBlock secondBlock=new PropertyBlock();
    secondBlock.setSingleBlock(1);
    secondBlock.setKeyIndexId(2);
    PropertyBlock thirdBlock=new PropertyBlock();
    thirdBlock.setSingleBlock(1);
    thirdBlock.setKeyIndexId(1);
    propertyRecord.addPropertyBlock(firstBlock);
    propertyRecord.addPropertyBlock(secondBlock);
    propertyRecord.addPropertyBlock(thirdBlock);
    records.add(propertyRecord);
    ConsistencyReport.NodeConsistencyReport report=mock(ConsistencyReport.NodeConsistencyReport.class);
    CheckerEngine<NodeRecord,ConsistencyReport.NodeConsistencyReport> checkEngine=records.engine(master,report);
    check.checkReference(master,propertyRecord,checkEngine,records);
    verify(report).propertyKeyNotUniqueInChain();
  }
  @Test void shouldReportDuplicatePropertyIndexesAcrossRecordsInPropertyChainForNode(){
    ChainCheck check=new ChainCheck();
    RecordAccessStub records=new RecordAccessStub();
    RelationshipRecord master=records.add(inUse(new RelationshipRecord(1,2,3,4)));
    master.setNextProp(1);
    PropertyRecord firstRecord=inUse(new PropertyRecord(1));
    firstRecord.setNextProp(12);
    PropertyBlock firstBlock=new PropertyBlock();
    firstBlock.setSingleBlock(1);
    firstBlock.setKeyIndexId(1);
    PropertyBlock secondBlock=new PropertyBlock();
    secondBlock.setSingleBlock(1);
    secondBlock.setKeyIndexId(2);
    PropertyRecord secondRecord=inUse(new PropertyRecord(12));
    secondRecord.setPrevProp(1);
    PropertyBlock thirdBlock=new PropertyBlock();
    thirdBlock.setSingleBlock(1);
    thirdBlock.setKeyIndexId(4);
    PropertyBlock fourthBlock=new PropertyBlock();
    fourthBlock.setSingleBlock(1);
    fourthBlock.setKeyIndexId(1);
    firstRecord.addPropertyBlock(firstBlock);
    firstRecord.addPropertyBlock(secondBlock);
    secondRecord.addPropertyBlock(thirdBlock);
    secondRecord.addPropertyBlock(fourthBlock);
    records.add(firstRecord);
    records.add(secondRecord);
    ConsistencyReport.RelationshipConsistencyReport report=mock(ConsistencyReport.RelationshipConsistencyReport.class);
    CheckerEngine<RelationshipRecord,ConsistencyReport.RelationshipConsistencyReport> checkEngine=records.engine(master,report);
    check.checkReference(master,firstRecord,checkEngine,records);
    records.checkDeferred();
    verify(report).propertyKeyNotUniqueInChain();
  }
  @Test void shouldNotReportAnythingForConsistentChains(){
    ChainCheck check=new ChainCheck();
    RecordAccessStub records=new RecordAccessStub();
    RelationshipRecord master=records.add(inUse(new RelationshipRecord(1,2,3,4)));
    master.setNextProp(1);
    PropertyRecord firstRecord=inUse(new PropertyRecord(1));
    firstRecord.setNextProp(12);
    PropertyBlock firstBlock=new PropertyBlock();
    firstBlock.setSingleBlock(1);
    firstBlock.setKeyIndexId(1);
    PropertyBlock secondBlock=new PropertyBlock();
    secondBlock.setSingleBlock(1);
    secondBlock.setKeyIndexId(2);
    PropertyRecord secondRecord=inUse(new PropertyRecord(12));
    secondRecord.setPrevProp(1);
    PropertyBlock thirdBlock=new PropertyBlock();
    thirdBlock.setSingleBlock(1);
    thirdBlock.setKeyIndexId(4);
    PropertyBlock fourthBlock=new PropertyBlock();
    fourthBlock.setSingleBlock(11);
    fourthBlock.setKeyIndexId(11);
    firstRecord.addPropertyBlock(firstBlock);
    firstRecord.addPropertyBlock(secondBlock);
    secondRecord.addPropertyBlock(thirdBlock);
    secondRecord.addPropertyBlock(fourthBlock);
    records.add(firstRecord);
    records.add(secondRecord);
    ConsistencyReport.RelationshipConsistencyReport report=mock(ConsistencyReport.RelationshipConsistencyReport.class);
    CheckerEngine<RelationshipRecord,ConsistencyReport.RelationshipConsistencyReport> checkEngine=records.engine(master,report);
    check.checkReference(master,firstRecord,checkEngine,records);
    records.checkDeferred();
    verifyZeroInteractions(report);
  }
}
