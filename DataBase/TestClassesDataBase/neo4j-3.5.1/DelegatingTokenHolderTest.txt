public class DelegatingTokenHolderTest {
  private TokenCreator creator;
  private TokenHolder holder;
  @Before public void setUp() throws Exception {
    creator=mock(TokenCreator.class);
    holder=new DelegatingTokenHolder(creator,"Dummy");
  }
  @Test public void mustCreateAndCacheNewTokens() throws Exception {
    when(creator.createToken("token")).thenReturn(42);
    assertThat(holder.getOrCreateId("token"),is(42));
    assertThat(holder.getOrCreateId("token"),is(42));
    verify(creator).createToken("token");
    verifyNoMoreInteractions(creator);
  }
  @Test public void batchTokenGetMustReturnWhetherThereWereUnresolvedTokens(){
    holder.setInitialTokens(asList(token("a",1),token("b",2)));
    String[] names;
    int[] ids;
    names=new String[]{"a","X","b"};
    ids=new int[]{-1,-1,-1};
    assertTrue(holder.getIdsByNames(names,ids));
    assertThat(ids[0],is(1));
    assertThat(ids[1],is(-1));
    assertThat(ids[2],is(2));
    names=new String[]{"a","b"};
    ids=new int[]{-1,-1};
    assertFalse(holder.getIdsByNames(names,ids));
    assertThat(ids[0],is(1));
    assertThat(ids[1],is(2));
  }
  @Test public void batchTokenCreateMustIgnoreExistingTokens() throws Exception {
    initialTokensABC();
    AtomicInteger nextId=new AtomicInteger(42);
    mockAssignNewTokenIdsInBatch(nextId);
    String[] names=new String[]{"b","X","a","Y","c"};
    int[] ids=new int[names.length];
    holder.getOrCreateIds(names,ids);
    assertThat(ids.length,is(5));
    assertThat(ids[0],is(2));
    assertThat(ids[1],isOneOf(42,43));
    assertThat(ids[2],is(1));
    assertThat(ids[3],isOneOf(42,43));
    assertThat(ids[4],is(3));
    assertThat(nextId.get(),is(44));
    holder.getTokenById(42);
    holder.getTokenById(43);
  }
  private void mockAssignNewTokenIdsInBatch(  AtomicInteger nextId) throws KernelException {
    doAnswer(inv -> {
      int[] ids=inv.getArgument(1);
      IntPredicate filter=inv.getArgument(2);
      for (int i=0; i < ids.length; i++) {
        if (filter.test(i)) {
          ids[i]=nextId.getAndIncrement();
        }
      }
      return null;
    }
).when(creator).createTokens(any(String[].class),any(int[].class),any(IntPredicate.class));
  }
  private void initialTokensABC() throws KernelException {
    holder.setInitialTokens(asList(token("a",1),token("b",2)));
    when(creator.createToken("c")).thenReturn(3);
    assertThat(holder.getOrCreateId("c"),is(3));
  }
  @Test public void batchTokenCreateMustDeduplicateTokenCreates() throws Exception {
    initialTokensABC();
    AtomicInteger nextId=new AtomicInteger(42);
    mockAssignNewTokenIdsInBatch(nextId);
    String[] names=new String[]{"b","b","X","a","X","c"};
    int[] ids=new int[names.length];
    holder.getOrCreateIds(names,ids);
    assertThat(ids.length,is(6));
    assertThat(ids[0],is(2));
    assertThat(ids[1],is(2));
    assertThat(ids[2],is(42));
    assertThat(ids[3],is(1));
    assertThat(ids[4],is(42));
    assertThat(ids[5],is(3));
    assertThat(nextId.get(),is(43));
    holder.getTokenById(42);
  }
  @Test(expected=IllegalArgumentException.class) public void batchTokenCreateMustThrowOnArraysOfDifferentLengths(){
    holder.getOrCreateIds(new String[3],new int[2]);
  }
  @Test public void shouldClearTokensAsPartOfInitialTokenLoading(){
    holder.setInitialTokens(asList(token("one",1),token("two",2)));
    assertTokens(holder.getAllTokens(),token("one",1),token("two",2));
    holder.setInitialTokens(asList(token("two",2),token("three",3),token("four",4)));
    assertTokens(holder.getAllTokens(),token("two",2),token("three",3),token("four",4));
  }
  private void assertTokens(  Iterable<NamedToken> allTokens,  NamedToken... expectedTokens){
    Map<String,NamedToken> existing=new HashMap<>();
    for (    NamedToken token : allTokens) {
      existing.put(token.name(),token);
    }
    Map<String,NamedToken> expected=new HashMap<>();
    for (    NamedToken token : expectedTokens) {
      expected.put(token.name(),token);
    }
    assertEquals(expected,existing);
  }
  private NamedToken token(  String name,  int id){
    return new NamedToken(name,id);
  }
}
