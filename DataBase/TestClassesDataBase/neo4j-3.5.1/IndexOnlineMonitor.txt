private static class IndexOnlineMonitor extends IndexingService.MonitorAdapter {
  private CountDownLatch updateTrackerCompletionLatch;
  private final CountDownLatch startSignal=new CountDownLatch(1);
  private volatile boolean isOnline;
  private Barrier.Control barrier;
  void initialize(  int numberOfUpdateTrackers){
    updateTrackerCompletionLatch=new CountDownLatch(numberOfUpdateTrackers);
    if (numberOfUpdateTrackers > 0) {
      barrier=new Barrier.Control();
    }
  }
  void updatesDone(){
    updateTrackerCompletionLatch.countDown();
    try {
      updateTrackerCompletionLatch.await();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
    if (barrier != null) {
      barrier.reached();
    }
  }
  @Override public void indexPopulationScanStarting(){
    startSignal.countDown();
  }
  /** 
 * Index population is now completed, the populator hasn't yet been flipped and so sample hasn't been extracted. The IndexPopulationJob, who is calling this method will now wait for the UpdatesTracker to notice that the index is online so that it will complete whatever update it's doing and then snapshot its created/deleted values for later assertions. When the UpdatesTracker notices this it will trigger this thread to continue and eventually call populationCompleteOn below, completing the flip and the sampling. The barrier should prevent UpdatesTracker and IndexPopulationJob from racing in this area.
 */
  @Override public void indexPopulationScanComplete(){
    isOnline=true;
    if (barrier != null) {
      try {
        barrier.await();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
  }
  @Override public void populationCompleteOn(  StoreIndexDescriptor descriptor){
    if (barrier != null) {
      barrier.release();
    }
  }
  boolean isIndexOnline(){
    return isOnline;
  }
}
