public class ContextFieldVisitorTest {
  private static final org.assertj.core.groups.Tuple UNKNOWN_CONTEXT_ERROR_MSG=tuple(Diagnostic.Kind.ERROR,"@org.neo4j.procedure.Context usage error: found unknown type <java.lang.String> on field " + "UnknownContextType#unsupportedType, expected one of: <" + GraphDatabaseService.class.getName() + ">, <"+ Log.class.getName()+ ">, <"+ TerminationGuard.class.getName()+ ">, <"+ SecurityContext.class.getName()+ ">, <"+ ProcedureTransaction.class.getName()+ ">");
  @Rule public CompilationRule compilationRule=new CompilationRule();
  private ElementTestUtils elementTestUtils;
  private ElementVisitor<Stream<CompilationMessage>,Void> contextFieldVisitor;
  @Before public void prepare(){
    elementTestUtils=new ElementTestUtils(compilationRule);
    contextFieldVisitor=new ContextFieldVisitor(compilationRule.getTypes(),compilationRule.getElements(),false);
  }
  @Test public void rejects_non_public_context_fields(){
    Stream<VariableElement> fields=elementTestUtils.getFields(NonPublicContextMisuse.class);
    Stream<CompilationMessage> result=fields.flatMap(contextFieldVisitor::visit);
    assertThat(result).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).containsExactly(tuple(Diagnostic.Kind.ERROR,"@org.neo4j.procedure.Context usage error: field NonPublicContextMisuse#arithm should be public, " + "non-static and non-final"));
  }
  @Test public void rejects_static_context_fields(){
    Stream<VariableElement> fields=elementTestUtils.getFields(StaticContextMisuse.class);
    Stream<CompilationMessage> result=fields.flatMap(contextFieldVisitor::visit);
    assertThat(result).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).containsExactly(tuple(Diagnostic.Kind.ERROR,"@org.neo4j.procedure.Context usage error: field StaticContextMisuse#db should be public, non-static " + "and non-final"));
  }
  @Test public void rejects_final_context_fields(){
    Stream<VariableElement> fields=elementTestUtils.getFields(FinalContextMisuse.class);
    Stream<CompilationMessage> result=fields.flatMap(contextFieldVisitor::visit);
    assertThat(result).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).containsExactly(tuple(Diagnostic.Kind.ERROR,"@org.neo4j.procedure.Context usage error: field FinalContextMisuse#graphDatabaseService should be " + "public, non-static and non-final"));
  }
  @Test public void warns_against_restricted_injected_types(){
    Stream<VariableElement> fields=elementTestUtils.getFields(RestrictedContextTypes.class);
    Stream<CompilationMessage> result=fields.flatMap(contextFieldVisitor::visit);
    assertThat(result).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).containsExactlyInAnyOrder(tuple(Diagnostic.Kind.WARNING,warning("org.neo4j.kernel.internal.GraphDatabaseAPI","RestrictedContextTypes#graphDatabaseAPI")),tuple(Diagnostic.Kind.WARNING,warning("org.neo4j.kernel.api.KernelTransaction","RestrictedContextTypes#kernelTransaction")),tuple(Diagnostic.Kind.WARNING,warning("org.neo4j.graphdb.DependencyResolver","RestrictedContextTypes#dependencyResolver")),tuple(Diagnostic.Kind.WARNING,warning("org.neo4j.kernel.api.security.UserManager","RestrictedContextTypes#userManager")));
  }
  @Test public void does_not_warn_against_restricted_injected_types_when_warnings_are_suppressed(){
    ContextFieldVisitor contextFieldVisitor=new ContextFieldVisitor(compilationRule.getTypes(),compilationRule.getElements(),true);
    Stream<VariableElement> fields=elementTestUtils.getFields(RestrictedContextTypes.class);
    Stream<CompilationMessage> result=fields.flatMap(contextFieldVisitor::visit);
    assertThat(result).isEmpty();
  }
  @Test public void rejects_unsupported_injected_type(){
    Stream<VariableElement> fields=elementTestUtils.getFields(UnknownContextType.class);
    Stream<CompilationMessage> result=fields.flatMap(contextFieldVisitor::visit);
    assertThat(result).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).containsExactly(UNKNOWN_CONTEXT_ERROR_MSG);
  }
  @Test public void rejects_unsupported_injected_type_when_warnings_are_suppressed(){
    ContextFieldVisitor contextFieldVisitor=new ContextFieldVisitor(compilationRule.getTypes(),compilationRule.getElements(),true);
    Stream<VariableElement> fields=elementTestUtils.getFields(UnknownContextType.class);
    Stream<CompilationMessage> result=fields.flatMap(contextFieldVisitor::visit);
    assertThat(result).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).containsExactly(UNKNOWN_CONTEXT_ERROR_MSG);
  }
  private String warning(  String fieldType,  String fieldName){
    return String.format("@org.neo4j.procedure.Context usage warning: found unsupported restricted type <%s> on %2$s.\n" + "The procedure will not load unless declared via the configuration option 'dbms.security.procedures.unrestricted'.\n" + "You can ignore this warning by passing the option -AIgnoreContextWarnings to the Java compiler",fieldType,fieldName);
  }
}
