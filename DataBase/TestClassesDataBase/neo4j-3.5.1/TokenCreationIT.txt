/** 
 * Token creation should be able to handle cases of concurrent token creation with different/same names. Short random interval (1-3) give a high chances of same token name in this test. <p> Newly created token should be visible only when token cache already have both mappings: "name -> id" and "id -> name" populated. Otherwise attempt to retrieve labels from newly created node can fail.
 */
public class TokenCreationIT {
  @Rule public final EmbeddedDatabaseRule databaseRule=new EmbeddedDatabaseRule();
  private volatile boolean stop;
  @Test @RepeatRule.Repeat(times=5) public void concurrentLabelTokenCreation() throws InterruptedException {
    int concurrentWorkers=10;
    CountDownLatch latch=new CountDownLatch(concurrentWorkers);
    for (int i=0; i < concurrentWorkers; i++) {
      new LabelCreator(databaseRule,latch).start();
    }
    LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(500));
    stop=true;
    latch.await();
  }
  public Label[] getLabels(){
    int randomLabelValue=ThreadLocalRandom.current().nextInt(2) + 1;
    Label[] labels=new Label[randomLabelValue];
    for (int i=0; i < labels.length; i++) {
      labels[i]=Label.label(RandomStringUtils.randomAscii(randomLabelValue));
    }
    return labels;
  }
private class LabelCreator extends Thread {
    private final GraphDatabaseService database;
    private final CountDownLatch createLatch;
    LabelCreator(    GraphDatabaseService database,    CountDownLatch createLatch){
      this.database=database;
      this.createLatch=createLatch;
    }
    @Override public void run(){
      try {
        while (!stop) {
          try (Transaction transaction=database.beginTx()){
            Label[] createdLabels=getLabels();
            Node node=database.createNode(createdLabels);
            Iterable<Label> nodeLabels=node.getLabels();
            assertEquals(asSet(asList(createdLabels)),asSet(nodeLabels));
            transaction.success();
          }
 catch (          Exception e) {
            stop=true;
            throw e;
          }
        }
      }
  finally {
        createLatch.countDown();
      }
    }
  }
}
