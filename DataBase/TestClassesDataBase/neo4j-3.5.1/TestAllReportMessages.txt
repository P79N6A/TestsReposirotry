@RunWith(Parameterized.class) public static class TestAllReportMessages implements Answer {
  @Test @SuppressWarnings("unchecked") public void shouldLogInconsistency() throws Exception {
    InconsistencyReport report=mock(InconsistencyReport.class);
    ConsistencyReport.Reporter reporter=new ConsistencyReporter(mock(RecordAccess.class),report);
    reportMethod.invoke(reporter,parameters(reportMethod));
    if (method.getAnnotation(ConsistencyReport.Warning.class) == null) {
      if (reportMethod.getName().endsWith("Change")) {
        verify(report).error(any(RecordType.class),any(AbstractBaseRecord.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),any(Object[].class));
      }
 else {
        verify(report).error(any(RecordType.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),nullSafeAny());
      }
    }
 else {
      if (reportMethod.getName().endsWith("Change")) {
        verify(report).warning(any(RecordType.class),any(AbstractBaseRecord.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),any(Object[].class));
      }
 else {
        verify(report).warning(any(RecordType.class),any(AbstractBaseRecord.class),argThat(hasExpectedFormat()),nullSafeAny());
      }
    }
  }
  private final Method reportMethod;
  private final Method method;
  public TestAllReportMessages(  Method reportMethod,  Method method){
    this.reportMethod=reportMethod;
    this.method=method;
  }
  @Parameterized.Parameters(name="{1}") public static List<Object[]> methods(){
    ArrayList<Object[]> methods=new ArrayList<>();
    for (    Method reporterMethod : ConsistencyReport.Reporter.class.getMethods()) {
      Type[] parameterTypes=reporterMethod.getGenericParameterTypes();
      ParameterizedType checkerParameter=(ParameterizedType)parameterTypes[parameterTypes.length - 1];
      Class reportType=(Class)checkerParameter.getActualTypeArguments()[1];
      for (      Method method : reportType.getMethods()) {
        methods.add(new Object[]{reporterMethod,method});
      }
    }
    return methods;
  }
  @Rule public final TestRule logFailure=(base,description) -> new Statement(){
    @Override public void evaluate() throws Throwable {
      try {
        base.evaluate();
      }
 catch (      Throwable failure) {
        System.err.println("Failure in " + TestAllReportMessages.this + ": "+ failure);
        throw failure;
      }
    }
  }
;
  @Override public String toString(){
    return format("report.%s( %s{ reporter.%s(); } )",reportMethod.getName(),signatureOf(reportMethod),method.getName());
  }
  private static String signatureOf(  Method reportMethod){
    if (reportMethod.getParameterTypes().length == 2) {
      return "record, RecordCheck( reporter )";
    }
 else {
      return "oldRecord, newRecord, RecordCheck( reporter )";
    }
  }
  private Object[] parameters(  Method method){
    Class<?>[] parameterTypes=method.getParameterTypes();
    Object[] parameters=new Object[parameterTypes.length];
    for (int i=0; i < parameters.length; i++) {
      parameters[i]=parameter(parameterTypes[i]);
    }
    return parameters;
  }
  private Object parameter(  Class<?> type){
    if (type == RecordType.class) {
      return RecordType.STRING_PROPERTY;
    }
    if (type == RecordCheck.class) {
      return mockChecker();
    }
    if (type == NodeRecord.class) {
      return new NodeRecord(0,false,1,2);
    }
    if (type == RelationshipRecord.class) {
      return new RelationshipRecord(0,1,2,3);
    }
    if (type == PropertyRecord.class) {
      return new PropertyRecord(0);
    }
    if (type == PropertyKeyTokenRecord.class) {
      return new PropertyKeyTokenRecord(0);
    }
    if (type == PropertyBlock.class) {
      return new PropertyBlock();
    }
    if (type == RelationshipTypeTokenRecord.class) {
      return new RelationshipTypeTokenRecord(0);
    }
    if (type == LabelTokenRecord.class) {
      return new LabelTokenRecord(0);
    }
    if (type == DynamicRecord.class) {
      return new DynamicRecord(0);
    }
    if (type == NeoStoreRecord.class) {
      return new NeoStoreRecord();
    }
    if (type == LabelScanDocument.class) {
      return new LabelScanDocument(new NodeLabelRange(0,new long[][]{}));
    }
    if (type == IndexEntry.class) {
      return new IndexEntry(0);
    }
    if (type == CountsEntry.class) {
      return new CountsEntry(nodeKey(7),42);
    }
    if (type == SchemaRule.Kind.class) {
      return SchemaRule.Kind.INDEX_RULE;
    }
    if (type == StoreIndexDescriptor.class) {
      return IndexDescriptorFactory.forSchema(forLabel(2,3),IndexProviderDescriptor.UNDECIDED).withId(1);
    }
    if (type == SchemaRule.class) {
      return simpleSchemaRule();
    }
    if (type == RelationshipGroupRecord.class) {
      return new RelationshipGroupRecord(0,1);
    }
    if (type == long.class) {
      return 12L;
    }
    if (type == Object.class) {
      return "object";
    }
    throw new IllegalArgumentException(format("Don't know how to provide parameter of type %s",type.getName()));
  }
  private static SchemaRule simpleSchemaRule(){
    return new SchemaRule(){
      @Override public long getId(){
        return 0;
      }
      @Override public String getName(){
        return null;
      }
      @Override public SchemaDescriptor schema(){
        return null;
      }
    }
;
  }
  @SuppressWarnings("unchecked") private RecordCheck mockChecker(){
    RecordCheck checker=mock(RecordCheck.class);
    doAnswer(this).when(checker).check(any(AbstractBaseRecord.class),any(CheckerEngine.class),any(RecordAccess.class));
    return checker;
  }
  @Override public Object answer(  InvocationOnMock invocation) throws Throwable {
    Object[] arguments=invocation.getArguments();
    ConsistencyReport report=((CheckerEngine)arguments[arguments.length - 2]).report();
    try {
      return method.invoke(report,parameters(method));
    }
 catch (    IllegalArgumentException ex) {
      throw new IllegalArgumentException(format("%s.%s#%s(...)",report,method.getDeclaringClass().getSimpleName(),method.getName()),ex);
    }
  }
}
