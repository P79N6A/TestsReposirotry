public class UnsupportedStructTypesV1V2IT extends AbstractBoltTransportsTest {
  private static final String USER_AGENT="TestClient/1.0";
  @Rule public Neo4jWithSocket server=new Neo4jWithSocket(getClass(),settings -> settings.put(auth_enabled.name(),"false"));
  @Before public void setup() throws Exception {
    address=server.lookupDefaultConnector();
  }
  @Test public void shouldFailWhenNullKeyIsSentWithInit() throws Exception {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    connection.send(util.chunk(64,createMsgWithNullKey(InitMessage.SIGNATURE)));
    assertThat(connection,util.eventuallyReceives(msgFailure(Status.Request.Invalid,"Value `null` is not supported as key in maps, must be a non-nullable string.")));
    assertThat(connection,eventuallyDisconnects());
  }
  @Test public void shouldFailWhenDuplicateKeyIsSentWithInit() throws Exception {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    connection.send(util.chunk(64,createMsgWithDuplicateKey(InitMessage.SIGNATURE)));
    assertThat(connection,util.eventuallyReceives(msgFailure(Status.Request.Invalid,"Duplicate map key `key1`.")));
    assertThat(connection,eventuallyDisconnects());
  }
  @Test public void shouldFailWhenNullKeyIsSentWithRun() throws Exception {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    connection.send(util.chunk(new InitMessage(USER_AGENT,Collections.emptyMap())));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
    connection.send(util.chunk(64,createMsgWithNullKey(RunMessage.SIGNATURE)));
    assertThat(connection,util.eventuallyReceives(msgFailure(Status.Request.Invalid,"Value `null` is not supported as key in maps, must be a non-nullable string.")));
    assertThat(connection,eventuallyDisconnects());
  }
  @Test public void shouldFailWhenDuplicateKeyIsSentWithRun() throws Exception {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    connection.send(util.chunk(new InitMessage(USER_AGENT,Collections.emptyMap())));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
    connection.send(util.chunk(64,createMsgWithDuplicateKey(RunMessage.SIGNATURE)));
    assertThat(connection,util.eventuallyReceives(msgFailure(Status.Request.Invalid,"Duplicate map key `key1`.")));
    assertThat(connection,eventuallyDisconnects());
  }
  @Test public void shouldFailWhenNodeIsSentWithRun() throws Exception {
    testFailureWithV1Value(ALICE,"Node");
  }
  @Test public void shouldFailWhenRelationshipIsSentWithRun() throws Exception {
    testFailureWithV1Value(ALICE_KNOWS_BOB,"Relationship");
  }
  @Test public void shouldFailWhenPathIsSentWithRun() throws Exception {
    for (    PathValue path : ALL_PATHS) {
      try {
        testFailureWithV1Value(path,"Path");
      }
  finally {
        reconnect();
      }
    }
  }
  @Test public void shouldTerminateConnectionWhenUnknownMessageIsSent() throws Exception {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    connection.send(util.chunk(new InitMessage(USER_AGENT,Collections.emptyMap())));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
    connection.send(util.chunk(64,createMsg((byte)'A')));
    assertThat(connection,eventuallyDisconnects());
  }
  @Test public void shouldTerminateConnectionWhenUnknownTypeIsSent() throws Exception {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    connection.send(util.chunk(new InitMessage(USER_AGENT,Collections.emptyMap())));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
    connection.send(util.chunk(64,createMsgWithUnknownValue(RunMessage.SIGNATURE)));
    assertThat(connection,eventuallyDisconnects());
  }
  private void testFailureWithV1Value(  AnyValue value,  String description) throws Exception {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    connection.send(util.chunk(new InitMessage(USER_AGENT,Collections.emptyMap())));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
    connection.send(util.chunk(64,createRunWithV1Value(value)));
    assertThat(connection,util.eventuallyReceives(msgFailure(Status.Statement.TypeError,description + " values cannot be unpacked with this version of bolt.")));
    assertThat(connection,eventuallyDisconnects());
  }
  private byte[] createRunWithV1Value(  AnyValue value) throws IOException {
    PackedOutputArray out=new PackedOutputArray();
    Neo4jPack.Packer packer=neo4jPack.newPacker(out);
    packer.packStructHeader(2,RunMessage.SIGNATURE);
    packer.pack("RETURN $x");
    packer.packMapHeader(1);
    packer.pack("x");
    packer.pack(value);
    return out.bytes();
  }
  private byte[] createMsg(  byte signature) throws IOException {
    PackedOutputArray out=new PackedOutputArray();
    Neo4jPack.Packer packer=neo4jPack.newPacker(out);
    packer.packStructHeader(0,signature);
    return out.bytes();
  }
  private byte[] createMsgWithNullKey(  byte signature) throws IOException {
    PackedOutputArray out=new PackedOutputArray();
    Neo4jPack.Packer packer=neo4jPack.newPacker(out);
    packer.packStructHeader(2,signature);
    packer.pack("Text");
    packMapWithNullKey(packer);
    return out.bytes();
  }
  private byte[] createMsgWithDuplicateKey(  byte signature) throws IOException {
    PackedOutputArray out=new PackedOutputArray();
    Neo4jPack.Packer packer=neo4jPack.newPacker(out);
    packer.packStructHeader(2,signature);
    packer.pack("Text");
    packMapWithDuplicateKey(packer);
    return out.bytes();
  }
  private byte[] createMsgWithUnknownValue(  byte signature) throws IOException {
    PackedOutputArray out=new PackedOutputArray();
    Neo4jPack.Packer packer=neo4jPack.newPacker(out);
    packer.packStructHeader(2,signature);
    packer.pack("Text");
    packer.packMapHeader(1);
    packer.pack("key1");
    packer.packStructHeader(0,(byte)'A');
    return out.bytes();
  }
  private static void packMapWithNullKey(  Neo4jPack.Packer packer) throws IOException {
    packer.packMapHeader(2);
    packer.pack("key1");
    packer.pack(ValueUtils.of(null));
    packer.pack(ValueUtils.of(null));
    packer.pack("value1");
  }
  private static void packMapWithDuplicateKey(  Neo4jPack.Packer packer) throws IOException {
    packer.packMapHeader(2);
    packer.pack("key1");
    packer.pack("value1");
    packer.pack("key1");
    packer.pack("value2");
  }
}
