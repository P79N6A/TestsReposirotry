public class LogPruningTest {
  private final Config config=Config.defaults();
  private FileSystemAbstraction fs;
  private LogFiles logFiles;
  private LogProvider logProvider;
  private Clock clock;
  private LogPruneStrategyFactory factory;
  @Before public void setUp(){
    fs=mock(FileSystemAbstraction.class);
    logFiles=mock(LogFiles.class);
    doAnswer(inv -> new File(String.valueOf(inv.getArguments()[0]))).when(logFiles).getLogFileForVersion(anyLong());
    logProvider=NullLogProvider.getInstance();
    clock=mock(Clock.class);
    factory=mock(LogPruneStrategyFactory.class);
  }
  @Test public void mustDeleteLogFilesThatCanBePruned(){
    when(factory.strategyFromConfigValue(eq(fs),eq(logFiles),eq(clock),anyString())).thenReturn(upTo -> LongStream.range(3,upTo));
    LogPruning pruning=new LogPruningImpl(fs,logFiles,logProvider,factory,clock,config);
    pruning.pruneLogs(5);
    InOrder order=inOrder(fs);
    order.verify(fs).deleteFile(new File("3"));
    order.verify(fs).deleteFile(new File("4"));
    verifyNoMoreInteractions(fs);
  }
  @Test public void mustHaveLogFilesToPruneIfStrategyFindsFiles(){
    when(factory.strategyFromConfigValue(eq(fs),eq(logFiles),eq(clock),anyString())).thenReturn(upTo -> LongStream.range(3,upTo));
    when(logFiles.getHighestLogVersion()).thenReturn(4L);
    LogPruning pruning=new LogPruningImpl(fs,logFiles,logProvider,factory,clock,config);
    assertTrue(pruning.mightHaveLogsToPrune());
  }
  @Test public void mustNotHaveLogsFilesToPruneIfStrategyFindsNoFiles(){
    when(factory.strategyFromConfigValue(eq(fs),eq(logFiles),eq(clock),anyString())).thenReturn(x -> LongStream.empty());
    LogPruning pruning=new LogPruningImpl(fs,logFiles,logProvider,factory,clock,config);
    assertFalse(pruning.mightHaveLogsToPrune());
  }
}
