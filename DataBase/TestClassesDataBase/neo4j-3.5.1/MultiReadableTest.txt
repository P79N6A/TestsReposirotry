class MultiReadableTest {
  private static final Configuration CONFIG=new Configuration.Overridden(Configuration.DEFAULT){
    @Override public int bufferSize(){
      return 200;
    }
  }
;
  private final Mark mark=new Mark();
  private final Extractors extractors=new Extractors(';');
  private final int delimiter=',';
  @Test void shouldReadFromMultipleReaders() throws Exception {
    String[][] data=new String[][]{{"this is","the first line"},{"where this","is the second line"},{"and here comes","the third line"}};
    RawIterator<CharReadable,IOException> readers=readerIteratorFromStrings(data,null);
    CharSeeker seeker=CharSeekers.charSeeker(new MultiReadable(readers),CONFIG,true);
    for (    String[] line : data) {
      assertNextLine(line,seeker,mark,extractors);
    }
    assertFalse(seeker.seek(mark,delimiter));
    seeker.close();
  }
  @Test void shouldHandleSourcesEndingWithNewLine() throws Exception {
    String[][] data=new String[][]{{"this is","the first line"},{"where this","is the second line"}};
    RawIterator<CharReadable,IOException> readers=readerIteratorFromStrings(data,'\n');
    CharSeeker seeker=CharSeekers.charSeeker(new MultiReadable(readers),CONFIG,true);
    for (    String[] line : data) {
      assertNextLine(line,seeker,mark,extractors);
    }
    assertFalse(seeker.seek(mark,delimiter));
    seeker.close();
  }
  @Test void shouldTrackAbsolutePosition() throws Exception {
    String[][] data=new String[][]{{"this is","the first line"},{"where this","is the second line"}};
    RawIterator<CharReadable,IOException> readers=readerIteratorFromStrings(data,'\n');
    CharReadable reader=new MultiReadable(readers);
    assertEquals(0L,reader.position());
    SectionedCharBuffer buffer=new SectionedCharBuffer(15);
    reader.read(buffer,buffer.front());
    assertEquals(15,reader.position());
    reader.read(buffer,buffer.front());
    assertEquals(23,reader.position(),"Should not transition to a new reader in the middle of a read");
    assertEquals("Reader1",reader.sourceDescription());
    reader.read(buffer,buffer.front());
    assertEquals(23 + 15,reader.position());
    reader.read(buffer,buffer.front());
    assertEquals(23 + 30,reader.position());
    reader.read(buffer,buffer.front());
    assertFalse(buffer.hasAvailable());
  }
  @Test void shouldNotCrossSourcesInOneRead() throws Exception {
    String source1="abcdefghijklm";
    String source2="nopqrstuvwxyz";
    String[][] data=new String[][]{{source1},{source2}};
    CharReadable readable=new MultiReadable(readerIteratorFromStrings(data,'\n'));
    char[] target=new char[source1.length() + source2.length() / 2];
    int read=readable.read(target,0,target.length);
    assertEquals(source1.length() + 1,read);
    target=new char[source2.length()];
    read=readable.read(target,0,target.length);
    assertEquals(source2.length(),read);
    read=readable.read(target,0,target.length);
    assertEquals(1,read);
  }
  private void assertNextLine(  String[] line,  CharSeeker seeker,  Mark mark,  Extractors extractors) throws IOException {
    for (    String value : line) {
      assertTrue(seeker.seek(mark,delimiter));
      assertEquals(value,seeker.extract(mark,extractors.string()).value());
    }
    assertTrue(mark.isEndOfLine());
  }
  private RawIterator<CharReadable,IOException> readerIteratorFromStrings(  final String[][] data,  final Character lineEnding){
    return new RawIterator<CharReadable,IOException>(){
      private int cursor;
      @Override public boolean hasNext(){
        return cursor < data.length;
      }
      @Override public CharReadable next(){
        String string=join(data[cursor++]);
        return Readables.wrap(new StringReader(string){
          @Override public String toString(){
            return "Reader" + cursor;
          }
        }
,string.length() * 2);
      }
      private String join(      String[] strings){
        StringBuilder builder=new StringBuilder();
        for (        String string : strings) {
          builder.append(builder.length() > 0 ? "," : "").append(string);
        }
        if (lineEnding != null) {
          builder.append(lineEnding);
        }
        return builder.toString();
      }
      @Override public void remove(){
        throw new UnsupportedOperationException();
      }
    }
;
  }
}
