@ExtendWith(RandomExtension.class) class KeySearchTest {
  private static final int STABLE_GENERATION=1;
  private static final int UNSTABLE_GENERATION=2;
  private static final int KEY_COUNT=10;
  private static final int PAGE_SIZE=512;
  private final PageCursor cursor=wrap(new byte[PAGE_SIZE],0,PAGE_SIZE);
  private final Layout<MutableLong,MutableLong> layout=longLayout().build();
  private final TreeNode<MutableLong,MutableLong> node=new TreeNodeFixedSize<>(PAGE_SIZE,layout);
  private final MutableLong readKey=layout.newKey();
  private final MutableLong searchKey=layout.newKey();
  private final MutableLong insertKey=layout.newKey();
  private final MutableLong dummyValue=layout.newValue();
  @Inject private RandomRule random;
  @Test void searchEmptyLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    int keyCount=TreeNode.keyCount(cursor);
    int result=search(cursor,node,LEAF,searchKey,readKey,keyCount);
    assertSearchResult(false,0,result);
  }
  @Test void searchEmptyInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    int keyCount=TreeNode.keyCount(cursor);
    final int result=search(cursor,node,INTERNAL,searchKey,readKey,keyCount);
    assertSearchResult(false,0,result);
  }
  @Test void searchNoHitLessThanWithOneKeyInLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    appendKey(1L);
    int result=searchKey(0L);
    assertSearchResult(false,0,result);
  }
  @Test void searchNoHitLessThanWithOneKeyInInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    appendKey(1L);
    int result=searchKey(0L);
    assertSearchResult(false,0,result);
  }
  @Test void searchHitWithOneKeyInLeaf(){
    long key=1L;
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    appendKey(key);
    int result=searchKey(key);
    assertSearchResult(true,0,result);
  }
  @Test void searchHitWithOneKeyInInternal(){
    long key=1L;
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    appendKey(key);
    int result=searchKey(key);
    assertSearchResult(true,0,result);
  }
  @Test void searchNoHitGreaterThanWithOneKeyInLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    appendKey(1L);
    int result=searchKey(2L);
    assertSearchResult(false,1,result);
  }
  @Test void searchNoHitGreaterThanWithOneKeyInInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    appendKey(1L);
    int result=searchKey(2L);
    assertSearchResult(false,1,result);
  }
  @Test void searchNoHitGreaterThanWithFullLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int result=searchKey(KEY_COUNT);
    assertSearchResult(false,KEY_COUNT,result);
  }
  @Test void searchNoHitGreaterThanWithFullInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int result=searchKey(KEY_COUNT);
    assertSearchResult(false,KEY_COUNT,result);
  }
  @Test void searchHitOnLastWithFullLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int result=searchKey(KEY_COUNT - 1);
    assertSearchResult(true,KEY_COUNT - 1,result);
  }
  @Test void searchHitOnLastWithFullInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int result=searchKey(KEY_COUNT - 1);
    assertSearchResult(true,KEY_COUNT - 1,result);
  }
  @Test void searchHitOnFirstWithFullLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int result=searchKey(0);
    assertSearchResult(true,0,result);
  }
  @Test void searchHitOnFirstWithFullInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int result=searchKey(0);
    assertSearchResult(true,0,result);
  }
  @Test void searchNoHitLessThanWithFullLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i + 1);
    }
    int result=searchKey(0);
    assertSearchResult(false,0,result);
  }
  @Test void searchNoHitLessThanWithFullInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i + 1);
    }
    int result=searchKey(0);
    assertSearchResult(false,0,result);
  }
  @Test void searchHitOnMiddleWithFullLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int middle=KEY_COUNT / 2;
    int result=searchKey(middle);
    assertSearchResult(true,middle,result);
  }
  @Test void searchHitOnMiddleWithFullInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i);
    }
    int middle=KEY_COUNT / 2;
    int result=searchKey(middle);
    assertSearchResult(true,middle,result);
  }
  @Test void searchNoHitInMiddleWithFullLeaf(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i * 2);
    }
    int middle=KEY_COUNT / 2;
    int result=searchKey((middle * 2) - 1);
    assertSearchResult(false,middle,result);
  }
  @Test void searchNoHitInMiddleWithFullInternal(){
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      appendKey(i * 2);
    }
    int middle=KEY_COUNT / 2;
    int result=searchKey((middle * 2) - 1);
    assertSearchResult(false,middle,result);
  }
  @Test void searchHitOnFirstNonUniqueKeysLeaf(){
    long first=1L;
    long second=2L;
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      long key=i < KEY_COUNT / 2 ? first : second;
      appendKey(key);
    }
    int result=searchKey(first);
    assertSearchResult(true,0,result);
  }
  @Test void searchHitOnFirstNonUniqueKeysInternal(){
    long first=1L;
    long second=2L;
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      long key=i < KEY_COUNT / 2 ? first : second;
      appendKey(key);
    }
    int result=searchKey(first);
    assertSearchResult(true,0,result);
  }
  @Test void searchHitOnMiddleNonUniqueKeysLeaf(){
    long first=1L;
    long second=2L;
    int middle=KEY_COUNT / 2;
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      long key=i < middle ? first : second;
      appendKey(key);
    }
    int result=searchKey(second);
    assertSearchResult(true,middle,result);
  }
  @Test void searchHitOnMiddleNonUniqueKeysInternal(){
    long first=1L;
    long second=2L;
    int middle=KEY_COUNT / 2;
    node.initializeInternal(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    for (int i=0; i < KEY_COUNT; i++) {
      long key=i < middle ? first : second;
      appendKey(key);
    }
    int result=searchKey(second);
    assertSearchResult(true,middle,result);
  }
  @Test void shouldFindExistingKey(){
    fullLeafWithUniqueKeys();
    MutableLong key=layout.newKey();
    for (int i=0; i < KEY_COUNT; i++) {
      key.setValue(key(i));
      int result=search(cursor,node,LEAF,key,readKey,KEY_COUNT);
      assertSearchResult(true,i,result);
    }
  }
  @Test void shouldReturnCorrectIndexesForKeysInBetweenExisting(){
    fullLeafWithUniqueKeys();
    MutableLong key=layout.newKey();
    for (int i=1; i < KEY_COUNT - 1; i++) {
      key.setValue(key(i) - 1);
      int result=search(cursor,node,LEAF,key,readKey,KEY_COUNT);
      assertSearchResult(false,i,result);
    }
  }
  @Test void shouldSearchAndFindOnRandomData(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    List<MutableLong> keys=new ArrayList<>();
    int currentKey=random.nextInt(10_000);
    MutableLong key=layout.newKey();
    int keyCount=0;
    while (true) {
      MutableLong expectedKey=layout.newKey();
      key.setValue(currentKey);
      if (node.leafOverflow(cursor,keyCount,key,dummyValue) != NO) {
        break;
      }
      layout.copyKey(key,expectedKey);
      keys.add(keyCount,expectedKey);
      node.insertKeyValueAt(cursor,key,dummyValue,keyCount,keyCount);
      currentKey+=random.nextInt(100) + 10;
      keyCount++;
    }
    TreeNode.setKeyCount(cursor,keyCount);
    MutableLong searchKey=layout.newKey();
    for (int i=0; i < 1_000; i++) {
      searchKey.setValue(random.nextInt(currentKey + 10));
      int searchResult=search(cursor,node,LEAF,searchKey,readKey,keyCount);
      boolean exists=contains(keys,searchKey,layout);
      int position=KeySearch.positionOf(searchResult);
      assertEquals(exists,KeySearch.isHit(searchResult));
      if (layout.compare(searchKey,keys.get(0)) <= 0) {
        assertEquals(0,position);
      }
 else {
        boolean found=false;
        for (int j=keyCount - 1; j >= 0; j--) {
          if (layout.compare(searchKey,keys.get(j)) > 0) {
            assertEquals(j + 1,position);
            found=true;
            break;
          }
        }
        assertTrue(found);
      }
    }
  }
  private int searchKey(  long key){
    int keyCount=TreeNode.keyCount(cursor);
    TreeNode.Type type=TreeNode.isInternal(cursor) ? INTERNAL : LEAF;
    searchKey.setValue(key);
    return search(cursor,node,type,searchKey,readKey,keyCount);
  }
  private void appendKey(  long key){
    insertKey.setValue(key);
    int keyCount=TreeNode.keyCount(cursor);
    if (TreeNode.isInternal(cursor)) {
      long dummyChild=10;
      node.insertKeyAndRightChildAt(cursor,insertKey,dummyChild,keyCount,keyCount,STABLE_GENERATION,UNSTABLE_GENERATION);
    }
 else {
      node.insertKeyValueAt(cursor,insertKey,dummyValue,keyCount,keyCount);
    }
    TreeNode.setKeyCount(cursor,keyCount + 1);
  }
  private void assertSearchResult(  boolean hit,  int position,  int searchResult){
    assertEquals(hit,KeySearch.isHit(searchResult));
    assertEquals(position,KeySearch.positionOf(searchResult));
  }
  private void fullLeafWithUniqueKeys(){
    node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
    MutableLong key=layout.newKey();
    for (int i=0; i < KEY_COUNT; i++) {
      key.setValue(key(i));
      node.insertKeyValueAt(cursor,key,dummyValue,i,i);
    }
    TreeNode.setKeyCount(cursor,KEY_COUNT);
  }
  private int key(  int i){
    return 2 << i;
  }
}
