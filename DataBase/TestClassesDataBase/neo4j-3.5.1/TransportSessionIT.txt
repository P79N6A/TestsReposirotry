public class TransportSessionIT extends AbstractBoltTransportsTest {
  @Rule public Neo4jWithSocket server=new Neo4jWithSocket(getClass(),settings -> settings.put(GraphDatabaseSettings.auth_enabled.name(),"false"));
  private HostnamePort address;
  @Before public void setup(){
    address=server.lookupDefaultConnector();
  }
  @Test public void shouldNegotiateProtocolVersion() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions());
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
  }
  @Test public void shouldReturnNilOnNoApplicableVersion() throws Throwable {
    connection.connect(address).send(util.acceptedVersions(1337,0,0,0));
    assertThat(connection,eventuallyReceives(new byte[]{0,0,0,0}));
  }
  @Test public void shouldRunSimpleStatement() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    Matcher<Map<? extends String,?>> entryTypeMatcher=hasEntry(is("type"),equalTo("r"));
    Matcher<Map<? extends String,?>> entryFieldMatcher=hasEntry(is("fields"),equalTo(asList("a","a_squared")));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(CoreMatchers.allOf(entryFieldMatcher,hasKey("result_available_after"))),msgRecord(eqRecord(equalTo(longValue(1L)),equalTo(longValue(1L)))),msgRecord(eqRecord(equalTo(longValue(2L)),equalTo(longValue(4L)))),msgRecord(eqRecord(equalTo(longValue(3L)),equalTo(longValue(9L)))),msgSuccess(CoreMatchers.allOf(entryTypeMatcher,hasKey("result_consumed_after")))));
  }
  @Test public void shouldRespondWithMetadataToDiscardAll() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared"),DiscardAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    Matcher<Map<? extends String,?>> entryFieldsMatcher=hasEntry(is("fields"),equalTo(asList("a","a_squared")));
    Matcher<Map<? extends String,?>> entryTypeMatcher=hasEntry(is("type"),equalTo("r"));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(CoreMatchers.allOf(entryFieldsMatcher,hasKey("result_available_after"))),msgSuccess(CoreMatchers.allOf(entryTypeMatcher,hasKey("result_consumed_after")))));
  }
  @Test public void shouldBeAbleToRunQueryAfterAckFailure() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("QINVALID"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgFailure(Status.Statement.SyntaxError,String.format("Invalid input 'Q': expected <init> (line 1, column 1 (offset: 0))%n" + "\"QINVALID\"%n" + " ^")),msgIgnored()));
    connection.send(util.chunk(AckFailureMessage.INSTANCE,new RunMessage("RETURN 1"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(),msgRecord(eqRecord(equalTo(longValue(1L)))),msgSuccess()));
  }
  @Test public void shouldRunProcedure() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("CREATE (n:Test {age: 2}) RETURN n.age AS age"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    Matcher<Map<? extends String,?>> ageMatcher=hasEntry(is("fields"),equalTo(singletonList("age")));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(CoreMatchers.allOf(ageMatcher,hasKey("result_available_after"))),msgRecord(eqRecord(equalTo(longValue(2L)))),msgSuccess()));
    connection.send(util.chunk(new RunMessage("CALL db.labels() YIELD label"),PullAllMessage.INSTANCE));
    Matcher<Map<? extends String,?>> entryFieldsMatcher=hasEntry(is("fields"),equalTo(singletonList("label")));
    assertThat(connection,util.eventuallyReceives(msgSuccess(CoreMatchers.allOf(entryFieldsMatcher,hasKey("result_available_after"))),msgRecord(eqRecord(Matchers.equalTo(stringValue("Test")))),msgSuccess()));
  }
  @Test public void shouldHandleDeletedNodes() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("CREATE (n:Test) DELETE n RETURN n"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    Matcher<Map<? extends String,?>> entryFieldsMatcher=hasEntry(is("fields"),equalTo(singletonList("n")));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(CoreMatchers.allOf(entryFieldsMatcher,hasKey("result_available_after")))));
    assertThat(connection,eventuallyReceives(bytes(0x00,0x08,0xB1,0x71,0x91,0xB3,0x4E,0x00,0x90,0xA0,0x00,0x00)));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
  }
  @Test public void shouldHandleDeletedRelationships() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("CREATE ()-[r:T {prop: 42}]->() DELETE r RETURN r"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    Matcher<Map<? extends String,?>> entryFieldsMatcher=hasEntry(is("fields"),equalTo(singletonList("r")));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(CoreMatchers.allOf(entryFieldsMatcher,hasKey("result_available_after")))));
    assertThat(connection,eventuallyReceives(bytes(0x00,0x0B,0xB1,0x71,0x91,0xB5,0x52,0x00,0x00,0x01,0x81,0x54,0xA0,0x00,0x00)));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
  }
  @Test public void shouldNotLeakStatsToNextStatement() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("CREATE (n)"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(),msgSuccess()));
    connection.send(util.chunk(new RunMessage("RETURN 1"),PullAllMessage.INSTANCE));
    Matcher<Map<? extends String,?>> typeMatcher=hasEntry(is("type"),equalTo("r"));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgRecord(eqRecord(equalTo(longValue(1L)))),msgSuccess(CoreMatchers.allOf(typeMatcher,hasKey("result_consumed_after")))));
  }
  @Test public void shouldSendNotifications() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("EXPLAIN MATCH (a:THIS_IS_NOT_A_LABEL) RETURN count(*)"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(),hasNotification(new TestNotification("Neo.ClientNotification.Statement.UnknownLabelWarning","The provided label is not in the database.","One of the labels in your query is not available in the database, " + "make sure you didn't misspell it or that the label is available when " + "you run this statement in your application (the missing label name is: "+ "THIS_IS_NOT_A_LABEL)",SeverityLevel.WARNING,new InputPosition(17,1,18)))));
  }
  @Test public void shouldFailNicelyOnPointsWhenProtocolDoesNotSupportThem() throws Throwable {
    assumeThat(neo4jPack.version(),equalTo(Neo4jPackV1.VERSION));
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("RETURN point({x:13, y:37, crs:'cartesian'}) as p"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    Matcher<Map<? extends String,?>> fieldsMatcher=hasEntry(is("fields"),equalTo(singletonList("p")));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(CoreMatchers.allOf(fieldsMatcher,hasKey("result_available_after"))),msgFailure(Status.Request.Invalid,"Point is not supported as a return type in Bolt")));
  }
  private byte[] bytes(  int... ints){
    byte[] bytes=new byte[ints.length];
    for (int i=0; i < ints.length; i++) {
      bytes[i]=(byte)ints[i];
    }
    return bytes;
  }
  @Test public void shouldFailNicelyOnNullKeysInMap() throws Throwable {
    HashMap<String,Object> params=new HashMap<>();
    HashMap<String,Object> inner=new HashMap<>();
    inner.put(null,42L);
    inner.put("foo",1337L);
    params.put("p",inner);
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("RETURN {p}",ValueUtils.asMapValue(params)),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgFailure(Status.Request.Invalid,"Value `null` is not supported as key in maps, must be a non-nullable string."),msgIgnored()));
    connection.send(util.chunk(AckFailureMessage.INSTANCE,new RunMessage("RETURN 1"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgSuccess(),msgRecord(eqRecord(equalTo(longValue(1L)))),msgSuccess()));
  }
  @Test public void shouldFailNicelyWhenDroppingUnknownIndex() throws Throwable {
    connection.connect(address).send(util.defaultAcceptedVersions()).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap()),new RunMessage("DROP INDEX on :Movie12345(id)"),PullAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceivesSelectedProtocolVersion());
    assertThat(connection,util.eventuallyReceives(msgSuccess(),msgFailure(Status.Schema.IndexDropFailed,"Unable to drop index on :Movie12345(id): No such INDEX ON :Movie12345(id)."),msgIgnored()));
  }
}
