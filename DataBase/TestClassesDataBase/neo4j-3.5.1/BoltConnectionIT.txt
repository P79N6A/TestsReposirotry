@SuppressWarnings("unchecked") public class BoltConnectionIT {
  private static final MapValue EMPTY_PARAMS=VirtualValues.EMPTY_MAP;
  private static final String USER_AGENT="BoltConnectionIT/0.0";
  private static final BoltChannel BOLT_CHANNEL=BoltTestUtil.newTestBoltChannel();
  @Rule public SessionRule env=new SessionRule();
  @Test public void shouldCloseConnectionAckFailureBeforeInit() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(AckFailureMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldCloseConnectionResetBeforeInit() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(ResetMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldCloseConnectionOnRunBeforeInit() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(new RunMessage("RETURN 1",map()),recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldCloseConnectionOnDiscardAllBeforeInit() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(DiscardAllMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldCloseConnectionOnPullAllBeforeInit() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(PullAllMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldExecuteStatement() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("CREATE (n {k:'k'}) RETURN n.k",EMPTY_PARAMS),recorder);
    assertThat(recorder.nextResponse(),succeeded());
    recorder.reset();
    machine.process(PullAllMessage.INSTANCE,recorder);
    recorder.nextResponse().assertRecord(0,stringValue("k"));
  }
  @Test public void shouldSucceedOn__run__pullAll__run() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("RETURN 2",EMPTY_PARAMS),recorder);
    assertThat(recorder.nextResponse(),succeeded());
  }
  @Test public void shouldSucceedOn__run__discardAll__run() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(DiscardAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("RETURN 2",EMPTY_PARAMS),recorder);
    assertThat(recorder.nextResponse(),succeeded());
  }
  @Test public void shouldSucceedOn__run_BEGIN__pullAll__run_COMMIT__pullALL__run_COMMIT() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("BEGIN",EMPTY_PARAMS),recorder);
    machine.process(PullAllMessage.INSTANCE,recorder);
    machine.process(new RunMessage("COMMIT",EMPTY_PARAMS),recorder);
    machine.process(PullAllMessage.INSTANCE,recorder);
    assertThat(recorder.nextResponse(),succeeded());
    assertThat(recorder.nextResponse(),succeeded());
    assertThat(recorder.nextResponse(),succeeded());
    assertThat(recorder.nextResponse(),succeeded());
    recorder.reset();
    machine.process(new RunMessage("BEGIN",EMPTY_PARAMS),recorder);
    assertThat(recorder.nextResponse(),succeeded());
  }
  @Test public void shouldNotSendBookmarkInPullAllResponse() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("BEGIN",EMPTY_PARAMS),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,nullResponseHandler());
    machine.process(new RunMessage("COMMIT",EMPTY_PARAMS),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,recorder);
    AnyValue bookmark=recorder.nextResponse().metadata("bookmark");
    assertNotNull(bookmark);
    String bookmarkStr=((TextValue)bookmark).stringValue();
    recorder.reset();
    machine.process(new RunMessage("BEGIN",map("bookmark",bookmarkStr)),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,recorder);
    RecordedBoltResponse response=recorder.nextResponse();
    assertThat(response,succeeded());
    assertThat(response.hasMetadata("bookmark"),is(false));
  }
  @Test public void shouldFailOn__run__run() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldFailOn__pullAll__pullAll() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(PullAllMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldFailOn__pullAll__discardAll() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(DiscardAllMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldFailOn__discardAll__discardAll() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(DiscardAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(DiscardAllMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldFailOn__discardAll__pullAll() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(DiscardAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    verifyKillsConnection(() -> machine.process(PullAllMessage.INSTANCE,recorder));
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Request.Invalid));
  }
  @Test public void shouldHandleImplicitCommitFailure() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("CREATE (n:Victim)-[:REL]->()",EMPTY_PARAMS),nullResponseHandler());
    machine.process(DiscardAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("MATCH (n:Victim) DELETE n",EMPTY_PARAMS),recorder);
    assertThat(recorder.nextResponse(),succeeded());
    recorder.reset();
    machine.process(DiscardAllMessage.INSTANCE,recorder);
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Schema.ConstraintValidationFailed));
  }
  @Test public void shouldAllowUserControlledRollbackOnExplicitTxFailure() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    machine.process(new RunMessage("BEGIN",EMPTY_PARAMS),nullResponseHandler());
    machine.process(DiscardAllMessage.INSTANCE,nullResponseHandler());
    machine.process(new RunMessage("CREATE (n:Victim)-[:REL]->()",EMPTY_PARAMS),nullResponseHandler());
    machine.process(DiscardAllMessage.INSTANCE,nullResponseHandler());
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("this is not valid syntax",EMPTY_PARAMS),recorder);
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Statement.SyntaxError));
    recorder.reset();
    machine.process(AckFailureMessage.INSTANCE,recorder);
    machine.process(new RunMessage("ROLLBACK",EMPTY_PARAMS),recorder);
    assertThat(recorder.nextResponse(),succeeded());
    assertThat(recorder.nextResponse(),succeeded());
  }
  @Test public void shouldHandleFailureDuringResultPublishing() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    final CountDownLatch pullAllCallbackCalled=new CountDownLatch(1);
    final AtomicReference<Neo4jError> error=new AtomicReference<>();
    machine.process(new RunMessage("RETURN 1",EMPTY_PARAMS),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,new BoltResponseHandler(){
      @Override public void onRecords(      BoltResult result,      boolean pull){
        throw new RuntimeException("Ooopsies!");
      }
      @Override public void onMetadata(      String key,      AnyValue value){
      }
      @Override public void markFailed(      Neo4jError err){
        error.set(err);
        pullAllCallbackCalled.countDown();
      }
      @Override public void markIgnored(){
      }
      @Override public void onFinish(){
      }
    }
);
    assertTrue(pullAllCallbackCalled.await(30,TimeUnit.SECONDS));
    final Neo4jError err=error.get();
    assertThat(err.status(),equalTo(Status.General.UnknownError));
    assertThat(err.message(),CoreMatchers.containsString("Ooopsies!"));
  }
  @Test public void shouldBeAbleToCleanlyRunMultipleSessionsInSingleThread() throws Throwable {
    BoltStateMachine firstMachine=env.newMachine(BOLT_CHANNEL);
    firstMachine.process(new InitMessage(USER_AGENT,emptyMap()),null);
    BoltStateMachine secondMachine=env.newMachine(BOLT_CHANNEL);
    secondMachine.process(new InitMessage(USER_AGENT,emptyMap()),null);
    runAndPull(firstMachine,"BEGIN");
    Object[] stream=runAndPull(secondMachine,"CREATE (a:Person) RETURN id(a)");
    long id=((LongValue)((Record)stream[0]).fields()[0]).value();
    runAndPull(firstMachine,"ROLLBACK");
    stream=runAndPull(secondMachine,"MATCH (a:Person) WHERE id(a) = " + id + " RETURN COUNT(*)");
    assertThat(((Record)stream[0]).fields()[0],equalTo(longValue(1L)));
  }
  @Test public void shouldSupportUsingPeriodicCommitInSession() throws Exception {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    MapValue params=map("csvFileUrl",createLocalIrisData(machine));
    long txIdBeforeQuery=env.lastClosedTxId();
    long batch=40;
    Object[] result=runAndPull(machine,"USING PERIODIC COMMIT " + batch + "\n"+ "LOAD CSV WITH HEADERS FROM {csvFileUrl} AS l\n"+ "MATCH (c:Class {name: l.class_name})\n"+ "CREATE (s:Sample {sepal_length: l.sepal_length, sepal_width: l.sepal_width, "+ "petal_length: l.petal_length, petal_width: l.petal_width})\n"+ "CREATE (c)<-[:HAS_CLASS]-(s)\n"+ "RETURN count(*) AS c",params);
    assertThat(result.length,equalTo(1));
    Record record=(Record)result[0];
    AnyValue[] fields=record.fields();
    assertThat(fields.length,equalTo(1));
    assertThat(fields[0],equalTo(longValue(150L)));
    long tokensCommits=7;
    long commits=(IRIS_DATA.split("\n").length - 1) / batch;
    long txId=env.lastClosedTxId();
    assertEquals(tokensCommits + commits + txIdBeforeQuery,txId);
  }
  @Test public void shouldNotSupportUsingPeriodicCommitInTransaction() throws Exception {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    MapValue params=map("csvFileUrl",createLocalIrisData(machine));
    runAndPull(machine,"BEGIN");
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage("USING PERIODIC COMMIT 40\n" + "LOAD CSV WITH HEADERS FROM {csvFileUrl} AS l\n" + "MATCH (c:Class {name: l.class_name})\n"+ "CREATE (s:Sample {sepal_length: l.sepal_length, sepal_width: l.sepal_width, petal_length: l"+ ".petal_length, petal_width: l.petal_width})\n"+ "CREATE (c)<-[:HAS_CLASS]-(s)\n"+ "RETURN count(*) AS c",params),recorder);
    assertThat(recorder.nextResponse(),failedWithStatus(Status.Statement.SemanticError));
  }
  @Test public void shouldCloseTransactionOnCommit() throws Exception {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    runAndPull(machine,"BEGIN");
    runAndPull(machine,"RETURN 1");
    runAndPull(machine,"COMMIT");
    assertFalse(hasTransaction(machine));
  }
  @Test public void shouldCloseTransactionEvenIfCommitFails() throws Exception {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    runAndPull(machine,"BEGIN");
    runAndPull(machine,"X",map(),IGNORED);
    machine.process(AckFailureMessage.INSTANCE,nullResponseHandler());
    runAndPull(machine,"COMMIT",map(),IGNORED);
    machine.process(AckFailureMessage.INSTANCE,nullResponseHandler());
    assertFalse(hasTransaction(machine));
  }
  @Test public void shouldCloseTransactionOnRollback() throws Exception {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    runAndPull(machine,"BEGIN");
    runAndPull(machine,"RETURN 1");
    runAndPull(machine,"ROLLBACK");
    assertFalse(hasTransaction(machine));
  }
  @Test public void shouldCloseTransactionOnRollbackAfterFailure() throws Exception {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    runAndPull(machine,"BEGIN");
    runAndPull(machine,"X",map(),IGNORED);
    machine.process(AckFailureMessage.INSTANCE,nullResponseHandler());
    runAndPull(machine,"ROLLBACK");
    assertFalse(hasTransaction(machine));
  }
  @Test public void shouldAllowNewTransactionAfterFailure() throws Throwable {
    BoltStateMachine machine=env.newMachine(BOLT_CHANNEL);
    machine.process(new InitMessage(USER_AGENT,emptyMap()),nullResponseHandler());
    runAndPull(machine,"BEGIN");
    machine.process(new RunMessage("invalid",EMPTY_PARAMS),nullResponseHandler());
    machine.process(ResetMessage.INSTANCE,nullResponseHandler());
    runAndPull(machine,"BEGIN");
    Object[] stream=runAndPull(machine,"RETURN 1");
    assertThat(((Record)stream[0]).fields()[0],equalTo(longValue(1L)));
  }
  private static boolean hasTransaction(  BoltStateMachine machine){
    return ((BoltStateMachineV1)machine).statementProcessor().hasTransaction();
  }
  private String createLocalIrisData(  BoltStateMachine machine) throws Exception {
    for (    String className : IRIS_CLASS_NAMES) {
      MapValue params=map("className",className);
      runAndPull(machine,"CREATE (c:Class {name: {className}}) RETURN c",params);
    }
    return env.putTmpFile("iris",".csv",IRIS_DATA).toExternalForm();
  }
  private Object[] runAndPull(  BoltStateMachine machine,  String statement) throws Exception {
    return runAndPull(machine,statement,EMPTY_PARAMS,SUCCESS);
  }
  private Record[] runAndPull(  BoltStateMachine machine,  String statement,  MapValue params) throws Exception {
    return runAndPull(machine,statement,params,SUCCESS);
  }
  private Record[] runAndPull(  BoltStateMachine machine,  String statement,  MapValue params,  BoltResponseMessage expectedResponse) throws Exception {
    BoltResponseRecorder recorder=new BoltResponseRecorder();
    machine.process(new RunMessage(statement,params),nullResponseHandler());
    machine.process(PullAllMessage.INSTANCE,recorder);
    RecordedBoltResponse response=recorder.nextResponse();
    assertEquals(expectedResponse,response.message());
    return response.records();
  }
  private MapValue map(  Object... keyValues){
    return ValueUtils.asMapValue(MapUtil.map(keyValues));
  }
  private static String[] IRIS_CLASS_NAMES=new String[]{"Iris-setosa","Iris-versicolor","Iris-virginica"};
  private static String IRIS_DATA="sepal_length,sepal_width,petal_length,petal_width,class_name\n" + "5.1,3.5,1.4,0.2,Iris-setosa\n" + "4.9,3.0,1.4,0.2,Iris-setosa\n"+ "4.7,3.2,1.3,0.2,Iris-setosa\n"+ "4.6,3.1,1.5,0.2,Iris-setosa\n"+ "5.0,3.6,1.4,0.2,Iris-setosa\n"+ "5.4,3.9,1.7,0.4,Iris-setosa\n"+ "4.6,3.4,1.4,0.3,Iris-setosa\n"+ "5.0,3.4,1.5,0.2,Iris-setosa\n"+ "4.4,2.9,1.4,0.2,Iris-setosa\n"+ "4.9,3.1,1.5,0.1,Iris-setosa\n"+ "5.4,3.7,1.5,0.2,Iris-setosa\n"+ "4.8,3.4,1.6,0.2,Iris-setosa\n"+ "4.8,3.0,1.4,0.1,Iris-setosa\n"+ "4.3,3.0,1.1,0.1,Iris-setosa\n"+ "5.8,4.0,1.2,0.2,Iris-setosa\n"+ "5.7,4.4,1.5,0.4,Iris-setosa\n"+ "5.4,3.9,1.3,0.4,Iris-setosa\n"+ "5.1,3.5,1.4,0.3,Iris-setosa\n"+ "5.7,3.8,1.7,0.3,Iris-setosa\n"+ "5.1,3.8,1.5,0.3,Iris-setosa\n"+ "5.4,3.4,1.7,0.2,Iris-setosa\n"+ "5.1,3.7,1.5,0.4,Iris-setosa\n"+ "4.6,3.6,1.0,0.2,Iris-setosa\n"+ "5.1,3.3,1.7,0.5,Iris-setosa\n"+ "4.8,3.4,1.9,0.2,Iris-setosa\n"+ "5.0,3.0,1.6,0.2,Iris-setosa\n"+ "5.0,3.4,1.6,0.4,Iris-setosa\n"+ "5.2,3.5,1.5,0.2,Iris-setosa\n"+ "5.2,3.4,1.4,0.2,Iris-setosa\n"+ "4.7,3.2,1.6,0.2,Iris-setosa\n"+ "4.8,3.1,1.6,0.2,Iris-setosa\n"+ "5.4,3.4,1.5,0.4,Iris-setosa\n"+ "5.2,4.1,1.5,0.1,Iris-setosa\n"+ "5.5,4.2,1.4,0.2,Iris-setosa\n"+ "4.9,3.1,1.5,0.2,Iris-setosa\n"+ "5.0,3.2,1.2,0.2,Iris-setosa\n"+ "5.5,3.5,1.3,0.2,Iris-setosa\n"+ "4.9,3.6,1.4,0.1,Iris-setosa\n"+ "4.4,3.0,1.3,0.2,Iris-setosa\n"+ "5.1,3.4,1.5,0.2,Iris-setosa\n"+ "5.0,3.5,1.3,0.3,Iris-setosa\n"+ "4.5,2.3,1.3,0.3,Iris-setosa\n"+ "4.4,3.2,1.3,0.2,Iris-setosa\n"+ "5.0,3.5,1.6,0.6,Iris-setosa\n"+ "5.1,3.8,1.9,0.4,Iris-setosa\n"+ "4.8,3.0,1.4,0.3,Iris-setosa\n"+ "5.1,3.8,1.6,0.2,Iris-setosa\n"+ "4.6,3.2,1.4,0.2,Iris-setosa\n"+ "5.3,3.7,1.5,0.2,Iris-setosa\n"+ "5.0,3.3,1.4,0.2,Iris-setosa\n"+ "7.0,3.2,4.7,1.4,Iris-versicolor\n"+ "6.4,3.2,4.5,1.5,Iris-versicolor\n"+ "6.9,3.1,4.9,1.5,Iris-versicolor\n"+ "5.5,2.3,4.0,1.3,Iris-versicolor\n"+ "6.5,2.8,4.6,1.5,Iris-versicolor\n"+ "5.7,2.8,4.5,1.3,Iris-versicolor\n"+ "6.3,3.3,4.7,1.6,Iris-versicolor\n"+ "4.9,2.4,3.3,1.0,Iris-versicolor\n"+ "6.6,2.9,4.6,1.3,Iris-versicolor\n"+ "5.2,2.7,3.9,1.4,Iris-versicolor\n"+ "5.0,2.0,3.5,1.0,Iris-versicolor\n"+ "5.9,3.0,4.2,1.5,Iris-versicolor\n"+ "6.0,2.2,4.0,1.0,Iris-versicolor\n"+ "6.1,2.9,4.7,1.4,Iris-versicolor\n"+ "5.6,2.9,3.6,1.3,Iris-versicolor\n"+ "6.7,3.1,4.4,1.4,Iris-versicolor\n"+ "5.6,3.0,4.5,1.5,Iris-versicolor\n"+ "5.8,2.7,4.1,1.0,Iris-versicolor\n"+ "6.2,2.2,4.5,1.5,Iris-versicolor\n"+ "5.6,2.5,3.9,1.1,Iris-versicolor\n"+ "5.9,3.2,4.8,1.8,Iris-versicolor\n"+ "6.1,2.8,4.0,1.3,Iris-versicolor\n"+ "6.3,2.5,4.9,1.5,Iris-versicolor\n"+ "6.1,2.8,4.7,1.2,Iris-versicolor\n"+ "6.4,2.9,4.3,1.3,Iris-versicolor\n"+ "6.6,3.0,4.4,1.4,Iris-versicolor\n"+ "6.8,2.8,4.8,1.4,Iris-versicolor\n"+ "6.7,3.0,5.0,1.7,Iris-versicolor\n"+ "6.0,2.9,4.5,1.5,Iris-versicolor\n"+ "5.7,2.6,3.5,1.0,Iris-versicolor\n"+ "5.5,2.4,3.8,1.1,Iris-versicolor\n"+ "5.5,2.4,3.7,1.0,Iris-versicolor\n"+ "5.8,2.7,3.9,1.2,Iris-versicolor\n"+ "6.0,2.7,5.1,1.6,Iris-versicolor\n"+ "5.4,3.0,4.5,1.5,Iris-versicolor\n"+ "6.0,3.4,4.5,1.6,Iris-versicolor\n"+ "6.7,3.1,4.7,1.5,Iris-versicolor\n"+ "6.3,2.3,4.4,1.3,Iris-versicolor\n"+ "5.6,3.0,4.1,1.3,Iris-versicolor\n"+ "5.5,2.5,4.0,1.3,Iris-versicolor\n"+ "5.5,2.6,4.4,1.2,Iris-versicolor\n"+ "6.1,3.0,4.6,1.4,Iris-versicolor\n"+ "5.8,2.6,4.0,1.2,Iris-versicolor\n"+ "5.0,2.3,3.3,1.0,Iris-versicolor\n"+ "5.6,2.7,4.2,1.3,Iris-versicolor\n"+ "5.7,3.0,4.2,1.2,Iris-versicolor\n"+ "5.7,2.9,4.2,1.3,Iris-versicolor\n"+ "6.2,2.9,4.3,1.3,Iris-versicolor\n"+ "5.1,2.5,3.0,1.1,Iris-versicolor\n"+ "5.7,2.8,4.1,1.3,Iris-versicolor\n"+ "6.3,3.3,6.0,2.5,Iris-virginica\n"+ "5.8,2.7,5.1,1.9,Iris-virginica\n"+ "7.1,3.0,5.9,2.1,Iris-virginica\n"+ "6.3,2.9,5.6,1.8,Iris-virginica\n"+ "6.5,3.0,5.8,2.2,Iris-virginica\n"+ "7.6,3.0,6.6,2.1,Iris-virginica\n"+ "4.9,2.5,4.5,1.7,Iris-virginica\n"+ "7.3,2.9,6.3,1.8,Iris-virginica\n"+ "6.7,2.5,5.8,1.8,Iris-virginica\n"+ "7.2,3.6,6.1,2.5,Iris-virginica\n"+ "6.5,3.2,5.1,2.0,Iris-virginica\n"+ "6.4,2.7,5.3,1.9,Iris-virginica\n"+ "6.8,3.0,5.5,2.1,Iris-virginica\n"+ "5.7,2.5,5.0,2.0,Iris-virginica\n"+ "5.8,2.8,5.1,2.4,Iris-virginica\n"+ "6.4,3.2,5.3,2.3,Iris-virginica\n"+ "6.5,3.0,5.5,1.8,Iris-virginica\n"+ "7.7,3.8,6.7,2.2,Iris-virginica\n"+ "7.7,2.6,6.9,2.3,Iris-virginica\n"+ "6.0,2.2,5.0,1.5,Iris-virginica\n"+ "6.9,3.2,5.7,2.3,Iris-virginica\n"+ "5.6,2.8,4.9,2.0,Iris-virginica\n"+ "7.7,2.8,6.7,2.0,Iris-virginica\n"+ "6.3,2.7,4.9,1.8,Iris-virginica\n"+ "6.7,3.3,5.7,2.1,Iris-virginica\n"+ "7.2,3.2,6.0,1.8,Iris-virginica\n"+ "6.2,2.8,4.8,1.8,Iris-virginica\n"+ "6.1,3.0,4.9,1.8,Iris-virginica\n"+ "6.4,2.8,5.6,2.1,Iris-virginica\n"+ "7.2,3.0,5.8,1.6,Iris-virginica\n"+ "7.4,2.8,6.1,1.9,Iris-virginica\n"+ "7.9,3.8,6.4,2.0,Iris-virginica\n"+ "6.4,2.8,5.6,2.2,Iris-virginica\n"+ "6.3,2.8,5.1,1.5,Iris-virginica\n"+ "6.1,2.6,5.6,1.4,Iris-virginica\n"+ "7.7,3.0,6.1,2.3,Iris-virginica\n"+ "6.3,3.4,5.6,2.4,Iris-virginica\n"+ "6.4,3.1,5.5,1.8,Iris-virginica\n"+ "6.0,3.0,4.8,1.8,Iris-virginica\n"+ "6.9,3.1,5.4,2.1,Iris-virginica\n"+ "6.7,3.1,5.6,2.4,Iris-virginica\n"+ "6.9,3.1,5.1,2.3,Iris-virginica\n"+ "5.8,2.7,5.1,1.9,Iris-virginica\n"+ "6.8,3.2,5.9,2.3,Iris-virginica\n"+ "6.7,3.3,5.7,2.5,Iris-virginica\n"+ "6.7,3.0,5.2,2.3,Iris-virginica\n"+ "6.3,2.5,5.0,1.9,Iris-virginica\n"+ "6.5,3.0,5.2,2.0,Iris-virginica\n"+ "6.2,3.4,5.4,2.3,Iris-virginica\n"+ "5.9,3.0,5.1,1.8,Iris-virginica\n"+ "\n";
}
