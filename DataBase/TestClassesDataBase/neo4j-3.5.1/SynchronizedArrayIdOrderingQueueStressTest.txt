public class SynchronizedArrayIdOrderingQueueStressTest {
  private static final int THRESHOLD=100;
  @Test public void shouldWithstandHighStressAndStillKeepOrder() throws Exception {
    VerifyingIdOrderingQueue queue=new VerifyingIdOrderingQueue(new SynchronizedArrayIdOrderingQueue());
    Committer[] committers=new Committer[20];
    CountDownLatch readySignal=new CountDownLatch(committers.length);
    AtomicBoolean end=new AtomicBoolean();
    CountDownLatch startSignal=new CountDownLatch(1);
    LongIterator idSource=neverEndingIdStream();
    for (int i=0; i < committers.length; i++) {
      committers[i]=new Committer(queue,idSource,end,readySignal,startSignal);
    }
    readySignal.await();
    startSignal.countDown();
    long startTime=currentTimeMillis();
    long endTime=startTime + SECONDS.toMillis(20);
    while (currentTimeMillis() < endTime && queue.getNumberOfOrderlyRemovedIds() < THRESHOLD) {
      Thread.sleep(100);
    }
    end.set(true);
    for (    Committer committer : committers) {
      committer.awaitFinish();
    }
    assertTrue("Would have wanted at least a few ids to be processed, but only saw " + queue.getNumberOfOrderlyRemovedIds(),queue.getNumberOfOrderlyRemovedIds() >= THRESHOLD);
  }
private static class VerifyingIdOrderingQueue implements IdOrderingQueue {
    private final IdOrderingQueue delegate;
    private final AtomicInteger removedCount=new AtomicInteger();
    private volatile long previousId=-1;
    VerifyingIdOrderingQueue(    IdOrderingQueue delegate){
      this.delegate=delegate;
    }
    @Override public void removeChecked(    long expectedValue){
      if (expectedValue < previousId) {
        assertTrue("Expected to remove head " + expectedValue + ", which should have been greater than previously seen id "+ previousId,expectedValue > previousId);
      }
      previousId=expectedValue;
      delegate.removeChecked(expectedValue);
      removedCount.incrementAndGet();
    }
    @Override public void offer(    long value){
      delegate.offer(value);
    }
    @Override public boolean isEmpty(){
      return delegate.isEmpty();
    }
    @Override public void waitFor(    long value) throws InterruptedException {
      delegate.waitFor(value);
    }
    public int getNumberOfOrderlyRemovedIds(){
      return removedCount.get();
    }
  }
  private LongIterator neverEndingIdStream(){
    return new LongIterator(){
      private final Stride stride=new Stride();
      private long next;
      @Override public boolean hasNext(){
        return true;
      }
      @Override public long next(){
        try {
          return next;
        }
  finally {
          next+=stride.next();
        }
      }
    }
;
  }
private static class Committer extends Thread {
    private final Random random=new Random();
    private final IdOrderingQueue queue;
    private final AtomicBoolean end;
    private final CountDownLatch startSignal;
    private final LongIterator idSource;
    private final CountDownLatch readySignal;
    private volatile Exception exception;
    Committer(    IdOrderingQueue queue,    LongIterator idSource,    AtomicBoolean end,    CountDownLatch readySignal,    CountDownLatch startSignal){
      this.queue=queue;
      this.idSource=idSource;
      this.end=end;
      this.readySignal=readySignal;
      this.startSignal=startSignal;
      start();
    }
    public void awaitFinish() throws Exception {
      join();
      if (exception != null) {
        throw exception;
      }
    }
    @Override public void run(){
      try {
        readySignal.countDown();
        awaitLatch(startSignal);
        while (!end.get()) {
          long id;
synchronized (queue) {
            id=idSource.next();
            queue.offer(id);
          }
          queue.waitFor(id);
          for (int i=0, max=random.nextInt(10_000); i < max; i++) {
            queue.isEmpty();
          }
          queue.removeChecked(id);
        }
      }
 catch (      Exception e) {
        this.exception=e;
      }
    }
  }
  /** 
 * Strides predictably: 1, 2, 3, ..., MAX, 1, 2, 3, ... a.s.o
 */
private static class Stride {
    private int stride;
    private final int max=5;
    public int next(){
      return (stride++ % max) + 1;
    }
  }
}
