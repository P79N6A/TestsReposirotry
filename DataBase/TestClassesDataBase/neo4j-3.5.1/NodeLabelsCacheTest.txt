public class NodeLabelsCacheTest {
  @Test public void shouldCacheSmallSetOfLabelsPerNode(){
    NodeLabelsCache cache=new NodeLabelsCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,5,CHUNK_SIZE);
    NodeLabelsCache.Client client=cache.newClient();
    long nodeId=0;
    cache.put(nodeId,new long[]{1,2,3});
    int[] readLabels=new int[3];
    cache.get(client,nodeId,readLabels);
    assertArrayEquals(new int[]{1,2,3},readLabels);
  }
  @Test public void shouldHandleLargeAmountOfLabelsPerNode(){
    int highLabelId=1000;
    NodeLabelsCache cache=new NodeLabelsCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,highLabelId,CHUNK_SIZE);
    NodeLabelsCache.Client client=cache.newClient();
    long nodeId=0;
    int[] labels=randomLabels(200,1000);
    cache.put(nodeId,asLongArray(labels));
    int[] readLabels=new int[labels.length];
    cache.get(client,nodeId,readLabels);
    assertArrayEquals(labels,readLabels);
  }
  @Test public void shouldHandleLabelsForManyNodes(){
    int highLabelId=1_000;
    NodeLabelsCache cache=new NodeLabelsCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,highLabelId,1_000_000);
    NodeLabelsCache.Client client=cache.newClient();
    int numberOfNodes=100_000;
    int[][] expectedLabels=new int[numberOfNodes][];
    for (int i=0; i < numberOfNodes; i++) {
      int[] labels=randomLabels(random.nextInt(30) + 1,highLabelId);
      expectedLabels[i]=labels;
      cache.put(i,asLongArray(labels));
    }
    int[] forceCreationOfNewIntArray=new int[0];
    for (int i=0; i < numberOfNodes; i++) {
      int[] labels=cache.get(client,i,forceCreationOfNewIntArray);
      assertArrayEquals("For node " + i,expectedLabels[i],labels);
    }
  }
  @Test public void shouldEndTargetArrayWithMinusOne(){
    NodeLabelsCache cache=new NodeLabelsCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,10);
    NodeLabelsCache.Client client=cache.newClient();
    cache.put(10,new long[]{5,6,7,8});
    int[] target=new int[20];
    assertSame(target,cache.get(client,10,target));
    assertEquals(5,target[0]);
    assertEquals(6,target[1]);
    assertEquals(7,target[2]);
    assertEquals(8,target[3]);
    assertEquals(-1,target[4]);
  }
  @Test public void shouldReturnEmptyArrayForNodeWithNoLabelsAndNoLabelsWhatsoever(){
    NodeLabelsCache cache=new NodeLabelsCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,0);
    NodeLabelsCache.Client client=cache.newClient();
    int[] target=new int[3];
    cache.get(client,0,target);
    assertEquals(-1,target[0]);
  }
  @Test public void shouldSupportConcurrentGet() throws Throwable {
    int highLabelId=10;
    int numberOfNodes=100;
    int[][] expectedLabels=new int[numberOfNodes][];
    NodeLabelsCache cache=new NodeLabelsCache(NumberArrayFactory.AUTO_WITHOUT_PAGECACHE,highLabelId);
    for (int i=0; i < numberOfNodes; i++) {
      cache.put(i,asLongArray(expectedLabels[i]=randomLabels(random.nextInt(5),highLabelId)));
    }
    Race getRace=new Race();
    for (int i=0; i < 10; i++) {
      getRace.addContestant(new LabelGetter(cache,expectedLabels,numberOfNodes));
    }
    getRace.go();
  }
private static class LabelGetter implements Runnable {
    private final NodeLabelsCache cache;
    private final int[][] expectedLabels;
    private final NodeLabelsCache.Client client;
    private final int numberOfNodes;
    private int[] scratch=new int[10];
    LabelGetter(    NodeLabelsCache cache,    int[][] expectedLabels,    int numberOfNodes){
      this.cache=cache;
      this.client=cache.newClient();
      this.expectedLabels=expectedLabels;
      this.numberOfNodes=numberOfNodes;
    }
    @Override public void run(){
      for (int i=0; i < 1_000; i++) {
        int nodeId=ThreadLocalRandom.current().nextInt(numberOfNodes);
        scratch=cache.get(client,nodeId,scratch);
        assertCorrectLabels(nodeId,scratch);
      }
    }
    private void assertCorrectLabels(    int nodeId,    int[] gotten){
      int[] expected=expectedLabels[nodeId];
      for (int i=0; i < expected.length; i++) {
        assertEquals(expected[i],gotten[i]);
      }
      if (gotten.length != expected.length) {
        assertEquals(-1,gotten[expected.length]);
      }
    }
  }
  private long[] asLongArray(  int[] labels){
    long[] result=new long[labels.length];
    for (int i=0; i < labels.length; i++) {
      result[i]=labels[i];
    }
    return result;
  }
  private int[] randomLabels(  int count,  int highId){
    int[] result=new int[count];
    for (int i=0; i < count; i++) {
      result[i]=random.nextInt(highId);
    }
    return result;
  }
  private static final int CHUNK_SIZE=100;
  private final Random random=new Random(1234);
}
