public class PathProxyTest {
  private EmbeddedProxySPI proxySPI;
  @Before public void setUp() throws Exception {
    proxySPI=mock(EmbeddedProxySPI.class);
  }
  @Test public void shouldIterateThroughNodes(){
    Path path=new PathProxy(proxySPI,new long[]{1,2,3},new long[]{100,200},new int[]{0,~0});
    Iterator<Node> iterator=path.nodes().iterator();
    Node node;
    assertTrue(iterator.hasNext());
    assertThat(node=iterator.next(),instanceOf(Node.class));
    assertEquals(1,node.getId());
    assertTrue(iterator.hasNext());
    assertThat(node=iterator.next(),instanceOf(Node.class));
    assertEquals(2,node.getId());
    assertTrue(iterator.hasNext());
    assertThat(node=iterator.next(),instanceOf(Node.class));
    assertEquals(3,node.getId());
    assertFalse(iterator.hasNext());
  }
  @Test public void shouldIterateThroughNodesInReverse(){
    Path path=new PathProxy(proxySPI,new long[]{1,2,3},new long[]{100,200},new int[]{0,~0});
    Iterator<Node> iterator=path.reverseNodes().iterator();
    Node node;
    assertTrue(iterator.hasNext());
    assertThat(node=iterator.next(),instanceOf(Node.class));
    assertEquals(3,node.getId());
    assertTrue(iterator.hasNext());
    assertThat(node=iterator.next(),instanceOf(Node.class));
    assertEquals(2,node.getId());
    assertTrue(iterator.hasNext());
    assertThat(node=iterator.next(),instanceOf(Node.class));
    assertEquals(1,node.getId());
    assertFalse(iterator.hasNext());
  }
  @Test public void shouldIterateThroughRelationships(){
    Path path=new PathProxy(proxySPI,new long[]{1,2,3},new long[]{100,200},new int[]{0,~0});
    Iterator<Relationship> iterator=path.relationships().iterator();
    Relationship relationship;
    assertTrue(iterator.hasNext());
    assertThat(relationship=iterator.next(),instanceOf(Relationship.class));
    assertEquals(100,relationship.getId());
    assertEquals(1,relationship.getStartNodeId());
    assertEquals(2,relationship.getEndNodeId());
    assertTrue(iterator.hasNext());
    assertThat(relationship=iterator.next(),instanceOf(Relationship.class));
    assertEquals(200,relationship.getId());
    assertEquals(3,relationship.getStartNodeId());
    assertEquals(2,relationship.getEndNodeId());
    assertFalse(iterator.hasNext());
  }
  @Test public void shouldIterateThroughRelationshipsInReverse(){
    Path path=new PathProxy(proxySPI,new long[]{1,2,3},new long[]{100,200},new int[]{0,~0});
    Iterator<Relationship> iterator=path.reverseRelationships().iterator();
    Relationship relationship;
    assertTrue(iterator.hasNext());
    assertThat(relationship=iterator.next(),instanceOf(Relationship.class));
    assertEquals(200,relationship.getId());
    assertEquals(3,relationship.getStartNodeId());
    assertEquals(2,relationship.getEndNodeId());
    assertTrue(iterator.hasNext());
    assertThat(relationship=iterator.next(),instanceOf(Relationship.class));
    assertEquals(100,relationship.getId());
    assertEquals(1,relationship.getStartNodeId());
    assertEquals(2,relationship.getEndNodeId());
    assertFalse(iterator.hasNext());
  }
  @Test public void shouldIterateAlternatingNodesAndRelationships(){
    Path path=new PathProxy(proxySPI,new long[]{1,2,3},new long[]{100,200},new int[]{0,~0});
    Iterator<PropertyContainer> iterator=path.iterator();
    PropertyContainer entity;
    assertTrue(iterator.hasNext());
    assertThat(entity=iterator.next(),instanceOf(Node.class));
    assertEquals(1,((Entity)entity).getId());
    assertTrue(iterator.hasNext());
    assertThat(entity=iterator.next(),instanceOf(Relationship.class));
    assertEquals(100,((Entity)entity).getId());
    assertTrue(iterator.hasNext());
    assertThat(entity=iterator.next(),instanceOf(Node.class));
    assertEquals(2,((Entity)entity).getId());
    assertTrue(iterator.hasNext());
    assertThat(entity=iterator.next(),instanceOf(Relationship.class));
    assertEquals(200,((Entity)entity).getId());
    assertTrue(iterator.hasNext());
    assertThat(entity=iterator.next(),instanceOf(Node.class));
    assertEquals(3,((Entity)entity).getId());
    assertFalse(iterator.hasNext());
  }
}
