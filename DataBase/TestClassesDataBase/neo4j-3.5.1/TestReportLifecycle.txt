public static class TestReportLifecycle {
  @Rule public final TestName testName=new TestName();
  @Test public void shouldSummarizeStatisticsAfterCheck(){
    ConsistencySummaryStatistics summary=mock(ConsistencySummaryStatistics.class);
    @SuppressWarnings("unchecked") RecordAccess records=mock(RecordAccess.class);
    ConsistencyReporter.ReportHandler handler=new ConsistencyReporter.ReportHandler(new InconsistencyReport(mock(InconsistencyLogger.class),summary),mock(ConsistencyReporter.ProxyFactory.class),RecordType.PROPERTY,records,new PropertyRecord(0),NO_MONITOR);
    handler.updateSummary();
    verify(summary).update(RecordType.PROPERTY,0,0);
    verifyNoMoreInteractions(summary);
  }
  @Test @SuppressWarnings("unchecked") public void shouldOnlySummarizeStatisticsWhenAllReferencesAreChecked(){
    ConsistencySummaryStatistics summary=mock(ConsistencySummaryStatistics.class);
    RecordAccess records=mock(RecordAccess.class);
    ConsistencyReporter.ReportHandler handler=new ConsistencyReporter.ReportHandler(new InconsistencyReport(mock(InconsistencyLogger.class),summary),mock(ConsistencyReporter.ProxyFactory.class),RecordType.PROPERTY,records,new PropertyRecord(0),NO_MONITOR);
    RecordReference<PropertyRecord> reference=mock(RecordReference.class);
    ComparativeRecordChecker<PropertyRecord,PropertyRecord,ConsistencyReport.PropertyConsistencyReport> checker=mock(ComparativeRecordChecker.class);
    handler.comparativeCheck(reference,checker);
    ArgumentCaptor<PendingReferenceCheck<PropertyRecord>> captor=(ArgumentCaptor)ArgumentCaptor.forClass(PendingReferenceCheck.class);
    verify(reference).dispatch(captor.capture());
    PendingReferenceCheck pendingRefCheck=captor.getValue();
    handler.updateSummary();
    verifyZeroInteractions(summary);
    pendingRefCheck.skip();
    verify(summary).update(RecordType.PROPERTY,0,0);
    verifyNoMoreInteractions(summary);
  }
  @Test public void shouldIncludeStackTraceInUnexpectedCheckException(){
    ConsistencySummaryStatistics summary=mock(ConsistencySummaryStatistics.class);
    RecordAccess records=mock(RecordAccess.class);
    final AtomicReference<String> loggedError=new AtomicReference<>();
    InconsistencyLogger logger=new InconsistencyLogger(){
      @Override public void error(      RecordType recordType,      AbstractBaseRecord record,      String message,      Object[] args){
        assertTrue(loggedError.compareAndSet(null,message));
      }
      @Override public void error(      RecordType recordType,      AbstractBaseRecord oldRecord,      AbstractBaseRecord newRecord,      String message,      Object[] args){
        assertTrue(loggedError.compareAndSet(null,message));
      }
      @Override public void warning(      RecordType recordType,      AbstractBaseRecord record,      String message,      Object[] args){
      }
      @Override public void warning(      RecordType recordType,      AbstractBaseRecord oldRecord,      AbstractBaseRecord newRecord,      String message,      Object[] args){
      }
    }
;
    InconsistencyReport inconsistencyReport=new InconsistencyReport(logger,summary);
    ConsistencyReporter reporter=new ConsistencyReporter(records,inconsistencyReport);
    NodeRecord node=new NodeRecord(10);
    RecordCheck<NodeRecord,NodeConsistencyReport> checker=mock(RecordCheck.class);
    RuntimeException exception=new RuntimeException("My specific exception");
    doThrow(exception).when(checker).check(any(NodeRecord.class),any(CheckerEngine.class),any(RecordAccess.class));
    reporter.forNode(node,checker);
    assertNotNull(loggedError.get());
    String error=loggedError.get();
    assertThat(error,containsString("at "));
    assertThat(error,containsString(testName.getMethodName()));
  }
}
