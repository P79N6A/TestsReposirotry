public abstract class RandomRelationshipTraversalCursorTestBase<G extends KernelAPIReadTestSupport> extends KernelAPIReadTestBase<G> {
  private static final int N_TRAVERSALS=10_000;
  private static int N_NODES=100;
  private static int N_RELATIONSHIPS=1000;
  private static long seed=(new Random()).nextInt();
  private static Random random=new Random(seed);
  private static List<Long> nodeIds=new ArrayList<>();
  @Override public void createTestGraph(  GraphDatabaseService graphDb){
    try (Transaction tx=graphDb.beginTx()){
      for (int i=0; i < N_NODES; i++) {
        nodeIds.add(graphDb.createNode(Label.label("LABEL" + i)).getId());
      }
      tx.success();
    }
     try (Transaction tx=graphDb.beginTx()){
      for (int i=0; i < N_RELATIONSHIPS; i++) {
        Long source=nodeIds.get(random.nextInt(N_NODES));
        Long target=nodeIds.get(random.nextInt(N_NODES));
        graphDb.getNodeById(source).createRelationshipTo(graphDb.getNodeById(target),RelationshipType.withName("REL" + (i % 10)));
      }
      tx.success();
    }
   }
  @Test public void shouldManageRandomTraversals(){
    try (NodeCursor node=cursors.allocateNodeCursor();RelationshipGroupCursor group=cursors.allocateRelationshipGroupCursor();RelationshipTraversalCursor relationship=cursors.allocateRelationshipTraversalCursor()){
      for (int i=0; i < N_TRAVERSALS; i++) {
        long nodeId=nodeIds.get(random.nextInt(N_NODES));
        read.singleNode(nodeId,node);
        assertTrue("access root node",node.next());
        node.relationships(group);
        assertFalse("single root",node.next());
        while (group.next()) {
          group.incoming(relationship);
          while (relationship.next()) {
            assertEquals("incoming origin",nodeId,relationship.originNodeReference());
            relationship.neighbour(node);
          }
          group.outgoing(relationship);
          while (relationship.next()) {
            assertEquals("outgoing origin",nodeId,relationship.originNodeReference());
            relationship.neighbour(node);
          }
          group.loops(relationship);
          while (relationship.next()) {
            assertEquals("loop origin",nodeId,relationship.originNodeReference());
            relationship.neighbour(node);
          }
        }
      }
    }
 catch (    Throwable t) {
      throw new RuntimeException("Failed with random seed " + seed,t);
    }
  }
}
