public class PhysicalFlushableChannelTest {
  @Rule public final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public final TestDirectory directory=TestDirectory.testDirectory();
  @Test public void shouldBeAbleToWriteSmallNumberOfBytes() throws IOException {
    final File firstFile=new File(directory.directory(),"file1");
    StoreChannel storeChannel=fileSystemRule.get().open(firstFile,OpenMode.READ_WRITE);
    PhysicalLogVersionedStoreChannel versionedStoreChannel=new PhysicalLogVersionedStoreChannel(storeChannel,1,(byte)-1);
    PhysicalFlushableChannel channel=new PhysicalFlushableChannel(versionedStoreChannel);
    int length=26_145;
    byte[] bytes=generateBytes(length);
    channel.put(bytes,length);
    channel.close();
    byte[] writtenBytes=new byte[length];
    try (InputStream in=new FileInputStream(firstFile)){
      in.read(writtenBytes);
    }
     assertArrayEquals(bytes,writtenBytes);
  }
  @Test public void shouldBeAbleToWriteValuesGreaterThanHalfTheBufferSize() throws IOException {
    final File firstFile=new File(directory.directory(),"file1");
    StoreChannel storeChannel=fileSystemRule.get().open(firstFile,OpenMode.READ_WRITE);
    PhysicalLogVersionedStoreChannel versionedStoreChannel=new PhysicalLogVersionedStoreChannel(storeChannel,1,(byte)-1);
    PhysicalFlushableChannel channel=new PhysicalFlushableChannel(versionedStoreChannel);
    int length=262_145;
    byte[] bytes=generateBytes(length);
    channel.put(bytes,length);
    channel.close();
    byte[] writtenBytes=new byte[length];
    try (InputStream in=new FileInputStream(firstFile)){
      in.read(writtenBytes);
    }
     assertArrayEquals(bytes,writtenBytes);
  }
  @Test public void shouldBeAbleToWriteValuesGreaterThanTheBufferSize() throws IOException {
    final File firstFile=new File(directory.directory(),"file1");
    StoreChannel storeChannel=fileSystemRule.get().open(firstFile,OpenMode.READ_WRITE);
    PhysicalLogVersionedStoreChannel versionedStoreChannel=new PhysicalLogVersionedStoreChannel(storeChannel,1,(byte)-1);
    PhysicalFlushableChannel channel=new PhysicalFlushableChannel(versionedStoreChannel);
    int length=1_000_000;
    byte[] bytes=generateBytes(length);
    channel.put(bytes,length);
    channel.close();
    byte[] writtenBytes=new byte[length];
    try (InputStream in=new FileInputStream(firstFile)){
      in.read(writtenBytes);
    }
     assertArrayEquals(bytes,writtenBytes);
  }
  private byte[] generateBytes(  int length){
    Random random=new Random();
    char[] validCharacters=new char[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o'};
    byte[] bytes=new byte[length];
    for (int i=0; i < length; i++) {
      bytes[i]=(byte)validCharacters[random.nextInt(validCharacters.length)];
    }
    return bytes;
  }
  @Test public void shouldWriteThroughRotation() throws Exception {
    final File firstFile=new File(directory.directory(),"file1");
    final File secondFile=new File(directory.directory(),"file2");
    StoreChannel storeChannel=fileSystemRule.get().open(firstFile,OpenMode.READ_WRITE);
    PhysicalLogVersionedStoreChannel versionedStoreChannel=new PhysicalLogVersionedStoreChannel(storeChannel,1,(byte)-1);
    PhysicalFlushableChannel channel=new PhysicalFlushableChannel(versionedStoreChannel);
    byte byteValue=(byte)4;
    short shortValue=(short)10;
    int intValue=3545;
    long longValue=45849589L;
    float floatValue=45849.332f;
    double doubleValue=458493343D;
    byte[] byteArrayValue=new byte[]{1,4,2,5,3,6};
    channel.put(byteValue);
    channel.putShort(shortValue);
    channel.putInt(intValue);
    channel.putLong(longValue);
    channel.prepareForFlush().flush();
    channel.close();
    storeChannel=fileSystemRule.get().open(secondFile,OpenMode.READ_WRITE);
    channel.setChannel(new PhysicalLogVersionedStoreChannel(storeChannel,2,(byte)-1));
    channel.putFloat(floatValue);
    channel.putDouble(doubleValue);
    channel.put(byteArrayValue,byteArrayValue.length);
    channel.close();
    ByteBuffer firstFileContents=readFile(firstFile);
    assertEquals(byteValue,firstFileContents.get());
    assertEquals(shortValue,firstFileContents.getShort());
    assertEquals(intValue,firstFileContents.getInt());
    assertEquals(longValue,firstFileContents.getLong());
    ByteBuffer secondFileContents=readFile(secondFile);
    assertEquals(floatValue,secondFileContents.getFloat(),0.0f);
    assertEquals(doubleValue,secondFileContents.getDouble(),0.0d);
    byte[] readByteArray=new byte[byteArrayValue.length];
    secondFileContents.get(readByteArray);
    assertArrayEquals(byteArrayValue,readByteArray);
  }
  @Test public void shouldSeeCorrectPositionEvenBeforeEmptyingDataIntoChannel() throws Exception {
    final File file=new File(directory.directory(),"file");
    StoreChannel storeChannel=fileSystemRule.get().open(file,OpenMode.READ_WRITE);
    PhysicalLogVersionedStoreChannel versionedStoreChannel=new PhysicalLogVersionedStoreChannel(storeChannel,1,(byte)-1);
    PositionAwarePhysicalFlushableChannel channel=new PositionAwarePhysicalFlushableChannel(versionedStoreChannel);
    LogPositionMarker positionMarker=new LogPositionMarker();
    LogPosition initialPosition=channel.getCurrentPosition(positionMarker).newPosition();
    channel.putLong(67);
    channel.putInt(1234);
    LogPosition positionAfterSomeData=channel.getCurrentPosition(positionMarker).newPosition();
    assertEquals(12,positionAfterSomeData.getByteOffset() - initialPosition.getByteOffset());
    channel.close();
  }
  @Test public void shouldThrowIllegalStateExceptionAfterClosed() throws Exception {
    final File file=new File(directory.directory(),"file");
    StoreChannel storeChannel=fileSystemRule.get().open(file,OpenMode.READ_WRITE);
    PhysicalLogVersionedStoreChannel versionedStoreChannel=new PhysicalLogVersionedStoreChannel(storeChannel,1,(byte)-1);
    PhysicalFlushableChannel channel=new PhysicalFlushableChannel(versionedStoreChannel);
    channel.close();
    storeChannel.close();
    channel.put((byte)0);
    try {
      channel.prepareForFlush();
      fail("Should have thrown exception");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void shouldThrowClosedChannelExceptionWhenChannelUnexpectedlyClosed() throws Exception {
    final File file=new File(directory.directory(),"file");
    StoreChannel storeChannel=fileSystemRule.get().open(file,OpenMode.READ_WRITE);
    PhysicalLogVersionedStoreChannel versionedStoreChannel=new PhysicalLogVersionedStoreChannel(storeChannel,1,(byte)-1);
    PhysicalFlushableChannel channel=new PhysicalFlushableChannel(versionedStoreChannel);
    storeChannel.close();
    channel.put((byte)0);
    try {
      channel.prepareForFlush();
      fail("Should have thrown exception");
    }
 catch (    ClosedChannelException e) {
    }
  }
  private ByteBuffer readFile(  File file) throws IOException {
    try (StoreChannel channel=fileSystemRule.get().open(file,OpenMode.READ)){
      ByteBuffer buffer=ByteBuffer.allocate((int)channel.size());
      channel.readAll(buffer);
      buffer.flip();
      return buffer;
    }
   }
}
