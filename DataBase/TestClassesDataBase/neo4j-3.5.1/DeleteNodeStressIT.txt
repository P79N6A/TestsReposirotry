public class DeleteNodeStressIT {
  private final ExecutorService executorService=Executors.newFixedThreadPool(10);
  @Rule public ImpermanentDatabaseRule db=new ImpermanentDatabaseRule();
  @Before public void setup(){
    for (int i=0; i < 100; i++) {
      try (Transaction tx=db.beginTx()){
        for (int j=0; j < 100; j++) {
          Node node=db.createNode(label("L"));
          node.setProperty("prop",i + j);
        }
        tx.success();
      }
     }
  }
  @After public void tearDown(){
    executorService.shutdown();
  }
  @Test public void shouldBeAbleToReturnNodesWhileDeletingNode() throws InterruptedException, ExecutionException {
    Future query1=executeInThread("MATCH (n:L {prop:42}) OPTIONAL MATCH (m:L {prop:1337}) WITH n MATCH (n) return n");
    Future query2=executeInThread("MATCH (n:L {prop:42}) DELETE n");
    query1.get();
    query2.get();
  }
  @Test public void shouldBeAbleToCheckPropertiesWhileDeletingNode() throws InterruptedException, ExecutionException {
    Future query1=executeInThread("MATCH (n:L {prop:42}) OPTIONAL MATCH (m:L {prop:1337}) WITH n MATCH (n) RETURN exists(n.prop)");
    Future query2=executeInThread("MATCH (n:L {prop:42}) DELETE n");
    query1.get();
    query2.get();
  }
  @Test public void shouldBeAbleToRemovePropertiesWhileDeletingNode() throws InterruptedException, ExecutionException {
    Future query1=executeInThread("MATCH (n:L {prop:42}) OPTIONAL MATCH (m:L {prop:1337}) WITH n MATCH (n) REMOVE n.prop");
    Future query2=executeInThread("MATCH (n:L {prop:42}) DELETE n");
    query1.get();
    query2.get();
  }
  @Test public void shouldBeAbleToSetPropertiesWhileDeletingNode() throws InterruptedException, ExecutionException {
    Future query1=executeInThread("MATCH (n:L {prop:42}) OPTIONAL MATCH (m:L {prop:1337}) WITH n MATCH (n) SET n.foo = 'bar'");
    Future query2=executeInThread("MATCH (n:L {prop:42}) DELETE n");
    query1.get();
    query2.get();
  }
  @Test public void shouldBeAbleToCheckLabelsWhileDeleting() throws InterruptedException, ExecutionException {
    Future query1=executeInThread("MATCH (n:L {prop:42}) OPTIONAL MATCH (m:L {prop:1337}) WITH n RETURN labels(n)");
    Future query2=executeInThread("MATCH (n:L {prop:42}) DELETE n");
    query1.get();
    query2.get();
  }
  private Future executeInThread(  final String query){
    return executorService.submit(() -> db.execute(query).resultAsString());
  }
}
