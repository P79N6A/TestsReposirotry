public class ConstraintIndexCreatorTest {
  private static final int PROPERTY_KEY_ID=456;
  private static final int LABEL_ID=123;
  private static final long INDEX_ID=0L;
  private final LabelSchemaDescriptor descriptor=SchemaDescriptorFactory.forLabel(LABEL_ID,PROPERTY_KEY_ID);
  private final IndexDescriptor index=TestIndexDescriptorFactory.uniqueForLabel(LABEL_ID,PROPERTY_KEY_ID);
  private final IndexReference indexReference=TestIndexDescriptorFactory.uniqueForLabel(LABEL_ID,PROPERTY_KEY_ID);
  private final SchemaRead schemaRead=schemaRead();
  private final SchemaWrite schemaWrite=mock(SchemaWrite.class);
  private final TokenRead tokenRead=mock(TokenRead.class);
  private final AssertableLogProvider logProvider=new AssertableLogProvider();
  @Test public void shouldCreateIndexInAnotherTransaction() throws Exception {
    StubKernel kernel=new StubKernel();
    IndexProxy indexProxy=mock(IndexProxy.class);
    IndexingService indexingService=mock(IndexingService.class);
    when(indexingService.getIndexProxy(INDEX_ID)).thenReturn(indexProxy);
    when(indexingService.getIndexProxy(descriptor)).thenReturn(indexProxy);
    when(indexProxy.getDescriptor()).thenReturn(index.withId(INDEX_ID).withoutCapabilities());
    NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
    long indexId=creator.createUniquenessConstraintIndex(createTransaction(),descriptor,getDefaultProvider());
    assertEquals(INDEX_ID,indexId);
    verify(schemaRead).indexGetCommittedId(indexReference);
    verify(schemaRead).index(descriptor);
    verifyNoMoreInteractions(schemaRead);
    verify(indexProxy).awaitStoreScanCompleted();
  }
  @Test public void shouldDropIndexIfPopulationFails() throws Exception {
    StubKernel kernel=new StubKernel();
    IndexingService indexingService=mock(IndexingService.class);
    IndexProxy indexProxy=mock(IndexProxy.class);
    when(indexingService.getIndexProxy(INDEX_ID)).thenReturn(indexProxy);
    when(indexingService.getIndexProxy(descriptor)).thenReturn(indexProxy);
    when(indexProxy.getDescriptor()).thenReturn(index.withId(INDEX_ID).withoutCapabilities());
    IndexEntryConflictException cause=new IndexEntryConflictException(2,1,Values.of("a"));
    doThrow(new IndexPopulationFailedKernelException("some index",cause)).when(indexProxy).awaitStoreScanCompleted();
    NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
    when(schemaRead.index(any(SchemaDescriptor.class))).thenReturn(IndexReference.NO_INDEX).thenReturn(indexReference);
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
    KernelTransactionImplementation transaction=createTransaction();
    try {
      creator.createUniquenessConstraintIndex(transaction,descriptor,getDefaultProvider());
      fail("expected exception");
    }
 catch (    UniquePropertyValueValidationException e) {
      assertEquals("Existing data does not satisfy CONSTRAINT ON ( label[123]:label[123] ) " + "ASSERT label[123].property[456] IS UNIQUE: Both node 2 and node 1 share the property value ( String(\"a\") )",e.getMessage());
    }
    assertEquals(2,kernel.transactions.size());
    KernelTransactionImplementation tx1=kernel.transactions.get(0);
    SchemaDescriptor newIndex=index.schema();
    verify(tx1).indexUniqueCreate(eq(newIndex),eq(getDefaultProvider()));
    verify(schemaRead).indexGetCommittedId(indexReference);
    verify(schemaRead,times(2)).index(descriptor);
    verifyNoMoreInteractions(schemaRead);
    TransactionState tx2=kernel.transactions.get(1).txState();
    verify(tx2).indexDoDrop(index);
    verifyNoMoreInteractions(tx2);
  }
  @Test public void shouldDropIndexInAnotherTransaction() throws Exception {
    StubKernel kernel=new StubKernel();
    IndexingService indexingService=mock(IndexingService.class);
    NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
    creator.dropUniquenessConstraintIndex(index);
    assertEquals(1,kernel.transactions.size());
    verify(kernel.transactions.get(0).txState()).indexDoDrop(index);
    verifyZeroInteractions(indexingService);
  }
  @Test public void shouldReleaseLabelLockWhileAwaitingIndexPopulation() throws Exception {
    StubKernel kernel=new StubKernel();
    IndexingService indexingService=mock(IndexingService.class);
    NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
    when(schemaRead.indexGetCommittedId(indexReference)).thenReturn(INDEX_ID);
    IndexProxy indexProxy=mock(IndexProxy.class);
    when(indexingService.getIndexProxy(anyLong())).thenReturn(indexProxy);
    when(indexingService.getIndexProxy(descriptor)).thenReturn(indexProxy);
    when(schemaRead.index(LABEL_ID,PROPERTY_KEY_ID)).thenReturn(IndexReference.NO_INDEX);
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
    KernelTransactionImplementation transaction=createTransaction();
    creator.createUniquenessConstraintIndex(transaction,descriptor,getDefaultProvider());
    verify(transaction.statementLocks().pessimistic()).releaseExclusive(ResourceTypes.LABEL,descriptor.getLabelId());
    verify(transaction.statementLocks().pessimistic()).acquireExclusive(transaction.lockTracer(),ResourceTypes.LABEL,descriptor.getLabelId());
  }
  @Test public void shouldReuseExistingOrphanedConstraintIndex() throws Exception {
    IndexingService indexingService=mock(IndexingService.class);
    StubKernel kernel=new StubKernel();
    long orphanedConstraintIndexId=111;
    when(schemaRead.indexGetCommittedId(indexReference)).thenReturn(orphanedConstraintIndexId);
    IndexProxy indexProxy=mock(IndexProxy.class);
    when(indexingService.getIndexProxy(orphanedConstraintIndexId)).thenReturn(indexProxy);
    NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
    when(schemaRead.index(descriptor)).thenReturn(indexReference);
    when(schemaRead.indexGetOwningUniquenessConstraintId(indexReference)).thenReturn(null);
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
    KernelTransactionImplementation transaction=createTransaction();
    long indexId=creator.createUniquenessConstraintIndex(transaction,descriptor,getDefaultProvider());
    assertEquals(orphanedConstraintIndexId,indexId);
    assertEquals("There should have been no need to acquire a statement to create the constraint index",0,kernel.transactions.size());
    verify(schemaRead).indexGetCommittedId(indexReference);
    verify(schemaRead).index(descriptor);
    verify(schemaRead).indexGetOwningUniquenessConstraintId(indexReference);
    verifyNoMoreInteractions(schemaRead);
    verify(indexProxy).awaitStoreScanCompleted();
  }
  @Test public void shouldFailOnExistingOwnedConstraintIndex() throws Exception {
    IndexingService indexingService=mock(IndexingService.class);
    StubKernel kernel=new StubKernel();
    long constraintIndexId=111;
    long constraintIndexOwnerId=222;
    when(schemaRead.indexGetCommittedId(indexReference)).thenReturn(constraintIndexId);
    IndexProxy indexProxy=mock(IndexProxy.class);
    when(indexingService.getIndexProxy(constraintIndexId)).thenReturn(indexProxy);
    NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
    when(schemaRead.index(descriptor)).thenReturn(indexReference);
    when(schemaRead.indexGetOwningUniquenessConstraintId(indexReference)).thenReturn(constraintIndexOwnerId);
    when(tokenRead.nodeLabelName(LABEL_ID)).thenReturn("MyLabel");
    when(tokenRead.propertyKeyName(PROPERTY_KEY_ID)).thenReturn("MyKey");
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
    try {
      KernelTransactionImplementation transaction=createTransaction();
      creator.createUniquenessConstraintIndex(transaction,descriptor,getDefaultProvider());
      fail("Should've failed");
    }
 catch (    AlreadyConstrainedException e) {
    }
    assertEquals("There should have been no need to acquire a statement to create the constraint index",0,kernel.transactions.size());
    verify(schemaRead).index(descriptor);
    verify(schemaRead).indexGetOwningUniquenessConstraintId(indexReference);
    verifyNoMoreInteractions(schemaRead);
  }
  @Test public void shouldCreateConstraintIndexForSpecifiedProvider() throws Exception {
    IndexingService indexingService=mock(IndexingService.class);
    StubKernel kernel=new StubKernel();
    when(schemaRead.indexGetCommittedId(indexReference)).thenReturn(INDEX_ID);
    IndexProxy indexProxy=mock(IndexProxy.class);
    when(indexingService.getIndexProxy(INDEX_ID)).thenReturn(indexProxy);
    when(indexingService.getIndexProxy(descriptor)).thenReturn(indexProxy);
    NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("Groovy","1.2");
    KernelTransactionImplementation transaction=createTransaction();
    creator.createUniquenessConstraintIndex(transaction,descriptor,providerDescriptor.name());
    assertEquals(1,kernel.transactions.size());
    KernelTransactionImplementation transactionInstance=kernel.transactions.get(0);
    verify(transactionInstance).indexUniqueCreate(eq(descriptor),eq(providerDescriptor.name()));
    verify(schemaRead).index(descriptor);
    verify(schemaRead).indexGetCommittedId(any());
    verifyNoMoreInteractions(schemaRead);
  }
  @Test public void logMessagesAboutConstraintCreation() throws SchemaKernelException, UniquePropertyValueValidationException, TransactionFailureException, IndexNotFoundKernelException {
    StubKernel kernel=new StubKernel();
    IndexProxy indexProxy=mock(IndexProxy.class);
    IndexingService indexingService=mock(IndexingService.class);
    when(indexingService.getIndexProxy(INDEX_ID)).thenReturn(indexProxy);
    when(indexingService.getIndexProxy(descriptor)).thenReturn(indexProxy);
    when(indexProxy.getDescriptor()).thenReturn(index.withId(INDEX_ID).withoutCapabilities());
    NodePropertyAccessor propertyAccessor=mock(NodePropertyAccessor.class);
    ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,propertyAccessor,logProvider);
    KernelTransactionImplementation transaction=createTransaction();
    creator.createUniquenessConstraintIndex(transaction,descriptor,"indexProviderByName-1.0");
    logProvider.assertContainsLogCallContaining("Starting constraint creation: %s.");
    logProvider.assertContainsLogCallContaining("Constraint %s populated, starting verification.");
    logProvider.assertContainsLogCallContaining("Constraint %s verified.");
  }
private class StubKernel implements Kernel {
    private final List<KernelTransactionImplementation> transactions=new ArrayList<>();
    private KernelTransaction remember(    KernelTransactionImplementation kernelTransaction){
      transactions.add(kernelTransaction);
      return kernelTransaction;
    }
    @Override public Transaction beginTransaction(    Transaction.Type type,    LoginContext loginContext){
      return remember(createTransaction());
    }
  }
  private SchemaRead schemaRead(){
    SchemaRead schemaRead=mock(SchemaRead.class);
    when(schemaRead.index(descriptor)).thenReturn(IndexReference.NO_INDEX);
    try {
      when(schemaRead.indexGetCommittedId(indexReference)).thenReturn(INDEX_ID);
    }
 catch (    SchemaKernelException e) {
      throw new AssertionError(e);
    }
    return schemaRead;
  }
  private KernelTransactionImplementation createTransaction(){
    KernelTransactionImplementation transaction=mock(KernelTransactionImplementation.class);
    try {
      TransactionHeaderInformation headerInformation=new TransactionHeaderInformation(-1,-1,new byte[0]);
      TransactionHeaderInformationFactory headerInformationFactory=mock(TransactionHeaderInformationFactory.class);
      when(headerInformationFactory.create()).thenReturn(headerInformation);
      StorageEngine storageEngine=mock(StorageEngine.class);
      StorageReader storageReader=mock(StorageReader.class);
      when(storageEngine.newReader()).thenReturn(storageReader);
      SimpleStatementLocks locks=new SimpleStatementLocks(mock(org.neo4j.kernel.impl.locking.Locks.Client.class));
      when(transaction.statementLocks()).thenReturn(locks);
      when(transaction.tokenRead()).thenReturn(tokenRead);
      when(transaction.schemaRead()).thenReturn(schemaRead);
      when(transaction.schemaWrite()).thenReturn(schemaWrite);
      TransactionState transactionState=mock(TransactionState.class);
      when(transaction.txState()).thenReturn(transactionState);
      when(transaction.indexUniqueCreate(any(SchemaDescriptor.class),any(String.class))).thenAnswer(i -> IndexDescriptorFactory.uniqueForSchema(i.getArgument(0)));
    }
 catch (    InvalidTransactionTypeKernelException e) {
      fail("Expected write transaction");
    }
    return transaction;
  }
  private static String getDefaultProvider(){
    return Config.defaults().get(GraphDatabaseSettings.default_schema_provider);
  }
}
