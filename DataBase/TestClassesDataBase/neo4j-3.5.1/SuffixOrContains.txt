@Nested class SuffixOrContains {
  @Test void shouldComputeIndexUpdatesForRangeSeekByContainsWhenThereAreNoMatchingNodes(){
    final ReadableTransactionState state=new TxStateBuilder().withAdded(42L,"foo").withAdded(43L,"bar").build();
    IndexQuery.StringContainsPredicate indexQuery=IndexQuery.stringContains(index.schema().getPropertyId(),stringValue("eulav"));
    AddedAndRemoved changes=indexUpdatesForSuffixOrContains(state,index,indexQuery,IndexOrder.NONE);
    AddedWithValuesAndRemoved changesWithValues=indexUpdatesWithValuesForSuffixOrContains(state,index,indexQuery,IndexOrder.NONE);
    assertTrue(changes.getAdded().isEmpty());
    assertFalse(changesWithValues.getAdded().iterator().hasNext());
  }
  @Test void shouldComputeIndexUpdatesForRangeSeekBySuffixWhenThereArePartiallyMatchingNewNodes(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(40L,"Aaron").withAdded(41L,"Agatha").withAdded(42L,"Andreas").withAdded(43L,"Andrea").withAdded(44L,"Aristotle").withAdded(45L,"Barbara").withAdded(46L,"Barbarella").withAdded(47L,"Cinderella").build();
    IndexQuery.StringSuffixPredicate indexQuery=IndexQuery.stringSuffix(index.schema().getPropertyId(),stringValue("ella"));
    AddedAndRemoved changes=indexUpdatesForSuffixOrContains(state,index,indexQuery,IndexOrder.NONE);
    AddedWithValuesAndRemoved changesWithValues=indexUpdatesWithValuesForSuffixOrContains(state,index,indexQuery,IndexOrder.NONE);
    assertContains(changes.getAdded(),46L,47L);
    assertContains(changesWithValues.getAdded(),nodeWithPropertyValues(46L,"Barbarella"),nodeWithPropertyValues(47L,"Cinderella"));
  }
  @Test void shouldComputeIndexUpdatesForSuffixWithAscendingOrder(){
    assertRangeSeekBySuffixForOrder(IndexOrder.ASCENDING);
  }
  @Test void shouldComputeIndexUpdatesForSuffixWithDescendingOrder(){
    assertRangeSeekBySuffixForOrder(IndexOrder.DESCENDING);
  }
  private void assertRangeSeekBySuffixForOrder(  IndexOrder indexOrder){
    ReadableTransactionState state=new TxStateBuilder().withAdded(40L,"Aaron").withAdded(41L,"Bonbon").withAdded(42L,"Crayfish").withAdded(43L,"Mayonnaise").withAdded(44L,"Seashell").withAdded(45L,"Ton").withAdded(46L,"Macron").withAdded(47L,"Tony").withAdded(48L,"Evon").withAdded(49L,"Andromeda").build();
    IndexQuery indexQuery=IndexQuery.stringSuffix(index.schema().getPropertyId(),stringValue("on"));
    AddedAndRemoved changes=indexUpdatesForSuffixOrContains(state,index,indexQuery,indexOrder);
    AddedWithValuesAndRemoved changesWithValues=indexUpdatesWithValuesForSuffixOrContains(state,index,indexQuery,indexOrder);
    NodeWithPropertyValues[] expected={nodeWithPropertyValues(40L,"Aaron"),nodeWithPropertyValues(41L,"Bonbon"),nodeWithPropertyValues(48L,"Evon"),nodeWithPropertyValues(46L,"Macron"),nodeWithPropertyValues(45L,"Ton")};
    assertContains(indexOrder,changes,changesWithValues,expected);
  }
  @Test void shouldComputeIndexUpdatesForRangeSeekByContainsWhenThereArePartiallyMatchingNewNodes(){
    ReadableTransactionState state=new TxStateBuilder().withAdded(40L,"Aaron").withAdded(41L,"Agatha").withAdded(42L,"Andreas").withAdded(43L,"Andrea").withAdded(44L,"Aristotle").withAdded(45L,"Barbara").withAdded(46L,"Barbarella").withAdded(47L,"Cinderella").build();
    IndexQuery.StringContainsPredicate indexQuery=IndexQuery.stringContains(index.schema().getPropertyId(),stringValue("arbar"));
    AddedAndRemoved changes=indexUpdatesForSuffixOrContains(state,index,indexQuery,IndexOrder.NONE);
    AddedWithValuesAndRemoved changesWithValues=indexUpdatesWithValuesForSuffixOrContains(state,index,indexQuery,IndexOrder.NONE);
    assertContains(changes.getAdded(),45L,46L);
    assertContains(changesWithValues.getAdded(),nodeWithPropertyValues(45L,"Barbara"),nodeWithPropertyValues(46L,"Barbarella"));
  }
  @Test void shouldComputeIndexUpdatesForContainsWithAscendingOrder(){
    assertRangeSeekByContainsForOrder(IndexOrder.ASCENDING);
  }
  @Test void shouldComputeIndexUpdatesForContainsWithDescendingOrder(){
    assertRangeSeekByContainsForOrder(IndexOrder.DESCENDING);
  }
  private void assertRangeSeekByContainsForOrder(  IndexOrder indexOrder){
    ReadableTransactionState state=new TxStateBuilder().withAdded(40L,"Smashing").withAdded(41L,"Bashley").withAdded(42L,"Crasch").withAdded(43L,"Mayonnaise").withAdded(44L,"Seashell").withAdded(45L,"Ton").withAdded(46L,"The Flash").withAdded(47L,"Strayhound").withAdded(48L,"Trashy").withAdded(49L,"Andromeda").build();
    IndexQuery indexQuery=IndexQuery.stringContains(index.schema().getPropertyId(),stringValue("ash"));
    AddedAndRemoved changes=indexUpdatesForSuffixOrContains(state,index,indexQuery,indexOrder);
    AddedWithValuesAndRemoved changesWithValues=indexUpdatesWithValuesForSuffixOrContains(state,index,indexQuery,indexOrder);
    NodeWithPropertyValues[] expected={nodeWithPropertyValues(41L,"Bashley"),nodeWithPropertyValues(44L,"Seashell"),nodeWithPropertyValues(40L,"Smashing"),nodeWithPropertyValues(46L,"The Flash"),nodeWithPropertyValues(48L,"Trashy")};
    assertContains(indexOrder,changes,changesWithValues,expected);
  }
}
