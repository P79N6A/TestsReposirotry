public class KeyValueMergerTest {
  @Test public void shouldMergeEmptyProviders() throws Exception {
    KeyValueMerger merger=new KeyValueMerger(provider(),provider(),4,4);
    List<Integer> data=extract(merger);
    assertEquals(Arrays.<Integer>asList(),data);
  }
  @Test public void shouldProvideUpdatesWhenNoDataProvided() throws Exception {
    KeyValueMerger merger=new KeyValueMerger(provider(),provider(pair(14,1),pair(19,2),pair(128,3)),4,4);
    List<Integer> data=extract(merger);
    assertEquals(asList(14,1,19,2,128,3),data);
  }
  @Test public void shouldProvideUpdatesWhenNoChangesProvided() throws Exception {
    KeyValueMerger merger=new KeyValueMerger(provider(pair(14,1),pair(19,2),pair(128,3)),provider(),4,4);
    List<Integer> data=extract(merger);
    assertEquals(asList(14,1,19,2,128,3),data);
  }
  @Test public void shouldMergeDataStreams() throws Exception {
    KeyValueMerger merger=new KeyValueMerger(provider(pair(1,1),pair(3,1),pair(5,1)),provider(pair(2,2),pair(4,2),pair(6,2)),4,4);
    List<Integer> data=extract(merger);
    assertEquals(asList(1,1,2,2,3,1,4,2,5,1,6,2),data);
  }
  @Test public void shouldReplaceValuesOnEqualKey() throws Exception {
    KeyValueMerger merger=new KeyValueMerger(provider(pair(1,1),pair(3,1),pair(5,1)),provider(pair(2,2),pair(3,2),pair(6,2)),4,4);
    List<Integer> data=extract(merger);
    assertEquals(asList(1,1,2,2,3,2,5,1,6,2),data);
  }
  private static List<Integer> extract(  EntryVisitor<WritableBuffer> producer) throws IOException {
    List<Integer> result=new ArrayList<>();
    BigEndianByteArrayBuffer key=new BigEndianByteArrayBuffer(4);
    BigEndianByteArrayBuffer value=new BigEndianByteArrayBuffer(4);
    while (producer.visit(key,value)) {
      result.add(key.getInt(0));
      result.add(value.getInt(0));
    }
    return result;
  }
  static DataProvider provider(  final Pair... data){
    return new DataProvider(){
      int i;
      @Override public boolean visit(      WritableBuffer key,      WritableBuffer value){
        if (i < data.length) {
          data[i++].visit(key,value);
          return true;
        }
        return false;
      }
      @Override public void close(){
      }
    }
;
  }
static class Pair {
    static Pair pair(    int key,    int value){
      return new Pair(key,value);
    }
    final int key;
    int value;
    Pair(    int key,    int value){
      this.key=key;
      this.value=value;
    }
    void visit(    WritableBuffer key,    WritableBuffer value){
      key.putInt(0,this.key);
      value.putInt(0,this.value);
    }
  }
}
