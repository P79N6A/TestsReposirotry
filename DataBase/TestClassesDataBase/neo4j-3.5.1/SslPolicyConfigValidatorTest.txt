public class SslPolicyConfigValidatorTest {
  @SuppressWarnings("unchecked") private Consumer<String> warnings=mock(Consumer.class);
  @Test public void shouldAcceptAllValidPolicyKeys(){
    SslPolicyConfigValidator validator=new SslPolicyConfigValidator();
    Map<String,String> originalParams=params("dbms.ssl.policy.default.base_directory","xyz","dbms.ssl.policy.default.allow_key_generation","xyz","dbms.ssl.policy.default.trust_all","xyz","dbms.ssl.policy.default.private_key","xyz","dbms.ssl.policy.default.private_key_password","xyz","dbms.ssl.policy.default.public_certificate","xyz","dbms.ssl.policy.default.trusted_dir","xyz","dbms.ssl.policy.default.revoked_dir","xyz","dbms.ssl.policy.default.client_auth","xyz","dbms.ssl.policy.default.tls_versions","xyz","dbms.ssl.policy.default.ciphers","xyz");
    Map<String,String> validatedParams=validator.validate(originalParams,warnings);
    assertEquals(originalParams,validatedParams);
  }
  @Test public void shouldThrowOnUnknownPolicySetting(){
    SslPolicyConfigValidator validator=new SslPolicyConfigValidator();
    Map<String,String> originalParams=params("dbms.ssl.policy.default.color","blue");
    try {
      validator.validate(originalParams,warnings);
      fail();
    }
 catch (    InvalidSettingException e) {
      assertTrue(e.getMessage().contains("Invalid setting name"));
    }
  }
  @Test public void shouldThrowOnDirectPolicySetting(){
    SslPolicyConfigValidator validator=new SslPolicyConfigValidator();
    Map<String,String> originalParams=params("dbms.ssl.policy.base_directory","path");
    try {
      validator.validate(originalParams,warnings);
      fail();
    }
 catch (    InvalidSettingException e) {
      assertTrue(e.getMessage().contains("Invalid setting name"));
    }
  }
  @Test public void shouldIgnoreUnknownNonPolicySettings(){
    SslPolicyConfigValidator validator=new SslPolicyConfigValidator();
    Map<String,String> originalParams=params("dbms.ssl.unknown","xyz","dbms.ssl.something","xyz","dbms.unrelated.totally","xyz");
    Map<String,String> validatedParams=validator.validate(originalParams,warnings);
    assertTrue(validatedParams.isEmpty());
  }
  @Test public void shouldComplainWhenMissingMandatoryBaseDirectory(){
    SslPolicyConfigValidator validator=new SslPolicyConfigValidator();
    Map<String,String> originalParams=params("dbms.ssl.policy.default.private_key","private.key","dbms.ssl.policy.default.public_certificate","public.crt");
    try {
      validator.validate(originalParams,warnings);
      fail();
    }
 catch (    InvalidSettingException e) {
      assertTrue(e.getMessage().contains("Missing mandatory setting"));
    }
  }
  private static Map<String,String> params(  String... params){
    return unmodifiableMap(stringMap(params));
  }
}
