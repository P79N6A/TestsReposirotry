public class AllNodesInStoreExistInLabelIndexTest {
  @Rule public final EmbeddedDatabaseRule db=new EmbeddedDatabaseRule();
  @Rule public final RandomRule random=new RandomRule();
  private final AssertableLogProvider log=new AssertableLogProvider();
  private static final Label[] LABEL_ALPHABET=new Label[]{LABEL_ONE,LABEL_TWO,LABEL_THREE};
  private static final Label EXTRA_LABEL=Label.label("extra");
  private static final double DELETE_RATIO=0.2;
  private static final double UPDATE_RATIO=0.2;
  private static final int NODE_COUNT_BASELINE=10;
  @Test public void mustReportSuccessfulForConsistentLabelScanStore() throws Exception {
    someData();
    db.shutdownAndKeepStore();
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertTrue("Expected consistency check to succeed",result.isSuccessful());
  }
  @Test public void reportNotCleanLabelIndex() throws IOException, ConsistencyCheckIncompleteException {
    DatabaseLayout databaseLayout=db.databaseLayout();
    someData();
    db.resolveDependency(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("forcedCheckpoint"));
    File labelIndexFileCopy=databaseLayout.file("label_index_copy");
    copyFile(databaseLayout.labelScanStore(),labelIndexFileCopy);
    try (Transaction tx=db.beginTx()){
      db.createNode(LABEL_ONE);
      tx.success();
    }
     db.shutdownAndKeepStore();
    copyFile(labelIndexFileCopy,databaseLayout.labelScanStore());
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertFalse("Expected consistency check to fail",result.isSuccessful());
    assertThat(readReport(result),hasItem(containsString("WARN : Label index was not properly shutdown and rebuild is required.")));
  }
  @Test public void reportNotCleanLabelIndexWithCorrectData() throws IOException, ConsistencyCheckIncompleteException {
    DatabaseLayout databaseLayout=db.databaseLayout();
    someData();
    db.resolveDependency(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("forcedCheckpoint"));
    File labelIndexFileCopy=databaseLayout.file("label_index_copy");
    copyFile(databaseLayout.labelScanStore(),labelIndexFileCopy);
    db.shutdownAndKeepStore();
    copyFile(labelIndexFileCopy,databaseLayout.labelScanStore());
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertTrue("Expected consistency check to fail",result.isSuccessful());
    assertThat(readReport(result),hasItem(containsString("WARN : Label index was not properly shutdown and rebuild is required.")));
  }
  @Test public void mustReportMissingNode() throws Exception {
    someData();
    File labelIndexFileCopy=copyLabelIndexFile();
    try (Transaction tx=db.beginTx()){
      db.createNode(LABEL_ONE);
      tx.success();
    }
     replaceLabelIndexWithCopy(labelIndexFileCopy);
    db.shutdownAndKeepStore();
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertFalse("Expected consistency check to fail",result.isSuccessful());
  }
  @Test public void mustReportMissingLabel() throws Exception {
    List<Pair<Long,Label[]>> nodesInStore=someData();
    File labelIndexFileCopy=copyLabelIndexFile();
    try (Transaction tx=db.beginTx()){
      addLabelToExistingNode(nodesInStore);
      tx.success();
    }
     replaceLabelIndexWithCopy(labelIndexFileCopy);
    db.shutdownAndKeepStore();
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertFalse("Expected consistency check to fail",result.isSuccessful());
  }
  @Test public void mustReportExtraLabelsOnExistingNode() throws Exception {
    List<Pair<Long,Label[]>> nodesInStore=someData();
    File labelIndexFileCopy=copyLabelIndexFile();
    try (Transaction tx=db.beginTx()){
      removeLabelFromExistingNode(nodesInStore);
      tx.success();
    }
     replaceLabelIndexWithCopy(labelIndexFileCopy);
    db.shutdownAndKeepStore();
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertFalse("Expected consistency check to fail",result.isSuccessful());
  }
  @Test public void mustReportExtraNode() throws Exception {
    List<Pair<Long,Label[]>> nodesInStore=someData();
    File labelIndexFileCopy=copyLabelIndexFile();
    try (Transaction tx=db.beginTx()){
      removeExistingNode(nodesInStore);
      tx.success();
    }
     replaceLabelIndexWithCopy(labelIndexFileCopy);
    db.shutdownAndKeepStore();
    ConsistencyCheckService.Result result=fullConsistencyCheck();
    assertFalse("Expected consistency check to fail",result.isSuccessful());
  }
  private List<String> readReport(  ConsistencyCheckService.Result result) throws IOException {
    return Files.readAllLines(result.reportFile().toPath());
  }
  private void removeExistingNode(  List<Pair<Long,Label[]>> nodesInStore){
    Node node;
    Label[] labels;
    do {
      int targetIndex=random.nextInt(nodesInStore.size());
      Pair<Long,Label[]> existingNode=nodesInStore.get(targetIndex);
      node=db.getNodeById(existingNode.first());
      labels=existingNode.other();
    }
 while (labels.length == 0);
    node.delete();
  }
  private void addLabelToExistingNode(  List<Pair<Long,Label[]>> nodesInStore){
    int targetIndex=random.nextInt(nodesInStore.size());
    Pair<Long,Label[]> existingNode=nodesInStore.get(targetIndex);
    Node node=db.getNodeById(existingNode.first());
    node.addLabel(EXTRA_LABEL);
  }
  private void removeLabelFromExistingNode(  List<Pair<Long,Label[]>> nodesInStore){
    Pair<Long,Label[]> existingNode;
    Node node;
    do {
      int targetIndex=random.nextInt(nodesInStore.size());
      existingNode=nodesInStore.get(targetIndex);
      node=db.getNodeById(existingNode.first());
    }
 while (existingNode.other().length == 0);
    node.removeLabel(existingNode.other()[0]);
  }
  private void replaceLabelIndexWithCopy(  File labelIndexFileCopy) throws IOException {
    db.restartDatabase((fs,directory) -> {
      DatabaseLayout databaseLayout=db.databaseLayout();
      fs.deleteFile(databaseLayout.labelScanStore());
      fs.copyFile(labelIndexFileCopy,databaseLayout.labelScanStore());
    }
);
  }
  private File copyLabelIndexFile() throws IOException {
    DatabaseLayout databaseLayout=db.databaseLayout();
    File labelIndexFileCopy=databaseLayout.file("label_index_copy");
    db.restartDatabase((fs,directory) -> fs.copyFile(databaseLayout.labelScanStore(),labelIndexFileCopy));
    return labelIndexFileCopy;
  }
  private List<Pair<Long,Label[]>> someData(){
    return someData(50);
  }
  private List<Pair<Long,Label[]>> someData(  int numberOfModifications){
    List<Pair<Long,Label[]>> existingNodes;
    existingNodes=new ArrayList<>();
    try (Transaction tx=db.beginTx()){
      randomModifications(existingNodes,numberOfModifications);
      tx.success();
    }
     return existingNodes;
  }
  private void randomModifications(  List<Pair<Long,Label[]>> existingNodes,  int numberOfModifications){
    for (int i=0; i < numberOfModifications; i++) {
      double selectModification=random.nextDouble();
      if (existingNodes.size() < NODE_COUNT_BASELINE || selectModification >= DELETE_RATIO + UPDATE_RATIO) {
        createNewNode(existingNodes);
      }
 else       if (selectModification < DELETE_RATIO) {
        deleteExistingNode(existingNodes);
      }
 else {
        modifyLabelsOnExistingNode(existingNodes);
      }
    }
  }
  private void createNewNode(  List<Pair<Long,Label[]>> existingNodes){
    Label[] labels=randomLabels();
    Node node=db.createNode(labels);
    existingNodes.add(Pair.of(node.getId(),labels));
  }
  private void modifyLabelsOnExistingNode(  List<Pair<Long,Label[]>> existingNodes){
    int targetIndex=random.nextInt(existingNodes.size());
    Pair<Long,Label[]> existingPair=existingNodes.get(targetIndex);
    long nodeId=existingPair.first();
    Node node=db.getNodeById(nodeId);
    node.getLabels().forEach(node::removeLabel);
    Label[] newLabels=randomLabels();
    for (    Label label : newLabels) {
      node.addLabel(label);
    }
    existingNodes.remove(targetIndex);
    existingNodes.add(Pair.of(nodeId,newLabels));
  }
  private void deleteExistingNode(  List<Pair<Long,Label[]>> existingNodes){
    int targetIndex=random.nextInt(existingNodes.size());
    Pair<Long,Label[]> existingPair=existingNodes.get(targetIndex);
    Node node=db.getNodeById(existingPair.first());
    node.delete();
    existingNodes.remove(targetIndex);
  }
  private Label[] randomLabels(){
    List<Label> labels=new ArrayList<>(3);
    for (    Label label : LABEL_ALPHABET) {
      if (random.nextBoolean()) {
        labels.add(label);
      }
    }
    return labels.toArray(new Label[labels.size()]);
  }
  private ConsistencyCheckService.Result fullConsistencyCheck() throws ConsistencyCheckIncompleteException, IOException {
    try (FileSystemAbstraction fsa=new DefaultFileSystemAbstraction()){
      ConsistencyCheckService service=new ConsistencyCheckService();
      Config config=Config.defaults();
      return service.runFullConsistencyCheck(db.databaseLayout(),config,NONE,log,fsa,true,new ConsistencyFlags(config));
    }
   }
}
