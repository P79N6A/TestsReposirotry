class StandardBranchCollisionDetectorTest {
  @Test void testFilteredPathEvaluation(){
    final PropertyContainer endNode=mock(Node.class);
    final PropertyContainer alternativeEndNode=mock(Node.class);
    final Node startNode=mock(Node.class);
    Evaluator evaluator=mock(Evaluator.class);
    TraversalBranch branch=mock(TraversalBranch.class);
    TraversalBranch alternativeBranch=mock(TraversalBranch.class);
    when(branch.iterator()).thenAnswer(new IteratorAnswer(endNode));
    when(alternativeBranch.iterator()).thenAnswer(new IteratorAnswer(alternativeEndNode));
    when(alternativeBranch.startNode()).thenReturn(startNode);
    when(evaluator.evaluate(Mockito.any(Path.class))).thenReturn(Evaluation.INCLUDE_AND_CONTINUE);
    StandardBranchCollisionDetector collisionDetector=new StandardBranchCollisionDetector(evaluator,path -> alternativeEndNode.equals(path.endNode()) && startNode.equals(path.startNode()));
    Collection<Path> incoming=collisionDetector.evaluate(branch,Direction.INCOMING);
    Collection<Path> outgoing=collisionDetector.evaluate(branch,Direction.OUTGOING);
    Collection<Path> alternativeIncoming=collisionDetector.evaluate(alternativeBranch,Direction.INCOMING);
    Collection<Path> alternativeOutgoing=collisionDetector.evaluate(alternativeBranch,Direction.OUTGOING);
    assertNull(incoming);
    assertNull(outgoing);
    assertNull(alternativeIncoming);
    assertEquals(1,alternativeOutgoing.size());
  }
private static class IteratorAnswer implements Answer<Object> {
    private final PropertyContainer endNode;
    IteratorAnswer(    PropertyContainer endNode){
      this.endNode=endNode;
    }
    @Override public Object answer(    InvocationOnMock invocation){
      return Arrays.asList(endNode).iterator();
    }
  }
}
