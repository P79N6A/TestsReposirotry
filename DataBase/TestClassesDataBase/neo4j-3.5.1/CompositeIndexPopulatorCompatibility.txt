@Ignore("Not a test. This is a compatibility suite that provides test cases for verifying" + " IndexProvider implementations. Each index provider that is to be tested by this suite" + " must create their own test class extending IndexProviderCompatibilityTestSuite."+ " The @Ignore annotation doesn't prevent these tests to run, it rather removes some annoying"+ " errors or warnings in some IDEs about test classes needing a public zero-arg constructor.") public class CompositeIndexPopulatorCompatibility extends IndexProviderCompatibilityTestSuite.Compatibility {
  public CompositeIndexPopulatorCompatibility(  IndexProviderCompatibilityTestSuite testSuite,  IndexDescriptor descriptor){
    super(testSuite,descriptor);
  }
@Ignore("Not a test. This is a compatibility suite") public static class General extends CompositeIndexPopulatorCompatibility {
    public General(    IndexProviderCompatibilityTestSuite testSuite){
      super(testSuite,TestIndexDescriptorFactory.forLabel(1000,100,200));
    }
    @Test public void shouldProvidePopulatorThatAcceptsDuplicateEntries() throws Exception {
      IndexSamplingConfig indexSamplingConfig=new IndexSamplingConfig(Config.defaults());
      withPopulator(indexProvider.getPopulator(descriptor,indexSamplingConfig),p -> p.add(Arrays.asList(add(1,descriptor.schema(),"v1","v2"),add(2,descriptor.schema(),"v1","v2"))));
      try (IndexAccessor accessor=indexProvider.getOnlineAccessor(descriptor,indexSamplingConfig)){
        try (IndexReader reader=new QueryResultComparingIndexReader(accessor.newReader())){
          LongIterator nodes=reader.query(IndexQuery.exact(1,"v1"),IndexQuery.exact(1,"v2"));
          assertEquals(asSet(1L,2L),PrimitiveLongCollections.toSet(nodes));
        }
       }
     }
  }
@Ignore("Not a test. This is a compatibility suite") public static class Unique extends CompositeIndexPopulatorCompatibility {
    Value value1=Values.of("value1");
    Value value2=Values.of("value2");
    Value value3=Values.of("value3");
    int nodeId1=3;
    int nodeId2=4;
    public Unique(    IndexProviderCompatibilityTestSuite testSuite){
      super(testSuite,TestIndexDescriptorFactory.uniqueForLabel(1000,100,200));
    }
    @Test public void shouldEnforceUniqueConstraintsDirectly() throws Exception {
      IndexSamplingConfig indexSamplingConfig=new IndexSamplingConfig(Config.defaults());
      withPopulator(indexProvider.getPopulator(descriptor,indexSamplingConfig),p -> {
        try {
          p.add(Arrays.asList(IndexEntryUpdate.add(nodeId1,descriptor.schema(),value1,value2),IndexEntryUpdate.add(nodeId2,descriptor.schema(),value1,value2)));
          TestNodePropertyAccessor propertyAccessor=new TestNodePropertyAccessor(nodeId1,descriptor.schema(),value1,value2);
          propertyAccessor.addNode(nodeId2,descriptor.schema(),value1,value2);
          p.verifyDeferredConstraints(propertyAccessor);
          fail("expected exception");
        }
 catch (        IndexEntryConflictException conflict) {
          assertEquals(nodeId1,conflict.getExistingNodeId());
          assertEquals(ValueTuple.of(value1,value2),conflict.getPropertyValues());
          assertEquals(nodeId2,conflict.getAddedNodeId());
        }
      }
);
    }
    @Test public void shouldNotRestrictUpdatesDifferingOnSecondProperty() throws Exception {
      IndexSamplingConfig indexSamplingConfig=new IndexSamplingConfig(Config.defaults());
      withPopulator(indexProvider.getPopulator(descriptor,indexSamplingConfig),p -> {
        p.add(Arrays.asList(IndexEntryUpdate.add(nodeId1,descriptor.schema(),value1,value2),IndexEntryUpdate.add(nodeId2,descriptor.schema(),value1,value3)));
        TestNodePropertyAccessor propertyAccessor=new TestNodePropertyAccessor(nodeId1,descriptor.schema(),value1,value2);
        propertyAccessor.addNode(nodeId2,descriptor.schema(),value1,value3);
        p.verifyDeferredConstraints(propertyAccessor);
      }
);
    }
  }
}
