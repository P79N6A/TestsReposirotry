@ExtendWith({DefaultFileSystemExtension.class,TestDirectoryExtension.class}) class DatabaseIndexIntegrationTest {
  private static final int THREAD_NUMBER=5;
  private static ExecutorService workers;
  @Inject private TestDirectory testDirectory;
  @Inject private DefaultFileSystemAbstraction fileSystem;
  private final CountDownLatch raceSignal=new CountDownLatch(1);
  private SyncNotifierDirectoryFactory directoryFactory;
  private WritableTestDatabaseIndex luceneIndex;
  @BeforeAll static void initExecutors(){
    workers=Executors.newFixedThreadPool(THREAD_NUMBER);
  }
  @AfterAll static void shutDownExecutor(){
    workers.shutdownNow();
  }
  @BeforeEach void setUp() throws IOException {
    directoryFactory=new SyncNotifierDirectoryFactory(raceSignal);
    luceneIndex=createTestLuceneIndex(directoryFactory,testDirectory.directory());
  }
  @AfterEach void tearDown(){
    directoryFactory.close();
  }
  @RepeatedTest(2) void testSaveCallCommitAndCloseFromMultipleThreads(){
    assertTimeout(ofSeconds(60),() -> {
      generateInitialData();
      Supplier<Runnable> closeTaskSupplier=() -> createConcurrentCloseTask(raceSignal);
      List<Future<?>> closeFutures=submitTasks(closeTaskSupplier);
      for (      Future<?> closeFuture : closeFutures) {
        closeFuture.get();
      }
      assertFalse(luceneIndex.isOpen());
    }
);
  }
  @RepeatedTest(2) void saveCallCloseAndDropFromMultipleThreads(){
    assertTimeout(ofSeconds(60),() -> {
      generateInitialData();
      Supplier<Runnable> dropTaskSupplier=() -> createConcurrentDropTask(raceSignal);
      List<Future<?>> futures=submitTasks(dropTaskSupplier);
      for (      Future<?> future : futures) {
        future.get();
      }
      assertFalse(luceneIndex.isOpen());
    }
);
  }
  private WritableTestDatabaseIndex createTestLuceneIndex(  DirectoryFactory dirFactory,  File folder) throws IOException {
    PartitionedIndexStorage indexStorage=new PartitionedIndexStorage(dirFactory,fileSystem,folder);
    WritableTestDatabaseIndex index=new WritableTestDatabaseIndex(indexStorage);
    index.create();
    index.open();
    return index;
  }
  private List<Future<?>> submitTasks(  Supplier<Runnable> taskSupplier){
    List<Future<?>> futures=new ArrayList<>(THREAD_NUMBER);
    futures.add(workers.submit(createMainCloseTask()));
    for (int i=0; i < THREAD_NUMBER - 1; i++) {
      futures.add(workers.submit(taskSupplier.get()));
    }
    return futures;
  }
  private void generateInitialData() throws IOException {
    IndexWriter indexWriter=firstPartitionWriter();
    for (int i=0; i < 10; i++) {
      indexWriter.addDocument(createTestDocument());
    }
  }
  private Runnable createConcurrentDropTask(  CountDownLatch dropRaceSignal){
    return () -> {
      try {
        dropRaceSignal.await();
        Thread.yield();
        luceneIndex.drop();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
;
  }
  private Runnable createConcurrentCloseTask(  CountDownLatch closeRaceSignal){
    return () -> {
      try {
        closeRaceSignal.await();
        Thread.yield();
        luceneIndex.close();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
;
  }
  private Runnable createMainCloseTask(){
    return () -> {
      try {
        luceneIndex.close();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
;
  }
  private static Document createTestDocument(){
    Document document=new Document();
    document.add(new TextField("text","textValue",Field.Store.YES));
    document.add(new LongField("long",1,Field.Store.YES));
    return document;
  }
  private IndexWriter firstPartitionWriter(){
    List<AbstractIndexPartition> partitions=luceneIndex.getPartitions();
    assertEquals(1,partitions.size());
    AbstractIndexPartition partition=partitions.get(0);
    return partition.getIndexWriter();
  }
private static class WritableTestDatabaseIndex extends WritableAbstractDatabaseIndex<TestLuceneIndex,AbstractIndexReader> {
    WritableTestDatabaseIndex(    PartitionedIndexStorage indexStorage){
      super(new TestLuceneIndex(indexStorage,new WritableIndexPartitionFactory(IndexWriterConfigs::standard)));
    }
  }
private static class TestLuceneIndex extends AbstractLuceneIndex<AbstractIndexReader> {
    TestLuceneIndex(    PartitionedIndexStorage indexStorage,    IndexPartitionFactory partitionFactory){
      super(indexStorage,partitionFactory,null);
    }
    @Override protected AbstractIndexReader createSimpleReader(    List<AbstractIndexPartition> partitions) throws IOException {
      return null;
    }
    @Override protected AbstractIndexReader createPartitionedReader(    List<AbstractIndexPartition> partitions) throws IOException {
      return null;
    }
  }
private static class SyncNotifierDirectoryFactory implements DirectoryFactory {
    final CountDownLatch signal;
    SyncNotifierDirectoryFactory(    CountDownLatch signal){
      this.signal=signal;
    }
    public Directory open(    File dir,    CountDownLatch signal) throws IOException {
      Directory directory=open(dir);
      return new SyncNotifierDirectory(directory,signal);
    }
    @Override public Directory open(    File dir) throws IOException {
      dir.mkdirs();
      FSDirectory fsDir=FSDirectory.open(dir.toPath());
      return new SyncNotifierDirectory(fsDir,signal);
    }
    @Override public void close(){
    }
private static class SyncNotifierDirectory extends Directory {
      private final Directory delegate;
      private final CountDownLatch signal;
      SyncNotifierDirectory(      Directory delegate,      CountDownLatch signal){
        this.delegate=delegate;
        this.signal=signal;
      }
      @Override public String[] listAll() throws IOException {
        return delegate.listAll();
      }
      @Override public void deleteFile(      String name) throws IOException {
        delegate.deleteFile(name);
      }
      @Override public long fileLength(      String name) throws IOException {
        return delegate.fileLength(name);
      }
      @Override public IndexOutput createOutput(      String name,      IOContext context) throws IOException {
        return delegate.createOutput(name,context);
      }
      @Override public void sync(      Collection<String> names) throws IOException {
        if (names.stream().noneMatch(name -> name.startsWith(IndexFileNames.PENDING_SEGMENTS))) {
          try {
            signal.countDown();
            Thread.sleep(500);
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
        delegate.sync(names);
      }
      @Override public void renameFile(      String source,      String dest) throws IOException {
        delegate.renameFile(source,dest);
      }
      @Override public IndexInput openInput(      String name,      IOContext context) throws IOException {
        return delegate.openInput(name,context);
      }
      @Override public Lock obtainLock(      String name) throws IOException {
        return delegate.obtainLock(name);
      }
      @Override public void close() throws IOException {
        delegate.close();
      }
    }
  }
}
