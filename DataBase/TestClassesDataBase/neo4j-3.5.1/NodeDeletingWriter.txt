private class NodeDeletingWriter extends IndexPopulator.Adapter {
  private final Map<Long,Object> added=new HashMap<>();
  private final Map<Long,Object> removed=new HashMap<>();
  private final long nodeToDelete;
  private IndexPopulationJob job;
  private final Value valueToDelete;
  private final LabelSchemaDescriptor index;
  NodeDeletingWriter(  long nodeToDelete,  int propertyKeyId,  Object valueToDelete,  int label){
    this.nodeToDelete=nodeToDelete;
    this.valueToDelete=Values.of(valueToDelete);
    this.index=SchemaDescriptorFactory.forLabel(label,propertyKeyId);
  }
  public void setJob(  IndexPopulationJob job){
    this.job=job;
  }
  @Override public void add(  Collection<? extends IndexEntryUpdate<?>> updates){
    for (    IndexEntryUpdate<?> update : updates) {
      add(update);
    }
  }
  void add(  IndexEntryUpdate<?> update){
    if (update.getEntityId() == 2) {
      job.update(IndexEntryUpdate.remove(nodeToDelete,index,valueToDelete));
    }
    added.put(update.getEntityId(),update.values()[0].asObjectCopy());
  }
  @Override public IndexUpdater newPopulatingUpdater(  NodePropertyAccessor nodePropertyAccessor){
    return new IndexUpdater(){
      @Override public void process(      IndexEntryUpdate<?> update){
switch (update.updateMode()) {
case ADDED:
case CHANGED:
          added.put(update.getEntityId(),update.values()[0].asObjectCopy());
        break;
case REMOVED:
      removed.put(update.getEntityId(),update.values()[0].asObjectCopy());
    break;
default :
  throw new IllegalArgumentException(update.updateMode().name());
}
}
@Override public void close(){
}
}
;
}
}
