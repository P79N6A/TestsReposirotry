private class NodeChangingWriter extends IndexPopulator.Adapter {
  private final Set<Pair<Long,Object>> added=new HashSet<>();
  private IndexPopulationJob job;
  private final long nodeToChange;
  private final Value newValue;
  private final Value previousValue;
  private final LabelSchemaDescriptor index;
  NodeChangingWriter(  long nodeToChange,  int propertyKeyId,  Object previousValue,  Object newValue,  int label){
    this.nodeToChange=nodeToChange;
    this.previousValue=Values.of(previousValue);
    this.newValue=Values.of(newValue);
    this.index=SchemaDescriptorFactory.forLabel(label,propertyKeyId);
  }
  @Override public void add(  Collection<? extends IndexEntryUpdate<?>> updates){
    for (    IndexEntryUpdate<?> update : updates) {
      add(update);
    }
  }
  void add(  IndexEntryUpdate<?> update){
    if (update.getEntityId() == 2) {
      job.update(IndexEntryUpdate.change(nodeToChange,index,previousValue,newValue));
    }
    added.add(Pair.of(update.getEntityId(),update.values()[0].asObjectCopy()));
  }
  @Override public IndexUpdater newPopulatingUpdater(  NodePropertyAccessor nodePropertyAccessor){
    return new IndexUpdater(){
      @Override public void process(      IndexEntryUpdate<?> update){
switch (update.updateMode()) {
case ADDED:
case CHANGED:
          added.add(Pair.of(update.getEntityId(),update.values()[0].asObjectCopy()));
        break;
default :
      throw new IllegalArgumentException(update.updateMode().name());
  }
}
@Override public void close(){
}
}
;
}
public void setJob(IndexPopulationJob job){
this.job=job;
}
}
