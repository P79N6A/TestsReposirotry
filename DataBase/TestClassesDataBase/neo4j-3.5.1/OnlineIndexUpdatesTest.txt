public class OnlineIndexUpdatesTest {
  private static final int ENTITY_TOKEN=1;
  private static final int OTHER_ENTITY_TOKEN=2;
  private static final int[] ENTITY_TOKENS={ENTITY_TOKEN};
  @Rule public PageCacheAndDependenciesRule storage=new PageCacheAndDependenciesRule();
  private NodeStore nodeStore;
  private RelationshipStore relationshipStore;
  private IndexingService indexingService;
  private PropertyPhysicalToLogicalConverter propertyPhysicalToLogicalConverter;
  private NeoStores neoStores;
  private LifeSupport life;
  private PropertyCreator propertyCreator;
  private DirectRecordAccess<PropertyRecord,PrimitiveRecord> recordAccess;
  @Before public void setUp() throws Exception {
    life=new LifeSupport();
    PageCache pageCache=storage.pageCache();
    DatabaseLayout databaseLayout=storage.directory().databaseLayout();
    Config config=Config.defaults(GraphDatabaseSettings.default_schema_provider,EMPTY.getProviderDescriptor().name());
    NullLogProvider nullLogProvider=NullLogProvider.getInstance();
    StoreFactory storeFactory=new StoreFactory(databaseLayout,config,new DefaultIdGeneratorFactory(storage.fileSystem()),pageCache,storage.fileSystem(),nullLogProvider,EmptyVersionContextSupplier.EMPTY);
    neoStores=storeFactory.openAllNeoStores(true);
    neoStores.getCounts().start();
    CountsComputer.recomputeCounts(neoStores,pageCache,databaseLayout);
    nodeStore=neoStores.getNodeStore();
    relationshipStore=neoStores.getRelationshipStore();
    PropertyStore propertyStore=neoStores.getPropertyStore();
    JobScheduler scheduler=JobSchedulerFactory.createScheduler();
    Dependencies dependencies=new Dependencies();
    dependencies.satisfyDependency(EMPTY);
    DefaultIndexProviderMap providerMap=new DefaultIndexProviderMap(dependencies,config);
    life.add(providerMap);
    indexingService=IndexingServiceFactory.createIndexingService(config,scheduler,providerMap,new NeoStoreIndexStoreView(LockService.NO_LOCK_SERVICE,neoStores),SchemaUtil.idTokenNameLookup,empty(),nullLogProvider,nullLogProvider,IndexingService.NO_MONITOR,new DatabaseSchemaState(nullLogProvider));
    propertyPhysicalToLogicalConverter=new PropertyPhysicalToLogicalConverter(neoStores.getPropertyStore());
    life.add(indexingService);
    life.add(scheduler);
    life.init();
    life.start();
    propertyCreator=new PropertyCreator(neoStores.getPropertyStore(),new PropertyTraverser());
    recordAccess=new DirectRecordAccess<>(neoStores.getPropertyStore(),Loaders.propertyLoader(propertyStore));
  }
  @After public void tearDown(){
    life.shutdown();
    neoStores.close();
  }
  @Test public void shouldContainFedNodeUpdate() throws Exception {
    OnlineIndexUpdates onlineIndexUpdates=new OnlineIndexUpdates(nodeStore,relationshipStore,indexingService,propertyPhysicalToLogicalConverter);
    int nodeId=0;
    NodeRecord inUse=getNode(nodeId,true);
    Value propertyValue=Values.of("hej");
    long propertyId=createNodeProperty(inUse,propertyValue,1);
    NodeRecord notInUse=getNode(nodeId,false);
    nodeStore.updateRecord(inUse);
    Command.NodeCommand nodeCommand=new Command.NodeCommand(inUse,notInUse);
    PropertyRecord propertyBlocks=new PropertyRecord(propertyId);
    propertyBlocks.setNodeId(nodeId);
    Command.PropertyCommand propertyCommand=new Command.PropertyCommand(recordAccess.getIfLoaded(propertyId).forReadingData(),propertyBlocks);
    StoreIndexDescriptor indexDescriptor=forSchema(multiToken(ENTITY_TOKENS,NODE,1,4,6),EMPTY.getProviderDescriptor()).withId(0);
    indexingService.createIndexes(indexDescriptor);
    indexingService.getIndexProxy(indexDescriptor.schema()).awaitStoreScanCompleted();
    onlineIndexUpdates.feed(LongObjectMaps.immutable.of(nodeId,singletonList(propertyCommand)),LongObjectMaps.immutable.empty(),LongObjectMaps.immutable.of(nodeId,nodeCommand),LongObjectMaps.immutable.empty());
    assertTrue(onlineIndexUpdates.hasUpdates());
    Iterator<IndexEntryUpdate<SchemaDescriptor>> iterator=onlineIndexUpdates.iterator();
    assertEquals(iterator.next(),IndexEntryUpdate.remove(nodeId,indexDescriptor,propertyValue,null,null));
    assertFalse(iterator.hasNext());
  }
  @Test public void shouldContainFedRelationshipUpdate() throws Exception {
    OnlineIndexUpdates onlineIndexUpdates=new OnlineIndexUpdates(nodeStore,relationshipStore,indexingService,propertyPhysicalToLogicalConverter);
    long relId=0;
    RelationshipRecord inUse=getRelationship(relId,true,ENTITY_TOKEN);
    Value propertyValue=Values.of("hej");
    long propertyId=createRelationshipProperty(inUse,propertyValue,1);
    RelationshipRecord notInUse=getRelationship(relId,false,ENTITY_TOKEN);
    relationshipStore.updateRecord(inUse);
    Command.RelationshipCommand relationshipCommand=new Command.RelationshipCommand(inUse,notInUse);
    PropertyRecord propertyBlocks=new PropertyRecord(propertyId);
    propertyBlocks.setRelId(relId);
    Command.PropertyCommand propertyCommand=new Command.PropertyCommand(recordAccess.getIfLoaded(propertyId).forReadingData(),propertyBlocks);
    StoreIndexDescriptor indexDescriptor=forSchema(multiToken(ENTITY_TOKENS,RELATIONSHIP,1,4,6),EMPTY.getProviderDescriptor()).withId(0);
    indexingService.createIndexes(indexDescriptor);
    indexingService.getIndexProxy(indexDescriptor.schema()).awaitStoreScanCompleted();
    onlineIndexUpdates.feed(LongObjectMaps.immutable.empty(),LongObjectMaps.immutable.of(relId,singletonList(propertyCommand)),LongObjectMaps.immutable.empty(),LongObjectMaps.immutable.of(relId,relationshipCommand));
    assertTrue(onlineIndexUpdates.hasUpdates());
    Iterator<IndexEntryUpdate<SchemaDescriptor>> iterator=onlineIndexUpdates.iterator();
    assertEquals(iterator.next(),IndexEntryUpdate.remove(relId,indexDescriptor,propertyValue,null,null));
    assertFalse(iterator.hasNext());
  }
  @Test public void shouldDifferentiateNodesAndRelationships() throws Exception {
    OnlineIndexUpdates onlineIndexUpdates=new OnlineIndexUpdates(nodeStore,relationshipStore,indexingService,propertyPhysicalToLogicalConverter);
    int nodeId=0;
    NodeRecord inUseNode=getNode(nodeId,true);
    Value nodePropertyValue=Values.of("hej");
    long nodePropertyId=createNodeProperty(inUseNode,nodePropertyValue,1);
    NodeRecord notInUseNode=getNode(nodeId,false);
    nodeStore.updateRecord(inUseNode);
    Command.NodeCommand nodeCommand=new Command.NodeCommand(inUseNode,notInUseNode);
    PropertyRecord nodePropertyBlocks=new PropertyRecord(nodePropertyId);
    nodePropertyBlocks.setNodeId(nodeId);
    Command.PropertyCommand nodePropertyCommand=new Command.PropertyCommand(recordAccess.getIfLoaded(nodePropertyId).forReadingData(),nodePropertyBlocks);
    StoreIndexDescriptor nodeIndexDescriptor=forSchema(multiToken(ENTITY_TOKENS,NODE,1,4,6),EMPTY.getProviderDescriptor()).withId(0);
    indexingService.createIndexes(nodeIndexDescriptor);
    indexingService.getIndexProxy(nodeIndexDescriptor.schema()).awaitStoreScanCompleted();
    long relId=0;
    RelationshipRecord inUse=getRelationship(relId,true,ENTITY_TOKEN);
    Value relationshipPropertyValue=Values.of("da");
    long propertyId=createRelationshipProperty(inUse,relationshipPropertyValue,1);
    RelationshipRecord notInUse=getRelationship(relId,false,ENTITY_TOKEN);
    relationshipStore.updateRecord(inUse);
    Command.RelationshipCommand relationshipCommand=new Command.RelationshipCommand(inUse,notInUse);
    PropertyRecord relationshipPropertyBlocks=new PropertyRecord(propertyId);
    relationshipPropertyBlocks.setRelId(relId);
    Command.PropertyCommand relationshipPropertyCommand=new Command.PropertyCommand(recordAccess.getIfLoaded(propertyId).forReadingData(),relationshipPropertyBlocks);
    StoreIndexDescriptor relationshipIndexDescriptor=forSchema(multiToken(ENTITY_TOKENS,RELATIONSHIP,1,4,6),EMPTY.getProviderDescriptor()).withId(1);
    indexingService.createIndexes(relationshipIndexDescriptor);
    indexingService.getIndexProxy(relationshipIndexDescriptor.schema()).awaitStoreScanCompleted();
    onlineIndexUpdates.feed(LongObjectMaps.immutable.of(nodeId,singletonList(nodePropertyCommand)),LongObjectMaps.immutable.of(relId,singletonList(relationshipPropertyCommand)),LongObjectMaps.immutable.of(nodeId,nodeCommand),LongObjectMaps.immutable.of(relId,relationshipCommand));
    assertTrue(onlineIndexUpdates.hasUpdates());
    assertThat(onlineIndexUpdates,containsInAnyOrder(IndexEntryUpdate.remove(relId,relationshipIndexDescriptor,relationshipPropertyValue,null,null),IndexEntryUpdate.remove(nodeId,nodeIndexDescriptor,nodePropertyValue,null,null)));
  }
  @Test public void shouldUpdateCorrectIndexes() throws Exception {
    OnlineIndexUpdates onlineIndexUpdates=new OnlineIndexUpdates(nodeStore,relationshipStore,indexingService,propertyPhysicalToLogicalConverter);
    long relId=0;
    RelationshipRecord inUse=getRelationship(relId,true,ENTITY_TOKEN);
    Value propertyValue=Values.of("hej");
    Value propertyValue2=Values.of("da");
    long propertyId=createRelationshipProperty(inUse,propertyValue,1);
    long propertyId2=createRelationshipProperty(inUse,propertyValue2,4);
    RelationshipRecord notInUse=getRelationship(relId,false,ENTITY_TOKEN);
    relationshipStore.updateRecord(inUse);
    Command.RelationshipCommand relationshipCommand=new Command.RelationshipCommand(inUse,notInUse);
    PropertyRecord propertyBlocks=new PropertyRecord(propertyId);
    propertyBlocks.setRelId(relId);
    Command.PropertyCommand propertyCommand=new Command.PropertyCommand(recordAccess.getIfLoaded(propertyId).forReadingData(),propertyBlocks);
    PropertyRecord propertyBlocks2=new PropertyRecord(propertyId2);
    propertyBlocks2.setRelId(relId);
    Command.PropertyCommand propertyCommand2=new Command.PropertyCommand(recordAccess.getIfLoaded(propertyId2).forReadingData(),propertyBlocks2);
    StoreIndexDescriptor indexDescriptor0=forSchema(multiToken(ENTITY_TOKENS,RELATIONSHIP,1,4,6),EMPTY.getProviderDescriptor()).withId(0);
    StoreIndexDescriptor indexDescriptor1=forSchema(multiToken(ENTITY_TOKENS,RELATIONSHIP,2,4,6),EMPTY.getProviderDescriptor()).withId(1);
    StoreIndexDescriptor indexDescriptor2=forSchema(multiToken(new int[]{ENTITY_TOKEN,OTHER_ENTITY_TOKEN},RELATIONSHIP,1),EMPTY.getProviderDescriptor()).withId(2);
    StoreIndexDescriptor indexDescriptor3=forSchema(multiToken(new int[]{OTHER_ENTITY_TOKEN},RELATIONSHIP,1),EMPTY.getProviderDescriptor()).withId(3);
    indexingService.createIndexes(indexDescriptor0,indexDescriptor1,indexDescriptor2);
    indexingService.getIndexProxy(indexDescriptor0.schema()).awaitStoreScanCompleted();
    indexingService.getIndexProxy(indexDescriptor1.schema()).awaitStoreScanCompleted();
    indexingService.getIndexProxy(indexDescriptor2.schema()).awaitStoreScanCompleted();
    onlineIndexUpdates.feed(LongObjectMaps.immutable.empty(),LongObjectMaps.immutable.of(relId,asList(propertyCommand,propertyCommand2)),LongObjectMaps.immutable.empty(),LongObjectMaps.immutable.of(relId,relationshipCommand));
    assertTrue(onlineIndexUpdates.hasUpdates());
    assertThat(onlineIndexUpdates,containsInAnyOrder(IndexEntryUpdate.remove(relId,indexDescriptor0,propertyValue,propertyValue2,null),IndexEntryUpdate.remove(relId,indexDescriptor1,null,propertyValue2,null),IndexEntryUpdate.remove(relId,indexDescriptor2,propertyValue)));
    assertThat(onlineIndexUpdates,not(containsInAnyOrder(indexDescriptor3)));
  }
  private long createRelationshipProperty(  RelationshipRecord relRecord,  Value propertyValue,  int propertyKey){
    return propertyCreator.createPropertyChain(relRecord,singletonList(propertyCreator.encodePropertyValue(propertyKey,propertyValue)).iterator(),recordAccess);
  }
  private long createNodeProperty(  NodeRecord inUse,  Value value,  int propertyKey){
    return propertyCreator.createPropertyChain(inUse,singletonList(propertyCreator.encodePropertyValue(propertyKey,value)).iterator(),recordAccess);
  }
  private NodeRecord getNode(  int nodeId,  boolean inUse){
    NodeRecord nodeRecord=new NodeRecord(nodeId);
    nodeRecord=nodeRecord.initialize(inUse,NO_NEXT_PROPERTY.longValue(),false,NO_NEXT_RELATIONSHIP.longValue(),NO_LABELS_FIELD.longValue());
    InlineNodeLabels labelFieldWriter=new InlineNodeLabels(nodeRecord);
    labelFieldWriter.put(new long[]{ENTITY_TOKEN},null,null);
    return nodeRecord;
  }
  private RelationshipRecord getRelationship(  long relId,  boolean inUse,  int type){
    return new RelationshipRecord(relId).initialize(inUse,NO_NEXT_PROPERTY.longValue(),0,0,type,NO_NEXT_RELATIONSHIP.longValue(),NO_NEXT_RELATIONSHIP.longValue(),NO_NEXT_RELATIONSHIP.longValue(),NO_NEXT_RELATIONSHIP.longValue(),true,false);
  }
}
