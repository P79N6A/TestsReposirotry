public class DetectAllRelationshipInconsistenciesIT {
  private final TestDirectory directory=TestDirectory.testDirectory();
  private final RandomRule random=new RandomRule();
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public final RuleChain rules=RuleChain.outerRule(random).around(directory).around(fileSystemRule);
  @Test public void shouldDetectSabotagedRelationshipWhereEverItIs() throws Exception {
    GraphDatabaseAPI db=getGraphDatabaseAPI();
    Sabotage sabotage;
    try {
      Node[] nodes=new Node[1_000];
      Relationship[] relationships=new Relationship[10_000];
      try (Transaction tx=db.beginTx()){
        for (int i=0; i < nodes.length; i++) {
          nodes[i]=db.createNode(label("Foo"));
        }
        for (int i=0; i < 10_000; i++) {
          relationships[i]=random.among(nodes).createRelationshipTo(random.among(nodes),MyRelTypes.TEST);
        }
        tx.success();
      }
       DependencyResolver resolver=db.getDependencyResolver();
      PageCache pageCache=resolver.resolveDependency(PageCache.class);
      StoreFactory storeFactory=newStoreFactory(pageCache);
      try (NeoStores neoStores=storeFactory.openNeoStores(false,StoreType.RELATIONSHIP)){
        RelationshipStore relationshipStore=neoStores.getRelationshipStore();
        Relationship sabotagedRelationships=random.among(relationships);
        sabotage=sabotage(relationshipStore,sabotagedRelationships.getId());
      }
     }
  finally {
      db.shutdown();
    }
    db=getGraphDatabaseAPI();
    try {
      DependencyResolver resolver=db.getDependencyResolver();
      PageCache pageCache=resolver.resolveDependency(PageCache.class);
      StoreFactory storeFactory=newStoreFactory(pageCache);
      try (NeoStores neoStores=storeFactory.openAllNeoStores()){
        StoreAccess storeAccess=new StoreAccess(neoStores).initialize();
        DirectStoreAccess directStoreAccess=new DirectStoreAccess(storeAccess,db.getDependencyResolver().resolveDependency(LabelScanStore.class),db.getDependencyResolver().resolveDependency(IndexProviderMap.class));
        int threads=random.intBetween(2,10);
        FullCheck checker=new FullCheck(getTuningConfiguration(),ProgressMonitorFactory.NONE,Statistics.NONE,threads);
        AssertableLogProvider logProvider=new AssertableLogProvider(true);
        ConsistencySummaryStatistics summary=checker.execute(directStoreAccess,logProvider.getLog(FullCheck.class));
        int relationshipInconsistencies=summary.getInconsistencyCountForRecordType(RecordType.RELATIONSHIP);
        assertTrue("Couldn't detect sabotaged relationship " + sabotage,relationshipInconsistencies > 0);
        logProvider.assertContainsLogCallContaining(sabotage.after.toString());
      }
     }
  finally {
      db.shutdown();
    }
  }
  private StoreFactory newStoreFactory(  PageCache pageCache){
    FileSystemAbstraction fileSystem=fileSystemRule.get();
    return new StoreFactory(directory.databaseLayout(),getTuningConfiguration(),new DefaultIdGeneratorFactory(fileSystem),pageCache,fileSystem,NullLogProvider.getInstance(),EmptyVersionContextSupplier.EMPTY);
  }
  private Config getTuningConfiguration(){
    return Config.defaults(stringMap(GraphDatabaseSettings.pagecache_memory.name(),"8m",GraphDatabaseSettings.record_format.name(),getRecordFormatName()));
  }
  private GraphDatabaseAPI getGraphDatabaseAPI(){
    TestGraphDatabaseFactory factory=new TestGraphDatabaseFactory();
    GraphDatabaseService database=factory.newEmbeddedDatabaseBuilder(directory.databaseDir()).setConfig(GraphDatabaseSettings.record_format,getRecordFormatName()).setConfig("dbms.backup.enabled","false").newGraphDatabase();
    return (GraphDatabaseAPI)database;
  }
  protected String getRecordFormatName(){
    return StringUtils.EMPTY;
  }
private static class Sabotage {
    private final RelationshipRecord before;
    private final RelationshipRecord after;
    private final RelationshipRecord other;
    Sabotage(    RelationshipRecord before,    RelationshipRecord after,    RelationshipRecord other){
      this.before=before;
      this.after=after;
      this.other=other;
    }
    @Override public String toString(){
      return "Sabotaged " + before + " --> "+ after+ ", other relationship "+ other;
    }
  }
  private Sabotage sabotage(  RelationshipStore store,  long id){
    RelationshipRecord before=store.getRecord(id,store.newRecord(),RecordLoad.NORMAL);
    RelationshipRecord after=before.clone();
    long otherReference;
    if (!after.isFirstInFirstChain()) {
      after.setFirstPrevRel(otherReference=after.getFirstPrevRel() + 1);
    }
 else {
      after.setFirstNextRel(otherReference=after.getFirstNextRel() + 1);
    }
    store.prepareForCommit(after);
    store.updateRecord(after);
    RelationshipRecord other=store.getRecord(otherReference,store.newRecord(),RecordLoad.FORCE);
    return new Sabotage(before,after,other);
  }
}
