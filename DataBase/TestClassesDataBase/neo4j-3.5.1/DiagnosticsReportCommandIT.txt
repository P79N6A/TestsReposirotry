public class DiagnosticsReportCommandIT {
  @Rule public final SuppressOutput suppressOutput=SuppressOutput.suppressAll();
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  private GraphDatabaseService database;
  @Before public void setUp(){
    database=new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(testDirectory.storeDir()).newGraphDatabase();
  }
  @After public void tearDown(){
    database.shutdown();
  }
  @Test public void shouldBeAbleToAttachToPidAndRunThreadDump() throws IOException, CommandFailed, IncorrectUsage {
    long pid=getPID();
    assertThat(pid,is(not(0)));
    Files.createFile(testDirectory.file("neo4j.conf").toPath());
    File run=testDirectory.directory("run");
    Files.write(Paths.get(run.getAbsolutePath(),"neo4j.pid"),String.valueOf(pid).getBytes());
    try (RealOutsideWorld outsideWorld=new RealOutsideWorld()){
      String[] args={"threads","--to=" + testDirectory.absolutePath().getAbsolutePath() + "/reports"};
      Path homeDir=testDirectory.directory().toPath();
      DiagnosticsReportCommand diagnosticsReportCommand=new DiagnosticsReportCommand(homeDir,homeDir,outsideWorld);
      diagnosticsReportCommand.execute(args);
    }
 catch (    IncorrectUsage e) {
      if (e.getMessage().equals("Unknown classifier: threads")) {
        return;
      }
      throw e;
    }
    File reports=testDirectory.directory("reports");
    File[] files=reports.listFiles();
    assertThat(files,notNullValue());
    assertThat(files.length,is(1));
    Path report=files[0].toPath();
    final URI uri=URI.create("jar:file:" + report.toUri().getRawPath());
    try (FileSystem fs=FileSystems.newFileSystem(uri,Collections.emptyMap())){
      String threadDump=new String(Files.readAllBytes(fs.getPath("threaddump.txt")));
      assertThat(threadDump,containsString(DiagnosticsReportCommandIT.class.getCanonicalName()));
    }
   }
  private static long getPID(){
    String processName=java.lang.management.ManagementFactory.getRuntimeMXBean().getName();
    if (processName != null && processName.length() > 0) {
      try {
        return Long.parseLong(processName.split("@")[0]);
      }
 catch (      Exception ignored) {
      }
    }
    return 0;
  }
}
