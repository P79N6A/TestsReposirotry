public class IndexMapReferenceTest {
  @Test public void shouldSynchronizeModifications() throws Throwable {
    IndexMapReference ref=new IndexMapReference();
    IndexProxy[] existing=mockedIndexProxies(5,0);
    ref.modify(indexMap -> {
      for (int i=0; i < existing.length; i++) {
        indexMap.putIndexProxy(existing[i]);
      }
      return indexMap;
    }
);
    Race race=new Race();
    for (int i=0; i < existing.length; i++) {
      race.addContestant(removeIndexProxy(ref,i),1);
    }
    IndexProxy[] created=mockedIndexProxies(3,existing.length);
    for (int i=0; i < existing.length; i++) {
      race.addContestant(putIndexProxy(ref,created[i]),1);
    }
    race.go();
    for (int i=0; i < existing.length; i++) {
      assertNull(ref.getIndexProxy(i));
    }
    for (int i=0; i < created.length; i++) {
      assertSame(created[i],ref.getIndexProxy(existing.length + i));
    }
  }
  private Runnable putIndexProxy(  IndexMapReference ref,  IndexProxy proxy){
    return () -> ref.modify(indexMap -> {
      indexMap.putIndexProxy(proxy);
      return indexMap;
    }
);
  }
  private Runnable removeIndexProxy(  IndexMapReference ref,  long indexId){
    return () -> ref.modify(indexMap -> {
      indexMap.removeIndexProxy(indexId);
      return indexMap;
    }
);
  }
  private IndexProxy[] mockedIndexProxies(  int base,  int count){
    IndexProxy[] existing=new IndexProxy[count];
    for (int i=0; i < count; i++) {
      existing[i]=mock(IndexProxy.class);
      when(existing[i].getDescriptor()).thenReturn(forSchema(forLabel(base + i,1),PROVIDER_DESCRIPTOR).withId(i).withoutCapabilities());
    }
    return existing;
  }
}
