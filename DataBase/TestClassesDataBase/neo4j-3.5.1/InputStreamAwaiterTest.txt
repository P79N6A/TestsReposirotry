class InputStreamAwaiterTest {
  @Test void shouldWaitForALineWithoutBlocking() throws Exception {
    FakeClock clock=getFakeClock();
    InputStream inputStream=spy(new MockInputStream(new Ticker(clock,5,TimeUnit.MILLISECONDS),lines("important message")));
    InputStreamAwaiter awaiter=new InputStreamAwaiter(clock,inputStream);
    awaiter.awaitLine("important message",5,TimeUnit.SECONDS);
  }
  @Test void shouldTimeoutWhenDifferentContentProvided(){
    FakeClock clock=getFakeClock();
    InputStream inputStream=spy(new MockInputStream(new Ticker(clock,1,TimeUnit.SECONDS),lines("different content"),lines("different message")));
    InputStreamAwaiter awaiter=new InputStreamAwaiter(clock,inputStream);
    assertThrows(TimeoutException.class,() -> awaiter.awaitLine("important message",5,TimeUnit.SECONDS));
  }
  @Test void shouldTimeoutWhenNoContentProvided() throws Exception {
    FakeClock clock=getFakeClock();
    InputStream inputStream=spy(new MockInputStream(new Ticker(clock,1,TimeUnit.SECONDS)));
    InputStreamAwaiter awaiter=new InputStreamAwaiter(clock,inputStream);
    assertThrows(TimeoutException.class,() -> awaiter.awaitLine("important message",5,TimeUnit.SECONDS));
  }
  private static String lines(  String... lines){
    StringBuilder result=new StringBuilder();
    for (    String line : lines) {
      result.append(line).append(System.lineSeparator());
    }
    return result.toString();
  }
  private static FakeClock getFakeClock(){
    return Clocks.fakeClock();
  }
private static class Ticker {
    private final FakeClock clock;
    private final long duration;
    private final TimeUnit timeUnit;
    Ticker(    FakeClock clock,    long duration,    TimeUnit timeUnit){
      this.clock=clock;
      this.duration=duration;
      this.timeUnit=timeUnit;
    }
    void tick(){
      clock.forward(duration,timeUnit);
    }
  }
private static class MockInputStream extends InputStream {
    private final Ticker ticker;
    private final byte[][] chunks;
    private int chunk;
    MockInputStream(    Ticker ticker,    String... chunks){
      this.ticker=ticker;
      this.chunks=new byte[chunks.length][];
      for (int i=0; i < chunks.length; i++) {
        this.chunks[i]=chunks[i].getBytes();
      }
    }
    @Override public int available(){
      ticker.tick();
      if (chunk >= chunks.length) {
        return 0;
      }
      return chunks[chunk].length;
    }
    @Override public int read(    byte[] target){
      if (chunk >= chunks.length) {
        return 0;
      }
      byte[] source=chunks[chunk++];
      System.arraycopy(source,0,target,0,source.length);
      return source.length;
    }
    @Override public int read(){
      throw new UnsupportedOperationException();
    }
  }
}
