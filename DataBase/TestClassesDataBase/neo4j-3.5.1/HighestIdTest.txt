public class HighestIdTest {
  @Rule public final RepeatRule repeater=new RepeatRule();
  @Repeat(times=100) @Test public void shouldKeepHighest() throws Throwable {
    Race race=new Race();
    HighestId highestId=new HighestId();
    int threads=Runtime.getRuntime().availableProcessors();
    CountDownLatch latch=new CountDownLatch(threads);
    AtomicLongArray highestIds=new AtomicLongArray(threads);
    for (int c=0; c < threads; c++) {
      int cc=c;
      race.addContestant(new Runnable(){
        boolean run;
        ThreadLocalRandom random=ThreadLocalRandom.current();
        @Override public void run(){
          if (run) {
            return;
          }
          long highest=0;
          for (int i=0; i < 10; i++) {
            long nextLong=random.nextLong(100);
            highestId.offer(nextLong);
            highest=max(highest,nextLong);
          }
          highestIds.set(cc,highest);
          latch.countDown();
          run=true;
        }
      }
);
    }
    race.withEndCondition(() -> latch.getCount() == 0);
    race.go();
    long highest=0;
    for (int i=0; i < threads; i++) {
      highest=max(highest,highestIds.get(i));
    }
    assertEquals(highest,highestId.get());
  }
}
