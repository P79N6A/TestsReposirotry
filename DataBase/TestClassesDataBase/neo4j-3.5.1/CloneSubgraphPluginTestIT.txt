public class CloneSubgraphPluginTestIT extends ExclusiveServerTestBase {
  private static final RelationshipType KNOWS=RelationshipType.withName("knows");
  private static final RelationshipType WORKED_FOR=RelationshipType.withName("worked_for");
  private static NeoServer server;
  private static FunctionalTestHelper functionalTestHelper;
  @BeforeClass public static void setupServer() throws IOException {
    server=ServerHelper.createNonPersistentServer();
    functionalTestHelper=new FunctionalTestHelper(server);
  }
  @AfterClass public static void shutdownServer(){
    try {
      if (server != null) {
        server.stop();
      }
    }
  finally {
      server=null;
    }
  }
  @Before public void setupTheDatabase(){
    ServerHelper.cleanTheDatabase(server);
    createASocialNetwork(server.getDatabase().getGraph());
  }
  private Node jw;
  private void createASocialNetwork(  GraphDatabaseService db){
    try (Transaction tx=db.beginTx()){
      jw=db.createNode();
      jw.setProperty("name","jim");
      Node sp=db.createNode();
      sp.setProperty("name","savas");
      Node bg=db.createNode();
      bg.setProperty("name","bill");
      Node th=db.createNode();
      th.setProperty("name","tony");
      Node rj=db.createNode();
      rj.setProperty("name","rhodri");
      rj.setProperty("hobby","family");
      Node nj=db.createNode();
      nj.setProperty("name","ned");
      nj.setProperty("hobby","cs");
      Node ml=db.createNode();
      ml.setProperty("name","mark");
      Node mf=db.createNode();
      mf.setProperty("name","martin");
      Node rp=db.createNode();
      rp.setProperty("name","rebecca");
      Node rs=db.createNode();
      rs.setProperty("name","roy");
      Node sc=db.createNode();
      sc.setProperty("name","steve");
      sc.setProperty("hobby","cloud");
      Node sw=db.createNode();
      sw.setProperty("name","stuart");
      sw.setProperty("hobby","cs");
      jw.createRelationshipTo(sp,KNOWS);
      jw.createRelationshipTo(mf,KNOWS);
      jw.createRelationshipTo(rj,KNOWS);
      rj.createRelationshipTo(nj,KNOWS);
      mf.createRelationshipTo(rp,KNOWS);
      mf.createRelationshipTo(rs,KNOWS);
      sp.createRelationshipTo(bg,KNOWS);
      sp.createRelationshipTo(th,KNOWS);
      sp.createRelationshipTo(mf,KNOWS);
      sp.createRelationshipTo(ml,WORKED_FOR);
      ml.createRelationshipTo(sc,KNOWS);
      ml.createRelationshipTo(sw,KNOWS);
      jw.setProperty("hobby","cs");
      sp.setProperty("hobby","cs");
      bg.setProperty("hobby","cs");
      ml.setProperty("hobby","cs");
      mf.setProperty("hobby","cs");
      rp.setProperty("hobby","lisp");
      rs.setProperty("hobby","socialism");
      th.setProperty("hobby","fishing");
      tx.success();
    }
   }
  @Test public void shouldAdvertiseExtensionThatPluginCreates() throws JsonParseException, ClientHandlerException, UniformInterfaceException {
    int originalCount=nodeCount();
    JaxRsResponse response=new RestRequest().get(functionalTestHelper.dataUri() + "node/1");
    String entity=response.getEntity();
    Map<String,Object> map=JsonHelper.jsonToMap(entity);
    HashMap<?,?> extensionsMap=(HashMap<?,?>)map.get("extensions");
    assertNotNull(extensionsMap);
    assertFalse(extensionsMap.isEmpty());
    final String GRAPH_CLONER_KEY="GraphCloner";
    assertTrue(extensionsMap.keySet().contains(GRAPH_CLONER_KEY));
    final String CLONE_SUBGRAPH_KEY="clonedSubgraph";
    String clonedSubgraphUri=(String)((HashMap<?,?>)extensionsMap.get(GRAPH_CLONER_KEY)).get(CLONE_SUBGRAPH_KEY);
    assertNotNull(clonedSubgraphUri);
    final String CLONE_DEPTH_MUCH_LARGER_THAN_THE_GRAPH="99";
    response.close();
    response=new RestRequest().post(clonedSubgraphUri,"depth=" + CLONE_DEPTH_MUCH_LARGER_THAN_THE_GRAPH,MediaType.APPLICATION_FORM_URLENCODED_TYPE);
    assertEquals(response.getEntity(),200,response.getStatus());
    int doubleTheNumberOfNodes=originalCount * 2;
    assertEquals(doubleTheNumberOfNodes,nodeCount());
  }
  private int nodeCount(){
    try (Transaction ignore=server.getDatabase().getGraph().beginTx()){
      return Math.toIntExact(server.getDatabase().getGraph().getAllNodes().stream().count());
    }
   }
}
