public class LuceneRecoveryIT {
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  @Rule public final VerboseTimeout timeout=VerboseTimeout.builder().withTimeout(30,MINUTES).build();
  @Test public void testHardCoreRecovery() throws Exception {
    String path=testDirectory.storeDir().getPath();
    Process process=Runtime.getRuntime().exec(new String[]{getJavaExecutable().toString(),"-cp",ProcessUtil.getClassPath(),Inserter.class.getName(),path});
    awaitFile(new File(path,"started"));
    Thread.sleep(5000);
    process.destroy();
    process.waitFor();
    GraphDatabaseService db=null;
    try {
      db=new TestGraphDatabaseFactory().newEmbeddedDatabase(testDirectory.storeDir());
      try (Transaction transaction=db.beginTx()){
        assertTrue(db.index().existsForNodes("myIndex"));
        Index<Node> index=db.index().forNodes("myIndex");
        for (        Node node : db.getAllNodes()) {
          for (          String key : node.getPropertyKeys()) {
            String value=(String)node.getProperty(key);
            boolean found=false;
            try (IndexHits<Node> indexHits=index.get(key,value)){
              for (              Node indexedNode : indexHits) {
                if (indexedNode.equals(node)) {
                  found=true;
                  break;
                }
              }
            }
             if (!found) {
              throw new IllegalStateException(node + " has property '" + key+ "'='"+ value+ "', but not in index");
            }
          }
        }
      }
 catch (      Throwable e) {
        if (Exceptions.contains(e,CorruptIndexException.class) || exceptionContainsStackTraceElementFromPackage(e,"org.apache.lucene")) {
          System.err.println("Lucene exception happened during recovery after a real crash. " + "It may be that the index is corrupt somehow and this is out of control and not " + "something this test can really improve on right now. Printing the exception for reference");
          e.printStackTrace();
          return;
        }
        throw e;
      }
      NodeCreator nodeCreator=new NodeCreator(db);
      Thread t=new Thread(nodeCreator);
      t.start();
      t.join();
    }
  finally {
      if (db != null) {
        db.shutdown();
      }
    }
  }
  private static boolean exceptionContainsStackTraceElementFromPackage(  Throwable e,  String packageName){
    for (    StackTraceElement element : e.getStackTrace()) {
      if (element.getClassName().startsWith(packageName)) {
        return true;
      }
    }
    return false;
  }
  private static void awaitFile(  File file) throws InterruptedException {
    long end=System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(300);
    while (!file.exists() && System.currentTimeMillis() < end) {
      Thread.sleep(100);
    }
    if (!file.exists()) {
      fail("The inserter doesn't seem to have run properly");
    }
  }
private static class NodeCreator implements Runnable {
    private final GraphDatabaseService db;
    NodeCreator(    GraphDatabaseService db){
      this.db=db;
    }
    @Override public void run(){
      try (Transaction tx=db.beginTx()){
        Index<Node> index=db.index().forNodes("myIndex");
        index.add(db.createNode(),"one","two");
        tx.success();
      }
     }
  }
}
