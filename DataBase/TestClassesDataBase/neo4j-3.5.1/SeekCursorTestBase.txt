@ExtendWith(RandomExtension.class) abstract class SeekCursorTestBase<KEY,VALUE> {
  private static final int PAGE_SIZE=256;
  private static long stableGeneration=GenerationSafePointer.MIN_GENERATION;
  private static long unstableGeneration=stableGeneration + 1;
  private static final LongSupplier generationSupplier=() -> Generation.generation(stableGeneration,unstableGeneration);
  private static final Supplier<Root> failingRootCatchup=() -> {
    throw new AssertionError("Should not happen");
  }
;
  private static final Consumer<Throwable> exceptionDecorator=t -> {
  }
;
  @Inject private RandomRule random;
  private TestLayout<KEY,VALUE> layout;
  private TreeNode<KEY,VALUE> node;
  private InternalTreeLogic<KEY,VALUE> treeLogic;
  private StructurePropagation<KEY> structurePropagation;
  private PageAwareByteArrayCursor cursor;
  private PageAwareByteArrayCursor utilCursor;
  private SimpleIdProvider id;
  private long rootId;
  private int numberOfRootSplits;
  @BeforeEach void setUp() throws IOException {
    cursor=new PageAwareByteArrayCursor(PAGE_SIZE);
    utilCursor=cursor.duplicate();
    id=new SimpleIdProvider(cursor::duplicate);
    layout=getLayout();
    node=getTreeNode(PAGE_SIZE,layout);
    treeLogic=new InternalTreeLogic<>(id,node,layout);
    structurePropagation=new StructurePropagation<>(layout.newKey(),layout.newKey(),layout.newKey());
    long firstPage=id.acquireNewId(stableGeneration,unstableGeneration);
    goTo(cursor,firstPage);
    goTo(utilCursor,firstPage);
    node.initializeLeaf(cursor,stableGeneration,unstableGeneration);
    updateRoot();
  }
  abstract TestLayout<KEY,VALUE> getLayout();
  abstract TreeNode<KEY,VALUE> getTreeNode(  int pageSize,  TestLayout<KEY,VALUE> layout);
  private static void goTo(  PageCursor cursor,  long pageId) throws IOException {
    PageCursorUtil.goTo(cursor,"test",pointer(pageId));
  }
  private void updateRoot(){
    rootId=cursor.getCurrentPageId();
    treeLogic.initialize(cursor);
  }
  @Test void mustFindEntriesWithinRangeInBeginningOfSingleLeaf() throws Exception {
    long lastSeed=fullLeaf();
    long fromInclusive=0;
    long toExclusive=lastSeed / 2;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesWithinRangeInBeginningOfSingleLeafBackwards() throws Exception {
    long maxKeyCount=fullLeaf();
    long fromInclusive=maxKeyCount / 2;
    long toExclusive=-1;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesWithinRangeInEndOfSingleLeaf() throws Exception {
    long maxKeyCount=fullLeaf();
    long fromInclusive=maxKeyCount / 2;
    long toExclusive=maxKeyCount;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesWithinRangeInEndOfSingleLeafBackwards() throws Exception {
    long maxKeyCount=fullLeaf();
    long fromInclusive=maxKeyCount - 1;
    long toExclusive=maxKeyCount / 2;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesWithinRangeInMiddleOfSingleLeaf() throws Exception {
    long maxKeyCount=fullLeaf();
    long middle=maxKeyCount / 2;
    long fromInclusive=middle / 2;
    long toExclusive=(middle + maxKeyCount) / 2;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesWithinRangeInMiddleOfSingleLeafBackwards() throws Exception {
    long maxKeyCount=fullLeaf();
    long middle=maxKeyCount / 2;
    long fromInclusive=(middle + maxKeyCount) / 2;
    long toExclusive=middle / 2;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesSpanningTwoLeaves() throws Exception {
    long i=fullLeaf();
    long left=createRightSibling(cursor);
    i=fullLeaf(i);
    cursor.next(left);
    long fromInclusive=0;
    long toExclusive=i;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesSpanningTwoLeavesBackwards() throws Exception {
    long i=fullLeaf();
    createRightSibling(cursor);
    i=fullLeaf(i);
    long fromInclusive=i - 1;
    long toExclusive=-1;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustFindEntriesOnSecondLeafWhenStartingFromFirstLeaf() throws Exception {
    long i=fullLeaf();
    long left=createRightSibling(cursor);
    long j=fullLeaf(i);
    cursor.next(left);
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(i,j)){
      assertRangeInSingleLeaf(i,j,cursor);
    }
   }
  @Test void mustFindEntriesOnSecondLeafWhenStartingFromFirstLeafBackwards() throws Exception {
    long leftKeyCount=fullLeaf();
    long left=createRightSibling(cursor);
    fullLeaf(leftKeyCount);
    cursor.next(left);
    long fromInclusive=leftKeyCount - 1;
    long toExclusive=-1;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
   }
  @Test void mustNotContinueToSecondLeafAfterFindingEndOfRangeInFirst() throws Exception {
    AtomicBoolean nextCalled=new AtomicBoolean();
    PageCursor pageCursorSpy=new DelegatingPageCursor(cursor){
      @Override public boolean next(      long pageId) throws IOException {
        nextCalled.set(true);
        return super.next(pageId);
      }
    }
;
    long i=fullLeaf();
    long left=createRightSibling(cursor);
    long j=fullLeaf(i);
    long fromInclusive=j - 1;
    long toExclusive=i;
    nextCalled.set(false);
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,pageCursorSpy)){
      assertRangeInSingleLeaf(fromInclusive,toExclusive,cursor);
    }
     assertFalse(nextCalled.get(),"Cursor continued to next leaf even though end of range is within first leaf");
  }
  @Test void shouldHandleEmptyRange(){
    Assertions.assertTimeoutPreemptively(Duration.ofSeconds(5),() -> {
      insert(0);
      insert(2);
      long fromInclusive=1;
      long toExclusive=2;
      try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
        assertFalse(cursor.next());
      }
     }
);
  }
  @Test void shouldHandleEmptyRangeBackwards(){
    Assertions.assertTimeoutPreemptively(Duration.ofSeconds(5),() -> {
      insert(0);
      insert(2);
      long fromInclusive=1;
      long toExclusive=0;
      try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
        assertFalse(cursor.next());
      }
     }
);
  }
  @Test void shouldHandleBackwardsWithNoExactHitOnFromInclusive(){
    Assertions.assertTimeoutPreemptively(Duration.ofSeconds(5),() -> {
      insert(0);
      insert(2);
      long fromInclusive=3;
      long toExclusive=0;
      try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
        assertTrue(cursor.next());
        assertFalse(cursor.next());
      }
     }
);
  }
  @Test void shouldHandleBackwardsWithExactHitOnFromInclusive(){
    Assertions.assertTimeoutPreemptively(Duration.ofSeconds(5),() -> {
      insert(0);
      insert(2);
      long fromInclusive=2;
      long toExclusive=0;
      try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
        assertTrue(cursor.next());
        assertFalse(cursor.next());
      }
     }
);
  }
  @Test void mustFindKeysWhenGivenRangeStartingOutsideStartOfData() throws Exception {
    long maxKeyCount=fullLeaf();
    long expectedKey=0;
    try (SeekCursor<KEY,VALUE> seekCursor=seekCursor(-1,maxKeyCount - 1)){
      while (seekCursor.next()) {
        assertKeyAndValue(seekCursor,expectedKey);
        expectedKey++;
      }
    }
     assertEquals(expectedKey,maxKeyCount - 1);
  }
  @Test void mustFindKeysWhenGivenRangeStartingOutsideStartOfDataBackwards() throws Exception {
    long maxKeyCount=fullLeaf();
    long expectedKey=maxKeyCount - 1;
    try (SeekCursor<KEY,VALUE> seekCursor=seekCursor(maxKeyCount,0)){
      while (seekCursor.next()) {
        assertKeyAndValue(seekCursor,expectedKey);
        expectedKey--;
      }
    }
     assertEquals(expectedKey,0);
  }
  @Test void mustFindKeysWhenGivenRangeEndingOutsideEndOfData() throws Exception {
    long maxKeyCount=fullLeaf();
    long expectedKey=0;
    try (SeekCursor<KEY,VALUE> seekCursor=seekCursor(0,maxKeyCount + 1)){
      while (seekCursor.next()) {
        assertKeyAndValue(seekCursor,expectedKey);
        expectedKey++;
      }
    }
     assertEquals(expectedKey,maxKeyCount);
  }
  @Test void mustFindKeysWhenGivenRangeEndingOutsideEndOfDataBackwards() throws Exception {
    long maxKeyCount=fullLeaf();
    long expectedKey=maxKeyCount - 1;
    try (SeekCursor<KEY,VALUE> seekCursor=seekCursor(maxKeyCount - 1,-2)){
      while (seekCursor.next()) {
        assertKeyAndValue(seekCursor,expectedKey);
        expectedKey--;
      }
    }
     assertEquals(expectedKey,-1);
  }
  @Test void mustStartReadingFromCorrectLeafWhenRangeStartWithKeyEqualToPrimKey() throws Exception {
    long lastSeed=rootWithTwoLeaves();
    KEY primKey=layout.newKey();
    node.keyAt(cursor,primKey,0,INTERNAL);
    long expectedNext=getSeed(primKey);
    long rightChild=GenerationSafePointerPair.pointer(node.childAt(cursor,1,stableGeneration,unstableGeneration));
    try (SeekCursor<KEY,VALUE> seek=seekCursor(expectedNext,lastSeed)){
      assertEquals(rightChild,cursor.getCurrentPageId());
      while (seek.next()) {
        assertKeyAndValue(seek,expectedNext);
        expectedNext++;
      }
    }
     assertEquals(lastSeed,expectedNext);
  }
  @Test void mustStartReadingFromCorrectLeafWhenRangeStartWithKeyEqualToPrimKeyBackwards() throws Exception {
    rootWithTwoLeaves();
    KEY primKey=layout.newKey();
    node.keyAt(cursor,primKey,0,INTERNAL);
    long expectedNext=getSeed(primKey);
    long rightChild=GenerationSafePointerPair.pointer(node.childAt(cursor,1,stableGeneration,unstableGeneration));
    try (SeekCursor<KEY,VALUE> seek=seekCursor(expectedNext,-1)){
      assertEquals(rightChild,cursor.getCurrentPageId());
      while (seek.next()) {
        assertKeyAndValue(seek,expectedNext);
        expectedNext--;
      }
    }
     assertEquals(-1,expectedNext);
  }
  @Test void exactMatchInStableRoot() throws Exception {
    long maxKeyCount=fullLeaf();
    for (long i=0; i < maxKeyCount; i++) {
      assertExactMatch(i);
    }
  }
  @Test void exactMatchInLeaves() throws Exception {
    long lastSeed=rootWithTwoLeaves();
    for (long i=0; i < lastSeed; i++) {
      assertExactMatch(i);
    }
  }
  private long rootWithTwoLeaves() throws IOException {
    long i=0;
    for (; numberOfRootSplits < 1; i++) {
      insert(i);
    }
    return i;
  }
  private void assertExactMatch(  long i) throws IOException {
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(i,i)){
      assertTrue(seeker.next());
      assertEqualsKey(key(i),seeker.get().key());
      assertEqualsValue(value(i),seeker.get().value());
      assertFalse(seeker.next());
    }
   }
  @Test void mustFindNewKeyInsertedAfterOfSeekPoint() throws Exception {
    int middle=2;
    for (int i=0; i < middle; i++) {
      append(i);
    }
    long fromInclusive=0;
    long toExclusive=middle + 1;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      int stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        assertKeyAndValue(cursor,readKeys);
        readKeys++;
      }
      append(middle);
      this.cursor.forceRetry();
      while (cursor.next()) {
        assertKeyAndValue(cursor,readKeys);
        readKeys++;
      }
      assertEquals(toExclusive,readKeys);
    }
   }
  @Test void mustFindNewKeyInsertedAfterOfSeekPointBackwards() throws Exception {
    int middle=2;
    for (int i=1; i <= middle; i++) {
      append(i);
    }
    long fromInclusive=middle;
    long toExclusive=0;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      int stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        assertKeyAndValue(cursor,middle - readKeys);
        readKeys++;
      }
      insertIn(0,0);
      this.cursor.forceRetry();
      while (cursor.next()) {
        assertKeyAndValue(cursor,middle - readKeys);
        readKeys++;
      }
      assertEquals(toExclusive,middle - readKeys);
    }
   }
  @Test void mustFindKeyInsertedOnSeekPosition() throws Exception {
    List<Long> expected=new ArrayList<>();
    int middle=2;
    for (int i=0; i < middle; i++) {
      long key=i * 2;
      append(key);
      expected.add(key);
    }
    long fromInclusive=0;
    long toExclusive=middle * 2;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      int stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      long midInsert=expected.get(stopPoint) - 1;
      insertIn(stopPoint,midInsert);
      expected.add(stopPoint,midInsert);
      this.cursor.forceRetry();
      while (cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustFindKeyInsertedOnSeekPositionBackwards() throws Exception {
    List<Long> expected=new ArrayList<>();
    int middle=2;
    for (int i=middle; i > 0; i--) {
      long key=i * 2;
      insert(key);
      expected.add(key);
    }
    long fromInclusive=middle * 2;
    long toExclusive=0;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      int stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      long midInsert=expected.get(stopPoint) + 1;
      insert(midInsert);
      expected.add(stopPoint,midInsert);
      this.cursor.forceRetry();
      while (cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustNotFindKeyInsertedBeforeOfSeekPoint() throws Exception {
    List<Long> expected=new ArrayList<>();
    int middle=2;
    for (int i=0; i < middle; i++) {
      long key=i * 2;
      append(key);
      expected.add(key);
    }
    long fromInclusive=0;
    long toExclusive=middle * 2;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      int stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      long midInsert=expected.get(readKeys - 1) - 1;
      insertIn(stopPoint - 1,midInsert);
      this.cursor.forceRetry();
      while (cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustNotFindKeyInsertedBeforeOfSeekPointBackwards() throws Exception {
    List<Long> expected=new ArrayList<>();
    int middle=2;
    for (int i=middle; i > 0; i--) {
      long key=i * 2;
      insert(key);
      expected.add(key);
    }
    long fromInclusive=middle * 2;
    long toExclusive=0;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      int stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      long midInsert=expected.get(readKeys - 1) + 1;
      insert(midInsert);
      this.cursor.forceRetry();
      while (cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustContinueToNextLeafWhenRangeIsSplitIntoRightLeafAndPosToLeft() throws Exception {
    List<Long> expected=new ArrayList<>();
    long maxKeyCount=fullLeaf(expected);
    long fromInclusive=0;
    long toExclusive=maxKeyCount + 1;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=maxKeyCount / 2;
      long stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      expected.add(maxKeyCount);
      insert(maxKeyCount);
      seekCursor.forceRetry();
      while (cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustContinueToNextLeafWhenRangeIsSplitIntoRightLeafAndPosToRightBackwards() throws Exception {
    List<Long> expected=new ArrayList<>();
    long lastSeed=fullLeaf(1,expected);
    Collections.reverse(expected);
    long fromInclusive=lastSeed - 1;
    long toExclusive=-1;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=lastSeed / 2;
      long stopPoint=middle / 2;
      int readKeys=0;
      while (readKeys < stopPoint && seeker.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(seeker,key);
        readKeys++;
      }
      expected.add(0L);
      insert(0L);
      seekCursor.forceRetry();
      while (seeker.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(seeker,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustContinueToNextLeafWhenRangeIsSplitIntoRightLeafAndPosToRight() throws Exception {
    List<Long> expected=new ArrayList<>();
    long maxKeyCount=fullLeaf(expected);
    long fromInclusive=0;
    long toExclusive=maxKeyCount + 1;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=maxKeyCount / 2;
      long stopPoint=middle + (middle / 2);
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      expected.add(maxKeyCount);
      insert(maxKeyCount);
      seekCursor.forceRetry();
      while (cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustContinueToNextLeafWhenRangeIsSplitIntoRightLeafAndPosToLeftBackwards() throws Exception {
    List<Long> expected=new ArrayList<>();
    long lastSeed=fullLeaf(1,expected);
    Collections.reverse(expected);
    long fromInclusive=lastSeed - 1;
    long toExclusive=-1;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=lastSeed / 2;
      long stopPoint=middle + (middle / 2);
      int readKeys=0;
      while (readKeys < stopPoint && cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      expected.add(0L);
      insert(0L);
      seekCursor.forceRetry();
      while (cursor.next()) {
        long key=expected.get(readKeys);
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(expected.size(),readKeys);
    }
   }
  @Test void mustNotFindKeyRemovedInFrontOfSeeker() throws Exception {
    long maxKeyCount=fullLeaf();
    long fromInclusive=0;
    long toExclusive=maxKeyCount;
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive)){
      long middle=maxKeyCount / 2;
      int readKeys=0;
      while (readKeys < middle && cursor.next()) {
        long key=readKeys;
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      removeAtPos((int)maxKeyCount - 1);
      this.cursor.forceRetry();
      while (cursor.next()) {
        long key=readKeys;
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(maxKeyCount - 1,readKeys);
    }
   }
  private long fullLeaf(  List<Long> expectedSeeds){
    return fullLeaf(0,expectedSeeds);
  }
  private long fullLeaf(  long firstSeed){
    return fullLeaf(firstSeed,new ArrayList<>());
  }
  private long fullLeaf(  long firstSeed,  List<Long> expectedSeeds){
    int keyCount=0;
    KEY key=key(firstSeed + keyCount);
    VALUE value=value(firstSeed + keyCount);
    while (node.leafOverflow(cursor,keyCount,key,value) == TreeNode.Overflow.NO) {
      node.insertKeyValueAt(cursor,key,value,keyCount,keyCount);
      expectedSeeds.add(firstSeed + keyCount);
      keyCount++;
      key=key(firstSeed + keyCount);
      value=value(firstSeed + keyCount);
    }
    TreeNode.setKeyCount(cursor,keyCount);
    return firstSeed + keyCount;
  }
  /** 
 * @return next seed to be inserted
 */
  private long fullLeaf(){
    return fullLeaf(0);
  }
  private KEY key(  long seed){
    return layout.key(seed);
  }
  private VALUE value(  long seed){
    return layout.value(seed);
  }
  private long getSeed(  KEY primKey){
    return layout.keySeed(primKey);
  }
  @Test void mustNotFindKeyRemovedInFrontOfSeekerBackwards() throws Exception {
    long lastSeed=fullLeaf(1);
    long maxKeyCount=lastSeed - 1;
    long fromInclusive=maxKeyCount;
    long toExclusive=0;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=maxKeyCount / 2;
      int readKeys=0;
      while (readKeys < middle && seeker.next()) {
        assertKeyAndValue(seeker,maxKeyCount - readKeys);
        readKeys++;
      }
      remove(1);
      seekCursor.forceRetry();
      while (seeker.next()) {
        assertKeyAndValue(seeker,maxKeyCount - readKeys);
        readKeys++;
      }
      assertEquals(maxKeyCount - 1,readKeys);
    }
   }
  @Test void mustFindKeyMovedPassedSeekerBecauseOfRemove() throws Exception {
    long maxKeyCount=fullLeaf();
    long fromInclusive=0;
    long toExclusive=maxKeyCount;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=maxKeyCount / 2;
      int readKeys=0;
      while (readKeys < middle && cursor.next()) {
        long key=readKeys;
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      removeAtPos(0);
      seekCursor.forceRetry();
      while (cursor.next()) {
        long key=readKeys;
        assertKeyAndValue(cursor,key);
        readKeys++;
      }
      assertEquals(maxKeyCount,readKeys);
    }
   }
  @Test void mustFindKeyMovedPassedSeekerBecauseOfRemoveBackwards() throws Exception {
    long lastSeed=fullLeaf(1);
    long maxKeyCount=lastSeed - 1;
    long fromInclusive=maxKeyCount;
    long toExclusive=0;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=maxKeyCount / 2;
      int readKeys=0;
      while (readKeys < middle && cursor.next()) {
        assertKeyAndValue(cursor,maxKeyCount - readKeys);
        readKeys++;
      }
      remove(maxKeyCount);
      seekCursor.forceRetry();
      while (cursor.next()) {
        assertKeyAndValue(cursor,maxKeyCount - readKeys);
        readKeys++;
      }
      assertEquals(maxKeyCount,readKeys);
    }
   }
  @Test void mustFindKeyMovedSeekerBecauseOfRemoveOfMostRecentReturnedKey() throws Exception {
    long maxKeyCount=fullLeaf();
    long fromInclusive=0;
    long toExclusive=maxKeyCount;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=maxKeyCount / 2;
      int readKeys=0;
      while (readKeys < middle && cursor.next()) {
        assertKeyAndValue(cursor,readKeys);
        readKeys++;
      }
      remove(readKeys - 1);
      seekCursor.forceRetry();
      while (cursor.next()) {
        assertKeyAndValue(cursor,readKeys);
        readKeys++;
      }
      assertEquals(maxKeyCount,readKeys);
    }
   }
  @Test void mustFindKeyMovedSeekerBecauseOfRemoveOfMostRecentReturnedKeyBackwards() throws Exception {
    long i=fullLeaf(1);
    long maxKeyCount=i - 1;
    long fromInclusive=i - 1;
    long toExclusive=0;
    PageAwareByteArrayCursor seekCursor=cursor.duplicate();
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> cursor=seekCursor(fromInclusive,toExclusive,seekCursor)){
      long middle=maxKeyCount / 2;
      int readKeys=0;
      while (readKeys < middle && cursor.next()) {
        assertKeyAndValue(cursor,maxKeyCount - readKeys);
        readKeys++;
      }
      remove(maxKeyCount - readKeys + 1);
      seekCursor.forceRetry();
      while (cursor.next()) {
        assertKeyAndValue(cursor,maxKeyCount - readKeys);
        readKeys++;
      }
      assertEquals(maxKeyCount,readKeys);
    }
   }
  @Test void mustRereadHeadersOnRetry() throws Exception {
    int keyCount=2;
    insertKeysAndValues(keyCount);
    KEY from=key(0);
    KEY to=key(keyCount + 1);
    try (SeekCursor<KEY,VALUE> cursor=new SeekCursor<>(this.cursor,node,from,to,layout,stableGeneration,unstableGeneration,() -> 0L,failingRootCatchup,unstableGeneration,exceptionDecorator,1)){
      assertTrue(cursor.next());
      assertEqualsKey(key(0),cursor.get().key());
      append(keyCount);
      this.cursor.forceRetry();
      assertTrue(cursor.next());
      assertEqualsKey(key(1),cursor.get().key());
      long lastFoundKey=1;
      while (cursor.next()) {
        assertEqualsKey(key(lastFoundKey + 1),cursor.get().key());
        lastFoundKey=getSeed(cursor.get().key());
      }
      assertEquals(keyCount,lastFoundKey);
    }
   }
  @Test void mustFindRangeWhenCompletelyRebalancedToTheRightBeforeCallToNext() throws Exception {
    long key=10;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    for (long smallKey=0; smallKey < 2; smallKey++) {
      insert(smallKey);
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(leftChild));
    int keyCount=TreeNode.keyCount(readCursor);
    KEY readKey=layout.newKey();
    node.keyAt(readCursor,readKey,keyCount - 1,LEAF);
    long fromInclusive=getSeed(readKey);
    long toExclusive=fromInclusive + 1;
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      triggerUnderflowAndSeekRange(seeker,seekCursor,fromInclusive,toExclusive,rightChild);
    }
   }
  @Test void mustFindRangeWhenCompletelyRebalancedToTheRightBeforeCallToNextBackwards() throws Exception {
    long key=10;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    for (long smallKey=0; smallKey < 2; smallKey++) {
      insert(smallKey);
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(leftChild));
    int keyCount=TreeNode.keyCount(readCursor);
    KEY from=layout.newKey();
    node.keyAt(readCursor,from,keyCount - 1,LEAF);
    long fromInclusive=getSeed(from);
    long toExclusive=fromInclusive - 1;
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      triggerUnderflowAndSeekRange(seeker,seekCursor,fromInclusive,toExclusive,rightChild);
    }
   }
  @Test void mustFindRangeWhenCompletelyRebalancedToTheRightAfterCallToNext() throws Exception {
    long key=10;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    for (long smallKey=0; smallKey < 2; smallKey++) {
      insert(smallKey);
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(leftChild));
    int keyCount=TreeNode.keyCount(readCursor);
    KEY from=layout.newKey();
    KEY to=layout.newKey();
    node.keyAt(readCursor,from,keyCount - 2,LEAF);
    node.keyAt(readCursor,to,keyCount - 1,LEAF);
    long fromInclusive=getSeed(from);
    long toExclusive=getSeed(to) + 1;
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      seekRangeWithUnderflowMidSeek(seeker,seekCursor,fromInclusive,toExclusive,rightChild);
    }
   }
  @Test void mustFindRangeWhenCompletelyRebalancedToTheRightAfterCallToNextBackwards() throws Exception {
    long key=10;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    for (long smallKey=0; smallKey < 2; smallKey++) {
      insert(smallKey);
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(leftChild));
    int keyCount=TreeNode.keyCount(readCursor);
    KEY from=layout.newKey();
    KEY to=layout.newKey();
    node.keyAt(readCursor,from,keyCount - 1,LEAF);
    node.keyAt(readCursor,to,keyCount - 2,LEAF);
    long fromInclusive=getSeed(from);
    long toExclusive=getSeed(to) - 1;
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      seekRangeWithUnderflowMidSeek(seeker,seekCursor,fromInclusive,toExclusive,rightChild);
    }
   }
  @Test void mustFindRangeWhenMergingFromCurrentSeekNode() throws Exception {
    long key=0;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(leftChild));
    KEY from=layout.newKey();
    node.keyAt(readCursor,from,0,LEAF);
    long fromInclusive=getSeed(from);
    long toExclusive=getSeed(from) + 2;
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      assertThat(seekCursor.getCurrentPageId(),is(leftChild));
      seekRangeWithUnderflowMidSeek(seeker,seekCursor,fromInclusive,toExclusive,rightChild);
      readCursor.next(rootId);
      assertTrue(TreeNode.isLeaf(readCursor));
    }
   }
  @Test void mustFindRangeWhenMergingToCurrentSeekNode() throws Exception {
    long key=0;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(rightChild));
    int keyCount=TreeNode.keyCount(readCursor);
    long fromInclusive=keyAt(readCursor,keyCount - 3,LEAF);
    long toExclusive=keyAt(readCursor,keyCount - 1,LEAF);
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      assertThat(seekCursor.getCurrentPageId(),is(rightChild));
      seekRangeWithUnderflowMidSeek(seeker,seekCursor,fromInclusive,toExclusive,leftChild);
      readCursor.next(rootId);
      assertTrue(TreeNode.isLeaf(readCursor));
    }
   }
  @Test void mustFindRangeWhenMergingToCurrentSeekNodeBackwards() throws Exception {
    long key=0;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(rightChild));
    int keyCount=TreeNode.keyCount(readCursor);
    long fromInclusive=keyAt(readCursor,keyCount - 1,LEAF);
    long toExclusive=keyAt(readCursor,keyCount - 3,LEAF);
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      assertThat(seekCursor.getCurrentPageId(),is(rightChild));
      seekRangeWithUnderflowMidSeek(seeker,seekCursor,fromInclusive,toExclusive,leftChild);
      readCursor.next(rootId);
      assertTrue(TreeNode.isLeaf(readCursor));
    }
   }
  @Test void mustFindRangeWhenMergingFromCurrentSeekNodeBackwards() throws Exception {
    long key=0;
    while (numberOfRootSplits == 0) {
      insert(key);
      key++;
    }
    PageAwareByteArrayCursor readCursor=cursor.duplicate(rootId);
    readCursor.next();
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    readCursor.next(pointer(leftChild));
    KEY from=layout.newKey();
    node.keyAt(readCursor,from,0,LEAF);
    long fromInclusive=getSeed(from) + 2;
    long toExclusive=getSeed(from);
    TestPageCursor seekCursor=new TestPageCursor(cursor.duplicate(rootId));
    seekCursor.next();
    try (SeekCursor<KEY,VALUE> seeker=seekCursor(fromInclusive,toExclusive,seekCursor)){
      assertThat(seekCursor.getCurrentPageId(),is(leftChild));
      seekRangeWithUnderflowMidSeek(seeker,seekCursor,fromInclusive,toExclusive,rightChild);
      readCursor.next(rootId);
      assertTrue(TreeNode.isLeaf(readCursor));
    }
   }
  @Test void shouldRereadSiblingIfReadFailureCausedByConcurrentCheckpoint() throws Exception {
    long i=0L;
    while (numberOfRootSplits == 0) {
      insert(i);
      i++;
    }
    long currentNode=cursor.getCurrentPageId();
    try (SeekCursor<KEY,VALUE> seek=seekCursor(0L,i,cursor)){
      checkpoint();
      PageAwareByteArrayCursor duplicate=cursor.duplicate(currentNode);
      duplicate.next();
      insert(i,i * 10,duplicate);
      while (seek.next()) {
      }
    }
   }
  @Test void shouldFailOnSiblingReadFailureIfNotCausedByConcurrentCheckpoint() throws Exception {
    long i=0L;
    while (numberOfRootSplits == 0) {
      insert(i);
      i++;
    }
    long currentNode=cursor.getCurrentPageId();
    try (SeekCursor<KEY,VALUE> seek=seekCursor(0L,i,cursor)){
      PageAwareByteArrayCursor duplicate=cursor.duplicate(currentNode);
      duplicate.next();
      long leftChild=childAt(duplicate,0,stableGeneration,unstableGeneration);
      duplicate.next(leftChild);
      corruptGSPP(duplicate,TreeNode.BYTE_POS_RIGHTSIBLING);
      checkpoint();
      assertThrows(TreeInconsistencyException.class,() -> {
        while (seek.next()) {
        }
      }
);
    }
   }
  @Test void shouldRereadSuccessorIfReadFailureCausedByCheckpointInLeaf() throws Exception {
    List<Long> expected=new ArrayList<>();
    List<Long> actual=new ArrayList<>();
    long i=0L;
    for (; i < 2; i++) {
      insert(i);
      expected.add(i);
    }
    long currentNode=cursor.getCurrentPageId();
    try (SeekCursor<KEY,VALUE> seek=seekCursor(0L,5,cursor)){
      checkpoint();
      PageAwareByteArrayCursor duplicate=cursor.duplicate(currentNode);
      duplicate.next();
      insert(i,i,duplicate);
      expected.add(i);
      cursor.forceRetry();
      while (seek.next()) {
        Hit<KEY,VALUE> hit=seek.get();
        actual.add(getSeed(hit.key()));
      }
    }
     assertEquals(expected,actual);
  }
  @Test void shouldFailSuccessorIfReadFailureNotCausedByCheckpointInLeaf() throws Exception {
    long i=0L;
    for (; i < 2; i++) {
      insert(i);
    }
    long currentNode=cursor.getCurrentPageId();
    try (SeekCursor<KEY,VALUE> seek=seekCursor(0L,5,cursor)){
      checkpoint();
      PageAwareByteArrayCursor duplicate=cursor.duplicate(currentNode);
      duplicate.next();
      insert(i,i,duplicate);
      corruptGSPP(duplicate,TreeNode.BYTE_POS_SUCCESSOR);
      cursor.forceRetry();
      assertThrows(TreeInconsistencyException.class,() -> {
        while (seek.next()) {
        }
      }
);
    }
   }
  @Test void shouldRereadSuccessorIfReadFailureCausedByCheckpointInInternal() throws Exception {
    long i=0L;
    while (numberOfRootSplits == 0) {
      insert(i);
      i++;
    }
    long oldRootId=rootId;
    long oldStableGeneration=stableGeneration;
    long oldUnstableGeneration=unstableGeneration;
    checkpoint();
    int keyCount=TreeNode.keyCount(cursor);
    while (keyCount(rootId) == keyCount) {
      insert(i);
      i++;
    }
    TreeNode.goTo(cursor,"root",rootId);
    long rightChild=childAt(cursor,2,stableGeneration,unstableGeneration);
    PageAwareByteArrayCursor pageCursorForSeeker=cursor.duplicate(oldRootId);
    BreadcrumbPageCursor breadcrumbCursor=new BreadcrumbPageCursor(pageCursorForSeeker);
    breadcrumbCursor.next();
    try (SeekCursor<KEY,VALUE> seek=seekCursor(i,i + 1,breadcrumbCursor,oldStableGeneration,oldUnstableGeneration)){
      while (seek.next()) {
      }
    }
     assertEquals(Arrays.asList(oldRootId,rootId,rightChild),breadcrumbCursor.getBreadcrumbs());
  }
  private int keyCount(  long nodeId) throws IOException {
    long prevId=cursor.getCurrentPageId();
    try {
      TreeNode.goTo(cursor,"supplied",nodeId);
      return TreeNode.keyCount(cursor);
    }
  finally {
      TreeNode.goTo(cursor,"prev",prevId);
    }
  }
  @Test void shouldFailSuccessorIfReadFailureNotCausedByCheckpointInInternal() throws Exception {
    long i=0L;
    while (numberOfRootSplits == 0) {
      insert(i);
      i++;
    }
    long oldRootId=rootId;
    long oldStableGeneration=stableGeneration;
    long oldUnstableGeneration=unstableGeneration;
    checkpoint();
    int keyCount=TreeNode.keyCount(cursor);
    while (keyCount(rootId) == keyCount) {
      insert(i);
      i++;
    }
    cursor.next(oldRootId);
    corruptGSPP(cursor,TreeNode.BYTE_POS_SUCCESSOR);
    PageAwareByteArrayCursor pageCursorForSeeker=cursor.duplicate(oldRootId);
    pageCursorForSeeker.next();
    long position=i;
    assertThrows(TreeInconsistencyException.class,() -> seekCursor(position,position + 1,pageCursorForSeeker,oldStableGeneration,oldUnstableGeneration));
  }
  @Test void shouldRereadChildPointerIfReadFailureCausedByCheckpoint() throws Exception {
    long i=0L;
    while (numberOfRootSplits == 0) {
      insert(i);
      i++;
    }
    long oldStableGeneration=stableGeneration;
    long oldUnstableGeneration=unstableGeneration;
    checkpoint();
    insert(i);
    i++;
    long newRightChild=childAt(cursor,1,stableGeneration,unstableGeneration);
    PageAwareByteArrayCursor pageCursorForSeeker=cursor.duplicate(rootId);
    BreadcrumbPageCursor breadcrumbCursor=new BreadcrumbPageCursor(pageCursorForSeeker);
    breadcrumbCursor.next();
    try (SeekCursor<KEY,VALUE> seek=seekCursor(i,i + 1,breadcrumbCursor,oldStableGeneration,oldUnstableGeneration)){
      while (seek.next()) {
      }
    }
     assertEquals(Arrays.asList(rootId,newRightChild),breadcrumbCursor.getBreadcrumbs());
  }
  @Test void shouldFailChildPointerIfReadFailureNotCausedByCheckpoint() throws Exception {
    long i=0L;
    while (numberOfRootSplits == 0) {
      insert(i);
      i++;
    }
    long oldStableGeneration=stableGeneration;
    long oldUnstableGeneration=unstableGeneration;
    checkpoint();
    insert(i);
    i++;
    corruptGSPP(cursor,node.childOffset(1));
    PageAwareByteArrayCursor pageCursorForSeeker=cursor.duplicate(rootId);
    pageCursorForSeeker.next();
    long position=i;
    assertThrows(TreeInconsistencyException.class,() -> seekCursor(position,position + 1,pageCursorForSeeker,oldStableGeneration,oldUnstableGeneration));
  }
  @Test void shouldCatchupRootWhenRootNodeHasTooNewGeneration() throws Exception {
    long id=cursor.getCurrentPageId();
    long generation=TreeNode.generation(cursor);
    MutableBoolean triggered=new MutableBoolean(false);
    Supplier<Root> rootCatchup=() -> {
      triggered.setTrue();
      return new Root(id,generation);
    }
;
    try (SeekCursor<KEY,VALUE> ignored=new SeekCursor<>(cursor,node,key(0),key(1),layout,stableGeneration,unstableGeneration,generationSupplier,rootCatchup,generation - 1,exceptionDecorator,1)){
    }
     assertTrue(triggered.getValue());
  }
  @Test void shouldCatchupRootWhenNodeHasTooNewGenerationWhileTraversingDownTree() throws Exception {
    long generation=TreeNode.generation(cursor);
    MutableBoolean triggered=new MutableBoolean(false);
    long rightChild=999;
    long leftChild=cursor.getCurrentPageId();
    node.initializeLeaf(cursor,stableGeneration + 1,unstableGeneration + 1);
    cursor.next();
    long rootId=cursor.getCurrentPageId();
    node.initializeInternal(cursor,stableGeneration,unstableGeneration);
    long keyInRoot=10L;
    node.insertKeyAndRightChildAt(cursor,key(keyInRoot),rightChild,0,0,stableGeneration,unstableGeneration);
    TreeNode.setKeyCount(cursor,1);
    node.setChildAt(cursor,leftChild,0,stableGeneration,unstableGeneration);
    Supplier<Root> rootCatchup=() -> {
      triggered.setTrue();
      cursor.next(leftChild);
      cursor.zapPage();
      node.initializeLeaf(cursor,stableGeneration,unstableGeneration);
      cursor.next(rootId);
      return new Root(rootId,generation);
    }
;
    KEY from=key(1L);
    KEY to=key(2L);
    try (SeekCursor<KEY,VALUE> ignored=new SeekCursor<>(cursor,node,from,to,layout,stableGeneration,unstableGeneration,generationSupplier,rootCatchup,unstableGeneration,exceptionDecorator,1)){
    }
     assertTrue(triggered.getValue());
  }
  @Test void shouldCatchupRootWhenNodeHasTooNewGenerationWhileTraversingLeaves() throws Exception {
    MutableBoolean triggered=new MutableBoolean(false);
    long oldRightChild=666;
    long rightChild=cursor.getCurrentPageId();
    node.initializeLeaf(cursor,stableGeneration,unstableGeneration);
    cursor.next();
    Supplier<Root> rootCatchup=() -> {
      cursor.next(rightChild);
      triggered.setTrue();
      return new Root(cursor.getCurrentPageId(),TreeNode.generation(cursor));
    }
;
    long leftChild=cursor.getCurrentPageId();
    node.initializeLeaf(cursor,stableGeneration - 1,unstableGeneration - 1);
    TreeNode.setRightSibling(cursor,rightChild,stableGeneration - 1,unstableGeneration - 1);
    cursor.next();
    node.initializeInternal(cursor,stableGeneration - 1,unstableGeneration - 1);
    long keyInRoot=10L;
    node.insertKeyAndRightChildAt(cursor,key(keyInRoot),oldRightChild,0,0,stableGeneration,unstableGeneration);
    TreeNode.setKeyCount(cursor,1);
    node.setChildAt(cursor,leftChild,0,stableGeneration,unstableGeneration);
    KEY from=key(1L);
    KEY to=key(20L);
    try (SeekCursor<KEY,VALUE> seek=new SeekCursor<>(cursor,node,from,to,layout,stableGeneration - 1,unstableGeneration - 1,generationSupplier,rootCatchup,unstableGeneration,exceptionDecorator,1)){
      while (seek.next()) {
        seek.get();
      }
    }
     assertTrue(triggered.getValue());
  }
  @Test void shouldThrowTreeInconsistencyExceptionOnBadReadWithoutShouldRetryWhileTraversingTree() throws Exception {
    int keyCount=10000;
    cursor.setOffset(TreeNode.BYTE_POS_KEYCOUNT);
    cursor.putInt(keyCount);
    try (SeekCursor<KEY,VALUE> ignored=seekCursor(0L,Long.MAX_VALUE)){
    }
 catch (    TreeInconsistencyException e) {
      assertThat(e.getMessage(),containsString("keyCount:" + keyCount));
    }
  }
  @Test void shouldThrowTreeInconsistencyExceptionOnBadReadWithoutShouldRetryWhileTraversingLeaves() throws Exception {
    int keyCount=10000;
    long i=0L;
    while (numberOfRootSplits == 0) {
      insert(i);
      i++;
    }
    long rootId=cursor.getCurrentPageId();
    long leftChild=node.childAt(cursor,0,stableGeneration,unstableGeneration);
    goTo(cursor,leftChild);
    cursor.setOffset(TreeNode.BYTE_POS_KEYCOUNT);
    cursor.putInt(keyCount);
    goTo(cursor,rootId);
    try (SeekCursor<KEY,VALUE> seek=seekCursor(0L,Long.MAX_VALUE)){
      while (seek.next()) {
      }
    }
 catch (    TreeInconsistencyException e) {
      assertThat(e.getMessage(),containsString("keyCount:" + keyCount));
    }
  }
  private void triggerUnderflowAndSeekRange(  SeekCursor<KEY,VALUE> seeker,  TestPageCursor seekCursor,  long fromInclusive,  long toExclusive,  long rightChild) throws IOException {
    int stride=fromInclusive <= toExclusive ? 1 : -1;
    triggerUnderflowAndSeekRange(seeker,seekCursor,fromInclusive,toExclusive,rightChild,stride);
  }
  private void seekRangeWithUnderflowMidSeek(  SeekCursor<KEY,VALUE> seeker,  TestPageCursor seekCursor,  long fromInclusive,  long toExclusive,  long underflowNode) throws IOException {
    assertTrue(seeker.next());
    assertThat(getSeed(seeker.get().key()),is(fromInclusive));
    int stride=fromInclusive <= toExclusive ? 1 : -1;
    triggerUnderflowAndSeekRange(seeker,seekCursor,fromInclusive + stride,toExclusive,underflowNode,stride);
  }
  private void triggerUnderflowAndSeekRange(  SeekCursor<KEY,VALUE> seeker,  TestPageCursor seekCursor,  long fromInclusive,  long toExclusive,  long rightChild,  int stride) throws IOException {
    triggerUnderflow(rightChild);
    seekCursor.changed();
    for (long expected=fromInclusive; Long.compare(expected,toExclusive) * stride < 0; expected+=stride) {
      assertTrue(seeker.next());
      assertThat(getSeed(seeker.get().key()),is(expected));
    }
    assertFalse(seeker.next());
  }
  private void triggerUnderflow(  long nodeId) throws IOException {
    PageCursor readCursor=cursor.duplicate(nodeId);
    readCursor.next();
    int midKeyCount=TreeNode.keyCount(readCursor);
    int prevKeyCount=midKeyCount + 1;
    PageCursor rightSiblingCursor=null;
    long rightSibling=TreeNode.rightSibling(readCursor,stableGeneration,unstableGeneration);
    int rightKeyCount=0;
    int prevRightKeyCount=1;
    boolean monitorRight=TreeNode.isNode(rightSibling);
    if (monitorRight) {
      rightSiblingCursor=cursor.duplicate(GenerationSafePointerPair.pointer(rightSibling));
      rightSiblingCursor.next();
      rightKeyCount=TreeNode.keyCount(rightSiblingCursor);
      prevRightKeyCount=rightKeyCount + 1;
    }
    while (midKeyCount < prevKeyCount && rightKeyCount <= prevRightKeyCount) {
      long toRemove=keyAt(readCursor,0,LEAF);
      remove(toRemove);
      prevKeyCount=midKeyCount;
      midKeyCount=TreeNode.keyCount(readCursor);
      if (monitorRight) {
        prevRightKeyCount=rightKeyCount;
        rightKeyCount=TreeNode.keyCount(rightSiblingCursor);
      }
    }
  }
  private void checkpoint(){
    stableGeneration=unstableGeneration;
    unstableGeneration++;
  }
  private void newRootFromSplit(  StructurePropagation<KEY> split){
    assertTrue(split.hasRightKeyInsert);
    long rootId=id.acquireNewId(stableGeneration,unstableGeneration);
    cursor.next(rootId);
    node.initializeInternal(cursor,stableGeneration,unstableGeneration);
    node.setChildAt(cursor,split.midChild,0,stableGeneration,unstableGeneration);
    node.insertKeyAndRightChildAt(cursor,split.rightKey,split.rightChild,0,0,stableGeneration,unstableGeneration);
    TreeNode.setKeyCount(cursor,1);
    split.hasRightKeyInsert=false;
    numberOfRootSplits++;
    updateRoot();
  }
  private void corruptGSPP(  PageAwareByteArrayCursor duplicate,  int offset){
    int someBytes=duplicate.getInt(offset);
    duplicate.putInt(offset,~someBytes);
    someBytes=duplicate.getInt(offset + GenerationSafePointer.SIZE);
    duplicate.putInt(offset + GenerationSafePointer.SIZE,~someBytes);
  }
  private void insert(  long key) throws IOException {
    insert(key,key);
  }
  private void insert(  long key,  long value) throws IOException {
    insert(key,value,cursor);
  }
  private void insert(  long key,  long value,  PageCursor cursor) throws IOException {
    treeLogic.insert(cursor,structurePropagation,key(key),value(value),overwrite(),stableGeneration,unstableGeneration);
    handleAfterChange();
  }
  private void remove(  long key) throws IOException {
    treeLogic.remove(cursor,structurePropagation,key(key),layout.newValue(),stableGeneration,unstableGeneration);
    handleAfterChange();
  }
  private void handleAfterChange(){
    if (structurePropagation.hasRightKeyInsert) {
      newRootFromSplit(structurePropagation);
    }
    if (structurePropagation.hasMidChildUpdate) {
      structurePropagation.hasMidChildUpdate=false;
      updateRoot();
    }
  }
  private SeekCursor<KEY,VALUE> seekCursor(  long fromInclusive,  long toExclusive) throws IOException {
    return seekCursor(fromInclusive,toExclusive,cursor);
  }
  private SeekCursor<KEY,VALUE> seekCursor(  long fromInclusive,  long toExclusive,  PageCursor pageCursor) throws IOException {
    return seekCursor(fromInclusive,toExclusive,pageCursor,stableGeneration,unstableGeneration);
  }
  private SeekCursor<KEY,VALUE> seekCursor(  long fromInclusive,  long toExclusive,  PageCursor pageCursor,  long stableGeneration,  long unstableGeneration) throws IOException {
    return new SeekCursor<>(pageCursor,node,key(fromInclusive),key(toExclusive),layout,stableGeneration,unstableGeneration,generationSupplier,failingRootCatchup,unstableGeneration,exceptionDecorator,random.nextInt(1,DEFAULT_MAX_READ_AHEAD));
  }
  /** 
 * Create a right sibling to node pointed to by cursor. Leave cursor on new right sibling when done, and return id of left sibling.
 */
  private long createRightSibling(  PageCursor pageCursor) throws IOException {
    long left=pageCursor.getCurrentPageId();
    long right=left + 1;
    TreeNode.setRightSibling(pageCursor,right,stableGeneration,unstableGeneration);
    pageCursor.next(right);
    node.initializeLeaf(pageCursor,stableGeneration,unstableGeneration);
    TreeNode.setLeftSibling(pageCursor,left,stableGeneration,unstableGeneration);
    return left;
  }
  private void assertRangeInSingleLeaf(  long fromInclusive,  long toExclusive,  SeekCursor<KEY,VALUE> cursor) throws IOException {
    int stride=fromInclusive <= toExclusive ? 1 : -1;
    long expected=fromInclusive;
    while (cursor.next()) {
      KEY key=key(expected);
      VALUE value=value(expected);
      assertKeyAndValue(cursor,key,value);
      expected+=stride;
    }
    assertEquals(toExclusive,expected);
  }
  private void assertKeyAndValue(  SeekCursor<KEY,VALUE> cursor,  long expectedKeySeed){
    KEY key=key(expectedKeySeed);
    VALUE value=value(expectedKeySeed);
    assertKeyAndValue(cursor,key,value);
  }
  private void assertKeyAndValue(  SeekCursor<KEY,VALUE> cursor,  KEY expectedKey,  VALUE expectedValue){
    KEY foundKey=cursor.get().key();
    VALUE foundValue=cursor.get().value();
    assertEqualsKey(expectedKey,foundKey);
    assertEqualsValue(expectedValue,foundValue);
  }
  private void assertEqualsKey(  KEY expected,  KEY actual){
    assertEquals(0,layout.compare(expected,actual),format("expected equal, expected=%s, actual=%s",expected.toString(),actual.toString()));
  }
  private void assertEqualsValue(  VALUE expected,  VALUE actual){
    assertEquals(0,layout.compareValue(expected,actual),format("expected equal, expected=%s, actual=%s",expected.toString(),actual.toString()));
  }
  private void insertKeysAndValues(  int keyCount){
    for (int i=0; i < keyCount; i++) {
      append(i);
    }
  }
  private void append(  long k){
    int keyCount=TreeNode.keyCount(cursor);
    node.insertKeyValueAt(cursor,key(k),value(k),keyCount,keyCount);
    TreeNode.setKeyCount(cursor,keyCount + 1);
  }
  private void insertIn(  int pos,  long k){
    int keyCount=TreeNode.keyCount(cursor);
    KEY key=key(k);
    VALUE value=value(k);
    TreeNode.Overflow overflow=node.leafOverflow(cursor,keyCount,key,value);
    if (overflow != TreeNode.Overflow.NO) {
      throw new IllegalStateException("Can not insert another key in current node");
    }
    node.insertKeyValueAt(cursor,key,value,pos,keyCount);
    TreeNode.setKeyCount(cursor,keyCount + 1);
  }
  private void removeAtPos(  int pos){
    int keyCount=TreeNode.keyCount(cursor);
    node.removeKeyValueAt(cursor,pos,keyCount);
    TreeNode.setKeyCount(cursor,keyCount - 1);
  }
private static class BreadcrumbPageCursor extends DelegatingPageCursor {
    private final List<Long> breadcrumbs=new ArrayList<>();
    BreadcrumbPageCursor(    PageCursor delegate){
      super(delegate);
    }
    @Override public boolean next() throws IOException {
      boolean next=super.next();
      breadcrumbs.add(getCurrentPageId());
      return next;
    }
    @Override public boolean next(    long pageId) throws IOException {
      boolean next=super.next(pageId);
      breadcrumbs.add(getCurrentPageId());
      return next;
    }
    List<Long> getBreadcrumbs(){
      return breadcrumbs;
    }
  }
  private long childAt(  PageCursor cursor,  int pos,  long stableGeneration,  long unstableGeneration){
    return pointer(node.childAt(cursor,pos,stableGeneration,unstableGeneration));
  }
  private long keyAt(  PageCursor cursor,  int pos,  TreeNode.Type type){
    KEY readKey=layout.newKey();
    node.keyAt(cursor,readKey,pos,type);
    return getSeed(readKey);
  }
  @SuppressWarnings("unused") private void printTree() throws IOException {
    long currentPageId=cursor.getCurrentPageId();
    cursor.next(rootId);
    new TreePrinter<>(node,layout,stableGeneration,unstableGeneration).printTree(cursor,cursor,System.out,false,false,false,false);
    cursor.next(currentPageId);
  }
}
