public class ConcurrentChangesOnEntitiesTest {
  private final SuppressOutput suppressOutput=SuppressOutput.suppressAll();
  private final TestDirectory testDirectory=TestDirectory.testDirectory();
  @Rule public RuleChain ruleChain=RuleChain.outerRule(suppressOutput).around(testDirectory);
  private final CyclicBarrier barrier=new CyclicBarrier(2);
  private final AtomicReference<Exception> ex=new AtomicReference<>();
  private GraphDatabaseService db;
  @Before public void setup(){
    db=new TestGraphDatabaseFactory().newEmbeddedDatabaseBuilder(testDirectory.databaseDir()).newGraphDatabase();
  }
  @Test public void addConcurrentlySameLabelToANode() throws Throwable {
    final long nodeId=initWithNode(db);
    Thread t1=newThreadForNodeAction(nodeId,node -> node.addLabel(Label.label("A")));
    Thread t2=newThreadForNodeAction(nodeId,node -> node.addLabel(Label.label("A")));
    startAndWait(t1,t2);
    db.shutdown();
    assertDatabaseConsistent();
  }
  @Test public void setConcurrentlySamePropertyWithDifferentValuesOnANode() throws Throwable {
    final long nodeId=initWithNode(db);
    Thread t1=newThreadForNodeAction(nodeId,node -> node.setProperty("a",0.788));
    Thread t2=newThreadForNodeAction(nodeId,node -> node.setProperty("a",new double[]{0.999,0.77}));
    startAndWait(t1,t2);
    db.shutdown();
    assertDatabaseConsistent();
  }
  @Test public void setConcurrentlySamePropertyWithDifferentValuesOnARelationship() throws Throwable {
    final long relId=initWithRel(db);
    Thread t1=newThreadForRelationshipAction(relId,relationship -> relationship.setProperty("a",0.788));
    Thread t2=newThreadForRelationshipAction(relId,relationship -> relationship.setProperty("a",new double[]{0.999,0.77}));
    startAndWait(t1,t2);
    db.shutdown();
    assertDatabaseConsistent();
  }
  private long initWithNode(  GraphDatabaseService db){
    try (Transaction tx=db.beginTx()){
      Node theNode=db.createNode();
      long id=theNode.getId();
      tx.success();
      return id;
    }
   }
  private long initWithRel(  GraphDatabaseService db){
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode();
      node.setProperty("a","prop");
      Relationship rel=node.createRelationshipTo(db.createNode(),RelationshipType.withName("T"));
      long id=rel.getId();
      tx.success();
      return id;
    }
   }
  private Thread newThreadForNodeAction(  final long nodeId,  final Consumer<Node> nodeConsumer){
    return new Thread(() -> {
      try (Transaction tx=db.beginTx()){
        Node node=db.getNodeById(nodeId);
        barrier.await();
        nodeConsumer.accept(node);
        tx.success();
      }
 catch (      Exception e) {
        ex.set(e);
      }
    }
);
  }
  private Thread newThreadForRelationshipAction(  final long relationshipId,  final Consumer<Relationship> relConsumer){
    return new Thread(() -> {
      try (Transaction tx=db.beginTx()){
        Relationship relationship=db.getRelationshipById(relationshipId);
        barrier.await();
        relConsumer.accept(relationship);
        tx.success();
      }
 catch (      Exception e) {
        ex.set(e);
      }
    }
);
  }
  private void startAndWait(  Thread t1,  Thread t2) throws Exception {
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    if (ex.get() != null) {
      throw ex.get();
    }
  }
  private void assertDatabaseConsistent(){
    LogProvider logProvider=FormattedLogProvider.toOutputStream(System.out);
    try {
      ConsistencyCheckService.Result result=new ConsistencyCheckService().runFullConsistencyCheck(testDirectory.databaseLayout(),Config.defaults(),ProgressMonitorFactory.textual(System.err),logProvider,false);
      assertTrue(result.isSuccessful());
    }
 catch (    ConsistencyCheckIncompleteException e) {
      fail(e.getMessage());
    }
  }
}
