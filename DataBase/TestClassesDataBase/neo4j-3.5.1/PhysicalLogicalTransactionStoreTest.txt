public class PhysicalLogicalTransactionStoreTest {
  private static final DatabaseHealth DATABASE_HEALTH=mock(DatabaseHealth.class);
  @Rule public final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public final TestDirectory dir=TestDirectory.testDirectory();
  private File databaseDirectory;
  private Monitors monitors=new Monitors();
  @Before public void setup(){
    databaseDirectory=dir.databaseDir();
  }
  @Test public void extractTransactionFromLogFilesSkippingLastLogFileWithoutHeader() throws IOException {
    TransactionIdStore transactionIdStore=new SimpleTransactionIdStore();
    TransactionMetadataCache positionCache=new TransactionMetadataCache();
    final byte[] additionalHeader=new byte[]{1,2,5};
    final int masterId=2;
    int authorId=1;
    final long timeStarted=12345;
    long latestCommittedTxWhenStarted=4545;
    long timeCommitted=timeStarted + 10;
    LifeSupport life=new LifeSupport();
    final LogFiles logFiles=LogFilesBuilder.builder(dir.databaseLayout(),fileSystemRule.get()).withTransactionIdStore(transactionIdStore).withLogVersionRepository(mock(LogVersionRepository.class)).build();
    life.add(logFiles);
    life.start();
    try {
      addATransactionAndRewind(life,logFiles,positionCache,transactionIdStore,additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted);
    }
  finally {
      life.shutdown();
    }
    fileSystemRule.get().create(logFiles.getLogFileForVersion(logFiles.getHighestLogVersion() + 1)).close();
    positionCache.clear();
    final LogicalTransactionStore store=new PhysicalLogicalTransactionStore(logFiles,positionCache,new VersionAwareLogEntryReader<>(),monitors,true);
    verifyTransaction(transactionIdStore,positionCache,additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted,store);
  }
  @Test public void shouldOpenCleanStore() throws Exception {
    TransactionIdStore transactionIdStore=new SimpleTransactionIdStore();
    TransactionMetadataCache positionCache=new TransactionMetadataCache();
    LifeSupport life=new LifeSupport();
    final LogFiles logFiles=LogFilesBuilder.builder(dir.databaseLayout(),fileSystemRule.get()).withTransactionIdStore(transactionIdStore).withLogVersionRepository(mock(LogVersionRepository.class)).build();
    life.add(logFiles);
    life.add(new BatchingTransactionAppender(logFiles,NO_ROTATION,positionCache,transactionIdStore,BYPASS,DATABASE_HEALTH));
    try {
      life.start();
    }
  finally {
      life.shutdown();
    }
  }
  @Test public void shouldOpenAndRecoverExistingData() throws Exception {
    TransactionIdStore transactionIdStore=new SimpleTransactionIdStore();
    TransactionMetadataCache positionCache=new TransactionMetadataCache();
    final byte[] additionalHeader=new byte[]{1,2,5};
    final int masterId=2;
    int authorId=1;
    final long timeStarted=12345;
    long latestCommittedTxWhenStarted=4545;
    long timeCommitted=timeStarted + 10;
    LifeSupport life=new LifeSupport();
    final LogFiles logFiles=LogFilesBuilder.builder(dir.databaseLayout(),fileSystemRule.get()).withTransactionIdStore(transactionIdStore).withLogVersionRepository(mock(LogVersionRepository.class)).build();
    life.start();
    life.add(logFiles);
    try {
      addATransactionAndRewind(life,logFiles,positionCache,transactionIdStore,additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted);
    }
  finally {
      life.shutdown();
    }
    life=new LifeSupport();
    life.add(logFiles);
    final AtomicBoolean recoveryRequired=new AtomicBoolean();
    FakeRecoveryVisitor visitor=new FakeRecoveryVisitor(additionalHeader,masterId,authorId,timeStarted,timeCommitted,latestCommittedTxWhenStarted);
    LogicalTransactionStore txStore=new PhysicalLogicalTransactionStore(logFiles,positionCache,new VersionAwareLogEntryReader<>(),monitors,true);
    life.add(new BatchingTransactionAppender(logFiles,NO_ROTATION,positionCache,transactionIdStore,BYPASS,DATABASE_HEALTH));
    CorruptedLogsTruncator logPruner=new CorruptedLogsTruncator(databaseDirectory,logFiles,fileSystemRule.get());
    life.add(new Recovery(new RecoveryService(){
      @Override public void startRecovery(){
        recoveryRequired.set(true);
      }
      @Override public RecoveryApplier getRecoveryApplier(      TransactionApplicationMode mode){
        return mode == TransactionApplicationMode.REVERSE_RECOVERY ? mock(RecoveryApplier.class) : visitor;
      }
      @Override public RecoveryStartInformation getRecoveryStartInformation(){
        return new RecoveryStartInformation(LogPosition.start(0),1);
      }
      @Override public TransactionCursor getTransactions(      LogPosition position) throws IOException {
        return txStore.getTransactions(position);
      }
      @Override public TransactionCursor getTransactionsInReverseOrder(      LogPosition position) throws IOException {
        return txStore.getTransactionsInReverseOrder(position);
      }
      @Override public void transactionsRecovered(      CommittedTransactionRepresentation lastRecoveredTransaction,      LogPosition positionAfterLastRecoveredTransaction){
      }
    }
,logPruner,mock(RecoveryMonitor.class),SilentProgressReporter.INSTANCE,false));
    try {
      life.start();
    }
  finally {
      life.shutdown();
    }
    assertEquals(1,visitor.getVisitedTransactions());
    assertTrue(recoveryRequired.get());
  }
  @Test public void shouldExtractMetadataFromExistingTransaction() throws Exception {
    TransactionIdStore transactionIdStore=new SimpleTransactionIdStore();
    TransactionMetadataCache positionCache=new TransactionMetadataCache();
    final byte[] additionalHeader=new byte[]{1,2,5};
    final int masterId=2;
    int authorId=1;
    final long timeStarted=12345;
    long latestCommittedTxWhenStarted=4545;
    long timeCommitted=timeStarted + 10;
    LifeSupport life=new LifeSupport();
    final LogFiles logFiles=LogFilesBuilder.builder(dir.databaseLayout(),fileSystemRule.get()).withTransactionIdStore(transactionIdStore).withLogVersionRepository(mock(LogVersionRepository.class)).build();
    life.start();
    life.add(logFiles);
    try {
      addATransactionAndRewind(life,logFiles,positionCache,transactionIdStore,additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted);
    }
  finally {
      life.shutdown();
    }
    life=new LifeSupport();
    life.add(logFiles);
    final LogicalTransactionStore store=new PhysicalLogicalTransactionStore(logFiles,positionCache,new VersionAwareLogEntryReader<>(),monitors,true);
    life.start();
    try {
      verifyTransaction(transactionIdStore,positionCache,additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted,store);
    }
  finally {
      life.shutdown();
    }
  }
  @Test public void shouldThrowNoSuchTransactionExceptionIfMetadataNotFound() throws Exception {
    LogFiles logFiles=mock(LogFiles.class);
    TransactionMetadataCache cache=new TransactionMetadataCache();
    LifeSupport life=new LifeSupport();
    final LogicalTransactionStore txStore=new PhysicalLogicalTransactionStore(logFiles,cache,new VersionAwareLogEntryReader<>(),monitors,true);
    try {
      life.start();
      try {
        txStore.getMetadataFor(10);
        fail("Should have thrown");
      }
 catch (      NoSuchTransactionException e) {
      }
    }
  finally {
      life.shutdown();
    }
  }
  @Test public void shouldThrowNoSuchTransactionExceptionIfLogFileIsMissing() throws Exception {
    LogFile logFile=mock(LogFile.class);
    LogFiles logFiles=mock(LogFiles.class);
    when(logFiles.getLogFile()).thenReturn(logFile);
    when(logFile.getReader(any(LogPosition.class))).thenThrow(new FileNotFoundException());
    TransactionMetadataCache cache=new TransactionMetadataCache();
    cache.cacheTransactionMetadata(10,new LogPosition(2,130),1,1,100,System.currentTimeMillis());
    LifeSupport life=new LifeSupport();
    final LogicalTransactionStore txStore=new PhysicalLogicalTransactionStore(logFiles,cache,new VersionAwareLogEntryReader<>(),monitors,true);
    try {
      life.start();
      try {
        txStore.getTransactions(10);
        fail();
      }
 catch (      NoSuchTransactionException e) {
      }
    }
  finally {
      life.shutdown();
    }
  }
  private void addATransactionAndRewind(  LifeSupport life,  LogFiles logFiles,  TransactionMetadataCache positionCache,  TransactionIdStore transactionIdStore,  byte[] additionalHeader,  int masterId,  int authorId,  long timeStarted,  long latestCommittedTxWhenStarted,  long timeCommitted) throws IOException {
    TransactionAppender appender=life.add(new BatchingTransactionAppender(logFiles,NO_ROTATION,positionCache,transactionIdStore,BYPASS,DATABASE_HEALTH));
    PhysicalTransactionRepresentation transaction=new PhysicalTransactionRepresentation(singleCreateNodeCommand());
    transaction.setHeader(additionalHeader,masterId,authorId,timeStarted,latestCommittedTxWhenStarted,timeCommitted,-1);
    appender.append(new TransactionToApply(transaction),LogAppendEvent.NULL);
  }
  private Collection<StorageCommand> singleCreateNodeCommand(){
    Collection<StorageCommand> commands=new ArrayList<>();
    long id=0;
    NodeRecord before=new NodeRecord(id);
    NodeRecord after=new NodeRecord(id);
    after.setInUse(true);
    commands.add(new Command.NodeCommand(before,after));
    return commands;
  }
  private void verifyTransaction(  TransactionIdStore transactionIdStore,  TransactionMetadataCache positionCache,  byte[] additionalHeader,  int masterId,  int authorId,  long timeStarted,  long latestCommittedTxWhenStarted,  long timeCommitted,  LogicalTransactionStore store) throws IOException {
    TransactionMetadata expectedMetadata;
    try (TransactionCursor cursor=store.getTransactions(TransactionIdStore.BASE_TX_ID + 1)){
      boolean hasNext=cursor.next();
      assertTrue(hasNext);
      CommittedTransactionRepresentation tx=cursor.get();
      TransactionRepresentation transaction=tx.getTransactionRepresentation();
      assertArrayEquals(additionalHeader,transaction.additionalHeader());
      assertEquals(masterId,transaction.getMasterId());
      assertEquals(authorId,transaction.getAuthorId());
      assertEquals(timeStarted,transaction.getTimeStarted());
      assertEquals(timeCommitted,transaction.getTimeCommitted());
      assertEquals(latestCommittedTxWhenStarted,transaction.getLatestCommittedTxWhenStarted());
      expectedMetadata=new TransactionMetadata(masterId,authorId,tx.getStartEntry().getStartPosition(),tx.getStartEntry().checksum(),timeCommitted);
    }
     positionCache.clear();
    TransactionMetadata actualMetadata=store.getMetadataFor(transactionIdStore.getLastCommittedTransactionId());
    assertEquals(expectedMetadata,actualMetadata);
  }
private static class FakeRecoveryVisitor implements RecoveryApplier {
    private final byte[] additionalHeader;
    private final int masterId;
    private final int authorId;
    private final long timeStarted;
    private final long timeCommitted;
    private final long latestCommittedTxWhenStarted;
    private int visitedTransactions;
    FakeRecoveryVisitor(    byte[] additionalHeader,    int masterId,    int authorId,    long timeStarted,    long timeCommitted,    long latestCommittedTxWhenStarted){
      this.additionalHeader=additionalHeader;
      this.masterId=masterId;
      this.authorId=authorId;
      this.timeStarted=timeStarted;
      this.timeCommitted=timeCommitted;
      this.latestCommittedTxWhenStarted=latestCommittedTxWhenStarted;
    }
    @Override public boolean visit(    CommittedTransactionRepresentation tx){
      TransactionRepresentation transaction=tx.getTransactionRepresentation();
      assertArrayEquals(additionalHeader,transaction.additionalHeader());
      assertEquals(masterId,transaction.getMasterId());
      assertEquals(authorId,transaction.getAuthorId());
      assertEquals(timeStarted,transaction.getTimeStarted());
      assertEquals(timeCommitted,transaction.getTimeCommitted());
      assertEquals(latestCommittedTxWhenStarted,transaction.getLatestCommittedTxWhenStarted());
      visitedTransactions++;
      return false;
    }
    int getVisitedTransactions(){
      return visitedTransactions;
    }
    @Override public void close(){
    }
  }
}
