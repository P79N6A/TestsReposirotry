public class ProceduresKernelIT extends KernelIntegrationTest {
  @Rule public ExpectedException exception=ExpectedException.none();
  private final ProcedureSignature signature=procedureSignature("example","exampleProc").in("name",NTString).out("name",NTString).build();
  private final CallableProcedure procedure=procedure(signature);
  @Test public void shouldGetProcedureByName() throws Throwable {
    internalKernel().registerProcedure(procedure);
    ProcedureSignature found=procs().procedureGet(new QualifiedName(new String[]{"example"},"exampleProc")).signature();
    assertThat(found,equalTo(signature));
    commit();
  }
  @Test public void shouldGetBuiltInProcedureByName() throws Throwable {
    ProcedureSignature found=procs().procedureGet(procedureName("db","labels")).signature();
    assertThat(found,equalTo(procedureSignature(procedureName("db","labels")).out("label",NTString).build()));
    commit();
  }
  @Test public void shouldGetAllProcedures() throws Throwable {
    internalKernel().registerProcedure(procedure);
    internalKernel().registerProcedure(procedure(procedureSignature("example","exampleProc2").out("name",NTString).build()));
    internalKernel().registerProcedure(procedure(procedureSignature("example","exampleProc3").out("name",NTString).build()));
    List<ProcedureSignature> signatures=Iterables.asList(newTransaction().procedures().proceduresGetAll());
    assertThat(signatures,hasItems(procedure.signature(),procedureSignature("example","exampleProc2").out("name",NTString).build(),procedureSignature("example","exampleProc3").out("name",NTString).build()));
    commit();
  }
  @Test public void shouldRefuseToRegisterNonVoidProcedureWithoutOutputs() throws ProcedureException, TransactionFailureException {
    exception.expect(ProcedureException.class);
    exception.expectMessage("Procedures with zero output fields must be declared as VOID");
    internalKernel().registerProcedure(procedure(procedureSignature("example","exampleProc2").build()));
    commit();
  }
  @Test public void shouldCallReadOnlyProcedure() throws Throwable {
    internalKernel().registerProcedure(procedure);
    RawIterator<Object[],ProcedureException> found=procs().procedureCallRead(procs().procedureGet(new QualifiedName(new String[]{"example"},"exampleProc")).id(),new Object[]{1337});
    assertThat(asList(found),contains(equalTo(new Object[]{1337})));
    commit();
  }
  @Test public void registeredProcedureShouldGetRead() throws Throwable {
    internalKernel().registerProcedure(new CallableProcedure.BasicProcedure(signature){
      @Override public RawIterator<Object[],ProcedureException> apply(      Context ctx,      Object[] input,      ResourceTracker resourceTracker) throws ProcedureException {
        return RawIterator.<Object[],ProcedureException>of(new Object[]{ctx.get(Context.KERNEL_TRANSACTION).dataRead()});
      }
    }
);
    RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procs().procedureGet(signature.name()).id(),new Object[]{""});
    assertNotNull(asList(stream).get(0)[0]);
    commit();
  }
  private static CallableProcedure procedure(  final ProcedureSignature signature){
    return new CallableProcedure.BasicProcedure(signature){
      @Override public RawIterator<Object[],ProcedureException> apply(      Context ctx,      Object[] input,      ResourceTracker resourceTracker){
        return RawIterator.<Object[],ProcedureException>of(input);
      }
    }
;
  }
}
