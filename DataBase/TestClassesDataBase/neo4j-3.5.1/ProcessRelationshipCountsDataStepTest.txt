public class ProcessRelationshipCountsDataStepTest {
  @Test public void shouldLetProcessorsBeZeroIfEnoughMemory(){
    ProcessRelationshipCountsDataStep step=instantiateStep(10,10,10_000,4,mebiBytes(10));
    assertEquals(0,step.getMaxProcessors());
  }
  @Test public void shouldNotOverflowWhenTooMuchMemoryAvailable(){
    ProcessRelationshipCountsDataStep step=instantiateStep(1,1,10_000,64,tebiBytes(10));
    assertEquals(0,step.getMaxProcessors());
  }
  @Test public void shouldLimitProcessorsIfScarceMemory(){
    ProcessRelationshipCountsDataStep step=instantiateStep(100,220,mebiBytes(1),4,mebiBytes(2));
    assertEquals(2,step.getMaxProcessors());
  }
  @Test public void shouldAtLeastHaveOneProcessorEvenIfLowMemory(){
    ProcessRelationshipCountsDataStep step=instantiateStep(1_000,1_000,mebiBytes(1),4,mebiBytes(2));
    assertEquals(1,step.getMaxProcessors());
  }
  private ProcessRelationshipCountsDataStep instantiateStep(  int highLabelId,  int highRelationshipTypeId,  long labelCacheSize,  int maxProcessors,  long maxMemory){
    StageControl control=new SimpleStageControl();
    NodeLabelsCache cache=nodeLabelsCache(labelCacheSize);
    Configuration config=mock(Configuration.class);
    when(config.maxNumberOfProcessors()).thenReturn(maxProcessors);
    when(config.maxMemoryUsage()).thenReturn(maxMemory);
    return new ProcessRelationshipCountsDataStep(control,cache,config,highLabelId,highRelationshipTypeId,mock(CountsAccessor.Updater.class),OFF_HEAP,INSTANCE);
  }
  private NodeLabelsCache nodeLabelsCache(  long sizeInBytes){
    NodeLabelsCache cache=mock(NodeLabelsCache.class);
    doAnswer(invocation -> {
      MemoryStatsVisitor visitor=invocation.getArgument(0);
      visitor.offHeapUsage(sizeInBytes);
      return null;
    }
).when(cache).acceptMemoryStatsVisitor(any());
    return cache;
  }
}
