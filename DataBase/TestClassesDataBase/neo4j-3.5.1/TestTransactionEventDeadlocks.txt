public class TestTransactionEventDeadlocks {
  @Rule public DatabaseRule database=new ImpermanentDatabaseRule();
  @Test public void canAvoidDeadlockThatWouldHappenIfTheRelationshipTypeCreationTransactionModifiedData(){
    GraphDatabaseService graphdb=database.getGraphDatabaseAPI();
    Node node=null;
    try (Transaction tx=graphdb.beginTx()){
      node=graphdb.createNode();
      node.setProperty("counter",0L);
      tx.success();
    }
     graphdb.registerTransactionEventHandler(new RelationshipCounterTransactionEventHandler(node));
    try (Transaction tx=graphdb.beginTx()){
      node.setProperty("state","not broken yet");
      node.createRelationshipTo(graphdb.createNode(),RelationshipType.withName("TEST"));
      node.removeProperty("state");
      tx.success();
    }
     assertThat(node,inTx(graphdb,hasProperty("counter").withValue(1L)));
  }
private static class RelationshipCounterTransactionEventHandler implements TransactionEventHandler<Void> {
    private final Node node;
    RelationshipCounterTransactionEventHandler(    Node node){
      this.node=node;
    }
    @SuppressWarnings("boxing") @Override public Void beforeCommit(    TransactionData data){
      if (Iterables.count(data.createdRelationships()) == 0) {
        return null;
      }
      node.setProperty("counter",((Long)node.removeProperty("counter")) + 1);
      return null;
    }
    @Override public void afterCommit(    TransactionData data,    Void state){
    }
    @Override public void afterRollback(    TransactionData data,    Void state){
    }
  }
}
