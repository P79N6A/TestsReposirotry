class SafeLifecycleTest {
  private ThrowingConsumer<Lifecycle,Throwable> init=Lifecycle::init;
  private ThrowingConsumer<Lifecycle,Throwable> start=Lifecycle::start;
  private ThrowingConsumer<Lifecycle,Throwable> stop=Lifecycle::stop;
  private ThrowingConsumer<Lifecycle,Throwable> shutdown=Lifecycle::shutdown;
  @SuppressWarnings("unchecked") private ThrowingConsumer<Lifecycle,Throwable>[] ops=new ThrowingConsumer[]{init,start,stop,shutdown};
  private Object[][] onSuccess=new Object[][]{new State[]{IDLE,null,null,HALT},new State[]{null,RUN,IDLE,HALT},new State[]{null,null,IDLE,null},new State[]{null,null,null,null}};
  private Object[][] onFailed=new Object[][]{new State[]{PRE,null,null,HALT},new State[]{null,IDLE,IDLE,HALT},new State[]{null,null,IDLE,null},new State[]{null,null,null,null}};
  private Boolean[][] ignored=new Boolean[][]{new Boolean[]{false,false,false,true},new Boolean[]{false,false,true,false},new Boolean[]{false,false,false,false},new Boolean[]{false,false,false,false}};
  @Test void shouldPerformSuccessfulTransitionsCorrectly() throws Throwable {
    for (int state=0; state < State.values().length; state++) {
      for (int op=0; op < ops.length; op++) {
        MySafeAndSuccessfulLife sf=new MySafeAndSuccessfulLife(State.values()[state]);
        boolean caughtIllegalTransition=false;
        try {
          ops[op].accept(sf);
        }
 catch (        IllegalStateException e) {
          caughtIllegalTransition=true;
        }
        if (onSuccess[state][op] == null) {
          assertTrue(caughtIllegalTransition);
          assertEquals(State.values()[state],sf.state());
        }
 else {
          assertFalse(caughtIllegalTransition);
          assertEquals(onSuccess[state][op],sf.state());
          int expectedOpCode=ignored[state][op] ? -1 : op;
          assertEquals(expectedOpCode,sf.opCode);
        }
      }
    }
  }
  @Test void shouldPerformFailedTransitionsCorrectly() throws Throwable {
    for (int state=0; state < State.values().length; state++) {
      for (int op=0; op < ops.length; op++) {
        MyFailedLife sf=new MyFailedLife(State.values()[state]);
        boolean caughtIllegalTransition=false;
        boolean failedOperation=false;
        try {
          ops[op].accept(sf);
        }
 catch (        IllegalStateException e) {
          caughtIllegalTransition=true;
        }
catch (        UnsupportedOperationException e) {
          failedOperation=true;
        }
        if (onFailed[state][op] == null) {
          assertTrue(caughtIllegalTransition);
          assertEquals(State.values()[state],sf.state());
        }
 else {
          assertFalse(caughtIllegalTransition);
          assertEquals(onFailed[state][op],sf.state());
          if (ignored[state][op]) {
            assertEquals(-1,sf.opCode);
            assertFalse(failedOperation);
          }
 else {
            assertEquals(op,sf.opCode);
            assertTrue(failedOperation);
          }
        }
      }
    }
  }
private static class MySafeAndSuccessfulLife extends SafeLifecycle {
    int opCode;
    MySafeAndSuccessfulLife(    State state){
      super(state);
      opCode=-1;
    }
    @Override public void init0(){
      invoke(0);
    }
    @Override public void start0(){
      invoke(1);
    }
    @Override public void stop0(){
      invoke(2);
    }
    @Override public void shutdown0(){
      invoke(3);
    }
    private void invoke(    int opCode){
      if (this.opCode == -1) {
        this.opCode=opCode;
      }
 else {
        throw new RuntimeException("Double invocation");
      }
    }
  }
private static class MyFailedLife extends SafeLifecycle {
    int opCode;
    MyFailedLife(    State state){
      super(state);
      opCode=-1;
    }
    @Override public void init0(){
      invoke(0);
    }
    @Override public void start0(){
      invoke(1);
    }
    @Override public void stop0(){
      invoke(2);
    }
    @Override public void shutdown0(){
      invoke(3);
    }
    private void invoke(    int opCode){
      if (this.opCode == -1) {
        this.opCode=opCode;
        throw new UnsupportedOperationException("I made a bo-bo");
      }
 else {
        throw new RuntimeException("Double invocation");
      }
    }
  }
}
