public class NumberArrayFactoryTest {
  private static final long KILO=1024;
  @Test public void shouldPickFirstAvailableCandidateLongArray(){
    NumberArrayFactory factory=new NumberArrayFactory.Auto(NO_MONITOR,NumberArrayFactory.HEAP);
    LongArray array=factory.newLongArray(KILO,-1);
    array.set(KILO - 10,12345);
    assertTrue(array instanceof HeapLongArray);
    assertEquals(12345,array.get(KILO - 10));
  }
  @Test public void shouldPickFirstAvailableCandidateLongArrayWhenSomeDontHaveEnoughMemory(){
    NumberArrayFactory lowMemoryFactory=mock(NumberArrayFactory.class);
    doThrow(OutOfMemoryError.class).when(lowMemoryFactory).newLongArray(anyLong(),anyLong(),anyLong());
    NumberArrayFactory factory=new NumberArrayFactory.Auto(NO_MONITOR,lowMemoryFactory,NumberArrayFactory.HEAP);
    LongArray array=factory.newLongArray(KILO,-1);
    array.set(KILO - 10,12345);
    verify(lowMemoryFactory,times(1)).newLongArray(KILO,-1,0);
    assertTrue(array instanceof HeapLongArray);
    assertEquals(12345,array.get(KILO - 10));
  }
  @Test public void shouldThrowOomOnNotEnoughMemory(){
    FailureMonitor monitor=new FailureMonitor();
    NumberArrayFactory lowMemoryFactory=mock(NumberArrayFactory.class);
    doThrow(OutOfMemoryError.class).when(lowMemoryFactory).newLongArray(anyLong(),anyLong(),anyLong());
    NumberArrayFactory factory=new NumberArrayFactory.Auto(monitor,lowMemoryFactory);
    try {
      factory.newLongArray(KILO,-1);
      fail("Should have thrown");
    }
 catch (    OutOfMemoryError e) {
      assertFalse(monitor.called);
    }
  }
  @Test public void shouldPickFirstAvailableCandidateIntArray(){
    FailureMonitor monitor=new FailureMonitor();
    NumberArrayFactory factory=new NumberArrayFactory.Auto(monitor,NumberArrayFactory.HEAP);
    IntArray array=factory.newIntArray(KILO,-1);
    array.set(KILO - 10,12345);
    assertTrue(array instanceof HeapIntArray);
    assertEquals(12345,array.get(KILO - 10));
    assertEquals(NumberArrayFactory.HEAP,monitor.successfulFactory);
    assertFalse(monitor.attemptedAllocationFailures.iterator().hasNext());
  }
  @Test public void shouldPickFirstAvailableCandidateIntArrayWhenSomeDontHaveEnoughMemory(){
    NumberArrayFactory lowMemoryFactory=mock(NumberArrayFactory.class);
    doThrow(OutOfMemoryError.class).when(lowMemoryFactory).newIntArray(anyLong(),anyInt(),anyLong());
    NumberArrayFactory factory=new NumberArrayFactory.Auto(NO_MONITOR,lowMemoryFactory,NumberArrayFactory.HEAP);
    IntArray array=factory.newIntArray(KILO,-1);
    array.set(KILO - 10,12345);
    verify(lowMemoryFactory,times(1)).newIntArray(KILO,-1,0);
    assertTrue(array instanceof HeapIntArray);
    assertEquals(12345,array.get(KILO - 10));
  }
  @Test public void shouldCatchArithmeticExceptionsAndTryNext(){
    NumberArrayFactory throwingMemoryFactory=mock(NumberArrayFactory.class);
    ArithmeticException failure=new ArithmeticException("This is an artificial failure");
    doThrow(failure).when(throwingMemoryFactory).newByteArray(anyLong(),any(byte[].class),anyLong());
    FailureMonitor monitor=new FailureMonitor();
    NumberArrayFactory factory=new NumberArrayFactory.Auto(monitor,throwingMemoryFactory,NumberArrayFactory.HEAP);
    int itemSize=4;
    ByteArray array=factory.newByteArray(KILO,new byte[itemSize],0);
    array.setInt(KILO - 10,0,12345);
    verify(throwingMemoryFactory,times(1)).newByteArray(eq(KILO),any(byte[].class),eq(0L));
    assertTrue(array instanceof HeapByteArray);
    assertEquals(12345,array.getInt(KILO - 10,0));
    assertEquals(KILO * itemSize,monitor.memory);
    assertEquals(NumberArrayFactory.HEAP,monitor.successfulFactory);
    assertEquals(throwingMemoryFactory,single(monitor.attemptedAllocationFailures).getFactory());
    assertThat(single(monitor.attemptedAllocationFailures).getFailure().getMessage(),containsString(failure.getMessage()));
  }
  @Test public void heapArrayShouldAllowVeryLargeBases(){
    NumberArrayFactory factory=new NumberArrayFactory.Auto(NO_MONITOR,NumberArrayFactory.HEAP);
    verifyVeryLargeBaseSupport(factory);
  }
  @Test public void offHeapArrayShouldAllowVeryLargeBases(){
    NumberArrayFactory factory=new NumberArrayFactory.Auto(NO_MONITOR,NumberArrayFactory.OFF_HEAP);
    verifyVeryLargeBaseSupport(factory);
  }
  private void verifyVeryLargeBaseSupport(  NumberArrayFactory factory){
    long base=Integer.MAX_VALUE * 1337L;
    byte[] into=new byte[1];
    into[0]=1;
    factory.newByteArray(10,new byte[1],base).get(base + 1,into);
    assertThat(into[0],is((byte)0));
    assertThat(factory.newIntArray(10,1,base).get(base + 1),is(1));
    assertThat(factory.newLongArray(10,1,base).get(base + 1),is(1L));
  }
private static class FailureMonitor implements NumberArrayFactory.Monitor {
    private boolean called;
    private long memory;
    private NumberArrayFactory successfulFactory;
    private Iterable<NumberArrayFactory.AllocationFailure> attemptedAllocationFailures;
    @Override public void allocationSuccessful(    long memory,    NumberArrayFactory successfulFactory,    Iterable<NumberArrayFactory.AllocationFailure> attemptedAllocationFailures){
      this.memory=memory;
      this.successfulFactory=successfulFactory;
      this.attemptedAllocationFailures=attemptedAllocationFailures;
      this.called=true;
    }
  }
}
