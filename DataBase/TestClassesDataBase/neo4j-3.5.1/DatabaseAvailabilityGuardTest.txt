public class DatabaseAvailabilityGuardTest {
  private static final AvailabilityRequirement REQUIREMENT_1=new DescriptiveAvailabilityRequirement("Requirement 1");
  private static final AvailabilityRequirement REQUIREMENT_2=new DescriptiveAvailabilityRequirement("Requirement 2");
  private final Clock clock=Clocks.systemClock();
  @Test public void logOnAvailabilityChange(){
    Log log=mock(Log.class);
    AvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    verifyZeroInteractions(log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    verifyLogging(log,atLeastOnce());
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    verifyLogging(log,times(4));
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    verifyLogging(log,times(6));
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    verifyLogging(log,times(6));
    databaseAvailabilityGuard.fulfill(REQUIREMENT_2);
    verifyLogging(log,times(8));
  }
  @Test public void givenAccessGuardWith2ConditionsWhenAwaitThenTimeoutAndReturnFalse(){
    Log log=mock(Log.class);
    DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    boolean result=databaseAvailabilityGuard.isAvailable(1000);
    assertThat(result,equalTo(false));
  }
  @Test public void givenAccessGuardWith2ConditionsWhenAwaitThenActuallyWaitGivenTimeout(){
    Log log=mock(Log.class);
    DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    long timeout=1000;
    long start=clock.millis();
    boolean result=databaseAvailabilityGuard.isAvailable(timeout);
    long end=clock.millis();
    long waitTime=end - start;
    assertThat(result,equalTo(false));
    assertThat(waitTime,greaterThanOrEqualTo(timeout));
  }
  @Test public void givenAccessGuardWith2ConditionsWhenGrantOnceAndAwaitThenTimeoutAndReturnFalse(){
    Log log=mock(Log.class);
    DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    long start=clock.millis();
    long timeout=1000;
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    boolean result=databaseAvailabilityGuard.isAvailable(timeout);
    long end=clock.millis();
    long waitTime=end - start;
    assertFalse(result);
    assertThat(waitTime,greaterThanOrEqualTo(timeout));
  }
  @Test public void givenAccessGuardWith2ConditionsWhenGrantEachAndAwaitThenTrue(){
    Log log=mock(Log.class);
    DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    databaseAvailabilityGuard.fulfill(REQUIREMENT_2);
    assertTrue(databaseAvailabilityGuard.isAvailable(1000));
  }
  @Test public void givenAccessGuardWith2ConditionsWhenGrantTwiceAndDenyOnceAndAwaitThenTimeoutAndReturnFalse(){
    Log log=mock(Log.class);
    DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    long start=clock.millis();
    long timeout=1000;
    boolean result=databaseAvailabilityGuard.isAvailable(timeout);
    long end=clock.millis();
    long waitTime=end - start;
    assertFalse(result);
    assertThat(waitTime,greaterThanOrEqualTo(timeout));
  }
  @Test public void givenAccessGuardWith2ConditionsWhenGrantOnceAndAwaitAndGrantAgainThenReturnTrue(){
    Log log=mock(Log.class);
    final DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    databaseAvailabilityGuard.fulfill(REQUIREMENT_2);
    assertFalse(databaseAvailabilityGuard.isAvailable(100));
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    assertTrue(databaseAvailabilityGuard.isAvailable(100));
  }
  @Test public void givenAccessGuardWithConditionWhenGrantThenNotifyListeners(){
    Log log=mock(Log.class);
    final DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    final AtomicBoolean notified=new AtomicBoolean();
    AvailabilityListener availabilityListener=new AvailabilityListener(){
      @Override public void available(){
        notified.set(true);
      }
      @Override public void unavailable(){
      }
    }
;
    databaseAvailabilityGuard.addListener(availabilityListener);
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    assertThat(notified.get(),equalTo(true));
  }
  @Test public void givenAccessGuardWithConditionWhenGrantAndDenyThenNotifyListeners(){
    Log log=mock(Log.class);
    final DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    final AtomicBoolean notified=new AtomicBoolean();
    AvailabilityListener availabilityListener=new AvailabilityListener(){
      @Override public void available(){
      }
      @Override public void unavailable(){
        notified.set(true);
      }
    }
;
    databaseAvailabilityGuard.addListener(availabilityListener);
    databaseAvailabilityGuard.fulfill(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    assertThat(notified.get(),equalTo(true));
  }
  @Test public void givenAccessGuardWithConditionWhenShutdownThenInstantlyDenyAccess(){
    Clock clock=Mockito.mock(Clock.class);
    final DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,NullLog.getInstance());
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.shutdown();
    assertFalse(databaseAvailabilityGuard.isAvailable(1000));
    verifyZeroInteractions(clock);
  }
  @Test public void shouldExplainWhoIsBlockingAccess(){
    Log log=mock(Log.class);
    DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(clock,log);
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    databaseAvailabilityGuard.require(REQUIREMENT_2);
    assertThat(databaseAvailabilityGuard.describeWhoIsBlocking(),equalTo("2 reasons for blocking: Requirement 1, Requirement 2."));
  }
  @Test public void shouldExplainBlockersOnCheckAvailable() throws Exception {
    DatabaseAvailabilityGuard databaseAvailabilityGuard=getDatabaseAvailabilityGuard(Clocks.systemClock(),getInstance());
    databaseAvailabilityGuard.checkAvailable();
    databaseAvailabilityGuard.require(REQUIREMENT_1);
    try {
      databaseAvailabilityGuard.checkAvailable();
      fail("Should not be available");
    }
 catch (    UnavailableException e) {
      assertThat(e.getMessage(),containsString(REQUIREMENT_1.description()));
    }
  }
  private static void verifyLogging(  Log log,  VerificationMode mode){
    verify(log,mode).info(anyString(),Mockito.<Object[]>anyVararg());
  }
  private static DatabaseAvailabilityGuard getDatabaseAvailabilityGuard(  Clock clock,  Log log){
    return new DatabaseAvailabilityGuard(DEFAULT_DATABASE_NAME,clock,log);
  }
}
