@ExtendWith(TestDirectoryExtension.class) class ArchiveTest {
  @Inject private TestDirectory testDirectory;
  @Test void shouldRoundTripAnEmptyDirectory() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Files.createDirectories(directory);
    assertRoundTrips(directory);
  }
  @Test void shouldRoundTripASingleFile() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Files.createDirectories(directory);
    Files.write(directory.resolve("a-file"),"text".getBytes());
    assertRoundTrips(directory);
  }
  @Test void shouldRoundTripAnEmptyFile() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Files.createDirectories(directory);
    Files.write(directory.resolve("a-file"),new byte[0]);
    assertRoundTrips(directory);
  }
  @Test void shouldRoundTripFilesWithDifferentContent() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Files.createDirectories(directory);
    Files.write(directory.resolve("a-file"),"text".getBytes());
    Files.write(directory.resolve("another-file"),"some-different-text".getBytes());
    assertRoundTrips(directory);
  }
  @Test void shouldRoundTripEmptyDirectories() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Path subdir=directory.resolve("a-subdirectory");
    Files.createDirectories(subdir);
    assertRoundTrips(directory);
  }
  @Test void shouldRoundTripFilesInDirectories() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Path subdir=directory.resolve("a-subdirectory");
    Files.createDirectories(subdir);
    Files.write(subdir.resolve("a-file"),"text".getBytes());
    assertRoundTrips(directory);
  }
  @Test void shouldCopeWithLongPaths() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Path subdir=directory.resolve("a/very/long/path/which/is/not/realistic/for/a/database/today/but/which" + "/ensures/that/we/dont/get/caught/out/at/in/the/future/the/point/being/that/there/are/multiple/tar" + "/formats/some/of/which/do/not/cope/with/long/paths");
    Files.createDirectories(subdir);
    Files.write(subdir.resolve("a-file"),"text".getBytes());
    assertRoundTrips(directory);
  }
  @Test void shouldExcludeFilesMatchedByTheExclusionPredicate() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Files.createDirectories(directory);
    Files.write(directory.resolve("a-file"),new byte[0]);
    Files.write(directory.resolve("another-file"),new byte[0]);
    Path archive=testDirectory.file("the-archive.dump").toPath();
    new Dumper().dump(directory,directory,archive,path -> path.getFileName().toString().equals("another-file"));
    Path newDirectory=testDirectory.file("the-new-directory").toPath();
    new Loader().load(archive,newDirectory,newDirectory);
    Path expectedOutput=testDirectory.directory("expected-output").toPath();
    Files.createDirectories(expectedOutput);
    Files.write(expectedOutput.resolve("a-file"),new byte[0]);
    assertEquals(describeRecursively(expectedOutput),describeRecursively(newDirectory));
  }
  @Test void shouldExcludeWholeDirectoriesMatchedByTheExclusionPredicate() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("a-directory").toPath();
    Path subdir=directory.resolve("subdir");
    Files.createDirectories(subdir);
    Files.write(subdir.resolve("a-file"),new byte[0]);
    Path archive=testDirectory.file("the-archive.dump").toPath();
    new Dumper().dump(directory,directory,archive,path -> path.getFileName().toString().equals("subdir"));
    Path newDirectory=testDirectory.file("the-new-directory").toPath();
    new Loader().load(archive,newDirectory,newDirectory);
    Path expectedOutput=testDirectory.directory("expected-output").toPath();
    Files.createDirectories(expectedOutput);
    assertEquals(describeRecursively(expectedOutput),describeRecursively(newDirectory));
  }
  @Test void dumpAndLoadTransactionLogsFromCustomLocations() throws IOException, IncorrectFormat {
    Path directory=testDirectory.directory("dbDirectory").toPath();
    Path txLogsDirectory=testDirectory.directory("txLogsDirectory").toPath();
    Files.write(directory.resolve("dbfile"),new byte[0]);
    Files.write(txLogsDirectory.resolve(TransactionLogFiles.DEFAULT_NAME + ".0"),new byte[0]);
    Path archive=testDirectory.file("the-archive.dump").toPath();
    new Dumper().dump(directory,txLogsDirectory,archive,Predicates.alwaysFalse());
    Path newDirectory=testDirectory.file("the-new-directory").toPath();
    Path newTxLogsDirectory=testDirectory.file("newTxLogsDirectory").toPath();
    new Loader().load(archive,newDirectory,newTxLogsDirectory);
    Path expectedOutput=testDirectory.directory("expected-output").toPath();
    Files.createDirectories(expectedOutput);
    Files.write(expectedOutput.resolve("dbfile"),new byte[0]);
    Path expectedTxLogs=testDirectory.directory("expectedTxLogs").toPath();
    Files.createDirectories(expectedTxLogs);
    Files.write(expectedTxLogs.resolve(TransactionLogFiles.DEFAULT_NAME + ".0"),new byte[0]);
    assertEquals(describeRecursively(expectedOutput),describeRecursively(newDirectory));
    assertEquals(describeRecursively(expectedTxLogs),describeRecursively(newTxLogsDirectory));
  }
  private void assertRoundTrips(  Path oldDirectory) throws IOException, IncorrectFormat {
    Path archive=testDirectory.file("the-archive.dump").toPath();
    new Dumper().dump(oldDirectory,oldDirectory,archive,Predicates.alwaysFalse());
    Path newDirectory=testDirectory.file("the-new-directory").toPath();
    new Loader().load(archive,newDirectory,newDirectory);
    assertEquals(describeRecursively(oldDirectory),describeRecursively(newDirectory));
  }
  private Map<Path,Description> describeRecursively(  Path directory) throws IOException {
    return Files.walk(directory).map(path -> pair(directory.relativize(path),describe(path))).collect(HashMap::new,(pathDescriptionHashMap,pathDescriptionPair) -> pathDescriptionHashMap.put(pathDescriptionPair.first(),pathDescriptionPair.other()),HashMap::putAll);
  }
  private Description describe(  Path file){
    try {
      return isDirectory(file) ? new DirectoryDescription() : new FileDescription(Files.readAllBytes(file));
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
private interface Description {
  }
private class DirectoryDescription implements Description {
    @Override public boolean equals(    Object o){
      return this == o || !(o == null || getClass() != o.getClass());
    }
    @Override public int hashCode(){
      return 1;
    }
  }
private class FileDescription implements Description {
    private final byte[] bytes;
    FileDescription(    byte[] bytes){
      this.bytes=bytes;
    }
    @Override public boolean equals(    Object o){
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      FileDescription that=(FileDescription)o;
      return Arrays.equals(bytes,that.bytes);
    }
    @Override public int hashCode(){
      return Arrays.hashCode(bytes);
    }
  }
}
