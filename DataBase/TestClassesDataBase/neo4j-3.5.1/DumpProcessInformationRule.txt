public class DumpProcessInformationRule extends ExternalResource {
public interface Dump {
    void dump() throws Exception ;
  }
  public static Dump localVm(  final PrintStream out){
    return () -> DumpVmInformation.dumpVmInfo(out);
  }
  public static Dump otherVm(  final Matcher<String> processFilter,  final File baseDir){
    return () -> new DumpProcessInformation(NullLogProvider.getInstance(),baseDir).doThreadDump(processFilter);
  }
  private final ScheduledExecutorService executor=Executors.newScheduledThreadPool(2);
  private final long duration;
  private final TimeUnit timeUnit;
  private volatile ScheduledFuture<?> thunk;
  private final Dump[] dumps;
  /** 
 * Dumps process information about processes on the local machine, filtered by processFilter
 */
  public DumpProcessInformationRule(  long duration,  TimeUnit timeUnit,  Dump... dumps){
    this.duration=duration;
    this.timeUnit=timeUnit;
    this.dumps=dumps;
  }
  @Override protected synchronized void before() throws Throwable {
    if (null == thunk) {
      super.before();
      thunk=executor.schedule((Callable<Void>)() -> {
        dump();
        return null;
      }
,duration,timeUnit);
    }
 else {
      throw new IllegalStateException("process dumping thunk already started");
    }
  }
  @Override protected synchronized void after(){
    if (null != thunk && !thunk.isDone()) {
      thunk.cancel(true);
    }
    thunk=null;
    super.after();
  }
  public void dump() throws Exception {
    for (    Dump dump : dumps) {
      dump.dump();
    }
  }
}
