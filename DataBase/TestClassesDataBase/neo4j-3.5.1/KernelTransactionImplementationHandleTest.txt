public class KernelTransactionImplementationHandleTest {
  private final SystemNanoClock clock=Clocks.nanoClock();
  @Test public void returnsCorrectLastTransactionTimestampWhenStarted(){
    long lastCommittedTxTimestamp=42;
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.lastTransactionTimestampWhenStarted()).thenReturn(lastCommittedTxTimestamp);
    when(tx.isOpen()).thenReturn(true);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    assertEquals(lastCommittedTxTimestamp,handle.lastTransactionTimestampWhenStarted());
  }
  @Test public void returnsCorrectLastTransactionTimestampWhenStartedForClosedTx(){
    long lastCommittedTxTimestamp=4242;
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.lastTransactionTimestampWhenStarted()).thenReturn(lastCommittedTxTimestamp);
    when(tx.isOpen()).thenReturn(false);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    assertEquals(lastCommittedTxTimestamp,handle.lastTransactionTimestampWhenStarted());
  }
  @Test public void isOpenForUnchangedKernelTransactionImplementation(){
    int reuseCount=42;
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.isOpen()).thenReturn(true);
    when(tx.getReuseCount()).thenReturn(reuseCount);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    assertTrue(handle.isOpen());
  }
  @Test public void isOpenForReusedKernelTransactionImplementation(){
    int initialReuseCount=42;
    int nextReuseCount=4242;
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.isOpen()).thenReturn(true);
    when(tx.getReuseCount()).thenReturn(initialReuseCount).thenReturn(nextReuseCount);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    assertFalse(handle.isOpen());
  }
  @Test public void markForTerminationCallsKernelTransactionImplementation(){
    int reuseCount=42;
    Status.Transaction terminationReason=Status.Transaction.Terminated;
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.getReuseCount()).thenReturn(reuseCount);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    handle.markForTermination(terminationReason);
    verify(tx).markForTermination(reuseCount,terminationReason);
  }
  @Test public void markForTerminationReturnsTrueWhenSuccessful(){
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.getReuseCount()).thenReturn(42);
    when(tx.markForTermination(anyLong(),any())).thenReturn(true);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    assertTrue(handle.markForTermination(Status.Transaction.Terminated));
  }
  @Test public void markForTerminationReturnsFalseWhenNotSuccessful(){
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.getReuseCount()).thenReturn(42);
    when(tx.markForTermination(anyLong(),any())).thenReturn(false);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    assertFalse(handle.markForTermination(Status.Transaction.Terminated));
  }
  @Test public void transactionStatisticForReusedTransactionIsNotAvailable(){
    KernelTransactionImplementation tx=mock(KernelTransactionImplementation.class);
    when(tx.isOpen()).thenReturn(true);
    when(tx.getReuseCount()).thenReturn(2).thenReturn(3);
    KernelTransactionImplementationHandle handle=new KernelTransactionImplementationHandle(tx,clock);
    assertSame(TransactionExecutionStatistic.NOT_AVAILABLE,handle.transactionStatistic());
  }
}
