private static class TestPooledConcurrentMergeScheduler extends PooledConcurrentMergeScheduler {
  private CountDownLatch executionLatch=new CountDownLatch(1);
  @Override protected synchronized MergeThread getMergeThread(  IndexWriter writer,  MergePolicy.OneMerge merge){
    return new BlockingMerge(writer,merge,executionLatch);
  }
  CountDownLatch getExecutionLatch(){
    return executionLatch;
  }
class BlockingMerge extends ConcurrentMergeScheduler.MergeThread {
    private CountDownLatch executionLatch;
    BlockingMerge(    IndexWriter writer,    MergePolicy.OneMerge merge,    CountDownLatch executionLatch){
      super(writer,merge);
      this.executionLatch=executionLatch;
    }
    @Override public void run(){
      try {
        executionLatch.await();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Interrupted while waiting for a latch",e);
      }
    }
  }
}
