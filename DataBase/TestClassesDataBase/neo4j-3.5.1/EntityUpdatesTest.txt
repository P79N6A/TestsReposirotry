@SuppressWarnings("unchecked") public class EntityUpdatesTest {
  private static final long nodeId=0;
  private static final int labelId1=0;
  private static final int labelId2=1;
  private static final int unusedLabelId=2;
  private static final int propertyKeyId1=0;
  private static final int propertyKeyId2=1;
  private static final int propertyKeyId3=2;
  private static final long[] label=new long[]{labelId1};
  private static final long[] allLabels=new long[]{labelId1,labelId2};
  private static final long[] empty=new long[]{};
  private static final LabelSchemaDescriptor index1=SchemaDescriptorFactory.forLabel(labelId1,propertyKeyId1);
  private static final LabelSchemaDescriptor index2=SchemaDescriptorFactory.forLabel(labelId1,propertyKeyId2);
  private static final LabelSchemaDescriptor index3=SchemaDescriptorFactory.forLabel(labelId1,propertyKeyId3);
  private static final LabelSchemaDescriptor index123=SchemaDescriptorFactory.forLabel(labelId1,propertyKeyId1,propertyKeyId2,propertyKeyId3);
  private static final List<LabelSchemaDescriptor> indexes=Arrays.asList(index1,index2,index3,index123);
  private static final MultiTokenSchemaDescriptor nonSchemaIndex=SchemaDescriptorFactory.multiToken(new int[]{labelId1,labelId2},EntityType.NODE,propertyKeyId1,propertyKeyId2,propertyKeyId3);
  private static final StorageProperty property1=new PropertyKeyValue(propertyKeyId1,Values.of("Neo"));
  private static final StorageProperty property2=new PropertyKeyValue(propertyKeyId2,Values.of(100L));
  private static final StorageProperty property3=new PropertyKeyValue(propertyKeyId3,Values.pointValue(CoordinateReferenceSystem.WGS84,12.3,45.6));
  private static final Value[] values123=new Value[]{property1.value(),property2.value(),property3.value()};
  @Test public void shouldNotGenerateUpdatesForEmptyNodeUpdates(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).build();
    assertThat(updates.forIndexKeys(indexes,assertNoLoading(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldNotGenerateUpdateForMultipleExistingPropertiesAndLabels(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).existing(propertyKeyId1,Values.of("Neo")).existing(propertyKeyId2,Values.of(100L)).existing(propertyKeyId3,Values.pointValue(CoordinateReferenceSystem.WGS84,12.3,45.6)).build();
    assertThat(updates.forIndexKeys(indexes,assertNoLoading(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldNotGenerateUpdatesForLabelAdditionWithNoProperties(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(empty).withTokensAfter(label).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldGenerateUpdateForLabelAdditionWithExistingProperty(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(empty).withTokensAfter(label).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(property1),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,index1,property1.value())));
  }
  @Test public void shouldGenerateUpdatesForLabelAdditionWithExistingProperties(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(empty).withTokensAfter(label).existing(propertyKeyId1,Values.of("Neo")).existing(propertyKeyId2,Values.of(100L)).existing(propertyKeyId3,Values.pointValue(CoordinateReferenceSystem.WGS84,12.3,45.6)).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,index1,property1.value()),IndexEntryUpdate.add(nodeId,index2,property2.value()),IndexEntryUpdate.add(nodeId,index3,property3.value()),IndexEntryUpdate.add(nodeId,index123,values123)));
  }
  @Test public void shouldNotGenerateUpdateForPartialCompositeSchemaIndexUpdate(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).added(propertyKeyId1,Values.of("Neo")).added(propertyKeyId3,Values.pointValue(CoordinateReferenceSystem.WGS84,12.3,45.6)).build();
    assertThat(updates.forIndexKeys(singleton(index123),propertyLoader(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldGenerateUpdateForWhenCompletingCompositeSchemaIndexUpdate(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).added(propertyKeyId1,Values.of("Neo")).added(propertyKeyId3,Values.pointValue(CoordinateReferenceSystem.WGS84,12.3,45.6)).build();
    assertThat(updates.forIndexKeys(singleton(index123),propertyLoader(property2),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,index123,values123)));
  }
  @Test public void shouldNotGenerateUpdatesForLabelRemovalWithNoProperties(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(empty).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldGenerateUpdateForLabelRemovalWithExistingProperty(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(empty).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(property1),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.remove(nodeId,index1,property1.value())));
  }
  @Test public void shouldGenerateUpdatesForLabelRemovalWithExistingProperties(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(empty).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.remove(nodeId,index1,property1.value()),IndexEntryUpdate.remove(nodeId,index2,property2.value()),IndexEntryUpdate.remove(nodeId,index3,property3.value()),IndexEntryUpdate.remove(nodeId,index123,values123)));
  }
  @Test public void shouldNotGenerateUpdatesForPropertyAdditionWithNoLabels(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).added(property1.propertyKeyId(),property1.value()).build();
    assertThat(updates.forIndexKeys(indexes,assertNoLoading(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldGenerateUpdatesForSinglePropertyAdditionWithLabels(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).added(property1.propertyKeyId(),property1.value()).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,index1,property1.value())));
  }
  @Test public void shouldGenerateUpdatesForMultiplePropertyAdditionWithLabels(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).added(property1.propertyKeyId(),property1.value()).added(property2.propertyKeyId(),property2.value()).added(property3.propertyKeyId(),property3.value()).build();
    assertThat(updates.forIndexKeys(indexes,propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,index1,property1.value()),IndexEntryUpdate.add(nodeId,index2,property2.value()),IndexEntryUpdate.add(nodeId,index3,property3.value()),IndexEntryUpdate.add(nodeId,index123,values123)));
  }
  @Test public void shouldNotGenerateUpdatesForLabelAddAndPropertyRemove(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(empty).withTokensAfter(label).removed(property1.propertyKeyId(),property1.value()).removed(property2.propertyKeyId(),property2.value()).removed(property3.propertyKeyId(),property3.value()).build();
    assertThat(updates.forIndexKeys(indexes,assertNoLoading(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldNotGenerateUpdatesForLabelRemoveAndPropertyAdd(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(empty).added(property1.propertyKeyId(),property1.value()).added(property2.propertyKeyId(),property2.value()).added(property3.propertyKeyId(),property3.value()).build();
    assertThat(updates.forIndexKeys(indexes,assertNoLoading(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldNotLoadPropertyForLabelsAndNoPropertyChanges(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).build();
    assertThat(updates.forIndexKeys(singleton(index1),assertNoLoading(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldNotLoadPropertyForNoLabelsAndButPropertyAddition(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(empty).added(property1.propertyKeyId(),property1.value()).build();
    assertThat(updates.forIndexKeys(singleton(index1),assertNoLoading(),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldGenerateUpdateForPartialNonSchemaIndexUpdate(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).added(propertyKeyId1,Values.of("Neo")).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,nonSchemaIndex,property1.value(),null,null)));
  }
  @Test public void shouldGenerateUpdateForFullNonSchemaIndexUpdate(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).added(property1.propertyKeyId(),property1.value()).added(property2.propertyKeyId(),property2.value()).added(property3.propertyKeyId(),property3.value()).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,nonSchemaIndex,values123)));
  }
  @Test public void shouldGenerateUpdateForSingleChangeNonSchemaIndex(){
    Value newValue2=Values.of(10L);
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).changed(property2.propertyKeyId(),property2.value(),newValue2).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.change(nodeId,nonSchemaIndex,values123,new Value[]{property1.value(),newValue2,property3.value()})));
  }
  @Test public void shouldGenerateUpdateForAllChangedNonSchemaIndex(){
    Value newValue1=Values.of("Nio");
    Value newValue2=Values.of(10L);
    Value newValue3=Values.pointValue(CoordinateReferenceSystem.WGS84,32.3,15.6);
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).changed(property1.propertyKeyId(),property1.value(),newValue1).changed(property2.propertyKeyId(),property2.value(),newValue2).changed(property3.propertyKeyId(),property3.value(),newValue3).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.change(nodeId,nonSchemaIndex,values123,new Value[]{newValue1,newValue2,newValue3})));
  }
  @Test public void shouldGenerateUpdateWhenRemovingLastPropForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).removed(property2.propertyKeyId(),property2.value()).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property2),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.remove(nodeId,nonSchemaIndex,null,property2.value(),null)));
  }
  @Test public void shouldGenerateUpdateWhenRemovingOnePropertyForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(label).removed(property2.propertyKeyId(),property2.value()).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.change(nodeId,nonSchemaIndex,values123,new Value[]{property1.value(),null,property3.value()})));
  }
  @Test public void shouldGenerateUpdateWhenAddingOneTokenForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(empty).withTokensAfter(label).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,nonSchemaIndex,values123)));
  }
  @Test public void shouldGenerateUpdateWhenAddingMultipleTokensForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(empty).withTokensAfter(allLabels).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.add(nodeId,nonSchemaIndex,values123)));
  }
  @Test public void shouldNotGenerateUpdateWhenAddingAnotherTokenForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(allLabels).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldNotGenerateUpdateWhenAddingAnotherUselessTokenForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(labelId1,unusedLabelId).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldGenerateUpdateWhenSwitchingToUselessTokenForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(unusedLabelId).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.remove(nodeId,nonSchemaIndex,values123)));
  }
  @Test public void shouldNotGenerateUpdateWhenRemovingOneTokenForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(allLabels).withTokensAfter(label).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),emptyIterable());
  }
  @Test public void shouldGenerateUpdateWhenRemovingLastTokenForNonSchemaIndex(){
    EntityUpdates updates=EntityUpdates.forEntity(nodeId).withTokens(label).withTokensAfter(empty).build();
    assertThat(updates.forIndexKeys(singleton(nonSchemaIndex),propertyLoader(property1,property2,property3),EntityType.NODE),containsInAnyOrder(IndexEntryUpdate.remove(nodeId,nonSchemaIndex,values123)));
  }
  private PropertyLoader propertyLoader(  StorageProperty... properties){
    Map<Integer,Value> propertyMap=new HashMap<>();
    for (    StorageProperty p : properties) {
      propertyMap.put(p.propertyKeyId(),p.value());
    }
    return (nodeId1,type,propertyIds,sink) -> {
      MutableIntIterator iterator=propertyIds.intIterator();
      while (iterator.hasNext()) {
        int propertyId=iterator.next();
        if (propertyMap.containsKey(propertyId)) {
          sink.onProperty(propertyId,propertyMap.get(propertyId));
          iterator.remove();
        }
      }
    }
;
  }
  private PropertyLoader assertNoLoading(){
    return (nodeId1,type,propertyIds,sink) -> fail("Should never attempt to load properties!");
  }
}
