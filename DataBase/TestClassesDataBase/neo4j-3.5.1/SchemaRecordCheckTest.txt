class SchemaRecordCheckTest extends RecordCheckTestBase<DynamicRecord,ConsistencyReport.SchemaConsistencyReport,SchemaRecordCheck> {
  private final int labelId=1;
  private final int propertyKeyId=2;
  SchemaRecordCheckTest(){
    super(new SchemaRecordCheck(configureSchemaStore(),configureIndexAccessors()),ConsistencyReport.SchemaConsistencyReport.class,new int[0]);
  }
  @Test void shouldReportMalformedSchemaRule() throws Exception {
    DynamicRecord badRecord=inUse(new DynamicRecord(0));
    badRecord.setType(RecordAccessStub.SCHEMA_RECORD_TYPE);
    when(checker().ruleAccess.loadSingleSchemaRule(0)).thenThrow(new MalformedSchemaRuleException("Bad Record"));
    ConsistencyReport.SchemaConsistencyReport report=check(badRecord);
    verify(report).malformedSchemaRule();
  }
  @Test void shouldReportInvalidLabelReferences() throws Exception {
    int schemaRuleId=0;
    DynamicRecord record=inUse(dynamicRecord(schemaRuleId));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule=indexRule(schemaRuleId,labelId,propertyKeyId,providerDescriptor);
    when(checker().ruleAccess.loadSingleSchemaRule(schemaRuleId)).thenReturn(rule);
    LabelTokenRecord labelTokenRecord=add(notInUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    ConsistencyReport.SchemaConsistencyReport report=check(record);
    verify(report).labelNotInUse(labelTokenRecord);
  }
  @Test void shouldReportInvalidPropertyReferenceFromIndexRule() throws Exception {
    int schemaRuleId=0;
    DynamicRecord record=inUse(dynamicRecord(schemaRuleId));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule=indexRule(schemaRuleId,labelId,propertyKeyId,providerDescriptor);
    when(checker().ruleAccess.loadSingleSchemaRule(schemaRuleId)).thenReturn(rule);
    add(inUse(new LabelTokenRecord(labelId)));
    PropertyKeyTokenRecord propertyKeyToken=add(notInUse(new PropertyKeyTokenRecord(propertyKeyId)));
    ConsistencyReport.SchemaConsistencyReport report=check(record);
    verify(report).propertyKeyNotInUse(propertyKeyToken);
  }
  @Test void shouldReportInvalidPropertyReferenceFromUniquenessConstraintRule() throws Exception {
    int schemaRuleId=0;
    int indexRuleId=1;
    DynamicRecord record=inUse(dynamicRecord(schemaRuleId));
    ConstraintRule rule=uniquenessConstraintRule(schemaRuleId,labelId,propertyKeyId,indexRuleId);
    when(checker().ruleAccess.loadSingleSchemaRule(schemaRuleId)).thenReturn(rule);
    add(inUse(new LabelTokenRecord(labelId)));
    PropertyKeyTokenRecord propertyKeyToken=add(notInUse(new PropertyKeyTokenRecord(propertyKeyId)));
    ConsistencyReport.SchemaConsistencyReport report=check(record);
    verify(report).propertyKeyNotInUse(propertyKeyToken);
  }
  @Test void shouldReportUniquenessConstraintNotReferencingBack() throws Exception {
    int ruleId1=0;
    int ruleId2=1;
    DynamicRecord record1=inUse(dynamicRecord(ruleId1));
    DynamicRecord record2=inUse(dynamicRecord(ruleId2));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule1=constraintIndexRule(ruleId1,labelId,propertyKeyId,providerDescriptor,(long)ruleId2);
    ConstraintRule rule2=uniquenessConstraintRule(ruleId2,labelId,propertyKeyId,ruleId2);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId1)).thenReturn(rule1);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId2)).thenReturn(rule2);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record1);
    check(record2);
    SchemaRecordCheck obligationChecker=checker().forObligationChecking();
    check(obligationChecker,record1);
    ConsistencyReport.SchemaConsistencyReport report=check(obligationChecker,record2);
    verify(report).uniquenessConstraintNotReferencingBack(record1);
  }
  @Test void shouldNotReportConstraintIndexRuleWithoutBackReference() throws Exception {
    int ruleId=1;
    DynamicRecord record=inUse(dynamicRecord(ruleId));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule=constraintIndexRule(ruleId,labelId,propertyKeyId,providerDescriptor);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId)).thenReturn(rule);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record);
    SchemaRecordCheck obligationChecker=checker().forObligationChecking();
    ConsistencyReport.SchemaConsistencyReport report=check(obligationChecker,record);
    verifyZeroInteractions(report);
  }
  @Test void shouldReportTwoUniquenessConstraintsReferencingSameIndex() throws Exception {
    int ruleId1=0;
    int ruleId2=1;
    DynamicRecord record1=inUse(dynamicRecord(ruleId1));
    DynamicRecord record2=inUse(dynamicRecord(ruleId2));
    ConstraintRule rule1=uniquenessConstraintRule(ruleId1,labelId,propertyKeyId,ruleId2);
    ConstraintRule rule2=uniquenessConstraintRule(ruleId2,labelId,propertyKeyId,ruleId2);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId1)).thenReturn(rule1);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId2)).thenReturn(rule2);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record1);
    ConsistencyReport.SchemaConsistencyReport report=check(record2);
    verify(report).duplicateObligation(record1);
  }
  @Test void shouldReportUnreferencedUniquenessConstraint() throws Exception {
    int ruleId=0;
    DynamicRecord record=inUse(dynamicRecord(ruleId));
    ConstraintRule rule=uniquenessConstraintRule(ruleId,labelId,propertyKeyId,ruleId);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId)).thenReturn(rule);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record);
    SchemaRecordCheck obligationChecker=checker().forObligationChecking();
    ConsistencyReport.SchemaConsistencyReport report=check(obligationChecker,record);
    verify(report).missingObligation(SchemaRule.Kind.CONSTRAINT_INDEX_RULE);
  }
  @Test void shouldReportConstraintIndexNotReferencingBack() throws Exception {
    int ruleId1=0;
    int ruleId2=1;
    DynamicRecord record1=inUse(dynamicRecord(ruleId1));
    DynamicRecord record2=inUse(dynamicRecord(ruleId2));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule1=constraintIndexRule(ruleId1,labelId,propertyKeyId,providerDescriptor,(long)ruleId1);
    ConstraintRule rule2=uniquenessConstraintRule(ruleId2,labelId,propertyKeyId,ruleId1);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId1)).thenReturn(rule1);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId2)).thenReturn(rule2);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record1);
    check(record2);
    SchemaRecordCheck obligationChecker=checker().forObligationChecking();
    ConsistencyReport.SchemaConsistencyReport report=check(obligationChecker,record1);
    check(obligationChecker,record2);
    verify(report).constraintIndexRuleNotReferencingBack(record2);
  }
  @Test void shouldReportTwoConstraintIndexesReferencingSameConstraint() throws Exception {
    int ruleId1=0;
    int ruleId2=1;
    DynamicRecord record1=inUse(dynamicRecord(ruleId1));
    DynamicRecord record2=inUse(dynamicRecord(ruleId2));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule1=constraintIndexRule(ruleId1,labelId,propertyKeyId,providerDescriptor,(long)ruleId1);
    StoreIndexDescriptor rule2=constraintIndexRule(ruleId2,labelId,propertyKeyId,providerDescriptor,(long)ruleId1);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId1)).thenReturn(rule1);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId2)).thenReturn(rule2);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record1);
    ConsistencyReport.SchemaConsistencyReport report=check(record2);
    verify(report).duplicateObligation(record1);
  }
  @Test void shouldReportUnreferencedConstraintIndex() throws Exception {
    int ruleId=0;
    DynamicRecord record=inUse(dynamicRecord(ruleId));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule=constraintIndexRule(ruleId,labelId,propertyKeyId,providerDescriptor,(long)ruleId);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId)).thenReturn(rule);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record);
    SchemaRecordCheck obligationChecker=checker().forObligationChecking();
    ConsistencyReport.SchemaConsistencyReport report=check(obligationChecker,record);
    verify(report).missingObligation(SchemaRule.Kind.UNIQUENESS_CONSTRAINT);
  }
  @Test void shouldReportTwoIndexRulesWithDuplicateContent() throws Exception {
    int ruleId1=0;
    int ruleId2=1;
    DynamicRecord record1=inUse(dynamicRecord(ruleId1));
    DynamicRecord record2=inUse(dynamicRecord(ruleId2));
    IndexProviderDescriptor providerDescriptor=new IndexProviderDescriptor("in-memory","1.0");
    StoreIndexDescriptor rule1=constraintIndexRule(ruleId1,labelId,propertyKeyId,providerDescriptor,(long)ruleId1);
    StoreIndexDescriptor rule2=constraintIndexRule(ruleId2,labelId,propertyKeyId,providerDescriptor,(long)ruleId2);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId1)).thenReturn(rule1);
    when(checker().ruleAccess.loadSingleSchemaRule(ruleId2)).thenReturn(rule2);
    add(inUse(new LabelTokenRecord(labelId)));
    add(inUse(new PropertyKeyTokenRecord(propertyKeyId)));
    check(record1);
    ConsistencyReport.SchemaConsistencyReport report=check(record2);
    verify(report).duplicateRuleContent(record1);
  }
  private static IndexAccessors configureIndexAccessors(){
    return mock(IndexAccessors.class);
  }
  private static SchemaStorage configureSchemaStore(){
    return mock(SchemaStorage.class);
  }
  private static DynamicRecord dynamicRecord(  long id){
    DynamicRecord record=new DynamicRecord(id);
    record.setType(RecordAccessStub.SCHEMA_RECORD_TYPE);
    return record;
  }
}
