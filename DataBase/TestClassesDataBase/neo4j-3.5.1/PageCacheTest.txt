@SuppressWarnings("OptionalGetWithoutIsPresent") public abstract class PageCacheTest<T extends PageCache> extends PageCacheTestSupport<T> {
  protected OpenOption[] openOptions=new OpenOption[0];
  protected PagedFile map(  PageCache pageCache,  File file,  int filePageSize,  OpenOption... options) throws IOException {
    return pageCache.map(file,filePageSize,addAll(openOptions,options));
  }
  protected PagedFile map(  File file,  int filePageSize,  OpenOption... options) throws IOException {
    return map(pageCache,file,filePageSize,options);
  }
  @Test void mustReportConfiguredMaxPages(){
    configureStandardPageCache();
    assertThat(pageCache.maxCachedPages(),is((long)maxPages));
  }
  @Test void mustReportConfiguredCachePageSize(){
    configureStandardPageCache();
    assertThat(pageCache.pageSize(),is(pageCachePageSize));
  }
  @Test void mustHaveAtLeastTwoPages(){
    assertThrows(IllegalArgumentException.class,() -> getPageCache(fs,1,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL));
  }
  @Test void mustAcceptTwoPagesAsMinimumConfiguration(){
    getPageCache(fs,2,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
  }
  @Test void gettingNameFromMappedFileMustMatchMappedFileName() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    try (PagedFile pf=map(file,filePageSize)){
      assertThat(pf.file(),equalTo(file));
    }
   }
  @Test void mustClosePageSwapperFactoryOnPageCacheClose() throws Exception {
    AtomicBoolean closed=new AtomicBoolean();
    PageSwapperFactory swapperFactory=new SingleFilePageSwapperFactory(){
      @Override public void close(){
        closed.set(true);
      }
    }
;
    PageCache cache=createPageCache(swapperFactory,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL,EmptyVersionContextSupplier.EMPTY);
    Exception exception=null;
    try {
      assertFalse(closed.get());
    }
 catch (    Exception e) {
      exception=e;
    }
 finally {
      try {
        cache.close();
        assertTrue(closed.get());
      }
 catch (      Exception e) {
        if (exception == null) {
          exception=e;
        }
 else {
          exception.addSuppressed(e);
        }
      }
      if (exception != null) {
        throw exception;
      }
    }
  }
  @Test void closingOfPageCacheMustBeConsideredSuccessfulEvenIfPageSwapperFactoryCloseThrows(){
    AtomicInteger closed=new AtomicInteger();
    PageSwapperFactory swapperFactory=new SingleFilePageSwapperFactory(){
      @Override public void close(){
        closed.getAndIncrement();
        throw new RuntimeException("boo");
      }
    }
;
    PageCache cache=createPageCache(swapperFactory,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL,EmptyVersionContextSupplier.EMPTY);
    Exception exception=assertThrows(Exception.class,cache::close);
    assertThat(exception.getMessage(),is("boo"));
    cache.close();
  }
  @Test void mustReadExistingData(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordCount,recordSize);
      int recordId=0;
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
        while (cursor.next()) {
          verifyRecordsMatchExpected(cursor);
          recordId+=recordsPerFilePage;
        }
      }
       assertThat(recordId,is(recordCount));
    }
);
  }
  @Test void mustScanInTheMiddleOfTheFile(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      long startPage=10;
      long endPage=(recordCount / recordsPerFilePage) - 10;
      generateFileWithRecords(file("a"),recordCount,recordSize);
      int recordId=(int)(startPage * recordsPerFilePage);
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(startPage,PF_SHARED_READ_LOCK)){
        while (cursor.next() && cursor.getCurrentPageId() < endPage) {
          verifyRecordsMatchExpected(cursor);
          recordId+=recordsPerFilePage;
        }
      }
       assertThat(recordId,is(recordCount - (10 * recordsPerFilePage)));
    }
);
  }
  @Test void writesFlushedFromPageFileMustBeExternallyObservable(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      long startPageId=0;
      long endPageId=recordCount / recordsPerFilePage;
      try (PageCursor cursor=pagedFile.io(startPageId,PF_SHARED_WRITE_LOCK)){
        while (cursor.getCurrentPageId() < endPageId && cursor.next()) {
          writeRecords(cursor);
        }
      }
       pagedFile.flushAndForce();
      verifyRecordsInFile(file("a"),recordCount);
      pagedFile.close();
    }
);
  }
  @Test void pageCacheFlushAndForceMustThrowOnNullIOPSLimiter(){
    configureStandardPageCache();
    assertThrows(IllegalArgumentException.class,() -> pageCache.flushAndForce(null));
  }
  @Test void pagedFileFlushAndForceMustThrowOnNullIOPSLimiter() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      assertThrows(IllegalArgumentException.class,() -> pf.flushAndForce(null));
    }
   }
  @Test void pageCacheFlushAndForceMustQueryTheGivenIOPSLimiter() throws Exception {
    int pagesToDirty=10_000;
    PageCache cache=getPageCache(fs,nextPowerOf2(2 * pagesToDirty),PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    PagedFile pfA=cache.map(existingFile("a"),filePageSize);
    PagedFile pfB=cache.map(existingFile("b"),filePageSize);
    dirtyManyPages(pfA,pagesToDirty);
    dirtyManyPages(pfB,pagesToDirty);
    AtomicInteger callbackCounter=new AtomicInteger();
    AtomicInteger ioCounter=new AtomicInteger();
    cache.flushAndForce((previousStamp,recentlyCompletedIOs,swapper) -> {
      ioCounter.addAndGet(recentlyCompletedIOs);
      return callbackCounter.getAndIncrement();
    }
);
    pfA.close();
    pfB.close();
    assertThat(callbackCounter.get(),greaterThan(0));
    assertThat(ioCounter.get(),greaterThanOrEqualTo(pagesToDirty * 2 - 30));
  }
  @Test void pagedFileFlushAndForceMustQueryTheGivenIOPSLimiter() throws Exception {
    int pagesToDirty=10_000;
    PageCache cache=getPageCache(fs,nextPowerOf2(pagesToDirty),PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    PagedFile pf=cache.map(file("a"),filePageSize);
    dirtyManyPages(pf,pagesToDirty);
    AtomicInteger callbackCounter=new AtomicInteger();
    AtomicInteger ioCounter=new AtomicInteger();
    pf.flushAndForce((previousStamp,recentlyCompletedIOs,swapper) -> {
      ioCounter.addAndGet(recentlyCompletedIOs);
      return callbackCounter.getAndIncrement();
    }
);
    pf.close();
    assertThat(callbackCounter.get(),greaterThan(0));
    assertThat(ioCounter.get(),greaterThanOrEqualTo(pagesToDirty - 30));
  }
  private void dirtyManyPages(  PagedFile pf,  int pagesToDirty) throws IOException {
    try (PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      for (int i=0; i < pagesToDirty; i++) {
        assertTrue(cursor.next());
      }
    }
   }
  @Test void writesFlushedFromPageFileMustBeObservableEvenWhenRacingWithEviction(){
    assertTimeout(ofMillis(LONG_TIMEOUT_MILLIS),() -> {
      getPageCache(fs,20,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
      long startPageId=0;
      long endPageId=21;
      int iterations=500;
      int shortsPerPage=pageCachePageSize / 2;
      try (PagedFile pagedFile=map(file("a"),pageCachePageSize)){
        for (int i=1; i <= iterations; i++) {
          try (PageCursor cursor=pagedFile.io(startPageId,PF_SHARED_WRITE_LOCK)){
            while (cursor.getCurrentPageId() < endPageId && cursor.next()) {
              for (int j=0; j < shortsPerPage; j++) {
                cursor.putShort((short)i);
              }
            }
          }
           pagedFile.flushAndForce();
          try (DataInputStream stream=new DataInputStream(fs.openAsInputStream(file("a")))){
            for (int j=0; j < shortsPerPage; j++) {
              int value=stream.readShort();
              assertThat("short pos = " + j + ", iteration = "+ i,value,is(i));
            }
          }
         }
      }
     }
);
  }
  @Test void flushAndForceMustNotLockPageCacheForWholeDuration(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      maxPages=5000;
      configureStandardPageCache();
      PageCache pageCache=this.pageCache;
      this.pageCache=null;
      File a=existingFile("a");
      File b=existingFile("b");
      try (PagedFile pfA=map(pageCache,a,filePageSize)){
        try (PageCursor cursor=pfA.io(0,PF_SHARED_WRITE_LOCK)){
          for (int i=0; i < maxPages; i++) {
            assertTrue(cursor.next());
          }
        }
         BinaryLatch limiterStartLatch=new BinaryLatch();
        BinaryLatch limiterBlockLatch=new BinaryLatch();
        Future<?> flusher=executor.submit(() -> {
          pageCache.flushAndForce((stamp,ios,flushable) -> {
            limiterStartLatch.release();
            limiterBlockLatch.await();
            return 0;
          }
);
          return null;
        }
);
        limiterStartLatch.await();
        map(pageCache,b,filePageSize).close();
        pageCache.listExistingMappings();
        pageCache.getExistingMapping(a).ifPresent(pf -> {
          try {
            pf.close();
          }
 catch (          IOException e) {
            throw new UncheckedIOException(e);
          }
        }
);
        limiterBlockLatch.release();
        flusher.get();
      }
     }
);
  }
  @Test void flushAndForceMustTolerateAsynchronousFileUnmapping() throws Exception {
    configureStandardPageCache();
    PageCache pageCache=this.pageCache;
    this.pageCache=null;
    File a=existingFile("a");
    File b=existingFile("b");
    File c=existingFile("c");
    BinaryLatch limiterStartLatch=new BinaryLatch();
    BinaryLatch limiterBlockLatch=new BinaryLatch();
    Future<?> flusher;
    try (PagedFile pfA=map(pageCache,a,filePageSize);PagedFile pfB=map(pageCache,b,filePageSize);PagedFile pfC=map(pageCache,c,filePageSize)){
      try (PageCursor cursor=pfA.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
       try (PageCursor cursor=pfB.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
       try (PageCursor cursor=pfC.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
       flusher=executor.submit(() -> {
        pageCache.flushAndForce((stamp,ios,flushable) -> {
          limiterStartLatch.release();
          limiterBlockLatch.await();
          return 0;
        }
);
        return null;
      }
);
      limiterStartLatch.await();
    }
     limiterBlockLatch.release();
    flusher.get();
  }
  @Test void writesFlushedFromPageCacheMustBeExternallyObservable(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      long startPageId=0;
      long endPageId=recordCount / recordsPerFilePage;
      File file=file("a");
      try (PagedFile pagedFile=map(file,filePageSize);PageCursor cursor=pagedFile.io(startPageId,PF_SHARED_WRITE_LOCK)){
        while (cursor.getCurrentPageId() < endPageId && cursor.next()) {
          writeRecords(cursor);
        }
      }
       verifyRecordsInFile(file,recordCount);
    }
);
  }
  @Test void writesToPagesMustNotBleedIntoAdjacentPages(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=1; i <= 100; i++) {
          assertTrue(cursor.next());
          for (int j=0; j < filePageSize; j++) {
            cursor.putByte((byte)i);
          }
        }
      }
       InputStream inputStream=fs.openAsInputStream(file("a"));
      for (int i=1; i <= 100; i++) {
        for (int j=0; j < filePageSize; j++) {
          assertThat(inputStream.read(),is(i));
        }
      }
      inputStream.close();
    }
);
  }
  @Test void channelMustBeForcedAfterPagedFileFlushAndForce() throws Exception {
    final AtomicInteger writeCounter=new AtomicInteger();
    final AtomicInteger forceCounter=new AtomicInteger();
    FileSystemAbstraction fs=writeAndForceCountingFs(writeCounter,forceCounter);
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.putInt(1);
        assertTrue(cursor.next());
        cursor.putInt(1);
      }
       pagedFile.flushAndForce();
      assertThat(writeCounter.get(),greaterThanOrEqualTo(2));
      assertThat(forceCounter.get(),is(1));
    }
   }
  @Test void channelsMustBeForcedAfterPageCacheFlushAndForce() throws Exception {
    final AtomicInteger writeCounter=new AtomicInteger();
    final AtomicInteger forceCounter=new AtomicInteger();
    FileSystemAbstraction fs=writeAndForceCountingFs(writeCounter,forceCounter);
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    try (PagedFile pagedFileA=map(existingFile("a"),filePageSize);PagedFile pagedFileB=map(existingFile("b"),filePageSize)){
      try (PageCursor cursor=pagedFileA.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.putInt(1);
        assertTrue(cursor.next());
        cursor.putInt(1);
      }
       try (PageCursor cursor=pagedFileB.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.putInt(1);
      }
       pageCache.flushAndForce();
      assertThat(writeCounter.get(),greaterThanOrEqualTo(3));
      assertThat(forceCounter.get(),is(2));
    }
   }
  private DelegatingFileSystemAbstraction writeAndForceCountingFs(  final AtomicInteger writeCounter,  final AtomicInteger forceCounter){
    return new DelegatingFileSystemAbstraction(fs){
      @Override public StoreChannel open(      File fileName,      OpenMode openMode) throws IOException {
        return new DelegatingStoreChannel(super.open(fileName,openMode)){
          @Override public void writeAll(          ByteBuffer src,          long position) throws IOException {
            writeCounter.getAndIncrement();
            super.writeAll(src,position);
          }
          @Override public void force(          boolean metaData) throws IOException {
            forceCounter.getAndIncrement();
            super.force(metaData);
          }
        }
;
      }
    }
;
  }
  @Test void firstNextCallMustReturnFalseWhenTheFileIsEmptyAndNoGrowIsSpecified(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
        assertFalse(cursor.next());
      }
     }
);
  }
  @Test void nextMustReturnTrueThenFalseWhenThereIsOnlyOnePageInTheFileAndNoGrowIsSpecified(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      int numberOfRecordsToGenerate=recordsPerFilePage;
      generateFileWithRecords(file("a"),numberOfRecordsToGenerate,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
        assertTrue(cursor.next());
        verifyRecordsMatchExpected(cursor);
        assertFalse(cursor.next());
      }
     }
);
  }
  @Test void closingWithoutCallingNextMustLeavePageUnpinnedAndUntouched(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      int numberOfRecordsToGenerate=recordsPerFilePage;
      generateFileWithRecords(file("a"),numberOfRecordsToGenerate,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        try (PageCursor ignore=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        }
         try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
          cursor.next();
          verifyRecordsMatchExpected(cursor);
        }
       }
     }
);
  }
  @Test void nextWithNegativeInitialPageIdMustReturnFalse() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordCount,recordSize);
    try (PagedFile pf=map(file,filePageSize)){
      try (PageCursor cursor=pf.io(-1,PF_SHARED_WRITE_LOCK)){
        assertFalse(cursor.next());
      }
       try (PageCursor cursor=pf.io(-1,PF_SHARED_READ_LOCK)){
        assertFalse(cursor.next());
      }
     }
   }
  @Test void nextWithNegativePageIdMustReturnFalse() throws Exception {
    File file=file("a");
    generateFileWithRecords(file,recordCount,recordSize);
    configureStandardPageCache();
    try (PagedFile pf=map(file,filePageSize)){
      long pageId=12;
      try (PageCursor cursor=pf.io(pageId,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        assertFalse(cursor.next(-1));
        assertThat(cursor.getCurrentPageId(),is(PageCursor.UNBOUND_PAGE_ID));
      }
       try (PageCursor cursor=pf.io(pageId,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        assertFalse(cursor.next(-1));
        assertThat(cursor.getCurrentPageId(),is(PageCursor.UNBOUND_PAGE_ID));
      }
     }
   }
  @Test void rewindMustStartScanningOverFromTheBeginning(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      int numberOfRewindsToTest=10;
      generateFileWithRecords(file("a"),recordCount,recordSize);
      int actualPageCounter=0;
      int filePageCount=recordCount / recordsPerFilePage;
      int expectedPageCounterResult=numberOfRewindsToTest * filePageCount;
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        for (int i=0; i < numberOfRewindsToTest; i++) {
          while (cursor.next()) {
            verifyRecordsMatchExpected(cursor);
            actualPageCounter++;
          }
          cursor.rewind();
        }
      }
       assertThat(actualPageCounter,is(expectedPageCounterResult));
    }
);
  }
  @Test void mustCloseFileChannelWhenTheLastHandleIsUnmapped(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      assumeTrue(fs.getClass() == EphemeralFileSystemAbstraction.class,"This depends on EphemeralFSA specific features");
      configureStandardPageCache();
      PagedFile a=map(file("a"),filePageSize);
      PagedFile b=map(file("a"),filePageSize);
      a.close();
      b.close();
      ((EphemeralFileSystemAbstraction)fs).assertNoOpenFiles();
    }
);
  }
  @Test void dirtyPagesMustBeFlushedWhenTheCacheIsClosed(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      long startPageId=0;
      long endPageId=recordCount / recordsPerFilePage;
      File file=file("a");
      try (PagedFile pagedFile=map(file,filePageSize);PageCursor cursor=pagedFile.io(startPageId,PF_SHARED_WRITE_LOCK)){
        while (cursor.getCurrentPageId() < endPageId && cursor.next()) {
          writeRecords(cursor);
        }
      }
  finally {
        pageCache.close();
      }
      verifyRecordsInFile(file,recordCount);
    }
);
  }
  @Test void dirtyPagesMustBeFlushedWhenThePagedFileIsClosed(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      long startPageId=0;
      long endPageId=recordCount / recordsPerFilePage;
      File file=file("a");
      try (PagedFile pagedFile=map(file,filePageSize);PageCursor cursor=pagedFile.io(startPageId,PF_SHARED_WRITE_LOCK)){
        while (cursor.getCurrentPageId() < endPageId && cursor.next()) {
          writeRecords(cursor);
        }
      }
       verifyRecordsInFile(file,recordCount);
    }
);
  }
  @RepeatedTest(100) void flushingDuringPagedFileCloseMustRetryUntilItSucceeds(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      FileSystemAbstraction fs=new DelegatingFileSystemAbstraction(this.fs){
        @Override public StoreChannel open(        File fileName,        OpenMode openMode) throws IOException {
          return new DelegatingStoreChannel(super.open(fileName,openMode)){
            private int writeCount;
            @Override public void writeAll(            ByteBuffer src,            long position) throws IOException {
              if (writeCount++ < 10) {
                throw new IOException("This is a benign exception that we expect to be thrown " + "during a flush of a PagedFile.");
              }
              super.writeAll(src,position);
            }
          }
;
        }
      }
;
      getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
      PrintStream oldSystemErr=System.err;
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        writeRecords(cursor);
        System.setErr(new PrintStream(new ByteArrayOutputStream()));
      }
  finally {
        System.setErr(oldSystemErr);
      }
      verifyRecordsInFile(file("a"),recordsPerFilePage);
    }
);
  }
  @Test void mappingFilesInClosedCacheMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      pageCache.close();
      assertThrows(IllegalStateException.class,() -> map(file("a"),filePageSize));
    }
);
  }
  @Test void flushingClosedCacheMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      pageCache.close();
      assertThrows(IllegalStateException.class,() -> pageCache.flushAndForce());
    }
);
  }
  @Test void mappingFileWithPageSizeGreaterThanCachePageSizeMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      assertThrows(IllegalArgumentException.class,() -> map(file("a"),pageCachePageSize + 1));
    }
);
  }
  @Test void mappingFileWithPageSizeSmallerThanLongSizeBytesMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      assertThrows(IllegalArgumentException.class,() -> map(file("a"),Long.BYTES - 1));
    }
);
  }
  @Test void mappingFileWithPageSizeSmallerThanLongSizeBytesMustThrowEvenWithAnyPageSizeOpenOptionAndNoExistingMapping(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      assertThrows(IllegalArgumentException.class,() -> map(file("a"),Long.BYTES - 1,PageCacheOpenOptions.ANY_PAGE_SIZE));
    }
);
  }
  @Test void mappingFileWithPageZeroPageSizeMustThrowEvenWithExistingMapping(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File file=file("a");
      try (PagedFile oldMapping=map(file,filePageSize)){
        assertThrows(IllegalArgumentException.class,() -> map(file,Long.BYTES - 1));
      }
     }
);
  }
  @Test void mappingFileWithPageZeroPageSizeAndAnyPageSizeOpenOptionMustNotThrowGivenExistingMapping(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File file=file("a");
      try (PagedFile oldMapping=map(file,filePageSize);PagedFile newMapping=map(file,0,PageCacheOpenOptions.ANY_PAGE_SIZE)){
      }
     }
);
  }
  @Test void mappingFileWithPageSizeEqualToCachePageSizeMustNotThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),pageCachePageSize);
      pagedFile.close();
    }
);
  }
  @Test void notSpecifyingAnyPfFlagsMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        assertThrows(IllegalArgumentException.class,() -> pagedFile.io(0,0));
      }
     }
);
  }
  @Test void notSpecifyingAnyPfLockFlagsMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        assertThrows(IllegalArgumentException.class,() -> pagedFile.io(0,PF_NO_FAULT));
      }
     }
);
  }
  @Test void specifyingBothReadAndWriteLocksMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        assertThrows(IllegalArgumentException.class,() -> pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_SHARED_READ_LOCK));
      }
     }
);
  }
  @Test void mustNotPinPagesAfterNextReturnsFalse(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final CountDownLatch startLatch=new CountDownLatch(1);
      final CountDownLatch unpinLatch=new CountDownLatch(1);
      final AtomicReference<Exception> exceptionRef=new AtomicReference<>();
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage,recordSize);
      final PagedFile pagedFile=map(file("a"),filePageSize);
      Runnable runnable=() -> {
        try (PageCursor cursorA=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertTrue(cursorA.next());
          assertFalse(cursorA.next());
          startLatch.countDown();
          unpinLatch.await();
        }
 catch (        Exception e) {
          exceptionRef.set(e);
        }
      }
;
      executor.submit(runnable);
      startLatch.await();
      try (PageCursor cursorB=pagedFile.io(1,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursorB.next());
        unpinLatch.countDown();
      }
  finally {
        pagedFile.close();
      }
      Exception e=exceptionRef.get();
      if (e != null) {
        throw new Exception("Child thread got exception",e);
      }
    }
);
  }
  @Test void nextMustResetTheCursorOffset(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.setOffset(0);
        cursor.putByte((byte)1);
        cursor.putByte((byte)2);
        cursor.putByte((byte)3);
        cursor.putByte((byte)4);
        assertTrue(cursor.next());
        cursor.setOffset(0);
        cursor.putByte((byte)5);
        cursor.putByte((byte)6);
        cursor.putByte((byte)7);
        cursor.putByte((byte)8);
      }
       try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK)){
        byte[] bytes=new byte[4];
        assertTrue(cursor.next());
        cursor.getBytes(bytes);
        assertThat(bytes,byteArray(new byte[]{1,2,3,4}));
        assertTrue(cursor.next());
        cursor.getBytes(bytes);
        assertThat(bytes,byteArray(new byte[]{5,6,7,8}));
      }
       pagedFile.close();
    }
);
  }
  @Test void nextMustAdvanceCurrentPageId(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        assertThat(cursor.getCurrentPageId(),is(0L));
        assertTrue(cursor.next());
        assertThat(cursor.getCurrentPageId(),is(1L));
      }
     }
);
  }
  @Test void nextToSpecificPageIdMustAdvanceFromThatPointOn(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(1L,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        assertThat(cursor.getCurrentPageId(),is(1L));
        assertTrue(cursor.next(4L));
        assertThat(cursor.getCurrentPageId(),is(4L));
        assertTrue(cursor.next());
        assertThat(cursor.getCurrentPageId(),is(5L));
      }
     }
);
  }
  @Test void currentPageIdIsUnboundBeforeFirstNextAndAfterRewind(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK)){
        assertThat(cursor.getCurrentPageId(),is(PageCursor.UNBOUND_PAGE_ID));
        assertTrue(cursor.next());
        assertThat(cursor.getCurrentPageId(),is(0L));
        cursor.rewind();
        assertThat(cursor.getCurrentPageId(),is(PageCursor.UNBOUND_PAGE_ID));
      }
     }
);
  }
  @Test void pageCursorMustKnowCurrentFilePageSize(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK)){
        assertThat(cursor.getCurrentPageSize(),is(PageCursor.UNBOUND_PAGE_SIZE));
        assertTrue(cursor.next());
        assertThat(cursor.getCurrentPageSize(),is(filePageSize));
        cursor.rewind();
        assertThat(cursor.getCurrentPageSize(),is(PageCursor.UNBOUND_PAGE_SIZE));
      }
     }
);
  }
  @Test void pageCursorMustKnowCurrentFile(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK)){
        assertThat(cursor.getCurrentFile(),nullValue());
        assertTrue(cursor.next());
        assertThat(cursor.getCurrentFile(),is(file("a")));
        cursor.rewind();
        assertThat(cursor.getCurrentFile(),nullValue());
      }
     }
);
  }
  @Test void readingFromUnboundReadCursorMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnReadCursor(this::checkUnboundReadCursorAccess));
  }
  @Test void readingFromUnboundWriteCursorMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnReadCursor(this::checkUnboundWriteCursorAccess));
  }
  @Test void readingFromPreviouslyBoundCursorMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnReadCursor(this::checkPreviouslyBoundWriteCursorAccess));
  }
  @Test void writingToUnboundCursorMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnWriteCursor(this::checkUnboundWriteCursorAccess));
  }
  @Test void writingToPreviouslyBoundCursorMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnWriteCursor(this::checkPreviouslyBoundWriteCursorAccess));
  }
  @Test void readFromReadCursorAfterNextReturnsFalseMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnReadCursor(this::checkReadCursorAfterFailedNext));
  }
  @Test void readFromPreviouslyBoundReadCursorAfterNextReturnsFalseMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnReadCursor(this::checkPreviouslyBoundReadCursorAfterFailedNext));
  }
  @Test void readFromWriteCursorAfterNextReturnsFalseMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnReadCursor(this::checkWriteCursorAfterFailedNext));
  }
  @Test void readFromPreviouslyBoundWriteCursorAfterNextReturnsFalseMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnReadCursor(this::checkPreviouslyBoundWriteCursorAfterFailedNext));
  }
  @Test void writeAfterNextReturnsFalseMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnWriteCursor(this::checkWriteCursorAfterFailedNext));
  }
  @Test void writeToPreviouslyBoundCursorAfterNextReturnsFalseMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyOnWriteCursor(this::checkPreviouslyBoundWriteCursorAfterFailedNext));
  }
  private void verifyOnReadCursor(  ThrowingConsumer<PageCursorAction,IOException> testTemplate) throws IOException {
    testTemplate.accept(PageCursor::getByte);
    testTemplate.accept(PageCursor::getInt);
    testTemplate.accept(PageCursor::getLong);
    testTemplate.accept(PageCursor::getShort);
    testTemplate.accept(cursor -> cursor.getByte(0));
    testTemplate.accept(cursor -> cursor.getInt(0));
    testTemplate.accept(cursor -> cursor.getLong(0));
    testTemplate.accept(cursor -> cursor.getShort(0));
  }
  private void verifyOnWriteCursor(  ThrowingConsumer<PageCursorAction,IOException> testTemplate) throws IOException {
    testTemplate.accept(cursor -> cursor.putByte((byte)1));
    testTemplate.accept(cursor -> cursor.putInt(1));
    testTemplate.accept(cursor -> cursor.putLong(1));
    testTemplate.accept(cursor -> cursor.putShort((short)1));
    testTemplate.accept(cursor -> cursor.putByte(0,(byte)1));
    testTemplate.accept(cursor -> cursor.putInt(0,1));
    testTemplate.accept(cursor -> cursor.putLong(0,1));
    testTemplate.accept(cursor -> cursor.putShort(0,(short)1));
    testTemplate.accept(PageCursor::zapPage);
  }
  private void checkUnboundReadCursorAccess(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      action.apply(cursor);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  private void checkUnboundWriteCursorAccess(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      action.apply(cursor);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  private void checkPreviouslyBoundWriteCursorAccess(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK);
      assertTrue(cursor.next());
      action.apply(cursor);
      assertFalse(cursor.checkAndClearBoundsFlag());
      cursor.close();
      action.apply(cursor);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  private void checkReadCursorAfterFailedNext(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      assertFalse(cursor.next());
      action.apply(cursor);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  private void checkPreviouslyBoundReadCursorAfterFailedNext(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
    }
     try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(cursor.next());
      assertFalse(cursor.next());
      action.apply(cursor);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  private void checkWriteCursorAfterFailedNext(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
      assertFalse(cursor.next());
      action.apply(cursor);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  private void checkPreviouslyBoundWriteCursorAfterFailedNext(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
    }
     try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
      assertTrue(cursor.next());
      assertFalse(cursor.next());
      action.apply(cursor);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void tryMappedPagedFileShouldReportMappedFilePresent() throws Exception {
    configureStandardPageCache();
    final File file=file("a");
    try (PagedFile pf=map(file,filePageSize)){
      final Optional<PagedFile> optional=pageCache.getExistingMapping(file);
      assertTrue(optional.isPresent());
      final PagedFile actual=optional.get();
      assertThat(actual,sameInstance(pf));
      actual.close();
    }
   }
  @Test void tryMappedPagedFileShouldReportNonMappedFileNotPresent() throws Exception {
    configureStandardPageCache();
    final Optional<PagedFile> dontExist=pageCache.getExistingMapping(new File("dont_exist"));
    assertFalse(dontExist.isPresent());
  }
  @Test void mustListExistingMappings() throws Exception {
    configureStandardPageCache();
    File f1=existingFile("1");
    File f2=existingFile("2");
    File f3=existingFile("3");
    existingFile("4");
    try (PagedFile pf1=map(f1,filePageSize);PagedFile pf2=map(f2,filePageSize)){
      map(f3,filePageSize).close();
      List<PagedFile> existingMappings=pageCache.listExistingMappings();
      assertThat(existingMappings.size(),is(2));
      assertThat(existingMappings,containsInAnyOrder(pf1,pf2));
    }
   }
  @Test void listExistingMappingsMustNotIncrementPagedFileReferenceCount() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    PagedFile existingMapping;
    try (PagedFile pf=map(file,filePageSize)){
      existingMapping=pageCache.listExistingMappings().get(0);
      try (PageCursor cursor=existingMapping.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
     }
     assertThrows(FileIsNotMappedException.class,() -> existingMapping.io(0,PF_SHARED_WRITE_LOCK).next());
  }
  @Test void listExistingMappingsMustThrowOnClosedPageCache() throws Exception {
    configureStandardPageCache();
    T pc=pageCache;
    pageCache=null;
    pc.close();
    assertThrows(IllegalStateException.class,pc::listExistingMappings);
  }
  @Test void lastPageMustBeAccessibleWithNoGrowSpecified(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertTrue(cursor.next());
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
          assertTrue(cursor.next());
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_READ_LOCK)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(2L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(2L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(3L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(3L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
        }
       }
     }
);
  }
  @Test void lastPageMustBeAccessibleWithNoGrowSpecifiedEvenIfLessThanFilePageSize(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),(recordsPerFilePage * 2) - 1,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertTrue(cursor.next());
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
          assertTrue(cursor.next());
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_READ_LOCK)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(2L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(2L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(3L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(3L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
        }
       }
     }
);
  }
  @Test void firstPageMustBeAccessibleWithNoGrowSpecifiedIfItIsTheOnlyPage(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
        }
       }
     }
);
  }
  @Test void firstPageMustBeAccessibleEvenIfTheFileIsNonEmptyButSmallerThanFilePageSize(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      generateFileWithRecords(file("a"),1,recordSize);
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
          assertTrue(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
        }
       }
     }
);
  }
  @Test void firstPageMustNotBeAccessibleIfFileIsEmptyAndNoGrowSpecified(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next());
        }
       }
     }
);
  }
  @Test void newlyWrittenPagesMustBeAccessibleWithNoGrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      int initialPages=1;
      int pagesToAdd=3;
      generateFileWithRecords(file("a"),recordsPerFilePage * initialPages,recordSize);
      PagedFile pagedFile=map(file("a"),filePageSize);
      try (PageCursor cursor=pagedFile.io(1L,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < pagesToAdd; i++) {
          assertTrue(cursor.next());
          writeRecords(cursor);
        }
      }
       int pagesChecked=0;
      try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
        while (cursor.next()) {
          verifyRecordsMatchExpected(cursor);
          pagesChecked++;
        }
      }
       assertThat(pagesChecked,is(initialPages + pagesToAdd));
      pagesChecked=0;
      try (PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
        while (cursor.next()) {
          verifyRecordsMatchExpected(cursor);
          pagesChecked++;
        }
      }
       assertThat(pagesChecked,is(initialPages + pagesToAdd));
      pagedFile.close();
    }
);
  }
  @Test void readLockImpliesNoGrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      int initialPages=3;
      generateFileWithRecords(file("a"),recordsPerFilePage * initialPages,recordSize);
      int pagesChecked=0;
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0L,PF_SHARED_READ_LOCK)){
        while (cursor.next()) {
          pagesChecked++;
        }
      }
       assertThat(pagesChecked,is(initialPages));
    }
);
  }
  @Test void retryMustResetCursorOffset() throws Exception {
    configureStandardPageCache();
    final PagedFile pagedFile=map(file("a"),filePageSize);
    final AtomicReference<Exception> caughtWriterException=new AtomicReference<>();
    final CountDownLatch startLatch=new CountDownLatch(1);
    final byte expectedByte=(byte)13;
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      if (cursor.next()) {
        cursor.putByte(expectedByte);
      }
    }
     AtomicBoolean end=new AtomicBoolean(false);
    Runnable writer=() -> {
      while (!end.get()) {
        try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
          if (cursor.next()) {
            cursor.setOffset(recordSize);
            cursor.putByte((byte)14);
          }
          startLatch.countDown();
        }
 catch (        IOException e) {
          caughtWriterException.set(e);
          throw new RuntimeException(e);
        }
      }
    }
;
    Future<?> writerFuture=executor.submit(writer);
    startLatch.await();
    long timeout=currentTimeMillis() + SHORT_TIMEOUT_MILLIS;
    int i=0;
    for (; i < 1000 && currentTimeMillis() < timeout; i++) {
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        do {
          assertThat(cursor.getByte(),is(expectedByte));
        }
 while (cursor.shouldRetry() && currentTimeMillis() < timeout);
      }
     }
    end.set(true);
    writerFuture.get();
    assertTrue(i > 1);
    pagedFile.close();
  }
  @Test void nextWithPageIdMustAllowTraversingInReverse(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordCount,recordSize);
      long lastFilePageId=(recordCount / recordsPerFilePage) - 1;
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        for (long currentPageId=lastFilePageId; currentPageId >= 0; currentPageId--) {
          assertTrue(cursor.next(currentPageId),"next( currentPageId = " + currentPageId + " )");
          assertThat(cursor.getCurrentPageId(),is(currentPageId));
          verifyRecordsMatchExpected(cursor);
        }
      }
     }
);
  }
  @Test void nextWithPageIdMustReturnFalseIfPageIdIsBeyondFilePageRangeAndNoGrowSpecified(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize)){
        try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
          assertFalse(cursor.next(2));
          assertTrue(cursor.next(1));
        }
         try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
          assertFalse(cursor.next(2));
          assertTrue(cursor.next(1));
        }
       }
     }
);
  }
  @Test void pagesAddedWithNextWithPageIdMustBeAccessibleWithNoGrowSpecified(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next(2));
        writeRecords(cursor);
        assertTrue(cursor.next(0));
        writeRecords(cursor);
        assertTrue(cursor.next(1));
        writeRecords(cursor);
      }
       try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
        while (cursor.next()) {
          verifyRecordsMatchExpected(cursor);
        }
      }
       try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        while (cursor.next()) {
          verifyRecordsMatchExpected(cursor);
        }
      }
       pagedFile.close();
    }
);
  }
  @Test void writesOfDifferentUnitsMustHaveCorrectEndianness(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),23)){
        try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
          assertTrue(cursor.next());
          byte[] data={42,43,44,45,46};
          cursor.putLong(41);
          cursor.putInt(41);
          cursor.putShort((short)41);
          cursor.putByte((byte)41);
          cursor.putBytes(data);
          cursor.putBytes(3,(byte)47);
        }
         try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
          assertTrue(cursor.next());
          long a=cursor.getLong();
          int b=cursor.getInt();
          short c=cursor.getShort();
          byte[] data=new byte[]{cursor.getByte(),cursor.getByte(),cursor.getByte(),cursor.getByte(),cursor.getByte(),cursor.getByte()};
          byte d=cursor.getByte();
          byte e=cursor.getByte();
          byte f=cursor.getByte();
          cursor.setOffset(0);
          cursor.putLong(1 + a);
          cursor.putInt(1 + b);
          cursor.putShort((short)(1 + c));
          for (          byte g : data) {
            g++;
            cursor.putByte(g);
          }
          cursor.putByte((byte)(1 + d));
          cursor.putByte((byte)(1 + e));
          cursor.putByte((byte)(1 + f));
        }
       }
       ByteBuffer buf=ByteBuffer.allocate(23);
      try (StoreChannel channel=fs.open(file("a"),OpenMode.READ)){
        channel.readAll(buf);
      }
       buf.flip();
      assertThat(buf.getLong(),is(42L));
      assertThat(buf.getInt(),is(42));
      assertThat(buf.getShort(),is((short)42));
      assertThat(buf.get(),is((byte)42));
      assertThat(buf.get(),is((byte)43));
      assertThat(buf.get(),is((byte)44));
      assertThat(buf.get(),is((byte)45));
      assertThat(buf.get(),is((byte)46));
      assertThat(buf.get(),is((byte)47));
      assertThat(buf.get(),is((byte)48));
      assertThat(buf.get(),is((byte)48));
      assertThat(buf.get(),is((byte)48));
    }
);
  }
  @Test void mappingFileSecondTimeWithLesserPageSizeMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile ignore=map(file("a"),filePageSize)){
        assertThrows(IllegalArgumentException.class,() -> map(file("a"),filePageSize - 1));
      }
     }
);
  }
  @Test void mappingFileSecondTimeWithGreaterPageSizeMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile ignore=map(file("a"),filePageSize)){
        assertThrows(IllegalArgumentException.class,() -> map(file("a"),filePageSize + 1));
      }
     }
);
  }
  @Test void allowOpeningMultipleReadAndWriteCursorsPerThread(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File fileA=existingFile("a");
      File fileB=existingFile("b");
      generateFileWithRecords(fileA,1,16);
      generateFileWithRecords(fileB,1,16);
      try (PagedFile pfA=map(fileA,filePageSize);PagedFile pfB=map(fileB,filePageSize);PageCursor a=pfA.io(0,PF_SHARED_READ_LOCK);PageCursor b=pfA.io(0,PF_SHARED_READ_LOCK);PageCursor c=pfA.io(0,PF_SHARED_WRITE_LOCK);PageCursor d=pfA.io(0,PF_SHARED_WRITE_LOCK);PageCursor e=pfB.io(0,PF_SHARED_READ_LOCK);PageCursor f=pfB.io(0,PF_SHARED_READ_LOCK);PageCursor g=pfB.io(0,PF_SHARED_WRITE_LOCK);PageCursor h=pfB.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(a.next());
        assertTrue(b.next());
        assertTrue(c.next());
        assertTrue(d.next());
        assertTrue(e.next());
        assertTrue(f.next());
        assertTrue(g.next());
        assertTrue(h.next());
      }
     }
);
  }
  @Test void mustNotLiveLockIfWeRunOutOfEvictablePages(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      List<PageCursor> cursors=new LinkedList<>();
      try (PagedFile pf=map(existingFile("a"),filePageSize)){
        try {
          assertThrows(IOException.class,() -> {
            for (long i=0; ; i++) {
              PageCursor cursor=pf.io(i,PF_SHARED_WRITE_LOCK);
              cursors.add(cursor);
              assertTrue(cursor.next());
            }
          }
);
        }
  finally {
          for (          PageCursor cursor : cursors) {
            cursor.close();
          }
        }
      }
     }
);
  }
  @Test void writeLocksMustNotBeExclusive(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(existingFile("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        executor.submit(() -> {
          try (PageCursor innerCursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
            assertTrue(innerCursor.next());
          }
           return null;
        }
).get();
      }
     }
);
  }
  @Test void writeLockMustInvalidateInnerReadLock(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(existingFile("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        executor.submit(() -> {
          try (PageCursor innerCursor=pf.io(0,PF_SHARED_READ_LOCK)){
            assertTrue(innerCursor.next());
            assertTrue(innerCursor.shouldRetry());
          }
           return null;
        }
).get();
      }
     }
);
  }
  @Test void writeLockMustInvalidateExistingReadLock(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      BinaryLatch startLatch=new BinaryLatch();
      BinaryLatch continueLatch=new BinaryLatch();
      try (PagedFile pf=map(existingFile("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        assertTrue(cursor.next());
        Future<Object> read=executor.submit(() -> {
          try (PageCursor innerCursor=pf.io(0,PF_SHARED_READ_LOCK)){
            assertTrue(innerCursor.next());
            assertFalse(innerCursor.shouldRetry());
            startLatch.release();
            continueLatch.await();
            assertTrue(innerCursor.shouldRetry());
          }
           return null;
        }
);
        startLatch.await();
        assertTrue(cursor.next(0));
        continueLatch.release();
        read.get();
      }
     }
);
  }
  @Test void writeUnlockMustInvalidateReadLocks(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      BinaryLatch startLatch=new BinaryLatch();
      BinaryLatch continueLatch=new BinaryLatch();
      try (PagedFile pf=map(existingFile("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        Future<Object> read=executor.submit(() -> {
          try (PageCursor innerCursor=pf.io(0,PF_SHARED_READ_LOCK)){
            assertTrue(innerCursor.next());
            assertTrue(innerCursor.shouldRetry());
            startLatch.release();
            continueLatch.await();
            assertTrue(innerCursor.shouldRetry());
          }
           return null;
        }
);
        startLatch.await();
        assertTrue(cursor.next());
        continueLatch.release();
        read.get();
      }
     }
);
  }
  @Test void mustNotFlushCleanPagesWhenEvicting(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final AtomicBoolean observedWrite=new AtomicBoolean();
      FileSystemAbstraction fs=new DelegatingFileSystemAbstraction(this.fs){
        @Override public StoreChannel open(        File fileName,        OpenMode openMode) throws IOException {
          StoreChannel channel=super.open(fileName,openMode);
          return new DelegatingStoreChannel(channel){
            @Override public long write(            ByteBuffer[] srcs,            int offset,            int length) throws IOException {
              observedWrite.set(true);
              throw new IOException("not allowed");
            }
            @Override public void writeAll(            ByteBuffer src,            long position) throws IOException {
              observedWrite.set(true);
              throw new IOException("not allowed");
            }
            @Override public void writeAll(            ByteBuffer src) throws IOException {
              observedWrite.set(true);
              throw new IOException("not allowed");
            }
            @Override public int write(            ByteBuffer src) throws IOException {
              observedWrite.set(true);
              throw new IOException("not allowed");
            }
            @Override public long write(            ByteBuffer[] srcs) throws IOException {
              observedWrite.set(true);
              throw new IOException("not allowed");
            }
          }
;
        }
      }
;
      getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
      generateFileWithRecords(file("a"),recordCount,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        while (cursor.next()) {
          verifyRecordsMatchExpected(cursor);
        }
      }
       assertFalse(observedWrite.get());
    }
);
  }
  @Test void evictionMustFlushPagesToTheRightFiles(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordCount,recordSize);
      int filePageSize2=filePageSize - 3;
      long maxPageIdCursor1=recordCount / recordsPerFilePage;
      File file2=file("b");
      long file2sizeBytes=(maxPageIdCursor1 + 17) * filePageSize2;
      try (OutputStream outputStream=fs.openAsOutputStream(file2,false)){
        for (int i=0; i < file2sizeBytes; i++) {
          outputStream.write('a');
        }
        outputStream.flush();
      }
       try (PagedFile pagedFile1=map(file("a"),filePageSize);PagedFile pagedFile2=map(file2,filePageSize2)){
        long pageId1=0;
        long pageId2=0;
        boolean moreWorkToDo;
        do {
          boolean cursorReady1;
          boolean cursorReady2;
          try (PageCursor cursor=pagedFile1.io(pageId1,PF_SHARED_WRITE_LOCK)){
            cursorReady1=cursor.next() && cursor.getCurrentPageId() < maxPageIdCursor1;
            if (cursorReady1) {
              writeRecords(cursor);
              pageId1++;
            }
          }
           try (PageCursor cursor=pagedFile2.io(pageId2,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
            cursorReady2=cursor.next();
            if (cursorReady2) {
              for (int i=0; i < filePageSize2; i++) {
                cursor.putByte((byte)'b');
              }
              assertFalse(cursor.shouldRetry());
            }
            pageId2++;
          }
           moreWorkToDo=cursorReady1 || cursorReady2;
        }
 while (moreWorkToDo);
      }
       assertThat(fs.getFileSize(file2),is(file2sizeBytes));
      try (InputStream inputStream=fs.openAsInputStream(file2)){
        for (int i=0; i < file2sizeBytes; i++) {
          int b=inputStream.read();
          assertThat(b,is((int)'b'));
        }
        assertThat(inputStream.read(),is(-1));
      }
       try (StoreChannel channel=fs.open(file("a"),OpenMode.READ)){
        ByteBuffer bufB=ByteBuffer.allocate(recordSize);
        for (int i=0; i < recordCount; i++) {
          bufA.clear();
          channel.readAll(bufA);
          bufA.flip();
          bufB.clear();
          generateRecordForId(i,bufB);
          assertThat(bufB.array(),byteArray(bufA.array()));
        }
      }
     }
);
  }
  @Test void tracerMustBeNotifiedAboutPinUnpinFaultAndEvictEventsWhenReading(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      DefaultPageCacheTracer tracer=new DefaultPageCacheTracer();
      DefaultPageCursorTracerSupplier cursorTracerSupplier=getCursorTracerSupplier(tracer);
      getPageCache(fs,maxPages,tracer,cursorTracerSupplier);
      generateFileWithRecords(file("a"),recordCount,recordSize);
      long countedPages=0;
      long countedFaults=0;
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        while (cursor.next()) {
          countedPages++;
          countedFaults++;
        }
        countedPages++;
        for (int i=0; i < 20; i++) {
          assertTrue(cursor.next(1));
        }
        for (int i=0; i < 20; i++) {
          assertTrue(cursor.next(i));
          countedPages++;
        }
      }
       pageCache.reportEvents();
      assertThat("wrong count of pins",tracer.pins(),is(countedPages));
      assertThat("wrong count of unpins",tracer.unpins(),is(countedPages));
      long faults=tracer.faults();
      long bytesRead=tracer.bytesRead();
      assertThat("wrong count of faults",faults,greaterThanOrEqualTo(countedFaults));
      assertThat("wrong number of bytes read",bytesRead,greaterThanOrEqualTo(countedFaults * filePageSize));
      assertThat("wrong count of evictions",tracer.evictions(),both(greaterThanOrEqualTo(countedFaults - maxPages)).and(lessThanOrEqualTo(countedPages + faults)));
    }
);
  }
  @Test void tracerMustBeNotifiedAboutPinUnpinFaultFlushAndEvictionEventsWhenWriting(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      long pagesToGenerate=142;
      DefaultPageCacheTracer tracer=new DefaultPageCacheTracer();
      DefaultPageCursorTracerSupplier tracerSupplier=getCursorTracerSupplier(tracer);
      getPageCache(fs,maxPages,tracer,tracerSupplier);
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        for (long i=0; i < pagesToGenerate; i++) {
          assertTrue(cursor.next());
          assertThat(cursor.getCurrentPageId(),is(i));
          assertTrue(cursor.next(i));
          assertThat(cursor.getCurrentPageId(),is(i));
          writeRecords(cursor);
        }
        assertTrue(cursor.next(0));
        assertTrue(cursor.next(0));
      }
       pageCache.reportEvents();
      assertThat("wrong count of pins",tracer.pins(),is(pagesToGenerate + 1));
      assertThat("wrong count of unpins",tracer.unpins(),is(pagesToGenerate + 1));
      long faults=tracer.faults();
      assertThat("wrong count of faults",faults,greaterThanOrEqualTo(pagesToGenerate));
      assertThat("wrong count of evictions",tracer.evictions(),both(greaterThanOrEqualTo(pagesToGenerate - maxPages)).and(lessThanOrEqualTo(pagesToGenerate + faults)));
      long flushes=tracer.flushes();
      long bytesWritten=tracer.bytesWritten();
      assertThat("wrong count of flushes",flushes,greaterThanOrEqualTo(pagesToGenerate - maxPages));
      assertThat("wrong count of bytes written",bytesWritten,greaterThanOrEqualTo(pagesToGenerate * filePageSize));
    }
);
  }
  @Test void tracerMustBeNotifiedOfReadAndWritePins() throws Exception {
    final AtomicInteger writeCount=new AtomicInteger();
    final AtomicInteger readCount=new AtomicInteger();
    DefaultPageCacheTracer tracer=new DefaultPageCacheTracer();
    DefaultPageCursorTracer pageCursorTracer=new DefaultPageCursorTracer(){
      @Override public PinEvent beginPin(      boolean writeLock,      long filePageId,      PageSwapper swapper){
        (writeLock ? writeCount : readCount).getAndIncrement();
        return super.beginPin(writeLock,filePageId,swapper);
      }
    }
;
    ConfigurablePageCursorTracerSupplier<DefaultPageCursorTracer> cursorTracerSupplier=new ConfigurablePageCursorTracerSupplier<>(pageCursorTracer);
    getPageCache(fs,maxPages,tracer,cursorTracerSupplier);
    generateFileWithRecords(file("a"),recordCount,recordSize);
    int pinsForRead=13;
    int pinsForWrite=42;
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        for (int i=0; i < pinsForRead; i++) {
          assertTrue(cursor.next());
        }
      }
       dirtyManyPages(pagedFile,pinsForWrite);
    }
     pageCache.reportEvents();
    assertThat("wrong read pin count",readCount.get(),is(pinsForRead));
    assertThat("wrong write pin count",writeCount.get(),is(pinsForWrite));
  }
  @Test void lastPageIdOfEmptyFileIsLessThanZero() throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      assertThat(pagedFile.getLastPageId(),lessThan(0L));
    }
   }
  @Test void lastPageIdOfFileWithOneByteIsZero() throws IOException {
    StoreChannel channel=fs.create(file("a"));
    channel.write(ByteBuffer.wrap(new byte[]{1}));
    channel.close();
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      assertThat(pagedFile.getLastPageId(),is(0L));
    }
   }
  @Test void lastPageIdOfFileWithExactlyTwoPagesWorthOfDataIsOne() throws IOException {
    configureStandardPageCache();
    int twoPagesWorthOfRecords=recordsPerFilePage * 2;
    generateFileWithRecords(file("a"),twoPagesWorthOfRecords,recordSize);
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      assertThat(pagedFile.getLastPageId(),is(1L));
    }
   }
  @Test void lastPageIdOfFileWithExactlyTwoPagesAndOneByteWorthOfDataIsTwo() throws IOException {
    configureStandardPageCache();
    int twoPagesWorthOfRecords=recordsPerFilePage * 2;
    generateFileWithRecords(file("a"),twoPagesWorthOfRecords,recordSize);
    OutputStream outputStream=fs.openAsOutputStream(file("a"),true);
    outputStream.write('a');
    outputStream.close();
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      assertThat(pagedFile.getLastPageId(),is(2L));
    }
   }
  @Test void lastPageIdMustNotIncreaseWhenReadingToEndWithReadLock() throws IOException {
    configureStandardPageCache();
    generateFileWithRecords(file("a"),recordCount,recordSize);
    PagedFile pagedFile=map(file("a"),filePageSize);
    long initialLastPageId=pagedFile.getLastPageId();
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      while (cursor.next()) {
      }
    }
     long resultingLastPageId=pagedFile.getLastPageId();
    pagedFile.close();
    assertThat(resultingLastPageId,is(initialLastPageId));
  }
  @Test void lastPageIdMustNotIncreaseWhenReadingToEndWithNoGrowAndWriteLock() throws IOException {
    configureStandardPageCache();
    generateFileWithRecords(file("a"),recordCount,recordSize);
    PagedFile pagedFile=map(file("a"),filePageSize);
    long initialLastPageId=pagedFile.getLastPageId();
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
      while (cursor.next()) {
      }
    }
     long resultingLastPageId=pagedFile.getLastPageId();
    try {
      assertThat(resultingLastPageId,is(initialLastPageId));
    }
  finally {
      pagedFile.close();
    }
  }
  @Test void lastPageIdMustIncreaseWhenScanningPastEndWithWriteLock() throws IOException {
    configureStandardPageCache();
    generateFileWithRecords(file("a"),recordsPerFilePage * 10,recordSize);
    PagedFile pagedFile=map(file("a"),filePageSize);
    assertThat(pagedFile.getLastPageId(),is(9L));
    dirtyManyPages(pagedFile,15);
    try {
      assertThat(pagedFile.getLastPageId(),is(14L));
    }
  finally {
      pagedFile.close();
    }
  }
  @Test void lastPageIdMustIncreaseWhenJumpingPastEndWithWriteLock() throws IOException {
    configureStandardPageCache();
    generateFileWithRecords(file("a"),recordsPerFilePage * 10,recordSize);
    PagedFile pagedFile=map(file("a"),filePageSize);
    assertThat(pagedFile.getLastPageId(),is(9L));
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next(15));
    }
     try {
      assertThat(pagedFile.getLastPageId(),is(15L));
    }
  finally {
      pagedFile.close();
    }
  }
  @Test void lastPageIdFromUnmappedFileMustThrow() throws IOException {
    configureStandardPageCache();
    PagedFile file;
    try (PagedFile pf=map(file("a"),filePageSize,StandardOpenOption.CREATE)){
      file=pf;
    }
     assertThrows(FileIsNotMappedException.class,file::getLastPageId);
  }
  @Test void cursorOffsetMustBeUpdatedReadAndWrite() throws IOException {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        verifyWriteOffsets(cursor);
        cursor.setOffset(0);
        verifyReadOffsets(cursor);
      }
       try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        verifyReadOffsets(cursor);
      }
     }
   }
  private void verifyWriteOffsets(  PageCursor cursor){
    cursor.setOffset(filePageSize / 2);
    cursor.zapPage();
    assertThat(cursor.getOffset(),is(filePageSize / 2));
    cursor.setOffset(0);
    cursor.putLong(1);
    assertThat(cursor.getOffset(),is(8));
    cursor.putInt(1);
    assertThat(cursor.getOffset(),is(12));
    cursor.putShort((short)1);
    assertThat(cursor.getOffset(),is(14));
    cursor.putByte((byte)1);
    assertThat(cursor.getOffset(),is(15));
    cursor.putBytes(new byte[]{1,2,3});
    assertThat(cursor.getOffset(),is(18));
    cursor.putBytes(new byte[]{1,2,3},1,1);
    assertThat(cursor.getOffset(),is(19));
    cursor.putBytes(5,(byte)1);
    assertThat(cursor.getOffset(),is(24));
  }
  private void verifyReadOffsets(  PageCursor cursor){
    assertThat(cursor.getOffset(),is(0));
    cursor.getLong();
    assertThat(cursor.getOffset(),is(8));
    cursor.getInt();
    assertThat(cursor.getOffset(),is(12));
    cursor.getShort();
    assertThat(cursor.getOffset(),is(14));
    cursor.getByte();
    assertThat(cursor.getOffset(),is(15));
    cursor.getBytes(new byte[3]);
    assertThat(cursor.getOffset(),is(18));
    cursor.getBytes(new byte[3],1,1);
    assertThat(cursor.getOffset(),is(19));
    cursor.getBytes(new byte[5]);
    assertThat(cursor.getOffset(),is(24));
    byte[] expectedBytes=new byte[]{0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,2,3,2,1,1,1,1,1};
    byte[] actualBytes=new byte[24];
    cursor.setOffset(0);
    cursor.getBytes(actualBytes);
    assertThat(actualBytes,byteArray(expectedBytes));
  }
  @Test void closeOnPageCacheMustThrowIfFilesAreStillMapped(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile ignore=map(file("a"),filePageSize)){
        assertThrows(IllegalStateException.class,() -> pageCache.close());
      }
     }
);
  }
  @Test void pagedFileIoMustThrowIfFileIsUnmapped(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      closeThisPagedFile(pagedFile);
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        FileIsNotMappedException exception=assertThrows(FileIsNotMappedException.class,cursor::next);
        StringWriter out=new StringWriter();
        exception.printStackTrace(new PrintWriter(out));
        assertThat(out.toString(),containsString("closeThisPagedFile"));
      }
     }
);
  }
  private void closeThisPagedFile(  PagedFile pagedFile) throws IOException {
    pagedFile.close();
  }
  @Test void writeLockedPageCursorNextMustThrowIfFileIsUnmapped(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK);
      closeThisPagedFile(pagedFile);
      FileIsNotMappedException exception=assertThrows(FileIsNotMappedException.class,cursor::next);
      StringWriter out=new StringWriter();
      exception.printStackTrace(new PrintWriter(out));
      assertThat(out.toString(),containsString("closeThisPagedFile"));
    }
);
  }
  @Test void writeLockedPageCursorNextWithIdMustThrowIfFileIsUnmapped(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK);
      pagedFile.close();
      assertThrows(FileIsNotMappedException.class,() -> cursor.next(1));
    }
);
  }
  @Test void readLockedPageCursorNextMustThrowIfFileIsUnmapped(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),1,recordSize);
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK);
      pagedFile.close();
      assertThrows(FileIsNotMappedException.class,cursor::next);
    }
);
  }
  @Test void readLockedPageCursorNextWithIdMustThrowIfFileIsUnmapped(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK);
      pagedFile.close();
      assertThrows(FileIsNotMappedException.class,() -> cursor.next(1));
    }
);
  }
  @Test void writeLockedPageMustBlockFileUnmapping(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK);
      assertTrue(cursor.next());
      Thread unmapper=fork(closePageFile(pagedFile));
      unmapper.join(100);
      cursor.close();
      unmapper.join();
    }
);
  }
  @Test void optimisticReadLockedPageMustNotBlockFileUnmapping(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      generateFileWithRecords(file("a"),1,recordSize);
      configureStandardPageCache();
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK);
      assertTrue(cursor.next());
      fork(closePageFile(pagedFile)).join();
      cursor.close();
    }
);
  }
  @Test void advancingPessimisticReadLockingCursorAfterUnmappingMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK);
      assertTrue(cursor.next());
      fork(closePageFile(pagedFile)).join();
      assertThrows(FileIsNotMappedException.class,cursor::next);
    }
);
  }
  @Test void advancingOptimisticReadLockingCursorAfterUnmappingMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK);
      assertTrue(cursor.next());
      assertTrue(cursor.next());
      assertTrue(cursor.next(0));
      fork(closePageFile(pagedFile)).join();
      assertThrows(FileIsNotMappedException.class,cursor::next);
    }
);
  }
  @Test void readingAndRetryingOnPageWithOptimisticReadLockingAfterUnmappingMustNotThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      PagedFile pagedFile=map(file("a"),filePageSize);
      PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK);
      assertTrue(cursor.next());
      assertTrue(cursor.next());
      assertTrue(cursor.next(0));
      fork(closePageFile(pagedFile)).join();
      pageCache.close();
      pageCache=null;
      cursor.getByte();
      cursor.shouldRetry();
      assertThrows(FileIsNotMappedException.class,cursor::next);
    }
);
  }
  @Test void shouldRetryFromUnboundReadCursorMustNotThrow() throws Exception {
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage,recordSize);
    configureStandardPageCache();
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      assertFalse(cursor.shouldRetry());
    }
   }
  @Test void shouldRetryFromUnboundWriteCursorMustNotThrow() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertFalse(cursor.shouldRetry());
    }
   }
  @Test void shouldRetryFromUnboundLinkedReadCursorMustNotThrow() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(cursor.next());
      try (PageCursor linked=cursor.openLinkedCursor(1)){
        assertFalse(cursor.shouldRetry());
      }
     }
   }
  @Test void shouldRetryFromUnboundLinkedWriteCursorMustNotThrow() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      try (PageCursor linked=cursor.openLinkedCursor(1)){
        assertFalse(cursor.shouldRetry());
      }
     }
   }
  @Test void shouldRetryOnWriteParentOfClosedLinkedCursorMustNotThrow() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      try (PageCursor linked=cursor.openLinkedCursor(1)){
        assertTrue(linked.next());
      }
       cursor.shouldRetry();
    }
   }
  @Test void shouldRetryOnReadParentOfClosedLinkedCursorMustNotThrow() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(cursor.next());
      try (PageCursor linked=cursor.openLinkedCursor(1)){
        assertTrue(linked.next());
      }
       cursor.shouldRetry();
    }
   }
  @Test void shouldRetryOnReadParentOnDirtyPageOfClosedLinkedCursorMustNotThrow() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(reader.next());
      try (PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(writer.next());
      }
       try (PageCursor linked=reader.openLinkedCursor(1)){
        assertTrue(linked.next());
      }
       assertTrue(reader.shouldRetry());
    }
   }
  @Test void pageCursorCloseShouldNotReturnAlreadyClosedLinkedCursorToPool() throws Exception {
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize)){
      PageCursor a=pf.io(0,PF_SHARED_WRITE_LOCK);
      PageCursor b=a.openLinkedCursor(0);
      b.close();
      PageCursor c=a.openLinkedCursor(0);
      PageCursor d=pf.io(0,PF_SHARED_WRITE_LOCK);
      assertNotSame(c,d);
      c.close();
      d.close();
    }
   }
  @Test void pageCursorCloseShouldNotReturnSameObjectToCursorPoolTwice() throws Exception {
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize)){
      PageCursor a=pf.io(0,PF_SHARED_WRITE_LOCK);
      a.close();
      a.close();
      PageCursor b=pf.io(0,PF_SHARED_WRITE_LOCK);
      PageCursor c=pf.io(0,PF_SHARED_WRITE_LOCK);
      assertNotSame(b,c);
      b.close();
      c.close();
    }
   }
  @Test void pageCursorCloseWithClosedLinkedCursorShouldNotReturnSameObjectToCursorPoolTwice() throws Exception {
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    try (PagedFile pf=map(file,filePageSize)){
      PageCursor a=pf.io(0,PF_SHARED_WRITE_LOCK);
      a.openLinkedCursor(0);
      a.openLinkedCursor(0).close();
      a.close();
      PageCursor x=pf.io(0,PF_SHARED_WRITE_LOCK);
      PageCursor y=pf.io(0,PF_SHARED_WRITE_LOCK);
      PageCursor z=pf.io(0,PF_SHARED_WRITE_LOCK);
      assertNotSame(x,y);
      assertNotSame(x,z);
      assertNotSame(y,z);
      x.close();
      y.close();
      z.close();
    }
   }
  @Test void pageCursorCloseMustNotClosePreviouslyLinkedCursorThatGotReused() throws Exception {
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    try (PagedFile pf=map(file,filePageSize)){
      PageCursor a=pf.io(0,PF_SHARED_WRITE_LOCK);
      a.openLinkedCursor(0).close();
      PageCursor x=pf.io(0,PF_SHARED_WRITE_LOCK);
      a.close();
      assertTrue(x.next(1));
      x.close();
    }
   }
private interface PageCursorAction {
    void apply(    PageCursor cursor);
  }
  @Test void getByteBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(PageCursor::getByte));
  }
  @Test void putByteBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(cursor -> cursor.putByte((byte)42)));
  }
  @Test void getShortBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(PageCursor::getShort));
  }
  @Test void putShortBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(cursor -> cursor.putShort((short)42)));
  }
  @Test void getIntBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(PageCursor::getInt));
  }
  @Test void putIntBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(cursor -> cursor.putInt(42)));
  }
  @Test void putLongBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(cursor -> cursor.putLong(42)));
  }
  @Test void getLongBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(PageCursor::getLong));
  }
  @Test void putBytesBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final byte[] bytes=new byte[]{1,2,3};
      verifyPageBounds(cursor -> cursor.putBytes(bytes));
    }
);
  }
  @Test void putBytesRepeatedByteBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> verifyPageBounds(cursor -> cursor.putBytes(3,(byte)1)));
  }
  @Test void getBytesBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final byte[] bytes=new byte[3];
      verifyPageBounds(cursor -> cursor.getBytes(bytes));
    }
);
  }
  @Test void putBytesWithOffsetAndLengthBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final byte[] bytes=new byte[]{1,2,3};
      verifyPageBounds(cursor -> cursor.putBytes(bytes,1,1));
    }
);
  }
  @Test void getBytesWithOffsetAndLengthBeyondPageEndMustThrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final byte[] bytes=new byte[3];
      verifyPageBounds(cursor -> cursor.getBytes(bytes,1,1));
    }
);
  }
  private void verifyPageBounds(  PageCursorAction action) throws IOException {
    configureStandardPageCache();
    generateFileWithRecords(file("a"),1,recordSize);
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      cursor.next();
      assertThrows(IndexOutOfBoundsException.class,() -> {
        for (int i=0; i < 100000; i++) {
          action.apply(cursor);
          if (cursor.checkAndClearBoundsFlag()) {
            throw new IndexOutOfBoundsException();
          }
        }
      }
);
    }
   }
  @Test void shouldRetryMustClearBoundsFlagWhenReturningTrue(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
        PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);
        assertTrue(writer.next());
        assertTrue(reader.next());
        reader.getByte(-1);
        writer.close();
        assertTrue(reader.shouldRetry());
        assertFalse(reader.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void shouldRetryMustNotClearBoundsFlagWhenReturningFalse(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
        PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);
        assertTrue(writer.next());
        writer.close();
        assertTrue(reader.next());
        reader.getByte(-1);
        assertFalse(reader.shouldRetry());
        assertTrue(reader.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void nextThatReturnsTrueMustNotClearBoundsFlagOnReadCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
        PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);
        assertTrue(writer.next());
        assertTrue(reader.next());
        reader.getByte(-1);
        writer.next();
        writer.close();
        assertTrue(reader.next());
        assertTrue(reader.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void nextThatReturnsTrueMustNotClearBoundsFlagOnWriteCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(writer.next());
        writer.getByte(-1);
        assertTrue(writer.next());
        assertTrue(writer.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void nextThatReturnsFalseMustNotClearBoundsFlagOnReadCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
        PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);
        assertTrue(writer.next());
        assertTrue(reader.next());
        reader.getByte(-1);
        writer.close();
        assertFalse(reader.next());
        assertTrue(reader.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void nextThatReturnsFalseMustNotClearBoundsFlagOnWriteCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File file=file("a");
      generateFileWithRecords(file,recordsPerFilePage,recordSize);
      try (PagedFile pf=map(file,filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
        assertTrue(writer.next());
        writer.getByte(-1);
        assertFalse(writer.next());
        assertTrue(writer.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void nextWithPageIdThatReturnsTrueMustNotClearBoundsFlagOnReadCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
        PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);
        assertTrue(writer.next());
        assertTrue(reader.next());
        reader.getByte(-1);
        writer.next(3);
        writer.close();
        assertTrue(reader.next(3));
        assertTrue(reader.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void nextWithPageIdMustNotClearBoundsFlagOnWriteCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(writer.next());
        writer.getByte(-1);
        assertTrue(writer.next(3));
        assertTrue(writer.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void settingOutOfBoundsCursorOffsetMustRaiseBoundsFlag(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),1,recordSize);
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        cursor.setOffset(-1);
        assertTrue(cursor.checkAndClearBoundsFlag());
        assertFalse(cursor.checkAndClearBoundsFlag());
        cursor.setOffset(filePageSize + 1);
        assertTrue(cursor.checkAndClearBoundsFlag());
        assertFalse(cursor.checkAndClearBoundsFlag());
        cursor.setOffset(pageCachePageSize + 1);
        assertTrue(cursor.checkAndClearBoundsFlag());
        assertFalse(cursor.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void manuallyRaisedBoundsFlagMustBeObservable() throws Exception {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor writer=pagedFile.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      writer.raiseOutOfBounds();
      assertTrue(writer.checkAndClearBoundsFlag());
      assertTrue(reader.next());
      reader.raiseOutOfBounds();
      assertTrue(reader.checkAndClearBoundsFlag());
    }
   }
  @Test void pageFaultForWriteMustThrowIfOutOfStorageSpace(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final AtomicInteger writeCounter=new AtomicInteger();
      AtomicBoolean restrictWrites=new AtomicBoolean(true);
      FileSystemAbstraction fs=new DelegatingFileSystemAbstraction(this.fs){
        private List<StoreChannel> channels=new CopyOnWriteArrayList<>();
        @Override public StoreChannel open(        File fileName,        OpenMode openMode) throws IOException {
          StoreChannel channel=new DelegatingStoreChannel(super.open(fileName,openMode)){
            @Override public void writeAll(            ByteBuffer src,            long position) throws IOException {
              if (restrictWrites.get() && writeCounter.incrementAndGet() > 10) {
                throw new IOException("No space left on device");
              }
              super.writeAll(src,position);
            }
          }
;
          channels.add(channel);
          return channel;
        }
        @Override public void close() throws IOException {
          IOUtils.closeAll(channels);
          super.close();
        }
      }
;
      fs.create(file("a")).close();
      getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
      PagedFile pagedFile=map(file("a"),filePageSize);
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        assertThrows(IOException.class,() -> {
          while (cursor.next()) {
          }
        }
);
      }
  finally {
        restrictWrites.set(false);
        pagedFile.close();
        pageCache.close();
        fs.close();
      }
    }
);
  }
  @Test void pageFaultForReadMustThrowIfOutOfStorageSpace(){
    try {
      assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
        final AtomicInteger writeCounter=new AtomicInteger();
        AtomicBoolean restrictWrites=new AtomicBoolean(true);
        FileSystemAbstraction fs=new DelegatingFileSystemAbstraction(this.fs){
          private final List<StoreChannel> channels=new CopyOnWriteArrayList<>();
          @Override public StoreChannel open(          File fileName,          OpenMode openMode) throws IOException {
            StoreChannel channel=new DelegatingStoreChannel(super.open(fileName,openMode)){
              @Override public void writeAll(              ByteBuffer src,              long position) throws IOException {
                if (restrictWrites.get() && writeCounter.incrementAndGet() >= 1) {
                  throw new IOException("No space left on device");
                }
                super.writeAll(src,position);
              }
            }
;
            channels.add(channel);
            return channel;
          }
          @Override public void close() throws IOException {
            IOUtils.closeAll(channels);
            super.close();
          }
        }
;
        getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
        generateFileWithRecords(file("a"),recordCount,recordSize);
        PagedFile pagedFile=map(file("a"),filePageSize);
        try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
          assertTrue(cursor.next());
        }
         try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
          for (; ; ) {
            while (cursor.next()) {
            }
            cursor.rewind();
          }
        }
  finally {
          restrictWrites.set(false);
          pagedFile.close();
          pageCache.close();
          fs.close();
        }
      }
);
    }
 catch (    Exception e) {
      assertThat(e,instanceOf(IOException.class));
    }
  }
  @Test void mustRecoverViaFileCloseFromFullDriveWhenMoreStorageBecomesAvailable(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      final AtomicBoolean hasSpace=new AtomicBoolean();
      FileSystemAbstraction fs=new DelegatingFileSystemAbstraction(this.fs){
        @Override public StoreChannel open(        File fileName,        OpenMode openMode) throws IOException {
          return new DelegatingStoreChannel(super.open(fileName,openMode)){
            @Override public void writeAll(            ByteBuffer src,            long position) throws IOException {
              if (!hasSpace.get()) {
                throw new IOException("No space left on device");
              }
              super.writeAll(src,position);
            }
          }
;
        }
      }
;
      fs.create(file("a")).close();
      getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
      PagedFile pagedFile=map(file("a"),filePageSize);
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        for (; ; ) {
          assertTrue(cursor.next());
          writeRecords(cursor);
        }
      }
 catch (      IOException ignore) {
      }
      hasSpace.set(true);
      pagedFile.close();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
      }
     }
);
  }
  @Test void mustRecoverViaFileFlushFromFullDriveWhenMoreStorageBecomesAvailable() throws Exception {
    final AtomicBoolean hasSpace=new AtomicBoolean();
    final AtomicBoolean hasThrown=new AtomicBoolean();
    FileSystemAbstraction fs=new DelegatingFileSystemAbstraction(this.fs){
      @Override public StoreChannel open(      File fileName,      OpenMode openMode) throws IOException {
        return new DelegatingStoreChannel(super.open(fileName,openMode)){
          @Override public void writeAll(          ByteBuffer src,          long position) throws IOException {
            if (!hasSpace.get()) {
              hasThrown.set(true);
              throw new IOException("No space left on device");
            }
            super.writeAll(src,position);
          }
        }
;
      }
    }
;
    fs.create(file("a")).close();
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    PagedFile pagedFile=map(file("a"),filePageSize);
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      while (!hasThrown.get()) {
        assertTrue(cursor.next());
        writeRecords(cursor);
      }
    }
 catch (    IOException ignore) {
    }
    hasSpace.set(true);
    pagedFile.flushAndForce();
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(cursor.next());
    }
     pagedFile.close();
  }
  @Test void dataFromDifferentFilesMustNotBleedIntoEachOther(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File fileB=existingFile("b");
      int filePageSizeA=pageCachePageSize - 2;
      int filePageSizeB=pageCachePageSize - 6;
      int pagesToWriteA=100;
      int pagesToWriteB=3;
      PagedFile pagedFileA=map(existingFile("a"),filePageSizeA);
      try (PageCursor cursor=pagedFileA.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < pagesToWriteA; i++) {
          assertTrue(cursor.next());
          for (int j=0; j < filePageSizeA; j++) {
            cursor.putByte((byte)42);
          }
        }
      }
       PagedFile pagedFileB=map(fileB,filePageSizeB);
      try (PageCursor cursor=pagedFileB.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < pagesToWriteB; i++) {
          assertTrue(cursor.next());
          cursor.putByte((byte)63);
        }
      }
       pagedFileA.close();
      pagedFileB.close();
      InputStream inputStream=fs.openAsInputStream(fileB);
      assertThat("first page first byte",inputStream.read(),is(63));
      for (int i=0; i < filePageSizeB - 1; i++) {
        assertThat("page 0 byte pos " + i,inputStream.read(),is(0));
      }
      assertThat("second page first byte",inputStream.read(),is(63));
      for (int i=0; i < filePageSizeB - 1; i++) {
        assertThat("page 1 byte pos " + i,inputStream.read(),is(0));
      }
      assertThat("third page first byte",inputStream.read(),is(63));
      for (int i=0; i < filePageSizeB - 1; i++) {
        assertThat("page 2 byte pos " + i,inputStream.read(),is(0));
      }
      assertThat("expect EOF",inputStream.read(),is(-1));
    }
);
  }
  @Test void freshlyCreatedPagesMustContainAllZeros(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      ThreadLocalRandom rng=ThreadLocalRandom.current();
      configureStandardPageCache();
      try (PagedFile pagedFile=map(existingFile("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < 100; i++) {
          assertTrue(cursor.next());
          for (int j=0; j < filePageSize; j++) {
            cursor.putByte((byte)rng.nextInt());
          }
        }
      }
       pageCache.close();
      pageCache=null;
      configureStandardPageCache();
      try (PagedFile pagedFile=map(existingFile("b"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < 100; i++) {
          assertTrue(cursor.next());
          for (int j=0; j < filePageSize; j++) {
            assertThat(cursor.getByte(),is((byte)0));
          }
        }
      }
     }
);
  }
  @Test void optimisticReadLockMustFaultOnRetryIfPageHasBeenEvicted(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      final byte a='a';
      final byte b='b';
      final File fileA=existingFile("a");
      final File fileB=existingFile("b");
      configureStandardPageCache();
      final PagedFile pagedFileA=map(fileA,filePageSize);
      final PagedFile pagedFileB=map(fileB,filePageSize);
      try (PageCursor cursor=pagedFileA.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < maxPages; i++) {
          assertTrue(cursor.next());
          for (int j=0; j < filePageSize; j++) {
            cursor.putByte(a);
          }
        }
      }
       Runnable fillPagedFileB=() -> {
        try (PageCursor cursor=pagedFileB.io(0,PF_SHARED_WRITE_LOCK)){
          for (int i=0; i < maxPages * 30; i++) {
            assertTrue(cursor.next());
            for (int j=0; j < filePageSize; j++) {
              cursor.putByte(b);
            }
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
;
      try (PageCursor cursor=pagedFileA.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next(0));
        assertTrue(cursor.next());
        assertTrue(cursor.next(0));
        for (int i=0; i < filePageSize; i++) {
          assertThat(cursor.getByte(),is(a));
        }
        fork(fillPagedFileB).join();
        if (cursor.shouldRetry()) {
          int expected=a * filePageSize;
          int actual;
          do {
            actual=0;
            for (int i=0; i < filePageSize; i++) {
              actual+=cursor.getByte();
            }
          }
 while (cursor.shouldRetry());
          assertThat(actual,is(expected));
        }
      }
       pagedFileA.close();
      pagedFileB.close();
    }
);
  }
  @Test void pagesMustReturnToFreelistIfSwapInThrows(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordCount,recordSize);
      PagedFile pagedFile=map(file("a"),filePageSize);
      int iterations=maxPages * 2;
      accessPagesWhileInterrupted(pagedFile,PF_SHARED_READ_LOCK,iterations);
      accessPagesWhileInterrupted(pagedFile,PF_SHARED_WRITE_LOCK,iterations);
      Thread.interrupted();
      try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        verifyRecordsMatchExpected(cursor);
      }
       pagedFile.close();
    }
);
  }
  private void accessPagesWhileInterrupted(  PagedFile pagedFile,  int pf_flags,  int iterations) throws IOException {
    try (PageCursor cursor=pagedFile.io(0,pf_flags)){
      for (int i=0; i < iterations; i++) {
        Thread.currentThread().interrupt();
        try {
          cursor.next(0);
        }
 catch (        IOException ignored) {
        }
      }
    }
   }
  @Test void mustSupportUnalignedWordAccesses() throws Exception {
    getPageCache(fs,5,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    int pageSize=pageCache.pageSize();
    ThreadLocalRandom rng=ThreadLocalRandom.current();
    try (PagedFile pagedFile=map(file("a"),pageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      long x=rng.nextLong();
      int limit=pageSize - Long.BYTES;
      for (int i=0; i < limit; i++) {
        x+=i;
        cursor.setOffset(i);
        cursor.putLong(x);
        cursor.setOffset(i);
        long y=cursor.getLong();
        assertFalse(cursor.checkAndClearBoundsFlag(),"Should not have had a page out-of-bounds access!");
        if (x != y) {
          String reason="Failed to read back the value that was written at " + "offset " + toHexString(i);
          assertThat(reason,toHexString(y),is(toHexString(x)));
        }
      }
    }
   }
  @RepeatedTest(50) void mustEvictPagesFromUnmappedFiles(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
       try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < maxPages + 5; i++) {
          assertTrue(cursor.next());
        }
      }
     }
);
  }
  @Test void mustReadZerosFromBeyondEndOfFile(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      StandardRecordFormat recordFormat=new StandardRecordFormat();
      File[] files={file("1"),file("2"),file("3"),file("4"),file("5"),file("6"),file("7"),file("8"),file("9"),file("0"),file("A"),file("B")};
      for (int fileId=0; fileId < files.length; fileId++) {
        File file=files[fileId];
        StoreChannel channel=fs.open(file,OpenMode.READ_WRITE);
        for (int recordId=0; recordId < fileId + 1; recordId++) {
          Record record=recordFormat.createRecord(file,recordId);
          recordFormat.writeRecord(record,channel);
        }
        channel.close();
      }
      getPageCache(fs,2,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
      int pageSize=pageCache.pageSize();
      int fileId=files.length;
      while (fileId-- > 0) {
        File file=files[fileId];
        try (PagedFile pf=map(file,pageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
          int pageCount=0;
          while (cursor.next()) {
            pageCount++;
            recordFormat.assertRecordsWrittenCorrectly(cursor);
          }
          assertThat("pages in file " + file,pageCount,greaterThan(0));
        }
       }
    }
);
  }
  private int nextPowerOf2(  int i){
    return 1 << (32 - Integer.numberOfLeadingZeros(i));
  }
  private PageSwapperFactory factoryCountingSyncDevice(  final AtomicInteger syncDeviceCounter,  final Queue<Integer> expectedCountsInForce){
    SingleFilePageSwapperFactory factory=new SingleFilePageSwapperFactory(){
      @Override public void syncDevice(){
        super.syncDevice();
        syncDeviceCounter.getAndIncrement();
      }
      @Override public PageSwapper createPageSwapper(      File file,      int filePageSize,      PageEvictionCallback onEviction,      boolean createIfNotExist,      boolean noChannelStriping) throws IOException {
        PageSwapper delegate=super.createPageSwapper(file,filePageSize,onEviction,createIfNotExist,noChannelStriping);
        return new DelegatingPageSwapper(delegate){
          @Override public void force() throws IOException {
            super.force();
            assertThat(syncDeviceCounter.get(),is(expectedCountsInForce.poll()));
          }
        }
;
      }
    }
;
    factory.open(fs,Configuration.EMPTY);
    return factory;
  }
  @SafeVarargs private static <E>Queue<E> queue(  E... items){
    Queue<E> queue=new ConcurrentLinkedQueue<>();
    for (    E item : items) {
      queue.offer(item);
    }
    return queue;
  }
  @Test void mustSyncDeviceWhenFlushAndForcingPagedFile(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      AtomicInteger syncDeviceCounter=new AtomicInteger();
      AtomicInteger expectedCountInForce=new AtomicInteger();
      Queue<Integer> expectedCountsInForce=queue(0,1,2);
      PageSwapperFactory factory=factoryCountingSyncDevice(syncDeviceCounter,expectedCountsInForce);
      try (PageCache cache=createPageCache(factory,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL,EmptyVersionContextSupplier.EMPTY);PagedFile p1=cache.map(existingFile("a"),filePageSize);PagedFile p2=cache.map(existingFile("b"),filePageSize)){
        try (PageCursor cursor=p1.io(0,PF_SHARED_WRITE_LOCK)){
          assertTrue(cursor.next());
        }
         try (PageCursor cursor=p2.io(0,PF_SHARED_WRITE_LOCK)){
          assertTrue(cursor.next());
        }
         p1.flushAndForce();
        expectedCountInForce.set(1);
        assertThat(syncDeviceCounter.get(),is(1));
      }
     }
);
  }
  @Test void mustSyncDeviceWhenFlushAndForcingPageCache(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      AtomicInteger syncDeviceCounter=new AtomicInteger();
      AtomicInteger expectedCountInForce=new AtomicInteger();
      Queue<Integer> expectedCountsInForce=queue(0,0,1,2);
      PageSwapperFactory factory=factoryCountingSyncDevice(syncDeviceCounter,expectedCountsInForce);
      try (PageCache cache=createPageCache(factory,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL,EmptyVersionContextSupplier.EMPTY);PagedFile p1=cache.map(existingFile("a"),filePageSize);PagedFile p2=cache.map(existingFile("b"),filePageSize)){
        try (PageCursor cursor=p1.io(0,PF_SHARED_WRITE_LOCK)){
          assertTrue(cursor.next());
        }
         try (PageCursor cursor=p2.io(0,PF_SHARED_WRITE_LOCK)){
          assertTrue(cursor.next());
        }
         cache.flushAndForce();
        expectedCountInForce.set(1);
        assertThat(syncDeviceCounter.get(),is(1));
      }
     }
);
  }
  @Test void mustThrowWhenMappingNonExistingFile(){
    assertThrows(NoSuchFileException.class,() -> {
      configureStandardPageCache();
      map(file("does not exist"),filePageSize);
    }
);
  }
  @Test void mustCreateNonExistingFileWithCreateOption(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("does not exist"),filePageSize,StandardOpenOption.CREATE);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
     }
);
  }
  @Test void mustIgnoreCreateOptionIfFileAlreadyExists(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize,StandardOpenOption.CREATE);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
     }
);
  }
  @Test void mustIgnoreCertainOpenOptions(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize,StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.APPEND,StandardOpenOption.SPARSE);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
      }
     }
);
  }
  @Test void mustThrowOnUnsupportedOpenOptions(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      verifyMappingWithOpenOptionThrows(StandardOpenOption.CREATE_NEW);
      verifyMappingWithOpenOptionThrows(StandardOpenOption.SYNC);
      verifyMappingWithOpenOptionThrows(StandardOpenOption.DSYNC);
      verifyMappingWithOpenOptionThrows(new OpenOption(){
        @Override public String toString(){
          return "NonStandardOpenOption";
        }
      }
);
    }
);
  }
  private void verifyMappingWithOpenOptionThrows(  OpenOption option) throws IOException {
    try {
      map(file("a"),filePageSize,option).close();
      fail("Expected map() to throw when given the OpenOption " + option);
    }
 catch (    IllegalArgumentException|UnsupportedOperationException e) {
    }
  }
  @Test void mappingFileWithTruncateOptionMustTruncateFile(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(10,PF_SHARED_WRITE_LOCK)){
        assertThat(pf.getLastPageId(),lessThan(0L));
        assertTrue(cursor.next());
        cursor.putInt(0xcafebabe);
      }
       try (PagedFile pf=map(file("a"),filePageSize,StandardOpenOption.TRUNCATE_EXISTING);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
        assertThat(pf.getLastPageId(),lessThan(0L));
        assertFalse(cursor.next());
      }
     }
);
  }
  @SuppressWarnings("unused") @Test void mappingAlreadyMappedFileWithTruncateOptionMustThrow() throws Exception {
    configureStandardPageCache();
    try (PagedFile first=map(file("a"),filePageSize)){
      assertThrows(UnsupportedOperationException.class,() -> {
        try (PagedFile second=map(file("a"),filePageSize,StandardOpenOption.TRUNCATE_EXISTING)){
        }
       }
);
    }
   }
  @Test void mustThrowIfFileIsClosedMoreThanItIsMapped() throws Exception {
    configureStandardPageCache();
    PagedFile pf=map(file("a"),filePageSize);
    pf.close();
    assertThrows(IllegalStateException.class,pf::close);
  }
  @Test void fileMappedWithDeleteOnCloseMustNotExistAfterUnmap() throws Exception {
    configureStandardPageCache();
    map(file("a"),filePageSize,DELETE_ON_CLOSE).close();
    assertThrows(NoSuchFileException.class,() -> map(file("a"),filePageSize));
  }
  @Test void fileMappedWithDeleteOnCloseMustNotExistAfterLastUnmap() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    try (PagedFile ignore=map(file,filePageSize)){
      map(file,filePageSize,DELETE_ON_CLOSE).close();
    }
     assertThrows(NoSuchFileException.class,() -> map(file,filePageSize));
  }
  @Test void fileMappedWithDeleteOnCloseShouldNotFlushDirtyPagesOnClose() throws Exception {
    AtomicInteger flushCounter=new AtomicInteger();
    PageSwapperFactory swapperFactory=flushCountingPageSwapperFactory(flushCounter);
    swapperFactory.open(fs,Configuration.EMPTY);
    File file=file("a");
    try (PageCache cache=createPageCache(swapperFactory,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL,EmptyVersionContextSupplier.EMPTY);PagedFile pf=cache.map(file,filePageSize,DELETE_ON_CLOSE);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      writeRecords(cursor);
      assertTrue(cursor.next());
    }
     assertThat(flushCounter.get(),lessThan(recordCount / recordsPerFilePage));
  }
  @Test void mustFlushAllDirtyPagesWhenClosingPagedFileThatIsNotMappedWithDeleteOnClose() throws Exception {
    AtomicInteger flushCounter=new AtomicInteger();
    PageSwapperFactory swapperFactory=flushCountingPageSwapperFactory(flushCounter);
    swapperFactory.open(fs,Configuration.EMPTY);
    File file=file("a");
    try (PageCache cache=createPageCache(swapperFactory,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL,EmptyVersionContextSupplier.EMPTY);PagedFile pf=cache.map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      writeRecords(cursor);
      assertTrue(cursor.next());
    }
     assertThat(flushCounter.get(),is(1));
  }
  private SingleFilePageSwapperFactory flushCountingPageSwapperFactory(  AtomicInteger flushCounter){
    return new SingleFilePageSwapperFactory(){
      @Override public PageSwapper createPageSwapper(      File file,      int filePageSize,      PageEvictionCallback onEviction,      boolean createIfNotExist,      boolean noChannelStriping) throws IOException {
        PageSwapper swapper=super.createPageSwapper(file,filePageSize,onEviction,createIfNotExist,noChannelStriping);
        return new DelegatingPageSwapper(swapper){
          @Override public long write(          long filePageId,          long bufferAddress) throws IOException {
            flushCounter.getAndIncrement();
            return super.write(filePageId,bufferAddress);
          }
          @Override public long write(          long startFilePageId,          long[] bufferAddresses,          int arrayOffset,          int length) throws IOException {
            flushCounter.getAndAdd(length);
            return super.write(startFilePageId,bufferAddresses,arrayOffset,length);
          }
        }
;
      }
    }
;
  }
  @Test void fileMappedWithDeleteOnCloseMustNotLeakDirtyPages(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File file=file("a");
      int iterations=50;
      for (int i=0; i < iterations; i++) {
        ensureExists(file);
        try (PagedFile pf=map(file,filePageSize,DELETE_ON_CLOSE);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
          writeRecords(cursor);
          assertTrue(cursor.next());
        }
       }
    }
);
  }
  @Test void mustNotThrowWhenMappingFileWithDifferentFilePageSizeAndAnyPageSizeIsSpecified() throws Exception {
    configureStandardPageCache();
    try (PagedFile ignore=map(file("a"),filePageSize)){
      map(file("a"),filePageSize + 1,PageCacheOpenOptions.ANY_PAGE_SIZE).close();
    }
   }
  @Test void mustCopyIntoSameSizedWritePageCursor() throws Exception {
    configureStandardPageCache();
    int bytes=200;
    try (PagedFile pf=map(file("a"),32);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      for (int i=0; i < bytes; i++) {
        if ((i & 31) == 0) {
          assertTrue(cursor.next());
        }
        cursor.putByte((byte)i);
      }
    }
     int pageSize=16;
    try (PagedFile pfA=map(file("a"),pageSize);PagedFile pfB=map(existingFile("b"),pageSize);PageCursor cursorA=pfA.io(0,PF_SHARED_READ_LOCK);PageCursor cursorB=pfB.io(0,PF_SHARED_WRITE_LOCK)){
      while (cursorA.next()) {
        assertTrue(cursorB.next());
        int bytesCopied;
        do {
          bytesCopied=cursorA.copyTo(0,cursorB,0,cursorA.getCurrentPageSize());
        }
 while (cursorA.shouldRetry());
        assertThat(bytesCopied,is(pageSize));
      }
    }
     try (PagedFile pf=map(file("b"),32);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      for (int i=0; i < bytes; i++) {
        if ((i & 31) == 0) {
          assertTrue(cursor.next());
        }
        int offset=cursor.getOffset();
        byte b;
        do {
          cursor.setOffset(offset);
          b=cursor.getByte();
        }
 while (cursor.shouldRetry());
        assertThat(b,is((byte)i));
      }
    }
   }
  @Test void mustCopyIntoLargerPageCursor() throws Exception {
    configureStandardPageCache();
    int smallPageSize=16;
    int largePageSize=17;
    try (PagedFile pfA=map(file("a"),smallPageSize);PagedFile pfB=map(existingFile("b"),largePageSize);PageCursor cursorA=pfA.io(0,PF_SHARED_WRITE_LOCK);PageCursor cursorB=pfB.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursorA.next());
      for (int i=0; i < smallPageSize; i++) {
        cursorA.putByte((byte)(i + 1));
      }
      assertTrue(cursorB.next());
      assertThat(cursorA.copyTo(0,cursorB,0,smallPageSize),is(smallPageSize));
      for (int i=0; i < smallPageSize; i++) {
        assertThat(cursorB.getByte(),is((byte)(i + 1)));
      }
      assertThat(cursorB.getByte(),is((byte)0));
    }
   }
  @Test void mustCopyIntoSmallerPageCursor() throws Exception {
    configureStandardPageCache();
    int smallPageSize=16;
    int largePageSize=17;
    try (PagedFile pfA=map(file("a"),largePageSize);PagedFile pfB=map(existingFile("b"),smallPageSize);PageCursor cursorA=pfA.io(0,PF_SHARED_WRITE_LOCK);PageCursor cursorB=pfB.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursorA.next());
      for (int i=0; i < largePageSize; i++) {
        cursorA.putByte((byte)(i + 1));
      }
      assertTrue(cursorB.next());
      assertThat(cursorA.copyTo(0,cursorB,0,largePageSize),is(smallPageSize));
      for (int i=0; i < smallPageSize; i++) {
        assertThat(cursorB.getByte(),is((byte)(i + 1)));
      }
    }
   }
  @Test void mustThrowOnCopyIntoReadPageCursor() throws Exception {
    configureStandardPageCache();
    int pageSize=17;
    try (PagedFile pfA=map(file("a"),pageSize);PagedFile pfB=map(existingFile("b"),pageSize)){
      try (PageCursor cursorA=pfA.io(0,PF_SHARED_WRITE_LOCK);PageCursor cursorB=pfB.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursorA.next());
        assertTrue(cursorB.next());
      }
       try (PageCursor cursorA=pfA.io(0,PF_SHARED_WRITE_LOCK);PageCursor cursorB=pfB.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursorA.next());
        assertTrue(cursorB.next());
        assertThrows(IllegalArgumentException.class,() -> cursorA.copyTo(0,cursorB,0,pageSize));
      }
     }
   }
  @Test void copyToPageCursorMustCheckBounds() throws Exception {
    configureStandardPageCache();
    int pageSize=16;
    try (PagedFile pf=map(file("a"),pageSize);PageCursor cursorA=pf.io(0,PF_SHARED_READ_LOCK);PageCursor cursorB=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursorB.next());
      assertTrue(cursorB.next());
      assertTrue(cursorA.next());
      cursorA.copyTo(-1,cursorB,0,1);
      assertTrue(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
      cursorA.copyTo(0,cursorB,-1,1);
      assertTrue(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
      cursorA.copyTo(pageSize,cursorB,0,1);
      assertTrue(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
      cursorA.copyTo(0,cursorB,pageSize,1);
      assertTrue(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
      assertThat(cursorA.copyTo(1,cursorB,0,pageSize),is(pageSize - 1));
      assertFalse(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
      assertThat(cursorA.copyTo(0,cursorB,1,pageSize),is(pageSize - 1));
      assertFalse(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
      assertThat(cursorA.copyTo(0,cursorB,1,0),is(0));
      assertFalse(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
      cursorA.copyTo(1,cursorB,1,-1);
      assertTrue(cursorA.checkAndClearBoundsFlag());
      assertFalse(cursorB.checkAndClearBoundsFlag());
    }
   }
  @Test void copyToHeapByteBufferFromReadPageCursorMustCheckBounds() throws Exception {
    configureStandardPageCache();
    ByteBuffer buffer=ByteBuffer.allocate(filePageSize);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(cursor.next());
      verifyCopyToBufferBounds(cursor,buffer);
    }
   }
  @Test void copyToDirectByteBufferFromReadPageCursorMustCheckBounds() throws Exception {
    configureStandardPageCache();
    ByteBuffer buffer=ByteBuffer.allocateDirect(filePageSize);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(cursor.next());
      verifyCopyToBufferBounds(cursor,buffer);
    }
   }
  @Test void copyToHeapByteBufferFromWritePageCursorMustCheckBounds() throws Exception {
    configureStandardPageCache();
    ByteBuffer buffer=ByteBuffer.allocate(filePageSize);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      verifyCopyToBufferBounds(cursor,buffer);
    }
   }
  @Test void copyToDirectByteBufferFromWritePageCursorMustCheckBounds() throws Exception {
    configureStandardPageCache();
    ByteBuffer buffer=ByteBuffer.allocateDirect(filePageSize);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      verifyCopyToBufferBounds(cursor,buffer);
    }
   }
  private void verifyCopyToBufferBounds(  PageCursor cursor,  ByteBuffer buffer) throws IOException {
    int copied;
    do {
      buffer.clear();
      copied=cursor.copyTo(0,buffer);
    }
 while (cursor.shouldRetry());
    assertThat(copied,is(filePageSize));
    buffer.clear();
    verifyRecordsMatchExpected(0,0,buffer);
    buffer.clear();
    cursor.copyTo(-1,buffer);
    assertTrue(cursor.checkAndClearBoundsFlag());
    buffer.clear();
    copied=cursor.copyTo(1,buffer);
    assertFalse(cursor.checkAndClearBoundsFlag());
    assertThat(copied,is(filePageSize - 1));
    assertThat(buffer.position(),is(filePageSize - 1));
    assertThat(buffer.remaining(),is(1));
    buffer.clear();
    zapBuffer(buffer);
    do {
      buffer.clear();
      buffer.limit(filePageSize - recordSize);
      copied=cursor.copyTo(0,buffer);
    }
 while (cursor.shouldRetry());
    assertThat(copied,is(filePageSize - recordSize));
    assertThat(buffer.position(),is(filePageSize - recordSize));
    assertThat(buffer.remaining(),is(0));
    buffer.clear();
    buffer.limit(filePageSize - recordSize);
    verifyRecordsMatchExpected(0,0,buffer);
    zapBuffer(buffer);
    do {
      buffer.clear();
      buffer.limit(filePageSize - recordSize);
      copied=cursor.copyTo(recordSize,buffer);
    }
 while (cursor.shouldRetry());
    assertThat(copied,is(filePageSize - recordSize));
    assertThat(buffer.position(),is(filePageSize - recordSize));
    assertThat(buffer.remaining(),is(0));
    buffer.clear();
    buffer.limit(filePageSize - recordSize);
    verifyRecordsMatchExpected(0,recordSize,buffer);
  }
  private void zapBuffer(  ByteBuffer buffer){
    byte zero=(byte)0;
    if (buffer.hasArray()) {
      Arrays.fill(buffer.array(),zero);
    }
 else {
      buffer.clear();
      while (buffer.hasRemaining()) {
        buffer.put(zero);
      }
    }
  }
  @Test void copyToReadOnlyHeapByteBufferMustThrow() throws Exception {
    configureStandardPageCache();
    ByteBuffer buf=ByteBuffer.allocate(filePageSize).asReadOnlyBuffer();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      assertThrows(ReadOnlyBufferException.class,() -> cursor.copyTo(0,buf));
    }
   }
  @Test void copyToReadOnlyDirectByteBufferMustThrow() throws Exception {
    configureStandardPageCache();
    ByteBuffer buf=ByteBuffer.allocateDirect(filePageSize).asReadOnlyBuffer();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      assertThrows(ReadOnlyBufferException.class,() -> cursor.copyTo(0,buf));
    }
   }
  @Test void shiftBytesMustNotRaiseOutOfBoundsOnLengthWithinPageBoundary() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      cursor.shiftBytes(0,filePageSize,0);
      assertFalse(cursor.checkAndClearBoundsFlag());
      cursor.shiftBytes(0,filePageSize - 1,1);
      assertFalse(cursor.checkAndClearBoundsFlag());
      cursor.shiftBytes(1,filePageSize - 1,-1);
      assertFalse(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustRaiseOutOfBoundsOnLengthLargerThanPageSize() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      cursor.shiftBytes(0,filePageSize + 1,0);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustRaiseOutOfBoundsOnNegativeLength() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      cursor.shiftBytes(1,-1,0);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustRaiseOutOfBoundsOnNegativeSource() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      cursor.shiftBytes(-1,10,0);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustRaiseOutOfBoundsOnOverSizedSource() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      cursor.shiftBytes(filePageSize,1,0);
      assertTrue(cursor.checkAndClearBoundsFlag());
      cursor.shiftBytes(filePageSize + 1,0,0);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustRaiseOutOfBoundsOnBufferUnderflow() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      cursor.shiftBytes(0,1,-1);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustRaiseOutOfBoundsOnBufferOverflow() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      cursor.shiftBytes(filePageSize - 1,1,1);
      assertTrue(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustThrowOnReadCursor() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      assertTrue(reader.next());
      assertThrows(IllegalStateException.class,() -> reader.shiftBytes(0,0,0));
    }
   }
  @Test void shiftBytesMustShiftBytesToTheRightOverlapping() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      byte[] bytes=new byte[30];
      for (int i=0; i < bytes.length; i++) {
        bytes[i]=(byte)(i + 1);
      }
      int srcOffset=10;
      cursor.setOffset(srcOffset);
      cursor.putBytes(bytes);
      int shift=5;
      assertZeroes(cursor,0,srcOffset);
      assertZeroes(cursor,srcOffset + bytes.length,filePageSize - srcOffset - bytes.length);
      cursor.shiftBytes(srcOffset,bytes.length,shift);
      assertZeroes(cursor,0,srcOffset);
      assertZeroes(cursor,srcOffset + bytes.length + shift,filePageSize - srcOffset - bytes.length- shift);
      cursor.setOffset(srcOffset);
      for (int i=0; i < shift; i++) {
        assertThat(cursor.getByte(),is((byte)(i + 1)));
      }
      for (int i=0; i < bytes.length; i++) {
        assertThat(cursor.getByte(),is((byte)(i + 1)));
      }
      assertFalse(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustShiftBytesToTheRightNotOverlapping() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      byte[] bytes=new byte[30];
      for (int i=0; i < bytes.length; i++) {
        bytes[i]=(byte)(i + 1);
      }
      int srcOffset=10;
      cursor.setOffset(srcOffset);
      cursor.putBytes(bytes);
      int gap=5;
      int shift=bytes.length + gap;
      assertZeroes(cursor,0,srcOffset);
      assertZeroes(cursor,srcOffset + bytes.length,filePageSize - srcOffset - bytes.length);
      cursor.shiftBytes(srcOffset,bytes.length,shift);
      assertZeroes(cursor,0,srcOffset);
      assertZeroes(cursor,srcOffset + bytes.length + shift,filePageSize - srcOffset - bytes.length- shift);
      cursor.setOffset(srcOffset);
      for (int i=0; i < bytes.length; i++) {
        assertThat(cursor.getByte(),is((byte)(i + 1)));
      }
      assertZeroes(cursor,srcOffset + bytes.length + shift,gap);
      cursor.setOffset(srcOffset + shift);
      for (int i=0; i < bytes.length; i++) {
        assertThat(cursor.getByte(),is((byte)(i + 1)));
      }
      assertFalse(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustShiftBytesToTheLeftOverlapping() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      byte[] bytes=new byte[30];
      for (int i=0; i < bytes.length; i++) {
        bytes[i]=(byte)(i + 1);
      }
      int srcOffset=10;
      cursor.setOffset(srcOffset);
      cursor.putBytes(bytes);
      int shift=-5;
      assertZeroes(cursor,0,srcOffset);
      assertZeroes(cursor,srcOffset + bytes.length,filePageSize - srcOffset - bytes.length);
      cursor.shiftBytes(srcOffset,bytes.length,shift);
      assertZeroes(cursor,0,srcOffset + shift);
      assertZeroes(cursor,srcOffset + bytes.length,filePageSize - srcOffset - bytes.length);
      cursor.setOffset(srcOffset + shift);
      for (int i=0; i < bytes.length; i++) {
        assertThat(cursor.getByte(),is((byte)(i + 1)));
      }
      for (int i=shift; i < 0; i++) {
        assertThat(cursor.getByte(),is((byte)(bytes.length + i + 1)));
      }
      assertFalse(cursor.checkAndClearBoundsFlag());
    }
   }
  @Test void shiftBytesMustShiftBytesToTheLeftNotOverlapping() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      byte[] bytes=new byte[30];
      for (int i=0; i < bytes.length; i++) {
        bytes[i]=(byte)(i + 1);
      }
      int srcOffset=filePageSize - bytes.length - 10;
      cursor.setOffset(srcOffset);
      cursor.putBytes(bytes);
      int gap=5;
      int shift=-bytes.length - gap;
      assertZeroes(cursor,0,srcOffset);
      assertZeroes(cursor,srcOffset + bytes.length,filePageSize - srcOffset - bytes.length);
      cursor.shiftBytes(srcOffset,bytes.length,shift);
      assertZeroes(cursor,0,srcOffset + shift);
      assertZeroes(cursor,srcOffset + bytes.length,filePageSize - srcOffset - bytes.length);
      cursor.setOffset(srcOffset + shift);
      for (int i=0; i < bytes.length; i++) {
        assertThat(cursor.getByte(),is((byte)(i + 1)));
      }
      assertZeroes(cursor,srcOffset + bytes.length + shift,gap);
      cursor.setOffset(srcOffset);
      for (int i=0; i < bytes.length; i++) {
        assertThat(cursor.getByte(),is((byte)(i + 1)));
      }
      assertFalse(cursor.checkAndClearBoundsFlag());
    }
   }
  private void assertZeroes(  PageCursor cursor,  int offset,  int length){
    for (int i=0; i < length; i++) {
      assertThat(cursor.getByte(offset + i),is((byte)0));
    }
  }
  @Test void readCursorsCanOpenLinkedCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor parent=pf.io(0,PF_SHARED_READ_LOCK)){
        PageCursor linked=parent.openLinkedCursor(1);
        assertTrue(parent.next());
        assertTrue(linked.next());
        verifyRecordsMatchExpected(parent);
        verifyRecordsMatchExpected(linked);
      }
     }
);
  }
  @Test void writeCursorsCanOpenLinkedCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File file=file("a");
      try (PagedFile pf=map(file,filePageSize);PageCursor parent=pf.io(0,PF_SHARED_WRITE_LOCK)){
        PageCursor linked=parent.openLinkedCursor(1);
        assertTrue(parent.next());
        assertTrue(linked.next());
        writeRecords(parent);
        writeRecords(linked);
      }
       verifyRecordsInFile(file,recordsPerFilePage * 2);
    }
);
  }
  @Test void closingParentCursorMustCloseLinkedCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize)){
        PageCursor writerParent=pf.io(0,PF_SHARED_WRITE_LOCK);
        PageCursor readerParent=pf.io(0,PF_SHARED_READ_LOCK);
        assertTrue(writerParent.next());
        assertTrue(readerParent.next());
        PageCursor writerLinked=writerParent.openLinkedCursor(1);
        PageCursor readerLinked=readerParent.openLinkedCursor(1);
        assertTrue(writerLinked.next());
        assertTrue(readerLinked.next());
        writerParent.close();
        readerParent.close();
        writerLinked.getByte(0);
        assertTrue(writerLinked.checkAndClearBoundsFlag());
        readerLinked.getByte(0);
        assertTrue(readerLinked.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void writeCursorWithNoGrowCanOpenLinkedCursorWithNoGrow(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor parent=pf.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
        PageCursor linked=parent.openLinkedCursor(1);
        assertTrue(parent.next());
        assertTrue(linked.next());
        verifyRecordsMatchExpected(parent);
        verifyRecordsMatchExpected(linked);
        assertFalse(linked.next());
      }
     }
);
  }
  @Test void openingLinkedCursorMustCloseExistingLinkedCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      File file=file("a");
      try (PagedFile pf=map(file,filePageSize);PageCursor parent=pf.io(0,PF_SHARED_WRITE_LOCK)){
        PageCursor linked=parent.openLinkedCursor(1);
        assertTrue(parent.next());
        assertTrue(linked.next());
        writeRecords(parent);
        writeRecords(linked);
        parent.openLinkedCursor(2);
        linked.putByte(0,(byte)1);
        assertTrue(linked.checkAndClearBoundsFlag());
      }
       try (PagedFile pf=map(file,filePageSize);PageCursor parent=pf.io(0,PF_SHARED_READ_LOCK)){
        PageCursor linked=parent.openLinkedCursor(1);
        assertTrue(parent.next());
        assertTrue(linked.next());
        parent.openLinkedCursor(2);
        linked.getByte(0);
        assertTrue(linked.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void shouldRetryOnParentCursorMustReturnTrueIfLinkedCursorNeedsRetry(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      generateFileWithRecords(file("a"),recordsPerFilePage * 2,recordSize);
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor parentReader=pf.io(0,PF_SHARED_READ_LOCK);PageCursor writer=pf.io(1,PF_SHARED_WRITE_LOCK)){
        PageCursor linkedReader=parentReader.openLinkedCursor(1);
        assertTrue(parentReader.next());
        assertTrue(linkedReader.next());
        assertTrue(writer.next());
        assertTrue(writer.next());
        assertTrue(parentReader.shouldRetry());
        assertFalse(parentReader.shouldRetry());
      }
     }
);
  }
  @Test void checkAndClearBoundsFlagMustCheckAndClearLinkedCursor(){
    assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
      configureStandardPageCache();
      try (PagedFile pf=map(file("a"),filePageSize);PageCursor parent=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(parent.next());
        PageCursor linked=parent.openLinkedCursor(1);
        linked.raiseOutOfBounds();
        assertTrue(parent.checkAndClearBoundsFlag());
        assertFalse(linked.checkAndClearBoundsFlag());
      }
     }
);
  }
  @Test void shouldRetryMustClearBoundsFlagIfLinkedCursorNeedsRetry() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(reader.next());
      try (PageCursor linkedReader=reader.openLinkedCursor(1)){
        assertTrue(linkedReader.next());
        assertTrue(writer.next(1));
        assertTrue(writer.next());
        reader.raiseOutOfBounds();
        assertTrue(reader.shouldRetry());
        assertFalse(reader.checkAndClearBoundsFlag());
      }
     }
   }
  @Test void checkAndClearCursorExceptionMustNotThrowIfNoExceptionIsSet() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      try (PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.checkAndClearCursorException();
      }
       try (PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        cursor.checkAndClearCursorException();
        do {
        }
 while (cursor.shouldRetry());
        cursor.checkAndClearCursorException();
      }
     }
   }
  @Test void checkAndClearCursorExceptionMustThrowIfExceptionIsSet() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      String msg="Boo" + ThreadLocalRandom.current().nextInt();
      try (PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.setCursorException(msg);
        cursor.checkAndClearCursorException();
        fail("checkAndClearError on write cursor should have thrown");
      }
 catch (      CursorException e) {
        assertThat(e.getMessage(),is(msg));
      }
      msg="Boo" + ThreadLocalRandom.current().nextInt();
      try (PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        cursor.setCursorException(msg);
        cursor.checkAndClearCursorException();
        fail("checkAndClearError on read cursor should have thrown");
      }
 catch (      CursorException e) {
        assertThat(e.getMessage(),is(msg));
      }
    }
   }
  @Test void checkAndClearCursorExceptionMustClearExceptionIfSet() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      try (PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.setCursorException("boo");
        try {
          cursor.checkAndClearCursorException();
          fail("checkAndClearError on write cursor should have thrown");
        }
 catch (        CursorException ignore) {
        }
        cursor.checkAndClearCursorException();
      }
       try (PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        cursor.setCursorException("boo");
        try {
          cursor.checkAndClearCursorException();
          fail("checkAndClearError on read cursor should have thrown");
        }
 catch (        CursorException ignore) {
        }
        cursor.checkAndClearCursorException();
      }
     }
   }
  @Test void nextMustClearCursorExceptionIfSet() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      try (PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.setCursorException("boo");
        assertTrue(cursor.next());
        cursor.checkAndClearCursorException();
      }
       try (PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        cursor.setCursorException("boo");
        assertTrue(cursor.next());
        cursor.checkAndClearCursorException();
      }
     }
   }
  @Test void nextWithIdMustClearCursorExceptionIfSet() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      try (PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next(1));
        cursor.setCursorException("boo");
        assertTrue(cursor.next(2));
        cursor.checkAndClearCursorException();
      }
       try (PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next(1));
        cursor.setCursorException("boo");
        assertTrue(cursor.next(2));
        cursor.checkAndClearCursorException();
      }
     }
   }
  @Test void shouldRetryMustClearCursorExceptionIfItReturnsTrue() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(reader.next());
      assertTrue(writer.next(0));
      assertTrue(writer.next());
      reader.setCursorException("boo");
      assertTrue(reader.shouldRetry());
      reader.checkAndClearCursorException();
    }
   }
  @Test void shouldRetryMustNotClearCursorExceptionIfItReturnsFalse() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordCount,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(cursor.next());
      do {
        cursor.setCursorException("boo");
      }
 while (cursor.shouldRetry());
      assertThrows(CursorException.class,cursor::checkAndClearCursorException);
    }
   }
  @Test void shouldRetryMustClearCursorExceptionIfLinkedShouldRetryReturnsTrue() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(reader.next());
      try (PageCursor linkedReader=reader.openLinkedCursor(1)){
        assertTrue(linkedReader.next());
        assertTrue(writer.next(1));
        assertTrue(writer.next());
        reader.setCursorException("boo");
        assertTrue(reader.shouldRetry());
        reader.checkAndClearCursorException();
      }
     }
   }
  @Test void shouldRetryMustClearLinkedCursorExceptionIfItReturnsTrue() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(reader.next());
      try (PageCursor linkedReader=reader.openLinkedCursor(1)){
        assertTrue(linkedReader.next());
        linkedReader.setCursorException("boo");
        assertTrue(writer.next(0));
        assertTrue(reader.shouldRetry());
        linkedReader.checkAndClearCursorException();
        reader.checkAndClearCursorException();
      }
     }
   }
  @Test void shouldRetryMustClearLinkedCursorExceptionIfLinkedShouldRetryReturnsTrue() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(writer.next());
      assertTrue(reader.next());
      try (PageCursor linkedReader=reader.openLinkedCursor(1)){
        assertTrue(linkedReader.next());
        linkedReader.setCursorException("boo");
        assertTrue(writer.next(1));
        assertTrue(reader.shouldRetry());
        linkedReader.checkAndClearCursorException();
        reader.checkAndClearCursorException();
      }
     }
   }
  @Test void shouldRetryMustNotClearCursorExceptionIfBothItAndLinkedShouldRetryReturnsFalse() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordCount,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK);PageCursor linkedReader=reader.openLinkedCursor(1)){
      assertTrue(reader.next());
      assertTrue(linkedReader.next());
      do {
        reader.setCursorException("boo");
      }
 while (reader.shouldRetry());
      assertThrows(CursorException.class,reader::checkAndClearCursorException);
    }
   }
  @Test void shouldRetryMustNotClearLinkedCursorExceptionIfBothItAndLinkedShouldRetryReturnsFalse() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordCount,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK);PageCursor linkedReader=reader.openLinkedCursor(1)){
      assertTrue(reader.next());
      assertTrue(linkedReader.next());
      do {
        linkedReader.setCursorException("boo");
      }
 while (reader.shouldRetry());
      assertThrows(CursorException.class,reader::checkAndClearCursorException);
    }
   }
  @Test void checkAndClearCursorExceptionMustThrowIfLinkedCursorHasErrorSet() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      String msg="Boo" + ThreadLocalRandom.current().nextInt();
      assertTrue(writer.next());
      try (PageCursor linkedWriter=writer.openLinkedCursor(1)){
        assertTrue(linkedWriter.next());
        linkedWriter.setCursorException(msg);
        CursorException exception=assertThrows(CursorException.class,writer::checkAndClearCursorException);
        assertThat(exception.getMessage(),is(msg));
      }
       msg="Boo" + ThreadLocalRandom.current().nextInt();
      assertTrue(reader.next());
      try (PageCursor linkedReader=reader.openLinkedCursor(1)){
        assertTrue(linkedReader.next());
        linkedReader.setCursorException(msg);
        CursorException exception=assertThrows(CursorException.class,reader::checkAndClearCursorException);
        assertThat(exception.getMessage(),is(msg));
      }
     }
   }
  @Test void checkAndClearCursorMustNotThrowIfErrorHasBeenSetButTheCursorHasBeenClosed() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);
      assertTrue(writer.next());
      writer.setCursorException("boo");
      writer.close();
      writer.checkAndClearCursorException();
      PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK);
      assertTrue(reader.next());
      reader.setCursorException("boo");
      reader.close();
      reader.checkAndClearCursorException();
      writer=pf.io(0,PF_SHARED_WRITE_LOCK);
      PageCursor linkedWriter=writer.openLinkedCursor(1);
      assertTrue(linkedWriter.next());
      linkedWriter.setCursorException("boo");
      writer.close();
      linkedWriter.checkAndClearCursorException();
      reader=pf.io(0,PF_SHARED_READ_LOCK);
      PageCursor linkedReader=reader.openLinkedCursor(1);
      assertTrue(linkedReader.next());
      linkedReader.setCursorException("boo");
      reader.close();
      linkedReader.checkAndClearCursorException();
    }
   }
  @Test void openingLinkedCursorOnClosedCursorMustThrow() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);
      assertTrue(writer.next());
      writer.close();
      assertThrows(IllegalStateException.class,() -> writer.openLinkedCursor(1));
      PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK);
      assertTrue(reader.next());
      reader.close();
      assertThrows(IllegalStateException.class,() -> reader.openLinkedCursor(1));
    }
   }
  @Test void settingNullCursorExceptionMustThrow() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      assertThrows(Exception.class,() -> writer.setCursorException(null));
      assertTrue(reader.next());
      assertThrows(Exception.class,() -> reader.setCursorException(null));
    }
   }
  @Test void clearCursorExceptionMustUnsetErrorCondition() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      writer.setCursorException("boo");
      writer.clearCursorException();
      writer.checkAndClearCursorException();
      assertTrue(reader.next());
      reader.setCursorException("boo");
      reader.clearCursorException();
      reader.checkAndClearCursorException();
    }
   }
  @Test void clearCursorExceptionMustUnsetErrorConditionOnLinkedCursor() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor writer=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor reader=pf.io(0,PF_SHARED_READ_LOCK)){
      assertTrue(writer.next());
      PageCursor linkedWriter=writer.openLinkedCursor(1);
      assertTrue(linkedWriter.next());
      linkedWriter.setCursorException("boo");
      writer.clearCursorException();
      writer.checkAndClearCursorException();
      assertTrue(reader.next());
      PageCursor linkedReader=reader.openLinkedCursor(1);
      assertTrue(linkedReader.next());
      linkedReader.setCursorException("boo");
      reader.clearCursorException();
      reader.checkAndClearCursorException();
    }
   }
  @Test void sizeOfEmptyFileMustBeZero() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize)){
      assertThat(pf.fileSize(),is(0L));
    }
   }
  @Test void fileSizeMustIncreaseInPageIncrements() throws Exception {
    configureStandardPageCache();
    long increment=filePageSize;
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.next());
      assertThat(pf.fileSize(),is(increment));
      assertTrue(cursor.next());
      assertThat(pf.fileSize(),is(2 * increment));
    }
   }
  @Test void shouldZeroAllBytesOnClear() throws Exception {
    configureStandardPageCache();
    try (PagedFile pagedFile=map(file("a"),filePageSize)){
      long pageId=0;
      try (PageCursor cursor=pagedFile.io(pageId,PF_SHARED_WRITE_LOCK)){
        ThreadLocalRandom rng=ThreadLocalRandom.current();
        byte[] bytes=new byte[filePageSize];
        rng.nextBytes(bytes);
        assertTrue(cursor.next());
        cursor.putBytes(bytes);
      }
       byte[] allZeros=new byte[filePageSize];
      try (PageCursor cursor=pagedFile.io(pageId,PF_SHARED_WRITE_LOCK)){
        assertTrue(cursor.next());
        cursor.zapPage();
        byte[] read=new byte[filePageSize];
        cursor.getBytes(read);
        assertFalse(cursor.checkAndClearBoundsFlag());
        assertArrayEquals(allZeros,read);
      }
       try (PageCursor cursor=pagedFile.io(pageId,PF_SHARED_READ_LOCK)){
        assertTrue(cursor.next());
        byte[] read=new byte[filePageSize];
        do {
          cursor.getBytes(read);
        }
 while (cursor.shouldRetry());
        assertFalse(cursor.checkAndClearBoundsFlag());
        assertArrayEquals(allZeros,read);
      }
     }
   }
  @Test void isWriteLockingMustBeTrueForCursorOpenedWithSharedWriteLock() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursor.isWriteLocked());
    }
   }
  @Test void isWriteLockingMustBeFalseForCursorOpenedWithSharedReadLock() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
      assertFalse(cursor.isWriteLocked());
    }
   }
  @Test void eagerFlushMustWriteToFileOnUnpin() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    try (PagedFile pf=map(file,filePageSize);PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK | PF_EAGER_FLUSH)){
      assertTrue(cursor.next());
      writeRecords(cursor);
      assertTrue(cursor.next());
      verifyRecordsInFile(file,recordsPerFilePage);
    }
   }
  @Test void noFaultNextReadOnInMemoryPages() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor faulter=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor nofault=pf.io(0,PF_SHARED_READ_LOCK | PF_NO_FAULT)){
      verifyNoFaultAccessToInMemoryPages(faulter,nofault);
    }
   }
  @Test void noFaultNextWriteOnInMemoryPages() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor faulter=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor nofault=pf.io(0,PF_SHARED_WRITE_LOCK | PF_NO_FAULT)){
      verifyNoFaultAccessToInMemoryPages(faulter,nofault);
    }
   }
  @Test void noFaultNextLinkedReadOnInMemoryPages() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor faulter=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor nofault=pf.io(0,PF_SHARED_READ_LOCK | PF_NO_FAULT);PageCursor linkedNoFault=nofault.openLinkedCursor(0)){
      verifyNoFaultAccessToInMemoryPages(faulter,linkedNoFault);
    }
   }
  @Test void noFaultNextLinkedWriteOnInMemoryPages() throws Exception {
    configureStandardPageCache();
    try (PagedFile pf=map(file("a"),filePageSize);PageCursor faulter=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor nofault=pf.io(0,PF_SHARED_WRITE_LOCK | PF_NO_FAULT);PageCursor linkedNoFault=nofault.openLinkedCursor(0)){
      verifyNoFaultAccessToInMemoryPages(faulter,linkedNoFault);
    }
   }
  private void verifyNoFaultAccessToInMemoryPages(  PageCursor faulter,  PageCursor nofault) throws IOException {
    assertTrue(faulter.next());
    assertTrue(nofault.next());
    verifyNoFaultCursorIsInMemory(nofault,0L);
    assertTrue(faulter.next());
    assertTrue(nofault.next(1));
    verifyNoFaultCursorIsInMemory(nofault,1L);
  }
  private void verifyNoFaultCursorIsInMemory(  PageCursor nofault,  long expectedPageId){
    assertThat(nofault.getCurrentPageId(),is(expectedPageId));
    nofault.getByte();
    assertFalse(nofault.checkAndClearBoundsFlag());
    nofault.getByte(0);
    assertFalse(nofault.checkAndClearBoundsFlag());
  }
  @Test void noFaultReadOfPagesNotInMemory() throws Exception {
    DefaultPageCacheTracer cacheTracer=new DefaultPageCacheTracer();
    DefaultPageCursorTracerSupplier cursorTracerSupplier=getCursorTracerSupplier(cacheTracer);
    getPageCache(fs,maxPages,cacheTracer,cursorTracerSupplier);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor nofault=pf.io(0,PF_SHARED_READ_LOCK | PF_NO_FAULT)){
      verifyNoFaultAccessToPagesNotInMemory(cacheTracer,cursorTracerSupplier,nofault);
    }
   }
  private DefaultPageCursorTracerSupplier getCursorTracerSupplier(  DefaultPageCacheTracer cacheTracer){
    DefaultPageCursorTracerSupplier cursorTracerSupplier=DefaultPageCursorTracerSupplier.INSTANCE;
    PageCursorTracer cursorTracer=cursorTracerSupplier.get();
    cursorTracer.init(new DefaultPageCacheTracer());
    cursorTracer.reportEvents();
    cursorTracer.init(cacheTracer);
    return cursorTracerSupplier;
  }
  @Test void noFaultWriteOnPagesNotInMemory() throws Exception {
    DefaultPageCacheTracer cacheTracer=new DefaultPageCacheTracer();
    DefaultPageCursorTracerSupplier cursorTracerSupplier=getCursorTracerSupplier(cacheTracer);
    getPageCache(fs,maxPages,cacheTracer,cursorTracerSupplier);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor nofault=pf.io(0,PF_SHARED_WRITE_LOCK | PF_NO_FAULT)){
      verifyNoFaultAccessToPagesNotInMemory(cacheTracer,cursorTracerSupplier,nofault);
      verifyNoFaultWriteIsOutOfBounds(nofault);
    }
   }
  @Test void noFaultLinkedReadOfPagesNotInMemory() throws Exception {
    DefaultPageCacheTracer cacheTracer=new DefaultPageCacheTracer();
    DefaultPageCursorTracerSupplier cursorTracerSupplier=getCursorTracerSupplier(cacheTracer);
    getPageCache(fs,maxPages,cacheTracer,cursorTracerSupplier);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor nofault=pf.io(0,PF_SHARED_READ_LOCK | PF_NO_FAULT);PageCursor linkedNoFault=nofault.openLinkedCursor(0)){
      verifyNoFaultAccessToPagesNotInMemory(cacheTracer,cursorTracerSupplier,linkedNoFault);
    }
   }
  @Test void noFaultLinkedWriteOnPagesNotInMemory() throws Exception {
    DefaultPageCacheTracer cacheTracer=new DefaultPageCacheTracer();
    DefaultPageCursorTracerSupplier cursorTracerSupplier=getCursorTracerSupplier(cacheTracer);
    getPageCache(fs,maxPages,cacheTracer,cursorTracerSupplier);
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 2,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor nofault=pf.io(0,PF_SHARED_WRITE_LOCK | PF_NO_FAULT);PageCursor linkedNoFault=nofault.openLinkedCursor(0)){
      verifyNoFaultAccessToPagesNotInMemory(cacheTracer,cursorTracerSupplier,linkedNoFault);
      verifyNoFaultWriteIsOutOfBounds(linkedNoFault);
    }
   }
  private void verifyNoFaultAccessToPagesNotInMemory(  DefaultPageCacheTracer cacheTracer,  DefaultPageCursorTracerSupplier cursorTracerSupplier,  PageCursor nofault) throws IOException {
    assertTrue(nofault.next());
    verifyNoFaultReadIsNotInMemory(nofault);
    assertTrue(nofault.next());
    verifyNoFaultReadIsNotInMemory(nofault);
    assertFalse(nofault.next());
    assertTrue(nofault.next(0));
    verifyNoFaultReadIsNotInMemory(nofault);
    assertFalse(nofault.next(2));
    cursorTracerSupplier.get().reportEvents();
    assertThat(cacheTracer.faults(),is(0L));
  }
  private void verifyNoFaultReadIsNotInMemory(  PageCursor nofault){
    assertThat(nofault.getCurrentPageId(),is(PageCursor.UNBOUND_PAGE_ID));
    nofault.getByte();
    assertTrue(nofault.checkAndClearBoundsFlag());
    nofault.getByte(0);
    assertTrue(nofault.checkAndClearBoundsFlag());
  }
  private void verifyNoFaultWriteIsOutOfBounds(  PageCursor nofault) throws IOException {
    assertTrue(nofault.next(0));
    assertThat(nofault.getCurrentPageId(),is(PageCursor.UNBOUND_PAGE_ID));
    nofault.putByte((byte)1);
    assertTrue(nofault.checkAndClearBoundsFlag());
    nofault.putByte(0,(byte)1);
    assertTrue(nofault.checkAndClearBoundsFlag());
  }
  @Test void noFaultNextReadMustStrideForwardMonotonically() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    generateFileWithRecords(file,recordsPerFilePage * 6,recordSize);
    try (PagedFile pf=map(file,filePageSize);PageCursor faulter=pf.io(0,PF_SHARED_READ_LOCK);PageCursor nofault=pf.io(0,PF_SHARED_READ_LOCK | PF_NO_FAULT)){
      assertTrue(faulter.next(1));
      assertTrue(faulter.next(3));
      assertTrue(faulter.next(5));
      assertTrue(nofault.next());
      verifyNoFaultReadIsNotInMemory(nofault);
      assertTrue(nofault.next());
      verifyNoFaultCursorIsInMemory(nofault,1);
      assertTrue(nofault.next());
      verifyNoFaultReadIsNotInMemory(nofault);
      assertTrue(nofault.next());
      verifyNoFaultCursorIsInMemory(nofault,3);
      assertTrue(nofault.next());
      verifyNoFaultReadIsNotInMemory(nofault);
      assertTrue(nofault.next());
      verifyNoFaultCursorIsInMemory(nofault,5);
      assertFalse(nofault.next());
    }
   }
  @Test void noFaultReadCursorMustCopeWithPageEviction() throws Exception {
    configureStandardPageCache();
    File file=file("a");
    try (PagedFile pf=map(file,filePageSize);PageCursor faulter=pf.io(0,PF_SHARED_WRITE_LOCK);PageCursor nofault=pf.io(0,PF_SHARED_READ_LOCK | PF_NO_FAULT)){
      assertTrue(faulter.next());
      assertTrue(faulter.next());
      assertTrue(nofault.next());
      verifyNoFaultCursorIsInMemory(nofault,0);
      PageCursor[] writerArray=new PageCursor[maxPages - 1];
      for (int i=0; i < writerArray.length; i++) {
        writerArray[i]=pf.io(2 + i,PF_SHARED_WRITE_LOCK);
        assertTrue(writerArray[i].next());
      }
      for (      PageCursor writer : writerArray) {
        writer.close();
      }
      assertTrue(nofault.shouldRetry());
      verifyNoFaultReadIsNotInMemory(nofault);
    }
   }
}
