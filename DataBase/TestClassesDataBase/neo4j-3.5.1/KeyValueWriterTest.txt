public class KeyValueWriterTest {
  private static final int ENTRIES_PER_PAGE=4 * 1024 / 16;
  @SuppressWarnings("unchecked") private StubCollector collector=new StubCollector(ENTRIES_PER_PAGE);
  private final StubWriter stub=new StubWriter();
  private KeyValueWriter writer=new KeyValueWriter(collector,stub);
  private final BigEndianByteArrayBuffer key=new BigEndianByteArrayBuffer(new byte[8]);
  private final BigEndianByteArrayBuffer value=new BigEndianByteArrayBuffer(new byte[8]);
  @After public void closeWriter() throws IOException {
    writer.close();
  }
  @Test public void shouldAcceptNoHeadersAndNoData() throws Exception {
    value.putByte(0,(byte)0x7F);
    value.putByte(7,(byte)0x7F);
    assertTrue("format specifier",writer.writeHeader(key,value));
    assertTrue("end-of-header marker",writer.writeHeader(key,value));
    assertTrue("end marker + number of data items",writer.writeHeader(key,value));
    stub.assertData(new byte[]{0x00,0,0,0,0,0,0,0x00,0x7F,0,0,0,0,0,0,0x7F,0x00,0,0,0,0,0,0,0x00,0x00,0,0,0,0,0,0,0x00,0x00,0,0,0,0,0,0,0x00,0x00,0,0,0,0,0,0,0x00});
  }
  @Test public void shouldRequireNonZeroFormatSpecifier() throws Exception {
    assertFalse("format-specifier",writer.writeHeader(key,value));
  }
  @Test public void shouldRejectInvalidHeaderKeyWhenAssertionsAreEnabled() throws Exception {
    key.putByte(3,(byte)1);
    value.putByte(0,(byte)0x7F);
    value.putByte(7,(byte)0x7F);
    try {
      writer.writeHeader(key,value);
    }
 catch (    AssertionError e) {
      assertEquals("key should have been cleared by previous call",e.getMessage());
    }
  }
  @Test public void shouldRejectInvalidDataKey() throws Exception {
    value.putByte(0,(byte)0x7F);
    value.putByte(7,(byte)0x7F);
    writer.writeHeader(key,value);
    writer.writeHeader(key,value);
    try {
      writer.writeData(key,value);
      fail("expected exception");
    }
 catch (    IllegalArgumentException e) {
      assertEquals("All-zero keys are not allowed.",e.getMessage());
    }
  }
  @Test public void shouldRejectDataBeforeHeaders() throws Exception {
    key.putByte(2,(byte)0x77);
    try {
      writer.writeData(key,value);
      fail("expected exception");
    }
 catch (    IllegalStateException e) {
      assertEquals("Cannot write data when expecting format specifier.",e.getMessage());
    }
  }
  @Test public void shouldRejectDataAfterInsufficientHeaders() throws Exception {
    value.fill((byte)0xFF);
    assertTrue(writer.writeHeader(key,value));
    key.putByte(2,(byte)0x77);
    try {
      writer.writeData(key,value);
      fail("expected exception");
    }
 catch (    IllegalStateException e) {
      assertEquals("Cannot write data when expecting header.",e.getMessage());
    }
  }
  @Test public void shouldNotOpenStoreFileIfWritingHasNotCompleted() throws Exception {
    for (int i=0; i <= 10; i++) {
      String[] headers;
switch (i) {
case 0:
case 1:
case 8:
case 9:
case 10:
        headers=new String[0];
      break;
case 2:
    headers=new String[]{"foo"};
  break;
default :
headers=new String[]{"foo","bar"};
break;
}
resetWriter(headers);
for (int field=1; field <= i; field++) {
switch (field) {
case 3:
if (i >= 8) {
writer.writeHeader(key,value);
}
case 2:
if (i >= 8) {
break;
}
case 1:
value.putByte(0,(byte)0x7F);
value.putByte(7,(byte)0x7F);
writer.writeHeader(key,value);
break;
default :
if ((i < 8) || (field > 8)) {
key.putByte(key.size() - 1,(byte)field);
writer.writeData(key,value);
}
}
}
try {
writer.openStoreFile();
fail("expected exception");
}
 catch (IllegalStateException e) {
assertTrue(e.getMessage().startsWith("Cannot open store file when "));
}
}
}
private void resetWriter(String... header){
collector=new StubCollector(ENTRIES_PER_PAGE,header);
writer=new KeyValueWriter(collector,stub);
}
private static class StubWriter extends KeyValueWriter.Writer {
IOException next;
ByteArrayOutputStream data=new ByteArrayOutputStream();
@Override void write(byte[] data) throws IOException {
io();
this.data.write(data);
}
@Override KeyValueStoreFile open(Metadata metadata,int keySize,int valueSize){
return null;
}
@Override void close() throws IOException {
io();
}
public void assertData(byte... expected){
assertArrayEquals(expected,this.data.toByteArray());
}
private void io() throws IOException {
try {
if (next != null) {
throw next;
}
}
  finally {
next=null;
}
}
}
}
