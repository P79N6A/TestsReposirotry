public class CountsOracle {
public static class Node {
    private final long[] labels;
    private Node(    long[] labels){
      this.labels=labels;
    }
  }
  private final CountsRecordState state=new CountsRecordState();
  public Node node(  long... labels){
    state.addNode(labels);
    return new Node(labels);
  }
  public void relationship(  Node start,  int type,  Node end){
    state.addRelationship(start.labels,type,end.labels);
  }
  public void indexUpdatesAndSize(  long indexId,  long updates,  long size){
    state.replaceIndexUpdateAndSize(indexId,updates,size);
  }
  public void indexSampling(  long indexId,  long unique,  long size){
    state.replaceIndexSample(indexId,unique,size);
  }
  public void update(  CountsTracker target,  long txId){
    try (CountsAccessor.Updater updater=target.apply(txId).get();CountsAccessor.IndexStatsUpdater stats=target.updateIndexCounts()){
      state.accept(new CountsAccessor.Initializer(updater,stats));
    }
   }
  public void update(  CountsOracle target){
    state.accept(new CountsAccessor.Initializer(target.state,target.state));
  }
  public <Tracker extends CountsVisitor.Visitable & CountsAccessor>void verify(  final Tracker tracker){
    CountsRecordState seenState=new CountsRecordState();
    final CountsAccessor.Initializer initializer=new CountsAccessor.Initializer(seenState,seenState);
    List<CountsRecordState.Difference> differences=state.verify(verifier -> tracker.accept(CountsVisitor.Adapter.multiplex(initializer,verifier)));
    seenState.accept(new CountsVisitor(){
      @Override public void visitNodeCount(      int labelId,      long count){
        long expected=tracker.nodeCount(labelId,newDoubleLongRegister()).readSecond();
        assertEquals("Should be able to read visited state.",expected,count);
      }
      @Override public void visitRelationshipCount(      int startLabelId,      int typeId,      int endLabelId,      long count){
        long expected=tracker.relationshipCount(startLabelId,typeId,endLabelId,newDoubleLongRegister()).readSecond();
        assertEquals("Should be able to read visited state.",expected,count);
      }
      @Override public void visitIndexStatistics(      long indexId,      long updates,      long size){
        Register.DoubleLongRegister output=tracker.indexUpdatesAndSize(indexId,newDoubleLongRegister());
        assertEquals("Should be able to read visited state.",output.readFirst(),updates);
        assertEquals("Should be able to read visited state.",output.readSecond(),size);
      }
      @Override public void visitIndexSample(      long indexId,      long unique,      long size){
        Register.DoubleLongRegister output=tracker.indexSample(indexId,newDoubleLongRegister());
        assertEquals("Should be able to read visited state.",output.readFirst(),unique);
        assertEquals("Should be able to read visited state.",output.readSecond(),size);
      }
    }
);
    if (!differences.isEmpty()) {
      StringBuilder errors=new StringBuilder().append("Counts differ in ").append(differences.size()).append(" places...");
      for (      CountsRecordState.Difference difference : differences) {
        errors.append("\n\t").append(difference);
      }
      throw new AssertionError(errors.toString());
    }
  }
}
