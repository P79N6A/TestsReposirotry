@ExtendWith(RandomExtension.class) class FreeListIdProviderTest {
  private static final int PAGE_SIZE=128;
  private static final long GENERATION_ONE=GenerationSafePointer.MIN_GENERATION;
  private static final long GENERATION_TWO=GENERATION_ONE + 1;
  private static final long GENERATION_THREE=GENERATION_TWO + 1;
  private static final long GENERATION_FOUR=GENERATION_THREE + 1;
  private static final long BASE_ID=5;
  private PageAwareByteArrayCursor cursor;
  private final PagedFile pagedFile=mock(PagedFile.class);
  private final FreelistPageMonitor monitor=new FreelistPageMonitor();
  private final FreeListIdProvider freelist=new FreeListIdProvider(pagedFile,PAGE_SIZE,BASE_ID,monitor);
  @Inject private RandomRule random;
  @BeforeEach void setUpPagedFile() throws IOException {
    cursor=new PageAwareByteArrayCursor(PAGE_SIZE);
    when(pagedFile.io(anyLong(),anyInt())).thenAnswer(invocation -> cursor.duplicate(invocation.getArgument(0)));
    freelist.initialize(BASE_ID + 1,BASE_ID + 1,BASE_ID + 1,0,0);
  }
  @Test void shouldReleaseAndAcquireId() throws Exception {
    long releasedId=11;
    fillPageWithRandomBytes(releasedId);
    freelist.releaseId(GENERATION_ONE,GENERATION_TWO,releasedId);
    long acquiredId=freelist.acquireNewId(GENERATION_TWO,GENERATION_THREE);
    assertEquals(releasedId,acquiredId);
    cursor.next(acquiredId);
    assertEmpty(cursor);
  }
  @Test void shouldReleaseAndAcquireIdsFromMultiplePages() throws Exception {
    int entries=freelist.entriesPerPage() + freelist.entriesPerPage() / 2;
    long baseId=101;
    for (int i=0; i < entries; i++) {
      freelist.releaseId(GENERATION_ONE,GENERATION_TWO,baseId + i);
    }
    for (int i=0; i < entries; i++) {
      long acquiredId=freelist.acquireNewId(GENERATION_TWO,GENERATION_THREE);
      assertEquals(baseId + i,acquiredId);
    }
  }
  @Test void shouldPutFreedFreeListPagesIntoFreeListAsWell() throws Exception {
    long prevId;
    long acquiredId=BASE_ID + 1;
    long freelistPageId=BASE_ID + 1;
    MutableLongSet released=new LongHashSet();
    do {
      prevId=acquiredId;
      acquiredId=freelist.acquireNewId(GENERATION_ONE,GENERATION_TWO);
      freelist.releaseId(GENERATION_ONE,GENERATION_TWO,acquiredId);
      released.add(acquiredId);
    }
 while (acquiredId - prevId == 1);
    while (!released.isEmpty()) {
      long reAcquiredId=freelist.acquireNewId(GENERATION_TWO,GENERATION_THREE);
      released.remove(reAcquiredId);
    }
    assertEquals(freelistPageId,freelist.acquireNewId(GENERATION_THREE,GENERATION_FOUR));
  }
  @Test void shouldStayBoundUnderStress() throws Exception {
    MutableLongSet acquired=new LongHashSet();
    List<Long> acquiredList=new ArrayList<>();
    long stableGeneration=GenerationSafePointer.MIN_GENERATION;
    long unstableGeneration=stableGeneration + 1;
    int iterations=100;
    for (int i=0; i < iterations; i++) {
      for (int j=0; j < 10; j++) {
        if (random.nextBoolean()) {
          int count=random.intBetween(5,10);
          for (int k=0; k < count; k++) {
            long acquiredId=freelist.acquireNewId(stableGeneration,unstableGeneration);
            assertTrue(acquired.add(acquiredId));
            acquiredList.add(acquiredId);
          }
        }
 else {
          int count=random.intBetween(5,20);
          for (int k=0; k < count && !acquired.isEmpty(); k++) {
            long id=acquiredList.remove(random.nextInt(acquiredList.size()));
            assertTrue(acquired.remove(id));
            freelist.releaseId(stableGeneration,unstableGeneration,id);
          }
        }
      }
      for (      long id : acquiredList) {
        freelist.releaseId(stableGeneration,unstableGeneration,id);
      }
      acquiredList.clear();
      acquired.clear();
      stableGeneration=unstableGeneration;
      unstableGeneration++;
    }
    assertTrue(freelist.lastId() < 200,String.valueOf(freelist.lastId()));
  }
  @Test void shouldVisitUnacquiredIds() throws Exception {
    MutableLongSet expected=new LongHashSet();
    for (int i=0; i < 100; i++) {
      expected.add(freelist.acquireNewId(GENERATION_ONE,GENERATION_TWO));
    }
    expected.forEach(id -> {
      try {
        freelist.releaseId(GENERATION_ONE,GENERATION_TWO,id);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
);
    for (int i=0; i < 10; i++) {
      long acquiredId=freelist.acquireNewId(GENERATION_TWO,GENERATION_THREE);
      assertTrue(expected.remove(acquiredId));
    }
    freelist.visitUnacquiredIds(unacquiredId -> assertTrue(expected.remove(unacquiredId)),GENERATION_THREE);
    assertTrue(expected.isEmpty());
  }
  @Test void shouldVisitFreelistPageIds() throws Exception {
    MutableLongSet expected=new LongHashSet();
    expected.add(BASE_ID + 1);
    monitor.set(new Monitor(){
      @Override public void acquiredFreelistPageId(      long freelistPageId){
        expected.add(freelistPageId);
      }
    }
);
    for (int i=0; i < 100; i++) {
      long id=freelist.acquireNewId(GENERATION_ONE,GENERATION_TWO);
      freelist.releaseId(GENERATION_ONE,GENERATION_TWO,id);
    }
    assertTrue(expected.size() > 0);
    freelist.visitFreelistPageIds(id -> assertTrue(expected.remove(id)));
    assertTrue(expected.isEmpty());
  }
  private void fillPageWithRandomBytes(  long releasedId){
    cursor.next(releasedId);
    byte[] crapData=new byte[PAGE_SIZE];
    ThreadLocalRandom.current().nextBytes(crapData);
    cursor.putBytes(crapData);
  }
  private static void assertEmpty(  PageCursor cursor){
    byte[] data=new byte[PAGE_SIZE];
    cursor.getBytes(data);
    for (    byte b : data) {
      assertEquals(0,b);
    }
  }
private static class FreelistPageMonitor implements Monitor {
    private Monitor actual=NO_MONITOR;
    void set(    Monitor actual){
      this.actual=actual;
    }
    @Override public void acquiredFreelistPageId(    long freelistPageId){
      actual.acquiredFreelistPageId(freelistPageId);
    }
    @Override public void releasedFreelistPageId(    long freelistPageId){
      actual.releasedFreelistPageId(freelistPageId);
    }
  }
}
