public class DefaultTransactionTracerTest {
  private final FakeClock clock=Clocks.fakeClock();
  private final OnDemandJobScheduler jobScheduler=new OnDemandJobScheduler();
  private final Monitor monitor=mock(Monitor.class);
  @Test public void shouldComputeStartEndAndTotalTimeForLogRotation(){
    DefaultTransactionTracer tracer=new DefaultTransactionTracer(clock,monitor,jobScheduler);
    triggerEvent(tracer,20);
    assertEquals(1,tracer.numberOfLogRotationEvents());
    assertEquals(20,tracer.logRotationAccumulatedTotalTimeMillis());
    verify(monitor,times(1)).lastLogRotationEventDuration(20L);
    triggerEvent(tracer,30);
    assertEquals(2,tracer.numberOfLogRotationEvents());
    assertEquals(50,tracer.logRotationAccumulatedTotalTimeMillis());
    verify(monitor,times(1)).lastLogRotationEventDuration(30L);
  }
  @Test public void shouldReturnMinusOneIfNoDataIsAvailableForLogRotation(){
    DefaultTransactionTracer tracer=new DefaultTransactionTracer(clock,monitor,jobScheduler);
    jobScheduler.runJob();
    assertEquals(0,tracer.numberOfLogRotationEvents());
    assertEquals(0,tracer.logRotationAccumulatedTotalTimeMillis());
    verifyZeroInteractions(monitor);
  }
  private void triggerEvent(  DefaultTransactionTracer tracer,  int eventDuration){
    try (TransactionEvent txEvent=tracer.beginTransaction()){
      try (CommitEvent commitEvent=txEvent.beginCommitEvent()){
        try (LogAppendEvent logAppendEvent=commitEvent.beginLogAppend()){
          clock.forward(ThreadLocalRandom.current().nextLong(200),TimeUnit.MILLISECONDS);
          try (LogRotateEvent event=logAppendEvent.beginLogRotate()){
            clock.forward(eventDuration,TimeUnit.MILLISECONDS);
          }
         }
       }
     }
     jobScheduler.runJob();
  }
}
