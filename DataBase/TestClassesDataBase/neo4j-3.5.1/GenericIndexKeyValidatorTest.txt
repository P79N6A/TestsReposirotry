public class GenericIndexKeyValidatorTest {
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldNotBotherSerializingToRealBytesIfFarFromThreshold(){
    Layout<GenericKey,NativeIndexValue> layout=mock(Layout.class);
    doThrow(RuntimeException.class).when(layout).newKey();
    GenericIndexKeyValidator validator=new GenericIndexKeyValidator(120,layout);
    validator.validate(new Value[]{intValue(10),epochDate(100),stringValue("abc")});
  }
  @Test public void shouldInvolveSerializingToRealBytesIfMayCrossThreshold(){
    Layout<GenericKey,NativeIndexValue> layout=mock(Layout.class);
    when(layout.newKey()).thenReturn(new CompositeGenericKey(3,spatialSettings()));
    GenericIndexKeyValidator validator=new GenericIndexKeyValidator(48,layout);
    try {
      validator.validate(new Value[]{intValue(10),epochDate(100),stringValue("abcdefghijklmnopqrstuvw")});
      fail("Should have failed");
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.getMessage(),containsString("abcdefghijklmnopqrstuvw"));
      verify(layout,times(1)).newKey();
    }
  }
  @Test public void shouldReportCorrectValidationErrorsOnRandomlyGeneratedValues(){
    int slots=random.nextInt(1,6);
    int maxLength=random.nextInt(15,30) * slots;
    GenericLayout layout=new GenericLayout(slots,spatialSettings());
    GenericIndexKeyValidator validator=new GenericIndexKeyValidator(maxLength,layout);
    GenericKey key=layout.newKey();
    int countOk=0;
    int countNotOk=0;
    for (int i=0; i < 100; i++) {
      Value[] tuple=generateValueTuple(slots);
      boolean isOk;
      try {
        validator.validate(tuple);
        isOk=true;
        countOk++;
      }
 catch (      IllegalArgumentException e) {
        isOk=false;
        countNotOk++;
      }
      int actualSize=actualSize(tuple,key);
      boolean manualIsOk=actualSize <= maxLength;
      if (manualIsOk != isOk) {
        fail(format("Validator not validating %s correctly. Manual validation on actual key resulted in %b whereas validator said %b",Arrays.toString(tuple),manualIsOk,isOk));
      }
    }
  }
  private IndexSpecificSpaceFillingCurveSettingsCache spatialSettings(){
    return new IndexSpecificSpaceFillingCurveSettingsCache(new ConfiguredSpaceFillingCurveSettingsCache(Config.defaults()),new HashMap<>());
  }
  private static int actualSize(  Value[] tuple,  GenericKey key){
    key.initialize(0);
    for (int i=0; i < tuple.length; i++) {
      key.initFromValue(i,tuple[i],NativeIndexKey.Inclusion.NEUTRAL);
    }
    return key.size();
  }
  private Value[] generateValueTuple(  int slots){
    Value[] tuple=new Value[slots];
    for (int j=0; j < slots; j++) {
      tuple[j]=random.nextValue();
    }
    return tuple;
  }
}
