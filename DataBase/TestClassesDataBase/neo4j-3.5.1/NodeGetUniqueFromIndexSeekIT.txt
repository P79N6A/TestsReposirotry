public class NodeGetUniqueFromIndexSeekIT extends KernelIntegrationTest {
  private int labelId;
  private int propertyId1;
  private int propertyId2;
  @Before public void createKeys() throws Exception {
    TokenWrite tokenWrite=tokenWriteInNewTransaction();
    this.labelId=tokenWrite.labelGetOrCreateForName("Person");
    this.propertyId1=tokenWrite.propertyKeyGetOrCreateForName("foo");
    this.propertyId2=tokenWrite.propertyKeyGetOrCreateForName("bar");
    commit();
  }
  @Test public void shouldFindMatchingNode() throws Exception {
    IndexReference index=createUniquenessConstraint(labelId,propertyId1);
    Value value=Values.of("value");
    long nodeId=createNodeWithValue(value);
    Read read=newTransaction().dataRead();
    int propertyId=index.properties()[0];
    long foundId=read.lockingNodeUniqueIndexSeek(index,exact(propertyId,value));
    commit();
    assertEquals("Created node was not found",nodeId,foundId);
  }
  @Test public void shouldNotFindNonMatchingNode() throws Exception {
    IndexReference index=createUniquenessConstraint(labelId,propertyId1);
    Value value=Values.of("value");
    createNodeWithValue(Values.of("other_" + value));
    Transaction transaction=newTransaction();
    long foundId=transaction.dataRead().lockingNodeUniqueIndexSeek(index,exact(propertyId1,value));
    commit();
    assertTrue("Non-matching created node was found",isNoSuchNode(foundId));
  }
  @Test public void shouldCompositeFindMatchingNode() throws Exception {
    IndexReference index=createUniquenessConstraint(labelId,propertyId1,propertyId2);
    Value value1=Values.of("value1");
    Value value2=Values.of("value2");
    long nodeId=createNodeWithValues(value1,value2);
    Transaction transaction=newTransaction();
    long foundId=transaction.dataRead().lockingNodeUniqueIndexSeek(index,exact(propertyId1,value1),exact(propertyId2,value2));
    commit();
    assertEquals("Created node was not found",nodeId,foundId);
  }
  @Test public void shouldNotCompositeFindNonMatchingNode() throws Exception {
    IndexReference index=createUniquenessConstraint(labelId,propertyId1,propertyId2);
    Value value1=Values.of("value1");
    Value value2=Values.of("value2");
    createNodeWithValues(Values.of("other_" + value1),Values.of("other_" + value2));
    Transaction transaction=newTransaction();
    long foundId=transaction.dataRead().lockingNodeUniqueIndexSeek(index,exact(propertyId1,value1),exact(propertyId2,value2));
    commit();
    assertTrue("Non-matching created node was found",isNoSuchNode(foundId));
  }
  @Test(timeout=10_000) public void shouldBlockUniqueIndexSeekFromCompetingTransaction() throws Exception {
    final DoubleLatch latch=new DoubleLatch();
    final IndexReference index=createUniquenessConstraint(labelId,propertyId1);
    final Value value=Values.of("value");
    Write write=dataWriteInNewTransaction();
    long nodeId=write.nodeCreate();
    write.nodeAddLabel(nodeId,labelId);
    write.nodeSetProperty(nodeId,propertyId1,value);
    Runnable runnableForThread2=() -> {
      latch.waitForAllToStart();
      try (Transaction tx=kernel.beginTransaction(Transaction.Type.implicit,LoginContext.AUTH_DISABLED)){
        tx.dataRead().lockingNodeUniqueIndexSeek(index,exact(propertyId1,value));
        tx.success();
      }
 catch (      KernelException e) {
        throw new RuntimeException(e);
      }
 finally {
        latch.finish();
      }
    }
;
    Thread thread2=new Thread(runnableForThread2,"Transaction Thread 2");
    thread2.start();
    latch.startAndWaitForAllToStart();
    while ((thread2.getState() != Thread.State.TIMED_WAITING) && (thread2.getState() != Thread.State.WAITING)) {
      Thread.yield();
    }
    commit();
    latch.waitForAllToFinish();
  }
  private boolean isNoSuchNode(  long foundId){
    return StatementConstants.NO_SUCH_NODE == foundId;
  }
  private long createNodeWithValue(  Value value) throws KernelException {
    Write write=dataWriteInNewTransaction();
    long nodeId=write.nodeCreate();
    write.nodeAddLabel(nodeId,labelId);
    write.nodeSetProperty(nodeId,propertyId1,value);
    commit();
    return nodeId;
  }
  private long createNodeWithValues(  Value value1,  Value value2) throws KernelException {
    Write write=dataWriteInNewTransaction();
    long nodeId=write.nodeCreate();
    write.nodeAddLabel(nodeId,labelId);
    write.nodeSetProperty(nodeId,propertyId1,value1);
    write.nodeSetProperty(nodeId,propertyId2,value2);
    commit();
    return nodeId;
  }
  private IndexReference createUniquenessConstraint(  int labelId,  int... propertyIds) throws Exception {
    Transaction transaction=newTransaction(LoginContext.AUTH_DISABLED);
    LabelSchemaDescriptor descriptor=SchemaDescriptorFactory.forLabel(labelId,propertyIds);
    transaction.schemaWrite().uniquePropertyConstraintCreate(descriptor);
    IndexReference result=transaction.schemaRead().index(descriptor.getLabelId(),descriptor.getPropertyIds());
    commit();
    return result;
  }
}
