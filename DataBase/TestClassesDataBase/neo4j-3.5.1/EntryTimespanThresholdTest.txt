public class EntryTimespanThresholdTest {
  private final File file=mock(File.class);
  private final LogFileInformation source=mock(LogFileInformation.class);
  private final long version=4;
  private Clock clock=Clock.fixed(Instant.ofEpochMilli(1000),ZoneOffset.UTC);
  @Test public void shouldReturnFalseWhenTimeIsEqualOrAfterTheLowerLimit() throws IOException {
    final EntryTimespanThreshold threshold=new EntryTimespanThreshold(clock,TimeUnit.MILLISECONDS,200);
    when(source.getFirstStartRecordTimestamp(version)).thenReturn(800L);
    threshold.init();
    final boolean result=threshold.reached(file,version,source);
    assertFalse(result);
  }
  @Test public void shouldReturnReturnWhenTimeIsBeforeTheLowerLimit() throws IOException {
    final EntryTimespanThreshold threshold=new EntryTimespanThreshold(clock,TimeUnit.MILLISECONDS,100);
    when(source.getFirstStartRecordTimestamp(version)).thenReturn(800L);
    threshold.init();
    final boolean result=threshold.reached(file,version,source);
    assertTrue(result);
  }
  @Test public void shouldThrowIfTheLogCannotBeRead() throws IOException {
    final EntryTimespanThreshold threshold=new EntryTimespanThreshold(clock,TimeUnit.MILLISECONDS,100);
    final IOException ex=new IOException();
    when(source.getFirstStartRecordTimestamp(version)).thenThrow(ex);
    threshold.init();
    try {
      threshold.reached(file,version,source);
      fail("should have thrown");
    }
 catch (    RuntimeException e) {
      assertEquals(ex,e.getCause());
    }
  }
}
