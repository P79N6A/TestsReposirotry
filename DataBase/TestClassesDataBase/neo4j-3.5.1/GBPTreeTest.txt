@SuppressWarnings("EmptyTryBlock") public class GBPTreeTest {
  private static final int DEFAULT_PAGE_SIZE=256;
  private static final Layout<MutableLong,MutableLong> layout=longLayout().build();
  private final DefaultFileSystemRule fs=new DefaultFileSystemRule();
  private final TestDirectory directory=TestDirectory.testDirectory(getClass(),fs.get());
  private final PageCacheRule pageCacheRule=new PageCacheRule(config().withAccessChecks(true));
  private final RandomRule random=new RandomRule();
  @Rule public final RuleChain rules=outerRule(fs).around(directory).around(pageCacheRule).around(random);
  private File indexFile;
  private ExecutorService executor;
  @Before public void setUp(){
    executor=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    indexFile=directory.file("index");
  }
  @After public void teardown(){
    executor.shutdown();
  }
  @Test public void shouldReadWrittenMetaData() throws Exception {
    try (GBPTree<MutableLong,MutableLong> ignored=index().build()){
    }
     try (GBPTree<MutableLong,MutableLong> ignored=index().build()){
    }
   }
  @Test public void shouldFailToOpenOnDifferentMetaData() throws Exception {
    try (GBPTree<MutableLong,MutableLong> ignored=index(1024).build()){
    }
     SimpleLongLayout otherLayout=longLayout().withCustomerNameAsMetaData("Something else").build();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(otherLayout).build()){
      fail("Should not load");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void shouldFailToOpenOnDifferentLayout() throws Exception {
    try (GBPTree<MutableLong,MutableLong> ignored=index().build()){
    }
     SimpleLongLayout otherLayout=longLayout().withIdentifier(123456).build();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(otherLayout).build()){
      fail("Should not load");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void shouldFailToOpenOnDifferentMajorVersion() throws Exception {
    try (GBPTree<MutableLong,MutableLong> ignored=index(1024).build()){
    }
     SimpleLongLayout otherLayout=longLayout().withMajorVersion(123).build();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(otherLayout).build()){
      fail("Should not load");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void shouldFailToOpenOnDifferentMinorVersion() throws Exception {
    try (GBPTree<MutableLong,MutableLong> ignored=index().build()){
    }
     SimpleLongLayout otherLayout=longLayout().withMinorVersion(123).build();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(otherLayout).build()){
      fail("Should not load");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void shouldFailOnOpenWithDifferentPageSize() throws Exception {
    int pageSize=1024;
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageSize).build()){
    }
     try (GBPTree<MutableLong,MutableLong> ignored=index(pageSize / 2).build()){
      fail("Should not load");
    }
 catch (    MetadataMismatchException e) {
      assertThat(e.getMessage(),containsString("page size"));
    }
  }
  @Test public void shouldFailOnStartingWithPageSizeLargerThanThatOfPageCache() throws Exception {
    int pageCachePageSize=512;
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCachePageSize).withIndexPageSize(2 * pageCachePageSize).build()){
      fail("Shouldn't have been created");
    }
 catch (    MetadataMismatchException e) {
      assertThat(e.getMessage(),containsString("page size"));
    }
  }
  @Test public void shouldMapIndexFileWithProvidedPageSizeIfLessThanOrEqualToCachePageSize() throws Exception {
    int pageCachePageSize=1024;
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCachePageSize).withIndexPageSize(pageCachePageSize / 2).build()){
    }
   }
  @Test public void shouldFailWhenTryingToRemapWithPageSizeLargerThanCachePageSize() throws Exception {
    int pageCachePageSize=1024;
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCachePageSize).build()){
    }
     try (GBPTree<MutableLong,MutableLong> ignored=index(pageCachePageSize / 2).withIndexPageSize(pageCachePageSize).build()){
      fail("Expected to fail");
    }
 catch (    MetadataMismatchException e) {
      assertThat(e.getMessage(),containsString("page size"));
    }
  }
  @Test public void shouldRemapFileIfMappedWithPageSizeLargerThanCreationSize() throws Exception {
    int pageSize=1024;
    List<Long> expectedData=new ArrayList<>();
    for (long i=0; i < 100; i++) {
      expectedData.add(i);
    }
    try (GBPTree<MutableLong,MutableLong> index=index(pageSize).withIndexPageSize(pageSize / 2).build()){
      try (Writer<MutableLong,MutableLong> writer=index.writer()){
        MutableLong key=new MutableLong();
        MutableLong value=new MutableLong();
        for (        Long insert : expectedData) {
          key.setValue(insert);
          value.setValue(insert);
          writer.put(key,value);
        }
      }
       index.checkpoint(UNLIMITED);
    }
     try (GBPTree<MutableLong,MutableLong> index=index(pageSize).build()){
      MutableLong fromInclusive=new MutableLong(0L);
      MutableLong toExclusive=new MutableLong(200L);
      try (RawCursor<Hit<MutableLong,MutableLong>,IOException> seek=index.seek(fromInclusive,toExclusive)){
        int i=0;
        while (seek.next()) {
          Hit<MutableLong,MutableLong> hit=seek.get();
          assertEquals(hit.key().getValue(),expectedData.get(i));
          assertEquals(hit.value().getValue(),expectedData.get(i));
          i++;
        }
      }
     }
   }
  @Test public void shouldFailWhenTryingToOpenWithDifferentFormatIdentifier() throws Exception {
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    GBPTreeBuilder<MutableLong,MutableLong> builder=index(pageCache);
    try (GBPTree<MutableLong,MutableLong> ignored=builder.build()){
    }
     try {
      builder.with(longLayout().withFixedSize(false).build()).build();
      fail("Should have failed");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void shouldReturnNoResultsOnEmptyIndex() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      RawCursor<Hit<MutableLong,MutableLong>,IOException> result=index.seek(new MutableLong(0),new MutableLong(10));
      assertFalse(result.next());
    }
   }
  @Test public void shouldNotBeAbleToAcquireModifierTwice() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      Writer<MutableLong,MutableLong> writer=index.writer();
      try {
        index.writer();
        fail("Should have failed");
      }
 catch (      IllegalStateException e) {
      }
      writer.close();
      index.writer().close();
    }
   }
  @Test public void shouldNotAllowClosingWriterMultipleTimes() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      Writer<MutableLong,MutableLong> writer=index.writer();
      writer.put(new MutableLong(0),new MutableLong(1));
      writer.close();
      try {
        writer.close();
        fail("Should have failed");
      }
 catch (      IllegalStateException e) {
        assertThat(e.getMessage(),containsString("already closed"));
      }
    }
   }
  @Test public void failureDuringInitializeWriterShouldNotFailNextInitialize() throws Exception {
    IOException no=new IOException("No");
    AtomicBoolean throwOnNextIO=new AtomicBoolean();
    PageCache controlledPageCache=pageCacheThatThrowExceptionWhenToldTo(no,throwOnNextIO);
    try (GBPTree<MutableLong,MutableLong> index=index(controlledPageCache).build()){
      assertTrue(throwOnNextIO.compareAndSet(false,true));
      try (Writer<MutableLong,MutableLong> ignored=index.writer()){
        fail("Expected to throw");
      }
 catch (      IOException e) {
        assertSame(no,e);
      }
      try (Writer<MutableLong,MutableLong> writer=index.writer()){
        writer.put(new MutableLong(1),new MutableLong(1));
      }
     }
   }
  @Test public void shouldAllowClosingTreeMultipleTimes() throws Exception {
    GBPTree<MutableLong,MutableLong> index=index().build();
    index.close();
    index.close();
  }
  @Test public void shouldPutHeaderDataInCheckPoint() throws Exception {
    BiConsumer<GBPTree<MutableLong,MutableLong>,byte[]> beforeClose=(index,expected) -> {
      ThrowingRunnable throwingRunnable=() -> index.checkpoint(UNLIMITED,cursor -> cursor.putBytes(expected));
      ThrowingRunnable.throwing(throwingRunnable).run();
    }
;
    verifyHeaderDataAfterClose(beforeClose);
  }
  @Test public void shouldCarryOverHeaderDataInCheckPoint() throws Exception {
    BiConsumer<GBPTree<MutableLong,MutableLong>,byte[]> beforeClose=(index,expected) -> {
      ThrowingRunnable throwingRunnable=() -> {
        index.checkpoint(UNLIMITED,cursor -> cursor.putBytes(expected));
        insert(index,0,1);
        index.checkpoint(UNLIMITED);
      }
;
      ThrowingRunnable.throwing(throwingRunnable).run();
    }
;
    verifyHeaderDataAfterClose(beforeClose);
  }
  @Test public void shouldCarryOverHeaderDataOnDirtyClose() throws Exception {
    BiConsumer<GBPTree<MutableLong,MutableLong>,byte[]> beforeClose=(index,expected) -> {
      ThrowingRunnable throwingRunnable=() -> {
        index.checkpoint(UNLIMITED,cursor -> cursor.putBytes(expected));
        insert(index,0,1);
      }
;
      ThrowingRunnable.throwing(throwingRunnable).run();
    }
;
    verifyHeaderDataAfterClose(beforeClose);
  }
  @Test public void shouldReplaceHeaderDataInNextCheckPoint() throws Exception {
    BiConsumer<GBPTree<MutableLong,MutableLong>,byte[]> beforeClose=(index,expected) -> {
      ThrowingRunnable throwingRunnable=() -> {
        index.checkpoint(UNLIMITED,cursor -> cursor.putBytes(expected));
        ThreadLocalRandom.current().nextBytes(expected);
        index.checkpoint(UNLIMITED,cursor -> cursor.putBytes(expected));
      }
;
      ThrowingRunnable.throwing(throwingRunnable).run();
    }
;
    verifyHeaderDataAfterClose(beforeClose);
  }
  @Test public void mustWriteHeaderOnInitialization() throws Exception {
    byte[] headerBytes=new byte[12];
    ThreadLocalRandom.current().nextBytes(headerBytes);
    Consumer<PageCursor> headerWriter=pc -> pc.putBytes(headerBytes);
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    try (GBPTree<MutableLong,MutableLong> ignore=index(pageCache).with(headerWriter).build()){
    }
     verifyHeader(pageCache,headerBytes);
  }
  @Test public void mustNotOverwriteHeaderOnExistingTree() throws Exception {
    byte[] expectedBytes=new byte[12];
    ThreadLocalRandom.current().nextBytes(expectedBytes);
    Consumer<PageCursor> headerWriter=pc -> pc.putBytes(expectedBytes);
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    try (GBPTree<MutableLong,MutableLong> ignore=index(pageCache).with(headerWriter).build()){
    }
     byte[] fraudulentBytes=new byte[12];
    do {
      ThreadLocalRandom.current().nextBytes(fraudulentBytes);
    }
 while (Arrays.equals(expectedBytes,fraudulentBytes));
    try (GBPTree<MutableLong,MutableLong> ignore=index(pageCache).with(headerWriter).build()){
    }
     verifyHeader(pageCache,expectedBytes);
  }
  private void verifyHeaderDataAfterClose(  BiConsumer<GBPTree<MutableLong,MutableLong>,byte[]> beforeClose) throws IOException {
    byte[] expectedHeader=new byte[12];
    ThreadLocalRandom.current().nextBytes(expectedHeader);
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    try (GBPTree<MutableLong,MutableLong> index=index(pageCache).build()){
      beforeClose.accept(index,expectedHeader);
    }
     verifyHeader(pageCache,expectedHeader);
  }
  @Test(timeout=10_000) public void writeHeaderInDirtyTreeMustNotDeadlock() throws Exception {
    PageCache pageCache=createPageCache(256);
    makeDirty(pageCache);
    Consumer<PageCursor> headerWriter=pc -> pc.putBytes("failed".getBytes());
    try (GBPTree<MutableLong,MutableLong> index=index(pageCache).with(RecoveryCleanupWorkCollector.ignore()).build()){
      index.checkpoint(UNLIMITED,headerWriter);
    }
     verifyHeader(pageCache,"failed".getBytes());
  }
  private void verifyHeader(  PageCache pageCache,  byte[] expectedHeader) throws IOException {
    byte[] readHeader=new byte[expectedHeader.length];
    AtomicInteger length=new AtomicInteger();
    Header.Reader headerReader=headerData -> {
      length.set(headerData.limit());
      headerData.get(readHeader);
    }
;
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCache).with(headerReader).build()){
    }
     assertEquals(expectedHeader.length,length.get());
    assertArrayEquals(expectedHeader,readHeader);
    GBPTree.readHeader(pageCache,indexFile,headerReader);
    assertEquals(expectedHeader.length,length.get());
    assertArrayEquals(expectedHeader,readHeader);
  }
  @Test public void readHeaderMustThrowIfFileDoesNotExist() throws Exception {
    File doesNotExist=new File("Does not exist");
    try {
      GBPTree.readHeader(createPageCache(DEFAULT_PAGE_SIZE),doesNotExist,NO_HEADER_READER);
      fail("Should have failed");
    }
 catch (    NoSuchFileException e) {
    }
  }
  @Test public void openWithReadHeaderMustThrowMetadataMismatchExceptionIfFileIsEmpty() throws Exception {
    openMustThrowMetadataMismatchExceptionIfFileIsEmpty(pageCache -> GBPTree.readHeader(pageCache,indexFile,NO_HEADER_READER));
  }
  @Test public void openWithConstructorMustThrowMetadataMismatchExceptionIfFileIsEmpty() throws Exception {
    openMustThrowMetadataMismatchExceptionIfFileIsEmpty(pageCache -> index(pageCache).build());
  }
  private void openMustThrowMetadataMismatchExceptionIfFileIsEmpty(  ThrowingConsumer<PageCache,IOException> opener) throws Exception {
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    pageCache.map(indexFile,pageCache.pageSize(),StandardOpenOption.CREATE).close();
    try {
      opener.accept(pageCache);
      fail("Should've thrown IOException");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void readHeaderMustThrowMetadataMismatchExceptionIfSomeMetaPageIsMissing() throws Exception {
    openMustThrowMetadataMismatchExceptionIfSomeMetaPageIsMissing(pageCache -> GBPTree.readHeader(pageCache,indexFile,NO_HEADER_READER));
  }
  @Test public void constructorMustThrowMetadataMismatchExceptionIfSomeMetaPageIsMissing() throws Exception {
    openMustThrowMetadataMismatchExceptionIfSomeMetaPageIsMissing(pageCache -> index(pageCache).build());
  }
  private void openMustThrowMetadataMismatchExceptionIfSomeMetaPageIsMissing(  ThrowingConsumer<PageCache,IOException> opener) throws Exception {
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCache).build()){
    }
     fs.truncate(indexFile,DEFAULT_PAGE_SIZE);
    try {
      opener.accept(pageCache);
      fail("Should've thrown IOException");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void readHeaderMustThrowIOExceptionIfStatePagesAreAllZeros() throws Exception {
    openMustThrowMetadataMismatchExceptionIfStatePagesAreAllZeros(pageCache -> GBPTree.readHeader(pageCache,indexFile,NO_HEADER_READER));
  }
  @Test public void constructorMustThrowMetadataMismatchExceptionIfStatePagesAreAllZeros() throws Exception {
    openMustThrowMetadataMismatchExceptionIfStatePagesAreAllZeros(pageCache -> index(pageCache).build());
  }
  private void openMustThrowMetadataMismatchExceptionIfStatePagesAreAllZeros(  ThrowingConsumer<PageCache,IOException> opener) throws Exception {
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCache).build()){
    }
     fs.truncate(indexFile,DEFAULT_PAGE_SIZE);
    try (OutputStream out=fs.openAsOutputStream(indexFile,true)){
      byte[] allZeroPage=new byte[DEFAULT_PAGE_SIZE];
      out.write(allZeroPage);
      out.write(allZeroPage);
    }
     try {
      opener.accept(pageCache);
      fail("Should've thrown IOException");
    }
 catch (    MetadataMismatchException e) {
    }
  }
  @Test public void readHeaderMustWorkWithOpenIndex() throws Exception {
    byte[] headerBytes=new byte[12];
    ThreadLocalRandom.current().nextBytes(headerBytes);
    Consumer<PageCursor> headerWriter=pc -> pc.putBytes(headerBytes);
    PageCache pageCache=createPageCache(DEFAULT_PAGE_SIZE);
    try (GBPTree<MutableLong,MutableLong> ignore=index(pageCache).with(headerWriter).build()){
      byte[] readHeader=new byte[headerBytes.length];
      AtomicInteger length=new AtomicInteger();
      Header.Reader headerReader=headerData -> {
        length.set(headerData.limit());
        headerData.get(readHeader);
      }
;
      GBPTree.readHeader(pageCache,indexFile,headerReader);
      assertEquals(headerBytes.length,length.get());
      assertArrayEquals(headerBytes,readHeader);
    }
   }
  @Test(timeout=5_000L) public void checkPointShouldLockOutWriter() throws Exception {
    CheckpointControlledMonitor monitor=new CheckpointControlledMonitor();
    try (GBPTree<MutableLong,MutableLong> index=index().with(monitor).build()){
      long key=10;
      try (Writer<MutableLong,MutableLong> writer=index.writer()){
        writer.put(new MutableLong(key),new MutableLong(key));
      }
       monitor.enabled=true;
      Future<?> checkpoint=executor.submit(throwing(() -> index.checkpoint(UNLIMITED)));
      monitor.barrier.awaitUninterruptibly();
      Future<?> writerClose=executor.submit(throwing(() -> index.writer().close()));
      shouldWait(writerClose);
      monitor.barrier.release();
      writerClose.get();
      checkpoint.get();
    }
   }
  @Test(timeout=5_000L) public void checkPointShouldWaitForWriter() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      Barrier.Control barrier=new Barrier.Control();
      Future<?> write=executor.submit(throwing(() -> {
        try (Writer<MutableLong,MutableLong> writer=index.writer()){
          writer.put(new MutableLong(1),new MutableLong(1));
          barrier.reached();
        }
       }
));
      barrier.awaitUninterruptibly();
      Future<?> checkpoint=executor.submit(throwing(() -> index.checkpoint(UNLIMITED)));
      shouldWait(checkpoint);
      barrier.release();
      checkpoint.get();
      write.get();
    }
   }
  @Test(timeout=50_000L) public void closeShouldLockOutWriter() throws Exception {
    AtomicBoolean enabled=new AtomicBoolean();
    Barrier.Control barrier=new Barrier.Control();
    PageCache pageCacheWithBarrier=pageCacheWithBarrierInClose(enabled,barrier);
    GBPTree<MutableLong,MutableLong> index=index(pageCacheWithBarrier).build();
    long key=10;
    try (Writer<MutableLong,MutableLong> writer=index.writer()){
      writer.put(new MutableLong(key),new MutableLong(key));
    }
     enabled.set(true);
    Future<?> close=executor.submit(throwing(index::close));
    barrier.awaitUninterruptibly();
    AtomicReference<Exception> writerError=new AtomicReference<>();
    Future<?> write=executor.submit(() -> {
      try {
        index.writer().close();
      }
 catch (      Exception e) {
        writerError.set(e);
      }
    }
);
    shouldWait(write);
    barrier.release();
    write.get();
    close.get();
    assertTrue("Writer should not be able to acquired after close",writerError.get() instanceof FileIsNotMappedException);
  }
  private PageCache pageCacheWithBarrierInClose(  final AtomicBoolean enabled,  final Barrier.Control barrier){
    return new DelegatingPageCache(createPageCache(1024)){
      @Override public PagedFile map(      File file,      int pageSize,      OpenOption... openOptions) throws IOException {
        return new DelegatingPagedFile(super.map(file,pageSize,openOptions)){
          @Override public void close() throws IOException {
            if (enabled.get()) {
              barrier.reached();
            }
            super.close();
          }
        }
;
      }
    }
;
  }
  @Test(timeout=5_000L) public void writerShouldLockOutClose() throws Exception {
    GBPTree<MutableLong,MutableLong> index=index().build();
    Barrier.Control barrier=new Barrier.Control();
    Future<?> write=executor.submit(throwing(() -> {
      try (Writer<MutableLong,MutableLong> writer=index.writer()){
        writer.put(new MutableLong(1),new MutableLong(1));
        barrier.reached();
      }
     }
));
    barrier.awaitUninterruptibly();
    Future<?> close=executor.submit(throwing(index::close));
    shouldWait(close);
    barrier.release();
    close.get();
    write.get();
  }
  @Test public void dirtyIndexIsNotCleanOnNextStartWithoutRecovery() throws IOException {
    makeDirty();
    try (GBPTree<MutableLong,MutableLong> index=index().with(RecoveryCleanupWorkCollector.ignore()).build()){
      assertTrue(index.wasDirtyOnStartup());
    }
   }
  @Test public void correctlyShutdownIndexIsClean() throws IOException {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      try (Writer<MutableLong,MutableLong> writer=index.writer()){
        writer.put(new MutableLong(1L),new MutableLong(2L));
      }
       index.checkpoint(UNLIMITED);
    }
     try (GBPTree<MutableLong,MutableLong> index=index().build()){
      assertFalse(index.wasDirtyOnStartup());
    }
   }
  @Test(timeout=5_000L) public void cleanJobShouldLockOutCheckpoint() throws Exception {
    makeDirty();
    RecoveryCleanupWorkCollector cleanupWork=new ControlledRecoveryCleanupWorkCollector();
    CleanJobControlledMonitor monitor=new CleanJobControlledMonitor();
    try (GBPTree<MutableLong,MutableLong> index=index().with(monitor).with(cleanupWork).build()){
      Future<?> cleanup=executor.submit(throwing(cleanupWork::start));
      monitor.barrier.awaitUninterruptibly();
      index.writer().close();
      Future<?> checkpoint=executor.submit(throwing(() -> index.checkpoint(UNLIMITED)));
      shouldWait(checkpoint);
      monitor.barrier.release();
      cleanup.get();
      checkpoint.get();
    }
   }
  @Test(timeout=5_000L) public void cleanJobShouldLockOutCheckpointOnNoUpdate() throws Exception {
    makeDirty();
    RecoveryCleanupWorkCollector cleanupWork=new ControlledRecoveryCleanupWorkCollector();
    CleanJobControlledMonitor monitor=new CleanJobControlledMonitor();
    try (GBPTree<MutableLong,MutableLong> index=index().with(monitor).with(cleanupWork).build()){
      Future<?> cleanup=executor.submit(throwing(cleanupWork::start));
      monitor.barrier.awaitUninterruptibly();
      Future<?> checkpoint=executor.submit(throwing(() -> index.checkpoint(UNLIMITED)));
      shouldWait(checkpoint);
      monitor.barrier.release();
      cleanup.get();
      checkpoint.get();
    }
   }
  @Test(timeout=5_000L) public void cleanJobShouldNotLockOutClose() throws Exception {
    makeDirty();
    RecoveryCleanupWorkCollector cleanupWork=new ControlledRecoveryCleanupWorkCollector();
    CleanJobControlledMonitor monitor=new CleanJobControlledMonitor();
    GBPTree<MutableLong,MutableLong> index=index().with(monitor).with(cleanupWork).build();
    Future<?> cleanup=executor.submit(throwing(cleanupWork::start));
    monitor.barrier.awaitUninterruptibly();
    Future<?> close=executor.submit(throwing(index::close));
    close.get();
    monitor.barrier.release();
    cleanup.get();
  }
  @Test(timeout=5_000L) public void cleanJobShouldNotLockOutWriter() throws Exception {
    makeDirty();
    RecoveryCleanupWorkCollector cleanupWork=new ControlledRecoveryCleanupWorkCollector();
    CleanJobControlledMonitor monitor=new CleanJobControlledMonitor();
    try (GBPTree<MutableLong,MutableLong> index=index().with(monitor).with(cleanupWork).build()){
      Future<?> cleanup=executor.submit(throwing(cleanupWork::start));
      monitor.barrier.awaitUninterruptibly();
      Future<?> writer=executor.submit(throwing(() -> index.writer().close()));
      writer.get();
      monitor.barrier.release();
      cleanup.get();
    }
   }
  @Test public void writerShouldNotLockOutCleanJob() throws Exception {
    makeDirty();
    RecoveryCleanupWorkCollector cleanupWork=new ControlledRecoveryCleanupWorkCollector();
    try (GBPTree<MutableLong,MutableLong> index=index().with(cleanupWork).build()){
      try (Writer<MutableLong,MutableLong> writer=index.writer()){
        Future<?> cleanup=executor.submit(throwing(cleanupWork::start));
        writer.put(new MutableLong(1),new MutableLong(1));
        cleanup.get();
      }
     }
   }
  @Test public void cleanerShouldDieSilentlyOnClose() throws Throwable {
    makeDirty();
    AtomicBoolean blockOnNextIO=new AtomicBoolean();
    Barrier.Control control=new Barrier.Control();
    PageCache pageCache=pageCacheThatBlockWhenToldTo(control,blockOnNextIO);
    ControlledRecoveryCleanupWorkCollector collector=new ControlledRecoveryCleanupWorkCollector();
    collector.init();
    Future<List<CleanupJob>> cleanJob;
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCache).with(collector).build()){
      blockOnNextIO.set(true);
      cleanJob=executor.submit(startAndReturnStartedJobs(collector));
      control.await();
    }
     control.release();
    assertFailedDueToUnmappedFile(cleanJob);
  }
  @Test public void treeMustBeDirtyAfterCleanerDiedOnClose() throws Throwable {
    makeDirty();
    AtomicBoolean blockOnNextIO=new AtomicBoolean();
    Barrier.Control control=new Barrier.Control();
    PageCache pageCache=pageCacheThatBlockWhenToldTo(control,blockOnNextIO);
    ControlledRecoveryCleanupWorkCollector collector=new ControlledRecoveryCleanupWorkCollector();
    collector.init();
    Future<List<CleanupJob>> cleanJob;
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCache).with(collector).build()){
      blockOnNextIO.set(true);
      cleanJob=executor.submit(startAndReturnStartedJobs(collector));
      control.await();
    }
     control.release();
    assertFailedDueToUnmappedFile(cleanJob);
    MonitorDirty monitor=new MonitorDirty();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(monitor).build()){
      assertFalse(monitor.cleanOnStart());
    }
   }
  private Callable<List<CleanupJob>> startAndReturnStartedJobs(  ControlledRecoveryCleanupWorkCollector collector){
    return () -> {
      try {
        collector.start();
      }
 catch (      Throwable throwable) {
        throw new RuntimeException(throwable);
      }
      return collector.allStartedJobs();
    }
;
  }
  private void assertFailedDueToUnmappedFile(  Future<List<CleanupJob>> cleanJob) throws InterruptedException, ExecutionException {
    for (    CleanupJob job : cleanJob.get()) {
      assertTrue(job.hasFailed());
      assertThat(job.getCause().getMessage(),allOf(containsString("File"),containsString("unmapped")));
    }
  }
  @Test public void checkpointMustRecognizeFailedCleaning() throws Exception {
    makeDirty();
    RuntimeException cleanupException=new RuntimeException("Fail cleaning job");
    CleanJobControlledMonitor cleanupMonitor=new CleanJobControlledMonitor(){
      @Override public void cleanupFinished(      long numberOfPagesVisited,      long numberOfCleanedCrashPointers,      long durationMillis){
        super.cleanupFinished(numberOfPagesVisited,numberOfCleanedCrashPointers,durationMillis);
        throw cleanupException;
      }
    }
;
    ControlledRecoveryCleanupWorkCollector collector=new ControlledRecoveryCleanupWorkCollector();
    try (GBPTree<MutableLong,MutableLong> index=index().with(cleanupMonitor).with(collector).build()){
      index.writer().close();
      Future<?> cleanup=executor.submit(throwing(collector::start));
      shouldWait(cleanup);
      Future<?> checkpoint=executor.submit(throwing(() -> index.checkpoint(UNLIMITED)));
      shouldWait(checkpoint);
      cleanupMonitor.barrier.release();
      cleanup.get();
      try {
        checkpoint.get();
        fail("Expected checkpoint to fail because of failed cleaning job");
      }
 catch (      ExecutionException e) {
        assertThat(e.getMessage(),allOf(containsString("cleaning"),containsString("failed")));
      }
    }
   }
  @Test public void shouldCheckpointAfterInitialCreation() throws Exception {
    CheckpointCounter checkpointCounter=new CheckpointCounter();
    GBPTree<MutableLong,MutableLong> index=index().with(checkpointCounter).build();
    assertEquals(1,checkpointCounter.count());
    index.close();
  }
  @Test public void shouldNotCheckpointOnClose() throws Exception {
    CheckpointCounter checkpointCounter=new CheckpointCounter();
    try (GBPTree<MutableLong,MutableLong> index=index().with(checkpointCounter).build()){
      checkpointCounter.reset();
      try (Writer<MutableLong,MutableLong> writer=index.writer()){
        writer.put(new MutableLong(0),new MutableLong(1));
      }
       index.checkpoint(UNLIMITED);
      assertEquals(1,checkpointCounter.count());
    }
     assertEquals(1,checkpointCounter.count());
  }
  @Test public void shouldCheckpointEvenIfNoChanges() throws Exception {
    CheckpointCounter checkpointCounter=new CheckpointCounter();
    try (GBPTree<MutableLong,MutableLong> index=index().with(checkpointCounter).build()){
      checkpointCounter.reset();
      index.checkpoint(UNLIMITED);
      assertEquals(1,checkpointCounter.count());
    }
   }
  @Test public void mustNotSeeUpdatesThatWasNotCheckpointed() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      insert(index,0,1);
    }
     try (GBPTree<MutableLong,MutableLong> index=index().build()){
      MutableLong from=new MutableLong(Long.MIN_VALUE);
      MutableLong to=new MutableLong(Long.MAX_VALUE);
      try (RawCursor<Hit<MutableLong,MutableLong>,IOException> seek=index.seek(from,to)){
        assertFalse(seek.next());
      }
     }
   }
  @Test public void mustSeeUpdatesThatWasCheckpointed() throws Exception {
    int key=1;
    int value=2;
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      insert(index,key,value);
      index.checkpoint(UNLIMITED);
    }
     try (GBPTree<MutableLong,MutableLong> index=index().build()){
      MutableLong from=new MutableLong(Long.MIN_VALUE);
      MutableLong to=new MutableLong(Long.MAX_VALUE);
      try (RawCursor<Hit<MutableLong,MutableLong>,IOException> seek=index.seek(from,to)){
        assertTrue(seek.next());
        assertEquals(key,seek.get().key().longValue());
        assertEquals(value,seek.get().value().longValue());
      }
     }
   }
  @Test public void mustBumpUnstableGenerationOnOpen() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      insert(index,0,1);
    }
     SimpleCleanupMonitor monitor=new SimpleCleanupMonitor();
    try (GBPTree<MutableLong,MutableLong> ignore=index().with(monitor).build()){
    }
     assertTrue("Expected monitor to get recovery complete message",monitor.cleanupFinished);
    assertEquals("Expected index to have exactly 1 crash pointer from root to successor of root",1,monitor.numberOfCleanedCrashPointers);
    assertEquals("Expected index to have exactly 2 tree node pages, root and successor of root",2,monitor.numberOfPagesVisited);
  }
  @Test public void indexMustBeCleanOnFirstInitialization() throws Exception {
    assertFalse(fs.get().fileExists(indexFile));
    MonitorDirty monitorDirty=new MonitorDirty();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(monitorDirty).build()){
    }
     assertTrue("Expected to be clean on start",monitorDirty.cleanOnStart());
  }
  @Test public void indexMustBeCleanWhenClosedWithoutAnyChanges() throws Exception {
    try (GBPTree<MutableLong,MutableLong> ignored=index().build()){
    }
     MonitorDirty monitorDirty=new MonitorDirty();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(monitorDirty).build()){
    }
     assertTrue("Expected to be clean on start after close with no changes",monitorDirty.cleanOnStart());
  }
  @Test public void indexMustBeCleanWhenClosedAfterCheckpoint() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      insert(index,0,1);
      index.checkpoint(UNLIMITED);
    }
     MonitorDirty monitorDirty=new MonitorDirty();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(monitorDirty).build()){
    }
     assertTrue("Expected to be clean on start after close with checkpoint",monitorDirty.cleanOnStart());
  }
  @Test public void indexMustBeDirtyWhenClosedWithChangesSinceLastCheckpoint() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      insert(index,0,1);
    }
     MonitorDirty monitorDirty=new MonitorDirty();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(monitorDirty).build()){
    }
     assertFalse("Expected to be dirty on start after close without checkpoint",monitorDirty.cleanOnStart());
  }
  @Test public void indexMustBeDirtyWhenCrashedWithChangesSinceLastCheckpoint() throws Exception {
    try (EphemeralFileSystemAbstraction ephemeralFs=new EphemeralFileSystemAbstraction()){
      ephemeralFs.mkdirs(indexFile.getParentFile());
      PageCache pageCache=pageCacheRule.getPageCache(ephemeralFs);
      EphemeralFileSystemAbstraction snapshot;
      try (GBPTree<MutableLong,MutableLong> index=index(pageCache).build()){
        insert(index,0,1);
        snapshot=ephemeralFs.snapshot();
      }
       pageCache.close();
      MonitorDirty monitorDirty=new MonitorDirty();
      pageCache=pageCacheRule.getPageCache(snapshot);
      try (GBPTree<MutableLong,MutableLong> ignored=index(pageCache).with(monitorDirty).build()){
      }
       assertFalse("Expected to be dirty on start after crash",monitorDirty.cleanOnStart());
    }
   }
  @Test public void cleanCrashPointersMustTriggerOnDirtyStart() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      insert(index,0,1);
    }
     MonitorCleanup monitor=new MonitorCleanup();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(monitor).build()){
      assertTrue("Expected cleanup to be called when starting on dirty tree",monitor.cleanupCalled());
    }
   }
  @Test public void cleanCrashPointersMustNotTriggerOnCleanStart() throws Exception {
    try (GBPTree<MutableLong,MutableLong> index=index().build()){
      insert(index,0,1);
      index.checkpoint(UNLIMITED);
    }
     MonitorCleanup monitor=new MonitorCleanup();
    try (GBPTree<MutableLong,MutableLong> ignored=index().with(monitor).build()){
      assertFalse("Expected cleanup not to be called when starting on clean tree",monitor.cleanupCalled());
    }
   }
  @Test public void shouldThrowIfTreeStatePointToRootWithValidSuccessor() throws Exception {
    try (PageCache specificPageCache=createPageCache(DEFAULT_PAGE_SIZE)){
      try (GBPTree<MutableLong,MutableLong> ignore=index(specificPageCache).build()){
      }
       try (PagedFile pagedFile=specificPageCache.map(indexFile,specificPageCache.pageSize());PageCursor cursor=pagedFile.io(0,PF_SHARED_WRITE_LOCK)){
        Pair<TreeState,TreeState> treeStates=TreeStatePair.readStatePages(cursor,IdSpace.STATE_PAGE_A,IdSpace.STATE_PAGE_B);
        TreeState newestState=TreeStatePair.selectNewestValidState(treeStates);
        long rootId=newestState.rootId();
        long stableGeneration=newestState.stableGeneration();
        long unstableGeneration=newestState.unstableGeneration();
        TreeNode.goTo(cursor,"root",rootId);
        TreeNode.setSuccessor(cursor,42,stableGeneration + 1,unstableGeneration + 1);
      }
       try (GBPTree<MutableLong,MutableLong> index=index(specificPageCache).build()){
        try (Writer<MutableLong,MutableLong> ignored=index.writer()){
          fail("Expected to throw because root pointed to by tree state should have a valid successor.");
        }
       }
 catch (      TreeInconsistencyException e) {
        assertThat(e.getMessage(),containsString(PointerChecking.WRITER_TRAVERSE_OLD_STATE_MESSAGE));
      }
    }
   }
  @Test public void mustRetryCloseIfFailure() throws Exception {
    AtomicBoolean throwOnNext=new AtomicBoolean();
    IOException exception=new IOException("My failure");
    PageCache pageCache=pageCacheThatThrowExceptionWhenToldTo(exception,throwOnNext);
    try (GBPTree<MutableLong,MutableLong> ignored=index(pageCache).build()){
      throwOnNext.set(true);
    }
   }
  @Test public void shouldThrowIllegalStateExceptionOnCallingNextAfterClose() throws Exception {
    try (GBPTree<MutableLong,MutableLong> tree=index().build()){
      try (Writer<MutableLong,MutableLong> writer=tree.writer()){
        MutableLong value=new MutableLong();
        for (int i=0; i < 10; i++) {
          value.setValue(i);
          writer.put(value,value);
        }
      }
       RawCursor<Hit<MutableLong,MutableLong>,IOException> seek=tree.seek(new MutableLong(0),new MutableLong(Long.MAX_VALUE));
      assertTrue(seek.next());
      assertTrue(seek.next());
      seek.close();
      for (int i=0; i < 2; i++) {
        try {
          seek.next();
          fail("Should have failed");
        }
 catch (        IllegalStateException e) {
        }
      }
    }
   }
private static class ControlledRecoveryCleanupWorkCollector extends RecoveryCleanupWorkCollector {
    Queue<CleanupJob> jobs=new LinkedList<>();
    List<CleanupJob> startedJobs=new LinkedList<>();
    @Override public void start(){
      executeWithExecutor(executor -> {
        CleanupJob job;
        while ((job=jobs.poll()) != null) {
          try {
            job.run(executor);
            startedJobs.add(job);
          }
  finally {
            job.close();
          }
        }
      }
);
    }
    @Override public void add(    CleanupJob job){
      jobs.add(job);
    }
    List<CleanupJob> allStartedJobs(){
      return startedJobs;
    }
  }
  private PageCache pageCacheThatThrowExceptionWhenToldTo(  final IOException e,  final AtomicBoolean throwOnNextIO){
    return new DelegatingPageCache(createPageCache(DEFAULT_PAGE_SIZE)){
      @Override public PagedFile map(      File file,      int pageSize,      OpenOption... openOptions) throws IOException {
        return new DelegatingPagedFile(super.map(file,pageSize,openOptions)){
          @Override public PageCursor io(          long pageId,          int pf_flags) throws IOException {
            maybeThrow();
            return super.io(pageId,pf_flags);
          }
          @Override public void flushAndForce(          IOLimiter limiter) throws IOException {
            maybeThrow();
            super.flushAndForce(limiter);
          }
          private void maybeThrow() throws IOException {
            if (throwOnNextIO.get()) {
              throwOnNextIO.set(false);
              assert e != null;
              throw e;
            }
          }
        }
;
      }
    }
;
  }
  private PageCache pageCacheThatBlockWhenToldTo(  final Barrier barrier,  final AtomicBoolean blockOnNextIO){
    return new DelegatingPageCache(createPageCache(DEFAULT_PAGE_SIZE)){
      @Override public PagedFile map(      File file,      int pageSize,      OpenOption... openOptions) throws IOException {
        return new DelegatingPagedFile(super.map(file,pageSize,openOptions)){
          @Override public PageCursor io(          long pageId,          int pf_flags) throws IOException {
            maybeBlock();
            return super.io(pageId,pf_flags);
          }
          private void maybeBlock(){
            if (blockOnNextIO.get()) {
              barrier.reached();
            }
          }
        }
;
      }
    }
;
  }
  private void makeDirty() throws IOException {
    makeDirty(createPageCache(DEFAULT_PAGE_SIZE));
  }
  private void makeDirty(  PageCache pageCache) throws IOException {
    try (GBPTree<MutableLong,MutableLong> index=index(pageCache).build()){
      index.writer().close();
    }
   }
  private void insert(  GBPTree<MutableLong,MutableLong> index,  long key,  long value) throws IOException {
    try (Writer<MutableLong,MutableLong> writer=index.writer()){
      writer.put(new MutableLong(key),new MutableLong(value));
    }
   }
  private void shouldWait(  Future<?> future) throws InterruptedException, ExecutionException {
    try {
      future.get(200,TimeUnit.MILLISECONDS);
      fail("Expected timeout");
    }
 catch (    TimeoutException e) {
    }
  }
  private PageCache createPageCache(  int pageSize){
    return pageCacheRule.getPageCache(fs.get(),config().withPageSize(pageSize));
  }
private static class CleanJobControlledMonitor extends Monitor.Adaptor {
    private final Barrier.Control barrier=new Barrier.Control();
    @Override public void cleanupFinished(    long numberOfPagesVisited,    long numberOfCleanedCrashPointers,    long durationMillis){
      barrier.reached();
    }
  }
  private GBPTreeBuilder<MutableLong,MutableLong> index(){
    return index(DEFAULT_PAGE_SIZE);
  }
  private GBPTreeBuilder<MutableLong,MutableLong> index(  int pageSize){
    return index(createPageCache(pageSize));
  }
  private GBPTreeBuilder<MutableLong,MutableLong> index(  PageCache pageCache){
    return new GBPTreeBuilder<>(pageCache,indexFile,layout);
  }
private static class CheckpointControlledMonitor extends Monitor.Adaptor {
    private final Barrier.Control barrier=new Barrier.Control();
    private volatile boolean enabled;
    @Override public void checkpointCompleted(){
      if (enabled) {
        barrier.reached();
      }
    }
  }
private static class CheckpointCounter extends Monitor.Adaptor {
    private int count;
    @Override public void checkpointCompleted(){
      count++;
    }
    public void reset(){
      count=0;
    }
    public int count(){
      return count;
    }
  }
private static class MonitorDirty extends Monitor.Adaptor {
    private boolean called;
    private boolean cleanOnStart;
    @Override public void startupState(    boolean clean){
      if (called) {
        throw new IllegalStateException("State has already been set. Can't set it again.");
      }
      called=true;
      cleanOnStart=clean;
    }
    boolean cleanOnStart(){
      if (!called) {
        throw new IllegalStateException("State has not been set");
      }
      return cleanOnStart;
    }
  }
private static class MonitorCleanup extends Monitor.Adaptor {
    private boolean cleanupCalled;
    @Override public void cleanupFinished(    long numberOfPagesVisited,    long numberOfCleanedCrashPointers,    long durationMillis){
      cleanupCalled=true;
    }
    boolean cleanupCalled(){
      return cleanupCalled;
    }
  }
}
