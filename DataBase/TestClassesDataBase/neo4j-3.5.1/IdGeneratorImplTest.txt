public class IdGeneratorImplTest {
  @Rule public final EphemeralFileSystemRule fsr=new EphemeralFileSystemRule();
  @Rule public ExpectedException expectedException=ExpectedException.none();
  private final File file=new File("ids");
  @Test public void shouldNotAcceptMinusOne(){
    IdGeneratorImpl.createGenerator(fsr.get(),file,0,false);
    IdGenerator idGenerator=new IdGeneratorImpl(fsr.get(),file,100,100,false,IdType.NODE,() -> 0L);
    expectedException.expect(NegativeIdException.class);
    idGenerator.setHighId(-1);
  }
  @Test public void throwsWhenNextIdIsTooHigh(){
    long maxId=10;
    IdGeneratorImpl.createGenerator(fsr.get(),file,0,false);
    IdGenerator idGenerator=new IdGeneratorImpl(fsr.get(),file,1,maxId,false,IdType.NODE,() -> 0L);
    for (long i=0; i <= maxId; i++) {
      idGenerator.nextId();
    }
    expectedException.expect(IdCapacityExceededException.class);
    expectedException.expectMessage("Maximum id limit for NODE has been reached. Generated id 11 is out of " + "permitted range [0, 10].");
    idGenerator.nextId();
  }
  @Test public void throwsWhenGivenHighIdIsTooHigh(){
    long maxId=10;
    IdGeneratorImpl.createGenerator(fsr.get(),file,0,false);
    IdGenerator idGenerator=new IdGeneratorImpl(fsr.get(),file,1,maxId,false,IdType.RELATIONSHIP_TYPE_TOKEN,() -> 0L);
    expectedException.expect(IdCapacityExceededException.class);
    expectedException.expectMessage("Maximum id limit for RELATIONSHIP_TYPE_TOKEN has been reached. Generated id 11 is out of permitted range [0, 10].");
    idGenerator.setHighId(maxId + 1);
  }
  /** 
 * It should be fine to set high id to  {@link IdGeneratorImpl#INTEGER_MINUS_ONE}. It will just be never returned from  {@link IdGeneratorImpl#nextId()}.
 */
  @Test public void highIdCouldBeSetToReservedId(){
    IdGeneratorImpl.createGenerator(fsr.get(),file,0,false);
    IdGenerator idGenerator=new IdGeneratorImpl(fsr.get(),file,1,Long.MAX_VALUE,false,IdType.NODE,() -> 0L);
    idGenerator.setHighId(IdGeneratorImpl.INTEGER_MINUS_ONE);
    assertEquals(IdGeneratorImpl.INTEGER_MINUS_ONE + 1,idGenerator.nextId());
  }
  @Test public void correctDefragCountWhenHaveIdsInFile(){
    IdGeneratorImpl.createGenerator(fsr.get(),file,100,false);
    IdGenerator idGenerator=new IdGeneratorImpl(fsr.get(),file,100,100,true,IdType.NODE,() -> 100L);
    idGenerator.freeId(5);
    idGenerator.close();
    IdGenerator reloadedIdGenerator=new IdGeneratorImpl(fsr.get(),file,100,100,true,IdType.NODE,() -> 100L);
    assertEquals(1,reloadedIdGenerator.getDefragCount());
    assertEquals(5,reloadedIdGenerator.nextId());
    assertEquals(0,reloadedIdGenerator.getDefragCount());
  }
  @Test public void shouldReadHighIdUsingStaticMethod() throws Exception {
    long highId=12345L;
    IdGeneratorImpl.createGenerator(fsr.get(),file,highId,false);
    long readHighId=IdGeneratorImpl.readHighId(fsr.get(),file);
    assertEquals(highId,readHighId);
  }
  @Test public void shouldReadDefragCountUsingStaticMethod() throws Exception {
    EphemeralFileSystemAbstraction fs=fsr.get();
    IdGeneratorImpl.createGenerator(fs,file,0,false);
    IdGeneratorImpl idGenerator=new IdGeneratorImpl(fs,file,1,10000,false,IdType.NODE,() -> 0L);
    idGenerator.nextId();
    long a=idGenerator.nextId();
    idGenerator.nextId();
    long b=idGenerator.nextId();
    idGenerator.nextId();
    idGenerator.freeId(a);
    idGenerator.freeId(b);
    long expectedDefragCount=idGenerator.getDefragCount();
    idGenerator.close();
    long actualDefragCount=IdGeneratorImpl.readDefragCount(fs,file);
    assertEquals(2,expectedDefragCount);
    assertEquals(expectedDefragCount,actualDefragCount);
  }
  @Test public void shouldBeAbleToReadWrittenGenerator(){
    IdGeneratorImpl.createGenerator(fsr.get(),file,42,false);
    IdGeneratorImpl idGenerator=new IdGeneratorImpl(fsr.get(),file,100,100,false,IdType.NODE,() -> 42L);
    idGenerator.close();
    idGenerator=new IdGeneratorImpl(fsr.get(),file,100,100,false,IdType.NODE,() -> 0L);
    assertThat(idGenerator.getHighId(),equalTo(42L));
  }
  @Test public void constructorShouldCallHighIdSupplierOnNonExistingIdFile(){
    LongSupplier highId=mock(LongSupplier.class);
    when(highId.getAsLong()).thenReturn(0L);
    IdGeneratorImpl idGenerator=new IdGeneratorImpl(fsr.get(),file,100,100,false,IdType.NODE,highId);
    verify(highId).getAsLong();
    idGenerator.close();
  }
  @Test public void constructorShouldNotCallHighIdSupplierOnCleanIdFile(){
    IdContainer.createEmptyIdFile(fsr.get(),file,42,true);
    LongSupplier highId=mock(LongSupplier.class);
    IdGenerator idGenerator=new IdGeneratorImpl(fsr.get(),file,100,100,false,IdType.NODE,highId);
    idGenerator.close();
    verifyZeroInteractions(highId);
  }
}
