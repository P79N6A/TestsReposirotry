public class TestLogPruning {
private interface Extractor {
    int extract(    long fromVersion) throws IOException ;
  }
  private GraphDatabaseAPI db;
  private FileSystemAbstraction fs;
  private LogFiles files;
  private int rotateEveryNTransactions;
  private int performedTransactions;
  @After public void after() throws Exception {
    if (db != null) {
      db.shutdown();
    }
    fs.close();
  }
  @Test public void noPruning() throws Exception {
    newDb("true",2);
    for (int i=0; i < 100; i++) {
      doTransaction();
    }
    long currentVersion=files.getHighestLogVersion();
    for (long version=0; version < currentVersion; version++) {
      assertTrue("Version " + version + " has been unexpectedly pruned",fs.fileExists(files.getLogFileForVersion(version)));
    }
  }
  @Test public void pruneByFileSize() throws Exception {
    int transactionByteSize=figureOutSampleTransactionSizeBytes();
    int transactionsPerFile=3;
    int logThreshold=transactionByteSize * transactionsPerFile;
    newDb(logThreshold + " size",1);
    for (int i=0; i < 100; i++) {
      doTransaction();
    }
    int totalLogFileSize=logFileSize();
    double totalTransactions=(double)totalLogFileSize / transactionByteSize;
    assertTrue(totalTransactions >= 3 && totalTransactions < 4);
  }
  @Test public void pruneByFileCount() throws Exception {
    int logsToKeep=5;
    newDb(logsToKeep + " files",3);
    for (int i=0; i < 100; i++) {
      doTransaction();
    }
    assertEquals(logsToKeep,logCount());
  }
  @Test public void pruneByTransactionCount() throws Exception {
    int transactionsToKeep=100;
    int transactionsPerLog=3;
    newDb(transactionsToKeep + " txs",3);
    for (int i=0; i < 100; i++) {
      doTransaction();
    }
    int transactionCount=transactionCount();
    assertTrue("Transaction count expected to be within " + transactionsToKeep + " <= txs <= "+ (transactionsToKeep + transactionsPerLog)+ ", but was "+ transactionCount,transactionCount >= transactionsToKeep && transactionCount <= (transactionsToKeep + transactionsPerLog));
  }
  @Test public void shouldKeepAtLeastOneTransactionAfterRotate() throws Exception {
    newDb(1 + " size",1);
    for (int i=0; i < 2; i++) {
      doTransaction();
    }
    db.getDependencyResolver().resolveDependency(LogRotation.class).rotateLogFile();
    assertThat(transactionCount(),greaterThanOrEqualTo(1));
  }
  private GraphDatabaseAPI newDb(  String logPruning,  int rotateEveryNTransactions){
    this.rotateEveryNTransactions=rotateEveryNTransactions;
    fs=new EphemeralFileSystemAbstraction();
    TestGraphDatabaseFactory gdf=new TestGraphDatabaseFactory();
    gdf.setFileSystem(new UncloseableDelegatingFileSystemAbstraction(fs));
    GraphDatabaseBuilder builder=gdf.newImpermanentDatabaseBuilder();
    builder.setConfig(keep_logical_logs,logPruning);
    this.db=(GraphDatabaseAPI)builder.newGraphDatabase();
    files=db.getDependencyResolver().resolveDependency(LogFiles.class);
    return db;
  }
  private void doTransaction() throws IOException {
    if (++performedTransactions >= rotateEveryNTransactions) {
      db.getDependencyResolver().resolveDependency(LogRotation.class).rotateLogFile();
      performedTransactions=0;
    }
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode();
      node.setProperty("name","a somewhat lengthy string of some sort, right?");
      tx.success();
    }
     checkPoint();
  }
  private void checkPoint() throws IOException {
    TriggerInfo triggerInfo=new SimpleTriggerInfo("test");
    db.getDependencyResolver().resolveDependency(CheckPointer.class).forceCheckPoint(triggerInfo);
  }
  private int figureOutSampleTransactionSizeBytes() throws IOException {
    db=newDb("true",5);
    doTransaction();
    db.shutdown();
    return (int)fs.getFileSize(files.getLogFileForVersion(0));
  }
  private int aggregateLogData(  Extractor extractor) throws IOException {
    int total=0;
    for (long i=files.getHighestLogVersion(); i >= 0; i--) {
      if (files.versionExists(i)) {
        total+=extractor.extract(i);
      }
 else {
        break;
      }
    }
    return total;
  }
  private int logCount() throws IOException {
    return aggregateLogData(from -> 1);
  }
  private int logFileSize() throws IOException {
    return aggregateLogData(from -> (int)fs.getFileSize(files.getLogFileForVersion(from)));
  }
  private int transactionCount() throws IOException {
    return aggregateLogData(version -> {
      int counter=0;
      LogVersionBridge bridge=channel -> channel;
      LogVersionedStoreChannel versionedStoreChannel=files.openForVersion(version);
      try (ReadableLogChannel channel=new ReadAheadLogChannel(versionedStoreChannel,bridge,1000)){
        try (PhysicalTransactionCursor<ReadableLogChannel> physicalTransactionCursor=new PhysicalTransactionCursor<>(channel,new VersionAwareLogEntryReader<>())){
          while (physicalTransactionCursor.next()) {
            counter++;
          }
        }
       }
       return counter;
    }
);
  }
}
