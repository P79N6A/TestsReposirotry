/** 
 * Ensures the absence of an issue where iterating through a  {@link RelationshipIterator} would result in{@link ArrayIndexOutOfBoundsException} due to incrementing an array index too eagerly so that a consecutivecall to  {@link RelationshipIterator#next()} would try to get the internal type iterator with a too high index.This test is probabilistic in trying to produce the issue. There's a chance this test will be unsuccessful in reproducing the issue (test being successful where it should have failed), but it will never randomly fail where it should have been successful. After the point where the issue has been fixed this test will use the full 0.5 seconds to try to reproduce it.
 */
public class ConcurrentCreateAndGetRelationshipsIT {
  @Rule public final ImpermanentDatabaseRule dbRule=new ImpermanentDatabaseRule();
  private static final RelationshipType RELTYPE=MyRelTypes.TEST;
  @Test public void tryToReproduceTheIssue() throws Exception {
    GraphDatabaseService db=dbRule.getGraphDatabaseAPI();
    CountDownLatch startSignal=new CountDownLatch(1);
    AtomicBoolean stopSignal=new AtomicBoolean();
    AtomicReference<Exception> failure=new AtomicReference<>();
    Node parentNode=createNode(db);
    Collection<Worker> workers=createWorkers(db,startSignal,stopSignal,failure,parentNode);
    startSignal.countDown();
    sleep(500);
    stopSignal.set(true);
    awaitWorkersToEnd(workers);
    if (failure.get() != null) {
      throw new Exception("A worker failed",failure.get());
    }
  }
  private void awaitWorkersToEnd(  Collection<Worker> workers) throws InterruptedException {
    for (    Worker worker : workers) {
      worker.join();
    }
  }
  private Collection<Worker> createWorkers(  GraphDatabaseService db,  CountDownLatch startSignal,  AtomicBoolean stopSignal,  AtomicReference<Exception> failure,  Node parentNode){
    Collection<Worker> workers=new ArrayList<>();
    for (int i=0; i < 2; i++) {
      workers.add(newWorker(db,startSignal,stopSignal,failure,parentNode));
    }
    return workers;
  }
  private Worker newWorker(  GraphDatabaseService db,  CountDownLatch startSignal,  AtomicBoolean stopSignal,  AtomicReference<Exception> failure,  Node parentNode){
    Worker worker=new Worker(db,startSignal,stopSignal,failure,parentNode);
    worker.start();
    return worker;
  }
  private Node createNode(  GraphDatabaseService db){
    try (Transaction tx=db.beginTx()){
      Node node=db.createNode();
      tx.success();
      return node;
    }
   }
private static class Worker extends Thread {
    private final GraphDatabaseService db;
    private final CountDownLatch startSignal;
    private final AtomicReference<Exception> failure;
    private final Node parentNode;
    private final AtomicBoolean stopSignal;
    Worker(    GraphDatabaseService db,    CountDownLatch startSignal,    AtomicBoolean stopSignal,    AtomicReference<Exception> failure,    Node parentNode){
      this.db=db;
      this.startSignal=startSignal;
      this.stopSignal=stopSignal;
      this.failure=failure;
      this.parentNode=parentNode;
    }
    @Override public void run(){
      awaitStartSignal();
      while (failure.get() == null && !stopSignal.get()) {
        try (Transaction tx=db.beginTx()){
          Iterables.count(parentNode.getRelationships(RELTYPE,OUTGOING));
          parentNode.createRelationshipTo(db.createNode(),RELTYPE);
          tx.success();
        }
 catch (        Exception e) {
          failure.compareAndSet(null,e);
        }
      }
    }
    private void awaitStartSignal(){
      try {
        startSignal.await(10,SECONDS);
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
  }
}
