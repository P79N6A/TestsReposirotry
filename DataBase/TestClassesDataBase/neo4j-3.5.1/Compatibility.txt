public abstract static class Compatibility {
  @Rule public OtherThreadRule<Void> threadA=new OtherThreadRule<>();
  @Rule public OtherThreadRule<Void> threadB=new OtherThreadRule<>();
  @Rule public OtherThreadRule<Void> threadC=new OtherThreadRule<>();
  @Rule public TestDirectory testDir=TestDirectory.testDirectory();
  protected final LockingCompatibilityTestSuite suite;
  protected Locks locks;
  protected Locks.Client clientA;
  protected Locks.Client clientB;
  protected Locks.Client clientC;
  private final Map<Locks.Client,OtherThreadRule<Void>> clientToThreadMap=new HashMap<>();
  public Compatibility(  LockingCompatibilityTestSuite suite){
    this.suite=suite;
  }
  @Before public void before(){
    this.locks=suite.createLockManager(Config.defaults(),Clocks.systemClock());
    clientA=this.locks.newClient();
    clientB=this.locks.newClient();
    clientC=this.locks.newClient();
    clientToThreadMap.put(clientA,threadA);
    clientToThreadMap.put(clientB,threadB);
    clientToThreadMap.put(clientC,threadC);
  }
  @After public void after(){
    clientA.close();
    clientB.close();
    clientC.close();
    locks.close();
    clientToThreadMap.clear();
  }
public abstract class LockCommand implements WorkerCommand<Void,Object> {
    private final OtherThreadRule<Void> thread;
    private final Locks.Client client;
    protected LockCommand(    OtherThreadRule<Void> thread,    Locks.Client client){
      this.thread=thread;
      this.client=client;
    }
    public Future<Object> call(){
      return thread.execute(this);
    }
    public Future<Object> callAndAssertWaiting(){
      Future<Object> otherThreadLock=call();
      assertThat(thread,isWaiting());
      assertFalse("Should not have acquired lock.",otherThreadLock.isDone());
      return otherThreadLock;
    }
    public Future<Object> callAndAssertNotWaiting(){
      Future<Object> run=call();
      assertNotWaiting(client,run);
      return run;
    }
    @Override public Object doWork(    Void state){
      doWork(client);
      return null;
    }
    abstract void doWork(    Locks.Client client) throws AcquireLockTimeoutException ;
    public Locks.Client client(){
      return client;
    }
  }
  protected LockCommand acquireExclusive(  final Locks.Client client,  final LockTracer tracer,  final ResourceType resourceType,  final long key){
    return new LockCommand(clientToThreadMap.get(client),client){
      @Override public void doWork(      Locks.Client client) throws AcquireLockTimeoutException {
        client.acquireExclusive(tracer,resourceType,key);
      }
    }
;
  }
  protected LockCommand acquireShared(  Locks.Client client,  final LockTracer tracer,  final ResourceType resourceType,  final long key){
    return new LockCommand(clientToThreadMap.get(client),client){
      @Override public void doWork(      Locks.Client client) throws AcquireLockTimeoutException {
        client.acquireShared(tracer,resourceType,key);
      }
    }
;
  }
  protected LockCommand release(  final Locks.Client client,  final ResourceType resourceType,  final long key){
    return new LockCommand(clientToThreadMap.get(client),client){
      @Override public void doWork(      Locks.Client client){
        client.releaseExclusive(resourceType,key);
      }
    }
;
  }
  protected void assertNotWaiting(  Locks.Client client,  Future<Object> lock){
    try {
      lock.get(5,TimeUnit.SECONDS);
    }
 catch (    ExecutionException|TimeoutException|InterruptedException e) {
      throw new RuntimeException("Waiting for lock timed out!");
    }
  }
  protected void assertWaiting(  Locks.Client client,  Future<Object> lock){
    try {
      lock.get(10,TimeUnit.MILLISECONDS);
      fail("Should be waiting.");
    }
 catch (    TimeoutException e) {
    }
catch (    ExecutionException|InterruptedException e) {
      throw new RuntimeException(e);
    }
    assertThat(clientToThreadMap.get(client),isWaiting());
  }
}
