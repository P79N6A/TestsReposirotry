public class NodeValueClientFilterTest implements IndexProgressor, NodeValueClient {
  @Rule public final RandomRule random=new RandomRule();
  private final Read read=mock(Read.class);
  private final List<Event> events=new ArrayList<>();
  private final StubNodeCursor node=new StubNodeCursor();
  private final StubPropertyCursor property=new StubPropertyCursor();
  @Test public void shouldAcceptAllNodesOnNoFilters(){
    node.withNode(17);
    NodeValueClientFilter filter=initializeFilter();
    filter.next();
    assertTrue(filter.acceptNode(17,null));
    filter.close();
    assertEvents(initialize(),Event.NEXT,new Event.Node(17,null),Event.CLOSE);
  }
  @Test public void shouldRejectNodeNotInUse(){
    NodeValueClientFilter filter=initializeFilter(IndexQuery.exists(12));
    filter.next();
    assertFalse(filter.acceptNode(17,null));
    filter.close();
    assertEvents(initialize(),Event.NEXT,Event.CLOSE);
  }
  @Test public void shouldRejectNodeWithNoProperties(){
    node.withNode(17);
    NodeValueClientFilter filter=initializeFilter(IndexQuery.exists(12));
    filter.next();
    assertFalse(filter.acceptNode(17,null));
    filter.close();
    assertEvents(initialize(),Event.NEXT,Event.CLOSE);
  }
  @Test public void shouldAcceptNodeWithMatchingProperty(){
    node.withNode(17,new long[0],genericMap(12,stringValue("hello")));
    NodeValueClientFilter filter=initializeFilter(IndexQuery.exists(12));
    filter.next();
    assertTrue(filter.acceptNode(17,null));
    filter.close();
    assertEvents(initialize(),Event.NEXT,new Event.Node(17,null),Event.CLOSE);
  }
  @Test public void shouldNotAcceptNodeWithoutMatchingProperty(){
    node.withNode(17,new long[0],genericMap(7,stringValue("wrong")));
    NodeValueClientFilter filter=initializeFilter(IndexQuery.exists(12));
    filter.next();
    assertFalse(filter.acceptNode(17,null));
    filter.close();
    assertEvents(initialize(),Event.NEXT,Event.CLOSE);
  }
  @Test public void shouldConsultProvidedAcceptingFiltersForMixOfValuesAndNoValues(){
    shouldConsultProvidedFilters(Function.identity(),true);
  }
  @Test public void shouldConsultProvidedAcceptingFiltersForNullValues(){
    shouldConsultProvidedFilters(v -> null,true);
  }
  @Test public void shouldConsultProvidedDenyingFiltersForMixOfValuesAndNoValues(){
    shouldConsultProvidedFilters(Function.identity(),false);
  }
  @Test public void shouldConsultProvidedDenyingFiltersForNullValues(){
    shouldConsultProvidedFilters(v -> null,false);
  }
  private void shouldConsultProvidedFilters(  Function<Value[],Value[]> filterValues,  boolean filterAcceptsValue){
    long nodeReference=123;
    int labelId=10;
    int slots=random.nextInt(3,8);
    IndexQuery[] filters=new IndexQuery[slots];
    Value[] actualValues=new Value[slots];
    Value[] values=new Value[slots];
    Map<Integer,Value> properties=new HashMap<>();
    int[] propertyKeyIds=new int[slots];
    int filterCount=0;
    for (int i=0; i < slots; i++) {
      actualValues[i]=random.nextValue();
      int propertyKeyId=i;
      propertyKeyIds[i]=propertyKeyId;
      if ((filterCount == 0 && i == slots - 1) || random.nextBoolean()) {
        Object filterValue=(filterAcceptsValue ? actualValues[i] : anyOtherValueThan(actualValues[i])).asObjectCopy();
        filters[i]=IndexQuery.exact(propertyKeyId,filterValue);
        filterCount++;
      }
      values[i]=random.nextBoolean() ? NO_VALUE : actualValues[i];
      properties.put(propertyKeyId,actualValues[i]);
    }
    node.withNode(nodeReference,new long[]{labelId},properties);
    NodeValueClientFilter filter=new NodeValueClientFilter(this,node,property,read,filters);
    filter.initialize(TestIndexDescriptorFactory.forLabel(labelId,propertyKeyIds),this,null,IndexOrder.NONE,true);
    boolean accepted=filter.acceptNode(nodeReference,filterValues.apply(values));
    assertEquals(filterAcceptsValue,accepted);
  }
  private Value anyOtherValueThan(  Value valueToNotReturn){
    Value candidate;
    do {
      candidate=random.nextValue();
    }
 while (candidate.eq(valueToNotReturn));
    return candidate;
  }
  private NodeValueClientFilter initializeFilter(  IndexQuery... filters){
    NodeValueClientFilter filter=new NodeValueClientFilter(this,node,property,read,filters);
    filter.initialize(TestIndexDescriptorFactory.forLabel(11),this,null,IndexOrder.NONE,true);
    return filter;
  }
  private void assertEvents(  Event... expected){
    assertEquals(Arrays.asList(expected),events);
  }
  private Event.Initialize initialize(  int... keys){
    return new Event.Initialize(this,keys);
  }
  @Override public void initialize(  IndexDescriptor descriptor,  IndexProgressor progressor,  IndexQuery[] queries,  IndexOrder indexOrder,  boolean needsValues){
    events.add(new Event.Initialize(progressor,descriptor.schema().getPropertyIds()));
  }
  @Override public boolean acceptNode(  long reference,  Value[] values){
    events.add(new Event.Node(reference,values));
    return true;
  }
  @Override public boolean needsValues(){
    return true;
  }
  @Override public boolean next(){
    events.add(Event.NEXT);
    return true;
  }
  @Override public void close(){
    events.add(Event.CLOSE);
  }
private abstract static class Event {
static class Initialize extends Event {
      final transient IndexProgressor progressor;
      final int[] keys;
      Initialize(      IndexProgressor progressor,      int[] keys){
        this.progressor=progressor;
        this.keys=keys;
      }
      @Override public String toString(){
        return "INITIALIZE(" + Arrays.toString(keys) + ")";
      }
    }
    static final Event CLOSE=new Event(){
      @Override public String toString(){
        return "CLOSE";
      }
    }
;
    static final Event NEXT=new Event(){
      @Override public String toString(){
        return "NEXT";
      }
    }
;
static class Node extends Event {
      final long reference;
      final Value[] values;
      Node(      long reference,      Value[] values){
        this.reference=reference;
        this.values=values;
      }
      @Override public String toString(){
        return "Node(" + reference + ","+ Arrays.toString(values)+ ")";
      }
    }
    @Override public final boolean equals(    Object other){
      return toString().equals(other.toString());
    }
    @Override public final int hashCode(){
      return toString().hashCode();
    }
  }
}
