public class TimedRepositoryTest {
  private final AtomicLong valueGenerator=new AtomicLong();
  private final List<Long> reapedValues=new ArrayList<>();
  private final Factory<Long> provider=valueGenerator::getAndIncrement;
  private final Consumer<Long> consumer=reapedValues::add;
  private final long timeout=100;
  private final FakeClock clock=Clocks.fakeClock();
  private final TimedRepository<Long,Long> repo=new TimedRepository<>(provider,consumer,timeout,clock);
  @Test public void shouldManageLifecycleWithNoTimeouts() throws Exception {
    repo.begin(1L);
    long acquired=repo.acquire(1L);
    repo.release(1L);
    repo.end(1L);
    assertThat(acquired,equalTo(0L));
    assertThat(reapedValues,equalTo(asList(0L)));
  }
  @Test public void shouldNotAllowOthersAccessWhenAcquired() throws Exception {
    repo.begin(1L);
    repo.acquire(1L);
    try {
      repo.acquire(1L);
      fail("Should not have been allowed access.");
    }
 catch (    ConcurrentAccessException e) {
      assertThat(e.getMessage(),equalTo("Cannot access '1', because another client is currently using it."));
    }
    repo.release(1L);
    assertThat(repo.acquire(1L),equalTo(0L));
  }
  @Test public void shouldNotAllowAccessAfterEnd() throws Exception {
    repo.begin(1L);
    repo.end(1L);
    try {
      repo.acquire(1L);
      fail("Should not have been able to acquire.");
    }
 catch (    NoSuchEntryException e) {
      assertThat(e.getMessage(),equalTo("Cannot access '1', no such entry exists."));
    }
  }
  @Test public void shouldSilentlyAllowMultipleEndings() throws Exception {
    repo.begin(1L);
    repo.end(1L);
    repo.end(1L);
  }
  @Test public void shouldNotEndImmediatelyIfEntryIsUsed() throws Exception {
    repo.begin(1L);
    repo.acquire(1L);
    repo.end(1L);
    assertTrue(reapedValues.isEmpty());
    repo.release(1L);
    assertThat(reapedValues,equalTo(asList(0L)));
  }
  @Test public void shouldNotAllowBeginningWithDuplicateKey() throws Exception {
    repo.begin(1L);
    try {
      repo.begin(1L);
      fail("Should not have been able to begin.");
    }
 catch (    ConcurrentAccessException e) {
      assertThat(e.getMessage(),containsString("Cannot begin '1', because Entry"));
      assertThat(e.getMessage(),containsString(" with that key already exists."));
    }
  }
  @Test public void shouldTimeOutUnusedEntries() throws Exception {
    repo.begin(1L);
    repo.acquire(1L);
    repo.release(1L);
    repo.run();
    assertThat(repo.acquire(1L),equalTo(0L));
    repo.release(1L);
    clock.forward(timeout + 1,MILLISECONDS);
    repo.run();
    assertThat(reapedValues,equalTo(asList(0L)));
    try {
      repo.acquire(1L);
      fail("Should not have been possible to acquire.");
    }
 catch (    NoSuchEntryException e) {
      assertThat(e.getMessage(),equalTo("Cannot access '1', no such entry exists."));
    }
  }
  @Test public void usingDuplicateKeysShouldDisposeOfPreemptiveAllocatedValue() throws Exception {
    repo.begin(1L);
    try {
      repo.begin(1L);
      fail("Should not have been able to begin.");
    }
 catch (    ConcurrentAccessException e) {
      assertThat(e.getMessage(),containsString("Cannot begin '1', because Entry"));
      assertThat(e.getMessage(),containsString(" with that key already exists."));
    }
    assertThat(reapedValues,equalTo(asList(1L)));
  }
  @Test public void shouldAllowBeginWithSameKeyAfterSessionRelease() throws Exception {
    repo.begin(1L);
    repo.acquire(1L);
    repo.release(1L);
    repo.end(1L);
    repo.begin(1L);
    assertThat(reapedValues,equalTo(asList(0L)));
  }
  @Test public void unusedEntriesSafelyAcquiredOnCleanup() throws ConcurrentAccessException, NoSuchEntryException, InterruptedException {
    CountDownReaper countDownReaper=new CountDownReaper();
    final TimedRepository<Object,Long> timedRepository=new TimedRepository<>(provider,countDownReaper,1,clock);
    ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();
    NonStoppableCleaner cleaner=new NonStoppableCleaner(timedRepository);
    try {
      singleThreadExecutor.submit(cleaner);
      long entryKey=1L;
      long iterations=100000L;
      while (entryKey++ < iterations) {
        timedRepository.begin(entryKey);
        timedRepository.acquire(entryKey);
        clock.forward(10,TimeUnit.MILLISECONDS);
        timedRepository.release(entryKey);
        timedRepository.end(entryKey);
        countDownReaper.await("Reaper should consume entry from cleaner thread or from our 'end' call. " + "If it was not consumed it mean cleaner and worker thread where not able to" + " figure out who removes entry, and block will ends up in the repo forever.",10,SECONDS);
        countDownReaper.reset();
      }
    }
  finally {
      cleaner.stop();
      singleThreadExecutor.shutdownNow();
    }
  }
private static class NonStoppableCleaner implements Runnable {
    private volatile boolean stop;
    private final TimedRepository<Object,Long> timedRepository;
    NonStoppableCleaner(    TimedRepository<Object,Long> timedRepository){
      this.timedRepository=timedRepository;
    }
    @Override public void run(){
      while (!stop) {
        timedRepository.run();
      }
    }
    public void stop(){
      stop=true;
    }
  }
private static class CountDownReaper implements Consumer<Long> {
    private volatile CountDownLatch reaperLatch;
    CountDownReaper(){
      reset();
    }
    public void reset(){
      reaperLatch=new CountDownLatch(1);
    }
    @Override public void accept(    Long aLong){
      reaperLatch.countDown();
    }
    public void await(    String message,    long timeout,    TimeUnit timeUnit) throws InterruptedException {
      if (!reaperLatch.await(timeout,timeUnit)) {
        throw new IllegalStateException(message);
      }
    }
  }
}
