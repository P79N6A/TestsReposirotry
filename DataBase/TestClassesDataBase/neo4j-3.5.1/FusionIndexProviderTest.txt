@RunWith(Parameterized.class) public class FusionIndexProviderTest {
  private static final IndexProviderDescriptor DESCRIPTOR=new IndexProviderDescriptor("test-fusion","1");
  public static final StoreIndexDescriptor AN_INDEX=IndexDescriptorFactory.forSchema(forLabel(0,0),PROVIDER_DESCRIPTOR).withId(0);
  private EnumMap<IndexSlot,IndexProvider> providers;
  private IndexProvider[] aliveProviders;
  private IndexProvider fusionIndexProvider;
  private SlotSelector slotSelector;
  private InstanceSelector<IndexProvider> instanceSelector;
  @Parameterized.Parameters(name="{0}") public static FusionVersion[] versions(){
    return new FusionVersion[]{v00,v10,v20};
  }
  @Parameterized.Parameter public static FusionVersion fusionVersion;
  @Before public void setup(){
    slotSelector=fusionVersion.slotSelector();
    setupMocks();
  }
  @Rule public RandomRule random=new RandomRule();
  private void setupMocks(){
    IndexSlot[] aliveSlots=fusionVersion.aliveSlots();
    aliveProviders=new IndexProvider[aliveSlots.length];
    providers=new EnumMap<>(IndexSlot.class);
    fill(providers,IndexProvider.EMPTY);
    for (int i=0; i < aliveSlots.length; i++) {
switch (aliveSlots[i]) {
case STRING:
        IndexProvider string=mockProvider(StringIndexProvider.class,"string");
      providers.put(STRING,string);
    aliveProviders[i]=string;
  break;
case NUMBER:
IndexProvider number=mockProvider(NumberIndexProvider.class,"number");
providers.put(NUMBER,number);
aliveProviders[i]=number;
break;
case SPATIAL:
IndexProvider spatial=mockProvider(SpatialIndexProvider.class,"spatial");
providers.put(SPATIAL,spatial);
aliveProviders[i]=spatial;
break;
case TEMPORAL:
IndexProvider temporal=mockProvider(TemporalIndexProvider.class,"temporal");
providers.put(TEMPORAL,temporal);
aliveProviders[i]=temporal;
break;
case LUCENE:
IndexProvider lucene=mockProvider(IndexProvider.class,"lucene");
providers.put(LUCENE,lucene);
aliveProviders[i]=lucene;
break;
default :
throw new RuntimeException();
}
}
fusionIndexProvider=new FusionIndexProvider(providers.get(STRING),providers.get(NUMBER),providers.get(SPATIAL),providers.get(TEMPORAL),providers.get(LUCENE),fusionVersion.slotSelector(),DESCRIPTOR,NONE,mock(FileSystemAbstraction.class),false);
instanceSelector=new InstanceSelector<>(providers);
}
private static IndexProvider mockProvider(Class<? extends IndexProvider> providerClass,String name){
IndexProvider mock=mock(providerClass);
when(mock.getProviderDescriptor()).thenReturn(new IndexProviderDescriptor(name,"1"));
return mock;
}
@Test public void mustSelectCorrectTargetForAllGivenValueCombinations(){
EnumMap<IndexSlot,Value[]> values=FusionIndexTestHelp.valuesByGroup();
Value[] allValues=FusionIndexTestHelp.allValues();
for (IndexSlot slot : IndexSlot.values()) {
Value[] group=values.get(slot);
for (Value value : group) {
IndexProvider selected=instanceSelector.select(slotSelector.selectSlot(array(value),GROUP_OF));
assertSame(orLucene(providers.get(slot)),selected);
}
}
for (Value firstValue : allValues) {
for (Value secondValue : allValues) {
IndexProvider selected=instanceSelector.select(slotSelector.selectSlot(array(firstValue,secondValue),GROUP_OF));
assertSame(providers.get(LUCENE),selected);
}
}
}
@Test public void mustCombineSamples(){
int sumIndexSize=0;
int sumUniqueValues=0;
int sumSampleSize=0;
IndexSample[] samples=new IndexSample[providers.size()];
for (int i=0; i < samples.length; i++) {
int indexSize=random.nextInt(0,1_000_000);
int uniqueValues=random.nextInt(0,1_000_000);
int sampleSize=random.nextInt(0,1_000_000);
samples[i]=new IndexSample(indexSize,uniqueValues,sampleSize);
sumIndexSize+=indexSize;
sumUniqueValues+=uniqueValues;
sumSampleSize+=sampleSize;
}
IndexSample fusionSample=FusionIndexSampler.combineSamples(Arrays.asList(samples));
assertEquals(sumIndexSize,fusionSample.indexSize());
assertEquals(sumUniqueValues,fusionSample.uniqueValues());
assertEquals(sumSampleSize,fusionSample.sampleSize());
}
@Test public void getPopulationFailureMustThrowIfNoFailure(){
IllegalStateException failure=new IllegalStateException("not failed");
for (IndexProvider provider : aliveProviders) {
when(provider.getPopulationFailure(any(StoreIndexDescriptor.class))).thenThrow(failure);
}
try {
fusionIndexProvider.getPopulationFailure(AN_INDEX);
fail("Should have failed");
}
 catch (IllegalStateException e) {
}
}
@Test public void getPopulationFailureMustReportFailureWhenAnyFailed(){
for (IndexProvider failingProvider : aliveProviders) {
String failure="failure";
IllegalStateException exception=new IllegalStateException("not failed");
for (IndexProvider provider : aliveProviders) {
if (provider == failingProvider) {
when(provider.getPopulationFailure(any(StoreIndexDescriptor.class))).thenReturn(failure);
}
 else {
when(provider.getPopulationFailure(any(StoreIndexDescriptor.class))).thenThrow(exception);
}
}
assertThat(fusionIndexProvider.getPopulationFailure(AN_INDEX),containsString(failure));
}
}
@Test public void getPopulationFailureMustReportFailureWhenMultipleFail(){
List<String> failureMessages=new ArrayList<>();
for (IndexProvider aliveProvider : aliveProviders) {
String failureMessage="FAILURE[" + aliveProvider + "]";
failureMessages.add(failureMessage);
when(aliveProvider.getPopulationFailure(any(StoreIndexDescriptor.class))).thenReturn(failureMessage);
}
String populationFailure=fusionIndexProvider.getPopulationFailure(AN_INDEX);
for (String failureMessage : failureMessages) {
assertThat(populationFailure,containsString(failureMessage));
}
}
@Test public void shouldReportFailedIfAnyIsFailed(){
IndexProvider provider=fusionIndexProvider;
for (InternalIndexState state : InternalIndexState.values()) {
for (IndexProvider failedProvider : aliveProviders) {
for (IndexProvider aliveProvider : aliveProviders) {
setInitialState(aliveProvider,failedProvider == aliveProvider ? InternalIndexState.FAILED : state);
}
InternalIndexState initialState=provider.getInitialState(AN_INDEX);
assertEquals(InternalIndexState.FAILED,initialState);
}
}
}
@Test public void shouldReportPopulatingIfAnyIsPopulating(){
for (InternalIndexState state : array(InternalIndexState.ONLINE,InternalIndexState.POPULATING)) {
for (IndexProvider populatingProvider : aliveProviders) {
for (IndexProvider aliveProvider : aliveProviders) {
setInitialState(aliveProvider,populatingProvider == aliveProvider ? InternalIndexState.POPULATING : state);
}
InternalIndexState initialState=fusionIndexProvider.getInitialState(AN_INDEX);
assertEquals(InternalIndexState.POPULATING,initialState);
}
}
}
private void setInitialState(IndexProvider mockedProvider,InternalIndexState state){
when(mockedProvider.getInitialState(any(StoreIndexDescriptor.class))).thenReturn(state);
}
private IndexProvider orLucene(IndexProvider provider){
return provider != IndexProvider.EMPTY ? provider : providers.get(LUCENE);
}
}
