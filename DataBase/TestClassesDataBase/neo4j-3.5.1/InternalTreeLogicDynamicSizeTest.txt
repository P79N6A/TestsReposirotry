public class InternalTreeLogicDynamicSizeTest extends InternalTreeLogicTestBase<RawBytes,RawBytes> {
  @Override protected ValueMerger<RawBytes,RawBytes> getAdder(){
    return (existingKey,newKey,base,add) -> {
      long baseSeed=layout.keySeed(base);
      long addSeed=layout.keySeed(add);
      return layout.value(baseSeed + addSeed);
    }
;
  }
  @Override protected TreeNode<RawBytes,RawBytes> getTreeNode(  int pageSize,  Layout<RawBytes,RawBytes> layout){
    return new TreeNodeDynamicSize<>(pageSize,layout);
  }
  @Override protected TestLayout<RawBytes,RawBytes> getLayout(){
    return new SimpleByteArrayLayout();
  }
  @Test public void shouldFailToInsertTooLargeKeys() throws IOException {
    RawBytes key=layout.newKey();
    RawBytes value=layout.newValue();
    key.bytes=new byte[node.keyValueSizeCap() + 1];
    value.bytes=new byte[0];
    shouldFailToInsertTooLargeKeyAndValue(key,value);
  }
  @Test public void shouldFailToInsertTooLargeKeyAndValueLargeKey() throws IOException {
    RawBytes key=layout.newKey();
    RawBytes value=layout.newValue();
    key.bytes=new byte[node.keyValueSizeCap()];
    value.bytes=new byte[1];
    shouldFailToInsertTooLargeKeyAndValue(key,value);
  }
  @Test public void shouldFailToInsertTooLargeKeyAndValueLargeValue() throws IOException {
    RawBytes key=layout.newKey();
    RawBytes value=layout.newValue();
    key.bytes=new byte[1];
    value.bytes=new byte[node.keyValueSizeCap()];
    shouldFailToInsertTooLargeKeyAndValue(key,value);
  }
  private void shouldFailToInsertTooLargeKeyAndValue(  RawBytes key,  RawBytes value) throws IOException {
    initialize();
    try {
      insert(key,value);
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.getMessage(),CoreMatchers.containsString("Index key-value size it to large. Please see index documentation for limitations."));
    }
  }
  @Test public void storeOnlyMinimalKeyDividerInInternal() throws IOException {
    initialize();
    long key=0;
    while (numberOfRootSplits == 0) {
      insert(key(key),value(key));
      key++;
    }
    RawBytes rawBytes=keyAt(rootId,0,INTERNAL);
    assertEquals("expected no tail on internal key but was " + rawBytes.toString(),Long.BYTES,rawBytes.bytes.length);
  }
}
