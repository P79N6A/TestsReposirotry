public class CrashGenerationCleanerCrashTest {
  @Rule public PageCacheAndDependenciesRule store=new PageCacheAndDependenciesRule();
  @Test public void mustNotLeakTasksOnCrash(){
    String exceptionMessage="When there's no more room in hell, the dead will walk the earth";
    CrashGenerationCleaner cleaner=newCrashingCrashGenerationCleaner(exceptionMessage);
    ExecutorService executorService=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    try {
      cleaner.clean(executorService);
      fail("Expected to throw");
    }
 catch (    Throwable e) {
      Throwable rootCause=Exceptions.rootCause(e);
      assertTrue(rootCause instanceof IOException);
      assertEquals(exceptionMessage,rootCause.getMessage());
    }
 finally {
      List<Runnable> tasks=executorService.shutdownNow();
      assertEquals(0,tasks.size());
    }
  }
  private CrashGenerationCleaner newCrashingCrashGenerationCleaner(  String message){
    int pageSize=8192;
    PagedFile pagedFile=new StubPagedFile(pageSize){
      AtomicBoolean first=new AtomicBoolean(true);
      @Override public PageCursor io(      long pageId,      int pf_flags) throws IOException {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
        if (first.getAndSet(false)) {
          throw new IOException(message);
        }
        return super.io(pageId,pf_flags);
      }
    }
;
    return new CrashGenerationCleaner(pagedFile,new TreeNodeFixedSize<>(pageSize,SimpleLongLayout.longLayout().build()),0,MAX_BATCH_SIZE * 1_000_000_000,5,7,NO_MONITOR);
  }
}
