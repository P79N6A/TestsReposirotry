class PooledConcurrentMergeSchedulerTest {
  private TestPooledConcurrentMergeScheduler mergeScheduler;
  private IndexWriter indexWriter=mock(IndexWriter.class);
  @BeforeEach void setUp(){
    mergeScheduler=new TestPooledConcurrentMergeScheduler();
  }
  @AfterEach void tearDown(){
    mergeScheduler.getExecutionLatch().countDown();
  }
  @Test void doNotAddMergeTaskWhenWriterDoesNotHaveMergesToDo() throws Exception {
    IndexWriter indexWriter=mock(IndexWriter.class);
    mergeScheduler.merge(indexWriter,MergeTrigger.EXPLICIT,false);
    assertEquals(0,mergeScheduler.getWriterTaskCount());
  }
  @Test void addMergeTaskWhenWriterHasOneMergeToPerform() throws IOException {
    SegmentCommitInfo segmentCommitInfo=getSegmentCommitInfo();
    Mockito.when(indexWriter.getNextMerge()).thenReturn(new TestOneMerge(segmentCommitInfo)).thenReturn(null);
    mergeScheduler.merge(indexWriter,MergeTrigger.EXPLICIT,false);
    assertEquals(1,mergeScheduler.getWriterTaskCount());
  }
  @Test void addTwoMergeTasksWhenWriterHastwoMergeToPerform() throws IOException {
    SegmentCommitInfo segmentCommitInfo=getSegmentCommitInfo();
    Mockito.when(indexWriter.getNextMerge()).thenReturn(new TestOneMerge(segmentCommitInfo)).thenReturn(new TestOneMerge(segmentCommitInfo)).thenReturn(null);
    mergeScheduler.merge(indexWriter,MergeTrigger.EXPLICIT,false);
    assertEquals(2,mergeScheduler.getWriterTaskCount());
  }
  @Test void writerCloseWaitForMergesInMergeQueue(){
    assertTimeout(Duration.ofSeconds(10),() -> {
      indexWriter=mock(IndexWriter.class);
      SegmentCommitInfo segmentCommitInfo=getSegmentCommitInfo();
      Mockito.when(indexWriter.getNextMerge()).thenReturn(new TestOneMerge(segmentCommitInfo)).thenReturn(null);
      mergeScheduler.merge(indexWriter,MergeTrigger.EXPLICIT,false);
      assertEquals(1,mergeScheduler.getWriterTaskCount());
      Thread closeSchedulerThread=ThreadTestUtils.fork(() -> mergeScheduler.close());
      ThreadTestUtils.awaitThreadState(closeSchedulerThread,TimeUnit.SECONDS.toMillis(5),Thread.State.TIMED_WAITING);
      mergeScheduler.getExecutionLatch().countDown();
      closeSchedulerThread.join();
      assertEquals(0,mergeScheduler.getWriterTaskCount());
    }
);
  }
  private static SegmentCommitInfo getSegmentCommitInfo(){
    SegmentInfo segmentInfo=new SegmentInfo(mock(Directory.class),Version.LATEST,"test",Integer.MAX_VALUE,true,mock(Codec.class),MapUtil.stringMap(),RandomUtils.nextBytes(16),MapUtil.stringMap());
    return new SegmentCommitInfo(segmentInfo,1,1L,1L,1L);
  }
private static class TestPooledConcurrentMergeScheduler extends PooledConcurrentMergeScheduler {
    private CountDownLatch executionLatch=new CountDownLatch(1);
    @Override protected synchronized MergeThread getMergeThread(    IndexWriter writer,    MergePolicy.OneMerge merge){
      return new BlockingMerge(writer,merge,executionLatch);
    }
    CountDownLatch getExecutionLatch(){
      return executionLatch;
    }
class BlockingMerge extends ConcurrentMergeScheduler.MergeThread {
      private CountDownLatch executionLatch;
      BlockingMerge(      IndexWriter writer,      MergePolicy.OneMerge merge,      CountDownLatch executionLatch){
        super(writer,merge);
        this.executionLatch=executionLatch;
      }
      @Override public void run(){
        try {
          executionLatch.await();
        }
 catch (        InterruptedException e) {
          throw new RuntimeException("Interrupted while waiting for a latch",e);
        }
      }
    }
  }
private static class TestOneMerge extends MergePolicy.OneMerge {
    TestOneMerge(    SegmentCommitInfo segmentCommitInfo){
      super(Collections.singletonList(segmentCommitInfo));
    }
  }
}
