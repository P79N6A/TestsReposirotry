public class UpdateCapturingIndexProvider extends IndexProvider {
  private final IndexProvider actual;
  private final Map<Long,UpdateCapturingIndexAccessor> indexes=new ConcurrentHashMap<>();
  private final Map<Long,Collection<IndexEntryUpdate<?>>> initialUpdates;
  UpdateCapturingIndexProvider(  IndexProvider actual,  Map<Long,Collection<IndexEntryUpdate<?>>> initialUpdates){
    super(actual);
    this.actual=actual;
    this.initialUpdates=initialUpdates;
  }
  @Override public IndexPopulator getPopulator(  StoreIndexDescriptor descriptor,  IndexSamplingConfig samplingConfig){
    return actual.getPopulator(descriptor,samplingConfig);
  }
  @Override public IndexAccessor getOnlineAccessor(  StoreIndexDescriptor descriptor,  IndexSamplingConfig samplingConfig) throws IOException {
    IndexAccessor actualAccessor=actual.getOnlineAccessor(descriptor,samplingConfig);
    return indexes.computeIfAbsent(descriptor.getId(),id -> new UpdateCapturingIndexAccessor(actualAccessor,initialUpdates.get(id)));
  }
  @Override public String getPopulationFailure(  StoreIndexDescriptor descriptor) throws IllegalStateException {
    return actual.getPopulationFailure(descriptor);
  }
  @Override public InternalIndexState getInitialState(  StoreIndexDescriptor descriptor){
    return actual.getInitialState(descriptor);
  }
  @Override public IndexCapability getCapability(  StoreIndexDescriptor descriptor){
    return actual.getCapability(descriptor);
  }
  @Override public StoreMigrationParticipant storeMigrationParticipant(  FileSystemAbstraction fs,  PageCache pageCache){
    return actual.storeMigrationParticipant(fs,pageCache);
  }
  public Map<Long,Collection<IndexEntryUpdate<?>>> snapshot(){
    Map<Long,Collection<IndexEntryUpdate<?>>> result=new HashMap<>();
    indexes.forEach((indexId,index) -> result.put(indexId,index.snapshot()));
    return result;
  }
}
