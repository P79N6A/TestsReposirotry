public class UtilsTest {
  @Test public void shouldDetectCollisions(){
    long[] first=new long[]{1,4,7,10,100,101};
    long[] other=new long[]{2,3,34,75,101};
    boolean collides=Utils.anyIdCollides(first,first.length,other,other.length);
    assertTrue(collides);
  }
  @Test public void shouldNotReportDisjointArraysAsCollision(){
    long[] first=new long[]{1,4,7,10,100,101};
    long[] other=new long[]{2,3,34,75,102};
    boolean collides=Utils.anyIdCollides(first,first.length,other,other.length);
    assertFalse(collides);
  }
  @Test public void shouldBeCorrectForSomeRandomBatches(){
    Random random=ThreadLocalRandom.current();
    long[][] batches=new long[20][];
    for (int i=0; i < batches.length; i++) {
      batches[i]=randomBatch(1_000,random,5_000_000);
    }
    for (    long[] rBatch : batches) {
      for (      long[] lBatch : batches) {
        assertEquals(actuallyCollides(rBatch,lBatch),Utils.anyIdCollides(rBatch,rBatch.length,lBatch,lBatch.length));
      }
    }
  }
  @Test public void shouldMergeIdsInto(){
    long[] values=new long[]{2,4,10,11,14};
    long[] into=new long[]{1,5,6,11,25};
    int intoLengthBefore=into.length;
    into=Arrays.copyOf(into,into.length + values.length);
    Utils.mergeSortedInto(values,into,intoLengthBefore);
    assertArrayEquals(new long[]{1,2,4,5,6,10,11,11,14,25},into);
  }
  @Test public void shouldMergeSomeRandomIdsInto(){
    Random random=ThreadLocalRandom.current();
    int batchSize=10_000;
    for (int i=0; i < 100; i++) {
      long[] values=randomBatch(batchSize,random,100_000_000);
      long[] into=randomBatch(batchSize,random,100_000_000);
      long[] expectedMergedArray=manuallyMerge(values,into);
      into=Arrays.copyOf(into,batchSize * 2);
      Utils.mergeSortedInto(values,into,batchSize);
      assertArrayEquals(expectedMergedArray,into);
    }
  }
  private long[] manuallyMerge(  long[] values,  long[] into){
    long[] all=new long[values.length + into.length];
    System.arraycopy(values,0,all,0,values.length);
    System.arraycopy(into,0,all,values.length,into.length);
    Arrays.sort(all);
    return all;
  }
  private boolean actuallyCollides(  long[] b1,  long[] b2){
    for (int i=0; i < b1.length; i++) {
      for (int j=0; j < b2.length; j++) {
        if (b1[i] == b2[j]) {
          return true;
        }
      }
    }
    return false;
  }
  private long[] randomBatch(  int length,  Random random,  int max){
    long[] result=new long[length];
    randomBatchInto(result,length,random,max);
    return result;
  }
  private void randomBatchInto(  long[] into,  int length,  Random random,  int max){
    for (int i=0; i < length; i++) {
      into[i]=random.nextInt(max);
    }
    Arrays.sort(into,0,length);
  }
}
