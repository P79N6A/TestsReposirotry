public class QueryEngineProviderTest {
  @Test public void shouldUsePickTheEngineWithLowestPriority(){
    QueryEngineProvider provider1=mock(QueryEngineProvider.class);
    QueryEngineProvider provider2=mock(QueryEngineProvider.class);
    when(provider1.enginePriority()).thenReturn(1);
    when(provider2.enginePriority()).thenReturn(2);
    Dependencies deps=new Dependencies();
    GraphDatabaseAPI graphAPI=mock(GraphDatabaseAPI.class);
    QueryExecutionEngine executionEngine=mock(QueryExecutionEngine.class);
    QueryExecutionEngine executionEngine2=mock(QueryExecutionEngine.class);
    when(provider1.createEngine(any(),any())).thenReturn(executionEngine);
    when(provider2.createEngine(any(),any())).thenReturn(executionEngine2);
    Iterable<QueryEngineProvider> providers=Iterables.asIterable(provider1,provider2);
    QueryExecutionEngine engine=QueryEngineProvider.initialize(deps,graphAPI,providers);
    assertSame(executionEngine,engine);
  }
  @Test public void shouldPickTheOneAndOnlyQueryEngineAvailable(){
    QueryEngineProvider provider=mock(QueryEngineProvider.class);
    when(provider.enginePriority()).thenReturn(1);
    Dependencies deps=new Dependencies();
    GraphDatabaseAPI graphAPI=mock(GraphDatabaseAPI.class);
    QueryExecutionEngine executionEngine=mock(QueryExecutionEngine.class);
    when(provider.createEngine(any(),any())).thenReturn(executionEngine);
    Iterable<QueryEngineProvider> providers=Iterables.asIterable(provider);
    QueryExecutionEngine engine=QueryEngineProvider.initialize(deps,graphAPI,providers);
    assertSame(executionEngine,engine);
  }
}
