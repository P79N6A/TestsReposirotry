public class NodeLabelsFieldTest {
  @ClassRule public static final PageCacheRule pageCacheRule=new PageCacheRule();
  @Rule public final EphemeralFileSystemRule fs=new EphemeralFileSystemRule();
  @Rule public final RandomRule random=new RandomRule();
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  private NeoStores neoStores;
  private NodeStore nodeStore;
  @Before public void startUp(){
    Config config=Config.defaults(GraphDatabaseSettings.label_block_size,"60");
    StoreFactory storeFactory=new StoreFactory(testDirectory.databaseLayout(),config,new DefaultIdGeneratorFactory(fs.get()),pageCacheRule.getPageCache(fs.get()),fs.get(),NullLogProvider.getInstance(),EmptyVersionContextSupplier.EMPTY);
    neoStores=storeFactory.openAllNeoStores(true);
    nodeStore=neoStores.getNodeStore();
  }
  @After public void cleanUp(){
    neoStores.close();
  }
  @Test public void shouldInlineOneLabel(){
    long labelId=10;
    NodeRecord node=nodeRecordWithInlinedLabels();
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    nodeLabels.add(labelId,null,null);
    assertEquals(inlinedLabelsLongRepresentation(labelId),node.getLabelField());
  }
  @Test public void shouldInlineOneLabelWithHighId(){
    long labelId=10000;
    NodeRecord node=nodeRecordWithInlinedLabels();
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    nodeLabels.add(labelId,null,null);
    assertEquals(inlinedLabelsLongRepresentation(labelId),node.getLabelField());
  }
  @Test public void shouldInlineTwoSmallLabels(){
    long labelId1=10;
    long labelId2=30;
    NodeRecord node=nodeRecordWithInlinedLabels(labelId1);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    nodeLabels.add(labelId2,null,null);
    assertEquals(inlinedLabelsLongRepresentation(labelId1,labelId2),node.getLabelField());
  }
  @Test public void shouldInlineThreeSmallLabels(){
    long labelId1=10;
    long labelId2=30;
    long labelId3=4095;
    NodeRecord node=nodeRecordWithInlinedLabels(labelId1,labelId2);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    nodeLabels.add(labelId3,null,null);
    assertEquals(inlinedLabelsLongRepresentation(labelId1,labelId2,labelId3),node.getLabelField());
  }
  @Test public void shouldInlineFourSmallLabels(){
    long labelId1=10;
    long labelId2=30;
    long labelId3=45;
    long labelId4=60;
    NodeRecord node=nodeRecordWithInlinedLabels(labelId1,labelId2,labelId3);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    nodeLabels.add(labelId4,null,null);
    assertEquals(inlinedLabelsLongRepresentation(labelId1,labelId2,labelId3,labelId4),node.getLabelField());
  }
  @Test public void shouldInlineFiveSmallLabels(){
    long labelId1=10;
    long labelId2=30;
    long labelId3=45;
    long labelId4=60;
    long labelId5=61;
    NodeRecord node=nodeRecordWithInlinedLabels(labelId1,labelId2,labelId3,labelId4);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    nodeLabels.add(labelId5,null,null);
    assertEquals(inlinedLabelsLongRepresentation(labelId1,labelId2,labelId3,labelId4,labelId5),node.getLabelField());
  }
  @Test public void shouldSpillOverToDynamicRecordIfExceedsInlinedSpace(){
    long labelId1=10;
    long labelId2=30;
    long labelId3=4096;
    NodeRecord node=nodeRecordWithInlinedLabels(labelId1,labelId2);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    Collection<DynamicRecord> changedDynamicRecords=nodeLabels.add(labelId3,nodeStore,nodeStore.getDynamicLabelStore());
    assertEquals(1,Iterables.count(changedDynamicRecords));
    assertEquals(dynamicLabelsLongRepresentation(changedDynamicRecords),node.getLabelField());
    assertTrue(Arrays.equals(new long[]{labelId1,labelId2,labelId3},DynamicNodeLabels.getDynamicLabelsArray(changedDynamicRecords,nodeStore.getDynamicLabelStore())));
  }
  @Test public void oneDynamicRecordShouldExtendIntoAnAdditionalIfTooManyLabels(){
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,oneByteLongs(56));
    Collection<DynamicRecord> initialRecords=node.getDynamicLabelRecords();
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    Set<DynamicRecord> changedDynamicRecords=Iterables.asSet(nodeLabels.add(1,nodeStore,nodeStore.getDynamicLabelStore()));
    assertTrue(changedDynamicRecords.containsAll(initialRecords));
    assertEquals(initialRecords.size() + 1,changedDynamicRecords.size());
  }
  @Test public void oneDynamicRecordShouldStoreItsOwner(){
    Long nodeId=24L;
    NodeRecord node=nodeRecordWithDynamicLabels(nodeId,nodeStore,oneByteLongs(56));
    Collection<DynamicRecord> initialRecords=node.getDynamicLabelRecords();
    Pair<Long,long[]> pair=DynamicNodeLabels.getDynamicLabelsArrayAndOwner(initialRecords,nodeStore.getDynamicLabelStore());
    assertEquals(nodeId,pair.first());
  }
  @Test public void twoDynamicRecordsShouldShrinkToOneWhenRemoving(){
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,oneByteLongs(57));
    Collection<DynamicRecord> initialRecords=node.getDynamicLabelRecords();
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    List<DynamicRecord> changedDynamicRecords=Iterables.addToCollection(nodeLabels.remove(255,nodeStore),new ArrayList<>());
    assertEquals(initialRecords,changedDynamicRecords);
    assertTrue(changedDynamicRecords.get(0).inUse());
    assertFalse(changedDynamicRecords.get(1).inUse());
  }
  @Test public void twoDynamicRecordsShouldShrinkToOneWhenRemovingWithoutChangingItsOwner(){
    Long nodeId=42L;
    NodeRecord node=nodeRecordWithDynamicLabels(nodeId,nodeStore,oneByteLongs(57));
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    List<DynamicRecord> changedDynamicRecords=Iterables.addToCollection(nodeLabels.remove(255,nodeStore),new ArrayList<>());
    Pair<Long,long[]> changedPair=DynamicNodeLabels.getDynamicLabelsArrayAndOwner(changedDynamicRecords,nodeStore.getDynamicLabelStore());
    assertEquals(nodeId,changedPair.first());
  }
  @Test public void oneDynamicRecordShouldShrinkIntoInlinedWhenRemoving(){
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,oneByteLongs(5));
    Collection<DynamicRecord> initialRecords=node.getDynamicLabelRecords();
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    Collection<DynamicRecord> changedDynamicRecords=Iterables.asCollection(nodeLabels.remove(255,nodeStore));
    assertEquals(initialRecords,changedDynamicRecords);
    assertFalse(Iterables.single(changedDynamicRecords).inUse());
    assertEquals(inlinedLabelsLongRepresentation(251,252,253,254),node.getLabelField());
  }
  @Test public void shouldReadIdOfDynamicRecordFromDynamicLabelsField(){
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,oneByteLongs(5));
    DynamicRecord dynamicRecord=node.getDynamicLabelRecords().iterator().next();
    long dynRecordId=NodeLabelsField.firstDynamicLabelRecordId(node.getLabelField());
    assertEquals(dynamicRecord.getId(),dynRecordId);
  }
  @Test public void shouldReadNullDynamicRecordFromInlineLabelsField(){
    NodeRecord node=nodeRecordWithInlinedLabels(23L);
    boolean isDynamicReference=NodeLabelsField.fieldPointsToDynamicRecordOfLabels(node.getLabelField());
    assertFalse(isDynamicReference);
  }
  @Test public void maximumOfSevenInlinedLabels(){
    long[] labels=new long[]{0,1,2,3,4,5,6};
    NodeRecord node=nodeRecordWithInlinedLabels(labels);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    Iterable<DynamicRecord> changedDynamicRecords=nodeLabels.add(23,nodeStore,nodeStore.getDynamicLabelStore());
    assertEquals(dynamicLabelsLongRepresentation(changedDynamicRecords),node.getLabelField());
    assertEquals(1,Iterables.count(changedDynamicRecords));
  }
  @Test public void addingAnAlreadyAddedLabelWhenLabelsAreInlinedShouldFail(){
    int labelId=1;
    NodeRecord node=nodeRecordWithInlinedLabels(labelId);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    try {
      nodeLabels.add(labelId,nodeStore,nodeStore.getDynamicLabelStore());
      fail("Should have thrown exception");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void addingAnAlreadyAddedLabelWhenLabelsAreInDynamicRecordsShouldFail(){
    long[] labels=oneByteLongs(20);
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,labels);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    try {
      nodeLabels.add(safeCastLongToInt(labels[0]),nodeStore,nodeStore.getDynamicLabelStore());
      fail("Should have thrown exception");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void removingNonExistentInlinedLabelShouldFail(){
    int labelId1=1;
    int labelId2=2;
    NodeRecord node=nodeRecordWithInlinedLabels(labelId1);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    try {
      nodeLabels.remove(labelId2,nodeStore);
      fail("Should have thrown exception");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void removingNonExistentLabelInDynamicRecordsShouldFail(){
    long[] labels=oneByteLongs(20);
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,labels);
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    try {
      nodeLabels.remove(123456,nodeStore);
      fail("Should have thrown exception");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void shouldReallocateSomeOfPreviousDynamicRecords(){
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,oneByteLongs(5));
    Set<DynamicRecord> initialRecords=Iterables.asUniqueSet(node.getDynamicLabelRecords());
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    Set<DynamicRecord> reallocatedRecords=Iterables.asUniqueSet(nodeLabels.put(fourByteLongs(100),nodeStore,nodeStore.getDynamicLabelStore()));
    assertTrue(reallocatedRecords.containsAll(initialRecords));
    assertTrue(reallocatedRecords.size() > initialRecords.size());
  }
  @Test public void shouldReallocateAllOfPreviousDynamicRecordsAndThenSome(){
    NodeRecord node=nodeRecordWithDynamicLabels(nodeStore,fourByteLongs(100));
    Set<DynamicRecord> initialRecords=Iterables.asSet(cloned(node.getDynamicLabelRecords(),DynamicRecord.class));
    NodeLabels nodeLabels=NodeLabelsField.parseLabelsField(node);
    Set<DynamicRecord> reallocatedRecords=Iterables.asUniqueSet(nodeLabels.put(fourByteLongs(5),nodeStore,nodeStore.getDynamicLabelStore()));
    assertTrue("initial:" + initialRecords + ", reallocated:"+ reallocatedRecords,initialRecords.containsAll(used(reallocatedRecords)));
    assertTrue(used(reallocatedRecords).size() < initialRecords.size());
  }
  @Test public void shouldHandleRandomAddsAndRemoves(){
    Set<Integer> key=new HashSet<>();
    NodeRecord node=new NodeRecord(0);
    node.setInUse(true);
    for (int i=0; i < 100_000; i++) {
      NodeLabels labels=NodeLabelsField.parseLabelsField(node);
      int labelId=random.nextInt(200);
      if (random.nextBoolean()) {
        if (!key.contains(labelId)) {
          labels.add(labelId,nodeStore,nodeStore.getDynamicLabelStore());
          key.add(labelId);
        }
      }
 else {
        if (key.remove(labelId)) {
          labels.remove(labelId,nodeStore);
        }
      }
    }
    NodeLabels labels=NodeLabelsField.parseLabelsField(node);
    long[] readLabelIds=labels.get(nodeStore);
    for (    long labelId : readLabelIds) {
      assertTrue("Found an unexpected label " + labelId,key.remove((int)labelId));
    }
    assertTrue(key.isEmpty());
  }
  private long dynamicLabelsLongRepresentation(  Iterable<DynamicRecord> records){
    return 0x8000000000L | Iterables.first(records).getId();
  }
  private long inlinedLabelsLongRepresentation(  long... labelIds){
    long header=(long)labelIds.length << 36;
    byte bitsPerLabel=(byte)(36 / labelIds.length);
    Bits bits=bits(5);
    for (    long labelId : labelIds) {
      bits.put(labelId,bitsPerLabel);
    }
    return header | bits.getLongs()[0];
  }
  private NodeRecord nodeRecordWithInlinedLabels(  long... labels){
    NodeRecord node=new NodeRecord(0,false,0,0);
    if (labels.length > 0) {
      node.setLabelField(inlinedLabelsLongRepresentation(labels),Collections.emptyList());
    }
    return node;
  }
  private NodeRecord nodeRecordWithDynamicLabels(  NodeStore nodeStore,  long... labels){
    return nodeRecordWithDynamicLabels(0,nodeStore,labels);
  }
  private NodeRecord nodeRecordWithDynamicLabels(  long nodeId,  NodeStore nodeStore,  long... labels){
    NodeRecord node=new NodeRecord(nodeId,false,0,0);
    Collection<DynamicRecord> initialRecords=allocateAndApply(nodeStore,node.getId(),labels);
    node.setLabelField(dynamicLabelsLongRepresentation(initialRecords),initialRecords);
    return node;
  }
  private Collection<DynamicRecord> allocateAndApply(  NodeStore nodeStore,  long nodeId,  long[] longs){
    Collection<DynamicRecord> records=DynamicNodeLabels.allocateRecordsForDynamicLabels(nodeId,longs,nodeStore.getDynamicLabelStore());
    nodeStore.updateDynamicLabelRecords(records);
    return records;
  }
  private long[] oneByteLongs(  int numberOfLongs){
    long[] result=new long[numberOfLongs];
    for (int i=0; i < numberOfLongs; i++) {
      result[i]=255 - i;
    }
    Arrays.sort(result);
    return result;
  }
  private long[] fourByteLongs(  int numberOfLongs){
    long[] result=new long[numberOfLongs];
    for (int i=0; i < numberOfLongs; i++) {
      result[i]=Integer.MAX_VALUE - i;
    }
    Arrays.sort(result);
    return result;
  }
  private Set<DynamicRecord> used(  Set<DynamicRecord> reallocatedRecords){
    Set<DynamicRecord> used=new HashSet<>();
    for (    DynamicRecord record : reallocatedRecords) {
      if (record.inUse()) {
        used.add(record);
      }
    }
    return used;
  }
  private static <T extends CloneableInPublic>Iterable<T> cloned(  Iterable<T> items,  final Class<T> itemClass){
    return Iterables.map(from -> itemClass.cast(from.clone()),items);
  }
}
