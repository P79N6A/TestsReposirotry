public class UserFunctionVisitorTest {
  @Rule public CompilationRule compilationRule=new CompilationRule();
  private ElementTestUtils elementTestUtils;
  private ElementVisitor<Stream<CompilationMessage>,Void> visitor;
  @Before public void prepare(){
    Types types=compilationRule.getTypes();
    Elements elements=compilationRule.getElements();
    elementTestUtils=new ElementTestUtils(compilationRule);
    final TypeMirrorUtils typeMirrorUtils=new TypeMirrorUtils(types,elements);
    visitor=new UserFunctionVisitor(new FunctionVisitor<>(UserFunction.class,types,elements,typeMirrorUtils,function -> CustomNameExtractor.getName(function::name,function::value),false));
  }
  @Test public void functions_with_specified_name_cannot_be_in_root_namespace(){
    Element function=elementTestUtils.findMethodElement(UserFunctionsExamples.class,"functionWithName");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getElement,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,function,"Function <in_root_namespace> cannot be defined in the root namespace. Valid name example: com.acme.my_function"));
  }
  @Test public void functions_with_specified_value_cannot_be_in_root_namespace(){
    Element function=elementTestUtils.findMethodElement(UserFunctionsExamples.class,"functionWithValue");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getElement,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,function,"Function <in_root_namespace_again> cannot be defined in the root namespace. Valid name example: com.acme.my_function"));
  }
  @Test public void functions_in_non_root_namespace_are_valid(){
    Element function=elementTestUtils.findMethodElement(UserFunctionsExamples.class,"ok");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).isEmpty();
  }
  @Test public void functions_with_unsupported_return_types_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserFunctionsExamples.class,"wrongReturnType");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getElement,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,function,"Unsupported return type <void> of function defined in " + "<org.neo4j.tooling.procedure.visitors.examples.UserFunctionsExamples#wrongReturnType>."));
  }
  @Test public void functions_with_unsupported_parameter_types_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserFunctionsExamples.class,"wrongParameterType");
    Stream<CompilationMessage> errors=visitor.visit(function);
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,"Unsupported parameter type <java.lang.Thread> of procedure|function " + "UserFunctionsExamples#wrongParameterType"));
  }
  @Test public void functions_with_non_annotated_parameters_are_invalid(){
    Element function=elementTestUtils.findMethodElement(UserFunctionsExamples.class,"missingParameterAnnotation");
    Stream<CompilationMessage> errors=visitor.visit(function);
    String errorMessage=JRE.JAVA_11.isCurrentVersion() ? "@org.neo4j.procedure.Name usage error: missing on parameter <oops>" : "@org.neo4j.procedure.Name usage error: missing on parameter <arg1>";
    assertThat(errors).hasSize(1).extracting(CompilationMessage::getCategory,CompilationMessage::getContents).contains(tuple(Diagnostic.Kind.ERROR,errorMessage));
  }
}
