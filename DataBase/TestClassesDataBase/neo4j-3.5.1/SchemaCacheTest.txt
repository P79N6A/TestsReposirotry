public class SchemaCacheTest {
  private final SchemaRule hans=newIndexRule(1,0,5);
  private final SchemaRule witch=nodePropertyExistenceConstraintRule(2,3,6);
  private final SchemaRule gretel=newIndexRule(3,0,7);
  private final ConstraintRule robot=relPropertyExistenceConstraintRule(7L,8,9);
  @Test public void should_construct_schema_cache(){
    Collection<SchemaRule> rules=asList(hans,witch,gretel,robot);
    SchemaCache cache=new SchemaCache(new ConstraintSemantics(),rules,IndexProviderMap.EMPTY);
    assertEquals(asSet(hans,gretel),Iterables.asSet(cache.indexDescriptors()));
    assertEquals(asSet(witch,robot),Iterables.asSet(cache.constraintRules()));
  }
  @Test public void addRemoveIndexes(){
    Collection<SchemaRule> rules=asList(hans,witch,gretel,robot);
    SchemaCache cache=new SchemaCache(new ConstraintSemantics(),rules,IndexProviderMap.EMPTY);
    StoreIndexDescriptor rule1=newIndexRule(10,11,12);
    StoreIndexDescriptor rule2=newIndexRule(13,14,15);
    cache.addSchemaRule(rule1);
    cache.addSchemaRule(rule2);
    cache.removeSchemaRule(hans.getId());
    cache.removeSchemaRule(witch.getId());
    assertEquals(asSet(gretel,rule1,rule2),Iterables.asSet(cache.indexDescriptors()));
    assertEquals(asSet(robot),Iterables.asSet(cache.constraintRules()));
  }
  @Test public void addSchemaRules(){
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(hans);
    cache.addSchemaRule(gretel);
    cache.addSchemaRule(witch);
    cache.addSchemaRule(robot);
    assertEquals(asSet(hans,gretel),Iterables.asSet(cache.indexDescriptors()));
    assertEquals(asSet(witch,robot),Iterables.asSet(cache.constraintRules()));
  }
  @Test public void should_list_constraints(){
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(uniquenessConstraintRule(0L,1,2,133L));
    cache.addSchemaRule(uniquenessConstraintRule(1L,3,4,133L));
    cache.addSchemaRule(relPropertyExistenceConstraintRule(2L,5,6));
    cache.addSchemaRule(nodePropertyExistenceConstraintRule(3L,7,8));
    ConstraintDescriptor unique1=uniqueForLabel(1,2);
    ConstraintDescriptor unique2=uniqueForLabel(3,4);
    ConstraintDescriptor existsRel=ConstraintDescriptorFactory.existsForRelType(5,6);
    ConstraintDescriptor existsNode=ConstraintDescriptorFactory.existsForLabel(7,8);
    assertEquals(asSet(unique1,unique2,existsRel,existsNode),asSet(cache.constraints()));
    assertEquals(asSet(unique1),asSet(cache.constraintsForLabel(1)));
    assertEquals(asSet(unique1),asSet(cache.constraintsForSchema(unique1.schema())));
    assertEquals(asSet(),asSet(cache.constraintsForSchema(forLabel(1,3))));
    assertEquals(asSet(existsRel),asSet(cache.constraintsForRelationshipType(5)));
  }
  @Test public void should_remove_constraints(){
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(uniquenessConstraintRule(0L,1,2,133L));
    cache.addSchemaRule(uniquenessConstraintRule(1L,3,4,133L));
    cache.removeSchemaRule(0L);
    ConstraintDescriptor dropped=uniqueForLabel(1,1);
    ConstraintDescriptor unique=uniqueForLabel(3,4);
    assertEquals(asSet(unique),asSet(cache.constraints()));
    assertEquals(asSet(),asSet(cache.constraintsForLabel(1)));
    assertEquals(asSet(),asSet(cache.constraintsForSchema(dropped.schema())));
  }
  @Test public void adding_constraints_should_be_idempotent(){
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(uniquenessConstraintRule(0L,1,2,133L));
    cache.addSchemaRule(uniquenessConstraintRule(0L,1,2,133L));
    assertEquals(asList(uniqueForLabel(1,2)),Iterators.asList(cache.constraints()));
  }
  @Test public void shouldResolveIndexDescriptor(){
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(newIndexRule(1L,1,2));
    cache.addSchemaRule(newIndexRule(2L,1,3));
    cache.addSchemaRule(newIndexRule(3L,2,2));
    LabelSchemaDescriptor schema=forLabel(1,3);
    IndexDescriptor descriptor=cache.indexDescriptor(schema);
    assertThat(descriptor.schema(),equalTo(schema));
  }
  @Test public void shouldReturnNullWhenNoIndexExists(){
    SchemaCache schemaCache=newSchemaCache();
    IndexDescriptor schemaIndexDescriptor=schemaCache.indexDescriptor(forLabel(1,1));
    assertNull(schemaIndexDescriptor);
  }
  @Test public void shouldListConstraintsForLabel(){
    ConstraintRule rule1=uniquenessConstraintRule(0,1,1,0);
    ConstraintRule rule2=uniquenessConstraintRule(1,2,1,0);
    ConstraintRule rule3=nodePropertyExistenceConstraintRule(2,1,2);
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(rule1);
    cache.addSchemaRule(rule2);
    cache.addSchemaRule(rule3);
    Set<ConstraintDescriptor> listed=asSet(cache.constraintsForLabel(1));
    Set<ConstraintDescriptor> expected=asSet(rule1.getConstraintDescriptor(),rule3.getConstraintDescriptor());
    assertEquals(expected,listed);
  }
  @Test public void shouldListConstraintsForSchema(){
    ConstraintRule rule1=uniquenessConstraintRule(0,1,1,0);
    ConstraintRule rule2=uniquenessConstraintRule(1,2,1,0);
    ConstraintRule rule3=nodePropertyExistenceConstraintRule(2,1,2);
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(rule1);
    cache.addSchemaRule(rule2);
    cache.addSchemaRule(rule3);
    Set<ConstraintDescriptor> listed=asSet(cache.constraintsForSchema(rule3.schema()));
    assertEquals(singleton(rule3.getConstraintDescriptor()),listed);
  }
  @Test public void shouldListConstraintsForRelationshipType(){
    ConstraintRule rule1=relPropertyExistenceConstraintRule(0,1,1);
    ConstraintRule rule2=relPropertyExistenceConstraintRule(0,2,1);
    ConstraintRule rule3=relPropertyExistenceConstraintRule(0,1,2);
    SchemaCache cache=newSchemaCache();
    cache.addSchemaRule(rule1);
    cache.addSchemaRule(rule2);
    cache.addSchemaRule(rule3);
    Set<ConstraintDescriptor> listed=asSet(cache.constraintsForRelationshipType(1));
    Set<ConstraintDescriptor> expected=asSet(rule1.getConstraintDescriptor(),rule3.getConstraintDescriptor());
    assertEquals(expected,listed);
  }
  @Test public void concurrentSchemaRuleAdd() throws Throwable {
    SchemaCache cache=newSchemaCache();
    Race race=new Race();
    int indexNumber=10;
    for (int i=0; i < indexNumber; i++) {
      int id=i;
      race.addContestant(() -> cache.addSchemaRule(newIndexRule(id,id,id)));
    }
    race.go();
    assertEquals(indexNumber,Iterables.count(cache.indexDescriptors()));
    for (int labelId=0; labelId < indexNumber; labelId++) {
      assertEquals(1,Iterators.count(cache.indexDescriptorsForLabel(labelId)));
    }
    for (int propertyId=0; propertyId < indexNumber; propertyId++) {
      assertEquals(1,Iterators.count(cache.indexesByProperty(propertyId)));
    }
  }
  @Test public void concurrentSchemaRuleRemove() throws Throwable {
    SchemaCache cache=newSchemaCache();
    int indexNumber=20;
    for (int i=0; i < indexNumber; i++) {
      cache.addSchemaRule(newIndexRule(i,i,i));
    }
    Race race=new Race();
    int numberOfDeletions=10;
    for (int i=0; i < numberOfDeletions; i++) {
      int indexId=i;
      race.addContestant(() -> cache.removeSchemaRule(indexId));
    }
    race.go();
    assertEquals(indexNumber - numberOfDeletions,Iterables.count(cache.indexDescriptors()));
    for (int labelId=numberOfDeletions; labelId < indexNumber; labelId++) {
      assertEquals(1,Iterators.count(cache.indexDescriptorsForLabel(labelId)));
    }
    for (int propertyId=numberOfDeletions; propertyId < indexNumber; propertyId++) {
      assertEquals(1,Iterators.count(cache.indexesByProperty(propertyId)));
    }
  }
  private StoreIndexDescriptor newIndexRule(  long id,  int label,  int propertyKey){
    return TestIndexDescriptorFactory.forLabel(label,propertyKey).withId(id);
  }
  private ConstraintRule nodePropertyExistenceConstraintRule(  long ruleId,  int labelId,  int propertyId){
    return constraintRule(ruleId,ConstraintDescriptorFactory.existsForLabel(labelId,propertyId));
  }
  private ConstraintRule relPropertyExistenceConstraintRule(  long ruleId,  int relTypeId,  int propertyId){
    return constraintRule(ruleId,ConstraintDescriptorFactory.existsForRelType(relTypeId,propertyId));
  }
  private ConstraintRule uniquenessConstraintRule(  long ruleId,  int labelId,  int propertyId,  long indexId){
    return constraintRule(ruleId,uniqueForLabel(labelId,propertyId),indexId);
  }
  private static SchemaCache newSchemaCache(  SchemaRule... rules){
    return new SchemaCache(new ConstraintSemantics(),(rules == null || rules.length == 0) ? Collections.emptyList() : Arrays.asList(rules),IndexProviderMap.EMPTY);
  }
private static class ConstraintSemantics extends StandardConstraintSemantics {
    @Override protected ConstraintDescriptor readNonStandardConstraint(    ConstraintRule rule,    String errorMessage){
      if (!rule.getConstraintDescriptor().enforcesPropertyExistence()) {
        throw new IllegalStateException("Unsupported constraint type: " + rule);
      }
      return rule.getConstraintDescriptor();
    }
  }
}
