public class SpatialIndexAccessorTest extends NativeIndexAccessorTests<SpatialIndexKey,NativeIndexValue> {
  private static final CoordinateReferenceSystem crs=CoordinateReferenceSystem.WGS84;
  private static final ConfiguredSpaceFillingCurveSettingsCache configuredSettings=new ConfiguredSpaceFillingCurveSettingsCache(Config.defaults());
  private SpatialIndexFiles.SpatialFile spatialFile;
  @Override NativeIndexAccessor<SpatialIndexKey,NativeIndexValue> makeAccessor() throws IOException {
    spatialFile=new SpatialIndexFiles.SpatialFile(CoordinateReferenceSystem.WGS84,configuredSettings,super.getIndexFile());
    return new SpatialIndexAccessor.PartAccessor(pageCache,fs,spatialFile.getLayoutForNewIndex(),immediate(),monitor,indexDescriptor,new StandardConfiguration());
  }
  @Override IndexCapability indexCapability(){
    return SpatialIndexProvider.CAPABILITY;
  }
  @Override protected ValueCreatorUtil<SpatialIndexKey,NativeIndexValue> createValueCreatorUtil(){
    return new SpatialValueCreatorUtil(TestIndexDescriptorFactory.forLabel(42,666).withId(0),ValueCreatorUtil.FRACTION_DUPLICATE_NON_UNIQUE);
  }
  @Override IndexLayout<SpatialIndexKey,NativeIndexValue> createLayout(){
    return new SpatialLayout(crs,configuredSettings.forCRS(crs).curve());
  }
  @Override public File getIndexFile(){
    return spatialFile.indexFile;
  }
  @Override public void shouldNotSeeFilteredEntries(){
  }
  @Test public void shouldReturnMatchingEntriesForRangePredicateWithInclusiveStartAndInclusiveEnd() throws Exception {
    IndexEntryUpdate<IndexDescriptor>[] updates=valueCreatorUtil.generateAddUpdatesFor(new Value[]{Values.pointValue(WGS84,-90,-90),Values.pointValue(WGS84,-70,-70),Values.pointValue(WGS84,-50,-50),Values.pointValue(WGS84,0,0),Values.pointValue(WGS84,50,50),Values.pointValue(WGS84,70,70),Values.pointValue(WGS84,90,90)});
    shouldReturnMatchingEntriesForRangePredicateWithInclusiveStartAndInclusiveEnd(updates);
  }
  @Override public void shouldReturnMatchingEntriesForRangePredicateWithExclusiveStartAndExclusiveEnd(){
  }
  @Override public void shouldReturnMatchingEntriesForRangePredicateWithExclusiveStartAndInclusiveEnd(){
  }
  @Override public void shouldReturnMatchingEntriesForRangePredicateWithInclusiveStartAndExclusiveEnd(){
  }
  @Override public void mustHandleNestedQueries() throws IndexEntryConflictException, IndexNotApplicableKernelException {
    IndexEntryUpdate<IndexDescriptor>[] updates=valueCreatorUtil.generateAddUpdatesFor(new Value[]{Values.pointValue(WGS84,-90,-90),Values.pointValue(WGS84,-70,-70),Values.pointValue(WGS84,-50,-50),Values.pointValue(WGS84,0,0),Values.pointValue(WGS84,50,50),Values.pointValue(WGS84,70,70),Values.pointValue(WGS84,90,90)});
    mustHandleNestedQueries(updates);
  }
  @Override public void mustHandleMultipleNestedQueries() throws Exception {
    IndexEntryUpdate<IndexDescriptor>[] updates=valueCreatorUtil.generateAddUpdatesFor(new Value[]{Values.pointValue(WGS84,-90,-90),Values.pointValue(WGS84,-70,-70),Values.pointValue(WGS84,-50,-50),Values.pointValue(WGS84,0,0),Values.pointValue(WGS84,50,50),Values.pointValue(WGS84,70,70),Values.pointValue(WGS84,90,90)});
    mustHandleMultipleNestedQueries(updates);
  }
  @Override public void shouldReturnNoEntriesForRangePredicateOutsideAnyMatch(){
  }
  @Override public void respectIndexOrder(){
  }
}
