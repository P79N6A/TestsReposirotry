@RunWith(Parameterized.class) public class BoltThrottleMaxDurationIT {
  private AssertableLogProvider logProvider;
  private EphemeralFileSystemRule fsRule=new EphemeralFileSystemRule();
  private Neo4jWithSocket server=new Neo4jWithSocket(getClass(),getTestGraphDatabaseFactory(),fsRule,getSettingsFunction());
  @Rule public RuleChain ruleChain=RuleChain.outerRule(fsRule).around(server);
  @Rule public OtherThreadRule<Void> otherThread=new OtherThreadRule<>(5,TimeUnit.MINUTES);
  @Parameterized.Parameter public Factory<TransportConnection> cf;
  private HostnamePort address;
  private TransportConnection client;
  private TransportTestUtil util;
  @Parameterized.Parameters public static Collection<Factory<TransportConnection>> transports(){
    return asList(SocketConnection::new,SecureSocketConnection::new);
  }
  protected TestGraphDatabaseFactory getTestGraphDatabaseFactory(){
    TestGraphDatabaseFactory factory=new TestGraphDatabaseFactory();
    logProvider=new AssertableLogProvider();
    factory.setInternalLogProvider(logProvider);
    return factory;
  }
  protected Consumer<Map<String,String>> getSettingsFunction(){
    return settings -> {
      settings.put(GraphDatabaseSettings.auth_enabled.name(),"false");
      settings.put(GraphDatabaseSettings.bolt_outbound_buffer_throttle_max_duration.name(),"30s");
    }
;
  }
  @Before public void setup(){
    client=cf.newInstance();
    address=server.lookupDefaultConnector();
    util=new TransportTestUtil(new Neo4jPackV1());
  }
  @After public void after() throws Exception {
    if (client != null) {
      client.disconnect();
    }
  }
  @Test public void sendingButNotReceivingClientShouldBeKilledWhenWriteThrottleMaxDurationIsReached() throws Exception {
    int numberOfRunDiscardPairs=10_000;
    String largeString=StringUtils.repeat(" ",8 * 1024);
    client.connect(address).send(util.acceptedVersions(1,0,0,0)).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap())));
    assertThat(client,eventuallyReceives(new byte[]{0,0,0,1}));
    assertThat(client,util.eventuallyReceives(msgSuccess()));
    Future sender=otherThread.execute(state -> {
      for (int i=0; i < numberOfRunDiscardPairs; i++) {
        client.send(util.chunk(new RunMessage("RETURN $data as data",ValueUtils.asMapValue(singletonMap("data",largeString))),PullAllMessage.INSTANCE));
      }
      return null;
    }
);
    try {
      otherThread.get().awaitFuture(sender);
      fail("should throw ExecutionException instead");
    }
 catch (    ExecutionException e) {
      assertThat(Exceptions.rootCause(e),instanceOf(SocketException.class));
    }
    logProvider.assertAtLeastOnce(inLog(Matchers.containsString(BoltConnection.class.getPackage().getName())).error(startsWith("Unexpected error detected in bolt session"),hasProperty("cause",matchesExceptionMessage(containsString("will be closed because the client did not consume outgoing buffers for ")))));
  }
}
