public class Neo4jTransactionalContextTest {
  private GraphDatabaseQueryService queryService;
  private KernelStatement initialStatement;
  private ThreadToStatementContextBridge txBridge;
  private ConfiguredExecutionStatistics statistics;
  @Before public void setUp(){
    setUpMocks();
  }
  @Test public void checkKernelStatementOnCheck(){
    InternalTransaction initialTransaction=mock(InternalTransaction.class,new ReturnsDeepStubs());
    Kernel kernel=mock(Kernel.class);
    ThreadToStatementContextBridge txBridge=mock(ThreadToStatementContextBridge.class);
    KernelTransaction kernelTransaction=mockTransaction(initialStatement);
    when(txBridge.getKernelTransactionBoundToThisThread(true)).thenReturn(kernelTransaction);
    Neo4jTransactionalContext transactionalContext=new Neo4jTransactionalContext(null,txBridge,null,initialTransaction,initialStatement,null,kernel);
    transactionalContext.check();
    verify(kernelTransaction).assertOpen();
  }
  @SuppressWarnings("ConstantConditions") @Test public void neverStopsExecutingQueryDuringCommitAndRestartTx(){
    KernelTransaction initialKTX=mockTransaction(initialStatement);
    InternalTransaction initialTransaction=mock(InternalTransaction.class,new ReturnsDeepStubs());
    KernelTransaction.Type transactionType=KernelTransaction.Type.implicit;
    SecurityContext securityContext=SecurityContext.AUTH_DISABLED;
    when(initialTransaction.transactionType()).thenReturn(transactionType);
    when(initialTransaction.securityContext()).thenReturn(securityContext);
    when(initialTransaction.terminationReason()).thenReturn(Optional.empty());
    QueryRegistryOperations initialQueryRegistry=mock(QueryRegistryOperations.class);
    ExecutingQuery executingQuery=mock(ExecutingQuery.class);
    PropertyContainerLocker locker=null;
    ThreadToStatementContextBridge txBridge=mock(ThreadToStatementContextBridge.class);
    Statement secondStatement=mock(Statement.class);
    KernelTransaction secondKTX=mockTransaction(secondStatement);
    InternalTransaction secondTransaction=mock(InternalTransaction.class);
    when(secondTransaction.terminationReason()).thenReturn(Optional.empty());
    QueryRegistryOperations secondQueryRegistry=mock(QueryRegistryOperations.class);
    when(executingQuery.queryText()).thenReturn("X");
    when(executingQuery.queryParameters()).thenReturn(EMPTY_MAP);
    when(initialStatement.queryRegistration()).thenReturn(initialQueryRegistry);
    when(queryService.beginTransaction(transactionType,securityContext)).thenReturn(secondTransaction);
    when(txBridge.getKernelTransactionBoundToThisThread(true)).thenReturn(initialKTX,initialKTX,secondKTX);
    when(secondStatement.queryRegistration()).thenReturn(secondQueryRegistry);
    Kernel kernel=mock(Kernel.class);
    Neo4jTransactionalContext context=new Neo4jTransactionalContext(queryService,txBridge,locker,initialTransaction,initialStatement,executingQuery,kernel);
    context.commitAndRestartTx();
    Object[] mocks={txBridge,initialTransaction,initialKTX,initialQueryRegistry,secondQueryRegistry,secondKTX};
    InOrder order=Mockito.inOrder(mocks);
    order.verify(initialTransaction).transactionType();
    order.verify(initialTransaction).securityContext();
    order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
    order.verify(initialTransaction).terminationReason();
    order.verify(initialKTX).executionStatistics();
    order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
    order.verify(txBridge).unbindTransactionFromCurrentThread();
    order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
    order.verify(secondKTX).acquireStatement();
    order.verify(secondQueryRegistry).registerExecutingQuery(executingQuery);
    order.verify(txBridge).unbindTransactionFromCurrentThread();
    order.verify(txBridge).bindTransactionToCurrentThread(initialKTX);
    order.verify(initialQueryRegistry).unregisterExecutingQuery(executingQuery);
    order.verify(initialTransaction).success();
    order.verify(initialTransaction).close();
    order.verify(txBridge).unbindTransactionFromCurrentThread();
    order.verify(txBridge).bindTransactionToCurrentThread(secondKTX);
    verifyNoMoreInteractions(mocks);
  }
  @SuppressWarnings("ConstantConditions") @Test public void rollsBackNewlyCreatedTransactionIfTerminationDetectedOnCloseDuringPeriodicCommit(){
    InternalTransaction initialTransaction=mock(InternalTransaction.class,new ReturnsDeepStubs());
    KernelTransaction.Type transactionType=KernelTransaction.Type.implicit;
    SecurityContext securityContext=SecurityContext.AUTH_DISABLED;
    when(initialTransaction.transactionType()).thenReturn(transactionType);
    when(initialTransaction.securityContext()).thenReturn(securityContext);
    when(initialTransaction.terminationReason()).thenReturn(Optional.empty());
    GraphDatabaseQueryService queryService=mock(GraphDatabaseQueryService.class);
    Statement initialStatement=mock(Statement.class);
    KernelTransaction initialKTX=mockTransaction(initialStatement);
    QueryRegistryOperations initialQueryRegistry=mock(QueryRegistryOperations.class);
    ExecutingQuery executingQuery=mock(ExecutingQuery.class);
    PropertyContainerLocker locker=new PropertyContainerLocker();
    ThreadToStatementContextBridge txBridge=mock(ThreadToStatementContextBridge.class);
    Statement secondStatement=mock(Statement.class);
    KernelTransaction secondKTX=mockTransaction(secondStatement);
    InternalTransaction secondTransaction=mock(InternalTransaction.class);
    when(secondTransaction.terminationReason()).thenReturn(Optional.empty());
    QueryRegistryOperations secondQueryRegistry=mock(QueryRegistryOperations.class);
    when(executingQuery.queryText()).thenReturn("X");
    when(executingQuery.queryParameters()).thenReturn(EMPTY_MAP);
    Mockito.doThrow(RuntimeException.class).when(initialTransaction).close();
    when(initialStatement.queryRegistration()).thenReturn(initialQueryRegistry);
    when(queryService.beginTransaction(transactionType,securityContext)).thenReturn(secondTransaction);
    when(txBridge.getKernelTransactionBoundToThisThread(true)).thenReturn(initialKTX,initialKTX,secondKTX);
    when(txBridge.get()).thenReturn(secondStatement);
    when(secondStatement.queryRegistration()).thenReturn(secondQueryRegistry);
    Kernel kernel=mock(Kernel.class);
    Neo4jTransactionalContext context=new Neo4jTransactionalContext(queryService,txBridge,locker,initialTransaction,initialStatement,executingQuery,kernel);
    try {
      context.commitAndRestartTx();
      throw new AssertionError("Expected RuntimeException to be thrown");
    }
 catch (    RuntimeException e) {
      Object[] mocks={txBridge,initialTransaction,initialQueryRegistry,initialKTX,secondQueryRegistry,secondKTX,secondTransaction};
      InOrder order=Mockito.inOrder(mocks);
      order.verify(initialTransaction).transactionType();
      order.verify(initialTransaction).securityContext();
      order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
      order.verify(initialTransaction).terminationReason();
      order.verify(initialKTX).executionStatistics();
      order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
      order.verify(txBridge).unbindTransactionFromCurrentThread();
      order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
      order.verify(secondKTX).acquireStatement();
      order.verify(secondQueryRegistry).registerExecutingQuery(executingQuery);
      order.verify(txBridge).unbindTransactionFromCurrentThread();
      order.verify(txBridge).bindTransactionToCurrentThread(initialKTX);
      order.verify(initialQueryRegistry).unregisterExecutingQuery(executingQuery);
      order.verify(initialTransaction).success();
      order.verify(initialTransaction).close();
      order.verify(txBridge).bindTransactionToCurrentThread(secondKTX);
      order.verify(secondTransaction).failure();
      order.verify(secondTransaction).close();
      order.verify(txBridge).unbindTransactionFromCurrentThread();
      verifyNoMoreInteractions(mocks);
    }
  }
  @Test public void accumulateExecutionStatisticOverCommitAndRestart(){
    InternalTransaction initialTransaction=mock(InternalTransaction.class,new ReturnsDeepStubs());
    when(initialTransaction.terminationReason()).thenReturn(Optional.empty());
    Kernel kernel=mock(Kernel.class);
    Neo4jTransactionalContext transactionalContext=new Neo4jTransactionalContext(queryService,txBridge,null,initialTransaction,initialStatement,null,kernel);
    statistics.setFaults(2);
    statistics.setHits(5);
    transactionalContext.commitAndRestartTx();
    statistics.setFaults(2);
    statistics.setHits(5);
    transactionalContext.commitAndRestartTx();
    statistics.setFaults(2);
    statistics.setHits(5);
    StatisticProvider statisticProvider=transactionalContext.kernelStatisticProvider();
    assertEquals("Expect to see accumulated number of page cache misses.",6,statisticProvider.getPageCacheMisses());
    assertEquals("Expected to see accumulated number of page cache hits.",15,statisticProvider.getPageCacheHits());
  }
  @Test public void shouldBeOpenAfterCreation(){
    InternalTransaction tx=mock(InternalTransaction.class);
    Neo4jTransactionalContext context=newContext(tx);
    assertTrue(context.isOpen());
  }
  @Test public void shouldBeTopLevelWithImplicitTx(){
    InternalTransaction tx=mock(InternalTransaction.class);
    when(tx.transactionType()).thenReturn(KernelTransaction.Type.implicit);
    Neo4jTransactionalContext context=newContext(tx);
    assertTrue(context.isTopLevelTx());
  }
  @Test public void shouldNotBeTopLevelWithExplicitTx(){
    InternalTransaction tx=mock(InternalTransaction.class);
    when(tx.transactionType()).thenReturn(KernelTransaction.Type.explicit);
    Neo4jTransactionalContext context=newContext(tx);
    assertFalse(context.isTopLevelTx());
  }
  @Test public void shouldNotCloseTransactionDuringTermination(){
    InternalTransaction tx=mock(InternalTransaction.class);
    when(tx.transactionType()).thenReturn(KernelTransaction.Type.implicit);
    Neo4jTransactionalContext context=newContext(tx);
    context.terminate();
    verify(tx).terminate();
    verify(tx,never()).close();
  }
  @Test public void shouldBePossibleToCloseAfterTermination(){
    InternalTransaction tx=mock(InternalTransaction.class);
    when(tx.transactionType()).thenReturn(KernelTransaction.Type.implicit);
    Neo4jTransactionalContext context=newContext(tx);
    context.terminate();
    verify(tx).terminate();
    verify(tx,never()).close();
    context.close(false);
    verify(tx).failure();
    verify(tx).close();
  }
  @Test public void shouldBePossibleToTerminateWithoutActiveTransaction(){
    InternalTransaction tx=mock(InternalTransaction.class);
    Neo4jTransactionalContext context=newContext(tx);
    context.close(true);
    verify(tx).success();
    verify(tx).close();
    context.terminate();
    verify(tx,never()).terminate();
  }
  @Test public void shouldThrowWhenRestartedAfterTermination(){
    MutableObject<Status> terminationReason=new MutableObject<>();
    InternalTransaction tx=mock(InternalTransaction.class);
    doAnswer(invocation -> {
      terminationReason.setValue(Status.Transaction.Terminated);
      return null;
    }
).when(tx).terminate();
    when(tx.terminationReason()).then(invocation -> Optional.ofNullable(terminationReason.getValue()));
    Neo4jTransactionalContext context=newContext(tx);
    context.terminate();
    try {
      context.commitAndRestartTx();
      fail("Exception expected");
    }
 catch (    Exception e) {
      assertThat(e,instanceOf(TransactionTerminatedException.class));
    }
  }
  @Test public void shouldThrowWhenGettingTxAfterTermination(){
    MutableObject<Status> terminationReason=new MutableObject<>();
    InternalTransaction tx=mock(InternalTransaction.class);
    doAnswer(invocation -> {
      terminationReason.setValue(Status.Transaction.Terminated);
      return null;
    }
).when(tx).terminate();
    when(tx.terminationReason()).then(invocation -> Optional.ofNullable(terminationReason.getValue()));
    Neo4jTransactionalContext context=newContext(tx);
    context.terminate();
    try {
      context.getOrBeginNewIfClosed();
      fail("Exception expected");
    }
 catch (    Exception e) {
      assertThat(e,instanceOf(TransactionTerminatedException.class));
    }
  }
  @Test public void shouldNotBePossibleToCloseMultipleTimes(){
    InternalTransaction tx=mock(InternalTransaction.class);
    Neo4jTransactionalContext context=newContext(tx);
    context.close(false);
    context.close(true);
    context.close(false);
    verify(tx).failure();
    verify(tx,never()).success();
    verify(tx).close();
  }
  private void setUpMocks(){
    queryService=mock(GraphDatabaseQueryService.class);
    DependencyResolver resolver=mock(DependencyResolver.class);
    txBridge=mock(ThreadToStatementContextBridge.class);
    initialStatement=mock(KernelStatement.class);
    statistics=new ConfiguredExecutionStatistics();
    QueryRegistryOperations queryRegistryOperations=mock(QueryRegistryOperations.class);
    InternalTransaction internalTransaction=mock(InternalTransaction.class);
    when(internalTransaction.terminationReason()).thenReturn(Optional.empty());
    when(initialStatement.queryRegistration()).thenReturn(queryRegistryOperations);
    when(queryService.getDependencyResolver()).thenReturn(resolver);
    when(resolver.resolveDependency(ThreadToStatementContextBridge.class)).thenReturn(txBridge);
    when(queryService.beginTransaction(any(),any())).thenReturn(internalTransaction);
    KernelTransaction mockTransaction=mockTransaction(initialStatement);
    when(txBridge.get()).thenReturn(initialStatement);
    when(txBridge.getKernelTransactionBoundToThisThread(true)).thenReturn(mockTransaction);
  }
  private Neo4jTransactionalContext newContext(  InternalTransaction initialTx){
    return new Neo4jTransactionalContext(queryService,txBridge,new PropertyContainerLocker(),initialTx,initialStatement,null,null);
  }
  private KernelTransaction mockTransaction(  Statement statement){
    KernelTransaction kernelTransaction=mock(KernelTransaction.class,new ReturnsDeepStubs());
    when(kernelTransaction.executionStatistics()).thenReturn(statistics);
    when(kernelTransaction.acquireStatement()).thenReturn(statement);
    return kernelTransaction;
  }
private class ConfiguredExecutionStatistics implements ExecutionStatistics {
    private long hits;
    private long faults;
    @Override public long pageHits(){
      return hits;
    }
    @Override public long pageFaults(){
      return faults;
    }
    void setHits(    long hits){
      this.hits=hits;
    }
    void setFaults(    long faults){
      this.faults=faults;
    }
  }
}
