public class CommunityLockAcquisitionTimeoutIT {
  @ClassRule public static final TestDirectory directory=TestDirectory.testDirectory();
  @Rule public final ExpectedException expectedException=ExpectedException.none();
  private final OtherThreadExecutor<Void> secondTransactionExecutor=new OtherThreadExecutor<>("transactionExecutor",null);
  private final OtherThreadExecutor<Void> clockExecutor=new OtherThreadExecutor<>("clockExecutor",null);
  private static final int TEST_TIMEOUT=5000;
  private static final String TEST_PROPERTY_NAME="a";
  private static final Label marker=Label.label("marker");
  private static final FakeClock fakeClock=Clocks.fakeClock();
  private static GraphDatabaseService database;
  @BeforeClass public static void setUp(){
    CustomClockFacadeFactory facadeFactory=new CustomClockFacadeFactory();
    database=new CustomClockTestGraphDatabaseFactory(facadeFactory).newEmbeddedDatabaseBuilder(directory.storeDir()).setConfig(GraphDatabaseSettings.lock_acquisition_timeout,"2s").setConfig("dbms.backup.enabled","false").newGraphDatabase();
    createTestNode(marker);
  }
  @AfterClass public static void tearDownClass(){
    database.shutdown();
  }
  @After public void tearDown(){
    secondTransactionExecutor.close();
    clockExecutor.close();
  }
  @Test(timeout=TEST_TIMEOUT) public void timeoutOnAcquiringExclusiveLock() throws Exception {
    expectedException.expect(new RootCauseMatcher<>(LockAcquisitionTimeoutException.class,"The transaction has been terminated. " + "Retry your operation in a new transaction, and you should see a successful result. " + "Unable to acquire lock within configured timeout (dbms.lock.acquisition.timeout). "+ "Unable to acquire lock for resource: NODE with id: 0 within 2000 millis."));
    try (Transaction ignored=database.beginTx()){
      ResourceIterator<Node> nodes=database.findNodes(marker);
      Node node=nodes.next();
      node.setProperty(TEST_PROPERTY_NAME,"b");
      Future<Void> propertySetFuture=secondTransactionExecutor.executeDontWait(state -> {
        try (Transaction transaction1=database.beginTx()){
          node.setProperty(TEST_PROPERTY_NAME,"b");
          transaction1.success();
        }
         return null;
      }
);
      secondTransactionExecutor.waitUntilWaiting(exclusiveLockWaitingPredicate());
      clockExecutor.execute((OtherThreadExecutor.WorkerCommand<Void,Void>)state -> {
        fakeClock.forward(3,TimeUnit.SECONDS);
        return null;
      }
);
      propertySetFuture.get();
      fail("Should throw termination exception.");
    }
   }
  @Test(timeout=TEST_TIMEOUT) public void timeoutOnAcquiringSharedLock() throws Exception {
    expectedException.expect(new RootCauseMatcher<>(LockAcquisitionTimeoutException.class,"The transaction has been terminated. " + "Retry your operation in a new transaction, and you should see a successful result. " + "Unable to acquire lock within configured timeout (dbms.lock.acquisition.timeout). "+ "Unable to acquire lock for resource: LABEL with id: 1 within 2000 millis."));
    try (Transaction ignored=database.beginTx()){
      Locks lockManger=getLockManager();
      lockManger.newClient().acquireExclusive(LockTracer.NONE,ResourceTypes.LABEL,1);
      Future<Void> propertySetFuture=secondTransactionExecutor.executeDontWait(state -> {
        try (Transaction nestedTransaction=database.beginTx()){
          ResourceIterator<Node> nodes=database.findNodes(marker);
          Node node=nodes.next();
          node.addLabel(Label.label("anotherLabel"));
          nestedTransaction.success();
        }
         return null;
      }
);
      secondTransactionExecutor.waitUntilWaiting(sharedLockWaitingPredicate());
      clockExecutor.execute((OtherThreadExecutor.WorkerCommand<Void,Void>)state -> {
        fakeClock.forward(3,TimeUnit.SECONDS);
        return null;
      }
);
      propertySetFuture.get();
      fail("Should throw termination exception.");
    }
   }
  protected Locks getLockManager(){
    return getDependencyResolver().resolveDependency(CommunityLockManger.class);
  }
  protected DependencyResolver getDependencyResolver(){
    return ((GraphDatabaseAPI)database).getDependencyResolver();
  }
  protected Predicate<OtherThreadExecutor.WaitDetails> exclusiveLockWaitingPredicate(){
    return waitDetails -> waitDetails.isAt(CommunityLockClient.class,"acquireExclusive");
  }
  protected Predicate<OtherThreadExecutor.WaitDetails> sharedLockWaitingPredicate(){
    return waitDetails -> waitDetails.isAt(CommunityLockClient.class,"acquireShared");
  }
  private static void createTestNode(  Label marker){
    try (Transaction transaction=database.beginTx()){
      database.createNode(marker);
      transaction.success();
    }
   }
private static class CustomClockTestGraphDatabaseFactory extends TestGraphDatabaseFactory {
    private GraphDatabaseFacadeFactory customFacadeFactory;
    CustomClockTestGraphDatabaseFactory(    GraphDatabaseFacadeFactory customFacadeFactory){
      this.customFacadeFactory=customFacadeFactory;
    }
    @Override protected GraphDatabaseBuilder.DatabaseCreator createDatabaseCreator(    File storeDir,    GraphDatabaseFactoryState state){
      return new GraphDatabaseBuilder.DatabaseCreator(){
        @Override public GraphDatabaseService newDatabase(        Config config){
          return customFacadeFactory.newFacade(storeDir,config,GraphDatabaseDependencies.newDependencies(state.databaseDependencies()));
        }
      }
;
    }
  }
private static class CustomClockFacadeFactory extends GraphDatabaseFacadeFactory {
    CustomClockFacadeFactory(){
      super(DatabaseInfo.COMMUNITY,CommunityEditionModule::new);
    }
    @Override protected PlatformModule createPlatform(    File storeDir,    Config config,    Dependencies dependencies){
      return new PlatformModule(storeDir,config,databaseInfo,dependencies){
        @Override protected SystemNanoClock createClock(){
          return fakeClock;
        }
      }
;
    }
  }
}
