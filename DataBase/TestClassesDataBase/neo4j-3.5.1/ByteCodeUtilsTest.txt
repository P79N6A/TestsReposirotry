public class ByteCodeUtilsTest {
  @Test public void shouldTranslateTypeNames(){
    assertTypeName(int.class,"I");
    assertTypeName(byte.class,"B");
    assertTypeName(short.class,"S");
    assertTypeName(char.class,"C");
    assertTypeName(float.class,"F");
    assertTypeName(double.class,"D");
    assertTypeName(boolean.class,"Z");
    assertTypeName(void.class,"V");
    assertTypeName(int[].class,"[I");
    assertTypeName(byte[].class,"[B");
    assertTypeName(short[].class,"[S");
    assertTypeName(char[].class,"[C");
    assertTypeName(float[].class,"[F");
    assertTypeName(double[].class,"[D");
    assertTypeName(boolean[].class,"[Z");
    assertTypeName(String.class,"Ljava/lang/String;");
    assertTypeName(String[].class,"[Ljava/lang/String;");
  }
  @Test public void shouldDescribeMethodWithNoParameters(){
    TypeReference owner=typeReference(ByteCodeUtilsTest.class);
    MethodDeclaration declaration=method(boolean.class,"foo").build(owner);
    String description=desc(declaration);
    assertThat(description,equalTo("()Z"));
  }
  @Test public void shouldDescribeMethodWithParameters(){
    TypeReference owner=typeReference(ByteCodeUtilsTest.class);
    MethodDeclaration declaration=method(List.class,"foo",param(String.class,"string"),param(char[].class,"chararray")).build(owner);
    String description=desc(declaration);
    assertThat(description,equalTo("(Ljava/lang/String;[C)Ljava/util/List;"));
  }
  @Test public void signatureShouldBeNullWhenNotGeneric(){
    TypeReference reference=typeReference(String.class);
    String signature=signature(reference);
    assertNull(signature);
  }
  @Test public void signatureShouldBeCorrectWhenGeneric(){
    TypeReference reference=TypeReference.parameterizedType(List.class,String.class);
    String signature=signature(reference);
    assertThat(signature,equalTo("Ljava/util/List<Ljava/lang/String;>;"));
  }
  @Test public void methodSignatureShouldBeNullWhenNotGeneric(){
    TypeReference owner=typeReference(ByteCodeUtilsTest.class);
    MethodDeclaration declaration=method(String.class,"foo",param(String.class,"string"),param(char[].class,"chararray")).build(owner);
    String signature=signature(declaration);
    assertNull(signature);
  }
  @Test public void methodSignatureShouldBeCorrectWhenGeneric(){
    TypeReference owner=typeReference(ByteCodeUtilsTest.class);
    MethodDeclaration declaration=method(TypeReference.parameterizedType(List.class,String.class),"foo",param(String.class,"string")).build(owner);
    String signature=signature(declaration);
    assertThat(signature,equalTo("(Ljava/lang/String;)Ljava/util/List<Ljava/lang/String;>;"));
  }
  @Test public void shouldHandleGenericReturnType(){
    TypeReference owner=typeReference(ByteCodeUtilsTest.class);
    MethodDeclaration declaration=MethodDeclaration.method(typeParameter("T"),"fail").parameterizedWith("T",extending(Object.class)).build(owner);
    String desc=desc(declaration);
    String signature=signature(declaration);
    assertThat(desc,equalTo("()Ljava/lang/Object;"));
    assertThat(signature,equalTo("<T:Ljava/lang/Object;>()TT;"));
  }
  @Test public void shouldHandleGenericThrows(){
    TypeReference owner=typeReference(ByteCodeUtilsTest.class);
    MethodDeclaration declaration=MethodDeclaration.method(void.class,"fail",param(TypeReference.parameterizedType(CodeGenerationTest.Thrower.class,typeParameter("E")),"thrower")).parameterizedWith("E",extending(Exception.class)).throwsException(typeParameter("E")).build(owner);
    String signature=signature(declaration);
    String[] exceptions=exceptions(declaration);
    assertThat(signature,equalTo("<E:Ljava/lang/Exception;>(Lorg/neo4j/codegen/CodeGenerationTest$Thrower<TE;>;)V^TE;"));
    assertThat(exceptions,equalTo(new String[]{"java/lang/Exception"}));
  }
  private void assertTypeName(  Class<?> type,  String expected){
    TypeReference reference=typeReference(type);
    String byteCodeName=typeName(reference);
    assertThat(byteCodeName,equalTo(expected));
  }
}
