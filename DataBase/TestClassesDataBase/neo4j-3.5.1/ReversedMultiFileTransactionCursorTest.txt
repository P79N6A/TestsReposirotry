public class ReversedMultiFileTransactionCursorTest {
  @Test public void shouldReadSingleVersionReversed() throws Exception {
    TransactionCursor cursor=new ReversedMultiFileTransactionCursor(log(5),0,start(0));
    CommittedTransactionRepresentation[] reversed=exhaust(cursor);
    assertTransactionRange(reversed,5,0);
  }
  @Test public void shouldReadMultipleVersionsReversed() throws Exception {
    TransactionCursor cursor=new ReversedMultiFileTransactionCursor(log(5,3,8),2,start(0));
    CommittedTransactionRepresentation[] reversed=exhaust(cursor);
    assertTransactionRange(reversed,5 + 3 + 8,0);
  }
  @Test public void shouldRespectStartLogPosition() throws Exception {
    TransactionCursor cursor=new ReversedMultiFileTransactionCursor(log(5,6,8),2,new LogPosition(1,LOG_HEADER_SIZE + 3));
    CommittedTransactionRepresentation[] reversed=exhaust(cursor);
    assertTransactionRange(reversed,5 + 6 + 8,5 + 3);
  }
  @Test public void shouldHandleEmptyLogsMidStream() throws Exception {
    TransactionCursor cursor=new ReversedMultiFileTransactionCursor(log(5,0,2,0,3),4,start(0));
    CommittedTransactionRepresentation[] reversed=exhaust(cursor);
    assertTransactionRange(reversed,5 + 2 + 3,0);
  }
  @Test public void shouldHandleEmptySingleLogVersion() throws Exception {
    TransactionCursor cursor=new ReversedMultiFileTransactionCursor(log(0),0,start(0));
    CommittedTransactionRepresentation[] reversed=exhaust(cursor);
    assertTransactionRange(reversed,0,0);
  }
  private void assertTransactionRange(  CommittedTransactionRepresentation[] reversed,  long highTxId,  long lowTxId){
    long expectedTxId=highTxId;
    for (    CommittedTransactionRepresentation transaction : reversed) {
      expectedTxId--;
      assertEquals(expectedTxId,transaction.getCommitEntry().getTxId());
    }
    assertEquals(lowTxId,expectedTxId);
  }
  private ThrowingFunction<LogPosition,TransactionCursor,IOException> log(  int... transactionCounts) throws IOException {
    long baseOffset=LogPosition.start(0).getByteOffset();
    @SuppressWarnings("unchecked") ThrowingFunction<LogPosition,TransactionCursor,IOException> result=mock(ThrowingFunction.class);
    AtomicLong txId=new AtomicLong(0);
    CommittedTransactionRepresentation[][] logs=new CommittedTransactionRepresentation[transactionCounts.length][];
    for (int logVersion=0; logVersion < transactionCounts.length; logVersion++) {
      logs[logVersion]=transactions(transactionCounts[logVersion],txId);
    }
    when(result.apply(any(LogPosition.class))).thenAnswer(invocation -> {
      LogPosition position=invocation.getArgument(0);
      if (position == null) {
        return null;
      }
      CommittedTransactionRepresentation[] transactions=logs[toIntExact(position.getLogVersion())];
      CommittedTransactionRepresentation[] subset=copyOfRange(transactions,toIntExact(position.getByteOffset() - baseOffset),transactions.length);
      ArrayUtil.reverse(subset);
      return given(subset);
    }
);
    return result;
  }
  private CommittedTransactionRepresentation[] transactions(  int count,  AtomicLong txId){
    CommittedTransactionRepresentation[] result=new CommittedTransactionRepresentation[count];
    for (int i=0; i < count; i++) {
      CommittedTransactionRepresentation transaction=result[i]=mock(CommittedTransactionRepresentation.class);
      LogEntryCommit commitEntry=mock(LogEntryCommit.class);
      when(commitEntry.getTxId()).thenReturn(txId.getAndIncrement());
      when(transaction.getCommitEntry()).thenReturn(commitEntry);
    }
    return result;
  }
}
