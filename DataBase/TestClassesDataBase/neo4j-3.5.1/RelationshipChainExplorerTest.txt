public class RelationshipChainExplorerTest {
  private static final int degreeTwoNodes=10;
  private final TestDirectory testDirectory=TestDirectory.testDirectory();
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @ClassRule public static PageCacheRule pageCacheRule=new PageCacheRule();
  @Rule public RuleChain ruleChain=RuleChain.outerRule(testDirectory).around(fileSystemRule);
  private StoreAccess store;
  @Before public void setupStoreAccess(){
    store=createStoreWithOneHighDegreeNodeAndSeveralDegreeTwoNodes(degreeTwoNodes);
  }
  @After public void tearDownStoreAccess(){
    store.close();
  }
  @Test public void shouldLoadAllConnectedRelationshipRecordsAndTheirFullChainsOfRelationshipRecords(){
    RecordStore<RelationshipRecord> relationshipStore=store.getRelationshipStore();
    int relationshipIdInMiddleOfChain=10;
    RecordSet<RelationshipRecord> records=new RelationshipChainExplorer(relationshipStore).exploreRelationshipRecordChainsToDepthTwo(relationshipStore.getRecord(relationshipIdInMiddleOfChain,relationshipStore.newRecord(),NORMAL));
    assertEquals(degreeTwoNodes * 2,records.size());
  }
  @Test public void shouldCopeWithAChainThatReferencesNotInUseZeroValueRecords(){
    RecordStore<RelationshipRecord> relationshipStore=store.getRelationshipStore();
    breakTheChain(relationshipStore);
    int relationshipIdInMiddleOfChain=10;
    RecordSet<RelationshipRecord> records=new RelationshipChainExplorer(relationshipStore).exploreRelationshipRecordChainsToDepthTwo(relationshipStore.getRecord(relationshipIdInMiddleOfChain,relationshipStore.newRecord(),NORMAL));
    int recordsInaccessibleBecauseOfBrokenChain=3;
    assertEquals(degreeTwoNodes * 2 - recordsInaccessibleBecauseOfBrokenChain,records.size());
  }
  private static void breakTheChain(  RecordStore<RelationshipRecord> relationshipStore){
    RelationshipRecord record=relationshipStore.getRecord(10,relationshipStore.newRecord(),NORMAL);
    long relationshipTowardsEndOfChain=record.getFirstNode();
    while (record.inUse() && !record.isFirstInFirstChain()) {
      record=relationshipStore.getRecord(relationshipTowardsEndOfChain,relationshipStore.newRecord(),FORCE);
      relationshipTowardsEndOfChain=record.getFirstPrevRel();
    }
    relationshipStore.updateRecord(new RelationshipRecord(relationshipTowardsEndOfChain,0,0,0));
  }
  enum TestRelationshipType implements RelationshipType {  CONNECTED}
  private StoreAccess createStoreWithOneHighDegreeNodeAndSeveralDegreeTwoNodes(  int nDegreeTwoNodes){
    File storeDirectory=testDirectory.databaseDir();
    GraphDatabaseService database=new TestGraphDatabaseFactory().newEmbeddedDatabaseBuilder(storeDirectory).setConfig(GraphDatabaseSettings.record_format,getRecordFormatName()).setConfig("dbms.backup.enabled","false").newGraphDatabase();
    try (Transaction transaction=database.beginTx()){
      Node denseNode=database.createNode();
      for (int i=0; i < nDegreeTwoNodes; i++) {
        Node degreeTwoNode=database.createNode();
        Node leafNode=database.createNode();
        if (i % 2 == 0) {
          denseNode.createRelationshipTo(degreeTwoNode,TestRelationshipType.CONNECTED);
        }
 else {
          degreeTwoNode.createRelationshipTo(denseNode,TestRelationshipType.CONNECTED);
        }
        degreeTwoNode.createRelationshipTo(leafNode,TestRelationshipType.CONNECTED);
      }
      transaction.success();
    }
     database.shutdown();
    PageCache pageCache=pageCacheRule.getPageCache(fileSystemRule.get());
    StoreAccess storeAccess=new StoreAccess(fileSystemRule.get(),pageCache,testDirectory.databaseLayout(),Config.defaults());
    return storeAccess.initialize();
  }
  protected String getRecordFormatName(){
    return StringUtils.EMPTY;
  }
}
