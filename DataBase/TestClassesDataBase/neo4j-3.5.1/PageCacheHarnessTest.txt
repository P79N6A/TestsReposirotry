@ExtendWith({TestDirectoryExtension.class,ProfilerExtension.class}) abstract class PageCacheHarnessTest<T extends PageCache> extends PageCacheTestSupport<T> {
  @Inject public TestDirectory directory;
  @Inject public Profiler profiler;
  @RepeatedTest(10) void readsAndWritesMustBeMutuallyConsistent(){
    assertTimeout(ofMillis(SEMI_LONG_TIMEOUT_MILLIS),() -> {
      int filePageCount=100;
      try (RandomPageCacheTestHarness harness=new RandomPageCacheTestHarness()){
        harness.disableCommands(FlushCache,FlushFile,MapFile,UnmapFile);
        harness.setCommandProbabilityFactor(ReadRecord,0.5);
        harness.setCommandProbabilityFactor(WriteRecord,0.5);
        harness.setConcurrencyLevel(8);
        harness.setFilePageCount(filePageCount);
        harness.setInitialMappedFiles(1);
        harness.setVerification(filesAreCorrectlyWrittenVerification(new StandardRecordFormat(),filePageCount));
        harness.run(SEMI_LONG_TIMEOUT_MILLIS,TimeUnit.MILLISECONDS);
      }
     }
);
  }
  @Test void concurrentPageFaultingMustNotPutInterleavedDataIntoPages(){
    assertTimeout(ofMillis(LONG_TIMEOUT_MILLIS),() -> {
      final int filePageCount=11;
      final RecordFormat recordFormat=new PageCountRecordFormat();
      try (RandomPageCacheTestHarness harness=new RandomPageCacheTestHarness()){
        harness.setConcurrencyLevel(11);
        harness.setUseAdversarialIO(false);
        harness.setCachePageCount(3);
        harness.setFilePageCount(filePageCount);
        harness.setInitialMappedFiles(1);
        harness.setCommandCount(10000);
        harness.setRecordFormat(recordFormat);
        harness.setFileSystem(fs);
        harness.useProfiler(profiler);
        harness.disableCommands(FlushCache,FlushFile,MapFile,UnmapFile,WriteRecord,WriteMulti);
        harness.setPreparation((cache,fs,filesTouched) -> {
          File file=filesTouched.iterator().next();
          try (PagedFile pf=cache.map(file,cache.pageSize());PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
            for (int pageId=0; pageId < filePageCount; pageId++) {
              cursor.next();
              recordFormat.fillWithRecords(cursor);
            }
          }
         }
);
        harness.run(LONG_TIMEOUT_MILLIS,MILLISECONDS);
      }
     }
);
  }
  @Test void concurrentFlushingMustNotPutInterleavedDataIntoFile(){
    assertTimeout(ofMillis(LONG_TIMEOUT_MILLIS),() -> {
      final RecordFormat recordFormat=new StandardRecordFormat();
      final int filePageCount=2_000;
      try (RandomPageCacheTestHarness harness=new RandomPageCacheTestHarness()){
        harness.setConcurrencyLevel(16);
        harness.setUseAdversarialIO(false);
        harness.setCachePageCount(filePageCount / 2);
        harness.setFilePageCount(filePageCount);
        harness.setInitialMappedFiles(3);
        harness.setCommandCount(15_000);
        harness.setFileSystem(fs);
        harness.disableCommands(MapFile,UnmapFile,ReadRecord,ReadMulti);
        harness.setVerification(filesAreCorrectlyWrittenVerification(recordFormat,filePageCount));
        harness.run(LONG_TIMEOUT_MILLIS,MILLISECONDS);
      }
     }
);
  }
  @Test void concurrentFlushingWithMischiefMustNotPutInterleavedDataIntoFile(){
    assertTimeout(ofMillis(LONG_TIMEOUT_MILLIS),() -> {
      final RecordFormat recordFormat=new StandardRecordFormat();
      final int filePageCount=2_000;
      try (RandomPageCacheTestHarness harness=new RandomPageCacheTestHarness()){
        harness.setConcurrencyLevel(16);
        harness.setUseAdversarialIO(true);
        harness.setMischiefRate(0.5);
        harness.setFailureRate(0.0);
        harness.setErrorRate(0.0);
        harness.setCachePageCount(filePageCount / 2);
        harness.setFilePageCount(filePageCount);
        harness.setInitialMappedFiles(3);
        harness.setCommandCount(15_000);
        harness.setFileSystem(fs);
        harness.disableCommands(MapFile,UnmapFile,ReadRecord,ReadMulti);
        harness.setVerification(filesAreCorrectlyWrittenVerification(recordFormat,filePageCount));
        harness.run(LONG_TIMEOUT_MILLIS,MILLISECONDS);
      }
     }
);
  }
  @Test void concurrentFlushingWithFailuresMustNotPutInterleavedDataIntoFile(){
    assertTimeout(ofMillis(LONG_TIMEOUT_MILLIS),() -> {
      final RecordFormat recordFormat=new StandardRecordFormat();
      final int filePageCount=2_000;
      try (RandomPageCacheTestHarness harness=new RandomPageCacheTestHarness()){
        harness.setConcurrencyLevel(16);
        harness.setUseAdversarialIO(true);
        harness.setMischiefRate(0.0);
        harness.setFailureRate(0.5);
        harness.setErrorRate(0.0);
        harness.setCachePageCount(filePageCount / 2);
        harness.setFilePageCount(filePageCount);
        harness.setInitialMappedFiles(3);
        harness.setCommandCount(15_000);
        harness.setFileSystem(fs);
        harness.disableCommands(MapFile,UnmapFile,ReadRecord,ReadMulti);
        harness.setVerification(filesAreCorrectlyWrittenVerification(recordFormat,filePageCount));
        harness.run(LONG_TIMEOUT_MILLIS,MILLISECONDS);
      }
     }
);
  }
  private Phase filesAreCorrectlyWrittenVerification(  final RecordFormat recordFormat,  final int filePageCount){
    return (cache,fs1,filesTouched) -> {
      for (      File file : filesTouched) {
        try (PagedFile pf=cache.map(file,cache.pageSize());PageCursor cursor=pf.io(0,PF_SHARED_READ_LOCK)){
          for (int pageId=0; pageId < filePageCount && cursor.next(); pageId++) {
            try {
              recordFormat.assertRecordsWrittenCorrectly(cursor);
            }
 catch (            Throwable th) {
              th.addSuppressed(new Exception("pageId = " + pageId));
              throw th;
            }
          }
        }
         try (StoreChannel channel=fs1.open(file,OpenMode.READ)){
          recordFormat.assertRecordsWrittenCorrectly(file,channel);
        }
       }
    }
;
  }
}
