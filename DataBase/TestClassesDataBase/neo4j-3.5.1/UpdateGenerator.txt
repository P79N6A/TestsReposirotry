private class UpdateGenerator implements Runnable {
  private Iterable<EntityUpdates> updates;
  UpdateGenerator(  Iterable<EntityUpdates> updates){
    this.updates=updates;
  }
  @Override public void run(){
    for (    EntityUpdates update : updates) {
      try (Transaction transaction=embeddedDatabase.beginTx()){
        Node node=embeddedDatabase.getNodeById(update.getEntityId());
        for (        int labelId : labelsNameIdMap.values()) {
          LabelSchemaDescriptor schema=SchemaDescriptorFactory.forLabel(labelId,propertyId);
          for (          IndexEntryUpdate<?> indexUpdate : update.forIndexKeys(Collections.singleton(schema))) {
switch (indexUpdate.updateMode()) {
case CHANGED:
case ADDED:
              node.addLabel(Label.label(labelsIdNameMap.get(schema.getLabelId())));
            node.setProperty(NAME_PROPERTY,indexUpdate.values()[0].asObject());
          break;
case REMOVED:
        node.addLabel(Label.label(labelsIdNameMap.get(schema.getLabelId())));
      node.delete();
    break;
default :
  throw new IllegalArgumentException(indexUpdate.updateMode().name());
}
}
}
transaction.success();
}
 }
try {
for (EntityUpdates update : updates) {
Iterable<IndexEntryUpdate<SchemaDescriptor>> entryUpdates=indexService.convertToIndexUpdates(update,EntityType.NODE);
DirectIndexUpdates directIndexUpdates=new DirectIndexUpdates(entryUpdates);
indexService.apply(directIndexUpdates);
}
}
 catch (UncheckedIOException|IndexEntryConflictException e) {
throw new RuntimeException(e);
}
}
}
