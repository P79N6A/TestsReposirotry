private static class CheckPointCollector {
  private final LogFiles logFiles;
  private final LogEntryReader<ReadableClosablePositionAwareChannel> logEntryReader;
  CheckPointCollector(  File directory,  FileSystemAbstraction fileSystem) throws IOException {
    this.logEntryReader=new VersionAwareLogEntryReader<>();
    this.logFiles=LogFilesBuilder.logFilesBasedOnlyBuilder(directory,fileSystem).withLogEntryReader(logEntryReader).build();
  }
  public List<CheckPoint> find(  long version) throws IOException {
    List<CheckPoint> checkPoints=new ArrayList<>();
    for (; version >= INITIAL_LOG_VERSION && logFiles.versionExists(version); version--) {
      LogVersionedStoreChannel channel=logFiles.openForVersion(version);
      ReadableClosablePositionAwareChannel recoveredDataChannel=new ReadAheadLogChannel(channel);
      try (LogEntryCursor cursor=new LogEntryCursor(logEntryReader,recoveredDataChannel)){
        while (cursor.next()) {
          LogEntry entry=cursor.get();
          if (entry instanceof CheckPoint) {
            checkPoints.add(entry.as());
          }
        }
      }
     }
    return checkPoints;
  }
}
