class AsyncEventsTest {
  private ExecutorService executor;
  @BeforeEach void setUp(){
    executor=Executors.newCachedThreadPool();
  }
  @AfterEach void tearDown(){
    executor.shutdown();
  }
static class Event extends AsyncEvent {
    Thread processedBy;
  }
static class EventConsumer implements Consumer<Event> {
    final BlockingQueue<Event> eventsProcessed=new LinkedBlockingQueue<>();
    @Override public void accept(    Event event){
      event.processedBy=Thread.currentThread();
      eventsProcessed.offer(event);
    }
    public Event poll(    long timeout,    TimeUnit unit) throws InterruptedException {
      return eventsProcessed.poll(timeout,unit);
    }
  }
  @Test void eventsMustBeProcessedByBackgroundThread() throws Exception {
    EventConsumer consumer=new EventConsumer();
    AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
    executor.submit(asyncEvents);
    Event firstSentEvent=new Event();
    asyncEvents.send(firstSentEvent);
    Event firstProcessedEvent=consumer.poll(10,TimeUnit.SECONDS);
    Event secondSentEvent=new Event();
    asyncEvents.send(secondSentEvent);
    Event secondProcessedEvent=consumer.poll(10,TimeUnit.SECONDS);
    asyncEvents.shutdown();
    assertThat(firstProcessedEvent,is(firstSentEvent));
    assertThat(secondProcessedEvent,is(secondSentEvent));
  }
  @Test void mustNotProcessEventInSameThreadWhenNotShutDown() throws Exception {
    EventConsumer consumer=new EventConsumer();
    AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
    executor.submit(asyncEvents);
    asyncEvents.send(new Event());
    Thread processingThread=consumer.poll(10,TimeUnit.SECONDS).processedBy;
    asyncEvents.shutdown();
    assertThat(processingThread,is(not(Thread.currentThread())));
  }
  @Test void mustProcessEventsDirectlyWhenShutDown(){
    assertTimeout(ofSeconds(10),() -> {
      EventConsumer consumer=new EventConsumer();
      AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
      executor.submit(asyncEvents);
      asyncEvents.send(new Event());
      Thread threadForFirstEvent=consumer.poll(10,TimeUnit.SECONDS).processedBy;
      asyncEvents.shutdown();
      assertThat(threadForFirstEvent,is(not(Thread.currentThread())));
      Thread threadForSubsequentEvents;
      do {
        asyncEvents.send(new Event());
        threadForSubsequentEvents=consumer.poll(10,TimeUnit.SECONDS).processedBy;
      }
 while (threadForSubsequentEvents != Thread.currentThread());
    }
);
  }
  @Test void concurrentlyPublishedEventsMustAllBeProcessed(){
    assertTimeout(ofSeconds(10),() -> {
      EventConsumer consumer=new EventConsumer();
      final CountDownLatch startLatch=new CountDownLatch(1);
      final int threads=10;
      final int iterations=2_000;
      final AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
      executor.submit(asyncEvents);
      ExecutorService threadPool=Executors.newFixedThreadPool(threads);
      Runnable runner=() -> {
        try {
          startLatch.await();
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
        for (int i=0; i < iterations; i++) {
          asyncEvents.send(new Event());
        }
      }
;
      for (int i=0; i < threads; i++) {
        threadPool.submit(runner);
      }
      startLatch.countDown();
      Thread thisThread=Thread.currentThread();
      int eventCount=threads * iterations;
      try {
        for (int i=0; i < eventCount; i++) {
          Event event=consumer.poll(1,TimeUnit.SECONDS);
          if (event == null) {
            i--;
          }
 else {
            assertThat(event.processedBy,is(not(thisThread)));
          }
        }
      }
  finally {
        asyncEvents.shutdown();
      }
    }
);
  }
  @Test void awaitingShutdownMustBlockUntilAllMessagesHaveBeenProcessed() throws Exception {
    final Event specialShutdownObservedEvent=new Event();
    final CountDownLatch awaitStartLatch=new CountDownLatch(1);
    final EventConsumer consumer=new EventConsumer();
    final AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
    executor.submit(asyncEvents);
    do {
      asyncEvents.send(new Event());
    }
 while (consumer.eventsProcessed.take().processedBy == Thread.currentThread());
    Future<?> awaitShutdownFuture=executor.submit(() -> {
      awaitStartLatch.countDown();
      asyncEvents.awaitTermination();
      consumer.eventsProcessed.offer(specialShutdownObservedEvent);
    }
);
    awaitStartLatch.await();
    asyncEvents.send(new Event());
    asyncEvents.send(new Event());
    asyncEvents.send(new Event());
    asyncEvents.send(new Event());
    asyncEvents.send(new Event());
    assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
    assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
    assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
    assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
    assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
    assertThat(consumer.eventsProcessed.poll(20,TimeUnit.MILLISECONDS),is(nullValue()));
    asyncEvents.shutdown();
    awaitShutdownFuture.get();
    assertThat(consumer.eventsProcessed.take(),sameInstance(specialShutdownObservedEvent));
  }
}
