public class ReferencesTest {
  private static long MAX_ID_LIMIT=1L << 50;
  @Test public void shouldPreserveNoId(){
    assertThat(RelationshipReferenceEncoding.encodeForFiltering(NO_ID),equalTo((long)NO_ID));
    assertThat(RelationshipReferenceEncoding.encodeForTxStateFiltering(NO_ID),equalTo((long)NO_ID));
    assertThat(RelationshipReferenceEncoding.encodeGroup(NO_ID),equalTo((long)NO_ID));
    assertThat(RelationshipReferenceEncoding.encodeNoIncomingRels(NO_ID),equalTo((long)NO_ID));
    assertThat(RelationshipReferenceEncoding.encodeNoOutgoingRels(NO_ID),equalTo((long)NO_ID));
    assertThat(RelationshipReferenceEncoding.encodeNoLoopRels(NO_ID),equalTo((long)NO_ID));
    assertThat(GroupReferenceEncoding.encodeRelationship(NO_ID),equalTo((long)NO_ID));
  }
  @Test public void shouldClearFlags(){
    ThreadLocalRandom random=ThreadLocalRandom.current();
    for (int i=0; i < 1000; i++) {
      long reference=random.nextLong(MAX_ID_LIMIT);
      int token=random.nextInt(Integer.MAX_VALUE);
      assertThat(clearEncoding(RelationshipReferenceEncoding.encodeGroup(reference)),equalTo(reference));
      assertThat(clearEncoding(RelationshipReferenceEncoding.encodeForFiltering(reference)),equalTo(reference));
      assertThat(clearEncoding(RelationshipReferenceEncoding.encodeForTxStateFiltering(reference)),equalTo(reference));
      assertThat(clearEncoding(RelationshipReferenceEncoding.encodeNoIncomingRels(token)),equalTo((long)token));
      assertThat(clearEncoding(RelationshipReferenceEncoding.encodeNoOutgoingRels(token)),equalTo((long)token));
      assertThat(clearEncoding(RelationshipReferenceEncoding.encodeNoLoopRels(token)),equalTo((long)token));
      assertThat(clearEncoding(GroupReferenceEncoding.encodeRelationship(reference)),equalTo(reference));
    }
  }
  @Test public void encodeForFiltering(){
    ThreadLocalRandom random=ThreadLocalRandom.current();
    for (int i=0; i < 1000; i++) {
      long reference=random.nextLong(MAX_ID_LIMIT);
      assertNotEquals(FILTER,parseEncoding(reference));
      assertEquals(FILTER,parseEncoding(RelationshipReferenceEncoding.encodeForFiltering(reference)));
      assertTrue("encoded reference is negative",RelationshipReferenceEncoding.encodeForFiltering(reference) < 0);
    }
  }
  @Test public void encodeForTxStateFiltering(){
    ThreadLocalRandom random=ThreadLocalRandom.current();
    for (int i=0; i < 1000; i++) {
      long reference=random.nextLong(MAX_ID_LIMIT);
      assertNotEquals(FILTER_TX_STATE,parseEncoding(reference));
      assertEquals(FILTER_TX_STATE,parseEncoding(RelationshipReferenceEncoding.encodeForTxStateFiltering(reference)));
      assertTrue("encoded reference is negative",RelationshipReferenceEncoding.encodeForTxStateFiltering(reference) < 0);
    }
  }
  @Test public void encodeFromGroup(){
    ThreadLocalRandom random=ThreadLocalRandom.current();
    for (int i=0; i < 1000; i++) {
      long reference=random.nextLong(MAX_ID_LIMIT);
      assertNotEquals(GROUP,parseEncoding(reference));
      assertEquals(GROUP,parseEncoding(RelationshipReferenceEncoding.encodeGroup(reference)));
      assertTrue("encoded reference is negative",RelationshipReferenceEncoding.encodeGroup(reference) < 0);
    }
  }
  @Test public void encodeNoIncomingRels(){
    ThreadLocalRandom random=ThreadLocalRandom.current();
    for (int i=0; i < 1000; i++) {
      int token=random.nextInt(Integer.MAX_VALUE);
      assertNotEquals(NO_INCOMING_OF_TYPE,parseEncoding(token));
      assertEquals(NO_INCOMING_OF_TYPE,parseEncoding(RelationshipReferenceEncoding.encodeNoIncomingRels(token)));
      assertTrue("encoded reference is negative",RelationshipReferenceEncoding.encodeNoIncomingRels(token) < 0);
    }
  }
  @Test public void encodeNoOutgoingRels(){
    ThreadLocalRandom random=ThreadLocalRandom.current();
    for (int i=0; i < 1000; i++) {
      int token=random.nextInt(Integer.MAX_VALUE);
      assertNotEquals(NO_OUTGOING_OF_TYPE,parseEncoding(token));
      assertEquals(NO_OUTGOING_OF_TYPE,parseEncoding(RelationshipReferenceEncoding.encodeNoOutgoingRels(token)));
      assertTrue("encoded reference is negative",RelationshipReferenceEncoding.encodeNoOutgoingRels(token) < 0);
    }
  }
  @Test public void encodeNoLoopRels(){
    ThreadLocalRandom random=ThreadLocalRandom.current();
    for (int i=0; i < 1000; i++) {
      int token=random.nextInt(Integer.MAX_VALUE);
      assertNotEquals(NO_LOOP_OF_TYPE,parseEncoding(token));
      assertEquals(NO_LOOP_OF_TYPE,parseEncoding(RelationshipReferenceEncoding.encodeNoLoopRels(token)));
      assertTrue("encoded reference is negative",RelationshipReferenceEncoding.encodeNoLoopRels(token) < 0);
    }
  }
}
