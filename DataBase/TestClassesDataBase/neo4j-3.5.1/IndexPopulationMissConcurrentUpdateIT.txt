public class IndexPopulationMissConcurrentUpdateIT {
  private static final String NAME_PROPERTY="name";
  private static final long INITIAL_CREATION_NODE_ID_THRESHOLD=30;
  private static final long SCAN_BARRIER_NODE_ID_THRESHOLD=10;
  private final ControlledSchemaIndexProvider index=new ControlledSchemaIndexProvider();
  @Rule public final DatabaseRule db=new ImpermanentDatabaseRule(){
    @Override protected GraphDatabaseFactory newFactory(){
      TestGraphDatabaseFactory factory=new TestGraphDatabaseFactory();
      return factory.addKernelExtension(index);
    }
  }
.withSetting(GraphDatabaseSettings.multi_threaded_schema_index_population_enabled,Settings.FALSE).withSetting(GraphDatabaseSettings.default_schema_provider,ControlledSchemaIndexProvider.INDEX_PROVIDER.name());
  @Before public void setFeatureToggle(){
    FeatureToggles.set(MultipleIndexPopulator.class,BATCH_SIZE_NAME,1);
    FeatureToggles.set(BatchingMultipleIndexPopulator.class,BATCH_SIZE_NAME,1);
    FeatureToggles.set(MultipleIndexPopulator.class,QUEUE_THRESHOLD_NAME,1);
    FeatureToggles.set(BatchingMultipleIndexPopulator.class,QUEUE_THRESHOLD_NAME,1);
  }
  @After public void resetFeatureToggle(){
    FeatureToggles.clear(MultipleIndexPopulator.class,BATCH_SIZE_NAME);
    FeatureToggles.clear(BatchingMultipleIndexPopulator.class,BATCH_SIZE_NAME);
    FeatureToggles.clear(MultipleIndexPopulator.class,QUEUE_THRESHOLD_NAME);
    FeatureToggles.clear(BatchingMultipleIndexPopulator.class,QUEUE_THRESHOLD_NAME);
  }
  /** 
 * Tests an issue where the  {@link MultipleIndexPopulator} had a condition when applying external concurrent updates that any givenupdate would only be applied if the entity id was lower than the highest entity id the scan had seen (i.e. where the scan was currently at). This would be a problem because of how the  {@link LabelScanReader} works internally, which is that it reads one bit-set of node idsat the time, effectively caching a small range of ids. If a concurrent creation would happen right in front of where the scan was after it had read and cached that bit-set it would not apply the update and miss that entity in the scan and would end up with an index that was inconsistent with the store.
 */
  @Test(timeout=60_000) public void shouldNoticeConcurrentUpdatesWithinCurrentLabelIndexEntryRange() throws Exception {
    List<Node> nodes=new ArrayList<>();
    int nextId=0;
    try (Transaction tx=db.beginTx()){
      Node node;
      do {
        node=db.createNode(LABEL_ONE);
        node.setProperty(NAME_PROPERTY,"Node " + nextId++);
        nodes.add(node);
      }
 while (node.getId() < INITIAL_CREATION_NODE_ID_THRESHOLD);
      tx.success();
    }
     assertThat("At least one node below the scan barrier threshold must have been created, otherwise test assumptions are invalid or outdated",count(filter(n -> n.getId() <= SCAN_BARRIER_NODE_ID_THRESHOLD,nodes)),greaterThan(0L));
    assertThat("At least two nodes above the scan barrier threshold and below initial creation threshold must have been created, " + "otherwise test assumptions are invalid or outdated",count(filter(n -> n.getId() > SCAN_BARRIER_NODE_ID_THRESHOLD,nodes)),greaterThan(1L));
    db.getDependencyResolver().resolveDependency(IdController.class).maintenance();
    try (Transaction tx=db.beginTx()){
      db.schema().indexFor(LABEL_ONE).on(NAME_PROPERTY).create();
      tx.success();
    }
     index.barrier.await();
    try (Transaction tx=db.beginTx()){
      Node node;
      do {
        node=db.createNode(LABEL_ONE);
        node.setProperty(NAME_PROPERTY,nextId++);
        nodes.add(node);
      }
 while (node.getId() < index.populationAtId);
      tx.success();
    }
     index.barrier.release();
    try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(1,MINUTES);
      tx.success();
    }
     assertEquals(nodes.size(),index.entitiesByScan.size() + index.entitiesByUpdater.size());
    try (Transaction tx=db.beginTx()){
      for (      Node node : db.getAllNodes()) {
        assertTrue(index.entitiesByScan.contains(node.getId()) || index.entitiesByUpdater.contains(node.getId()));
      }
      tx.success();
    }
   }
  /** 
 * A very specific  {@link IndexProvider} which can be paused and continued at juuust the right places.
 */
private static class ControlledSchemaIndexProvider extends KernelExtensionFactory<Supplier> {
    private final Barrier.Control barrier=new Barrier.Control();
    private final Set<Long> entitiesByScan=new ConcurrentSkipListSet<>();
    private final Set<Long> entitiesByUpdater=new ConcurrentSkipListSet<>();
    private volatile long populationAtId;
    static IndexProviderDescriptor INDEX_PROVIDER=new IndexProviderDescriptor("controlled","1");
    ControlledSchemaIndexProvider(){
      super(ExtensionType.DATABASE,"controlled");
    }
    @Override public Lifecycle newInstance(    KernelContext context,    Supplier noDependencies){
      return new IndexProvider(INDEX_PROVIDER,directoriesByProvider(new File("not-even-persistent"))){
        @Override public IndexPopulator getPopulator(        StoreIndexDescriptor descriptor,        IndexSamplingConfig samplingConfig){
          return new IndexPopulator(){
            @Override public void create(){
            }
            @Override public void drop(){
            }
            @Override public void add(            Collection<? extends IndexEntryUpdate<?>> updates){
              for (              IndexEntryUpdate<?> update : updates) {
                boolean added=entitiesByScan.add(update.getEntityId());
                assertTrue(added);
                if (update.getEntityId() > SCAN_BARRIER_NODE_ID_THRESHOLD) {
                  populationAtId=update.getEntityId();
                  barrier.reached();
                }
              }
            }
            @Override public void verifyDeferredConstraints(            NodePropertyAccessor nodePropertyAccessor){
            }
            @Override public IndexUpdater newPopulatingUpdater(            NodePropertyAccessor nodePropertyAccessor){
              return new IndexUpdater(){
                @Override public void process(                IndexEntryUpdate<?> update){
                  boolean added=entitiesByUpdater.add(update.getEntityId());
                  assertTrue(added);
                }
                @Override public void close(){
                }
              }
;
            }
            @Override public void close(            boolean populationCompletedSuccessfully){
              assertTrue(populationCompletedSuccessfully);
            }
            @Override public void markAsFailed(            String failure){
              throw new UnsupportedOperationException();
            }
            @Override public void includeSample(            IndexEntryUpdate<?> update){
            }
            @Override public IndexSample sampleResult(){
              return new IndexSample(0,0,0);
            }
          }
;
        }
        @Override public IndexAccessor getOnlineAccessor(        StoreIndexDescriptor descriptor,        IndexSamplingConfig samplingConfig){
          return mock(IndexAccessor.class);
        }
        @Override public String getPopulationFailure(        StoreIndexDescriptor descriptor){
          throw new IllegalStateException();
        }
        @Override public InternalIndexState getInitialState(        StoreIndexDescriptor descriptor){
          return POPULATING;
        }
        @Override public IndexCapability getCapability(        StoreIndexDescriptor descriptor){
          return IndexCapability.NO_CAPABILITY;
        }
        @Override public StoreMigrationParticipant storeMigrationParticipant(        FileSystemAbstraction fs,        PageCache pageCache){
          return NOT_PARTICIPATING;
        }
      }
;
    }
  }
}
