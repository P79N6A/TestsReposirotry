public class PhysicalLogCommandReadersTest {
  private static final long ID=42;
  private static final byte IN_USE_FLAG=Record.IN_USE.byteValue();
  private static final short TYPE=(short)(Short.MAX_VALUE + 42);
  private static final int TYPE_AS_INT=TYPE & 0xFFFF;
  private static final long NEXT=42;
  private static final long FIRST_OUT=42;
  private static final long FIRST_IN=42;
  private static final long FIRST_LOOP=42;
  private static final long OWNING_NODE=42;
  @Test public void readRelGroupWithHugeTypeInV2_2_4() throws IOException {
    assertCanReadRelGroup(new PhysicalLogCommandReaderV2_2_4());
  }
  @Test public void readRelGroupWithHugeTypeInV2_2_10() throws IOException {
    assertCanReadRelGroup(new PhysicalLogCommandReaderV2_2_10());
  }
  @Test public void readRelGroupWithHugeTypeInV3_0() throws IOException {
    assertCanReadRelGroup(new PhysicalLogCommandReaderV3_0());
  }
  @Test public void readRelGroupWithHugeTypeInV3_0_2() throws IOException {
    assertCanReadRelGroup(new PhysicalLogCommandReaderV3_0_2());
  }
  private static void assertDoesNotKnowAboutRelGroups(  CommandReader reader){
    try {
      reader.read(channelWithRelGroupRecord());
      fail("Exception expected");
    }
 catch (    IOException e) {
      assertEquals("Unknown command type[" + NeoCommandType.REL_GROUP_COMMAND + "]",e.getMessage());
    }
  }
  private void assertCanReadRelGroup(  CommandReader reader) throws IOException {
    StorageCommand command=reader.read(channelWithRelGroupRecord());
    assertValidRelGroupCommand(command);
  }
  private static void assertValidRelGroupCommand(  StorageCommand command){
    assertThat(command,instanceOf(RelationshipGroupCommand.class));
    RelationshipGroupCommand relGroupCommand=(RelationshipGroupCommand)command;
    RelationshipGroupRecord record=relGroupCommand.getAfter();
    assertEquals(ID,record.getId());
    if (IN_USE_FLAG == Record.IN_USE.byteValue()) {
      assertTrue(record.inUse());
    }
 else     if (IN_USE_FLAG == Record.NOT_IN_USE.byteValue()) {
      assertFalse(record.inUse());
    }
 else {
      throw new IllegalStateException("Illegal inUse flag: " + IN_USE_FLAG);
    }
    assertEquals(TYPE_AS_INT,record.getType());
    assertEquals(NEXT,record.getNext());
    assertEquals(FIRST_OUT,record.getFirstOut());
    assertEquals(FIRST_IN,record.getFirstIn());
    assertEquals(FIRST_LOOP,record.getNext());
    assertEquals(OWNING_NODE,record.getOwningNode());
  }
  private static ReadableChannel channelWithRelGroupRecord() throws IOException {
    return channelWithRelGroupRecord(ID,IN_USE_FLAG,TYPE,NEXT,FIRST_OUT,FIRST_IN,FIRST_LOOP,OWNING_NODE);
  }
  private static ReadableChannel channelWithRelGroupRecord(  long id,  byte inUse,  short type,  long next,  long firstOut,  long firstIn,  long firstLoop,  long owningNode) throws IOException {
    ReadableChannel channel=mock(ReadableChannel.class);
    when(channel.get()).thenReturn(NeoCommandType.REL_GROUP_COMMAND).thenReturn(inUse);
    when(channel.getLong()).thenReturn(id).thenReturn(next).thenReturn(firstOut).thenReturn(firstIn).thenReturn(firstLoop).thenReturn(owningNode);
    when(channel.getShort()).thenReturn(type);
    return channel;
  }
}
