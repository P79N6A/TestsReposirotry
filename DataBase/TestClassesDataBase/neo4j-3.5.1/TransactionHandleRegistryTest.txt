public class TransactionHandleRegistryTest {
  @Test public void shouldGenerateTransactionId(){
    AssertableLogProvider logProvider=new AssertableLogProvider();
    TransactionHandleRegistry registry=new TransactionHandleRegistry(Clocks.fakeClock(),0,logProvider);
    TransactionHandle handle=mock(TransactionHandle.class);
    long id1=registry.begin(handle);
    long id2=registry.begin(handle);
    assertNotEquals(id1,id2);
    logProvider.assertNoLoggingOccurred();
  }
  @Test public void shouldStoreSuspendedTransaction() throws Exception {
    AssertableLogProvider logProvider=new AssertableLogProvider();
    TransactionHandleRegistry registry=new TransactionHandleRegistry(Clocks.fakeClock(),0,logProvider);
    TransactionHandle handle=mock(TransactionHandle.class);
    long id=registry.begin(handle);
    registry.release(id,handle);
    TransactionHandle acquiredHandle=registry.acquire(id);
    assertSame(handle,acquiredHandle);
    logProvider.assertNoLoggingOccurred();
  }
  @Test public void acquiringATransactionThatHasAlreadyBeenAcquiredShouldThrowInvalidConcurrentTransactionAccess() throws Exception {
    AssertableLogProvider logProvider=new AssertableLogProvider();
    TransactionHandleRegistry registry=new TransactionHandleRegistry(Clocks.fakeClock(),0,logProvider);
    TransactionHandle handle=mock(TransactionHandle.class);
    long id=registry.begin(handle);
    registry.release(id,handle);
    registry.acquire(id);
    try {
      registry.acquire(id);
      fail("Should have thrown exception");
    }
 catch (    InvalidConcurrentTransactionAccess e) {
    }
    logProvider.assertNoLoggingOccurred();
  }
  @Test public void acquiringANonExistentTransactionShouldThrowErrorInvalidTransactionId() throws Exception {
    AssertableLogProvider logProvider=new AssertableLogProvider();
    TransactionHandleRegistry registry=new TransactionHandleRegistry(Clocks.fakeClock(),0,logProvider);
    long madeUpTransactionId=1337;
    try {
      registry.acquire(madeUpTransactionId);
      fail("Should have thrown exception");
    }
 catch (    InvalidTransactionId e) {
    }
    logProvider.assertNoLoggingOccurred();
  }
  @Test public void transactionsShouldBeEvictedWhenUnusedLongerThanTimeout() throws Exception {
    FakeClock clock=Clocks.fakeClock();
    AssertableLogProvider logProvider=new AssertableLogProvider();
    TransactionHandleRegistry registry=new TransactionHandleRegistry(clock,0,logProvider);
    TransactionHandle oldTx=mock(TransactionHandle.class);
    TransactionHandle newTx=mock(TransactionHandle.class);
    TransactionHandle handle=mock(TransactionHandle.class);
    long txId1=registry.begin(handle);
    long txId2=registry.begin(handle);
    registry.release(txId1,oldTx);
    clock.forward(1,TimeUnit.MINUTES);
    registry.release(txId2,newTx);
    registry.rollbackSuspendedTransactionsIdleSince(clock.millis() - 1000);
    assertThat(registry.acquire(txId2),equalTo(newTx));
    try {
      registry.acquire(txId1);
      fail("Should have thrown exception");
    }
 catch (    InvalidTransactionId e) {
    }
    logProvider.assertExactly(inLog(TransactionHandleRegistry.class).info("Transaction with id 1 has been automatically rolled " + "back due to transaction timeout."));
  }
  @Test public void expiryTimeShouldBeSetToCurrentTimePlusTimeout() throws Exception {
    AssertableLogProvider logProvider=new AssertableLogProvider();
    FakeClock clock=Clocks.fakeClock();
    int timeoutLength=123;
    TransactionHandleRegistry registry=new TransactionHandleRegistry(clock,timeoutLength,logProvider);
    TransactionHandle handle=mock(TransactionHandle.class);
    long id=registry.begin(handle);
    long timesOutAt=registry.release(id,handle);
    assertThat(timesOutAt,equalTo(clock.millis() + timeoutLength));
    clock.forward(1337,TimeUnit.MILLISECONDS);
    registry.acquire(id);
    timesOutAt=registry.release(id,handle);
    assertThat(timesOutAt,equalTo(clock.millis() + timeoutLength));
  }
  @Test public void shouldProvideInterruptHandlerForActiveTransaction() throws TransactionLifecycleException {
    AssertableLogProvider logProvider=new AssertableLogProvider();
    FakeClock clock=Clocks.fakeClock();
    int timeoutLength=123;
    TransactionHandleRegistry registry=new TransactionHandleRegistry(clock,timeoutLength,logProvider);
    TransactionHandle handle=mock(TransactionHandle.class);
    long id=registry.begin(handle);
    registry.terminate(id);
    verify(handle,times(1)).terminate();
    verifyNoMoreInteractions(handle);
  }
  @Test public void shouldProvideInterruptHandlerForSuspendedTransaction() throws TransactionLifecycleException {
    AssertableLogProvider logProvider=new AssertableLogProvider();
    FakeClock clock=Clocks.fakeClock();
    int timeoutLength=123;
    TransactionHandleRegistry registry=new TransactionHandleRegistry(clock,timeoutLength,logProvider);
    TransactionHandle handle=mock(TransactionHandle.class);
    long id=registry.begin(handle);
    registry.release(id,handle);
    registry.terminate(id);
    verify(handle,times(1)).terminate();
    verifyNoMoreInteractions(handle);
  }
  @Test(expected=InvalidTransactionId.class) public void gettingInterruptHandlerForUnknownIdShouldThrowErrorInvalidTransactionId() throws TransactionLifecycleException {
    AssertableLogProvider logProvider=new AssertableLogProvider();
    FakeClock clock=Clocks.fakeClock();
    int timeoutLength=123;
    TransactionHandleRegistry registry=new TransactionHandleRegistry(clock,timeoutLength,logProvider);
    registry.terminate(456);
  }
}
