@ExtendWith({TestDirectoryExtension.class,DefaultFileSystemExtension.class,SuppressOutputExtension.class}) public class DiagnosticsReportCommandTest {
  @Inject private TestDirectory testDirectory;
  @Inject private DefaultFileSystemAbstraction fs;
  private Path homeDir;
  private Path configDir;
  private Path configFile;
  private String originalUserDir;
public static class MyDiagnosticsOfflineReportProvider extends DiagnosticsOfflineReportProvider {
    public MyDiagnosticsOfflineReportProvider(){
      super("my-provider","logs","tx");
    }
    @Override public void init(    FileSystemAbstraction fs,    Config config,    File storeDirectory){
    }
    @Nonnull @Override protected List<DiagnosticsReportSource> provideSources(    Set<String> classifiers){
      return Collections.emptyList();
    }
  }
  @BeforeEach void setUp() throws Exception {
    homeDir=testDirectory.directory("home-dir").toPath();
    configDir=testDirectory.directory("config-dir").toPath();
    configFile=configDir.resolve("neo4j.conf");
    Files.createFile(configFile);
    originalUserDir=System.setProperty("user.dir",testDirectory.absolutePath().getAbsolutePath());
  }
  @AfterEach void tearDown(){
    System.setProperty("user.dir",originalUserDir);
  }
  @Test void exitIfConfigFileIsMissing() throws IOException {
    Files.delete(configFile);
    String[] args={"--list"};
    try (RealOutsideWorld outsideWorld=new RealOutsideWorld()){
      DiagnosticsReportCommand diagnosticsReportCommand=new DiagnosticsReportCommand(homeDir,configDir,outsideWorld);
      CommandFailed commandFailed=assertThrows(CommandFailed.class,() -> diagnosticsReportCommand.execute(args));
      assertThat(commandFailed.getMessage(),containsString("Unable to find config file, tried: "));
    }
   }
  @Test void allHasToBeOnlyClassifier() throws Exception {
    String[] args={"all","logs","tx"};
    try (RealOutsideWorld outsideWorld=new RealOutsideWorld()){
      DiagnosticsReportCommand diagnosticsReportCommand=new DiagnosticsReportCommand(homeDir,configDir,outsideWorld);
      IncorrectUsage incorrectUsage=assertThrows(IncorrectUsage.class,() -> diagnosticsReportCommand.execute(args));
      assertEquals("If you specify 'all' this has to be the only classifier. Found ['logs','tx'] as well.",incorrectUsage.getMessage());
    }
   }
  @Test void printUnrecognizedClassifiers() throws Exception {
    String[] args={"logs","tx","invalid"};
    try (RealOutsideWorld outsideWorld=new RealOutsideWorld()){
      DiagnosticsReportCommand diagnosticsReportCommand=new DiagnosticsReportCommand(homeDir,configDir,outsideWorld);
      IncorrectUsage incorrectUsage=assertThrows(IncorrectUsage.class,() -> diagnosticsReportCommand.execute(args));
      assertEquals("Unknown classifier: invalid",incorrectUsage.getMessage());
    }
   }
  @SuppressWarnings("ResultOfMethodCallIgnored") @Test void defaultValuesShouldBeValidClassifiers(){
    for (    String classifier : DEFAULT_CLASSIFIERS) {
      describeClassifier(classifier);
    }
    IllegalArgumentException exception=assertThrows(IllegalArgumentException.class,() -> describeClassifier("invalid"));
    assertEquals("Unknown classifier: invalid",exception.getMessage());
  }
  @Test void listShouldDisplayAllClassifiers() throws Exception {
    try (ByteArrayOutputStream baos=new ByteArrayOutputStream()){
      PrintStream ps=new PrintStream(baos);
      String[] args={"--list"};
      OutsideWorld outsideWorld=mock(OutsideWorld.class);
      when(outsideWorld.fileSystem()).thenReturn(fs);
      when(outsideWorld.outStream()).thenReturn(ps);
      DiagnosticsReportCommand diagnosticsReportCommand=new DiagnosticsReportCommand(homeDir,configDir,outsideWorld);
      diagnosticsReportCommand.execute(args);
      assertThat(baos.toString(),is(String.format("Finding running instance of neo4j%n" + "No running instance of neo4j was found. Online reports will be omitted.%n" + "If neo4j is running but not detected, you can supply the process id of the running instance with --pid%n"+ "All available classifiers:%n"+ "  config     include configuration file%n"+ "  logs       include log files%n"+ "  plugins    include a view of the plugin directory%n"+ "  ps         include a list of running processes%n"+ "  tree       include a view of the tree structure of the data directory%n"+ "  tx         include transaction logs%n")));
    }
   }
  @Test void overrideDestination() throws Exception {
    String toArgument=JRE.JAVA_11.isCurrentVersion() ? "--to=" + System.getProperty("user.dir") + "/other/" : "--to=other/";
    String[] args={toArgument,"all"};
    try (RealOutsideWorld outsideWorld=new RealOutsideWorld()){
      DiagnosticsReportCommand diagnosticsReportCommand=new DiagnosticsReportCommand(homeDir,configDir,outsideWorld);
      diagnosticsReportCommand.execute(args);
      File other=testDirectory.directory("other");
      FileSystemAbstraction fs=outsideWorld.fileSystem();
      assertThat(fs.fileExists(other),is(true));
      assertThat(fs.listFiles(other).length,is(1));
      File reports=new File(testDirectory.directory(),"reports");
      assertThat(fs.fileExists(reports),is(false));
    }
   }
  @Test void errorOnInvalidPid() throws Exception {
    String[] args={"--pid=a","all"};
    try (RealOutsideWorld outsideWorld=new RealOutsideWorld()){
      DiagnosticsReportCommand diagnosticsReportCommand=new DiagnosticsReportCommand(homeDir,configDir,outsideWorld);
      CommandFailed commandFailed=assertThrows(CommandFailed.class,() -> diagnosticsReportCommand.execute(args));
      assertEquals("Unable to parse --pid",commandFailed.getMessage());
    }
   }
}
