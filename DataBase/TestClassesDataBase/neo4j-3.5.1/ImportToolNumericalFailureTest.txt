/** 
 * Tests that we fail correctly when given strings which can't be interpreted as numbers when configured to interpret them as such.
 */
@RunWith(Parameterized.class) public class ImportToolNumericalFailureTest {
  @Parameters(name="{index}: {0}, \"{1}\", \"{2}\"") public static List<Object[]> types(){
    ArrayList<Object[]> params=new ArrayList<>();
    for (    String type : Arrays.asList("int","long","short","byte","float","double")) {
      for (      String val : Arrays.asList(" 1 7 "," -1 7 "," - 1 ","   ","   -  ","-","1. 0","1 .",".","1E 10"," . 1")) {
        if (val.contains(".") && !(type.equals("float") || type.equals("double"))) {
          continue;
        }
        final String error;
        if (type.equals("float") || type.equals("double")) {
          error="Not a number: \"" + val + "\"";
        }
 else {
          error="Not an integer: \"" + val + "\"";
        }
        String[] args=new String[3];
        args[0]=type;
        args[1]=val;
        args[2]=error;
        params.add(args);
      }
    }
    return params;
  }
  @Parameter public String type;
  @Parameter(value=1) public String val;
  @Parameter(value=2) public String expectedError;
  @Rule public final EmbeddedDatabaseRule dbRule=new EmbeddedDatabaseRule().startLazily();
  @Rule public final SuppressOutput suppressOutput=SuppressOutput.suppress(SuppressOutput.System.values());
  private int dataIndex;
  @Test public void test() throws Exception {
    File data=file(fileName("whitespace.csv"));
    try (PrintStream writer=new PrintStream(data)){
      writer.println(":LABEL,adult:" + type);
      writer.println("PERSON," + val);
    }
     try {
      importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
      fail("Expected import to fail");
    }
 catch (    Exception e) {
      assertExceptionContains(e,expectedError,InputException.class);
    }
  }
  private String fileName(  String name){
    return dataIndex++ + "-" + name;
  }
  private File file(  String localname){
    return dbRule.databaseLayout().file(localname);
  }
}
