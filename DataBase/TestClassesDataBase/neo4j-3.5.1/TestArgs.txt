class TestArgs {
  @Test void testInterleavedParametersWithValuesAndNot(){
    String[] line={"-host","machine.foo.com","-port","1234","-v","-name","othershell"};
    Args args=Args.parse(line);
    assertEquals("machine.foo.com",args.get("host",null));
    assertEquals("1234",args.get("port",null));
    assertEquals(1234,args.getNumber("port",null).intValue());
    assertEquals("othershell",args.get("name",null));
    assertTrue(args.has("v"));
    assertTrue(args.orphans().isEmpty());
  }
  @Test void testInterleavedEqualsArgsAndSplitKeyValue(){
    String[] line={"-host=localhost","-v","--port","1234","param1","-name=Something","param2"};
    Args args=Args.parse(line);
    assertEquals("localhost",args.get("host",null));
    assertTrue(args.has("v"));
    assertEquals(1234,args.getNumber("port",null).intValue());
    assertEquals("Something",args.get("name",null));
    assertEquals(2,args.orphans().size());
    assertEquals("param1",args.orphans().get(0));
    assertEquals("param2",args.orphans().get(1));
  }
  @Test void testParameterWithDashValue(){
    String[] line={"-file","-"};
    Args args=Args.parse(line);
    assertEquals(1,args.asMap().size());
    assertEquals("-",args.get("file",null));
    assertTrue(args.orphans().isEmpty());
  }
  @Test void testEnum(){
    String[] line={"--enum=" + MyEnum.second.name()};
    Args args=Args.parse(line);
    Enum<MyEnum> result=args.getEnum(MyEnum.class,"enum",MyEnum.first);
    assertEquals(MyEnum.second,result);
  }
  @Test void testEnumWithDefault(){
    String[] line={};
    Args args=Args.parse(line);
    MyEnum result=args.getEnum(MyEnum.class,"enum",MyEnum.third);
    assertEquals(MyEnum.third,result);
  }
  @Test void testEnumWithInvalidValue(){
    String[] line={"--myenum=something"};
    Args args=Args.parse(line);
    assertThrows(IllegalArgumentException.class,() -> args.getEnum(MyEnum.class,"myenum",MyEnum.third));
  }
  @Test void shouldInterpretOption(){
    int expectedValue=42;
    Args args=Args.parse("--arg",String.valueOf(expectedValue));
    @SuppressWarnings("unchecked") Validator<Integer> validator=mock(Validator.class);
    int value=args.interpretOption("arg",mandatory(),toInt(),validator);
    assertEquals(expectedValue,value);
    verify(validator).validate(expectedValue);
  }
  @Test void shouldInterpretOrphan(){
    int expectedValue=42;
    Args args=Args.parse(String.valueOf(expectedValue));
    @SuppressWarnings("unchecked") Validator<Integer> validator=mock(Validator.class);
    int value=args.interpretOrphan(0,mandatory(),toInt(),validator);
    assertEquals(expectedValue,value);
    verify(validator).validate(expectedValue);
  }
  @Test void shouldInterpretMultipleOptionValues(){
    Collection<Integer> expectedValues=Arrays.asList(12,34,56);
    List<String> argList=new ArrayList<>();
    String key="number";
    for (    int value : expectedValues) {
      argList.add("--" + key);
      argList.add(String.valueOf(value));
    }
    Args args=Args.parse(argList.toArray(new String[argList.size()]));
    assertThrows(IllegalArgumentException.class,() -> args.get(key));
    Collection<Integer> numbers=args.interpretOptions(key,optional(),toInt());
    assertEquals(expectedValues,numbers);
  }
  @Test void testBooleanWithDefault(){
    Args args=Args.parse("--no_value");
    assertThat(args.getBoolean("not_set",true,true),equalTo(true));
    assertThat(args.getBoolean("not_set",false,true),equalTo(false));
    assertThat(args.getBoolean("not_set",false,false),equalTo(false));
    assertThat(args.getBoolean("not_set",true,false),equalTo(true));
    assertThat(args.getBoolean("no_value",true,true),equalTo(true));
    assertThat(args.getBoolean("no_value",false,true),equalTo(true));
    assertThat(args.getBoolean("no_value",false,false),equalTo(false));
    assertThat(args.getBoolean("no_value",true,false),equalTo(false));
  }
  @Test void shouldGetAsMap(){
    Args args=Args.parse("--with-value","value","--without-value");
    Map<String,String> map=args.asMap();
    assertEquals(stringMap("with-value","value","without-value",null),map);
  }
  @Test void shouldInterpretOptionMetadata(){
    Args args=Args.parse("--my-option:Meta","my value","--my-option:Other","other value");
    Collection<Option<String>> options=args.interpretOptionsWithMetadata("my-option",mandatory(),value -> value);
    assertEquals(2,options.size());
    Iterator<Option<String>> optionIterator=options.iterator();
    Option<String> first=optionIterator.next();
    assertEquals("my value",first.value());
    assertEquals("Meta",first.metadata());
    Option<String> second=optionIterator.next();
    assertEquals("other value",second.value());
    assertEquals("Other",second.metadata());
  }
  @Test void shouldHandleLastOrphanParam(){
    Args args=Args.withFlags("recovery").parse("--recovery","/tmp/graph.db");
    List<String> orphans=args.orphans();
    assertEquals(Arrays.asList("/tmp/graph.db"),orphans);
  }
  @Test void shouldHandleOnlyFlagsAndNoArgs(){
    Args args=Args.withFlags("foo","bar").parse("-foo","--bar");
    List<String> orphans=args.orphans();
    assertEquals(Collections.<String>emptyList(),orphans);
    assertTrue(args.getBoolean("foo",false,true));
    assertTrue(args.getBoolean("bar",false,true));
  }
  @Test void shouldStillAllowExplicitValuesForFlags(){
    Args args=Args.withFlags("foo","bar").parse("-foo=false","--bar");
    List<String> orphans=args.orphans();
    assertEquals(Arrays.<String>asList(),orphans);
    assertFalse(args.getBoolean("foo",false,false));
    assertTrue(args.getBoolean("bar",false,true));
  }
  @Test void shouldHandleMixtureOfFlagsAndOrphanParams(){
    Args args=Args.withFlags("big","soft","saysMeow").parse("-big","-size=120","-soft=true","withStripes","-saysMeow=false","-name=ShereKhan","badTiger");
    List<String> orphans=args.orphans();
    assertEquals(Arrays.asList("withStripes","badTiger"),orphans);
    assertEquals(120,args.getNumber("size",0).intValue());
    assertEquals("ShereKhan",args.get("name"));
    assertTrue(args.getBoolean("big",false,true));
    assertTrue(args.getBoolean("soft",false,false));
    assertFalse(args.getBoolean("saysMeow",true,true));
  }
  @Test void shouldHandleFlagSpecifiedAsLastArgument(){
    Args args=Args.withFlags("flag1","flag2").parse("-key=Foo","-flag1","false","-value","Bar","-flag2","false");
    List<String> orphans=args.orphans();
    assertTrue(orphans.isEmpty(),"Orphan args expected to be empty, but were: " + orphans);
    assertEquals("Foo",args.get("key"));
    assertEquals("Bar",args.get("value"));
    assertFalse(args.getBoolean("flag1",true));
    assertFalse(args.getBoolean("flag2",true));
  }
  @Test void shouldRecognizeFlagsOfAnyForm(){
    Args args=Args.withFlags("flag1","flag2","flag3").parse("-key1=Foo","-flag1","-key1","Bar","-flag2=true","-key3=Baz","-flag3","true");
    List<String> orphans=args.orphans();
    assertTrue(orphans.isEmpty(),"Orphan args expected to be empty, but were: " + orphans);
    assertTrue(args.getBoolean("flag1",false,true));
    assertTrue(args.getBoolean("flag2",false,false));
    assertTrue(args.getBoolean("flag3",false,false));
  }
  @Test void shouldReturnEmptyCollectionForOptionalMissingOption(){
    Args args=Args.withFlags().parse();
    Collection<String> interpreted=args.interpretOptions("something",optional(),value -> value);
    assertTrue(interpreted.isEmpty());
  }
  private enum MyEnum {  first,   second,   third}
}
