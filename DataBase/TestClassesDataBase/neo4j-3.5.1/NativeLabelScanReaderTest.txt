public class NativeLabelScanReaderTest {
  private static final int LABEL_ID=1;
  @SuppressWarnings("unchecked") @Test public void shouldFindMultipleNodesInEachRange() throws Exception {
    GBPTree<LabelScanKey,LabelScanValue> index=mock(GBPTree.class);
    RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException> cursor=mock(RawCursor.class);
    when(cursor.next()).thenReturn(true,true,true,false);
    when(cursor.get()).thenReturn(hit(0,0b1000_1000__1100_0010L),hit(1,0b0000_0010__0000_1000L),hit(3,0b0010_0000__1010_0001L),null);
    when(index.seek(any(LabelScanKey.class),any(LabelScanKey.class))).thenReturn(cursor);
    try (NativeLabelScanReader reader=new NativeLabelScanReader(index)){
      LongIterator iterator=reader.nodesWithLabel(LABEL_ID);
      assertArrayEquals(new long[]{1,6,7,11,15,64 + 3,64 + 9,192 + 0,192 + 5,192 + 7,192 + 13},asArray(iterator));
    }
   }
  @Test public void shouldSupportMultipleOpenCursorsConcurrently() throws Exception {
    GBPTree<LabelScanKey,LabelScanValue> index=mock(GBPTree.class);
    RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException> cursor1=mock(RawCursor.class);
    when(cursor1.next()).thenReturn(false);
    RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException> cursor2=mock(RawCursor.class);
    when(cursor2.next()).thenReturn(false);
    when(index.seek(any(LabelScanKey.class),any(LabelScanKey.class))).thenReturn(cursor1,cursor2);
    try (NativeLabelScanReader reader=new NativeLabelScanReader(index)){
      verify(cursor1,never()).close();
      verify(cursor2,never()).close();
      LongIterator first=reader.nodesWithLabel(LABEL_ID);
      LongIterator second=reader.nodesWithLabel(LABEL_ID);
      verify(cursor1,never()).close();
      verify(cursor2,never()).close();
      exhaust(first);
      verify(cursor1,times(1)).close();
      verify(cursor2,never()).close();
      exhaust(second);
      verify(cursor1,times(1)).close();
      verify(cursor2,times(1)).close();
    }
   }
  @Test public void shouldCloseUnexhaustedCursorsOnReaderClose() throws Exception {
    GBPTree<LabelScanKey,LabelScanValue> index=mock(GBPTree.class);
    RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException> cursor1=mock(RawCursor.class);
    when(cursor1.next()).thenReturn(false);
    RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException> cursor2=mock(RawCursor.class);
    when(cursor2.next()).thenReturn(false);
    when(index.seek(any(LabelScanKey.class),any(LabelScanKey.class))).thenReturn(cursor1,cursor2);
    try (NativeLabelScanReader reader=new NativeLabelScanReader(index)){
      reader.nodesWithLabel(LABEL_ID);
      reader.nodesWithLabel(LABEL_ID);
      verify(cursor1,never()).close();
      verify(cursor2,never()).close();
    }
     verify(cursor1,times(1)).close();
    verify(cursor2,times(1)).close();
  }
  @Test public void shouldStartFromGivenId() throws IOException {
    GBPTree<LabelScanKey,LabelScanValue> index=mock(GBPTree.class);
    RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException> cursor=mock(RawCursor.class);
    when(cursor.next()).thenReturn(true,true,false);
    when(cursor.get()).thenReturn(hit(1,0b0001_1000__0101_1110L),hit(3,0b0010_0000__1010_0001L),null);
    when(index.seek(any(LabelScanKey.class),any(LabelScanKey.class))).thenReturn(cursor);
    long fromId=LabelScanValue.RANGE_SIZE + 3;
    try (NativeLabelScanReader reader=new NativeLabelScanReader(index);PrimitiveLongResourceIterator iterator=reader.nodesWithAnyOfLabels(fromId,LABEL_ID)){
      assertArrayEquals(new long[]{64 + 4,64 + 6,64 + 11,64 + 12,192 + 0,192 + 5,192 + 7,192 + 13},asArray(iterator));
    }
   }
  private static Hit<LabelScanKey,LabelScanValue> hit(  long baseNodeId,  long bits){
    LabelScanKey key=new LabelScanKey(LABEL_ID,baseNodeId);
    LabelScanValue value=new LabelScanValue();
    value.bits=bits;
    return new MutableHit<>(key,value);
  }
  private void exhaust(  LongIterator iterator){
    while (iterator.hasNext()) {
      iterator.next();
    }
  }
}
