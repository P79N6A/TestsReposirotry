public class RepresentationFormatRepositoryTest {
  private final RepresentationFormatRepository repository=new RepresentationFormatRepository(null);
  @Test public void canProvideJsonFormat(){
    assertNotNull(repository.inputFormat(MediaType.valueOf("application/json")));
  }
  @Test public void canProvideUTF8EncodedJsonFormat(){
    assertNotNull(repository.inputFormat(MediaType.valueOf("application/json;charset=UTF-8")));
  }
  @Test(expected=MediaTypeNotSupportedException.class) public void canNotGetInputFormatBasedOnWildcardMediaType() throws Exception {
    InputFormat format=repository.inputFormat(MediaType.WILDCARD_TYPE);
    format.readValue("foo");
    fail("Got InputFormat based on wild card type: " + format);
  }
  @Test public void canProvideJsonOutputFormat(){
    OutputFormat format=repository.outputFormat(asList(MediaType.APPLICATION_JSON_TYPE),null,null);
    assertNotNull(format);
    assertEquals("\"test\"",format.assemble(ValueRepresentation.string("test")));
  }
  @Test public void cannotProvideStreamingForOtherMediaTypes() throws Exception {
    final Response.ResponseBuilder responseBuilder=mock(Response.ResponseBuilder.class);
    when(responseBuilder.entity(any(byte[].class))).thenReturn(responseBuilder);
    Mockito.verify(responseBuilder,never()).entity(isA(StreamingOutput.class));
    when(responseBuilder.type(ArgumentMatchers.<MediaType>any())).thenReturn(responseBuilder);
    when(responseBuilder.build()).thenReturn(null);
    OutputFormat format=repository.outputFormat(asList(MediaType.TEXT_HTML_TYPE),new URI("http://some.host"),streamingHeader());
    assertNotNull(format);
    format.response(responseBuilder,new ExceptionRepresentation(new RuntimeException()));
  }
  @Test public void canProvideStreamingJsonOutputFormat() throws Exception {
    Response response=mock(Response.class);
    final AtomicReference<StreamingOutput> ref=new AtomicReference<>();
    final Response.ResponseBuilder responseBuilder=mockResponseBuilder(response,ref);
    OutputFormat format=repository.outputFormat(asList(MediaType.APPLICATION_JSON_TYPE),null,streamingHeader());
    assertNotNull(format);
    Response returnedResponse=format.response(responseBuilder,new MapRepresentation(map("a","test")));
    assertSame(response,returnedResponse);
    StreamingOutput streamingOutput=ref.get();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    streamingOutput.write(baos);
    assertEquals("{\"a\":\"test\"}",baos.toString());
  }
  private Response.ResponseBuilder mockResponseBuilder(  Response response,  final AtomicReference<StreamingOutput> ref){
    final Response.ResponseBuilder responseBuilder=mock(Response.ResponseBuilder.class);
    when(responseBuilder.entity(ArgumentMatchers.isA(StreamingOutput.class))).thenAnswer(invocationOnMock -> {
      ref.set(invocationOnMock.getArgument(0));
      return responseBuilder;
    }
);
    when(responseBuilder.type(ArgumentMatchers.<MediaType>any())).thenReturn(responseBuilder);
    when(responseBuilder.build()).thenReturn(response);
    return responseBuilder;
  }
  @SuppressWarnings("unchecked") private MultivaluedMap<String,String> streamingHeader(){
    MultivaluedMap<String,String> headers=mock(MultivaluedMap.class);
    when(headers.getFirst(StreamingFormat.STREAM_HEADER)).thenReturn("true");
    return headers;
  }
}
