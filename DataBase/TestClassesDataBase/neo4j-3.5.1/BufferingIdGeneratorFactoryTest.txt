public class BufferingIdGeneratorFactoryTest {
  @Rule public final EphemeralFileSystemRule fs=new EphemeralFileSystemRule();
  @Test public void shouldDelayFreeingOfAggressivelyReusedIds(){
    MockedIdGeneratorFactory actual=new MockedIdGeneratorFactory();
    ControllableSnapshotSupplier boundaries=new ControllableSnapshotSupplier();
    BufferingIdGeneratorFactory bufferingIdGeneratorFactory=new BufferingIdGeneratorFactory(actual,IdReuseEligibility.ALWAYS,new CommunityIdTypeConfigurationProvider());
    bufferingIdGeneratorFactory.initialize(boundaries);
    IdGenerator idGenerator=bufferingIdGeneratorFactory.open(new File("doesnt-matter"),10,IdType.STRING_BLOCK,() -> 0L,Integer.MAX_VALUE);
    idGenerator.freeId(7);
    verifyNoMoreInteractions(actual.get(IdType.STRING_BLOCK));
    bufferingIdGeneratorFactory.maintenance();
    verifyNoMoreInteractions(actual.get(IdType.STRING_BLOCK));
    boundaries.setMostRecentlyReturnedSnapshotToAllClosed();
    bufferingIdGeneratorFactory.maintenance();
    verify(actual.get(IdType.STRING_BLOCK)).freeId(7);
  }
  @Test public void shouldDelayFreeingOfAggressivelyReusedIdsConsideringTimeAsWell(){
    MockedIdGeneratorFactory actual=new MockedIdGeneratorFactory();
    final FakeClock clock=Clocks.fakeClock();
    final long safeZone=MINUTES.toMillis(1);
    ControllableSnapshotSupplier boundaries=new ControllableSnapshotSupplier();
    BufferingIdGeneratorFactory bufferingIdGeneratorFactory=new BufferingIdGeneratorFactory(actual,t -> clock.millis() - t.snapshotTime() >= safeZone,new CommunityIdTypeConfigurationProvider());
    bufferingIdGeneratorFactory.initialize(boundaries);
    IdGenerator idGenerator=bufferingIdGeneratorFactory.open(new File("doesnt-matter"),10,IdType.STRING_BLOCK,() -> 0L,Integer.MAX_VALUE);
    idGenerator.freeId(7);
    verifyNoMoreInteractions(actual.get(IdType.STRING_BLOCK));
    bufferingIdGeneratorFactory.maintenance();
    verifyNoMoreInteractions(actual.get(IdType.STRING_BLOCK));
    boundaries.setMostRecentlyReturnedSnapshotToAllClosed();
    bufferingIdGeneratorFactory.maintenance();
    verifyNoMoreInteractions(actual.get(IdType.STRING_BLOCK));
    clock.forward(70,SECONDS);
    bufferingIdGeneratorFactory.maintenance();
    verify(actual.get(IdType.STRING_BLOCK)).freeId(7);
  }
private static class ControllableSnapshotSupplier implements Supplier<KernelTransactionsSnapshot> {
    KernelTransactionsSnapshot mostRecentlyReturned;
    @Override public KernelTransactionsSnapshot get(){
      return mostRecentlyReturned=mock(KernelTransactionsSnapshot.class);
    }
    void setMostRecentlyReturnedSnapshotToAllClosed(){
      when(mostRecentlyReturned.allClosed()).thenReturn(true);
    }
  }
private static class MockedIdGeneratorFactory implements IdGeneratorFactory {
    private final IdGenerator[] generators=new IdGenerator[IdType.values().length];
    @Override public IdGenerator open(    File filename,    IdType idType,    LongSupplier highId,    long maxId){
      return open(filename,0,idType,highId,maxId);
    }
    @Override public IdGenerator open(    File filename,    int grabSize,    IdType idType,    LongSupplier highId,    long maxId){
      return generators[idType.ordinal()]=mock(IdGenerator.class);
    }
    @Override public void create(    File filename,    long highId,    boolean throwIfFileExists){
    }
    @Override public IdGenerator get(    IdType idType){
      return generators[idType.ordinal()];
    }
  }
}
