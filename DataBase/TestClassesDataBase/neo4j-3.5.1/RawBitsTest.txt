@RunWith(Parameterized.class) public class RawBitsTest {
  @Parameterized.Parameter() public String name;
  @Parameterized.Parameter(1) public NumberLayout layout;
  @Parameterized.Parameters(name="{0}") public static List<Object[]> layouts(){
    return asList(new Object[]{"Unique",new NumberLayoutUnique()},new Object[]{"NonUnique",new NumberLayoutNonUnique()});
  }
  final List<Object> objects=Arrays.asList(Double.NEGATIVE_INFINITY,-Double.MAX_VALUE,Long.MIN_VALUE,Long.MIN_VALUE + 1,Integer.MIN_VALUE,Short.MIN_VALUE,Byte.MIN_VALUE,0,Double.MIN_VALUE,Double.MIN_NORMAL,Float.MIN_VALUE,Float.MIN_NORMAL,1L,1.1d,1.2f,Math.E,Math.PI,(byte)10,(short)20,Byte.MAX_VALUE,Short.MAX_VALUE,Integer.MAX_VALUE,33554432,33554432F,33554433,33554433F,33554434,33554434F,9007199254740991L,9007199254740991D,9007199254740992L,9007199254740992D,9007199254740993L,9007199254740993D,9007199254740994L,9007199254740994D,Long.MAX_VALUE,Float.MAX_VALUE,Double.MAX_VALUE,Double.POSITIVE_INFINITY,Double.NaN,Math.nextDown(Math.E),Math.nextUp(Math.E),Math.nextDown(Math.PI),Math.nextUp(Math.PI));
  @Test public void mustSortInSameOrderAsValueComparator(){
    List<Value> values=asValueObjects(objects);
    List<NumberIndexKey> numberIndexKeys=asNumberIndexKeys(values);
    Collections.shuffle(values);
    Collections.shuffle(numberIndexKeys);
    values.sort(Values.COMPARATOR);
    numberIndexKeys.sort(layout);
    List<Value> actual=asValues(numberIndexKeys);
    assertSameOrder(actual,values);
  }
  @Test public void shouldCompareAllValuesToAllOtherValuesLikeValueComparator(){
    List<Value> values=asValueObjects(objects);
    List<NumberIndexKey> numberIndexKeys=asNumberIndexKeys(values);
    values.sort(Values.COMPARATOR);
    for (    NumberIndexKey numberKey : numberIndexKeys) {
      List<NumberIndexKey> withoutThisOne=new ArrayList<>(numberIndexKeys);
      assertTrue(withoutThisOne.remove(numberKey));
      withoutThisOne=unmodifiableList(withoutThisOne);
      for (int i=0; i < withoutThisOne.size(); i++) {
        List<NumberIndexKey> withThisOneInWrongPlace=new ArrayList<>(withoutThisOne);
        withThisOneInWrongPlace.add(i,numberKey);
        withThisOneInWrongPlace.sort(layout);
        List<Value> actual=asValues(withThisOneInWrongPlace);
        assertSameOrder(actual,values);
      }
    }
  }
  @Test public void shouldHaveSameCompareResultsAsValueCompare(){
    List<Value> values=asValueObjects(objects);
    List<NumberIndexKey> numberIndexKeys=asNumberIndexKeys(values);
    for (int i=0; i < values.size(); i++) {
      Value value1=values.get(i);
      NumberIndexKey numberIndexKey1=numberIndexKeys.get(i);
      for (int j=0; j < values.size(); j++) {
        Value value2=values.get(j);
        NumberIndexKey numberIndexKey2=numberIndexKeys.get(j);
        assertEquals(Values.COMPARATOR.compare(value1,value2),layout.compare(numberIndexKey1,numberIndexKey2));
        assertEquals(Values.COMPARATOR.compare(value2,value1),layout.compare(numberIndexKey2,numberIndexKey1));
      }
    }
  }
  private List<Value> asValues(  List<NumberIndexKey> numberIndexKeys){
    return numberIndexKeys.stream().map(k -> RawBits.asNumberValue(k.rawValueBits,k.type)).collect(Collectors.toList());
  }
  private void assertSameOrder(  List<Value> actual,  List<Value> values){
    assertEquals(actual.size(),values.size());
    for (int i=0; i < actual.size(); i++) {
      Number actualAsNumber=(Number)actual.get(i).asObject();
      Number valueAsNumber=(Number)values.get(i).asObject();
      if (Double.isNaN(actualAsNumber.doubleValue()) && Double.isNaN(valueAsNumber.doubleValue())) {
      }
 else {
        assertEquals(actual.get(i),values.get(i));
      }
    }
  }
  private List<Value> asValueObjects(  List<Object> objects){
    List<Value> values=new ArrayList<>();
    for (    Object object : objects) {
      values.add(Values.of(object));
    }
    return values;
  }
  private List<NumberIndexKey> asNumberIndexKeys(  List<Value> values){
    List<NumberIndexKey> numberIndexKeys=new ArrayList<>();
    for (    Value value : values) {
      NumberIndexKey key=new NumberIndexKey();
      key.from(value);
      numberIndexKeys.add(key);
    }
    return numberIndexKeys;
  }
}
