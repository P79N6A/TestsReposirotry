public class SpatialIndexSettingsTest {
  private static final CoordinateReferenceSystem crs=CoordinateReferenceSystem.WGS84;
  private static final Config config1=Config.defaults();
  private static final Config config2=configWithRange(0,-90,180,90);
  private static final ConfiguredSpaceFillingCurveSettingsCache configuredSettings1=new ConfiguredSpaceFillingCurveSettingsCache(config1);
  private static final ConfiguredSpaceFillingCurveSettingsCache configuredSettings2=new ConfiguredSpaceFillingCurveSettingsCache(config2);
  private StoreIndexDescriptor schemaIndexDescriptor1;
  private StoreIndexDescriptor schemaIndexDescriptor2;
  private ValueCreatorUtil<SpatialIndexKey,NativeIndexValue> layoutUtil1;
  private ValueCreatorUtil<SpatialIndexKey,NativeIndexValue> layoutUtil2;
  private long indexId1=1;
  private long indexId2=2;
  final DefaultFileSystemRule fs=new DefaultFileSystemRule();
  private final TestDirectory directory=TestDirectory.testDirectory(getClass(),fs.get());
  private final PageCacheRule pageCacheRule=new PageCacheRule(config().withAccessChecks(true));
  private RandomRule randomRule=new RandomRule();
  @Rule public final RuleChain rules=outerRule(fs).around(directory).around(pageCacheRule).around(randomRule);
  private PageCache pageCache;
  private IndexProvider.Monitor monitor=IndexProvider.Monitor.EMPTY;
  @Before public void setupTwoIndexes() throws IOException {
    pageCache=pageCacheRule.getPageCache(fs);
    layoutUtil1=createLayoutTestUtil(indexId1,42);
    layoutUtil2=createLayoutTestUtil(indexId2,43);
    schemaIndexDescriptor1=layoutUtil1.indexDescriptor();
    schemaIndexDescriptor2=layoutUtil2.indexDescriptor();
    createEmptyIndex(schemaIndexDescriptor1,configuredSettings1);
    createEmptyIndex(schemaIndexDescriptor2,configuredSettings2);
  }
  @Test public void shouldAddToSpatialIndexWithDefaults() throws Exception {
    SpatialIndexProvider provider=newSpatialIndexProvider(config1);
    addUpdates(provider,schemaIndexDescriptor1,layoutUtil1);
    verifySpatialSettings(indexFile(indexId1),configuredSettings1.forCRS(crs));
  }
  @Test public void shouldAddToSpatialIndexWithModifiedSettings() throws Exception {
    SpatialIndexProvider provider=newSpatialIndexProvider(config2);
    addUpdates(provider,schemaIndexDescriptor2,layoutUtil2);
    verifySpatialSettings(indexFile(indexId2),configuredSettings2.forCRS(crs));
  }
  @Test public void shouldAddToTwoDifferentIndexesOneDefaultAndOneModified() throws Exception {
    SpatialIndexProvider provider=newSpatialIndexProvider(config2);
    addUpdates(provider,schemaIndexDescriptor1,layoutUtil1);
    addUpdates(provider,schemaIndexDescriptor2,layoutUtil2);
    verifySpatialSettings(indexFile(indexId1),configuredSettings1.forCRS(crs));
    verifySpatialSettings(indexFile(indexId2),configuredSettings2.forCRS(crs));
  }
  @Test public void shouldNotLeakSpaceFillingCurveSettingsBetweenExistingAndNewIndexes() throws Exception {
    Config config=configWithRange(-10,-10,10,10);
    SpatialIndexProvider provider=newSpatialIndexProvider(config);
    addUpdates(provider,schemaIndexDescriptor1,layoutUtil1);
    addUpdates(provider,schemaIndexDescriptor2,layoutUtil2);
    long indexId3=3;
    ConfiguredSpaceFillingCurveSettingsCache settings3=new ConfiguredSpaceFillingCurveSettingsCache(config);
    SpatialValueCreatorUtil layoutUtil3=createLayoutTestUtil(indexId3,44);
    StoreIndexDescriptor schemaIndexDescriptor3=layoutUtil3.indexDescriptor();
    createEmptyIndex(schemaIndexDescriptor3,provider);
    addUpdates(provider,schemaIndexDescriptor3,layoutUtil3);
    verifySpatialSettings(indexFile(indexId1),configuredSettings1.forCRS(crs));
    verifySpatialSettings(indexFile(indexId2),configuredSettings2.forCRS(crs));
    verifySpatialSettings(indexFile(indexId3),settings3.forCRS(crs));
  }
  private IndexSamplingConfig samplingConfig(){
    return new IndexSamplingConfig(Config.defaults());
  }
  private SpatialValueCreatorUtil createLayoutTestUtil(  long indexId,  int labelId){
    StoreIndexDescriptor descriptor=TestIndexDescriptorFactory.forLabel(labelId,666).withId(indexId);
    return new SpatialValueCreatorUtil(descriptor,ValueCreatorUtil.FRACTION_DUPLICATE_NON_UNIQUE);
  }
  private SpatialIndexProvider newSpatialIndexProvider(  Config config){
    return new SpatialIndexProvider(pageCache,fs,directoriesByProvider(directory.databaseDir()),monitor,immediate(),false,config);
  }
  private void addUpdates(  SpatialIndexProvider provider,  StoreIndexDescriptor schemaIndexDescriptor,  ValueCreatorUtil<SpatialIndexKey,NativeIndexValue> layoutUtil) throws IOException, IndexEntryConflictException {
    IndexAccessor accessor=provider.getOnlineAccessor(schemaIndexDescriptor,samplingConfig());
    try (IndexUpdater updater=accessor.newUpdater(ONLINE)){
      for (      IndexEntryUpdate<IndexDescriptor> update : layoutUtil.someUpdates(randomRule)) {
        updater.process(update);
      }
    }
     accessor.force(IOLimiter.UNLIMITED);
    accessor.close();
  }
  private SpatialIndexFiles.SpatialFile makeIndexFile(  long indexId,  ConfiguredSpaceFillingCurveSettingsCache configuredSettings){
    return new SpatialIndexFiles.SpatialFile(CoordinateReferenceSystem.WGS84,configuredSettings,indexDir(indexId));
  }
  private File indexDir(  long indexId){
    return new File(indexRoot(),Long.toString(indexId));
  }
  private File indexFile(  long indexId){
    return makeIndexFile(indexId,new ConfiguredSpaceFillingCurveSettingsCache(Config.defaults())).indexFile;
  }
  private File indexRoot(){
    return new File(new File(new File(directory.databaseDir(),"schema"),"index"),"spatial-1.0");
  }
  private void createEmptyIndex(  StoreIndexDescriptor schemaIndexDescriptor,  ConfiguredSpaceFillingCurveSettingsCache configuredSettings) throws IOException {
    SpatialIndexFiles.SpatialFileLayout fileLayout=makeIndexFile(schemaIndexDescriptor.getId(),configuredSettings).getLayoutForNewIndex();
    SpatialIndexPopulator.PartPopulator populator=new SpatialIndexPopulator.PartPopulator(pageCache,fs,fileLayout,monitor,schemaIndexDescriptor,new StandardConfiguration());
    populator.create();
    populator.close(true);
  }
  private void createEmptyIndex(  StoreIndexDescriptor schemaIndexDescriptor,  SpatialIndexProvider provider) throws IOException {
    IndexPopulator populator=provider.getPopulator(schemaIndexDescriptor,samplingConfig());
    populator.create();
    populator.close(true);
  }
  private void verifySpatialSettings(  File indexFile,  SpaceFillingCurveSettings expectedSettings){
    try {
      SpaceFillingCurveSettings settings=SpaceFillingCurveSettingsFactory.fromGBPTree(indexFile,pageCache,NativeIndexHeaderReader::readFailureMessage);
      assertThat("Should get correct results from header",settings,equalTo(expectedSettings));
    }
 catch (    IOException e) {
      fail("Failed to read GBPTree header: " + e.getMessage());
    }
  }
  private static Config configWithRange(  double minX,  double minY,  double maxX,  double maxY){
    Setting<Double> wgs84MinX=SpatialIndexSettings.makeCRSRangeSetting(CoordinateReferenceSystem.WGS84,0,"min");
    Setting<Double> wgs84MinY=SpatialIndexSettings.makeCRSRangeSetting(CoordinateReferenceSystem.WGS84,1,"min");
    Setting<Double> wgs84MaxX=SpatialIndexSettings.makeCRSRangeSetting(CoordinateReferenceSystem.WGS84,0,"max");
    Setting<Double> wgs84MaxY=SpatialIndexSettings.makeCRSRangeSetting(CoordinateReferenceSystem.WGS84,1,"max");
    Config config=Config.defaults();
    config.augment(wgs84MinX,Double.toString(minX));
    config.augment(wgs84MinY,Double.toString(minY));
    config.augment(wgs84MaxX,Double.toString(maxX));
    config.augment(wgs84MaxY,Double.toString(maxY));
    return config;
  }
}
