public class StartupLoggingIT extends ExclusiveServerTestBase {
  @Rule public SuppressOutput suppressOutput=SuppressOutput.suppressAll();
  @Rule public TestDirectory testDir=TestDirectory.testDirectory();
  @Test public void shouldLogHelpfulStartupMessages(){
    CommunityBootstrapper boot=new CommunityBootstrapper();
    Map<String,String> propertyPairs=getPropertyPairs();
    boot.start(testDir.directory(),Optional.of(new File("nonexistent-file.conf")),propertyPairs);
    URI uri=boot.getServer().baseUri();
    boot.stop();
    List<String> captured=suppressOutput.getOutputVoice().lines();
    assertThat(captured,containsAtLeastTheseLines(warn("Config file \\[nonexistent-file.conf\\] does not exist."),info(NEO4J_IS_STARTING_MESSAGE),info("Starting..."),info("Started."),info("Remote interface available at " + uri.toString()),info("Stopping..."),info("Stopped.")));
  }
  private Map<String,String> getPropertyPairs(){
    Map<String,String> properties=new HashMap<>();
    properties.put(GraphDatabaseSettings.data_directory.name(),testDir.databaseDir().toString());
    properties.put(GraphDatabaseSettings.logs_directory.name(),testDir.databaseDir().toString());
    properties.put(LegacySslPolicyConfig.certificates_directory.name(),testDir.databaseDir().toString());
    properties.put(GraphDatabaseSettings.allow_upgrade.name(),Settings.TRUE);
    HttpConnector http=new HttpConnector("http",Encryption.NONE);
    properties.put(http.type.name(),"HTTP");
    properties.put(http.listen_address.name(),"localhost:0");
    properties.put(http.enabled.name(),Settings.TRUE);
    HttpConnector https=new HttpConnector("https",Encryption.TLS);
    properties.put(https.type.name(),"HTTP");
    properties.put(https.listen_address.name(),"localhost:0");
    properties.put(https.enabled.name(),Settings.TRUE);
    BoltConnector bolt=new BoltConnector(DEFAULT_CONNECTOR_KEY);
    properties.put(bolt.type.name(),"BOLT");
    properties.put(bolt.enabled.name(),"true");
    properties.put(bolt.listen_address.name(),"localhost:0");
    properties.put(GraphDatabaseSettings.database_path.name(),testDir.absolutePath().getAbsolutePath());
    return properties;
  }
  @SafeVarargs private static Matcher<List<String>> containsAtLeastTheseLines(  final Matcher<String>... expectedLinePatterns){
    return new TypeSafeMatcher<List<String>>(){
      @Override protected boolean matchesSafely(      List<String> lines){
        if (expectedLinePatterns.length > lines.size()) {
          return false;
        }
        for (int i=0, e=0; i < lines.size(); i++) {
          String line=lines.get(i);
          while (!expectedLinePatterns[e].matches(line)) {
            if (++i >= lines.size()) {
              return false;
            }
            line=lines.get(i);
          }
          e++;
        }
        return true;
      }
      @Override public void describeTo(      Description description){
        description.appendList("","\n","",asList(expectedLinePatterns));
      }
    }
;
  }
  public static Matcher<String> info(  String messagePattern){
    return line("INFO",messagePattern);
  }
  public static Matcher<String> warn(  String messagePattern){
    return line("WARN",messagePattern);
  }
  public static Matcher<String> line(  final String level,  final String messagePattern){
    return new TypeSafeMatcher<String>(){
      @Override protected boolean matchesSafely(      String line){
        return line.matches(".*" + level + "\\s+"+ messagePattern);
      }
      @Override public void describeTo(      Description description){
        description.appendText(level).appendText(" ").appendText(messagePattern);
      }
    }
;
  }
}
