public class UniqueDatabaseIndexPopulatorTest {
  private final CleanupRule cleanup=new CleanupRule();
  private final TestDirectory testDir=TestDirectory.testDirectory();
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public final RuleChain ruleChain=RuleChain.outerRule(testDir).around(cleanup).around(fileSystemRule);
  private static final int LABEL_ID=1;
  private static final int PROPERTY_KEY_ID=2;
  private final DirectoryFactory directoryFactory=new DirectoryFactory.InMemoryDirectoryFactory();
  private static final IndexDescriptor descriptor=TestIndexDescriptorFactory.forLabel(LABEL_ID,PROPERTY_KEY_ID);
  private final NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
  private PartitionedIndexStorage indexStorage;
  private SchemaIndex index;
  private UniqueLuceneIndexPopulator populator;
  private SchemaDescriptor schemaDescriptor;
  @Before public void setUp(){
    File folder=testDir.directory("folder");
    indexStorage=new PartitionedIndexStorage(directoryFactory,fileSystemRule.get(),folder);
    index=LuceneSchemaIndexBuilder.create(descriptor,Config.defaults()).withIndexStorage(indexStorage).build();
    schemaDescriptor=descriptor.schema();
  }
  @After public void tearDown() throws Exception {
    if (populator != null) {
      populator.close(false);
    }
    IOUtils.closeAll(index,directoryFactory);
  }
  @Test public void shouldVerifyThatThereAreNoDuplicates() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,"value1");
    addUpdate(populator,2,"value2");
    addUpdate(populator,3,"value3");
    populator.verifyDeferredConstraints(nodePropertyAccessor);
    populator.close(true);
    assertEquals(asList(1L),getAllNodes(getDirectory(),"value1"));
    assertEquals(asList(2L),getAllNodes(getDirectory(),"value2"));
    assertEquals(asList(3L),getAllNodes(getDirectory(),"value3"));
  }
  private Directory getDirectory() throws IOException {
    File partitionFolder=indexStorage.getPartitionFolder(1);
    return indexStorage.openDirectory(partitionFolder);
  }
  @Test public void shouldUpdateEntryForNodeThatHasAlreadyBeenIndexed() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,"value1");
    IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
    updater.process(change(1,schemaDescriptor,"value1","value2"));
    populator.close(true);
    assertEquals(Collections.EMPTY_LIST,getAllNodes(getDirectory(),"value1"));
    assertEquals(asList(1L),getAllNodes(getDirectory(),"value2"));
  }
  @Test public void shouldUpdateEntryForNodeThatHasPropertyRemovedAndThenAddedAgain() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,"value1");
    IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
    updater.process(remove(1,schemaDescriptor,"value1"));
    updater.process(add(1,schemaDescriptor,"value1"));
    populator.close(true);
    assertEquals(asList(1L),getAllNodes(getDirectory(),"value1"));
  }
  @Test public void shouldRemoveEntryForNodeThatHasAlreadyBeenIndexed() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,"value1");
    IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
    updater.process(remove(1,schemaDescriptor,"value1"));
    populator.close(true);
    assertEquals(Collections.EMPTY_LIST,getAllNodes(getDirectory(),"value1"));
  }
  @Test public void shouldBeAbleToHandleSwappingOfIndexValues() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,"value1");
    addUpdate(populator,2,"value2");
    IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
    updater.process(change(1,schemaDescriptor,"value1","value2"));
    updater.process(change(2,schemaDescriptor,"value2","value1"));
    populator.close(true);
    assertEquals(asList(2L),getAllNodes(getDirectory(),"value1"));
    assertEquals(asList(1L),getAllNodes(getDirectory(),"value2"));
  }
  @Test public void shouldFailAtVerificationStageWithAlreadyIndexedStringValue() throws Exception {
    populator=newPopulator();
    String value="value1";
    addUpdate(populator,1,value);
    addUpdate(populator,2,"value2");
    addUpdate(populator,3,value);
    when(nodePropertyAccessor.getNodePropertyValue(1,PROPERTY_KEY_ID)).thenReturn(Values.of(value));
    when(nodePropertyAccessor.getNodePropertyValue(3,PROPERTY_KEY_ID)).thenReturn(Values.of(value));
    try {
      populator.verifyDeferredConstraints(nodePropertyAccessor);
      fail("should have thrown exception");
    }
 catch (    IndexEntryConflictException conflict) {
      assertEquals(1,conflict.getExistingNodeId());
      assertEquals(Values.of(value),conflict.getSinglePropertyValue());
      assertEquals(3,conflict.getAddedNodeId());
    }
  }
  @Test public void shouldFailAtVerificationStageWithAlreadyIndexedNumberValue() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,1);
    addUpdate(populator,2,2);
    addUpdate(populator,3,1);
    when(nodePropertyAccessor.getNodePropertyValue(1,PROPERTY_KEY_ID)).thenReturn(Values.of(1));
    when(nodePropertyAccessor.getNodePropertyValue(3,PROPERTY_KEY_ID)).thenReturn(Values.of(1));
    try {
      populator.verifyDeferredConstraints(nodePropertyAccessor);
      fail("should have thrown exception");
    }
 catch (    IndexEntryConflictException conflict) {
      assertEquals(1,conflict.getExistingNodeId());
      assertEquals(Values.of(1),conflict.getSinglePropertyValue());
      assertEquals(3,conflict.getAddedNodeId());
    }
  }
  @Test public void shouldRejectDuplicateEntryWhenUsingPopulatingUpdater() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,"value1");
    addUpdate(populator,2,"value2");
    Value value=Values.of("value1");
    when(nodePropertyAccessor.getNodePropertyValue(1,PROPERTY_KEY_ID)).thenReturn(value);
    when(nodePropertyAccessor.getNodePropertyValue(3,PROPERTY_KEY_ID)).thenReturn(value);
    try {
      IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
      updater.process(add(3,schemaDescriptor,"value1"));
      updater.close();
      fail("should have thrown exception");
    }
 catch (    IndexEntryConflictException conflict) {
      assertEquals(1,conflict.getExistingNodeId());
      assertEquals(value,conflict.getSinglePropertyValue());
      assertEquals(3,conflict.getAddedNodeId());
    }
  }
  @Test public void shouldRejectDuplicateEntryAfterUsingPopulatingUpdater() throws Exception {
    populator=newPopulator();
    String valueString="value1";
    IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
    updater.process(add(1,schemaDescriptor,valueString));
    addUpdate(populator,2,valueString);
    Value value=Values.of(valueString);
    when(nodePropertyAccessor.getNodePropertyValue(1,PROPERTY_KEY_ID)).thenReturn(value);
    when(nodePropertyAccessor.getNodePropertyValue(2,PROPERTY_KEY_ID)).thenReturn(value);
    try {
      populator.verifyDeferredConstraints(nodePropertyAccessor);
      fail("should have thrown exception");
    }
 catch (    IndexEntryConflictException conflict) {
      assertEquals(1,conflict.getExistingNodeId());
      assertEquals(value,conflict.getSinglePropertyValue());
      assertEquals(2,conflict.getAddedNodeId());
    }
  }
  @Test public void shouldNotRejectDuplicateEntryOnSameNodeIdAfterUsingPopulatingUpdater() throws Exception {
    populator=newPopulator();
    when(nodePropertyAccessor.getNodePropertyValue(1,PROPERTY_KEY_ID)).thenReturn(Values.of("value1"));
    IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
    updater.process(add(1,schemaDescriptor,"value1"));
    updater.process(change(1,schemaDescriptor,"value1","value1"));
    updater.close();
    addUpdate(populator,2,"value2");
    addUpdate(populator,3,"value3");
    populator.verifyDeferredConstraints(nodePropertyAccessor);
    populator.close(true);
    assertEquals(asList(1L),getAllNodes(getDirectory(),"value1"));
    assertEquals(asList(2L),getAllNodes(getDirectory(),"value2"));
    assertEquals(asList(3L),getAllNodes(getDirectory(),"value3"));
  }
  @Test public void shouldNotRejectIndexCollisionsCausedByPrecisionLossAsDuplicates() throws Exception {
    populator=newPopulator();
    addUpdate(populator,1,1000000000000000001L);
    addUpdate(populator,2,2);
    addUpdate(populator,3,1000000000000000001L);
    when(nodePropertyAccessor.getNodePropertyValue(1,PROPERTY_KEY_ID)).thenReturn(Values.of(1000000000000000001L));
    when(nodePropertyAccessor.getNodePropertyValue(3,PROPERTY_KEY_ID)).thenReturn(Values.of(1000000000000000002L));
    populator.verifyDeferredConstraints(nodePropertyAccessor);
  }
  @Test public void shouldCheckAllCollisionsFromPopulatorAdd() throws Exception {
    populator=newPopulator();
    int iterations=228;
    IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor);
    for (int nodeId=0; nodeId < iterations; nodeId++) {
      updater.process(add(nodeId,schemaDescriptor,1));
      when(nodePropertyAccessor.getNodePropertyValue(nodeId,PROPERTY_KEY_ID)).thenReturn(Values.of(nodeId));
    }
    updater.process(add(iterations,schemaDescriptor,1));
    when(nodePropertyAccessor.getNodePropertyValue(iterations,PROPERTY_KEY_ID)).thenReturn(Values.of(1));
    try {
      updater.close();
      fail("should have thrown exception");
    }
 catch (    IndexEntryConflictException conflict) {
      assertEquals(1,conflict.getExistingNodeId());
      assertEquals(Values.of(1),conflict.getSinglePropertyValue());
      assertEquals(iterations,conflict.getAddedNodeId());
    }
  }
  @Test public void shouldCheckAllCollisionsFromUpdaterClose() throws Exception {
    populator=newPopulator();
    int iterations=228;
    for (int nodeId=0; nodeId < iterations; nodeId++) {
      addUpdate(populator,nodeId,1);
      when(nodePropertyAccessor.getNodePropertyValue(nodeId,PROPERTY_KEY_ID)).thenReturn(Values.of(nodeId));
    }
    addUpdate(populator,iterations,1);
    when(nodePropertyAccessor.getNodePropertyValue(iterations,PROPERTY_KEY_ID)).thenReturn(Values.of(1));
    try {
      populator.verifyDeferredConstraints(nodePropertyAccessor);
      fail("should have thrown exception");
    }
 catch (    IndexEntryConflictException conflict) {
      assertEquals(1,conflict.getExistingNodeId());
      assertEquals(Values.of(1),conflict.getSinglePropertyValue());
      assertEquals(iterations,conflict.getAddedNodeId());
    }
  }
  @Test public void shouldReleaseSearcherProperlyAfterVerifyingDeferredConstraints() throws Exception {
    populator=newPopulator();
    OtherThreadExecutor<Void> executor=cleanup.add(new OtherThreadExecutor<>("Deferred",null));
    executor.execute((WorkerCommand<Void,Void>)state -> {
      try (IndexUpdater updater=populator.newPopulatingUpdater(nodePropertyAccessor)){
      }
       return null;
    }
);
    executor.execute((WorkerCommand<Void,Void>)state -> {
      populator.verifyDeferredConstraints(nodePropertyAccessor);
      return null;
    }
);
    executor.execute((WorkerCommand<Void,Void>)state -> {
      try (IndexUpdater secondUpdater=populator.newPopulatingUpdater(nodePropertyAccessor)){
      }
       return null;
    }
,5,SECONDS);
  }
  @Test public void sampleEmptyIndex() throws Exception {
    populator=newPopulator();
    IndexSample sample=populator.sampleResult();
    assertEquals(new IndexSample(),sample);
  }
  @Test public void sampleIncludedUpdates() throws Exception {
    LabelSchemaDescriptor schemaDescriptor=SchemaDescriptorFactory.forLabel(1,1);
    populator=newPopulator();
    List<IndexEntryUpdate<?>> updates=Arrays.asList(add(1,schemaDescriptor,"foo"),add(2,schemaDescriptor,"bar"),add(3,schemaDescriptor,"baz"),add(4,schemaDescriptor,"qux"));
    updates.forEach(populator::includeSample);
    IndexSample sample=populator.sampleResult();
    assertEquals(new IndexSample(4,4,4),sample);
  }
  @Test public void addUpdates() throws Exception {
    populator=newPopulator();
    List<IndexEntryUpdate<?>> updates=Arrays.asList(add(1,schemaDescriptor,"aaa"),add(2,schemaDescriptor,"bbb"),add(3,schemaDescriptor,"ccc"));
    populator.add(updates);
    index.maybeRefreshBlocking();
    try (IndexReader reader=index.getIndexReader()){
      LongIterator allEntities=reader.query(IndexQuery.exists(1));
      assertArrayEquals(new long[]{1,2,3},PrimitiveLongCollections.asArray(allEntities));
    }
   }
  private UniqueLuceneIndexPopulator newPopulator() throws IOException {
    UniqueLuceneIndexPopulator populator=new UniqueLuceneIndexPopulator(index,descriptor);
    populator.create();
    return populator;
  }
  private static void addUpdate(  UniqueLuceneIndexPopulator populator,  long nodeId,  Object value) throws IOException {
    IndexEntryUpdate<?> update=add(nodeId,descriptor.schema(),value);
    populator.add(asList(update));
  }
  private List<Long> getAllNodes(  Directory directory,  Object value) throws IOException {
    return AllNodesCollector.getAllNodes(directory,Values.of(value));
  }
}
