public class KernelTransactionTestBase {
  protected final StorageEngine storageEngine=mock(StorageEngine.class);
  protected final NeoStores neoStores=mock(NeoStores.class);
  protected final MetaDataStore metaDataStore=mock(MetaDataStore.class);
  protected final StorageReader readLayer=mock(StorageReader.class);
  protected final TransactionHooks hooks=new TransactionHooks();
  protected final AuxiliaryTransactionStateManager auxTxStateManager=new KernelAuxTransactionStateManager();
  protected final ExplicitIndexTransactionState explicitIndexState=mock(ExplicitIndexTransactionState.class);
  protected final TransactionMonitor transactionMonitor=mock(TransactionMonitor.class);
  protected final CapturingCommitProcess commitProcess=new CapturingCommitProcess();
  protected final TransactionHeaderInformation headerInformation=mock(TransactionHeaderInformation.class);
  protected final TransactionHeaderInformationFactory headerInformationFactory=mock(TransactionHeaderInformationFactory.class);
  protected final SchemaWriteGuard schemaWriteGuard=mock(SchemaWriteGuard.class);
  protected final FakeClock clock=Clocks.fakeClock();
  protected final Pool<KernelTransactionImplementation> txPool=mock(Pool.class);
  protected final StatementOperationParts statementOperations=mock(StatementOperationParts.class);
  protected CollectionsFactory collectionsFactory;
  private final long defaultTransactionTimeoutMillis=Config.defaults().get(GraphDatabaseSettings.transaction_timeout).toMillis();
  @Before public void before() throws Exception {
    collectionsFactory=Mockito.spy(new TestCollectionsFactory());
    when(headerInformation.getAdditionalHeader()).thenReturn(new byte[0]);
    when(headerInformationFactory.create()).thenReturn(headerInformation);
    when(neoStores.getMetaDataStore()).thenReturn(metaDataStore);
    when(storageEngine.newReader()).thenReturn(readLayer);
    doAnswer(invocation -> ((Collection<StorageCommand>)invocation.getArgument(0)).add(new Command.RelationshipCountsCommand(1,2,3,4L))).when(storageEngine).createCommands(anyCollection(),any(ReadableTransactionState.class),any(StorageReader.class),any(ResourceLocker.class),anyLong(),any(TxStateVisitor.Decorator.class));
  }
  public KernelTransactionImplementation newTransaction(  long transactionTimeoutMillis){
    return newTransaction(0,AUTH_DISABLED,transactionTimeoutMillis);
  }
  public KernelTransactionImplementation newTransaction(  LoginContext loginContext){
    return newTransaction(0,loginContext);
  }
  public KernelTransactionImplementation newTransaction(  LoginContext loginContext,  Locks.Client locks){
    return newTransaction(0,loginContext,locks,defaultTransactionTimeoutMillis);
  }
  public KernelTransactionImplementation newTransaction(  long lastTransactionIdWhenStarted,  LoginContext loginContext){
    return newTransaction(lastTransactionIdWhenStarted,loginContext,defaultTransactionTimeoutMillis);
  }
  public KernelTransactionImplementation newTransaction(  long lastTransactionIdWhenStarted,  LoginContext loginContext,  long transactionTimeoutMillis){
    return newTransaction(lastTransactionIdWhenStarted,loginContext,new NoOpClient(),transactionTimeoutMillis);
  }
  public KernelTransactionImplementation newTransaction(  long lastTransactionIdWhenStarted,  LoginContext loginContext,  Locks.Client locks,  long transactionTimeout){
    KernelTransactionImplementation tx=newNotInitializedTransaction();
    StatementLocks statementLocks=new SimpleStatementLocks(locks);
    SecurityContext securityContext=loginContext.authorize(s -> -1,GraphDatabaseSettings.DEFAULT_DATABASE_NAME);
    tx.initialize(lastTransactionIdWhenStarted,BASE_TX_COMMIT_TIMESTAMP,statementLocks,Type.implicit,securityContext,transactionTimeout,1L);
    return tx;
  }
  public KernelTransactionImplementation newNotInitializedTransaction(){
    return new KernelTransactionImplementation(Config.defaults(),statementOperations,schemaWriteGuard,hooks,null,null,headerInformationFactory,commitProcess,transactionMonitor,auxTxStateManager,txPool,clock,new AtomicReference<>(CpuClock.NOT_AVAILABLE),new AtomicReference<>(HeapAllocation.NOT_AVAILABLE),TransactionTracer.NULL,LockTracer.NONE,PageCursorTracerSupplier.NULL,storageEngine,new CanWrite(),AutoIndexing.UNSUPPORTED,mock(ExplicitIndexStore.class),EmptyVersionContextSupplier.EMPTY,() -> collectionsFactory,new StandardConstraintSemantics(),mock(SchemaState.class),mock(IndexingService.class),mockedTokenHolders(),new Dependencies());
  }
public class CapturingCommitProcess implements TransactionCommitProcess {
    private long txId=TransactionIdStore.BASE_TX_ID;
    public TransactionRepresentation transaction;
    @Override public long commit(    TransactionToApply batch,    CommitEvent commitEvent,    TransactionApplicationMode mode){
      assert transaction == null : "Designed to only allow one transaction";
      assert batch.next() == null : "Designed to only allow one transaction";
      transaction=batch.transactionRepresentation();
      return ++txId;
    }
  }
private class TestCollectionsFactory implements CollectionsFactory {
    @Override public MutableLongSet newLongSet(){
      return OnHeapCollectionsFactory.INSTANCE.newLongSet();
    }
    @Override public MutableLongDiffSetsImpl newLongDiffSets(){
      return OnHeapCollectionsFactory.INSTANCE.newLongDiffSets();
    }
    @Override public MutableLongObjectMap<Value> newValuesMap(){
      return new LongObjectHashMap<>();
    }
    @Override public MemoryTracker getMemoryTracker(){
      return OnHeapCollectionsFactory.INSTANCE.getMemoryTracker();
    }
    @Override public void release(){
    }
  }
}
