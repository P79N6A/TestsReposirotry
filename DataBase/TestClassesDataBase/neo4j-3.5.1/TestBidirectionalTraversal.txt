public class TestBidirectionalTraversal extends TraversalTestBase {
  RelationshipType to=withName("TO");
  private Transaction tx;
  @Before public void init(){
    tx=beginTx();
  }
  @After public void tearDown(){
    tx.close();
  }
  @Test(expected=IllegalArgumentException.class) public void bothSidesMustHaveSameUniqueness(){
    createGraph("A TO B");
    Traverser traverse=getGraphDb().bidirectionalTraversalDescription().startSide(getGraphDb().traversalDescription().uniqueness(Uniqueness.NODE_GLOBAL)).endSide(getGraphDb().traversalDescription().uniqueness(Uniqueness.RELATIONSHIP_GLOBAL)).traverse(getNodeWithName("A"),getNodeWithName("B"));
    try (ResourceIterator<Path> iterator=traverse.iterator()){
      Iterators.count(iterator);
    }
   }
  @Test public void pathsForOneDirection(){
    createGraph("a TO b","b TO c","c TO d","d TO e","e TO f","f TO a");
    PathExpander<Void> expander=PathExpanders.forTypeAndDirection(to,OUTGOING);
    expectPaths(getGraphDb().bidirectionalTraversalDescription().mirroredSides(getGraphDb().traversalDescription().uniqueness(NODE_PATH).expand(expander)).traverse(getNodeWithName("a"),getNodeWithName("f")),"a,b,c,d,e,f");
    expectPaths(getGraphDb().bidirectionalTraversalDescription().mirroredSides(getGraphDb().traversalDescription().uniqueness(RELATIONSHIP_PATH).expand(expander)).traverse(getNodeWithName("a"),getNodeWithName("f")),"a,b,c,d,e,f","a,b,c,d,e,f");
  }
  @Test public void collisionEvaluator(){
    createGraph("a TO b","a TO c","c TO b","a TO d","d TO e","e TO b","e TO f","f TO b");
    PathExpander<Void> expander=PathExpanders.forTypeAndDirection(to,OUTGOING);
    BidirectionalTraversalDescription traversal=getGraphDb().bidirectionalTraversalDescription().mirroredSides(getGraphDb().traversalDescription().uniqueness(NODE_PATH).expand(expander));
    expectPaths(traversal.collisionEvaluator(includeIfContainsAll(getNodeWithName("e"))).traverse(getNodeWithName("a"),getNodeWithName("b")),"a,d,e,b","a,d,e,f,b");
    expectPaths(traversal.collisionEvaluator(includeIfContainsAll(getNodeWithName("e"),getNodeWithName("f"))).traverse(getNodeWithName("a"),getNodeWithName("b")),"a,d,e,f,b");
  }
  @Test public void multipleCollisionEvaluators(){
    createGraph("a TO b","b TO g","g TO c","a TO d","d TO e","e TO c","e TO f","f TO c");
    expectPaths(getGraphDb().bidirectionalTraversalDescription().mirroredSides(getGraphDb().traversalDescription().uniqueness(NODE_PATH)).collisionEvaluator(Evaluators.atDepth(3)).collisionEvaluator(includeIfContainsAll(getNodeWithName("e"))).traverse(getNodeWithName("a"),getNodeWithName("c")),"a,d,e,c");
  }
  @Test public void multipleStartAndEndNodes(){
    createGraph("a TO d","b TO d","c TO d","e TO d","e TO f","e TO g");
    PathExpander<Void> expander=PathExpanderBuilder.empty().add(to).build();
    TraversalDescription side=getGraphDb().traversalDescription().uniqueness(NODE_PATH).expand(expander);
    expectPaths(getGraphDb().bidirectionalTraversalDescription().mirroredSides(side).traverse(asList(getNodeWithName("a"),getNodeWithName("b"),getNodeWithName("c")),asList(getNodeWithName("f"),getNodeWithName("g"))),"a,d,e,f","a,d,e,g","b,d,e,f","b,d,e,g","c,d,e,f","c,d,e,g");
  }
  @Test public void ensureCorrectPathEntitiesInShortPath(){
    createGraph("a TO b");
    Node a=getNodeWithName("a");
    Node b=getNodeWithName("b");
    Relationship r=a.getSingleRelationship(to,OUTGOING);
    Path path=Iterables.single(getGraphDb().bidirectionalTraversalDescription().mirroredSides(getGraphDb().traversalDescription().relationships(to,OUTGOING).uniqueness(NODE_PATH)).collisionEvaluator(Evaluators.atDepth(1)).sideSelector(SideSelectorPolicies.LEVEL,1).traverse(a,b));
    assertContainsInOrder(path.nodes(),a,b);
    assertContainsInOrder(path.reverseNodes(),b,a);
    assertContainsInOrder(path.relationships(),r);
    assertContainsInOrder(path.reverseRelationships(),r);
    assertContainsInOrder(path,a,r,b);
    assertEquals(a,path.startNode());
    assertEquals(b,path.endNode());
    assertEquals(r,path.lastRelationship());
  }
  @Test public void mirroredTraversalReversesInitialState(){
    createGraph("a TO b","b TO c","c TO d");
    BranchCollisionPolicy collisionPolicy=(evaluator,pathPredicate) -> new StandardBranchCollisionDetector(null,null){
      @Override protected boolean includePath(      Path path,      TraversalBranch startPath,      TraversalBranch endPath){
        assertEquals(0,startPath.state());
        assertEquals(10,endPath.state());
        return true;
      }
    }
;
    Iterables.count(getGraphDb().bidirectionalTraversalDescription().mirroredSides(getGraphDb().traversalDescription().uniqueness(NODE_PATH).expand(PathExpanders.forType(to),new InitialBranchState.State<>(0,10))).collisionPolicy(collisionPolicy).traverse(getNodeWithName("a"),getNodeWithName("d")));
  }
}
