public class ProcedureSignatureTest {
  @Rule public ExpectedException exception=ExpectedException.none();
  private final ProcedureSignature signature=procedureSignature("asd").in("a",Neo4jTypes.NTAny).build();
  @Test public void inputSignatureShouldNotBeModifiable(){
    exception.expect(UnsupportedOperationException.class);
    signature.inputSignature().add(FieldSignature.inputField("b",Neo4jTypes.NTAny));
  }
  @Test public void outputSignatureShouldNotBeModifiable(){
    exception.expect(UnsupportedOperationException.class);
    signature.outputSignature().add(FieldSignature.outputField("b",Neo4jTypes.NTAny));
  }
  @Test public void shouldHonorVoidInEquals(){
    ProcedureSignature sig1=procedureSignature("foo").in("a",Neo4jTypes.NTAny).build();
    ProcedureSignature sig2=procedureSignature("foo").in("a",Neo4jTypes.NTAny).out(ProcedureSignature.VOID).build();
    ProcedureSignature sig2clone=procedureSignature("foo").in("a",Neo4jTypes.NTAny).out(ProcedureSignature.VOID).build();
    assertEquals(sig2,sig2clone);
    assertNotEquals(sig1,sig2);
  }
  @Test public void toStringShouldMatchCypherSyntax(){
    String toStr=procedureSignature("org","myProcedure").in("inputArg",Neo4jTypes.NTList(Neo4jTypes.NTString)).out("outputArg",Neo4jTypes.NTNumber).build().toString();
    assertEquals("org.myProcedure(inputArg :: LIST? OF STRING?) :: (outputArg :: NUMBER?)",toStr);
  }
  @Test public void toStringForVoidProcedureShouldMatchCypherSyntax(){
    ProcedureSignature proc=procedureSignature("org","myProcedure").in("inputArg",Neo4jTypes.NTList(Neo4jTypes.NTString)).out(ProcedureSignature.VOID).build();
    String toStr=proc.toString();
    assertEquals("org.myProcedure(inputArg :: LIST? OF STRING?) :: VOID",toStr);
  }
}
