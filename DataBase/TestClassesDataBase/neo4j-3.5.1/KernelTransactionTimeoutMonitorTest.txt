class KernelTransactionTimeoutMonitorTest {
  private static final int EXPECTED_REUSE_COUNT=2;
  private KernelTransactions kernelTransactions;
  private FakeClock fakeClock;
  private AssertableLogProvider logProvider;
  private LogService logService;
  @BeforeEach void setUp(){
    kernelTransactions=mock(KernelTransactions.class);
    fakeClock=Clocks.fakeClock();
    logProvider=new AssertableLogProvider();
    logService=new SimpleLogService(logProvider,logProvider);
  }
  @Test void terminateExpiredTransactions(){
    HashSet<KernelTransactionHandle> transactions=new HashSet<>();
    KernelTransactionImplementation tx1=prepareTxMock(3,1,3);
    KernelTransactionImplementation tx2=prepareTxMock(4,1,8);
    KernelTransactionImplementationHandle handle1=new KernelTransactionImplementationHandle(tx1,fakeClock);
    KernelTransactionImplementationHandle handle2=new KernelTransactionImplementationHandle(tx2,fakeClock);
    transactions.add(handle1);
    transactions.add(handle2);
    when(kernelTransactions.activeTransactions()).thenReturn(transactions);
    KernelTransactionMonitor transactionMonitor=buildTransactionMonitor();
    fakeClock.forward(3,TimeUnit.MILLISECONDS);
    transactionMonitor.run();
    verify(tx1,never()).markForTermination(Status.Transaction.TransactionTimedOut);
    verify(tx2,never()).markForTermination(Status.Transaction.TransactionTimedOut);
    logProvider.assertNoMessagesContaining("timeout");
    fakeClock.forward(2,TimeUnit.MILLISECONDS);
    transactionMonitor.run();
    verify(tx1).markForTermination(EXPECTED_REUSE_COUNT,Status.Transaction.TransactionTimedOut);
    verify(tx2,never()).markForTermination(Status.Transaction.TransactionTimedOut);
    logProvider.assertContainsLogCallContaining("timeout");
    logProvider.clear();
    fakeClock.forward(10,TimeUnit.MILLISECONDS);
    transactionMonitor.run();
    verify(tx2).markForTermination(EXPECTED_REUSE_COUNT,Status.Transaction.TransactionTimedOut);
    logProvider.assertContainsLogCallContaining("timeout");
  }
  @Test void skipTransactionWithoutTimeout(){
    HashSet<KernelTransactionHandle> transactions=new HashSet<>();
    KernelTransactionImplementation tx1=prepareTxMock(7,3,0);
    KernelTransactionImplementation tx2=prepareTxMock(8,4,0);
    KernelTransactionImplementationHandle handle1=new KernelTransactionImplementationHandle(tx1,fakeClock);
    KernelTransactionImplementationHandle handle2=new KernelTransactionImplementationHandle(tx2,fakeClock);
    transactions.add(handle1);
    transactions.add(handle2);
    when(kernelTransactions.activeTransactions()).thenReturn(transactions);
    KernelTransactionMonitor transactionMonitor=buildTransactionMonitor();
    fakeClock.forward(300,TimeUnit.MILLISECONDS);
    transactionMonitor.run();
    verify(tx1,never()).markForTermination(Status.Transaction.TransactionTimedOut);
    verify(tx2,never()).markForTermination(Status.Transaction.TransactionTimedOut);
    logProvider.assertNoMessagesContaining("timeout");
  }
  private KernelTransactionMonitor buildTransactionMonitor(){
    return new KernelTransactionMonitor(kernelTransactions,fakeClock,logService);
  }
  private static KernelTransactionImplementation prepareTxMock(  long userTxId,  long startMillis,  long timeoutMillis){
    KernelTransactionImplementation transaction=mock(KernelTransactionImplementation.class);
    when(transaction.startTime()).thenReturn(startMillis);
    when(transaction.userTransactionId()).thenReturn(userTxId);
    when(transaction.getReuseCount()).thenReturn(EXPECTED_REUSE_COUNT);
    when(transaction.timeout()).thenReturn(timeoutMillis);
    when(transaction.markForTermination(EXPECTED_REUSE_COUNT,Status.Transaction.TransactionTimedOut)).thenReturn(true);
    return transaction;
  }
}
