public class IndexEntryConflictExceptionTest {
  public static final int labelId=1;
  public static final Value value=Values.of("hi");
  @Test public void shouldMakeEntryConflicts(){
    LabelSchemaDescriptor schema=SchemaDescriptorFactory.forLabel(labelId,2);
    IndexEntryConflictException e=new IndexEntryConflictException(0L,1L,value);
    assertThat(e.evidenceMessage(SchemaUtil.idTokenNameLookup,schema),equalTo("Both Node(0) and Node(1) have the label `label[1]` and property `property[2]` = 'hi'"));
  }
  @Test public void shouldMakeEntryConflictsForOneNode(){
    LabelSchemaDescriptor schema=SchemaDescriptorFactory.forLabel(labelId,2);
    IndexEntryConflictException e=new IndexEntryConflictException(0L,StatementConstants.NO_SUCH_NODE,value);
    assertThat(e.evidenceMessage(SchemaUtil.idTokenNameLookup,schema),equalTo("Node(0) already exists with label `label[1]` and property `property[2]` = 'hi'"));
  }
  @Test public void shouldMakeCompositeEntryConflicts(){
    LabelSchemaDescriptor schema=SchemaDescriptorFactory.forLabel(labelId,2,3,4);
    ValueTuple values=ValueTuple.of(true,"hi",new long[]{6L,4L});
    IndexEntryConflictException e=new IndexEntryConflictException(0L,1L,values);
    assertThat(e.evidenceMessage(SchemaUtil.idTokenNameLookup,schema),equalTo("Both Node(0) and Node(1) have the label `label[1]` " + "and properties `property[2]` = true, `property[3]` = 'hi', `property[4]` = [6, 4]"));
  }
}
