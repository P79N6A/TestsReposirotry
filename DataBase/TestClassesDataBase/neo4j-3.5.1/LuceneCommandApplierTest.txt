@ExtendWith({EphemeralFileSystemExtension.class,TestDirectoryExtension.class}) class LuceneCommandApplierTest {
  @Inject private EphemeralFileSystemAbstraction fs;
  @Inject private TestDirectory testDirectory;
  @Test void shouldHandleMultipleIdSpaces() throws Exception {
    String indexName="name";
    String key="key";
    DatabaseLayout databaseLayout=testDirectory.databaseLayout();
    IndexConfigStore configStore=new IndexConfigStore(databaseLayout,fs);
    configStore.set(Node.class,indexName,EXACT_CONFIG);
    try (Lifespan lifespan=new Lifespan()){
      Config dataSourceConfig=Config.defaults(LuceneDataSource.Configuration.ephemeral,Settings.TRUE);
      LuceneDataSource originalDataSource=new LuceneDataSource(databaseLayout,dataSourceConfig,configStore,fs,OperationalMode.single);
      LuceneDataSource dataSource=lifespan.add(spy(originalDataSource));
      try (LuceneCommandApplier applier=new LuceneCommandApplier(dataSource,false)){
        IndexDefineCommand definitions=definitions(ObjectIntHashMap.newWithKeysValues(indexName,0),ObjectIntHashMap.newWithKeysValues(key,0));
        applier.visitIndexDefineCommand(definitions);
        applier.visitIndexAddNodeCommand(addNodeToIndex(definitions,indexName,0L));
        definitions=definitions(ObjectIntHashMap.newWithKeysValues(indexName,1),ObjectIntHashMap.newWithKeysValues(key,0));
        applier.visitIndexDefineCommand(definitions);
        applier.visitIndexAddNodeCommand(addNodeToIndex(definitions,indexName,1L));
      }
       verify(dataSource,times(1)).getIndexSearcher(any(IndexIdentifier.class));
    }
   }
  private static AddNodeCommand addNodeToIndex(  IndexDefineCommand definitions,  String indexName,  long nodeId){
    AddNodeCommand command=new AddNodeCommand();
    command.init(definitions.getOrAssignIndexNameId(indexName),nodeId,(byte)0,"some value");
    return command;
  }
  private static IndexDefineCommand definitions(  MutableObjectIntMap<String> names,  MutableObjectIntMap<String> keys){
    IndexDefineCommand definitions=new IndexDefineCommand();
    definitions.init(names,keys);
    return definitions;
  }
}
