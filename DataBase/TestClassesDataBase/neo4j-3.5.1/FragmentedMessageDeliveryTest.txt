/** 
 * This tests network fragmentation of messages. Given a set of messages, it will serialize and chunk the message up to a specified chunk size. Then it will split that data into a specified number of fragments, trying every possible permutation of fragment sizes for the specified number. For instance, assuming an unfragmented message size of 15, and a fragment count of 3, it will create fragment size permutations like: <p/> [1,1,13] [1,2,12] [1,3,11] .. [12,1,1] <p/> For each permutation, it delivers the fragments to the protocol implementation, and asserts the protocol handled them properly.
 */
@RunWith(Parameterized.class) public class FragmentedMessageDeliveryTest {
  private EmbeddedChannel channel;
  private int chunkSize=16;
  private RequestMessage[] messages=new RequestMessage[]{new RunMessage("Mjölnir")};
  @Parameter public Neo4jPack neo4jPack;
  @Parameters(name="{0}") public static List<Neo4jPack> parameters(){
    return Arrays.asList(new Neo4jPackV1(),new Neo4jPackV2());
  }
  @After public void cleanup(){
    if (channel != null) {
      channel.finishAndReleaseAll();
    }
  }
  @Test public void testFragmentedMessageDelivery() throws Throwable {
    byte[] unfragmented=serialize(chunkSize,messages);
    int n=unfragmented.length;
    for (int i=1; i < n - 1; i++) {
      for (int j=1; j < n - i; j++) {
        testPermutation(unfragmented,i,j,n - i - j);
      }
    }
  }
  private void testPermutation(  byte[] unfragmented,  int... sizes) throws Exception {
    int pos=0;
    ByteBuf[] fragments=new ByteBuf[sizes.length];
    for (int i=0; i < sizes.length; i++) {
      fragments[i]=wrappedBuffer(unfragmented,pos,sizes[i]);
      pos+=sizes[i];
    }
    testPermutation(unfragmented,fragments);
  }
  private void testPermutation(  byte[] unfragmented,  ByteBuf[] fragments) throws Exception {
    channel=new EmbeddedChannel();
    BoltChannel boltChannel=newBoltChannel(channel);
    BoltStateMachine machine=mock(BoltStateMachine.class);
    SynchronousBoltConnection boltConnection=new SynchronousBoltConnection(machine);
    NullLogService logging=NullLogService.getInstance();
    BoltProtocol boltProtocol=new BoltProtocolV1(boltChannel,(ch,s) -> boltConnection,(v,ch) -> machine,logging);
    boltProtocol.install();
    for (    ByteBuf fragment : fragments) {
      channel.writeInbound(fragment.readerIndex(0).retain());
    }
    try {
      RequestMessage run=new RunMessage("Mjölnir",EMPTY_MAP);
      verify(machine).process(eq(run),any(BoltResponseHandler.class));
    }
 catch (    AssertionError e) {
      throw new AssertionError("Failed to handle fragmented delivery.\n" + "Messages: " + Arrays.toString(messages) + "\n"+ "Chunk size: "+ chunkSize+ "\n"+ "Serialized data delivered in fragments: "+ describeFragments(fragments)+ "\n"+ "Unfragmented data: "+ HexPrinter.hex(unfragmented)+ "\n",e);
    }
  }
  private String describeFragments(  ByteBuf[] fragments){
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < fragments.length; i++) {
      if (i > 0) {
        sb.append(",");
      }
      sb.append(fragments[i].capacity());
    }
    return sb.toString();
  }
  private byte[] serialize(  int chunkSize,  RequestMessage... msgs) throws IOException {
    byte[][] serialized=new byte[msgs.length][];
    for (int i=0; i < msgs.length; i++) {
      RecordingByteChannel channel=new RecordingByteChannel();
      BoltRequestMessageWriter writer=new BoltRequestMessageWriter(new Neo4jPackV1().newPacker(new BufferedChannelOutput(channel)));
      writer.write(msgs[i]).flush();
      serialized[i]=channel.getBytes();
    }
    return Chunker.chunk(chunkSize,serialized);
  }
  private static BoltChannel newBoltChannel(  EmbeddedChannel rawChannel){
    BoltChannel boltChannel=mock(BoltChannel.class);
    when(boltChannel.rawChannel()).thenReturn(rawChannel);
    return boltChannel;
  }
}
