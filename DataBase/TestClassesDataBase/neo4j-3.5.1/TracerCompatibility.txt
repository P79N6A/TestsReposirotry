@Ignore("Not a test. This is a compatibility suite, run from LockingCompatibilityTestSuite.") public class TracerCompatibility extends LockingCompatibilityTestSuite.Compatibility {
  public TracerCompatibility(  LockingCompatibilityTestSuite suite){
    super(suite);
  }
  @Test public void shouldTraceWaitTimeWhenTryingToAcquireExclusiveLockAndExclusiveIsHeld() throws Exception {
    Tracer tracerA=new Tracer();
    Tracer tracerB=new Tracer();
    clientA.acquireExclusive(tracerA,NODE,17);
    Future<Object> future=acquireExclusive(clientB,tracerB,NODE,17).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,17);
    future.get();
    tracerA.assertCalls(0);
    tracerB.assertCalls(1);
  }
  @Test public void shouldTraceWaitTimeWhenTryingToAcquireSharedLockAndExclusiveIsHeld() throws Exception {
    Tracer tracerA=new Tracer();
    Tracer tracerB=new Tracer();
    clientA.acquireExclusive(tracerA,NODE,17);
    Future<Object> future=acquireShared(clientB,tracerB,NODE,17).callAndAssertWaiting();
    clientA.releaseExclusive(NODE,17);
    future.get();
    tracerA.assertCalls(0);
    tracerB.assertCalls(1);
  }
  @Test public void shouldTraceWaitTimeWhenTryingToAcquireExclusiveLockAndSharedIsHeld() throws Exception {
    Tracer tracerA=new Tracer();
    Tracer tracerB=new Tracer();
    clientA.acquireShared(tracerA,NODE,17);
    Future<Object> future=acquireExclusive(clientB,tracerB,NODE,17).callAndAssertWaiting();
    clientA.releaseShared(NODE,17);
    future.get();
    tracerA.assertCalls(0);
    tracerB.assertCalls(1);
  }
static class Tracer implements LockTracer, LockWaitEvent {
    int done;
    final List<StackTraceElement[]> waitCalls=new ArrayList<>();
    @Override public LockWaitEvent waitForLock(    boolean exclusive,    ResourceType resourceType,    long... resourceIds){
      waitCalls.add(Thread.currentThread().getStackTrace());
      return this;
    }
    @Override public void close(){
      done++;
    }
    void assertCalls(    int expected){
      if (waitCalls.size() != done) {
        throw withCallTraces(new AssertionError("Should complete waiting as many times as started."));
      }
      if (done != expected) {
        throw withCallTraces(new AssertionError(format("Expected %d calls, but got %d",expected,done)));
      }
    }
    private <EX extends Throwable>EX withCallTraces(    EX failure){
      for (      StackTraceElement[] waitCall : waitCalls) {
        RuntimeException call=new RuntimeException("Wait called");
        call.setStackTrace(waitCall);
        failure.addSuppressed(call);
      }
      return failure;
    }
  }
}
