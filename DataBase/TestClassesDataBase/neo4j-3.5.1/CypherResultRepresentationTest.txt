public class CypherResultRepresentationTest {
  @Rule public DatabaseRule database=new ImpermanentDatabaseRule();
  @Test @SuppressWarnings("unchecked") public void shouldSerializeProfilingResult() throws Exception {
    String name="Kalle";
    ExecutionPlanDescription plan=getMockDescription(name);
    ExecutionPlanDescription childPlan=getMockDescription("child");
    when(plan.getChildren()).thenReturn(asList(childPlan));
    when(plan.hasProfilerStatistics()).thenReturn(true);
    ExecutionPlanDescription.ProfilerStatistics stats=mock(ExecutionPlanDescription.ProfilerStatistics.class);
    when(stats.getDbHits()).thenReturn(13L);
    when(stats.getRows()).thenReturn(25L);
    when(plan.getProfilerStatistics()).thenReturn(stats);
    Result result=mock(Result.class);
    when(result.hasNext()).thenReturn(false);
    when(result.columns()).thenReturn(new ArrayList<>());
    when(result.getExecutionPlanDescription()).thenReturn(plan);
    Map<String,Object> serialized=serializeToStringThenParseAsToMap(new CypherResultRepresentation(result,false,true));
    Map<String,Object> serializedPlan=(Map<String,Object>)serialized.get("plan");
    assertThat(serializedPlan.get("name"),equalTo(name));
    assertThat(serializedPlan.get("rows"),is(25));
    assertThat(serializedPlan.get("dbHits"),is(13));
    List<Map<String,Object>> children=(List<Map<String,Object>>)serializedPlan.get("children");
    assertThat(children.size(),is(1));
    Map<String,Object> args=(Map<String,Object>)serializedPlan.get("args");
    assertThat(args.get("argumentKey"),is("argumentValue"));
  }
  @Test @SuppressWarnings("unchecked") public void shouldNotIncludePlanUnlessAskedFor() throws Exception {
    Result result=mock(Result.class);
    when(result.hasNext()).thenReturn(false);
    when(result.columns()).thenReturn(new ArrayList<>());
    Map<String,Object> serialized=serializeToStringThenParseAsToMap(new CypherResultRepresentation(result,false,false));
    assertFalse("Didn't expect to see a plan here",serialized.containsKey("plan"));
  }
  @Test public void shouldFormatMapsProperly() throws Exception {
    GraphDatabaseService graphdb=database.getGraphDatabaseAPI();
    Result result=graphdb.execute("RETURN {one:{two:['wait for it...', {three: 'GO!'}]}}");
    CypherResultRepresentation representation=new CypherResultRepresentation(result,false,false);
    Map<String,Object> serialized=serializeToStringThenParseAsToMap(representation);
    Map one=(Map)((Map)((List)((List)serialized.get("data")).get(0)).get(0)).get("one");
    List two=(List)one.get("two");
    assertThat(two.get(0),is("wait for it..."));
    Map foo=(Map)two.get(1);
    assertThat(foo.get("three"),is("GO!"));
  }
  @Test public void shouldRenderNestedEntities() throws Exception {
    try (Transaction ignored=database.getGraphDatabaseAPI().beginTx()){
      GraphDatabaseService graphdb=database.getGraphDatabaseAPI();
      graphdb.execute("CREATE (n {name: 'Sally'}), (m {age: 42}), (n)-[r:FOO {drunk: false}]->(m)");
      Result result=graphdb.execute("MATCH p=(n)-[r]->(m) RETURN n, r, p, {node: n, edge: r, path: p}");
      CypherResultRepresentation representation=new CypherResultRepresentation(result,false,false);
      Map<String,Object> serialized=serializeToStringThenParseAsToMap(representation);
      Object firstRow=((List)serialized.get("data")).get(0);
      Map nested=(Map)((List)firstRow).get(3);
      assertThat(nested.get("node"),is(equalTo(((List)firstRow).get(0))));
      assertThat(nested.get("edge"),is(equalTo(((List)firstRow).get(1))));
      assertThat(nested.get("path"),is(equalTo(((List)firstRow).get(2))));
    }
   }
  private ExecutionPlanDescription getMockDescription(  String name){
    ExecutionPlanDescription plan=mock(ExecutionPlanDescription.class);
    when(plan.getName()).thenReturn(name);
    when(plan.getArguments()).thenReturn(MapUtil.map("argumentKey","argumentValue"));
    return plan;
  }
  private Map<String,Object> serializeToStringThenParseAsToMap(  CypherResultRepresentation repr) throws Exception {
    OutputFormat format=new OutputFormat(new JsonFormat(),new URI("http://localhost/"),null);
    return jsonToMap(format.assemble(repr));
  }
}
