@ExtendWith(RandomExtension.class) class GenericKeyStateTest {
  private final IndexSpecificSpaceFillingCurveSettingsCache noSpecificIndexSettings=new IndexSpecificSpaceFillingCurveSettingsCache(new ConfiguredSpaceFillingCurveSettingsCache(Config.defaults()),new HashMap<>());
  @Inject private static RandomRule random;
  @BeforeEach void setupRandomConfig(){
    random=random.withConfiguration(new RandomValues.Configuration(){
      @Override public int stringMinLength(){
        return 0;
      }
      @Override public int stringMaxLength(){
        return 50;
      }
      @Override public int arrayMinLength(){
        return 0;
      }
      @Override public int arrayMaxLength(){
        return 10;
      }
      @Override public int maxCodePoint(){
        return RandomValues.MAX_BMP_CODE_POINT;
      }
    }
);
    random.reset();
  }
  @ParameterizedTest @MethodSource("validValueGenerators") void readWhatIsWritten(  ValueGenerator valueGenerator){
    PageCursor cursor=newPageCursor();
    GenericKey writeState=newKeyState();
    Value value=valueGenerator.next();
    int offset=cursor.getOffset();
    writeState.writeValue(value,NEUTRAL);
    writeState.put(cursor);
    GenericKey readState=newKeyState();
    int size=writeState.size();
    cursor.setOffset(offset);
    assertTrue(readState.get(cursor,size),"failed to read");
    assertEquals(0,readState.compareValueTo(writeState),"key states are not equal");
    Value readValue=readState.asValue();
    assertEquals(value,readValue,"deserialized values are not equal");
  }
  @ParameterizedTest @MethodSource("validValueGenerators") void copyShouldCopy(  ValueGenerator valueGenerator){
    GenericKey from=newKeyState();
    Value value=valueGenerator.next();
    from.writeValue(value,NEUTRAL);
    GenericKey to=genericKeyStateWithSomePreviousState(valueGenerator);
    to.copyFrom(from);
    assertEquals(0,from.compareValueTo(to),"states not equals after copy");
  }
  @Test void copyShouldCopyExtremeValues(){
    GenericKey extreme=newKeyState();
    GenericKey copy=newKeyState();
    for (    ValueGroup valueGroup : ValueGroup.values()) {
      if (valueGroup != ValueGroup.NO_VALUE) {
        extreme.initValueAsLowest(valueGroup);
        copy.copyFrom(extreme);
        assertEquals(0,extreme.compareValueTo(copy),"states not equals after copy, valueGroup=" + valueGroup);
        extreme.initValueAsHighest(valueGroup);
        copy.copyFrom(extreme);
        assertEquals(0,extreme.compareValueTo(copy),"states not equals after copy, valueGroup=" + valueGroup);
      }
    }
  }
  @ParameterizedTest @MethodSource("validComparableValueGenerators") void compareToMustAlignWithValuesCompareTo(  ValueGenerator valueGenerator){
    List<Value> values=new ArrayList<>();
    List<GenericKey> states=new ArrayList<>();
    for (int i=0; i < 10; i++) {
      Value value=valueGenerator.next();
      values.add(value);
      GenericKey state=newKeyState();
      state.writeValue(value,NEUTRAL);
      states.add(state);
    }
    values.sort(COMPARATOR);
    states.sort(GenericKey::compareValueTo);
    for (int i=0; i < values.size(); i++) {
      assertEquals(values.get(i),states.get(i).asValue(),"sort order was different");
    }
  }
  @Test void comparePointsMustOnlyReturnZeroForEqualPoints(){
    PointValue firstPoint=random.randomValues().nextPointValue();
    PointValue equalPoint=Values.point(firstPoint);
    CoordinateReferenceSystem crs=firstPoint.getCoordinateReferenceSystem();
    SpaceFillingCurve curve=noSpecificIndexSettings.forCrs(crs,false);
    Long spaceFillingCurveValue=curve.derivedValueFor(firstPoint.coordinate());
    PointValue centerPoint=Values.pointValue(crs,curve.centerPointFor(spaceFillingCurveValue));
    GenericKey firstKey=newKeyState();
    firstKey.writeValue(firstPoint,NEUTRAL);
    GenericKey equalKey=newKeyState();
    equalKey.writeValue(equalPoint,NEUTRAL);
    GenericKey centerKey=newKeyState();
    centerKey.writeValue(centerPoint,NEUTRAL);
    GenericKey noCoordsKey=newKeyState();
    noCoordsKey.writeValue(equalPoint,NEUTRAL);
    GeometryType.setNoCoordinates(noCoordsKey);
    assertEquals(0,firstKey.compareValueTo(equalKey),"expected keys to be equal");
    assertEquals(firstPoint.compareTo(centerPoint) != 0,firstKey.compareValueTo(centerKey) != 0,"expected keys to be equal if and only if source points are equal");
    assertEquals(0,firstKey.compareValueTo(noCoordsKey),"expected keys to be equal");
  }
  @Test void comparePointArraysMustOnlyReturnZeroForEqualArrays(){
    PointArray firstArray=random.randomValues().nextPointArray();
    PointValue[] sourcePointValues=firstArray.asObjectCopy();
    PointArray equalArray=Values.pointArray(sourcePointValues);
    PointValue[] centerPointValues=new PointValue[sourcePointValues.length];
    for (int i=0; i < sourcePointValues.length; i++) {
      PointValue sourcePointValue=sourcePointValues[i];
      CoordinateReferenceSystem crs=sourcePointValue.getCoordinateReferenceSystem();
      SpaceFillingCurve curve=noSpecificIndexSettings.forCrs(crs,false);
      Long spaceFillingCurveValue=curve.derivedValueFor(sourcePointValue.coordinate());
      centerPointValues[i]=Values.pointValue(crs,curve.centerPointFor(spaceFillingCurveValue));
    }
    PointArray centerArray=Values.pointArray(centerPointValues);
    GenericKey firstKey=newKeyState();
    firstKey.writeValue(firstArray,NEUTRAL);
    GenericKey equalKey=newKeyState();
    equalKey.writeValue(equalArray,NEUTRAL);
    GenericKey centerKey=newKeyState();
    centerKey.writeValue(centerArray,NEUTRAL);
    GenericKey noCoordsKey=newKeyState();
    noCoordsKey.writeValue(equalArray,NEUTRAL);
    GeometryType.setNoCoordinates(noCoordsKey);
    assertEquals(0,firstKey.compareValueTo(equalKey),"expected keys to be equal");
    assertEquals(firstArray.compareToSequence(centerArray,AnyValues.COMPARATOR) != 0,firstKey.compareValueTo(centerKey) != 0,"expected keys to be equal if and only if source points are equal");
    assertEquals(0,firstKey.compareValueTo(noCoordsKey),"expected keys to be equal");
  }
  @ParameterizedTest @MethodSource("validComparableValueGenerators") void mustProduceValidMinimalSplitters(  ValueGenerator valueGenerator){
    Value value1=valueGenerator.next();
    Value value2;
    do {
      value2=valueGenerator.next();
    }
 while (COMPARATOR.compare(value1,value2) == 0);
    Value left=pickSmaller(value1,value2);
    Value right=left == value1 ? value2 : value1;
    assertValidMinimalSplitter(left,right);
  }
  @ParameterizedTest @MethodSource("validValueGenerators") void mustProduceValidMinimalSplittersWhenValuesAreEqual(  ValueGenerator valueGenerator){
    assertValidMinimalSplitterForEqualValues(valueGenerator.next());
  }
  @ParameterizedTest @MethodSource("validValueGenerators") void mustReportCorrectSize(  ValueGenerator valueGenerator){
    PageCursor cursor=newPageCursor();
    Value value=valueGenerator.next();
    GenericKey state=newKeyState();
    state.writeValue(value,NEUTRAL);
    int offsetBefore=cursor.getOffset();
    int reportedSize=state.size();
    state.put(cursor);
    int offsetAfter=cursor.getOffset();
    int actualSize=offsetAfter - offsetBefore;
    assertEquals(reportedSize,actualSize,String.format("did not report correct size, value=%s, actualSize=%d, reportedSize=%d",value,actualSize,reportedSize));
  }
  @Test void lowestMustBeLowest(){
    assertLowest(PointValue.MIN_VALUE);
    assertLowest(DateTimeValue.MIN_VALUE);
    assertLowest(LocalDateTimeValue.MIN_VALUE);
    assertLowest(DateValue.MIN_VALUE);
    assertLowest(TimeValue.MIN_VALUE);
    assertLowest(LocalTimeValue.MIN_VALUE);
    assertLowest(DurationValue.duration(Duration.ofSeconds(Long.MIN_VALUE,0)));
    assertLowest(DurationValue.duration(Period.of(Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE)));
    assertLowest(of(UTF8.decode(new byte[0])));
    assertLowest(of(false));
    assertLowest(of(Byte.MIN_VALUE));
    assertLowest(of(Short.MIN_VALUE));
    assertLowest(of(Integer.MIN_VALUE));
    assertLowest(of(Long.MIN_VALUE));
    assertLowest(of(Float.NEGATIVE_INFINITY));
    assertLowest(of(Double.NEGATIVE_INFINITY));
    assertLowest(pointArray(new PointValue[0]));
    assertLowest(dateTimeArray(new ZonedDateTime[0]));
    assertLowest(localDateTimeArray(new LocalDateTime[0]));
    assertLowest(dateArray(new LocalDate[0]));
    assertLowest(timeArray(new OffsetTime[0]));
    assertLowest(localTimeArray(new LocalTime[0]));
    assertLowest(durationArray(new DurationValue[0]));
    assertLowest(durationArray(new TemporalAmount[0]));
    assertLowest(of(new String[0]));
    assertLowest(of(new boolean[0]));
    assertLowest(of(new byte[0]));
    assertLowest(of(new short[0]));
    assertLowest(of(new int[0]));
    assertLowest(of(new long[0]));
    assertLowest(of(new float[0]));
    assertLowest(of(new double[0]));
  }
  @Test void highestMustBeHighest(){
    assertHighest(PointValue.MAX_VALUE);
    assertHighest(DateTimeValue.MAX_VALUE);
    assertHighest(LocalDateTimeValue.MAX_VALUE);
    assertHighest(DateValue.MAX_VALUE);
    assertHighest(TimeValue.MAX_VALUE);
    assertHighest(LocalTimeValue.MAX_VALUE);
    assertHighest(DurationValue.duration(Duration.ofSeconds(Long.MAX_VALUE,999_999_999)));
    assertHighest(DurationValue.duration(Period.of(Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE)));
    assertHighestString();
    assertHighest(of(true));
    assertHighest(of(Byte.MAX_VALUE));
    assertHighest(of(Short.MAX_VALUE));
    assertHighest(of(Integer.MAX_VALUE));
    assertHighest(of(Long.MAX_VALUE));
    assertHighest(of(Float.POSITIVE_INFINITY));
    assertHighest(of(Double.POSITIVE_INFINITY));
    assertHighest(pointArray(new PointValue[]{PointValue.MAX_VALUE}));
    assertHighest(dateTimeArray(new ZonedDateTime[]{DateTimeValue.MAX_VALUE.asObjectCopy()}));
    assertHighest(localDateTimeArray(new LocalDateTime[]{LocalDateTimeValue.MAX_VALUE.asObjectCopy()}));
    assertHighest(dateArray(new LocalDate[]{DateValue.MAX_VALUE.asObjectCopy()}));
    assertHighest(timeArray(new OffsetTime[]{TimeValue.MAX_VALUE.asObjectCopy()}));
    assertHighest(localTimeArray(new LocalTime[]{LocalTimeValue.MAX_VALUE.asObjectCopy()}));
    assertHighest(durationArray(new DurationValue[]{DurationValue.duration(Duration.ofSeconds(Long.MAX_VALUE,999_999_999))}));
    assertHighest(durationArray(new DurationValue[]{DurationValue.duration(Period.of(Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE))}));
    assertHighest(durationArray(new TemporalAmount[]{Duration.ofSeconds(Long.MAX_VALUE,999_999_999)}));
    assertHighest(durationArray(new TemporalAmount[]{Period.of(Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE)}));
    assertHighestStringArray();
    assertHighest(booleanArray(new boolean[]{true}));
    assertHighest(byteArray(new byte[]{Byte.MAX_VALUE}));
    assertHighest(shortArray(new short[]{Short.MAX_VALUE}));
    assertHighest(intArray(new int[]{Integer.MAX_VALUE}));
    assertHighest(longArray(new long[]{Long.MAX_VALUE}));
    assertHighest(floatArray(new float[]{Float.POSITIVE_INFINITY}));
    assertHighest(doubleArray(new double[]{Double.POSITIVE_INFINITY}));
  }
  @Test void shouldNeverOverwriteDereferencedTextValues(){
    Value srcValue=Values.utf8Value("First string".getBytes(StandardCharsets.UTF_8));
    GenericKey genericKeyState=newKeyState();
    genericKeyState.writeValue(srcValue,NEUTRAL);
    Value dereferencedValue=genericKeyState.asValue();
    assertEquals(srcValue,dereferencedValue);
    PageCursor cursor=newPageCursor();
    int offset=cursor.getOffset();
    genericKeyState.put(cursor);
    int keySize=cursor.getOffset() - offset;
    cursor.setOffset(offset);
    genericKeyState.clear();
    Value srcValue2=Values.utf8Value("Secondstring".getBytes(StandardCharsets.UTF_8));
    genericKeyState.writeValue(srcValue2,NEUTRAL);
    Value dereferencedValue2=genericKeyState.asValue();
    assertEquals(srcValue2,dereferencedValue2);
    assertEquals(srcValue,dereferencedValue);
    genericKeyState.clear();
    genericKeyState.get(cursor,keySize);
    Value dereferencedValue3=genericKeyState.asValue();
    assertEquals(srcValue,dereferencedValue3);
    assertEquals(srcValue2,dereferencedValue2);
    assertEquals(srcValue,dereferencedValue);
  }
  @Test void indexedCharShouldComeBackAsCharValue(){
    shouldReadBackToExactOriginalValue(random.randomValues().nextCharValue());
  }
  @Test void indexedCharArrayShouldComeBackAsCharArrayValue(){
    shouldReadBackToExactOriginalValue(random.randomValues().nextCharArray());
  }
  private void shouldReadBackToExactOriginalValue(  Value srcValue){
    GenericKey state=newKeyState();
    state.clear();
    state.writeValue(srcValue,NEUTRAL);
    Value retrievedValueAfterWrittenToState=state.asValue();
    assertEquals(srcValue,retrievedValueAfterWrittenToState);
    assertEquals(srcValue.getClass(),retrievedValueAfterWrittenToState.getClass());
    PageCursor cursor=newPageCursor();
    int offset=cursor.getOffset();
    state.put(cursor);
    int keySize=cursor.getOffset() - offset;
    cursor.setOffset(offset);
    state.clear();
    state.get(cursor,keySize);
    Value retrievedValueAfterReadFromCursor=state.asValue();
    assertEquals(srcValue,retrievedValueAfterReadFromCursor);
    assertEquals(srcValue.getClass(),retrievedValueAfterReadFromCursor.getClass());
  }
  private void assertHighestStringArray(){
    for (int i=0; i < 1000; i++) {
      assertHighest(random.randomValues().nextTextArray());
    }
  }
  private void assertHighestString(){
    for (int i=0; i < 1000; i++) {
      assertHighest(random.randomValues().nextTextValue());
    }
  }
  private void assertHighest(  Value value){
    GenericKey highestOfAll=newKeyState();
    GenericKey highestInValueGroup=newKeyState();
    GenericKey other=newKeyState();
    highestOfAll.initValueAsHighest(ValueGroup.UNKNOWN);
    highestInValueGroup.initValueAsHighest(value.valueGroup());
    other.writeValue(value,NEUTRAL);
    assertTrue(highestInValueGroup.compareValueTo(other) > 0,"highestInValueGroup not higher than " + value);
    assertTrue(highestOfAll.compareValueTo(other) > 0,"highestOfAll not higher than " + value);
    assertTrue(highestOfAll.compareValueTo(highestInValueGroup) > 0 || highestOfAll.type == highestInValueGroup.type,"highestOfAll not higher than highestInValueGroup");
  }
  private void assertLowest(  Value value){
    GenericKey lowestOfAll=newKeyState();
    GenericKey lowestInValueGroup=newKeyState();
    GenericKey other=newKeyState();
    lowestOfAll.initValueAsLowest(ValueGroup.UNKNOWN);
    lowestInValueGroup.initValueAsLowest(value.valueGroup());
    other.writeValue(value,NEUTRAL);
    assertTrue(lowestInValueGroup.compareValueTo(other) <= 0);
    assertTrue(lowestOfAll.compareValueTo(other) <= 0);
    assertTrue(lowestOfAll.compareValueTo(lowestInValueGroup) <= 0);
  }
  private Value pickSmaller(  Value value1,  Value value2){
    return COMPARATOR.compare(value1,value2) < 0 ? value1 : value2;
  }
  private void assertValidMinimalSplitter(  Value left,  Value right){
    GenericKey leftState=newKeyState();
    leftState.writeValue(left,NEUTRAL);
    GenericKey rightState=newKeyState();
    rightState.writeValue(right,NEUTRAL);
    GenericKey minimalSplitter=newKeyState();
    rightState.minimalSplitter(leftState,rightState,minimalSplitter);
    assertTrue(leftState.compareValueTo(minimalSplitter) < 0,"left state not less than minimal splitter, leftState=" + leftState + ", rightState="+ rightState+ ", minimalSplitter="+ minimalSplitter);
    assertTrue(rightState.compareValueTo(minimalSplitter) >= 0,"right state not less than minimal splitter, leftState=" + leftState + ", rightState="+ rightState+ ", minimalSplitter="+ minimalSplitter);
  }
  private void assertValidMinimalSplitterForEqualValues(  Value value){
    GenericKey leftState=newKeyState();
    leftState.writeValue(value,NEUTRAL);
    GenericKey rightState=newKeyState();
    rightState.writeValue(value,NEUTRAL);
    GenericKey minimalSplitter=newKeyState();
    rightState.minimalSplitter(leftState,rightState,minimalSplitter);
    assertEquals(0,leftState.compareValueTo(minimalSplitter),"left state not equal to minimal splitter, leftState=" + leftState + ", rightState="+ rightState+ ", minimalSplitter="+ minimalSplitter);
    assertEquals(0,rightState.compareValueTo(minimalSplitter),"right state not equal to minimal splitter, leftState=" + leftState + ", rightState="+ rightState+ ", minimalSplitter="+ minimalSplitter);
  }
  private static Value nextValidValue(  boolean includeIncomparable){
    Value value;
    do {
      value=random.randomValues().nextValue();
    }
 while (!includeIncomparable && isIncomparable(value));
    return value;
  }
  private static boolean isIncomparable(  Value value){
    return isGeometryValue(value) || isGeometryArray(value);
  }
  private static ValueGenerator[] listValueGenerators(  boolean includeIncomparable){
    List<ValueGenerator> generators=new ArrayList<>(asList(() -> random.randomValues().nextDateTimeValue(),() -> random.randomValues().nextLocalDateTimeValue(),() -> random.randomValues().nextDateValue(),() -> random.randomValues().nextTimeValue(),() -> random.randomValues().nextLocalTimeValue(),() -> random.randomValues().nextPeriod(),() -> random.randomValues().nextDuration(),() -> random.randomValues().nextCharValue(),() -> random.randomValues().nextTextValue(),() -> random.randomValues().nextAlphaNumericTextValue(),() -> random.randomValues().nextBooleanValue(),() -> random.randomValues().nextNumberValue(),() -> random.randomValues().nextDateTimeArray(),() -> random.randomValues().nextLocalDateTimeArray(),() -> random.randomValues().nextDateArray(),() -> random.randomValues().nextTimeArray(),() -> random.randomValues().nextLocalTimeArray(),() -> random.randomValues().nextDurationArray(),() -> random.randomValues().nextDurationArray(),() -> random.randomValues().nextCharArray(),() -> random.randomValues().nextTextArray(),() -> random.randomValues().nextAlphaNumericTextArray(),() -> random.randomValues().nextBooleanArray(),() -> random.randomValues().nextByteArray(),() -> random.randomValues().nextShortArray(),() -> random.randomValues().nextIntArray(),() -> random.randomValues().nextLongArray(),() -> random.randomValues().nextFloatArray(),() -> random.randomValues().nextDoubleArray(),() -> nextValidValue(includeIncomparable)));
    if (includeIncomparable) {
      generators.addAll(asList(() -> random.randomValues().nextPointValue(),() -> random.randomValues().nextGeographicPoint(),() -> random.randomValues().nextGeographic3DPoint(),() -> random.randomValues().nextCartesianPoint(),() -> random.randomValues().nextCartesian3DPoint(),() -> random.randomValues().nextGeographicPointArray(),() -> random.randomValues().nextGeographic3DPoint(),() -> random.randomValues().nextCartesianPointArray(),() -> random.randomValues().nextCartesian3DPointArray()));
    }
    return generators.toArray(new ValueGenerator[0]);
  }
  private static Stream<ValueGenerator> validValueGenerators(){
    return Stream.of(listValueGenerators(true));
  }
  private static Stream<ValueGenerator> validComparableValueGenerators(){
    return Stream.of(listValueGenerators(false));
  }
  private GenericKey genericKeyStateWithSomePreviousState(  ValueGenerator valueGenerator){
    GenericKey to=newKeyState();
    if (random.nextBoolean()) {
      NativeIndexKey.Inclusion inclusion=random.among(NativeIndexKey.Inclusion.values());
      Value value=valueGenerator.next();
      to.writeValue(value,inclusion);
    }
    return to;
  }
  private PageCursor newPageCursor(){
    return ByteArrayPageCursor.wrap(PageCache.PAGE_SIZE);
  }
  private GenericKey newKeyState(){
    return new GenericKey(noSpecificIndexSettings);
  }
@FunctionalInterface private interface ValueGenerator {
    Value next();
  }
}
