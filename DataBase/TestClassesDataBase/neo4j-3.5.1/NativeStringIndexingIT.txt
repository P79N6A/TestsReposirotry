public class NativeStringIndexingIT {
  private static final Label LABEL=TestLabels.LABEL_ONE;
  private static final String KEY="key";
  private static final String KEY2="key2";
  @Rule public final DatabaseRule db=new EmbeddedDatabaseRule().withSetting(GraphDatabaseSettings.default_schema_provider,GraphDatabaseSettings.SchemaIndex.NATIVE20.providerName());
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldHandleSizesCloseToTheLimit(){
    createIndex(KEY);
    Map<String,Long> strings=new HashMap<>();
    try (Transaction tx=db.beginTx()){
      for (int i=0; i < 1_000; i++) {
        String string;
        do {
          string=random.nextAlphaNumericString(3_000,4_000);
        }
 while (strings.containsKey(string));
        Node node=db.createNode(LABEL);
        node.setProperty(KEY,string);
        strings.put(string,node.getId());
      }
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      for (      String string : strings.keySet()) {
        Node node=db.findNode(LABEL,KEY,string);
        assertEquals(strings.get(string).longValue(),node.getId());
      }
      tx.success();
    }
   }
  @Test public void shouldFailBeforeCommitOnSizesLargerThanLimit(){
    createIndex(KEY);
    int length=5_000;
    try {
      try (Transaction tx=db.beginTx()){
        db.createNode(LABEL).setProperty(KEY,random.nextAlphaNumericString(length,length));
        tx.success();
      }
       fail("Should have failed");
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.getMessage(),containsString("Property value size is too large for index. Please see index documentation for limitations."));
    }
  }
  @Test public void shouldHandleCompositeSizesCloseToTheLimit() throws KernelException {
    createIndex(KEY,KEY2);
    int length=20_000;
    String string1=random.nextAlphaNumericString(length,length);
    String string2=random.nextAlphaNumericString(length,length);
    Node node;
    try (Transaction tx=db.beginTx()){
      node=db.createNode(LABEL);
      node.setProperty(KEY,string1);
      node.setProperty(KEY2,string2);
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      KernelTransaction ktx=db.getDependencyResolver().resolveDependency(ThreadToStatementContextBridge.class).getKernelTransactionBoundToThisThread(true);
      int labelId=ktx.tokenRead().nodeLabel(LABEL.name());
      int propertyKeyId1=ktx.tokenRead().propertyKey(KEY);
      int propertyKeyId2=ktx.tokenRead().propertyKey(KEY2);
      try (NodeValueIndexCursor cursor=ktx.cursors().allocateNodeValueIndexCursor()){
        ktx.dataRead().nodeIndexSeek(TestIndexDescriptorFactory.forLabel(labelId,propertyKeyId1,propertyKeyId2),cursor,IndexOrder.NONE,false,IndexQuery.exact(propertyKeyId1,string1),IndexQuery.exact(propertyKeyId2,string2));
        assertTrue(cursor.next());
        assertEquals(node.getId(),cursor.nodeReference());
        assertFalse(cursor.next());
      }
       tx.success();
    }
   }
  @Test public void shouldFailBeforeCommitOnCompositeSizesLargerThanLimit(){
    createIndex(KEY,KEY2);
    int length=50_000;
    try {
      try (Transaction tx=db.beginTx()){
        Node node=db.createNode(LABEL);
        node.setProperty(KEY,random.nextAlphaNumericString(length,length));
        node.setProperty(KEY2,random.nextAlphaNumericString(length,length));
        tx.success();
      }
       fail("Should have failed");
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.getMessage(),containsString("Property value size is too large for index. Please see index documentation for limitations."));
    }
  }
  private void createIndex(  String... keys){
    try (Transaction tx=db.beginTx()){
      IndexCreator indexCreator=db.schema().indexFor(LABEL);
      for (      String key : keys) {
        indexCreator=indexCreator.on(key);
      }
      indexCreator.create();
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(10,SECONDS);
      tx.success();
    }
   }
}
