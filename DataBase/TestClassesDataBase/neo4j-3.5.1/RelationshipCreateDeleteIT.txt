/** 
 * Testing on database level that creating and deleting relationships over the the same two nodes doesn't create unnecessary deadlock scenarios, i.e. that locking order is predictable and symmetrical Also test that relationship chains are consistently read during concurrent updates.
 */
public class RelationshipCreateDeleteIT {
  @Rule public final DatabaseRule db=new ImpermanentDatabaseRule();
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldNotDeadlockOrCrashFromInconsistency() throws Throwable {
    final Node a;
    final Node b;
    try (Transaction tx=db.beginTx()){
      (a=db.createNode()).createRelationshipTo(b=db.createNode(),MyRelTypes.TEST);
      tx.success();
    }
     Race race=new Race();
    for (int i=0; i < 30; i++) {
      race.addContestant(() -> {
        for (int j=0; j < 10; j++) {
          try (Transaction tx=db.beginTx()){
            Node node=random.nextBoolean() ? a : b;
            for (            Relationship relationship : node.getRelationships()) {
              try {
                relationship.delete();
              }
 catch (              NotFoundException e) {
                assertTrue(e.getMessage().contains("already deleted"));
              }
            }
            tx.success();
          }
         }
      }
);
    }
    for (int i=0; i < 30; i++) {
      race.addContestant(() -> {
        for (int j=0; j < 10; j++) {
          try (Transaction tx=db.beginTx()){
            boolean order=random.nextBoolean();
            Node start=order ? a : b;
            Node end=order ? b : a;
            start.createRelationshipTo(end,MyRelTypes.TEST);
            tx.success();
          }
         }
      }
);
    }
    race.go();
  }
}
