class ConsistencyCheckerTest {
  @Test void shouldThrowDescriptiveExceptionOnBrokenGSPP() throws Exception {
    int pageSize=256;
    PageCursor cursor=new PageAwareByteArrayCursor(pageSize);
    long stableGeneration=MIN_GENERATION;
    long crashGeneration=stableGeneration + 1;
    long unstableGeneration=stableGeneration + 2;
    String pointerFieldName="abc";
    long pointer=123;
    cursor.next(0);
    new TreeNodeFixedSize<>(pageSize,longLayout().build()).initializeInternal(cursor,stableGeneration,crashGeneration);
    TreeNode.setSuccessor(cursor,pointer,stableGeneration,crashGeneration);
    CursorException exception=assertThrows(CursorException.class,() -> {
      assertNoCrashOrBrokenPointerInGSPP(cursor,stableGeneration,unstableGeneration,pointerFieldName,TreeNode.BYTE_POS_SUCCESSOR);
      cursor.checkAndClearCursorException();
    }
);
    assertThat(exception.getMessage(),allOf(containsString(pointerFieldName),containsString(pointerFieldName),containsString("state=CRASH"),containsString("state=EMPTY"),containsString(String.valueOf(pointer))));
  }
  @Test void shouldDetectUnusedPages() throws Exception {
    int pageSize=256;
    Layout<MutableLong,MutableLong> layout=longLayout().build();
    TreeNode<MutableLong,MutableLong> node=new TreeNodeFixedSize<>(pageSize,layout);
    long stableGeneration=GenerationSafePointer.MIN_GENERATION;
    long unstableGeneration=stableGeneration + 1;
    PageAwareByteArrayCursor cursor=new PageAwareByteArrayCursor(pageSize);
    SimpleIdProvider idProvider=new SimpleIdProvider(cursor::duplicate);
    InternalTreeLogic<MutableLong,MutableLong> logic=new InternalTreeLogic<>(idProvider,node,layout);
    cursor.next(idProvider.acquireNewId(stableGeneration,unstableGeneration));
    node.initializeLeaf(cursor,stableGeneration,unstableGeneration);
    logic.initialize(cursor);
    StructurePropagation<MutableLong> structure=new StructurePropagation<>(layout.newKey(),layout.newKey(),layout.newKey());
    MutableLong key=layout.newKey();
    for (int g=0, k=0; g < 3; g++) {
      for (int i=0; i < 100; i++, k++) {
        key.setValue(k);
        logic.insert(cursor,structure,key,key,ValueMergers.overwrite(),stableGeneration,unstableGeneration);
        if (structure.hasRightKeyInsert) {
          goTo(cursor,"new root",idProvider.acquireNewId(stableGeneration,unstableGeneration));
          node.initializeInternal(cursor,stableGeneration,unstableGeneration);
          node.setChildAt(cursor,structure.midChild,0,stableGeneration,unstableGeneration);
          node.insertKeyAndRightChildAt(cursor,structure.rightKey,structure.rightChild,0,0,stableGeneration,unstableGeneration);
          TreeNode.setKeyCount(cursor,1);
          logic.initialize(cursor);
        }
        if (structure.hasMidChildUpdate) {
          logic.initialize(cursor);
        }
        structure.clear();
      }
      stableGeneration=unstableGeneration;
      unstableGeneration++;
    }
    ConsistencyChecker<MutableLong> cc=new ConsistencyChecker<>(node,layout,stableGeneration,unstableGeneration);
    RuntimeException exception=assertThrows(RuntimeException.class,() -> cc.checkSpace(cursor,idProvider.lastId(),ImmutableEmptyLongIterator.INSTANCE));
    assertThat(exception.getMessage(),containsString("unused pages"));
  }
}
