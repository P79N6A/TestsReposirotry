@Nested class IterationConcurrentModification {
  @Test void put(){
    testIteratorsFail(m -> m.put(0,0),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.put(1,1),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.put(0,0),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.put(1,1),pair(0L,10L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.put(2,2),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.put(4,14),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
  }
  @Test void getIfAbsentPut_put(){
    testIteratorsFail(m -> m.getIfAbsentPut(0,0),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.getIfAbsentPut(1,1),pair(0L,10L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.getIfAbsentPut(4,4),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
  }
  @Test void getIfAbsentPut_onlyGetNoPut(){
    fill(map,0L,1L,2L,3L);
    final MutableLongIterator keyIter=map.longIterator();
    final Iterator<LongLongPair> keyValueIter=map.keyValuesView().iterator();
    map.getIfAbsentPut(0,0);
    map.getIfAbsentPut(1,1);
    map.getIfAbsentPut(2,2);
    assertDoesNotThrow(keyIter::hasNext);
    assertDoesNotThrow(keyIter::next);
    assertDoesNotThrow(keyValueIter::hasNext);
    assertDoesNotThrow(keyValueIter::next);
  }
  @Test void remove(){
    testIteratorsFail(m -> m.remove(0),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.remove(1),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.remove(0),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.remove(1),pair(0L,10L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.remove(2),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.remove(4),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
  }
  @Test void putAll(){
    testIteratorsFail(m -> m.putAll(newWithKeysValues(0,0)),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.putAll(newWithKeysValues(4,4)),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.putAll(LongLongMaps.immutable.empty()),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
  }
  @Test void updateValue(){
    testIteratorsFail(m -> m.updateValue(0,0,x -> x * 2),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.updateValue(2,2,x -> x * 2),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
    testIteratorsFail(m -> m.updateValue(4,4,x -> x * 2),pair(0L,10L),pair(1L,11L),pair(2L,12L),pair(3L,13L));
  }
  @Test void close(){
    testIteratorsFail(LinearProbeLongLongHashMap::close,pair(0L,10L),pair(2L,12L));
  }
  private void testIteratorsFail(  Consumer<LinearProbeLongLongHashMap> mutator,  LongLongPair... initialValues){
    map.clear();
    for (    LongLongPair pair : initialValues) {
      map.putPair(pair);
    }
    final MutableLongIterator keysIterator=map.longIterator();
    final Iterator<LongLongPair> keyValueIterator=map.keyValuesView().iterator();
    assertTrue(keysIterator.hasNext());
    assertDoesNotThrow(keysIterator::next);
    assertTrue(keyValueIterator.hasNext());
    assertDoesNotThrow(keyValueIterator::next);
    mutator.accept(map);
    assertThrows(ConcurrentModificationException.class,keysIterator::hasNext);
    assertThrows(ConcurrentModificationException.class,keysIterator::next);
    assertThrows(ConcurrentModificationException.class,keyValueIterator::hasNext);
    assertThrows(ConcurrentModificationException.class,keyValueIterator::next);
  }
}
