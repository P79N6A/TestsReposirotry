public class ExecutingQueryTest {
  private final FakeClock clock=Clocks.fakeClock(ZonedDateTime.parse("2016-12-03T15:10:00+01:00"));
  @Rule public final FakeCpuClock cpuClock=new FakeCpuClock().add(randomLong(0x1_0000_0000L));
  @Rule public final FakeHeapAllocation heapAllocation=new FakeHeapAllocation().add(randomLong(0x1_0000_0000L));
  private final PageCursorCountersStub page=new PageCursorCountersStub();
  private long lockCount;
  private ExecutingQuery query=createExecutingquery(1,"hello world",page,clock,cpuClock,heapAllocation);
  private ExecutingQuery subQuery=createExecutingquery(2,"goodbye world",page,clock,cpuClock,heapAllocation);
  @Test public void shouldReportElapsedTime(){
    clock.forward(10,TimeUnit.MILLISECONDS);
    long elapsedTime=query.snapshot().elapsedTimeMicros();
    assertEquals(10_000,elapsedTime);
  }
  @Test public void shouldTransitionBetweenStates(){
    assertEquals("planning",query.snapshot().status());
    query.compilationCompleted(new CompilerInfo("the-planner","the-runtime",emptyList()),null);
    assertEquals("running",query.snapshot().status());
    try (LockWaitEvent event=lock("NODE",17)){
      assertEquals("waiting",query.snapshot().status());
    }
     assertEquals("running",query.snapshot().status());
    query.waitsForQuery(subQuery);
    assertEquals("waiting",query.snapshot().status());
    query.waitsForQuery(null);
    assertEquals("running",query.snapshot().status());
  }
  @Test public void shouldReportPlanningTime(){
    clock.forward(124,TimeUnit.MICROSECONDS);
    QuerySnapshot snapshot=query.snapshot();
    assertEquals(snapshot.compilationTimeMicros(),snapshot.elapsedTimeMicros());
    clock.forward(16,TimeUnit.MICROSECONDS);
    query.compilationCompleted(new CompilerInfo("the-planner","the-runtime",emptyList()),null);
    clock.forward(200,TimeUnit.MICROSECONDS);
    snapshot=query.snapshot();
    assertEquals(140,snapshot.compilationTimeMicros());
    assertEquals(340,snapshot.elapsedTimeMicros());
  }
  @Test public void shouldReportWaitTime(){
    query.compilationCompleted(new CompilerInfo("the-planner","the-runtime",emptyList()),null);
    assertEquals("running",query.snapshot().status());
    clock.forward(10,TimeUnit.SECONDS);
    try (LockWaitEvent event=lock("NODE",17)){
      clock.forward(5,TimeUnit.SECONDS);
      QuerySnapshot snapshot=query.snapshot();
      assertEquals("waiting",snapshot.status());
      assertThat(snapshot.resourceInformation(),CoreMatchers.<Map<String,Object>>allOf(hasEntry("waitTimeMillis",5_000L),hasEntry("resourceType","NODE"),hasEntry(equalTo("resourceIds"),longArray(17))));
      assertEquals(5_000_000,snapshot.waitTimeMicros());
    }
 {
      QuerySnapshot snapshot=query.snapshot();
      assertEquals("running",snapshot.status());
      assertEquals(5_000_000,snapshot.waitTimeMicros());
    }
    clock.forward(2,TimeUnit.SECONDS);
    try (LockWaitEvent event=lock("RELATIONSHIP",612)){
      clock.forward(1,TimeUnit.SECONDS);
      QuerySnapshot snapshot=query.snapshot();
      assertEquals("waiting",snapshot.status());
      assertThat(snapshot.resourceInformation(),CoreMatchers.<Map<String,Object>>allOf(hasEntry("waitTimeMillis",1_000L),hasEntry("resourceType","RELATIONSHIP"),hasEntry(equalTo("resourceIds"),longArray(612))));
      assertEquals(6_000_000,snapshot.waitTimeMicros());
    }
 {
      QuerySnapshot snapshot=query.snapshot();
      assertEquals("running",snapshot.status());
      assertEquals(6_000_000,snapshot.waitTimeMicros());
    }
  }
  @Test public void shouldReportQueryWaitTime(){
    query.compilationCompleted(new CompilerInfo("the-planner","the-runtime",emptyList()),null);
    query.waitsForQuery(subQuery);
    clock.forward(5,TimeUnit.SECONDS);
    QuerySnapshot snapshot=query.snapshot();
    assertEquals(5_000_000L,snapshot.waitTimeMicros());
    assertEquals("waiting",snapshot.status());
    assertThat(snapshot.resourceInformation(),CoreMatchers.<Map<String,Object>>allOf(hasEntry("waitTimeMillis",5_000L),hasEntry("queryId","query-2")));
    clock.forward(1,TimeUnit.SECONDS);
    query.waitsForQuery(null);
    clock.forward(2,TimeUnit.SECONDS);
    snapshot=query.snapshot();
    assertEquals(6_000_000L,snapshot.waitTimeMicros());
    assertEquals("running",snapshot.status());
  }
  @Test public void shouldReportCpuTime(){
    cpuClock.add(60,TimeUnit.MICROSECONDS);
    long cpuTime=query.snapshot().cpuTimeMicros();
    assertEquals(60,cpuTime);
  }
  @Test public void shouldNotReportCpuTimeIfUnavailable(){
    ExecutingQuery query=new ExecutingQuery(17,ClientConnectionInfo.EMBEDDED_CONNECTION,"neo4j","hello world",EMPTY_MAP,Collections.emptyMap(),() -> lockCount,PageCursorTracer.NULL,Thread.currentThread().getId(),Thread.currentThread().getName(),clock,FakeCpuClock.NOT_AVAILABLE,HeapAllocation.NOT_AVAILABLE);
    QuerySnapshot snapshot=query.snapshot();
    assertNull(snapshot.cpuTimeMicros());
    assertNull(snapshot.idleTimeMicros());
  }
  @Test public void shouldReportHeapAllocation(){
    heapAllocation.add(4096);
    long allocatedBytes=query.snapshot().allocatedBytes();
    assertEquals(4096,allocatedBytes);
    heapAllocation.add(4096);
    allocatedBytes=query.snapshot().allocatedBytes();
    assertEquals(8192,allocatedBytes);
  }
  @Test public void shouldNotReportHeapAllocationIfUnavailable(){
    ExecutingQuery query=new ExecutingQuery(17,ClientConnectionInfo.EMBEDDED_CONNECTION,"neo4j","hello world",EMPTY_MAP,Collections.emptyMap(),() -> lockCount,PageCursorTracer.NULL,Thread.currentThread().getId(),Thread.currentThread().getName(),clock,FakeCpuClock.NOT_AVAILABLE,HeapAllocation.NOT_AVAILABLE);
    QuerySnapshot snapshot=query.snapshot();
    assertNull(snapshot.allocatedBytes());
  }
  @Test public void shouldReportLockCount(){
    lockCount=11;
    assertEquals(11,query.snapshot().activeLockCount());
    lockCount=2;
    assertEquals(2,query.snapshot().activeLockCount());
  }
  @Test public void shouldReportPageHitsAndFaults(){
    page.hits(7);
    page.faults(3);
    QuerySnapshot snapshot=query.snapshot();
    assertEquals(7,snapshot.pageHits());
    assertEquals(3,snapshot.pageFaults());
    page.hits(2);
    page.faults(5);
    snapshot=query.snapshot();
    assertEquals(9,snapshot.pageHits());
    assertEquals(8,snapshot.pageFaults());
  }
  @Test public void includeQueryExecutorThreadName(){
    String queryDescription=query.toString();
    assertTrue(queryDescription.contains("threadExecutingTheQueryName=" + Thread.currentThread().getName()));
  }
  private LockWaitEvent lock(  String resourceType,  long resourceId){
    return query.lockTracer().waitForLock(false,resourceType(resourceType),resourceId);
  }
  static ResourceType resourceType(  String name){
    return new ResourceType(){
      @Override public String toString(){
        return name();
      }
      @Override public int typeId(){
        throw new UnsupportedOperationException("not used");
      }
      @Override public WaitStrategy waitStrategy(){
        throw new UnsupportedOperationException("not used");
      }
      @Override public String name(){
        return name;
      }
    }
;
  }
  @SuppressWarnings("unchecked") private static Matcher<Object> longArray(  long... expected){
    return (Matcher)new TypeSafeMatcher<long[]>(){
      @Override protected boolean matchesSafely(      long[] item){
        return Arrays.equals(expected,item);
      }
      @Override public void describeTo(      Description description){
        description.appendValue(expected);
      }
    }
;
  }
  private static long randomLong(  long bound){
    return ThreadLocalRandom.current().nextLong(bound);
  }
  private ExecutingQuery createExecutingquery(  int queryId,  String hello_world,  PageCursorCountersStub page,  FakeClock clock,  FakeCpuClock cpuClock,  FakeHeapAllocation heapAllocation){
    return new ExecutingQuery(queryId,ClientConnectionInfo.EMBEDDED_CONNECTION,"neo4j",hello_world,EMPTY_MAP,Collections.emptyMap(),() -> lockCount,page,Thread.currentThread().getId(),Thread.currentThread().getName(),clock,cpuClock,heapAllocation);
  }
private static class PageCursorCountersStub implements PageCursorCounters {
    private long faults;
    private long pins;
    private long unpins;
    private long hits;
    private long bytesRead;
    private long evictions;
    private long evictionExceptions;
    private long bytesWritten;
    private long flushes;
    @Override public long faults(){
      return faults;
    }
    public void faults(    long increment){
      faults+=increment;
    }
    @Override public long pins(){
      return pins;
    }
    public void pins(    long increment){
      pins+=increment;
    }
    @Override public long unpins(){
      return unpins;
    }
    public void unpins(    long increment){
      unpins+=increment;
    }
    @Override public long hits(){
      return hits;
    }
    public void hits(    long increment){
      hits+=increment;
    }
    @Override public long bytesRead(){
      return bytesRead;
    }
    public void bytesRead(    long increment){
      bytesRead+=increment;
    }
    @Override public long evictions(){
      return evictions;
    }
    public void evictions(    long increment){
      evictions+=increment;
    }
    @Override public long evictionExceptions(){
      return evictionExceptions;
    }
    public void evictionExceptions(    long increment){
      evictionExceptions+=increment;
    }
    @Override public long bytesWritten(){
      return bytesWritten;
    }
    public void bytesWritten(    long increment){
      bytesWritten+=increment;
    }
    @Override public long flushes(){
      return flushes;
    }
    public void flushes(    long increment){
      flushes+=increment;
    }
    @Override public double hitRatio(){
      return MathUtil.portion(hits(),faults());
    }
  }
}
