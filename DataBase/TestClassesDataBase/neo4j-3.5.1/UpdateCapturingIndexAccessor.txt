public class UpdateCapturingIndexAccessor implements IndexAccessor {
  private final IndexAccessor actual;
  private final Collection<IndexEntryUpdate<?>> updates=new ArrayList<>();
  UpdateCapturingIndexAccessor(  IndexAccessor actual,  Collection<IndexEntryUpdate<?>> initialUpdates){
    this.actual=actual;
    if (initialUpdates != null) {
      this.updates.addAll(initialUpdates);
    }
  }
  @Override public void drop(){
    actual.drop();
  }
  @Override public IndexUpdater newUpdater(  IndexUpdateMode mode){
    return wrap(actual.newUpdater(mode));
  }
  private IndexUpdater wrap(  IndexUpdater actual){
    return new UpdateCapturingIndexUpdater(actual,updates);
  }
  @Override public void force(  IOLimiter ioLimiter){
    actual.force(ioLimiter);
  }
  @Override public void refresh(){
    actual.refresh();
  }
  @Override public void close(){
    actual.close();
  }
  @Override public IndexReader newReader(){
    return actual.newReader();
  }
  @Override public BoundedIterable<Long> newAllEntriesReader(){
    return actual.newAllEntriesReader();
  }
  @Override public ResourceIterator<File> snapshotFiles(){
    return actual.snapshotFiles();
  }
  @Override public void verifyDeferredConstraints(  NodePropertyAccessor propertyAccessor) throws IndexEntryConflictException {
    actual.verifyDeferredConstraints(propertyAccessor);
  }
  @Override public boolean isDirty(){
    return actual.isDirty();
  }
  public Collection<IndexEntryUpdate<?>> snapshot(){
    return new ArrayList<>(updates);
  }
}
