class FusionIndexTestHelp {
  private static LabelSchemaDescriptor indexKey=SchemaDescriptorFactory.forLabel(0,0);
  private static LabelSchemaDescriptor compositeIndexKey=SchemaDescriptorFactory.forLabel(0,0,1);
  private static final Value[] stringValues=new Value[]{Values.stringValue("abc"),Values.stringValue("abcdefghijklmnopqrstuvwxyzåäö"),Values.charValue('S')};
  private static final Value[] numberValues=new Value[]{Values.byteValue((byte)1),Values.shortValue((short)2),Values.intValue(3),Values.longValue(4),Values.floatValue(5.6f),Values.doubleValue(7.8)};
  private static final Value[] pointValues=new Value[]{Values.pointValue(CoordinateReferenceSystem.Cartesian,123.0,456.0),Values.pointValue(CoordinateReferenceSystem.Cartesian_3D,123.0,456.0,789.0),Values.pointValue(CoordinateReferenceSystem.WGS84,13.2,56.8)};
  private static final Value[] temporalValues=new Value[]{DateValue.epochDate(1),DateValue.epochDate(10000)};
  private static final Value[] otherValues=new Value[]{Values.booleanValue(true),Values.booleanArray(new boolean[2]),Values.byteArray(new byte[]{1,2}),Values.shortArray(new short[]{3,4}),Values.intArray(new int[]{5,6}),Values.longArray(new long[]{7,8}),Values.floatArray(new float[]{9.10f,11.12f}),Values.doubleArray(new double[]{13.14,15.16}),Values.charArray(new char[2]),Values.stringArray("a","b"),Values.pointArray(pointValues),Values.NO_VALUE};
  static Value[] valuesSupportedByString(){
    return stringValues;
  }
  static Value[] valuesSupportedByNumber(){
    return numberValues;
  }
  static Value[] valuesSupportedBySpatial(){
    return pointValues;
  }
  static Value[] valuesSupportedByTemporal(){
    return temporalValues;
  }
  static Value[] valuesNotSupportedBySpecificIndex(){
    return otherValues;
  }
  static Value[] allValues(){
    List<Value> values=new ArrayList<>();
    for (    Value[] group : valuesByGroup().values()) {
      values.addAll(Arrays.asList(group));
    }
    return values.toArray(new Value[0]);
  }
  static EnumMap<IndexSlot,Value[]> valuesByGroup(){
    EnumMap<IndexSlot,Value[]> values=new EnumMap<>(IndexSlot.class);
    values.put(STRING,FusionIndexTestHelp.valuesSupportedByString());
    values.put(NUMBER,FusionIndexTestHelp.valuesSupportedByNumber());
    values.put(SPATIAL,FusionIndexTestHelp.valuesSupportedBySpatial());
    values.put(TEMPORAL,FusionIndexTestHelp.valuesSupportedByTemporal());
    values.put(LUCENE,FusionIndexTestHelp.valuesNotSupportedBySpecificIndex());
    return values;
  }
  static void verifyCallFail(  Exception expectedFailure,  Callable failingCall){
    try {
      failingCall.call();
      fail("Should have failed");
    }
 catch (    Exception e) {
      assertSame(expectedFailure,e);
    }
  }
  static IndexEntryUpdate<LabelSchemaDescriptor> add(  Value... value){
switch (value.length) {
case 1:
      return IndexEntryUpdate.add(0,indexKey,value);
case 2:
    return IndexEntryUpdate.add(0,compositeIndexKey,value);
default :
  return null;
}
}
static IndexEntryUpdate<LabelSchemaDescriptor> remove(Value... value){
switch (value.length) {
case 1:
return IndexEntryUpdate.remove(0,indexKey,value);
case 2:
return IndexEntryUpdate.remove(0,compositeIndexKey,value);
default :
return null;
}
}
static IndexEntryUpdate<LabelSchemaDescriptor> change(Value[] before,Value[] after){
return IndexEntryUpdate.change(0,compositeIndexKey,before,after);
}
static IndexEntryUpdate<LabelSchemaDescriptor> change(Value before,Value after){
return IndexEntryUpdate.change(0,indexKey,before,after);
}
static void verifyOtherIsClosedOnSingleThrow(AutoCloseable failingCloseable,AutoCloseable fusionCloseable,AutoCloseable... successfulCloseables) throws Exception {
UncheckedIOException failure=new UncheckedIOException(new IOException("fail"));
doThrow(failure).when(failingCloseable).close();
try {
fusionCloseable.close();
fail("Should have failed");
}
 catch (UncheckedIOException ignore) {
}
for (AutoCloseable successfulCloseable : successfulCloseables) {
verify(successfulCloseable,Mockito.times(1)).close();
}
}
static void verifyFusionCloseThrowOnSingleCloseThrow(AutoCloseable failingCloseable,AutoCloseable fusionCloseable) throws Exception {
UncheckedIOException expectedFailure=new UncheckedIOException(new IOException("fail"));
doThrow(expectedFailure).when(failingCloseable).close();
try {
fusionCloseable.close();
fail("Should have failed");
}
 catch (UncheckedIOException e) {
assertSame(expectedFailure,e);
}
}
static void verifyFusionCloseThrowIfAllThrow(AutoCloseable fusionCloseable,AutoCloseable... autoCloseables) throws Exception {
UncheckedIOException[] failures=new UncheckedIOException[autoCloseables.length];
for (int i=0; i < autoCloseables.length; i++) {
failures[i]=new UncheckedIOException(new IOException("unknown"));
doThrow(failures[i]).when(autoCloseables[i]).close();
}
try {
fusionCloseable.close();
fail("Should have failed");
}
 catch (UncheckedIOException e) {
List<Matcher<? super UncheckedIOException>> matchers=new ArrayList<>();
for (UncheckedIOException failure : failures) {
matchers.add(sameInstance(failure));
}
assertThat(e,anyOf(matchers));
}
}
static <T>void fill(EnumMap<IndexSlot,T> map,T instance){
for (IndexSlot slot : IndexSlot.values()) {
map.put(slot,instance);
}
}
}
