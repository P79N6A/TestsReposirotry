@RunWith(Parameterized.class) public class BoltSchedulerBusyIT extends AbstractBoltTransportsTest {
  private AssertableLogProvider internalLogProvider=new AssertableLogProvider();
  private AssertableLogProvider userLogProvider=new AssertableLogProvider();
  private EphemeralFileSystemRule fsRule=new EphemeralFileSystemRule();
  private Neo4jWithSocket server=new Neo4jWithSocket(getClass(),getTestGraphDatabaseFactory(),fsRule::get,getSettingsFunction());
  private TransportConnection connection1;
  private TransportConnection connection2;
  private TransportConnection connection3;
  private TransportConnection connection4;
  @Rule public RuleChain ruleChain=RuleChain.outerRule(fsRule).around(server);
  protected TestGraphDatabaseFactory getTestGraphDatabaseFactory(){
    TestGraphDatabaseFactory factory=new TestGraphDatabaseFactory();
    factory.setInternalLogProvider(internalLogProvider);
    factory.setUserLogProvider(userLogProvider);
    return factory;
  }
  protected Consumer<Map<String,String>> getSettingsFunction(){
    return settings -> {
      settings.put(GraphDatabaseSettings.auth_enabled.name(),"false");
      settings.put(new BoltConnector(DEFAULT_CONNECTOR_KEY).enabled.name(),"TRUE");
      settings.put(new BoltConnector(DEFAULT_CONNECTOR_KEY).listen_address.name(),"localhost:0");
      settings.put(new BoltConnector(DEFAULT_CONNECTOR_KEY).type.name(),BoltConnector.ConnectorType.BOLT.name());
      settings.put(new BoltConnector(DEFAULT_CONNECTOR_KEY).thread_pool_min_size.name(),"0");
      settings.put(new BoltConnector(DEFAULT_CONNECTOR_KEY).thread_pool_max_size.name(),"2");
    }
;
  }
  @Before public void setup() throws Exception {
    address=server.lookupDefaultConnector();
  }
  @After public void cleanup() throws Exception {
    close(connection1);
    close(connection2);
    close(connection3);
    close(connection4);
  }
  @Test public void shouldReportFailureWhenAllThreadsInThreadPoolAreBusy() throws Throwable {
    connection1=enterStreaming();
    connection2=enterStreaming();
    try {
      connection3=connectAndPerformBoltHandshake(newConnection());
      connection3.send(util.chunk(new InitMessage("TestClient/1.1",emptyMap())));
      assertThat(connection3,util.eventuallyReceives(msgFailure(Status.Request.NoThreadsAvailable,"There are no available threads to serve this request at the moment")));
      userLogProvider.assertContainsMessageContaining("since there are no available threads to serve it at the moment. You can retry at a later time");
      internalLogProvider.assertAtLeastOnce(AssertableLogProvider.inLog(startsWith(BoltConnection.class.getPackage().getName())).error(containsString("since there are no available threads to serve it at the moment. You can retry at a later time"),isA(RejectedExecutionException.class)));
    }
  finally {
      exitStreaming(connection1);
      exitStreaming(connection2);
    }
  }
  @Test public void shouldStopConnectionsWhenRelatedJobIsRejectedOnShutdown() throws Throwable {
    connection1=enterStreaming();
    exitStreaming(connection1);
    connection2=enterStreaming();
    exitStreaming(connection2);
    connection3=enterStreaming();
    connection4=enterStreaming();
    internalLogProvider.clear();
    server.shutdownDatabase();
    userLogProvider.assertNoLogCallContaining("since there are no available threads to serve it at the moment. You can retry at a later time");
    internalLogProvider.assertNoLogCallContaining("since there are no available threads to serve it at the moment. You can retry at a later time");
  }
  private TransportConnection enterStreaming() throws Throwable {
    TransportConnection connection=null;
    Throwable error=null;
    for (int i=1; i <= 7; i++) {
      try {
        connection=newConnection();
        enterStreaming(connection,i);
        error=null;
        return connection;
      }
 catch (      Throwable t) {
        if (error == null) {
          error=t;
        }
 else {
          error.addSuppressed(t);
        }
        close(connection);
        SECONDS.sleep(i);
      }
    }
    if (error != null) {
      throw error;
    }
    throw new IllegalStateException("Unable to enter the streaming state");
  }
  private void enterStreaming(  TransportConnection connection,  int sleepSeconds) throws Exception {
    connectAndPerformBoltHandshake(connection);
    connection.send(util.chunk(new InitMessage("TestClient/1.1",emptyMap())));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
    SECONDS.sleep(sleepSeconds);
    connection.send(util.chunk(new RunMessage("UNWIND RANGE (1, 100) AS x RETURN x")));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
  }
  private TransportConnection connectAndPerformBoltHandshake(  TransportConnection connection) throws Exception {
    connection.connect(address).send(util.acceptedVersions(1,0,0,0));
    assertThat(connection,eventuallyReceives(new byte[]{0,0,0,1}));
    return connection;
  }
  private void exitStreaming(  TransportConnection connection) throws Exception {
    connection.send(util.chunk(DiscardAllMessage.INSTANCE));
    assertThat(connection,util.eventuallyReceives(msgSuccess()));
  }
  private void close(  TransportConnection connection){
    if (connection != null) {
      try {
        connection.disconnect();
      }
 catch (      IOException ignore) {
      }
    }
  }
}
