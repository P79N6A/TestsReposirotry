private static class ControlledInserter implements Writer<LabelScanKey,LabelScanValue> {
  private final Map<Integer,Map<LabelScanKey,LabelScanValue>> data=new HashMap<>();
  @Override public void close(){
  }
  @Override public void put(  LabelScanKey key,  LabelScanValue value){
    merge(key,value,ValueMergers.overwrite());
  }
  @Override public void merge(  LabelScanKey key,  LabelScanValue value,  ValueMerger<LabelScanKey,LabelScanValue> amender){
    key=clone(key);
    value=clone(value);
    Map<LabelScanKey,LabelScanValue> forLabel=data.computeIfAbsent(key.labelId,labelId -> new TreeMap<>(KEY_COMPARATOR));
    LabelScanValue existing=forLabel.get(key);
    if (existing == null) {
      forLabel.put(key,value);
    }
 else {
      amender.merge(key,key,existing,value);
    }
  }
  private static LabelScanValue clone(  LabelScanValue value){
    LabelScanValue result=new LabelScanValue();
    result.bits=value.bits;
    return result;
  }
  private static LabelScanKey clone(  LabelScanKey key){
    return new LabelScanKey(key.labelId,key.idRange);
  }
  @Override public LabelScanValue remove(  LabelScanKey key){
    throw new UnsupportedOperationException("Should not be called");
  }
  @SuppressWarnings("unchecked") RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException> nodesFor(  int labelId){
    Map<LabelScanKey,LabelScanValue> forLabel=data.get(labelId);
    if (forLabel == null) {
      forLabel=Collections.emptyMap();
    }
    Map.Entry<LabelScanKey,LabelScanValue>[] entries=forLabel.entrySet().toArray(new Map.Entry[forLabel.size()]);
    return new RawCursor<Hit<LabelScanKey,LabelScanValue>,IOException>(){
      private int arrayIndex=-1;
      @Override public Hit<LabelScanKey,LabelScanValue> get(){
        Entry<LabelScanKey,LabelScanValue> entry=entries[arrayIndex];
        return new MutableHit<>(entry.getKey(),entry.getValue());
      }
      @Override public boolean next(){
        arrayIndex++;
        return arrayIndex < entries.length;
      }
      @Override public void close(){
      }
    }
;
  }
}
