class PropertyRecordCheckTest extends RecordCheckTestBase<PropertyRecord,ConsistencyReport.PropertyConsistencyReport,PropertyRecordCheck> {
  PropertyRecordCheckTest(){
    super(new PropertyRecordCheck(),ConsistencyReport.PropertyConsistencyReport.class,new int[0]);
  }
  @Test void shouldNotReportAnythingForPropertyRecordNotInUse(){
    PropertyRecord property=notInUse(new PropertyRecord(42));
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldNotReportAnythingForPropertyWithoutBlocksThatDoesNotReferenceAnyOtherRecords(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportPropertyKeyNotInUse(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyKeyTokenRecord key=add(notInUse(new PropertyKeyTokenRecord(0)));
    PropertyBlock block=propertyBlock(key,PropertyType.INT,0);
    property.addPropertyBlock(block);
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).keyNotInUse(block,key);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportPreviousPropertyNotInUse(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyRecord prev=add(notInUse(new PropertyRecord(51)));
    property.setPrevProp(prev.getId());
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).prevNotInUse(prev);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportNextPropertyNotInUse(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyRecord next=add(notInUse(new PropertyRecord(51)));
    property.setNextProp(next.getId());
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).nextNotInUse(next);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportPreviousPropertyNotReferringBack(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyRecord prev=add(inUse(new PropertyRecord(51)));
    property.setPrevProp(prev.getId());
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).previousDoesNotReferenceBack(prev);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportNextPropertyNotReferringBack(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyRecord next=add(inUse(new PropertyRecord(51)));
    property.setNextProp(next.getId());
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).nextDoesNotReferenceBack(next);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportStringRecordNotInUse(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyKeyTokenRecord key=add(inUse(new PropertyKeyTokenRecord(6)));
    DynamicRecord value=add(notInUse(string(new DynamicRecord(1001))));
    PropertyBlock block=propertyBlock(key,value);
    property.addPropertyBlock(block);
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).stringNotInUse(block,value);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportArrayRecordNotInUse(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyKeyTokenRecord key=add(inUse(new PropertyKeyTokenRecord(6)));
    DynamicRecord value=add(notInUse(array(new DynamicRecord(1001))));
    PropertyBlock block=propertyBlock(key,value);
    property.addPropertyBlock(block);
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).arrayNotInUse(block,value);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportEmptyStringRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyKeyTokenRecord key=add(inUse(new PropertyKeyTokenRecord(6)));
    DynamicRecord value=add(inUse(string(new DynamicRecord(1001))));
    PropertyBlock block=propertyBlock(key,value);
    property.addPropertyBlock(block);
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).stringEmpty(block,value);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportUnknownGTypeGeometryRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=GeometryType.encodePoint(keyId,CoordinateReferenceSystem.WGS84,new double[]{1.0,2.0});
    long gtypeBits=0xFL << StandardFormatSettings.PROPERTY_TOKEN_MAXIMUM_ID_BITS + 4;
    longs[0]|=gtypeBits;
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReport15DimensionalPointRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=GeometryType.encodePoint(keyId,CoordinateReferenceSystem.WGS84,new double[]{1.0,2.0});
    long dimensionBits=0xFL << StandardFormatSettings.PROPERTY_TOKEN_MAXIMUM_ID_BITS + 8;
    longs[0]|=dimensionBits;
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportUnknownCRSPointRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=GeometryType.encodePoint(keyId,CoordinateReferenceSystem.WGS84,new double[]{1.0,2.0});
    long crsTableIdAndCodeBits=0xFFFFL << StandardFormatSettings.PROPERTY_TOKEN_MAXIMUM_ID_BITS + 12;
    longs[0]|=crsTableIdAndCodeBits;
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighDateRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeDate(keyId,LocalDate.MAX.toEpochDay() + 1);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighLocalTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeLocalTime(keyId,LocalTime.MAX.toNanoOfDay() + 1);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighNanoLocalDateTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeLocalDateTime(keyId,1,1_000_000_000);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighEpochSecondLocalDateTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeLocalDateTime(keyId,Instant.MAX.getEpochSecond() + 1,1);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighNanoDateTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeDateTime(keyId,1,1_000_000_000,0);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighEpochSecondDateTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeDateTime(keyId,Instant.MAX.getEpochSecond() + 1,1,0);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighNanoDateTimeRecordWithNamedTZ(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeDateTime(keyId,1,1_000_000_000,"Europe/London");
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighEpochSecondDateTimeRecordWithNamedTZ(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeDateTime(keyId,Instant.MAX.getEpochSecond() + 1,1,"Europe/London");
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighOffsetSecondDateTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeDateTime(keyId,1,1,ZoneOffset.MAX.getTotalSeconds() + 1);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighNanoTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeTime(keyId,LocalTime.MAX.toNanoOfDay() + 1,0);
    expectInvalidPropertyValue(property,longs);
  }
  @Test void shouldReportTooHighOffsetSecondTimeRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    final int keyId=6;
    add(inUse(new PropertyKeyTokenRecord(keyId)));
    final long[] longs=TemporalType.encodeTime(keyId,1,ZoneOffset.MAX.getTotalSeconds() + 1);
    expectInvalidPropertyValue(property,longs);
  }
  private void expectInvalidPropertyValue(  PropertyRecord property,  long[] longs){
    PropertyBlock block=new PropertyBlock();
    block.setValueBlocks(longs);
    property.addPropertyBlock(block);
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).invalidPropertyValue(block);
    verifyNoMoreInteractions(report);
  }
  @Test void shouldReportEmptyArrayRecord(){
    PropertyRecord property=inUse(new PropertyRecord(42));
    PropertyKeyTokenRecord key=add(inUse(new PropertyKeyTokenRecord(6)));
    DynamicRecord value=add(inUse(array(new DynamicRecord(1001))));
    PropertyBlock block=propertyBlock(key,value);
    property.addPropertyBlock(block);
    ConsistencyReport.PropertyConsistencyReport report=check(property);
    verify(report).arrayEmpty(block,value);
    verifyNoMoreInteractions(report);
  }
}
