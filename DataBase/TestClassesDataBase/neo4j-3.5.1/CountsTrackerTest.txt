public class CountsTrackerTest {
  @Rule public final Resources resourceManager=new Resources();
  @Rule public final ThreadingRule threading=new ThreadingRule();
  @Test public void shouldBeAbleToStartAndStopTheStore(){
    resourceManager.managed(newTracker());
    resourceManager.lifeStarts();
    resourceManager.lifeShutsDown();
  }
  @Test @Resources.Life(STARTED) public void shouldBeAbleToWriteDataToCountsTracker() throws Exception {
    CountsTracker tracker=resourceManager.managed(newTracker());
    long indexId=0;
    CountsOracle oracle=new CountsOracle();
{
      CountsOracle.Node a=oracle.node(1);
      CountsOracle.Node b=oracle.node(1);
      oracle.relationship(a,1,b);
      oracle.indexSampling(indexId,2,2);
      oracle.indexUpdatesAndSize(indexId,10,2);
    }
    oracle.update(tracker,2);
    oracle.verify(tracker);
    tracker.rotate(2);
    oracle.verify(tracker);
    try (CountsAccessor.IndexStatsUpdater updater=tracker.updateIndexCounts()){
      updater.incrementIndexUpdates(indexId,2);
    }
     oracle.indexUpdatesAndSize(indexId,12,2);
    oracle.verify(tracker);
    tracker.rotate(2);
    oracle.verify(tracker);
  }
  @Test public void shouldStoreCounts() throws Exception {
    CountsOracle oracle=someData();
    try (Lifespan life=new Lifespan()){
      CountsTracker tracker=life.add(newTracker());
      oracle.update(tracker,2);
      tracker.rotate(2);
    }
     try (Lifespan life=new Lifespan()){
      oracle.verify(life.add(newTracker()));
    }
   }
  @Test public void shouldUpdateCountsOnExistingStore() throws Exception {
    CountsOracle oracle=someData();
    int firstTx=2;
    int secondTx=3;
    try (Lifespan life=new Lifespan()){
      CountsTracker tracker=life.add(newTracker());
      oracle.update(tracker,firstTx);
      tracker.rotate(firstTx);
      oracle.verify(tracker);
      CountsOracle delta=new CountsOracle();
{
        CountsOracle.Node n1=delta.node(1);
        CountsOracle.Node n2=delta.node(1,4);
        delta.relationship(n1,1,n2);
        delta.relationship(n2,2,n1);
      }
      delta.update(tracker,secondTx);
      delta.update(oracle);
      oracle.verify(tracker);
      tracker.rotate(secondTx);
    }
     try (Lifespan life=new Lifespan()){
      oracle.verify(life.add(newTracker()));
    }
   }
  @Test public void detectInMemoryDirtyVersionRead(){
    int labelId=1;
    long lastClosedTransactionId=11L;
    long writeTransactionId=22L;
    TransactionVersionContextSupplier versionContextSupplier=new TransactionVersionContextSupplier();
    versionContextSupplier.init(() -> lastClosedTransactionId);
    VersionContext versionContext=versionContextSupplier.getVersionContext();
    try (Lifespan life=new Lifespan()){
      CountsTracker tracker=life.add(newTracker(versionContextSupplier));
      try (CountsAccessor.Updater updater=tracker.apply(writeTransactionId).get()){
        updater.incrementNodeCount(labelId,1);
      }
       versionContext.initRead();
      tracker.nodeCount(labelId,Registers.newDoubleLongRegister());
      assertTrue(versionContext.isDirty());
    }
   }
  @Test public void allowNonDirtyInMemoryDirtyVersionRead(){
    int labelId=1;
    long lastClosedTransactionId=15L;
    long writeTransactionId=13L;
    TransactionVersionContextSupplier versionContextSupplier=new TransactionVersionContextSupplier();
    versionContextSupplier.init(() -> lastClosedTransactionId);
    VersionContext versionContext=versionContextSupplier.getVersionContext();
    try (Lifespan life=new Lifespan()){
      CountsTracker tracker=life.add(newTracker(versionContextSupplier));
      try (CountsAccessor.Updater updater=tracker.apply(writeTransactionId).get()){
        updater.incrementNodeCount(labelId,1);
      }
       versionContext.initRead();
      tracker.nodeCount(labelId,Registers.newDoubleLongRegister());
      assertFalse(versionContext.isDirty());
    }
   }
  @Test public void shouldBeAbleToReadUpToDateValueWhileAnotherThreadIsPerformingRotation() throws Exception {
    CountsOracle oracle=someData();
    final int firstTransaction=2;
    int secondTransaction=3;
    try (Lifespan life=new Lifespan()){
      CountsTracker tracker=life.add(newTracker());
      oracle.update(tracker,firstTransaction);
      tracker.rotate(firstTransaction);
    }
     final CountsOracle delta=new CountsOracle();
{
      CountsOracle.Node n1=delta.node(1);
      CountsOracle.Node n2=delta.node(1,4);
      delta.relationship(n1,1,n2);
      delta.relationship(n2,2,n1);
    }
    delta.update(oracle);
    try (Lifespan life=new Lifespan()){
      final Barrier.Control barrier=new Barrier.Control();
      CountsTracker tracker=life.add(new CountsTracker(resourceManager.logProvider(),resourceManager.fileSystem(),resourceManager.pageCache(),Config.defaults(),resourceManager.testDirectory().databaseLayout(),EmptyVersionContextSupplier.EMPTY){
        @Override protected boolean include(        CountsKey countsKey,        ReadableBuffer value){
          barrier.reached();
          return super.include(countsKey,value);
        }
      }
);
      Future<Void> task=threading.execute(t -> {
        try {
          delta.update(t,secondTransaction);
          t.rotate(secondTransaction);
        }
 catch (        IOException e) {
          throw new AssertionError(e);
        }
        return null;
      }
,tracker);
      barrier.await();
      oracle.verify(tracker);
      barrier.release();
      task.get();
      oracle.verify(tracker);
    }
   }
  @Test public void shouldOrderStoreByTxIdInHeaderThenMinorVersion(){
    FileVersion version=new FileVersion(16,5);
    assertTrue(CountsTracker.compare(version,new FileVersion(5,5)) > 0);
    assertEquals(0,CountsTracker.compare(version,new FileVersion(16,5)));
    assertTrue(CountsTracker.compare(version,new FileVersion(30,1)) < 0);
    assertTrue(CountsTracker.compare(version,new FileVersion(16,1)) > 0);
    assertTrue(CountsTracker.compare(version,new FileVersion(16,7)) < 0);
  }
  @Test @Resources.Life(STARTED) public void shouldNotRotateIfNoDataChanges() throws Exception {
    CountsTracker tracker=resourceManager.managed(newTracker());
    File before=tracker.currentFile();
    tracker.rotate(tracker.txId());
    assertSame("not rotated",before,tracker.currentFile());
  }
  @Test @Resources.Life(STARTED) public void shouldRotateOnDataChangesEvenIfTransactionIsUnchanged() throws Exception {
    CountsTracker tracker=resourceManager.managed(newTracker());
    File before=tracker.currentFile();
    try (CountsAccessor.IndexStatsUpdater updater=tracker.updateIndexCounts()){
      updater.incrementIndexUpdates(7,100);
    }
     tracker.rotate(tracker.txId());
    assertNotEquals("rotated",before,tracker.currentFile());
  }
  @Test @Resources.Life(STARTED) public void shouldSupportTransactionsAppliedOutOfOrderOnRotation() throws Exception {
    final CountsTracker tracker=resourceManager.managed(newTracker());
    try (CountsAccessor.Updater tx=tracker.apply(2).get()){
      tx.incrementNodeCount(1,1);
    }
     try (CountsAccessor.Updater tx=tracker.apply(4).get()){
      tx.incrementNodeCount(1,1);
    }
     Future<Long> rotated=threading.executeAndAwait(new Rotation(2),tracker,thread -> {
switch (thread.getState()) {
case BLOCKED:
case WAITING:
case TIMED_WAITING:
case TERMINATED:
        return true;
default :
      return false;
  }
}
,10,SECONDS);
try (CountsAccessor.Updater tx=tracker.apply(5).get()){
  tx.incrementNodeCount(1,1);
}
 try (CountsAccessor.Updater tx=tracker.apply(3).get()){
  tx.incrementNodeCount(1,1);
}
 assertEquals("rotated transaction",4,rotated.get().longValue());
assertEquals("stored transaction",4,tracker.txId());
assertEquals("count",4,tracker.nodeCount(1,Registers.newDoubleLongRegister()).readSecond());
CountsVisitor visitor=mock(CountsVisitor.class);
tracker.visitFile(tracker.currentFile(),visitor);
verify(visitor).visitNodeCount(1,3);
verifyNoMoreInteractions(visitor);
assertEquals("final rotation",5,tracker.rotate(5));
}
@Test @Resources.Life(STARTED) public void shouldNotEndUpInBrokenStateAfterRotationFailure() throws Exception {
FakeClock clock=Clocks.fakeClock();
CallTrackingClock callTrackingClock=new CallTrackingClock(clock);
CountsTracker tracker=resourceManager.managed(newTracker(callTrackingClock,EmptyVersionContextSupplier.EMPTY));
int labelId=1;
try (CountsAccessor.Updater tx=tracker.apply(2).get()){
  tx.incrementNodeCount(labelId,1);
}
 Predicate<Thread> arrived=thread -> stackTraceContains(thread,all(classNameContains("Rotation"),methodIs("rotate")));
Future<Object> rotation=threading.executeAndAwait(t -> t.rotate(4),tracker,arrived,1,SECONDS);
try (CountsAccessor.Updater tx=tracker.apply(3).get()){
  tx.incrementNodeCount(labelId,1);
}
 while (callTrackingClock.callsToNanos() == 0) {
  Thread.sleep(10);
}
clock.forward(Config.defaults().get(GraphDatabaseSettings.counts_store_rotation_timeout).toMillis() * 2,MILLISECONDS);
try {
  rotation.get();
  fail("Should've failed rotation due to timeout");
}
 catch (ExecutionException e) {
  assertTrue(e.getCause() instanceof RotationTimeoutException);
}
Register.DoubleLongRegister register=Registers.newDoubleLongRegister();
tracker.get(CountsKeyFactory.nodeKey(labelId),register);
assertEquals(2,register.readSecond());
try (CountsAccessor.Updater tx=tracker.apply(4).get()){
  tx.incrementNodeCount(labelId,1);
}
 tracker.rotate(4);
tracker.get(CountsKeyFactory.nodeKey(labelId),register);
assertEquals(3,register.readSecond());
}
private CountsTracker newTracker(){
return newTracker(Clocks.nanoClock(),EmptyVersionContextSupplier.EMPTY);
}
private CountsTracker newTracker(VersionContextSupplier versionContextSupplier){
return newTracker(Clocks.nanoClock(),versionContextSupplier);
}
private CountsTracker newTracker(SystemNanoClock clock,VersionContextSupplier versionContextSupplier){
return new CountsTracker(resourceManager.logProvider(),resourceManager.fileSystem(),resourceManager.pageCache(),Config.defaults(),resourceManager.testDirectory().databaseLayout(),clock,versionContextSupplier).setInitializer(new DataInitializer<CountsAccessor.Updater>(){
  @Override public void initialize(  CountsAccessor.Updater updater){
  }
  @Override public long initialVersion(){
    return FileVersion.INITIAL_TX_ID;
  }
}
);
}
private static CountsOracle someData(){
CountsOracle oracle=new CountsOracle();
CountsOracle.Node n0=oracle.node(0,1);
CountsOracle.Node n1=oracle.node(0,3);
CountsOracle.Node n2=oracle.node(2,3);
CountsOracle.Node n3=oracle.node(2);
oracle.relationship(n0,1,n2);
oracle.relationship(n1,1,n3);
oracle.relationship(n1,1,n2);
oracle.relationship(n0,1,n3);
long indexId=2;
oracle.indexUpdatesAndSize(indexId,0L,50L);
oracle.indexSampling(indexId,25L,50L);
return oracle;
}
private static class Rotation implements IOFunction<CountsTracker,Long> {
private final long txId;
Rotation(long txId){
  this.txId=txId;
}
@Override public Long apply(CountsTracker tracker) throws IOException {
  return tracker.rotate(txId);
}
}
}
