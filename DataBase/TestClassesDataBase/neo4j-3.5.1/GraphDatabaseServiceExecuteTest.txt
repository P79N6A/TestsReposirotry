public class GraphDatabaseServiceExecuteTest {
  @Rule public final DatabaseRule graphDb=new ImpermanentDatabaseRule();
  @Test public void shouldExecuteCypher(){
    final long before;
    final long after;
    try (Transaction tx=graphDb.beginTx()){
      before=Iterables.count(graphDb.getAllNodes());
      tx.success();
    }
     graphDb.execute("CREATE (n:Foo{bar:\"baz\"})");
    try (Transaction tx=graphDb.beginTx()){
      after=Iterables.count(graphDb.getAllNodes());
      tx.success();
    }
     assertEquals(before + 1,after);
  }
  @Test public void shouldNotReturnInternalGeographicPointType(){
    Result execute=graphDb.execute("RETURN point({longitude: 144.317718, latitude: -37.031738}) AS p");
    Object obj=execute.next().get("p");
    assertThat(obj,Matchers.instanceOf(Point.class));
    Point point=(Point)obj;
    assertThat(point.getCoordinate().getCoordinate().get(0),equalTo(144.317718));
    assertThat(point.getCoordinate().getCoordinate().get(1),equalTo(-37.031738));
    CRS crs=point.getCRS();
    assertThat(crs.getCode(),equalTo(4326));
    assertThat(crs.getType(),equalTo("wgs-84"));
    assertThat(crs.getHref(),equalTo("http://spatialreference.org/ref/epsg/4326/"));
  }
  @Test public void shouldNotReturnInternalCartesianPointType(){
    Result execute=graphDb.execute("RETURN point({x: 13.37, y: 13.37, crs:'cartesian'}) AS p");
    Object obj=execute.next().get("p");
    assertThat(obj,Matchers.instanceOf(Point.class));
    Point point=(Point)obj;
    assertThat(point.getCoordinate(),equalTo(new Coordinate(13.37,13.37)));
    CRS crs=point.getCRS();
    assertThat(crs.getCode(),equalTo(7203));
    assertThat(crs.getType(),equalTo("cartesian"));
    assertThat(crs.getHref(),equalTo("http://spatialreference.org/ref/sr-org/7203/"));
  }
  @SuppressWarnings("unchecked") @Test public void shouldNotReturnInternalPointWhenInArray(){
    Result execute=graphDb.execute("RETURN [point({longitude: 144.317718, latitude: -37.031738})] AS ps");
    List<Point> points=(List<Point>)execute.next().get("ps");
    assertThat(points.get(0),Matchers.instanceOf(Point.class));
  }
  @SuppressWarnings("unchecked") @Test public void shouldNotReturnInternalPointWhenInMap(){
    Result execute=graphDb.execute("RETURN {p: point({longitude: 144.317718, latitude: -37.031738})} AS m");
    Map<String,Object> points=(Map<String,Object>)execute.next().get("m");
    assertThat(points.get("p"),Matchers.instanceOf(Point.class));
  }
  @Test public void shouldBeAbleToUseResultingPointFromOneQueryAsParameterToNext(){
    Result execute=graphDb.execute("RETURN point({longitude: 144.317718, latitude: -37.031738}) AS p");
    Point point=(Point)execute.next().get("p");
    Result result=graphDb.execute("RETURN distance(point({longitude: 144.317718, latitude: -37.031738}),{previous}) AS dist",map("previous",point));
    Double dist=(Double)result.next().get("dist");
    assertThat(dist,equalTo(0.0));
  }
  @Test public void shouldBeAbleToUseExternalPointAsParameterToQuery(){
    Point point=makeFakePoint(144.317718,-37.031738,makeWGS84());
    Result result=graphDb.execute("RETURN distance(point({longitude: 144.317718, latitude: -37.031738}),{previous}) AS dist",map("previous",point));
    Double dist=(Double)result.next().get("dist");
    assertThat(dist,equalTo(0.0));
  }
  @Test public void shouldBeAbleToUseExternalGeometryAsParameterToQuery(){
    Geometry geometry=makeFakePointAsGeometry(144.317718,-37.031738,makeWGS84());
    Result result=graphDb.execute("RETURN distance(point({longitude: 144.317718, latitude: -37.031738}),{previous}) AS dist",map("previous",geometry));
    Double dist=(Double)result.next().get("dist");
    assertThat(dist,equalTo(0.0));
  }
  @Test public void shouldBeAbleToUseExternalPointArrayAsParameterToQuery(){
    Point point=makeFakePoint(144.317718,-37.031738,makeWGS84());
    Point[] points=new Point[]{point,point};
    Result result=graphDb.execute("RETURN distance({points}[0],{points}[1]) AS dist",map("points",points));
    Double dist=(Double)result.next().get("dist");
    assertThat(dist,equalTo(0.0));
  }
  @Test public void shouldBeAbleToUseResultsOfPointProcedureAsInputToDistanceFunction() throws Exception {
    Procedures procedures=graphDb.getDependencyResolver().resolveDependency(Procedures.class);
    procedures.registerProcedure(PointProcs.class);
    Result result=graphDb.execute("CALL spatial.point(144.317718, -37.031738) YIELD point " + "RETURN distance(point({longitude: 144.317718, latitude: -37.031738}), point) AS dist");
    Double dist=(Double)result.next().get("dist");
    assertThat(dist,equalTo(0.0));
  }
  @Test public void shouldBeAbleToUseResultsOfPointGeometryProcedureAsInputToDistanceFunction() throws Exception {
    Procedures procedures=graphDb.getDependencyResolver().resolveDependency(Procedures.class);
    procedures.registerProcedure(PointProcs.class);
    Result result=graphDb.execute("CALL spatial.pointGeometry(144.317718, -37.031738) YIELD geometry " + "RETURN distance(point({longitude: 144.317718, latitude: -37.031738}), geometry) AS dist");
    Object dist1=result.next().get("dist");
    Double dist=(Double)dist1;
    assertThat(dist,equalTo(0.0));
  }
  private static Point makeFakePoint(  double x,  double y,  final CRS crs){
    final Coordinate coord=new Coordinate(x,y);
    return new Point(){
      @Override public String getGeometryType(){
        return "Point";
      }
      @Override public List<Coordinate> getCoordinates(){
        return Arrays.asList(coord);
      }
      @Override public CRS getCRS(){
        return crs;
      }
    }
;
  }
  private static Geometry makeFakePointAsGeometry(  double x,  double y,  final CRS crs){
    final Coordinate coord=new Coordinate(x,y);
    return new Geometry(){
      @Override public String getGeometryType(){
        return "Point";
      }
      @Override public List<Coordinate> getCoordinates(){
        return Arrays.asList(coord);
      }
      @Override public CRS getCRS(){
        return crs;
      }
    }
;
  }
  private static CRS makeWGS84(){
    return new CRS(){
      @Override public int getCode(){
        return 4326;
      }
      @Override public String getType(){
        return "WGS-84";
      }
      @Override public String getHref(){
        return "http://spatialreference.org/ref/epsg/4326/";
      }
    }
;
  }
public static class PointProcs {
    @Procedure("spatial.point") public Stream<PointResult> spatialPoint(    @Name("longitude") double longitude,    @Name("latitude") double latitude){
      Point point=makeFakePoint(longitude,latitude,makeWGS84());
      return Stream.of(new PointResult(point));
    }
    @Procedure("spatial.pointGeometry") public Stream<GeometryResult> spatialPointGeometry(    @Name("longitude") double longitude,    @Name("latitude") double latitude){
      Geometry geometry=makeFakePointAsGeometry(longitude,latitude,makeWGS84());
      return Stream.of(new GeometryResult(geometry));
    }
  }
public static class PointResult {
    public Point point;
    public PointResult(    Point point){
      this.point=point;
    }
  }
public static class GeometryResult {
    public Geometry geometry;
    public GeometryResult(    Geometry geometry){
      this.geometry=geometry;
    }
  }
}
