public class GenericAccessorPointsTest {
  private static final CoordinateReferenceSystem crs=CoordinateReferenceSystem.WGS84;
  private static final ConfiguredSpaceFillingCurveSettingsCache configuredSettings=new ConfiguredSpaceFillingCurveSettingsCache(Config.defaults());
  private static final IndexSpecificSpaceFillingCurveSettingsCache indexSettings=new IndexSpecificSpaceFillingCurveSettingsCache(configuredSettings,new HashMap<>());
  private static final SpaceFillingCurve curve=indexSettings.forCrs(crs,true);
  private final DefaultFileSystemRule fs=new DefaultFileSystemRule();
  private final TestDirectory directory=TestDirectory.testDirectory(getClass(),fs.get());
  private final PageCacheRule pageCacheRule=new PageCacheRule(config().withAccessChecks(true));
  private final RandomRule random=new RandomRule();
  @Rule public final RuleChain rules=outerRule(random).around(fs).around(directory).around(pageCacheRule);
  private NativeIndexAccessor accessor;
  private StoreIndexDescriptor descriptor;
  @Before public void setup(){
    DefaultFileSystemAbstraction fs=this.fs.get();
    PageCache pc=pageCacheRule.getPageCache(fs);
    File file=directory.file("index");
    GenericLayout layout=new GenericLayout(1,indexSettings);
    RecoveryCleanupWorkCollector collector=RecoveryCleanupWorkCollector.ignore();
    descriptor=TestIndexDescriptorFactory.forLabel(1,1).withId(1);
    IndexDirectoryStructure.Factory factory=IndexDirectoryStructure.directoriesByProvider(directory.storeDir());
    IndexDirectoryStructure structure=factory.forProvider(GenericNativeIndexProvider.DESCRIPTOR);
    accessor=new GenericNativeIndexAccessor(pc,fs,file,layout,collector,EMPTY,descriptor,indexSettings,structure,new StandardConfiguration());
  }
  @After public void tearDown(){
    accessor.close();
  }
  /** 
 * This test verify that we correctly handle unique points that all belong to the same tile on the space filling curve. All points share at least one dimension coordinate with another point to exercise minimal splitter. We verify this by asserting that we always get exactly one hit on an exact match and that the value is what we expect.
 */
  @Test public void mustHandlePointsWithinSameTile() throws IndexEntryConflictException, IndexNotApplicableKernelException {
    int nbrOfValues=10000;
    PointValue origin=Values.pointValue(WGS84,0.0,0.0);
    Long derivedValueForCenterPoint=curve.derivedValueFor(origin.coordinate());
    double[] centerPoint=curve.centerPointFor(derivedValueForCenterPoint);
    double xWidthMultiplier=curve.getTileWidth(0,curve.getMaxLevel()) / 2;
    double yWidthMultiplier=curve.getTileWidth(1,curve.getMaxLevel()) / 2;
    List<Value> pointValues=new ArrayList<>();
    List<IndexEntryUpdate<?>> updates=new ArrayList<>();
    long nodeId=1;
    for (int i=0; i < nbrOfValues / 4; i++) {
      double x1=(random.nextDouble() * 2 - 1) * xWidthMultiplier;
      double x2=(random.nextDouble() * 2 - 1) * xWidthMultiplier;
      double y1=(random.nextDouble() * 2 - 1) * yWidthMultiplier;
      double y2=(random.nextDouble() * 2 - 1) * yWidthMultiplier;
      PointValue value11=Values.pointValue(WGS84,centerPoint[0] + x1,centerPoint[1] + y1);
      PointValue value12=Values.pointValue(WGS84,centerPoint[0] + x1,centerPoint[1] + y2);
      PointValue value21=Values.pointValue(WGS84,centerPoint[0] + x2,centerPoint[1] + y1);
      PointValue value22=Values.pointValue(WGS84,centerPoint[0] + x2,centerPoint[1] + y2);
      assertDerivedValue(derivedValueForCenterPoint,value11,value12,value21,value22);
      nodeId=addPointsToLists(pointValues,updates,nodeId,value11,value12,value21,value22);
    }
    processAll(updates);
    exactMatchOnAllValues(pointValues);
  }
  /** 
 * This test verify that we correctly handle unique point arrays where every point in every array belong to the same tile on the space filling curve. We verify this by asserting that we always get exactly one hit on an exact match and that the value is what we expect.
 */
  @Test public void mustHandlePointArraysWithinSameTile() throws IndexEntryConflictException, IndexNotApplicableKernelException {
    int nbrOfValues=10000;
    PointValue origin=Values.pointValue(WGS84,0.0,0.0);
    Long derivedValueForCenterPoint=curve.derivedValueFor(origin.coordinate());
    double[] centerPoint=curve.centerPointFor(derivedValueForCenterPoint);
    double xWidthMultiplier=curve.getTileWidth(0,curve.getMaxLevel()) / 2;
    double yWidthMultiplier=curve.getTileWidth(1,curve.getMaxLevel()) / 2;
    List<Value> pointArrays=new ArrayList<>();
    List<IndexEntryUpdate<?>> updates=new ArrayList<>();
    for (int i=0; i < nbrOfValues; i++) {
      int arrayLength=random.nextInt(5) + 1;
      PointValue[] pointValues=new PointValue[arrayLength];
      for (int j=0; j < arrayLength; j++) {
        double x=(random.nextDouble() * 2 - 1) * xWidthMultiplier;
        double y=(random.nextDouble() * 2 - 1) * yWidthMultiplier;
        PointValue value=Values.pointValue(WGS84,centerPoint[0] + x,centerPoint[1] + y);
        assertDerivedValue(derivedValueForCenterPoint,value);
        pointValues[j]=value;
      }
      PointArray array=Values.pointArray(pointValues);
      pointArrays.add(array);
      updates.add(IndexEntryUpdate.add(i,descriptor,array));
    }
    processAll(updates);
    exactMatchOnAllValues(pointArrays);
  }
  private long addPointsToLists(  List<Value> pointValues,  List<IndexEntryUpdate<?>> updates,  long nodeId,  PointValue... values){
    for (    PointValue value : values) {
      pointValues.add(value);
      updates.add(IndexEntryUpdate.add(nodeId++,descriptor,value));
    }
    return nodeId;
  }
  private void assertDerivedValue(  Long targetDerivedValue,  PointValue... values){
    for (    PointValue value : values) {
      Long derivedValueForValue=curve.derivedValueFor(value.coordinate());
      assertEquals(targetDerivedValue,derivedValueForValue,"expected random value to belong to same tile as center point");
    }
  }
  private void processAll(  List<IndexEntryUpdate<?>> updates) throws IndexEntryConflictException {
    try (NativeIndexUpdater updater=accessor.newUpdater(IndexUpdateMode.ONLINE)){
      for (      IndexEntryUpdate<?> update : updates) {
        updater.process(update);
      }
    }
   }
  private void exactMatchOnAllValues(  List<Value> values) throws IndexNotApplicableKernelException {
    try (IndexReader indexReader=accessor.newReader()){
      SimpleNodeValueClient client=new SimpleNodeValueClient();
      for (      Value value : values) {
        IndexQuery.ExactPredicate exact=IndexQuery.exact(descriptor.schema().getPropertyId(),value);
        indexReader.query(client,IndexOrder.NONE,true,exact);
        assertTrue(client.next());
        assertEquals(value,client.values[0]);
        assertFalse(client.next());
      }
    }
   }
}
