/** 
 * Tests an issue where writer would append data and sometimes rotate the log to new file. When rotating the log there's an intricate relationship between  {@link LogVersionRepository}, creating the file and writing the header. Concurrent readers which scans the log stream will use  {@link LogVersionBridge} to seemlesslyjump over to new files, where the highest file is dictated by  {@link LogVersionRepository#getCurrentLogVersion()}. There was this race where the log version was incremented, the new log file created and reader would get to this new file and try to read the header and fail before the header had been written. This test tries to reproduce this race. It will not produce false negatives, but sometimes false positives since it's non-deterministic.
 */
public class TransactionLogFileRotateAndReadRaceIT {
  private final TestDirectory directory=TestDirectory.testDirectory();
  private final LifeRule life=new LifeRule(true);
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  private final OtherThreadRule<Void> t2=new OtherThreadRule<>(getClass().getName() + "-T2");
  @Rule public final RuleChain rules=RuleChain.outerRule(directory).around(life).around(t2).around(fileSystemRule);
  private static final long LIMIT_TIME=SECONDS.toMillis(5);
  private static final int LIMIT_ROTATIONS=500;
  private static final int LIMIT_READS=1_000;
  @Test public void shouldNotSeeEmptyLogFileWhenReadingTransactionStream() throws Exception {
    LogVersionRepository logVersionRepository=new SimpleLogVersionRepository();
    LogFiles logFiles=LogFilesBuilder.builder(directory.databaseLayout(),fileSystemRule.get()).withLogVersionRepository(logVersionRepository).withTransactionIdStore(new SimpleTransactionIdStore()).build();
    life.add(logFiles);
    LogFile logFile=logFiles.getLogFile();
    FlushablePositionAwareChannel writer=logFile.getWriter();
    LogPositionMarker startPosition=new LogPositionMarker();
    writer.getCurrentPosition(startPosition);
    AtomicBoolean end=new AtomicBoolean();
    byte[] dataChunk=new byte[100];
    AtomicInteger rotations=new AtomicInteger();
    CountDownLatch startSignal=new CountDownLatch(1);
    Future<Void> writeFuture=t2.execute(ignored -> {
      ThreadLocalRandom random=ThreadLocalRandom.current();
      startSignal.countDown();
      while (!end.get()) {
        writer.put(dataChunk,random.nextInt(1,dataChunk.length));
        if (logFile.rotationNeeded()) {
          logFile.rotate();
          writer.getCurrentPosition(startPosition);
          rotations.incrementAndGet();
        }
      }
      return null;
    }
);
    assertTrue(startSignal.await(10,SECONDS));
    long maxEndTime=currentTimeMillis() + LIMIT_TIME;
    int reads=0;
    try {
      for (; currentTimeMillis() < maxEndTime && reads < LIMIT_READS && rotations.get() < LIMIT_ROTATIONS; reads++) {
        try (ReadableLogChannel reader=logFile.getReader(startPosition.newPosition())){
          deplete(reader);
        }
       }
    }
  finally {
      end.set(true);
      writeFuture.get();
    }
  }
  private void deplete(  ReadableLogChannel reader){
    byte[] dataChunk=new byte[100];
    try {
      while (true) {
        reader.get(dataChunk,dataChunk.length);
      }
    }
 catch (    ReadPastEndException e) {
    }
catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}
