public class ParameterConverterTest {
  private ParameterConverter converter=new ParameterConverter(mock(EmbeddedProxySPI.class));
  @Before public void setup(){
    EmbeddedProxySPI manager=mock(EmbeddedProxySPI.class);
    when(manager.newNodeProxy(anyLong())).thenAnswer(invocationOnMock -> {
      long id=invocationOnMock.getArgument(0);
      NodeProxy mock=mock(NodeProxy.class);
      when(mock.getId()).thenReturn(id);
      return mock;
    }
);
    when(manager.newRelationshipProxy(anyLong())).thenAnswer(invocationOnMock -> {
      long id=invocationOnMock.getArgument(0);
      RelationshipProxy mock=mock(RelationshipProxy.class);
      when(mock.getId()).thenReturn(id);
      return mock;
    }
);
    converter=new ParameterConverter(manager);
  }
  @Test public void shouldTurnAllIntegerTypesToLongs(){
    AnyValue[] values=new AnyValue[]{byteValue((byte)13),shortValue((short)13),intValue(13),longValue(13L)};
    for (    AnyValue val : values) {
      val.writeTo(converter);
      Object value=converter.value();
      assertThat(value,instanceOf(Long.class));
      assertThat(value,equalTo(13L));
    }
  }
  @Test public void shouldTurnAllFloatingTypesToDoubles(){
    AnyValue[] values=new AnyValue[]{floatValue(13f),doubleValue(13d)};
    for (    AnyValue val : values) {
      val.writeTo(converter);
      Object value=converter.value();
      assertThat(value,instanceOf(Double.class));
      assertThat(value,equalTo(13d));
    }
  }
  @Test public void shouldHandleNodes(){
    NodeValue nodeValue=nodeValue(42L,stringArray("L"),EMPTY_MAP);
    nodeValue.writeTo(converter);
    assertThat(converter.value(),equalTo(VirtualValues.node(42L)));
  }
  @Test public void shouldHandleRelationships(){
    RelationshipValue relValue=relationshipValue(1L,nodeValue(42L,stringArray("L"),EMPTY_MAP),nodeValue(42L,stringArray("L"),EMPTY_MAP),stringValue("R"),EMPTY_MAP);
    relValue.writeTo(converter);
    assertThat(converter.value(),equalTo(VirtualValues.relationship(1L)));
  }
  @Test public void shouldHandleBooleans(){
    TRUE.writeTo(converter);
    assertThat(converter.value(),equalTo(true));
    FALSE.writeTo(converter);
    assertThat(converter.value(),equalTo(false));
  }
  @Test public void shouldHandlePaths(){
    NodeValue n1=nodeValue(42L,stringArray("L"),EMPTY_MAP);
    NodeValue n2=nodeValue(43L,stringArray("L"),EMPTY_MAP);
    PathValue p=path(new NodeValue[]{n1,n2},new RelationshipValue[]{relationshipValue(1L,n1,n2,stringValue("T"),EMPTY_MAP)});
    p.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(Path.class));
    Path path=(Path)value;
    assertThat(path.length(),equalTo(1));
    assertThat(path.startNode().getId(),equalTo(42L));
    assertThat(path.endNode().getId(),equalTo(43L));
    assertThat(path.relationships().iterator().next().getId(),equalTo(1L));
  }
  @Test public void shouldHandlePoints(){
    PointValue pointValue=Values.pointValue(CoordinateReferenceSystem.WGS84,1.0,2.0);
    pointValue.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(Point.class));
    Point point=(Point)value;
    assertThat(point.getCoordinate().getCoordinate().get(0),equalTo(1.0));
    assertThat(point.getCoordinate().getCoordinate().get(1),equalTo(2.0));
    assertThat(point.getCRS().getCode(),equalTo(4326));
  }
  @Test public void shouldHandleDateTimeWithZoneOffset(){
    DateTimeValue dvalue=DateTimeValue.datetime(1,2,3,4,5,6,7,"+00:00");
    dvalue.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(ZonedDateTime.class));
    assertThat(value,equalTo(dvalue.asObjectCopy()));
  }
  @Test public void shouldHandleDateTimeWithZoneId(){
    DateTimeValue dvalue=DateTimeValue.datetime(1,2,3,4,5,6,7,ZoneId.of("Europe/Stockholm"));
    dvalue.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(ZonedDateTime.class));
    assertThat(value,equalTo(dvalue.asObjectCopy()));
  }
  @Test public void shouldHandleLocalDateTime(){
    LocalDateTimeValue dvalue=LocalDateTimeValue.localDateTime(1,2,3,4,5,6,7);
    dvalue.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(LocalDateTime.class));
    assertThat(value,equalTo(dvalue.asObjectCopy()));
  }
  @Test public void shouldHandleDate(){
    DateValue dvalue=DateValue.date(1,2,3);
    dvalue.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(LocalDate.class));
    assertThat(value,equalTo(dvalue.asObjectCopy()));
  }
  @Test public void shouldHandleTimeUTC(){
    TimeValue time=TimeValue.time(1,2,3,4,"+00:00");
    time.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(OffsetTime.class));
    assertThat(value,equalTo(time.asObjectCopy()));
  }
  @Test public void shouldHandleTimeWithOffset(){
    TimeValue time=TimeValue.time(1,2,3,4,"+01:00");
    time.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(OffsetTime.class));
    assertThat(value,equalTo(time.asObjectCopy()));
  }
  @Test public void shouldHandleLocalTime(){
    LocalTimeValue dvalue=LocalTimeValue.localTime(1,2,3,4);
    dvalue.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(LocalTime.class));
    assertThat(value,equalTo(dvalue.asObjectCopy()));
  }
  @Test public void shouldHandleDurations(){
    DurationValue dvalue=DurationValue.duration(1,2,3,4);
    dvalue.writeTo(converter);
    Object value=converter.value();
    assertThat(value,instanceOf(DurationValue.class));
    assertThat(value,equalTo(dvalue.asObjectCopy()));
  }
  @Test public void shouldHandleLists(){
    ListValue list=list(stringValue("foo"),longValue(42L),TRUE);
    list.writeTo(converter);
    assertThat(converter.value(),equalTo(Arrays.asList("foo",42L,true)));
  }
  @Test public void shouldHandleArrays(){
    LongArray longArray=Values.longArray(new long[]{1L,2L,3L});
    longArray.writeTo(converter);
    assertThat(converter.value(),equalTo(new long[]{1L,2L,3L}));
  }
  @Test public void shouldHandleMaps(){
    MapValue map=map(new String[]{"foo","bar"},new AnyValue[]{longValue(42L),stringValue("baz")});
    map.writeTo(converter);
    assertThat(converter.value(),equalTo(MapUtil.map("foo",42L,"bar","baz")));
  }
  @Test public void shouldHandleListWithMaps(){
    ListValue list=list(longValue(42L),map(new String[]{"foo","bar"},new AnyValue[]{longValue(42L),stringValue("baz")}));
    list.writeTo(converter);
    List<?> converted=(List<?>)converter.value();
    assertThat(converted.get(0),equalTo(42L));
    assertThat(converted.get(1),equalTo(MapUtil.map("foo",42L,"bar","baz")));
  }
  @Test public void shouldHandleMapsWithLists(){
    MapValue map=map(new String[]{"foo","bar"},new AnyValue[]{longValue(42L),list(stringValue("baz"))});
    map.writeTo(converter);
    Map<?,?> value=(Map<?,?>)converter.value();
    assertThat(value.get("foo"),equalTo(42L));
    assertThat(value.get("bar"),equalTo(singletonList("baz")));
    assertThat(value.size(),equalTo(2));
  }
}
