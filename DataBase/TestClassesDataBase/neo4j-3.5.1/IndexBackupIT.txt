public class IndexBackupIT {
  private static final String PROPERTY_PREFIX="property";
  private static final int NUMBER_OF_INDEXES=10;
  @Rule public RandomRule randomRule=new RandomRule();
  @Rule public EmbeddedDatabaseRule database=new EmbeddedDatabaseRule().startLazily();
  private CheckPointer checkPointer;
  private IndexingService indexingService;
  private FileSystemAbstraction fileSystem;
  @Test public void concurrentLuceneIndexSnapshotUseDifferentSnapshots() throws Exception {
    Label label=Label.label("testLabel");
    database.withSetting(GraphDatabaseSettings.default_schema_provider,GraphDatabaseSettings.SchemaIndex.NATIVE20.providerName());
    prepareDatabase(label);
    forceCheckpoint(checkPointer);
    ResourceIterator<File> firstCheckpointSnapshot=indexingService.snapshotIndexFiles();
    generateData(label);
    removeOldNodes(LongStream.range(1,20));
    updateOldNodes(LongStream.range(30,40));
    forceCheckpoint(checkPointer);
    ResourceIterator<File> secondCheckpointSnapshot=indexingService.snapshotIndexFiles();
    generateData(label);
    removeOldNodes(LongStream.range(50,60));
    updateOldNodes(LongStream.range(70,80));
    forceCheckpoint(checkPointer);
    ResourceIterator<File> thirdCheckpointSnapshot=indexingService.snapshotIndexFiles();
    Set<String> firstSnapshotFileNames=getFileNames(firstCheckpointSnapshot);
    Set<String> secondSnapshotFileNames=getFileNames(secondCheckpointSnapshot);
    Set<String> thirdSnapshotFileNames=getFileNames(thirdCheckpointSnapshot);
    compareSnapshotFiles(firstSnapshotFileNames,secondSnapshotFileNames,fileSystem);
    compareSnapshotFiles(secondSnapshotFileNames,thirdSnapshotFileNames,fileSystem);
    compareSnapshotFiles(thirdSnapshotFileNames,firstSnapshotFileNames,fileSystem);
    firstCheckpointSnapshot.close();
    secondCheckpointSnapshot.close();
    thirdCheckpointSnapshot.close();
  }
  @Test public void snapshotFilesDeletedWhenSnapshotReleased() throws IOException {
    Label label=Label.label("testLabel");
    prepareDatabase(label);
    ResourceIterator<File> firstCheckpointSnapshot=indexingService.snapshotIndexFiles();
    generateData(label);
    ResourceIterator<File> secondCheckpointSnapshot=indexingService.snapshotIndexFiles();
    generateData(label);
    ResourceIterator<File> thirdCheckpointSnapshot=indexingService.snapshotIndexFiles();
    Set<String> firstSnapshotFileNames=getFileNames(firstCheckpointSnapshot);
    Set<String> secondSnapshotFileNames=getFileNames(secondCheckpointSnapshot);
    Set<String> thirdSnapshotFileNames=getFileNames(thirdCheckpointSnapshot);
    generateData(label);
    forceCheckpoint(checkPointer);
    assertTrue(firstSnapshotFileNames.stream().map(File::new).allMatch(fileSystem::fileExists));
    assertTrue(secondSnapshotFileNames.stream().map(File::new).allMatch(fileSystem::fileExists));
    assertTrue(thirdSnapshotFileNames.stream().map(File::new).allMatch(fileSystem::fileExists));
    firstCheckpointSnapshot.close();
    secondCheckpointSnapshot.close();
    thirdCheckpointSnapshot.close();
    generateData(label);
    forceCheckpoint(checkPointer);
    assertFalse(firstSnapshotFileNames.stream().map(File::new).anyMatch(fileSystem::fileExists));
    assertFalse(secondSnapshotFileNames.stream().map(File::new).anyMatch(fileSystem::fileExists));
    assertFalse(thirdSnapshotFileNames.stream().map(File::new).anyMatch(fileSystem::fileExists));
  }
  private void compareSnapshotFiles(  Set<String> firstSnapshotFileNames,  Set<String> secondSnapshotFileNames,  FileSystemAbstraction fileSystem){
    assertThat(format("Should have %d modified index segment files. Snapshot segment files are: %s",NUMBER_OF_INDEXES,firstSnapshotFileNames),firstSnapshotFileNames,hasSize(NUMBER_OF_INDEXES));
    for (    String fileName : firstSnapshotFileNames) {
      assertFalse("Snapshot segments fileset should not have files from another snapshot set." + describeFileSets(firstSnapshotFileNames,secondSnapshotFileNames),secondSnapshotFileNames.contains(fileName));
      String path=FilenameUtils.getFullPath(fileName);
      assertTrue("Snapshot should contain files for index in path: " + path + "."+ describeFileSets(firstSnapshotFileNames,secondSnapshotFileNames),secondSnapshotFileNames.stream().anyMatch(name -> name.startsWith(path)));
      assertTrue(format("Snapshot segment file '%s' should exist.",fileName),fileSystem.fileExists(new File(fileName)));
    }
  }
  private void removeOldNodes(  LongStream idRange){
    try (Transaction transaction=database.beginTx()){
      idRange.mapToObj(id -> database.getNodeById(id)).forEach(Node::delete);
      transaction.success();
    }
   }
  private void updateOldNodes(  LongStream idRange){
    try (Transaction transaction=database.beginTx()){
      List<Node> nodes=idRange.mapToObj(id -> database.getNodeById(id)).collect(Collectors.toList());
      for (int i=0; i < NUMBER_OF_INDEXES; i++) {
        String propertyName=PROPERTY_PREFIX + i;
        nodes.forEach(node -> node.setProperty(propertyName,randomRule.nextLong()));
      }
      transaction.success();
    }
   }
  private String describeFileSets(  Set<String> firstFileSet,  Set<String> secondFileSet){
    return "First snapshot files are: " + firstFileSet + System.lineSeparator()+ "second snapshot files are: "+ secondFileSet;
  }
  private Set<String> getFileNames(  ResourceIterator<File> files){
    return files.stream().map(File::getAbsolutePath).filter(this::segmentsFilePredicate).collect(Collectors.toSet());
  }
  private void forceCheckpoint(  CheckPointer checkPointer) throws IOException {
    checkPointer.forceCheckPoint(new SimpleTriggerInfo("testForcedCheckpoint"));
  }
  private void prepareDatabase(  Label label){
    generateData(label);
    try (Transaction transaction=database.beginTx()){
      for (int i=0; i < 10; i++) {
        database.schema().indexFor(label).on(PROPERTY_PREFIX + i).create();
      }
      transaction.success();
    }
     try (Transaction ignored=database.beginTx()){
      database.schema().awaitIndexesOnline(1,TimeUnit.MINUTES);
    }
     checkPointer=resolveDependency(CheckPointer.class);
    indexingService=resolveDependency(IndexingService.class);
    fileSystem=resolveDependency(FileSystemAbstraction.class);
  }
  private void generateData(  Label label){
    for (int i=0; i < 100; i++) {
      testNodeCreationTransaction(label,i);
    }
  }
  private void testNodeCreationTransaction(  Label label,  int i){
    try (Transaction transaction=database.beginTx()){
      Node node=database.createNode(label);
      node.setProperty("property" + i,i);
      transaction.success();
    }
   }
  private <T>T resolveDependency(  Class<T> clazz){
    return getDatabaseResolver().resolveDependency(clazz);
  }
  private DependencyResolver getDatabaseResolver(){
    return database.getDependencyResolver();
  }
  private boolean segmentsFilePredicate(  String fileName){
    return FilenameUtils.getName(fileName).startsWith(IndexFileNames.SEGMENTS);
  }
}
