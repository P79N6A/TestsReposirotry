public class IndexWorkSyncTransactionApplicationStressIT {
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  private final RecordStorageEngineRule storageEngineRule=new RecordStorageEngineRule();
  private final TestDirectory directory=TestDirectory.testDirectory();
  private final PageCacheRule pageCacheRule=new PageCacheRule();
  @Rule public RuleChain ruleChain=RuleChain.outerRule(directory).around(fileSystemRule).around(pageCacheRule).around(storageEngineRule);
  private final LabelSchemaDescriptor descriptor=SchemaDescriptorFactory.forLabel(0,0);
  @Test public void shouldApplyIndexUpdatesInWorkSyncedBatches() throws Exception {
    long duration=parseTimeMillis.apply(System.getProperty(getClass().getName() + ".duration","2s"));
    int numThreads=Integer.getInteger(getClass().getName() + ".numThreads",Runtime.getRuntime().availableProcessors());
    DefaultFileSystemAbstraction fs=fileSystemRule.get();
    PageCache pageCache=pageCacheRule.getPageCache(fs);
    FusionIndexProvider indexProvider=NativeLuceneFusionIndexProviderFactory20.create(pageCache,directory.databaseDir(),fs,IndexProvider.Monitor.EMPTY,Config.defaults(),OperationalMode.single,RecoveryCleanupWorkCollector.immediate());
    RecordStorageEngine storageEngine=storageEngineRule.getWith(fs,pageCache,directory.databaseLayout()).indexProvider(indexProvider).build();
    storageEngine.apply(tx(singletonList(createIndexRule(DESCRIPTOR,1,descriptor))),TransactionApplicationMode.EXTERNAL);
    Dependencies dependencies=new Dependencies();
    storageEngine.satisfyDependencies(dependencies);
    IndexProxy index=dependencies.resolveDependency(IndexingService.class).getIndexProxy(descriptor);
    awaitOnline(index);
    Workers<Worker> workers=new Workers<>(getClass().getSimpleName());
    final AtomicBoolean end=new AtomicBoolean();
    for (int i=0; i < numThreads; i++) {
      workers.start(new Worker(i,end,storageEngine,10,index));
    }
    Thread.sleep(duration);
    end.set(true);
    workers.awaitAndThrowOnError();
  }
  private void awaitOnline(  IndexProxy index) throws InterruptedException {
    while (index.getState() == InternalIndexState.POPULATING) {
      Thread.sleep(10);
    }
  }
  private static Value propertyValue(  int id,  int progress){
    return Values.of(id + "_" + progress);
  }
  private static TransactionToApply tx(  Collection<StorageCommand> commands){
    TransactionToApply tx=new TransactionToApply(transactionRepresentation(commands));
    tx.commitment(NO_COMMITMENT,0);
    return tx;
  }
private class Worker implements Runnable {
    private final int id;
    private final AtomicBoolean end;
    private final RecordStorageEngine storageEngine;
    private final NodeStore nodeIds;
    private final int batchSize;
    private final IndexProxy index;
    private final CommandCreationContext commandCreationContext;
    private int i;
    private int base;
    Worker(    int id,    AtomicBoolean end,    RecordStorageEngine storageEngine,    int batchSize,    IndexProxy index){
      this.id=id;
      this.end=end;
      this.storageEngine=storageEngine;
      this.batchSize=batchSize;
      this.index=index;
      NeoStores neoStores=this.storageEngine.testAccessNeoStores();
      this.nodeIds=neoStores.getNodeStore();
      this.commandCreationContext=storageEngine.allocateCommandCreationContext();
    }
    @Override public void run(){
      try {
        TransactionQueue queue=new TransactionQueue(batchSize,(tx,last) -> {
          storageEngine.apply(tx,TransactionApplicationMode.EXTERNAL);
          verifyIndex(tx);
          base+=batchSize;
        }
);
        for (; !end.get(); i++) {
          queue.queue(createNodeAndProperty(i));
        }
        queue.empty();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
 finally {
        commandCreationContext.close();
      }
    }
    private TransactionToApply createNodeAndProperty(    int progress) throws Exception {
      TransactionState txState=new TxState();
      long nodeId=nodeIds.nextId();
      txState.nodeDoCreate(nodeId);
      txState.nodeDoAddLabel(descriptor.getLabelId(),nodeId);
      txState.nodeDoAddProperty(nodeId,descriptor.getPropertyId(),propertyValue(id,progress));
      Collection<StorageCommand> commands=new ArrayList<>();
      try (StorageReader statement=storageEngine.newReader()){
        storageEngine.createCommands(commands,txState,statement,null,0,NO_DECORATION);
      }
       return tx(commands);
    }
    private void verifyIndex(    TransactionToApply tx) throws Exception {
      try (IndexReader reader=index.newReader()){
        NodeVisitor visitor=new NodeVisitor();
        for (int i=0; tx != null; i++) {
          tx.transactionRepresentation().accept(visitor.clear());
          Value propertyValue=propertyValue(id,base + i);
          IndexQuery.ExactPredicate query=IndexQuery.exact(descriptor.getPropertyId(),propertyValue);
          LongIterator hits=reader.query(query);
          assertEquals("Index doesn't contain " + visitor.nodeId + " "+ propertyValue,visitor.nodeId,hits.next());
          assertFalse(hits.hasNext());
          tx=tx.next();
        }
      }
     }
  }
private static class NodeVisitor implements Visitor<StorageCommand,IOException> {
    long nodeId;
    @Override public boolean visit(    StorageCommand element){
      if (element instanceof NodeCommand) {
        nodeId=((NodeCommand)element).getKey();
      }
      return false;
    }
    public NodeVisitor clear(){
      nodeId=-1;
      return this;
    }
  }
}
