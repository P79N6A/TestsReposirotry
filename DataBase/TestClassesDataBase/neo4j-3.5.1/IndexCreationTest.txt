/** 
 * Test for a problem where multiple threads getting an index for the first time and adding to or removing from it right there after. There was a race condition where the transaction which created the index came after the first one using it.
 * @author Mattias Persson
 */
public class IndexCreationTest {
  @Rule public final TestDirectory testDirectory=TestDirectory.testDirectory();
  private GraphDatabaseAPI db;
  @Before public void before(){
    db=(GraphDatabaseAPI)new TestGraphDatabaseFactory().newEmbeddedDatabase(testDirectory.storeDir());
  }
  @After public void after(){
    db.shutdown();
  }
  @Test public void indexCreationConfigRaceCondition() throws Exception {
    for (int run=0; run < 10; run++) {
      final int r=run;
      final CountDownLatch latch=new CountDownLatch(1);
      ExecutorService executor=newCachedThreadPool();
      for (int thread=0; thread < 10; thread++) {
        executor.submit(() -> {
          try (Transaction tx=db.beginTx()){
            latch.await();
            Index<Node> index=db.index().forNodes("index" + r);
            Node node=db.createNode();
            index.add(node,"name","Name");
            tx.success();
          }
 catch (          InterruptedException e) {
            Thread.interrupted();
          }
        }
);
      }
      latch.countDown();
      executor.shutdown();
      executor.awaitTermination(10,TimeUnit.SECONDS);
      verifyThatIndexCreationTransactionIsTheFirstOne();
    }
  }
  private void verifyThatIndexCreationTransactionIsTheFirstOne() throws Exception {
    LogFiles logFiles=db.getDependencyResolver().resolveDependency(LogFiles.class);
    long version=db.getDependencyResolver().resolveDependency(LogVersionRepository.class).getCurrentLogVersion();
    db.getDependencyResolver().resolveDependency(LogRotation.class).rotateLogFile();
    db.getDependencyResolver().resolveDependency(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("test"));
    ReadableLogChannel logChannel=logFiles.getLogFile().getReader(LogPosition.start(version));
    final AtomicBoolean success=new AtomicBoolean(false);
    try (IOCursor<LogEntry> cursor=new LogEntryCursor(new VersionAwareLogEntryReader<>(),logChannel)){
      List<StorageCommand> commandsInFirstEntry=new ArrayList<>();
      boolean startFound=false;
      while (cursor.next()) {
        LogEntry entry=cursor.get();
        if (entry instanceof LogEntryStart) {
          if (startFound) {
            throw new IllegalArgumentException("More than one start entry");
          }
          startFound=true;
        }
        if (startFound && entry instanceof LogEntryCommand) {
          commandsInFirstEntry.add(entry.<LogEntryCommand>as().getCommand());
        }
        if (entry instanceof LogEntryCommit) {
          assertTrue(startFound);
          assertFalse("Index creation transaction wasn't the first one",commandsInFirstEntry.isEmpty());
          List<StorageCommand> createCommands=Iterators.asList(new FilteringIterator<>(commandsInFirstEntry.iterator(),item -> item instanceof IndexDefineCommand));
          assertEquals(1,createCommands.size());
          success.set(true);
          break;
        }
      }
    }
     assertTrue("Didn't find any commit record in log " + version,success.get());
  }
}
