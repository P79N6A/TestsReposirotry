public class CheckPointerImplTest {
  private static final SimpleTriggerInfo INFO=new SimpleTriggerInfo("test");
  private final TransactionIdStore txIdStore=mock(TransactionIdStore.class);
  private final CheckPointThreshold threshold=mock(CheckPointThreshold.class);
  private final StorageEngine storageEngine=mock(StorageEngine.class);
  private final LogPruning logPruning=mock(LogPruning.class);
  private final TransactionAppender appender=mock(TransactionAppender.class);
  private final DatabaseHealth health=mock(DatabaseHealth.class);
  private final CheckPointTracer tracer=mock(CheckPointTracer.class,RETURNS_MOCKS);
  private IOLimiter limiter=mock(IOLimiter.class);
  private final long initialTransactionId=2L;
  private final long transactionId=42L;
  private final LogPosition logPosition=new LogPosition(16L,233L);
  @Test public void shouldNotFlushIfItIsNotNeeded() throws Throwable {
    CheckPointerImpl checkPointing=checkPointer();
    when(threshold.isCheckPointingNeeded(anyLong(),any(TriggerInfo.class))).thenReturn(false);
    checkPointing.start();
    long txId=checkPointing.checkPointIfNeeded(INFO);
    assertEquals(-1,txId);
    verifyZeroInteractions(storageEngine);
    verifyZeroInteractions(tracer);
    verifyZeroInteractions(appender);
  }
  @Test public void shouldFlushIfItIsNeeded() throws Throwable {
    CheckPointerImpl checkPointing=checkPointer();
    when(threshold.isCheckPointingNeeded(anyLong(),eq(INFO))).thenReturn(true,false);
    mockTxIdStore();
    checkPointing.start();
    long txId=checkPointing.checkPointIfNeeded(INFO);
    assertEquals(transactionId,txId);
    verify(storageEngine,times(1)).flushAndForce(limiter);
    verify(health,times(2)).assertHealthy(IOException.class);
    verify(appender,times(1)).checkPoint(eq(logPosition),any(LogCheckPointEvent.class));
    verify(threshold,times(1)).initialize(initialTransactionId);
    verify(threshold,times(1)).checkPointHappened(transactionId);
    verify(threshold,times(1)).isCheckPointingNeeded(transactionId,INFO);
    verify(logPruning,times(1)).pruneLogs(logPosition.getLogVersion());
    verify(tracer,times(1)).beginCheckPoint();
    verifyNoMoreInteractions(storageEngine,health,appender,threshold,tracer);
  }
  @Test public void shouldForceCheckPointAlways() throws Throwable {
    CheckPointerImpl checkPointing=checkPointer();
    when(threshold.isCheckPointingNeeded(anyLong(),eq(INFO))).thenReturn(false);
    mockTxIdStore();
    checkPointing.start();
    long txId=checkPointing.forceCheckPoint(INFO);
    assertEquals(transactionId,txId);
    verify(storageEngine,times(1)).flushAndForce(limiter);
    verify(health,times(2)).assertHealthy(IOException.class);
    verify(appender,times(1)).checkPoint(eq(logPosition),any(LogCheckPointEvent.class));
    verify(threshold,times(1)).initialize(initialTransactionId);
    verify(threshold,times(1)).checkPointHappened(transactionId);
    verify(threshold,never()).isCheckPointingNeeded(transactionId,INFO);
    verify(logPruning,times(1)).pruneLogs(logPosition.getLogVersion());
    verifyZeroInteractions(tracer);
    verifyNoMoreInteractions(storageEngine,health,appender,threshold,tracer);
  }
  @Test public void shouldCheckPointAlwaysWhenThereIsNoRunningCheckPoint() throws Throwable {
    CheckPointerImpl checkPointing=checkPointer();
    when(threshold.isCheckPointingNeeded(anyLong(),eq(INFO))).thenReturn(false);
    mockTxIdStore();
    checkPointing.start();
    long txId=checkPointing.tryCheckPoint(INFO);
    assertEquals(transactionId,txId);
    verify(storageEngine,times(1)).flushAndForce(limiter);
    verify(health,times(2)).assertHealthy(IOException.class);
    verify(appender,times(1)).checkPoint(eq(logPosition),any(LogCheckPointEvent.class));
    verify(threshold,times(1)).initialize(initialTransactionId);
    verify(threshold,times(1)).checkPointHappened(transactionId);
    verify(threshold,never()).isCheckPointingNeeded(transactionId,INFO);
    verify(logPruning,times(1)).pruneLogs(logPosition.getLogVersion());
    verifyZeroInteractions(tracer);
    verifyNoMoreInteractions(storageEngine,health,appender,threshold,tracer);
  }
  @Test public void forceCheckPointShouldWaitTheCurrentCheckPointingToCompleteBeforeRunning() throws Throwable {
    Lock lock=new ReentrantLock();
    final Lock spyLock=spy(lock);
    doAnswer(invocation -> {
      verify(appender).checkPoint(any(LogPosition.class),any(LogCheckPointEvent.class));
      reset(appender);
      invocation.callRealMethod();
      return null;
    }
).when(spyLock).unlock();
    final CheckPointerImpl checkPointing=checkPointer(mutex(spyLock));
    mockTxIdStore();
    final CountDownLatch startSignal=new CountDownLatch(2);
    final CountDownLatch completed=new CountDownLatch(2);
    checkPointing.start();
    Thread checkPointerThread=new CheckPointerThread(checkPointing,startSignal,completed);
    Thread forceCheckPointThread=new Thread(() -> {
      try {
        startSignal.countDown();
        startSignal.await();
        checkPointing.forceCheckPoint(INFO);
        completed.countDown();
      }
 catch (      Throwable e) {
        throw new RuntimeException(e);
      }
    }
);
    checkPointerThread.start();
    forceCheckPointThread.start();
    completed.await();
    verify(spyLock,times(2)).lock();
    verify(spyLock,times(2)).unlock();
  }
  private StoreCopyCheckPointMutex mutex(  Lock lock){
    return new StoreCopyCheckPointMutex(new ReadWriteLock(){
      @Override public Lock writeLock(){
        return lock;
      }
      @Override public Lock readLock(){
        throw new UnsupportedOperationException();
      }
    }
);
  }
  @Test public void tryCheckPointShouldWaitTheCurrentCheckPointingToCompleteNoRunCheckPointButUseTheTxIdOfTheEarlierRun() throws Throwable {
    Lock lock=mock(Lock.class);
    final CheckPointerImpl checkPointing=checkPointer(mutex(lock));
    mockTxIdStore();
    checkPointing.forceCheckPoint(INFO);
    verify(appender).checkPoint(eq(logPosition),any(LogCheckPointEvent.class));
    reset(appender);
    checkPointing.tryCheckPoint(INFO);
    verifyNoMoreInteractions(appender);
  }
  @Test public void mustUseIoLimiterFromFlushing() throws Throwable {
    limiter=new IOLimiter(){
      @Override public long maybeLimitIO(      long previousStamp,      int recentlyCompletedIOs,      Flushable flushable){
        return 42;
      }
      @Override public boolean isLimited(){
        return true;
      }
    }
;
    when(threshold.isCheckPointingNeeded(anyLong(),eq(INFO))).thenReturn(true,false);
    mockTxIdStore();
    CheckPointerImpl checkPointing=checkPointer();
    checkPointing.start();
    checkPointing.checkPointIfNeeded(INFO);
    verify(storageEngine).flushAndForce(limiter);
  }
  @Test public void mustFlushAsFastAsPossibleDuringForceCheckPoint() throws Exception {
    AtomicBoolean doneDisablingLimits=new AtomicBoolean();
    limiter=new IOLimiter(){
      @Override public long maybeLimitIO(      long previousStamp,      int recentlyCompletedIOs,      Flushable flushable){
        return 0;
      }
      @Override public void enableLimit(){
        doneDisablingLimits.set(true);
      }
      @Override public boolean isLimited(){
        return doneDisablingLimits.get();
      }
    }
;
    mockTxIdStore();
    CheckPointerImpl checkPointer=checkPointer();
    checkPointer.forceCheckPoint(new SimpleTriggerInfo("test"));
    assertTrue(doneDisablingLimits.get());
  }
  @Test public void mustFlushAsFastAsPossibleDuringTryCheckPoint() throws Exception {
    AtomicBoolean doneDisablingLimits=new AtomicBoolean();
    limiter=new IOLimiter(){
      @Override public long maybeLimitIO(      long previousStamp,      int recentlyCompletedIOs,      Flushable flushable){
        return 0;
      }
      @Override public void enableLimit(){
        doneDisablingLimits.set(true);
      }
      @Override public boolean isLimited(){
        return doneDisablingLimits.get();
      }
    }
;
    mockTxIdStore();
    CheckPointerImpl checkPointer=checkPointer();
    checkPointer.tryCheckPoint(INFO);
    assertTrue(doneDisablingLimits.get());
  }
  private void verifyAsyncActionCausesConcurrentFlushingRush(  ThrowingConsumer<CheckPointerImpl,IOException> asyncAction) throws Exception {
    AtomicLong limitDisableCounter=new AtomicLong();
    AtomicLong observedRushCount=new AtomicLong();
    BinaryLatch backgroundCheckPointStartedLatch=new BinaryLatch();
    BinaryLatch forceCheckPointStartLatch=new BinaryLatch();
    limiter=new IOLimiter(){
      @Override public long maybeLimitIO(      long previousStamp,      int recentlyCompletedIOs,      Flushable flushable){
        return 0;
      }
      @Override public void disableLimit(){
        limitDisableCounter.getAndIncrement();
        forceCheckPointStartLatch.release();
      }
      @Override public void enableLimit(){
        limitDisableCounter.getAndDecrement();
      }
      @Override public boolean isLimited(){
        return limitDisableCounter.get() != 0;
      }
    }
;
    mockTxIdStore();
    CheckPointerImpl checkPointer=checkPointer();
    doAnswer(invocation -> {
      backgroundCheckPointStartedLatch.release();
      forceCheckPointStartLatch.await();
      long newValue=limitDisableCounter.get();
      observedRushCount.set(newValue);
      return null;
    }
).when(storageEngine).flushAndForce(limiter);
    Future<Object> forceCheckPointer=forkFuture(() -> {
      backgroundCheckPointStartedLatch.await();
      asyncAction.accept(checkPointer);
      return null;
    }
);
    when(threshold.isCheckPointingNeeded(anyLong(),eq(INFO))).thenReturn(true);
    checkPointer.checkPointIfNeeded(INFO);
    forceCheckPointer.get();
    assertThat(observedRushCount.get(),is(1L));
  }
  @Test(timeout=5000) public void mustRequestFastestPossibleFlushWhenForceCheckPointIsCalledDuringBackgroundCheckPoint() throws Exception {
    verifyAsyncActionCausesConcurrentFlushingRush(checkPointer -> checkPointer.forceCheckPoint(new SimpleTriggerInfo("async")));
  }
  @Test(timeout=5000) public void mustRequestFastestPossibleFlushWhenTryCheckPointIsCalledDuringBackgroundCheckPoint() throws Exception {
    verifyAsyncActionCausesConcurrentFlushingRush(checkPointer -> checkPointer.tryCheckPoint(new SimpleTriggerInfo("async")));
  }
  private CheckPointerImpl checkPointer(  StoreCopyCheckPointMutex mutex){
    return new CheckPointerImpl(txIdStore,threshold,storageEngine,logPruning,appender,health,NullLogProvider.getInstance(),tracer,limiter,mutex);
  }
  private CheckPointerImpl checkPointer(){
    return checkPointer(new StoreCopyCheckPointMutex());
  }
  private void mockTxIdStore(){
    long[] triggerCommittedTransaction={transactionId,logPosition.getLogVersion(),logPosition.getByteOffset()};
    when(txIdStore.getLastClosedTransaction()).thenReturn(triggerCommittedTransaction);
    when(txIdStore.getLastClosedTransactionId()).thenReturn(initialTransactionId,transactionId,transactionId);
  }
private static class CheckPointerThread extends Thread {
    private final CheckPointerImpl checkPointing;
    private final CountDownLatch startSignal;
    private final CountDownLatch completed;
    CheckPointerThread(    CheckPointerImpl checkPointing,    CountDownLatch startSignal,    CountDownLatch completed){
      this.checkPointing=checkPointing;
      this.startSignal=startSignal;
      this.completed=completed;
    }
    @Override public void run(){
      try {
        startSignal.countDown();
        startSignal.await();
        checkPointing.forceCheckPoint(INFO);
        completed.countDown();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
  }
}
