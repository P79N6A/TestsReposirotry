public class RelationshipGroupCacheTest {
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldPutGroupsOnlyWithinPreparedRange(){
    int nodeCount=1000;
    RelationshipGroupCache cache=new RelationshipGroupCache(HEAP,ByteUnit.kibiBytes(4),nodeCount);
    int[] counts=new int[nodeCount];
    for (int nodeId=0; nodeId < counts.length; nodeId++) {
      counts[nodeId]=random.nextInt(10);
      setCount(cache,nodeId,counts[nodeId]);
    }
    long toNodeId=cache.prepare(0);
    assertTrue(toNodeId < nodeCount);
    boolean thereAreMoreGroups=true;
    int cachedCount=0;
    while (thereAreMoreGroups) {
      thereAreMoreGroups=false;
      for (int nodeId=0; nodeId < nodeCount; nodeId++) {
        if (counts[nodeId] > 0) {
          thereAreMoreGroups=true;
          int typeId=counts[nodeId]--;
          if (cache.put(new RelationshipGroupRecord(nodeId).initialize(true,typeId,-1,-1,-1,nodeId,-1))) {
            cachedCount++;
          }
        }
      }
    }
    assertTrue(cachedCount >= toNodeId);
    int readCount=0;
    for (    RelationshipGroupRecord cachedGroup : cache) {
      assertTrue(cachedGroup.getOwningNode() >= 0 && cachedGroup.getOwningNode() < toNodeId);
      readCount++;
    }
    assertEquals(cachedCount,readCount);
  }
  @Test public void shouldNotFindSpaceToPutMoreGroupsThanSpecifiedForANode(){
    int nodeCount=10;
    RelationshipGroupCache cache=new RelationshipGroupCache(HEAP,ByteUnit.kibiBytes(4),nodeCount);
    setCount(cache,1,7);
    assertEquals(nodeCount,cache.prepare(0));
    for (int i=0; i < 7; i++) {
      cache.put(new RelationshipGroupRecord(i + 1).initialize(true,i,-1,-1,-1,1,-1));
    }
    try {
      cache.put(new RelationshipGroupRecord(8).initialize(true,8,-1,-1,-1,1,-1));
      fail("Should have failed");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void shouldSortOutOfOrderTypes(){
    int nodeCount=100;
    RelationshipGroupCache cache=new RelationshipGroupCache(HEAP,ByteUnit.kibiBytes(40),nodeCount);
    int[] counts=new int[nodeCount];
    int groupCount=0;
    for (int nodeId=0; nodeId < counts.length; nodeId++) {
      counts[nodeId]=random.nextInt(10);
      setCount(cache,nodeId,counts[nodeId]);
      groupCount+=counts[nodeId];
    }
    assertEquals(nodeCount,cache.prepare(0));
    boolean thereAreMoreGroups=true;
    int cachedCount=0;
    int[] types=scrambledTypes(10);
    for (int i=0; thereAreMoreGroups; i++) {
      int typeId=types[i];
      thereAreMoreGroups=false;
      for (int nodeId=0; nodeId < nodeCount; nodeId++) {
        if (counts[nodeId] > 0) {
          thereAreMoreGroups=true;
          if (cache.put(new RelationshipGroupRecord(nodeId).initialize(true,typeId,-1,-1,-1,nodeId,-1))) {
            cachedCount++;
            counts[nodeId]--;
          }
        }
      }
    }
    assertEquals(groupCount,cachedCount);
    long currentNodeId=-1;
    int currentTypeId=-1;
    int readCount=0;
    for (    RelationshipGroupRecord group : cache) {
      assertTrue(group.getOwningNode() >= currentNodeId);
      if (group.getOwningNode() > currentNodeId) {
        currentNodeId=group.getOwningNode();
        currentTypeId=-1;
      }
      assertTrue(group.getType() > currentTypeId);
      readCount++;
    }
    assertEquals(cachedCount,readCount);
  }
  @Test public void shouldHandleGroupCountBeyondSignedShortRange(){
    long nodeId=0;
    int limit=Short.MAX_VALUE + 10;
    RelationshipGroupCache cache=new RelationshipGroupCache(HEAP,ByteUnit.kibiBytes(100),nodeId + 1);
    for (int type=0; type < limit; type++) {
      cache.incrementGroupCount(nodeId);
    }
    RelationshipGroupRecord group=new RelationshipGroupRecord(-1);
    group.setOwningNode(nodeId);
    for (int type=0; type < limit; type++) {
      group.setId(type);
      group.setFirstOut(type);
      group.setType(type);
      cache.put(group);
    }
    long prepared=cache.prepare(nodeId);
    assertEquals(nodeId,prepared);
    assertEquals(limit,cache.groupCount(nodeId));
  }
  private int[] scrambledTypes(  int count){
    int[] types=new int[count];
    for (int i=0; i < count; i++) {
      types[i]=i + Short.MAX_VALUE;
    }
    for (int i=0; i < 10; i++) {
      swap(types,i,random.nextInt(count));
    }
    return types;
  }
  private void swap(  int[] types,  int a,  int b){
    int temp=types[a];
    types[a]=types[b];
    types[b]=temp;
  }
  private void setCount(  RelationshipGroupCache cache,  int nodeId,  int count){
    for (int i=0; i < count; i++) {
      cache.incrementGroupCount(nodeId);
    }
  }
}
