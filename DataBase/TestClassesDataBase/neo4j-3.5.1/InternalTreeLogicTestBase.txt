@RunWith(Parameterized.class) public abstract class InternalTreeLogicTestBase<KEY,VALUE> {
  protected TestLayout<KEY,VALUE> layout;
  protected TreeNode<KEY,VALUE> node;
  private final int pageSize=256;
  private PageAwareByteArrayCursor cursor;
  private PageAwareByteArrayCursor readCursor;
  private SimpleIdProvider id;
  private ValueMerger<KEY,VALUE> adder;
  private InternalTreeLogic<KEY,VALUE> treeLogic;
  private VALUE dontCare;
  private StructurePropagation<KEY> structurePropagation;
  private static long stableGeneration=GenerationSafePointer.MIN_GENERATION;
  private static long unstableGeneration=stableGeneration + 1;
  @Parameterized.Parameters(name="{0}") public static Collection<Object[]> generators(){
    List<Object[]> parameters=new ArrayList<>();
    parameters.add(new Object[]{"NoCheckpoint",GenerationManager.NO_OP_GENERATION,false});
    parameters.add(new Object[]{"Checkpoint",GenerationManager.DEFAULT,true});
    return parameters;
  }
  @Parameterized.Parameter(0) public String name;
  @Parameterized.Parameter(1) public GenerationManager generationManager;
  @Parameterized.Parameter(2) public boolean isCheckpointing;
  @Rule public RandomRule random=new RandomRule();
  long rootId;
  int numberOfRootSplits;
  private long rootGeneration;
  private int numberOfRootSuccessors;
  @Before public void setUp() throws IOException {
    cursor=new PageAwareByteArrayCursor(pageSize);
    readCursor=cursor.duplicate();
    id=new SimpleIdProvider(cursor::duplicate);
    id.reset();
    long newId=id.acquireNewId(stableGeneration,unstableGeneration);
    goTo(cursor,newId);
    readCursor.next(newId);
    layout=getLayout();
    node=getTreeNode(pageSize,layout);
    adder=getAdder();
    treeLogic=new InternalTreeLogic<>(id,node,layout);
    dontCare=layout.newValue();
    structurePropagation=new StructurePropagation<>(layout.newKey(),layout.newKey(),layout.newKey());
  }
  protected abstract ValueMerger<KEY,VALUE> getAdder();
  protected abstract TreeNode<KEY,VALUE> getTreeNode(  int pageSize,  Layout<KEY,VALUE> layout);
  protected abstract TestLayout<KEY,VALUE> getLayout();
  @Test public void modifierMustInsertAtFirstPositionInEmptyLeaf() throws Exception {
    initialize();
    KEY key=key(1L);
    VALUE value=value(1L);
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(0));
    generationManager.checkpoint();
    insert(key,value);
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(1));
    assertEqualsKey(keyAt(0,LEAF),key);
    assertEqualsValue(valueAt(0),value);
  }
  @Test public void modifierMustSortCorrectlyOnInsertFirstInLeaf() throws Exception {
    initialize();
    generationManager.checkpoint();
    long someHighSeed=1000L;
    int keyCount=0;
    KEY newKey=key(someHighSeed);
    VALUE newValue=value(someHighSeed);
    while (node.leafOverflow(cursor,keyCount,newKey,newValue) == NO) {
      insert(newKey,newValue);
      readCursor.next(rootId);
      assertEqualsKey(keyAt(0,LEAF),newKey);
      assertEqualsValue(valueAt(0),newValue);
      keyCount++;
      newKey=key(someHighSeed - keyCount);
      newValue=value(someHighSeed - keyCount);
    }
  }
  @Test public void modifierMustSortCorrectlyOnInsertLastInLeaf() throws Exception {
    initialize();
    generationManager.checkpoint();
    int keyCount=0;
    KEY key=key(keyCount);
    VALUE value=value(keyCount);
    while (node.leafOverflow(cursor,keyCount,key,value) == NO) {
      insert(key,value);
      readCursor.next(rootId);
      assertEqualsKey(keyAt(keyCount,LEAF),key);
      assertEqualsValue(valueAt(keyCount),value);
      keyCount++;
      key=key(keyCount);
      value=value(keyCount);
    }
  }
  @Test public void modifierMustSortCorrectlyOnInsertInMiddleOfLeaf() throws Exception {
    initialize();
    generationManager.checkpoint();
    int keyCount=0;
    int someHighSeed=1000;
    long middleValue=keyCount % 2 == 0 ? keyCount / 2 : someHighSeed - keyCount / 2;
    KEY key=key(middleValue);
    VALUE value=value(middleValue);
    while (node.leafOverflow(cursor,keyCount,key,value) == NO) {
      insert(key,value);
      readCursor.next(rootId);
      assertEqualsKey(keyAt((keyCount + 1) / 2,LEAF),key);
      keyCount++;
      middleValue=keyCount % 2 == 0 ? keyCount / 2 : someHighSeed - keyCount / 2;
      key=key(middleValue);
      value=value(middleValue);
    }
  }
  @Test public void modifierMustSplitWhenInsertingMiddleOfFullLeaf() throws Exception {
    initialize();
    int someMiddleSeed=1000;
    int keyCount=0;
    int middle=keyCount % 2 == 0 ? keyCount : someMiddleSeed - keyCount;
    KEY key=key(middle);
    VALUE value=value(middle);
    while (node.leafOverflow(cursor,keyCount,key,value) == NO) {
      insert(key,value);
      keyCount++;
      middle=keyCount % 2 == 0 ? keyCount : someMiddleSeed - keyCount;
      key=key(middle);
      value=value(middle);
    }
    generationManager.checkpoint();
    insert(key,value);
    assertEquals(1,numberOfRootSplits);
  }
  @Test public void modifierMustSplitWhenInsertingLastInFullLeaf() throws Exception {
    initialize();
    int keyCount=0;
    KEY key=key(keyCount);
    VALUE value=value(keyCount);
    while (node.leafOverflow(cursor,keyCount,key,value) == NO) {
      insert(key,value);
      assertFalse(structurePropagation.hasRightKeyInsert);
      keyCount++;
      key=key(keyCount);
      value=value(keyCount);
    }
    generationManager.checkpoint();
    insert(key,value);
    assertEquals(1,numberOfRootSplits);
  }
  @Test public void modifierMustSplitWhenInsertingFirstInFullLeaf() throws Exception {
    initialize();
    int keyCount=0;
    int someHighSeed=1000;
    KEY key=key(someHighSeed - keyCount);
    VALUE value=value(someHighSeed - keyCount);
    while (node.leafOverflow(cursor,keyCount,key,value) == NO) {
      insert(key,value);
      assertFalse(structurePropagation.hasRightKeyInsert);
      keyCount++;
      key=key(someHighSeed - keyCount);
      value=value(someHighSeed - keyCount);
    }
    generationManager.checkpoint();
    insert(key,value);
    assertEquals(1,numberOfRootSplits);
  }
  @Test public void modifierMustUpdatePointersInSiblingsToSplit() throws Exception {
    initialize();
    long someLargeSeed=10000;
    int keyCount=0;
    KEY key=key(someLargeSeed - keyCount);
    VALUE value=value(someLargeSeed - keyCount);
    while (node.leafOverflow(cursor,keyCount,key,value) == NO) {
      insert(key,value);
      keyCount++;
      key=key(someLargeSeed - keyCount);
      value=value(someLargeSeed - keyCount);
    }
    generationManager.checkpoint();
    insert(key,value);
    keyCount++;
    key=key(someLargeSeed - keyCount);
    value=value(keyCount);
    goTo(readCursor,rootId);
    long child0=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long child1=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertSiblingOrderAndPointers(child0,child1);
    while (keyCount(rootId) == 1) {
      insert(key,value);
      keyCount++;
      key=key(someLargeSeed - keyCount);
      value=value(keyCount);
    }
    assertTrue(TreeNode.isInternal(readCursor));
    assertThat(TreeNode.keyCount(readCursor),is(2));
    child0=childAt(readCursor,0,stableGeneration,unstableGeneration);
    child1=childAt(readCursor,1,stableGeneration,unstableGeneration);
    long child2=childAt(readCursor,2,stableGeneration,unstableGeneration);
    assertSiblingOrderAndPointers(child0,child1,child2);
  }
  @Test public void modifierMustRemoveFirstInEmptyLeaf() throws Exception {
    initialize();
    long keyValue=1L;
    long valueValue=1L;
    KEY key=key(keyValue);
    VALUE value=value(valueValue);
    insert(key,value);
    generationManager.checkpoint();
    VALUE readValue=layout.newValue();
    remove(key,readValue);
    goTo(readCursor,rootId);
    assertThat(TreeNode.keyCount(cursor),is(0));
    assertEqualsValue(value,readValue);
  }
  @Test public void modifierMustRemoveFirstInFullLeaf() throws Exception {
    initialize();
    int maxKeyCount=0;
    KEY key=key(maxKeyCount);
    VALUE value=value(maxKeyCount);
    while (node.leafOverflow(cursor,maxKeyCount,key,value) == NO) {
      insert(key,value);
      maxKeyCount++;
      key=key(maxKeyCount);
      value=value(maxKeyCount);
    }
    generationManager.checkpoint();
    VALUE readValue=layout.newValue();
    remove(key(0),readValue);
    assertEqualsValue(value(0),readValue);
    goTo(readCursor,rootId);
    assertThat(TreeNode.keyCount(readCursor),is(maxKeyCount - 1));
    for (int i=0; i < maxKeyCount - 1; i++) {
      assertEqualsKey(keyAt(i,LEAF),key(i + 1L));
    }
  }
  @Test public void modifierMustRemoveInMiddleInFullLeaf() throws Exception {
    initialize();
    int maxKeyCount=0;
    KEY key=key(maxKeyCount);
    VALUE value=value(maxKeyCount);
    while (node.leafOverflow(cursor,maxKeyCount,key,value) == NO) {
      insert(key,value);
      maxKeyCount++;
      key=key(maxKeyCount);
      value=value(maxKeyCount);
    }
    int middle=maxKeyCount / 2;
    generationManager.checkpoint();
    VALUE readValue=layout.newValue();
    remove(key(middle),readValue);
    assertEqualsValue(value(middle),readValue);
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(maxKeyCount - 1));
    assertEqualsKey(keyAt(middle,LEAF),key(middle + 1L));
    for (int i=0; i < maxKeyCount - 1; i++) {
      long expected=i < middle ? i : i + 1L;
      assertEqualsKey(keyAt(i,LEAF),key(expected));
    }
  }
  @Test public void modifierMustRemoveLastInFullLeaf() throws Exception {
    initialize();
    int maxKeyCount=0;
    KEY key=key(maxKeyCount);
    VALUE value=value(maxKeyCount);
    while (node.leafOverflow(cursor,maxKeyCount,key,value) == NO) {
      insert(key,value);
      maxKeyCount++;
      key=key(maxKeyCount);
      value=value(maxKeyCount);
    }
    generationManager.checkpoint();
    VALUE readValue=layout.newValue();
    remove(key(maxKeyCount - 1),readValue);
    assertEqualsValue(value(maxKeyCount - 1),readValue);
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(maxKeyCount - 1));
    for (int i=0; i < maxKeyCount - 1; i++) {
      assertEqualsKey(keyAt(i,LEAF),key(i));
    }
  }
  @Test public void modifierMustRemoveFromLeftChild() throws Exception {
    initialize();
    for (int i=0; numberOfRootSplits == 0; i++) {
      insert(key(i),value(i));
    }
    generationManager.checkpoint();
    goTo(readCursor,structurePropagation.midChild);
    assertEqualsKey(keyAt(0,LEAF),key(0L));
    VALUE readValue=layout.newValue();
    remove(key(0),readValue);
    assertEqualsValue(value(0),readValue);
    goTo(readCursor,structurePropagation.midChild);
    assertEqualsKey(keyAt(0,LEAF),key(1L));
  }
  @Test public void modifierMustRemoveFromRightChildButNotFromInternalWithHitOnInternalSearch() throws Exception {
    initialize();
    int i;
    for (i=0; numberOfRootSplits == 0; i++) {
      insert(key(i),value(i));
    }
    insert(key(i),value(i));
    KEY internalKey=structurePropagation.rightKey;
    goTo(readCursor,rootId);
    assertEqualsKey(keyAt(0,INTERNAL),internalKey);
    long rightChild=structurePropagation.rightChild;
    goTo(readCursor,rightChild);
    int keyCountInRightChild=keyCount();
    KEY keyToRemove=keyAt(0,LEAF);
    assertEquals("expected same seed",getSeed(keyToRemove),getSeed(internalKey));
    generationManager.checkpoint();
    remove(keyToRemove,dontCare);
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(1));
    assertEquals("expected same seed",getSeed(keyAt(0,INTERNAL)),getSeed(keyToRemove));
    rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    goTo(readCursor,rightChild);
    assertThat(keyCount(),is(keyCountInRightChild - 1));
    assertEqualsKey(keyAt(0,LEAF),key(getSeed(keyToRemove) + 1));
  }
  @Test public void modifierMustNotRemoveWhenKeyDoesNotExist() throws Exception {
    initialize();
    int maxKeyCount=0;
    KEY key=key(maxKeyCount);
    VALUE value=value(maxKeyCount);
    while (node.leafOverflow(cursor,maxKeyCount,key,value) == NO) {
      insert(key,value);
      maxKeyCount++;
      key=key(maxKeyCount);
      value=value(maxKeyCount);
    }
    generationManager.checkpoint();
    assertNull(remove(key(maxKeyCount),dontCare));
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(maxKeyCount));
    for (int i=0; i < maxKeyCount; i++) {
      assertEqualsKey(keyAt(i,LEAF),key(i));
    }
  }
  @Test public void modifierMustNotRemoveWhenKeyOnlyExistInInternal() throws Exception {
    initialize();
    int i;
    for (i=0; numberOfRootSplits == 0; i++) {
      insert(key(i),value(i));
    }
    insert(key(i),value(i));
    long currentRightChild=structurePropagation.rightChild;
    KEY keyToRemove=keyAt(currentRightChild,0,LEAF);
    assertEquals(getSeed(keyAt(rootId,0,INTERNAL)),getSeed(keyToRemove));
    goTo(readCursor,currentRightChild);
    int keyCountInRightChild=keyCount();
    assertEquals("same seed",getSeed(keyToRemove),getSeed(keyAt(0,LEAF)));
    generationManager.checkpoint();
    remove(keyToRemove,dontCare);
    goTo(readCursor,rootId);
    currentRightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertThat(keyCount(),is(1));
    assertEquals("same seed",getSeed(keyAt(0,INTERNAL)),getSeed(keyToRemove));
    goTo(readCursor,currentRightChild);
    assertThat(keyCount(),is(keyCountInRightChild - 1));
    assertEquals("same seed",getSeed(keyAt(0,LEAF)),getSeed(key(getSeed(keyToRemove) + 1)));
    assertNull(remove(keyToRemove,dontCare));
  }
  @Test public void mustNotRebalanceFromRightToLeft() throws Exception {
    initialize();
    long key=0;
    while (numberOfRootSplits == 0) {
      insert(key(key),value(key));
      key++;
    }
    insert(key(key),value(key));
    key++;
    goTo(readCursor,rootId);
    KEY primKey=keyAt(0,INTERNAL);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    goTo(readCursor,rightChild);
    int expectedKeyCount=TreeNode.keyCount(readCursor);
    for (long i=0; ; i++) {
      KEY removeKey=key(i);
      if (layout.compare(removeKey,primKey) >= 0) {
        break;
      }
      remove(removeKey,dontCare);
    }
    goTo(readCursor,rightChild);
    int actualKeyCount=TreeNode.keyCount(readCursor);
    assertEquals("actualKeyCount=" + actualKeyCount + ", expectedKeyCount="+ expectedKeyCount,expectedKeyCount,actualKeyCount);
    assertEquals("same seed",getSeed(primKey),getSeed(keyAt(0,LEAF)));
  }
  @Test public void mustPropagateAllStructureChanges() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    long key=10;
    while (numberOfRootSplits == 0) {
      insert(key(key),value(key));
      key++;
    }
    for (long smallKey=0; smallKey < 2; smallKey++) {
      insert(key(smallKey),value(smallKey));
    }
    goTo(readCursor,rootId);
    KEY oldPrimKey=keyAt(0,INTERNAL);
    long originalLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long originalRightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    goTo(readCursor,originalRightChild);
    List<KEY> keysInRightChild=allKeys(readCursor,LEAF);
    generationManager.checkpoint();
    int index=0;
    long rightChild;
    KEY originalLeftmost=keysInRightChild.get(0);
    KEY leftmostInRightChild;
    do {
      remove(keysInRightChild.get(index),dontCare);
      index++;
      goTo(readCursor,rootId);
      rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
      goTo(readCursor,rightChild);
      leftmostInRightChild=keyAt(0,LEAF);
    }
 while (layout.compare(leftmostInRightChild,originalLeftmost) >= 0);
    goTo(readCursor,rootId);
    KEY primKey=keyAt(0,INTERNAL);
    assertEqualsKey(primKey,leftmostInRightChild);
    assertNotEqualsKey(primKey,oldPrimKey);
    long newLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long newRightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertThat(newLeftChild,is(not(originalLeftChild)));
    assertThat(newRightChild,is(not(originalRightChild)));
  }
  @Test public void mustPropagateStructureOnMergeFromLeft() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    List<KEY> allKeys=new ArrayList<>();
    initialize();
    long targetLastId=id.lastId() + 3;
    long i=0;
    for (; id.lastId() < targetLastId; i++) {
      KEY key=key(i);
      insert(key,value(i));
      allKeys.add(key);
    }
    goTo(readCursor,rootId);
    assertEquals(2,keyCount());
    long oldRootId=readCursor.getCurrentPageId();
    long oldLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long oldMiddleChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    long oldRightChild=childAt(readCursor,2,stableGeneration,unstableGeneration);
    assertSiblings(oldLeftChild,oldMiddleChild,oldRightChild);
    generationManager.checkpoint();
    KEY middleKey=keyAt(oldMiddleChild,0,LEAF);
    remove(middleKey,dontCare);
    allKeys.remove(middleKey);
    goTo(readCursor,oldRootId);
    assertEquals(2,keyCount());
    goTo(readCursor,rootId);
    assertEquals(1,keyCount());
    long newLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    assertNotEquals(newLeftChild,oldLeftChild);
    assertNotEquals(newLeftChild,oldMiddleChild);
    long newRightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertEquals(newRightChild,oldRightChild);
    goTo(readCursor,oldLeftChild);
    assertEquals(newLeftChild,successor(readCursor,stableGeneration,unstableGeneration));
    goTo(readCursor,oldMiddleChild);
    assertEquals(newLeftChild,successor(readCursor,stableGeneration,unstableGeneration));
    goTo(readCursor,oldRightChild);
    KEY firstKeyOfOldRightChild=keyAt(0,LEAF);
    int index=indexOf(firstKeyOfOldRightChild,allKeys,layout);
    List<KEY> expectedKeysInNewLeftChild=allKeys.subList(0,index);
    goTo(readCursor,newLeftChild);
    assertNodeContainsExpectedKeys(expectedKeysInNewLeftChild,LEAF);
    assertSiblings(newLeftChild,oldRightChild,TreeNode.NO_NODE_FLAG);
  }
  @Test public void mustPropagateStructureOnMergeToRight() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    List<KEY> allKeys=new ArrayList<>();
    initialize();
    long targetLastId=id.lastId() + 3;
    long i=0;
    for (; id.lastId() < targetLastId; i++) {
      KEY key=key(i);
      insert(key,value(i));
      allKeys.add(key);
    }
    goTo(readCursor,rootId);
    assertEquals(2,keyCount());
    long oldLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long oldMiddleChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    long oldRightChild=childAt(readCursor,2,stableGeneration,unstableGeneration);
    assertSiblings(oldLeftChild,oldMiddleChild,oldRightChild);
    goTo(readCursor,oldLeftChild);
    KEY keyInLeftChild=keyAt(0,LEAF);
    generationManager.checkpoint();
    goTo(readCursor,rootId);
    remove(keyInLeftChild,dontCare);
    allKeys.remove(keyInLeftChild);
    assertEquals(2,keyCount());
    goTo(readCursor,rootId);
    assertEquals(1,keyCount());
    long newLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    assertNotEquals(newLeftChild,oldLeftChild);
    assertNotEquals(newLeftChild,oldMiddleChild);
    long newRightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertEquals(newRightChild,oldRightChild);
    goTo(readCursor,oldLeftChild);
    assertEquals(newLeftChild,newestGeneration(readCursor,stableGeneration,unstableGeneration));
    goTo(readCursor,oldMiddleChild);
    assertEquals(newLeftChild,successor(readCursor,stableGeneration,unstableGeneration));
    goTo(readCursor,oldRightChild);
    KEY firstKeyInOldRightChild=keyAt(0,LEAF);
    int index=indexOf(firstKeyInOldRightChild,allKeys,layout);
    List<KEY> expectedKeysInNewLeftChild=allKeys.subList(0,index);
    goTo(readCursor,newLeftChild);
    assertNodeContainsExpectedKeys(expectedKeysInNewLeftChild,LEAF);
    assertSiblings(newLeftChild,oldRightChild,TreeNode.NO_NODE_FLAG);
  }
  @Test public void mustPropagateStructureWhenMergingBetweenDifferentSubtrees() throws Exception {
    initialize();
    long i=0;
    while (numberOfRootSplits < 2) {
      insert(key(i),value(i));
      i++;
    }
    goTo(readCursor,rootId);
    long oldLeft=rightmostLeafInSubtree(rootId,0);
    long oldRight=leftmostLeafInSubtree(rootId,1);
    KEY oldSplitter=keyAt(0,INTERNAL);
    KEY rightmostKeyInLeftSubtree=rightmostInternalKeyInSubtree(rootId,0);
    ArrayList<KEY> allKeysInOldLeftAndOldRight=new ArrayList<>();
    goTo(readCursor,oldLeft);
    allKeys(readCursor,allKeysInOldLeftAndOldRight,LEAF);
    goTo(readCursor,oldRight);
    allKeys(readCursor,allKeysInOldLeftAndOldRight,LEAF);
    KEY keyInOldRight=keyAt(0,LEAF);
    generationManager.checkpoint();
    remove(keyInOldRight,dontCare);
    remove(keyInOldRight,allKeysInOldLeftAndOldRight,layout);
    goTo(readCursor,rootId);
    KEY newSplitter=keyAt(0,INTERNAL);
    assertNotEqualsKey(newSplitter,oldSplitter);
    assertEqualsKey(newSplitter,rightmostKeyInLeftSubtree);
    KEY newRightmostInternalKeyInLeftSubtree=rightmostInternalKeyInSubtree(rootId,0);
    assertNotEqualsKey(newRightmostInternalKeyInLeftSubtree,rightmostKeyInLeftSubtree);
    goToSuccessor(readCursor,oldRight);
    List<KEY> allKeysInNewRight=allKeys(readCursor,LEAF);
    assertThat(allKeysInNewRight.size(),is(allKeysInOldLeftAndOldRight.size()));
    for (int index=0; index < allKeysInOldLeftAndOldRight.size(); index++) {
      assertEqualsKey(allKeysInOldLeftAndOldRight.get(index),allKeysInNewRight.get(index));
    }
  }
  @Test public void mustLeaveSingleLeafAsRootWhenEverythingIsRemoved() throws Exception {
    List<KEY> allKeys=new ArrayList<>();
    initialize();
    long i=0;
    while (numberOfRootSplits < 3) {
      KEY key=key(i);
      insert(key,value(i));
      allKeys.add(key);
      i++;
    }
    generationManager.checkpoint();
    for (int j=0; j < allKeys.size() - 1; j++) {
      remove(allKeys.get(j),dontCare);
    }
    goTo(readCursor,rootId);
    assertTrue(TreeNode.isLeaf(readCursor));
  }
  @Test public void modifierMustProduceConsistentTreeWithRandomInserts() throws Exception {
    initialize();
    int numberOfEntries=100_000;
    for (int i=0; i < numberOfEntries; i++) {
      long keySeed=random.nextLong();
      insert(key(keySeed),value(random.nextLong()));
      if (i == numberOfEntries / 2) {
        generationManager.checkpoint();
      }
    }
    goTo(readCursor,rootId);
    consistencyCheck();
  }
  @Test public void modifierMustProduceConsistentTreeWithRandomInsertsWithConflictingKeys() throws Exception {
    initialize();
    int numberOfEntries=100_000;
    for (int i=0; i < numberOfEntries; i++) {
      long keySeed=random.nextLong(1000);
      insert(key(keySeed),value(random.nextLong()));
      if (i == numberOfEntries / 2) {
        generationManager.checkpoint();
      }
    }
    consistencyCheck();
  }
  @Test public void modifierMustOverwriteWithOverwriteMerger() throws Exception {
    initialize();
    KEY key=key(random.nextLong());
    VALUE firstValue=value(random.nextLong());
    insert(key,firstValue);
    generationManager.checkpoint();
    VALUE secondValue=value(random.nextLong());
    insert(key,secondValue,ValueMergers.overwrite());
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(1));
    assertEqualsValue(valueAt(0),secondValue);
  }
  @Test public void modifierMustKeepExistingWithKeepExistingMerger() throws Exception {
    initialize();
    KEY key=key(random.nextLong());
    VALUE firstValue=value(random.nextLong());
    insert(key,firstValue,ValueMergers.keepExisting());
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(1));
    VALUE actual=valueAt(0);
    assertEqualsValue(actual,firstValue);
    generationManager.checkpoint();
    VALUE secondValue=value(random.nextLong());
    insert(key,secondValue,ValueMergers.keepExisting());
    goTo(readCursor,rootId);
    assertThat(keyCount(),is(1));
    actual=valueAt(0);
    assertEqualsValue(actual,firstValue);
  }
  @Test public void shouldMergeValue() throws Exception {
    initialize();
    KEY key=key(10);
    long baseValue=100;
    insert(key,value(baseValue));
    generationManager.checkpoint();
    long toAdd=5;
    insert(key,value(toAdd),adder);
    goTo(readCursor,rootId);
    int searchResult=KeySearch.search(readCursor,node,LEAF,key,layout.newKey(),keyCount());
    assertTrue(KeySearch.isHit(searchResult));
    int pos=KeySearch.positionOf(searchResult);
    assertEquals(0,pos);
    assertEqualsKey(key,keyAt(pos,LEAF));
    assertEqualsValue(value(baseValue + toAdd),valueAt(pos));
  }
  @Test public void shouldCreateNewVersionWhenInsertInStableRootAsLeaf() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    long oldGenerationId=cursor.getCurrentPageId();
    generationManager.checkpoint();
    insert(key(1L),value(1L));
    long successor=cursor.getCurrentPageId();
    goTo(readCursor,rootId);
    assertEquals(1,numberOfRootSuccessors);
    assertEquals(successor,structurePropagation.midChild);
    assertNotEquals(oldGenerationId,successor);
    assertEquals(1,keyCount());
    goTo(readCursor,oldGenerationId);
    assertEquals(successor,successor(readCursor,stableGeneration,unstableGeneration));
    assertEquals(0,keyCount());
  }
  @Test public void shouldCreateNewVersionWhenRemoveInStableRootAsLeaf() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    KEY key=key(1L);
    VALUE value=value(10L);
    insert(key,value);
    long oldGenerationId=cursor.getCurrentPageId();
    generationManager.checkpoint();
    remove(key,dontCare);
    long successor=cursor.getCurrentPageId();
    goTo(readCursor,rootId);
    assertEquals(1,numberOfRootSuccessors);
    assertEquals(successor,structurePropagation.midChild);
    assertNotEquals(oldGenerationId,successor);
    assertEquals(0,keyCount());
    goTo(readCursor,oldGenerationId);
    assertEquals(successor,successor(readCursor,stableGeneration,unstableGeneration));
    assertEquals(1,keyCount());
  }
  @Test public void shouldCreateNewVersionWhenInsertInStableLeaf() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    long targetLastId=id.lastId() + 3;
    long i=0;
    for (; id.lastId() < targetLastId; i++) {
      insert(key(i),value(i));
    }
    goTo(readCursor,rootId);
    assertEquals(2,keyCount());
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long middleChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,2,stableGeneration,unstableGeneration);
    assertSiblings(leftChild,middleChild,rightChild);
    generationManager.checkpoint();
    long middle=i / 2;
    KEY middleKey=key(middle);
    VALUE oldValue=value(middle);
    VALUE newValue=value(middle * 11);
    insert(middleKey,newValue);
    long expectedNewMiddleChild=targetLastId + 1;
    assertEquals(expectedNewMiddleChild,id.lastId());
    long newMiddleChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertEquals(expectedNewMiddleChild,newMiddleChild);
    goTo(readCursor,middleChild);
    assertEquals(newMiddleChild,successor(readCursor,stableGeneration,unstableGeneration));
    assertKeyAssociatedWithValue(middleKey,oldValue);
    goTo(readCursor,newMiddleChild);
    assertKeyAssociatedWithValue(middleKey,newValue);
    assertSiblings(leftChild,newMiddleChild,rightChild);
  }
  @Test public void shouldCreateNewVersionWhenRemoveInStableLeaf() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    long targetLastId=id.lastId() + 3;
    long i=0;
    for (; id.lastId() < targetLastId; i+=2) {
      insert(key(i),value(i));
    }
    goTo(readCursor,rootId);
    assertEquals(2,keyCount());
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long middleChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    long rightChild=childAt(readCursor,2,stableGeneration,unstableGeneration);
    goTo(readCursor,middleChild);
    KEY firstKeyInMiddleChild=keyAt(0,LEAF);
    VALUE firstValueInMiddleChild=valueAt(0);
    long seed=getSeed(firstKeyInMiddleChild);
    insert(key(seed + 1),value(seed + 1));
    insert(key(seed + 3),value(seed + 3));
    goTo(readCursor,rootId);
    assertSiblings(leftChild,middleChild,rightChild);
    generationManager.checkpoint();
    assertNotNull(remove(firstKeyInMiddleChild,dontCare));
    long expectedNewMiddleChild=targetLastId + 1;
    assertEquals(expectedNewMiddleChild,id.lastId());
    long newMiddleChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertEquals(expectedNewMiddleChild,newMiddleChild);
    goTo(readCursor,middleChild);
    assertEquals(newMiddleChild,successor(readCursor,stableGeneration,unstableGeneration));
    assertKeyAssociatedWithValue(firstKeyInMiddleChild,firstValueInMiddleChild);
    goTo(readCursor,newMiddleChild);
    assertKeyNotFound(firstKeyInMiddleChild,LEAF);
    assertSiblings(leftChild,newMiddleChild,rightChild);
  }
  @Test public void shouldCreateNewVersionWhenInsertInStableRootAsInternal() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    int keyCount=0;
    KEY key=key(keyCount);
    VALUE value=value(keyCount);
    while (node.leafOverflow(cursor,keyCount,key,value) == NO) {
      insert(key,value);
      keyCount++;
      key=key(keyCount);
      value=value(keyCount);
    }
    insert(key,value);
    keyCount++;
    key=key(keyCount);
    value=value(keyCount);
    goTo(readCursor,rootId);
    long rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    goTo(readCursor,rightChild);
    int rightChildKeyCount=TreeNode.keyCount(readCursor);
    while (node.leafOverflow(readCursor,rightChildKeyCount,key,value) == NO) {
      insert(key,value);
      keyCount++;
      rightChildKeyCount++;
      key=key(keyCount);
      value=value(keyCount);
    }
    long oldRootId=rootId;
    goTo(readCursor,rootId);
    assertEquals(1,keyCount());
    long leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    assertSiblings(leftChild,rightChild,TreeNode.NO_NODE_FLAG);
    generationManager.checkpoint();
    insert(key,value);
    assertEquals(1,numberOfRootSuccessors);
    goTo(readCursor,rootId);
    leftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    rightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
    long farRightChild=childAt(readCursor,2,stableGeneration,unstableGeneration);
    assertSiblings(leftChild,rightChild,farRightChild);
    goTo(readCursor,oldRootId);
    assertEquals(rootId,successor(readCursor,stableGeneration,unstableGeneration));
  }
  @Test public void shouldCreateNewVersionWhenInsertInStableInternal() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    long someHighMultiplier=1000;
    for (int i=0; numberOfRootSplits < 2; i++) {
      long seed=i * someHighMultiplier;
      insert(key(seed),value(seed));
    }
    long rootAfterInitialData=rootId;
    goTo(readCursor,rootId);
    assertEquals(1,keyCount());
    long leftInternal=childAt(readCursor,0,stableGeneration,unstableGeneration);
    long rightInternal=childAt(readCursor,1,stableGeneration,unstableGeneration);
    assertSiblings(leftInternal,rightInternal,TreeNode.NO_NODE_FLAG);
    goTo(readCursor,leftInternal);
    int leftInternalKeyCount=keyCount();
    assertTrue(TreeNode.isInternal(readCursor));
    long leftLeaf=childAt(readCursor,0,stableGeneration,unstableGeneration);
    goTo(readCursor,leftLeaf);
    KEY firstKeyInLeaf=keyAt(0,LEAF);
    long seedOfFirstKeyInLeaf=getSeed(firstKeyInLeaf);
    generationManager.checkpoint();
    long targetLastId=id.lastId() + 3;
    for (int i=0; id.lastId() < targetLastId; i++) {
      insert(key(seedOfFirstKeyInLeaf + i),value(seedOfFirstKeyInLeaf + i));
      assertFalse(structurePropagation.hasRightKeyInsert);
    }
    assertEquals(rootAfterInitialData,rootId);
    goTo(readCursor,rootId);
    long successorLeftInternal=id.lastId();
    assertEquals(successorLeftInternal,childAt(readCursor,0,stableGeneration,unstableGeneration));
    goTo(readCursor,successorLeftInternal);
    int successorLeftInternalKeyCount=keyCount();
    assertEquals(leftInternalKeyCount + 1,successorLeftInternalKeyCount);
    goTo(readCursor,leftInternal);
    assertEquals(successorLeftInternal,successor(readCursor,stableGeneration,unstableGeneration));
    assertSiblings(successorLeftInternal,rightInternal,TreeNode.NO_NODE_FLAG);
  }
  @Test public void shouldOverwriteInheritedSuccessorOnSuccessor() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    long originalNodeId=rootId;
    generationManager.checkpoint();
    insert(key(1L),value(10L));
    assertEquals(1,numberOfRootSuccessors);
    generationManager.recovery();
    goTo(cursor,originalNodeId);
    treeLogic.initialize(cursor);
    insert(key(1L),value(10L));
    assertEquals(2,numberOfRootSuccessors);
    goTo(readCursor,rootId);
    assertSuccessorPointerNotCrashOrBroken();
    goTo(readCursor,originalNodeId);
    assertSuccessorPointerNotCrashOrBroken();
  }
  @Test public void mustThrowIfReachingNodeWithValidSuccessor() throws Exception {
    assumeTrue("No checkpointing, no successor",isCheckpointing);
    initialize();
    long someHighMultiplier=1000;
    for (int i=1; numberOfRootSplits < 1; i++) {
      long seed=i * someHighMultiplier;
      insert(key(seed),value(seed));
    }
    generationManager.checkpoint();
    goTo(readCursor,rootId);
    long leftmostChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
    giveSuccessor(readCursor,leftmostChild);
    try {
      insert(key(0),value(0));
      fail("Expected insert to throw because child targeted for insertion has a valid new successor.");
    }
 catch (    TreeInconsistencyException e) {
      assertThat(e.getMessage(),containsString(PointerChecking.WRITER_TRAVERSE_OLD_STATE_MESSAGE));
    }
  }
  private void consistencyCheck() throws IOException {
    long currentPageId=readCursor.getCurrentPageId();
    goTo(readCursor,rootId);
    ConsistencyChecker<KEY> consistencyChecker=new ConsistencyChecker<>(node,layout,stableGeneration,unstableGeneration);
    consistencyChecker.check(readCursor,rootGeneration);
    goTo(readCursor,currentPageId);
  }
  private void remove(  KEY toRemove,  List<KEY> list,  Comparator<KEY> comparator){
    int i=indexOf(toRemove,list,comparator);
    list.remove(i);
  }
  private int indexOf(  KEY theKey,  List<KEY> keys,  Comparator<KEY> comparator){
    int i=0;
    for (    KEY key : keys) {
      if (comparator.compare(theKey,key) == 0) {
        return i;
      }
      i++;
    }
    return -1;
  }
  private void giveSuccessor(  PageCursor cursor,  long nodeId) throws IOException {
    goTo(cursor,nodeId);
    TreeNode.setSuccessor(cursor,42,stableGeneration,unstableGeneration);
  }
  private KEY rightmostInternalKeyInSubtree(  long parentNodeId,  int subtreePosition) throws IOException {
    long current=readCursor.getCurrentPageId();
    goToSubtree(parentNodeId,subtreePosition);
    boolean found=false;
    KEY rightmostKeyInSubtree=layout.newKey();
    while (TreeNode.isInternal(readCursor)) {
      int keyCount=TreeNode.keyCount(readCursor);
      if (keyCount <= 0) {
        break;
      }
      rightmostKeyInSubtree=keyAt(keyCount - 1,INTERNAL);
      found=true;
      long rightmostChild=childAt(readCursor,keyCount,stableGeneration,unstableGeneration);
      goTo(readCursor,rightmostChild);
    }
    if (!found) {
      throw new IllegalArgumentException("Subtree on position " + subtreePosition + " in node "+ parentNodeId+ " did not contain a rightmost internal key.");
    }
    goTo(readCursor,current);
    return rightmostKeyInSubtree;
  }
  private void goToSubtree(  long parentNodeId,  int subtreePosition) throws IOException {
    goTo(readCursor,parentNodeId);
    long subtree=childAt(readCursor,subtreePosition,stableGeneration,unstableGeneration);
    goTo(readCursor,subtree);
  }
  private long leftmostLeafInSubtree(  long parentNodeId,  int subtreePosition) throws IOException {
    long current=readCursor.getCurrentPageId();
    goToSubtree(parentNodeId,subtreePosition);
    long leftmostChild=current;
    while (TreeNode.isInternal(readCursor)) {
      leftmostChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
      goTo(readCursor,leftmostChild);
    }
    goTo(readCursor,current);
    return leftmostChild;
  }
  private long rightmostLeafInSubtree(  long parentNodeId,  int subtreePosition) throws IOException {
    long current=readCursor.getCurrentPageId();
    goToSubtree(parentNodeId,subtreePosition);
    long rightmostChild=current;
    while (TreeNode.isInternal(readCursor)) {
      int keyCount=TreeNode.keyCount(readCursor);
      rightmostChild=childAt(readCursor,keyCount,stableGeneration,unstableGeneration);
      goTo(readCursor,rightmostChild);
    }
    goTo(readCursor,current);
    return rightmostChild;
  }
  private void assertNodeContainsExpectedKeys(  List<KEY> expectedKeys,  TreeNode.Type type){
    List<KEY> actualKeys=allKeys(readCursor,type);
    for (    KEY actualKey : actualKeys) {
      GBPTreeTestUtil.contains(expectedKeys,actualKey,layout);
    }
    for (    KEY expectedKey : expectedKeys) {
      GBPTreeTestUtil.contains(actualKeys,expectedKey,layout);
    }
  }
  private List<KEY> allKeys(  PageCursor cursor,  TreeNode.Type type){
    List<KEY> keys=new ArrayList<>();
    return allKeys(cursor,keys,type);
  }
  private List<KEY> allKeys(  PageCursor cursor,  List<KEY> keys,  TreeNode.Type type){
    int keyCount=TreeNode.keyCount(cursor);
    for (int i=0; i < keyCount; i++) {
      KEY into=layout.newKey();
      node.keyAt(cursor,into,i,type);
      keys.add(into);
    }
    return keys;
  }
  private int keyCount(  long nodeId) throws IOException {
    long prevId=readCursor.getCurrentPageId();
    try {
      goTo(readCursor,nodeId);
      return TreeNode.keyCount(readCursor);
    }
  finally {
      goTo(readCursor,prevId);
    }
  }
  private int keyCount(){
    return TreeNode.keyCount(readCursor);
  }
  void initialize(){
    node.initializeLeaf(cursor,stableGeneration,unstableGeneration);
    updateRoot();
  }
  private void updateRoot(){
    rootId=cursor.getCurrentPageId();
    rootGeneration=unstableGeneration;
    treeLogic.initialize(cursor);
  }
  private void assertSuccessorPointerNotCrashOrBroken(){
    assertNoCrashOrBrokenPointerInGSPP(readCursor,stableGeneration,unstableGeneration,"Successor",TreeNode.BYTE_POS_SUCCESSOR);
  }
  private void assertKeyAssociatedWithValue(  KEY key,  VALUE expectedValue){
    KEY readKey=layout.newKey();
    VALUE readValue=layout.newValue();
    int search=KeySearch.search(readCursor,node,LEAF,key,readKey,TreeNode.keyCount(readCursor));
    assertTrue(KeySearch.isHit(search));
    int keyPos=KeySearch.positionOf(search);
    node.valueAt(readCursor,readValue,keyPos);
    assertEqualsValue(expectedValue,readValue);
  }
  private void assertKeyNotFound(  KEY key,  TreeNode.Type type){
    KEY readKey=layout.newKey();
    int search=KeySearch.search(readCursor,node,type,key,readKey,TreeNode.keyCount(readCursor));
    assertFalse(KeySearch.isHit(search));
  }
  private void assertSiblings(  long left,  long middle,  long right) throws IOException {
    long origin=readCursor.getCurrentPageId();
    goTo(readCursor,middle);
    assertEquals(right,rightSibling(readCursor,stableGeneration,unstableGeneration));
    assertEquals(left,leftSibling(readCursor,stableGeneration,unstableGeneration));
    if (left != TreeNode.NO_NODE_FLAG) {
      goTo(readCursor,left);
      assertEquals(middle,rightSibling(readCursor,stableGeneration,unstableGeneration));
    }
    if (right != TreeNode.NO_NODE_FLAG) {
      goTo(readCursor,right);
      assertEquals(middle,leftSibling(readCursor,stableGeneration,unstableGeneration));
    }
    goTo(readCursor,origin);
  }
  private void printTree() throws IOException {
    long currentPageId=cursor.getCurrentPageId();
    cursor.next(rootId);
    new TreePrinter<>(node,layout,stableGeneration,unstableGeneration).printTree(cursor,cursor,System.out,false,false,false,false);
    cursor.next(currentPageId);
  }
  KEY key(  long seed){
    return layout.key(seed);
  }
  VALUE value(  long seed){
    return layout.value(seed);
  }
  private long getSeed(  KEY key){
    return layout.keySeed(key);
  }
  private void newRootFromSplit(  StructurePropagation<KEY> split) throws IOException {
    assertTrue(split.hasRightKeyInsert);
    long rootId=id.acquireNewId(stableGeneration,unstableGeneration);
    goTo(cursor,rootId);
    node.initializeInternal(cursor,stableGeneration,unstableGeneration);
    node.setChildAt(cursor,split.midChild,0,stableGeneration,unstableGeneration);
    node.insertKeyAndRightChildAt(cursor,split.rightKey,split.rightChild,0,0,stableGeneration,unstableGeneration);
    TreeNode.setKeyCount(cursor,1);
    split.hasRightKeyInsert=false;
    updateRoot();
  }
  private void assertSiblingOrderAndPointers(  long... children) throws IOException {
    long currentPageId=readCursor.getCurrentPageId();
    RightmostInChain rightmost=new RightmostInChain();
    GenerationKeeper generationTarget=new GenerationKeeper();
    for (    long child : children) {
      goTo(readCursor,child);
      long leftSibling=TreeNode.leftSibling(readCursor,stableGeneration,unstableGeneration,generationTarget);
      long leftSiblingGeneration=generationTarget.generation;
      long rightSibling=TreeNode.rightSibling(readCursor,stableGeneration,unstableGeneration,generationTarget);
      long rightSiblingGeneration=generationTarget.generation;
      rightmost.assertNext(readCursor,TreeNode.generation(readCursor),pointer(leftSibling),leftSiblingGeneration,pointer(rightSibling),rightSiblingGeneration);
    }
    rightmost.assertLast();
    goTo(readCursor,currentPageId);
  }
  KEY keyAt(  long nodeId,  int pos,  TreeNode.Type type){
    KEY readKey=layout.newKey();
    long prevId=readCursor.getCurrentPageId();
    try {
      readCursor.next(nodeId);
      return node.keyAt(readCursor,readKey,pos,type);
    }
  finally {
      readCursor.next(prevId);
    }
  }
  private KEY keyAt(  int pos,  TreeNode.Type type){
    return node.keyAt(readCursor,layout.newKey(),pos,type);
  }
  private VALUE valueAt(  int pos){
    return node.valueAt(readCursor,layout.newValue(),pos);
  }
  void insert(  KEY key,  VALUE value) throws IOException {
    insert(key,value,overwrite());
  }
  private void insert(  KEY key,  VALUE value,  ValueMerger<KEY,VALUE> valueMerger) throws IOException {
    structurePropagation.hasRightKeyInsert=false;
    structurePropagation.hasMidChildUpdate=false;
    treeLogic.insert(cursor,structurePropagation,key,value,valueMerger,stableGeneration,unstableGeneration);
    handleAfterChange();
  }
  private void handleAfterChange() throws IOException {
    if (structurePropagation.hasRightKeyInsert) {
      newRootFromSplit(structurePropagation);
      numberOfRootSplits++;
    }
    if (structurePropagation.hasMidChildUpdate) {
      structurePropagation.hasMidChildUpdate=false;
      updateRoot();
      numberOfRootSuccessors++;
    }
  }
  private VALUE remove(  KEY key,  VALUE into) throws IOException {
    VALUE result=treeLogic.remove(cursor,structurePropagation,key,into,stableGeneration,unstableGeneration);
    handleAfterChange();
    return result;
  }
private interface GenerationManager {
    void checkpoint();
    void recovery();
    GenerationManager NO_OP_GENERATION=new GenerationManager(){
      @Override public void checkpoint(){
      }
      @Override public void recovery(){
      }
    }
;
    GenerationManager DEFAULT=new GenerationManager(){
      @Override public void checkpoint(){
        stableGeneration=unstableGeneration;
        unstableGeneration++;
      }
      @Override public void recovery(){
        unstableGeneration++;
      }
    }
;
  }
  private static void goTo(  PageCursor cursor,  long pageId) throws IOException {
    PageCursorUtil.goTo(cursor,"test",pointer(pageId));
  }
  private void goToSuccessor(  PageCursor cursor) throws IOException {
    long newestGeneration=newestGeneration(cursor,stableGeneration,unstableGeneration);
    goTo(cursor,newestGeneration);
  }
  private void goToSuccessor(  PageCursor cursor,  long targetNode) throws IOException {
    goTo(cursor,targetNode);
    goToSuccessor(cursor);
  }
  private long childAt(  PageCursor cursor,  int pos,  long stableGeneration,  long unstableGeneration){
    return pointer(node.childAt(cursor,pos,stableGeneration,unstableGeneration));
  }
  private long rightSibling(  PageCursor cursor,  long stableGeneration,  long unstableGeneration){
    return pointer(TreeNode.rightSibling(cursor,stableGeneration,unstableGeneration));
  }
  private long leftSibling(  PageCursor cursor,  long stableGeneration,  long unstableGeneration){
    return pointer(TreeNode.leftSibling(cursor,stableGeneration,unstableGeneration));
  }
  private long successor(  PageCursor cursor,  long stableGeneration,  long unstableGeneration){
    return pointer(TreeNode.successor(cursor,stableGeneration,unstableGeneration));
  }
  private long newestGeneration(  PageCursor cursor,  long stableGeneration,  long unstableGeneration) throws IOException {
    long current=cursor.getCurrentPageId();
    long successor=current;
    do {
      goTo(cursor,successor);
      successor=pointer(TreeNode.successor(cursor,stableGeneration,unstableGeneration));
    }
 while (successor != TreeNode.NO_NODE_FLAG);
    successor=cursor.getCurrentPageId();
    goTo(cursor,current);
    return successor;
  }
  private void assertNotEqualsKey(  KEY key1,  KEY key2){
    assertNotEquals(String.format("expected no not equal, key1=%s, key2=%s",key1.toString(),key2.toString()),0,layout.compare(key1,key2));
  }
  private void assertEqualsKey(  KEY expected,  KEY actual){
    assertEquals(String.format("expected equal, expected=%s, actual=%s",expected.toString(),actual.toString()),0,layout.compare(expected,actual));
  }
  private void assertEqualsValue(  VALUE expected,  VALUE actual){
    assertEquals(String.format("expected equal, expected=%s, actual=%s",expected.toString(),actual.toString()),0,layout.compareValue(expected,actual));
  }
}
