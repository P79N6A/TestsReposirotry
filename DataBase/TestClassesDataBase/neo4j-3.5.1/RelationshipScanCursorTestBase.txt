public abstract class RelationshipScanCursorTestBase<G extends KernelAPIReadTestSupport> extends KernelAPIReadTestBase<G> {
  private static List<Long> RELATIONSHIP_IDS;
  private static long none, loop, one, c, d;
  @Override public void createTestGraph(  GraphDatabaseService graphDb){
    Relationship deleted;
    try (Transaction tx=graphDb.beginTx()){
      Node a=graphDb.createNode(), b=graphDb.createNode(), c=graphDb.createNode(), d=graphDb.createNode(), e=graphDb.createNode(), f=graphDb.createNode();
      a.createRelationshipTo(b,withName("CIRCLE"));
      b.createRelationshipTo(c,withName("CIRCLE"));
      one=c.createRelationshipTo(d,withName("CIRCLE")).getId();
      d.createRelationshipTo(e,withName("CIRCLE"));
      e.createRelationshipTo(f,withName("CIRCLE"));
      f.createRelationshipTo(a,withName("CIRCLE"));
      a.createRelationshipTo(b,withName("TRIANGLE"));
      a.createRelationshipTo(c,withName("TRIANGLE"));
      b.createRelationshipTo(c,withName("TRIANGLE"));
      none=(deleted=c.createRelationshipTo(b,withName("TRIANGLE"))).getId();
      RelationshipScanCursorTestBase.c=c.getId();
      RelationshipScanCursorTestBase.d=d.getId();
      d.createRelationshipTo(e,withName("TRIANGLE"));
      e.createRelationshipTo(f,withName("TRIANGLE"));
      f.createRelationshipTo(d,withName("TRIANGLE"));
      loop=a.createRelationshipTo(a,withName("LOOP")).getId();
      tx.success();
    }
     RELATIONSHIP_IDS=new ArrayList<>();
    try (Transaction tx=graphDb.beginTx()){
      deleted.delete();
      for (      Relationship relationship : graphDb.getAllRelationships()) {
        RELATIONSHIP_IDS.add(relationship.getId());
      }
      tx.success();
    }
   }
  @Test public void shouldScanRelationships(){
    List<Long> ids=new ArrayList<>();
    try (RelationshipScanCursor relationships=cursors.allocateRelationshipScanCursor()){
      read.allRelationshipsScan(relationships);
      while (relationships.next()) {
        ids.add(relationships.relationshipReference());
      }
    }
     assertEquals(RELATIONSHIP_IDS,ids);
  }
  @Test public void shouldAccessRelationshipByReference(){
    try (RelationshipScanCursor relationships=cursors.allocateRelationshipScanCursor()){
      for (      long id : RELATIONSHIP_IDS) {
        read.singleRelationship(id,relationships);
        assertTrue("should access defined relationship",relationships.next());
        assertEquals("should access the correct relationship",id,relationships.relationshipReference());
        assertFalse("should only access a single relationship",relationships.next());
      }
    }
   }
  @Test public void shouldNotAccessDeletedRelationship(){
    try (RelationshipScanCursor relationships=cursors.allocateRelationshipScanCursor()){
      read.singleRelationship(none,relationships);
      assertFalse("should not access deleted relationship",relationships.next());
    }
   }
  @Test public void shouldNotAccessNegativeReferences(){
    try (RelationshipScanCursor relationship=cursors.allocateRelationshipScanCursor()){
      read.singleRelationship(-2L,relationship);
      assertFalse("should not access negative reference relationship",relationship.next());
    }
   }
  @Test public void shouldAccessRelationshipLabels(){
    Map<Integer,Integer> counts=new HashMap<>();
    try (RelationshipScanCursor relationships=cursors.allocateRelationshipScanCursor()){
      read.allRelationshipsScan(relationships);
      while (relationships.next()) {
        counts.compute(relationships.type(),(k,v) -> v == null ? 1 : v + 1);
      }
    }
     assertEquals(3,counts.size());
    int[] values=new int[3];
    int i=0;
    for (    int value : counts.values()) {
      values[i++]=value;
    }
    Arrays.sort(values);
    assertArrayEquals(new int[]{1,6,6},values);
  }
  @Test public void shouldAccessNodes(){
    try (RelationshipScanCursor relationships=cursors.allocateRelationshipScanCursor()){
      read.singleRelationship(one,relationships);
      assertTrue(relationships.next());
      assertEquals(c,relationships.sourceNodeReference());
      assertEquals(d,relationships.targetNodeReference());
      assertFalse(relationships.next());
      read.singleRelationship(loop,relationships);
      assertTrue(relationships.next());
      assertEquals(relationships.sourceNodeReference(),relationships.targetNodeReference());
      assertFalse(relationships.next());
    }
   }
}
