class NumberValuesTest {
  @Test void shouldHashNaN(){
    assertThat(hash(Double.NaN),equalTo(hash(Float.NaN)));
  }
  @Test void shouldHashInfinite(){
    assertThat(hash(Double.NEGATIVE_INFINITY),equalTo(hash(Float.NEGATIVE_INFINITY)));
    assertThat(hash(Double.POSITIVE_INFINITY),equalTo(hash(Float.POSITIVE_INFINITY)));
  }
  @Test void shouldHandleNaNCorrectly(){
    assertIncomparable(toAnyValue(Double.NaN),toAnyValue(Double.NaN));
    assertIncomparable(toAnyValue(1),toAnyValue(Double.NaN));
    assertIncomparable(toAnyValue(Double.NaN),toAnyValue(1));
  }
  @Test void shouldHashIntegralDoubleAsLong(){
    assertThat(hash(1337d),equalTo(hash(1337L)));
  }
  @Test void shouldGiveSameResultEvenWhenArraysContainDifferentTypes(){
    int[] ints=new int[32];
    long[] longs=new long[32];
    Random r=ThreadLocalRandom.current();
    for (int i=0; i < 32; i++) {
      int nextInt=r.nextInt();
      ints[i]=nextInt;
      longs[i]=nextInt;
    }
    assertThat(hash(ints),equalTo(hash(longs)));
  }
  @Test void shouldGiveSameHashForLongsAndInts(){
    Random r=ThreadLocalRandom.current();
    for (int i=0; i < 1_000_000; i++) {
      int anInt=r.nextInt();
      assertThat(anInt,equalTo(hash((long)anInt)));
    }
  }
  @Test void shouldGiveSameResultEvenWhenArraysContainDifferentTypes2(){
    byte[] bytes=new byte[32];
    short[] shorts=new short[32];
    Random r=ThreadLocalRandom.current();
    for (int i=0; i < 32; i++) {
      byte nextByte=((Number)(r.nextInt())).byteValue();
      bytes[i]=nextByte;
      shorts[i]=nextByte;
    }
    assertThat(hash(bytes),equalTo(hash(shorts)));
  }
}
