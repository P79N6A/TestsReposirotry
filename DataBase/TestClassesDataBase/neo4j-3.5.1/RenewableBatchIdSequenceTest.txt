public class RenewableBatchIdSequenceTest {
  public static final int BATCH_SIZE=5;
  private final IdSource idSource=new IdSource();
  private final List<Long> excessIds=new ArrayList<>();
  private final RenewableBatchIdSequence ids=new RenewableBatchIdSequence(idSource,BATCH_SIZE,excessIds::add);
  @Test public void shouldRequestIdBatchFromSourceOnFirstCall(){
    assertEquals(0,idSource.calls);
    assertEquals(0,ids.nextId());
    assertEquals(1,idSource.calls);
    for (int i=1; i < BATCH_SIZE; i++) {
      assertEquals(i,ids.nextId());
      assertEquals(1,idSource.calls);
    }
  }
  @Test public void shouldRequestIdBatchFromSourceOnDepletingCurrent(){
    assertEquals(0,idSource.calls);
    for (int i=0; i < BATCH_SIZE; i++) {
      assertEquals(i,ids.nextId());
    }
    assertEquals(1,idSource.calls);
    long firstIdOfNextBatch=ids.nextId();
    assertEquals(BATCH_SIZE,firstIdOfNextBatch);
    assertEquals(2,idSource.calls);
  }
  @Test public void shouldGiveBackExcessIdsOnClose(){
    for (int i=0; i < BATCH_SIZE / 2; i++) {
      ids.nextId();
    }
    ids.close();
    assertEquals(BATCH_SIZE - BATCH_SIZE / 2,excessIds.size());
    for (long i=BATCH_SIZE / 2; i < BATCH_SIZE; i++) {
      assertTrue(excessIds.contains(i));
    }
  }
  @Test public void shouldHandleCloseWithNoCurrentBatch(){
    ids.close();
    assertTrue(excessIds.isEmpty());
  }
  @Test public void shouldOnlyCloseOnce(){
    for (int i=0; i < BATCH_SIZE / 2; i++) {
      ids.nextId();
    }
    ids.close();
    for (long i=BATCH_SIZE / 2; i < BATCH_SIZE; i++) {
      assertTrue(excessIds.remove(i));
    }
    ids.close();
    assertTrue(excessIds.isEmpty());
  }
  @Test public void shouldContinueThroughEmptyIdBatch(){
    IdSequence idSource=mock(IdSequence.class);
    Iterator<IdRange> ranges=asList(new IdRange(EMPTY_LONG_ARRAY,0,BATCH_SIZE),new IdRange(EMPTY_LONG_ARRAY,BATCH_SIZE,0),new IdRange(EMPTY_LONG_ARRAY,BATCH_SIZE,BATCH_SIZE)).iterator();
    when(idSource.nextIdBatch(anyInt())).thenAnswer(invocation -> ranges.next());
    RenewableBatchIdSequence ids=new RenewableBatchIdSequence(idSource,BATCH_SIZE,excessIds::add);
    for (long expectedId=0; expectedId < BATCH_SIZE * 2; expectedId++) {
      assertEquals(expectedId,ids.nextId());
    }
  }
private static class IdSource implements IdSequence {
    int calls;
    long nextId;
    @Override public IdRange nextIdBatch(    int batchSize){
      calls++;
      try {
        return new IdRange(EMPTY_LONG_ARRAY,nextId,batchSize);
      }
  finally {
        nextId+=batchSize;
      }
    }
    @Override public long nextId(){
      throw new UnsupportedOperationException("Should not be used");
    }
  }
}
