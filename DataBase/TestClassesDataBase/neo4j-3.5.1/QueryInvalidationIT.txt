public class QueryInvalidationIT {
  private static final int USERS=10;
  private static final int CONNECTIONS=100;
  @Rule public final DatabaseRule db=new ImpermanentDatabaseRule().withSetting(GraphDatabaseSettings.query_statistics_divergence_threshold,"0.5").withSetting(GraphDatabaseSettings.cypher_min_replan_interval,"1s");
  @Test public void shouldRePlanAfterDataChangesFromAnEmptyDatabase() throws Exception {
    TestMonitor monitor=new TestMonitor();
    db.resolveDependency(Monitors.class).addMonitorListener(monitor);
    createIndex();
    executeDistantFriendsCountQuery(USERS);
    long replanTime=System.currentTimeMillis() + 1_800;
    createData(0,USERS,CONNECTIONS);
    while (System.currentTimeMillis() < replanTime) {
      Thread.sleep(100);
    }
    monitor.reset();
    executeDistantFriendsCountQuery(USERS);
    assertEquals("Query should have been replanned.",1,monitor.discards.get());
    assertThat("Replan should have occurred after TTL",monitor.waitTime.get(),greaterThanOrEqualTo(1L));
  }
  @Test public void shouldRePlanAfterDataChangesFromAPopulatedDatabase() throws Exception {
    Config config=db.getDependencyResolver().resolveDependency(Config.class);
    double divergenceThreshold=config.get(GraphDatabaseSettings.query_statistics_divergence_threshold);
    long replanInterval=config.get(GraphDatabaseSettings.cypher_min_replan_interval).toMillis();
    TestMonitor monitor=new TestMonitor();
    db.resolveDependency(Monitors.class).addMonitorListener(monitor);
    createIndex();
    createData(0,USERS,CONNECTIONS);
    executeDistantFriendsCountQuery(USERS);
    long replanTime=System.currentTimeMillis() + replanInterval;
    assertTrue("Test does not work with edge setting for query_statistics_divergence_threshold: " + divergenceThreshold,divergenceThreshold > 0.0 && divergenceThreshold < 1.0);
    int usersToCreate=((int)(Math.ceil(((double)USERS) / (1.0 - divergenceThreshold)))) - USERS + 1;
    createData(USERS,usersToCreate,CONNECTIONS);
    while (System.currentTimeMillis() <= replanTime) {
      Thread.sleep(100);
    }
    monitor.reset();
    executeDistantFriendsCountQuery(USERS);
    assertEquals("Query should have been replanned.",1,monitor.discards.get());
    assertThat("Replan should have occurred after TTL",monitor.waitTime.get(),greaterThanOrEqualTo(replanInterval / 1000));
  }
  private void createIndex(){
    try (Transaction tx=db.beginTx()){
      db.schema().indexFor(Label.label("User")).on("userId").create();
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().awaitIndexesOnline(10,SECONDS);
      tx.success();
    }
   }
  private void createData(  long startingUserId,  int numUsers,  int numConnections){
    for (long userId=startingUserId; userId < numUsers + startingUserId; userId++) {
      db.execute("CREATE (newUser:User {userId: {userId}})",singletonMap("userId",userId));
    }
    Map<String,Object> params=new HashMap<>();
    for (int i=0; i < numConnections; i++) {
      long user1=startingUserId + randomInt(numUsers);
      long user2;
      do {
        user2=startingUserId + randomInt(numUsers);
      }
 while (user1 == user2);
      params.put("user1",user1);
      params.put("user2",user2);
      db.execute("MATCH (user1:User { userId: {user1} }), (user2:User { userId: {user2} }) " + "MERGE (user1) -[:FRIEND]- (user2)",params);
    }
  }
  private void executeDistantFriendsCountQuery(  int userId){
    Map<String,Object> params=singletonMap("userId",(long)randomInt(userId));
    try (Result result=db.execute("MATCH (user:User { userId: {userId} } ) -[:FRIEND]- () -[:FRIEND]- (distantFriend) " + "RETURN COUNT(distinct distantFriend)",params)){
      while (result.hasNext()) {
        result.next();
      }
    }
   }
  private static int randomInt(  int max){
    return ThreadLocalRandom.current().nextInt(max);
  }
private static class TestMonitor implements CypherCacheHitMonitor<Pair<String,scala.collection.immutable.Map<String,Class<?>>>> {
    private final AtomicInteger hits=new AtomicInteger();
    private final AtomicInteger misses=new AtomicInteger();
    private final AtomicInteger discards=new AtomicInteger();
    private final AtomicInteger recompilations=new AtomicInteger();
    private final AtomicLong waitTime=new AtomicLong();
    @Override public void cacheHit(    Pair<String,scala.collection.immutable.Map<String,Class<?>>> key){
      hits.incrementAndGet();
    }
    @Override public void cacheMiss(    Pair<String,scala.collection.immutable.Map<String,Class<?>>> key){
      misses.incrementAndGet();
    }
    @Override public void cacheDiscard(    Pair<String,scala.collection.immutable.Map<String,Class<?>>> key,    String ignored,    int secondsSinceReplan){
      discards.incrementAndGet();
      waitTime.addAndGet(secondsSinceReplan);
    }
    @Override public void cacheRecompile(    Pair<String,scala.collection.immutable.Map<String,Class<?>>> key){
      recompilations.incrementAndGet();
    }
    @Override public String toString(){
      return "TestMonitor{hits=" + hits + ", misses="+ misses+ ", discards="+ discards+ ", waitTime="+ waitTime+ ", recompilations="+ recompilations+ "}";
    }
    public void reset(){
      hits.set(0);
      recompilations.set(0);
      misses.set(0);
      discards.set(0);
      waitTime.set(0);
    }
  }
}
