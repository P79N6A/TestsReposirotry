class NodeInUseWithCorrectLabelsCheckTest {
  @Test void shouldReportNodeNotInUse(){
    int nodeId=42;
    long labelId=7;
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    NodeRecord node=notInUse(new NodeRecord(nodeId,false,0,0));
    checker(new long[]{labelId},true).checkReference(null,node,engineFor(report),null);
    verify(report).nodeNotInUse(node);
  }
  @Test void shouldReportNodeWithoutExpectedLabelWhenLabelsAreInlineBothDirections(){
    int nodeId=42;
    long[] storeLabelIds=new long[]{7,9};
    long[] indexLabelIds=new long[]{9,10};
    NodeRecord node=inUse(withInlineLabels(new NodeRecord(nodeId,false,0,0),storeLabelIds));
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    checker(indexLabelIds,true).checkReference(null,node,engineFor(report),null);
    verify(report).nodeDoesNotHaveExpectedLabel(node,10);
  }
  @Test void shouldReportNodeWithoutExpectedLabelWhenLabelsAreInlineIndexToStore(){
    int nodeId=42;
    long[] storeLabelIds=new long[]{7,9};
    long[] indexLabelIds=new long[]{9,10};
    NodeRecord node=inUse(withInlineLabels(new NodeRecord(nodeId,false,0,0),storeLabelIds));
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    checker(indexLabelIds,false).checkReference(null,node,engineFor(report),null);
    verify(report).nodeDoesNotHaveExpectedLabel(node,10);
  }
  @Test void shouldReportNodeWithoutExpectedLabelWhenLabelsAreDynamicBothDirections(){
    int nodeId=42;
    long[] indexLabelIds={1,2,3,4,5,6,7,8,9,10};
    long[] storeLabelIds={1,2,3,4,5,6,8,9,10,11};
    RecordAccessStub recordAccess=new RecordAccessStub();
    NodeRecord node=inUse(withDynamicLabels(recordAccess,new NodeRecord(nodeId,false,0,0),storeLabelIds));
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    CheckerEngine<LabelScanDocument,ConsistencyReport.LabelScanConsistencyReport> engine=recordAccess.engine(null,report);
    checker(indexLabelIds,true).checkReference(null,node,engine,recordAccess);
    recordAccess.checkDeferred();
    verify(report).nodeDoesNotHaveExpectedLabel(node,7);
    verify(report).nodeLabelNotInIndex(node,11);
  }
  @Test void shouldReportNodeWithoutExpectedLabelWhenLabelsAreDynamicIndexToStore(){
    int nodeId=42;
    long[] indexLabelIds={3,7,9,10};
    long[] storeLabelIds={1,2,3,4,5,6,8,9,10};
    long missingLabelId=7;
    RecordAccessStub recordAccess=new RecordAccessStub();
    NodeRecord node=inUse(withDynamicLabels(recordAccess,new NodeRecord(nodeId,false,0,0),storeLabelIds));
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    CheckerEngine<LabelScanDocument,ConsistencyReport.LabelScanConsistencyReport> engine=recordAccess.engine(null,report);
    checker(indexLabelIds,true).checkReference(null,node,engine,recordAccess);
    recordAccess.checkDeferred();
    verify(report).nodeDoesNotHaveExpectedLabel(node,missingLabelId);
  }
  @Test void reportNodeWithoutLabelsWhenLabelsAreInlined(){
    int nodeId=42;
    long[] indexLabelIds={3};
    long[] storeLabelIds={};
    long missingLabelId=3;
    RecordAccessStub recordAccess=new RecordAccessStub();
    NodeRecord node=inUse(withInlineLabels(new NodeRecord(nodeId,false,0,0),storeLabelIds));
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    CheckerEngine<LabelScanDocument,ConsistencyReport.LabelScanConsistencyReport> engine=recordAccess.engine(null,report);
    checker(indexLabelIds,true).checkReference(null,node,engine,recordAccess);
    recordAccess.checkDeferred();
    verify(report).nodeDoesNotHaveExpectedLabel(node,missingLabelId);
  }
  @Test void reportNodeWithoutLabelsWhenLabelsAreDynamic(){
    int nodeId=42;
    long[] indexLabelIds={3,7,9,10};
    long[] storeLabelIds={};
    long[] missingLabelIds={3,7,9,10};
    RecordAccessStub recordAccess=new RecordAccessStub();
    NodeRecord node=inUse(withDynamicLabels(recordAccess,new NodeRecord(nodeId,false,0,0),storeLabelIds));
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    CheckerEngine<LabelScanDocument,ConsistencyReport.LabelScanConsistencyReport> engine=recordAccess.engine(null,report);
    checker(indexLabelIds,true).checkReference(null,node,engine,recordAccess);
    recordAccess.checkDeferred();
    for (    long missingLabelId : missingLabelIds) {
      verify(report).nodeDoesNotHaveExpectedLabel(node,missingLabelId);
    }
  }
  @Test void shouldRemainSilentWhenEverythingIsInOrder(){
    int nodeId=42;
    int labelId=7;
    NodeRecord node=withInlineLabels(inUse(new NodeRecord(nodeId,false,0,0)),labelId);
    ConsistencyReport.LabelScanConsistencyReport report=mock(ConsistencyReport.LabelScanConsistencyReport.class);
    checker(new long[]{labelId},true).checkReference(null,node,engineFor(report),null);
    verifyNoMoreInteractions(report);
  }
  private static NodeRecord withInlineLabels(  NodeRecord nodeRecord,  long... labelIds){
    new InlineNodeLabels(nodeRecord).put(labelIds,null,null);
    return nodeRecord;
  }
  private static NodeRecord withDynamicLabels(  RecordAccessStub recordAccess,  NodeRecord nodeRecord,  long... labelIds){
    List<DynamicRecord> preAllocatedRecords=new ArrayList<>();
    for (int i=0; i < 10; i++) {
      preAllocatedRecords.add(inUse(new DynamicRecord(i)));
    }
    Collection<DynamicRecord> dynamicRecords=new ArrayList<>();
    DynamicArrayStore.allocateFromNumbers(dynamicRecords,prependNodeId(nodeRecord.getId(),labelIds),new ReusableRecordsAllocator(4,preAllocatedRecords));
    for (    DynamicRecord dynamicRecord : dynamicRecords) {
      recordAccess.addNodeDynamicLabels(dynamicRecord);
    }
    nodeRecord.setLabelField(dynamicPointer(dynamicRecords),dynamicRecords);
    return nodeRecord;
  }
  private static Engine engineFor(  ConsistencyReport.LabelScanConsistencyReport report){
    Engine engine=mock(Engine.class);
    when(engine.report()).thenReturn(report);
    return engine;
  }
  private static NodeInUseWithCorrectLabelsCheck<LabelScanDocument,ConsistencyReport.LabelScanConsistencyReport> checker(  long[] expectedLabels,  boolean checkStoreToIndex){
    return new NodeInUseWithCorrectLabelsCheck<>(expectedLabels,COMPLETE_ALL_TOKENS,checkStoreToIndex);
  }
interface Engine extends CheckerEngine<LabelScanDocument,ConsistencyReport.LabelScanConsistencyReport> {
  }
}
