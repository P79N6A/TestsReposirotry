public class NativeLabelScanReaderIT {
  @Rule public final RandomRule random=new RandomRule();
  @Rule public final PageCacheAndDependenciesRule storage=new PageCacheAndDependenciesRule();
  @Rule public final LifeRule life=new LifeRule(true);
  @Test public void shouldStartFromGivenIdDense() throws IOException {
    shouldStartFromGivenId(10);
  }
  @Test public void shouldStartFromGivenIdSparse() throws IOException {
    shouldStartFromGivenId(100);
  }
  @Test public void shouldStartFromGivenIdSuperSparse() throws IOException {
    shouldStartFromGivenId(1000);
  }
  private void shouldStartFromGivenId(  int sparsity) throws IOException {
    NativeLabelScanStore store=life.add(new NativeLabelScanStore(storage.pageCache(),DatabaseLayout.of(storage.directory().directory()),storage.fileSystem(),EMPTY,false,new Monitors(),immediate()));
    int labelId=1;
    int highNodeId=100_000;
    BitSet expected=new BitSet(highNodeId);
    try (LabelScanWriter writer=store.newWriter()){
      int updates=highNodeId / sparsity;
      for (int i=0; i < updates; i++) {
        int nodeId=random.nextInt(highNodeId);
        writer.write(labelChanges(nodeId,EMPTY_LONG_ARRAY,new long[]{labelId}));
        expected.set(nodeId);
      }
    }
     long fromId=random.nextInt(highNodeId);
    int nextExpectedId=expected.nextSetBit(toIntExact(fromId + 1));
    try (LabelScanReader reader=store.newReader();PrimitiveLongResourceIterator ids=reader.nodesWithAnyOfLabels(fromId,new int[]{labelId})){
      while (nextExpectedId != -1) {
        assertTrue(ids.hasNext());
        long nextId=ids.next();
        assertEquals(nextExpectedId,toIntExact(nextId));
        nextExpectedId=expected.nextSetBit(nextExpectedId + 1);
      }
      assertFalse(ids.hasNext());
    }
   }
}
