@RunWith(Parameterized.class) public class NativeIndexAccessorTest<KEY extends NativeIndexKey<KEY>,VALUE extends NativeIndexValue> extends NativeIndexAccessorTests<KEY,VALUE> {
  @Parameterized.Parameters(name="{index}: {0}") public static Collection<Object[]> data(){
    return Arrays.asList(new Object[][]{{"Number",numberAccessorFactory(),RandomValues.typesOfGroup(ValueGroup.NUMBER),(IndexLayoutFactory)NumberLayoutNonUnique::new,NumberIndexProvider.CAPABILITY},{"String",stringAccessorFactory(),RandomValues.typesOfGroup(ValueGroup.TEXT),(IndexLayoutFactory)StringLayout::new,StringIndexProvider.CAPABILITY},{"Date",temporalAccessorFactory(ValueGroup.DATE),RandomValues.typesOfGroup(ValueGroup.DATE),(IndexLayoutFactory)DateLayout::new,TemporalIndexProvider.CAPABILITY},{"DateTime",temporalAccessorFactory(ValueGroup.ZONED_DATE_TIME),RandomValues.typesOfGroup(ValueGroup.ZONED_DATE_TIME),(IndexLayoutFactory)ZonedDateTimeLayout::new,TemporalIndexProvider.CAPABILITY},{"Duration",temporalAccessorFactory(ValueGroup.DURATION),RandomValues.typesOfGroup(ValueGroup.DURATION),(IndexLayoutFactory)DurationLayout::new,TemporalIndexProvider.CAPABILITY},{"LocalDateTime",temporalAccessorFactory(ValueGroup.LOCAL_DATE_TIME),RandomValues.typesOfGroup(ValueGroup.LOCAL_DATE_TIME),(IndexLayoutFactory)LocalDateTimeLayout::new,TemporalIndexProvider.CAPABILITY},{"LocalTime",temporalAccessorFactory(ValueGroup.LOCAL_TIME),RandomValues.typesOfGroup(ValueGroup.LOCAL_TIME),(IndexLayoutFactory)LocalTimeLayout::new,TemporalIndexProvider.CAPABILITY},{"LocalDateTime",temporalAccessorFactory(ValueGroup.LOCAL_DATE_TIME),RandomValues.typesOfGroup(ValueGroup.LOCAL_DATE_TIME),(IndexLayoutFactory)LocalDateTimeLayout::new,TemporalIndexProvider.CAPABILITY},{"Time",temporalAccessorFactory(ValueGroup.ZONED_TIME),RandomValues.typesOfGroup(ValueGroup.ZONED_TIME),(IndexLayoutFactory)ZonedTimeLayout::new,TemporalIndexProvider.CAPABILITY},{"Generic",genericAccessorFactory(),ValueType.values(),(IndexLayoutFactory)() -> new GenericLayout(1,spaceFillingCurveSettings),GenericNativeIndexProvider.CAPABILITY}});
  }
  private static final IndexSpecificSpaceFillingCurveSettingsCache spaceFillingCurveSettings=new IndexSpecificSpaceFillingCurveSettingsCache(new ConfiguredSpaceFillingCurveSettingsCache(Config.defaults()),Collections.emptyMap());
  private static final StandardConfiguration configuration=new StandardConfiguration();
  private final AccessorFactory<KEY,VALUE> accessorFactory;
  private final ValueType[] supportedTypes;
  private final IndexLayoutFactory<KEY,VALUE> indexLayoutFactory;
  private final IndexCapability indexCapability;
  @SuppressWarnings("unused") public NativeIndexAccessorTest(  String name,  AccessorFactory<KEY,VALUE> accessorFactory,  ValueType[] supportedTypes,  IndexLayoutFactory<KEY,VALUE> indexLayoutFactory,  IndexCapability indexCapability){
    this.accessorFactory=accessorFactory;
    this.supportedTypes=supportedTypes;
    this.indexLayoutFactory=indexLayoutFactory;
    this.indexCapability=indexCapability;
  }
  @Override NativeIndexAccessor<KEY,VALUE> makeAccessor() throws IOException {
    return accessorFactory.create(pageCache,fs,getIndexFile(),layout,RecoveryCleanupWorkCollector.immediate(),monitor,indexDescriptor,indexDirectoryStructure);
  }
  @Override IndexCapability indexCapability(){
    return indexCapability;
  }
  @Override ValueCreatorUtil<KEY,VALUE> createValueCreatorUtil(){
    return new ValueCreatorUtil<>(forLabel(42,666).withId(0),supportedTypes,FRACTION_DUPLICATE_NON_UNIQUE);
  }
  @Override IndexLayout<KEY,VALUE> createLayout(){
    return indexLayoutFactory.create();
  }
  private static AccessorFactory<NumberIndexKey,NativeIndexValue> numberAccessorFactory(){
    return (pageCache,fs,storeFile,layout,recoveryCleanupWorkCollector,monitor,descriptor,directory) -> new NumberIndexAccessor(pageCache,fs,storeFile,layout,recoveryCleanupWorkCollector,monitor,descriptor);
  }
  private static AccessorFactory<StringIndexKey,NativeIndexValue> stringAccessorFactory(){
    return (pageCache,fs,storeFile,layout,recoveryCleanupWorkCollector,monitor,descriptor,directory) -> new StringIndexAccessor(pageCache,fs,storeFile,layout,recoveryCleanupWorkCollector,monitor,descriptor);
  }
  private static <TK extends NativeIndexSingleValueKey<TK>>AccessorFactory<TK,NativeIndexValue> temporalAccessorFactory(  ValueGroup temporalValueGroup){
    return (pageCache,fs,storeFile,layout,cleanup,monitor,descriptor,directory) -> {
      TemporalIndexFiles.FileLayout<TK> fileLayout=new TemporalIndexFiles.FileLayout<>(storeFile,layout,temporalValueGroup);
      return new TemporalIndexAccessor.PartAccessor<>(pageCache,fs,fileLayout,cleanup,monitor,descriptor);
    }
;
  }
  private static AccessorFactory<GenericKey,NativeIndexValue> genericAccessorFactory(){
    return (pageCache,fs,storeFile,layout,cleanup,monitor,descriptor,directory) -> new GenericNativeIndexAccessor(pageCache,fs,storeFile,layout,cleanup,monitor,descriptor,spaceFillingCurveSettings,directory,configuration);
  }
@FunctionalInterface private interface AccessorFactory<KEY extends NativeIndexKey<KEY>,VALUE extends NativeIndexValue> {
    NativeIndexAccessor<KEY,VALUE> create(    PageCache pageCache,    FileSystemAbstraction fs,    File storeFile,    IndexLayout<KEY,VALUE> layout,    RecoveryCleanupWorkCollector recoveryCleanupWorkCollector,    IndexProvider.Monitor monitor,    StoreIndexDescriptor descriptor,    IndexDirectoryStructure directory) throws IOException ;
  }
}
