public class HeapSizeSanityCheckerTest {
  private final LongSupplier freeMemorySupplier=mock(LongSupplier.class);
  private final LongSupplier actualHeapSizeSupplier=mock(LongSupplier.class);
  private final ImportLogic.Monitor monitor=mock(ImportLogic.Monitor.class);
  private final HeapSizeSanityChecker checker=new HeapSizeSanityChecker(monitor,freeMemorySupplier,actualHeapSizeSupplier);
  private final LongSupplier baseMemorySupplier=mock(LongSupplier.class);
  private final MemoryStatsVisitor.Visitable baseMemory=visitor -> visitor.offHeapUsage(baseMemorySupplier.getAsLong());
  private final LongSupplier memoryUser1Supplier=mock(LongSupplier.class);
  private final MemoryStatsVisitor.Visitable memoryUser1=visitor -> visitor.offHeapUsage(memoryUser1Supplier.getAsLong());
  private final LongSupplier memoryUser2Supplier=mock(LongSupplier.class);
  private final MemoryStatsVisitor.Visitable memoryUser2=visitor -> visitor.offHeapUsage(memoryUser2Supplier.getAsLong());
  @Test public void shouldReportInsufficientAvailableMemory(){
    when(freeMemorySupplier.getAsLong()).thenReturn(gibiBytes(2));
    when(actualHeapSizeSupplier.getAsLong()).thenReturn(gibiBytes(1));
    when(baseMemorySupplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser1Supplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser2Supplier.getAsLong()).thenReturn(gibiBytes(1));
    Input.Estimates estimates=knownEstimates(1_000_000_000,10_000_000_000L,2_000_000_000L,0,gibiBytes(50),gibiBytes(100),0);
    checker.sanityCheck(estimates,LATEST_RECORD_FORMATS,baseMemory,memoryUser1,memoryUser2);
    verify(monitor).insufficientAvailableMemory(anyLong(),anyLong(),anyLong());
    verifyNoMoreInteractions(monitor);
  }
  @Test public void shouldReportInsufficientHeapSize(){
    when(freeMemorySupplier.getAsLong()).thenReturn(gibiBytes(20));
    when(actualHeapSizeSupplier.getAsLong()).thenReturn(gibiBytes(1));
    when(baseMemorySupplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser1Supplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser2Supplier.getAsLong()).thenReturn(gibiBytes(1));
    Input.Estimates estimates=knownEstimates(1_000_000_000,10_000_000_000L,2_000_000_000L,0,gibiBytes(50),gibiBytes(100),0);
    checker.sanityCheck(estimates,LATEST_RECORD_FORMATS,baseMemory,memoryUser1,memoryUser2);
    verify(monitor).insufficientHeapSize(anyLong(),anyLong());
    verifyNoMoreInteractions(monitor);
  }
  @Test public void shouldReportAbundantHeapSize(){
    when(freeMemorySupplier.getAsLong()).thenReturn(gibiBytes(2));
    when(actualHeapSizeSupplier.getAsLong()).thenReturn(gibiBytes(20));
    when(baseMemorySupplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser1Supplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser2Supplier.getAsLong()).thenReturn(gibiBytes(1));
    Input.Estimates estimates=knownEstimates(1_000_000_000,10_000_000_000L,2_000_000_000L,0,gibiBytes(50),gibiBytes(100),0);
    checker.sanityCheck(estimates,LATEST_RECORD_FORMATS,baseMemory,memoryUser1,memoryUser2);
    verify(monitor).abundantHeapSize(anyLong(),anyLong());
    verifyNoMoreInteractions(monitor);
  }
  @Test public void shouldReportNothingOnGoodSetup(){
    when(freeMemorySupplier.getAsLong()).thenReturn(gibiBytes(10));
    when(baseMemorySupplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser1Supplier.getAsLong()).thenReturn(gibiBytes(1));
    when(memoryUser2Supplier.getAsLong()).thenReturn(gibiBytes(1));
    when(actualHeapSizeSupplier.getAsLong()).thenReturn(gibiBytes(2));
    Input.Estimates estimates=knownEstimates(1_000_000_000,10_000_000_000L,2_000_000_000L,0,gibiBytes(50),gibiBytes(100),0);
    checker.sanityCheck(estimates,LATEST_RECORD_FORMATS,baseMemory,memoryUser1,memoryUser2);
    verifyNoMoreInteractions(monitor);
  }
}
