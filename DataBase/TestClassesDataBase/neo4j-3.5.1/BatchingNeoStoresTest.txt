public class BatchingNeoStoresTest {
  @Rule public final PageCacheAndDependenciesRule storage=new PageCacheAndDependenciesRule();
  @Test public void shouldNotOpenStoreWithNodesOrRelationshipsInIt() throws Exception {
    someDataInTheDatabase();
    try (JobScheduler jobScheduler=new ThreadPoolJobScheduler()){
      RecordFormats recordFormats=RecordFormatSelector.selectForConfig(Config.defaults(),NullLogProvider.getInstance());
      try (BatchingNeoStores store=BatchingNeoStores.batchingNeoStores(storage.fileSystem(),storage.directory().databaseDir(),recordFormats,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults(),jobScheduler)){
        store.createNew();
        fail("Should fail on existing data");
      }
     }
 catch (    IllegalStateException e) {
      assertThat(e.getMessage(),containsString("already contains"));
    }
  }
  @Test public void shouldRespectDbConfig() throws Exception {
    int size=10;
    Config config=Config.defaults(stringMap(GraphDatabaseSettings.array_block_size.name(),String.valueOf(size),GraphDatabaseSettings.string_block_size.name(),String.valueOf(size)));
    RecordFormats recordFormats=LATEST_RECORD_FORMATS;
    int headerSize=recordFormats.dynamic().getRecordHeaderSize();
    try (JobScheduler jobScheduler=new ThreadPoolJobScheduler();BatchingNeoStores store=BatchingNeoStores.batchingNeoStores(storage.fileSystem(),storage.directory().absolutePath(),recordFormats,DEFAULT,NullLogService.getInstance(),EMPTY,config,jobScheduler)){
      store.createNew();
      assertEquals(size + headerSize,store.getPropertyStore().getArrayStore().getRecordSize());
      assertEquals(size + headerSize,store.getPropertyStore().getStringStore().getRecordSize());
    }
   }
  @Test public void shouldPruneAndOpenExistingDatabase() throws Exception {
    for (    StoreType typeToTest : relevantRecordStores()) {
      try (PageCache pageCache=storage.pageCache()){
        storage.directory().cleanup();
        try (BatchingNeoStores stores=BatchingNeoStores.batchingNeoStoresWithExternalPageCache(storage.fileSystem(),pageCache,PageCacheTracer.NULL,storage.directory().absolutePath(),LATEST_RECORD_FORMATS,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults())){
          stores.createNew();
          for (          StoreType type : relevantRecordStores()) {
            createRecordIn(stores.getNeoStores().getRecordStore(type));
          }
        }
         try (BatchingNeoStores stores=BatchingNeoStores.batchingNeoStoresWithExternalPageCache(storage.fileSystem(),pageCache,PageCacheTracer.NULL,storage.directory().absolutePath(),LATEST_RECORD_FORMATS,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults())){
          stores.pruneAndOpenExistingStore(type -> type == typeToTest,Predicates.alwaysFalse());
          for (          StoreType type : relevantRecordStores()) {
            RecordStore<AbstractBaseRecord> store=stores.getNeoStores().getRecordStore(type);
            if (type == typeToTest) {
              assertThat(store.toString(),(int)store.getHighId(),greaterThan(store.getNumberOfReservedLowIds()));
            }
 else {
              assertEquals(store.toString(),store.getNumberOfReservedLowIds(),store.getHighId());
            }
          }
        }
       }
     }
  }
  @Test public void shouldDecideToAllocateDoubleRelationshipRecordUnitsOnLargeAmountOfRelationshipsOnSupportedFormat() throws Exception {
    RecordFormats formats=new ForcedSecondaryUnitRecordFormats(LATEST_RECORD_FORMATS);
    try (PageCache pageCache=storage.pageCache();BatchingNeoStores stores=BatchingNeoStores.batchingNeoStoresWithExternalPageCache(storage.fileSystem(),pageCache,PageCacheTracer.NULL,storage.directory().absolutePath(),formats,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults())){
      stores.createNew();
      Estimates estimates=Inputs.knownEstimates(0,DOUBLE_RELATIONSHIP_RECORD_UNIT_THRESHOLD << 1,0,0,0,0,0);
      boolean doubleUnits=stores.determineDoubleRelationshipRecordUnits(estimates);
      assertTrue(doubleUnits);
    }
   }
  @Test public void shouldNotDecideToAllocateDoubleRelationshipRecordUnitsonLowAmountOfRelationshipsOnSupportedFormat() throws Exception {
    RecordFormats formats=new ForcedSecondaryUnitRecordFormats(LATEST_RECORD_FORMATS);
    try (BatchingNeoStores stores=BatchingNeoStores.batchingNeoStoresWithExternalPageCache(storage.fileSystem(),storage.pageCache(),PageCacheTracer.NULL,storage.directory().absolutePath(),formats,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults())){
      stores.createNew();
      Estimates estimates=Inputs.knownEstimates(0,DOUBLE_RELATIONSHIP_RECORD_UNIT_THRESHOLD >> 1,0,0,0,0,0);
      boolean doubleUnits=stores.determineDoubleRelationshipRecordUnits(estimates);
      assertFalse(doubleUnits);
    }
   }
  @Test public void shouldNotDecideToAllocateDoubleRelationshipRecordUnitsonLargeAmountOfRelationshipsOnUnsupportedFormat() throws Exception {
    RecordFormats formats=LATEST_RECORD_FORMATS;
    try (BatchingNeoStores stores=BatchingNeoStores.batchingNeoStoresWithExternalPageCache(storage.fileSystem(),storage.pageCache(),PageCacheTracer.NULL,storage.directory().absolutePath(),formats,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults())){
      stores.createNew();
      Estimates estimates=Inputs.knownEstimates(0,DOUBLE_RELATIONSHIP_RECORD_UNIT_THRESHOLD << 1,0,0,0,0,0);
      boolean doubleUnits=stores.determineDoubleRelationshipRecordUnits(estimates);
      assertFalse(doubleUnits);
    }
   }
  @Test public void shouldDeleteIdGeneratorsWhenOpeningExistingStore() throws IOException {
    long expectedHighId;
    try (BatchingNeoStores stores=BatchingNeoStores.batchingNeoStoresWithExternalPageCache(storage.fileSystem(),storage.pageCache(),PageCacheTracer.NULL,storage.directory().absolutePath(),LATEST_RECORD_FORMATS,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults())){
      stores.createNew();
      RelationshipStore relationshipStore=stores.getRelationshipStore();
      RelationshipRecord record=relationshipStore.newRecord();
      long no=NULL_REFERENCE.longValue();
      record.initialize(true,no,1,2,0,no,no,no,no,true,true);
      record.setId(relationshipStore.nextId());
      expectedHighId=relationshipStore.getHighId();
      relationshipStore.updateRecord(record);
      relationshipStore.setHighId(record.getId() + 999);
    }
     try (BatchingNeoStores stores=BatchingNeoStores.batchingNeoStoresWithExternalPageCache(storage.fileSystem(),storage.pageCache(),PageCacheTracer.NULL,storage.directory().absolutePath(),LATEST_RECORD_FORMATS,DEFAULT,NullLogService.getInstance(),EMPTY,Config.defaults())){
      stores.pruneAndOpenExistingStore(Predicates.alwaysTrue(),Predicates.alwaysTrue());
      assertEquals(expectedHighId,stores.getRelationshipStore().getHighId());
    }
   }
  private StoreType[] relevantRecordStores(){
    return Stream.of(StoreType.values()).filter(type -> type.isRecordStore() && type != StoreType.META_DATA).toArray(StoreType[]::new);
  }
  private <RECORD extends AbstractBaseRecord>void createRecordIn(  RecordStore<RECORD> store){
    RECORD record=store.newRecord();
    record.setId(store.nextId());
    record.setInUse(true);
    if (record instanceof PropertyRecord) {
      PropertyBlock block=new PropertyBlock();
      ((PropertyStore)store).encodeValue(block,0,Values.of(10));
      ((PropertyRecord)record).addPropertyBlock(block);
    }
    store.updateRecord(record);
  }
  private void someDataInTheDatabase(){
    GraphDatabaseService db=new TestGraphDatabaseFactory().setFileSystem(new UncloseableDelegatingFileSystemAbstraction(storage.fileSystem())).newImpermanentDatabase(storage.directory().databaseDir());
    try (Transaction tx=db.beginTx()){
      db.createNode().createRelationshipTo(db.createNode(),MyRelTypes.TEST);
      tx.success();
    }
  finally {
      db.shutdown();
    }
  }
}
