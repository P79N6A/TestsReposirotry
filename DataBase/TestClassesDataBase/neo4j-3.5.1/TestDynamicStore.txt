public class TestDynamicStore {
  private final EphemeralFileSystemRule fs=new EphemeralFileSystemRule();
  private final PageCacheRule pageCacheRule=new PageCacheRule();
  private final TestDirectory testDirectory=TestDirectory.testDirectory(fs);
  @Rule public final RuleChain chain=RuleChain.outerRule(fs).around(testDirectory).around(pageCacheRule);
  private StoreFactory storeFactory;
  private NeoStores neoStores;
  private Config config;
  @Before public void setUp(){
    config=config();
    storeFactory=new StoreFactory(testDirectory.databaseLayout(),config,new DefaultIdGeneratorFactory(fs.get()),pageCacheRule.getPageCache(fs.get()),fs.get(),NullLogProvider.getInstance(),EmptyVersionContextSupplier.EMPTY);
  }
  @After public void tearDown(){
    if (neoStores != null) {
      neoStores.close();
    }
  }
  private DynamicArrayStore createDynamicArrayStore(){
    neoStores=storeFactory.openAllNeoStores(true);
    return neoStores.getPropertyStore().getArrayStore();
  }
  private Config config(){
    return Config.defaults();
  }
  @Test public void testClose(){
    DynamicArrayStore store=createDynamicArrayStore();
    Collection<DynamicRecord> records=new ArrayList<>();
    store.allocateRecordsFromBytes(records,new byte[10]);
    long blockId=Iterables.first(records).getId();
    for (    DynamicRecord record : records) {
      store.updateRecord(record);
    }
    neoStores.close();
    neoStores=null;
    try {
      store.getArrayFor(store.getRecords(blockId,NORMAL));
      fail("Closed store should throw exception");
    }
 catch (    RuntimeException e) {
    }
    try {
      store.getRecords(0,NORMAL);
      fail("Closed store should throw exception");
    }
 catch (    RuntimeException e) {
    }
  }
  @Test public void testStoreGetCharsFromString(){
    final String STR="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    DynamicArrayStore store=createDynamicArrayStore();
    char[] chars=new char[STR.length()];
    STR.getChars(0,STR.length(),chars,0);
    Collection<DynamicRecord> records=new ArrayList<>();
    store.allocateRecords(records,chars);
    for (    DynamicRecord record : records) {
      store.updateRecord(record);
    }
  }
  @Test public void testRandomTest(){
    Random random=new Random(System.currentTimeMillis());
    DynamicArrayStore store=createDynamicArrayStore();
    ArrayList<Long> idsTaken=new ArrayList<>();
    Map<Long,byte[]> byteData=new HashMap<>();
    float deleteIndex=0.2f;
    float closeIndex=0.1f;
    int currentCount=0;
    int maxCount=128;
    Set<Long> set=new HashSet<>();
    while (currentCount < maxCount) {
      float rIndex=random.nextFloat();
      if (rIndex < deleteIndex && currentCount > 0) {
        long blockId=idsTaken.remove(random.nextInt(currentCount));
        store.getRecords(blockId,NORMAL);
        byte[] bytes=(byte[])store.getArrayFor(store.getRecords(blockId,NORMAL));
        validateData(bytes,byteData.remove(blockId));
        Collection<DynamicRecord> records=store.getRecords(blockId,NORMAL);
        for (        DynamicRecord record : records) {
          record.setInUse(false);
          store.updateRecord(record);
          set.remove(record.getId());
        }
        currentCount--;
      }
 else {
        byte[] bytes=createRandomBytes(random);
        Collection<DynamicRecord> records=new ArrayList<>();
        store.allocateRecords(records,bytes);
        for (        DynamicRecord record : records) {
          assert !set.contains(record.getId());
          store.updateRecord(record);
          set.add(record.getId());
        }
        long blockId=Iterables.first(records).getId();
        idsTaken.add(blockId);
        byteData.put(blockId,bytes);
        currentCount++;
      }
      if (rIndex > (1.0f - closeIndex) || rIndex < closeIndex) {
        neoStores.close();
        store=createDynamicArrayStore();
      }
    }
  }
  private byte[] createBytes(  int length){
    return new byte[length];
  }
  private byte[] createRandomBytes(  Random r){
    return new byte[r.nextInt(1024)];
  }
  private void validateData(  byte[] data1,  byte[] data2){
    assertEquals(data1.length,data2.length);
    for (int i=0; i < data1.length; i++) {
      assertEquals(data1[i],data2[i]);
    }
  }
  private long create(  DynamicArrayStore store,  Object arrayToStore){
    Collection<DynamicRecord> records=new ArrayList<>();
    store.allocateRecords(records,arrayToStore);
    for (    DynamicRecord record : records) {
      store.updateRecord(record);
    }
    return Iterables.first(records).getId();
  }
  @Test public void testAddDeleteSequenceEmptyNumberArray(){
    DynamicArrayStore store=createDynamicArrayStore();
    byte[] emptyToWrite=createBytes(0);
    long blockId=create(store,emptyToWrite);
    store.getRecords(blockId,NORMAL);
    byte[] bytes=(byte[])store.getArrayFor(store.getRecords(blockId,NORMAL));
    assertEquals(0,bytes.length);
    Collection<DynamicRecord> records=store.getRecords(blockId,NORMAL);
    for (    DynamicRecord record : records) {
      record.setInUse(false);
      store.updateRecord(record);
    }
  }
  @Test public void testAddDeleteSequenceEmptyStringArray(){
    DynamicArrayStore store=createDynamicArrayStore();
    long blockId=create(store,new String[0]);
    store.getRecords(blockId,NORMAL);
    String[] readBack=(String[])store.getArrayFor(store.getRecords(blockId,NORMAL));
    assertEquals(0,readBack.length);
    Collection<DynamicRecord> records=store.getRecords(blockId,NORMAL);
    for (    DynamicRecord record : records) {
      record.setInUse(false);
      store.updateRecord(record);
    }
  }
}
