public abstract class StatefullFieldExtension<T> implements TestInstancePostProcessor, AfterAllCallback {
  protected abstract String getFieldKey();
  protected abstract Class<T> getFieldType();
  protected abstract T createField(  ExtensionContext extensionContext);
  protected abstract Namespace getNameSpace();
  @Override public void afterAll(  ExtensionContext context){
    removeStoredValue(context);
  }
  @Override public void postProcessTestInstance(  Object testInstance,  ExtensionContext context) throws Exception {
    Class<?> clazz=testInstance.getClass();
    Object instance=createInstance(context);
    List<Field> declaredFields=getAllFields(clazz);
    for (    Field declaredField : declaredFields) {
      if (declaredField.isAnnotationPresent(Inject.class) && getFieldType().equals(declaredField.getType())) {
        declaredField.setAccessible(true);
        declaredField.set(testInstance,instance);
      }
    }
  }
  protected T getStoredValue(  ExtensionContext context){
    return getLocalStore(context).get(getFieldKey(),getFieldType());
  }
  void removeStoredValue(  ExtensionContext context){
    getLocalStore(context).remove(getFieldKey(),getFieldType());
  }
  static Store getStore(  ExtensionContext extensionContext,  Namespace namespace){
    return extensionContext.getRoot().getStore(namespace);
  }
  private Store getLocalStore(  ExtensionContext extensionContext){
    return getStore(extensionContext,getNameSpace());
  }
  private Object createInstance(  ExtensionContext extensionContext){
    Store store=getLocalStore(extensionContext);
    return store.getOrComputeIfAbsent(getFieldKey(),(Function<String,Object>)s -> createField(extensionContext));
  }
  private static List<Field> getAllFields(  Class<?> baseClazz){
    ArrayList<Field> fields=new ArrayList<>();
    Class<?> clazz=baseClazz;
    do {
      Collections.addAll(fields,clazz.getDeclaredFields());
      clazz=clazz.getSuperclass();
    }
 while (clazz != null);
    return fields;
  }
}
