public class ConstraintCreationIT {
  @Rule public EmbeddedDatabaseRule db=new EmbeddedDatabaseRule().startLazily();
  private static final Label LABEL=Label.label("label1");
  private static final long indexId=1;
  @Test public void shouldNotLeaveLuceneIndexFilesHangingAroundIfConstraintCreationFails(){
    db.withSetting(default_schema_provider,NATIVE20.providerName());
    attemptAndFailConstraintCreation();
    IndexProvider indexProvider=db.getDependencyResolver().resolveDependency(IndexProviderMap.class).getDefaultProvider();
    File indexDir=indexProvider.directoryStructure().directoryForIndex(indexId);
    assertFalse(new IndexFolderLayout(indexDir).getIndexFolder().exists());
  }
  @Test public void shouldNotLeaveNativeIndexFilesHangingAroundIfConstraintCreationFails(){
    attemptAndFailConstraintCreation();
    IndexProvider indexProvider=db.getDependencyResolver().resolveDependency(IndexProviderMap.class).getDefaultProvider();
    File indexDir=indexProvider.directoryStructure().directoryForIndex(indexId);
    assertEquals(0,indexDir.listFiles().length);
  }
  private void attemptAndFailConstraintCreation(){
    try (Transaction tx=db.beginTx()){
      for (int i=0; i < 2; i++) {
        Node node1=db.createNode(LABEL);
        node1.setProperty("prop",true);
      }
      tx.success();
    }
     try (Transaction tx=db.beginTx()){
      db.schema().constraintFor(LABEL).assertPropertyIsUnique("prop").create();
      fail("Should have failed with ConstraintViolationException");
      tx.success();
    }
 catch (    ConstraintViolationException ignored) {
    }
    try (Transaction ignore=db.beginTx()){
      assertEquals(0,Iterables.count(db.schema().getIndexes()));
    }
   }
}
