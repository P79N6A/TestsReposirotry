public class ConflictDetectingValueMergerTest {
  private final ConflictDetectingValueMerger<NumberIndexKey,NativeIndexValue> detector=new ConflictDetectingValueMerger<>(true);
  @Test public void shouldReportConflictOnSameValueAndDifferentEntityIds(){
    Value value=Values.of(123);
    long entityId1=10;
    long entityId2=20;
    NativeIndexValue merged=detector.merge(key(entityId1,value),key(entityId2,value),NativeIndexValue.INSTANCE,NativeIndexValue.INSTANCE);
    assertNull(merged);
    try {
      detector.checkConflict(array(value));
      fail("Should've detected conflict");
    }
 catch (    IndexEntryConflictException e) {
      assertEquals(entityId1,e.getExistingNodeId());
      assertEquals(entityId2,e.getAddedNodeId());
      assertEquals(value,e.getSinglePropertyValue());
    }
  }
  @Test public void shouldNotReportConflictOnSameValueSameEntityId() throws IndexEntryConflictException {
    Value value=Values.of(123);
    long entityId=10;
    NativeIndexValue merged=detector.merge(key(entityId,value),key(entityId,value),NativeIndexValue.INSTANCE,NativeIndexValue.INSTANCE);
    assertNull(merged);
    detector.checkConflict(array());
  }
  private static NumberIndexKey key(  long entityId,  Value value){
    NumberIndexKey key=new NumberIndexKey();
    key.initialize(entityId);
    key.initFromValue(0,value,NativeIndexKey.Inclusion.LOW);
    return key;
  }
}
