/** 
 * @version 
 */
public class RollbackDefaultErrorHandlerTest extends ContextTestSupport {
  @Test public void testOk() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    template.requestBody("direct:start","ok");
    assertMockEndpointsSatisfied();
  }
  @Test public void testRollback() throws Exception {
    try {
      template.requestBody("direct:start","bad");
      fail("Should have thrown a RollbackExchangeException");
    }
 catch (    RuntimeCamelException e) {
      assertTrue(e.getCause() instanceof RollbackExchangeException);
    }
  }
  @Test public void testRollbackWithExchange() throws Exception {
    Exchange out=template.request("direct:start",new Processor(){
      public void process(      Exchange exchange) throws Exception {
        exchange.getIn().setBody("bad");
      }
    }
);
    assertNotNull(out.getException());
    assertIsInstanceOf(RollbackExchangeException.class,out.getException());
    assertEquals("Should be marked as rollback",true,out.isRollbackOnly());
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("direct:start").choice().when(body().isNotEqualTo("ok")).process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            assertFalse("Rollback flag should have been cleared on redelivery",exchange.isRollbackOnly());
          }
        }
).to("mock:rollback").rollback("That do not work").otherwise().to("mock:result").end();
      }
    }
;
  }
}
