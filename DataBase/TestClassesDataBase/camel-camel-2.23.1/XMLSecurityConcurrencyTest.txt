/** 
 * @version 
 */
public class XMLSecurityConcurrencyTest extends CamelTestSupport {
  private static final boolean HAS_3DES;
static {
    boolean ok=false;
    try {
      XMLCipher.getInstance(XMLCipher.TRIPLEDES_KeyWrap);
      ok=true;
    }
 catch (    XMLEncryptionException e) {
    }
    HAS_3DES=ok;
  }
  @Test public void testNoConcurrentProducers() throws Exception {
    if (!HAS_3DES) {
      return;
    }
    doSendMessages(1,1);
  }
  @Test public void testConcurrentProducers() throws Exception {
    if (!HAS_3DES) {
      return;
    }
    doSendMessages(10,5);
  }
  private void doSendMessages(  int files,  int poolSize) throws Exception {
    getMockEndpoint("mock:result").expectedMessageCount(files);
    getMockEndpoint("mock:secure").expectedMessageCount(files);
    getMockEndpoint("mock:result").assertNoDuplicates(body());
    ExecutorService executor=Executors.newFixedThreadPool(poolSize);
    for (int i=0; i < files; i++) {
      final int index=i;
      executor.submit(new Callable<Object>(){
        public Object call() throws Exception {
          String body="<?xml version=\"1.0\" encoding=\"UTF-8\" ?><body>you can not read me " + index + "</body>";
          template.sendBody("direct:start",body);
          return null;
        }
      }
);
    }
    assertMockEndpointsSatisfied();
    String secure=getMockEndpoint("mock:secure").getReceivedExchanges().get(0).getIn().getBody(String.class);
    assertNotNull(secure);
    assertTrue("Should not be readable",secure.indexOf("read") == -1);
    executor.shutdownNow();
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        from("direct:start").marshal().secureXML().to("mock:secure").to("direct:marshalled");
        from("direct:marshalled").unmarshal().secureXML().convertBodyTo(String.class).to("mock:result");
      }
    }
;
  }
}
