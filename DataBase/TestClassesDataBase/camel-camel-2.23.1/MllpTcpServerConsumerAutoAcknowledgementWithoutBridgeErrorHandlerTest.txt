public class MllpTcpServerConsumerAutoAcknowledgementWithoutBridgeErrorHandlerTest extends TcpServerConsumerAcknowledgementTestSupport {
  @Override protected boolean isBridgeErrorHandler(){
    return false;
  }
  @Override protected boolean isAutoAck(){
    return true;
  }
  @Test public void testReceiveSingleMessage() throws Exception {
    result.expectedBodiesReceived(TEST_MESSAGE);
    complete.expectedBodiesReceived(TEST_MESSAGE);
    complete.expectedHeaderReceived(MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE,"AA");
    receiveSingleMessage();
    Exchange completeExchange=complete.getReceivedExchanges().get(0);
    assertNotNull(completeExchange.getIn().getHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT));
    assertNotNull(completeExchange.getIn().getHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING));
    String acknowledgement=completeExchange.getIn().getHeader(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING,String.class);
    assertThat(acknowledgement,startsWith("MSH|^~\\&|^org^sys||APP_A|FAC_A|"));
    assertThat(acknowledgement,endsWith("||ACK^A04^ADT_A04|||2.6\rMSA|AA|\r"));
  }
  public void testAcknowledgementDeliveryFailure() throws Exception {
    result.expectedBodiesReceived(TEST_MESSAGE);
    failure.expectedBodiesReceived(TEST_MESSAGE);
    failure.expectedHeaderReceived(MllpConstants.MLLP_ACKNOWLEDGEMENT_TYPE,"AA");
    failure.expectedHeaderReceived(MllpConstants.MLLP_ACKNOWLEDGEMENT,EXPECTED_ACKNOWLEDGEMENT);
    failure.expectedHeaderReceived(MllpConstants.MLLP_ACKNOWLEDGEMENT_STRING,EXPECTED_ACKNOWLEDGEMENT);
    acknowledgementDeliveryFailure();
    Exchange failureExchange=failure.getExchanges().get(0);
    Object failureException=failureExchange.getProperty(MllpConstants.MLLP_ACKNOWLEDGEMENT_EXCEPTION);
    assertNotNull("OnFailureOnly exchange should have a " + MllpConstants.MLLP_ACKNOWLEDGEMENT_EXCEPTION + " property",failureException);
    assertIsInstanceOf(Exception.class,failureException);
  }
  @Test public void testUnparsableMessage() throws Exception {
    final String testMessage="MSH" + TEST_MESSAGE;
    result.expectedBodiesReceived(testMessage);
    complete.expectedMessageCount(1);
    unparsableMessage(testMessage);
    assertNull("Should not have the exception in the exchange property",result.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT));
    assertNull("Should not have the exception in the exchange property",complete.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT));
  }
  @Test public void testMessageWithEmptySegment() throws Exception {
    final String testMessage=TEST_MESSAGE.replace("\rPID|","\r\rPID|");
    result.expectedBodiesReceived(testMessage);
    complete.expectedMessageCount(1);
    unparsableMessage(testMessage);
    assertNull("Should not have the exception in the exchange property",result.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT));
    assertNull("Should not have the exception in the exchange property",complete.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT));
  }
  @Test public void testMessageWithEmbeddedNewlines() throws Exception {
    final String testMessage=TEST_MESSAGE.replace("\rPID|","\r\n\rPID|\n");
    result.expectedBodiesReceived(testMessage);
    complete.expectedMessageCount(1);
    unparsableMessage(testMessage);
    assertNull("Should not have the exception in the exchange property",result.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT));
    assertNull("Should not have the exception in the exchange property",complete.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT));
  }
}
