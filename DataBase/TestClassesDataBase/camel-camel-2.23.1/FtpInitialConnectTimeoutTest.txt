public class FtpInitialConnectTimeoutTest extends CamelTestSupport {
  private static final int CONNECT_TIMEOUT=11223;
  /** 
 * Create the answer for the socket factory that causes a SocketTimeoutException to occur in connect.
 */
private static class SocketAnswer implements Answer<Socket> {
    @Override public Socket answer(    InvocationOnMock invocation) throws Throwable {
      final Socket socket=spy(new Socket());
      final AtomicBoolean timeout=new AtomicBoolean();
      try {
        doAnswer(new Answer<InputStream>(){
          @Override public InputStream answer(          InvocationOnMock invocation) throws Throwable {
            final InputStream stream=(InputStream)invocation.callRealMethod();
            InputStream inputStream=new InputStream(){
              @Override public int read() throws IOException {
                if (timeout.get()) {
                  throw new SocketTimeoutException();
                }
                return stream.read();
              }
            }
;
            return inputStream;
          }
        }
).when(socket).getInputStream();
      }
 catch (      IOException ignored) {
      }
      try {
        doAnswer(new Answer<Object>(){
          @Override public Object answer(          InvocationOnMock invocation) throws Throwable {
            if ((Integer)invocation.getArguments()[0] == CONNECT_TIMEOUT) {
              timeout.set(true);
            }
 else {
              timeout.set(false);
            }
            return invocation.callRealMethod();
          }
        }
).when(socket).setSoTimeout(anyInt());
      }
 catch (      SocketException e) {
        throw new RuntimeException(e);
      }
      return socket;
    }
  }
  private FakeFtpServer fakeFtpServer;
  @Override @Before public void setUp() throws Exception {
    fakeFtpServer=new FakeFtpServer();
    fakeFtpServer.setServerControlPort(0);
    fakeFtpServer.start();
    super.setUp();
  }
  @Override @After public void tearDown() throws Exception {
    super.tearDown();
    if (fakeFtpServer != null) {
      fakeFtpServer.stop();
    }
  }
  private FTPClient mockedClient() throws IOException {
    FTPClient client=new FTPClient();
    client.setSocketFactory(createSocketFactory());
    return client;
  }
  private SocketFactory createSocketFactory() throws IOException {
    SocketFactory socketFactory=mock(SocketFactory.class);
    when(socketFactory.createSocket()).thenAnswer(new SocketAnswer());
    return socketFactory;
  }
  @Override protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry registry=super.createRegistry();
    registry.bind("mocked",mockedClient());
    return registry;
  }
  @Test public void testReConnect() throws Exception {
    getMockEndpoint("mock:done").expectedMessageCount(0);
    getMockEndpoint("mock:dead").expectedMessageCount(1);
    sendBody("direct:start","test");
    assertMockEndpointsSatisfied();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        errorHandler(deadLetterChannel("mock:dead"));
        from("direct:start").to("ftp://localhost:" + fakeFtpServer.getServerControlPort() + "?ftpClient=#mocked"+ "&soTimeout=0&"+ "connectTimeout="+ CONNECT_TIMEOUT).to("mock:done");
      }
    }
;
  }
}
