/** 
 * Unit test for testing possibility to modify exchange before redelivering
 */
public class DeadLetterChannelOnRedeliveryTest extends ContextTestSupport {
  static int counter;
  @Test public void testOnExceptionAlterMessageBeforeRedelivery() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Hello World3");
    template.sendBody("direct:start","Hello World");
    assertMockEndpointsSatisfied();
  }
  @Test public void testOnExceptionAlterMessageWithHeadersBeforeRedelivery() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Hello World3");
    mock.expectedHeaderReceived("foo","123");
    template.sendBodyAndHeader("direct:start","Hello World","foo","123");
    assertMockEndpointsSatisfied();
  }
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    counter=0;
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(5).onRedelivery(new MyRedeliverProcessor()).redeliveryDelay(0L));
        from("direct:start").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            if (++counter <= 3) {
              throw new IllegalArgumentException("Forced by unit test");
            }
          }
        }
).to("mock:result");
      }
    }
;
  }
public class MyRedeliverProcessor implements Processor {
    public void process(    Exchange exchange) throws Exception {
      String body=exchange.getIn().getBody(String.class);
      int count=exchange.getIn().getHeader(Exchange.REDELIVERY_COUNTER,Integer.class);
      exchange.getIn().setBody(body + count);
      int max=exchange.getIn().getHeader(Exchange.REDELIVERY_MAX_COUNTER,Integer.class);
      assertEquals(5,max);
    }
  }
}
