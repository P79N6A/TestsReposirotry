/** 
 * @version 
 */
public class HttpAsyncCallbackTest extends HttpAsyncTestSupport {
  private static final CountDownLatch LATCH=new CountDownLatch(3);
  @Test public void testAsyncAndSyncAtSameTimeWithHttp() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceivedInAnyOrder("Hello Claus","Hello Hadrian","Hello Willem");
    MyCallback callback=new MyCallback();
    String url="http://localhost:" + getPort() + "/myservice";
    template.asyncCallbackRequestBody(url,"Claus",callback);
    template.asyncCallbackRequestBody(url,"Hadrian",callback);
    template.asyncCallbackRequestBody(url,"Willem",callback);
    assertMockEndpointsSatisfied();
    assertTrue("Should get 3 callbacks",LATCH.await(10,TimeUnit.SECONDS));
    assertTrue("Claus is missing",callback.getData().contains("Hello Claus"));
    assertTrue("Hadrian is missing",callback.getData().contains("Hello Hadrian"));
    assertTrue("Willem is missing",callback.getData().contains("Hello Willem"));
  }
  /** 
 * Our own callback that will gather all the responses. We extend the SynchronizationAdapter class as we then only need to override the onComplete method.
 */
private static class MyCallback extends SynchronizationAdapter {
    private final List<String> data=new Vector<>();
    @Override public void onComplete(    Exchange exchange){
      String body=exchange.getOut().getBody(String.class);
      data.add(body);
      LATCH.countDown();
    }
    public List<String> getData(){
      return data;
    }
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("jetty:http://0.0.0.0:" + getPort() + "/myservice").delay(300).transform(body().prepend("Hello ")).to("mock:result");
      }
    }
;
  }
}
