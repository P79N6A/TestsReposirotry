public class CustomLoadBalanceTest extends ContextTestSupport {
  protected MockEndpoint x;
  protected MockEndpoint y;
  protected MockEndpoint z;
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    x=getMockEndpoint("mock:x");
    y=getMockEndpoint("mock:y");
    z=getMockEndpoint("mock:z");
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        from("direct:start").loadBalance(new MyLoadBalancer()).to("mock:x","mock:y","mock:z");
      }
    }
;
  }
  @Test public void testCustomLoadBalancer() throws Exception {
    x.expectedBodiesReceived("x","x","x");
    y.expectedBodiesReceived("y","y");
    z.expectedBodiesReceived("foo","bar","baz");
    template.sendBody("direct:start","x");
    template.sendBody("direct:start","y");
    template.sendBody("direct:start","foo");
    template.sendBody("direct:start","bar");
    template.sendBody("direct:start","y");
    template.sendBody("direct:start","x");
    template.sendBody("direct:start","x");
    template.sendBody("direct:start","baz");
    assertMockEndpointsSatisfied();
  }
public static class MyLoadBalancer extends LoadBalancerSupport {
    public boolean process(    Exchange exchange,    AsyncCallback callback){
      String body=exchange.getIn().getBody(String.class);
      try {
        if ("x".equals(body)) {
          getProcessors().get(0).process(exchange);
        }
 else         if ("y".equals(body)) {
          getProcessors().get(1).process(exchange);
        }
 else {
          getProcessors().get(2).process(exchange);
        }
      }
 catch (      Throwable e) {
        exchange.setException(e);
      }
      callback.done(true);
      return true;
    }
  }
}
