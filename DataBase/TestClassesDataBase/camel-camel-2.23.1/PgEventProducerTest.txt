@RunWith(MockitoJUnitRunner.class) public class PgEventProducerTest {
  private PgEventEndpoint endpoint=mock(PgEventEndpoint.class);
  private PGDataSource dataSource=mock(PGDataSource.class);
  private PGConnection connection=mock(PGConnection.class);
  private PreparedStatement statement=mock(PreparedStatement.class);
  private Exchange exchange=mock(Exchange.class);
  private Message message=mock(Message.class);
  @Test public void testPgEventProducerStart() throws Exception {
    when(endpoint.getDatasource()).thenReturn(dataSource);
    when(dataSource.getConnection()).thenReturn(connection);
    PgEventProducer producer=new PgEventProducer(endpoint);
    producer.start();
    assertTrue(producer.isStarted());
  }
  @Test public void testPgEventProducerStop() throws Exception {
    when(endpoint.getDatasource()).thenReturn(dataSource);
    when(dataSource.getConnection()).thenReturn(connection);
    PgEventProducer producer=new PgEventProducer(endpoint);
    producer.start();
    producer.stop();
    verify(connection).close();
    assertTrue(producer.isStopped());
  }
  @Test(expected=InvalidStateException.class) public void testPgEventProducerProcessDbThrowsInvalidStateException() throws Exception {
    when(endpoint.getDatasource()).thenReturn(dataSource);
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.isClosed()).thenThrow(new SQLException("DB problem occurred"));
    PgEventProducer producer=new PgEventProducer(endpoint);
    producer.start();
    producer.process(exchange);
  }
  @Test public void testPgEventProducerProcessDbConnectionClosed() throws Exception {
    PGConnection connectionNew=mock(PGConnection.class);
    when(endpoint.getDatasource()).thenReturn(dataSource);
    when(dataSource.getConnection()).thenReturn(connection,connectionNew);
    when(connection.isClosed()).thenReturn(true);
    when(exchange.getIn()).thenReturn(message);
    when(message.getBody(String.class)).thenReturn("pgevent");
    when(endpoint.getChannel()).thenReturn("camel");
    when(connectionNew.prepareStatement("NOTIFY camel, 'pgevent'")).thenReturn(statement);
    PgEventProducer producer=new PgEventProducer(endpoint);
    producer.start();
    producer.process(exchange);
    verify(statement).execute();
  }
  @Test public void testPgEventProducerProcessServerMinimumVersionMatched() throws Exception {
    CallableStatement statement=mock(CallableStatement.class);
    when(endpoint.getDatasource()).thenReturn(dataSource);
    when(connection.isClosed()).thenReturn(false);
    when(dataSource.getConnection()).thenReturn(connection);
    when(exchange.getIn()).thenReturn(message);
    when(message.getBody(String.class)).thenReturn("pgevent");
    when(endpoint.getChannel()).thenReturn("camel");
    when(connection.isServerMinimumVersion(9,0)).thenReturn(true);
    when(connection.prepareCall(ArgumentMatchers.anyString())).thenReturn(statement);
    PgEventProducer producer=new PgEventProducer(endpoint);
    producer.start();
    producer.process(exchange);
    verify(statement).execute();
  }
  @Test public void testPgEventProducerProcessServerMinimumVersionNotMatched() throws Exception {
    when(endpoint.getDatasource()).thenReturn(dataSource);
    when(connection.isClosed()).thenReturn(false);
    when(dataSource.getConnection()).thenReturn(connection);
    when(exchange.getIn()).thenReturn(message);
    when(message.getBody(String.class)).thenReturn("pgevent");
    when(endpoint.getChannel()).thenReturn("camel");
    when(connection.isServerMinimumVersion(9,0)).thenReturn(false);
    when(connection.prepareStatement("NOTIFY camel, 'pgevent'")).thenReturn(statement);
    PgEventProducer producer=new PgEventProducer(endpoint);
    producer.start();
    producer.process(exchange);
    verify(statement).execute();
  }
}
