/** 
 * This is a manual test to run
 * @version
 */
@Ignore("Manual test") public class RouteContextProcessorTest extends ContextTestSupport {
  public static final int CONCURRENCY=10;
  public static final long SAFETY_TIMEOUT=100;
  public static final int SAFETY_CAPACITY=10;
  public static final long TIMEOUT=SAFETY_TIMEOUT + (RandomSleepProcessor.MAX_PROCESS_TIME - RandomSleepProcessor.MIN_PROCESS_TIME);
  public static final int CAPACITY=SAFETY_CAPACITY + (int)(CONCURRENCY * TIMEOUT / RandomSleepProcessor.MIN_PROCESS_TIME);
  private static final int NUMBER_OF_MESSAGES=10000;
  @Test public void testForkAndJoin() throws InterruptedException {
  }
  public void xxxTestForkAndJoin() throws InterruptedException {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(NUMBER_OF_MESSAGES);
    ProducerTemplate template=context.createProducerTemplate();
    for (int i=0; i < NUMBER_OF_MESSAGES; i++) {
      template.sendBodyAndHeader("seda:fork","Test Message: " + i,"seqnum",new Long(i));
    }
    long expectedTime=NUMBER_OF_MESSAGES * (RandomSleepProcessor.MAX_PROCESS_TIME + RandomSleepProcessor.MIN_PROCESS_TIME) / 2 / CONCURRENCY + TIMEOUT;
    Thread.sleep(expectedTime);
    assertMockEndpointsSatisfied();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        Processor myProcessor=new RandomSleepProcessor();
        from("seda:fork?concurrentConsumers=" + CONCURRENCY).process(myProcessor).to("seda:join");
        from("seda:join").resequence(header("seqnum")).stream().capacity(CAPACITY).timeout(TIMEOUT).to("mock:result");
      }
    }
;
  }
  /** 
 * Simulation processor that sleeps a random time between MIN_PROCESS_TIME and MAX_PROCESS_TIME milliseconds.
 */
public static class RandomSleepProcessor implements Processor {
    public static final long MIN_PROCESS_TIME=5;
    public static final long MAX_PROCESS_TIME=50;
    @Override public void process(    Exchange arg0) throws Exception {
      long processTime=(long)(MIN_PROCESS_TIME + Math.random() * (MAX_PROCESS_TIME - MIN_PROCESS_TIME));
      Thread.sleep(processTime);
    }
  }
}
