/** 
 * @version 
 */
public class RestletHeaderFilterStrategyTest extends RestletTestSupport {
  private static final String HEADER_FILTER="filter";
  @Test public void testRestletProducerInFilterAllowedHeader() throws Exception {
    String acceptedHeaderKey="dontFilter";
    MockEndpoint mock=getMockEndpoint("mock:out");
    mock.expectedHeaderReceived(acceptedHeaderKey,"any value");
    template.requestBodyAndHeader("direct:start",null,acceptedHeaderKey,"any value",String.class);
    mock.assertIsSatisfied();
  }
  @Test public void testRestletProducerInFilterNotAllowedHeader() throws Exception {
    String notAcceptedHeaderKey=HEADER_FILTER + "ThisHeader";
    MockEndpoint mock=getMockEndpoint("mock:out");
    mock.whenAnyExchangeReceived(new Processor(){
      public void process(      Exchange exchange) throws Exception {
        Map<String,Object> headers=exchange.getIn().getHeaders();
        for (        String key : headers.keySet()) {
          assertFalse("Header should have been filtered: " + key,key.startsWith(HEADER_FILTER));
        }
      }
    }
);
    template.requestBodyAndHeader("direct:start",null,notAcceptedHeaderKey,"any value",String.class);
    mock.assertIsSatisfied();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        DefaultHeaderFilterStrategy strategy=new DefaultHeaderFilterStrategy();
        strategy.setInFilterPattern(HEADER_FILTER + ".*");
        strategy.setOutFilterPattern(HEADER_FILTER + ".*");
        RestletComponent restlet=context.getComponent("restlet",RestletComponent.class);
        restlet.setHeaderFilterStrategy(strategy);
        restlet.setSynchronous(true);
        from("direct:start").to("restlet:http://localhost:" + portNum + "/users/123/exclude").to("log:reply");
        from("restlet:http://localhost:" + portNum + "/users/{id}/{filterExcluded}?restletMethods=GET").to("mock:out");
      }
    }
;
  }
}
