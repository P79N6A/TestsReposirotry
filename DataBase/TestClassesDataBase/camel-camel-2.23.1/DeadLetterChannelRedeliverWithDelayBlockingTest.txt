/** 
 * Unit test to verify that using DLC with redelivery and delays with blocking threads. As threads comes cheap these days in the modern JVM its no biggie. And for transactions you should use the same thread anyway.
 * @version 
 */
public class DeadLetterChannelRedeliverWithDelayBlockingTest extends ContextTestSupport {
  private static int counter;
  @Test public void testRedeliverWithDelay() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Message 2","Message 1");
    mock.expectedHeaderReceived("foo","bar");
    mock.message(0).header(Exchange.REDELIVERED).isNull();
    mock.message(1).header(Exchange.REDELIVERED).isEqualTo(true);
    Callable<?> task1=Executors.callable(new Runnable(){
      public void run(){
        template.sendBody("direct:start","Message 1");
      }
    }
);
    Callable<?> task2=Executors.callable(new Runnable(){
      public void run(){
        template.sendBody("direct:start","Message 2");
      }
    }
);
    Executors.newCachedThreadPool().submit(task1);
    Thread.sleep(100);
    Executors.newCachedThreadPool().submit(task2);
    assertMockEndpointsSatisfied();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        errorHandler(deadLetterChannel("mock:dead").redeliveryDelay(250).maximumRedeliveries(3).logStackTrace(false));
        from("direct:start").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            String body=exchange.getIn().getBody(String.class);
            if ("Message 1".equals(body) && counter++ < 2) {
              throw new IllegalArgumentException("Damn");
            }
            exchange.getIn().setHeader("foo","bar");
          }
        }
).to("mock:result");
      }
    }
;
  }
}
