public class ComposedMessageProcessorTest extends ContextTestSupport {
  @SuppressWarnings("unchecked") @Test public void testValidatingCorrectOrder() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(1);
    resultEndpoint.expectedHeaderReceived("orderId","myorderid");
    List<OrderItem> order=Arrays.asList(new OrderItem[]{new OrderItem("widget",5),new OrderItem("gadget",10)});
    template.sendBodyAndHeader("direct:start",order,"orderId","myorderid");
    assertMockEndpointsSatisfied();
    List<OrderItem> validatedOrder=resultEndpoint.getExchanges().get(0).getIn().getBody(List.class);
    assertTrue(validatedOrder.get(0).valid);
    assertTrue(validatedOrder.get(1).valid);
  }
  @SuppressWarnings("unchecked") @Test public void testValidatingIncorrectOrder() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(1);
    resultEndpoint.expectedHeaderReceived("orderId","myorderid");
    List<OrderItem> order=Arrays.asList(new OrderItem[]{new OrderItem("widget",500),new OrderItem("gadget",200)});
    template.sendBodyAndHeader("direct:start",order,"orderId","myorderid");
    assertMockEndpointsSatisfied();
    List<OrderItem> validatedOrder=resultEndpoint.getExchanges().get(0).getIn().getBody(List.class);
    assertFalse(validatedOrder.get(0).valid);
    assertFalse(validatedOrder.get(1).valid);
  }
  protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry jndi=super.createRegistry();
    jndi.bind("orderItemHelper",new OrderItemHelper());
    jndi.bind("widgetInventory",new WidgetInventory());
    jndi.bind("gadgetInventory",new GadgetInventory());
    return jndi;
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        from("direct:start").split().body().choice().when().method("orderItemHelper","isWidget").to("bean:widgetInventory").otherwise().to("bean:gadgetInventory").end().to("seda:aggregate");
        from("seda:aggregate").aggregate(new MyOrderAggregationStrategy()).header("orderId").completionTimeout(100).completionTimeoutCheckerInterval(10).to("mock:result");
      }
    }
;
  }
public static final class OrderItem {
    String type;
    int quantity;
    boolean valid;
    public OrderItem(    String type,    int quantity){
      this.type=type;
      this.quantity=quantity;
    }
  }
public static final class OrderItemHelper {
    private OrderItemHelper(){
    }
    public static boolean isWidget(    @Body OrderItem orderItem){
      return orderItem.type.equals("widget");
    }
  }
  /** 
 * Bean that checks whether the specified number of widgets can be ordered
 */
public static final class WidgetInventory {
    public void checkInventory(    @Body OrderItem orderItem){
      assertEquals("widget",orderItem.type);
      if (orderItem.quantity < 10) {
        orderItem.valid=true;
      }
    }
  }
  /** 
 * Bean that checks whether the specified number of gadgets can be ordered
 */
public static final class GadgetInventory {
    public void checkInventory(    @Body OrderItem orderItem){
      assertEquals("gadget",orderItem.type);
      if (orderItem.quantity < 20) {
        orderItem.valid=true;
      }
    }
  }
  /** 
 * Aggregation strategy that re-assembles the validated OrderItems  into an order, which is just a List.
 */
public static final class MyOrderAggregationStrategy implements AggregationStrategy {
    public Exchange aggregate(    Exchange oldExchange,    Exchange newExchange){
      if (oldExchange == null) {
        return newExchange;
      }
      List<OrderItem> order=new ArrayList<>(2);
      order.add(oldExchange.getIn().getBody(OrderItem.class));
      order.add(newExchange.getIn().getBody(OrderItem.class));
      oldExchange.getIn().setBody(order);
      return oldExchange;
    }
  }
}
