/** 
 * For unit testing the <tt>filters</tt> option.
 */
public class Mina2FiltersTest extends BaseMina2Test {
  @Test public void testFilterListRef() throws Exception {
    testFilter(String.format("mina2:tcp://localhost:%1$s?textline=true&minaLogger=true&sync=false&filters=#myFilters",getPort()));
  }
  @Test public void testFilterElementRef() throws Exception {
    testFilter(String.format("mina2:tcp://localhost:%1$s?textline=true&minaLogger=true&sync=false&filters=#myFilter",getPort()));
  }
  @Override @After public void tearDown() throws Exception {
    TestFilter.called=0;
    super.tearDown();
  }
  private void testFilter(  final String uri) throws Exception {
    context.addRoutes(new RouteBuilder(){
      public void configure() throws Exception {
        from(uri).to("mock:result");
      }
    }
);
    MockEndpoint mock=this.getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Hello World");
    Endpoint endpoint=context.getEndpoint(uri);
    Exchange exchange=endpoint.createExchange();
    Producer producer=endpoint.createProducer();
    producer.start();
    exchange.getIn().setBody("Hello World");
    producer.process(exchange);
    assertMockEndpointsSatisfied();
    assertEquals("The filter should have been called twice (producer and consumer)",2,TestFilter.called);
    producer.stop();
  }
  @Override protected Context createJndiContext() throws Exception {
    JndiContext answer=new JndiContext();
    IoFilter myFilter=new TestFilter();
    List<IoFilter> myFilters=new ArrayList<>();
    myFilters.add(myFilter);
    answer.bind("myFilters",myFilters);
    answer.bind("myFilter",myFilter);
    return answer;
  }
public static final class TestFilter extends IoFilterAdapter {
    public static volatile int called;
    @Override public void sessionCreated(    NextFilter nextFilter,    IoSession session) throws Exception {
      incCalled();
      nextFilter.sessionCreated(session);
    }
    public static synchronized void incCalled(){
      called++;
    }
  }
}
