/** 
 * Unit test to verify that aggregate by timeout only also works.
 * @version 
 */
public class AggregateTimeoutWithExecutorServiceTest extends ContextTestSupport {
  public static final int NUM_AGGREGATORS=20;
  @Test public void testThreadNotUsedForEveryAggregatorWithCustomExecutorService() throws Exception {
    assertTrue("There should not be a thread for every aggregator when using a shared thread pool",aggregateThreadsCount() < NUM_AGGREGATORS);
    for (int i=0; i < NUM_AGGREGATORS; ++i) {
      MockEndpoint result=getMockEndpoint("mock:result" + i);
      result.expectedBodiesReceived("Message 4");
    }
    for (int i=0; i < NUM_AGGREGATORS; ++i) {
      for (int j=0; j < 5; j++) {
        template.sendBodyAndHeader("direct:start" + i,"Message " + j,"id","1");
      }
    }
    assertMockEndpointsSatisfied();
  }
  public static int aggregateThreadsCount(){
    int count=0;
    ThreadGroup threadGroup=Thread.currentThread().getThreadGroup();
    Thread[] threads=new Thread[threadGroup.activeCount()];
    threadGroup.enumerate(threads);
    for (    Thread thread : threads) {
      if (thread != null && thread.getName().contains(AggregateProcessor.AGGREGATE_TIMEOUT_CHECKER)) {
        ++count;
      }
    }
    return count;
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        ScheduledExecutorService threadPool=context.getExecutorServiceManager().newScheduledThreadPool(this,"MyThreadPool",8);
        for (int i=0; i < NUM_AGGREGATORS; ++i) {
          from("direct:start" + i).aggregate(header("id"),new UseLatestAggregationStrategy()).completionTimeout(100).timeoutCheckerExecutorService(threadPool).completionTimeoutCheckerInterval(10).to("mock:result" + i);
        }
      }
    }
;
  }
}
