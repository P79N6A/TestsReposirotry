/** 
 * @version
 */
public class DistributedOptimisticLockFailingTest extends AbstractDistributedTest {
private static final class AlwaysFailingRepository extends MemoryAggregationRepository {
    @Override public Exchange add(    CamelContext camelContext,    String key,    Exchange oldExchange,    Exchange newExchange){
      throw new OptimisticLockingException();
    }
  }
private static final class EverySecondOneFailsRepository extends MemoryAggregationRepository {
    private AtomicInteger counter=new AtomicInteger();
    private EverySecondOneFailsRepository(){
      super(true);
    }
    @Override public Exchange add(    CamelContext camelContext,    String key,    Exchange oldExchange,    Exchange newExchange){
      int count=counter.incrementAndGet();
      if (count % 2 == 0) {
        throw new OptimisticLockingException();
      }
 else {
        return super.add(camelContext,key,oldExchange,newExchange);
      }
    }
  }
  private EverySecondOneFailsRepository sharedRepository=new EverySecondOneFailsRepository();
  @Test public void testAlwaysFails() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(0);
    MockEndpoint mock2=getMockEndpoint2("mock:result");
    mock2.expectedMessageCount(0);
    try {
      template.sendBodyAndHeader("direct:fails","hello world","id",1);
      fail("Should throw CamelExecutionException");
    }
 catch (    CamelExecutionException e) {
      assertIsInstanceOf(CamelExchangeException.class,e.getCause());
      assertIsInstanceOf(OptimisticLockingAggregationRepository.OptimisticLockingException.class,e.getCause().getCause());
    }
    try {
      template2.sendBodyAndHeader("direct:fails","hello world","id",1);
      fail("Should throw CamelExecutionException");
    }
 catch (    CamelExecutionException e) {
      assertIsInstanceOf(CamelExchangeException.class,e.getCause());
      assertIsInstanceOf(OptimisticLockingAggregationRepository.OptimisticLockingException.class,e.getCause().getCause());
    }
    mock.assertIsSatisfied();
    mock2.assertIsSatisfied();
  }
  @Test public void testEverySecondOneFails() throws Exception {
    int size=200;
    ExecutorService service=Executors.newFixedThreadPool(10);
    List<Callable<Object>> tasks=new ArrayList<>();
    for (int i=0; i < size; i++) {
      final int id=i % 25;
      final int choice=i % 2;
      final int count=i;
      tasks.add(new Callable<Object>(){
        public Object call() throws Exception {
          if (choice == 0) {
            template.sendBodyAndHeader("direct:everysecondone","" + count,"id",id);
          }
 else {
            template2.sendBodyAndHeader("direct:everysecondone","" + count,"id",id);
          }
          return null;
        }
      }
);
    }
    MockEndpoint mock=getMockEndpoint("mock:result");
    MockEndpoint mock2=getMockEndpoint2("mock:result");
    service.invokeAll(tasks);
    service.shutdown();
    service.awaitTermination(10,TimeUnit.SECONDS);
    int contextCount=mock.getReceivedCounter();
    int context2Count=mock2.getReceivedCounter();
    assertEquals(25,contextCount + context2Count);
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("direct:fails").aggregate(header("id"),new BodyInAggregatingStrategy()).aggregationRepository(new AlwaysFailingRepository()).optimisticLocking().optimisticLockRetryPolicy(new OptimisticLockRetryPolicy().maximumRetries(5).retryDelay(0)).completionSize(2).to("mock:result");
        from("direct:everysecondone").aggregate(header("id"),new BodyInAggregatingStrategy()).aggregationRepository(sharedRepository).optimisticLocking().completionSize(8).to("mock:result");
      }
    }
;
  }
}
