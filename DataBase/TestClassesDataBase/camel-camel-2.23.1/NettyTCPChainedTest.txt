/** 
 * In this test we are checking that same netty endpoint can be safely called twice in single route with reconnect. It requires for processing to be fully async otherwise {@link io.netty.util.concurrent.BlockingOperationException} is thrown by netty.
 */
public class NettyTCPChainedTest extends BaseNettyTest {
  @EndpointInject(uri="mock:result") protected MockEndpoint resultEndpoint;
  private void sendFile(  String uri) throws Exception {
    Exchange exchange=template.asyncSend(uri,new Processor(){
      public void process(      Exchange exchange) throws Exception {
        InputStream is=IOHelper.buffered(new FileInputStream("src/test/resources/test.txt"));
        byte buffer[]=IOConverter.toBytes(is);
        is.close();
        exchange.setProperty(Exchange.CHARSET_NAME,"UTF-8");
        Message in=exchange.getIn();
        in.setBody(buffer);
      }
    }
).get();
    if (exchange.getException() != null) {
      throw new AssertionError(exchange.getException());
    }
    Assert.assertFalse(exchange.isFailed());
  }
  @Test public void testTCPChainedConnectionFromCallbackThread() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(2);
    sendFile("direct:chainedCalls");
    mock.assertIsSatisfied();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("netty4:tcp://localhost:{{port}}?sync=false").to("log:result").to("mock:result");
        from("direct:nettyCall").to("netty4:tcp://localhost:{{port}}?sync=false&disconnect=true&workerCount=1");
        from("direct:chainedCalls").to("direct:nettyCall").to("direct:nettyCall");
      }
    }
;
  }
}
