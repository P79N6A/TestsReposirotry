@RunWith(Arquillian.class) public class MultiContextEventEndpointTest {
  @Inject @ContextName("first") @Uri("mock:consumeString") private MockEndpoint firstConsumeString;
  @Inject @ContextName("second") @Uri("mock:consumeString") private MockEndpoint secondConsumeString;
  @Inject @ContextName("first") @Uri("direct:produceString") private ProducerTemplate firstProduceString;
  @Inject @ContextName("second") @Uri("direct:produceString") private ProducerTemplate secondProduceString;
  @Inject private Event<Object> objectEvent;
  @Inject private EventObserver observer;
  @Deployment public static Archive<?> deployment(){
    return ShrinkWrap.create(JavaArchive.class).addPackage(CdiCamelExtension.class.getPackage()).addClasses(FirstCamelContextBean.class,FirstCamelContextEventConsumingRoute.class,FirstCamelContextEventProducingRoute.class,SecondCamelContextBean.class,SecondCamelContextEventConsumingRoute.class,SecondCamelContextEventProducingRoute.class).addAsManifestResource(EmptyAsset.INSTANCE,"beans.xml");
  }
  @Test @InSequence(1) public void configureCamelContexts(  @ContextName("second") CamelContext secondContext) throws Exception {
    secondContext.startAllRoutes();
  }
  @Test @InSequence(2) public void sendEventsToConsumers() throws InterruptedException {
    firstConsumeString.expectedMessageCount(1);
    firstConsumeString.expectedBodiesReceived("testFirst");
    secondConsumeString.expectedMessageCount(2);
    secondConsumeString.expectedBodiesReceived("testSecond1","testSecond2");
    objectEvent.select(String.class,ContextName.Literal.of("first")).fire("testFirst");
    objectEvent.select(String.class,ContextName.Literal.of("second")).fire("testSecond1");
    objectEvent.select(String.class,ContextName.Literal.of("second")).fire("testSecond2");
    assertIsSatisfied(2L,TimeUnit.SECONDS,firstConsumeString,secondConsumeString);
  }
  @Test @InSequence(3) public void sendMessagesToProducers(){
    firstProduceString.sendBody("testFirst");
    secondProduceString.sendBody("testSecond");
    assertThat(observer.getObjectEvents(),Matchers.<Object>contains("testFirst","testSecond"));
    assertThat(observer.getStringEvents(),contains("testFirst","testSecond"));
    assertThat(observer.getFirstStringEvents(),contains("testFirst"));
    assertThat(observer.secondStringEvents(),contains("testSecond"));
  }
  @Before public void resetCollectedEvents(){
    observer.reset();
  }
@ApplicationScoped static class EventObserver {
    private final List<Object> objectEvents=new ArrayList<>();
    private final List<String> stringEvents=new ArrayList<>();
    private final List<String> firstStringEvents=new ArrayList<>();
    private final List<String> secondStringEvents=new ArrayList<>();
    void collectObjectEvents(    @Observes Object event){
      objectEvents.add(event);
    }
    void collectStringEvents(    @Observes String event){
      stringEvents.add(event);
    }
    void collectFirstStringEvents(    @Observes @ContextName("first") String event){
      firstStringEvents.add(event);
    }
    void collectSecondStringEvents(    @Observes @ContextName("second") String event){
      secondStringEvents.add(event);
    }
    List<Object> getObjectEvents(){
      return objectEvents;
    }
    List<String> getStringEvents(){
      return stringEvents;
    }
    List<String> getFirstStringEvents(){
      return firstStringEvents;
    }
    List<String> secondStringEvents(){
      return secondStringEvents;
    }
    void reset(){
      objectEvents.clear();
      stringEvents.clear();
      firstStringEvents.clear();
      secondStringEvents.clear();
    }
  }
}
