public class NettyConsumerClientModeReconnectTest extends BaseNettyTest {
  private MyServer server;
  public void startNettyServer() throws Exception {
    server=new MyServer(getPort());
    server.start();
  }
  public void shutdownServer(){
    if (server != null) {
      server.shutdown();
    }
  }
  @Test public void testNettyRouteServerNotStarted() throws Exception {
    try {
      MockEndpoint receive=context.getEndpoint("mock:receive",MockEndpoint.class);
      receive.expectedBodiesReceived("Bye Willem");
      log.info(">>> starting Camel route while Netty server is not ready");
      context.startRoute("client");
      Thread.sleep(500);
      log.info(">>> starting Netty server");
      startNettyServer();
      assertMockEndpointsSatisfied();
      log.info(">>> routing done");
      Thread.sleep(500);
    }
  finally {
      log.info(">>> shutting down Netty server");
      shutdownServer();
    }
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("netty4:tcp://localhost:{{port}}?textline=true&clientMode=true&reconnect=true&reconnectInterval=200").id("client").process(new Processor(){
          public void process(          final Exchange exchange){
            log.info("Processing exchange in Netty server {}",exchange);
            String body=exchange.getIn().getBody(String.class);
            exchange.getOut().setBody("Bye " + body);
          }
        }
).to("log:receive").to("mock:receive").noAutoStartup();
      }
    }
;
  }
private static class MyServer {
    private int port;
    private ServerBootstrap bootstrap;
    private Channel channel;
    private EventLoopGroup bossGroup;
    private EventLoopGroup workerGroup;
    MyServer(    int port){
      this.port=port;
    }
    public void start() throws Exception {
      bossGroup=new NioEventLoopGroup(1);
      workerGroup=new NioEventLoopGroup();
      bootstrap=new ServerBootstrap();
      bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ServerInitializer());
      ChannelFuture cf=bootstrap.bind(port).sync();
      channel=cf.channel();
    }
    public void shutdown(){
      channel.disconnect();
      bossGroup.shutdownGracefully();
      workerGroup.shutdownGracefully();
    }
  }
private static class ServerHandler extends SimpleChannelInboundHandler<String> {
    public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      ctx.write("Willem\r\n");
      ctx.flush();
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      cause.printStackTrace();
      ctx.close();
    }
    @Override protected void channelRead0(    ChannelHandlerContext ctx,    String msg) throws Exception {
    }
    public void channelReadComplete(    ChannelHandlerContext ctx) throws Exception {
      ctx.flush();
    }
  }
private static class ServerInitializer extends ChannelInitializer<SocketChannel> {
    private static final StringDecoder DECODER=new StringDecoder();
    private static final StringEncoder ENCODER=new StringEncoder();
    private static final ServerHandler SERVERHANDLER=new ServerHandler();
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ChannelPipeline pipeline=ch.pipeline();
      pipeline.addLast("framer",new DelimiterBasedFrameDecoder(8192,Delimiters.lineDelimiter()));
      pipeline.addLast("decoder",DECODER);
      pipeline.addLast("encoder",ENCODER);
      pipeline.addLast("handler",SERVERHANDLER);
    }
  }
}
