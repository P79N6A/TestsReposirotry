/** 
 * Tests that a Disruptor producer blocks when a message is sent while the ring buffer is full.
 */
public class DisruptorBlockWhenFullTest extends CamelTestSupport {
  private static final int QUEUE_SIZE=8;
  private static final int DELAY=100;
  private static final String MOCK_URI="mock:blockWhenFullOutput";
  private static final String DEFAULT_URI="disruptor:foo?size=" + QUEUE_SIZE;
  private static final String EXCEPTION_WHEN_FULL_URI="disruptor:foo?blockWhenFull=false&size=" + QUEUE_SIZE;
  @Override protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from(DEFAULT_URI).delay(DELAY).to(MOCK_URI);
      }
    }
;
  }
  @Test public void testDisruptorBlockingWhenFull() throws Exception {
    getMockEndpoint(MOCK_URI).setExpectedMessageCount(QUEUE_SIZE + 20);
    final DisruptorEndpoint disruptor=context.getEndpoint(DEFAULT_URI,DisruptorEndpoint.class);
    assertEquals(QUEUE_SIZE,disruptor.getRemainingCapacity());
    sendSoManyOverCapacity(DEFAULT_URI,QUEUE_SIZE,20);
    assertMockEndpointsSatisfied();
  }
  @Test(expected=CamelExecutionException.class) public void testDisruptorExceptionWhenFull() throws Exception {
    getMockEndpoint(MOCK_URI).setExpectedMessageCount(QUEUE_SIZE + 20);
    final DisruptorEndpoint disruptor=context.getEndpoint(DEFAULT_URI,DisruptorEndpoint.class);
    assertEquals(QUEUE_SIZE,disruptor.getRemainingCapacity());
    sendSoManyOverCapacity(EXCEPTION_WHEN_FULL_URI,QUEUE_SIZE,20);
    assertMockEndpointsSatisfied();
  }
  /** 
 * This method make sure that we hit the limit by sending 'soMany' messages over the given capacity which allows the delayer to kick in.
 */
  private void sendSoManyOverCapacity(  final String uri,  final int capacity,  final int soMany){
    for (int i=0; i < (capacity + soMany); i++) {
      template.sendBody(uri,"Message " + i);
    }
  }
}
