public abstract class TcpServerConsumerAcknowledgementTestSupport extends CamelTestSupport {
  static final String TEST_MESSAGE="MSH|^~\\&|APP_A|FAC_A|^org^sys||||ADT^A04^ADT_A04|||2.6" + '\r' + "PID|1||1100832^^^^PI||TEST^FIG||98765432|U||R|435 MAIN STREET^^LONGMONT^CO^80503||123-456-7890|||S"+ '\r';
  static final String EXPECTED_ACKNOWLEDGEMENT="MSH|^~\\&|^org^sys||APP_A|FAC_A|||ACK^A04^ADT_A04|||2.6" + '\r' + "MSA|AA|"+ '\r';
  @Rule public MllpClientResource mllpClient=new MllpClientResource();
  @EndpointInject(uri="mock://result") MockEndpoint result;
  @EndpointInject(uri="mock://on-complete-only") MockEndpoint complete;
  @EndpointInject(uri="mock://on-failure-only") MockEndpoint failure;
  @EndpointInject(uri="mock://invalid-ack-ex") MockEndpoint invalidAckEx;
  @EndpointInject(uri="mock://ack-generation-ex") MockEndpoint ackGenerationEx;
  @Override protected void doPostSetup() throws Exception {
    super.doPostSetup();
    result.expectedMessageCount(0);
    complete.expectedMessageCount(0);
    failure.expectedMessageCount(0);
    invalidAckEx.expectedMessageCount(0);
    ackGenerationEx.expectedMessageCount(0);
  }
  @Override protected CamelContext createCamelContext() throws Exception {
    DefaultCamelContext context=(DefaultCamelContext)super.createCamelContext();
    context.setUseMDCLogging(true);
    context.setName(this.getClass().getSimpleName());
    return context;
  }
  @Override protected RouteBuilder createRouteBuilder(){
    mllpClient.setMllpHost("localhost");
    mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable());
    return new RouteBuilder(){
      int connectTimeout=500;
      int responseTimeout=5000;
      @Override public void configure() throws Exception {
        String routeId="mllp-test-receiver-route";
        onException(MllpInvalidAcknowledgementException.class).handled(false).to("mock://invalid-ack-ex");
        onException(MllpAcknowledgementGenerationException.class).handled(false).to("mock://ack-generation-ex");
        onCompletion().onCompleteOnly().log(LoggingLevel.INFO,routeId,"Test route complete").to("mock://on-complete-only");
        onCompletion().onFailureOnly().log(LoggingLevel.INFO,routeId,"Test route complete").to("mock://on-failure-only");
        fromF("mllp://%s:%d?bridgeErrorHandler=%b&autoAck=%b&connectTimeout=%d&receiveTimeout=%d",mllpClient.getMllpHost(),mllpClient.getMllpPort(),isBridgeErrorHandler(),isAutoAck(),connectTimeout,responseTimeout).routeId(routeId).to(result);
      }
    }
;
  }
  protected abstract boolean isBridgeErrorHandler();
  protected abstract boolean isAutoAck();
  public void receiveSingleMessage() throws Exception {
    NotifyBuilder done=new NotifyBuilder(context).whenDone(1).create();
    mllpClient.connect();
    mllpClient.sendFramedData(TEST_MESSAGE);
    assertTrue("Exchange should have completed",done.matches(10,TimeUnit.SECONDS));
    assertMockEndpointsSatisfied();
  }
  public void acknowledgementDeliveryFailure() throws Exception {
    boolean disconnectAfterSend=true;
    mllpClient.setDisconnectMethod(MllpClientResource.DisconnectMethod.RESET);
    mllpClient.connect();
    mllpClient.sendFramedData(TEST_MESSAGE,disconnectAfterSend);
    assertMockEndpointsSatisfied(10,TimeUnit.SECONDS);
  }
  public void unparsableMessage(  String testMessage) throws Exception {
    NotifyBuilder done=new NotifyBuilder(context).whenDone(1).create();
    mllpClient.connect();
    mllpClient.sendFramedData(testMessage);
    assertTrue("One exchange should have complete",done.matches(5,TimeUnit.SECONDS));
    assertMockEndpointsSatisfied();
  }
}
