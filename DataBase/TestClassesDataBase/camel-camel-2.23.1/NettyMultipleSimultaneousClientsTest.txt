/** 
 */
public class NettyMultipleSimultaneousClientsTest extends BaseNettyTest {
  private String uri="netty4:tcp://localhost:{{port}}?sync=true&reuseAddress=true&synchronous=false";
  private int clientCount=20;
  private CountDownLatch startLatch=new CountDownLatch(1);
  private CountDownLatch finishLatch=new CountDownLatch(clientCount);
  @Test public void testSimultaneousClients() throws Exception {
    ExecutorService executorService=Executors.newFixedThreadPool(clientCount);
    Future<?>[] replies=new Future[clientCount];
    for (int i=0; i < clientCount; i++) {
      replies[i]=executorService.submit(new Callable<Object>(){
        @Override public Object call() throws Exception {
          startLatch.await();
          Object reply=template.requestBody(uri,"World");
          finishLatch.countDown();
          return reply;
        }
      }
);
    }
    Object[] expectedReplies=new Object[clientCount];
    Arrays.fill(expectedReplies,"Bye World");
    getMockEndpoint("mock:result").expectedMessageCount(clientCount);
    getMockEndpoint("mock:result").expectedBodiesReceived(expectedReplies);
    startLatch.countDown();
    assertTrue("Waiting on the latch ended up with a timeout!",finishLatch.await(5,TimeUnit.SECONDS));
    executorService.shutdown();
    for (int i=0; i < clientCount; i++) {
      assertEquals("Bye World",replies[i].get());
    }
    assertMockEndpointsSatisfied();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from(uri).log("${body}").transform(body().prepend("Bye ")).to("mock:result");
      }
    }
;
  }
}
