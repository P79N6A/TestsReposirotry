/** 
 * @version 
 */
public class SplitterPojoTest extends ContextTestSupport {
  @Override protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry jndi=super.createRegistry();
    jndi.bind("mySplitterBean",new MySplitterBean());
    return jndi;
  }
  @Test public void testSplitBodyWithPojoBean() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.reset();
    mock.expectedBodiesReceived("James","Jonathan","Hadrian","Claus","Willem");
    template.sendBody("direct:body","James,Jonathan,Hadrian,Claus,Willem");
    assertMockEndpointsSatisfied();
  }
  @Test public void testSplitMessageWithPojoBean() throws Exception {
    String users[]={"James","Jonathan","Hadrian","Claus","Willem"};
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.reset();
    mock.expectedMessageCount(5);
    template.sendBodyAndHeader("direct:message","Test Body Message","user","James,Jonathan,Hadrian,Claus,Willem");
    int i=0;
    for (    Exchange exchange : mock.getExchanges()) {
      assertEquals("We got a wrong body ","Test Body Message",exchange.getIn().getBody());
      assertEquals("We got a wrong header ",users[i],exchange.getIn().getHeader("user"));
      i++;
    }
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        from("direct:body").split().method("mySplitterBean","splitBody").to("mock:result");
        from("direct:message").split().method("mySplitterBean","splitMessage").to("mock:result");
      }
    }
;
  }
public class MySplitterBean {
    /** 
 * The split body method returns something that is iteratable such as a java.util.List.
 * @param body the payload of the incoming message
 * @return a list containing each part splitted
 */
    public List<String> splitBody(    String body){
      List<String> answer=new ArrayList<>();
      String[] parts=body.split(",");
      for (      String part : parts) {
        answer.add(part);
      }
      return answer;
    }
    /** 
 * The split message method returns something that is iteratable such as a java.util.List.
 * @param header the header of the incoming message with the name user
 * @param body the payload of the incoming message
 * @return a list containing each part splitted
 */
    public List<Message> splitMessage(    @Header(value="user") String header,    @Body String body,    CamelContext camelContext){
      List<Message> answer=new ArrayList<>();
      String[] parts=header.split(",");
      for (      String part : parts) {
        DefaultMessage message=new DefaultMessage(camelContext);
        message.setHeader("user",part);
        message.setBody(body);
        answer.add(message);
      }
      return answer;
    }
  }
}
