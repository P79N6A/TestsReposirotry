public final class ExpectedDeploymentException implements TestRule {
  private final List<Matcher<Throwable>> exceptions=new ArrayList<>();
  private final List<Matcher<String>> messages=new ArrayList<>();
  private final LogVerifier log=new LogVerifier();
  private final TestRule chain;
  private ExpectedDeploymentException(){
    chain=RuleChain.outerRule(log).around((base,description) -> new Statement(){
      @Override public void evaluate() throws Throwable {
        try {
          base.evaluate();
        }
 catch (        Throwable exception) {
          assertThat(exception,allOf(pecs(exceptions)));
          try {
            assertThat(log.getMessages(),anyOf(hasItems(messages)));
          }
 catch (          AssertionError error) {
            assertThat(exception.getMessage(),allOf(pecs(messages)));
          }
        }
      }
    }
);
  }
  public static ExpectedDeploymentException none(){
    return new ExpectedDeploymentException();
  }
  public ExpectedDeploymentException expect(  Class<? extends Throwable> type){
    exceptions.add(Matchers.instanceOf(type));
    return this;
  }
  public ExpectedDeploymentException expectMessage(  Matcher<String> matcher){
    messages.add(matcher);
    return this;
  }
  @SuppressWarnings({"unchecked","rawtypes"}) private <T>List<Matcher<? super T>> pecs(  List<Matcher<T>> matchers){
    return new ArrayList<>((List)matchers);
  }
  private <T>Matcher<Iterable<? super T>>[] hasItems(  List<Matcher<T>> matchers){
    @SuppressWarnings("unchecked") Matcher<Iterable<? super T>>[] items=new Matcher[matchers.size()];
    for (int i=0; i < items.length; i++) {
      items[i]=hasItem(matchers.get(i));
    }
    return items;
  }
  @Override public Statement apply(  Statement base,  Description description){
    return chain.apply(base,description);
  }
}
