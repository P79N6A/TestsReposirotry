/** 
 * @version 
 */
public class ExchangeIdempotentConsumerTest extends ContextTestSupport {
  protected Endpoint startEndpoint;
  protected MockEndpoint resultEndpoint;
  private MyIdempotentRepo repo=new MyIdempotentRepo();
  @Override public boolean isUseRouteBuilder(){
    return false;
  }
  @Test public void testDuplicateMessagesAreFilteredOut() throws Exception {
    assertEquals(0,repo.getExchange().size());
    context.addRoutes(new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("direct:start").idempotentConsumer(header("messageId"),repo).to("mock:result");
      }
    }
);
    context.start();
    resultEndpoint.expectedBodiesReceived("one","two","three");
    sendMessage("1","one");
    sendMessage("2","two");
    sendMessage("1","one");
    sendMessage("2","two");
    sendMessage("1","one");
    sendMessage("3","three");
    assertMockEndpointsSatisfied();
    assertEquals(6,repo.getExchange().size());
    for (    Exchange exchange : resultEndpoint.getExchanges()) {
      assertTrue("Should contain the exchange",repo.getExchange().contains(exchange.getExchangeId()));
    }
  }
  protected void sendMessage(  final Object messageId,  final Object body){
    template.send(startEndpoint,new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody(body);
        in.setHeader("messageId",messageId);
      }
    }
);
  }
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    startEndpoint=resolveMandatoryEndpoint("direct:start");
    resultEndpoint=getMockEndpoint("mock:result");
  }
private final class MyIdempotentRepo implements ExchangeIdempotentRepository<String> {
    private IdempotentRepository<String> delegate;
    private Set<String> exchanges=new LinkedHashSet<>();
    private MyIdempotentRepo(){
      delegate=MemoryIdempotentRepository.memoryIdempotentRepository(200);
    }
    @Override public boolean add(    Exchange exchange,    String key){
      exchanges.add(exchange.getExchangeId());
      return delegate.add(key);
    }
    @Override public boolean contains(    Exchange exchange,    String key){
      exchanges.add(exchange.getExchangeId());
      return delegate.contains(key);
    }
    @Override public boolean remove(    Exchange exchange,    String key){
      exchanges.add(exchange.getExchangeId());
      return delegate.remove(key);
    }
    @Override public boolean confirm(    Exchange exchange,    String key){
      exchanges.add(exchange.getExchangeId());
      return delegate.confirm(key);
    }
    @Override public void clear(){
      delegate.clear();
    }
    @Override public boolean add(    String key){
      throw new UnsupportedOperationException("Should not be called");
    }
    @Override public boolean contains(    String key){
      throw new UnsupportedOperationException("Should not be called");
    }
    @Override public boolean remove(    String key){
      throw new UnsupportedOperationException("Should not be called");
    }
    @Override public boolean confirm(    String key){
      throw new UnsupportedOperationException("Should not be called");
    }
    public Set<String> getExchange(){
      return exchanges;
    }
    @Override public void start() throws Exception {
    }
    @Override public void stop() throws Exception {
    }
  }
}
