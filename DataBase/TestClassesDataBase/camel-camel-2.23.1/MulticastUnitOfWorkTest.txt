/** 
 * Unit test to verify unit of work with multicast.
 * @version 
 */
public class MulticastUnitOfWorkTest extends ContextTestSupport {
  private static String sync;
  private static String lastOne;
  @Test public void testMulticastUOW() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(2);
    template.sendBody("direct:start","Hello World");
    assertMockEndpointsSatisfied();
    assertEquals("onCompleteA",sync);
    assertEquals("onCompleteA",lastOne);
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        context.setTracing(true);
        from("direct:start").process(new MyUOWProcessor("A")).multicast().to("direct:foo","direct:bar");
        from("direct:foo").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            assertNull("First exchange is not complete yet",sync);
          }
        }
).process(new MyUOWProcessor("B")).process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            lastOne="processor";
          }
        }
).to("mock:result");
        from("direct:bar").to("mock:result");
      }
    }
;
  }
private static final class MyUOWProcessor implements Processor {
    private String id;
    private MyUOWProcessor(    String id){
      this.id=id;
    }
    public void process(    Exchange exchange) throws Exception {
      exchange.getUnitOfWork().addSynchronization(new Synchronization(){
        public void onComplete(        Exchange exchange){
          sync="onComplete" + id;
          lastOne=sync;
        }
        public void onFailure(        Exchange exchange){
          sync="onFailure" + id;
          lastOne=sync;
        }
      }
);
    }
  }
}
