/** 
 * Test the effect of redelivery in association with netty component.
 */
public class NettyRedeliveryTest extends CamelTestSupport {
  /** 
 * Body of sufficient size such that it doesn't fit into the TCP buffer and has to be read.
 */
  private static final byte[] LARGE_BUFFER_BODY=new byte[1000000];
  /** 
 * Failure will occur with 2 redeliveries however is increasingly more likely the more it retries.
 */
  private static final int REDELIVERY_COUNT=100;
  private ExecutorService listener=Executors.newSingleThreadExecutor();
  @EndpointInject(uri="mock:exception") private MockEndpoint exception;
  @EndpointInject(uri="mock:downstream") private MockEndpoint downstream;
  private Deque<Callable<?>> tasks=new LinkedBlockingDeque<>();
  private int port;
  private boolean alive=true;
  @Override protected void doPreSetup() throws Exception {
    port=createServerSocket(0);
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        onException(Exception.class).maximumRedeliveries(REDELIVERY_COUNT).retryAttemptedLogLevel(LoggingLevel.INFO).retriesExhaustedLogLevel(LoggingLevel.ERROR).redeliveryDelay(10).to("mock:exception").handled(true);
        from("direct:start").routeId("start").to("netty4:tcp://localhost:" + port).to("log:downstream").to("mock:downstream");
      }
    }
;
  }
  @Override @After public void tearDown() throws Exception {
    super.tearDown();
    alive=false;
    listener.shutdown();
  }
  @Test public void testExceptionHandler() throws Exception {
    downstream.setExpectedMessageCount(0);
    downstream.setAssertPeriod(1000);
    exception.setExpectedMessageCount(1);
    sendBody("direct:start",LARGE_BUFFER_BODY);
    exception.assertIsSatisfied();
    assertEquals(REDELIVERY_COUNT,tasks.size());
    downstream.assertIsSatisfied();
  }
  @Override protected CamelContext createCamelContext() throws Exception {
    CamelContext context=new DefaultCamelContext(createRegistry()){
      @Override public ScheduledExecutorService getErrorHandlerExecutorService(){
        return getScheduledExecutorService();
      }
    }
;
    return context;
  }
  private ScheduledExecutorService getScheduledExecutorService(){
    final ScheduledExecutorService delegate=Executors.newScheduledThreadPool(10);
    return newProxy(ScheduledExecutorService.class,new InvocationHandler(){
      @Override public Object invoke(      Object proxy,      Method method,      Object[] args) throws Throwable {
        if ("submit".equals(method.getName()) || "schedule".equals(method.getName())) {
          tasks.add((Callable<?>)args[0]);
        }
        return method.invoke(delegate,args);
      }
    }
);
  }
  private int createServerSocket(  int port) throws IOException {
    final ServerSocket listen=new ServerSocket(port);
    listen.setSoTimeout(100);
    listener.execute(new Runnable(){
      private ExecutorService pool=Executors.newCachedThreadPool();
      @Override public void run(){
        try {
          while (alive) {
            try {
              pool.execute(new ClosingClientRunnable(listen.accept()));
            }
 catch (            SocketTimeoutException ignored) {
            }
          }
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
 finally {
          try {
            listen.close();
          }
 catch (          IOException ignored) {
          }
        }
      }
    }
);
    return listen.getLocalPort();
  }
  private static <T>T newProxy(  Class<T> interfaceType,  InvocationHandler handler){
    Object object=Proxy.newProxyInstance(interfaceType.getClassLoader(),new Class<?>[]{interfaceType},handler);
    return interfaceType.cast(object);
  }
  /** 
 * Handler for client connection.
 */
private class ClosingClientRunnable implements Runnable {
    private final Socket socket;
    ClosingClientRunnable(    Socket socket){
      this.socket=socket;
    }
    @Override public void run(){
      try {
        Thread.sleep(10);
        socket.close();
      }
 catch (      Throwable e) {
        throw new RuntimeException(e);
      }
 finally {
        try {
          socket.close();
        }
 catch (        IOException ignored) {
        }
      }
    }
  }
}
