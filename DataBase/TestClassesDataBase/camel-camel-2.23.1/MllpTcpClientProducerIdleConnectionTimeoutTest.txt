public class MllpTcpClientProducerIdleConnectionTimeoutTest extends CamelTestSupport {
  static final int CONNECT_TIMEOUT=500;
  static final int RECEIVE_TIMEOUT=1000;
  static final int READ_TIMEOUT=500;
  static final int IDLE_TIMEOUT=RECEIVE_TIMEOUT * 3;
  @Rule public MllpServerResource mllpServer=new MllpServerResource("localhost",AvailablePortFinder.getNextAvailable());
  @EndpointInject(uri="direct://source") ProducerTemplate source;
  @EndpointInject(uri="mock://complete") MockEndpoint complete;
  @EndpointInject(uri="mock://write-ex") MockEndpoint writeEx;
  @EndpointInject(uri="mock://receive-ex") MockEndpoint receiveEx;
  @Override protected CamelContext createCamelContext() throws Exception {
    DefaultCamelContext context=(DefaultCamelContext)super.createCamelContext();
    context.setUseMDCLogging(true);
    context.setName(this.getClass().getSimpleName());
    return context;
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      String routeId="mllp-sender";
      public void configure(){
        onException(MllpWriteException.class).handled(true).to(writeEx).log(LoggingLevel.ERROR,routeId,"Write Error").stop();
        onException(MllpAcknowledgementReceiveException.class).handled(true).to(receiveEx).log(LoggingLevel.ERROR,routeId,"Receive Error").stop();
        from(source.getDefaultEndpoint()).routeId(routeId).log(LoggingLevel.INFO,routeId,"Sending Message").toF("mllp://%s:%d?connectTimeout=%d&receiveTimeout=%d&readTimeout=%d&idleTimeout=%s",mllpServer.getListenHost(),mllpServer.getListenPort(),CONNECT_TIMEOUT,RECEIVE_TIMEOUT,READ_TIMEOUT,IDLE_TIMEOUT).log(LoggingLevel.INFO,routeId,"Received Acknowledgement").to(complete);
      }
    }
;
  }
  @Test(expected=MllpJUnitResourceException.class) public void testIdleConnectionTimeout() throws Exception {
    complete.expectedMessageCount(2);
    writeEx.expectedMessageCount(0);
    receiveEx.expectedMessageCount(0);
    NotifyBuilder done=new NotifyBuilder(context).whenCompleted(2).create();
    source.sendBody(Hl7TestMessageGenerator.generateMessage());
    Thread.sleep(IDLE_TIMEOUT / 2);
    source.sendBody(Hl7TestMessageGenerator.generateMessage());
    assertTrue("Should have completed two exchanges",done.matches(5,TimeUnit.SECONDS));
    assertMockEndpointsSatisfied(5,TimeUnit.SECONDS);
    Thread.sleep((long)(IDLE_TIMEOUT * 1.1));
    mllpServer.checkClientConnections();
  }
  @Test public void testReconnectAfterIdleConnectionTimeout() throws Exception {
    complete.expectedMessageCount(3);
    writeEx.expectedMessageCount(0);
    receiveEx.expectedMessageCount(0);
    NotifyBuilder done=new NotifyBuilder(context).whenCompleted(2).create();
    source.sendBody(Hl7TestMessageGenerator.generateMessage());
    Thread.sleep(IDLE_TIMEOUT / 2);
    source.sendBody(Hl7TestMessageGenerator.generateMessage());
    assertTrue("Should have completed two exchanges",done.matches(5,TimeUnit.SECONDS));
    Thread.sleep((long)(IDLE_TIMEOUT * 1.1));
    try {
      mllpServer.checkClientConnections();
      fail("Should receive and exception for the closed connection");
    }
 catch (    MllpJUnitResourceException expectedEx) {
    }
    source.sendBody(Hl7TestMessageGenerator.generateMessage());
    assertMockEndpointsSatisfied(5,TimeUnit.SECONDS);
    log.debug("Breakpoint");
  }
}
