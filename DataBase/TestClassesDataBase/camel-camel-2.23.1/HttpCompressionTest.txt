/** 
 * @version
 */
public class HttpCompressionTest extends BaseHttpTest {
  private HttpServer localServer;
  @Before @Override public void setUp() throws Exception {
    Map<String,String> expectedHeaders=new HashMap<>();
    expectedHeaders.put("Content-Type","text/plain");
    expectedHeaders.put("Content-Encoding","gzip");
    localServer=ServerBootstrap.bootstrap().setHttpProcessor(getBasicHttpProcessor()).setConnectionReuseStrategy(getConnectionReuseStrategy()).setResponseFactory(getHttpResponseFactory()).setExpectationVerifier(getHttpExpectationVerifier()).setSslContext(getSSLContext()).registerHandler("/",new HeaderValidationHandler("POST",null,getBody(),getExpectedContent(),expectedHeaders)).create();
    localServer.start();
    super.setUp();
  }
  @After @Override public void tearDown() throws Exception {
    super.tearDown();
    if (localServer != null) {
      localServer.stop();
    }
  }
  @Test public void compressedHttpPost() throws Exception {
    Exchange exchange=template.request("http4://" + localServer.getInetAddress().getHostName() + ":"+ localServer.getLocalPort()+ "/",new Processor(){
      public void process(      Exchange exchange) throws Exception {
        exchange.getIn().setHeader(Exchange.CONTENT_TYPE,"text/plain");
        exchange.getIn().setHeader(Exchange.CONTENT_ENCODING,"gzip");
        exchange.getIn().setBody(getBody());
      }
    }
);
    assertNotNull(exchange);
    Message out=exchange.getOut();
    assertNotNull(out);
    Map<String,Object> headers=out.getHeaders();
    assertEquals(HttpStatus.SC_OK,headers.get(Exchange.HTTP_RESPONSE_CODE));
    assertBody(out.getBody(String.class));
  }
  @Override protected HttpProcessor getBasicHttpProcessor(){
    List<HttpRequestInterceptor> requestInterceptors=new ArrayList<>();
    requestInterceptors.add(new RequestDecompressingInterceptor());
    List<HttpResponseInterceptor> responseInterceptors=new ArrayList<>();
    responseInterceptors.add(new ResponseCompressingInterceptor());
    responseInterceptors.add(new ResponseBasicUnauthorized());
    ImmutableHttpProcessor httpproc=new ImmutableHttpProcessor(requestInterceptors,responseInterceptors);
    return httpproc;
  }
  protected String getBody(){
    return "hl=en&q=camel";
  }
static class RequestDecompressingInterceptor implements HttpRequestInterceptor {
    public void process(    HttpRequest request,    HttpContext context) throws HttpException, IOException {
      Header contentEncoding=request.getFirstHeader("Content-Encoding");
      if (contentEncoding != null && contentEncoding.getValue().equalsIgnoreCase("gzip")) {
        HttpEntity entity=((HttpEntityEnclosingRequest)request).getEntity();
        ((HttpEntityEnclosingRequest)request).setEntity(new GzipDecompressingEntity(entity));
      }
    }
static class GzipDecompressingEntity extends HttpEntityWrapper {
      GzipDecompressingEntity(      final HttpEntity entity){
        super(entity);
      }
      @Override public InputStream getContent() throws IOException, IllegalStateException {
        InputStream wrappedin=wrappedEntity.getContent();
        return new GZIPInputStream(wrappedin);
      }
      @Override public long getContentLength(){
        return -1;
      }
      @Override public boolean isStreaming(){
        return false;
      }
    }
  }
static class ResponseCompressingInterceptor implements HttpResponseInterceptor {
    public void process(    HttpResponse response,    HttpContext context) throws HttpException, IOException {
      response.setHeader("Content-Encoding","gzip");
      HttpEntity entity=response.getEntity();
      response.setEntity(new GzipCompressingEntity(entity));
    }
static class GzipCompressingEntity extends HttpEntityWrapper {
      GzipCompressingEntity(      final HttpEntity entity){
        super(entity);
      }
      @Override public Header getContentEncoding(){
        return new BasicHeader("Content-Encoding","gzip");
      }
      @Override public void writeTo(      OutputStream outstream) throws IOException {
        GZIPOutputStream gzip=new GZIPOutputStream(outstream);
        gzip.write(EntityUtils.toByteArray(wrappedEntity));
        gzip.close();
      }
      @Override public long getContentLength(){
        return -1;
      }
      @Override public boolean isStreaming(){
        return false;
      }
    }
  }
}
