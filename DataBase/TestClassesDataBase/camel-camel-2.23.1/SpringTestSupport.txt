/** 
 * @version 
 */
public abstract class SpringTestSupport extends ContextTestSupport {
  protected AbstractXmlApplicationContext applicationContext;
  protected abstract AbstractXmlApplicationContext createApplicationContext();
  @Before @SuppressWarnings("deprecation") @Override public void setUp() throws Exception {
    if (isLazyLoadingTypeConverter()) {
      System.setProperty(AbstractCamelContextFactoryBean.LAZY_LOAD_TYPE_CONVERTERS,"true");
    }
 else {
      System.setProperty(AbstractCamelContextFactoryBean.LAZY_LOAD_TYPE_CONVERTERS,"false");
    }
    System.setProperty("CamelSedaPollTimeout","10");
    if (!this.useJmx()) {
      this.disableJMX();
    }
 else {
      this.enableJMX();
    }
    applicationContext=createApplicationContext();
    assertNotNull("Should have created a valid spring context",applicationContext);
    super.setUp();
  }
  @After @Override public void tearDown() throws Exception {
    super.tearDown();
    IOHelper.close(applicationContext);
  }
private static class ExcludingPackageScanClassResolver extends DefaultPackageScanClassResolver {
    public void setExcludedClasses(    Set<Class<?>> excludedClasses){
      if (excludedClasses == null) {
        excludedClasses=Collections.emptySet();
      }
      addFilter(new InvertingPackageScanFilter(new AssignableToPackageScanFilter(excludedClasses)));
    }
  }
  /** 
 * Create a parent context that initializes a {@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes frombeing resolved. Typically this is used at test time to exclude certain routes, which might otherwise be just noisy, from being discovered and initialized. <p/> To use this filtering mechanism it is necessary to provide the {@link ApplicationContext} returned from here as the parent context toyour test context e.g. <pre> protected AbstractXmlApplicationContext createApplicationContext() { return new ClassPathXmlApplicationContext(new String[] {&quot;test-context.xml&quot;}, getRouteExcludingApplicationContext()); } </pre> This will, in turn, call the template methods <code>excludedRoutes</code> and <code>excludedRoute</code> to determine the classes to be excluded from scanning.
 * @see org.apache.camel.spring.config.scan.SpringComponentScanTest for an example.
 * @return ApplicationContext a parent {@link ApplicationContext} configuredto exclude certain classes from package scanning
 */
  protected ApplicationContext getRouteExcludingApplicationContext(){
    GenericApplicationContext routeExcludingContext=new GenericApplicationContext();
    routeExcludingContext.registerBeanDefinition("excludingResolver",new RootBeanDefinition(ExcludingPackageScanClassResolver.class));
    routeExcludingContext.refresh();
    ExcludingPackageScanClassResolver excludingResolver=routeExcludingContext.getBean("excludingResolver",ExcludingPackageScanClassResolver.class);
    List<Class<?>> excluded=Arrays.asList(excludeRoutes());
    excludingResolver.setExcludedClasses(new HashSet<>(excluded));
    return routeExcludingContext;
  }
  /** 
 * Template method used to exclude  {@link org.apache.camel.Route} from the test time contextroute scanning
 * @return Class[] the classes to be excluded from test time context route scanning
 */
  protected Class<?>[] excludeRoutes(){
    Class<?> excludedRoute=excludeRoute();
    return excludedRoute != null ? new Class[]{excludedRoute} : new Class[0];
  }
  /** 
 * Template method used to exclude a  {@link org.apache.camel.Route} from the test camel context
 */
  protected Class<?> excludeRoute(){
    return null;
  }
  /** 
 * Looks up the mandatory spring bean of the given name and type, failing if it is not present or the correct type
 */
  public <T>T getMandatoryBean(  Class<T> type,  String name){
    T value=applicationContext.getBean(name,type);
    assertNotNull("No spring bean found for name <" + name + ">",value);
    return value;
  }
  @SuppressWarnings("deprecation") @Override protected CamelContext createCamelContext() throws Exception {
    CamelContext context=SpringCamelContext.springCamelContext(applicationContext);
    context.setLazyLoadTypeConverters(isLazyLoadingTypeConverter());
    return context;
  }
}
