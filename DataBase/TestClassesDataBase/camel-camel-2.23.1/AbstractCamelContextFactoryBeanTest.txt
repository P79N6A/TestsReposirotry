public class AbstractCamelContextFactoryBeanTest {
  Set<String> propertiesThatAreNotPlaceholdered=Collections.singleton("{{getErrorHandlerRef}}");
  TypeConverter typeConverter=new DefaultTypeConverter(new DefaultPackageScanClassResolver(),new ReflectionInjector(),new DefaultFactoryFinder(new DefaultClassResolver(),"META-INF/services/org/apache/camel/"),false);
  Set<String> valuesThatReturnBoolean=new HashSet<>(asList("{{getStreamCache}}","{{getTrace}}","{{getMessageHistory}}","{{getLogMask}}","{{getLogExhaustedMessageBody}}","{{getHandleFault}}","{{getAutoStartup}}","{{getUseMDCLogging}}","{{getUseDataType}}","{{getUseBreadcrumb}}","{{getAllowUseOriginalMessage}}"));
  Set<String> valuesThatReturnLong=new HashSet<>(asList("{{getDelayer}}"));
  public AbstractCamelContextFactoryBeanTest() throws Exception {
    ((Service)typeConverter).start();
  }
  @Test public void shouldSupportPropertyPlaceholdersOnAllProperties() throws Exception {
    final Set<Invocation> invocations=new LinkedHashSet<>();
    final ModelCamelContext context=mock(ModelCamelContext.class,withSettings().invocationListeners(i -> invocations.add((Invocation)i.getInvocation())));
    when(context.resolvePropertyPlaceholders(anyString())).thenAnswer(invocation -> {
      final String placeholder=invocation.getArgument(0);
      if (valuesThatReturnBoolean.contains(placeholder) || placeholder.endsWith("Enabled}}")) {
        return "true";
      }
      if (valuesThatReturnLong.contains(placeholder)) {
        return "1";
      }
      return "string";
    }
);
    when(context.getTypeConverter()).thenReturn(typeConverter);
    when(context.getRuntimeEndpointRegistry()).thenReturn(mock(RuntimeEndpointRegistry.class));
    when(context.getManagementNameStrategy()).thenReturn(mock(ManagementNameStrategy.class));
    when(context.getExecutorServiceManager()).thenReturn(mock(ExecutorServiceManager.class));
    @SuppressWarnings("unchecked") final AbstractCamelContextFactoryBean<ModelCamelContext> factory=mock(AbstractCamelContextFactoryBean.class);
    when(factory.getContext()).thenReturn(context);
    doCallRealMethod().when(factory).initCamelContext(context);
    final Set<String> expectedPropertiesToBeResolved=propertiesToBeResolved(factory);
    factory.initCamelContext(context);
    final ArgumentCaptor<String> capturedPlaceholders=ArgumentCaptor.forClass(String.class);
    verify(context,atLeastOnce()).resolvePropertyPlaceholders(capturedPlaceholders.capture());
    expectedPropertiesToBeResolved.removeAll(propertiesThatAreNotPlaceholdered);
    assertThat(capturedPlaceholders.getAllValues()).as("The expectation is that all abstract getter methods that return Strings should support property " + "placeholders, and that for those will delegate to CamelContext::resolvePropertyPlaceholders, " + "we captured all placeholders that tried to resolve and found differences").containsAll(expectedPropertiesToBeResolved);
  }
  Set<String> propertiesToBeResolved(  final AbstractCamelContextFactoryBean<ModelCamelContext> factory){
    final Set<String> expectedPropertiesToBeResolved=new HashSet<>();
    stream(AbstractCamelContextFactoryBean.class.getDeclaredMethods()).filter(m -> Modifier.isAbstract(m.getModifiers()) && m.getParameterCount() == 0).forEach(m -> {
      try {
        when(m.invoke(factory)).thenAnswer(invocation -> {
          final Method method=invocation.getMethod();
          final String name=method.getName();
          if (String.class.equals(method.getReturnType())) {
            final String placeholder="{{" + name + "}}";
            expectedPropertiesToBeResolved.add(placeholder);
            return placeholder;
          }
          return null;
        }
);
      }
 catch (      IllegalAccessException|IllegalArgumentException|InvocationTargetException ignored) {
      }
    }
);
    return expectedPropertiesToBeResolved;
  }
  static boolean shouldProvidePropertyPlaceholderSupport(  final Method method){
    final boolean isAbstract=Modifier.isAbstract(method.getModifiers());
    final boolean isGetter=method.getName().startsWith("get");
    final Class<?> returnType=method.getReturnType();
    final boolean isCompatibleReturnType=String.class.isAssignableFrom(returnType);
    return isAbstract && isGetter && isCompatibleReturnType;
  }
}
