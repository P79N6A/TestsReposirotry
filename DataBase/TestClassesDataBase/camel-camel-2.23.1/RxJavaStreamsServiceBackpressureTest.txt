public class RxJavaStreamsServiceBackpressureTest extends RxJavaStreamsServiceTestSupport {
  @Test public void testBufferStrategy() throws Exception {
    getReactiveStreamsComponent().setBackpressureStrategy(ReactiveStreamsBackpressureStrategy.BUFFER);
    context.addRoutes(new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers");
      }
    }
);
    Flowable<Integer> integers=Flowable.fromPublisher(crs.fromStream("integers",Integer.class));
    ConcurrentLinkedQueue<Integer> queue=new ConcurrentLinkedQueue<>();
    CountDownLatch latch=new CountDownLatch(1);
    Flowable.range(0,50).zipWith(integers,(l,i) -> i).timeout(2000,TimeUnit.MILLISECONDS,Flowable.empty()).doOnComplete(latch::countDown).subscribe(queue::add);
    context.start();
    Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
    Assert.assertEquals(20,queue.size());
    int num=1;
    for (    int i : queue) {
      Assert.assertEquals(num++,i);
    }
  }
  @Test public void testDropStrategy() throws Exception {
    getReactiveStreamsComponent().setBackpressureStrategy(ReactiveStreamsBackpressureStrategy.OLDEST);
    context.addRoutes(new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers");
      }
    }
);
    final ConcurrentLinkedQueue<Integer> queue=new ConcurrentLinkedQueue<>();
    final CountDownLatch latch=new CountDownLatch(1);
    final CountDownLatch latch2=new CountDownLatch(2);
    TestSubscriber<Integer> subscriber=new TestSubscriber<Integer>(){
      @Override public void onNext(      Integer o){
        queue.add(o);
        latch.countDown();
        latch2.countDown();
      }
    }
;
    subscriber.setInitiallyRequested(1);
    crs.fromStream("integers",Integer.class).subscribe(subscriber);
    context.start();
    Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
    Thread.sleep(1000);
    subscriber.request(19);
    Assert.assertTrue(latch2.await(1,TimeUnit.SECONDS));
    Thread.sleep(200);
    Assert.assertEquals(2,queue.size());
    int sum=queue.stream().reduce((i,j) -> i + j).get();
    Assert.assertEquals(3,sum);
    subscriber.cancel();
  }
  @Test public void testLatestStrategy() throws Exception {
    getReactiveStreamsComponent().setBackpressureStrategy(ReactiveStreamsBackpressureStrategy.LATEST);
    context.addRoutes(new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers");
      }
    }
);
    final ConcurrentLinkedQueue<Integer> queue=new ConcurrentLinkedQueue<>();
    final CountDownLatch latch1=new CountDownLatch(1);
    final CountDownLatch latch2=new CountDownLatch(2);
    TestSubscriber<Integer> subscriber=new TestSubscriber<Integer>(){
      @Override public void onNext(      Integer o){
        queue.add(o);
        latch1.countDown();
        latch2.countDown();
      }
    }
;
    subscriber.setInitiallyRequested(1);
    crs.fromStream("integers",Integer.class).subscribe(subscriber);
    context.start();
    Assert.assertTrue(latch1.await(5,TimeUnit.SECONDS));
    Thread.sleep(1000);
    subscriber.request(19);
    Assert.assertTrue(latch2.await(1,TimeUnit.SECONDS));
    Thread.sleep(200);
    Assert.assertEquals(3,queue.size());
    int sum=queue.stream().reduce((i,j) -> i + j).get();
    Assert.assertEquals(23,sum);
    subscriber.cancel();
  }
}
