public class CacheInputStreamInDeadLetterIssue520Test extends ContextTestSupport {
  private int count;
  @Test public void testSendingInputStream() throws Exception {
    InputStream message=new ByteArrayInputStream("<hello>Willem</hello>".getBytes());
    sendingMessage(message);
  }
  @Test public void testSendingReader() throws Exception {
    StringReader message=new StringReader("<hello>Willem</hello>");
    sendingMessage(message);
  }
  @Test public void testSendingSource() throws Exception {
    StreamSource message=new StreamSource(new StringReader("<hello>Willem</hello>"));
    sendingMessage(message);
  }
  private void sendingMessage(  Object message) throws InterruptedException {
    count=0;
    MockEndpoint mock=getMockEndpoint("mock:error");
    mock.expectedMessageCount(1);
    template.sendBody("direct:start",message);
    assertEquals("The message should be delivered 4 times",count,4);
    mock.assertIsSatisfied();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      public void configure() throws Exception {
        context.setStreamCaching(true);
        errorHandler(deadLetterChannel("direct:errorHandler").maximumRedeliveries(3).redeliveryDelay(0));
        from("direct:start").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            count++;
            String result=exchange.getIn().getBody(String.class);
            assertEquals("Should read the inputstream out again","<hello>Willem</hello>",result);
            throw new Exception("Forced exception by unit test");
          }
        }
);
        from("direct:errorHandler").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            String result=exchange.getIn().getBody(String.class);
            assertEquals("Should read the inputstream out again","<hello>Willem</hello>",result);
          }
        }
).to("mock:error");
      }
    }
;
  }
}
