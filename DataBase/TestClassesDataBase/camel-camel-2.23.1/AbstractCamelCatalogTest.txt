public class AbstractCamelCatalogTest {
  AbstractCamelCatalog catalog=new AbstractCamelCatalog(){
  }
;
  JSonSchemaResolver resolver;
  @Before public void setupMockCatalog(){
    resolver=mock(JSonSchemaResolver.class);
    catalog.setJSonSchemaResolver(resolver);
  }
  @Test public void shouldConstructEndpointUris() throws URISyntaxException {
    when(resolver.getComponentJSonSchema("comp")).thenReturn("{\n" + "  \"component\": {\n" + "    \"syntax\": \"comp:param1:param2\"\n"+ "  }\n"+ "}");
    final Map<String,String> properties=new HashMap<>();
    properties.put("param1","value1");
    properties.put("param2","value2");
    properties.put("param3","value3");
    final String endpointUri=catalog.doAsEndpointUri("comp",properties,"&",false);
    assertEquals("comp:value1:value2?param3=value3",endpointUri);
  }
  @Test public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException {
    when(resolver.getComponentJSonSchema("comp")).thenReturn("{\n" + "  \"component\": {\n" + "    \"syntax\": \"comp:param1:param2\"\n"+ "  }\n"+ "}");
    final Map<String,String> properties=new HashMap<>();
    properties.put("param1","{{prop1}}");
    properties.put("param2","{{prop2}}");
    properties.put("param3","{{prop3}}");
    final String endpointUri=catalog.doAsEndpointUri("comp",properties,"&",false);
    assertEquals("comp:{{prop1}}:{{prop2}}?param3={{prop3}}",endpointUri);
  }
  @Test public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException {
    when(resolver.getComponentJSonSchema("comp")).thenReturn("{\n" + "  \"component\": {\n" + "    \"syntax\": \"comp:param1:param2\"\n"+ "  }\n"+ "}");
    final Map<String,String> properties=new HashMap<>();
    properties.put("param1","{value1}");
    properties.put("param2","/value2/");
    properties.put("param3","/value3/{param}");
    final String endpointUri=catalog.doAsEndpointUri("comp",properties,"&",false);
    assertEquals("comp:{value1}:/value2/?param3=/value3/{param}",endpointUri);
  }
  @Test public void shouldContextPathAndQuery() throws URISyntaxException {
    when(resolver.getComponentJSonSchema("comp")).thenReturn("{\n" + "  \"component\": {\n" + "    \"syntax\": \"comp:value1\"\n"+ "  }\n"+ "}");
    final Map<String,String> properties=new HashMap<>();
    properties.put("value1","camel");
    properties.put("foo","123");
    final String endpointUri=catalog.doAsEndpointUri("comp",properties,"&",false);
    assertEquals("comp:camel?foo=123",endpointUri);
  }
  @Test public void shouldEmptyContextPath() throws URISyntaxException {
    when(resolver.getComponentJSonSchema("comp")).thenReturn("{\n" + "  \"component\": {\n" + "    \"syntax\": \"comp\"\n"+ "  }\n"+ "}");
    final Map<String,String> properties=new HashMap<>();
    final String endpointUri=catalog.doAsEndpointUri("comp",properties,"&",false);
    assertEquals("comp",endpointUri);
  }
  @Test public void shouldEmptyContextPathWithQuery() throws URISyntaxException {
    when(resolver.getComponentJSonSchema("comp")).thenReturn("{\n" + "  \"component\": {\n" + "    \"syntax\": \"comp\"\n"+ "  }\n"+ "}");
    final Map<String,String> properties=new HashMap<>();
    properties.put("foo","123");
    final String endpointUri=catalog.doAsEndpointUri("comp",properties,"&",false);
    assertEquals("comp?foo=123",endpointUri);
  }
}
