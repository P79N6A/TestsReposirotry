/** 
 * @version 
 */
public class SplitterTest extends ContextTestSupport {
  @Test public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedBodiesReceived("James","Guillaume","Hiram","Rob");
    template.send("direct:seqential",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody("James,Guillaume,Hiram,Rob");
        in.setHeader("foo","bar");
      }
    }
);
    assertMockEndpointsSatisfied();
    Set<String> ids=new HashSet<>();
    Set<String> ids2=new HashSet<>();
    List<Exchange> list=resultEndpoint.getReceivedExchanges();
    for (int i=0; i < 4; i++) {
      Exchange exchange=list.get(i);
      Message in=exchange.getIn();
      ids.add(in.getMessageId());
      ids2.add(exchange.getExchangeId());
      assertNotNull("The in message should not be null.",in);
      assertProperty(exchange,Exchange.SPLIT_INDEX,i);
      assertProperty(exchange,Exchange.SPLIT_SIZE,4);
    }
    assertEquals("The sub messages should have unique message ids",4,ids.size());
    assertEquals("The sub messages should have unique exchange ids",4,ids2.size());
  }
  @Test public void testSplitterWithAggregationStrategy() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedBodiesReceived("James","Guillaume","Hiram","Rob","Roman");
    Exchange result=template.request("direct:seqential",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody("James,Guillaume,Hiram,Rob,Roman");
        in.setHeader("foo","bar");
      }
    }
);
    assertMockEndpointsSatisfied();
    Message out=result.getOut();
    assertEquals("Roman",out.getBody());
    assertMessageHeader(out,"foo","bar");
    assertProperty(result,Exchange.SPLIT_INDEX,4);
  }
  @Test public void testEmptyBody(){
    Exchange result=template.request("direct:seqential",new Processor(){
      public void process(      Exchange exchange) throws Exception {
        exchange.getIn().setHeader("foo","bar");
      }
    }
);
    assertFalse("Should not have out",result.hasOut());
  }
  @Test public void testSendingAMessageUsingMulticastReceivesItsOwnExchangeParallel() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectsNoDuplicates(body());
    resultEndpoint.expectedMessageCount(4);
    template.send("direct:parallel",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody("James,Guillaume,Hiram,Rob");
        in.setHeader("foo","bar");
      }
    }
);
    assertMockEndpointsSatisfied();
    List<Exchange> list=resultEndpoint.getReceivedExchanges();
    Set<Integer> numbersFound=new TreeSet<>();
    final String[] names={"James","Guillaume","Hiram","Rob"};
    for (int i=0; i < 4; i++) {
      Exchange exchange=list.get(i);
      Message in=exchange.getIn();
      Integer splitCounter=exchange.getProperty(Exchange.SPLIT_INDEX,Integer.class);
      numbersFound.add(splitCounter);
      assertEquals(names[splitCounter],in.getBody());
      assertProperty(exchange,Exchange.SPLIT_SIZE,4);
    }
    assertEquals(4,numbersFound.size());
  }
  @Test public void testSplitterWithAggregationStrategyParallel() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(5);
    Exchange result=template.request("direct:parallel",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody("James,Guillaume,Hiram,Rob,Roman");
        in.setHeader("foo","bar");
      }
    }
);
    assertMockEndpointsSatisfied();
    Message out=result.getOut();
    assertMessageHeader(out,"foo","bar");
    assertEquals((Integer)5,result.getProperty("aggregated",Integer.class));
  }
  @Test public void testSplitterWithAggregationStrategyParallelStreaming() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(5);
    resultEndpoint.expectedBodiesReceivedInAnyOrder("James","Guillaume","Hiram","Rob","Roman");
    Exchange result=template.request("direct:parallel-streaming",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody("James,Guillaume,Hiram,Rob,Roman");
        in.setHeader("foo","bar");
      }
    }
);
    assertMockEndpointsSatisfied();
    Message out=result.getOut();
    assertMessageHeader(out,"foo","bar");
    assertEquals((Integer)5,result.getProperty("aggregated",Integer.class));
  }
  @Test public void testSplitterParallelAggregate() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(5);
    resultEndpoint.expectedBodiesReceivedInAnyOrder("James","Guillaume","Hiram","Rob","Roman");
    Exchange result=template.request("direct:parallelAggregate",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody("James,Guillaume,Hiram,Rob,Roman");
        in.setHeader("foo","bar");
      }
    }
);
    assertMockEndpointsSatisfied();
    Message out=result.getOut();
    assertMessageHeader(out,"foo","bar");
  }
  @Test public void testSplitterWithStreamingAndFileBody() throws Exception {
    URL url=this.getClass().getResource("/org/apache/camel/processor/simple.txt");
    assertNotNull("We should find this simple file here.",url);
    File file=new File(url.getFile());
    sendToSplitterWithStreaming(file);
  }
  @Test public void testSplitterWithStreamingAndStringBody() throws Exception {
    sendToSplitterWithStreaming("James,Guillaume,Hiram,Rob,Roman");
  }
  public void sendToSplitterWithStreaming(  final Object body) throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(5);
    resultEndpoint.expectedHeaderReceived("foo","bar");
    template.request("direct:streaming",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody(body);
        in.setHeader("foo","bar");
      }
    }
);
    assertMockEndpointsSatisfied();
    int size=resultEndpoint.getReceivedExchanges().size();
    for (int i=0; i < size; i++) {
      Exchange exchange=resultEndpoint.getReceivedExchanges().get(i);
      assertEquals(i,exchange.getProperty(Exchange.SPLIT_INDEX));
      if (i < (size - 1)) {
        assertEquals(Boolean.FALSE,exchange.getProperty(Exchange.SPLIT_COMPLETE));
        assertNull(exchange.getProperty(Exchange.SPLIT_SIZE));
      }
 else {
        assertEquals(Boolean.TRUE,exchange.getProperty(Exchange.SPLIT_COMPLETE));
        assertEquals(size,exchange.getProperty(Exchange.SPLIT_SIZE));
      }
    }
  }
  @Test public void testSplitterWithException() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(4);
    resultEndpoint.expectedHeaderReceived("foo","bar");
    MockEndpoint failedEndpoint=getMockEndpoint("mock:failed");
    failedEndpoint.expectedMessageCount(1);
    failedEndpoint.expectedHeaderReceived("foo","bar");
    Exchange result=template.request("direct:exception",new Processor(){
      public void process(      Exchange exchange){
        Message in=exchange.getIn();
        in.setBody("James,Guillaume,Hiram,Rob,Exception");
        in.setHeader("foo","bar");
      }
    }
);
    assertTrue("The result exchange should have a camel exception",result.getException() instanceof CamelException);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSplitterWithIterable() throws Exception {
    MockEndpoint resultEndpoint=getMockEndpoint("mock:result");
    resultEndpoint.expectedMessageCount(4);
    resultEndpoint.expectedBodiesReceived("A","B","C","D");
    final List<String> data=Arrays.asList("A","B","C","D");
    Iterable<String> itb=new Iterable<String>(){
      public Iterator<String> iterator(){
        return data.iterator();
      }
    }
;
    sendBody("direct:simple",itb);
    resultEndpoint.assertIsSatisfied();
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        onException(CamelException.class).to("mock:failed");
        from("direct:seqential").split(body().tokenize(","),new UseLatestAggregationStrategy()).to("mock:result");
        from("direct:parallel").split(body().tokenize(","),new MyAggregationStrategy()).parallelProcessing().to("mock:result");
        from("direct:parallelAggregate").split(body().tokenize(","),new MyAggregationStrategy()).parallelProcessing().parallelAggregate().to("mock:result");
        from("direct:streaming").split(body().tokenize(",")).streaming().to("mock:result");
        from("direct:parallel-streaming").split(body().tokenize(","),new MyAggregationStrategy()).parallelProcessing().streaming().to("mock:result");
        from("direct:exception").split(body().tokenize(",")).aggregationStrategy(new MyAggregationStrategy()).parallelProcessing().process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            String string=exchange.getIn().getBody(String.class);
            if ("Exception".equals(string)) {
              throw new CamelException("Just want to throw exception here");
            }
          }
        }
).to("mock:result");
        from("direct:simple").split(body()).to("mock:result");
      }
    }
;
  }
}
