public class JdbcAggregateLoadAndRecoverTest extends AbstractJdbcAggregationTestSupport {
  private static final Logger LOG=LoggerFactory.getLogger(JdbcAggregateLoadAndRecoverTest.class);
  private static final int SIZE=200;
  private static AtomicInteger counter=new AtomicInteger();
  @Test public void testLoadAndRecoverJdbcAggregate() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(SIZE / 10);
    mock.setResultWaitTime(50 * 1000);
    LOG.info("Staring to send " + SIZE + " messages.");
    for (int i=0; i < SIZE; i++) {
      final int value=1;
      char id='A';
      Map<String,Object> headers=new HashMap<>();
      headers.put("id",id);
      headers.put("seq",i);
      LOG.debug("Sending {} with id {}",value,id);
      template.sendBodyAndHeaders("seda:start?size=" + SIZE,value,headers);
      Thread.sleep(3);
    }
    LOG.info("Sending all " + SIZE + " message done. Now waiting for aggregation to complete.");
    assertMockEndpointsSatisfied();
    int recovered=0;
    for (    Exchange exchange : mock.getReceivedExchanges()) {
      if (exchange.getIn().getHeader(Exchange.REDELIVERED) != null) {
        recovered++;
      }
    }
    int expected=SIZE / 10 / 10;
    assertEquals("There should be " + expected + " recovered",expected,recovered);
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("seda:start?size=" + SIZE).to("log:input?groupSize=500").aggregate(header("id"),new MyAggregationStrategy()).aggregationRepository(repo).completionSize(10).to("log:output?showHeaders=true").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            if (exchange.getIn().getHeader(Exchange.REDELIVERED) == null) {
              int num=counter.incrementAndGet();
              if (num % 10 == 0) {
                throw new IllegalStateException("Failed for num " + num);
              }
            }
          }
        }
).to("mock:result").end();
      }
    }
;
  }
}
