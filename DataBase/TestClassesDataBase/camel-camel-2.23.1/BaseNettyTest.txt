/** 
 */
public class BaseNettyTest extends CamelTestSupport {
  protected static final Logger LOG=LoggerFactory.getLogger(BaseNettyTest.class);
  private static volatile int port;
  @BeforeClass public static void initPort() throws Exception {
    File file=new File("target/nettyport.txt");
    if (!file.exists()) {
      port=AvailablePortFinder.getNextAvailable(26000);
    }
 else {
      String s=IOConverter.toString(file,null);
      port=Integer.parseInt(s);
      port=AvailablePortFinder.getNextAvailable(port + 1);
    }
  }
  @AfterClass public static void savePort() throws Exception {
    File file=new File("target/nettyport.txt");
    FileOutputStream fos=new FileOutputStream(file,false);
    try {
      fos.write(String.valueOf(port).getBytes());
    }
  finally {
      fos.close();
    }
  }
  @BeforeClass public static void startLeakDetection(){
    System.setProperty("io.netty.leakDetection.maxRecords","100");
    System.setProperty("io.netty.leakDetection.acquireAndReleaseOnly","true");
    ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);
  }
  @AfterClass public static void verifyNoLeaks() throws Exception {
    System.gc();
    ByteBufAllocator.DEFAULT.buffer(1).release();
    Collection<LogEvent> events=LogCaptureAppender.getEvents();
    if (!events.isEmpty()) {
      String message="Leaks detected while running tests: " + events;
      for (      LogEvent event : events) {
        LOG.info(event.getMessage().getFormattedMessage());
      }
      LogCaptureAppender.reset();
      throw new AssertionError(message);
    }
  }
  @Override protected CamelContext createCamelContext() throws Exception {
    CamelContext context=super.createCamelContext();
    context.addComponent("properties",new PropertiesComponent("ref:prop"));
    return context;
  }
  @Override protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry jndi=super.createRegistry();
    Properties prop=new Properties();
    prop.setProperty("port","" + getPort());
    jndi.bind("prop",prop);
    return jndi;
  }
  protected int getNextPort(){
    port=AvailablePortFinder.getNextAvailable(port + 1);
    return port;
  }
  protected int getPort(){
    return port;
  }
}
