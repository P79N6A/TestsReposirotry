/** 
 * @version 
 */
public class ValidationTest extends ContextTestSupport {
  protected Processor validator=new MyValidator();
  protected MockEndpoint validEndpoint;
  protected MockEndpoint invalidEndpoint;
  @Test public void testValidMessage() throws Exception {
    validEndpoint.expectedMessageCount(1);
    invalidEndpoint.expectedMessageCount(0);
    Object result=template.requestBodyAndHeader("direct:start","<valid/>","foo","bar");
    assertEquals("validResult",result);
    assertMockEndpointsSatisfied();
  }
  @Test public void testInvalidMessage() throws Exception {
    validEndpoint.expectedMessageCount(0);
    invalidEndpoint.expectedMessageCount(1);
    try {
      template.sendBodyAndHeader("direct:start","<invalid/>","foo","notMatchedHeaderValue");
    }
 catch (    RuntimeCamelException e) {
    }
    assertMockEndpointsSatisfied();
  }
  @Test public void testinvalidThenValidMessage() throws Exception {
    validEndpoint.expectedMessageCount(2);
    invalidEndpoint.expectedMessageCount(1);
    try {
      template.sendBodyAndHeader("direct:start","<invalid/>","foo","notMatchedHeaderValue");
    }
 catch (    RuntimeCamelException e) {
    }
    Object result=template.requestBodyAndHeader("direct:start","<valid/>","foo","bar");
    assertEquals("validResult",result);
    result=template.requestBodyAndHeader("direct:start","<valid/>","foo","bar");
    assertEquals("validResult",result);
    assertMockEndpointsSatisfied();
  }
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    validEndpoint=resolveMandatoryEndpoint("mock:valid",MockEndpoint.class);
    invalidEndpoint=resolveMandatoryEndpoint("mock:invalid",MockEndpoint.class);
    validEndpoint.whenAnyExchangeReceived(ProcessorBuilder.setBody(Builder.constant("validResult")));
    invalidEndpoint.whenAnyExchangeReceived(ProcessorBuilder.setBody(Builder.constant("invalidResult")));
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        from("direct:start").doTry().process(validator).to("mock:valid").doCatch(ValidationException.class).to("mock:invalid");
      }
    }
;
  }
}
