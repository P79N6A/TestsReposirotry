public class ShiroAuthenticationTest extends CamelTestSupport {
  @EndpointInject(uri="mock:success") protected MockEndpoint successEndpoint;
  @EndpointInject(uri="mock:authenticationException") protected MockEndpoint failureEndpoint;
  private byte[] passPhrase={(byte)0x08,(byte)0x09,(byte)0x0A,(byte)0x0B,(byte)0x0C,(byte)0x0D,(byte)0x0E,(byte)0x0F,(byte)0x10,(byte)0x11,(byte)0x12,(byte)0x13,(byte)0x14,(byte)0x15,(byte)0x16,(byte)0x17};
  @Test public void testShiroAuthenticationFailure() throws Exception {
    ShiroSecurityToken shiroSecurityToken=new ShiroSecurityToken("ringo","stirr");
    TestShiroSecurityTokenInjector shiroSecurityTokenInjector=new TestShiroSecurityTokenInjector(shiroSecurityToken,passPhrase);
    successEndpoint.expectedMessageCount(0);
    failureEndpoint.expectedMessageCount(1);
    template.send("direct:secureEndpoint",shiroSecurityTokenInjector);
    successEndpoint.assertIsSatisfied();
    failureEndpoint.assertIsSatisfied();
  }
  @Test public void testSuccessfulShiroAuthenticationWithNoAuthorization() throws Exception {
    ShiroSecurityToken shiroSecurityToken=new ShiroSecurityToken("ringo","starr");
    TestShiroSecurityTokenInjector shiroSecurityTokenInjector=new TestShiroSecurityTokenInjector(shiroSecurityToken,passPhrase);
    successEndpoint.expectedMessageCount(1);
    failureEndpoint.expectedMessageCount(0);
    template.send("direct:secureEndpoint",shiroSecurityTokenInjector);
    successEndpoint.assertIsSatisfied();
    failureEndpoint.assertIsSatisfied();
  }
  @Test public void testSuccessfulTokenHeader() throws Exception {
    ShiroSecurityToken shiroSecurityToken=new ShiroSecurityToken("ringo","starr");
    successEndpoint.expectedMessageCount(1);
    failureEndpoint.expectedMessageCount(0);
    template.sendBodyAndHeader("direct:secureEndpoint","Beatle Mania",ShiroSecurityConstants.SHIRO_SECURITY_TOKEN,shiroSecurityToken);
    successEndpoint.assertIsSatisfied();
    failureEndpoint.assertIsSatisfied();
  }
  @Test public void testSuccessfulUsernameHeader() throws Exception {
    successEndpoint.expectedMessageCount(1);
    failureEndpoint.expectedMessageCount(0);
    Map<String,Object> headers=new HashMap<>();
    headers.put(ShiroSecurityConstants.SHIRO_SECURITY_USERNAME,"ringo");
    headers.put(ShiroSecurityConstants.SHIRO_SECURITY_PASSWORD,"starr");
    template.sendBodyAndHeaders("direct:secureEndpoint","Beatle Mania",headers);
    successEndpoint.assertIsSatisfied();
    failureEndpoint.assertIsSatisfied();
  }
  protected RouteBuilder createRouteBuilder() throws Exception {
    final ShiroSecurityPolicy securityPolicy=new ShiroSecurityPolicy("src/test/resources/securityconfig.ini",passPhrase);
    return new RouteBuilder(){
      @SuppressWarnings("unchecked") public void configure(){
        onException(UnknownAccountException.class,IncorrectCredentialsException.class,LockedAccountException.class,AuthenticationException.class).to("mock:authenticationException");
        from("direct:secureEndpoint").policy(securityPolicy).to("log:incoming payload").to("mock:success");
      }
    }
;
  }
private static class TestShiroSecurityTokenInjector extends ShiroSecurityTokenInjector {
    TestShiroSecurityTokenInjector(    ShiroSecurityToken shiroSecurityToken,    byte[] bytes){
      super(shiroSecurityToken,bytes);
    }
    public void process(    Exchange exchange) throws Exception {
      exchange.getIn().setHeader(ShiroSecurityConstants.SHIRO_SECURITY_TOKEN,encrypt());
      exchange.getIn().setBody("Beatle Mania");
    }
  }
}
