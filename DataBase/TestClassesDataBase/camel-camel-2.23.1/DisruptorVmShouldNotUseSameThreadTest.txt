/** 
 * Unit test to verify continuing using NOT same thread on the consumer side.
 */
public class DisruptorVmShouldNotUseSameThreadTest extends AbstractVmTestSupport {
  private static long id;
  private final ThreadLocal<String> local=new ThreadLocal<>();
  @Test public void testNotUseSameThread() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Hello World");
    template2.sendBody("direct:start","Hello World");
    assertMockEndpointsSatisfied();
  }
  protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      public void configure() throws Exception {
        from("disruptor-vm:foo").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            assertNull(local.get());
            assertNotSame("Thread is should not be same",id,Thread.currentThread().getId());
          }
        }
).to("mock:result");
      }
    }
;
  }
  @Override protected RouteBuilder createRouteBuilderForSecondContext() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("direct:start").process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            local.set("Hello");
            id=Thread.currentThread().getId();
          }
        }
).to("disruptor-vm:foo");
      }
    }
;
  }
}
