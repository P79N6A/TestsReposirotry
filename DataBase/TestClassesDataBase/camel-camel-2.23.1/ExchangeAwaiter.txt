private static final class ExchangeAwaiter implements Processor {
  private CountDownLatch latch;
  private final int count;
  private long countDownReachedTime;
  private Queue<Long> latencyQueue=new ConcurrentLinkedQueue<>();
  ExchangeAwaiter(  final int count){
    this.count=count;
  }
  public void reset(){
    latencyQueue=new ConcurrentLinkedQueue<>();
    latch=new CountDownLatch(count);
    countDownReachedTime=0;
  }
  public boolean awaitMessagesReceived(  final long timeout,  final TimeUnit unit) throws InterruptedException {
    return latch.await(timeout,unit);
  }
  public String getStatus(){
    final StringBuilder sb=new StringBuilder(100);
    sb.append("processed ");
    sb.append(count - latch.getCount());
    sb.append('/');
    sb.append(count);
    sb.append(" messages");
    return sb.toString();
  }
  @Override public void process(  final Exchange exchange) throws Exception {
    final long sentTimeNs=exchange.getIn().getBody(Long.class);
    latencyQueue.offer(Long.valueOf(System.nanoTime() - sentTimeNs));
    countDownReachedTime=System.currentTimeMillis();
    latch.countDown();
  }
  public long getCountDownReachedTime(){
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      countDownReachedTime=0;
    }
    return countDownReachedTime;
  }
  public Histogram getLatencyHistogram(){
    final Histogram histogram=new Histogram(LATENCY_HISTOGRAM_BOUNDS[LATENCY_HISTOGRAM_BOUNDS.length - 1],4);
    for (    final Long latencyValue : latencyQueue) {
      histogram.recordValue(latencyValue / 1000000);
    }
    return histogram;
  }
}
