/** 
 * Unit test to verify *NON* exclusive read.
 */
public class FromFtpExclusiveReadNoneStrategyTest extends FtpServerTestSupport {
  private static final Logger LOG=LoggerFactory.getLogger(FromFtpExclusiveReadNoneStrategyTest.class);
  private String getFtpUrl(){
    return "ftp://admin@localhost:" + getPort() + "/slowfile?password=admin"+ "&readLock=none&consumer.delay=500";
  }
  @Override public boolean isUseRouteBuilder(){
    return false;
  }
  @Test public void testPollFileWhileSlowFileIsBeingWrittenUsingNonExclusiveRead() throws Exception {
    if (isPlatform("windows")) {
      return;
    }
    context.addRoutes(new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("seda:start").process(new MySlowFileProcessor());
        from(getFtpUrl()).to("mock:result");
      }
    }
);
    context.start();
    deleteDirectory(FTP_ROOT_DIR);
    createDirectory(FTP_ROOT_DIR + "/slowfile");
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    template.sendBody("seda:start","Create the slow file");
    mock.assertIsSatisfied();
    String body=mock.getReceivedExchanges().get(0).getIn().getBody(String.class);
    LOG.debug("Body is: " + body);
    assertFalse("Should not wait and read the entire file",body.endsWith("Bye World"));
  }
private static class MySlowFileProcessor implements Processor {
    public void process(    Exchange exchange) throws Exception {
      LOG.info("Creating a slow file ...");
      File file=new File(FTP_ROOT_DIR + "/slowfile/hello.txt");
      FileOutputStream fos=new FileOutputStream(file);
      FileLock lock=fos.getChannel().lock();
      fos.write("Hello World".getBytes());
      for (int i=0; i < 3; i++) {
        Thread.sleep(1000);
        fos.write(("Line #" + i).getBytes());
        LOG.info("Appending to slowfile");
      }
      fos.write("Bye World".getBytes());
      lock.release();
      fos.close();
      LOG.info("... done creating slowfile");
    }
  }
}
