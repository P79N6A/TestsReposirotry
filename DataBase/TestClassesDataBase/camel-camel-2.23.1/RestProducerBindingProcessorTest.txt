public class RestProducerBindingProcessorTest {
public static class RequestPojo {
  }
public static class ResponsePojo {
  }
  final AsyncCallback callback=mock(AsyncCallback.class);
  final CamelContext context=new DefaultCamelContext();
  final DataFormat jsonDataFormat=mock(DataFormat.class);
  final DataFormat outJsonDataFormat=mock(DataFormat.class);
  final DataFormat outXmlDataFormat=mock(DataFormat.class);
  final AsyncProcessor processor=mock(AsyncProcessor.class);
  final DataFormat xmlDataFormat=mock(DataFormat.class);
  @Test public void shouldMarshalAndUnmarshalJson() throws Exception {
    final String outType=ResponsePojo.class.getName();
    final RestProducerBindingProcessor bindingProcessor=new RestProducerBindingProcessor(processor,context,jsonDataFormat,xmlDataFormat,outJsonDataFormat,outXmlDataFormat,"json",true,outType);
    final Exchange exchange=new DefaultExchange(context);
    final Message input=new DefaultMessage(context);
    final RequestPojo request=new RequestPojo();
    input.setBody(request);
    exchange.setIn(input);
    final ResponsePojo response=new ResponsePojo();
    when(outJsonDataFormat.unmarshal(same(exchange),any(InputStream.class))).thenReturn(response);
    final ArgumentCaptor<AsyncCallback> bindingCallback=ArgumentCaptor.forClass(AsyncCallback.class);
    when(processor.process(same(exchange),bindingCallback.capture())).thenReturn(false);
    bindingProcessor.process(exchange,callback);
    verify(jsonDataFormat).marshal(same(exchange),same(request),any(OutputStream.class));
    assertNotNull(bindingCallback.getValue());
    final AsyncCallback that=bindingCallback.getValue();
    that.done(false);
    Assert.assertSame(response,exchange.getOut().getBody());
  }
  @Test public void shouldMarshalAndUnmarshalXml() throws Exception {
    final String outType=ResponsePojo.class.getName();
    final RestProducerBindingProcessor bindingProcessor=new RestProducerBindingProcessor(processor,context,jsonDataFormat,xmlDataFormat,outJsonDataFormat,outXmlDataFormat,"xml",true,outType);
    final Exchange exchange=new DefaultExchange(context);
    final Message input=new DefaultMessage(context);
    final RequestPojo request=new RequestPojo();
    input.setBody(request);
    exchange.setIn(input);
    final ResponsePojo response=new ResponsePojo();
    when(outXmlDataFormat.unmarshal(same(exchange),any(InputStream.class))).thenReturn(response);
    final ArgumentCaptor<AsyncCallback> bindingCallback=ArgumentCaptor.forClass(AsyncCallback.class);
    when(processor.process(same(exchange),bindingCallback.capture())).thenReturn(false);
    bindingProcessor.process(exchange,callback);
    verify(xmlDataFormat).marshal(same(exchange),same(request),any(OutputStream.class));
    assertNotNull(bindingCallback.getValue());
    final AsyncCallback that=bindingCallback.getValue();
    that.done(false);
    Assert.assertSame(response,exchange.getOut().getBody());
  }
  @Test public void shouldNotMarshalAndUnmarshalByDefault() throws Exception {
    final String outType=ResponsePojo.class.getName();
    final RestProducerBindingProcessor bindingProcessor=new RestProducerBindingProcessor(processor,context,jsonDataFormat,xmlDataFormat,outJsonDataFormat,outXmlDataFormat,"off",true,outType);
    final Exchange exchange=new DefaultExchange(context);
    final Message input=new DefaultMessage(context);
    final RequestPojo request=new RequestPojo();
    input.setBody(request);
    exchange.setIn(input);
    final ArgumentCaptor<AsyncCallback> bindingCallback=ArgumentCaptor.forClass(AsyncCallback.class);
    when(processor.process(same(exchange),bindingCallback.capture())).thenReturn(false);
    bindingProcessor.process(exchange,callback);
    assertNotNull(bindingCallback.getValue());
    final AsyncCallback that=bindingCallback.getValue();
    that.done(false);
  }
}
