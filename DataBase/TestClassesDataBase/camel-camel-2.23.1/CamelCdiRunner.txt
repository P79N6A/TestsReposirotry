public class CamelCdiRunner extends BlockJUnit4ClassRunner {
  private final CamelCdiContext context=new CamelCdiContext();
  public CamelCdiRunner(  Class<?> clazz) throws InitializationError {
    super(clazz);
  }
  @Override protected void validateConstructor(  List<Throwable> errors){
  }
  @Override protected void validatePublicVoidNoArgMethods(  Class<? extends Annotation> annotation,  boolean isStatic,  List<Throwable> errors){
    List<FrameworkMethod> methods=getTestClass().getAnnotatedMethods(annotation);
    for (    FrameworkMethod eachTestMethod : methods) {
      eachTestMethod.validatePublicVoid(isStatic,errors);
    }
  }
  @Override protected List<FrameworkMethod> getChildren(){
    List<FrameworkMethod> children=super.getChildren();
    boolean hasDefinedOrder=false;
    for (    FrameworkMethod method : children) {
      if (method.getAnnotation(Order.class) != null) {
        hasDefinedOrder=true;
      }
    }
    if (hasDefinedOrder) {
      List<FrameworkMethod> sorted=new ArrayList<>(children);
      Collections.sort(sorted,new FrameworkMethodSorter());
      return sorted;
    }
    return children;
  }
  @Override protected List<TestRule> classRules(){
    List<TestRule> rules=super.classRules();
    rules.add(0,new CamelCdiDeployment(getTestClass(),context));
    return rules;
  }
  @Override protected Object createTest(){
    BeanManager manager=context.getBeanManager();
    Set<Bean<?>> beans=manager.getBeans(getTestClass().getJavaClass(),AnyLiteral.INSTANCE);
    Bean<?> bean=beans.iterator().next();
    return manager.getReference(bean,bean.getBeanClass(),manager.createCreationalContext(bean));
  }
  @Override protected Statement methodInvoker(  FrameworkMethod method,  Object test){
    return new FrameworkMethodCdiInjection(method,test,context);
  }
}
