public class SignatureTests extends CamelTestSupport {
  private KeyPair keyPair;
  private String payload="Dear Alice, Rest assured it's me, signed Bob";
  @Override protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry registry=super.createRegistry();
    KeyStore keystore=loadKeystore();
    Certificate cert=keystore.getCertificate("bob");
    KeyStoreParameters keystoreParameters=new KeyStoreParameters();
    keystoreParameters.setPassword("letmein");
    keystoreParameters.setResource("./ks.keystore");
    registry.bind("signatureParams",keystoreParameters);
    registry.bind("keystore",keystore);
    registry.bind("myPublicKey",cert.getPublicKey());
    registry.bind("myCert",cert);
    registry.bind("myPrivateKey",keystore.getKey("bob","letmein".toCharArray()));
    return registry;
  }
  @Override protected RouteBuilder[] createRouteBuilders() throws Exception {
    return new RouteBuilder[]{new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:keypair").to("crypto:sign:basic?privateKey=#myPrivateKey","crypto:verify:basic?publicKey=#myPublicKey","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        keyPair=getKeyPair("RSA");
        PrivateKey privateKey=keyPair.getPrivate();
        PublicKey publicKey=keyPair.getPublic();
        context.getEndpoint("crypto:sign:rsa?algorithm=MD5withRSA",DigitalSignatureEndpoint.class).setPrivateKey(privateKey);
        context.getEndpoint("crypto:verify:rsa?algorithm=MD5withRSA",DigitalSignatureEndpoint.class).setPublicKey(publicKey);
        from("direct:algorithm").to("crypto:sign:rsa?algorithm=MD5withRSA","crypto:verify:rsa?algorithm=MD5withRSA","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        keyPair=getKeyPair("RSA");
        PrivateKey privateKey=keyPair.getPrivate();
        PublicKey publicKey=keyPair.getPublic();
        context.getEndpoint("crypto:sign:rsa?algorithm=SHA1withRSA",DigitalSignatureEndpoint.class).setPrivateKey(privateKey);
        context.getEndpoint("crypto:verify:rsa?algorithm=SHA1withRSA",DigitalSignatureEndpoint.class).setPublicKey(publicKey);
        from("direct:rsa-sha1").to("crypto:sign:rsa?algorithm=SHA1withRSA","crypto:verify:rsa?algorithm=SHA1withRSA","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        keyPair=getKeyPair("RSA");
        PrivateKey privateKey=keyPair.getPrivate();
        PublicKey publicKey=keyPair.getPublic();
        context.getEndpoint("crypto:sign:rsa?algorithm=SHA256withRSA",DigitalSignatureEndpoint.class).setPrivateKey(privateKey);
        context.getEndpoint("crypto:verify:rsa?algorithm=SHA256withRSA",DigitalSignatureEndpoint.class).setPublicKey(publicKey);
        from("direct:rsa-sha256").to("crypto:sign:rsa?algorithm=SHA256withRSA","crypto:verify:rsa?algorithm=SHA256withRSA","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:buffersize").to("crypto:sign:buffer?privateKey=#myPrivateKey&buffersize=1024","crypto:verify:buffer?publicKey=#myPublicKey&buffersize=1024","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:provider").to("crypto:sign:provider?privateKey=#myPrivateKey&provider=SUN","crypto:verify:provider?publicKey=#myPublicKey&provider=SUN","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:certificate").to("crypto:sign:withcert?privateKey=#myPrivateKey","crypto:verify:withcert?certificate=#myCert","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:keystore").to("crypto:sign:keystore?keystore=#keystore&alias=bob&password=letmein","crypto:verify:keystore?keystore=#keystore&alias=bob","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:keystoreParameters").to("crypto:sign:keyStoreParameters?keyStoreParameters=#signatureParams&alias=bob&password=letmein","crypto:verify:keyStoreParameters?keyStoreParameters=#signatureParams&alias=bob","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:signature-header").to("crypto:sign:another?privateKey=#myPrivateKey&signatureHeader=AnotherDigitalSignature","crypto:verify:another?publicKey=#myPublicKey&signatureHeader=AnotherDigitalSignature","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:random").to("crypto:sign:another?privateKey=#myPrivateKey&secureRandom=#someRandom","crypto:verify:another?publicKey=#myPublicKey&secureRandom=#someRandom","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:alias-sign").to("crypto:sign:alias?keystore=#keystore");
        from("direct:alias-verify").to("crypto:verify:alias?keystore=#keystore","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:headerkey-sign").to("crypto:sign:alias");
        from("direct:headerkey-verify").to("crypto:verify:alias","mock:result");
      }
    }
,new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:headers").to("crypto:sign:headers?privateKey=#myPrivateKey","crypto:verify:headers?publicKey=#myPublicKey&clearHeaders=false","mock:result");
      }
    }
};
  }
  @Test public void testBasicSignatureRoute() throws Exception {
    setupMock();
    sendBody("direct:keypair",payload);
    assertMockEndpointsSatisfied();
    MockEndpoint mock=getMockEndpoint("mock:result");
    Exchange e=mock.getExchanges().get(0);
    Message result=e == null ? null : e.hasOut() ? e.getOut() : e.getIn();
    assertNull(result.getHeader(DigitalSignatureConstants.SIGNATURE));
  }
  @Test public void testSetAlgorithmInRouteDefinition() throws Exception {
    setupMock();
    sendBody("direct:algorithm",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testRSASHA1() throws Exception {
    setupMock();
    sendBody("direct:rsa-sha1",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testRSASHA256() throws Exception {
    setupMock();
    sendBody("direct:rsa-sha256",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSetBufferInRouteDefinition() throws Exception {
    setupMock();
    sendBody("direct:buffersize",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSetRandomInRouteDefinition() throws Exception {
    setupMock();
    sendBody("direct:random",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSetProviderInRouteDefinition() throws Exception {
    if (isJavaVendor("ibm")) {
      return;
    }
    setupMock();
    sendBody("direct:provider",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSetCertificateInRouteDefinition() throws Exception {
    setupMock();
    sendBody("direct:certificate",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSetKeystoreInRouteDefinition() throws Exception {
    setupMock();
    sendBody("direct:keystore",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSetKeystoreParametersInRouteDefinition() throws Exception {
    setupMock();
    sendBody("direct:keystoreParameters",payload);
    assertMockEndpointsSatisfied();
  }
  @Test public void testSignatureHeaderInRouteDefinition() throws Exception {
    setupMock();
    Exchange signed=getMandatoryEndpoint("direct:signature-header").createExchange();
    signed.getIn().setBody(payload);
    template.send("direct:signature-header",signed);
    assertNotNull(signed.getIn().getHeader("AnotherDigitalSignature"));
    assertMockEndpointsSatisfied();
  }
  @Test public void testProvideAliasInHeader() throws Exception {
    setupMock();
    Exchange unsigned=getMandatoryEndpoint("direct:alias-sign").createExchange();
    unsigned.getIn().setBody(payload);
    unsigned.getIn().setHeader(DigitalSignatureConstants.KEYSTORE_ALIAS,"bob");
    unsigned.getIn().setHeader(DigitalSignatureConstants.KEYSTORE_PASSWORD,"letmein".toCharArray());
    template.send("direct:alias-sign",unsigned);
    Exchange signed=getMandatoryEndpoint("direct:alias-sign").createExchange();
    signed.getIn().copyFrom(unsigned.getOut());
    signed.getIn().setHeader(KEYSTORE_ALIAS,"bob");
    template.send("direct:alias-verify",signed);
    assertMockEndpointsSatisfied();
  }
  @Test public void testProvideKeysInHeader() throws Exception {
    setupMock();
    Exchange unsigned=getMandatoryEndpoint("direct:headerkey-sign").createExchange();
    unsigned.getIn().setBody(payload);
    KeyPair pair=getKeyPair("DSA");
    unsigned.getIn().setHeader(SIGNATURE_PRIVATE_KEY,pair.getPrivate());
    template.send("direct:headerkey-sign",unsigned);
    Exchange signed=getMandatoryEndpoint("direct:alias-sign").createExchange();
    signed.getIn().copyFrom(unsigned.getOut());
    signed.getIn().setHeader(SIGNATURE_PUBLIC_KEY_OR_CERT,pair.getPublic());
    template.send("direct:headerkey-verify",signed);
    assertMockEndpointsSatisfied();
  }
  @Test public void testProvideCertificateInHeader() throws Exception {
    setupMock();
    Exchange unsigned=getMandatoryEndpoint("direct:signature-property").createExchange();
    unsigned.getIn().setBody(payload);
    KeyStore keystore=loadKeystore();
    Certificate certificate=keystore.getCertificate("bob");
    PrivateKey pk=(PrivateKey)keystore.getKey("bob","letmein".toCharArray());
    unsigned.getIn().setHeader(SIGNATURE_PRIVATE_KEY,pk);
    template.send("direct:headerkey-sign",unsigned);
    Exchange signed=getMandatoryEndpoint("direct:alias-sign").createExchange();
    signed.getIn().copyFrom(unsigned.getOut());
    signed.getIn().setHeader(SIGNATURE_PUBLIC_KEY_OR_CERT,certificate);
    template.send("direct:headerkey-verify",signed);
    assertMockEndpointsSatisfied();
  }
  @Test public void testVerifyHeadersNotCleared() throws Exception {
    setupMock();
    template.requestBody("direct:headers",payload);
    assertMockEndpointsSatisfied();
    assertMockEndpointsSatisfied();
    MockEndpoint mock=getMockEndpoint("mock:result");
    Exchange e=mock.getExchanges().get(0);
    Message result=e == null ? null : e.hasOut() ? e.getOut() : e.getIn();
    assertNotNull(result.getHeader(DigitalSignatureConstants.SIGNATURE));
  }
  private MockEndpoint setupMock(){
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived(payload);
    return mock;
  }
  public Exchange doTestSignatureRoute(  RouteBuilder builder) throws Exception {
    return doSignatureRouteTest(builder,null,Collections.<String,Object>emptyMap());
  }
  public Exchange doSignatureRouteTest(  RouteBuilder builder,  Exchange e,  Map<String,Object> headers) throws Exception {
    CamelContext context=new DefaultCamelContext();
    try {
      context.addRoutes(builder);
      context.start();
      MockEndpoint mock=context.getEndpoint("mock:result",MockEndpoint.class);
      mock.setExpectedMessageCount(1);
      ProducerTemplate template=context.createProducerTemplate();
      if (e != null) {
        template.send("direct:in",e);
      }
 else {
        template.sendBodyAndHeaders("direct:in",payload,headers);
      }
      assertMockEndpointsSatisfied();
      return mock.getReceivedExchanges().get(0);
    }
  finally {
      context.stop();
    }
  }
  @Before public void setUp() throws Exception {
    setUpKeys("DSA");
    disableJMX();
    super.setUp();
  }
  public void setUpKeys(  String algorithm) throws Exception {
    keyPair=getKeyPair(algorithm);
  }
  public KeyPair getKeyPair(  String algorithm) throws NoSuchAlgorithmException {
    KeyPairGenerator keyGen=KeyPairGenerator.getInstance(algorithm);
    keyGen.initialize(512,new SecureRandom());
    return keyGen.generateKeyPair();
  }
  public static KeyStore loadKeystore() throws Exception {
    KeyStore keystore=KeyStore.getInstance(KeyStore.getDefaultType());
    InputStream in=SignatureTests.class.getResourceAsStream("/ks.keystore");
    keystore.load(in,"letmein".toCharArray());
    return keystore;
  }
  public Certificate getCertificateFromKeyStore() throws Exception {
    Certificate c=loadKeystore().getCertificate("bob");
    return c;
  }
  public PrivateKey getKeyFromKeystore() throws Exception {
    return (PrivateKey)loadKeystore().getKey("bob","letmein".toCharArray());
  }
}
