public class SplitterParallelAggregateTest extends ContextTestSupport {
  private boolean enabled;
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("direct:splitSynchronizedAggregation").split(method(new MySplitter(),"rowIterator"),new MyAggregationStrategy()).to("log:someSplitProcessing?groupSize=500");
        from("direct:splitUnsynchronizedAggregation").split(method(new MySplitter(),"rowIterator"),new MyAggregationStrategy()).parallelAggregate().to("log:someSplitProcessing?groupSize=500");
      }
    }
;
  }
  @Test public void test1() throws Exception {
    if (!enabled) {
      return;
    }
    int numberOfRequests=1;
    timeSplitRoutes(numberOfRequests);
  }
  @Test public void test2() throws Exception {
    if (!enabled) {
      return;
    }
    int numberOfRequests=2;
    timeSplitRoutes(numberOfRequests);
  }
  @Test public void test4() throws Exception {
    if (!enabled) {
      return;
    }
    int numberOfRequests=4;
    timeSplitRoutes(numberOfRequests);
  }
  protected void timeSplitRoutes(  int numberOfRequests) throws Exception {
    String[] endpoints=new String[]{"direct:splitSynchronizedAggregation","direct:splitUnsynchronizedAggregation"};
    List<Future<File>> futures=new ArrayList<>();
    StopWatch stopWatch=new StopWatch(false);
    for (    String endpoint : endpoints) {
      stopWatch.restart();
      for (int requestIndex=0; requestIndex < numberOfRequests; requestIndex++) {
        futures.add(template.asyncRequestBody(endpoint,null,File.class));
      }
      for (int i=0; i < futures.size(); i++) {
        Future<File> future=futures.get(i);
        future.get();
      }
      stopWatch.taken();
      log.info(String.format("test%d.%s=%d\n",numberOfRequests,endpoint,stopWatch.taken()));
    }
  }
public static class MySplitter {
    public Iterator<String[]> rowIterator(){
      LinkedList<String[]> rows=new LinkedList<>();
      String[] row;
      for (int i=0; i < 10000; i++) {
        row=new String[10];
        for (int j=0; j < row.length; j++) {
          row[j]=String.valueOf(System.nanoTime());
        }
        rows.add(row);
      }
      return rows.iterator();
    }
  }
public static class MyAggregationStrategy implements AggregationStrategy {
    @Override public Exchange aggregate(    Exchange oldExchange,    Exchange newExchange){
      Random random=new Random(System.currentTimeMillis());
      for (int i=0; i < 10000; i++) {
        random.nextGaussian();
      }
      return newExchange;
    }
  }
}
