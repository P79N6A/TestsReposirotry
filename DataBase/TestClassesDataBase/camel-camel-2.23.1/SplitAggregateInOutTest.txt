/** 
 * @version 
 */
public class SplitAggregateInOutTest extends ContextTestSupport {
  private static final Logger LOG=LoggerFactory.getLogger(SplitAggregateInOutTest.class);
  private String expectedBody="Response[(id=1,item=A);(id=2,item=B);(id=3,item=C)]";
  @Test public void testSplitAndAggregateInOut() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived(expectedBody);
    Object out=template.requestBody("direct:start","A@B@C");
    assertEquals(expectedBody,out);
    LOG.debug("Response to caller: " + out);
    assertMockEndpointsSatisfied();
  }
  @Override protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry jndi=super.createRegistry();
    jndi.bind("MyOrderService",new MyOrderService());
    return jndi;
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("direct:start").split(body().tokenize("@"),new MyOrderStrategy()).to("bean:MyOrderService?method=handleOrder").end().to("bean:MyOrderService?method=buildCombinedResponse").to("mock:result");
      }
    }
;
  }
public static class MyOrderService {
    private static int counter;
    /** 
 * We just handle the order by returning a id line for the order
 */
    public String handleOrder(    String line){
      LOG.debug("HandleOrder: " + line);
      return "(id=" + ++counter + ",item="+ line+ ")";
    }
    /** 
 * We use the same bean for building the combined response to send back to the original caller
 */
    public String buildCombinedResponse(    String line){
      LOG.debug("BuildCombinedResponse: " + line);
      return "Response[" + line + "]";
    }
  }
  /** 
 * This is our own order aggregation strategy where we can control how each splitted message should be combined. As we do not want to loos any message we copy from the new to the old to preserve the order lines as long we process them
 */
public static class MyOrderStrategy implements AggregationStrategy {
    public Exchange aggregate(    Exchange oldExchange,    Exchange newExchange){
      if (oldExchange == null) {
        return newExchange;
      }
      String orders=oldExchange.getIn().getBody(String.class);
      String newLine=newExchange.getIn().getBody(String.class);
      LOG.debug("Aggregate old orders: " + orders);
      LOG.debug("Aggregate new order: " + newLine);
      orders=orders + ";" + newLine;
      oldExchange.getIn().setBody(orders);
      return oldExchange;
    }
  }
}
