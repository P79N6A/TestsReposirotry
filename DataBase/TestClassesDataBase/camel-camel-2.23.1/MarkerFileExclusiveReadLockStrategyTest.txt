/** 
 * Tests the MarkerFileExclusiveReadLockStrategy in a multi-threaded scenario.
 */
public class MarkerFileExclusiveReadLockStrategyTest extends ContextTestSupport {
  private static final Logger LOG=LoggerFactory.getLogger(MarkerFileExclusiveReadLockStrategyTest.class);
  private static final int NUMBER_OF_THREADS=5;
  private AtomicInteger numberOfFilesProcessed=new AtomicInteger(0);
  @Override @Before public void setUp() throws Exception {
    deleteDirectory("target/marker/");
    createDirectory("target/marker/in");
    super.setUp();
  }
  @Test public void testMultithreadedLocking() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(2);
    mock.expectedFileExists("target/marker/out/file1.dat");
    mock.expectedFileExists("target/marker/out/file2.dat");
    writeFiles();
    assertMockEndpointsSatisfied();
    String content=context.getTypeConverter().convertTo(String.class,new File("target/marker/out/file1.dat"));
    String[] lines=content.split(LS);
    for (int i=0; i < 20; i++) {
      assertEquals("Line " + i,lines[i]);
    }
    content=context.getTypeConverter().convertTo(String.class,new File("target/marker/out/file2.dat"));
    lines=content.split(LS);
    for (int i=0; i < 20; i++) {
      assertEquals("Line " + i,lines[i]);
    }
    waitUntilCompleted();
    assertFileDoesNotExists("target/marker/in/file1.dat.camelLock");
    assertFileDoesNotExists("target/marker/in/file2.dat.camelLock");
    assertFileDoesNotExists("target/marker/in/file1.dat");
    assertFileDoesNotExists("target/marker/in/file2.dat");
    assertEquals(2,this.numberOfFilesProcessed.get());
  }
  private void writeFiles() throws Exception {
    LOG.debug("Writing files...");
    FileOutputStream fos=new FileOutputStream("target/marker/in/file1.dat");
    FileOutputStream fos2=new FileOutputStream("target/marker/in/file2.dat");
    for (int i=0; i < 20; i++) {
      fos.write(("Line " + i + LS).getBytes());
      fos2.write(("Line " + i + LS).getBytes());
      LOG.debug("Writing line " + i);
    }
    fos.flush();
    fos.close();
    fos2.flush();
    fos2.close();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("file:target/marker/in?readLock=markerFile&initialDelay=0&delay=10").onCompletion().process(new Processor(){
          public void process(          Exchange exchange) throws Exception {
            numberOfFilesProcessed.addAndGet(1);
          }
        }
).end().threads(NUMBER_OF_THREADS).to("file:target/marker/out","mock:result");
      }
    }
;
  }
  private void waitUntilCompleted(){
    while (this.numberOfFilesProcessed.get() < 2) {
      try {
        Thread.sleep(10);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  private static void assertFileDoesNotExists(  String filename){
    File file=new File(filename);
    assertFalse("File " + filename + " should not exist, it should have been deleted after being processed",file.exists());
  }
}
