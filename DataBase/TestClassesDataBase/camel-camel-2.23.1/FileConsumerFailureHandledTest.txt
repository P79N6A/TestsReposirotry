/** 
 * Unit test for consuming files but the exchange fails and is handled by the failure handler (usually the DeadLetterChannel)
 */
public class FileConsumerFailureHandledTest extends ContextTestSupport {
  @Override @Before public void setUp() throws Exception {
    deleteDirectory("target/messages/input");
    super.setUp();
  }
  @Test public void testParis() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:valid");
    mock.expectedBodiesReceived("Hello Paris");
    template.sendBodyAndHeader("file:target/messages/input/","Paris",Exchange.FILE_NAME,"paris.txt");
    mock.assertIsSatisfied();
    oneExchangeDone.matchesMockWaitTime();
    assertFiles("paris.txt",true);
  }
  @Test public void testLondon() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:invalid");
    mock.expectedBodiesReceived("London");
    template.sendBodyAndHeader("file:target/messages/input/","London",Exchange.FILE_NAME,"london.txt");
    mock.assertIsSatisfied();
    oneExchangeDone.matchesMockWaitTime();
    assertFiles("london.txt",true);
  }
  @Test public void testDublin() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:beer");
    mock.expectedBodiesReceived("Dublin");
    template.sendBodyAndHeader("file:target/messages/input/","Dublin",Exchange.FILE_NAME,"dublin.txt");
    mock.assertIsSatisfied();
    oneExchangeDone.matchesMockWaitTime();
    assertFiles("dublin.txt",false);
  }
  @Test public void testMadrid() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:error");
    mock.expectedBodiesReceived("Madrid");
    template.sendBodyAndHeader("file:target/messages/input/","Madrid",Exchange.FILE_NAME,"madrid.txt");
    mock.assertIsSatisfied();
    oneExchangeDone.matchesMockWaitTime();
    assertFiles("madrid.txt",true);
  }
  private static void assertFiles(  String filename,  boolean deleted) throws InterruptedException {
    File file=new File("target/messages/input/" + filename);
    assertEquals("File " + filename + " should be deleted: "+ deleted,deleted,!file.exists());
    String lock=filename + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;
    file=new File("target/messages/input/" + lock);
    assertFalse("File " + lock + " should be deleted",file.exists());
  }
  protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      public void configure() throws Exception {
        errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(2).redeliveryDelay(0).logStackTrace(false));
        onException(ValidationException.class).onWhen(exceptionMessage().contains("beer")).handled(false).to("mock:beer");
        onException(ValidationException.class).handled(true).to("mock:invalid");
        from("file:target/messages/input/?initialDelay=0&delay=10&delete=true").process(new MyValidatorProcessor()).to("mock:valid");
      }
    }
;
  }
private static class MyValidatorProcessor implements Processor {
    public void process(    Exchange exchange) throws Exception {
      String body=exchange.getIn().getBody(String.class);
      if ("London".equals(body)) {
        throw new ValidationException(exchange,"Forced exception by unit test");
      }
 else       if ("Madrid".equals(body)) {
        throw new RuntimeCamelException("Madrid is not a supported city");
      }
 else       if ("Dublin".equals(body)) {
        throw new ValidationException(exchange,"Dublin have good beer");
      }
      exchange.getOut().setBody("Hello " + body);
    }
  }
}
