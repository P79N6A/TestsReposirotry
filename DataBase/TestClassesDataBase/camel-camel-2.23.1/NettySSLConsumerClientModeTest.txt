public class NettySSLConsumerClientModeTest extends BaseNettyTest {
  private MyServer server;
  public void startNettyServer() throws Exception {
    server=new MyServer(getPort());
    server.start();
  }
  public void shutdownServer(){
    if (server != null) {
      server.shutdown();
    }
  }
  @Override protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry registry=super.createRegistry();
    registry.bind("ksf",new File("src/test/resources/keystore.jks"));
    registry.bind("tsf",new File("src/test/resources/keystore.jks"));
    return registry;
  }
  @Test public void testNettyRoute() throws Exception {
    try {
      startNettyServer();
      MockEndpoint receive=context.getEndpoint("mock:receive",MockEndpoint.class);
      receive.expectedBodiesReceived("Bye Willem");
      context.startRoute("sslclient");
      receive.assertIsSatisfied();
    }
  finally {
      shutdownServer();
    }
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("netty4:tcp://localhost:{{port}}?textline=true&clientMode=true&ssl=true&passphrase=changeit&keyStoreFile=#ksf&trustStoreFile=#tsf").id("sslclient").process(new Processor(){
          public void process(          final Exchange exchange){
            String body=exchange.getIn().getBody(String.class);
            exchange.getOut().setBody("Bye " + body);
          }
        }
).to("mock:receive").noAutoStartup();
      }
    }
;
  }
private static class MyServer {
    private int port;
    private ServerBootstrap bootstrap;
    private Channel channel;
    private EventLoopGroup bossGroup;
    private EventLoopGroup workerGroup;
    MyServer(    int port){
      this.port=port;
    }
    public void start() throws Exception {
      bossGroup=new NioEventLoopGroup(1);
      workerGroup=new NioEventLoopGroup();
      bootstrap=new ServerBootstrap();
      bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ServerInitializer());
      ChannelFuture cf=bootstrap.bind(port).sync();
      channel=cf.channel();
    }
    public void shutdown(){
      channel.disconnect();
      bossGroup.shutdownGracefully();
      workerGroup.shutdownGracefully();
    }
  }
private static class ServerHandler extends SimpleChannelInboundHandler<String> {
    public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      ctx.write("Willem\r\n");
      ctx.flush();
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      cause.printStackTrace();
      ctx.close();
    }
    @Override protected void channelRead0(    ChannelHandlerContext ctx,    String msg) throws Exception {
    }
    public void channelReadComplete(    ChannelHandlerContext ctx) throws Exception {
      ctx.flush();
    }
  }
private static class ServerInitializer extends ChannelInitializer<SocketChannel> {
    private static final StringDecoder DECODER=new StringDecoder();
    private static final StringEncoder ENCODER=new StringEncoder();
    private static final ServerHandler SERVERHANDLER=new ServerHandler();
    private SSLContext sslContext;
    ServerInitializer(){
      super();
      try {
        char[] pass="changeit".toCharArray();
        KeyManagerFactory kmf;
        kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        TrustManagerFactory tmf=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        KeyStore ks=KeyStore.getInstance("JKS");
        try (InputStream ksStream=new FileInputStream(new File("src/test/resources/keystore.jks"))){
          ks.load(ksStream,pass);
        }
         kmf.init(ks,pass);
        tmf.init(ks);
        sslContext=SSLContext.getInstance("TLS");
        sslContext.init(kmf.getKeyManagers(),tmf.getTrustManagers(),null);
      }
 catch (      NoSuchAlgorithmException|KeyStoreException|CertificateException|IOException|UnrecoverableKeyException|KeyManagementException e) {
        e.printStackTrace();
      }
    }
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ChannelPipeline pipeline=ch.pipeline();
      SSLEngine engine=sslContext.createSSLEngine();
      engine.setUseClientMode(false);
      engine.setNeedClientAuth(true);
      pipeline.addLast("ssl",new SslHandler(engine));
      pipeline.addLast("framer",new DelimiterBasedFrameDecoder(8192,Delimiters.lineDelimiter()));
      pipeline.addLast("decoder",DECODER);
      pipeline.addLast("encoder",ENCODER);
      pipeline.addLast("handler",SERVERHANDLER);
    }
  }
}
