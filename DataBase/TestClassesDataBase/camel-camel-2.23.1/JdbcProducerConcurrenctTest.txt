public class JdbcProducerConcurrenctTest extends AbstractJdbcTestSupport {
  @EndpointInject(uri="mock:result") private MockEndpoint mock;
  @Test public void testNoConcurrentProducers() throws Exception {
    doSendMessages(1,1);
  }
  @Test public void testConcurrentProducers() throws Exception {
    doSendMessages(10,5);
  }
  @SuppressWarnings("rawtypes") private void doSendMessages(  int files,  int poolSize) throws Exception {
    mock.expectedMessageCount(files);
    ExecutorService executor=Executors.newFixedThreadPool(poolSize);
    Map<Integer,Future<List<?>>> responses=new HashMap<>();
    for (int i=0; i < files; i++) {
      final int index=i;
      Future<List<?>> out=executor.submit(new Callable<List<?>>(){
        public List<?> call() throws Exception {
          int id=(index % 2) + 1;
          return template.requestBody("direct:start","select * from customer where id = 'cust" + id + "'",List.class);
        }
      }
);
      responses.put(index,out);
    }
    assertMockEndpointsSatisfied();
    assertEquals(files,responses.size());
    for (int i=0; i < files; i++) {
      List<?> rows=responses.get(i).get();
      Map columns=(Map)rows.get(0);
      if (i % 2 == 0) {
        assertEquals("jstrachan",columns.get("NAME"));
      }
 else {
        assertEquals("nsandhu",columns.get("NAME"));
      }
    }
    executor.shutdownNow();
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      public void configure() throws Exception {
        from("direct:start").to("jdbc:testdb").to("mock:result");
      }
    }
;
  }
}
