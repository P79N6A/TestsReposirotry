/** 
 * Stress tests for the XML JSON data format: concurrency and large JSON and XML documents
 */
public class XmlJsonStressTest extends AbstractJsonTestSupport {
  @Test public void testNoConcurrentProducers() throws Exception {
    doSendMessages(1,1,"direct:startFromXML","org/apache/camel/dataformat/xmljson/testMessage1.xml");
  }
  @Test public void testConcurrentProducers() throws Exception {
    doSendMessages(1000,5,"direct:startFromXML","org/apache/camel/dataformat/xmljson/testMessage1.xml");
  }
  @Test public void testLargeMessages() throws Exception {
    doSendMessages(5,2,"direct:startFromXML","org/apache/camel/dataformat/xmljson/testMessage3-large.xml");
    resetMocks();
    doSendMessages(5,2,"direct:startFromJson","org/apache/camel/dataformat/xmljson/testMessage3-large.json");
  }
  private void doSendMessages(  int files,  int poolSize,  final String endpointURI,  String resourceURI) throws Exception {
    MockEndpoint mockJSON=getMockEndpoint("mock:json");
    MockEndpoint mockXML=getMockEndpoint("mock:xml");
    mockJSON.expectedMessageCount(files);
    mockXML.expectedMessageCount(files);
    InputStream inStream=getClass().getClassLoader().getResourceAsStream(resourceURI);
    final String in=context.getTypeConverter().convertTo(String.class,inStream);
    ExecutorService executor=Executors.newFixedThreadPool(poolSize);
    for (int i=0; i < files; i++) {
      executor.submit(new Callable<Object>(){
        public Object call() throws Exception {
          template.sendBody(endpointURI,in);
          return null;
        }
      }
);
    }
    assertMockEndpointsSatisfied(60,TimeUnit.SECONDS);
    Object jsonBody=mockJSON.getExchanges().get(0).getIn().getBody(String.class);
    Object xmlBody=mockXML.getExchanges().get(0).getIn().getBody(String.class);
    for (    Exchange e : mockJSON.getExchanges()) {
      assertEquals("Bodies are expected to be equal (json mock endpoint)",jsonBody,e.getIn().getBody(String.class));
    }
    for (    Exchange e : mockXML.getExchanges()) {
      assertEquals("Bodies are expected to be equal (xml mock endpoint)",xmlBody,e.getIn().getBody(String.class));
    }
    mockJSON.reset();
    mockXML.reset();
    executor.shutdownNow();
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        XmlJsonDataFormat format=new XmlJsonDataFormat();
        from("direct:startFromXML").marshal(format).to("mock:json").to("direct:unmarshalToJson");
        from("direct:unmarshalToJson").unmarshal(format).to("mock:xml");
        from("direct:startFromJson").unmarshal(format).to("mock:json").to("direct:marshalToXML");
        from("direct:marshalToXML").marshal(format).to("mock:xml");
      }
    }
;
  }
}
