/** 
 * @version 
 */
public class JmsMessageTypeTest extends CamelTestSupport {
  protected CamelContext createCamelContext() throws Exception {
    CamelContext camelContext=super.createCamelContext();
    ConnectionFactory connectionFactory=CamelJmsTestHelper.createConnectionFactory();
    camelContext.addComponent("jms",jmsComponentAutoAcknowledge(connectionFactory));
    camelContext.getTypeConverterRegistry().addTypeConverter(byte[].class,MyFooBean.class,new MyFooBean());
    camelContext.getTypeConverterRegistry().addTypeConverter(String.class,MyFooBean.class,new MyFooBean());
    camelContext.getTypeConverterRegistry().addTypeConverter(Map.class,MyFooBean.class,new MyFooBean());
    return camelContext;
  }
  @Test public void testHeaderTextType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Hello World");
    mock.message(0).body().isInstanceOf(String.class);
    template.sendBodyAndHeader("direct:foo",new MyFooBean("World"),JMS_MESSAGE_TYPE,"Text");
    assertMockEndpointsSatisfied();
  }
  @Test public void testConvertTextType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Hello World");
    mock.message(0).body().isInstanceOf(String.class);
    template.sendBody("direct:text",new MyFooBean("World"));
    assertMockEndpointsSatisfied();
  }
  @Test public void testTextType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Hello World");
    mock.message(0).body().isInstanceOf(String.class);
    template.sendBody("direct:text","Hello World");
    assertMockEndpointsSatisfied();
  }
  @Test public void testHeaderBytesType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Bye World".getBytes());
    mock.message(0).body().isInstanceOf(byte[].class);
    template.sendBodyAndHeader("direct:foo",new MyFooBean("World"),JMS_MESSAGE_TYPE,"Bytes");
    assertMockEndpointsSatisfied();
  }
  @Test public void testConvertBytesType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Bye World".getBytes());
    mock.message(0).body().isInstanceOf(byte[].class);
    template.sendBody("direct:bytes",new MyFooBean("World"));
    assertMockEndpointsSatisfied();
  }
  @Test public void testBytesType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedBodiesReceived("Bye World".getBytes());
    mock.message(0).body().isInstanceOf(byte[].class);
    template.sendBody("direct:bytes","Bye World");
    assertMockEndpointsSatisfied();
  }
  @Test public void testHeaderMapType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    mock.message(0).body().isInstanceOf(Map.class);
    template.sendBodyAndHeader("direct:foo",new MyFooBean("Claus"),JMS_MESSAGE_TYPE,"Map");
    assertMockEndpointsSatisfied();
    assertEquals("Claus",mock.getExchanges().get(0).getIn().getBody(Map.class).get("name"));
  }
  @Test public void testConvertMapType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    mock.message(0).body().isInstanceOf(Map.class);
    template.sendBody("direct:map",new MyFooBean("Claus"));
    assertMockEndpointsSatisfied();
    assertEquals("Claus",mock.getExchanges().get(0).getIn().getBody(Map.class).get("name"));
  }
  @Test public void testMapType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    mock.message(0).body().isInstanceOf(Map.class);
    Map<String,Object> body=new HashMap<>();
    body.put("name","Claus");
    template.sendBody("direct:map",body);
    assertMockEndpointsSatisfied();
    assertEquals("Claus",mock.getExchanges().get(0).getIn().getBody(Map.class).get("name"));
  }
  @Test public void testHeaderObjectType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    mock.message(0).body().isInstanceOf(MyFooBean.class);
    template.sendBodyAndHeader("direct:foo",new MyFooBean("James"),JMS_MESSAGE_TYPE,"Object");
    assertMockEndpointsSatisfied();
    assertEquals("James",mock.getExchanges().get(0).getIn().getBody(MyFooBean.class).getName());
  }
  @Test public void testObjectType() throws Exception {
    MockEndpoint mock=getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    mock.message(0).body().isInstanceOf(MyFooBean.class);
    template.sendBody("direct:object",new MyFooBean("James"));
    assertMockEndpointsSatisfied();
    assertEquals("James",mock.getExchanges().get(0).getIn().getBody(MyFooBean.class).getName());
  }
  @Override protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder(){
      @Override public void configure() throws Exception {
        from("direct:text").to("jms:queue:foo?jmsMessageType=Text");
        from("direct:bytes").to("jms:queue:foo?jmsMessageType=Bytes");
        from("direct:map").to("jms:queue:foo?jmsMessageType=Map");
        from("direct:object").to("jms:queue:foo?jmsMessageType=Object");
        from("direct:foo").to("jms:queue:foo");
        from("jms:queue:foo").to("mock:result");
      }
    }
;
  }
public static final class MyFooBean extends TypeConverterSupport implements Serializable {
    private static final long serialVersionUID=1L;
    private String name;
    private MyFooBean(){
    }
    private MyFooBean(    String name){
      this.name=name;
    }
    public String getName(){
      return name;
    }
    @Override @SuppressWarnings("unchecked") public <T>T convertTo(    Class<T> type,    Exchange exchange,    Object value) throws TypeConversionException {
      if (type.isAssignableFrom(String.class)) {
        return (T)("Hello " + ((MyFooBean)value).getName());
      }
      if (type.isAssignableFrom(byte[].class)) {
        return (T)("Bye " + ((MyFooBean)value).getName()).getBytes();
      }
      if (type.isAssignableFrom(Map.class)) {
        Map<String,Object> map=new HashMap<>();
        map.put("name",((MyFooBean)value).getName());
        return (T)map;
      }
      return null;
    }
  }
}
