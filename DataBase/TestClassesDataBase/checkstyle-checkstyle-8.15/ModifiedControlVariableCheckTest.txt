public class ModifiedControlVariableCheckTest extends AbstractModuleTestSupport {
  @Override protected String getPackageLocation(){
    return "com/puppycrawl/tools/checkstyle/checks/coding/modifiedcontrolvariable";
  }
  @Test public void testModifiedControlVariable() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(ModifiedControlVariableCheck.class);
    final String[] expected={"14:14: " + getCheckMessage(MSG_KEY,"i"),"17:15: " + getCheckMessage(MSG_KEY,"i"),"20:37: " + getCheckMessage(MSG_KEY,"i"),"21:17: " + getCheckMessage(MSG_KEY,"i"),"49:15: " + getCheckMessage(MSG_KEY,"s"),"56:14: " + getCheckMessage(MSG_KEY,"m"),"67:15: " + getCheckMessage(MSG_KEY,"i"),"68:15: " + getCheckMessage(MSG_KEY,"k"),"78:15: " + getCheckMessage(MSG_KEY,"v")};
    verify(checkConfig,getPath("InputModifiedControlVariableBothForLoops.java"),expected);
  }
  @Test public void testEnhancedForLoopVariableTrue() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(ModifiedControlVariableCheck.class);
    checkConfig.addAttribute("skipEnhancedForLoopVariable","true");
    final String[] expected=CommonUtil.EMPTY_STRING_ARRAY;
    verify(checkConfig,getPath("InputModifiedControlVariableEnhancedForLoopVariable.java"),expected);
  }
  @Test public void testEnhancedForLoopVariableFalse() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(ModifiedControlVariableCheck.class);
    final String[] expected={"9:18: " + getCheckMessage(MSG_KEY,"line")};
    verify(checkConfig,getPath("InputModifiedControlVariableEnhancedForLoopVariable.java"),expected);
  }
  @Test public void testEnhancedForLoopVariable2() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(ModifiedControlVariableCheck.class);
    checkConfig.addAttribute("skipEnhancedForLoopVariable","true");
    final String[] expected={"14:18: " + getCheckMessage(MSG_KEY,"i")};
    verify(checkConfig,getPath("InputModifiedControlVariableEnhancedForLoopVariable2.java"),expected);
  }
  @Test public void testTokensNotNull(){
    final ModifiedControlVariableCheck check=new ModifiedControlVariableCheck();
    Assert.assertNotNull("Acceptable tokens should not be null",check.getAcceptableTokens());
    Assert.assertNotNull("Default tokens should not be null",check.getDefaultTokens());
    Assert.assertNotNull("Required tokens should not be null",check.getRequiredTokens());
  }
  @Test public void testImproperToken(){
    final ModifiedControlVariableCheck check=new ModifiedControlVariableCheck();
    final DetailAST classDefAst=new DetailAST();
    classDefAst.setType(TokenTypes.CLASS_DEF);
    try {
      check.visitToken(classDefAst);
      Assert.fail("IllegalStateException is expected");
    }
 catch (    IllegalStateException ex) {
    }
    try {
      check.leaveToken(classDefAst);
      Assert.fail("IllegalStateException is expected");
    }
 catch (    IllegalStateException ex) {
    }
  }
  /** 
 * We cannot reproduce situation when visitToken is called and leaveToken is not. So, we have to use reflection to be sure that even in such situation state of the field will be cleared.
 * @throws Exception when code tested throws exception
 */
  @Test @SuppressWarnings("unchecked") public void testClearState() throws Exception {
    final ModifiedControlVariableCheck check=new ModifiedControlVariableCheck();
    final Optional<DetailAST> methodDef=TestUtil.findTokenInAstByPredicate(JavaParser.parseFile(new File(getPath("InputModifiedControlVariableEnhancedForLoopVariable.java")),JavaParser.Options.WITHOUT_COMMENTS),ast -> ast.getType() == TokenTypes.OBJBLOCK);
    assertTrue("Ast should contain METHOD_DEF",methodDef.isPresent());
    assertTrue("State is not cleared on beginTree",TestUtil.isStatefulFieldClearedDuringBeginTree(check,methodDef.get(),"variableStack",variableStack -> ((Collection<Set<String>>)variableStack).isEmpty()));
  }
}
