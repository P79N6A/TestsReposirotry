public class AbstractClassNameCheckTest extends AbstractModuleTestSupport {
  @Override protected String getPackageLocation(){
    return "com/puppycrawl/tools/checkstyle/checks/naming/abstractclassname";
  }
  @Test public void testIllegalAbstractClassName() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(AbstractClassNameCheck.class);
    checkConfig.addAttribute("ignoreName","false");
    checkConfig.addAttribute("ignoreModifier","true");
    final String pattern="^Abstract.+$";
    final String[] expected={"3:1: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"InputAbstractClassName",pattern),"6:1: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"NonAbstractClassName",pattern),"10:5: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"NonAbstractInnerClass",pattern)};
    verify(checkConfig,getPath("InputAbstractClassName.java"),expected);
  }
  @Test public void testCustomFormat() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(AbstractClassNameCheck.class);
    checkConfig.addAttribute("ignoreName","false");
    checkConfig.addAttribute("ignoreModifier","true");
    checkConfig.addAttribute("format","^NonAbstract.+$");
    final String[] expected={"3:1: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"InputAbstractClassName","^NonAbstract.+$"),"9:1: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"AbstractClassOther","^NonAbstract.+$"),"21:1: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"AbstractClassName2","^NonAbstract.+$")};
    verify(checkConfig,getPath("InputAbstractClassName.java"),expected);
  }
  @Test public void testIllegalClassType() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(AbstractClassNameCheck.class);
    checkConfig.addAttribute("ignoreName","true");
    checkConfig.addAttribute("ignoreModifier","false");
    final String[] expected={"18:1: " + getCheckMessage(MSG_NO_ABSTRACT_CLASS_MODIFIER,"AbstractClass"),"22:5: " + getCheckMessage(MSG_NO_ABSTRACT_CLASS_MODIFIER,"AbstractInnerClass")};
    verify(checkConfig,getPath("InputAbstractClassName.java"),expected);
  }
  @Test public void testAllVariants() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(AbstractClassNameCheck.class);
    checkConfig.addAttribute("ignoreName","false");
    checkConfig.addAttribute("ignoreModifier","false");
    final String pattern="^Abstract.+$";
    final String[] expected={"3:1: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"InputAbstractClassName",pattern),"6:1: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"NonAbstractClassName",pattern),"10:5: " + getCheckMessage(MSG_ILLEGAL_ABSTRACT_CLASS_NAME,"NonAbstractInnerClass",pattern),"18:1: " + getCheckMessage(MSG_NO_ABSTRACT_CLASS_MODIFIER,"AbstractClass"),"22:5: " + getCheckMessage(MSG_NO_ABSTRACT_CLASS_MODIFIER,"AbstractInnerClass")};
    verify(checkConfig,getPath("InputAbstractClassName.java"),expected);
  }
  @Test public void testFalsePositive() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(AbstractClassNameCheck.class);
    final String[] expected={"9:5: " + getCheckMessage(MSG_NO_ABSTRACT_CLASS_MODIFIER,"AbstractClass")};
    verify(checkConfig,getPath("InputAbstractClassNameFormerFalsePositive.java"),expected);
  }
  @Test public void testGetAcceptableTokens(){
    final AbstractClassNameCheck classNameCheckObj=new AbstractClassNameCheck();
    final int[] actual=classNameCheckObj.getAcceptableTokens();
    final int[] expected={TokenTypes.CLASS_DEF};
    Assert.assertArrayEquals("Invalid acceptable tokens",expected,actual);
  }
  @Test public void testGetRequiredTokens(){
    final AbstractClassNameCheck classNameCheckObj=new AbstractClassNameCheck();
    final int[] actual=classNameCheckObj.getRequiredTokens();
    final int[] expected={TokenTypes.CLASS_DEF};
    Assert.assertArrayEquals("Invalid required tokens",expected,actual);
  }
}
