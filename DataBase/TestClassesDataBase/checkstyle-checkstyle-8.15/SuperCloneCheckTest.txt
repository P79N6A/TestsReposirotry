public class SuperCloneCheckTest extends AbstractModuleTestSupport {
  @Override protected String getPackageLocation(){
    return "com/puppycrawl/tools/checkstyle/checks/coding/superclone";
  }
  @Test public void testIt() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(SuperCloneCheck.class);
    final String[] expected={"27:19: " + getCheckMessage(MSG_KEY,"clone","super.clone"),"35:19: " + getCheckMessage(MSG_KEY,"clone","super.clone"),"60:48: " + getCheckMessage(MSG_KEY,"clone","super.clone")};
    verify(checkConfig,getPath("InputSuperCloneInnerAndWithArguments.java"),expected);
  }
  @Test public void testAnotherInputFile() throws Exception {
    final DefaultConfiguration checkConfig=createModuleConfig(SuperCloneCheck.class);
    final String[] expected={"9:17: " + getCheckMessage(MSG_KEY,"clone","super.clone")};
    verify(checkConfig,getPath("InputSuperClonePlainAndSubclasses.java"),expected);
  }
  @Test public void testTokensNotNull(){
    final SuperCloneCheck check=new SuperCloneCheck();
    Assert.assertNotNull("Acceptable tokens should not be null",check.getAcceptableTokens());
    Assert.assertNotNull("Default tokens should not be null",check.getDefaultTokens());
    Assert.assertNotNull("Required tokens should not be null",check.getRequiredTokens());
  }
  /** 
 * We cannot reproduce situation when visitToken is called and leaveToken is not. So, we have to use reflection to be sure that even in such situation state of the field will be cleared.
 * @throws Exception when code tested throws exception
 */
  @Test @SuppressWarnings("unchecked") public void testClearState() throws Exception {
    final AbstractSuperCheck check=new SuperCloneCheck();
    final Optional<DetailAST> methodDef=TestUtil.findTokenInAstByPredicate(JavaParser.parseFile(new File(getPath("InputSuperCloneWithoutWarnings.java")),JavaParser.Options.WITHOUT_COMMENTS),ast -> ast.getType() == TokenTypes.METHOD_DEF);
    assertTrue("Ast should contain METHOD_DEF",methodDef.isPresent());
    assertTrue("State is not cleared on beginTree",TestUtil.isStatefulFieldClearedDuringBeginTree(check,methodDef.get(),"methodStack",methodStack -> ((Collection<Set<String>>)methodStack).isEmpty()));
  }
}
