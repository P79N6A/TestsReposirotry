private static final class AssertGeneratedJavaLexer extends GeneratedJavaLexer {
  private int laPosition;
  private char[] laResults;
  private AssertGeneratedJavaLexer(){
    super((InputStream)null);
  }
  public static void verifyFailNoGuessing(  String methodName,  char... laResults) throws Exception {
    verify(methodName,false,0,laResults);
  }
  public static void verifyPass(  String methodName,  char... laResults) throws Exception {
    verify(methodName,true,1,laResults);
  }
  public static void verifyFail(  String methodName,  char... laResults) throws Exception {
    verify(methodName,false,1,laResults);
  }
  private static void verify(  String methodName,  boolean expectPass,  int guessing,  char... laResults) throws Exception {
    final AssertGeneratedJavaLexer instance=new AssertGeneratedJavaLexer();
    instance.laPosition=0;
    instance.laResults=laResults.clone();
    instance.inputState.guessing=guessing;
    final Method method=GeneratedJavaLexer.class.getDeclaredMethod(methodName,boolean.class);
    boolean exception;
    try {
      method.invoke(instance,true);
      exception=false;
    }
 catch (    InvocationTargetException ex) {
      if (expectPass) {
        throw ex;
      }
      final Class<?> clss=ex.getTargetException().getClass();
      if (clss != NoViableAltForCharException.class && clss != SemanticException.class) {
        throw ex;
      }
      exception=true;
    }
    if (expectPass) {
      assertFalse("Call to GeneratedJavaLexer." + methodName + " resulted in an exception",exception);
    }
 else {
      assertTrue("Call to GeneratedJavaLexer." + methodName + " did not result in an exception",exception);
    }
  }
  @Override public char LA(  int i){
    return laResults[laPosition + i - 1];
  }
  @Override public void consume(){
    laPosition++;
  }
  @Override public int mark(){
    return 1;
  }
}
