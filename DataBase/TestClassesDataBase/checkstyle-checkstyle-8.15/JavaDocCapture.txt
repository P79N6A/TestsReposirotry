private static class JavaDocCapture extends AbstractCheck {
  private static final Pattern SETTER_PATTERN=Pattern.compile("^set[A-Z].*");
  private int depth;
  @Override public boolean isCommentNodesRequired(){
    return true;
  }
  @Override public int[] getRequiredTokens(){
    return new int[]{TokenTypes.BLOCK_COMMENT_BEGIN};
  }
  @Override public int[] getDefaultTokens(){
    return getRequiredTokens();
  }
  @Override public int[] getAcceptableTokens(){
    return getRequiredTokens();
  }
  @Override public void beginTree(  DetailAST rootAST){
    depth=0;
  }
  @Override public void visitToken(  DetailAST ast){
    if (JavadocUtil.isJavadocComment(ast)) {
      final DetailAST node=getParent(ast);
switch (node.getType()) {
case TokenTypes.CLASS_DEF:
        visitClass(ast);
      break;
case TokenTypes.METHOD_DEF:
    visitMethod(ast,node);
  break;
case TokenTypes.VARIABLE_DEF:
final String propertyName=node.findFirstToken(TokenTypes.IDENT).getText();
final String propertyDoc=CHECK_PROPERTY_DOC.get(propertyName);
if (propertyDoc != null) {
Assert.assertEquals(checkName + "'s class field-level JavaDoc for " + propertyName,makeFirstUpper(propertyDoc),getJavaDocText(ast));
}
break;
case TokenTypes.CTOR_DEF:
case TokenTypes.ENUM_DEF:
case TokenTypes.ENUM_CONSTANT_DEF:
break;
default :
Assert.fail("Unknown token '" + TokenUtil.getTokenName(node.getType()) + "': "+ ast.getLineNo());
break;
}
}
}
@Override public void leaveToken(DetailAST ast){
final DetailAST node=getParent(ast);
if (node.getType() == TokenTypes.CLASS_DEF && JavadocUtil.isJavadocComment(ast)) {
depth--;
}
}
private static DetailAST getParent(DetailAST node){
DetailAST result=node.getParent();
int type=result.getType();
while (type == TokenTypes.MODIFIERS || type == TokenTypes.ANNOTATION) {
result=result.getParent();
type=result.getType();
}
return result;
}
private void visitClass(DetailAST ast){
if (depth == 0) {
Assert.assertEquals(checkName + "'s class-level JavaDoc",CHECK_TEXT.get("Description") + CHECK_TEXT.get("Properties") + CHECK_TEXT.get("Examples")+ " @since "+ CHECK_TEXT.get("since"),getJavaDocText(ast));
}
depth++;
}
private void visitMethod(DetailAST ast,DetailAST node){
if (depth == 0 && isSetterMethod(node)) {
final String propertyUpper=node.findFirstToken(TokenTypes.IDENT).getText().substring(3);
final String propertyName=makeFirstLower(propertyUpper);
final String propertyDoc=CHECK_PROPERTY_DOC.get(propertyName);
if (propertyDoc != null) {
final String javaDoc=getJavaDocText(ast);
Assert.assertEquals(checkName + "'s class method-level JavaDoc for " + propertyName,"Setter to " + makeFirstLower(propertyDoc),javaDoc.substring(0,javaDoc.indexOf(" @param")));
}
}
}
/** 
 * Returns whether an AST represents a setter method. This is similar to {@link CheckUtil#isSetterMethod(DetailAST)} except this doesn't careabout the number of children in the method.
 * @param ast the AST to check with.
 * @return whether the AST represents a setter method.
 */
private static boolean isSetterMethod(DetailAST ast){
boolean setterMethod=false;
if (ast.getType() == TokenTypes.METHOD_DEF) {
final DetailAST type=ast.findFirstToken(TokenTypes.TYPE);
final String name=type.getNextSibling().getText();
final boolean matchesSetterFormat=SETTER_PATTERN.matcher(name).matches();
final boolean voidReturnType=type.findFirstToken(TokenTypes.LITERAL_VOID) != null;
final DetailAST params=ast.findFirstToken(TokenTypes.PARAMETERS);
final boolean singleParam=params.getChildCount(TokenTypes.PARAMETER_DEF) == 1;
if (matchesSetterFormat && voidReturnType && singleParam) {
final DetailAST slist=ast.findFirstToken(TokenTypes.SLIST);
setterMethod=slist != null;
}
}
return setterMethod;
}
private static String getJavaDocText(DetailAST node){
final String text="<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<document>\n" + node.getFirstChild().getText().replaceAll("(^|\\r?\\n)\\s*\\* ?","\n").trim() + "\n</document>";
String result=null;
try {
result=getNodeText(XmlUtil.getRawXml(checkName,text,text).getFirstChild(),false).replace("\r","");
}
 catch (ParserConfigurationException ex) {
Assert.fail("Exception: " + ex.getClass() + " - "+ ex.getMessage());
}
return result;
}
private static String makeFirstUpper(String str){
final char ch=str.charAt(0);
final String result;
if (Character.isLowerCase(ch)) {
result=Character.toUpperCase(ch) + str.substring(1);
}
 else {
result=str;
}
return result;
}
private static String makeFirstLower(String str){
return Character.toLowerCase(str.charAt(0)) + str.substring(1);
}
}
