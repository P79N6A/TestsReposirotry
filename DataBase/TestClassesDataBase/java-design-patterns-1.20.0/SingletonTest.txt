/** 
 * This class provides several test case that test singleton construction. The first proves that multiple calls to the singleton getInstance object are the same when called in the SAME thread. The second proves that multiple calls to the singleton getInstance object are the same when called in the DIFFERENT thread. Date: 12/29/15 - 19:25 PM
 * @param < S > Supplier method generating singletons
 * @author Jeroen Meulemeester
 * @author Richard Jones
 */
public abstract class SingletonTest<S> {
  /** 
 * The singleton's getInstance method
 */
  private final Supplier<S> singletonInstanceMethod;
  /** 
 * Create a new singleton test instance using the given 'getInstance' method
 * @param singletonInstanceMethod The singleton's getInstance method
 */
  public SingletonTest(  final Supplier<S> singletonInstanceMethod){
    this.singletonInstanceMethod=singletonInstanceMethod;
  }
  /** 
 * Test the singleton in a non-concurrent setting
 */
  @Test public void testMultipleCallsReturnTheSameObjectInSameThread(){
    S instance1=this.singletonInstanceMethod.get();
    S instance2=this.singletonInstanceMethod.get();
    S instance3=this.singletonInstanceMethod.get();
    assertSame(instance1,instance2);
    assertSame(instance1,instance3);
    assertSame(instance2,instance3);
  }
  /** 
 * Test singleton instance in a concurrent setting
 */
  @Test public void testMultipleCallsReturnTheSameObjectInDifferentThreads() throws Exception {
    assertTimeout(ofMillis(10000),() -> {
      final List<Callable<S>> tasks=new ArrayList<>();
      for (int i=0; i < 10000; i++) {
        tasks.add(this.singletonInstanceMethod::get);
      }
      final ExecutorService executorService=Executors.newFixedThreadPool(8);
      final List<Future<S>> results=executorService.invokeAll(tasks);
      final S expectedInstance=this.singletonInstanceMethod.get();
      for (      Future<S> res : results) {
        final S instance=res.get();
        assertNotNull(instance);
        assertSame(expectedInstance,instance);
      }
      executorService.shutdown();
    }
);
  }
}
