/** 
 * Represents a scenario where DB connectivity is not present due to network issue, or DB service unavailable.
 */
@Nested public class ConnectivityIssue {
  private static final String EXCEPTION_CAUSE="Connection not available";
  /** 
 * setup a connection failure scenario.
 * @throws SQLException if any error occurs.
 */
  @BeforeEach public void setUp() throws SQLException {
    dao=new DbCustomerDao(mockedDatasource());
  }
  private DataSource mockedDatasource() throws SQLException {
    DataSource mockedDataSource=mock(DataSource.class);
    Connection mockedConnection=mock(Connection.class);
    SQLException exception=new SQLException(EXCEPTION_CAUSE);
    doThrow(exception).when(mockedConnection).prepareStatement(Mockito.anyString());
    doReturn(mockedConnection).when(mockedDataSource).getConnection();
    return mockedDataSource;
  }
  @Test public void addingACustomerFailsWithExceptionAsFeedbackToClient(){
    assertThrows(Exception.class,() -> {
      dao.add(new Customer(2,"Bernard","Montgomery"));
    }
);
  }
  @Test public void deletingACustomerFailsWithExceptionAsFeedbackToTheClient(){
    assertThrows(Exception.class,() -> {
      dao.delete(existingCustomer);
    }
);
  }
  @Test public void updatingACustomerFailsWithFeedbackToTheClient(){
    final String newFirstname="Bernard";
    final String newLastname="Montgomery";
    assertThrows(Exception.class,() -> {
      dao.update(new Customer(existingCustomer.getId(),newFirstname,newLastname));
    }
);
  }
  @Test public void retrievingACustomerByIdFailsWithExceptionAsFeedbackToClient(){
    assertThrows(Exception.class,() -> {
      dao.getById(existingCustomer.getId());
    }
);
  }
  @Test public void retrievingAllCustomersFailsWithExceptionAsFeedbackToClient(){
    assertThrows(Exception.class,() -> {
      dao.getAll();
    }
);
  }
}
