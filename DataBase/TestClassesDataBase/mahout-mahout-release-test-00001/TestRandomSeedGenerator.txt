public final class TestRandomSeedGenerator extends MahoutTestCase {
  private static final double[][] RAW={{1,1},{2,1},{1,2},{2,2},{3,3},{4,4},{5,4},{4,5},{5,5}};
  private FileSystem fs;
  private static List<VectorWritable> getPoints(){
    List<VectorWritable> points=Lists.newArrayList();
    for (    double[] fr : RAW) {
      Vector vec=new RandomAccessSparseVector(fr.length);
      vec.assign(fr);
      points.add(new VectorWritable(vec));
    }
    return points;
  }
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    Configuration conf=getConfiguration();
    fs=FileSystem.get(conf);
  }
  /** 
 * Story: test random seed generation generates 4 clusters with proper ids and data 
 */
  @Test public void testRandomSeedGenerator() throws Exception {
    List<VectorWritable> points=getPoints();
    Job job=new Job();
    Configuration conf=job.getConfiguration();
    job.setMapOutputValueClass(VectorWritable.class);
    Path input=getTestTempFilePath("random-input");
    Path output=getTestTempDirPath("random-output");
    ClusteringTestUtils.writePointsToFile(points,input,fs,conf);
    RandomSeedGenerator.buildRandom(conf,input,output,4,new ManhattanDistanceMeasure());
    int clusterCount=0;
    Collection<Integer> set=Sets.newHashSet();
    for (    ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output,"part-randomSeed"),true,conf)) {
      clusterCount++;
      Cluster cluster=clusterWritable.getValue();
      int id=cluster.getId();
      assertTrue(set.add(id));
      Vector v=cluster.getCenter();
      assertVectorEquals(RAW[id],v);
    }
    assertEquals(4,clusterCount);
  }
  /** 
 * Be sure that the buildRandomSeeded works in the same way as RandomSeedGenerator.buildRandom 
 */
  @Test public void testRandomSeedGeneratorSeeded() throws Exception {
    List<VectorWritable> points=getPoints();
    Job job=new Job();
    Configuration conf=job.getConfiguration();
    job.setMapOutputValueClass(VectorWritable.class);
    Path input=getTestTempFilePath("random-input");
    Path output=getTestTempDirPath("random-output");
    ClusteringTestUtils.writePointsToFile(points,input,fs,conf);
    RandomSeedGenerator.buildRandom(conf,input,output,4,new ManhattanDistanceMeasure(),1L);
    int clusterCount=0;
    Collection<Integer> set=Sets.newHashSet();
    for (    ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output,"part-randomSeed"),true,conf)) {
      clusterCount++;
      Cluster cluster=clusterWritable.getValue();
      int id=cluster.getId();
      assertTrue(set.add(id));
      Vector v=cluster.getCenter();
      assertVectorEquals(RAW[id],v);
    }
    assertEquals(4,clusterCount);
  }
  /** 
 * Test that initial clusters built with same random seed are reproduced  
 */
  @Test public void testBuildRandomSeededSameInitalClusters() throws Exception {
    List<VectorWritable> points=getPoints();
    Job job=new Job();
    Configuration conf=job.getConfiguration();
    job.setMapOutputValueClass(VectorWritable.class);
    Path input=getTestTempFilePath("random-input");
    Path output=getTestTempDirPath("random-output");
    ClusteringTestUtils.writePointsToFile(points,input,fs,conf);
    long randSeed=1;
    RandomSeedGenerator.buildRandom(conf,input,output,4,new ManhattanDistanceMeasure(),randSeed);
    int[] clusterIDSeq=new int[4];
    int clusterCount=0;
    for (    ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output,"part-randomSeed"),true,conf)) {
      Cluster cluster=clusterWritable.getValue();
      clusterIDSeq[clusterCount]=cluster.getId();
      clusterCount++;
    }
    RandomSeedGenerator.buildRandom(conf,input,output,4,new ManhattanDistanceMeasure(),randSeed);
    clusterCount=0;
    for (    ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output,"part-randomSeed"),true,conf)) {
      Cluster cluster=clusterWritable.getValue();
      assertEquals(clusterIDSeq[clusterCount],cluster.getId());
      clusterCount++;
    }
  }
  private static void assertVectorEquals(  double[] raw,  Vector v){
    assertEquals(raw.length,v.size());
    for (int i=0; i < raw.length; i++) {
      assertEquals(raw[i],v.getQuick(i),EPSILON);
    }
  }
}
