/** 
 * Shared ssvd test code
 */
public class SSVDCommonTest extends MahoutTestCase {
  private static final double SCALE=1000;
  private static final double SVD_EPSILON=1.0e-10;
  @Test public void testGivensQR() throws Exception {
    Matrix m=new DenseMatrix(3,3);
    m.assign(new DoubleFunction(){
      private final Random rnd=RandomUtils.getRandom();
      @Override public double apply(      double arg0){
        return rnd.nextDouble() * SCALE;
      }
    }
);
    m.setQuick(0,0,1);
    m.setQuick(0,1,2);
    m.setQuick(0,2,3);
    m.setQuick(1,0,4);
    m.setQuick(1,1,5);
    m.setQuick(1,2,6);
    m.setQuick(2,0,7);
    m.setQuick(2,1,8);
    m.setQuick(2,2,9);
    GivensThinSolver qrSolver=new GivensThinSolver(m.rowSize(),m.columnSize());
    qrSolver.solve(m);
    Matrix qtm=new DenseMatrix(qrSolver.getThinQtTilde());
    assertOrthonormality(qtm.transpose(),false,SVD_EPSILON);
    Matrix aClone=new DenseMatrix(qrSolver.getThinQtTilde()).transpose().times(qrSolver.getRTilde());
    System.out.println("aclone : " + aClone);
  }
  public static void assertOrthonormality(  Matrix mtx,  boolean insufficientRank,  double epsilon){
    int n=mtx.columnSize();
    int rank=0;
    for (int i=0; i < n; i++) {
      Vector ei=mtx.viewColumn(i);
      double norm=ei.norm(2);
      if (Math.abs(1 - norm) < epsilon) {
        rank++;
      }
 else {
        assertTrue(Math.abs(norm) < epsilon);
      }
      for (int j=0; j <= i; j++) {
        Vector e_j=mtx.viewColumn(j);
        double dot=ei.dot(e_j);
        assertTrue(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon);
      }
    }
    assertTrue((!insufficientRank && rank == n) || (insufficientRank && rank < n));
  }
}
