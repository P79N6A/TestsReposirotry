public final class LSMRTest extends MahoutTestCase {
  @Test public void basics(){
    Matrix m=hilbert(5);
    assertEquals(1,m.get(0,0),0);
    assertEquals(0.5,m.get(0,1),0);
    assertEquals(1 / 6.0,m.get(2,3),1.0e-9);
    Vector x=new DenseVector(new double[]{5,-120,630,-1120,630});
    Vector b=new DenseVector(5);
    b.assign(1);
    assertEquals(0,m.times(x).minus(b).norm(2),1.0e-9);
    LSMR r=new LSMR();
    Vector x1=r.solve(m,b);
    assertEquals(0,m.times(x1).minus(b).norm(2),1.0e-2);
    assertEquals(0,m.transpose().times(m).times(x1).minus(m.transpose().times(b)).norm(2),1.0e-7);
    assertEquals(m.times(x1).minus(b).norm(2),r.getResidualNorm(),1.0e-5);
    assertEquals(m.transpose().times(m).times(x1).minus(m.transpose().times(b)).norm(2),r.getNormalEquationResidual(),1.0e-9);
  }
  @Test public void random(){
    Matrix m=new DenseMatrix(200,30).assign(Functions.random());
    Vector b=new DenseVector(200).assign(1);
    LSMR r=new LSMR();
    Vector x1=r.solve(m,b);
    double norm=new SingularValueDecomposition(m).getS().viewDiagonal().norm(2);
    double actual=m.transpose().times(m).times(x1).minus(m.transpose().times(b)).norm(2);
    System.out.printf("%.4f\n",actual / norm * 1.0e6);
    assertEquals(0,actual,norm * 1.0e-5);
    assertEquals(m.times(x1).minus(b).norm(2),r.getResidualNorm(),1.0e-5);
    assertEquals(actual,r.getNormalEquationResidual(),1.0e-9);
  }
  private static Matrix hilbert(  int n){
    Matrix r=new DenseMatrix(n,n);
    for (int i=0; i < n; i++) {
      for (int j=0; j < n; j++) {
        r.set(i,j,1.0 / (i + j + 1));
      }
    }
    return r;
  }
}
