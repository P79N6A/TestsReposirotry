public final class SequentialOutOfCoreSvdTest extends MahoutTestCase {
  private File tmpDir;
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    tmpDir=getTestTempDir("matrix");
  }
  @Test public void testSingularValues() throws IOException {
    Matrix A=lowRankMatrix(tmpDir,"A",200,970,1020);
    List<File> partsOfA=Arrays.asList(tmpDir.listFiles(new FilenameFilter(){
      @Override public boolean accept(      File file,      String fileName){
        return fileName.matches("A-.*");
      }
    }
));
    partsOfA=Lists.reverse(partsOfA);
    SequentialOutOfCoreSvd s=new SequentialOutOfCoreSvd(partsOfA,tmpDir,100,210);
    SequentialBigSvd svd=new SequentialBigSvd(A,100);
    Vector reference=new DenseVector(svd.getSingularValues()).viewPart(0,6);
    Vector actual=s.getSingularValues().viewPart(0,6);
    assertEquals(0,reference.minus(actual).maxValue(),1.0e-9);
    s.computeU(partsOfA,tmpDir);
    Matrix u=readBlockMatrix(Arrays.asList(tmpDir.listFiles(new FilenameFilter(){
      @Override public boolean accept(      File file,      String fileName){
        return fileName.matches("U-.*");
      }
    }
)));
    s.computeV(tmpDir,A.columnSize());
    Matrix v=readBlockMatrix(Arrays.asList(tmpDir.listFiles(new FilenameFilter(){
      @Override public boolean accept(      File file,      String fileName){
        return fileName.matches("V-.*");
      }
    }
)));
    assertEquals(0,A.minus(u.times(new DiagonalMatrix(s.getSingularValues())).times(v.transpose())).aggregate(Functions.PLUS,Functions.ABS),1.0e-7);
  }
  /** 
 * Reads a list of files that contain a column of blocks.  It is assumed that the files can be sorted lexicographically to determine the order they should be stacked.  It is also assumed here that all blocks will be the same size except the last one which may be shorter than the others.
 * @param files  The list of files to read.
 * @return  The row-wise concatenation of the matrices in the files.
 * @throws IOException If we can't read the sub-matrices.
 */
  private static Matrix readBlockMatrix(  List<File> files) throws IOException {
    Collections.sort(files);
    int nrows=-1;
    int ncols=-1;
    Matrix r=null;
    MatrixWritable m=new MatrixWritable();
    int row=0;
    for (    File file : files) {
      DataInputStream in=new DataInputStream(new FileInputStream(file));
      m.readFields(in);
      in.close();
      if (nrows == -1) {
        nrows=m.get().rowSize() * files.size();
        ncols=m.get().columnSize();
        r=new DenseMatrix(nrows,ncols);
      }
      r.viewPart(row,m.get().rowSize(),0,r.columnSize()).assign(m.get());
      row+=m.get().rowSize();
    }
    if (row != nrows && r != null) {
      r=r.viewPart(0,row,0,ncols);
    }
    return r;
  }
  @Test public void testLeftVectors() throws IOException {
    Matrix A=lowRankMatrixInMemory(20,20);
    SequentialBigSvd s=new SequentialBigSvd(A,6);
    SingularValueDecomposition svd=new SingularValueDecomposition(A);
    Matrix u1=svd.getU().viewPart(0,20,0,3).assign(Functions.ABS);
    Matrix u2=s.getU().viewPart(0,20,0,3).assign(Functions.ABS);
    assertEquals(u1,u2);
  }
  private static Matrix lowRankMatrixInMemory(  int rows,  int columns) throws IOException {
    return lowRankMatrix(null,null,0,rows,columns);
  }
  private static void assertEquals(  Matrix u1,  Matrix u2){
    assertEquals(0.0,u1.minus(u2).aggregate(Functions.MAX,Functions.ABS),1.0e-10);
  }
  @Test public void testRightVectors() throws IOException {
    Matrix A=lowRankMatrixInMemory(20,20);
    SequentialBigSvd s=new SequentialBigSvd(A,6);
    SingularValueDecomposition svd=new SingularValueDecomposition(A);
    Matrix v1=svd.getV().viewPart(0,20,0,3).assign(Functions.ABS);
    Matrix v2=s.getV().viewPart(0,20,0,3).assign(Functions.ABS);
    assertEquals(v1,v2);
  }
  private static Matrix lowRankMatrix(  File tmpDir,  String aBase,  int rowsPerSlice,  int rows,  int columns) throws IOException {
    int rank=10;
    Matrix u=new RandomTrinaryMatrix(1,rows,rank,false);
    Matrix d=new DenseMatrix(rank,rank);
    d.set(0,0,5);
    d.set(1,1,3);
    d.set(2,2,1);
    d.set(3,3,0.5);
    Matrix v=new RandomTrinaryMatrix(2,columns,rank,false);
    Matrix a=u.times(d).times(v.transpose());
    if (tmpDir != null) {
      for (int i=0; i < a.rowSize(); i+=rowsPerSlice) {
        MatrixWritable m=new MatrixWritable(a.viewPart(i,Math.min(a.rowSize() - i,rowsPerSlice),0,a.columnSize()));
        DataOutputStream out=new DataOutputStream(new FileOutputStream(new File(tmpDir,String.format("%s-%09d",aBase,i))));
        try {
          m.write(out);
        }
  finally {
          out.close();
        }
      }
    }
    return a;
  }
}
