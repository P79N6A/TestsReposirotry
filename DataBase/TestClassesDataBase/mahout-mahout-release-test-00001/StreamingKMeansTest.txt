@RunWith(Parameterized.class) public class StreamingKMeansTest {
  private static final int NUM_DATA_POINTS=1 << 16;
  private static final int NUM_DIMENSIONS=6;
  private static final int NUM_PROJECTIONS=2;
  private static final int SEARCH_SIZE=10;
  private static Pair<List<Centroid>,List<Centroid>> syntheticData;
  @Before public void setUp(){
    RandomUtils.useTestSeed();
    syntheticData=DataUtils.sampleMultiNormalHypercube(NUM_DIMENSIONS,NUM_DATA_POINTS);
  }
  private UpdatableSearcher searcher;
  private boolean allAtOnce;
  public StreamingKMeansTest(  UpdatableSearcher searcher,  boolean allAtOnce){
    this.searcher=searcher;
    this.allAtOnce=allAtOnce;
  }
  @Parameters public static List<Object[]> generateData(){
    return Arrays.asList(new Object[][]{{new ProjectionSearch(new SquaredEuclideanDistanceMeasure(),NUM_PROJECTIONS,SEARCH_SIZE),true},{new FastProjectionSearch(new SquaredEuclideanDistanceMeasure(),NUM_PROJECTIONS,SEARCH_SIZE),true},{new ProjectionSearch(new SquaredEuclideanDistanceMeasure(),NUM_PROJECTIONS,SEARCH_SIZE),false},{new FastProjectionSearch(new SquaredEuclideanDistanceMeasure(),NUM_PROJECTIONS,SEARCH_SIZE),false}});
  }
  @Test public void testAverageDistanceCutoff(){
    double avgDistanceCutoff=0;
    double avgNumClusters=0;
    int numTests=1;
    System.out.printf("Distance cutoff for %s\n",searcher.getClass().getName());
    for (int i=0; i < numTests; ++i) {
      searcher.clear();
      int numStreamingClusters=(int)Math.log(syntheticData.getFirst().size()) * (1 << NUM_DIMENSIONS);
      double distanceCutoff=1.0e-6;
      double estimatedCutoff=ClusteringUtils.estimateDistanceCutoff(syntheticData.getFirst(),searcher.getDistanceMeasure(),100);
      System.out.printf("[%d] Generated synthetic data [magic] %f [estimate] %f\n",i,distanceCutoff,estimatedCutoff);
      StreamingKMeans clusterer=new StreamingKMeans(searcher,numStreamingClusters,estimatedCutoff);
      clusterer.cluster(syntheticData.getFirst());
      avgDistanceCutoff+=clusterer.getDistanceCutoff();
      avgNumClusters+=clusterer.getNumClusters();
      System.out.printf("[%d] %f\n",i,clusterer.getDistanceCutoff());
    }
    avgDistanceCutoff/=numTests;
    avgNumClusters/=numTests;
    System.out.printf("Final: distanceCutoff: %f estNumClusters: %f\n",avgDistanceCutoff,avgNumClusters);
  }
  @Test public void testClustering(){
    searcher.clear();
    int numStreamingClusters=(int)Math.log(syntheticData.getFirst().size()) * (1 << NUM_DIMENSIONS);
    System.out.printf("k log n = %d\n",numStreamingClusters);
    double estimatedCutoff=ClusteringUtils.estimateDistanceCutoff(syntheticData.getFirst(),searcher.getDistanceMeasure(),100);
    StreamingKMeans clusterer=new StreamingKMeans(searcher,numStreamingClusters,estimatedCutoff);
    long startTime=System.currentTimeMillis();
    if (allAtOnce) {
      clusterer.cluster(syntheticData.getFirst());
    }
 else {
      for (      Centroid datapoint : syntheticData.getFirst()) {
        clusterer.cluster(datapoint);
      }
    }
    long endTime=System.currentTimeMillis();
    System.out.printf("%s %s\n",searcher.getClass().getName(),searcher.getDistanceMeasure().getClass().getName());
    System.out.printf("Total number of clusters %d\n",clusterer.getNumClusters());
    System.out.printf("Weights: %f %f\n",ClusteringUtils.totalWeight(syntheticData.getFirst()),ClusteringUtils.totalWeight(clusterer));
    assertEquals("Total weight not preserved",ClusteringUtils.totalWeight(syntheticData.getFirst()),ClusteringUtils.totalWeight(clusterer),1.0e-9);
    double maxWeight=0;
    for (    Vector mean : syntheticData.getSecond()) {
      WeightedThing<Vector> v=searcher.search(mean,1).get(0);
      maxWeight=Math.max(v.getWeight(),maxWeight);
    }
    assertTrue("Maximum weight too large " + maxWeight,maxWeight < 0.05);
    double clusterTime=(endTime - startTime) / 1000.0;
    System.out.printf("%s\n%.2f for clustering\n%.1f us per row\n\n",searcher.getClass().getName(),clusterTime,clusterTime / syntheticData.getFirst().size() * 1.0e6);
    double[] cornerWeights=new double[1 << NUM_DIMENSIONS];
    Searcher trueFinder=new BruteSearch(new EuclideanDistanceMeasure());
    for (    Vector trueCluster : syntheticData.getSecond()) {
      trueFinder.add(trueCluster);
    }
    for (    Centroid centroid : clusterer) {
      WeightedThing<Vector> closest=trueFinder.search(centroid,1).get(0);
      cornerWeights[((Centroid)closest.getValue()).getIndex()]+=centroid.getWeight();
    }
    int expectedNumPoints=NUM_DATA_POINTS / (1 << NUM_DIMENSIONS);
    for (    double v : cornerWeights) {
      System.out.printf("%f ",v);
    }
    System.out.println();
    for (    double v : cornerWeights) {
      assertEquals(expectedNumPoints,v,0);
    }
  }
}
