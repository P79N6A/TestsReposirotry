/** 
 * Tests SSVD solver with a made-up data running hadoop solver in a local mode. It requests full-rank SSVD and then compares singular values to that of Colt's SVD asserting epsilon(precision) 1e-10 or whatever most recent value configured.
 */
public class LocalSSVDSolverSparseSequentialTest extends MahoutTestCase {
  private static final double s_epsilon=1.0E-10d;
  @Test public void testSSVDSolverPowerIterations1() throws IOException {
    runSSVDSolver(1);
  }
  public void runSSVDSolver(  int q) throws IOException {
    Configuration conf=getConfiguration();
    conf.set("mapred.job.tracker","local");
    conf.set("fs.default.name","file:///");
    Deque<Closeable> closeables=Lists.newLinkedList();
    ;
    Random rnd=RandomUtils.getRandom();
    File tmpDir=getTestTempDir("svdtmp");
    conf.set("hadoop.tmp.dir",tmpDir.getAbsolutePath());
    Path aLocPath=new Path(getTestTempDirPath("svdtmp/A"),"A.seq");
    SequenceFile.Writer w=SequenceFile.createWriter(FileSystem.getLocal(conf),conf,aLocPath,IntWritable.class,VectorWritable.class,CompressionType.BLOCK,new DefaultCodec());
    closeables.addFirst(w);
    int n=100;
    int m=2000;
    double percent=5;
    VectorWritable vw=new VectorWritable();
    IntWritable roww=new IntWritable();
    double muAmplitude=50.0;
    for (int i=0; i < m; i++) {
      Vector dv=new SequentialAccessSparseVector(n);
      for (int j=0; j < n * percent / 100; j++) {
        dv.setQuick(rnd.nextInt(n),muAmplitude * (rnd.nextDouble() - 0.5));
      }
      roww.set(i);
      vw.set(dv);
      w.append(roww,vw);
    }
    closeables.remove(w);
    Closeables.close(w,false);
    FileSystem fs=FileSystem.get(aLocPath.toUri(),conf);
    Path tempDirPath=getTestTempDirPath("svd-proc");
    Path aPath=new Path(tempDirPath,"A/A.seq");
    fs.copyFromLocalFile(aLocPath,aPath);
    Path svdOutPath=new Path(tempDirPath,"SSVD-out");
    fs.delete(svdOutPath,true);
    System.out.println("Input prepared, starting solver...");
    int ablockRows=867;
    int p=60;
    int k=40;
    SSVDSolver ssvd=new SSVDSolver(conf,new Path[]{aPath},svdOutPath,ablockRows,k,p,3);
    ssvd.setOuterBlockHeight(500);
    ssvd.setAbtBlockHeight(251);
    ssvd.setComputeU(false);
    ssvd.setComputeV(false);
    ssvd.setOverwrite(true);
    ssvd.setQ(q);
    ssvd.setBroadcast(true);
    ssvd.run();
    Vector stochasticSValues=ssvd.getSingularValues();
    System.out.println("--SSVD solver singular values:");
    dumpSv(stochasticSValues);
    System.out.println("--Colt SVD solver singular values:");
    DenseMatrix a=SSVDHelper.drmLoadAsDense(fs,aPath,conf);
    SingularValueDecomposition svd2=new SingularValueDecomposition(a);
    Vector svalues2=new DenseVector(svd2.getSingularValues());
    dumpSv(svalues2);
    for (int i=0; i < k + p; i++) {
      assertTrue(Math.abs(svalues2.getQuick(i) - stochasticSValues.getQuick(i)) <= s_epsilon);
    }
    DenseMatrix mQ=SSVDHelper.drmLoadAsDense(fs,new Path(svdOutPath,"Bt-job/" + BtJob.OUTPUT_Q + "-*"),conf);
    SSVDCommonTest.assertOrthonormality(mQ,false,s_epsilon);
    IOUtils.close(closeables);
  }
  static void dumpSv(  Vector s){
    System.out.printf("svs: ");
    for (    Vector.Element el : s.all()) {
      System.out.printf("%f  ",el.get());
    }
    System.out.println();
  }
  static void dump(  double[][] matrix){
    for (    double[] aMatrix : matrix) {
      for (      double anAMatrix : aMatrix) {
        System.out.printf("%f  ",anAMatrix);
      }
      System.out.println();
    }
  }
}
