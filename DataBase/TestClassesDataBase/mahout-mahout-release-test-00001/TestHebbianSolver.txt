/** 
 * This test is woefully inadequate, and also requires tons of memory, because it's part unit test, part performance test, and part comparison test (between the Hebbian and Lanczos approaches). TODO: make better.
 */
public final class TestHebbianSolver extends SolverTest {
  public static long timeSolver(  Matrix corpus,  double convergence,  int maxNumPasses,  TrainingState state){
    return timeSolver(corpus,convergence,maxNumPasses,10,state);
  }
  public static long timeSolver(  Matrix corpus,  double convergence,  int maxNumPasses,  int desiredRank,  TrainingState state){
    HebbianUpdater updater=new HebbianUpdater();
    AsyncEigenVerifier verifier=new AsyncEigenVerifier();
    HebbianSolver solver=new HebbianSolver(updater,verifier,convergence,maxNumPasses);
    long start=System.nanoTime();
    TrainingState finalState=solver.solve(corpus,desiredRank);
    assertNotNull(finalState);
    state.setCurrentEigens(finalState.getCurrentEigens());
    state.setCurrentEigenValues(finalState.getCurrentEigenValues());
    long time=0L;
    time+=System.nanoTime() - start;
    verifier.close();
    assertEquals(state.getCurrentEigens().numRows(),desiredRank);
    return time / 1000000L;
  }
  public static long timeSolver(  Matrix corpus,  TrainingState state){
    return timeSolver(corpus,state,10);
  }
  public static long timeSolver(  Matrix corpus,  TrainingState state,  int rank){
    return timeSolver(corpus,0.01,20,rank,state);
  }
  @Test public void testHebbianSolver(){
    int numColumns=800;
    Matrix corpus=randomSequentialAccessSparseMatrix(1000,900,numColumns,30,1.0);
    int rank=50;
    Matrix eigens=new DenseMatrix(rank,numColumns);
    TrainingState state=new TrainingState(eigens,null);
    long optimizedTime=timeSolver(corpus,0.00001,5,rank,state);
    eigens=state.getCurrentEigens();
    assertEigen(eigens,corpus,0.05,false);
    assertOrthonormal(eigens,1.0e-6);
    System.out.println("Avg solving (Hebbian) time in ms: " + optimizedTime);
  }
}
