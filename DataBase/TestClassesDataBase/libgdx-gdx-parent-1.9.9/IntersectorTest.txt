public class IntersectorTest {
  /** 
 * Compares two triangles for equality. Triangles must have the same winding, but may begin with different vertex. Values are epsilon compared, with default tolerance. Triangles are assumed to be valid triangles - no duplicate vertices. 
 */
  private static boolean triangleEquals(  float[] base,  int baseOffset,  int stride,  float[] comp){
    assertTrue(stride >= 3);
    assertTrue(base.length - baseOffset >= 9);
    assertTrue(comp.length == 9);
    int offset=-1;
    for (int i=0; i < 3; i++) {
      int b=baseOffset + i * stride;
      if (MathUtils.isEqual(base[b],comp[0]) && MathUtils.isEqual(base[b + 1],comp[1]) && MathUtils.isEqual(base[b + 2],comp[2])) {
        offset=i;
        break;
      }
    }
    assertTrue("Triangles do not have common first vertex.",offset != -1);
    for (int i=0; i < 3; i++) {
      int b=baseOffset + ((offset + i) * stride) % (3 * stride);
      int c=i * stride;
      if (!MathUtils.isEqual(base[b],comp[c]) || !MathUtils.isEqual(base[b + 1],comp[c + 1]) || !MathUtils.isEqual(base[b + 2],comp[c + 2])) {
        return false;
      }
    }
    return true;
  }
  @Test public void testSplitTriangle(){
    Plane plane=new Plane(new Vector3(1,0,0),0);
    SplitTriangle split=new SplitTriangle(3);
{
      float[] fTriangle={-10,0,10,-1,0,0,-12,0,10};
      Intersector.splitTriangle(fTriangle,plane,split);
      assertTrue(split.numBack == 1);
      assertTrue(split.numFront == 0);
      assertTrue(split.total == 1);
      assertTrue(triangleEquals(split.back,0,3,fTriangle));
      fTriangle[4]=5f;
      assertFalse("Test is broken",triangleEquals(split.back,0,3,fTriangle));
    }
{
      float[] fTriangle={10,0,10,1,0,0,12,0,10};
      Intersector.splitTriangle(fTriangle,plane,split);
      assertTrue(split.numBack == 0);
      assertTrue(split.numFront == 1);
      assertTrue(split.total == 1);
      assertTrue(triangleEquals(split.front,0,3,fTriangle));
    }
{
      float[] triangle={-10,0,10,10,0,0,-10,0,-10};
      Intersector.splitTriangle(triangle,plane,split);
      assertTrue(split.numBack == 2);
      assertTrue(split.numFront == 1);
      assertTrue(split.total == 3);
      assertTrue(triangleEquals(split.front,0,3,new float[]{0,0,5,10,0,0,0,0,-5}));
      float[][] firstWay={{-10,0,10,0,0,5,0,0,-5},{-10,0,10,0,0,-5,-10,0,-10}};
      float[][] secondWay={{-10,0,10,0,0,5,-10,0,-10},{0,0,5,0,0,-5,-10,0,-10}};
      float[] base=split.back;
      boolean first=(triangleEquals(base,0,3,firstWay[0]) && triangleEquals(base,9,3,firstWay[1])) || (triangleEquals(base,0,3,firstWay[1]) && triangleEquals(base,9,3,firstWay[0]));
      boolean second=(triangleEquals(base,0,3,secondWay[0]) && triangleEquals(base,9,3,secondWay[1])) || (triangleEquals(base,0,3,secondWay[1]) && triangleEquals(base,9,3,secondWay[0]));
      assertTrue("Either first or second way must be right (first: " + first + ", second: "+ second+ ")",first ^ second);
    }
{
      float[] triangle={10,0,10,-10,0,0,10,0,-10};
      Intersector.splitTriangle(triangle,plane,split);
      assertTrue(split.numBack == 1);
      assertTrue(split.numFront == 2);
      assertTrue(split.total == 3);
      assertTrue(triangleEquals(split.back,0,3,new float[]{0,0,5,-10,0,0,0,0,-5}));
      float[][] firstWay={{10,0,10,0,0,5,0,0,-5},{10,0,10,0,0,-5,10,0,-10}};
      float[][] secondWay={{10,0,10,0,0,5,10,0,-10},{0,0,5,0,0,-5,10,0,-10}};
      float[] base=split.front;
      boolean first=(triangleEquals(base,0,3,firstWay[0]) && triangleEquals(base,9,3,firstWay[1])) || (triangleEquals(base,0,3,firstWay[1]) && triangleEquals(base,9,3,firstWay[0]));
      boolean second=(triangleEquals(base,0,3,secondWay[0]) && triangleEquals(base,9,3,secondWay[1])) || (triangleEquals(base,0,3,secondWay[1]) && triangleEquals(base,9,3,secondWay[0]));
      assertTrue("Either first or second way must be right (first: " + first + ", second: "+ second+ ")",first ^ second);
    }
  }
}
