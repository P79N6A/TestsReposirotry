private static class CustomReduceTakeSecond implements AggregableColumnReduction {
  @Override public IAggregableReduceOp<Writable,List<Writable>> reduceOp(){
    return new AggregableMultiOp<>(Collections.<IAggregableReduceOp<Writable,Writable>>singletonList(new AggregableSecond<Writable>()));
  }
  @Override public List<String> getColumnsOutputName(  String columnInputName){
    return Collections.singletonList("myCustomReduce(" + columnInputName + ")");
  }
  @Override public List<ColumnMetaData> getColumnOutputMetaData(  List<String> newColumnName,  ColumnMetaData columnInputMeta){
    ColumnMetaData thiscolumnMeta=new StringMetaData(newColumnName.get(0));
    return Collections.singletonList(thiscolumnMeta);
  }
public static class AggregableSecond<T> implements IAggregableReduceOp<T,Writable> {
    @Getter private T firstMet=null;
    @Getter private T elem=null;
    @Override public void accept(    T element){
      if (firstMet == null)       firstMet=element;
 else {
        if (elem == null)         elem=element;
      }
    }
    @Override public <W extends IAggregableReduceOp<T,Writable>>void combine(    W accu){
      if (accu instanceof AggregableSecond && elem == null) {
        if (firstMet == null) {
          AggregableSecond<T> accumulator=(AggregableSecond)accu;
          T otherFirst=accumulator.getFirstMet();
          T otherElement=accumulator.getElem();
          if (otherFirst != null)           firstMet=otherFirst;
          if (otherElement != null)           elem=otherElement;
        }
 else {
          AggregableSecond<T> accumulator=(AggregableSecond)accu;
          T otherFirst=accumulator.getFirstMet();
          if (otherFirst != null)           elem=otherFirst;
        }
      }
    }
    @Override public Writable get(){
      return UnsafeWritableInjector.inject(elem);
    }
  }
  /** 
 * Get the output schema for this transformation, given an input schema
 * @param inputSchema
 */
  @Override public Schema transform(  Schema inputSchema){
    return null;
  }
  /** 
 * Set the input schema.
 * @param inputSchema
 */
  @Override public void setInputSchema(  Schema inputSchema){
  }
  /** 
 * Getter for input schema
 * @return
 */
  @Override public Schema getInputSchema(){
    return null;
  }
  /** 
 * The output column name after the operation has been applied
 * @return the output column name
 */
  @Override public String outputColumnName(){
    return null;
  }
  /** 
 * The output column names This will often be the same as the input
 * @return the output column names
 */
  @Override public String[] outputColumnNames(){
    return new String[0];
  }
  /** 
 * Returns column names this op is meant to run on
 * @return
 */
  @Override public String[] columnNames(){
    return new String[0];
  }
  /** 
 * Returns a singular column name this op is meant to run on
 * @return
 */
  @Override public String columnName(){
    return null;
  }
}
