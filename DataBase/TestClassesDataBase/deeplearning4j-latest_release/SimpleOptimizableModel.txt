/** 
 * Simple abstract class to deal with the fact that we don't care about the majority of the Model/Layer methods here. Classes extending this model for optimizer tests need only implement the score() and gradient() methods.
 */
private static abstract class SimpleOptimizableModel implements Model, Layer {
  private static final long serialVersionUID=4409380971404019303L;
  protected INDArray parameters;
  protected INDArray gradientView;
  protected final NeuralNetConfiguration conf;
  protected Gradient gradient;
  protected double score;
  /** 
 * @param parameterInit Initial parameters. Also determines dimensionality of problem. Should be row vector.
 */
  private SimpleOptimizableModel(  INDArray parameterInit,  NeuralNetConfiguration conf){
    this.parameters=parameterInit.dup();
    this.gradientView=Nd4j.create(parameterInit.shape());
    this.conf=conf;
  }
  @Override public void addListeners(  TrainingListener... listener){
  }
  @Override public TrainingConfig getConfig(){
    return conf.getLayer();
  }
  /** 
 * Init the model
 */
  @Override public void init(){
  }
  @Override public int getIndex(){
    return 0;
  }
  @Override public void setInput(  INDArray input,  LayerWorkspaceMgr workspaceMgr){
  }
  @Override public void fit(){
    throw new UnsupportedOperationException();
  }
  @Override public void update(  INDArray gradient,  String paramType){
    if (!"W".equals(paramType))     throw new UnsupportedOperationException();
    parameters.subi(gradient);
  }
  @Override public void setListeners(  TrainingListener... listeners){
  }
  @Override public void update(  Gradient gradient){
  }
  @Override public INDArray activate(  boolean training,  LayerWorkspaceMgr workspaceMgr){
    return null;
  }
  @Override public INDArray activate(  INDArray input,  boolean training,  LayerWorkspaceMgr workspaceMgr){
    return null;
  }
  @Override public double score(){
    return score;
  }
  @Override public Gradient gradient(){
    return gradient;
  }
  @Override public double calcL2(  boolean backpropParamsOnly){
    return 0;
  }
  @Override public double calcL1(  boolean backpropParamsOnly){
    return 0;
  }
  @Override public void computeGradientAndScore(  LayerWorkspaceMgr workspaceMgr){
    throw new UnsupportedOperationException("Ensure you implement this function.");
  }
  @Override public INDArray params(){
    return parameters;
  }
  @Override public long numParams(){
    return (int)parameters.length();
  }
  @Override public void setParams(  INDArray params){
    this.parameters=params;
  }
  @Override public void fit(  INDArray data,  LayerWorkspaceMgr workspaceMgr){
    throw new UnsupportedOperationException();
  }
  @Override public Pair<Gradient,Double> gradientAndScore(){
    computeGradientAndScore(LayerWorkspaceMgr.noWorkspaces());
    return new Pair<>(gradient(),score());
  }
  @Override public int batchSize(){
    return 1;
  }
  @Override public NeuralNetConfiguration conf(){
    return conf;
  }
  @Override public void setConf(  NeuralNetConfiguration conf){
    throw new UnsupportedOperationException();
  }
  @Override public INDArray input(){
    return Nd4j.zeros(1);
  }
  @Override public ConvexOptimizer getOptimizer(){
    throw new UnsupportedOperationException();
  }
  @Override public INDArray getParam(  String param){
    return parameters;
  }
  @Override public Map<String,INDArray> paramTable(){
    return Collections.singletonMap("W",getParam("W"));
  }
  @Override public Map<String,INDArray> paramTable(  boolean backpropParamsOnly){
    return paramTable();
  }
  @Override public void setParamTable(  Map<String,INDArray> paramTable){
    throw new UnsupportedOperationException();
  }
  @Override public void setParam(  String key,  INDArray val){
    throw new UnsupportedOperationException();
  }
  @Override public void clear(){
    throw new UnsupportedOperationException();
  }
  @Override public Type type(){
    throw new UnsupportedOperationException();
  }
  @Override public Pair<Gradient,INDArray> backpropGradient(  INDArray epsilon,  LayerWorkspaceMgr mgr){
    throw new UnsupportedOperationException();
  }
  @Override public Collection<TrainingListener> getListeners(){
    return null;
  }
  @Override public void setListeners(  Collection<TrainingListener> listeners){
    throw new UnsupportedOperationException();
  }
  @Override public void setIndex(  int index){
    throw new UnsupportedOperationException();
  }
  @Override public void setInputMiniBatchSize(  int size){
  }
  @Override public int getInputMiniBatchSize(){
    return 1;
  }
  @Override public void setMaskArray(  INDArray maskArray){
  }
  @Override public INDArray getMaskArray(){
    return null;
  }
  @Override public Pair<INDArray,MaskState> feedForwardMaskArray(  INDArray maskArray,  MaskState currentMaskState,  int minibatchSize){
    throw new UnsupportedOperationException();
  }
  @Override public INDArray getGradientsViewArray(){
    return gradientView;
  }
  @Override public void applyConstraints(  int iteration,  int epoch){
  }
  @Override public int getIterationCount(){
    return 0;
  }
  @Override public int getEpochCount(){
    return 0;
  }
  @Override public void setIterationCount(  int iterationCount){
  }
  @Override public void setEpochCount(  int epochCount){
  }
  @Override public void allowInputModification(  boolean allow){
  }
  @Override public LayerHelper getHelper(){
    return null;
  }
  @Override public boolean updaterDivideByMinibatch(  String paramName){
    return true;
  }
}
