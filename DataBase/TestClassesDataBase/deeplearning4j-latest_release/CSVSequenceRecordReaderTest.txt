public class CSVSequenceRecordReaderTest {
  @Rule public TemporaryFolder tempDir=new TemporaryFolder();
  @Test public void test() throws Exception {
    CSVSequenceRecordReader seqReader=new CSVSequenceRecordReader(1,",");
    seqReader.initialize(new TestInputSplit());
    int sequenceCount=0;
    while (seqReader.hasNext()) {
      List<List<Writable>> sequence=seqReader.sequenceRecord();
      assertEquals(4,sequence.size());
      Iterator<List<Writable>> timeStepIter=sequence.iterator();
      int lineCount=0;
      while (timeStepIter.hasNext()) {
        List<Writable> timeStep=timeStepIter.next();
        assertEquals(3,timeStep.size());
        Iterator<Writable> lineIter=timeStep.iterator();
        int countInLine=0;
        while (lineIter.hasNext()) {
          Writable entry=lineIter.next();
          int expValue=100 * sequenceCount + 10 * lineCount + countInLine;
          assertEquals(String.valueOf(expValue),entry.toString());
          countInLine++;
        }
        lineCount++;
      }
      sequenceCount++;
    }
  }
  @Test public void testReset() throws Exception {
    CSVSequenceRecordReader seqReader=new CSVSequenceRecordReader(1,",");
    seqReader.initialize(new TestInputSplit());
    int nTests=5;
    for (int i=0; i < nTests; i++) {
      seqReader.reset();
      int sequenceCount=0;
      while (seqReader.hasNext()) {
        List<List<Writable>> sequence=seqReader.sequenceRecord();
        assertEquals(4,sequence.size());
        Iterator<List<Writable>> timeStepIter=sequence.iterator();
        int lineCount=0;
        while (timeStepIter.hasNext()) {
          timeStepIter.next();
          lineCount++;
        }
        sequenceCount++;
        assertEquals(4,lineCount);
      }
      assertEquals(3,sequenceCount);
    }
  }
  @Test public void testMetaData() throws Exception {
    CSVSequenceRecordReader seqReader=new CSVSequenceRecordReader(1,",");
    seqReader.initialize(new TestInputSplit());
    List<List<List<Writable>>> l=new ArrayList<>();
    while (seqReader.hasNext()) {
      List<List<Writable>> sequence=seqReader.sequenceRecord();
      assertEquals(4,sequence.size());
      Iterator<List<Writable>> timeStepIter=sequence.iterator();
      int lineCount=0;
      while (timeStepIter.hasNext()) {
        timeStepIter.next();
        lineCount++;
      }
      assertEquals(4,lineCount);
      l.add(sequence);
    }
    List<SequenceRecord> l2=new ArrayList<>();
    List<RecordMetaData> meta=new ArrayList<>();
    seqReader.reset();
    while (seqReader.hasNext()) {
      SequenceRecord sr=seqReader.nextSequence();
      l2.add(sr);
      meta.add(sr.getMetaData());
    }
    assertEquals(3,l2.size());
    List<SequenceRecord> fromMeta=seqReader.loadSequenceFromMetaData(meta);
    for (int i=0; i < 3; i++) {
      assertEquals(l.get(i),l2.get(i).getSequenceRecord());
      assertEquals(l.get(i),fromMeta.get(i).getSequenceRecord());
    }
  }
private static class TestInputSplit implements InputSplit {
    @Override public boolean canWriteToLocation(    URI location){
      return false;
    }
    @Override public String addNewLocation(){
      return null;
    }
    @Override public String addNewLocation(    String location){
      return null;
    }
    @Override public void updateSplitLocations(    boolean reset){
    }
    @Override public boolean needsBootstrapForWrite(){
      return false;
    }
    @Override public void bootStrapForWrite(){
    }
    @Override public OutputStream openOutputStreamFor(    String location) throws Exception {
      return null;
    }
    @Override public InputStream openInputStreamFor(    String location) throws Exception {
      return null;
    }
    @Override public long length(){
      return 3;
    }
    @Override public URI[] locations(){
      URI[] arr=new URI[3];
      try {
        arr[0]=new ClassPathResource("datavec-api/csvsequence_0.txt").getFile().toURI();
        arr[1]=new ClassPathResource("datavec-api/csvsequence_1.txt").getFile().toURI();
        arr[2]=new ClassPathResource("datavec-api/csvsequence_2.txt").getFile().toURI();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
      return arr;
    }
    @Override public Iterator<URI> locationsIterator(){
      return Arrays.asList(locations()).iterator();
    }
    @Override public Iterator<String> locationsPathIterator(){
      URI[] loc=locations();
      String[] arr=new String[loc.length];
      for (int i=0; i < loc.length; i++) {
        arr[i]=loc[i].toString();
      }
      return Arrays.asList(arr).iterator();
    }
    @Override public void reset(){
    }
    @Override public boolean resetSupported(){
      return true;
    }
  }
  @Test public void testCsvSeqAndNumberedFileSplit() throws Exception {
    File baseDir=tempDir.newFolder();
    for (int i=0; i < 3; i++) {
      new org.nd4j.linalg.io.ClassPathResource(String.format("csvsequence_%d.txt",i)).getTempFileFromArchive(baseDir);
    }
    org.nd4j.linalg.io.ClassPathResource resource=new org.nd4j.linalg.io.ClassPathResource("csvsequence_0.txt");
    String featuresPath=new File(baseDir,"csvsequence_%d.txt").getAbsolutePath();
    SequenceRecordReader featureReader=new CSVSequenceRecordReader(1,",");
    featureReader.initialize(new NumberedFileInputSplit(featuresPath,0,2));
    while (featureReader.hasNext()) {
      featureReader.nextSequence();
    }
  }
}
