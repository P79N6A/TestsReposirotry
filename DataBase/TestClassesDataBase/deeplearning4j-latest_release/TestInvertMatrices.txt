/** 
 * Created by agibsoncccc on 12/7/15.
 */
@RunWith(Parameterized.class) public class TestInvertMatrices extends BaseNd4jTest {
  public TestInvertMatrices(  Nd4jBackend backend){
    super(backend);
  }
  @Test public void testInverse(){
    RealMatrix matrix=new Array2DRowRealMatrix(new double[][]{{1,2},{3,4}});
    RealMatrix inverse=MatrixUtils.inverse(matrix);
    INDArray arr=InvertMatrix.invert(Nd4j.linspace(1,4,4).reshape(2,2),false);
    for (int i=0; i < inverse.getRowDimension(); i++) {
      for (int j=0; j < inverse.getColumnDimension(); j++) {
        assertEquals(arr.getDouble(i,j),inverse.getEntry(i,j),1e-1);
      }
    }
  }
  @Test public void testInverseComparison(){
    List<Pair<INDArray,String>> list=NDArrayCreationUtil.getAllTestMatricesWithShape(10,10,12345);
    for (    Pair<INDArray,String> p : list) {
      INDArray orig=p.getFirst();
      orig.assign(Nd4j.rand(orig.shape()));
      INDArray inverse=InvertMatrix.invert(orig,false);
      RealMatrix rm=CheckUtil.convertToApacheMatrix(orig);
      RealMatrix rmInverse=new LUDecomposition(rm).getSolver().getInverse();
      INDArray expected=CheckUtil.convertFromApacheMatrix(rmInverse);
      assertTrue(p.getSecond(),CheckUtil.checkEntries(expected,inverse,1e-3,1e-4));
    }
  }
  @Test public void testInvalidMatrixInversion(){
    try {
      InvertMatrix.invert(Nd4j.create(5,4),false);
      fail("No exception thrown for invalid input");
    }
 catch (    Exception e) {
    }
    try {
      InvertMatrix.invert(Nd4j.create(5,5,5),false);
      fail("No exception thrown for invalid input");
    }
 catch (    Exception e) {
    }
    try {
      InvertMatrix.invert(Nd4j.create(1,5),false);
      fail("No exception thrown for invalid input");
    }
 catch (    Exception e) {
    }
  }
  /** 
 * Example from: <a href="https://www.wolframalpha.com/input/?i=invert+matrix+((1,2),(3,4),(5,6))">here</a>
 */
  @Test public void testLeftPseudoInvert(){
    INDArray X=Nd4j.create(new double[][]{{1,2},{3,4},{5,6}});
    INDArray expectedLeftInverse=Nd4j.create(new double[][]{{-16,-4,8},{13,4,-5}}).mul(1 / 12d);
    INDArray leftInverse=InvertMatrix.pLeftInvert(X,false);
    assertEquals(expectedLeftInverse,leftInverse);
    final INDArray identity3x3=Nd4j.create(new double[][]{{1,0,0},{0,1,0},{0,0,1}});
    final INDArray identity2x2=Nd4j.create(new double[][]{{1,0},{0,1}});
    final double precision=1e-5;
    final INDArray rightInverseCheck=X.mmul(leftInverse);
    assertFalse(rightInverseCheck.equalsWithEps(identity3x3,precision));
    final INDArray leftInverseCheck=leftInverse.mmul(X);
    assertTrue(leftInverseCheck.equalsWithEps(identity2x2,precision));
    final INDArray generalCond=X.mmul(leftInverse).mmul(X);
    assertTrue(X.equalsWithEps(generalCond,precision));
    checkMoorePenroseConditions(X,leftInverse,precision);
  }
  /** 
 * Check the Moore-Penrose conditions for pseudo-matrices.
 * @param A Initial matrix
 * @param B Pseudo-Inverse of {@code A}
 * @param precision Precision when comparing matrix elements
 */
  private void checkMoorePenroseConditions(  INDArray A,  INDArray B,  double precision){
    assertTrue(A.equalsWithEps(A.mmul(B).mmul(A),precision));
    assertTrue(B.equalsWithEps(B.mmul(A).mmul(B),precision));
    assertTrue((A.mmul(B)).transpose().equalsWithEps(A.mmul(B),precision));
    assertTrue((B.mmul(A)).transpose().equalsWithEps(B.mmul(A),precision));
  }
  /** 
 * Example from: <a href="https://www.wolframalpha.com/input/?i=invert+matrix+((1,2),(3,4),(5,6))^T">here</a>
 */
  @Test public void testRightPseudoInvert(){
    INDArray X=Nd4j.create(new double[][]{{1,2},{3,4},{5,6}}).transpose();
    INDArray expectedRightInverse=Nd4j.create(new double[][]{{-16,13},{-4,4},{8,-5}}).mul(1 / 12d);
    INDArray rightInverse=InvertMatrix.pRightInvert(X,false);
    assertEquals(expectedRightInverse,rightInverse);
    final INDArray identity3x3=Nd4j.create(new double[][]{{1,0,0},{0,1,0},{0,0,1}});
    final INDArray identity2x2=Nd4j.create(new double[][]{{1,0},{0,1}});
    final double precision=1e-5;
    final INDArray leftInverseCheck=rightInverse.mmul(X);
    assertFalse(leftInverseCheck.equalsWithEps(identity3x3,precision));
    final INDArray rightInverseCheck=X.mmul(rightInverse);
    assertTrue(rightInverseCheck.equalsWithEps(identity2x2,precision));
    final INDArray generalCond=X.mmul(rightInverse).mmul(X);
    assertTrue(X.equalsWithEps(generalCond,precision));
    checkMoorePenroseConditions(X,rightInverse,precision);
  }
  /** 
 * Try to compute the right pseudo inverse of a matrix without full row rank (x1 = 2*x2)
 */
  @Test(expected=IllegalArgumentException.class) public void testRightPseudoInvertWithNonFullRowRank(){
    INDArray X=Nd4j.create(new double[][]{{1,2},{3,6},{5,10}}).transpose();
    INDArray rightInverse=InvertMatrix.pRightInvert(X,false);
  }
  /** 
 * Try to compute the left pseudo inverse of a matrix without full column rank (x1 = 2*x2)
 */
  @Test(expected=IllegalArgumentException.class) public void testLeftPseudoInvertWithNonFullColumnRank(){
    INDArray X=Nd4j.create(new double[][]{{1,2},{3,6},{5,10}});
    INDArray leftInverse=InvertMatrix.pLeftInvert(X,false);
  }
  @Override public char ordering(){
    return 'c';
  }
}
