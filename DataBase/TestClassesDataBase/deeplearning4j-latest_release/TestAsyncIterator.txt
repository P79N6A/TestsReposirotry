/** 
 * @author Alex Black
 */
@Ignore public class TestAsyncIterator extends BaseDL4JTest {
  @Test public void testBasic(){
    int size=13;
    DataSetIterator baseIter=new TestIterator(size,0);
    DataSetIterator async=new AsyncDataSetIterator(baseIter,1);
    for (int i=0; i < size; i++) {
      assertTrue(async.hasNext());
      DataSet ds=async.next();
      assertEquals(ds.getFeatures().getDouble(0),i,0.0);
      assertEquals(ds.getLabels().getDouble(0),i,0.0);
    }
    assertFalse(async.hasNext());
    async.reset();
    assertTrue(async.hasNext());
    ((AsyncDataSetIterator)async).shutdown();
    baseIter=new TestIterator(size,5);
    async=new AsyncDataSetIterator(baseIter,5);
    for (int i=0; i < size; i++) {
      assertTrue(async.hasNext());
      DataSet ds=async.next();
      assertEquals(ds.getFeatures().getDouble(0),i,0.0);
      assertEquals(ds.getLabels().getDouble(0),i,0.0);
    }
    assertFalse(async.hasNext());
    async.reset();
    assertTrue(async.hasNext());
    ((AsyncDataSetIterator)async).shutdown();
    baseIter=new TestIterator(size,100);
    async=new AsyncDataSetIterator(baseIter,100);
    for (int i=0; i < size; i++) {
      assertTrue(async.hasNext());
      DataSet ds=async.next();
      while (ds == null)       ds=async.next();
      assertEquals(ds.getFeatures().getDouble(0),i,0.0);
      assertEquals(ds.getLabels().getDouble(0),i,0.0);
    }
    assertFalse(async.hasNext());
    async.reset();
    assertTrue(async.hasNext());
    ((AsyncDataSetIterator)async).shutdown();
    baseIter=new TestIterator(size,1000);
    async=new AsyncDataSetIterator(baseIter,5);
    for (int i=0; i < size; i++) {
      assertTrue(async.hasNext());
      DataSet ds=async.next();
      assertEquals(ds.getFeatures().getDouble(0),i,0.0);
      assertEquals(ds.getLabels().getDouble(0),i,0.0);
    }
    assertFalse(async.hasNext());
    async.reset();
    assertTrue(async.hasNext());
    ((AsyncDataSetIterator)async).shutdown();
  }
  @Test public void testInitializeNoNextIter(){
    DataSetIterator iter=new IrisDataSetIterator(10,150);
    while (iter.hasNext())     iter.next();
    DataSetIterator async=new AsyncDataSetIterator(iter,2);
    assertFalse(iter.hasNext());
    assertFalse(async.hasNext());
    try {
      iter.next();
      fail("Should have thrown NoSuchElementException");
    }
 catch (    Exception e) {
    }
    async.reset();
    int count=0;
    while (async.hasNext()) {
      async.next();
      count++;
    }
    assertEquals(150 / 10,count);
  }
  @Test public void testResetWhileBlocking(){
    int size=6;
    DataSetIterator baseIter=new TestIterator(size,1000);
    AsyncDataSetIterator async=new AsyncDataSetIterator(baseIter);
    async.next();
    async.reset();
    for (int i=0; i < 6; i++) {
      assertTrue(async.hasNext());
      DataSet ds=async.next();
      assertEquals(ds.getFeatures().getDouble(0),i,0.0);
      assertEquals(ds.getLabels().getDouble(0),i,0.0);
    }
    assertFalse(async.hasNext());
    async.shutdown();
    baseIter=new TestIterator(size,0);
    async=new AsyncDataSetIterator(baseIter);
    async.next();
    async.next();
    async.reset();
    for (int i=0; i < 6; i++) {
      assertTrue(async.hasNext());
      DataSet ds=async.next();
      assertEquals(ds.getFeatures().getDouble(0),i,0.0);
      assertEquals(ds.getLabels().getDouble(0),i,0.0);
    }
    assertFalse(async.hasNext());
    async.shutdown();
  }
private static class TestIterator implements DataSetIterator {
    private int size;
    private int cursor;
    private long delayMSOnNext;
    private TestIterator(    int size,    long delayMSOnNext){
      this.size=size;
      this.cursor=0;
      this.delayMSOnNext=delayMSOnNext;
    }
    @Override public DataSet next(    int num){
      throw new UnsupportedOperationException();
    }
    @Override public int inputColumns(){
      return 1;
    }
    @Override public int totalOutcomes(){
      return 1;
    }
    @Override public boolean resetSupported(){
      return true;
    }
    @Override public boolean asyncSupported(){
      return false;
    }
    @Override public void reset(){
      cursor=0;
    }
    @Override public int batch(){
      return 1;
    }
    @Override public void setPreProcessor(    DataSetPreProcessor preProcessor){
      throw new UnsupportedOperationException();
    }
    @Override public DataSetPreProcessor getPreProcessor(){
      throw new UnsupportedOperationException();
    }
    @Override public List<String> getLabels(){
      return null;
    }
    @Override public boolean hasNext(){
      return cursor < size;
    }
    @Override public DataSet next(){
      if (delayMSOnNext > 0) {
        try {
          Thread.sleep(delayMSOnNext);
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
      INDArray features=Nd4j.scalar(cursor);
      INDArray labels=Nd4j.scalar(cursor);
      cursor++;
      return new DataSet(features,labels);
    }
    @Override public void remove(){
    }
  }
}
