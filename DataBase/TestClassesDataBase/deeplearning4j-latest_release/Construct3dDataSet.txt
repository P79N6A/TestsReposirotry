public class Construct3dDataSet {
  DataSet sampleDataSet;
  INDArray featureScale;
  int numFeatures, maxN, timeSteps, samples, origin, newOrigin;
  INDArray expectedMean, expectedStd, expectedMin, expectedMax;
  public Construct3dDataSet(  INDArray featureScale,  int timeSteps,  int samples,  int origin){
    this.featureScale=featureScale;
    this.timeSteps=timeSteps;
    this.samples=samples;
    this.origin=origin;
    numFeatures=(int)featureScale.size(0);
    maxN=samples * timeSteps;
    INDArray template=Nd4j.linspace(origin,origin + timeSteps - 1,timeSteps);
    template=Nd4j.concat(0,Nd4j.linspace(origin,origin + timeSteps - 1,timeSteps),template);
    template=Nd4j.concat(0,Nd4j.linspace(origin,origin + timeSteps - 1,timeSteps),template);
    template.muliColumnVector(featureScale);
    template=template.reshape(1,numFeatures,timeSteps);
    INDArray featureMatrix=template.dup();
    int newStart=origin + timeSteps;
    int newEnd;
    for (int i=1; i < samples; i++) {
      newEnd=newStart + timeSteps - 1;
      template=Nd4j.linspace(newStart,newEnd,timeSteps);
      template=Nd4j.concat(0,Nd4j.linspace(newStart,newEnd,timeSteps),template);
      template=Nd4j.concat(0,Nd4j.linspace(newStart,newEnd,timeSteps),template);
      template.muliColumnVector(featureScale);
      template=template.reshape(1,numFeatures,timeSteps);
      newStart=newEnd + 1;
      featureMatrix=Nd4j.concat(0,featureMatrix,template);
    }
    INDArray labelSet=featureMatrix.dup();
    this.newOrigin=newStart;
    sampleDataSet=new DataSet(featureMatrix,labelSet);
    float theoreticalMean=origin - 1 + (samples * timeSteps + 1) / 2.0f;
    expectedMean=Nd4j.create(new double[]{theoreticalMean,theoreticalMean,theoreticalMean}).reshape(3,1);
    expectedMean.muliColumnVector(featureScale);
    float stdNaturalNums=(float)Math.sqrt((samples * samples * timeSteps* timeSteps - 1) / 12);
    expectedStd=Nd4j.create(new float[]{stdNaturalNums,stdNaturalNums,stdNaturalNums}).reshape(3,1);
    expectedStd.muliColumnVector(Transforms.abs(featureScale,true));
    expectedStd=expectedStd.dup().muli(Math.sqrt(maxN)).divi(Math.sqrt(maxN)).transpose();
    expectedMin=Nd4j.ones(3,1).muliColumnVector(featureScale);
    expectedMax=Nd4j.ones(3,1).muli(samples * timeSteps).muliColumnVector(featureScale);
  }
}
