/** 
 * Created by Alex on 04/11/2016.
 */
public class ROCTest extends BaseNd4jTest {
  public ROCTest(  Nd4jBackend backend){
    super(backend);
  }
  @Override public char ordering(){
    return 'c';
  }
  private static Map<Double,Double> expTPR;
  private static Map<Double,Double> expFPR;
static {
    expTPR=new HashMap<>();
    double totalPositives=5.0;
    expTPR.put(0 / 10.0,5.0 / totalPositives);
    expTPR.put(1 / 10.0,5.0 / totalPositives);
    expTPR.put(2 / 10.0,5.0 / totalPositives);
    expTPR.put(3 / 10.0,5.0 / totalPositives);
    expTPR.put(4 / 10.0,5.0 / totalPositives);
    expTPR.put(5 / 10.0,5.0 / totalPositives);
    expTPR.put(6 / 10.0,4.0 / totalPositives);
    expTPR.put(7 / 10.0,3.0 / totalPositives);
    expTPR.put(8 / 10.0,2.0 / totalPositives);
    expTPR.put(9 / 10.0,1.0 / totalPositives);
    expTPR.put(10 / 10.0,0.0 / totalPositives);
    expFPR=new HashMap<>();
    double totalNegatives=5.0;
    expFPR.put(0 / 10.0,5.0 / totalNegatives);
    expFPR.put(1 / 10.0,4.0 / totalNegatives);
    expFPR.put(2 / 10.0,3.0 / totalNegatives);
    expFPR.put(3 / 10.0,2.0 / totalNegatives);
    expFPR.put(4 / 10.0,1.0 / totalNegatives);
    expFPR.put(5 / 10.0,0.0 / totalNegatives);
    expFPR.put(6 / 10.0,0.0 / totalNegatives);
    expFPR.put(7 / 10.0,0.0 / totalNegatives);
    expFPR.put(8 / 10.0,0.0 / totalNegatives);
    expFPR.put(9 / 10.0,0.0 / totalNegatives);
    expFPR.put(10 / 10.0,0.0 / totalNegatives);
  }
  @Test public void testRocBasic(){
    INDArray predictions=Nd4j.create(new double[][]{{1.0,0.001},{0.899,0.101},{0.799,0.201},{0.699,0.301},{0.599,0.401},{0.499,0.501},{0.399,0.601},{0.299,0.701},{0.199,0.801},{0.099,0.901}});
    INDArray actual=Nd4j.create(new double[][]{{1,0},{1,0},{1,0},{1,0},{1,0},{0,1},{0,1},{0,1},{0,1},{0,1}});
    ROC roc=new ROC(10);
    roc.eval(actual,predictions);
    RocCurve rocCurve=roc.getRocCurve();
    assertEquals(11,rocCurve.getThreshold().length);
    for (int i=0; i < 11; i++) {
      double expThreshold=i / 10.0;
      assertEquals(expThreshold,rocCurve.getThreshold(i),1e-5);
      double efpr=expFPR.get(expThreshold);
      double afpr=rocCurve.getFalsePositiveRate(i);
      assertEquals(efpr,afpr,1e-5);
      double etpr=expTPR.get(expThreshold);
      double atpr=rocCurve.getTruePositiveRate(i);
      assertEquals(etpr,atpr,1e-5);
    }
    double auc=roc.calculateAUC();
    assertEquals(1.0,auc,1e-6);
    roc.reset();
    roc.eval(actual,predictions);
    auc=roc.calculateAUC();
    assertEquals(1.0,auc,1e-6);
  }
  @Test public void testRocBasicSingleClass(){
    INDArray predictions=Nd4j.create(new double[]{0.001,0.101,0.201,0.301,0.401,0.501,0.601,0.701,0.801,0.901},new int[]{10,1});
    INDArray actual=Nd4j.create(new double[]{0,0,0,0,0,1,1,1,1,1},new int[]{10,1});
    ROC roc=new ROC(10);
    roc.eval(actual,predictions);
    RocCurve rocCurve=roc.getRocCurve();
    assertEquals(11,rocCurve.getThreshold().length);
    for (int i=0; i < 11; i++) {
      double expThreshold=i / 10.0;
      assertEquals(expThreshold,rocCurve.getThreshold(i),1e-5);
      double efpr=expFPR.get(expThreshold);
      double afpr=rocCurve.getFalsePositiveRate(i);
      assertEquals(efpr,afpr,1e-5);
      double etpr=expTPR.get(expThreshold);
      double atpr=rocCurve.getTruePositiveRate(i);
      assertEquals(etpr,atpr,1e-5);
    }
    double auc=roc.calculateAUC();
    assertEquals(1.0,auc,1e-6);
  }
  @Test public void testRoc(){
    INDArray labels=Nd4j.create(new double[][]{{0,1},{0,1},{1,0},{1,0},{1,0}});
    INDArray prediction=Nd4j.create(new double[][]{{0.199,0.801},{0.499,0.501},{0.399,0.601},{0.799,0.201},{0.899,0.101}});
    Map<Double,Double> expTPR=new HashMap<>();
    double totalPositives=2.0;
    expTPR.put(0.0,2.0 / totalPositives);
    expTPR.put(0.1,2.0 / totalPositives);
    expTPR.put(0.2,2.0 / totalPositives);
    expTPR.put(0.3,2.0 / totalPositives);
    expTPR.put(0.4,2.0 / totalPositives);
    expTPR.put(0.5,2.0 / totalPositives);
    expTPR.put(0.6,1.0 / totalPositives);
    expTPR.put(0.7,1.0 / totalPositives);
    expTPR.put(0.8,1.0 / totalPositives);
    expTPR.put(0.9,0.0 / totalPositives);
    expTPR.put(1.0,0.0 / totalPositives);
    Map<Double,Double> expFPR=new HashMap<>();
    double totalNegatives=3.0;
    expFPR.put(0.0,3.0 / totalNegatives);
    expFPR.put(0.1,3.0 / totalNegatives);
    expFPR.put(0.2,2.0 / totalNegatives);
    expFPR.put(0.3,1.0 / totalNegatives);
    expFPR.put(0.4,1.0 / totalNegatives);
    expFPR.put(0.5,1.0 / totalNegatives);
    expFPR.put(0.6,1.0 / totalNegatives);
    expFPR.put(0.7,0.0 / totalNegatives);
    expFPR.put(0.8,0.0 / totalNegatives);
    expFPR.put(0.9,0.0 / totalNegatives);
    expFPR.put(1.0,0.0 / totalNegatives);
    int[] expTPs=new int[]{2,2,2,2,2,2,1,1,1,0,0};
    int[] expFPs=new int[]{3,3,2,1,1,1,1,0,0,0,0};
    int[] expFNs=new int[11];
    int[] expTNs=new int[11];
    for (int i=0; i < 11; i++) {
      expFNs[i]=(int)totalPositives - expTPs[i];
      expTNs[i]=5 - expTPs[i] - expFPs[i]- expFNs[i];
    }
    ROC roc=new ROC(10);
    roc.eval(labels,prediction);
    RocCurve rocCurve=roc.getRocCurve();
    assertEquals(11,rocCurve.getThreshold().length);
    assertEquals(11,rocCurve.getFpr().length);
    assertEquals(11,rocCurve.getTpr().length);
    for (int i=0; i < 11; i++) {
      double expThreshold=i / 10.0;
      assertEquals(expThreshold,rocCurve.getThreshold(i),1e-5);
      double efpr=expFPR.get(expThreshold);
      double afpr=rocCurve.getFalsePositiveRate(i);
      assertEquals(efpr,afpr,1e-5);
      double etpr=expTPR.get(expThreshold);
      double atpr=rocCurve.getTruePositiveRate(i);
      assertEquals(etpr,atpr,1e-5);
    }
    double expAUC=0.5 * 1.0 / 3.0 + (1 - 1 / 3.0) * 1.0;
    double actAUC=roc.calculateAUC();
    assertEquals(expAUC,actAUC,1e-6);
    PrecisionRecallCurve prc=roc.getPrecisionRecallCurve();
    for (int i=0; i < 11; i++) {
      PrecisionRecallCurve.Confusion c=prc.getConfusionMatrixAtThreshold(i * 0.1);
      assertEquals(expTPs[i],c.getTpCount());
      assertEquals(expFPs[i],c.getFpCount());
      assertEquals(expFPs[i],c.getFpCount());
      assertEquals(expTNs[i],c.getTnCount());
    }
  }
  @Test public void testRocTimeSeriesNoMasking(){
    INDArray predictions2d=Nd4j.create(new double[][]{{1.0,0.001},{0.899,0.101},{0.799,0.201},{0.699,0.301},{0.599,0.401},{0.499,0.501},{0.399,0.601},{0.299,0.701},{0.199,0.801},{0.099,0.901}});
    INDArray actual2d=Nd4j.create(new double[][]{{1,0},{1,0},{1,0},{1,0},{1,0},{0,1},{0,1},{0,1},{0,1},{0,1}});
    INDArray predictions3d=Nd4j.create(2,2,5);
    INDArray firstTSp=predictions3d.get(NDArrayIndex.point(0),NDArrayIndex.all(),NDArrayIndex.all()).transpose();
    assertArrayEquals(new long[]{5,2},firstTSp.shape());
    firstTSp.assign(predictions2d.get(NDArrayIndex.interval(0,5),NDArrayIndex.all()));
    INDArray secondTSp=predictions3d.get(NDArrayIndex.point(1),NDArrayIndex.all(),NDArrayIndex.all()).transpose();
    assertArrayEquals(new long[]{5,2},secondTSp.shape());
    secondTSp.assign(predictions2d.get(NDArrayIndex.interval(5,10),NDArrayIndex.all()));
    INDArray labels3d=Nd4j.create(2,2,5);
    INDArray firstTS=labels3d.get(NDArrayIndex.point(0),NDArrayIndex.all(),NDArrayIndex.all()).transpose();
    assertArrayEquals(new long[]{5,2},firstTS.shape());
    firstTS.assign(actual2d.get(NDArrayIndex.interval(0,5),NDArrayIndex.all()));
    INDArray secondTS=labels3d.get(NDArrayIndex.point(1),NDArrayIndex.all(),NDArrayIndex.all()).transpose();
    assertArrayEquals(new long[]{5,2},secondTS.shape());
    secondTS.assign(actual2d.get(NDArrayIndex.interval(5,10),NDArrayIndex.all()));
    for (    int steps : new int[]{10,0}) {
      ROC rocExp=new ROC(steps);
      rocExp.eval(actual2d,predictions2d);
      ROC rocAct=new ROC(steps);
      rocAct.evalTimeSeries(labels3d,predictions3d);
      assertEquals(rocExp.calculateAUC(),rocAct.calculateAUC(),1e-6);
      assertEquals(rocExp.calculateAUCPR(),rocAct.calculateAUCPR(),1e-6);
      assertEquals(rocExp.getRocCurve(),rocAct.getRocCurve());
    }
  }
  @Test public void testRocTimeSeriesMasking(){
    INDArray predictions2d=Nd4j.create(new double[][]{{1.0,0.001},{0.899,0.101},{0.799,0.201},{0.699,0.301},{0.599,0.401},{0.499,0.501},{0.399,0.601},{0.299,0.701},{0.199,0.801},{0.099,0.901}});
    INDArray actual2d=Nd4j.create(new double[][]{{1,0},{1,0},{1,0},{1,0},{1,0},{0,1},{0,1},{0,1},{0,1},{0,1}});
    INDArray predictions3d=Nd4j.create(2,2,6);
    INDArray tad=predictions3d.tensorAlongDimension(0,1,2).transpose();
    tad.get(NDArrayIndex.interval(0,4),NDArrayIndex.all()).assign(predictions2d.get(NDArrayIndex.interval(0,4),NDArrayIndex.all()));
    tad=predictions3d.tensorAlongDimension(1,1,2).transpose();
    tad.assign(predictions2d.get(NDArrayIndex.interval(4,10),NDArrayIndex.all()));
    INDArray labels3d=Nd4j.create(2,2,6);
    tad=labels3d.tensorAlongDimension(0,1,2).transpose();
    tad.get(NDArrayIndex.interval(0,4),NDArrayIndex.all()).assign(actual2d.get(NDArrayIndex.interval(0,4),NDArrayIndex.all()));
    tad=labels3d.tensorAlongDimension(1,1,2).transpose();
    tad.assign(actual2d.get(NDArrayIndex.interval(4,10),NDArrayIndex.all()));
    INDArray mask=Nd4j.zeros(2,6);
    mask.get(NDArrayIndex.point(0),NDArrayIndex.interval(0,4)).assign(1);
    mask.get(NDArrayIndex.point(1),NDArrayIndex.all()).assign(1);
    for (    int steps : new int[]{20,0}) {
      ROC rocExp=new ROC(steps);
      rocExp.eval(actual2d,predictions2d);
      ROC rocAct=new ROC(steps);
      rocAct.evalTimeSeries(labels3d,predictions3d,mask);
      assertEquals(rocExp.calculateAUC(),rocAct.calculateAUC(),1e-6);
      assertEquals(rocExp.getRocCurve(),rocAct.getRocCurve());
    }
  }
  @Test public void testCompareRocAndRocMultiClass(){
    Nd4j.getRandom().setSeed(12345);
    int nExamples=200;
    INDArray predictions=Nd4j.rand(nExamples,2);
    INDArray tempSum=predictions.sum(1);
    predictions.diviColumnVector(tempSum);
    INDArray labels=Nd4j.create(nExamples,2);
    Random r=new Random(12345);
    for (int i=0; i < nExamples; i++) {
      labels.putScalar(i,r.nextInt(2),1.0);
    }
    for (    int numSteps : new int[]{30,0}) {
      ROC roc=new ROC(numSteps);
      roc.eval(labels,predictions);
      ROCMultiClass rocMultiClass=new ROCMultiClass(numSteps);
      rocMultiClass.eval(labels,predictions);
      double auc=roc.calculateAUC();
      double auc1=rocMultiClass.calculateAUC(1);
      assertEquals(auc,auc1,1e-6);
    }
  }
  @Test public void testCompare2Vs3Classes(){
    int nExamples=200;
    INDArray predictions3=Nd4j.rand(nExamples,3);
    INDArray tempSum=predictions3.sum(1);
    predictions3.diviColumnVector(tempSum);
    INDArray labels3=Nd4j.create(nExamples,3);
    Random r=new Random(12345);
    for (int i=0; i < nExamples; i++) {
      labels3.putScalar(i,r.nextInt(3),1.0);
    }
    INDArray predictions2=Nd4j.zeros(nExamples,2);
    predictions2.getColumn(0).assign(predictions3.getColumn(0));
    predictions2.getColumn(0).addi(predictions3.getColumn(1));
    predictions2.getColumn(1).addi(predictions3.getColumn(2));
    INDArray labels2=Nd4j.zeros(nExamples,2);
    labels2.getColumn(0).assign(labels3.getColumn(0));
    labels2.getColumn(0).addi(labels3.getColumn(1));
    labels2.getColumn(1).addi(labels3.getColumn(2));
    for (    int numSteps : new int[]{30,0}) {
      ROCMultiClass rocMultiClass3=new ROCMultiClass(numSteps);
      ROCMultiClass rocMultiClass2=new ROCMultiClass(numSteps);
      rocMultiClass3.eval(labels3,predictions3);
      rocMultiClass2.eval(labels2,predictions2);
      double auc3=rocMultiClass3.calculateAUC(2);
      double auc2=rocMultiClass2.calculateAUC(1);
      assertEquals(auc2,auc3,1e-6);
      RocCurve c3=rocMultiClass3.getRocCurve(2);
      RocCurve c2=rocMultiClass2.getRocCurve(1);
      assertArrayEquals(c2.getThreshold(),c3.getThreshold(),1e-6);
      assertArrayEquals(c2.getFpr(),c3.getFpr(),1e-6);
      assertArrayEquals(c2.getTpr(),c3.getTpr(),1e-6);
    }
  }
  @Test public void testROCMerging(){
    int nArrays=10;
    int minibatch=64;
    int nROCs=3;
    for (    int steps : new int[]{0,20}) {
      Nd4j.getRandom().setSeed(12345);
      Random r=new Random(12345);
      List<ROC> rocList=new ArrayList<>();
      for (int i=0; i < nROCs; i++) {
        rocList.add(new ROC(steps));
      }
      ROC single=new ROC(steps);
      for (int i=0; i < nArrays; i++) {
        INDArray p=Nd4j.rand(minibatch,2);
        p.diviColumnVector(p.sum(1));
        INDArray l=Nd4j.zeros(minibatch,2);
        for (int j=0; j < minibatch; j++) {
          l.putScalar(j,r.nextInt(2),1.0);
        }
        single.eval(l,p);
        ROC other=rocList.get(i % rocList.size());
        other.eval(l,p);
      }
      ROC first=rocList.get(0);
      for (int i=1; i < nROCs; i++) {
        first.merge(rocList.get(i));
      }
      double singleAUC=single.calculateAUC();
      assertTrue(singleAUC >= 0.0 && singleAUC <= 1.0);
      assertEquals(singleAUC,first.calculateAUC(),1e-6);
      assertEquals(single.getRocCurve(),first.getRocCurve());
    }
  }
  @Test public void testROCMerging2(){
    int nArrays=10;
    int minibatch=64;
    int exactAllocBlockSize=10;
    int nROCs=3;
    int steps=0;
    Nd4j.getRandom().setSeed(12345);
    Random r=new Random(12345);
    List<ROC> rocList=new ArrayList<>();
    for (int i=0; i < nROCs; i++) {
      rocList.add(new ROC(steps,true,exactAllocBlockSize));
    }
    ROC single=new ROC(steps);
    for (int i=0; i < nArrays; i++) {
      INDArray p=Nd4j.rand(minibatch,2);
      p.diviColumnVector(p.sum(1));
      INDArray l=Nd4j.zeros(minibatch,2);
      for (int j=0; j < minibatch; j++) {
        l.putScalar(j,r.nextInt(2),1.0);
      }
      single.eval(l,p);
      ROC other=rocList.get(i % rocList.size());
      other.eval(l,p);
    }
    ROC first=rocList.get(0);
    for (int i=1; i < nROCs; i++) {
      first.merge(rocList.get(i));
    }
    double singleAUC=single.calculateAUC();
    assertTrue(singleAUC >= 0.0 && singleAUC <= 1.0);
    assertEquals(singleAUC,first.calculateAUC(),1e-6);
    assertEquals(single.getRocCurve(),first.getRocCurve());
  }
  @Test public void testROCMultiMerging(){
    int nArrays=10;
    int minibatch=64;
    int nROCs=3;
    int nClasses=3;
    for (    int steps : new int[]{20,0}) {
      Nd4j.getRandom().setSeed(12345);
      Random r=new Random(12345);
      List<ROCMultiClass> rocList=new ArrayList<>();
      for (int i=0; i < nROCs; i++) {
        rocList.add(new ROCMultiClass(steps));
      }
      ROCMultiClass single=new ROCMultiClass(steps);
      for (int i=0; i < nArrays; i++) {
        INDArray p=Nd4j.rand(minibatch,nClasses);
        p.diviColumnVector(p.sum(1));
        INDArray l=Nd4j.zeros(minibatch,nClasses);
        for (int j=0; j < minibatch; j++) {
          l.putScalar(j,r.nextInt(nClasses),1.0);
        }
        single.eval(l,p);
        ROCMultiClass other=rocList.get(i % rocList.size());
        other.eval(l,p);
      }
      ROCMultiClass first=rocList.get(0);
      for (int i=1; i < nROCs; i++) {
        first.merge(rocList.get(i));
      }
      for (int i=0; i < nClasses; i++) {
        assertEquals(single.calculateAUC(i),first.calculateAUC(i),1e-6);
        assertEquals(single.getRocCurve(i),first.getRocCurve(i));
      }
    }
  }
  @Test public void testAUCPrecisionRecall(){
    for (    int steps : new int[]{10,0}) {
      String msg="Steps = " + steps;
      ROC r=new ROC(steps);
      INDArray zero=Nd4j.zeros(1);
      INDArray one=Nd4j.ones(1);
      r.eval(zero,Nd4j.create(new double[]{0.25}));
      r.eval(one,Nd4j.create(new double[]{0.33}));
      r.eval(one,Nd4j.create(new double[]{0.66}));
      PrecisionRecallCurve prc=r.getPrecisionRecallCurve();
      double auprc=r.calculateAUCPR();
      assertEquals(msg,1.0,auprc,1e-6);
      r=new ROC(steps);
      r.eval(one,Nd4j.create(new double[]{0.33}));
      r.eval(zero,Nd4j.create(new double[]{0.5}));
      r.eval(one,Nd4j.create(new double[]{0.66}));
      double precision;
      if (steps == 0) {
        precision=1e-8;
      }
 else {
        precision=1e-4;
      }
      assertEquals(msg,0.7916666666667,r.calculateAUCPR(),precision);
    }
  }
  @Test public void testRocAucExact(){
    double[] p=new double[]{0.92961609,0.31637555,0.18391881,0.20456028,0.56772503,0.5955447,0.96451452,0.6531771,0.74890664,0.65356987,0.74771481,0.96130674,0.0083883,0.10644438,0.29870371,0.65641118,0.80981255,0.87217591,0.9646476,0.72368535,0.64247533,0.71745362,0.46759901,0.32558468,0.43964461,0.72968908,0.99401459,0.67687371,0.79082252,0.17091426};
    double[] l=new double[]{1,0,0,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1};
    double[] fpr_skl=new double[]{0.0,0.0,0.15789474,0.15789474,0.31578947,0.31578947,0.52631579,0.52631579,0.68421053,0.68421053,0.84210526,0.84210526,0.89473684,0.89473684,1.0};
    double[] tpr_skl=new double[]{0.0,0.09090909,0.09090909,0.18181818,0.18181818,0.36363636,0.36363636,0.45454545,0.45454545,0.72727273,0.72727273,0.90909091,0.90909091,1.0,1.0};
    double[] thr_skl=new double[]{1.0,0.99401459,0.96130674,0.92961609,0.79082252,0.74771481,0.67687371,0.65641118,0.64247533,0.46759901,0.31637555,0.20456028,0.18391881,0.17091426,0.0};
    INDArray prob=Nd4j.create(p,new int[]{30,1});
    INDArray label=Nd4j.create(l,new int[]{30,1});
    ROC roc=new ROC(0);
    roc.eval(label,prob);
    RocCurve rocCurve=roc.getRocCurve();
    assertArrayEquals(thr_skl,rocCurve.getThreshold(),1e-6);
    assertArrayEquals(fpr_skl,rocCurve.getFpr(),1e-6);
    assertArrayEquals(tpr_skl,rocCurve.getTpr(),1e-6);
    double auc=roc.calculateAUC();
    double aucExpSKL=0.459330143541;
    assertEquals(aucExpSKL,auc,1e-6);
    roc=new ROC(0,false);
    roc.eval(label,prob);
    assertEquals(aucExpSKL,roc.calculateAUC(),1e-6);
    roc=new ROC(0,true);
    roc.eval(label,prob);
    double auprcExp=0.398963619227;
    double auprcAct=roc.calculateAUCPR();
    assertEquals(auprcExp,auprcAct,1e-8);
    roc=new ROC(0,false);
    roc.eval(label,prob);
    assertEquals(auprcExp,roc.calculateAUCPR(),1e-8);
    PrecisionRecallCurve prc=roc.getPrecisionRecallCurve();
    for (int i=0; i < thr_skl.length; i++) {
      double threshold=thr_skl[i] - 1e-6;
      threshold=Math.max(0.0,threshold);
      PrecisionRecallCurve.Confusion c=prc.getConfusionMatrixAtThreshold(threshold);
      int tp=c.getTpCount();
      int fp=c.getFpCount();
      int tn=c.getTnCount();
      int fn=c.getFnCount();
      assertEquals(30,tp + fp + tn+ fn);
      double prec=tp / (double)(tp + fp);
      double rec=tp / (double)(tp + fn);
      double fpr=fp / 19.0;
      if (c.getPoint().getThreshold() == 0.0) {
        rec=1.0;
        prec=11.0 / 30;
      }
 else       if (c.getPoint().getThreshold() == 1.0) {
        rec=0.0;
        prec=1.0;
      }
      assertEquals(tpr_skl[i],rec,1e-6);
      assertEquals(fpr_skl[i],fpr,1e-6);
      assertEquals(rec,c.getPoint().getRecall(),1e-6);
      assertEquals(prec,c.getPoint().getPrecision(),1e-6);
    }
    prob=Nd4j.create(new double[]{0.1,0.2,0.5,0.9},new int[]{4,1});
    label=Nd4j.create(new double[]{0,0,1,1},new int[]{4,1});
    roc=new ROC(0);
    roc.eval(label,prob);
    assertEquals(1.0,roc.calculateAUC(),1e-8);
    assertEquals(1.0,roc.calculateAUCPR(),1e-8);
  }
  @Test public void rocExactEdgeCaseReallocation(){
    ROC roc=new ROC(0,true,50);
    roc.eval(Nd4j.rand(100,1),Nd4j.ones(100,1));
  }
  @Test public void testPrecisionRecallCurveGetPointMethods(){
    double[] threshold=new double[101];
    double[] precision=threshold;
    double[] recall=new double[101];
    int i=0;
    for (double d=0; d <= 1; d+=0.01) {
      threshold[i]=d;
      recall[i]=1.0 - d;
      i++;
    }
    PrecisionRecallCurve prc=new PrecisionRecallCurve(threshold,precision,recall,null,null,null,-1);
    PrecisionRecallCurve.Point[] points=new PrecisionRecallCurve.Point[]{prc.getPointAtThreshold(0.05),prc.getPointAtPrecision(0.05),prc.getPointAtRecall(1 - 0.05),prc.getPointAtThreshold(0.0495),prc.getPointAtPrecision(0.0495),prc.getPointAtRecall(1 - 0.0505)};
    for (    PrecisionRecallCurve.Point p : points) {
      assertEquals(5,p.getIdx());
      assertEquals(0.05,p.getThreshold(),1e-6);
      assertEquals(0.05,p.getPrecision(),1e-6);
      assertEquals(1 - 0.05,p.getRecall(),1e-6);
    }
  }
  @Test public void testPrecisionRecallCurveConfusion(){
    for (    boolean removeRedundantPts : new boolean[]{true,false}) {
      ROC r=new ROC(0,removeRedundantPts);
      INDArray labels=Nd4j.getExecutioner().exec(new BernoulliDistribution(Nd4j.createUninitialized(100,1),0.5));
      INDArray probs=Nd4j.rand(100,1);
      r.eval(labels,probs);
      PrecisionRecallCurve prc=r.getPrecisionRecallCurve();
      int nPoints=prc.numPoints();
      for (int i=0; i < nPoints; i++) {
        PrecisionRecallCurve.Confusion c=prc.getConfusionMatrixAtPoint(i);
        PrecisionRecallCurve.Point p=c.getPoint();
        int tp=c.getTpCount();
        int fp=c.getFpCount();
        int fn=c.getFnCount();
        double prec=tp / (double)(tp + fp);
        double rec=tp / (double)(tp + fn);
        if (tp == 0 && fp == 0) {
          prec=1.0;
        }
        assertEquals(p.getPrecision(),prec,1e-6);
        assertEquals(p.getRecall(),rec,1e-6);
      }
    }
  }
  @Test public void testRocMerge(){
    Nd4j.getRandom().setSeed(12345);
    ROC roc=new ROC();
    ROC roc1=new ROC();
    ROC roc2=new ROC();
    int nOut=2;
    Random r=new Random(12345);
    for (int i=0; i < 10; i++) {
      INDArray labels=Nd4j.zeros(3,nOut);
      for (int j=0; j < 3; j++) {
        labels.putScalar(j,r.nextInt(nOut),1.0);
      }
      INDArray out=Nd4j.rand(3,nOut);
      out.diviColumnVector(out.sum(1));
      roc.eval(labels,out);
      if (i % 2 == 0) {
        roc1.eval(labels,out);
      }
 else {
        roc2.eval(labels,out);
      }
    }
    roc1.calculateAUC();
    roc1.calculateAUCPR();
    roc2.calculateAUC();
    roc2.calculateAUCPR();
    roc1.merge(roc2);
    double aucExp=roc.calculateAUC();
    double auprc=roc.calculateAUCPR();
    double aucAct=roc1.calculateAUC();
    double auprcAct=roc1.calculateAUCPR();
    assertEquals(aucExp,aucAct,1e-6);
    assertEquals(auprc,auprcAct,1e-6);
  }
  @Test public void testRocMultiMerge(){
    Nd4j.getRandom().setSeed(12345);
    ROCMultiClass roc=new ROCMultiClass();
    ROCMultiClass roc1=new ROCMultiClass();
    ROCMultiClass roc2=new ROCMultiClass();
    int nOut=5;
    Random r=new Random(12345);
    for (int i=0; i < 10; i++) {
      INDArray labels=Nd4j.zeros(3,nOut);
      for (int j=0; j < 3; j++) {
        labels.putScalar(j,r.nextInt(nOut),1.0);
      }
      INDArray out=Nd4j.rand(3,nOut);
      out.diviColumnVector(out.sum(1));
      roc.eval(labels,out);
      if (i % 2 == 0) {
        roc1.eval(labels,out);
      }
 else {
        roc2.eval(labels,out);
      }
    }
    for (int i=0; i < nOut; i++) {
      roc1.calculateAUC(i);
      roc1.calculateAUCPR(i);
      roc2.calculateAUC(i);
      roc2.calculateAUCPR(i);
    }
    roc1.merge(roc2);
    for (int i=0; i < nOut; i++) {
      double aucExp=roc.calculateAUC(i);
      double auprc=roc.calculateAUCPR(i);
      double aucAct=roc1.calculateAUC(i);
      double auprcAct=roc1.calculateAUCPR(i);
      assertEquals(aucExp,aucAct,1e-6);
      assertEquals(auprc,auprcAct,1e-6);
    }
  }
  @Test public void testRocBinaryMerge(){
    Nd4j.getRandom().setSeed(12345);
    ROCBinary roc=new ROCBinary();
    ROCBinary roc1=new ROCBinary();
    ROCBinary roc2=new ROCBinary();
    int nOut=5;
    for (int i=0; i < 10; i++) {
      INDArray labels=Nd4j.getExecutioner().exec(new BernoulliDistribution(Nd4j.createUninitialized(3,nOut),0.5));
      INDArray out=Nd4j.rand(3,nOut);
      out.diviColumnVector(out.sum(1));
      roc.eval(labels,out);
      if (i % 2 == 0) {
        roc1.eval(labels,out);
      }
 else {
        roc2.eval(labels,out);
      }
    }
    for (int i=0; i < nOut; i++) {
      roc1.calculateAUC(i);
      roc1.calculateAUCPR(i);
      roc2.calculateAUC(i);
      roc2.calculateAUCPR(i);
    }
    roc1.merge(roc2);
    for (int i=0; i < nOut; i++) {
      double aucExp=roc.calculateAUC(i);
      double auprc=roc.calculateAUCPR(i);
      double aucAct=roc1.calculateAUC(i);
      double auprcAct=roc1.calculateAUCPR(i);
      assertEquals(aucExp,aucAct,1e-6);
      assertEquals(auprc,auprcAct,1e-6);
    }
  }
}
