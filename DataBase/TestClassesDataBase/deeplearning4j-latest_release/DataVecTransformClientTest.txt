/** 
 * Created by agibsonccc on 6/12/17.
 */
public class DataVecTransformClientTest {
  private static CSVSparkTransformServer server;
  private static int port=getAvailablePort();
  private static DataVecTransformClient client;
  private static Schema schema=new Schema.Builder().addColumnDouble("1.0").addColumnDouble("2.0").build();
  private static TransformProcess transformProcess=new TransformProcess.Builder(schema).convertToDouble("1.0").convertToDouble("2.0").build();
  private static File fileSave=new File(UUID.randomUUID().toString() + ".json");
  @BeforeClass public static void beforeClass() throws Exception {
    FileUtils.write(fileSave,transformProcess.toJson());
    fileSave.deleteOnExit();
    server=new CSVSparkTransformServer();
    server.runMain(new String[]{"-dp",String.valueOf(port)});
    client=new DataVecTransformClient("http://localhost:" + port);
    client.setCSVTransformProcess(transformProcess);
  }
  @AfterClass public static void afterClass() throws Exception {
    server.stop();
  }
  @Test public void testSequenceClient(){
    SequenceBatchCSVRecord sequenceBatchCSVRecord=new SequenceBatchCSVRecord();
    SingleCSVRecord singleCsvRecord=new SingleCSVRecord(new String[]{"0","0"});
    BatchCSVRecord batchCSVRecord=new BatchCSVRecord(Arrays.asList(singleCsvRecord,singleCsvRecord));
    List<BatchCSVRecord> batchCSVRecordList=new ArrayList<>();
    for (int i=0; i < 5; i++) {
      batchCSVRecordList.add(batchCSVRecord);
    }
    sequenceBatchCSVRecord.add(batchCSVRecordList);
    SequenceBatchCSVRecord sequenceBatchCSVRecord1=client.transformSequence(sequenceBatchCSVRecord);
    assumeNotNull(sequenceBatchCSVRecord1);
    Base64NDArrayBody array=client.transformSequenceArray(sequenceBatchCSVRecord);
    assumeNotNull(array);
    Base64NDArrayBody incrementalBody=client.transformSequenceArrayIncremental(batchCSVRecord);
    assumeNotNull(incrementalBody);
    Base64NDArrayBody incrementalSequenceBody=client.transformSequenceArrayIncremental(batchCSVRecord);
    assumeNotNull(incrementalSequenceBody);
  }
  @Test public void testRecord() throws Exception {
    SingleCSVRecord singleCsvRecord=new SingleCSVRecord(new String[]{"0","0"});
    SingleCSVRecord transformed=client.transformIncremental(singleCsvRecord);
    assertEquals(singleCsvRecord.getValues().size(),transformed.getValues().size());
    Base64NDArrayBody body=client.transformArrayIncremental(singleCsvRecord);
    INDArray arr=Nd4jBase64.fromBase64(body.getNdarray());
    assumeNotNull(arr);
  }
  @Test public void testBatchRecord() throws Exception {
    SingleCSVRecord singleCsvRecord=new SingleCSVRecord(new String[]{"0","0"});
    BatchCSVRecord batchCSVRecord=new BatchCSVRecord(Arrays.asList(singleCsvRecord,singleCsvRecord));
    BatchCSVRecord batchCSVRecord1=client.transform(batchCSVRecord);
    assertEquals(batchCSVRecord.getRecords().size(),batchCSVRecord1.getRecords().size());
    Base64NDArrayBody body=client.transformArray(batchCSVRecord);
    INDArray arr=Nd4jBase64.fromBase64(body.getNdarray());
    assumeNotNull(arr);
  }
  public static int getAvailablePort(){
    try {
      ServerSocket socket=new ServerSocket(0);
      try {
        return socket.getLocalPort();
      }
  finally {
        socket.close();
      }
    }
 catch (    IOException e) {
      throw new IllegalStateException("Cannot find available port: " + e.getMessage(),e);
    }
  }
}
