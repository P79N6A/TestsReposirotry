/** 
 * A Command implementation that supports caching.
 */
private static class SuccessfulCacheableCommandViaSemaphore extends TestHystrixObservableCommand<String> {
  private final boolean cacheEnabled;
  private volatile boolean executed=false;
  private final String value;
  public SuccessfulCacheableCommandViaSemaphore(  TestCircuitBreaker circuitBreaker,  boolean cacheEnabled,  String value){
    super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)));
    this.value=value;
    this.cacheEnabled=cacheEnabled;
  }
  @Override protected Observable<String> construct(){
    executed=true;
    System.out.println("successfully executed");
    return Observable.just(value).subscribeOn(Schedulers.computation());
  }
  public boolean isCommandRunningInThread(){
    return super.getProperties().executionIsolationStrategy().get().equals(ExecutionIsolationStrategy.THREAD);
  }
  @Override public String getCacheKey(){
    if (cacheEnabled)     return value;
 else     return null;
  }
}
