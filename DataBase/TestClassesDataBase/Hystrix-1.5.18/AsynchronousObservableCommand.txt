private static class AsynchronousObservableCommand extends HystrixObservableCommand<Integer> {
  protected AsynchronousObservableCommand(){
    super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("GROUP")).andCommandKey(HystrixCommandKey.Factory.asKey("AsyncObservable")).andCommandPropertiesDefaults(new HystrixCommandProperties.Setter().withExecutionIsolationSemaphoreMaxConcurrentRequests(1000)));
  }
  @Override protected Observable<Integer> construct(){
    return Observable.create(new Observable.OnSubscribe<Integer>(){
      @Override public void call(      Subscriber<? super Integer> subscriber){
        try {
          System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " AsyncCommand construct()");
          Thread.sleep(10);
          System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " AsyncCommand construct() -> OnNext(1)");
          subscriber.onNext(1);
          Thread.sleep(10);
          System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " AsyncCommand construct() -> OnNext(2)");
          subscriber.onNext(2);
          System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " AsyncCommand construct() -> OnCompleted");
          subscriber.onCompleted();
        }
 catch (        Throwable ex) {
          subscriber.onError(ex);
        }
      }
    }
).subscribeOn(Schedulers.computation());
  }
}
