private static class TestCollapserCommandWithMultipleResponsePerArgument extends TestHystrixObservableCommand<String> {
  private final List<Integer> args;
  private final Map<String,Integer> emitsPerArg;
  private final boolean commandExecutionFails;
  private static InspectableBuilder.TestCommandBuilder setter=testPropsBuilder();
  TestCollapserCommandWithMultipleResponsePerArgument(  List<Integer> args,  Map<String,Integer> emitsPerArg,  boolean commandExecutionFails){
    super(setter);
    this.args=args;
    this.emitsPerArg=emitsPerArg;
    this.commandExecutionFails=commandExecutionFails;
  }
  @Override protected Observable<String> construct(){
    assertNotNull("Wiring the Batch command into the Observable chain should have a HystrixRequestContext",HystrixRequestContext.getContextForCurrentThread());
    if (commandExecutionFails) {
      return Observable.error(new RuntimeException("Synthetic error while running batch command"));
    }
 else {
      return Observable.create(new OnSubscribe<String>(){
        @Override public void call(        Subscriber<? super String> subscriber){
          try {
            assertNotNull("Executing the Batch command should have a HystrixRequestContext",HystrixRequestContext.getContextForCurrentThread());
            Thread.sleep(1);
            for (            Integer arg : args) {
              int numEmits=emitsPerArg.get(arg.toString());
              for (int j=1; j < numEmits + 1; j++) {
                subscriber.onNext(arg + ":" + (arg * j));
                Thread.sleep(1);
              }
              Thread.sleep(1);
            }
            subscriber.onCompleted();
          }
 catch (          Throwable ex) {
            ex.printStackTrace();
            subscriber.onError(ex);
          }
        }
      }
);
    }
  }
}
