/** 
 * This has a ThreadPool that has a single thread and queueSize of 1.
 */
private static class TestCommandRejection extends TestHystrixCommand<Boolean> {
  private final static int FALLBACK_NOT_IMPLEMENTED=1;
  private final static int FALLBACK_SUCCESS=2;
  private final static int FALLBACK_FAILURE=3;
  private final int fallbackBehavior;
  private final int sleepTime;
  private TestCommandRejection(  HystrixCommandKey key,  TestCircuitBreaker circuitBreaker,  HystrixThreadPool threadPool,  int sleepTime,  int timeout,  int fallbackBehavior){
    super(testPropsBuilder().setCommandKey(key).setThreadPool(threadPool).setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionTimeoutInMilliseconds(timeout)));
    this.fallbackBehavior=fallbackBehavior;
    this.sleepTime=sleepTime;
  }
  @Override protected Boolean run(){
    System.out.println(">>> TestCommandRejection running");
    try {
      Thread.sleep(sleepTime);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    return true;
  }
  @Override protected Boolean getFallback(){
    if (fallbackBehavior == FALLBACK_SUCCESS) {
      return false;
    }
 else     if (fallbackBehavior == FALLBACK_FAILURE) {
      throw new RuntimeException("failed on fallback");
    }
 else {
      return super.getFallback();
    }
  }
}
