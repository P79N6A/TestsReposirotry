/** 
 * Failed execution - fallback implementation successfully returns value.
 */
private static class KnownFailureTestCommandWithFallback extends TestHystrixObservableCommand<Boolean> {
  private final boolean asyncException;
  public KnownFailureTestCommandWithFallback(  TestCircuitBreaker circuitBreaker,  ExecutionIsolationStrategy isolationStrategy,  boolean asyncException){
    super(testPropsBuilder(isolationStrategy,circuitBreaker).setMetrics(circuitBreaker.metrics));
    this.asyncException=asyncException;
  }
  public KnownFailureTestCommandWithFallback(  TestCircuitBreaker circuitBreaker,  boolean fallbackEnabled,  boolean asyncException){
    super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withFallbackEnabled(fallbackEnabled).withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)));
    this.asyncException=asyncException;
  }
  @Override protected Observable<Boolean> construct(){
    System.out.println("*** simulated failed execution ***");
    RuntimeException ex=new RuntimeException("we failed with a simulated issue");
    if (asyncException) {
      return Observable.error(ex);
    }
 else {
      throw ex;
    }
  }
  @Override protected Observable<Boolean> resumeWithFallback(){
    return Observable.just(false).subscribeOn(Schedulers.computation());
  }
}
