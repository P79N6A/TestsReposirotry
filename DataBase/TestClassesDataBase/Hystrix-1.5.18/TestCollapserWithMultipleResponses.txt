private static class TestCollapserWithMultipleResponses extends HystrixObservableCollapser<String,String,String,String> {
  private final String arg;
  private final static ConcurrentMap<String,Integer> emitsPerArg;
  private final boolean commandConstructionFails;
  private final boolean commandExecutionFails;
  private final Func1<String,String> keyMapper;
  private final Action1<CollapsedRequest<String,String>> onMissingResponseHandler;
  private final static HystrixCollapserKey key=HystrixCollapserKey.Factory.asKey("COLLAPSER_MULTI");
  private final static HystrixCollapserProperties.Setter propsSetter=HystrixCollapserProperties.Setter().withMaxRequestsInBatch(10).withTimerDelayInMilliseconds(10);
  private final static HystrixCollapserMetrics metrics=HystrixCollapserMetrics.getInstance(key,new HystrixPropertiesCollapserDefault(key,HystrixCollapserProperties.Setter()));
static {
    emitsPerArg=new ConcurrentHashMap<String,Integer>();
  }
  public TestCollapserWithMultipleResponses(  CollapserTimer timer,  int arg,  int numEmits,  boolean commandConstructionFails){
    this(timer,arg,numEmits,commandConstructionFails,false,prefixMapper,onMissingComplete);
  }
  public TestCollapserWithMultipleResponses(  CollapserTimer timer,  int arg,  int numEmits,  Action1<CollapsedRequest<String,String>> onMissingHandler){
    this(timer,arg,numEmits,false,false,prefixMapper,onMissingHandler);
  }
  public TestCollapserWithMultipleResponses(  CollapserTimer timer,  int arg,  int numEmits,  Func1<String,String> keyMapper){
    this(timer,arg,numEmits,false,false,keyMapper,onMissingComplete);
  }
  public TestCollapserWithMultipleResponses(  CollapserTimer timer,  int arg,  int numEmits,  boolean commandConstructionFails,  boolean commandExecutionFails,  Func1<String,String> keyMapper,  Action1<CollapsedRequest<String,String>> onMissingResponseHandler){
    super(collapserKeyFromString(timer),Scope.REQUEST,timer,propsSetter,metrics);
    this.arg=arg + "";
    emitsPerArg.put(this.arg,numEmits);
    this.commandConstructionFails=commandConstructionFails;
    this.commandExecutionFails=commandExecutionFails;
    this.keyMapper=keyMapper;
    this.onMissingResponseHandler=onMissingResponseHandler;
  }
  @Override public String getRequestArgument(){
    return arg;
  }
  @Override protected HystrixObservableCommand<String> createCommand(  Collection<CollapsedRequest<String,String>> collapsedRequests){
    assertNotNull("command creation should have HystrixRequestContext",HystrixRequestContext.getContextForCurrentThread());
    if (commandConstructionFails) {
      throw new RuntimeException("Exception thrown in command construction");
    }
 else {
      List<Integer> args=new ArrayList<Integer>();
      for (      CollapsedRequest<String,String> collapsedRequest : collapsedRequests) {
        String stringArg=collapsedRequest.getArgument();
        int intArg=Integer.parseInt(stringArg);
        args.add(intArg);
      }
      return new TestCollapserCommandWithMultipleResponsePerArgument(args,emitsPerArg,commandExecutionFails);
    }
  }
  @Override protected Func1<String,String> getBatchReturnTypeKeySelector(){
    return keyMapper;
  }
  @Override protected Func1<String,String> getRequestArgumentKeySelector(){
    return new Func1<String,String>(){
      @Override public String call(      String s){
        return s;
      }
    }
;
  }
  @Override protected void onMissingResponse(  CollapsedRequest<String,String> r){
    onMissingResponseHandler.call(r);
  }
  @Override protected Func1<String,String> getBatchReturnTypeToResponseTypeMapper(){
    return new Func1<String,String>(){
      @Override public String call(      String s){
        return s;
      }
    }
;
  }
}
