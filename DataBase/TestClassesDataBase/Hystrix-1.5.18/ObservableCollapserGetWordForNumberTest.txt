public static class ObservableCollapserGetWordForNumberTest {
  private HystrixRequestContext ctx;
  @Before public void before(){
    ctx=HystrixRequestContext.initializeContext();
    ObservableCollapserGetWordForNumber.resetCmdCounter();
  }
  @After public void after(){
    System.out.println(HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
    ctx.shutdown();
  }
  /** 
 * Example where we subscribe without using a specific scheduler. That means we run the actions on the same thread.
 */
  @Test public void shouldCollapseRequestsSync(){
    final int noOfRequests=10;
    final Map<Integer,TestSubscriber<String>> subscribersByNumber=new HashMap<Integer,TestSubscriber<String>>(noOfRequests);
    TestSubscriber<String> subscriber;
    for (int number=0; number < noOfRequests; number++) {
      subscriber=new TestSubscriber<String>();
      new ObservableCollapserGetWordForNumber(number).toObservable().subscribe(subscriber);
      subscribersByNumber.put(number,subscriber);
      if (number == noOfRequests / 2)       sleep(1000);
    }
    assertThat(subscribersByNumber.size(),is(noOfRequests));
    for (    final Entry<Integer,TestSubscriber<String>> subscriberByNumber : subscribersByNumber.entrySet()) {
      subscriber=subscriberByNumber.getValue();
      subscriber.awaitTerminalEvent(10,TimeUnit.SECONDS);
      assertThat(subscriber.getOnErrorEvents().toString(),subscriber.getOnErrorEvents().size(),is(0));
      assertThat(subscriber.getOnNextEvents().size(),is(1));
      final String word=subscriber.getOnNextEvents().get(0);
      System.out.println("Translated " + subscriberByNumber.getKey() + " to "+ word);
      assertThat(word,equalTo(numberToWord(subscriberByNumber.getKey())));
    }
    assertTrue(ObservableCollapserGetWordForNumber.getCmdCount() > 1);
    assertTrue(ObservableCollapserGetWordForNumber.getCmdCount() < noOfRequests);
  }
  /** 
 * Example where we subscribe on the computation scheduler. For this we need the  {@link HystrixContextScheduler}, that passes the  {@link HystrixRequestContext} to the thread that runs the action.
 */
  @Test public void shouldCollapseRequestsAsync(){
    final HystrixContextScheduler contextAwareScheduler=new HystrixContextScheduler(Schedulers.computation());
    final int noOfRequests=10;
    final Map<Integer,TestSubscriber<String>> subscribersByNumber=new HashMap<Integer,TestSubscriber<String>>(noOfRequests);
    TestSubscriber<String> subscriber;
    for (int number=0; number < noOfRequests; number++) {
      subscriber=new TestSubscriber<String>();
      final int finalNumber=number;
      Observable.defer(new Func0<Observable<String>>(){
        @Override public Observable<String> call(){
          return new ObservableCollapserGetWordForNumber(finalNumber).toObservable();
        }
      }
).subscribeOn(contextAwareScheduler).subscribe(subscriber);
      subscribersByNumber.put(number,subscriber);
      if (number == noOfRequests / 2)       sleep(1000);
    }
    assertThat(subscribersByNumber.size(),is(noOfRequests));
    for (    final Entry<Integer,TestSubscriber<String>> subscriberByNumber : subscribersByNumber.entrySet()) {
      subscriber=subscriberByNumber.getValue();
      subscriber.awaitTerminalEvent(10,TimeUnit.SECONDS);
      assertThat(subscriber.getOnErrorEvents().toString(),subscriber.getOnErrorEvents().size(),is(0));
      assertThat(subscriber.getOnNextEvents().size(),is(1));
      final String word=subscriber.getOnNextEvents().get(0);
      System.out.println("Translated " + subscriberByNumber.getKey() + " to "+ word);
      assertThat(word,equalTo(numberToWord(subscriberByNumber.getKey())));
    }
    assertTrue(ObservableCollapserGetWordForNumber.getCmdCount() > 1);
    assertTrue(ObservableCollapserGetWordForNumber.getCmdCount() < noOfRequests);
  }
  @Test public void shouldCollapseSameRequests(){
    final HystrixContextScheduler contextAwareScheduler=new HystrixContextScheduler(Schedulers.computation());
    TestSubscriber<String> subscriber1=getWordForNumber(contextAwareScheduler,0);
    TestSubscriber<String> subscriber2=getWordForNumber(contextAwareScheduler,0);
    subscriberReceived(subscriber1,0);
    subscriberReceived(subscriber2,0);
  }
  private TestSubscriber<String> getWordForNumber(  HystrixContextScheduler contextAwareScheduler,  final int number){
    final TestSubscriber<String> subscriber=new TestSubscriber<String>();
    Observable.defer(new Func0<Observable<String>>(){
      @Override public Observable<String> call(){
        return new ObservableCollapserGetWordForNumber(number).toObservable();
      }
    }
).subscribeOn(contextAwareScheduler).subscribe(subscriber);
    return subscriber;
  }
  private void subscriberReceived(  TestSubscriber<String> subscriber,  int number){
    subscriber.awaitTerminalEvent(10,TimeUnit.SECONDS);
    assertThat(subscriber.getOnErrorEvents().toString(),subscriber.getOnErrorEvents().size(),is(0));
    assertThat(subscriber.getOnNextEvents().size(),is(1));
    assertThat(subscriber.getOnNextEvents().get(0),equalTo(numberToWord(number)));
  }
  private String numberToWord(  final int number){
    return ObservableCommandNumbersToWords.dict.get(number);
  }
  private void sleep(  final long ms){
    try {
      Thread.sleep(1000);
    }
 catch (    final InterruptedException e) {
      throw new IllegalStateException(e);
    }
  }
}
