static class TestCollapserTimer implements CollapserTimer {
  private final ConcurrentLinkedQueue<ATask> tasks=new ConcurrentLinkedQueue<ATask>();
  @Override public Reference<TimerListener> addListener(  final TimerListener collapseTask){
    tasks.add(new ATask(new TestTimerListener(collapseTask)));
    return new SoftReference<TimerListener>(collapseTask){
      @Override public void clear(){
        for (        ATask t : tasks) {
          if (t.task.actualListener.equals(collapseTask)) {
            tasks.remove(t);
          }
        }
      }
    }
;
  }
  /** 
 * Increment time by X. Note that incrementing by multiples of delay or period time will NOT execute multiple times. <p> You must call incrementTime multiple times each increment being larger than 'period' on subsequent calls to cause multiple executions. <p> This is because executing multiple times in a tight-loop would not achieve the correct behavior, such as batching, since it will all execute "now" not after intervals of time.
 * @param timeInMilliseconds amount of time to increment
 */
  public synchronized void incrementTime(  int timeInMilliseconds){
    for (    ATask t : tasks) {
      t.incrementTime(timeInMilliseconds);
    }
  }
private static class ATask {
    final TestTimerListener task;
    final int delay=10;
    volatile int time=0;
    volatile int executionCount=0;
    private ATask(    TestTimerListener task){
      this.task=task;
    }
    public synchronized void incrementTime(    int timeInMilliseconds){
      time+=timeInMilliseconds;
      if (task != null) {
        if (executionCount == 0) {
          System.out.println("ExecutionCount 0 => Time: " + time + " Delay: "+ delay);
          if (time >= delay) {
            executeTask();
          }
        }
 else {
          System.out.println("ExecutionCount 1+ => Time: " + time + " Delay: "+ delay);
          if (time >= delay) {
            executeTask();
          }
        }
      }
    }
    private synchronized void executeTask(){
      System.out.println("Executing task ...");
      task.tick();
      this.time=0;
      this.executionCount++;
      System.out.println("executionCount: " + executionCount);
    }
  }
}
