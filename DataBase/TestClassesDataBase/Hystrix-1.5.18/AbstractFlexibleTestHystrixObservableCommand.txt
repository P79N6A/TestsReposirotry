private static class AbstractFlexibleTestHystrixObservableCommand extends TestHystrixObservableCommand<Integer> {
  private final AbstractTestHystrixCommand.ExecutionResult executionResult;
  private final int executionLatency;
  private final CacheEnabled cacheEnabled;
  private final Object value;
  public AbstractFlexibleTestHystrixObservableCommand(  HystrixCommandKey commandKey,  ExecutionIsolationStrategy isolationStrategy,  AbstractTestHystrixCommand.ExecutionResult executionResult,  int executionLatency,  TestCircuitBreaker circuitBreaker,  HystrixThreadPool threadPool,  int timeout,  CacheEnabled cacheEnabled,  Object value,  TryableSemaphore executionSemaphore,  TryableSemaphore fallbackSemaphore,  boolean circuitBreakerDisabled){
    super(testPropsBuilder(circuitBreaker).setCommandKey(commandKey).setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setThreadPool(threadPool).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(isolationStrategy).withExecutionTimeoutInMilliseconds(timeout).withCircuitBreakerEnabled(!circuitBreakerDisabled)).setExecutionSemaphore(executionSemaphore).setFallbackSemaphore(fallbackSemaphore));
    this.executionResult=executionResult;
    this.executionLatency=executionLatency;
    this.cacheEnabled=cacheEnabled;
    this.value=value;
  }
  @Override protected Observable<Integer> construct(){
    if (executionResult == AbstractTestHystrixCommand.ExecutionResult.FAILURE) {
      addLatency(executionLatency);
      throw new RuntimeException("Execution Sync Failure for TestHystrixObservableCommand");
    }
 else     if (executionResult == AbstractTestHystrixCommand.ExecutionResult.HYSTRIX_FAILURE) {
      addLatency(executionLatency);
      throw new HystrixRuntimeException(HystrixRuntimeException.FailureType.COMMAND_EXCEPTION,AbstractFlexibleTestHystrixObservableCommand.class,"Execution Hystrix Failure for TestHystrixObservableCommand",new RuntimeException("Execution Failure for TestHystrixObservableCommand"),new RuntimeException("Fallback Failure for TestHystrixObservableCommand"));
    }
 else     if (executionResult == AbstractTestHystrixCommand.ExecutionResult.NOT_WRAPPED_FAILURE) {
      addLatency(executionLatency);
      throw new NotWrappedByHystrixTestRuntimeException();
    }
 else     if (executionResult == AbstractTestHystrixCommand.ExecutionResult.RECOVERABLE_ERROR) {
      addLatency(executionLatency);
      throw new java.lang.Error("Execution Sync Error for TestHystrixObservableCommand");
    }
 else     if (executionResult == AbstractTestHystrixCommand.ExecutionResult.UNRECOVERABLE_ERROR) {
      addLatency(executionLatency);
      throw new OutOfMemoryError("Execution Sync OOME for TestHystrixObservableCommand");
    }
 else     if (executionResult == AbstractTestHystrixCommand.ExecutionResult.BAD_REQUEST) {
      addLatency(executionLatency);
      throw new HystrixBadRequestException("Execution Bad Request Exception for TestHystrixObservableCommand");
    }
    return Observable.create(new OnSubscribe<Integer>(){
      @Override public void call(      Subscriber<? super Integer> subscriber){
        System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " construct() method has been subscribed to");
        addLatency(executionLatency);
        if (executionResult == AbstractTestHystrixCommand.ExecutionResult.SUCCESS) {
          subscriber.onNext(1);
          subscriber.onCompleted();
        }
 else         if (executionResult == AbstractTestHystrixCommand.ExecutionResult.MULTIPLE_EMITS_THEN_SUCCESS) {
          subscriber.onNext(2);
          subscriber.onNext(3);
          subscriber.onNext(4);
          subscriber.onNext(5);
          subscriber.onCompleted();
        }
 else         if (executionResult == AbstractTestHystrixCommand.ExecutionResult.MULTIPLE_EMITS_THEN_FAILURE) {
          subscriber.onNext(6);
          subscriber.onNext(7);
          subscriber.onNext(8);
          subscriber.onNext(9);
          subscriber.onError(new RuntimeException("Execution Async Failure For TestHystrixObservableCommand after 4 emits"));
        }
 else         if (executionResult == AbstractTestHystrixCommand.ExecutionResult.ASYNC_FAILURE) {
          subscriber.onError(new RuntimeException("Execution Async Failure for TestHystrixObservableCommand after 0 emits"));
        }
 else         if (executionResult == AbstractTestHystrixCommand.ExecutionResult.ASYNC_HYSTRIX_FAILURE) {
          subscriber.onError(new HystrixRuntimeException(HystrixRuntimeException.FailureType.COMMAND_EXCEPTION,AbstractFlexibleTestHystrixObservableCommand.class,"Execution Hystrix Failure for TestHystrixObservableCommand",new RuntimeException("Execution Failure for TestHystrixObservableCommand"),new RuntimeException("Fallback Failure for TestHystrixObservableCommand")));
        }
 else         if (executionResult == AbstractTestHystrixCommand.ExecutionResult.ASYNC_RECOVERABLE_ERROR) {
          subscriber.onError(new java.lang.Error("Execution Async Error for TestHystrixObservableCommand"));
        }
 else         if (executionResult == AbstractTestHystrixCommand.ExecutionResult.ASYNC_UNRECOVERABLE_ERROR) {
          subscriber.onError(new OutOfMemoryError("Execution Async OOME for TestHystrixObservableCommand"));
        }
 else         if (executionResult == AbstractTestHystrixCommand.ExecutionResult.ASYNC_BAD_REQUEST) {
          subscriber.onError(new HystrixBadRequestException("Execution Async Bad Request Exception for TestHystrixObservableCommand"));
        }
 else {
          subscriber.onError(new RuntimeException("You passed in a executionResult enum that can't be represented in HystrixObservableCommand: " + executionResult));
        }
      }
    }
);
  }
  @Override public String getCacheKey(){
    if (cacheEnabled == CacheEnabled.YES)     return value.toString();
 else     return null;
  }
  protected void addLatency(  int latency){
    if (latency > 0) {
      try {
        System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " About to sleep for : "+ latency);
        Thread.sleep(latency);
        System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " Woke up from sleep!");
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        try {
          Thread.sleep(latency);
        }
 catch (        Exception e2) {
        }
        System.out.println("after interruption with extra sleep");
      }
    }
  }
}
