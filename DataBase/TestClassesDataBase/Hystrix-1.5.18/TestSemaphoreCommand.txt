/** 
 * The run() will take time. Configurable fallback implementation.
 */
private static class TestSemaphoreCommand extends TestHystrixObservableCommand<Boolean> {
  private final long executionSleep;
  private final static int RESULT_SUCCESS=1;
  private final static int RESULT_FAILURE=2;
  private final static int RESULT_BAD_REQUEST_EXCEPTION=3;
  private final int resultBehavior;
  private final static int FALLBACK_SUCCESS=10;
  private final static int FALLBACK_NOT_IMPLEMENTED=11;
  private final static int FALLBACK_FAILURE=12;
  private final int fallbackBehavior;
  private final static boolean FALLBACK_FAILURE_SYNC=false;
  private final static boolean FALLBACK_FAILURE_ASYNC=true;
  private final boolean asyncFallbackException;
  private TestSemaphoreCommand(  TestCircuitBreaker circuitBreaker,  int executionSemaphoreCount,  long executionSleep,  int resultBehavior,  int fallbackBehavior){
    super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE).withExecutionIsolationSemaphoreMaxConcurrentRequests(executionSemaphoreCount)));
    this.executionSleep=executionSleep;
    this.resultBehavior=resultBehavior;
    this.fallbackBehavior=fallbackBehavior;
    this.asyncFallbackException=FALLBACK_FAILURE_ASYNC;
  }
  private TestSemaphoreCommand(  TestCircuitBreaker circuitBreaker,  TryableSemaphore semaphore,  long executionSleep,  int resultBehavior,  int fallbackBehavior){
    super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)).setExecutionSemaphore(semaphore));
    this.executionSleep=executionSleep;
    this.resultBehavior=resultBehavior;
    this.fallbackBehavior=fallbackBehavior;
    this.asyncFallbackException=FALLBACK_FAILURE_ASYNC;
  }
  @Override protected Observable<Boolean> construct(){
    return Observable.create(new OnSubscribe<Boolean>(){
      @Override public void call(      Subscriber<? super Boolean> subscriber){
        try {
          Thread.sleep(executionSleep);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        if (resultBehavior == RESULT_SUCCESS) {
          subscriber.onNext(true);
          subscriber.onCompleted();
        }
 else         if (resultBehavior == RESULT_FAILURE) {
          subscriber.onError(new RuntimeException("TestSemaphoreCommand failure"));
        }
 else         if (resultBehavior == RESULT_BAD_REQUEST_EXCEPTION) {
          subscriber.onError(new HystrixBadRequestException("TestSemaphoreCommand BadRequestException"));
        }
 else {
          subscriber.onError(new IllegalStateException("Didn't use a proper enum for result behavior"));
        }
      }
    }
);
  }
  @Override protected Observable<Boolean> resumeWithFallback(){
    if (fallbackBehavior == FALLBACK_SUCCESS) {
      return Observable.just(false);
    }
 else     if (fallbackBehavior == FALLBACK_FAILURE) {
      RuntimeException ex=new RuntimeException("fallback failure");
      if (asyncFallbackException) {
        return Observable.error(ex);
      }
 else {
        throw ex;
      }
    }
 else {
      return super.resumeWithFallback();
    }
  }
}
