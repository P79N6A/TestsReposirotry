/** 
 * A Command implementation that supports caching and execution takes a while. <p> Used to test scenario where Futures are returned with a backing call still executing.
 */
private static class SlowCacheableCommand extends TestHystrixObservableCommand<String> {
  private final String value;
  private final int duration;
  private volatile boolean executed=false;
  public SlowCacheableCommand(  TestCircuitBreaker circuitBreaker,  String value,  int duration){
    super(testPropsBuilder().setCommandKey(HystrixCommandKey.Factory.asKey("ObservableSlowCacheable")).setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics));
    this.value=value;
    this.duration=duration;
  }
  @Override protected Observable<String> construct(){
    executed=true;
    return Observable.just(value).delay(duration,TimeUnit.MILLISECONDS).subscribeOn(Schedulers.computation()).doOnNext(new Action1<String>(){
      @Override public void call(      String t1){
        System.out.println("successfully executed");
      }
    }
);
  }
  @Override public String getCacheKey(){
    return value;
  }
}
