private static class RequestCacheThreadRejectionWithoutFallback extends TestHystrixObservableCommand<Boolean> {
  final CountDownLatch completionLatch;
  public RequestCacheThreadRejectionWithoutFallback(  TestCircuitBreaker circuitBreaker,  CountDownLatch completionLatch){
    super(testPropsBuilder().setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD)).setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setThreadPool(new HystrixThreadPool(){
      @Override public ThreadPoolExecutor getExecutor(){
        return null;
      }
      @Override public void markThreadExecution(){
      }
      @Override public void markThreadCompletion(){
      }
      @Override public void markThreadRejection(){
      }
      @Override public boolean isQueueSpaceAvailable(){
        return false;
      }
      @Override public Scheduler getScheduler(){
        return new HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(),this);
      }
      @Override public Scheduler getScheduler(      Func0<Boolean> shouldInterruptThread){
        return new HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(),this,shouldInterruptThread);
      }
    }
));
    this.completionLatch=completionLatch;
  }
  @Override protected Observable<Boolean> construct(){
    try {
      if (completionLatch.await(1000,TimeUnit.MILLISECONDS)) {
        throw new RuntimeException("timed out waiting on completionLatch");
      }
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
    return Observable.just(true);
  }
  @Override public String getCacheKey(){
    return "A";
  }
}
