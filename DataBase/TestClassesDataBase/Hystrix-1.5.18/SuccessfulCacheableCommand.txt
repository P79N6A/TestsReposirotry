/** 
 * A Command implementation that supports caching.
 */
private static class SuccessfulCacheableCommand<T> extends TestHystrixObservableCommand<T> {
  private final boolean cacheEnabled;
  private volatile boolean executed=false;
  private final T value;
  public SuccessfulCacheableCommand(  TestCircuitBreaker circuitBreaker,  boolean cacheEnabled,  T value){
    super(testPropsBuilder().setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD)));
    this.value=value;
    this.cacheEnabled=cacheEnabled;
  }
  @Override protected Observable<T> construct(){
    executed=true;
    System.out.println("successfully executed");
    return Observable.just(value).subscribeOn(Schedulers.computation());
  }
  public boolean isCommandRunningInThread(){
    return super.getProperties().executionIsolationStrategy().get().equals(ExecutionIsolationStrategy.THREAD);
  }
  @Override public String getCacheKey(){
    if (cacheEnabled)     return value.toString();
 else     return null;
  }
}
