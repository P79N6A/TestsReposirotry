private static class FlexibleTestHystrixCommandWithFallback extends AbstractFlexibleTestHystrixCommand {
  protected final AbstractTestHystrixCommand.FallbackResult fallbackResult;
  protected final int fallbackLatency;
  FlexibleTestHystrixCommandWithFallback(  HystrixCommandKey commandKey,  ExecutionIsolationStrategy isolationStrategy,  AbstractTestHystrixCommand.ExecutionResult executionResult,  int executionLatency,  FallbackResult fallbackResult,  int fallbackLatency,  TestCircuitBreaker circuitBreaker,  HystrixThreadPool threadPool,  int timeout,  CacheEnabled cacheEnabled,  Object value,  TryableSemaphore executionSemaphore,  TryableSemaphore fallbackSemaphore,  boolean circuitBreakerDisabled){
    super(commandKey,isolationStrategy,executionResult,executionLatency,circuitBreaker,threadPool,timeout,cacheEnabled,value,executionSemaphore,fallbackSemaphore,circuitBreakerDisabled);
    this.fallbackResult=fallbackResult;
    this.fallbackLatency=fallbackLatency;
  }
  @Override protected Integer getFallback(){
    addLatency(fallbackLatency);
    if (fallbackResult == AbstractTestHystrixCommand.FallbackResult.SUCCESS) {
      return FlexibleTestHystrixCommand.FALLBACK_VALUE;
    }
 else     if (fallbackResult == AbstractTestHystrixCommand.FallbackResult.FAILURE) {
      throw new RuntimeException("Fallback Failure for TestHystrixCommand");
    }
 else     if (fallbackResult == FallbackResult.UNIMPLEMENTED) {
      return super.getFallback();
    }
 else {
      throw new RuntimeException("You passed in a fallbackResult enum that can't be represented in HystrixCommand: " + fallbackResult);
    }
  }
}
