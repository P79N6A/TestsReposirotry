public class StreamingOutputProviderTest {
  private final Observable<String> streamOfOnNexts=Observable.interval(100,TimeUnit.MILLISECONDS).map(new Func1<Long,String>(){
    @Override public String call(    Long timestamp){
      return "test-stream";
    }
  }
);
  private final Observable<String> streamOfOnNextThenOnError=Observable.create(new Observable.OnSubscribe<String>(){
    @Override public void call(    Subscriber<? super String> subscriber){
      try {
        Thread.sleep(100);
        subscriber.onNext("test-stream");
        Thread.sleep(100);
        subscriber.onError(new RuntimeException("stream failure"));
      }
 catch (      InterruptedException ex) {
        ex.printStackTrace();
      }
    }
  }
).subscribeOn(Schedulers.computation());
  private final Observable<String> streamOfOnNextThenOnCompleted=Observable.create(new Observable.OnSubscribe<String>(){
    @Override public void call(    Subscriber<? super String> subscriber){
      try {
        Thread.sleep(100);
        subscriber.onNext("test-stream");
        Thread.sleep(100);
        subscriber.onCompleted();
      }
 catch (      InterruptedException ex) {
        ex.printStackTrace();
      }
    }
  }
).subscribeOn(Schedulers.computation());
  private AbstractHystrixStreamController sse=new AbstractHystrixStreamController(streamOfOnNexts){
    @Override protected int getMaxNumberConcurrentConnectionsAllowed(){
      return 2;
    }
  }
;
  @Test @Ignore("Test is flaky") public void concurrencyTest() throws Exception {
    Response resp=sse.handleRequest();
    assertEquals(200,resp.getStatus());
    assertEquals("text/event-stream;charset=UTF-8",resp.getHeaders().getFirst(HttpHeaders.CONTENT_TYPE));
    assertEquals("no-cache, no-store, max-age=0, must-revalidate",resp.getHeaders().getFirst(HttpHeaders.CACHE_CONTROL));
    assertEquals("no-cache",resp.getHeaders().getFirst("Pragma"));
    resp=sse.handleRequest();
    assertEquals(200,resp.getStatus());
    resp=sse.handleRequest();
    assertEquals(503,resp.getStatus());
    assertEquals("MaxConcurrentConnections reached: " + sse.getMaxNumberConcurrentConnectionsAllowed(),resp.getEntity());
    sse.getCurrentConnections().decrementAndGet();
    resp=sse.handleRequest();
    assertEquals(200,resp.getStatus());
  }
  @Test public void testInfiniteOnNextStream() throws Exception {
    final PipedInputStream is=new PipedInputStream();
    final PipedOutputStream os=new PipedOutputStream(is);
    final AtomicInteger writes=new AtomicInteger(0);
    final HystrixStream stream=new HystrixStream(streamOfOnNexts,100,new AtomicInteger(1));
    Thread streamingThread=startStreamingThread(stream,os);
    verifyStream(is,writes);
    Thread.sleep(1000);
    streamingThread.interrupt();
    os.close();
    is.close();
    System.out.println("Total lines:" + writes.get());
    assertTrue(writes.get() >= 9);
    assertTrue(stream.getConcurrentConnections().get() == 0);
  }
  @Test public void testOnError() throws Exception {
    testStreamOnce(streamOfOnNextThenOnError);
  }
  @Test public void testOnComplete() throws Exception {
    testStreamOnce(streamOfOnNextThenOnCompleted);
  }
  private void testStreamOnce(  Observable<String> observable) throws Exception {
    final PipedInputStream is=new PipedInputStream();
    final PipedOutputStream os=new PipedOutputStream(is);
    final AtomicInteger writes=new AtomicInteger(0);
    final HystrixStream stream=new HystrixStream(observable,100,new AtomicInteger(1));
    startStreamingThread(stream,os);
    verifyStream(is,writes);
    Thread.sleep(1000);
    os.close();
    is.close();
    System.out.println("Total lines:" + writes.get());
    assertTrue(writes.get() == 1);
    assertTrue(stream.getConcurrentConnections().get() == 0);
  }
  private static Thread startStreamingThread(  final HystrixStream stream,  final OutputStream outputSteam){
    Thread th1=new Thread(new Runnable(){
      @Override public void run(){
        try {
          final HystrixStreamingOutputProvider provider=new HystrixStreamingOutputProvider();
          provider.writeTo(stream,null,null,null,null,null,outputSteam);
        }
 catch (        IOException e) {
          fail(e.getMessage());
        }
      }
    }
);
    th1.start();
    return th1;
  }
  private static void verifyStream(  final InputStream is,  final AtomicInteger lineCount){
    Thread th2=new Thread(new Runnable(){
      public void run(){
        BufferedReader br=null;
        try {
          br=new BufferedReader(new InputStreamReader(is));
          String line;
          while ((line=br.readLine()) != null) {
            if (!"".equals(line)) {
              System.out.println(line);
              lineCount.incrementAndGet();
            }
          }
        }
 catch (        IOException e) {
          fail("Failed while verifying streaming output.Stacktrace:" + e.getMessage());
        }
 finally {
          if (br != null) {
            try {
              br.close();
            }
 catch (            IOException e) {
              fail("Failed while verifying streaming output.Stacktrace:" + e.getMessage());
            }
          }
        }
      }
    }
);
    th2.start();
  }
}
