/** 
 * Semaphore based command that allows caller to use latches to know when it has started and signal when it would like the command to finish
 */
private static class LatchedSemaphoreCommand extends TestHystrixObservableCommand<Boolean> {
  private final CountDownLatch startLatch, waitLatch;
  /** 
 * @param circuitBreaker circuit breaker (passed in so it may be shared)
 * @param semaphore semaphore (passed in so it may be shared)
 * @param startLatch this command calls  {@link CountDownLatch#countDown()} immediately upon running
 * @param waitLatch this command calls  {@link CountDownLatch#await()} once it startsto run. The caller can use the latch to signal the command to finish
 */
  private LatchedSemaphoreCommand(  TestCircuitBreaker circuitBreaker,  TryableSemaphoreActual semaphore,  CountDownLatch startLatch,  CountDownLatch waitLatch){
    this("Latched",circuitBreaker,semaphore,startLatch,waitLatch);
  }
  private LatchedSemaphoreCommand(  String commandName,  TestCircuitBreaker circuitBreaker,  TryableSemaphoreActual semaphore,  CountDownLatch startLatch,  CountDownLatch waitLatch){
    super(testPropsBuilder().setCommandKey(HystrixCommandKey.Factory.asKey(commandName)).setCircuitBreaker(circuitBreaker).setMetrics(circuitBreaker.metrics).setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE).withCircuitBreakerEnabled(false)).setExecutionSemaphore(semaphore));
    this.startLatch=startLatch;
    this.waitLatch=waitLatch;
  }
  @Override protected Observable<Boolean> construct(){
    return Observable.create(new OnSubscribe<Boolean>(){
      @Override public void call(      Subscriber<? super Boolean> s){
        startLatch.countDown();
        try {
          waitLatch.await();
          s.onNext(true);
          s.onCompleted();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          s.onNext(false);
          s.onCompleted();
        }
      }
    }
).subscribeOn(Schedulers.computation());
  }
  @Override protected Observable<Boolean> resumeWithFallback(){
    return Observable.defer(new Func0<Observable<Boolean>>(){
      @Override public Observable<Boolean> call(){
        startLatch.countDown();
        return Observable.just(false);
      }
    }
);
  }
}
