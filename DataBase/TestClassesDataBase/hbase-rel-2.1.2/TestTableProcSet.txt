public static class TestTableProcSet {
  private final MasterProcedureScheduler queue;
  public TestTableProcSet(  final MasterProcedureScheduler queue){
    this.queue=queue;
  }
  public void addBack(  Procedure proc){
    queue.addBack(proc);
  }
  public void addFront(  Procedure proc){
    queue.addFront(proc);
  }
  public Procedure acquire(){
    Procedure proc=null;
    boolean waiting=true;
    while (waiting && queue.size() > 0) {
      proc=queue.poll(100000000L);
      if (proc == null)       continue;
switch (getTableOperationType(proc)) {
case CREATE:
case DELETE:
case EDIT:
        waiting=queue.waitTableExclusiveLock(proc,getTableName(proc));
      break;
case READ:
    waiting=queue.waitTableSharedLock(proc,getTableName(proc));
  break;
default :
throw new UnsupportedOperationException();
}
}
return proc;
}
public void release(Procedure proc){
switch (getTableOperationType(proc)) {
case CREATE:
case DELETE:
case EDIT:
queue.wakeTableExclusiveLock(proc,getTableName(proc));
break;
case READ:
queue.wakeTableSharedLock(proc,getTableName(proc));
break;
default :
throw new UnsupportedOperationException();
}
}
public TableName getTableName(Procedure proc){
return ((TableProcedureInterface)proc).getTableName();
}
public TableProcedureInterface.TableOperationType getTableOperationType(Procedure proc){
return ((TableProcedureInterface)proc).getTableOperationType();
}
}
