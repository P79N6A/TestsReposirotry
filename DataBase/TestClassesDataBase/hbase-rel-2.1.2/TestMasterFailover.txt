@Category({FlakeyTests.class,LargeTests.class}) public class TestMasterFailover {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMasterFailover.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestMasterFailover.class);
  @Rule public TestName name=new TestName();
  /** 
 * Simple test of master failover. <p> Starts with three masters.  Kills a backup master.  Then kills the active master.  Ensures the final master becomes active and we can still contact the cluster.
 */
  @Test public void testSimpleMasterFailover() throws Exception {
    final int NUM_MASTERS=3;
    final int NUM_RS=3;
    HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
    try {
      TEST_UTIL.startMiniCluster(NUM_MASTERS,NUM_RS);
      MiniHBaseCluster cluster=TEST_UTIL.getHBaseCluster();
      List<MasterThread> masterThreads=cluster.getMasterThreads();
      for (      MasterThread mt : masterThreads) {
        assertTrue(mt.isAlive());
      }
      int numActive=0;
      int activeIndex=-1;
      ServerName activeName=null;
      HMaster active=null;
      for (int i=0; i < masterThreads.size(); i++) {
        if (masterThreads.get(i).getMaster().isActiveMaster()) {
          numActive++;
          activeIndex=i;
          active=masterThreads.get(activeIndex).getMaster();
          activeName=active.getServerName();
        }
      }
      assertEquals(1,numActive);
      assertEquals(NUM_MASTERS,masterThreads.size());
      LOG.info("Active master " + activeName);
      assertNotNull(active);
      ClusterMetrics status=active.getClusterMetrics();
      assertTrue(status.getMasterName().equals(activeName));
      assertEquals(2,status.getBackupMasterNames().size());
      int backupIndex=(activeIndex == 0 ? 1 : activeIndex - 1);
      HMaster master=cluster.getMaster(backupIndex);
      LOG.debug("\n\nStopping a backup master: " + master.getServerName() + "\n");
      cluster.stopMaster(backupIndex,false);
      cluster.waitOnMaster(backupIndex);
      for (int i=0; i < masterThreads.size(); i++) {
        if (masterThreads.get(i).getMaster().isActiveMaster()) {
          assertTrue(activeName.equals(masterThreads.get(i).getMaster().getServerName()));
          activeIndex=i;
          active=masterThreads.get(activeIndex).getMaster();
        }
      }
      assertEquals(1,numActive);
      assertEquals(2,masterThreads.size());
      int rsCount=masterThreads.get(activeIndex).getMaster().getClusterMetrics().getLiveServerMetrics().size();
      LOG.info("Active master " + active.getServerName() + " managing "+ rsCount+ " regions servers");
      assertEquals(3,rsCount);
      assertNotNull(active);
      status=active.getClusterMetrics();
      assertTrue(status.getMasterName().equals(activeName));
      assertEquals(1,status.getBackupMasterNames().size());
      LOG.debug("\n\nStopping the active master " + active.getServerName() + "\n");
      cluster.stopMaster(activeIndex,false);
      cluster.waitOnMaster(activeIndex);
      assertTrue(cluster.waitForActiveAndReadyMaster());
      LOG.debug("\n\nVerifying backup master is now active\n");
      assertEquals(1,masterThreads.size());
      active=masterThreads.get(0).getMaster();
      assertNotNull(active);
      status=active.getClusterMetrics();
      ServerName mastername=status.getMasterName();
      assertTrue(mastername.equals(active.getServerName()));
      assertTrue(active.isActiveMaster());
      assertEquals(0,status.getBackupMasterNames().size());
      int rss=status.getLiveServerMetrics().size();
      LOG.info("Active master " + mastername.getServerName() + " managing "+ rss+ " region servers");
      assertEquals(3,rss);
    }
  finally {
      TEST_UTIL.shutdownMiniCluster();
    }
  }
  /** 
 * Test meta in transition when master failover. This test used to manipulate region state up in zk. That is not allowed any more in hbase2 so I removed that messing. That makes this test anemic.
 */
  @Test public void testMetaInTransitionWhenMasterFailover() throws Exception {
    final int NUM_MASTERS=1;
    final int NUM_RS=1;
    HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
    TEST_UTIL.startMiniCluster(NUM_MASTERS,NUM_RS);
    try {
      MiniHBaseCluster cluster=TEST_UTIL.getHBaseCluster();
      LOG.info("Cluster started");
      HMaster activeMaster=cluster.getMaster();
      ServerName metaServerName=cluster.getServerHoldingMeta();
      HRegionServer hrs=cluster.getRegionServer(metaServerName);
      LOG.info("Aborting master");
      activeMaster.abort("test-kill");
      cluster.waitForMasterToStop(activeMaster.getServerName(),30000);
      LOG.info("Master has aborted");
      RegionState metaState=MetaTableLocator.getMetaRegionState(hrs.getZooKeeper());
      assertEquals("hbase:meta should be online on RS",metaState.getServerName(),metaServerName);
      assertEquals("hbase:meta should be online on RS",State.OPEN,metaState.getState());
      LOG.info("Starting up a new master");
      activeMaster=cluster.startMaster().getMaster();
      LOG.info("Waiting for master to be ready");
      cluster.waitForActiveAndReadyMaster();
      LOG.info("Master is ready");
      metaState=MetaTableLocator.getMetaRegionState(activeMaster.getZooKeeper());
      assertEquals("hbase:meta should be online on RS",metaState.getServerName(),metaServerName);
      assertEquals("hbase:meta should be online on RS",State.OPEN,metaState.getState());
    }
  finally {
      TEST_UTIL.shutdownMiniCluster();
    }
  }
}
