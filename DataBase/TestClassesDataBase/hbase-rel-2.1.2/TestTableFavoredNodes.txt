@Category({ClientTests.class,MediumTests.class}) public class TestTableFavoredNodes {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestTableFavoredNodes.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestTableFavoredNodes.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private final static int WAIT_TIMEOUT=60000;
  private final static int SLAVES=8;
  private FavoredNodesManager fnm;
  private Admin admin;
  private final byte[][] splitKeys=new byte[][]{Bytes.toBytes(1),Bytes.toBytes(9)};
  private final int NUM_REGIONS=splitKeys.length + 1;
  @Rule public TestName name=new TestName();
  @BeforeClass public static void setupBeforeClass() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,LoadOnlyFavoredStochasticBalancer.class,LoadBalancer.class);
    conf.set(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART,"" + SLAVES);
    conf.set(BaseLoadBalancer.TABLES_ON_MASTER,"none");
    TEST_UTIL.startMiniCluster(SLAVES);
    TEST_UTIL.getMiniHBaseCluster().waitForActiveAndReadyMaster(WAIT_TIMEOUT);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
    TEST_UTIL.cleanupTestDir();
  }
  @Before public void setup() throws IOException {
    fnm=TEST_UTIL.getMiniHBaseCluster().getMaster().getFavoredNodesManager();
    admin=TEST_UTIL.getAdmin();
    admin.setBalancerRunning(false,true);
    admin.enableCatalogJanitor(false);
  }
  @Test public void testCreateTable() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    TEST_UTIL.createTable(tableName,Bytes.toBytes("f"),splitKeys);
    TEST_UTIL.waitUntilAllRegionsAssigned(tableName);
    checkIfFavoredNodeInformationIsCorrect(tableName);
    List<HRegionInfo> regions=admin.getTableRegions(tableName);
    TEST_UTIL.deleteTable(tableName);
    checkNoFNForDeletedTable(regions);
  }
  @Test public void testTruncateTable() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    TEST_UTIL.createTable(tableName,Bytes.toBytes("f"),splitKeys);
    TEST_UTIL.waitUntilAllRegionsAssigned(tableName);
    checkIfFavoredNodeInformationIsCorrect(tableName);
    List<HRegionInfo> regions=admin.getTableRegions(tableName);
    TEST_UTIL.truncateTable(tableName,true);
    checkNoFNForDeletedTable(regions);
    checkIfFavoredNodeInformationIsCorrect(tableName);
    regions=admin.getTableRegions(tableName);
    TEST_UTIL.truncateTable(tableName,false);
    checkNoFNForDeletedTable(regions);
    TEST_UTIL.deleteTable(tableName);
  }
  @Test public void testSplitTable() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    Table t=TEST_UTIL.createTable(tableName,Bytes.toBytes("f"),splitKeys);
    TEST_UTIL.waitUntilAllRegionsAssigned(tableName);
    final int numberOfRegions=admin.getTableRegions(t.getName()).size();
    checkIfFavoredNodeInformationIsCorrect(tableName);
    byte[] splitPoint=Bytes.toBytes(0);
    RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
    HRegionInfo parent=locator.getRegionLocation(splitPoint).getRegionInfo();
    List<ServerName> parentFN=fnm.getFavoredNodes(parent);
    assertNotNull("FN should not be null for region: " + parent,parentFN);
    LOG.info("SPLITTING TABLE");
    admin.split(tableName,splitPoint);
    TEST_UTIL.waitUntilNoRegionsInTransition(WAIT_TIMEOUT);
    LOG.info("FINISHED WAITING ON RIT");
    waitUntilTableRegionCountReached(tableName,numberOfRegions + 1);
    HRegionInfo daughter1=locator.getRegionLocation(parent.getStartKey(),true).getRegionInfo();
    List<ServerName> daughter1FN=fnm.getFavoredNodes(daughter1);
    HRegionInfo daughter2=locator.getRegionLocation(splitPoint,true).getRegionInfo();
    List<ServerName> daughter2FN=fnm.getFavoredNodes(daughter2);
    checkIfDaughterInherits2FN(parentFN,daughter1FN);
    checkIfDaughterInherits2FN(parentFN,daughter2FN);
    assertEquals("Daughter's PRIMARY FN should be PRIMARY of parent",parentFN.get(PRIMARY.ordinal()),daughter1FN.get(PRIMARY.ordinal()));
    assertEquals("Daughter's SECONDARY FN should be SECONDARY of parent",parentFN.get(SECONDARY.ordinal()),daughter1FN.get(SECONDARY.ordinal()));
    assertEquals("Daughter's PRIMARY FN should be PRIMARY of parent",parentFN.get(PRIMARY.ordinal()),daughter2FN.get(PRIMARY.ordinal()));
    assertEquals("Daughter's SECONDARY FN should be TERTIARY of parent",parentFN.get(TERTIARY.ordinal()),daughter2FN.get(SECONDARY.ordinal()));
    TEST_UTIL.getMiniHBaseCluster().compact(tableName,true);
    admin.runCatalogScan();
    ProcedureTestingUtility.waitAllProcedures(TEST_UTIL.getMiniHBaseCluster().getMaster().getMasterProcedureExecutor());
    assertNull("Parent FN should be null",fnm.getFavoredNodes(parent));
    List<HRegionInfo> regions=admin.getTableRegions(tableName);
    Threads.sleep(2000);
    LOG.info("STARTING DELETE");
    TEST_UTIL.deleteTable(tableName);
    checkNoFNForDeletedTable(regions);
  }
  @Test public void testMergeTable() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    TEST_UTIL.createTable(tableName,Bytes.toBytes("f"),splitKeys);
    TEST_UTIL.waitUntilAllRegionsAssigned(tableName);
    checkIfFavoredNodeInformationIsCorrect(tableName);
    RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
    HRegionInfo regionA=locator.getRegionLocation(HConstants.EMPTY_START_ROW).getRegionInfo();
    HRegionInfo regionB=locator.getRegionLocation(splitKeys[0]).getRegionInfo();
    List<ServerName> regionAFN=fnm.getFavoredNodes(regionA);
    LOG.info("regionA: " + regionA.getEncodedName() + " with FN: "+ fnm.getFavoredNodes(regionA));
    LOG.info("regionB: " + regionA.getEncodedName() + " with FN: "+ fnm.getFavoredNodes(regionB));
    int countOfRegions=MetaTableAccessor.getRegionCount(TEST_UTIL.getConfiguration(),tableName);
    admin.mergeRegionsAsync(regionA.getEncodedNameAsBytes(),regionB.getEncodedNameAsBytes(),false).get(60,TimeUnit.SECONDS);
    TEST_UTIL.waitUntilNoRegionsInTransition(WAIT_TIMEOUT);
    waitUntilTableRegionCountReached(tableName,countOfRegions - 1);
    checkIfFavoredNodeInformationIsCorrect(tableName);
    HRegionInfo mergedRegion=locator.getRegionLocation(HConstants.EMPTY_START_ROW).getRegionInfo();
    List<ServerName> mergedFN=fnm.getFavoredNodes(mergedRegion);
    assertArrayEquals("Merged region doesn't match regionA's FN",regionAFN.toArray(),mergedFN.toArray());
    TEST_UTIL.getMiniHBaseCluster().compact(tableName,true);
    assertEquals("Merge parents should have been cleaned",1,admin.runCatalogScan());
    ProcedureTestingUtility.waitAllProcedures(TEST_UTIL.getMiniHBaseCluster().getMaster().getMasterProcedureExecutor());
    assertNull("Parent FN should be null",fnm.getFavoredNodes(regionA));
    assertNull("Parent FN should be null",fnm.getFavoredNodes(regionB));
    List<HRegionInfo> regions=admin.getTableRegions(tableName);
    TEST_UTIL.deleteTable(tableName);
    checkNoFNForDeletedTable(regions);
  }
  private void checkNoFNForDeletedTable(  List<HRegionInfo> regions){
    for (    HRegionInfo region : regions) {
      LOG.info("Testing if FN data for " + region);
      assertNull("FN not null for deleted table's region: " + region,fnm.getFavoredNodes(region));
    }
  }
  private void checkIfFavoredNodeInformationIsCorrect(  TableName tableName) throws Exception {
    Map<ServerName,HRegionServer> snRSMap=Maps.newHashMap();
    for (    JVMClusterUtil.RegionServerThread rst : TEST_UTIL.getMiniHBaseCluster().getLiveRegionServerThreads()) {
      snRSMap.put(rst.getRegionServer().getServerName(),rst.getRegionServer());
    }
    for (    JVMClusterUtil.MasterThread rst : TEST_UTIL.getMiniHBaseCluster().getLiveMasterThreads()) {
      snRSMap.put(rst.getMaster().getServerName(),rst.getMaster());
    }
    int dnPort=fnm.getDataNodePort();
    RegionLocator regionLocator=admin.getConnection().getRegionLocator(tableName);
    for (    HRegionLocation regionLocation : regionLocator.getAllRegionLocations()) {
      HRegionInfo regionInfo=regionLocation.getRegionInfo();
      List<ServerName> fnList=fnm.getFavoredNodes(regionInfo);
      assertNotNull("Favored nodes should not be null for region:" + regionInfo,fnList);
      assertEquals("Incorrect favored nodes for region:" + regionInfo + " fnlist: "+ fnList,FavoredNodeAssignmentHelper.FAVORED_NODES_NUM,fnList.size());
      for (      ServerName sn : fnList) {
        assertEquals("FN should not have startCode, fnlist:" + fnList,-1,sn.getStartcode());
      }
      HRegionServer regionServer=snRSMap.get(regionLocation.getServerName());
      assertNotNull("RS should not be null for regionLocation: " + regionLocation,regionServer);
      InetSocketAddress[] rsFavNodes=regionServer.getFavoredNodesForRegion(regionInfo.getEncodedName());
      assertNotNull("RS " + regionLocation.getServerName() + " does not have FN for region: "+ regionInfo,rsFavNodes);
      assertEquals("Incorrect FN for region:" + regionInfo.getEncodedName() + " on server:"+ regionLocation.getServerName(),FavoredNodeAssignmentHelper.FAVORED_NODES_NUM,rsFavNodes.length);
      for (      ServerName sn : fnm.getFavoredNodesWithDNPort(regionInfo)) {
        assertEquals("FN should not have startCode, fnlist:" + fnList,-1,sn.getStartcode());
        assertEquals("FN port should belong to DN port, fnlist:" + fnList,dnPort,sn.getPort());
      }
    }
  }
  @Test public void testSystemTables() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    TEST_UTIL.createTable(tableName,Bytes.toBytes("f"),splitKeys);
    TEST_UTIL.waitUntilAllRegionsAssigned(tableName);
    checkIfFavoredNodeInformationIsCorrect(tableName);
    for (    TableName sysTable : admin.listTableNamesByNamespace(NamespaceDescriptor.SYSTEM_NAMESPACE_NAME_STR)) {
      List<HRegionInfo> regions=admin.getTableRegions(sysTable);
      for (      HRegionInfo region : regions) {
        assertNull("FN should be null for sys region",fnm.getFavoredNodes(region));
      }
    }
    TEST_UTIL.deleteTable(tableName);
  }
  private void checkIfDaughterInherits2FN(  List<ServerName> parentFN,  List<ServerName> daughterFN){
    assertNotNull(parentFN);
    assertNotNull(daughterFN);
    List<ServerName> favoredNodes=Lists.newArrayList(daughterFN);
    favoredNodes.removeAll(parentFN);
    assertTrue("Daughter FN:" + daughterFN + " should have inherited 2 FN from parent FN:"+ parentFN,favoredNodes.size() <= 1);
  }
  private void waitUntilTableRegionCountReached(  final TableName tableName,  final int numRegions) throws Exception {
    TEST_UTIL.waitFor(WAIT_TIMEOUT,new Waiter.Predicate<Exception>(){
      @Override public boolean evaluate() throws Exception {
        return MetaTableAccessor.getRegionCount(TEST_UTIL.getConfiguration(),tableName) == numRegions;
      }
    }
);
  }
}
