@Category(MediumTests.class) public class TestFlushWithThroughputController {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestFlushWithThroughputController.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestFlushWithThroughputController.class);
  private static final double EPSILON=1E-6;
  private HBaseTestingUtility hbtu;
  @Rule public TestName testName=new TestName();
  private TableName tableName;
  private final byte[] family=Bytes.toBytes("f");
  private final byte[] qualifier=Bytes.toBytes("q");
  @Before public void setUp(){
    hbtu=new HBaseTestingUtility();
    tableName=TableName.valueOf("Table-" + testName.getMethodName());
    hbtu.getConfiguration().set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,PressureAwareFlushThroughputController.class.getName());
  }
  @After public void tearDown() throws Exception {
    hbtu.shutdownMiniCluster();
  }
  private HStore getStoreWithName(  TableName tableName){
    MiniHBaseCluster cluster=hbtu.getMiniHBaseCluster();
    List<JVMClusterUtil.RegionServerThread> rsts=cluster.getRegionServerThreads();
    for (int i=0; i < cluster.getRegionServerThreads().size(); i++) {
      HRegionServer hrs=rsts.get(i).getRegionServer();
      for (      Region region : hrs.getRegions(tableName)) {
        return ((HRegion)region).getStores().iterator().next();
      }
    }
    return null;
  }
  private void setMaxMinThroughputs(  long max,  long min){
    Configuration conf=hbtu.getConfiguration();
    conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_LOWER_BOUND,min);
    conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_UPPER_BOUND,max);
  }
  /** 
 * Writes Puts to the table and flushes few times.
 * @return {@link Pair} of (throughput, duration).
 */
  private Pair<Double,Long> generateAndFlushData(  Table table) throws IOException {
    final int NUM_FLUSHES=3, NUM_PUTS=50, VALUE_SIZE=200 * 1024;
    Random rand=new Random();
    long duration=0;
    for (int i=0; i < NUM_FLUSHES; i++) {
      for (int j=0; j < NUM_PUTS; j++) {
        byte[] value=new byte[VALUE_SIZE];
        rand.nextBytes(value);
        table.put(new Put(Bytes.toBytes(i * 10 + j)).addColumn(family,qualifier,value));
      }
      long startTime=System.nanoTime();
      hbtu.getAdmin().flush(tableName);
      duration+=System.nanoTime() - startTime;
    }
    HStore store=getStoreWithName(tableName);
    assertEquals(NUM_FLUSHES,store.getStorefilesCount());
    double throughput=(double)store.getStorefilesSize() / TimeUnit.NANOSECONDS.toSeconds(duration);
    return new Pair<>(throughput,duration);
  }
  private long testFlushWithThroughputLimit() throws Exception {
    final long throughputLimit=1024 * 1024;
    setMaxMinThroughputs(throughputLimit,throughputLimit);
    Configuration conf=hbtu.getConfiguration();
    conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_THROUGHPUT_CONTROL_CHECK_INTERVAL,throughputLimit);
    hbtu.startMiniCluster(1);
    Table table=hbtu.createTable(tableName,family);
    Pair<Double,Long> result=generateAndFlushData(table);
    hbtu.deleteTable(tableName);
    LOG.debug("Throughput is: " + (result.getFirst() / 1024 / 1024) + " MB/s");
    assertTrue(result.getFirst() < throughputLimit * 1.2);
    assertTrue(result.getFirst() > throughputLimit * 0.8);
    return result.getSecond();
  }
  @Test public void testFlushControl() throws Exception {
    testFlushWithThroughputLimit();
  }
  /** 
 * Test the tuning task of  {@link PressureAwareFlushThroughputController}
 */
  @Test public void testFlushThroughputTuning() throws Exception {
    Configuration conf=hbtu.getConfiguration();
    setMaxMinThroughputs(20L * 1024 * 1024,10L * 1024 * 1024);
    conf.set(StoreEngine.STORE_ENGINE_CLASS_KEY,DefaultStoreEngine.class.getName());
    conf.setInt(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_THROUGHPUT_TUNE_PERIOD,3000);
    hbtu.startMiniCluster(1);
    Connection conn=ConnectionFactory.createConnection(conf);
    hbtu.getAdmin().createTable(TableDescriptorBuilder.newBuilder(tableName).setColumnFamily(ColumnFamilyDescriptorBuilder.of(family)).setCompactionEnabled(false).build());
    hbtu.waitTableAvailable(tableName);
    HRegionServer regionServer=hbtu.getRSForFirstRegionInTable(tableName);
    double pressure=regionServer.getFlushPressure();
    LOG.debug("Flush pressure before flushing: " + pressure);
    PressureAwareFlushThroughputController throughputController=(PressureAwareFlushThroughputController)regionServer.getFlushThroughputController();
    for (    HRegion region : regionServer.getRegions()) {
      region.flush(true);
    }
    assertTrue(regionServer.getFlushPressure() < pressure);
    Thread.sleep(5000);
    boolean tablesOnMaster=LoadBalancer.isTablesOnMaster(hbtu.getConfiguration());
    if (tablesOnMaster) {
      assertEquals(10L * 1024 * 1024,throughputController.getMaxThroughput(),EPSILON);
    }
    Table table=conn.getTable(tableName);
    Random rand=new Random();
    for (int i=0; i < 10; i++) {
      for (int j=0; j < 10; j++) {
        byte[] value=new byte[256 * 1024];
        rand.nextBytes(value);
        table.put(new Put(Bytes.toBytes(i * 10 + j)).addColumn(family,qualifier,value));
      }
    }
    Thread.sleep(5000);
    double expectedThroughPut=10L * 1024 * 1024* (1 + regionServer.getFlushPressure());
    assertEquals(expectedThroughPut,throughputController.getMaxThroughput(),EPSILON);
    conf.set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,NoLimitThroughputController.class.getName());
    regionServer.onConfigurationChange(conf);
    assertTrue(throughputController.isStopped());
    assertTrue(regionServer.getFlushThroughputController() instanceof NoLimitThroughputController);
    conn.close();
  }
  /** 
 * Test the logic for striped store.
 */
  @Test public void testFlushControlForStripedStore() throws Exception {
    hbtu.getConfiguration().set(StoreEngine.STORE_ENGINE_CLASS_KEY,StripeStoreEngine.class.getName());
    testFlushWithThroughputLimit();
  }
}
