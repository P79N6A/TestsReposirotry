/** 
 * This Event+Procedure exhibits following behavior: <ul> <li>On procedure execute() <ul> <li>If had enough timeouts, abort the procedure. Else....</li> <li>Suspend the event and add self to its suspend queue</li> <li>Go into waiting state</li> </ul> </li> <li> On waiting timeout <ul> <li>Wake the event (which adds this procedure back into scheduler queue), and set own's state to RUNNABLE (so can be executed again).</li> </ul> </li> </ul>
 */
public static class TestTimeoutEventProcedure extends NoopProcedure<TestProcEnv> {
  private final ProcedureEvent event=new ProcedureEvent("timeout-event");
  private final AtomicInteger ntimeouts=new AtomicInteger(0);
  private int maxTimeouts=1;
  public TestTimeoutEventProcedure(){
  }
  public TestTimeoutEventProcedure(  final int timeoutMsec,  final int maxTimeouts){
    this.maxTimeouts=maxTimeouts;
    setTimeout(timeoutMsec);
  }
  public int getTimeoutsCount(){
    return ntimeouts.get();
  }
  @Override protected Procedure[] execute(  final TestProcEnv env) throws ProcedureSuspendedException {
    LOG.info("EXECUTE " + this + " ntimeouts="+ ntimeouts);
    if (ntimeouts.get() > maxTimeouts) {
      setAbortFailure("test","give up after " + ntimeouts.get());
      return null;
    }
    event.suspend();
    if (event.suspendIfNotReady(this)) {
      setState(ProcedureState.WAITING_TIMEOUT);
      throw new ProcedureSuspendedException();
    }
    return null;
  }
  @Override protected synchronized boolean setTimeoutFailure(  final TestProcEnv env){
    int n=ntimeouts.incrementAndGet();
    LOG.info("HANDLE TIMEOUT " + this + " ntimeouts="+ n);
    setState(ProcedureState.RUNNABLE);
    event.wake((AbstractProcedureScheduler)env.getProcedureScheduler());
    return false;
  }
  @Override protected void afterReplay(  final TestProcEnv env){
    if (getState() == ProcedureState.WAITING_TIMEOUT) {
      event.suspend();
      event.suspendIfNotReady(this);
    }
  }
  @Override protected void serializeStateData(  ProcedureStateSerializer serializer) throws IOException {
    Int32Value.Builder ntimeoutsBuilder=Int32Value.newBuilder().setValue(ntimeouts.get());
    serializer.serialize(ntimeoutsBuilder.build());
    Int32Value.Builder maxTimeoutsBuilder=Int32Value.newBuilder().setValue(maxTimeouts);
    serializer.serialize(maxTimeoutsBuilder.build());
  }
  @Override protected void deserializeStateData(  ProcedureStateSerializer serializer) throws IOException {
    Int32Value ntimeoutsValue=serializer.deserialize(Int32Value.class);
    ntimeouts.set(ntimeoutsValue.getValue());
    Int32Value maxTimeoutsValue=serializer.deserialize(Int32Value.class);
    maxTimeouts=maxTimeoutsValue.getValue();
  }
}
