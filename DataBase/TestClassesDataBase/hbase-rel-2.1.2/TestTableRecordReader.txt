@Category(MediumTests.class) public class TestTableRecordReader {
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestTableRecordReader.class);
  private static TableName TABLE_NAME=TableName.valueOf("TestTableRecordReader");
  private static int NUM_ROWS=5;
  private static byte[] ROW=Bytes.toBytes("testRow");
  private static byte[][] ROWS=HTestConst.makeNAscii(ROW,NUM_ROWS);
  private static int NUM_FAMILIES=2;
  private static byte[] FAMILY=Bytes.toBytes("testFamily");
  private static byte[][] FAMILIES=HTestConst.makeNAscii(FAMILY,NUM_FAMILIES);
  private static int NUM_QUALIFIERS=2;
  private static byte[] QUALIFIER=Bytes.toBytes("testQualifier");
  private static byte[][] QUALIFIERS=HTestConst.makeNAscii(QUALIFIER,NUM_QUALIFIERS);
  private static int VALUE_SIZE=10;
  private static byte[] VALUE=Bytes.createMaxByteArray(VALUE_SIZE);
  private static final int TIMEOUT=4000;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setInt(HConstants.HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD,TIMEOUT);
    conf.setInt(HConstants.HBASE_RPC_TIMEOUT_KEY,TIMEOUT);
    conf.setLong(StoreScanner.HBASE_CELLS_SCANNED_PER_HEARTBEAT_CHECK,1);
    TEST_UTIL.startMiniCluster(1);
    createTestTable(TABLE_NAME,ROWS,FAMILIES,QUALIFIERS,VALUE);
  }
  private static void createTestTable(  TableName name,  byte[][] rows,  byte[][] families,  byte[][] qualifiers,  byte[] cellValue) throws IOException {
    TEST_UTIL.createTable(name,families).put(createPuts(rows,families,qualifiers,cellValue));
  }
  private static List<Put> createPuts(  byte[][] rows,  byte[][] families,  byte[][] qualifiers,  byte[] value) throws IOException {
    List<Put> puts=new ArrayList<>();
    for (int row=0; row < rows.length; row++) {
      Put put=new Put(rows[row]);
      for (int fam=0; fam < families.length; fam++) {
        for (int qual=0; qual < qualifiers.length; qual++) {
          KeyValue kv=new KeyValue(rows[row],families[fam],qualifiers[qual],qual,value);
          put.add(kv);
        }
      }
      puts.add(put);
    }
    return puts;
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void test() throws Exception {
    try (Connection conn=ConnectionFactory.createConnection(TEST_UTIL.getConfiguration());Table table=conn.getTable(TABLE_NAME)){
      org.apache.hadoop.hbase.mapreduce.TableRecordReaderImpl trr=new org.apache.hadoop.hbase.mapreduce.TableRecordReaderImpl();
      Scan scan=new Scan().setMaxResultSize(1).setCaching(Integer.MAX_VALUE).setNeedCursorResult(true);
      trr.setScan(scan);
      trr.setHTable(table);
      trr.initialize(null,null);
      int num=0;
      while (trr.nextKeyValue()) {
        num++;
      }
      assertEquals(NUM_ROWS * NUM_FAMILIES * NUM_QUALIFIERS,num);
    }
   }
}
