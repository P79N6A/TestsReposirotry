@Category({MasterTests.class,MediumTests.class}) public class TestEnableTable {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestEnableTable.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final Logger LOG=LoggerFactory.getLogger(TestEnableTable.class);
  private static final byte[] FAMILYNAME=Bytes.toBytes("fam");
  @Rule public TestName name=new TestName();
  @Before public void setUp() throws Exception {
    TEST_UTIL.getConfiguration().set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,MasterSyncObserver.class.getName());
    TEST_UTIL.startMiniCluster(1);
  }
  @After public void tearDown() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testEnableTableWithNoRegionServers() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final MiniHBaseCluster cluster=TEST_UTIL.getHBaseCluster();
    final HMaster m=cluster.getMaster();
    final Admin admin=TEST_UTIL.getAdmin();
    final HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(FAMILYNAME));
    admin.createTable(desc);
    admin.disableTable(tableName);
    TEST_UTIL.waitTableDisabled(tableName.getName());
    admin.enableTable(tableName);
    TEST_UTIL.waitTableEnabled(tableName);
    admin.disableTable(tableName);
    TEST_UTIL.waitUntilNoRegionsInTransition(60000);
    JVMClusterUtil.RegionServerThread rs=cluster.getRegionServerThreads().get(0);
    rs.getRegionServer().stop("stop");
    cluster.waitForRegionServerToStop(rs.getRegionServer().getServerName(),10000);
    JVMClusterUtil.RegionServerThread rs2=cluster.startRegionServer();
    cluster.waitForRegionServerToStart(rs2.getRegionServer().getServerName().getHostname(),rs2.getRegionServer().getServerName().getPort(),60000);
    LOG.debug("Now enabling table " + tableName);
    admin.enableTable(tableName);
    assertTrue(admin.isTableEnabled(tableName));
    List<HRegionInfo> regions=TEST_UTIL.getAdmin().getTableRegions(tableName);
    assertEquals(1,regions.size());
    for (    HRegionInfo region : regions) {
      TEST_UTIL.getAdmin().assign(region.getEncodedNameAsBytes());
    }
    LOG.debug("Waiting for table assigned " + tableName);
    TEST_UTIL.waitUntilAllRegionsAssigned(tableName);
    List<HRegionInfo> onlineRegions=admin.getOnlineRegions(rs2.getRegionServer().getServerName());
    ArrayList<HRegionInfo> tableRegions=filterTableRegions(tableName,onlineRegions);
    assertEquals(1,tableRegions.size());
  }
  private ArrayList<HRegionInfo> filterTableRegions(  final TableName tableName,  List<HRegionInfo> onlineRegions){
    return Lists.newArrayList(Iterables.filter(onlineRegions,new Predicate<HRegionInfo>(){
      @Override public boolean apply(      HRegionInfo input){
        return input.getTable().equals(tableName);
      }
    }
));
  }
  /** 
 * We were only clearing rows that had a hregioninfo column in hbase:meta.  Mangled rows that were missing the hregioninfo because of error were being left behind messing up any subsequent table made with the same name. HBASE-12980
 * @throws IOException
 * @throws InterruptedException
 */
  @Test public void testDeleteForSureClearsAllTableRowsFromMeta() throws IOException, InterruptedException {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final Admin admin=TEST_UTIL.getAdmin();
    final HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(FAMILYNAME));
    try {
      createTable(TEST_UTIL,desc,HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail("Got an exception while creating " + tableName);
    }
    try (Table metaTable=TEST_UTIL.getConnection().getTable(TableName.META_TABLE_NAME)){
      try (ResultScanner scanner=metaTable.getScanner(MetaTableAccessor.getScanForTableName(TEST_UTIL.getConnection(),tableName))){
        for (        Result result : scanner) {
          Delete d=new Delete(result.getRow());
          d.addColumn(HConstants.CATALOG_FAMILY,HConstants.REGIONINFO_QUALIFIER);
          LOG.info("Mangled: " + d);
          metaTable.delete(d);
          break;
        }
      }
       admin.disableTable(tableName);
      TEST_UTIL.waitTableDisabled(tableName.getName());
      try {
        deleteTable(TEST_UTIL,tableName);
      }
 catch (      Exception e) {
        e.printStackTrace();
        fail("Got an exception while deleting " + tableName);
      }
      int rowCount=0;
      try (ResultScanner scanner=metaTable.getScanner(MetaTableAccessor.getScanForTableName(TEST_UTIL.getConnection(),tableName))){
        for (        Result result : scanner) {
          LOG.info("Found when none expected: " + result);
          rowCount++;
        }
      }
       assertEquals(0,rowCount);
    }
   }
public static class MasterSyncObserver implements MasterCoprocessor, MasterObserver {
    volatile CountDownLatch tableCreationLatch=null;
    volatile CountDownLatch tableDeletionLatch=null;
    @Override public Optional<MasterObserver> getMasterObserver(){
      return Optional.of(this);
    }
    @Override public void postCompletedCreateTableAction(    final ObserverContext<MasterCoprocessorEnvironment> ctx,    final TableDescriptor desc,    final RegionInfo[] regions) throws IOException {
      if (tableCreationLatch != null) {
        tableCreationLatch.countDown();
      }
    }
    @Override public void postCompletedDeleteTableAction(    final ObserverContext<MasterCoprocessorEnvironment> ctx,    final TableName tableName) throws IOException {
      if (tableDeletionLatch != null) {
        tableDeletionLatch.countDown();
      }
    }
  }
  public static void createTable(  HBaseTestingUtility testUtil,  HTableDescriptor htd,  byte[][] splitKeys) throws Exception {
    MasterSyncObserver observer=testUtil.getHBaseCluster().getMaster().getMasterCoprocessorHost().findCoprocessor(MasterSyncObserver.class);
    observer.tableCreationLatch=new CountDownLatch(1);
    Admin admin=testUtil.getAdmin();
    if (splitKeys != null) {
      admin.createTable(htd,splitKeys);
    }
 else {
      admin.createTable(htd);
    }
    observer.tableCreationLatch.await();
    observer.tableCreationLatch=null;
    testUtil.waitUntilAllRegionsAssigned(htd.getTableName());
  }
  public static void deleteTable(  HBaseTestingUtility testUtil,  TableName tableName) throws Exception {
    MasterSyncObserver observer=testUtil.getHBaseCluster().getMaster().getMasterCoprocessorHost().findCoprocessor(MasterSyncObserver.class);
    observer.tableDeletionLatch=new CountDownLatch(1);
    Admin admin=testUtil.getAdmin();
    try {
      admin.disableTable(tableName);
    }
 catch (    Exception e) {
      LOG.debug("Table: " + tableName + " already disabled, so just deleting it.");
    }
    admin.deleteTable(tableName);
    observer.tableDeletionLatch.await();
    observer.tableDeletionLatch=null;
  }
}
