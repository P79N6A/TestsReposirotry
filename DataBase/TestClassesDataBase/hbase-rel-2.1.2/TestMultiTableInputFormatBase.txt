/** 
 * Tests of MultiTableInputFormatBase.
 */
@Category({SmallTests.class}) public class TestMultiTableInputFormatBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMultiTableInputFormatBase.class);
  @Rule public final TestName name=new TestName();
  /** 
 * Test getSplits only puts up one Connection. In past it has put up many Connections. Each Connection setup comes with a fresh new cache so we have to do fresh hit on hbase:meta. Should only do one Connection when doing getSplits even if a MultiTableInputFormat.
 * @throws IOException
 */
  @Test public void testMRSplitsConnectionCount() throws IOException {
    MultiTableInputFormatBase mtif=new MultiTableInputFormatBase(){
      @Override public RecordReader<ImmutableBytesWritable,Result> createRecordReader(      InputSplit split,      TaskAttemptContext context) throws IOException, InterruptedException {
        return super.createRecordReader(split,context);
      }
    }
;
    JobContext mockedJobContext=Mockito.mock(JobContext.class);
    Configuration c=HBaseConfiguration.create();
    c.set(ClusterConnection.HBASE_CLIENT_CONNECTION_IMPL,MRSplitsConnection.class.getName());
    Mockito.when(mockedJobContext.getConfiguration()).thenReturn(c);
    List<Scan> scans=new ArrayList<>();
    for (int i=0; i < 10; i++) {
      Scan scan=new Scan();
      String tableName=this.name.getMethodName() + i;
      scan.setAttribute(SCAN_ATTRIBUTES_TABLE_NAME,Bytes.toBytes(tableName));
      scans.add(scan);
    }
    mtif.setScans(scans);
    List<InputSplit> splits=mtif.getSplits(mockedJobContext);
    Assert.assertTrue(splits.size() > 0);
    Assert.assertEquals(1,MRSplitsConnection.creations.get());
  }
  /** 
 * Connection to use above in Test.
 */
public static class MRSplitsConnection implements Connection {
    private final Configuration configuration;
    static final AtomicInteger creations=new AtomicInteger(0);
    MRSplitsConnection(    Configuration conf,    ExecutorService pool,    User user) throws IOException {
      this.configuration=conf;
      creations.incrementAndGet();
    }
    @Override public void abort(    String why,    Throwable e){
    }
    @Override public boolean isAborted(){
      return false;
    }
    @Override public Configuration getConfiguration(){
      return this.configuration;
    }
    @Override public BufferedMutator getBufferedMutator(    TableName tableName) throws IOException {
      return null;
    }
    @Override public BufferedMutator getBufferedMutator(    BufferedMutatorParams params) throws IOException {
      return null;
    }
    @Override public RegionLocator getRegionLocator(    final TableName tableName) throws IOException {
      final byte[][] startKeys=new byte[][]{HConstants.EMPTY_BYTE_ARRAY,Bytes.toBytes("aaaa"),Bytes.toBytes("bbb"),Bytes.toBytes("ccc"),Bytes.toBytes("ddd"),Bytes.toBytes("eee"),Bytes.toBytes("fff"),Bytes.toBytes("ggg"),Bytes.toBytes("hhh"),Bytes.toBytes("iii"),Bytes.toBytes("lll"),Bytes.toBytes("mmm"),Bytes.toBytes("nnn"),Bytes.toBytes("ooo"),Bytes.toBytes("ppp"),Bytes.toBytes("qqq"),Bytes.toBytes("rrr"),Bytes.toBytes("sss"),Bytes.toBytes("ttt"),Bytes.toBytes("uuu"),Bytes.toBytes("vvv"),Bytes.toBytes("zzz")};
      final byte[][] endKeys=new byte[][]{Bytes.toBytes("aaaa"),Bytes.toBytes("bbb"),Bytes.toBytes("ccc"),Bytes.toBytes("ddd"),Bytes.toBytes("eee"),Bytes.toBytes("fff"),Bytes.toBytes("ggg"),Bytes.toBytes("hhh"),Bytes.toBytes("iii"),Bytes.toBytes("lll"),Bytes.toBytes("mmm"),Bytes.toBytes("nnn"),Bytes.toBytes("ooo"),Bytes.toBytes("ppp"),Bytes.toBytes("qqq"),Bytes.toBytes("rrr"),Bytes.toBytes("sss"),Bytes.toBytes("ttt"),Bytes.toBytes("uuu"),Bytes.toBytes("vvv"),Bytes.toBytes("zzz"),HConstants.EMPTY_BYTE_ARRAY};
      final Map<byte[],HRegionLocation> map=new TreeMap<byte[],HRegionLocation>(Bytes.BYTES_COMPARATOR);
      for (      byte[] startKey : startKeys) {
        HRegionLocation hrl=new HRegionLocation(RegionInfoBuilder.newBuilder(tableName).setStartKey(startKey).build(),ServerName.valueOf(Bytes.toString(startKey),0,0));
        map.put(startKey,hrl);
      }
      final List<HRegionLocation> locations=new ArrayList<HRegionLocation>(map.values());
      RegionLocator mockedRegionLocator=Mockito.mock(RegionLocator.class);
      Mockito.when(mockedRegionLocator.getRegionLocation(Mockito.any(byte[].class),Mockito.anyBoolean())).thenAnswer(new Answer<HRegionLocation>(){
        @Override public HRegionLocation answer(        InvocationOnMock invocationOnMock) throws Throwable {
          Object[] args=invocationOnMock.getArguments();
          byte[] key=(byte[])args[0];
          return map.get(key);
        }
      }
);
      Mockito.when(mockedRegionLocator.getAllRegionLocations()).thenReturn(locations);
      Mockito.when(mockedRegionLocator.getStartEndKeys()).thenReturn(new Pair<byte[][],byte[][]>(startKeys,endKeys));
      Mockito.when(mockedRegionLocator.getName()).thenReturn(tableName);
      return mockedRegionLocator;
    }
    @Override public Admin getAdmin() throws IOException {
      Admin admin=Mockito.mock(Admin.class);
      Mockito.when(admin.getConfiguration()).thenReturn(getConfiguration());
      return admin;
    }
    @Override public Table getTable(    TableName tableName) throws IOException {
      Table table=Mockito.mock(Table.class);
      Mockito.when(table.getName()).thenReturn(tableName);
      return table;
    }
    @Override public void close() throws IOException {
    }
    @Override public boolean isClosed(){
      return false;
    }
    @Override public TableBuilder getTableBuilder(    TableName tableName,    ExecutorService pool){
      return Mockito.mock(TableBuilder.class);
    }
  }
}
