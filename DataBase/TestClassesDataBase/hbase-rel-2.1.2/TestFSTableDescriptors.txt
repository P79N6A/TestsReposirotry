/** 
 * Tests for  {@link FSTableDescriptors}.
 */
@Category({MiscTests.class,MediumTests.class}) public class TestFSTableDescriptors {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestFSTableDescriptors.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final Logger LOG=LoggerFactory.getLogger(TestFSTableDescriptors.class);
  @Rule public TestName name=new TestName();
  @Test(expected=IllegalArgumentException.class) public void testRegexAgainstOldStyleTableInfo(){
    Path p=new Path("/tmp",FSTableDescriptors.TABLEINFO_FILE_PREFIX);
    int i=FSTableDescriptors.getTableInfoSequenceId(p);
    assertEquals(0,i);
    p=new Path("/tmp","abc");
    FSTableDescriptors.getTableInfoSequenceId(p);
  }
  @Test public void testCreateAndUpdate() throws IOException {
    Path testdir=UTIL.getDataTestDir(name.getMethodName());
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    FSTableDescriptors fstd=new FSTableDescriptors(UTIL.getConfiguration(),fs,testdir);
    assertTrue(fstd.createTableDescriptor(htd));
    assertFalse(fstd.createTableDescriptor(htd));
    FileStatus[] statuses=fs.listStatus(testdir);
    assertTrue("statuses.length=" + statuses.length,statuses.length == 1);
    for (int i=0; i < 10; i++) {
      fstd.updateTableDescriptor(htd);
    }
    statuses=fs.listStatus(testdir);
    assertTrue(statuses.length == 1);
    Path tmpTableDir=new Path(FSUtils.getTableDir(testdir,htd.getTableName()),".tmp");
    statuses=fs.listStatus(tmpTableDir);
    assertTrue(statuses.length == 0);
  }
  @Test public void testSequenceIdAdvancesOnTableInfo() throws IOException {
    Path testdir=UTIL.getDataTestDir(name.getMethodName());
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    FSTableDescriptors fstd=new FSTableDescriptors(UTIL.getConfiguration(),fs,testdir);
    Path p0=fstd.updateTableDescriptor(htd);
    int i0=FSTableDescriptors.getTableInfoSequenceId(p0);
    Path p1=fstd.updateTableDescriptor(htd);
    assertTrue(!fs.exists(p0));
    int i1=FSTableDescriptors.getTableInfoSequenceId(p1);
    assertTrue(i1 == i0 + 1);
    Path p2=fstd.updateTableDescriptor(htd);
    assertTrue(!fs.exists(p1));
    int i2=FSTableDescriptors.getTableInfoSequenceId(p2);
    assertTrue(i2 == i1 + 1);
    Path p3=fstd.updateTableDescriptor(htd);
    assertTrue(!fs.exists(p2));
    int i3=FSTableDescriptors.getTableInfoSequenceId(p3);
    assertTrue(i3 == i2 + 1);
    TableDescriptor descriptor=fstd.get(htd.getTableName());
    assertEquals(descriptor,htd);
  }
  @Test public void testFormatTableInfoSequenceId(){
    Path p0=assertWriteAndReadSequenceId(0);
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < FSTableDescriptors.WIDTH_OF_SEQUENCE_ID; i++) {
      sb.append("0");
    }
    assertEquals(FSTableDescriptors.TABLEINFO_FILE_PREFIX + "." + sb.toString(),p0.getName());
    Path p2=assertWriteAndReadSequenceId(2);
    Path p10000=assertWriteAndReadSequenceId(10000);
    Path p=new Path(p0.getParent(),FSTableDescriptors.TABLEINFO_FILE_PREFIX);
    FileStatus fs=new FileStatus(0,false,0,0,0,p);
    FileStatus fs0=new FileStatus(0,false,0,0,0,p0);
    FileStatus fs2=new FileStatus(0,false,0,0,0,p2);
    FileStatus fs10000=new FileStatus(0,false,0,0,0,p10000);
    Comparator<FileStatus> comparator=FSTableDescriptors.TABLEINFO_FILESTATUS_COMPARATOR;
    assertTrue(comparator.compare(fs,fs0) > 0);
    assertTrue(comparator.compare(fs0,fs2) > 0);
    assertTrue(comparator.compare(fs2,fs10000) > 0);
  }
  private Path assertWriteAndReadSequenceId(  final int i){
    Path p=new Path("/tmp",FSTableDescriptors.getTableInfoFileName(i));
    int ii=FSTableDescriptors.getTableInfoSequenceId(p);
    assertEquals(i,ii);
    return p;
  }
  @Test public void testRemoves() throws IOException {
    final String name=this.name.getMethodName();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=new Path(UTIL.getDataTestDir(),name);
    TableDescriptors htds=new FSTableDescriptors(UTIL.getConfiguration(),fs,rootdir);
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(name)).build();
    htds.add(htd);
    assertNotNull(htds.remove(htd.getTableName()));
    assertNull(htds.remove(htd.getTableName()));
  }
  @Test public void testReadingHTDFromFS() throws IOException {
    final String name=this.name.getMethodName();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(name)).build();
    Path rootdir=UTIL.getDataTestDir(name);
    FSTableDescriptors fstd=new FSTableDescriptors(UTIL.getConfiguration(),fs,rootdir);
    fstd.createTableDescriptor(htd);
    TableDescriptor td2=FSTableDescriptors.getTableDescriptorFromFs(fs,rootdir,htd.getTableName());
    assertTrue(htd.equals(td2));
  }
  @Test public void testReadingOldHTDFromFS() throws IOException, DeserializationException {
    final String name=this.name.getMethodName();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=UTIL.getDataTestDir(name);
    FSTableDescriptors fstd=new FSTableDescriptors(UTIL.getConfiguration(),fs,rootdir);
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(name)).build();
    Path descriptorFile=fstd.updateTableDescriptor(htd);
    try (FSDataOutputStream out=fs.create(descriptorFile,true)){
      out.write(TableDescriptorBuilder.toByteArray(htd));
    }
     FSTableDescriptors fstd2=new FSTableDescriptors(UTIL.getConfiguration(),fs,rootdir);
    TableDescriptor td2=fstd2.get(htd.getTableName());
    assertEquals(htd,td2);
    FileStatus descriptorFile2=FSTableDescriptors.getTableInfoPath(fs,fstd2.getTableDir(htd.getTableName()));
    byte[] buffer=TableDescriptorBuilder.toByteArray(htd);
    try (FSDataInputStream in=fs.open(descriptorFile2.getPath())){
      in.readFully(buffer);
    }
     TableDescriptor td3=TableDescriptorBuilder.parseFrom(buffer);
    assertEquals(htd,td3);
  }
  @Test public void testTableDescriptors() throws IOException, InterruptedException {
    final String name=this.name.getMethodName();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=new Path(UTIL.getDataTestDir(),name);
    FSTableDescriptors htds=new FSTableDescriptors(UTIL.getConfiguration(),fs,rootdir){
      @Override public TableDescriptor get(      TableName tablename) throws TableExistsException, FileNotFoundException, IOException {
        LOG.info(tablename + ", cachehits=" + this.cachehits);
        return super.get(tablename);
      }
    }
;
    final int count=10;
    for (int i=0; i < count; i++) {
      htds.createTableDescriptor(TableDescriptorBuilder.newBuilder(TableName.valueOf(name + i)).build());
    }
    for (int i=0; i < count; i++) {
      assertTrue(htds.get(TableName.valueOf(name + i)) != null);
    }
    for (int i=0; i < count; i++) {
      assertTrue(htds.get(TableName.valueOf(name + i)) != null);
    }
    for (int i=0; i < count; i++) {
      TableDescriptorBuilder builder=TableDescriptorBuilder.newBuilder(TableName.valueOf(name + i));
      builder.setColumnFamily(ColumnFamilyDescriptorBuilder.of("" + i));
      htds.updateTableDescriptor(builder.build());
    }
    Thread.sleep(100);
    for (int i=0; i < count; i++) {
      assertTrue(htds.get(TableName.valueOf(name + i)) != null);
    }
    for (int i=0; i < count; i++) {
      assertTrue(htds.get(TableName.valueOf(name + i)) != null);
    }
    assertEquals(count * 4,htds.invocations);
    assertTrue("expected=" + (count * 2) + ", actual="+ htds.cachehits,htds.cachehits >= (count * 2));
  }
  @Test public void testTableDescriptorsNoCache() throws IOException, InterruptedException {
    final String name=this.name.getMethodName();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=new Path(UTIL.getDataTestDir(),name);
    FSTableDescriptors htds=new FSTableDescriptorsTest(UTIL.getConfiguration(),fs,rootdir,false,false);
    final int count=10;
    for (int i=0; i < count; i++) {
      htds.createTableDescriptor(TableDescriptorBuilder.newBuilder(TableName.valueOf(name + i)).build());
    }
    for (int i=0; i < 2 * count; i++) {
      assertNotNull("Expected HTD, got null instead",htds.get(TableName.valueOf(name + i % 2)));
    }
    for (int i=0; i < count; i++) {
      TableDescriptorBuilder builder=TableDescriptorBuilder.newBuilder(TableName.valueOf(name + i));
      builder.setColumnFamily(ColumnFamilyDescriptorBuilder.of("" + i));
      htds.updateTableDescriptor(builder.build());
    }
    for (int i=0; i < count; i++) {
      assertNotNull("Expected HTD, got null instead",htds.get(TableName.valueOf(name + i)));
      assertTrue("Column Family " + i + " missing",htds.get(TableName.valueOf(name + i)).hasColumnFamily(Bytes.toBytes("" + i)));
    }
    assertEquals(count * 4,htds.invocations);
    assertEquals("expected=0, actual=" + htds.cachehits,0,htds.cachehits);
  }
  @Test public void testGetAll() throws IOException, InterruptedException {
    final String name="testGetAll";
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=new Path(UTIL.getDataTestDir(),name);
    FSTableDescriptors htds=new FSTableDescriptorsTest(UTIL.getConfiguration(),fs,rootdir);
    final int count=4;
    for (int i=0; i < count; i++) {
      htds.createTableDescriptor(TableDescriptorBuilder.newBuilder(TableName.valueOf(name + i)).build());
    }
    htds.createTableDescriptor(TableDescriptorBuilder.newBuilder(TableName.META_TABLE_NAME).build());
    assertEquals("getAll() didn't return all TableDescriptors, expected: " + (count + 1) + " got: "+ htds.getAll().size(),count + 1,htds.getAll().size());
  }
  @Test public void testCacheConsistency() throws IOException, InterruptedException {
    final String name=this.name.getMethodName();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=new Path(UTIL.getDataTestDir(),name);
    FSTableDescriptors chtds=new FSTableDescriptorsTest(UTIL.getConfiguration(),fs,rootdir);
    FSTableDescriptors nonchtds=new FSTableDescriptorsTest(UTIL.getConfiguration(),fs,rootdir,false,false);
    final int count=10;
    for (int i=0; i < count; i++) {
      nonchtds.createTableDescriptor(TableDescriptorBuilder.newBuilder(TableName.valueOf(name + i)).build());
    }
    for (int i=0; i < count; i++) {
      assertTrue(chtds.get(TableName.valueOf(name + i)) != null);
    }
    assertTrue(nonchtds.getAll().size() == chtds.getAll().size());
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.META_TABLE_NAME).build();
    nonchtds.createTableDescriptor(htd);
    assertTrue(nonchtds.getAll().size() == chtds.getAll().size());
    for (    Map.Entry<String,TableDescriptor> entry : nonchtds.getAll().entrySet()) {
      String t=(String)entry.getKey();
      TableDescriptor nchtd=entry.getValue();
      assertTrue("expected " + htd.toString() + " got: "+ chtds.get(TableName.valueOf(t)).toString(),(nchtd.equals(chtds.get(TableName.valueOf(t)))));
    }
  }
  @Test public void testNoSuchTable() throws IOException {
    final String name="testNoSuchTable";
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=new Path(UTIL.getDataTestDir(),name);
    TableDescriptors htds=new FSTableDescriptors(UTIL.getConfiguration(),fs,rootdir);
    assertNull("There shouldn't be any HTD for this table",htds.get(TableName.valueOf("NoSuchTable")));
  }
  @Test public void testUpdates() throws IOException {
    final String name="testUpdates";
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    Path rootdir=new Path(UTIL.getDataTestDir(),name);
    TableDescriptors htds=new FSTableDescriptors(UTIL.getConfiguration(),fs,rootdir);
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(name)).build();
    htds.add(htd);
    htds.add(htd);
    htds.add(htd);
  }
  @Test public void testTableInfoFileStatusComparator(){
    FileStatus bare=new FileStatus(0,false,0,0,-1,new Path("/tmp",FSTableDescriptors.TABLEINFO_FILE_PREFIX));
    FileStatus future=new FileStatus(0,false,0,0,-1,new Path("/tmp/tablinfo." + System.currentTimeMillis()));
    FileStatus farFuture=new FileStatus(0,false,0,0,-1,new Path("/tmp/tablinfo." + System.currentTimeMillis() + 1000));
    FileStatus[] alist={bare,future,farFuture};
    FileStatus[] blist={bare,farFuture,future};
    FileStatus[] clist={farFuture,bare,future};
    Comparator<FileStatus> c=FSTableDescriptors.TABLEINFO_FILESTATUS_COMPARATOR;
    Arrays.sort(alist,c);
    Arrays.sort(blist,c);
    Arrays.sort(clist,c);
    for (int i=0; i < alist.length; i++) {
      assertTrue(alist[i].equals(blist[i]));
      assertTrue(blist[i].equals(clist[i]));
      assertTrue(clist[i].equals(i == 0 ? farFuture : i == 1 ? future : bare));
    }
  }
  @Test public void testReadingInvalidDirectoryFromFS() throws IOException {
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    try {
      new FSTableDescriptors(UTIL.getConfiguration(),fs,FSUtils.getRootDir(UTIL.getConfiguration())).get(TableName.valueOf(HConstants.HBASE_TEMP_DIRECTORY));
      fail("Shouldn't be able to read a table descriptor for the archive directory.");
    }
 catch (    Exception e) {
      LOG.debug("Correctly got error when reading a table descriptor from the archive directory: " + e.getMessage());
    }
  }
  @Test public void testCreateTableDescriptorUpdatesIfExistsAlready() throws IOException {
    Path testdir=UTIL.getDataTestDir(name.getMethodName());
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    FileSystem fs=FileSystem.get(UTIL.getConfiguration());
    FSTableDescriptors fstd=new FSTableDescriptors(UTIL.getConfiguration(),fs,testdir);
    assertTrue(fstd.createTableDescriptor(htd));
    assertFalse(fstd.createTableDescriptor(htd));
    htd=TableDescriptorBuilder.newBuilder(htd).setValue(Bytes.toBytes("mykey"),Bytes.toBytes("myValue")).build();
    assertTrue(fstd.createTableDescriptor(htd));
    Path tableDir=fstd.getTableDir(htd.getTableName());
    Path tmpTableDir=new Path(tableDir,FSTableDescriptors.TMP_DIR);
    FileStatus[] statuses=fs.listStatus(tmpTableDir);
    assertTrue(statuses.length == 0);
    assertEquals(htd,FSTableDescriptors.getTableDescriptorFromFs(fs,tableDir));
  }
private static class FSTableDescriptorsTest extends FSTableDescriptors {
    public FSTableDescriptorsTest(    Configuration conf,    FileSystem fs,    Path rootdir) throws IOException {
      this(conf,fs,rootdir,false,true);
    }
    public FSTableDescriptorsTest(    Configuration conf,    FileSystem fs,    Path rootdir,    boolean fsreadonly,    boolean usecache) throws IOException {
      super(conf,fs,rootdir,fsreadonly,usecache);
    }
    @Override public TableDescriptor get(    TableName tablename) throws TableExistsException, FileNotFoundException, IOException {
      LOG.info((super.isUsecache() ? "Cached" : "Non-Cached") + " TableDescriptor.get() on " + tablename+ ", cachehits="+ this.cachehits);
      return super.get(tablename);
    }
  }
}
