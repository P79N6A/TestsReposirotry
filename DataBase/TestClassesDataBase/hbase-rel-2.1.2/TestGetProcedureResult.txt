/** 
 * Testcase for HBASE-19608.
 */
@Category({MasterTests.class,MediumTests.class}) public class TestGetProcedureResult {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestGetProcedureResult.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
public static final class DummyProcedure extends Procedure<MasterProcedureEnv> implements TableProcedureInterface {
    private final CountDownLatch failureSet=new CountDownLatch(1);
    private final CountDownLatch canRollback=new CountDownLatch(1);
    @Override public TableName getTableName(){
      return TableName.valueOf("dummy");
    }
    @Override public TableOperationType getTableOperationType(){
      return TableOperationType.READ;
    }
    @Override protected Procedure<MasterProcedureEnv>[] execute(    MasterProcedureEnv env) throws ProcedureYieldException, ProcedureSuspendedException, InterruptedException {
      setFailure("dummy",new IOException("inject error"));
      failureSet.countDown();
      return null;
    }
    @Override protected void rollback(    MasterProcedureEnv env) throws IOException, InterruptedException {
      canRollback.await();
    }
    @Override protected boolean abort(    MasterProcedureEnv env){
      return false;
    }
    @Override protected void serializeStateData(    ProcedureStateSerializer serializer) throws IOException {
    }
    @Override protected void deserializeStateData(    ProcedureStateSerializer serializer) throws IOException {
    }
  }
  @BeforeClass public static void setUp() throws Exception {
    UTIL.startMiniCluster(1);
  }
  @AfterClass public static void tearDown() throws Exception {
    UTIL.shutdownMiniCluster();
  }
  private GetProcedureResultResponse.State getState(  long procId) throws MasterNotRunningException, IOException, ServiceException {
    MasterProtos.MasterService.BlockingInterface master=((ConnectionImplementation)UTIL.getConnection()).getMaster();
    GetProcedureResultResponse resp=master.getProcedureResult(null,GetProcedureResultRequest.newBuilder().setProcId(procId).build());
    return resp.getState();
  }
  @Test public void testRace() throws Exception {
    ProcedureExecutor<MasterProcedureEnv> executor=UTIL.getMiniHBaseCluster().getMaster().getMasterProcedureExecutor();
    DummyProcedure p=new DummyProcedure();
    long procId=executor.submitProcedure(p);
    p.failureSet.await();
    assertEquals(GetProcedureResultResponse.State.RUNNING,getState(procId));
    p.canRollback.countDown();
    UTIL.waitFor(30000,new Waiter.ExplainingPredicate<Exception>(){
      @Override public boolean evaluate() throws Exception {
        return getState(procId) == GetProcedureResultResponse.State.FINISHED;
      }
      @Override public String explainFailure() throws Exception {
        return "Procedure pid=" + procId + " is still in "+ getState(procId)+ " state, expected "+ GetProcedureResultResponse.State.FINISHED;
      }
    }
);
  }
}
