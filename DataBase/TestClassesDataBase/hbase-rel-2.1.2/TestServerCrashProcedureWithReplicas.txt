@Category({MasterTests.class,LargeTests.class}) public class TestServerCrashProcedureWithReplicas extends TestServerCrashProcedure {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestServerCrashProcedureWithReplicas.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestServerCrashProcedureWithReplicas.class);
  @Override protected void startMiniCluster() throws Exception {
    this.util.startMiniCluster(4);
  }
  @Override protected Table createTable(  final TableName tableName) throws IOException {
    final Table t=this.util.createTable(tableName,HBaseTestingUtility.COLUMNS,HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE,3);
    return t;
  }
  protected void assertReplicaDistributed(  final Table t){
    List<RegionInfo> regionInfos=new ArrayList<>();
    for (    RegionServerThread rs : this.util.getMiniHBaseCluster().getRegionServerThreads()) {
      regionInfos.clear();
      for (      Region r : rs.getRegionServer().getRegions(t.getName())) {
        LOG.info("The region is " + r.getRegionInfo() + " the location is "+ rs.getRegionServer().getServerName());
        if (contains(regionInfos,r.getRegionInfo())) {
          LOG.error("Am exiting");
          fail("Crashed replica regions should not be assigned to same region server");
        }
 else {
          regionInfos.add(r.getRegionInfo());
        }
      }
    }
  }
  private boolean contains(  List<RegionInfo> regionInfos,  RegionInfo regionInfo){
    for (    RegionInfo info : regionInfos) {
      if (RegionReplicaUtil.isReplicasForSameRegion(info,regionInfo)) {
        return true;
      }
    }
    return false;
  }
}
