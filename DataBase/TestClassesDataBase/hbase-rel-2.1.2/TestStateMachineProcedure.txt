public static class TestStateMachineProcedure extends StateMachineProcedure<TestProcEnv,TestStateMachineProcedure.State> {
  enum State {  STATE_1,   STATE_2,   STATE_3}
public static class ExecutionInfo {
    private final boolean rollback;
    private final long timestamp;
    private final State step;
    public ExecutionInfo(    long timestamp,    State step,    boolean isRollback){
      this.timestamp=timestamp;
      this.step=step;
      this.rollback=isRollback;
    }
    public State getStep(){
      return step;
    }
    public long getTimestamp(){
      return timestamp;
    }
    public boolean isRollback(){
      return rollback;
    }
  }
  private final ArrayList<ExecutionInfo> executionInfo=new ArrayList<>();
  private final AtomicBoolean aborted=new AtomicBoolean(false);
  private final boolean throwInterruptOnceOnEachStep;
  private final boolean abortOnFinalStep;
  public TestStateMachineProcedure(){
    this(false,false);
  }
  public TestStateMachineProcedure(  boolean abortOnFinalStep,  boolean throwInterruptOnceOnEachStep){
    this.abortOnFinalStep=abortOnFinalStep;
    this.throwInterruptOnceOnEachStep=throwInterruptOnceOnEachStep;
  }
  public ArrayList<ExecutionInfo> getExecutionInfo(){
    return executionInfo;
  }
  @Override protected StateMachineProcedure.Flow executeFromState(  TestProcEnv env,  State state) throws InterruptedException {
    final long ts=env.nextTimestamp();
    LOG.info(getProcId() + " execute step " + state+ " ts="+ ts);
    executionInfo.add(new ExecutionInfo(ts,state,false));
    Thread.sleep(150);
    if (throwInterruptOnceOnEachStep && ((executionInfo.size() - 1) % 2) == 0) {
      LOG.debug("THROW INTERRUPT");
      throw new InterruptedException("test interrupt");
    }
switch (state) {
case STATE_1:
      setNextState(State.STATE_2);
    break;
case STATE_2:
  setNextState(State.STATE_3);
break;
case STATE_3:
if (abortOnFinalStep) {
setFailure("test",new IOException("Requested abort on final step"));
}
return Flow.NO_MORE_STATE;
default :
throw new UnsupportedOperationException();
}
return Flow.HAS_MORE_STATE;
}
@Override protected void rollbackState(TestProcEnv env,final State state) throws InterruptedException {
final long ts=env.nextTimestamp();
LOG.debug(getProcId() + " rollback state " + state+ " ts="+ ts);
executionInfo.add(new ExecutionInfo(ts,state,true));
Thread.sleep(150);
if (throwInterruptOnceOnEachStep && ((executionInfo.size() - 1) % 2) == 0) {
LOG.debug("THROW INTERRUPT");
throw new InterruptedException("test interrupt");
}
switch (state) {
case STATE_1:
break;
case STATE_2:
break;
case STATE_3:
break;
default :
throw new UnsupportedOperationException();
}
}
@Override protected State getState(final int stateId){
return State.values()[stateId];
}
@Override protected int getStateId(final State state){
return state.ordinal();
}
@Override protected State getInitialState(){
return State.STATE_1;
}
@Override protected boolean isYieldBeforeExecuteFromState(TestProcEnv env,State state){
return true;
}
@Override protected boolean abort(TestProcEnv env){
aborted.set(true);
return true;
}
}
