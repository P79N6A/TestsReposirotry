/** 
 * Check if CompletedProcedureCleaner cleans up failed nonce procedures.
 */
@Category(MediumTests.class) public class TestFailedProcCleanup {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestFailedProcCleanup.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestFailedProcCleanup.class);
  protected static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static Configuration conf;
  private static final TableName TABLE=TableName.valueOf("test");
  private static final byte[] FAMILY=Bytes.toBytesBinary("f");
  private static final int evictionDelay=10 * 1000;
  @BeforeClass public static void setUpBeforeClass(){
    conf=TEST_UTIL.getConfiguration();
    conf.setInt("hbase.procedure.cleaner.evict.ttl",evictionDelay);
    conf.setInt("hbase.procedure.cleaner.evict.batch.size",1);
  }
  @After public void tearDown() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testFailCreateTable() throws Exception {
    conf.set(MASTER_COPROCESSOR_CONF_KEY,CreateFailObserver.class.getName());
    TEST_UTIL.startMiniCluster(3);
    try {
      TEST_UTIL.createTable(TABLE,FAMILY);
    }
 catch (    AccessDeniedException e) {
      LOG.debug("Ignoring exception: ",e);
      Thread.sleep(evictionDelay * 3);
    }
    List<Procedure<MasterProcedureEnv>> procedureInfos=TEST_UTIL.getMiniHBaseCluster().getMaster().getMasterProcedureExecutor().getProcedures();
    for (    Procedure procedureInfo : procedureInfos) {
      if (procedureInfo.getProcName().equals("CreateTableProcedure") && procedureInfo.getState() == ProcedureProtos.ProcedureState.ROLLEDBACK) {
        fail("Found procedure " + procedureInfo + " that hasn't been cleaned up");
      }
    }
  }
  @Test public void testFailCreateTableAction() throws Exception {
    conf.set(MASTER_COPROCESSOR_CONF_KEY,CreateFailObserverHandler.class.getName());
    TEST_UTIL.startMiniCluster(3);
    try {
      TEST_UTIL.createTable(TABLE,FAMILY);
      fail("Table shouldn't be created");
    }
 catch (    AccessDeniedException e) {
      LOG.debug("Ignoring exception: ",e);
      Thread.sleep(evictionDelay * 3);
    }
    List<Procedure<MasterProcedureEnv>> procedureInfos=TEST_UTIL.getMiniHBaseCluster().getMaster().getMasterProcedureExecutor().getProcedures();
    for (    Procedure procedureInfo : procedureInfos) {
      if (procedureInfo.getProcName().equals("CreateTableProcedure") && procedureInfo.getState() == ProcedureProtos.ProcedureState.ROLLEDBACK) {
        fail("Found procedure " + procedureInfo + " that hasn't been cleaned up");
      }
    }
  }
public static class CreateFailObserver implements MasterCoprocessor, MasterObserver {
    @Override public void preCreateTable(    ObserverContext<MasterCoprocessorEnvironment> env,    TableDescriptor desc,    RegionInfo[] regions) throws IOException {
      if (desc.getTableName().equals(TABLE)) {
        throw new AccessDeniedException("Don't allow creation of table");
      }
    }
    @Override public Optional<MasterObserver> getMasterObserver(){
      return Optional.of(this);
    }
  }
public static class CreateFailObserverHandler implements MasterCoprocessor, MasterObserver {
    @Override public void preCreateTableAction(    final ObserverContext<MasterCoprocessorEnvironment> ctx,    final TableDescriptor desc,    final RegionInfo[] regions) throws IOException {
      if (desc.getTableName().equals(TABLE)) {
        throw new AccessDeniedException("Don't allow creation of table");
      }
    }
    @Override public Optional<MasterObserver> getMasterObserver(){
      return Optional.of(this);
    }
  }
}
