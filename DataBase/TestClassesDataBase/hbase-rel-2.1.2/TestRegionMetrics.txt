@Category({MiscTests.class,MediumTests.class}) public class TestRegionMetrics {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRegionMetrics.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRegionMetrics.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static Admin admin;
  private static final TableName TABLE_1=TableName.valueOf("table_1");
  private static final TableName TABLE_2=TableName.valueOf("table_2");
  private static final TableName TABLE_3=TableName.valueOf("table_3");
  private static final TableName[] tables=new TableName[]{TABLE_1,TABLE_2,TABLE_3};
  private static final int MSG_INTERVAL=500;
  @BeforeClass public static void beforeClass() throws Exception {
    UTIL.getConfiguration().setInt("hbase.regionserver.msginterval",MSG_INTERVAL);
    UTIL.startMiniCluster(4);
    admin=UTIL.getAdmin();
    admin.balancerSwitch(false,true);
    byte[] FAMILY=Bytes.toBytes("f");
    for (    TableName tableName : tables) {
      Table table=UTIL.createMultiRegionTable(tableName,FAMILY,16);
      UTIL.waitTableAvailable(tableName);
      UTIL.loadTable(table,FAMILY);
    }
  }
  @AfterClass public static void afterClass() throws Exception {
    for (    TableName table : tables) {
      UTIL.deleteTableIfAny(table);
    }
    UTIL.shutdownMiniCluster();
  }
  @Test public void testRegionMetrics() throws Exception {
    for (    ServerName serverName : admin.getClusterMetrics(EnumSet.of(Option.LIVE_SERVERS)).getLiveServerMetrics().keySet()) {
      List<RegionInfo> regions=admin.getRegions(serverName);
      Collection<RegionMetrics> regionMetricsList=admin.getRegionMetrics(serverName);
      checkRegionsAndRegionMetrics(regions,regionMetricsList);
    }
    for (    TableName table : new TableName[]{TABLE_1,TABLE_2,TABLE_3}) {
      List<RegionInfo> tableRegions=admin.getRegions(table);
      List<RegionMetrics> regionMetrics=new ArrayList<>();
      for (      ServerName serverName : admin.getClusterMetrics(EnumSet.of(Option.LIVE_SERVERS)).getLiveServerMetrics().keySet()) {
        regionMetrics.addAll(admin.getRegionMetrics(serverName,table));
      }
      checkRegionsAndRegionMetrics(tableRegions,regionMetrics);
    }
    TimeUnit.MILLISECONDS.sleep(3 * MSG_INTERVAL);
    for (    Map.Entry<ServerName,ServerMetrics> entry : admin.getClusterMetrics(EnumSet.of(Option.LIVE_SERVERS)).getLiveServerMetrics().entrySet()) {
      ServerName serverName=entry.getKey();
      ServerMetrics serverMetrics=entry.getValue();
      List<RegionMetrics> regionMetrics=admin.getRegionMetrics(serverName);
      LOG.debug("serverName=" + serverName + ", getRegionLoads="+ serverMetrics.getRegionMetrics().keySet().stream().map(r -> Bytes.toString(r)).collect(Collectors.toList()));
      LOG.debug("serverName=" + serverName + ", regionLoads="+ regionMetrics.stream().map(r -> Bytes.toString(r.getRegionName())).collect(Collectors.toList()));
      assertEquals(serverMetrics.getRegionMetrics().size(),regionMetrics.size());
    }
  }
  private void checkRegionsAndRegionMetrics(  Collection<RegionInfo> regions,  Collection<RegionMetrics> regionMetrics){
    assertEquals("No of regions and regionMetrics doesn't match",regions.size(),regionMetrics.size());
    Map<byte[],RegionMetrics> regionMetricsMap=Maps.newTreeMap(Bytes.BYTES_COMPARATOR);
    for (    RegionMetrics r : regionMetrics) {
      regionMetricsMap.put(r.getRegionName(),r);
    }
    for (    RegionInfo info : regions) {
      assertTrue("Region not in RegionMetricsMap region:" + info.getRegionNameAsString() + " regionMap: "+ regionMetricsMap,regionMetricsMap.containsKey(info.getRegionName()));
    }
  }
}
