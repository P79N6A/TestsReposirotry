@Category({ClientTests.class,SmallTests.class}) public class TestInterfaceAlign {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestInterfaceAlign.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestInterfaceAlign.class);
  /** 
 * Test methods name match up
 */
  @Test public void testAdminWithAsyncAdmin(){
    List<String> adminMethodNames=getMethodNames(Admin.class);
    List<String> asyncAdminMethodNames=getMethodNames(AsyncAdmin.class);
    adminMethodNames.remove("getOperationTimeout");
    adminMethodNames.remove("getConnection");
    adminMethodNames.remove("getConfiguration");
    adminMethodNames.removeAll(getMethodNames(Abortable.class));
    adminMethodNames.removeAll(getMethodNames(Closeable.class));
    adminMethodNames.forEach(method -> {
      boolean contains=asyncAdminMethodNames.contains(method);
      if (method.endsWith("Async")) {
        contains=asyncAdminMethodNames.contains(method.replace("Async",""));
      }
      assertTrue("Admin method " + method + " should in AsyncAdmin too",contains);
    }
);
    asyncAdminMethodNames.forEach(method -> {
      boolean contains=adminMethodNames.contains(method);
      if (!contains) {
        contains=adminMethodNames.contains(method + "Async");
      }
      assertTrue("AsyncAdmin method " + method + " should in Admin too",contains);
    }
);
  }
  private <T>List<String> getMethodNames(  Class<T> c){
    return Arrays.asList(c.getMethods()).stream().filter(m -> !isDeprecated(m)).map(Method::getName).distinct().collect(Collectors.toList());
  }
  private boolean isDeprecated(  Method method){
    Annotation[] annotations=method.getDeclaredAnnotations();
    for (    Annotation annotation : annotations) {
      if (annotation instanceof Deprecated) {
        return true;
      }
    }
    return false;
  }
}
