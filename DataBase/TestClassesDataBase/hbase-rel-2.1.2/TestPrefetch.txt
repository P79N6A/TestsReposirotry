@Category({IOTests.class,SmallTests.class}) public class TestPrefetch {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestPrefetch.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final int NUM_VALID_KEY_TYPES=KeyValue.Type.values().length - 2;
  private static final int DATA_BLOCK_SIZE=2048;
  private static final int NUM_KV=1000;
  private static final Random RNG=new Random();
  private Configuration conf;
  private CacheConfig cacheConf;
  private FileSystem fs;
  @Before public void setUp() throws IOException {
    conf=TEST_UTIL.getConfiguration();
    conf.setBoolean(CacheConfig.PREFETCH_BLOCKS_ON_OPEN_KEY,true);
    fs=HFileSystem.get(conf);
    CacheConfig.blockCacheDisabled=false;
    CacheConfig.instantiateBlockCache(conf);
    cacheConf=new CacheConfig(conf);
  }
  @Test public void testPrefetchSetInHCDWorks(){
    HColumnDescriptor hcd=new HColumnDescriptor(Bytes.toBytes("f"));
    hcd.setPrefetchBlocksOnOpen(true);
    Configuration c=HBaseConfiguration.create();
    assertFalse(c.getBoolean(CacheConfig.PREFETCH_BLOCKS_ON_OPEN_KEY,false));
    CacheConfig cc=new CacheConfig(c,hcd);
    assertTrue(cc.shouldPrefetchOnOpen());
  }
  @Test public void testPrefetch() throws Exception {
    Path storeFile=writeStoreFile("TestPrefetch");
    readStoreFile(storeFile);
  }
  @Test public void testPrefetchRace() throws Exception {
    for (int i=0; i < 10; i++) {
      Path storeFile=writeStoreFile("TestPrefetchRace-" + i);
      readStoreFileLikeScanner(storeFile);
    }
  }
  /** 
 * Read a storefile in the same manner as a scanner -- using non-positional reads and without waiting for prefetch to complete.
 */
  private void readStoreFileLikeScanner(  Path storeFilePath) throws Exception {
    HFile.Reader reader=HFile.createReader(fs,storeFilePath,cacheConf,true,conf);
    do {
      long offset=0;
      while (offset < reader.getTrailer().getLoadOnOpenDataOffset()) {
        HFileBlock block=reader.readBlock(offset,-1,false,false,false,true,null,null);
        offset+=block.getOnDiskSizeWithHeader();
      }
    }
 while (!reader.prefetchComplete());
  }
  private void readStoreFile(  Path storeFilePath) throws Exception {
    HFile.Reader reader=HFile.createReader(fs,storeFilePath,cacheConf,true,conf);
    while (!reader.prefetchComplete()) {
      Thread.sleep(1000);
    }
    BlockCache blockCache=cacheConf.getBlockCache();
    long offset=0;
    while (offset < reader.getTrailer().getLoadOnOpenDataOffset()) {
      HFileBlock block=reader.readBlock(offset,-1,false,true,false,true,null,null);
      BlockCacheKey blockCacheKey=new BlockCacheKey(reader.getName(),offset);
      boolean isCached=blockCache.getBlock(blockCacheKey,true,false,true) != null;
      if (block.getBlockType() == BlockType.DATA || block.getBlockType() == BlockType.ROOT_INDEX || block.getBlockType() == BlockType.INTERMEDIATE_INDEX) {
        assertTrue(isCached);
      }
      offset+=block.getOnDiskSizeWithHeader();
    }
  }
  private Path writeStoreFile(  String fname) throws IOException {
    Path storeFileParentDir=new Path(TEST_UTIL.getDataTestDir(),fname);
    HFileContext meta=new HFileContextBuilder().withBlockSize(DATA_BLOCK_SIZE).build();
    StoreFileWriter sfw=new StoreFileWriter.Builder(conf,cacheConf,fs).withOutputDir(storeFileParentDir).withComparator(CellComparatorImpl.COMPARATOR).withFileContext(meta).build();
    final int rowLen=32;
    for (int i=0; i < NUM_KV; ++i) {
      byte[] k=RandomKeyValueUtil.randomOrderedKey(RNG,i);
      byte[] v=RandomKeyValueUtil.randomValue(RNG);
      int cfLen=RNG.nextInt(k.length - rowLen + 1);
      KeyValue kv=new KeyValue(k,0,rowLen,k,rowLen,cfLen,k,rowLen + cfLen,k.length - rowLen - cfLen,RNG.nextLong(),generateKeyType(RNG),v,0,v.length);
      sfw.append(kv);
    }
    sfw.close();
    return sfw.getPath();
  }
  public static KeyValue.Type generateKeyType(  Random rand){
    if (rand.nextBoolean()) {
      return KeyValue.Type.Put;
    }
 else {
      KeyValue.Type keyType=KeyValue.Type.values()[1 + rand.nextInt(NUM_VALID_KEY_TYPES)];
      if (keyType == KeyValue.Type.Minimum || keyType == KeyValue.Type.Maximum) {
        throw new RuntimeException("Generated an invalid key type: " + keyType + ". "+ "Probably the layout of KeyValue.Type has changed.");
      }
      return keyType;
    }
  }
}
