/** 
 * This class is to test checksum behavior when data is corrupted. It mimics the following behavior: - When fs checksum is disabled, hbase may get corrupted data from hdfs. If verifyChecksum is true, it means hbase checksum is on and fs checksum is off, so we corrupt the data. - When fs checksum is enabled, hdfs will get a different copy from another node, and will always return correct data. So we don't corrupt the data when verifyChecksum for hbase is off.
 */
static private class CorruptedFSReaderImpl extends HFileBlock.FSReaderImpl {
  /** 
 * If set to true, corrupt reads using readAtOffset(...).
 */
  boolean corruptDataStream=false;
  public CorruptedFSReaderImpl(  FSDataInputStreamWrapper istream,  long fileSize,  FileSystem fs,  Path path,  HFileContext meta) throws IOException {
    super(istream,fileSize,(HFileSystem)fs,path,meta);
  }
  @Override protected HFileBlock readBlockDataInternal(  FSDataInputStream is,  long offset,  long onDiskSizeWithHeaderL,  boolean pread,  boolean verifyChecksum,  boolean updateMetrics) throws IOException {
    if (verifyChecksum) {
      corruptDataStream=true;
    }
    HFileBlock b=super.readBlockDataInternal(is,offset,onDiskSizeWithHeaderL,pread,verifyChecksum,updateMetrics);
    corruptDataStream=false;
    return b;
  }
  @Override protected int readAtOffset(  FSDataInputStream istream,  byte[] dest,  int destOffset,  int size,  boolean peekIntoNextBlock,  long fileOffset,  boolean pread) throws IOException {
    int returnValue=super.readAtOffset(istream,dest,destOffset,size,peekIntoNextBlock,fileOffset,pread);
    if (!corruptDataStream) {
      return returnValue;
    }
    if (peekIntoNextBlock) {
      dest[destOffset + size + 3]=0b00000000;
    }
    dest[destOffset + 1]=0b00000000;
    if (size > hdrSize) {
      dest[destOffset + hdrSize + 1]=0b00000000;
    }
    return returnValue;
  }
}
