@Category({MasterTests.class,LargeTests.class}) public class TestRegionReplicaSplit {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRegionReplicaSplit.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRegionReplicaSplit.class);
  private static final int NB_SERVERS=4;
  private static Table table;
  private static final HBaseTestingUtility HTU=new HBaseTestingUtility();
  private static final byte[] f=HConstants.CATALOG_FAMILY;
  @BeforeClass public static void beforeClass() throws Exception {
    HTU.getConfiguration().setInt("hbase.master.wait.on.regionservers.mintostart",3);
    HTU.startMiniCluster(NB_SERVERS);
    final TableName tableName=TableName.valueOf(TestRegionReplicaSplit.class.getSimpleName());
    createTable(tableName);
  }
  @Rule public TestName name=new TestName();
  private static void createTable(  final TableName tableName) throws IOException {
    TableDescriptorBuilder builder=TableDescriptorBuilder.newBuilder(tableName);
    builder.setRegionReplication(3);
    table=HTU.createTable(builder.build(),new byte[][]{f},getSplits(2),new Configuration(HTU.getConfiguration()));
  }
  private static byte[][] getSplits(  int numRegions){
    RegionSplitter.UniformSplit split=new RegionSplitter.UniformSplit();
    split.setFirstRow(Bytes.toBytes(0L));
    split.setLastRow(Bytes.toBytes(Long.MAX_VALUE));
    return split.split(numRegions);
  }
  @AfterClass public static void afterClass() throws Exception {
    HRegionServer.TEST_SKIP_REPORTING_TRANSITION=false;
    table.close();
    HTU.shutdownMiniCluster();
  }
  @Test public void testRegionReplicaSplitRegionAssignment() throws Exception {
    HTU.loadNumericRows(table,f,0,3);
    List<RegionInfo> regions=new ArrayList<RegionInfo>();
    for (    RegionServerThread rs : HTU.getMiniHBaseCluster().getRegionServerThreads()) {
      for (      Region r : rs.getRegionServer().getRegions(table.getName())) {
        System.out.println("the region before split is is " + r.getRegionInfo() + rs.getRegionServer().getServerName());
        regions.add(r.getRegionInfo());
      }
    }
    HTU.getAdmin().split(table.getName(),Bytes.toBytes(1));
    int count=0;
    while (true) {
      for (      RegionServerThread rs : HTU.getMiniHBaseCluster().getRegionServerThreads()) {
        for (        Region r : rs.getRegionServer().getRegions(table.getName())) {
          count++;
        }
      }
      if (count >= 9) {
        break;
      }
      count=0;
    }
    List<ServerName> newRegionLocations=new ArrayList<ServerName>();
    for (    RegionServerThread rs : HTU.getMiniHBaseCluster().getRegionServerThreads()) {
      RegionInfo prevInfo=null;
      for (      Region r : rs.getRegionServer().getRegions(table.getName())) {
        if (!regions.contains(r.getRegionInfo()) && !RegionReplicaUtil.isDefaultReplica(r.getRegionInfo())) {
          LOG.info("The region is " + r.getRegionInfo() + " the location is "+ rs.getRegionServer().getServerName());
          if (!RegionReplicaUtil.isDefaultReplica(r.getRegionInfo()) && newRegionLocations.contains(rs.getRegionServer().getServerName()) && prevInfo != null && Bytes.equals(prevInfo.getStartKey(),r.getRegionInfo().getStartKey()) && Bytes.equals(prevInfo.getEndKey(),r.getRegionInfo().getEndKey())) {
            fail("Splitted regions should not be assigned to same region server");
          }
 else {
            prevInfo=r.getRegionInfo();
            if (!RegionReplicaUtil.isDefaultReplica(r.getRegionInfo()) && !newRegionLocations.contains(rs.getRegionServer().getServerName())) {
              newRegionLocations.add(rs.getRegionServer().getServerName());
            }
          }
        }
      }
    }
    assertEquals("The new regions should be assigned to 3 unique servers ",3,newRegionLocations.size());
  }
}
