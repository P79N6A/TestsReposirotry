@Category({MediumTests.class,ClientTests.class}) public class TestRawAsyncScanCursor extends AbstractTestScanCursor {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRawAsyncScanCursor.class);
  private static AsyncConnection CONN;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    AbstractTestScanCursor.setUpBeforeClass();
    CONN=ConnectionFactory.createAsyncConnection(TEST_UTIL.getConfiguration()).get();
  }
  public static void tearDownAfterClass() throws Exception {
    if (CONN != null) {
      CONN.close();
    }
    AbstractTestScanCursor.tearDownAfterClass();
  }
  private void doTest(  boolean reversed) throws InterruptedException, ExecutionException, IOException {
    CompletableFuture<Void> future=new CompletableFuture<>();
    AsyncTable<AdvancedScanResultConsumer> table=CONN.getTable(TABLE_NAME);
    table.scan(reversed ? createReversedScanWithSparseFilter() : createScanWithSparseFilter(),new AdvancedScanResultConsumer(){
      private int count;
      @Override public void onHeartbeat(      ScanController controller){
        int row=count / NUM_FAMILIES / NUM_QUALIFIERS;
        if (reversed) {
          row=NUM_ROWS - 1 - row;
        }
        try {
          assertArrayEquals(ROWS[row],controller.cursor().get().getRow());
          count++;
        }
 catch (        Throwable e) {
          future.completeExceptionally(e);
          throw e;
        }
      }
      @Override public void onNext(      Result[] results,      ScanController controller){
        try {
          assertEquals(1,results.length);
          assertEquals(NUM_ROWS - 1,count / NUM_FAMILIES / NUM_QUALIFIERS);
          assertTrue(controller.cursor().isPresent());
          assertArrayEquals(ROWS[reversed ? 0 : NUM_ROWS - 1],controller.cursor().get().getRow());
          assertArrayEquals(ROWS[reversed ? 0 : NUM_ROWS - 1],results[0].getRow());
          count++;
        }
 catch (        Throwable e) {
          future.completeExceptionally(e);
          throw e;
        }
      }
      @Override public void onError(      Throwable error){
        future.completeExceptionally(error);
      }
      @Override public void onComplete(){
        future.complete(null);
      }
    }
);
    future.get();
  }
  @Test public void testHeartbeatWithSparseFilter() throws IOException, InterruptedException, ExecutionException {
    doTest(false);
  }
  @Test public void testHeartbeatWithSparseFilterReversed() throws IOException, InterruptedException, ExecutionException {
    doTest(true);
  }
  @Test public void testSizeLimit() throws InterruptedException, ExecutionException {
    CompletableFuture<Void> future=new CompletableFuture<>();
    AsyncTable<AdvancedScanResultConsumer> table=CONN.getTable(TABLE_NAME);
    table.scan(createScanWithSizeLimit(),new AdvancedScanResultConsumer(){
      private int count;
      @Override public void onHeartbeat(      ScanController controller){
        try {
          assertArrayEquals(ROWS[count / NUM_FAMILIES / NUM_QUALIFIERS],controller.cursor().get().getRow());
          count++;
        }
 catch (        Throwable e) {
          future.completeExceptionally(e);
          throw e;
        }
      }
      @Override public void onNext(      Result[] results,      ScanController controller){
        try {
          assertFalse(controller.cursor().isPresent());
          assertEquals(1,results.length);
          assertArrayEquals(ROWS[count / NUM_FAMILIES / NUM_QUALIFIERS],results[0].getRow());
          count++;
        }
 catch (        Throwable e) {
          future.completeExceptionally(e);
          throw e;
        }
      }
      @Override public void onError(      Throwable error){
        future.completeExceptionally(error);
      }
      @Override public void onComplete(){
        future.complete(null);
      }
    }
);
    future.get();
  }
}
