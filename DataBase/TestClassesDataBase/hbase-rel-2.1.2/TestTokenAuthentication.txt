/** 
 * Tests for authentication token creation and usage
 */
@RunWith(Parameterized.class) @Category({SecurityTests.class,MediumTests.class}) public class TestTokenAuthentication {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestTokenAuthentication.class);
static {
    System.setProperty("java.security.krb5.realm","hbase");
    System.setProperty("java.security.krb5.kdc","blah");
  }
  /** 
 * Basic server process for RPC authentication testing
 */
private static class TokenServer extends TokenProvider implements AuthenticationProtos.AuthenticationService.BlockingInterface, Runnable, Server {
    private static final Logger LOG=LoggerFactory.getLogger(TokenServer.class);
    private Configuration conf;
    private HBaseTestingUtility TEST_UTIL;
    private RpcServerInterface rpcServer;
    private InetSocketAddress isa;
    private ZKWatcher zookeeper;
    private Sleeper sleeper;
    private boolean started=false;
    private boolean aborted=false;
    private boolean stopped=false;
    private long startcode;
    public TokenServer(    Configuration conf,    HBaseTestingUtility TEST_UTIL) throws IOException {
      this.conf=conf;
      this.TEST_UTIL=TEST_UTIL;
      this.startcode=EnvironmentEdgeManager.currentTime();
      String hostname=Strings.domainNamePointerToHostName(DNS.getDefaultHost("default","default"));
      int port=0;
      InetSocketAddress initialIsa=new InetSocketAddress(hostname,port);
      if (initialIsa.getAddress() == null) {
        throw new IllegalArgumentException("Failed resolve of " + initialIsa);
      }
      final List<BlockingServiceAndInterface> sai=new ArrayList<>(1);
      final BlockingService service=AuthenticationProtos.AuthenticationService.newReflectiveBlockingService(this);
      final org.apache.hbase.thirdparty.com.google.protobuf.BlockingService proxy=new org.apache.hbase.thirdparty.com.google.protobuf.BlockingService(){
        @Override public Message callBlockingMethod(        MethodDescriptor md,        org.apache.hbase.thirdparty.com.google.protobuf.RpcController controller,        Message param) throws org.apache.hbase.thirdparty.com.google.protobuf.ServiceException {
          com.google.protobuf.Descriptors.MethodDescriptor methodDescriptor=service.getDescriptorForType().findMethodByName(md.getName());
          com.google.protobuf.Message request=service.getRequestPrototype(methodDescriptor);
          com.google.protobuf.Message response=null;
          try {
            response=service.callBlockingMethod(methodDescriptor,null,request);
          }
 catch (          ServiceException e) {
            throw new org.apache.hbase.thirdparty.com.google.protobuf.ServiceException(e);
          }
          return null;
        }
        @Override public ServiceDescriptor getDescriptorForType(){
          return null;
        }
        @Override public Message getRequestPrototype(        MethodDescriptor arg0){
          return null;
        }
        @Override public Message getResponsePrototype(        MethodDescriptor arg0){
          return null;
        }
      }
;
      sai.add(new BlockingServiceAndInterface(proxy,AuthenticationProtos.AuthenticationService.BlockingInterface.class));
      this.rpcServer=RpcServerFactory.createRpcServer(this,"tokenServer",sai,initialIsa,conf,new FifoRpcScheduler(conf,1));
      InetSocketAddress address=rpcServer.getListenerAddress();
      if (address == null) {
        throw new IOException("Listener channel is closed");
      }
      this.isa=address;
      this.sleeper=new Sleeper(1000,this);
    }
    @Override public Configuration getConfiguration(){
      return conf;
    }
    @Override public ClusterConnection getConnection(){
      return null;
    }
    @Override public MetaTableLocator getMetaTableLocator(){
      return null;
    }
    @Override public ZKWatcher getZooKeeper(){
      return zookeeper;
    }
    @Override public CoordinatedStateManager getCoordinatedStateManager(){
      return null;
    }
    @Override public boolean isAborted(){
      return aborted;
    }
    @Override public ServerName getServerName(){
      return ServerName.valueOf(isa.getHostName(),isa.getPort(),startcode);
    }
    @Override public FileSystem getFileSystem(){
      return null;
    }
    @Override public boolean isStopping(){
      return this.stopped;
    }
    @Override public void abort(    String reason,    Throwable error){
      LOG.error(HBaseMarkers.FATAL,"Aborting on: " + reason,error);
      this.aborted=true;
      this.stopped=true;
      sleeper.skipSleepCycle();
    }
    private void initialize() throws IOException {
      Configuration zkConf=new Configuration(conf);
      zkConf.set(User.HBASE_SECURITY_CONF_KEY,"simple");
      this.zookeeper=new ZKWatcher(zkConf,TokenServer.class.getSimpleName(),this,true);
      this.rpcServer.start();
      RegionCoprocessorEnvironment mockRegionCpEnv=mock(RegionCoprocessorEnvironment.class,Mockito.withSettings().extraInterfaces(HasRegionServerServices.class));
      when(mockRegionCpEnv.getConfiguration()).thenReturn(conf);
      when(mockRegionCpEnv.getClassLoader()).then((var1) -> Thread.currentThread().getContextClassLoader());
      RegionServerServices mockRss=mock(RegionServerServices.class);
      when(mockRss.getRpcServer()).thenReturn(rpcServer);
      when(((HasRegionServerServices)mockRegionCpEnv).getRegionServerServices()).thenReturn(mockRss);
      super.start(mockRegionCpEnv);
      started=true;
    }
    @Override public void run(){
      try {
        initialize();
        while (!stopped) {
          this.sleeper.sleep();
        }
      }
 catch (      Exception e) {
        abort(e.getMessage(),e);
      }
      this.rpcServer.stop();
    }
    public boolean isStarted(){
      return started;
    }
    @Override public void stop(    String reason){
      LOG.info("Stopping due to: " + reason);
      this.stopped=true;
      sleeper.skipSleepCycle();
    }
    @Override public boolean isStopped(){
      return stopped;
    }
    public InetSocketAddress getAddress(){
      return isa;
    }
    public SecretManager<? extends TokenIdentifier> getSecretManager(){
      return ((RpcServer)rpcServer).getSecretManager();
    }
    @Override public AuthenticationProtos.GetAuthenticationTokenResponse getAuthenticationToken(    RpcController controller,    AuthenticationProtos.GetAuthenticationTokenRequest request) throws ServiceException {
      LOG.debug("Authentication token request from " + RpcServer.getRequestUserName().orElse(null));
      ServerRpcController serverController=new ServerRpcController();
      final NonShadedBlockingRpcCallback<AuthenticationProtos.GetAuthenticationTokenResponse> callback=new NonShadedBlockingRpcCallback<>();
      getAuthenticationToken(null,request,callback);
      try {
        serverController.checkFailed();
        return callback.get();
      }
 catch (      IOException ioe) {
        throw new ServiceException(ioe);
      }
    }
    @Override public AuthenticationProtos.WhoAmIResponse whoAmI(    RpcController controller,    AuthenticationProtos.WhoAmIRequest request) throws ServiceException {
      LOG.debug("whoAmI() request from " + RpcServer.getRequestUserName().orElse(null));
      ServerRpcController serverController=new ServerRpcController();
      NonShadedBlockingRpcCallback<AuthenticationProtos.WhoAmIResponse> callback=new NonShadedBlockingRpcCallback<>();
      whoAmI(null,request,callback);
      try {
        serverController.checkFailed();
        return callback.get();
      }
 catch (      IOException ioe) {
        throw new ServiceException(ioe);
      }
    }
    @Override public ChoreService getChoreService(){
      return null;
    }
    @Override public ClusterConnection getClusterConnection(){
      return null;
    }
    @Override public Connection createConnection(    Configuration conf) throws IOException {
      return null;
    }
  }
  @Parameters(name="{index}: rpcServerImpl={0}") public static Collection<Object[]> parameters(){
    return Arrays.asList(new Object[]{SimpleRpcServer.class.getName()},new Object[]{NettyRpcServer.class.getName()});
  }
  @Parameter(0) public String rpcServerImpl;
  private HBaseTestingUtility TEST_UTIL;
  private TokenServer server;
  private Thread serverThread;
  private AuthenticationTokenSecretManager secretManager;
  private ClusterId clusterId=new ClusterId();
  @Before public void setUp() throws Exception {
    TEST_UTIL=new HBaseTestingUtility();
    TEST_UTIL.startMiniZKCluster();
    SecurityInfo.addInfo(AuthenticationProtos.AuthenticationService.getDescriptor().getName(),new SecurityInfo("hbase.test.kerberos.principal",AuthenticationProtos.TokenIdentifier.Kind.HBASE_AUTH_TOKEN));
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.set("hadoop.security.authentication","kerberos");
    conf.set("hbase.security.authentication","kerberos");
    conf.setBoolean(HADOOP_SECURITY_AUTHORIZATION,true);
    conf.set(RpcServerFactory.CUSTOM_RPC_SERVER_IMPL_CONF_KEY,rpcServerImpl);
    server=new TokenServer(conf,TEST_UTIL);
    serverThread=new Thread(server);
    Threads.setDaemonThreadRunning(serverThread,"TokenServer:" + server.getServerName().toString());
    while (!server.isStarted() && !server.isStopped()) {
      Thread.sleep(10);
    }
    server.rpcServer.refreshAuthManager(new PolicyProvider(){
      @Override public Service[] getServices(){
        return new Service[]{new Service("security.client.protocol.acl",AuthenticationProtos.AuthenticationService.BlockingInterface.class)};
      }
    }
);
    ZKClusterId.setClusterId(server.getZooKeeper(),clusterId);
    secretManager=(AuthenticationTokenSecretManager)server.getSecretManager();
    while (secretManager.getCurrentKey() == null) {
      Thread.sleep(1);
    }
  }
  @After public void tearDown() throws Exception {
    server.stop("Test complete");
    Threads.shutdown(serverThread);
    TEST_UTIL.shutdownMiniZKCluster();
  }
  @Test public void testTokenCreation() throws Exception {
    Token<AuthenticationTokenIdentifier> token=secretManager.generateToken("testuser");
    AuthenticationTokenIdentifier ident=new AuthenticationTokenIdentifier();
    Writables.getWritable(token.getIdentifier(),ident);
    assertEquals("Token username should match","testuser",ident.getUsername());
    byte[] passwd=secretManager.retrievePassword(ident);
    assertTrue("Token password and password from secret manager should match",Bytes.equals(token.getPassword(),passwd));
  }
  @Test public void testUseExistingToken() throws Exception {
    User user=User.createUserForTesting(TEST_UTIL.getConfiguration(),"testuser2",new String[]{"testgroup"});
    Token<AuthenticationTokenIdentifier> token=secretManager.generateToken(user.getName());
    assertNotNull(token);
    user.addToken(token);
    Token<AuthenticationTokenIdentifier> firstToken=new AuthenticationTokenSelector().selectToken(token.getService(),user.getTokens());
    assertNotNull(firstToken);
    assertEquals(token,firstToken);
    Connection conn=ConnectionFactory.createConnection(TEST_UTIL.getConfiguration());
    try {
      assertFalse(TokenUtil.addTokenIfMissing(conn,user));
      Token<AuthenticationTokenIdentifier> secondToken=new AuthenticationTokenSelector().selectToken(token.getService(),user.getTokens());
      assertEquals(firstToken,secondToken);
    }
  finally {
      conn.close();
    }
  }
  /** 
 * A copy of the BlockingRpcCallback class for use locally. Only difference is that it makes use of non-shaded protobufs; i.e. refers to com.google.protobuf.* rather than to org.apache.hbase.thirdparty.com.google.protobuf.
 */
private static class NonShadedBlockingRpcCallback<R> implements com.google.protobuf.RpcCallback<R> {
    private R result;
    private boolean resultSet=false;
    /** 
 * Called on completion of the RPC call with the response object, or  {@code null} in the case ofan error.
 * @param parameter the response object or {@code null} if an error occurred
 */
    @Override public void run(    R parameter){
synchronized (this) {
        result=parameter;
        resultSet=true;
        this.notifyAll();
      }
    }
    /** 
 * Returns the parameter passed to  {@link #run(Object)} or {@code null} if a null value waspassed.  When used asynchronously, this method will block until the  {@link #run(Object)}method has been called.
 * @return the response object or {@code null} if no response was passed
 */
    public synchronized R get() throws IOException {
      while (!resultSet) {
        try {
          this.wait();
        }
 catch (        InterruptedException ie) {
          InterruptedIOException exception=new InterruptedIOException(ie.getMessage());
          exception.initCause(ie);
          throw exception;
        }
      }
      return result;
    }
  }
}
