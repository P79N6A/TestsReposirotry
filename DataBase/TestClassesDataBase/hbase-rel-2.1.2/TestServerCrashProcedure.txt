@Category({MasterTests.class,LargeTests.class}) public class TestServerCrashProcedure {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestServerCrashProcedure.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestServerCrashProcedure.class);
  protected HBaseTestingUtility util;
  private ProcedureMetrics serverCrashProcMetrics;
  private long serverCrashSubmittedCount=0;
  private long serverCrashFailedCount=0;
  private void setupConf(  Configuration conf){
    conf.setInt(MasterProcedureConstants.MASTER_PROCEDURE_THREADS,1);
    conf.setInt(MasterProcedureConstants.MASTER_URGENT_PROCEDURE_THREADS,0);
    conf.set("hbase.balancer.tablesOnMaster","none");
    conf.setInt("hbase.client.retries.number",3);
  }
  @Before public void setup() throws Exception {
    this.util=new HBaseTestingUtility();
    setupConf(this.util.getConfiguration());
    startMiniCluster();
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(this.util.getHBaseCluster().getMaster().getMasterProcedureExecutor(),false);
    serverCrashProcMetrics=this.util.getHBaseCluster().getMaster().getMasterMetrics().getServerCrashProcMetrics();
  }
  protected void startMiniCluster() throws Exception {
    this.util.startMiniCluster(3);
  }
  @After public void tearDown() throws Exception {
    MiniHBaseCluster cluster=this.util.getHBaseCluster();
    HMaster master=cluster == null ? null : cluster.getMaster();
    if (master != null && master.getMasterProcedureExecutor() != null) {
      ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(master.getMasterProcedureExecutor(),false);
    }
    this.util.shutdownMiniCluster();
  }
  @Test public void testCrashTargetRs() throws Exception {
    testRecoveryAndDoubleExecution(false,false);
  }
  @Test public void testRecoveryAndDoubleExecutionOnRsWithMeta() throws Exception {
    testRecoveryAndDoubleExecution(true,true);
  }
  @Test public void testRecoveryAndDoubleExecutionOnRsWithoutMeta() throws Exception {
    testRecoveryAndDoubleExecution(false,true);
  }
  private long getSCPProcId(  ProcedureExecutor<?> procExec){
    util.waitFor(30000,() -> !procExec.getProcedures().isEmpty());
    return procExec.getActiveProcIds().stream().mapToLong(Long::longValue).min().getAsLong();
  }
  /** 
 * Run server crash procedure steps twice to test idempotency and that we are persisting all needed state.
 */
  private void testRecoveryAndDoubleExecution(  boolean carryingMeta,  boolean doubleExecution) throws Exception {
    final TableName tableName=TableName.valueOf("testRecoveryAndDoubleExecution-carryingMeta-" + carryingMeta + "-doubleExecution-"+ doubleExecution);
    try (Table t=createTable(tableName)){
      this.util.loadTable(t,HBaseTestingUtility.COLUMNS[0]);
      final int count=util.countRows(t);
      assertTrue("expected some rows",count > 0);
      final String checksum=util.checksumRows(t);
      final HMaster master=this.util.getHBaseCluster().getMaster();
      final ProcedureExecutor<MasterProcedureEnv> procExec=master.getMasterProcedureExecutor();
      ServerName rsToKill=null;
      for (      RegionInfo hri : util.getAdmin().getRegions(tableName)) {
        final ServerName serverName=AssignmentTestingUtil.getServerHoldingRegion(util,hri);
        if (AssignmentTestingUtil.isServerHoldingMeta(util,serverName) == carryingMeta) {
          rsToKill=serverName;
          break;
        }
      }
      ProcedureTestingUtility.waitNoProcedureRunning(procExec);
      if (doubleExecution) {
        ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
        AssignmentTestingUtil.killRs(util,rsToKill);
        long procId=getSCPProcId(procExec);
        MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec,procId);
      }
 else {
        AssignmentTestingUtil.killRs(util,rsToKill);
        long procId=getSCPProcId(procExec);
        ProcedureTestingUtility.waitProcedure(procExec,procId);
      }
      assertReplicaDistributed(t);
      assertEquals(count,util.countRows(t));
      assertEquals(checksum,util.checksumRows(t));
    }
 catch (    Throwable throwable) {
      LOG.error("Test failed!",throwable);
      throw throwable;
    }
  }
  protected void assertReplicaDistributed(  final Table t){
    return;
  }
  protected Table createTable(  final TableName tableName) throws IOException {
    final Table t=this.util.createTable(tableName,HBaseTestingUtility.COLUMNS,HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);
    return t;
  }
  private void collectMasterMetrics(){
    serverCrashSubmittedCount=serverCrashProcMetrics.getSubmittedCounter().getCount();
    serverCrashFailedCount=serverCrashProcMetrics.getFailedCounter().getCount();
  }
}
