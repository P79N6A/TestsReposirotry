public class BlockingStoreMockMaker extends StatefulStoreMockMaker {
  BlockingCompactionContext blocked=null;
public class BlockingCompactionContext extends CompactionContext {
    public volatile boolean isInCompact=false;
    public void unblock(){
synchronized (this) {
        this.notifyAll();
      }
    }
    @Override public List<Path> compact(    ThroughputController throughputController,    User user) throws IOException {
      try {
        isInCompact=true;
synchronized (this) {
          this.wait();
        }
      }
 catch (      InterruptedException e) {
        Assume.assumeNoException(e);
      }
      return new ArrayList<>();
    }
    @Override public List<HStoreFile> preSelect(    List<HStoreFile> filesCompacting){
      return new ArrayList<>();
    }
    @Override public boolean select(    List<HStoreFile> f,    boolean i,    boolean m,    boolean e) throws IOException {
      this.request=new CompactionRequestImpl(new ArrayList<>());
      return true;
    }
  }
  @Override public Optional<CompactionContext> selectCompaction(){
    this.blocked=new BlockingCompactionContext();
    try {
      this.blocked.select(null,false,false,false);
    }
 catch (    IOException ex) {
      fail("Shouldn't happen");
    }
    return Optional.of(blocked);
  }
  @Override public void cancelCompaction(  Object object){
  }
  @Override public int getPriority(){
    return Integer.MIN_VALUE;
  }
  public BlockingCompactionContext waitForBlocking(){
    while (this.blocked == null || !this.blocked.isInCompact) {
      Threads.sleepWithoutInterrupt(50);
    }
    BlockingCompactionContext ctx=this.blocked;
    this.blocked=null;
    return ctx;
  }
  @Override public HStore createStoreMock(  String name) throws Exception {
    return createStoreMock(Integer.MIN_VALUE,name);
  }
  public HStore createStoreMock(  int priority,  String name) throws Exception {
    HStore s=super.createStoreMock(name);
    when(s.getCompactPriority()).thenReturn(priority);
    return s;
  }
}
