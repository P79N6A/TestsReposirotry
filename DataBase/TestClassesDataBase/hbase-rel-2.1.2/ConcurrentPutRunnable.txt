/** 
 * The in-memory-flusher thread performs the flush asynchronously. There is at most one thread per memstore instance. It takes the updatesLock exclusively, pushes active into the pipeline, releases updatesLock and compacts the pipeline.
 */
private class ConcurrentPutRunnable implements Runnable {
  private final HRegion stressedRegion;
  private final int startNumber;
  ConcurrentPutRunnable(  HRegion r,  int i){
    this.stressedRegion=r;
    this.startNumber=i;
  }
  @Override public void run(){
    try {
      int dummy=startNumber / 10000;
      System.out.print("Thread " + dummy + " with start number "+ startNumber+ " starts\n");
      for (int i=startNumber; i <= startNumber + 3000; i++) {
        stressedRegion.put(createPut(1,i));
        if (i <= startNumber + 2000) {
          stressedRegion.put(createPut(2,i));
          if (i <= startNumber + 1000) {
            stressedRegion.put(createPut(3,i));
          }
        }
      }
      System.out.print("Thread with start number " + startNumber + " continues to more puts\n");
      for (int i=startNumber + 3000; i < startNumber + 5000; i++) {
        stressedRegion.put(createPut(2,i));
      }
      for (int i=startNumber + 5000; i < startNumber + 7000; i++) {
        stressedRegion.put(createPut(1,i));
      }
      System.out.print("Thread with start number " + startNumber + " flushes\n");
      if (startNumber == 0) {
        ((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY1)).memstore).flushInMemory();
        while (((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY1)).memstore).isMemStoreFlushingInMemory()) {
          Threads.sleep(10);
        }
      }
      if (startNumber == 10000) {
        ((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY2)).memstore).flushInMemory();
        while (((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY2)).memstore).isMemStoreFlushingInMemory()) {
          Threads.sleep(10);
        }
      }
      if (startNumber == 20000) {
        ((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY3)).memstore).flushInMemory();
        while (((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY3)).memstore).isMemStoreFlushingInMemory()) {
          Threads.sleep(10);
        }
      }
      System.out.print("Thread with start number " + startNumber + " finishes\n");
    }
 catch (    IOException e) {
      assert false;
    }
  }
}
