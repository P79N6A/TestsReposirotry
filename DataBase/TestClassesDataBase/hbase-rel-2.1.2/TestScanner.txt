/** 
 * Test of a long-lived scanner validating as we go.
 */
@Category({RegionServerTests.class,SmallTests.class}) public class TestScanner {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestScanner.class);
  @Rule public TestName name=new TestName();
  private static final Logger LOG=LoggerFactory.getLogger(TestScanner.class);
  private final static HBaseTestingUtility TEST_UTIL=HBaseTestingUtility.createLocalHTU();
  private static final byte[] FIRST_ROW=HConstants.EMPTY_START_ROW;
  private static final byte[][] COLS={HConstants.CATALOG_FAMILY};
  private static final byte[][] EXPLICIT_COLS={HConstants.REGIONINFO_QUALIFIER,HConstants.SERVER_QUALIFIER};
  static final HTableDescriptor TESTTABLEDESC=new HTableDescriptor(TableName.valueOf("testscanner"));
static {
    TESTTABLEDESC.addFamily(new HColumnDescriptor(HConstants.CATALOG_FAMILY).setMaxVersions(10).setBlockCacheEnabled(false).setBlocksize(8 * 1024));
  }
  /** 
 * HRegionInfo for root region 
 */
  public static final HRegionInfo REGION_INFO=new HRegionInfo(TESTTABLEDESC.getTableName(),HConstants.EMPTY_BYTE_ARRAY,HConstants.EMPTY_BYTE_ARRAY);
  private static final byte[] ROW_KEY=REGION_INFO.getRegionName();
  private static final long START_CODE=Long.MAX_VALUE;
  private HRegion region;
  private byte[] firstRowBytes, secondRowBytes, thirdRowBytes;
  final private byte[] col1;
  public TestScanner(){
    super();
    firstRowBytes=START_KEY_BYTES;
    secondRowBytes=START_KEY_BYTES.clone();
    secondRowBytes[START_KEY_BYTES.length - 1]++;
    thirdRowBytes=START_KEY_BYTES.clone();
    thirdRowBytes[START_KEY_BYTES.length - 1]=(byte)(thirdRowBytes[START_KEY_BYTES.length - 1] + 2);
    col1=Bytes.toBytes("column1");
  }
  /** 
 * Test basic stop row filter works.
 * @throws Exception
 */
  @Test public void testStopRow() throws Exception {
    byte[] startrow=Bytes.toBytes("bbb");
    byte[] stoprow=Bytes.toBytes("ccc");
    try {
      this.region=TEST_UTIL.createLocalHRegion(TESTTABLEDESC,null,null);
      HBaseTestCase.addContent(this.region,HConstants.CATALOG_FAMILY);
      List<Cell> results=new ArrayList<>();
      Scan scan=new Scan(Bytes.toBytes("abc"),Bytes.toBytes("abd"));
      scan.addFamily(HConstants.CATALOG_FAMILY);
      InternalScanner s=region.getScanner(scan);
      int count=0;
      while (s.next(results)) {
        count++;
      }
      s.close();
      assertEquals(0,count);
      scan=new Scan(startrow,stoprow);
      scan.addFamily(HConstants.CATALOG_FAMILY);
      s=region.getScanner(scan);
      count=0;
      Cell kv=null;
      results=new ArrayList<>();
      for (boolean first=true; s.next(results); ) {
        kv=results.get(0);
        if (first) {
          assertTrue(CellUtil.matchingRows(kv,startrow));
          first=false;
        }
        count++;
      }
      assertTrue(Bytes.BYTES_COMPARATOR.compare(stoprow,CellUtil.cloneRow(kv)) > 0);
      assertTrue(count > 10);
      s.close();
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
    }
  }
  void rowPrefixFilter(  Scan scan) throws IOException {
    List<Cell> results=new ArrayList<>();
    scan.addFamily(HConstants.CATALOG_FAMILY);
    InternalScanner s=region.getScanner(scan);
    boolean hasMore=true;
    while (hasMore) {
      hasMore=s.next(results);
      for (      Cell kv : results) {
        assertEquals((byte)'a',CellUtil.cloneRow(kv)[0]);
        assertEquals((byte)'b',CellUtil.cloneRow(kv)[1]);
      }
      results.clear();
    }
    s.close();
  }
  void rowInclusiveStopFilter(  Scan scan,  byte[] stopRow) throws IOException {
    List<Cell> results=new ArrayList<>();
    scan.addFamily(HConstants.CATALOG_FAMILY);
    InternalScanner s=region.getScanner(scan);
    boolean hasMore=true;
    while (hasMore) {
      hasMore=s.next(results);
      for (      Cell kv : results) {
        assertTrue(Bytes.compareTo(CellUtil.cloneRow(kv),stopRow) <= 0);
      }
      results.clear();
    }
    s.close();
  }
  @Test public void testFilters() throws IOException {
    try {
      this.region=TEST_UTIL.createLocalHRegion(TESTTABLEDESC,null,null);
      HBaseTestCase.addContent(this.region,HConstants.CATALOG_FAMILY);
      byte[] prefix=Bytes.toBytes("ab");
      Filter newFilter=new PrefixFilter(prefix);
      Scan scan=new Scan();
      scan.setFilter(newFilter);
      rowPrefixFilter(scan);
      byte[] stopRow=Bytes.toBytes("bbc");
      newFilter=new WhileMatchFilter(new InclusiveStopFilter(stopRow));
      scan=new Scan();
      scan.setFilter(newFilter);
      rowInclusiveStopFilter(scan,stopRow);
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
    }
  }
  /** 
 * Test that closing a scanner while a client is using it doesn't throw NPEs but instead a UnknownScannerException. HBASE-2503
 * @throws Exception
 */
  @Test public void testRaceBetweenClientAndTimeout() throws Exception {
    try {
      this.region=TEST_UTIL.createLocalHRegion(TESTTABLEDESC,null,null);
      HBaseTestCase.addContent(this.region,HConstants.CATALOG_FAMILY);
      Scan scan=new Scan();
      InternalScanner s=region.getScanner(scan);
      List<Cell> results=new ArrayList<>();
      try {
        s.next(results);
        s.close();
        s.next(results);
        fail("We don't want anything more, we should be failing");
      }
 catch (      UnknownScannerException ex) {
        return;
      }
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
    }
  }
  /** 
 * The test!
 * @throws IOException
 */
  @Test public void testScanner() throws IOException {
    try {
      region=TEST_UTIL.createLocalHRegion(TESTTABLEDESC,null,null);
      Table table=new RegionAsTable(region);
      Put put=new Put(ROW_KEY,System.currentTimeMillis());
      put.addColumn(HConstants.CATALOG_FAMILY,HConstants.REGIONINFO_QUALIFIER,REGION_INFO.toByteArray());
      table.put(put);
      scan(false,null);
      getRegionInfo(table);
      ((HRegion)region).close();
      region=HRegion.openHRegion(region,null);
      table=new RegionAsTable(region);
      scan(false,null);
      getRegionInfo(table);
      String address=HConstants.LOCALHOST_IP + ":" + HBaseTestingUtility.randomFreePort();
      put=new Put(ROW_KEY,System.currentTimeMillis());
      put.addColumn(HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER,Bytes.toBytes(address));
      table.put(put);
      scan(true,address.toString());
      getRegionInfo(table);
      this.region.flush(true);
      scan(true,address.toString());
      getRegionInfo(table);
      ((HRegion)region).close();
      region=HRegion.openHRegion(region,null);
      table=new RegionAsTable(region);
      scan(true,address.toString());
      getRegionInfo(table);
      address="bar.foo.com:4321";
      put=new Put(ROW_KEY,System.currentTimeMillis());
      put.addColumn(HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER,Bytes.toBytes(address));
      table.put(put);
      scan(true,address.toString());
      getRegionInfo(table);
      region.flush(true);
      scan(true,address.toString());
      getRegionInfo(table);
      ((HRegion)this.region).close();
      this.region=HRegion.openHRegion(region,null);
      table=new RegionAsTable(this.region);
      scan(true,address.toString());
      getRegionInfo(table);
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
    }
  }
  /** 
 * Compare the HRegionInfo we read from HBase to what we stored 
 */
  private void validateRegionInfo(  byte[] regionBytes) throws IOException {
    HRegionInfo info=HRegionInfo.parseFromOrNull(regionBytes);
    assertEquals(REGION_INFO.getRegionId(),info.getRegionId());
    assertEquals(0,info.getStartKey().length);
    assertEquals(0,info.getEndKey().length);
    assertEquals(0,Bytes.compareTo(info.getRegionName(),REGION_INFO.getRegionName()));
  }
  /** 
 * Use a scanner to get the region info and then validate the results 
 */
  private void scan(  boolean validateStartcode,  String serverName) throws IOException {
    InternalScanner scanner=null;
    Scan scan=null;
    List<Cell> results=new ArrayList<>();
    byte[][][] scanColumns={COLS,EXPLICIT_COLS};
    for (int i=0; i < scanColumns.length; i++) {
      try {
        scan=new Scan(FIRST_ROW);
        for (int ii=0; ii < EXPLICIT_COLS.length; ii++) {
          scan.addColumn(COLS[0],EXPLICIT_COLS[ii]);
        }
        scanner=region.getScanner(scan);
        while (scanner.next(results)) {
          assertTrue(hasColumn(results,HConstants.CATALOG_FAMILY,HConstants.REGIONINFO_QUALIFIER));
          byte[] val=CellUtil.cloneValue(getColumn(results,HConstants.CATALOG_FAMILY,HConstants.REGIONINFO_QUALIFIER));
          validateRegionInfo(val);
          if (validateStartcode) {
            assertNotNull(val);
            assertFalse(val.length == 0);
            long startCode=Bytes.toLong(val);
            assertEquals(START_CODE,startCode);
          }
          if (serverName != null) {
            assertTrue(hasColumn(results,HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER));
            val=CellUtil.cloneValue(getColumn(results,HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER));
            assertNotNull(val);
            assertFalse(val.length == 0);
            String server=Bytes.toString(val);
            assertEquals(0,server.compareTo(serverName));
          }
        }
      }
  finally {
        InternalScanner s=scanner;
        scanner=null;
        if (s != null) {
          s.close();
        }
      }
    }
  }
  private boolean hasColumn(  final List<Cell> kvs,  final byte[] family,  final byte[] qualifier){
    for (    Cell kv : kvs) {
      if (CellUtil.matchingFamily(kv,family) && CellUtil.matchingQualifier(kv,qualifier)) {
        return true;
      }
    }
    return false;
  }
  private Cell getColumn(  final List<Cell> kvs,  final byte[] family,  final byte[] qualifier){
    for (    Cell kv : kvs) {
      if (CellUtil.matchingFamily(kv,family) && CellUtil.matchingQualifier(kv,qualifier)) {
        return kv;
      }
    }
    return null;
  }
  /** 
 * Use get to retrieve the HRegionInfo and validate it 
 */
  private void getRegionInfo(  Table table) throws IOException {
    Get get=new Get(ROW_KEY);
    get.addColumn(HConstants.CATALOG_FAMILY,HConstants.REGIONINFO_QUALIFIER);
    Result result=table.get(get);
    byte[] bytes=result.value();
    validateRegionInfo(bytes);
  }
  /** 
 * Tests to do a sync flush during the middle of a scan. This is testing the StoreScanner update readers code essentially.  This is not highly concurrent, since its all 1 thread. HBase-910.
 * @throws Exception
 */
  @Test public void testScanAndSyncFlush() throws Exception {
    this.region=TEST_UTIL.createLocalHRegion(TESTTABLEDESC,null,null);
    Table hri=new RegionAsTable(region);
    try {
      LOG.info("Added: " + HBaseTestCase.addContent(hri,Bytes.toString(HConstants.CATALOG_FAMILY),Bytes.toString(HConstants.REGIONINFO_QUALIFIER)));
      int count=count(hri,-1,false);
      assertEquals(count,count(hri,100,false));
    }
 catch (    Exception e) {
      LOG.error("Failed",e);
      throw e;
    }
 finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
    }
  }
  /** 
 * Tests to do a concurrent flush (using a 2nd thread) while scanning.  This tests both the StoreScanner update readers and the transition from memstore -> snapshot -> store file.
 * @throws Exception
 */
  @Test public void testScanAndRealConcurrentFlush() throws Exception {
    this.region=TEST_UTIL.createLocalHRegion(TESTTABLEDESC,null,null);
    Table hri=new RegionAsTable(region);
    try {
      LOG.info("Added: " + HBaseTestCase.addContent(hri,Bytes.toString(HConstants.CATALOG_FAMILY),Bytes.toString(HConstants.REGIONINFO_QUALIFIER)));
      int count=count(hri,-1,false);
      assertEquals(count,count(hri,100,true));
    }
 catch (    Exception e) {
      LOG.error("Failed",e);
      throw e;
    }
 finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
    }
  }
  /** 
 * Make sure scanner returns correct result when we run a major compaction with deletes.
 * @throws Exception
 */
  @Test @SuppressWarnings("deprecation") public void testScanAndConcurrentMajorCompact() throws Exception {
    HTableDescriptor htd=TEST_UTIL.createTableDescriptor(name.getMethodName());
    this.region=TEST_UTIL.createLocalHRegion(htd,null,null);
    Table hri=new RegionAsTable(region);
    try {
      HBaseTestCase.addContent(hri,Bytes.toString(fam1),Bytes.toString(col1),firstRowBytes,secondRowBytes);
      HBaseTestCase.addContent(hri,Bytes.toString(fam2),Bytes.toString(col1),firstRowBytes,secondRowBytes);
      Delete dc=new Delete(firstRowBytes);
      dc.addColumns(fam1,col1);
      region.delete(dc);
      region.flush(true);
      HBaseTestCase.addContent(hri,Bytes.toString(fam1),Bytes.toString(col1),secondRowBytes,thirdRowBytes);
      HBaseTestCase.addContent(hri,Bytes.toString(fam2),Bytes.toString(col1),secondRowBytes,thirdRowBytes);
      region.flush(true);
      InternalScanner s=region.getScanner(new Scan());
      region.compact(true);
      List<Cell> results=new ArrayList<>();
      s.next(results);
      assertTrue("result is not correct, keyValues : " + results,results.size() == 1);
      assertTrue(CellUtil.matchingRows(results.get(0),firstRowBytes));
      assertTrue(CellUtil.matchingFamily(results.get(0),fam2));
      results=new ArrayList<>();
      s.next(results);
      assertTrue(results.size() == 2);
      assertTrue(CellUtil.matchingRows(results.get(0),secondRowBytes));
      assertTrue(CellUtil.matchingFamily(results.get(0),fam1));
      assertTrue(CellUtil.matchingFamily(results.get(1),fam2));
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
    }
  }
  private int count(  final Table countTable,  final int flushIndex,  boolean concurrent) throws IOException {
    LOG.info("Taking out counting scan");
    Scan scan=new Scan();
    for (    byte[] qualifier : EXPLICIT_COLS) {
      scan.addColumn(HConstants.CATALOG_FAMILY,qualifier);
    }
    ResultScanner s=countTable.getScanner(scan);
    int count=0;
    boolean justFlushed=false;
    while (s.next() != null) {
      if (justFlushed) {
        LOG.info("after next() just after next flush");
        justFlushed=false;
      }
      count++;
      if (flushIndex == count) {
        LOG.info("Starting flush at flush index " + flushIndex);
        Thread t=new Thread(){
          @Override public void run(){
            try {
              region.flush(true);
              LOG.info("Finishing flush");
            }
 catch (            IOException e) {
              LOG.info("Failed flush cache");
            }
          }
        }
;
        if (concurrent) {
          t.start();
        }
 else {
          t.run();
        }
        LOG.info("Continuing on after kicking off background flush");
        justFlushed=true;
      }
    }
    s.close();
    LOG.info("Found " + count + " items");
    return count;
  }
}
