@Category({FilterTests.class,SmallTests.class}) public class TestDependentColumnFilter {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestDependentColumnFilter.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestDependentColumnFilter.class);
  private static final byte[][] ROWS={Bytes.toBytes("test1"),Bytes.toBytes("test2")};
  private static final byte[][] FAMILIES={Bytes.toBytes("familyOne"),Bytes.toBytes("familyTwo")};
  private static final long STAMP_BASE=System.currentTimeMillis();
  private static final long[] STAMPS={STAMP_BASE - 100,STAMP_BASE - 200,STAMP_BASE - 300};
  private static final byte[] QUALIFIER=Bytes.toBytes("qualifier");
  private static final byte[][] BAD_VALS={Bytes.toBytes("bad1"),Bytes.toBytes("bad2"),Bytes.toBytes("bad3")};
  private static final byte[] MATCH_VAL=Bytes.toBytes("match");
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  List<KeyValue> testVals;
  private HRegion region;
  @Before public void setUp() throws Exception {
    testVals=makeTestVals();
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(this.getClass().getSimpleName()));
    HColumnDescriptor hcd0=new HColumnDescriptor(FAMILIES[0]);
    hcd0.setMaxVersions(3);
    htd.addFamily(hcd0);
    HColumnDescriptor hcd1=new HColumnDescriptor(FAMILIES[1]);
    hcd1.setMaxVersions(3);
    htd.addFamily(hcd1);
    HRegionInfo info=new HRegionInfo(htd.getTableName(),null,null,false);
    this.region=HBaseTestingUtility.createRegionAndWAL(info,TEST_UTIL.getDataTestDir(),TEST_UTIL.getConfiguration(),htd);
    addData();
  }
  @After public void tearDown() throws Exception {
    HBaseTestingUtility.closeRegionAndWAL(this.region);
  }
  private void addData() throws IOException {
    Put put=new Put(ROWS[0]);
    put.addColumn(FAMILIES[0],QUALIFIER,STAMPS[0],BAD_VALS[0]);
    put.addColumn(FAMILIES[0],QUALIFIER,STAMPS[1],BAD_VALS[1]);
    put.addColumn(FAMILIES[0],QUALIFIER,STAMPS[2],MATCH_VAL);
    put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[0],BAD_VALS[0]);
    put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[2],BAD_VALS[2]);
    this.region.put(put);
    put=new Put(ROWS[1]);
    put.addColumn(FAMILIES[0],QUALIFIER,STAMPS[0],BAD_VALS[0]);
    put.addColumn(FAMILIES[0],QUALIFIER,STAMPS[2],MATCH_VAL);
    put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[0],MATCH_VAL);
    put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[1],BAD_VALS[2]);
    this.region.put(put);
  }
  private List<KeyValue> makeTestVals(){
    List<KeyValue> testVals=new ArrayList<>();
    testVals.add(new KeyValue(ROWS[0],FAMILIES[0],QUALIFIER,STAMPS[0],BAD_VALS[0]));
    testVals.add(new KeyValue(ROWS[0],FAMILIES[0],QUALIFIER,STAMPS[1],BAD_VALS[1]));
    testVals.add(new KeyValue(ROWS[0],FAMILIES[1],QUALIFIER,STAMPS[1],BAD_VALS[2]));
    testVals.add(new KeyValue(ROWS[0],FAMILIES[1],QUALIFIER,STAMPS[0],MATCH_VAL));
    testVals.add(new KeyValue(ROWS[0],FAMILIES[1],QUALIFIER,STAMPS[2],BAD_VALS[2]));
    return testVals;
  }
  /** 
 * This shouldn't be confused with TestFilter#verifyScan as expectedKeys is not the per row total, but the scan total
 * @param s
 * @param expectedRows
 * @param expectedCells
 * @throws IOException
 */
  private void verifyScan(  Scan s,  long expectedRows,  long expectedCells) throws IOException {
    InternalScanner scanner=this.region.getScanner(s);
    List<Cell> results=new ArrayList<>();
    int i=0;
    int cells=0;
    for (boolean done=true; done; i++) {
      done=scanner.next(results);
      Arrays.sort(results.toArray(new Cell[results.size()]),CellComparatorImpl.COMPARATOR);
      LOG.info("counter=" + i + ", "+ results);
      if (results.isEmpty())       break;
      cells+=results.size();
      assertTrue("Scanned too many rows! Only expected " + expectedRows + " total but already scanned "+ (i + 1),expectedRows > i);
      assertTrue("Expected " + expectedCells + " cells total but "+ "already scanned "+ cells,expectedCells >= cells);
      results.clear();
    }
    assertEquals("Expected " + expectedRows + " rows but scanned "+ i+ " rows",expectedRows,i);
    assertEquals("Expected " + expectedCells + " cells but scanned "+ cells+ " cells",expectedCells,cells);
  }
  /** 
 * Test scans using a DependentColumnFilter
 */
  @Test public void testScans() throws Exception {
    Filter filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER);
    Scan scan=new Scan();
    scan.setFilter(filter);
    scan.setMaxVersions(Integer.MAX_VALUE);
    verifyScan(scan,2,8);
    filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER,true);
    scan=new Scan();
    scan.setFilter(filter);
    scan.setMaxVersions(Integer.MAX_VALUE);
    verifyScan(scan,2,3);
    filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER,false,CompareOperator.EQUAL,new BinaryComparator(MATCH_VAL));
    scan=new Scan();
    scan.setFilter(filter);
    scan.setMaxVersions(Integer.MAX_VALUE);
    verifyScan(scan,2,3);
    filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER,true,CompareOperator.EQUAL,new BinaryComparator(MATCH_VAL));
    scan=new Scan();
    scan.setFilter(filter);
    scan.setMaxVersions(Integer.MAX_VALUE);
    verifyScan(scan,1,1);
  }
  /** 
 * Test that the filter correctly drops rows without a corresponding timestamp
 * @throws Exception
 */
  @Test public void testFilterDropping() throws Exception {
    Filter filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER);
    List<Cell> accepted=new ArrayList<>();
    for (    Cell val : testVals) {
      if (filter.filterCell(val) == ReturnCode.INCLUDE) {
        accepted.add(val);
      }
    }
    assertEquals("check all values accepted from filterCell",5,accepted.size());
    filter.filterRowCells(accepted);
    assertEquals("check filterRow(List<KeyValue>) dropped cell without corresponding column entry",4,accepted.size());
    filter=new DependentColumnFilter(FAMILIES[1],QUALIFIER,true);
    accepted.clear();
    for (    KeyValue val : testVals) {
      if (filter.filterCell(val) == ReturnCode.INCLUDE) {
        accepted.add(val);
      }
    }
    assertEquals("check the filtering column cells got dropped",2,accepted.size());
    filter.filterRowCells(accepted);
    assertEquals("check cell retention",2,accepted.size());
  }
  /** 
 * Test for HBASE-8794. Avoid NullPointerException in DependentColumnFilter.toString().
 */
  @Test public void testToStringWithNullComparator(){
    Filter filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER);
    assertNotNull(filter.toString());
    assertTrue("check string contains 'null' as compatator is null",filter.toString().contains("null"));
    filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER,true,CompareOperator.EQUAL,null);
    assertNotNull(filter.toString());
    assertTrue("check string contains 'null' as compatator is null",filter.toString().contains("null"));
  }
  @Test public void testToStringWithNonNullComparator(){
    Filter filter=new DependentColumnFilter(FAMILIES[0],QUALIFIER,true,CompareOperator.EQUAL,new BinaryComparator(MATCH_VAL));
    assertNotNull(filter.toString());
    assertTrue("check string contains comparator value",filter.toString().contains("match"));
  }
}
