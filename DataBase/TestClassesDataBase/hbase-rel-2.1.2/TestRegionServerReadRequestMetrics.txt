@Ignore @Category(MediumTests.class) public class TestRegionServerReadRequestMetrics {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRegionServerReadRequestMetrics.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRegionServerReadRequestMetrics.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final TableName TABLE_NAME=TableName.valueOf("test");
  private static final byte[] CF1="c1".getBytes();
  private static final byte[] CF2="c2".getBytes();
  private static final byte[] ROW1="a".getBytes();
  private static final byte[] ROW2="b".getBytes();
  private static final byte[] ROW3="c".getBytes();
  private static final byte[] COL1="q1".getBytes();
  private static final byte[] COL2="q2".getBytes();
  private static final byte[] COL3="q3".getBytes();
  private static final byte[] VAL1="v1".getBytes();
  private static final byte[] VAL2="v2".getBytes();
  private static final byte[] VAL3=Bytes.toBytes(0L);
  private static final int MAX_TRY=20;
  private static final int SLEEP_MS=100;
  private static final int TTL=1;
  private static Admin admin;
  private static Collection<ServerName> serverNames;
  private static Table table;
  private static RegionInfo regionInfo;
  private static Map<Metric,Long> requestsMap=new HashMap<>();
  private static Map<Metric,Long> requestsMapPrev=new HashMap<>();
  @BeforeClass public static void setUpOnce() throws Exception {
    TEST_UTIL.getConfiguration().setBoolean(LoadBalancer.TABLES_ON_MASTER,true);
    TEST_UTIL.startMiniCluster();
    admin=TEST_UTIL.getAdmin();
    serverNames=admin.getClusterMetrics(EnumSet.of(Option.LIVE_SERVERS)).getLiveServerMetrics().keySet();
    table=createTable();
    putData();
    List<RegionInfo> regions=admin.getRegions(TABLE_NAME);
    assertEquals("Table " + TABLE_NAME + " should have 1 region",1,regions.size());
    regionInfo=regions.get(0);
    for (    Metric metric : Metric.values()) {
      requestsMap.put(metric,0L);
      requestsMapPrev.put(metric,0L);
    }
  }
  private static Table createTable() throws IOException {
    TableDescriptorBuilder builder=TableDescriptorBuilder.newBuilder(TABLE_NAME);
    builder.setColumnFamily(ColumnFamilyDescriptorBuilder.of(CF1));
    builder.setColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(CF2).setTimeToLive(TTL).build());
    admin.createTable(builder.build());
    return TEST_UTIL.getConnection().getTable(TABLE_NAME);
  }
  private static void testReadRequests(  long resultCount,  long expectedReadRequests,  long expectedFilteredReadRequests) throws IOException, InterruptedException {
    updateMetricsMap();
    System.out.println("requestsMapPrev = " + requestsMapPrev);
    System.out.println("requestsMap = " + requestsMap);
    assertEquals(expectedReadRequests,requestsMap.get(Metric.REGION_READ) - requestsMapPrev.get(Metric.REGION_READ));
    boolean tablesOnMaster=LoadBalancer.isTablesOnMaster(TEST_UTIL.getConfiguration());
    if (tablesOnMaster) {
      assertEquals(expectedReadRequests,requestsMap.get(Metric.SERVER_READ) - requestsMapPrev.get(Metric.SERVER_READ));
    }
    assertEquals(expectedFilteredReadRequests,requestsMap.get(Metric.FILTERED_REGION_READ) - requestsMapPrev.get(Metric.FILTERED_REGION_READ));
    assertEquals(expectedFilteredReadRequests,requestsMap.get(Metric.FILTERED_SERVER_READ) - requestsMapPrev.get(Metric.FILTERED_SERVER_READ));
    assertEquals(expectedReadRequests,resultCount);
  }
  private static void updateMetricsMap() throws IOException, InterruptedException {
    for (    Metric metric : Metric.values()) {
      requestsMapPrev.put(metric,requestsMap.get(metric));
    }
    ServerLoad serverLoad=null;
    RegionLoad regionLoadOuter=null;
    boolean metricsUpdated=false;
    for (int i=0; i < MAX_TRY; i++) {
      for (      ServerName serverName : serverNames) {
        serverLoad=new ServerLoad(admin.getClusterMetrics(EnumSet.of(Option.LIVE_SERVERS)).getLiveServerMetrics().get(serverName));
        Map<byte[],RegionLoad> regionsLoad=serverLoad.getRegionsLoad();
        RegionLoad regionLoad=regionsLoad.get(regionInfo.getRegionName());
        if (regionLoad != null) {
          regionLoadOuter=regionLoad;
          for (          Metric metric : Metric.values()) {
            if (getReadRequest(serverLoad,regionLoad,metric) > requestsMapPrev.get(metric)) {
              for (              Metric metricInner : Metric.values()) {
                requestsMap.put(metricInner,getReadRequest(serverLoad,regionLoad,metricInner));
              }
              metricsUpdated=true;
              break;
            }
          }
        }
      }
      if (metricsUpdated) {
        break;
      }
      Thread.sleep(SLEEP_MS);
    }
    if (!metricsUpdated) {
      for (      Metric metric : Metric.values()) {
        requestsMap.put(metric,getReadRequest(serverLoad,regionLoadOuter,metric));
      }
    }
  }
  private static long getReadRequest(  ServerLoad serverLoad,  RegionLoad regionLoad,  Metric metric){
switch (metric) {
case REGION_READ:
      return regionLoad.getReadRequestsCount();
case SERVER_READ:
    return serverLoad.getReadRequestsCount();
case FILTERED_REGION_READ:
  return regionLoad.getFilteredReadRequestsCount();
case FILTERED_SERVER_READ:
return serverLoad.getFilteredReadRequestsCount();
default :
throw new IllegalStateException();
}
}
private static void putData() throws IOException {
Put put;
put=new Put(ROW1);
put.addColumn(CF1,COL1,VAL1);
put.addColumn(CF1,COL2,VAL2);
put.addColumn(CF1,COL3,VAL3);
table.put(put);
put=new Put(ROW2);
put.addColumn(CF1,COL1,VAL2);
put.addColumn(CF1,COL2,VAL2);
table.put(put);
put=new Put(ROW3);
put.addColumn(CF1,COL1,VAL1);
put.addColumn(CF1,COL2,VAL2);
table.put(put);
}
private static void putTTLExpiredData() throws IOException, InterruptedException {
Put put;
put=new Put(ROW1);
put.addColumn(CF2,COL1,VAL1);
put.addColumn(CF2,COL2,VAL2);
table.put(put);
Thread.sleep(TTL * 1000);
put=new Put(ROW2);
put.addColumn(CF2,COL1,VAL1);
put.addColumn(CF2,COL2,VAL2);
table.put(put);
put=new Put(ROW3);
put.addColumn(CF2,COL1,VAL1);
put.addColumn(CF2,COL2,VAL2);
table.put(put);
}
@AfterClass public static void tearDownOnce() throws Exception {
TEST_UTIL.shutdownMiniCluster();
}
@Test public void testReadRequestsCountNotFiltered() throws Exception {
int resultCount;
Scan scan;
Append append;
Put put;
Increment increment;
Get get;
scan=new Scan();
try (ResultScanner scanner=table.getScanner(scan)){
resultCount=0;
for (Result ignore : scanner) {
resultCount++;
}
testReadRequests(resultCount,3,0);
}
 scan=new Scan(ROW2,ROW3);
try (ResultScanner scanner=table.getScanner(scan)){
resultCount=0;
for (Result ignore : scanner) {
resultCount++;
}
testReadRequests(resultCount,1,0);
}
 get=new Get(ROW2);
Result result=table.get(get);
resultCount=result.isEmpty() ? 0 : 1;
testReadRequests(resultCount,1,0);
increment=new Increment(ROW1);
increment.addColumn(CF1,COL3,1);
result=table.increment(increment);
resultCount=result.isEmpty() ? 0 : 1;
testReadRequests(resultCount,1,0);
put=new Put(ROW1);
put.addColumn(CF1,COL2,VAL2);
boolean checkAndPut=table.checkAndMutate(ROW1,CF1).qualifier(COL2).ifEquals(VAL2).thenPut(put);
resultCount=checkAndPut ? 1 : 0;
testReadRequests(resultCount,1,0);
append=new Append(ROW1);
append.addColumn(CF1,COL2,VAL2);
result=table.append(append);
resultCount=result.isEmpty() ? 0 : 1;
testReadRequests(resultCount,1,0);
put=new Put(ROW1);
put.addColumn(CF1,COL1,VAL1);
RowMutations rm=new RowMutations(ROW1);
rm.add(put);
boolean checkAndMutate=table.checkAndMutate(ROW1,CF1).qualifier(COL1).ifEquals(VAL1).thenMutate(rm);
resultCount=checkAndMutate ? 1 : 0;
testReadRequests(resultCount,1,0);
}
@Ignore @Test public void testReadRequestsCountWithFilter() throws Exception {
int resultCount;
Scan scan;
scan=new Scan();
scan.setFilter(new SingleColumnValueFilter(CF1,COL1,CompareFilter.CompareOp.EQUAL,VAL1));
try (ResultScanner scanner=table.getScanner(scan)){
resultCount=0;
for (Result ignore : scanner) {
resultCount++;
}
testReadRequests(resultCount,2,1);
}
 scan=new Scan();
scan.setFilter(new RowFilter(CompareFilter.CompareOp.EQUAL,new BinaryComparator(ROW1)));
try (ResultScanner scanner=table.getScanner(scan)){
resultCount=0;
for (Result ignore : scanner) {
resultCount++;
}
testReadRequests(resultCount,1,2);
}
 scan=new Scan(ROW2,ROW3);
scan.setFilter(new RowFilter(CompareFilter.CompareOp.EQUAL,new BinaryComparator(ROW1)));
try (ResultScanner scanner=table.getScanner(scan)){
resultCount=0;
for (Result ignore : scanner) {
resultCount++;
}
testReadRequests(resultCount,0,1);
}
 }
@Ignore @Test public void testReadRequestsCountWithDeletedRow() throws Exception {
try {
Delete delete=new Delete(ROW3);
table.delete(delete);
Scan scan=new Scan();
try (ResultScanner scanner=table.getScanner(scan)){
int resultCount=0;
for (Result ignore : scanner) {
resultCount++;
}
testReadRequests(resultCount,2,1);
}
 }
  finally {
Put put=new Put(ROW3);
put.addColumn(CF1,COL1,VAL1);
put.addColumn(CF1,COL2,VAL2);
table.put(put);
}
}
@Test public void testReadRequestsCountWithTTLExpiration() throws Exception {
putTTLExpiredData();
Scan scan=new Scan();
scan.addFamily(CF2);
try (ResultScanner scanner=table.getScanner(scan)){
int resultCount=0;
for (Result ignore : scanner) {
resultCount++;
}
testReadRequests(resultCount,2,1);
}
 }
@Ignore @Test public void testReadRequestsWithCoprocessor() throws Exception {
TableName tableName=TableName.valueOf("testReadRequestsWithCoprocessor");
TableDescriptorBuilder builder=TableDescriptorBuilder.newBuilder(tableName);
builder.setColumnFamily(ColumnFamilyDescriptorBuilder.of(CF1));
builder.setCoprocessor(ScanRegionCoprocessor.class.getName());
admin.createTable(builder.build());
try {
TEST_UTIL.waitTableAvailable(tableName);
List<RegionInfo> regionInfos=admin.getRegions(tableName);
assertEquals("Table " + TABLE_NAME + " should have 1 region",1,regionInfos.size());
boolean success=true;
int i=0;
for (; i < MAX_TRY; i++) {
try {
testReadRequests(regionInfos.get(0).getRegionName(),3);
}
 catch (Throwable t) {
LOG.warn("Got exception when try " + i + " times",t);
Thread.sleep(SLEEP_MS);
success=false;
}
if (success) {
break;
}
}
if (i == MAX_TRY) {
fail("Failed to get right read requests metric after try " + i + " times");
}
}
  finally {
admin.disableTable(tableName);
admin.deleteTable(tableName);
}
}
private void testReadRequests(byte[] regionName,int expectedReadRequests) throws Exception {
for (ServerName serverName : serverNames) {
ServerLoad serverLoad=new ServerLoad(admin.getClusterMetrics(EnumSet.of(Option.LIVE_SERVERS)).getLiveServerMetrics().get(serverName));
Map<byte[],RegionLoad> regionsLoad=serverLoad.getRegionsLoad();
RegionLoad regionLoad=regionsLoad.get(regionName);
if (regionLoad != null) {
LOG.debug("server read request is " + serverLoad.getReadRequestsCount() + ", region read request is "+ regionLoad.getReadRequestsCount());
assertEquals(3,serverLoad.getReadRequestsCount());
assertEquals(3,regionLoad.getReadRequestsCount());
}
}
}
public static class ScanRegionCoprocessor implements RegionCoprocessor, RegionObserver {
@Override public Optional<RegionObserver> getRegionObserver(){
return Optional.of(this);
}
@Override public void postOpen(ObserverContext<RegionCoprocessorEnvironment> c){
RegionCoprocessorEnvironment env=c.getEnvironment();
Region region=env.getRegion();
try {
putData(region);
RegionScanner scanner=region.getScanner(new Scan());
List<Cell> result=new LinkedList<>();
while (scanner.next(result)) {
result.clear();
}
}
 catch (Exception e) {
LOG.warn("Got exception in coprocessor",e);
}
}
private void putData(Region region) throws Exception {
Put put=new Put(ROW1);
put.addColumn(CF1,COL1,VAL1);
region.put(put);
put=new Put(ROW2);
put.addColumn(CF1,COL1,VAL1);
region.put(put);
put=new Put(ROW3);
put.addColumn(CF1,COL1,VAL1);
region.put(put);
}
}
private enum Metric {REGION_READ, SERVER_READ, FILTERED_REGION_READ, FILTERED_SERVER_READ}
}
