/** 
 * Test a multi-column scanner when there is a Bloom filter false-positive. This is needed for the multi-column Bloom filter optimization.
 */
@RunWith(Parameterized.class) @Category({RegionServerTests.class,SmallTests.class}) public class TestScanWithBloomError {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestScanWithBloomError.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestScanWithBloomError.class);
  private static final String TABLE_NAME="ScanWithBloomError";
  private static final String FAMILY="myCF";
  private static final byte[] FAMILY_BYTES=Bytes.toBytes(FAMILY);
  private static final String ROW="theRow";
  private static final String QUALIFIER_PREFIX="qual";
  private static final byte[] ROW_BYTES=Bytes.toBytes(ROW);
  private static NavigableSet<Integer> allColIds=new TreeSet<>();
  private HRegion region;
  private BloomType bloomType;
  private FileSystem fs;
  private Configuration conf;
  private final static HBaseTestingUtility TEST_UTIL=HBaseTestingUtility.createLocalHTU();
  @Parameters public static final Collection<Object[]> parameters(){
    List<Object[]> configurations=new ArrayList<>();
    for (    BloomType bloomType : BloomType.values()) {
      configurations.add(new Object[]{bloomType});
    }
    return configurations;
  }
  public TestScanWithBloomError(  BloomType bloomType){
    this.bloomType=bloomType;
  }
  @Before public void setUp() throws IOException {
    conf=TEST_UTIL.getConfiguration();
    fs=FileSystem.get(conf);
  }
  @Test public void testThreeStoreFiles() throws IOException {
    region=TEST_UTIL.createTestRegion(TABLE_NAME,new HColumnDescriptor(FAMILY).setCompressionType(Compression.Algorithm.GZ).setBloomFilterType(bloomType).setMaxVersions(TestMultiColumnScanner.MAX_VERSIONS));
    createStoreFile(new int[]{1,2,6});
    createStoreFile(new int[]{1,2,3,7});
    createStoreFile(new int[]{1,9});
    scanColSet(new int[]{1,4,6,7},new int[]{1,6,7});
    HBaseTestingUtility.closeRegionAndWAL(region);
  }
  private void scanColSet(  int[] colSet,  int[] expectedResultCols) throws IOException {
    LOG.info("Scanning column set: " + Arrays.toString(colSet));
    Scan scan=new Scan(ROW_BYTES,ROW_BYTES);
    addColumnSetToScan(scan,colSet);
    RegionScannerImpl scanner=region.getScanner(scan);
    KeyValueHeap storeHeap=scanner.getStoreHeapForTesting();
    assertEquals(0,storeHeap.getHeap().size());
    StoreScanner storeScanner=(StoreScanner)storeHeap.getCurrentForTesting();
    @SuppressWarnings({"unchecked","rawtypes"}) List<StoreFileScanner> scanners=(List<StoreFileScanner>)(List)storeScanner.getAllScannersForTesting();
    Collections.sort(scanners,new Comparator<StoreFileScanner>(){
      @Override public int compare(      StoreFileScanner s1,      StoreFileScanner s2){
        Path p1=s1.getReader().getHFileReader().getPath();
        Path p2=s2.getReader().getHFileReader().getPath();
        long t1, t2;
        try {
          t1=fs.getFileStatus(p1).getModificationTime();
          t2=fs.getFileStatus(p2).getModificationTime();
        }
 catch (        IOException ex) {
          throw new RuntimeException(ex);
        }
        return t1 < t2 ? -1 : t1 == t2 ? 1 : 0;
      }
    }
);
    StoreFileReader lastStoreFileReader=null;
    for (    StoreFileScanner sfScanner : scanners)     lastStoreFileReader=sfScanner.getReader();
    new HFilePrettyPrinter(conf).run(new String[]{"-m","-p","-f",lastStoreFileReader.getHFileReader().getPath().toString()});
    LOG.info("Disabling Bloom filter for: " + lastStoreFileReader.getHFileReader().getName());
    lastStoreFileReader.disableBloomFilterForTesting();
    List<Cell> allResults=new ArrayList<>();
{
      List<Cell> results=new ArrayList<>();
      while (scanner.next(results) || results.size() > 0) {
        allResults.addAll(results);
        results.clear();
      }
    }
    List<Integer> actualIds=new ArrayList<>();
    for (    Cell kv : allResults) {
      String qual=Bytes.toString(CellUtil.cloneQualifier(kv));
      assertTrue(qual.startsWith(QUALIFIER_PREFIX));
      actualIds.add(Integer.valueOf(qual.substring(QUALIFIER_PREFIX.length())));
    }
    List<Integer> expectedIds=new ArrayList<>();
    for (    int expectedId : expectedResultCols)     expectedIds.add(expectedId);
    LOG.info("Column ids returned: " + actualIds + ", expected: "+ expectedIds);
    assertEquals(expectedIds.toString(),actualIds.toString());
  }
  private void addColumnSetToScan(  Scan scan,  int[] colIds){
    for (    int colId : colIds) {
      scan.addColumn(FAMILY_BYTES,Bytes.toBytes(qualFromId(colId)));
    }
  }
  private String qualFromId(  int colId){
    return QUALIFIER_PREFIX + colId;
  }
  private void createStoreFile(  int[] colIds) throws IOException {
    Put p=new Put(ROW_BYTES);
    for (    int colId : colIds) {
      long ts=Long.MAX_VALUE;
      String qual=qualFromId(colId);
      allColIds.add(colId);
      KeyValue kv=KeyValueTestUtil.create(ROW,FAMILY,qual,ts,TestMultiColumnScanner.createValue(ROW,qual,ts));
      p.add(kv);
    }
    region.put(p);
    region.flush(true);
  }
}
