class Cluster {
  Random random=new Random();
  ReadWriteLock lock=new ReentrantReadWriteLock();
  HashMap<InetSocketAddress,RpcServer> rpcServers=new HashMap<>();
  List<RpcServer> serverList=new ArrayList<>();
  int maxServers;
  int minServers;
  Cluster(  int minServers,  int maxServers){
    this.minServers=minServers;
    this.maxServers=maxServers;
  }
  RpcServer startServer() throws IOException {
    lock.writeLock().lock();
    try {
      if (rpcServers.size() >= maxServers) {
        return null;
      }
      RpcServer rpcServer=RpcServerFactory.createRpcServer(null,"testRpcServer",Lists.newArrayList(new BlockingServiceAndInterface(SERVICE,null)),new InetSocketAddress("localhost",0),conf,new FifoRpcScheduler(conf,1));
      rpcServer.start();
      InetSocketAddress address=rpcServer.getListenerAddress();
      if (address == null) {
        throw new IOException("Listener channel is closed");
      }
      rpcServers.put(address,rpcServer);
      serverList.add(rpcServer);
      LOG.info("Started server: " + address);
      return rpcServer;
    }
  finally {
      lock.writeLock().unlock();
    }
  }
  void stopRandomServer() throws Exception {
    lock.writeLock().lock();
    RpcServer rpcServer=null;
    try {
      if (rpcServers.size() <= minServers) {
        return;
      }
      int size=rpcServers.size();
      int rand=random.nextInt(size);
      rpcServer=serverList.remove(rand);
      InetSocketAddress address=rpcServer.getListenerAddress();
      if (address == null) {
        throw new IOException("Listener channel is closed");
      }
      rpcServers.remove(address);
      if (rpcServer != null) {
        stopServer(rpcServer);
      }
    }
  finally {
      lock.writeLock().unlock();
    }
  }
  void stopServer(  RpcServer rpcServer) throws InterruptedException {
    InetSocketAddress address=rpcServer.getListenerAddress();
    LOG.info("Stopping server: " + address);
    rpcServer.stop();
    rpcServer.join();
    LOG.info("Stopped server: " + address);
  }
  void stopRunning() throws InterruptedException {
    lock.writeLock().lock();
    try {
      for (      RpcServer rpcServer : serverList) {
        stopServer(rpcServer);
      }
    }
  finally {
      lock.writeLock().unlock();
    }
  }
  RpcServer getRandomServer(){
    lock.readLock().lock();
    try {
      int size=rpcServers.size();
      int rand=random.nextInt(size);
      return serverList.get(rand);
    }
  finally {
      lock.readLock().unlock();
    }
  }
}
