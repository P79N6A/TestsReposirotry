/** 
 * Randomly selects and walks a random flushed loop concurrently with the Generator Mapper by spawning ConcurrentWalker's with specified StartNodes. These ConcurrentWalker's are configured to only log erroneous nodes.
 */
public class ContinuousConcurrentWalker implements Runnable {
  ConcurrentWalker walker;
  Configuration conf;
  Context context;
  Random rand;
  public ContinuousConcurrentWalker(  Configuration conf,  Context context){
    this.conf=conf;
    this.context=context;
    rand=new Random();
  }
  @Override public void run(){
    while (!walkersStop) {
      try {
        long node=selectLoop();
        try {
          walkLoop(node);
        }
 catch (        IOException e) {
          context.getCounter(Counts.IOEXCEPTION).increment(1l);
          return;
        }
      }
 catch (      InterruptedException e) {
        return;
      }
    }
  }
  private void walkLoop(  long node) throws IOException {
    walker=new ConcurrentWalker(context);
    walker.setConf(conf);
    walker.run(node,wrap);
  }
  private long selectLoop() throws InterruptedException {
synchronized (flushedLoops) {
      while (flushedLoops.isEmpty() && !walkersStop) {
        flushedLoops.wait();
      }
      if (walkersStop) {
        throw new InterruptedException();
      }
      return flushedLoops.get(rand.nextInt(flushedLoops.size()));
    }
  }
}
