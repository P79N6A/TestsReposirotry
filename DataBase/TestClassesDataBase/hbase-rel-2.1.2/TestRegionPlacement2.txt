@Category({MasterTests.class,MediumTests.class}) public class TestRegionPlacement2 {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRegionPlacement2.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRegionPlacement2.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private final static int SLAVES=7;
  private final static int PRIMARY=Position.PRIMARY.ordinal();
  private final static int SECONDARY=Position.SECONDARY.ordinal();
  private final static int TERTIARY=Position.TERTIARY.ordinal();
  @Rule public TestName name=new TestName();
  @BeforeClass public static void setupBeforeClass() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,FavoredNodeLoadBalancer.class,LoadBalancer.class);
    conf.setBoolean("hbase.tests.use.shortcircuit.reads",false);
    TEST_UTIL.startMiniCluster(SLAVES);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testFavoredNodesPresentForRoundRobinAssignment() throws HBaseIOException {
    LoadBalancer balancer=LoadBalancerFactory.getLoadBalancer(TEST_UTIL.getConfiguration());
    balancer.setMasterServices(TEST_UTIL.getMiniHBaseCluster().getMaster());
    balancer.initialize();
    List<ServerName> servers=new ArrayList<>();
    for (int i=0; i < SLAVES; i++) {
      ServerName server=TEST_UTIL.getMiniHBaseCluster().getRegionServer(i).getServerName();
      servers.add(server);
    }
    List<RegionInfo> regions=new ArrayList<>(1);
    RegionInfo region=RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    regions.add(region);
    Map<ServerName,List<RegionInfo>> assignmentMap=balancer.roundRobinAssignment(regions,servers);
    Set<ServerName> serverBefore=assignmentMap.keySet();
    List<ServerName> favoredNodesBefore=((FavoredNodeLoadBalancer)balancer).getFavoredNodes(region);
    assertTrue(favoredNodesBefore.size() == FavoredNodeAssignmentHelper.FAVORED_NODES_NUM);
    assertTrue(ServerName.isSameAddress(serverBefore.iterator().next(),favoredNodesBefore.get(PRIMARY)));
    List<ServerName> removedServers=removeMatchingServers(serverBefore,servers);
    assignmentMap=balancer.roundRobinAssignment(regions,servers);
    List<ServerName> favoredNodesAfter=((FavoredNodeLoadBalancer)balancer).getFavoredNodes(region);
    assertTrue(favoredNodesAfter.size() == FavoredNodeAssignmentHelper.FAVORED_NODES_NUM);
    assertTrue(favoredNodesAfter.containsAll(favoredNodesBefore));
    Set<ServerName> serverAfter=assignmentMap.keySet();
    assertTrue(ServerName.isSameAddress(serverAfter.iterator().next(),favoredNodesBefore.get(SECONDARY)) || ServerName.isSameAddress(serverAfter.iterator().next(),favoredNodesBefore.get(TERTIARY)));
    servers.addAll(removedServers);
    assignmentMap=balancer.roundRobinAssignment(regions,servers);
    Set<ServerName> serverWithPrimary=assignmentMap.keySet();
    assertTrue(serverBefore.containsAll(serverWithPrimary));
    removeMatchingServers(favoredNodesAfter,servers);
    assignmentMap=balancer.roundRobinAssignment(regions,servers);
    List<ServerName> favoredNodesNow=((FavoredNodeLoadBalancer)balancer).getFavoredNodes(region);
    assertTrue(favoredNodesNow.size() == FavoredNodeAssignmentHelper.FAVORED_NODES_NUM);
    assertTrue(!favoredNodesNow.contains(favoredNodesAfter.get(PRIMARY)) && !favoredNodesNow.contains(favoredNodesAfter.get(SECONDARY)) && !favoredNodesNow.contains(favoredNodesAfter.get(TERTIARY)));
  }
  @Test public void testFavoredNodesPresentForRandomAssignment() throws HBaseIOException {
    LoadBalancer balancer=LoadBalancerFactory.getLoadBalancer(TEST_UTIL.getConfiguration());
    balancer.setMasterServices(TEST_UTIL.getMiniHBaseCluster().getMaster());
    balancer.initialize();
    List<ServerName> servers=new ArrayList<>();
    for (int i=0; i < SLAVES; i++) {
      ServerName server=TEST_UTIL.getMiniHBaseCluster().getRegionServer(i).getServerName();
      servers.add(server);
    }
    List<RegionInfo> regions=new ArrayList<>(1);
    RegionInfo region=RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).build();
    regions.add(region);
    ServerName serverBefore=balancer.randomAssignment(region,servers);
    List<ServerName> favoredNodesBefore=((FavoredNodeLoadBalancer)balancer).getFavoredNodes(region);
    assertTrue(favoredNodesBefore.size() == FavoredNodeAssignmentHelper.FAVORED_NODES_NUM);
    assertTrue(ServerName.isSameAddress(serverBefore,favoredNodesBefore.get(PRIMARY)));
    removeMatchingServers(serverBefore,servers);
    ServerName serverAfter=balancer.randomAssignment(region,servers);
    List<ServerName> favoredNodesAfter=((FavoredNodeLoadBalancer)balancer).getFavoredNodes(region);
    assertTrue(favoredNodesAfter.size() == FavoredNodeAssignmentHelper.FAVORED_NODES_NUM);
    assertTrue(favoredNodesAfter.containsAll(favoredNodesBefore));
    assertTrue(ServerName.isSameAddress(serverAfter,favoredNodesBefore.get(SECONDARY)) || ServerName.isSameAddress(serverAfter,favoredNodesBefore.get(TERTIARY)));
    removeMatchingServers(favoredNodesAfter,servers);
    balancer.randomAssignment(region,servers);
    List<ServerName> favoredNodesNow=((FavoredNodeLoadBalancer)balancer).getFavoredNodes(region);
    assertTrue(favoredNodesNow.size() == FavoredNodeAssignmentHelper.FAVORED_NODES_NUM);
    assertTrue(!favoredNodesNow.contains(favoredNodesAfter.get(PRIMARY)) && !favoredNodesNow.contains(favoredNodesAfter.get(SECONDARY)) && !favoredNodesNow.contains(favoredNodesAfter.get(TERTIARY)));
  }
  private List<ServerName> removeMatchingServers(  Collection<ServerName> serversWithoutStartCode,  List<ServerName> servers){
    List<ServerName> serversToRemove=new ArrayList<>();
    for (    ServerName s : serversWithoutStartCode) {
      serversToRemove.addAll(removeMatchingServers(s,servers));
    }
    return serversToRemove;
  }
  private List<ServerName> removeMatchingServers(  ServerName serverWithoutStartCode,  List<ServerName> servers){
    List<ServerName> serversToRemove=new ArrayList<>();
    for (    ServerName s : servers) {
      if (ServerName.isSameAddress(s,serverWithoutStartCode)) {
        serversToRemove.add(s);
      }
    }
    servers.removeAll(serversToRemove);
    return serversToRemove;
  }
}
