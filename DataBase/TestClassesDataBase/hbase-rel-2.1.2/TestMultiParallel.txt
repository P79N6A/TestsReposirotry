@Category({MediumTests.class,FlakeyTests.class}) public class TestMultiParallel {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMultiParallel.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestMultiParallel.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final byte[] VALUE=Bytes.toBytes("value");
  private static final byte[] QUALIFIER=Bytes.toBytes("qual");
  private static final String FAMILY="family";
  private static final TableName TEST_TABLE=TableName.valueOf("multi_test_table");
  private static final byte[] BYTES_FAMILY=Bytes.toBytes(FAMILY);
  private static final byte[] ONE_ROW=Bytes.toBytes("xxx");
  private static final byte[][] KEYS=makeKeys();
  private static final int slaves=5;
  private static Connection CONNECTION;
  @BeforeClass public static void beforeClass() throws Exception {
    UTIL.getConfiguration().set(HConstants.RPC_CODEC_CONF_KEY,KeyValueCodec.class.getCanonicalName());
    UTIL.getConfiguration().set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,MyMasterObserver.class.getName());
    UTIL.startMiniCluster(slaves);
    Table t=UTIL.createMultiRegionTable(TEST_TABLE,Bytes.toBytes(FAMILY));
    UTIL.waitTableEnabled(TEST_TABLE);
    t.close();
    CONNECTION=ConnectionFactory.createConnection(UTIL.getConfiguration());
    assertTrue(MyMasterObserver.start.get());
  }
  @AfterClass public static void afterClass() throws Exception {
    CONNECTION.close();
    UTIL.shutdownMiniCluster();
  }
  @Before public void before() throws Exception {
    final int balanceCount=MyMasterObserver.postBalanceCount.get();
    LOG.info("before");
    if (UTIL.ensureSomeRegionServersAvailable(slaves)) {
      UTIL.getMiniHBaseCluster().getMaster().balance();
      if (MyMasterObserver.postBalanceCount.get() > balanceCount) {
        UTIL.waitFor(3 * 1000,100,false,() -> UTIL.getMiniHBaseCluster().getMaster().getAssignmentManager().hasRegionsInTransition());
      }
      UTIL.waitUntilAllRegionsAssigned(TEST_TABLE);
    }
    LOG.info("before done");
  }
  private static byte[][] makeKeys(){
    byte[][] starterKeys=HBaseTestingUtility.KEYS;
    int numKeys=(int)(starterKeys.length * 10.33F);
    List<byte[]> keys=new ArrayList<>();
    for (int i=0; i < numKeys; i++) {
      int kIdx=i % starterKeys.length;
      byte[] k=starterKeys[kIdx];
      byte[] cp=new byte[k.length + 1];
      System.arraycopy(k,0,cp,0,k.length);
      cp[k.length]=new Integer(i % 256).byteValue();
      keys.add(cp);
    }
    for (int i=0; i < 100; i++) {
      int kIdx=i % starterKeys.length;
      byte[] k=starterKeys[kIdx];
      byte[] cp=new byte[k.length + 1];
      System.arraycopy(k,0,cp,0,k.length);
      cp[k.length]=new Integer(i % 256).byteValue();
      keys.add(cp);
    }
    return keys.toArray(new byte[][]{new byte[]{}});
  }
  /** 
 * This is for testing the active number of threads that were used while doing a batch operation. It inserts one row per region via the batch operation, and then checks the number of active threads. <p/> For HBASE-3553
 */
  @Test public void testActiveThreadsCount() throws Exception {
    UTIL.getConfiguration().setLong("hbase.htable.threads.coresize",slaves + 1);
    try (Connection connection=ConnectionFactory.createConnection(UTIL.getConfiguration())){
      ThreadPoolExecutor executor=HTable.getDefaultExecutor(UTIL.getConfiguration());
      try {
        try (Table t=connection.getTable(TEST_TABLE,executor)){
          List<Put> puts=constructPutRequests();
          t.batch(puts,null);
          HashSet<ServerName> regionservers=new HashSet<>();
          try (RegionLocator locator=connection.getRegionLocator(TEST_TABLE)){
            for (            Row r : puts) {
              HRegionLocation location=locator.getRegionLocation(r.getRow());
              regionservers.add(location.getServerName());
            }
          }
           assertEquals(regionservers.size(),executor.getLargestPoolSize());
        }
       }
  finally {
        executor.shutdownNow();
      }
    }
   }
  @Test public void testBatchWithGet() throws Exception {
    LOG.info("test=testBatchWithGet");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    List<Put> puts=constructPutRequests();
    table.batch(puts,null);
    List<Row> gets=new ArrayList<>();
    for (    byte[] k : KEYS) {
      Get get=new Get(k);
      get.addColumn(BYTES_FAMILY,QUALIFIER);
      gets.add(get);
    }
    Result[] multiRes=new Result[gets.size()];
    table.batch(gets,multiRes);
    List<Result> singleRes=new ArrayList<>();
    for (    Row get : gets) {
      singleRes.add(table.get((Get)get));
    }
    Assert.assertEquals(singleRes.size(),multiRes.length);
    for (int i=0; i < singleRes.size(); i++) {
      Assert.assertTrue(singleRes.get(i).containsColumn(BYTES_FAMILY,QUALIFIER));
      Cell[] singleKvs=singleRes.get(i).rawCells();
      Cell[] multiKvs=multiRes[i].rawCells();
      for (int j=0; j < singleKvs.length; j++) {
        Assert.assertEquals(singleKvs[j],multiKvs[j]);
        Assert.assertEquals(0,Bytes.compareTo(CellUtil.cloneValue(singleKvs[j]),CellUtil.cloneValue(multiKvs[j])));
      }
    }
    table.close();
  }
  @Test public void testBadFam() throws Exception {
    LOG.info("test=testBadFam");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    List<Row> actions=new ArrayList<>();
    Put p=new Put(Bytes.toBytes("row1"));
    p.addColumn(Bytes.toBytes("bad_family"),Bytes.toBytes("qual"),Bytes.toBytes("value"));
    actions.add(p);
    p=new Put(Bytes.toBytes("row2"));
    p.addColumn(BYTES_FAMILY,Bytes.toBytes("qual"),Bytes.toBytes("value"));
    actions.add(p);
    Object[] r=new Object[actions.size()];
    try {
      table.batch(actions,r);
      fail();
    }
 catch (    RetriesExhaustedWithDetailsException ex) {
      LOG.debug(ex.toString(),ex);
      assertFalse(ex.mayHaveClusterIssues());
    }
    assertEquals(2,r.length);
    assertTrue(r[0] instanceof Throwable);
    assertTrue(r[1] instanceof Result);
    table.close();
  }
  @Test public void testFlushCommitsNoAbort() throws Exception {
    LOG.info("test=testFlushCommitsNoAbort");
    doTestFlushCommits(false);
  }
  /** 
 * Only run one Multi test with a forced RegionServer abort. Otherwise, the unit tests will take an unnecessarily long time to run.
 */
  @Test public void testFlushCommitsWithAbort() throws Exception {
    LOG.info("test=testFlushCommitsWithAbort");
    doTestFlushCommits(true);
  }
  /** 
 * Set table auto flush to false and test flushing commits
 * @param doAbort true if abort one regionserver in the testing
 */
  private void doTestFlushCommits(  boolean doAbort) throws Exception {
    LOG.info("get new table");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    LOG.info("constructPutRequests");
    List<Put> puts=constructPutRequests();
    table.put(puts);
    LOG.info("puts");
    final int liveRScount=UTIL.getMiniHBaseCluster().getLiveRegionServerThreads().size();
    assert liveRScount > 0;
    JVMClusterUtil.RegionServerThread liveRS=UTIL.getMiniHBaseCluster().getLiveRegionServerThreads().get(0);
    if (doAbort) {
      liveRS.getRegionServer().abort("Aborting for tests",new Exception("doTestFlushCommits"));
      while (liveRS.getRegionServer().getNumberOfOnlineRegions() != 0) {
        Thread.sleep(100);
      }
      puts=constructPutRequests();
      table.put(puts);
    }
    LOG.info("validating loaded data");
    validateLoadedData(table);
    List<JVMClusterUtil.RegionServerThread> liveRSs=UTIL.getMiniHBaseCluster().getLiveRegionServerThreads();
    int count=0;
    for (    JVMClusterUtil.RegionServerThread t : liveRSs) {
      count++;
      LOG.info("Count=" + count + ", Alive="+ t.getRegionServer());
    }
    LOG.info("Count=" + count);
    Assert.assertEquals("Server count=" + count + ", abort="+ doAbort,(doAbort ? (liveRScount - 1) : liveRScount),count);
    if (doAbort) {
      UTIL.getMiniHBaseCluster().waitOnRegionServer(0);
      UTIL.waitFor(15 * 1000,new Waiter.Predicate<Exception>(){
        @Override public boolean evaluate() throws Exception {
          return UTIL.getMiniHBaseCluster().getMaster().getClusterMetrics().getLiveServerMetrics().size() == liveRScount - 1;
        }
      }
);
      UTIL.waitFor(15 * 1000,UTIL.predicateNoRegionsInTransition());
    }
    table.close();
    LOG.info("done");
  }
  @Test public void testBatchWithPut() throws Exception {
    LOG.info("test=testBatchWithPut");
    Table table=CONNECTION.getTable(TEST_TABLE);
    List<Put> puts=constructPutRequests();
    Object[] results=new Object[puts.size()];
    table.batch(puts,results);
    validateSizeAndEmpty(results,KEYS.length);
    if (true) {
      int liveRScount=UTIL.getMiniHBaseCluster().getLiveRegionServerThreads().size();
      assert liveRScount > 0;
      JVMClusterUtil.RegionServerThread liveRS=UTIL.getMiniHBaseCluster().getLiveRegionServerThreads().get(0);
      liveRS.getRegionServer().abort("Aborting for tests",new Exception("testBatchWithPut"));
      puts=constructPutRequests();
      try {
        results=new Object[puts.size()];
        table.batch(puts,results);
      }
 catch (      RetriesExhaustedWithDetailsException ree) {
        LOG.info(ree.getExhaustiveDescription());
        table.close();
        throw ree;
      }
      validateSizeAndEmpty(results,KEYS.length);
    }
    validateLoadedData(table);
    table.close();
  }
  @Test public void testBatchWithDelete() throws Exception {
    LOG.info("test=testBatchWithDelete");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    List<Put> puts=constructPutRequests();
    Object[] results=new Object[puts.size()];
    table.batch(puts,results);
    validateSizeAndEmpty(results,KEYS.length);
    List<Row> deletes=new ArrayList<>();
    for (int i=0; i < KEYS.length; i++) {
      Delete delete=new Delete(KEYS[i]);
      delete.addFamily(BYTES_FAMILY);
      deletes.add(delete);
    }
    results=new Object[deletes.size()];
    table.batch(deletes,results);
    validateSizeAndEmpty(results,KEYS.length);
    for (    byte[] k : KEYS) {
      Get get=new Get(k);
      get.addColumn(BYTES_FAMILY,QUALIFIER);
      Assert.assertFalse(table.exists(get));
    }
    table.close();
  }
  @Test public void testHTableDeleteWithList() throws Exception {
    LOG.info("test=testHTableDeleteWithList");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    List<Put> puts=constructPutRequests();
    Object[] results=new Object[puts.size()];
    table.batch(puts,results);
    validateSizeAndEmpty(results,KEYS.length);
    ArrayList<Delete> deletes=new ArrayList<>();
    for (int i=0; i < KEYS.length; i++) {
      Delete delete=new Delete(KEYS[i]);
      delete.addFamily(BYTES_FAMILY);
      deletes.add(delete);
    }
    table.delete(deletes);
    Assert.assertTrue(deletes.isEmpty());
    for (    byte[] k : KEYS) {
      Get get=new Get(k);
      get.addColumn(BYTES_FAMILY,QUALIFIER);
      Assert.assertFalse(table.exists(get));
    }
    table.close();
  }
  @Test public void testBatchWithManyColsInOneRowGetAndPut() throws Exception {
    LOG.info("test=testBatchWithManyColsInOneRowGetAndPut");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    List<Row> puts=new ArrayList<>();
    for (int i=0; i < 100; i++) {
      Put put=new Put(ONE_ROW);
      byte[] qual=Bytes.toBytes("column" + i);
      put.addColumn(BYTES_FAMILY,qual,VALUE);
      puts.add(put);
    }
    Object[] results=new Object[puts.size()];
    table.batch(puts,results);
    validateSizeAndEmpty(results,100);
    List<Row> gets=new ArrayList<>();
    for (int i=0; i < 100; i++) {
      Get get=new Get(ONE_ROW);
      byte[] qual=Bytes.toBytes("column" + i);
      get.addColumn(BYTES_FAMILY,qual);
      gets.add(get);
    }
    Object[] multiRes=new Object[gets.size()];
    table.batch(gets,multiRes);
    int idx=0;
    for (    Object r : multiRes) {
      byte[] qual=Bytes.toBytes("column" + idx);
      validateResult(r,qual,VALUE);
      idx++;
    }
    table.close();
  }
  @Test public void testBatchWithIncrementAndAppend() throws Exception {
    LOG.info("test=testBatchWithIncrementAndAppend");
    final byte[] QUAL1=Bytes.toBytes("qual1");
    final byte[] QUAL2=Bytes.toBytes("qual2");
    final byte[] QUAL3=Bytes.toBytes("qual3");
    final byte[] QUAL4=Bytes.toBytes("qual4");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    Delete d=new Delete(ONE_ROW);
    table.delete(d);
    Put put=new Put(ONE_ROW);
    put.addColumn(BYTES_FAMILY,QUAL1,Bytes.toBytes("abc"));
    put.addColumn(BYTES_FAMILY,QUAL2,Bytes.toBytes(1L));
    table.put(put);
    Increment inc=new Increment(ONE_ROW);
    inc.addColumn(BYTES_FAMILY,QUAL2,1);
    inc.addColumn(BYTES_FAMILY,QUAL3,1);
    Append a=new Append(ONE_ROW);
    a.addColumn(BYTES_FAMILY,QUAL1,Bytes.toBytes("def"));
    a.addColumn(BYTES_FAMILY,QUAL4,Bytes.toBytes("xyz"));
    List<Row> actions=new ArrayList<>();
    actions.add(inc);
    actions.add(a);
    Object[] multiRes=new Object[actions.size()];
    table.batch(actions,multiRes);
    validateResult(multiRes[1],QUAL1,Bytes.toBytes("abcdef"));
    validateResult(multiRes[1],QUAL4,Bytes.toBytes("xyz"));
    validateResult(multiRes[0],QUAL2,Bytes.toBytes(2L));
    validateResult(multiRes[0],QUAL3,Bytes.toBytes(1L));
    table.close();
  }
  @Test public void testNonceCollision() throws Exception {
    LOG.info("test=testNonceCollision");
    final Connection connection=ConnectionFactory.createConnection(UTIL.getConfiguration());
    Table table=connection.getTable(TEST_TABLE);
    Put put=new Put(ONE_ROW);
    put.addColumn(BYTES_FAMILY,QUALIFIER,Bytes.toBytes(0L));
    NonceGenerator cnm=new NonceGenerator(){
      private final PerClientRandomNonceGenerator delegate=PerClientRandomNonceGenerator.get();
      private long lastNonce=-1;
      @Override public synchronized long newNonce(){
        long nonce=0;
        if (lastNonce == -1) {
          lastNonce=nonce=delegate.newNonce();
        }
 else {
          nonce=lastNonce;
          lastNonce=-1L;
        }
        return nonce;
      }
      @Override public long getNonceGroup(){
        return delegate.getNonceGroup();
      }
    }
;
    NonceGenerator oldCnm=ConnectionUtils.injectNonceGeneratorForTesting((ClusterConnection)connection,cnm);
    try {
      Increment inc=new Increment(ONE_ROW);
      inc.addColumn(BYTES_FAMILY,QUALIFIER,1L);
      table.increment(inc);
      inc=new Increment(ONE_ROW);
      inc.addColumn(BYTES_FAMILY,QUALIFIER,1L);
      Result result=table.increment(inc);
      validateResult(result,QUALIFIER,Bytes.toBytes(1L));
      Get get=new Get(ONE_ROW);
      get.addColumn(BYTES_FAMILY,QUALIFIER);
      result=table.get(get);
      validateResult(result,QUALIFIER,Bytes.toBytes(1L));
      int numRequests=40;
      final CountDownLatch startedLatch=new CountDownLatch(numRequests);
      final CountDownLatch startLatch=new CountDownLatch(1);
      final CountDownLatch doneLatch=new CountDownLatch(numRequests);
      for (int i=0; i < numRequests; ++i) {
        Runnable r=new Runnable(){
          @Override public void run(){
            Table table=null;
            try {
              table=connection.getTable(TEST_TABLE);
            }
 catch (            IOException e) {
              fail("Not expected");
            }
            Increment inc=new Increment(ONE_ROW);
            inc.addColumn(BYTES_FAMILY,QUALIFIER,1L);
            startedLatch.countDown();
            try {
              startLatch.await();
            }
 catch (            InterruptedException e) {
              fail("Not expected");
            }
            try {
              table.increment(inc);
            }
 catch (            IOException ioEx) {
              fail("Not expected");
            }
            doneLatch.countDown();
          }
        }
;
        Threads.setDaemonThreadRunning(new Thread(r));
      }
      startedLatch.await();
      startLatch.countDown();
      doneLatch.await();
      get=new Get(ONE_ROW);
      get.addColumn(BYTES_FAMILY,QUALIFIER);
      result=table.get(get);
      validateResult(result,QUALIFIER,Bytes.toBytes((numRequests / 2) + 1L));
      table.close();
    }
  finally {
      ConnectionImplementation.injectNonceGeneratorForTesting((ClusterConnection)connection,oldCnm);
    }
  }
  @Test public void testBatchWithMixedActions() throws Exception {
    LOG.info("test=testBatchWithMixedActions");
    Table table=UTIL.getConnection().getTable(TEST_TABLE);
    List<Put> puts=constructPutRequests();
    Object[] results=new Object[puts.size()];
    table.batch(puts,results);
    validateSizeAndEmpty(results,KEYS.length);
    List<Row> actions=new ArrayList<>();
    byte[] qual2=Bytes.toBytes("qual2");
    byte[] val2=Bytes.toBytes("putvalue2");
    Get get=new Get(KEYS[10]);
    get.addColumn(BYTES_FAMILY,QUALIFIER);
    actions.add(get);
    get=new Get(KEYS[11]);
    get.addColumn(BYTES_FAMILY,QUALIFIER);
    actions.add(get);
    Put put=new Put(KEYS[10]);
    put.addColumn(BYTES_FAMILY,qual2,val2);
    actions.add(put);
    Delete delete=new Delete(KEYS[20]);
    delete.addFamily(BYTES_FAMILY);
    actions.add(delete);
    get=new Get(KEYS[30]);
    get.addColumn(BYTES_FAMILY,QUALIFIER);
    actions.add(get);
    put=new Put(KEYS[40]);
    put.addColumn(BYTES_FAMILY,qual2,val2);
    actions.add(put);
    RowMutations rm=new RowMutations(KEYS[50]);
    put=new Put(KEYS[50]);
    put.addColumn(BYTES_FAMILY,qual2,val2);
    rm.add((Mutation)put);
    byte[] qual3=Bytes.toBytes("qual3");
    byte[] val3=Bytes.toBytes("putvalue3");
    put=new Put(KEYS[50]);
    put.addColumn(BYTES_FAMILY,qual3,val3);
    rm.add((Mutation)put);
    actions.add(rm);
    get=new Get(KEYS[10]);
    get.addColumn(BYTES_FAMILY,QUALIFIER);
    actions.add(get);
    results=new Object[actions.size()];
    table.batch(actions,results);
    validateResult(results[0]);
    validateResult(results[1]);
    validateEmpty(results[3]);
    validateResult(results[4]);
    validateEmpty(results[5]);
    validateEmpty(results[6]);
    validateResult(results[7]);
    get=new Get(KEYS[40]);
    get.addColumn(BYTES_FAMILY,qual2);
    Result r=table.get(get);
    validateResult(r,qual2,val2);
    get=new Get(KEYS[50]);
    get.addColumn(BYTES_FAMILY,qual2);
    r=table.get(get);
    validateResult(r,qual2,val2);
    get=new Get(KEYS[50]);
    get.addColumn(BYTES_FAMILY,qual3);
    r=table.get(get);
    validateResult(r,qual3,val3);
    table.close();
  }
  private void validateResult(  Object r){
    validateResult(r,QUALIFIER,VALUE);
  }
  private void validateResult(  Object r1,  byte[] qual,  byte[] val){
    Result r=(Result)r1;
    Assert.assertTrue(r.containsColumn(BYTES_FAMILY,qual));
    byte[] value=r.getValue(BYTES_FAMILY,qual);
    if (0 != Bytes.compareTo(val,value)) {
      fail("Expected [" + Bytes.toStringBinary(val) + "] but got ["+ Bytes.toStringBinary(value)+ "]");
    }
  }
  private List<Put> constructPutRequests(){
    List<Put> puts=new ArrayList<>();
    for (    byte[] k : KEYS) {
      Put put=new Put(k);
      put.addColumn(BYTES_FAMILY,QUALIFIER,VALUE);
      puts.add(put);
    }
    return puts;
  }
  private void validateLoadedData(  Table table) throws IOException {
    LOG.info("Validating data on " + table);
    List<Get> gets=new ArrayList<>();
    for (    byte[] k : KEYS) {
      Get get=new Get(k);
      get.addColumn(BYTES_FAMILY,QUALIFIER);
      gets.add(get);
    }
    int retryNum=10;
    Result[] results=null;
    do {
      results=table.get(gets);
      boolean finished=true;
      for (      Result result : results) {
        if (result.isEmpty()) {
          finished=false;
          break;
        }
      }
      if (finished) {
        break;
      }
      try {
        Thread.sleep(10);
      }
 catch (      InterruptedException e) {
      }
      retryNum--;
    }
 while (retryNum > 0);
    if (retryNum == 0) {
      fail("Timeout for validate data");
    }
 else {
      if (results != null) {
        for (        Result r : results) {
          Assert.assertTrue(r.containsColumn(BYTES_FAMILY,QUALIFIER));
          Assert.assertEquals(0,Bytes.compareTo(VALUE,r.getValue(BYTES_FAMILY,QUALIFIER)));
        }
        LOG.info("Validating data on " + table + " successfully!");
      }
    }
  }
  private void validateEmpty(  Object r1){
    Result result=(Result)r1;
    Assert.assertTrue(result != null);
    Assert.assertTrue(result.isEmpty());
  }
  private void validateSizeAndEmpty(  Object[] results,  int expectedSize){
    Assert.assertEquals(expectedSize,results.length);
    for (    Object result : results) {
      validateEmpty(result);
    }
  }
public static class MyMasterObserver implements MasterObserver, MasterCoprocessor {
    private static final AtomicInteger postBalanceCount=new AtomicInteger(0);
    private static final AtomicBoolean start=new AtomicBoolean(false);
    @Override public void start(    CoprocessorEnvironment env) throws IOException {
      start.set(true);
    }
    @Override public Optional<MasterObserver> getMasterObserver(){
      return Optional.of(this);
    }
    @Override public void postBalance(    final ObserverContext<MasterCoprocessorEnvironment> ctx,    List<RegionPlan> plans) throws IOException {
      if (!plans.isEmpty()) {
        postBalanceCount.incrementAndGet();
      }
    }
  }
}
