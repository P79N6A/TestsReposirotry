/** 
 * Test our testing utility class
 */
@Category({MiscTests.class,LargeTests.class}) public class TestHBaseTestingUtility {
  private static final int NUMTABLES=1;
  private static final int NUMROWS=100;
  private static final int NUMREGIONS=10;
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestHBaseTestingUtility.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestHBaseTestingUtility.class);
  @Rule public TestName name=new TestName();
  /** 
 * Basic sanity test that spins up multiple HDFS and HBase clusters that share the same ZK ensemble. We then create the same table in both and make sure that what we insert in one place doesn't end up in the other.
 * @throws Exception
 */
  @Test public void testMultiClusters() throws Exception {
    HBaseTestingUtility htu1=new HBaseTestingUtility();
    htu1.getConfiguration().set(HConstants.ZOOKEEPER_ZNODE_PARENT,"/1");
    htu1.startMiniZKCluster();
    HBaseTestingUtility htu2=new HBaseTestingUtility();
    htu2.getConfiguration().set(HConstants.ZOOKEEPER_ZNODE_PARENT,"/2");
    htu2.getConfiguration().set(HConstants.ZOOKEEPER_CLIENT_PORT,htu1.getConfiguration().get(HConstants.ZOOKEEPER_CLIENT_PORT,"-1"));
    htu2.setZkCluster(htu1.getZkCluster());
    HBaseTestingUtility htu3=new HBaseTestingUtility();
    htu3.getConfiguration().set(HConstants.ZOOKEEPER_ZNODE_PARENT,"/3");
    htu3.getConfiguration().set(HConstants.ZOOKEEPER_CLIENT_PORT,htu1.getConfiguration().get(HConstants.ZOOKEEPER_CLIENT_PORT,"-1"));
    htu3.setZkCluster(htu1.getZkCluster());
    try {
      htu1.startMiniCluster();
      htu2.startMiniCluster();
      htu3.startMiniCluster();
      final TableName tableName=TableName.valueOf(name.getMethodName());
      final byte[] FAM_NAME=Bytes.toBytes("fam");
      final byte[] ROW=Bytes.toBytes("row");
      final byte[] QUAL_NAME=Bytes.toBytes("qual");
      final byte[] VALUE=Bytes.toBytes("value");
      Table table1=htu1.createTable(tableName,FAM_NAME);
      Table table2=htu2.createTable(tableName,FAM_NAME);
      Put put=new Put(ROW);
      put.addColumn(FAM_NAME,QUAL_NAME,VALUE);
      table1.put(put);
      Get get=new Get(ROW);
      get.addColumn(FAM_NAME,QUAL_NAME);
      Result res=table1.get(get);
      assertEquals(1,res.size());
      res=table2.get(get);
      assertEquals(0,res.size());
      table1.close();
      table2.close();
    }
  finally {
      htu3.shutdownMiniCluster();
      htu2.shutdownMiniCluster();
      htu1.shutdownMiniCluster();
    }
  }
  @Test public void testMiniCluster() throws Exception {
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    MiniHBaseCluster cluster=hbt.startMiniCluster();
    try {
      assertEquals(1,cluster.getLiveRegionServerThreads().size());
    }
  finally {
      hbt.shutdownMiniCluster();
    }
  }
  @Test public void testMiniClusterBindToWildcard() throws Exception {
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    hbt.getConfiguration().set("hbase.regionserver.ipc.address","0.0.0.0");
    MiniHBaseCluster cluster=hbt.startMiniCluster();
    try {
      assertEquals(1,cluster.getLiveRegionServerThreads().size());
    }
  finally {
      hbt.shutdownMiniCluster();
    }
  }
  @Test public void testMiniClusterWithSSLOn() throws Exception {
    final String BASEDIR=System.getProperty("test.build.dir","target/test-dir") + "/" + TestHBaseTestingUtility.class.getSimpleName();
    String sslConfDir=KeyStoreTestUtil.getClasspathDir(TestHBaseTestingUtility.class);
    String keystoresDir=new File(BASEDIR).getAbsolutePath();
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    File base=new File(BASEDIR);
    FileUtil.fullyDelete(base);
    base.mkdirs();
    KeyStoreTestUtil.setupSSLConfig(keystoresDir,sslConfDir,hbt.getConfiguration(),false);
    hbt.getConfiguration().set("hbase.ssl.enabled","true");
    hbt.getConfiguration().addResource("ssl-server.xml");
    hbt.getConfiguration().addResource("ssl-client.xml");
    MiniHBaseCluster cluster=hbt.startMiniCluster();
    try {
      assertEquals(1,cluster.getLiveRegionServerThreads().size());
    }
  finally {
      hbt.shutdownMiniCluster();
    }
  }
  /** 
 * Test that we can start and stop multiple time a cluster with the same HBaseTestingUtility.
 */
  @Test public void testMultipleStartStop() throws Exception {
    HBaseTestingUtility htu1=new HBaseTestingUtility();
    Path foo=new Path("foo");
    htu1.startMiniCluster();
    htu1.getDFSCluster().getFileSystem().create(foo);
    assertTrue(htu1.getDFSCluster().getFileSystem().exists(foo));
    htu1.shutdownMiniCluster();
    htu1.startMiniCluster();
    assertFalse(htu1.getDFSCluster().getFileSystem().exists(foo));
    htu1.getDFSCluster().getFileSystem().create(foo);
    assertTrue(htu1.getDFSCluster().getFileSystem().exists(foo));
    htu1.shutdownMiniCluster();
  }
  @Test public void testMiniZooKeeperWithOneServer() throws Exception {
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    MiniZooKeeperCluster cluster1=hbt.startMiniZKCluster();
    try {
      assertEquals(0,cluster1.getBackupZooKeeperServerNum());
      assertTrue((cluster1.killCurrentActiveZooKeeperServer() == -1));
    }
  finally {
      hbt.shutdownMiniZKCluster();
    }
  }
  @Test public void testMiniZooKeeperWithMultipleServers() throws Exception {
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    MiniZooKeeperCluster cluster2=hbt.startMiniZKCluster(5);
    int defaultClientPort=21818;
    cluster2.setDefaultClientPort(defaultClientPort);
    try {
      assertEquals(4,cluster2.getBackupZooKeeperServerNum());
      int currentActivePort=cluster2.killCurrentActiveZooKeeperServer();
      assertTrue(currentActivePort >= defaultClientPort);
      assertTrue(cluster2.getClientPort() == currentActivePort);
      currentActivePort=cluster2.killCurrentActiveZooKeeperServer();
      assertTrue(currentActivePort >= defaultClientPort);
      assertTrue(cluster2.getClientPort() == currentActivePort);
      assertEquals(2,cluster2.getBackupZooKeeperServerNum());
      assertEquals(3,cluster2.getZooKeeperServerNum());
      cluster2.killOneBackupZooKeeperServer();
      cluster2.killOneBackupZooKeeperServer();
      assertEquals(0,cluster2.getBackupZooKeeperServerNum());
      assertEquals(1,cluster2.getZooKeeperServerNum());
      currentActivePort=cluster2.killCurrentActiveZooKeeperServer();
      assertTrue(currentActivePort == -1);
      assertTrue(cluster2.getClientPort() == currentActivePort);
      cluster2.killOneBackupZooKeeperServer();
      assertEquals(-1,cluster2.getBackupZooKeeperServerNum());
      assertEquals(0,cluster2.getZooKeeperServerNum());
    }
  finally {
      hbt.shutdownMiniZKCluster();
    }
  }
  @Test public void testMiniZooKeeperWithMultipleClientPorts() throws Exception {
    int defaultClientPort=8888;
    int i, j;
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    int[] clientPortList1={1111,1112,1113};
    MiniZooKeeperCluster cluster1=hbt.startMiniZKCluster(clientPortList1.length,clientPortList1);
    try {
      List<Integer> clientPortListInCluster=cluster1.getClientPortList();
      for (i=0; i < clientPortListInCluster.size(); i++) {
        assertEquals(clientPortListInCluster.get(i).intValue(),clientPortList1[i]);
      }
    }
  finally {
      hbt.shutdownMiniZKCluster();
    }
    hbt.getConfiguration().setInt("test.hbase.zookeeper.property.clientPort",defaultClientPort);
    int[] clientPortList2={2222,2223};
    MiniZooKeeperCluster cluster2=hbt.startMiniZKCluster(clientPortList2.length + 2,clientPortList2);
    try {
      List<Integer> clientPortListInCluster=cluster2.getClientPortList();
      for (i=0, j=0; i < clientPortListInCluster.size(); i++) {
        if (i < clientPortList2.length) {
          assertEquals(clientPortListInCluster.get(i).intValue(),clientPortList2[i]);
        }
 else {
          assertEquals(clientPortListInCluster.get(i).intValue(),defaultClientPort + j);
          j++;
        }
      }
    }
  finally {
      hbt.shutdownMiniZKCluster();
    }
    hbt.getConfiguration().setInt("test.hbase.zookeeper.property.clientPort",defaultClientPort);
    int[] clientPortList3={3333,-3334,3335,0};
    MiniZooKeeperCluster cluster3=hbt.startMiniZKCluster(clientPortList3.length + 1,clientPortList3);
    try {
      List<Integer> clientPortListInCluster=cluster3.getClientPortList();
      for (i=0, j=0; i < clientPortListInCluster.size(); i++) {
        if (i < clientPortList3.length && clientPortList3[i] > 0) {
          assertEquals(clientPortListInCluster.get(i).intValue(),clientPortList3[i]);
        }
 else {
          assertEquals(clientPortListInCluster.get(i).intValue(),defaultClientPort + j);
          j++;
        }
      }
    }
  finally {
      hbt.shutdownMiniZKCluster();
    }
    hbt.getConfiguration().setInt("test.hbase.zookeeper.property.clientPort",defaultClientPort);
    int[] clientPortList4={-4444,defaultClientPort + 2,4446,defaultClientPort};
    MiniZooKeeperCluster cluster4=hbt.startMiniZKCluster(clientPortList4.length + 1,clientPortList4);
    try {
      List<Integer> clientPortListInCluster=cluster4.getClientPortList();
      for (i=0, j=1; i < clientPortListInCluster.size(); i++) {
        if (i < clientPortList4.length && clientPortList4[i] > 0) {
          assertEquals(clientPortListInCluster.get(i).intValue(),clientPortList4[i]);
        }
 else {
          assertEquals(clientPortListInCluster.get(i).intValue(),defaultClientPort + j);
          j+=2;
        }
      }
    }
  finally {
      hbt.shutdownMiniZKCluster();
    }
    int[] clientPortList5={5555,5556,5556};
    try {
      MiniZooKeeperCluster cluster5=hbt.startMiniZKCluster(clientPortList5.length,clientPortList5);
      assertTrue(cluster5.getClientPort() == -1);
    }
 catch (    Exception e) {
    }
 finally {
      hbt.shutdownMiniZKCluster();
    }
  }
  @Test public void testMiniDFSCluster() throws Exception {
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    MiniDFSCluster cluster=hbt.startMiniDFSCluster(null);
    FileSystem dfs=cluster.getFileSystem();
    Path dir=new Path("dir");
    Path qualifiedDir=dfs.makeQualified(dir);
    LOG.info("dir=" + dir + ", qualifiedDir="+ qualifiedDir);
    assertFalse(dfs.exists(qualifiedDir));
    assertTrue(dfs.mkdirs(qualifiedDir));
    assertTrue(dfs.delete(qualifiedDir,true));
    hbt.shutdownMiniCluster();
  }
  @Test public void testSetupClusterTestBuildDir() throws Exception {
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    Path testdir=hbt.getClusterTestDir();
    LOG.info("uuid-subdir=" + testdir);
    FileSystem fs=hbt.getTestFileSystem();
    assertFalse(fs.exists(testdir));
    hbt.startMiniDFSCluster(null);
    assertTrue(fs.exists(testdir));
    hbt.shutdownMiniCluster();
    assertFalse(fs.exists(testdir));
  }
  @Test public void testTestDir() throws Exception {
    HBaseTestingUtility hbt=new HBaseTestingUtility();
    Path testdir=hbt.getDataTestDir();
    LOG.info("testdir=" + testdir);
    FileSystem fs=hbt.getTestFileSystem();
    assertTrue(!fs.exists(testdir));
    assertTrue(fs.mkdirs(testdir));
    assertTrue(hbt.cleanupTestDir());
  }
  @Test public void testResolvePortConflict() throws Exception {
    Random random=mock(Random.class);
    when(random.nextInt(anyInt())).thenAnswer(new Answer<Integer>(){
      int[] numbers={1,1,2};
      int count=0;
      @Override public Integer answer(      InvocationOnMock invocation){
        int ret=numbers[count];
        count++;
        return ret;
      }
    }
);
    HBaseTestingUtility.PortAllocator.AvailablePortChecker portChecker=mock(HBaseTestingUtility.PortAllocator.AvailablePortChecker.class);
    when(portChecker.available(anyInt())).thenReturn(true);
    HBaseTestingUtility.PortAllocator portAllocator=new HBaseTestingUtility.PortAllocator(random,portChecker);
    int port1=portAllocator.randomFreePort();
    int port2=portAllocator.randomFreePort();
    assertNotEquals(port1,port2);
    Mockito.verify(random,Mockito.times(3)).nextInt(anyInt());
  }
  @Test public void testOverridingOfDefaultPorts() throws Exception {
    Configuration defaultConfig=HBaseConfiguration.create();
    defaultConfig.setInt(HConstants.MASTER_INFO_PORT,HConstants.DEFAULT_MASTER_INFOPORT);
    defaultConfig.setInt(HConstants.REGIONSERVER_INFO_PORT,HConstants.DEFAULT_REGIONSERVER_INFOPORT);
    HBaseTestingUtility htu=new HBaseTestingUtility(defaultConfig);
    try {
      MiniHBaseCluster defaultCluster=htu.startMiniCluster();
      assertNotEquals(HConstants.DEFAULT_MASTER_INFOPORT,defaultCluster.getConfiguration().getInt(HConstants.MASTER_INFO_PORT,0));
      assertNotEquals(HConstants.DEFAULT_REGIONSERVER_INFOPORT,defaultCluster.getConfiguration().getInt(HConstants.REGIONSERVER_INFO_PORT,0));
    }
  finally {
      htu.shutdownMiniCluster();
    }
    Configuration altConfig=HBaseConfiguration.create();
    final int nonDefaultMasterInfoPort=3333;
    final int nonDefaultRegionServerPort=4444;
    altConfig.setInt(HConstants.MASTER_INFO_PORT,nonDefaultMasterInfoPort);
    altConfig.setInt(HConstants.REGIONSERVER_INFO_PORT,nonDefaultRegionServerPort);
    htu=new HBaseTestingUtility(altConfig);
    try {
      MiniHBaseCluster customCluster=htu.startMiniCluster();
      assertEquals(nonDefaultMasterInfoPort,customCluster.getConfiguration().getInt(HConstants.MASTER_INFO_PORT,0));
      assertEquals(nonDefaultRegionServerPort,customCluster.getConfiguration().getInt(HConstants.REGIONSERVER_INFO_PORT,0));
    }
  finally {
      htu.shutdownMiniCluster();
    }
  }
  @Test public void testKillMiniHBaseCluster() throws Exception {
    HBaseTestingUtility htu=new HBaseTestingUtility();
    htu.startMiniZKCluster();
    try {
      htu.startMiniHBaseCluster(1,1);
      TableName tableName;
      byte[] FAM_NAME;
      for (int i=0; i < NUMTABLES; i++) {
        tableName=TableName.valueOf(name.getMethodName() + i);
        FAM_NAME=Bytes.toBytes("fam" + i);
        try (Table table=htu.createMultiRegionTable(tableName,FAM_NAME,NUMREGIONS)){
          htu.loadRandomRows(table,FAM_NAME,100,NUMROWS);
        }
       }
    }
  finally {
      htu.killMiniHBaseCluster();
      htu.shutdownMiniZKCluster();
    }
  }
}
