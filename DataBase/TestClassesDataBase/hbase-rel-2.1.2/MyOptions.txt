private static class MyOptions {
  int dictSize=1000;
  int minWordLen=5;
  int maxWordLen=20;
  private HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  String rootDir=TEST_UTIL.getDataTestDir("TestTFileSeek").toString();
  String file="TestTFileSeek";
  String compress="none";
  int minKeyLen=10;
  int maxKeyLen=50;
  int minValLength=1024;
  int maxValLength=2 * 1024;
  int minBlockSize=1 * 1024 * 1024;
  int fsOutputBufferSize=1;
  int fsInputBufferSize=0;
  long fileSize=10 * 1024 * 1024;
  long seekCount=1000;
  long trialCount=1;
  long seed;
  boolean useRawFs=false;
  static final int OP_CREATE=1;
  static final int OP_READ=2;
  int op=OP_CREATE | OP_READ;
  boolean proceed=false;
  public MyOptions(  String[] args){
    seed=System.nanoTime();
    try {
      Options opts=buildOptions();
      CommandLineParser parser=new GnuParser();
      CommandLine line=parser.parse(opts,args,true);
      processOptions(line,opts);
      validateOptions();
    }
 catch (    ParseException e) {
      System.out.println(e.getMessage());
      System.out.println("Try \"--help\" option for details.");
      setStopProceed();
    }
  }
  public boolean proceed(){
    return proceed;
  }
  private Options buildOptions(){
    Option compress=OptionBuilder.withLongOpt("compress").withArgName("[none|lzo|gz|snappy]").hasArg().withDescription("compression scheme").create('c');
    Option fileSize=OptionBuilder.withLongOpt("file-size").withArgName("size-in-MB").hasArg().withDescription("target size of the file (in MB).").create('s');
    Option fsInputBufferSz=OptionBuilder.withLongOpt("fs-input-buffer").withArgName("size").hasArg().withDescription("size of the file system input buffer (in bytes).").create('i');
    Option fsOutputBufferSize=OptionBuilder.withLongOpt("fs-output-buffer").withArgName("size").hasArg().withDescription("size of the file system output buffer (in bytes).").create('o');
    Option keyLen=OptionBuilder.withLongOpt("key-length").withArgName("min,max").hasArg().withDescription("the length range of the key (in bytes)").create('k');
    Option valueLen=OptionBuilder.withLongOpt("value-length").withArgName("min,max").hasArg().withDescription("the length range of the value (in bytes)").create('v');
    Option blockSz=OptionBuilder.withLongOpt("block").withArgName("size-in-KB").hasArg().withDescription("minimum block size (in KB)").create('b');
    Option operation=OptionBuilder.withLongOpt("operation").withArgName("r|w|rw").hasArg().withDescription("action: seek-only, create-only, seek-after-create").create('x');
    Option rootDir=OptionBuilder.withLongOpt("root-dir").withArgName("path").hasArg().withDescription("specify root directory where files will be created.").create('r');
    Option file=OptionBuilder.withLongOpt("file").withArgName("name").hasArg().withDescription("specify the file name to be created or read.").create('f');
    Option seekCount=OptionBuilder.withLongOpt("seek").withArgName("count").hasArg().withDescription("specify how many seek operations we perform (requires -x r or -x rw.").create('n');
    Option trialCount=OptionBuilder.withLongOpt("trials").withArgName("n").hasArg().withDescription("specify how many times to run the whole benchmark").create('t');
    Option useRawFs=OptionBuilder.withLongOpt("rawfs").withDescription("use raw instead of checksummed file system").create();
    Option help=OptionBuilder.withLongOpt("help").hasArg(false).withDescription("show this screen").create("h");
    return new Options().addOption(compress).addOption(fileSize).addOption(fsInputBufferSz).addOption(fsOutputBufferSize).addOption(keyLen).addOption(blockSz).addOption(rootDir).addOption(valueLen).addOption(operation).addOption(seekCount).addOption(file).addOption(trialCount).addOption(useRawFs).addOption(help);
  }
  private void processOptions(  CommandLine line,  Options opts) throws ParseException {
    if (line.hasOption('h')) {
      HelpFormatter formatter=new HelpFormatter();
      System.out.println("TFile and SeqFile benchmark.");
      System.out.println();
      formatter.printHelp(100,"java ... TestTFileSeqFileComparison [options]","\nSupported options:",opts,"");
      return;
    }
    if (line.hasOption('c')) {
      compress=line.getOptionValue('c');
    }
    if (line.hasOption('d')) {
      dictSize=Integer.parseInt(line.getOptionValue('d'));
    }
    if (line.hasOption('s')) {
      fileSize=Long.parseLong(line.getOptionValue('s')) * 1024 * 1024;
    }
    if (line.hasOption('i')) {
      fsInputBufferSize=Integer.parseInt(line.getOptionValue('i'));
    }
    if (line.hasOption('o')) {
      fsOutputBufferSize=Integer.parseInt(line.getOptionValue('o'));
    }
    if (line.hasOption('n')) {
      seekCount=Integer.parseInt(line.getOptionValue('n'));
    }
    if (line.hasOption('t')) {
      trialCount=Integer.parseInt(line.getOptionValue('t'));
    }
    if (line.hasOption('k')) {
      IntegerRange ir=IntegerRange.parse(line.getOptionValue('k'));
      minKeyLen=ir.from();
      maxKeyLen=ir.to();
    }
    if (line.hasOption('v')) {
      IntegerRange ir=IntegerRange.parse(line.getOptionValue('v'));
      minValLength=ir.from();
      maxValLength=ir.to();
    }
    if (line.hasOption('b')) {
      minBlockSize=Integer.parseInt(line.getOptionValue('b')) * 1024;
    }
    if (line.hasOption('r')) {
      rootDir=line.getOptionValue('r');
    }
    if (line.hasOption('f')) {
      file=line.getOptionValue('f');
    }
    if (line.hasOption('S')) {
      seed=Long.parseLong(line.getOptionValue('S'));
    }
    if (line.hasOption('x')) {
      String strOp=line.getOptionValue('x');
      if (strOp.equals("r")) {
        op=OP_READ;
      }
 else       if (strOp.equals("w")) {
        op=OP_CREATE;
      }
 else       if (strOp.equals("rw")) {
        op=OP_CREATE | OP_READ;
      }
 else {
        throw new ParseException("Unknown action specifier: " + strOp);
      }
    }
    useRawFs=line.hasOption("rawfs");
    proceed=true;
  }
  private void validateOptions() throws ParseException {
    if (!compress.equals("none") && !compress.equals("lzo") && !compress.equals("gz")&& !compress.equals("snappy")) {
      throw new ParseException("Unknown compression scheme: " + compress);
    }
    if (minKeyLen >= maxKeyLen) {
      throw new ParseException("Max key length must be greater than min key length.");
    }
    if (minValLength >= maxValLength) {
      throw new ParseException("Max value length must be greater than min value length.");
    }
    if (minWordLen >= maxWordLen) {
      throw new ParseException("Max word length must be greater than min word length.");
    }
    return;
  }
  private void setStopProceed(){
    proceed=false;
  }
  public boolean doCreate(){
    return (op & OP_CREATE) != 0;
  }
  public boolean doRead(){
    return (op & OP_READ) != 0;
  }
}
