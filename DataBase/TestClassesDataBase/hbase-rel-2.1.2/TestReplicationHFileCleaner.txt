@Category({MasterTests.class,SmallTests.class}) public class TestReplicationHFileCleaner {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestReplicationHFileCleaner.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestReplicationHFileCleaner.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static Server server;
  private static ReplicationQueueStorage rq;
  private static ReplicationPeers rp;
  private static final String peerId="TestReplicationHFileCleaner";
  private static Configuration conf=TEST_UTIL.getConfiguration();
  static FileSystem fs=null;
  Path root;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    TEST_UTIL.startMiniZKCluster();
    server=new DummyServer();
    conf.setBoolean(HConstants.REPLICATION_BULKLOAD_ENABLE_KEY,true);
    HMaster.decorateMasterConfiguration(conf);
    rp=ReplicationFactory.getReplicationPeers(server.getZooKeeper(),conf);
    rp.init();
    rq=ReplicationStorageFactory.getReplicationQueueStorage(server.getZooKeeper(),conf);
    fs=FileSystem.get(conf);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniZKCluster();
  }
  @Before public void setup() throws ReplicationException, IOException {
    root=TEST_UTIL.getDataTestDirOnTestFS();
    rp.getPeerStorage().addPeer(peerId,ReplicationPeerConfig.newBuilder().setClusterKey(TEST_UTIL.getClusterKey()).build(),true);
    rq.addPeerToHFileRefs(peerId);
  }
  @After public void cleanup() throws ReplicationException {
    try {
      fs.delete(root,true);
    }
 catch (    IOException e) {
      LOG.warn("Failed to delete files recursively from path " + root);
    }
    rp.getPeerStorage().removePeer(peerId);
  }
  @Test public void testIsFileDeletable() throws IOException, ReplicationException {
    Path file=new Path(root,"testIsFileDeletableWithNoHFileRefs");
    fs.createNewFile(file);
    assertTrue("Test file not created!",fs.exists(file));
    ReplicationHFileCleaner cleaner=new ReplicationHFileCleaner();
    cleaner.setConf(conf);
    assertTrue("Cleaner should allow to delete this file as there is no hfile reference node " + "for it in the queue.",cleaner.isFileDeletable(fs.getFileStatus(file)));
    List<Pair<Path,Path>> files=new ArrayList<>(1);
    files.add(new Pair<>(null,file));
    rq.addHFileRefs(peerId,files);
    assertFalse("Cleaner should not allow to delete this file as there is a hfile reference node " + "for it in the queue.",cleaner.isFileDeletable(fs.getFileStatus(file)));
  }
  @Test public void testGetDeletableFiles() throws Exception {
    Path notDeletablefile=new Path(root,"testGetDeletableFiles_1");
    fs.createNewFile(notDeletablefile);
    assertTrue("Test file not created!",fs.exists(notDeletablefile));
    Path deletablefile=new Path(root,"testGetDeletableFiles_2");
    fs.createNewFile(deletablefile);
    assertTrue("Test file not created!",fs.exists(deletablefile));
    List<FileStatus> files=new ArrayList<>(2);
    FileStatus f=new FileStatus();
    f.setPath(deletablefile);
    files.add(f);
    f=new FileStatus();
    f.setPath(notDeletablefile);
    files.add(f);
    List<Pair<Path,Path>> hfiles=new ArrayList<>(1);
    hfiles.add(new Pair<>(null,notDeletablefile));
    rq.addHFileRefs(peerId,hfiles);
    ReplicationHFileCleaner cleaner=new ReplicationHFileCleaner();
    cleaner.setConf(conf);
    Iterator<FileStatus> deletableFilesIterator=cleaner.getDeletableFiles(files).iterator();
    int i=0;
    while (deletableFilesIterator.hasNext() && i < 2) {
      i++;
    }
    if (i > 2) {
      fail("File " + notDeletablefile + " should not be deletable as its hfile reference node is not added.");
    }
    assertTrue(deletableFilesIterator.next().getPath().equals(deletablefile));
  }
  /** 
 * ReplicationHFileCleaner should be able to ride over ZooKeeper errors without aborting.
 */
  @Test public void testZooKeeperAbort() throws Exception {
    ReplicationHFileCleaner cleaner=new ReplicationHFileCleaner();
    List<FileStatus> dummyFiles=Lists.newArrayList(new FileStatus(100,false,3,100,System.currentTimeMillis(),new Path("hfile1")),new FileStatus(100,false,3,100,System.currentTimeMillis(),new Path("hfile2")));
    FaultyZooKeeperWatcher faultyZK=new FaultyZooKeeperWatcher(conf,"testZooKeeperAbort-faulty",null);
    try {
      faultyZK.init();
      cleaner.setConf(conf,faultyZK);
      Iterable<FileStatus> toDelete=cleaner.getDeletableFiles(dummyFiles);
      assertFalse(toDelete.iterator().hasNext());
      assertFalse(cleaner.isStopped());
    }
  finally {
      faultyZK.close();
    }
    cleaner=new ReplicationHFileCleaner();
    ZKWatcher zkw=new ZKWatcher(conf,"testZooKeeperAbort-normal",null);
    try {
      cleaner.setConf(conf,zkw);
      Iterable<FileStatus> filesToDelete=cleaner.getDeletableFiles(dummyFiles);
      Iterator<FileStatus> iter=filesToDelete.iterator();
      assertTrue(iter.hasNext());
      assertEquals(new Path("hfile1"),iter.next().getPath());
      assertTrue(iter.hasNext());
      assertEquals(new Path("hfile2"),iter.next().getPath());
      assertFalse(iter.hasNext());
    }
  finally {
      zkw.close();
    }
  }
static class DummyServer implements Server {
    @Override public Configuration getConfiguration(){
      return TEST_UTIL.getConfiguration();
    }
    @Override public ZKWatcher getZooKeeper(){
      try {
        return new ZKWatcher(getConfiguration(),"dummy server",this);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
      return null;
    }
    @Override public CoordinatedStateManager getCoordinatedStateManager(){
      return null;
    }
    @Override public ClusterConnection getConnection(){
      return null;
    }
    @Override public MetaTableLocator getMetaTableLocator(){
      return null;
    }
    @Override public ServerName getServerName(){
      return ServerName.valueOf("regionserver,60020,000000");
    }
    @Override public void abort(    String why,    Throwable e){
    }
    @Override public boolean isAborted(){
      return false;
    }
    @Override public void stop(    String why){
    }
    @Override public boolean isStopped(){
      return false;
    }
    @Override public ChoreService getChoreService(){
      return null;
    }
    @Override public ClusterConnection getClusterConnection(){
      return null;
    }
    @Override public FileSystem getFileSystem(){
      return null;
    }
    @Override public boolean isStopping(){
      return false;
    }
    @Override public Connection createConnection(    Configuration conf) throws IOException {
      return null;
    }
  }
static class FaultyZooKeeperWatcher extends ZKWatcher {
    private RecoverableZooKeeper zk;
    public FaultyZooKeeperWatcher(    Configuration conf,    String identifier,    Abortable abortable) throws ZooKeeperConnectionException, IOException {
      super(conf,identifier,abortable);
    }
    public void init() throws Exception {
      this.zk=spy(super.getRecoverableZooKeeper());
      doThrow(new KeeperException.ConnectionLossException()).when(zk).getData("/hbase/replication/hfile-refs",null,new Stat());
    }
    @Override public RecoverableZooKeeper getRecoverableZooKeeper(){
      return zk;
    }
  }
}
