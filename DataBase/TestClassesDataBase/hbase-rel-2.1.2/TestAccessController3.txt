/** 
 * Performs checks for reference counting w.r.t. TableAuthManager which is used by AccessController. NOTE: Only one test in  here. In AMv2, there is problem deleting because we are missing auth. For now disabled. See the cleanup method.
 */
@Category({SecurityTests.class,MediumTests.class}) public class TestAccessController3 extends SecureTestUtil {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestAccessController3.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestAccessController.class);
  private static TableName TEST_TABLE=TableName.valueOf("testtable1");
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static Configuration conf;
  /** 
 * The systemUserConnection created here is tied to the system user. In case, you are planning to create AccessTestAction, DON'T use this systemUserConnection as the 'doAs' user gets  eclipsed by the system user. 
 */
  private static Connection systemUserConnection;
  private static User SUPERUSER;
  private static User USER_ADMIN;
  private static User USER_RW;
  private static User USER_RO;
  private static User USER_OWNER;
  private static User USER_CREATE;
  private static User USER_NONE;
  private static User USER_ADMIN_CF;
  private static final String GROUP_ADMIN="group_admin";
  private static final String GROUP_CREATE="group_create";
  private static final String GROUP_READ="group_read";
  private static final String GROUP_WRITE="group_write";
  private static User USER_GROUP_ADMIN;
  private static User USER_GROUP_CREATE;
  private static User USER_GROUP_READ;
  private static User USER_GROUP_WRITE;
  private static byte[] TEST_FAMILY=Bytes.toBytes("f1");
  private static MasterCoprocessorEnvironment CP_ENV;
  private static AccessController ACCESS_CONTROLLER;
  private static RegionServerCoprocessorEnvironment RSCP_ENV;
  private static RegionCoprocessorEnvironment RCP_ENV;
  private static boolean callSuperTwice=true;
  @Rule public TestName name=new TestName();
public static class FaultyAccessController extends AccessController {
    public FaultyAccessController(){
    }
    @Override public void stop(    CoprocessorEnvironment env){
      super.stop(env);
      if (callSuperTwice) {
        super.stop(env);
      }
    }
  }
  @BeforeClass public static void setupBeforeClass() throws Exception {
    conf=TEST_UTIL.getConfiguration();
    enableSecurity(conf);
    String accessControllerClassName=FaultyAccessController.class.getName();
    conf.set(CoprocessorHost.REGION_COPROCESSOR_CONF_KEY,accessControllerClassName);
    verifyConfiguration(conf);
    conf.setBoolean(AccessControlConstants.EXEC_PERMISSION_CHECKS_KEY,true);
    TEST_UTIL.startMiniCluster();
    MasterCoprocessorHost cpHost=TEST_UTIL.getMiniHBaseCluster().getMaster().getMasterCoprocessorHost();
    cpHost.load(FaultyAccessController.class,Coprocessor.PRIORITY_HIGHEST,conf);
    ACCESS_CONTROLLER=(AccessController)cpHost.findCoprocessor(accessControllerClassName);
    CP_ENV=cpHost.createEnvironment(ACCESS_CONTROLLER,Coprocessor.PRIORITY_HIGHEST,1,conf);
    RegionServerCoprocessorHost rsHost;
    do {
      rsHost=TEST_UTIL.getMiniHBaseCluster().getRegionServer(0).getRegionServerCoprocessorHost();
    }
 while (rsHost == null);
    RSCP_ENV=rsHost.createEnvironment(ACCESS_CONTROLLER,Coprocessor.PRIORITY_HIGHEST,1,conf);
    TEST_UTIL.waitUntilAllRegionsAssigned(AccessControlLists.ACL_TABLE_NAME);
    SUPERUSER=User.createUserForTesting(conf,"admin",new String[]{"supergroup"});
    USER_ADMIN=User.createUserForTesting(conf,"admin2",new String[0]);
    USER_RW=User.createUserForTesting(conf,"rwuser",new String[0]);
    USER_RO=User.createUserForTesting(conf,"rouser",new String[0]);
    USER_OWNER=User.createUserForTesting(conf,"owner",new String[0]);
    USER_CREATE=User.createUserForTesting(conf,"tbl_create",new String[0]);
    USER_NONE=User.createUserForTesting(conf,"nouser",new String[0]);
    USER_ADMIN_CF=User.createUserForTesting(conf,"col_family_admin",new String[0]);
    USER_GROUP_ADMIN=User.createUserForTesting(conf,"user_group_admin",new String[]{GROUP_ADMIN});
    USER_GROUP_CREATE=User.createUserForTesting(conf,"user_group_create",new String[]{GROUP_CREATE});
    USER_GROUP_READ=User.createUserForTesting(conf,"user_group_read",new String[]{GROUP_READ});
    USER_GROUP_WRITE=User.createUserForTesting(conf,"user_group_write",new String[]{GROUP_WRITE});
    systemUserConnection=TEST_UTIL.getConnection();
    setUpTableAndUserPermissions();
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    HRegionServer rs=null;
    for (    JVMClusterUtil.RegionServerThread thread : TEST_UTIL.getMiniHBaseCluster().getRegionServerThreads()) {
      rs=thread.getRegionServer();
    }
    cleanUp();
    TEST_UTIL.shutdownMiniCluster();
    assertTrue("region server should have aborted due to FaultyAccessController",rs.isAborted());
  }
  private static void setUpTableAndUserPermissions() throws Exception {
    HTableDescriptor htd=new HTableDescriptor(TEST_TABLE);
    HColumnDescriptor hcd=new HColumnDescriptor(TEST_FAMILY);
    hcd.setMaxVersions(100);
    htd.addFamily(hcd);
    htd.setOwner(USER_OWNER);
    createTable(TEST_UTIL,htd,new byte[][]{Bytes.toBytes("s")});
    HRegion region=TEST_UTIL.getHBaseCluster().getRegions(TEST_TABLE).get(0);
    RegionCoprocessorHost rcpHost=region.getCoprocessorHost();
    RCP_ENV=rcpHost.createEnvironment(ACCESS_CONTROLLER,Coprocessor.PRIORITY_HIGHEST,1,conf);
    grantGlobal(TEST_UTIL,USER_ADMIN.getShortName(),Permission.Action.ADMIN,Permission.Action.CREATE,Permission.Action.READ,Permission.Action.WRITE);
    grantOnTable(TEST_UTIL,USER_RW.getShortName(),TEST_TABLE,TEST_FAMILY,null,Permission.Action.READ,Permission.Action.WRITE);
    grantOnTable(TEST_UTIL,USER_CREATE.getShortName(),TEST_TABLE,null,null,Permission.Action.CREATE,Permission.Action.READ,Permission.Action.WRITE);
    grantOnTable(TEST_UTIL,USER_RO.getShortName(),TEST_TABLE,TEST_FAMILY,null,Permission.Action.READ);
    grantOnTable(TEST_UTIL,USER_ADMIN_CF.getShortName(),TEST_TABLE,TEST_FAMILY,null,Permission.Action.ADMIN,Permission.Action.CREATE);
    grantGlobal(TEST_UTIL,toGroupEntry(GROUP_ADMIN),Permission.Action.ADMIN);
    grantGlobal(TEST_UTIL,toGroupEntry(GROUP_CREATE),Permission.Action.CREATE);
    grantGlobal(TEST_UTIL,toGroupEntry(GROUP_READ),Permission.Action.READ);
    grantGlobal(TEST_UTIL,toGroupEntry(GROUP_WRITE),Permission.Action.WRITE);
    assertEquals(5,AccessControlLists.getTablePermissions(conf,TEST_TABLE).size());
    try {
      assertEquals(5,AccessControlClient.getUserPermissions(systemUserConnection,TEST_TABLE.toString()).size());
    }
 catch (    Throwable e) {
      LOG.error("error during call of AccessControlClient.getUserPermissions. ",e);
    }
  }
  private static void cleanUp() throws Exception {
    try {
      deleteTable(TEST_UTIL,TEST_TABLE);
    }
 catch (    TableNotFoundException ex) {
      LOG.info("Test deleted table " + TEST_TABLE);
    }
    assertEquals(0,AccessControlLists.getTablePermissions(conf,TEST_TABLE).size());
    assertEquals(0,AccessControlLists.getNamespacePermissions(conf,TEST_TABLE.getNamespaceAsString()).size());
  }
  @Test public void testTableCreate() throws Exception {
    AccessTestAction createTable=new AccessTestAction(){
      @Override public Object run() throws Exception {
        HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(name.getMethodName()));
        htd.addFamily(new HColumnDescriptor(TEST_FAMILY));
        ACCESS_CONTROLLER.preCreateTable(ObserverContextImpl.createAndPrepare(CP_ENV),htd,null);
        return null;
      }
    }
;
    verifyAllowed(createTable,SUPERUSER,USER_ADMIN,USER_GROUP_CREATE);
    verifyDenied(createTable,USER_CREATE,USER_RW,USER_RO,USER_NONE,USER_GROUP_ADMIN,USER_GROUP_READ,USER_GROUP_WRITE);
  }
}
