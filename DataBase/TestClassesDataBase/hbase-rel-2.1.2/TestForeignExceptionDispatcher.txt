/** 
 * Test that we propagate errors through an dispatcher exactly once via different failure injection mechanisms.
 */
@Category({MasterTests.class,SmallTests.class}) public class TestForeignExceptionDispatcher {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestForeignExceptionDispatcher.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestForeignExceptionDispatcher.class);
  /** 
 * Exception thrown from the test
 */
  final ForeignException EXTEXN=new ForeignException("FORTEST",new IllegalArgumentException("FORTEST"));
  final ForeignException EXTEXN2=new ForeignException("FORTEST2",new IllegalArgumentException("FORTEST2"));
  /** 
 * Tests that a dispatcher only dispatches only the first exception, and does not propagate subsequent exceptions.
 */
  @Test public void testErrorPropagation(){
    ForeignExceptionListener listener1=Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionListener listener2=Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionDispatcher dispatcher=new ForeignExceptionDispatcher();
    dispatcher.addListener(listener1);
    dispatcher.addListener(listener2);
    dispatcher.receive(EXTEXN);
    Mockito.verify(listener1,Mockito.times(1)).receive(EXTEXN);
    Mockito.verify(listener2,Mockito.times(1)).receive(EXTEXN);
    try {
      dispatcher.rethrowException();
      fail("Monitor should have thrown an exception after getting error.");
    }
 catch (    ForeignException ex) {
      assertTrue("Got an unexpected exception:" + ex,ex.getCause() == EXTEXN.getCause());
      LOG.debug("Got the testing exception!");
    }
    dispatcher.receive(EXTEXN2);
    Mockito.verify(listener1,Mockito.never()).receive(EXTEXN2);
    Mockito.verify(listener2,Mockito.never()).receive(EXTEXN2);
  }
  @Test public void testSingleDispatcherWithTimer(){
    ForeignExceptionListener listener1=Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionListener listener2=Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionDispatcher monitor=new ForeignExceptionDispatcher();
    monitor.addListener(listener1);
    monitor.addListener(listener2);
    TimeoutExceptionInjector timer=new TimeoutExceptionInjector(monitor,1000);
    timer.start();
    timer.trigger();
    assertTrue("Monitor didn't get timeout",monitor.hasException());
    Mockito.verify(listener1).receive(Mockito.any());
    Mockito.verify(listener2).receive(Mockito.any());
  }
  /** 
 * Test that the dispatcher can receive an error via the timer mechanism.
 */
  @Test public void testAttemptTimer(){
    ForeignExceptionListener listener1=Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionListener listener2=Mockito.mock(ForeignExceptionListener.class);
    ForeignExceptionDispatcher orchestrator=new ForeignExceptionDispatcher();
    orchestrator.addListener(listener1);
    orchestrator.addListener(listener2);
    TimeoutExceptionInjector timer=new TimeoutExceptionInjector(orchestrator,1000);
    timer.start();
    timer.trigger();
    Mockito.verify(listener1,Mockito.times(1)).receive(Mockito.any());
    Mockito.verify(listener2,Mockito.times(1)).receive(Mockito.any());
  }
}
