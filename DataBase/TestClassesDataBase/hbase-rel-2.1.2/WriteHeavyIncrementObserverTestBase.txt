public class WriteHeavyIncrementObserverTestBase {
  protected static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  protected static TableName NAME=TableName.valueOf("TestCP");
  protected static byte[] FAMILY=Bytes.toBytes("cf");
  protected static byte[] ROW=Bytes.toBytes("row");
  protected static byte[] CQ1=Bytes.toBytes("cq1");
  protected static byte[] CQ2=Bytes.toBytes("cq2");
  protected static Table TABLE;
  protected static long UPPER=1000;
  protected static int THREADS=10;
  @BeforeClass public static void setUp() throws Exception {
    UTIL.getConfiguration().setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,64 * 1024L);
    UTIL.getConfiguration().setLong("hbase.hregion.memstore.flush.size.limit",1024L);
    UTIL.startMiniCluster(3);
  }
  @AfterClass public static void tearDown() throws Exception {
    if (TABLE != null) {
      TABLE.close();
    }
    UTIL.shutdownMiniCluster();
  }
  private static void increment(  int sleepSteps) throws IOException {
    for (long i=1; i <= UPPER; i++) {
      TABLE.increment(new Increment(ROW).addColumn(FAMILY,CQ1,i).addColumn(FAMILY,CQ2,2 * i));
      if (sleepSteps > 0 && i % sleepSteps == 0) {
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
  protected final void assertSum() throws IOException {
    Result result=TABLE.get(new Get(ROW).addColumn(FAMILY,CQ1).addColumn(FAMILY,CQ2));
    assertEquals(THREADS * (1 + UPPER) * UPPER / 2,Bytes.toLong(result.getValue(FAMILY,CQ1)));
    assertEquals(THREADS * (1 + UPPER) * UPPER,Bytes.toLong(result.getValue(FAMILY,CQ2)));
  }
  protected final void doIncrement(  int sleepSteps) throws InterruptedException {
    Thread[] threads=IntStream.range(0,THREADS).mapToObj(i -> new Thread(() -> {
      try {
        increment(sleepSteps);
      }
 catch (      IOException e) {
        throw new UncheckedIOException(e);
      }
    }
,"increment-" + i)).toArray(Thread[]::new);
    for (    Thread thread : threads) {
      thread.start();
    }
    for (    Thread thread : threads) {
      thread.join();
    }
  }
}
