@Category({MasterTests.class,LargeTests.class}) public class TestDeleteColumnFamilyProcedureFromClient {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestDeleteColumnFamilyProcedureFromClient.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final TableName TABLENAME=TableName.valueOf("column_family_handlers");
  private static final byte[][] FAMILIES=new byte[][]{Bytes.toBytes("cf1"),Bytes.toBytes("cf2"),Bytes.toBytes("cf3")};
  /** 
 * Start up a mini cluster and put a small table of empty regions into it.
 * @throws Exception
 */
  @BeforeClass public static void beforeAllTests() throws Exception {
    TEST_UTIL.startMiniCluster(2);
  }
  @AfterClass public static void afterAllTests() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Before public void setup() throws IOException, InterruptedException {
    TEST_UTIL.createTable(TABLENAME,FAMILIES);
    Table t=TEST_UTIL.getConnection().getTable(TABLENAME);
    TEST_UTIL.waitUntilNoRegionsInTransition();
    TEST_UTIL.loadTable(t,FAMILIES);
    TEST_UTIL.flush();
    t.close();
    TEST_UTIL.ensureSomeRegionServersAvailable(2);
  }
  @After public void cleanup() throws Exception {
    TEST_UTIL.deleteTable(TABLENAME);
  }
  @Test public void deleteColumnFamilyWithMultipleRegions() throws Exception {
    Admin admin=TEST_UTIL.getAdmin();
    HTableDescriptor beforehtd=admin.getTableDescriptor(TABLENAME);
    FileSystem fs=TEST_UTIL.getDFSCluster().getFileSystem();
    assertTrue(admin.isTableAvailable(TABLENAME));
    assertEquals(3,beforehtd.getColumnFamilyCount());
    HColumnDescriptor[] families=beforehtd.getColumnFamilies();
    for (int i=0; i < families.length; i++) {
      assertTrue(families[i].getNameAsString().equals("cf" + (i + 1)));
    }
    Path tableDir=FSUtils.getTableDir(TEST_UTIL.getDefaultRootDirPath(),TABLENAME);
    assertTrue(fs.exists(tableDir));
    FileStatus[] fileStatus=fs.listStatus(tableDir);
    for (int i=0; i < fileStatus.length; i++) {
      if (fileStatus[i].isDirectory() == true) {
        FileStatus[] cf=fs.listStatus(fileStatus[i].getPath(),new PathFilter(){
          @Override public boolean accept(          Path p){
            if (p.getName().contains(HConstants.RECOVERED_EDITS_DIR)) {
              return false;
            }
            return true;
          }
        }
);
        int k=1;
        for (int j=0; j < cf.length; j++) {
          if (cf[j].isDirectory() == true && cf[j].getPath().getName().startsWith(".") == false) {
            assertEquals(cf[j].getPath().getName(),"cf" + k);
            k++;
          }
        }
      }
    }
    admin.disableTable(TABLENAME);
    admin.deleteColumnFamily(TABLENAME,Bytes.toBytes("cf2"));
    HTableDescriptor afterhtd=admin.getTableDescriptor(TABLENAME);
    assertEquals(2,afterhtd.getColumnFamilyCount());
    HColumnDescriptor[] newFamilies=afterhtd.getColumnFamilies();
    assertTrue(newFamilies[0].getNameAsString().equals("cf1"));
    assertTrue(newFamilies[1].getNameAsString().equals("cf3"));
    fileStatus=fs.listStatus(tableDir);
    for (int i=0; i < fileStatus.length; i++) {
      if (fileStatus[i].isDirectory() == true) {
        FileStatus[] cf=fs.listStatus(fileStatus[i].getPath(),new PathFilter(){
          @Override public boolean accept(          Path p){
            if (WALSplitter.isSequenceIdFile(p)) {
              return false;
            }
            return true;
          }
        }
);
        for (int j=0; j < cf.length; j++) {
          if (cf[j].isDirectory() == true) {
            assertFalse(cf[j].getPath().getName().equals("cf2"));
          }
        }
      }
    }
  }
  @Test public void deleteColumnFamilyTwice() throws Exception {
    Admin admin=TEST_UTIL.getAdmin();
    HTableDescriptor beforehtd=admin.getTableDescriptor(TABLENAME);
    String cfToDelete="cf1";
    FileSystem fs=TEST_UTIL.getDFSCluster().getFileSystem();
    assertTrue(admin.isTableAvailable(TABLENAME));
    HColumnDescriptor[] families=beforehtd.getColumnFamilies();
    Boolean foundCF=false;
    for (int i=0; i < families.length; i++) {
      if (families[i].getNameAsString().equals(cfToDelete)) {
        foundCF=true;
        break;
      }
    }
    assertTrue(foundCF);
    Path tableDir=FSUtils.getTableDir(TEST_UTIL.getDefaultRootDirPath(),TABLENAME);
    assertTrue(fs.exists(tableDir));
    FileStatus[] fileStatus=fs.listStatus(tableDir);
    foundCF=false;
    for (int i=0; i < fileStatus.length; i++) {
      if (fileStatus[i].isDirectory() == true) {
        FileStatus[] cf=fs.listStatus(fileStatus[i].getPath(),new PathFilter(){
          @Override public boolean accept(          Path p){
            if (p.getName().contains(HConstants.RECOVERED_EDITS_DIR)) {
              return false;
            }
            return true;
          }
        }
);
        for (int j=0; j < cf.length; j++) {
          if (cf[j].isDirectory() == true && cf[j].getPath().getName().equals(cfToDelete)) {
            foundCF=true;
            break;
          }
        }
      }
      if (foundCF) {
        break;
      }
    }
    assertTrue(foundCF);
    if (admin.isTableEnabled(TABLENAME)) {
      admin.disableTable(TABLENAME);
    }
    admin.deleteColumnFamily(TABLENAME,Bytes.toBytes(cfToDelete));
    fileStatus=fs.listStatus(tableDir);
    for (int i=0; i < fileStatus.length; i++) {
      if (fileStatus[i].isDirectory() == true) {
        FileStatus[] cf=fs.listStatus(fileStatus[i].getPath(),new PathFilter(){
          @Override public boolean accept(          Path p){
            if (WALSplitter.isSequenceIdFile(p)) {
              return false;
            }
            return true;
          }
        }
);
        for (int j=0; j < cf.length; j++) {
          if (cf[j].isDirectory() == true) {
            assertFalse(cf[j].getPath().getName().equals(cfToDelete));
          }
        }
      }
    }
    try {
      admin.deleteColumnFamily(TABLENAME,Bytes.toBytes(cfToDelete));
      Assert.fail("Delete a non-exist column family should fail");
    }
 catch (    InvalidFamilyOperationException e) {
    }
  }
}
