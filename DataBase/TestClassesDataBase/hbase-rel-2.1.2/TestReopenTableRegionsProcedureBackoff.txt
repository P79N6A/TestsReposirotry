/** 
 * Confirm that we will do backoff when retrying on reopening table regions, to avoid consuming all the CPUs.
 */
@Category({MasterTests.class,MediumTests.class}) public class TestReopenTableRegionsProcedureBackoff {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestReopenTableRegionsProcedureBackoff.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestReopenTableRegionsProcedureBackoff.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static TableName TABLE_NAME=TableName.valueOf("Backoff");
  private static byte[] CF=Bytes.toBytes("cf");
  @BeforeClass public static void setUp() throws Exception {
    UTIL.getConfiguration().setInt(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART,1);
    UTIL.startMiniCluster(1);
    UTIL.createTable(TABLE_NAME,CF);
  }
  @AfterClass public static void tearDown() throws Exception {
    UTIL.shutdownMiniCluster();
  }
  @Test public void testRetryBackoff() throws IOException, InterruptedException {
    AssignmentManager am=UTIL.getMiniHBaseCluster().getMaster().getAssignmentManager();
    ProcedureExecutor<MasterProcedureEnv> procExec=UTIL.getMiniHBaseCluster().getMaster().getMasterProcedureExecutor();
    RegionInfo regionInfo=UTIL.getAdmin().getRegions(TABLE_NAME).get(0);
    RegionStateNode regionNode=am.getRegionStates().getRegionStateNode(regionInfo);
    long openSeqNum;
synchronized (regionNode) {
      openSeqNum=regionNode.getOpenSeqNum();
      regionNode.setState(State.OPENING);
      regionNode.setOpenSeqNum(-1L);
    }
    ReopenTableRegionsProcedure proc=new ReopenTableRegionsProcedure(TABLE_NAME);
    procExec.submitProcedure(proc);
    UTIL.waitFor(10000,() -> proc.getState() == ProcedureState.WAITING_TIMEOUT);
    long oldTimeout=0;
    int timeoutIncrements=0;
    for (; ; ) {
      long timeout=proc.getTimeout();
      if (timeout > oldTimeout) {
        LOG.info("Timeout incremented, was {}, now is {}, increments={}",timeout,oldTimeout,timeoutIncrements);
        oldTimeout=timeout;
        timeoutIncrements++;
        if (timeoutIncrements > 3) {
          break;
        }
      }
      Thread.sleep(1000);
    }
synchronized (regionNode) {
      regionNode.setState(State.OPEN);
      regionNode.setOpenSeqNum(openSeqNum);
    }
    ProcedureSyncWait.waitForProcedureToComplete(procExec,proc,60000);
    assertTrue(regionNode.getOpenSeqNum() > openSeqNum);
  }
}
