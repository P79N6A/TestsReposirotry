/** 
 * Basic test of BucketCache.Puts and gets. <p> Tests will ensure that blocks' data correctness under several threads concurrency
 */
@RunWith(Parameterized.class) @Category({IOTests.class,MediumTests.class}) public class TestBucketCache {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestBucketCache.class);
  private static final Random RAND=new Random();
  @Parameterized.Parameters(name="{index}: blockSize={0}, bucketSizes={1}") public static Iterable<Object[]> data(){
    return Arrays.asList(new Object[][]{{8192,null},{16 * 1024,new int[]{2 * 1024 + 1024,4 * 1024 + 1024,8 * 1024 + 1024,16 * 1024 + 1024,28 * 1024 + 1024,32 * 1024 + 1024,64 * 1024 + 1024,96 * 1024 + 1024,128 * 1024 + 1024}}});
  }
  @Parameterized.Parameter(0) public int constructedBlockSize;
  @Parameterized.Parameter(1) public int[] constructedBlockSizes;
  BucketCache cache;
  final int CACHE_SIZE=1000000;
  final int NUM_BLOCKS=100;
  final int BLOCK_SIZE=CACHE_SIZE / NUM_BLOCKS;
  final int NUM_THREADS=100;
  final int NUM_QUERIES=10000;
  final long capacitySize=32 * 1024 * 1024;
  final int writeThreads=BucketCache.DEFAULT_WRITER_THREADS;
  final int writerQLen=BucketCache.DEFAULT_WRITER_QUEUE_ITEMS;
  String ioEngineName="offheap";
  String persistencePath=null;
private static class MockedBucketCache extends BucketCache {
    public MockedBucketCache(    String ioEngineName,    long capacity,    int blockSize,    int[] bucketSizes,    int writerThreads,    int writerQLen,    String persistencePath) throws FileNotFoundException, IOException {
      super(ioEngineName,capacity,blockSize,bucketSizes,writerThreads,writerQLen,persistencePath);
      super.wait_when_cache=true;
    }
    @Override public void cacheBlock(    BlockCacheKey cacheKey,    Cacheable buf,    boolean inMemory){
      super.cacheBlock(cacheKey,buf,inMemory);
    }
    @Override public void cacheBlock(    BlockCacheKey cacheKey,    Cacheable buf){
      super.cacheBlock(cacheKey,buf);
    }
  }
  @Before public void setup() throws FileNotFoundException, IOException {
    cache=new MockedBucketCache(ioEngineName,capacitySize,constructedBlockSize,constructedBlockSizes,writeThreads,writerQLen,persistencePath);
  }
  @After public void tearDown(){
    cache.shutdown();
  }
  /** 
 * Return a random element from  {@code a}.
 */
  private static <T>T randFrom(  List<T> a){
    return a.get(RAND.nextInt(a.size()));
  }
  @Test public void testBucketAllocator() throws BucketAllocatorException {
    BucketAllocator mAllocator=cache.getAllocator();
    final List<Integer> BLOCKSIZES=Arrays.asList(4 * 1024,8 * 1024,64 * 1024,96 * 1024);
    boolean full=false;
    ArrayList<Long> allocations=new ArrayList<>();
    List<Integer> tmp=new ArrayList<>(BLOCKSIZES);
    while (!full) {
      Integer blockSize=null;
      try {
        blockSize=randFrom(tmp);
        allocations.add(mAllocator.allocateBlock(blockSize));
      }
 catch (      CacheFullException cfe) {
        tmp.remove(blockSize);
        if (tmp.isEmpty())         full=true;
      }
    }
    for (    Integer blockSize : BLOCKSIZES) {
      BucketSizeInfo bucketSizeInfo=mAllocator.roundUpToBucketSizeInfo(blockSize);
      IndexStatistics indexStatistics=bucketSizeInfo.statistics();
      assertEquals("unexpected freeCount for " + bucketSizeInfo,0,indexStatistics.freeCount());
    }
    for (    long offset : allocations) {
      assertEquals(mAllocator.sizeOfAllocation(offset),mAllocator.freeBlock(offset));
    }
    assertEquals(0,mAllocator.getUsedSize());
  }
  @Test public void testCacheSimple() throws Exception {
    CacheTestUtils.testCacheSimple(cache,BLOCK_SIZE,NUM_QUERIES);
  }
  @Test public void testCacheMultiThreadedSingleKey() throws Exception {
    CacheTestUtils.hammerSingleKey(cache,BLOCK_SIZE,2 * NUM_THREADS,2 * NUM_QUERIES);
  }
  @Test public void testHeapSizeChanges() throws Exception {
    cache.stopWriterThreads();
    CacheTestUtils.testHeapSizeChanges(cache,BLOCK_SIZE);
  }
  private void waitUntilFlushedToBucket(  BucketCache cache,  BlockCacheKey cacheKey) throws InterruptedException {
    while (!cache.backingMap.containsKey(cacheKey) || cache.ramCache.containsKey(cacheKey)) {
      Thread.sleep(100);
    }
  }
  private void cacheAndWaitUntilFlushedToBucket(  BucketCache cache,  BlockCacheKey cacheKey,  Cacheable block) throws InterruptedException {
    cache.cacheBlock(cacheKey,block);
    waitUntilFlushedToBucket(cache,cacheKey);
  }
  @Test public void testMemoryLeak() throws Exception {
    final BlockCacheKey cacheKey=new BlockCacheKey("dummy",1L);
    cacheAndWaitUntilFlushedToBucket(cache,cacheKey,new CacheTestUtils.ByteArrayCacheable(new byte[10]));
    long lockId=cache.backingMap.get(cacheKey).offset();
    ReentrantReadWriteLock lock=cache.offsetLock.getLock(lockId);
    lock.writeLock().lock();
    Thread evictThread=new Thread("evict-block"){
      @Override public void run(){
        cache.evictBlock(cacheKey);
      }
    }
;
    evictThread.start();
    cache.offsetLock.waitForWaiters(lockId,1);
    cache.blockEvicted(cacheKey,cache.backingMap.remove(cacheKey),true);
    cacheAndWaitUntilFlushedToBucket(cache,cacheKey,new CacheTestUtils.ByteArrayCacheable(new byte[10]));
    lock.writeLock().unlock();
    evictThread.join();
    assertEquals(1L,cache.getBlockCount());
    assertTrue(cache.getCurrentSize() > 0L);
    assertTrue("We should have a block!",cache.iterator().hasNext());
  }
  @Test public void testRetrieveFromFile() throws Exception {
    HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
    Path testDir=TEST_UTIL.getDataTestDir();
    TEST_UTIL.getTestFileSystem().mkdirs(testDir);
    BucketCache bucketCache=new BucketCache("file:" + testDir + "/bucket.cache",capacitySize,constructedBlockSize,constructedBlockSizes,writeThreads,writerQLen,testDir + "/bucket.persistence");
    long usedSize=bucketCache.getAllocator().getUsedSize();
    assertTrue(usedSize == 0);
    HFileBlockPair[] blocks=CacheTestUtils.generateHFileBlocks(constructedBlockSize,1);
    for (    HFileBlockPair block : blocks) {
      bucketCache.cacheBlock(block.getBlockName(),block.getBlock());
    }
    for (    HFileBlockPair block : blocks) {
      cacheAndWaitUntilFlushedToBucket(bucketCache,block.getBlockName(),block.getBlock());
    }
    usedSize=bucketCache.getAllocator().getUsedSize();
    assertTrue(usedSize != 0);
    bucketCache.shutdown();
    bucketCache=new BucketCache("file:" + testDir + "/bucket.cache",capacitySize,constructedBlockSize,constructedBlockSizes,writeThreads,writerQLen,testDir + "/bucket.persistence");
    assertEquals(usedSize,bucketCache.getAllocator().getUsedSize());
    bucketCache.shutdown();
    int[] smallBucketSizes=new int[]{2 * 1024 + 1024,4 * 1024 + 1024};
    bucketCache=new BucketCache("file:" + testDir + "/bucket.cache",capacitySize,constructedBlockSize,smallBucketSizes,writeThreads,writerQLen,testDir + "/bucket.persistence");
    assertEquals(0,bucketCache.getAllocator().getUsedSize());
    assertEquals(0,bucketCache.backingMap.size());
    TEST_UTIL.cleanupTestDir();
  }
  @Test public void testBucketAllocatorLargeBuckets() throws BucketAllocatorException {
    long availableSpace=20 * 1024L * 1024* 1024;
    int[] bucketSizes=new int[]{1024,1024 * 1024,1024 * 1024 * 1024};
    BucketAllocator allocator=new BucketAllocator(availableSpace,bucketSizes);
    assertTrue(allocator.getBuckets().length > 0);
  }
  @Test public void testGetPartitionSize() throws IOException {
    validateGetPartitionSize(cache,BucketCache.DEFAULT_SINGLE_FACTOR,BucketCache.DEFAULT_MIN_FACTOR);
    Configuration conf=HBaseConfiguration.create();
    conf.setFloat(BucketCache.MIN_FACTOR_CONFIG_NAME,0.5f);
    conf.setFloat(BucketCache.SINGLE_FACTOR_CONFIG_NAME,0.1f);
    conf.setFloat(BucketCache.MULTI_FACTOR_CONFIG_NAME,0.7f);
    conf.setFloat(BucketCache.MEMORY_FACTOR_CONFIG_NAME,0.2f);
    BucketCache cache=new BucketCache(ioEngineName,capacitySize,constructedBlockSize,constructedBlockSizes,writeThreads,writerQLen,persistencePath,100,conf);
    validateGetPartitionSize(cache,0.1f,0.5f);
    validateGetPartitionSize(cache,0.7f,0.5f);
    validateGetPartitionSize(cache,0.2f,0.5f);
  }
  @Test public void testValidBucketCacheConfigs() throws IOException {
    Configuration conf=HBaseConfiguration.create();
    conf.setFloat(BucketCache.ACCEPT_FACTOR_CONFIG_NAME,0.9f);
    conf.setFloat(BucketCache.MIN_FACTOR_CONFIG_NAME,0.5f);
    conf.setFloat(BucketCache.EXTRA_FREE_FACTOR_CONFIG_NAME,0.5f);
    conf.setFloat(BucketCache.SINGLE_FACTOR_CONFIG_NAME,0.1f);
    conf.setFloat(BucketCache.MULTI_FACTOR_CONFIG_NAME,0.7f);
    conf.setFloat(BucketCache.MEMORY_FACTOR_CONFIG_NAME,0.2f);
    BucketCache cache=new BucketCache(ioEngineName,capacitySize,constructedBlockSize,constructedBlockSizes,writeThreads,writerQLen,persistencePath,100,conf);
    assertEquals(BucketCache.ACCEPT_FACTOR_CONFIG_NAME + " failed to propagate.",0.9f,cache.getAcceptableFactor(),0);
    assertEquals(BucketCache.MIN_FACTOR_CONFIG_NAME + " failed to propagate.",0.5f,cache.getMinFactor(),0);
    assertEquals(BucketCache.EXTRA_FREE_FACTOR_CONFIG_NAME + " failed to propagate.",0.5f,cache.getExtraFreeFactor(),0);
    assertEquals(BucketCache.SINGLE_FACTOR_CONFIG_NAME + " failed to propagate.",0.1f,cache.getSingleFactor(),0);
    assertEquals(BucketCache.MULTI_FACTOR_CONFIG_NAME + " failed to propagate.",0.7f,cache.getMultiFactor(),0);
    assertEquals(BucketCache.MEMORY_FACTOR_CONFIG_NAME + " failed to propagate.",0.2f,cache.getMemoryFactor(),0);
  }
  @Test public void testInvalidAcceptFactorConfig() throws IOException {
    float[] configValues={-1f,0.2f,0.86f,1.05f};
    boolean[] expectedOutcomes={false,false,true,false};
    Map<String,float[]> configMappings=ImmutableMap.of(BucketCache.ACCEPT_FACTOR_CONFIG_NAME,configValues);
    Configuration conf=HBaseConfiguration.create();
    checkConfigValues(conf,configMappings,expectedOutcomes);
  }
  @Test public void testInvalidMinFactorConfig() throws IOException {
    float[] configValues={-1f,0f,0.96f,1.05f};
    boolean[] expectedOutcomes={false,true,false,false};
    Map<String,float[]> configMappings=ImmutableMap.of(BucketCache.MIN_FACTOR_CONFIG_NAME,configValues);
    Configuration conf=HBaseConfiguration.create();
    checkConfigValues(conf,configMappings,expectedOutcomes);
  }
  @Test public void testInvalidExtraFreeFactorConfig() throws IOException {
    float[] configValues={-1f,0f,0.2f,1.05f};
    boolean[] expectedOutcomes={false,true,true,true};
    Map<String,float[]> configMappings=ImmutableMap.of(BucketCache.EXTRA_FREE_FACTOR_CONFIG_NAME,configValues);
    Configuration conf=HBaseConfiguration.create();
    checkConfigValues(conf,configMappings,expectedOutcomes);
  }
  @Test public void testInvalidCacheSplitFactorConfig() throws IOException {
    float[] singleFactorConfigValues={0.2f,0f,-0.2f,1f};
    float[] multiFactorConfigValues={0.4f,0f,1f,.05f};
    float[] memoryFactorConfigValues={0.4f,0f,0.2f,.5f};
    boolean[] expectedOutcomes={true,false,false,false};
    Map<String,float[]> configMappings=ImmutableMap.of(BucketCache.SINGLE_FACTOR_CONFIG_NAME,singleFactorConfigValues,BucketCache.MULTI_FACTOR_CONFIG_NAME,multiFactorConfigValues,BucketCache.MEMORY_FACTOR_CONFIG_NAME,memoryFactorConfigValues);
    Configuration conf=HBaseConfiguration.create();
    checkConfigValues(conf,configMappings,expectedOutcomes);
  }
  private void checkConfigValues(  Configuration conf,  Map<String,float[]> configMap,  boolean[] expectSuccess) throws IOException {
    Set<String> configNames=configMap.keySet();
    for (int i=0; i < expectSuccess.length; i++) {
      try {
        for (        String configName : configNames) {
          conf.setFloat(configName,configMap.get(configName)[i]);
        }
        BucketCache cache=new BucketCache(ioEngineName,capacitySize,constructedBlockSize,constructedBlockSizes,writeThreads,writerQLen,persistencePath,100,conf);
        assertTrue("Created BucketCache and expected it to succeed: " + expectSuccess[i] + ", but it actually was: "+ !expectSuccess[i],expectSuccess[i]);
      }
 catch (      IllegalArgumentException e) {
        assertFalse("Created BucketCache and expected it to succeed: " + expectSuccess[i] + ", but it actually was: "+ !expectSuccess[i],expectSuccess[i]);
      }
    }
  }
  private void validateGetPartitionSize(  BucketCache bucketCache,  float partitionFactor,  float minFactor){
    long expectedOutput=(long)Math.floor(bucketCache.getAllocator().getTotalSize() * partitionFactor * minFactor);
    assertEquals(expectedOutput,bucketCache.getPartitionSize(partitionFactor));
  }
  @Test public void testOffsetProducesPositiveOutput(){
    long testValue=549888460800L;
    BucketCache.BucketEntry bucketEntry=new BucketCache.BucketEntry(testValue,10,10L,true);
    assertEquals(testValue,bucketEntry.offset());
  }
  @Test public void testCacheBlockNextBlockMetadataMissing() throws Exception {
    int size=100;
    int length=HConstants.HFILEBLOCK_HEADER_SIZE + size;
    byte[] byteArr=new byte[length];
    ByteBuffer buf=ByteBuffer.wrap(byteArr,0,size);
    HFileContext meta=new HFileContextBuilder().build();
    HFileBlock blockWithNextBlockMetadata=new HFileBlock(BlockType.DATA,size,size,-1,buf,HFileBlock.FILL_HEADER,-1,52,-1,meta);
    HFileBlock blockWithoutNextBlockMetadata=new HFileBlock(BlockType.DATA,size,size,-1,buf,HFileBlock.FILL_HEADER,-1,-1,-1,meta);
    BlockCacheKey key=new BlockCacheKey("key1",0);
    ByteBuffer actualBuffer=ByteBuffer.allocate(length);
    ByteBuffer block1Buffer=ByteBuffer.allocate(length);
    ByteBuffer block2Buffer=ByteBuffer.allocate(length);
    blockWithNextBlockMetadata.serialize(block1Buffer,true);
    blockWithoutNextBlockMetadata.serialize(block2Buffer,true);
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithNextBlockMetadata,actualBuffer,block1Buffer);
    waitUntilFlushedToBucket(cache,key);
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithoutNextBlockMetadata,actualBuffer,block1Buffer);
    cache.evictBlock(key);
    assertNull(cache.getBlock(key,false,false,false));
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithoutNextBlockMetadata,actualBuffer,block2Buffer);
    waitUntilFlushedToBucket(cache,key);
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithNextBlockMetadata,actualBuffer,block1Buffer);
  }
}
