/** 
 * Test if Filter is incompatible with scan-limits
 */
@Category({FilterTests.class,MediumTests.class}) public class TestFilterWithScanLimits extends FilterTestingCluster {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestFilterWithScanLimits.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestFilterWithScanLimits.class);
  private static final TableName tableName=TableName.valueOf("scanWithLimit");
  private static final String columnFamily="f1";
  @Test public void testScanWithLimit(){
    int kv_number=0;
    try {
      Scan scan=new Scan();
      scan.setBatch(2);
      SingleColumnValueFilter filter=new SingleColumnValueFilter(Bytes.toBytes(columnFamily),Bytes.toBytes("c5"),CompareOperator.EQUAL,new SubstringComparator("2_c5"));
      scan.setFilter(filter);
      Table table=openTable(tableName);
      ResultScanner scanner=table.getScanner(scan);
      for (      Result result : scanner) {
        for (        Cell kv : result.listCells()) {
          kv_number++;
          LOG.debug(kv_number + ". kv: " + kv);
        }
      }
      scanner.close();
      table.close();
    }
 catch (    Exception e) {
      assertNotNull("No IncompatibleFilterException catched",e);
    }
    LOG.debug("check the fetched kv number");
    assertEquals("We should not get result(s) returned.",0,kv_number);
  }
  @BeforeClass public static void prepareData(){
    try {
      createTable(tableName,columnFamily);
      Table table=openTable(tableName);
      List<Put> puts=new ArrayList<>();
      for (int i=1; i < 4; i++) {
        Put put=new Put(Bytes.toBytes("row" + i));
        for (int j=1; j < 6; j++) {
          put.addColumn(Bytes.toBytes("f1"),Bytes.toBytes("c" + j),Bytes.toBytes(i + "_c" + j));
        }
        puts.add(put);
      }
      table.put(puts);
      table.close();
    }
 catch (    IOException e) {
      assertNull("Exception found while putting data into table",e);
    }
  }
}
