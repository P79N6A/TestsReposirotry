@Category({MiscTests.class,SmallTests.class}) public class TestHttpServer extends HttpServerFunctionalTest {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestHttpServer.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestHttpServer.class);
  private static HttpServer server;
  private static URL baseUrl;
  static final int MAX_THREADS=16;
@SuppressWarnings("serial") public static class EchoMapServlet extends HttpServlet {
    @Override public void doGet(    HttpServletRequest request,    HttpServletResponse response) throws ServletException, IOException {
      PrintWriter out=response.getWriter();
      Map<String,String[]> params=request.getParameterMap();
      SortedSet<String> keys=new TreeSet<>(params.keySet());
      for (      String key : keys) {
        out.print(key);
        out.print(':');
        String[] values=params.get(key);
        if (values.length > 0) {
          out.print(values[0]);
          for (int i=1; i < values.length; ++i) {
            out.print(',');
            out.print(values[i]);
          }
        }
        out.print('\n');
      }
      out.close();
    }
  }
@SuppressWarnings("serial") public static class EchoServlet extends HttpServlet {
    @Override public void doGet(    HttpServletRequest request,    HttpServletResponse response) throws ServletException, IOException {
      PrintWriter out=response.getWriter();
      SortedSet<String> sortedKeys=new TreeSet<>();
      Enumeration<String> keys=request.getParameterNames();
      while (keys.hasMoreElements()) {
        sortedKeys.add(keys.nextElement());
      }
      for (      String key : sortedKeys) {
        out.print(key);
        out.print(':');
        out.print(request.getParameter(key));
        out.print('\n');
      }
      out.close();
    }
  }
@SuppressWarnings("serial") public static class LongHeaderServlet extends HttpServlet {
    @Override public void doGet(    HttpServletRequest request,    HttpServletResponse response) throws ServletException, IOException {
      Assert.assertEquals(63 * 1024,request.getHeader("longheader").length());
      response.setStatus(HttpServletResponse.SC_OK);
    }
  }
@SuppressWarnings("serial") public static class HtmlContentServlet extends HttpServlet {
    @Override public void doGet(    HttpServletRequest request,    HttpServletResponse response) throws ServletException, IOException {
      response.setContentType("text/html");
      PrintWriter out=response.getWriter();
      out.print("hello world");
      out.close();
    }
  }
  @BeforeClass public static void setup() throws Exception {
    Configuration conf=new Configuration();
    conf.setInt(HttpServer.HTTP_MAX_THREADS,MAX_THREADS);
    server=createTestServer(conf);
    server.addServlet("echo","/echo",EchoServlet.class);
    server.addServlet("echomap","/echomap",EchoMapServlet.class);
    server.addServlet("htmlcontent","/htmlcontent",HtmlContentServlet.class);
    server.addServlet("longheader","/longheader",LongHeaderServlet.class);
    server.addJerseyResourcePackage(JerseyResource.class.getPackage().getName(),"/jersey/*");
    server.start();
    baseUrl=getServerURL(server);
    LOG.info("HTTP server started: " + baseUrl);
  }
  @AfterClass public static void cleanup() throws Exception {
    server.stop();
  }
  /** 
 * Test the maximum number of threads cannot be exceeded. 
 */
  @Test public void testMaxThreads() throws Exception {
    int clientThreads=MAX_THREADS * 10;
    Executor executor=Executors.newFixedThreadPool(clientThreads);
    final CountDownLatch ready=new CountDownLatch(clientThreads);
    final CountDownLatch start=new CountDownLatch(1);
    for (int i=0; i < clientThreads; i++) {
      executor.execute(new Runnable(){
        @Override public void run(){
          ready.countDown();
          try {
            start.await();
            assertEquals("a:b\nc:d\n",readOutput(new URL(baseUrl,"/echo?a=b&c=d")));
            int serverThreads=server.webServer.getThreadPool().getThreads();
            assertTrue("More threads are started than expected, Server Threads count: " + serverThreads,serverThreads <= MAX_THREADS);
            System.out.println("Number of threads = " + serverThreads + " which is less or equal than the max = "+ MAX_THREADS);
          }
 catch (          Exception e) {
          }
        }
      }
);
    }
    ready.await();
    start.countDown();
  }
  @Test public void testEcho() throws Exception {
    assertEquals("a:b\nc:d\n",readOutput(new URL(baseUrl,"/echo?a=b&c=d")));
    assertEquals("a:b\nc&lt;:d\ne:&gt;\n",readOutput(new URL(baseUrl,"/echo?a=b&c<=d&e=>")));
  }
  /** 
 * Test the echo map servlet that uses getParameterMap. 
 */
  @Test public void testEchoMap() throws Exception {
    assertEquals("a:b\nc:d\n",readOutput(new URL(baseUrl,"/echomap?a=b&c=d")));
    assertEquals("a:b,&gt;\nc&lt;:d\n",readOutput(new URL(baseUrl,"/echomap?a=b&c<=d&a=>")));
  }
  /** 
 * Test that verifies headers can be up to 64K long. The test adds a 63K header leaving 1K for other headers. This is because the header buffer setting is for ALL headers, names and values included. 
 */
  @Test public void testLongHeader() throws Exception {
    URL url=new URL(baseUrl,"/longheader");
    HttpURLConnection conn=(HttpURLConnection)url.openConnection();
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < 63 * 1024; i++) {
      sb.append("a");
    }
    conn.setRequestProperty("longheader",sb.toString());
    assertEquals(HttpURLConnection.HTTP_OK,conn.getResponseCode());
  }
  @Test public void testContentTypes() throws Exception {
    URL cssUrl=new URL(baseUrl,"/static/test.css");
    HttpURLConnection conn=(HttpURLConnection)cssUrl.openConnection();
    conn.connect();
    assertEquals(200,conn.getResponseCode());
    assertEquals("text/css",conn.getContentType());
    URL servletUrl=new URL(baseUrl,"/echo?a=b");
    conn=(HttpURLConnection)servletUrl.openConnection();
    conn.connect();
    assertEquals(200,conn.getResponseCode());
    assertEquals("text/plain;charset=utf-8",conn.getContentType());
    servletUrl=new URL(baseUrl,"/echo?a=b.css");
    conn=(HttpURLConnection)servletUrl.openConnection();
    conn.connect();
    assertEquals(200,conn.getResponseCode());
    assertEquals("text/plain;charset=utf-8",conn.getContentType());
    servletUrl=new URL(baseUrl,"/htmlcontent");
    conn=(HttpURLConnection)servletUrl.openConnection();
    conn.connect();
    assertEquals(200,conn.getResponseCode());
    assertEquals("text/html;charset=utf-8",conn.getContentType());
  }
  /** 
 * Dummy filter that mimics as an authentication filter. Obtains user identity from the request parameter user.name. Wraps around the request so that request.getRemoteUser() returns the user identity.
 */
public static class DummyServletFilter implements Filter {
    @Override public void destroy(){
    }
    @Override public void doFilter(    ServletRequest request,    ServletResponse response,    FilterChain filterChain) throws IOException, ServletException {
      final String userName=request.getParameter("user.name");
      ServletRequest requestModified=new HttpServletRequestWrapper((HttpServletRequest)request){
        @Override public String getRemoteUser(){
          return userName;
        }
      }
;
      filterChain.doFilter(requestModified,response);
    }
    @Override public void init(    FilterConfig arg0) throws ServletException {
    }
  }
  /** 
 * FilterInitializer that initialized the DummyFilter.
 */
public static class DummyFilterInitializer extends FilterInitializer {
    public DummyFilterInitializer(){
    }
    @Override public void initFilter(    FilterContainer container,    Configuration conf){
      container.addFilter("DummyFilter",DummyServletFilter.class.getName(),null);
    }
  }
  /** 
 * Access a URL and get the corresponding return Http status code. The URL will be accessed as the passed user, by sending user.name request parameter.
 * @param urlstring The url to access
 * @param userName The user to perform access as
 * @return The HTTP response code
 * @throws IOException if there is a problem communicating with the server
 */
  static int getHttpStatusCode(  String urlstring,  String userName) throws IOException {
    URL url=new URL(urlstring + "?user.name=" + userName);
    System.out.println("Accessing " + url + " as user "+ userName);
    HttpURLConnection connection=(HttpURLConnection)url.openConnection();
    connection.connect();
    return connection.getResponseCode();
  }
  /** 
 * Custom user->group mapping service.
 */
public static class MyGroupsProvider extends ShellBasedUnixGroupsMapping {
    static Map<String,List<String>> mapping=new HashMap<>();
    static void clearMapping(){
      mapping.clear();
    }
    @Override public List<String> getGroups(    String user) throws IOException {
      return mapping.get(user);
    }
  }
  /** 
 * Verify the access for /logs, /stacks, /conf, /logLevel and /metrics servlets, when authentication filters are set, but authorization is not enabled.
 * @throws Exception
 */
  @Test @Ignore public void testDisabledAuthorizationOfDefaultServlets() throws Exception {
    Configuration conf=new Configuration();
    conf.set(HttpServer.FILTER_INITIALIZERS_PROPERTY,DummyFilterInitializer.class.getName());
    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_GROUP_MAPPING,MyGroupsProvider.class.getName());
    Groups.getUserToGroupsMappingService(conf);
    MyGroupsProvider.clearMapping();
    MyGroupsProvider.mapping.put("userA",Arrays.asList("groupA"));
    MyGroupsProvider.mapping.put("userB",Arrays.asList("groupB"));
    HttpServer myServer=new HttpServer.Builder().setName("test").addEndpoint(new URI("http://localhost:0")).setFindPort(true).build();
    myServer.setAttribute(HttpServer.CONF_CONTEXT_ATTRIBUTE,conf);
    myServer.start();
    String serverURL="http://" + NetUtils.getHostPortString(myServer.getConnectorAddress(0)) + "/";
    for (    String servlet : new String[]{"conf","logs","stacks","logLevel","metrics"}) {
      for (      String user : new String[]{"userA","userB"}) {
        assertEquals(HttpURLConnection.HTTP_OK,getHttpStatusCode(serverURL + servlet,user));
      }
    }
    myServer.stop();
  }
  /** 
 * Verify the administrator access for /logs, /stacks, /conf, /logLevel and /metrics servlets.
 * @throws Exception
 */
  @Test @Ignore public void testAuthorizationOfDefaultServlets() throws Exception {
    Configuration conf=new Configuration();
    conf.setBoolean(CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION,true);
    conf.setBoolean(CommonConfigurationKeys.HADOOP_SECURITY_INSTRUMENTATION_REQUIRES_ADMIN,true);
    conf.set(HttpServer.FILTER_INITIALIZERS_PROPERTY,DummyFilterInitializer.class.getName());
    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_GROUP_MAPPING,MyGroupsProvider.class.getName());
    Groups.getUserToGroupsMappingService(conf);
    MyGroupsProvider.clearMapping();
    MyGroupsProvider.mapping.put("userA",Arrays.asList("groupA"));
    MyGroupsProvider.mapping.put("userB",Arrays.asList("groupB"));
    MyGroupsProvider.mapping.put("userC",Arrays.asList("groupC"));
    MyGroupsProvider.mapping.put("userD",Arrays.asList("groupD"));
    MyGroupsProvider.mapping.put("userE",Arrays.asList("groupE"));
    HttpServer myServer=new HttpServer.Builder().setName("test").addEndpoint(new URI("http://localhost:0")).setFindPort(true).setConf(conf).setACL(new AccessControlList("userA,userB groupC,groupD")).build();
    myServer.setAttribute(HttpServer.CONF_CONTEXT_ATTRIBUTE,conf);
    myServer.start();
    String serverURL="http://" + NetUtils.getHostPortString(myServer.getConnectorAddress(0)) + "/";
    for (    String servlet : new String[]{"conf","logs","stacks","logLevel","metrics"}) {
      for (      String user : new String[]{"userA","userB","userC","userD"}) {
        assertEquals(HttpURLConnection.HTTP_OK,getHttpStatusCode(serverURL + servlet,user));
      }
      assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED,getHttpStatusCode(serverURL + servlet,"userE"));
    }
    myServer.stop();
  }
  @Test public void testRequestQuoterWithNull() throws Exception {
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    Mockito.doReturn(null).when(request).getParameterValues("dummy");
    RequestQuoter requestQuoter=new RequestQuoter(request);
    String[] parameterValues=requestQuoter.getParameterValues("dummy");
    Assert.assertEquals("It should return null " + "when there are no values for the parameter",null,parameterValues);
  }
  @Test public void testRequestQuoterWithNotNull() throws Exception {
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    String[] values=new String[]{"abc","def"};
    Mockito.doReturn(values).when(request).getParameterValues("dummy");
    RequestQuoter requestQuoter=new RequestQuoter(request);
    String[] parameterValues=requestQuoter.getParameterValues("dummy");
    Assert.assertTrue("It should return Parameter Values",Arrays.equals(values,parameterValues));
  }
  @SuppressWarnings("unchecked") private static Map<String,Object> parse(  String jsonString){
    return (Map<String,Object>)JSON.parse(jsonString);
  }
  @Test public void testJersey() throws Exception {
    LOG.info("BEGIN testJersey()");
    final String js=readOutput(new URL(baseUrl,"/jersey/foo?op=bar"));
    final Map<String,Object> m=parse(js);
    LOG.info("m=" + m);
    assertEquals("foo",m.get(JerseyResource.PATH));
    assertEquals("bar",m.get(JerseyResource.OP));
    LOG.info("END testJersey()");
  }
  @Test public void testHasAdministratorAccess() throws Exception {
    Configuration conf=new Configuration();
    conf.setBoolean(CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION,false);
    ServletContext context=Mockito.mock(ServletContext.class);
    Mockito.when(context.getAttribute(HttpServer.CONF_CONTEXT_ATTRIBUTE)).thenReturn(conf);
    Mockito.when(context.getAttribute(HttpServer.ADMINS_ACL)).thenReturn(null);
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    Mockito.when(request.getRemoteUser()).thenReturn(null);
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    Assert.assertTrue(HttpServer.hasAdministratorAccess(context,request,response));
    response=Mockito.mock(HttpServletResponse.class);
    conf.setBoolean(CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION,true);
    Assert.assertFalse(HttpServer.hasAdministratorAccess(context,request,response));
    Mockito.verify(response).sendError(Mockito.eq(HttpServletResponse.SC_UNAUTHORIZED),Mockito.anyString());
    response=Mockito.mock(HttpServletResponse.class);
    Mockito.when(request.getRemoteUser()).thenReturn("foo");
    Assert.assertTrue(HttpServer.hasAdministratorAccess(context,request,response));
    response=Mockito.mock(HttpServletResponse.class);
    AccessControlList acls=Mockito.mock(AccessControlList.class);
    Mockito.when(acls.isUserAllowed(Mockito.<UserGroupInformation>any())).thenReturn(false);
    Mockito.when(context.getAttribute(HttpServer.ADMINS_ACL)).thenReturn(acls);
    Assert.assertFalse(HttpServer.hasAdministratorAccess(context,request,response));
    Mockito.verify(response).sendError(Mockito.eq(HttpServletResponse.SC_UNAUTHORIZED),Mockito.anyString());
    response=Mockito.mock(HttpServletResponse.class);
    Mockito.when(acls.isUserAllowed(Mockito.<UserGroupInformation>any())).thenReturn(true);
    Mockito.when(context.getAttribute(HttpServer.ADMINS_ACL)).thenReturn(acls);
    Assert.assertTrue(HttpServer.hasAdministratorAccess(context,request,response));
  }
  @Test public void testRequiresAuthorizationAccess() throws Exception {
    Configuration conf=new Configuration();
    ServletContext context=Mockito.mock(ServletContext.class);
    Mockito.when(context.getAttribute(HttpServer.CONF_CONTEXT_ATTRIBUTE)).thenReturn(conf);
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    Assert.assertTrue(HttpServer.isInstrumentationAccessAllowed(context,request,response));
    conf.setBoolean(CommonConfigurationKeys.HADOOP_SECURITY_INSTRUMENTATION_REQUIRES_ADMIN,true);
    conf.setBoolean(CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION,true);
    AccessControlList acls=Mockito.mock(AccessControlList.class);
    Mockito.when(acls.isUserAllowed(Mockito.<UserGroupInformation>any())).thenReturn(false);
    Mockito.when(context.getAttribute(HttpServer.ADMINS_ACL)).thenReturn(acls);
    Assert.assertFalse(HttpServer.isInstrumentationAccessAllowed(context,request,response));
  }
  @Test public void testBindAddress() throws Exception {
    checkBindAddress("localhost",0,false).stop();
    HttpServer myServer=checkBindAddress("localhost",0,false);
    HttpServer myServer2=null;
    try {
      int port=myServer.getConnectorAddress(0).getPort();
      myServer2=checkBindAddress("localhost",port,true);
      port=myServer2.getConnectorAddress(0).getPort();
      myServer2.stop();
      assertNull(myServer2.getConnectorAddress(0));
      myServer2.openListeners();
      assertEquals(port,myServer2.getConnectorAddress(0).getPort());
    }
  finally {
      myServer.stop();
      if (myServer2 != null) {
        myServer2.stop();
      }
    }
  }
  private HttpServer checkBindAddress(  String host,  int port,  boolean findPort) throws Exception {
    HttpServer server=createServer(host,port);
    try {
      ServerConnector listener=server.getServerConnectors().get(0);
      assertEquals(port,listener.getPort());
      server.openListeners();
      assertEquals(host,server.getConnectorAddress(0).getHostName());
      int boundPort=server.getConnectorAddress(0).getPort();
      if (port == 0) {
        assertTrue(boundPort != 0);
      }
 else       if (findPort) {
        assertTrue(boundPort > port);
        assertTrue(boundPort - port < 8);
      }
    }
 catch (    Exception e) {
      server.stop();
      throw e;
    }
    return server;
  }
  @Test public void testXFrameHeaderSameOrigin() throws Exception {
    Configuration conf=new Configuration();
    conf.set("hbase.http.filter.xframeoptions.mode","SAMEORIGIN");
    HttpServer myServer=new HttpServer.Builder().setName("test").addEndpoint(new URI("http://localhost:0")).setFindPort(true).setConf(conf).build();
    myServer.setAttribute(HttpServer.CONF_CONTEXT_ATTRIBUTE,conf);
    myServer.addServlet("echo","/echo",EchoServlet.class);
    myServer.start();
    String serverURL="http://" + NetUtils.getHostPortString(myServer.getConnectorAddress(0));
    URL url=new URL(new URL(serverURL),"/echo?a=b&c=d");
    HttpURLConnection conn=(HttpURLConnection)url.openConnection();
    assertEquals(HttpURLConnection.HTTP_OK,conn.getResponseCode());
    assertEquals("SAMEORIGIN",conn.getHeaderField("X-Frame-Options"));
    myServer.stop();
  }
  @Test public void testNoCacheHeader() throws Exception {
    URL url=new URL(baseUrl,"/echo?a=b&c=d");
    HttpURLConnection conn=(HttpURLConnection)url.openConnection();
    assertEquals(HttpURLConnection.HTTP_OK,conn.getResponseCode());
    assertEquals("no-cache",conn.getHeaderField("Cache-Control"));
    assertEquals("no-cache",conn.getHeaderField("Pragma"));
    assertNotNull(conn.getHeaderField("Expires"));
    assertNotNull(conn.getHeaderField("Date"));
    assertEquals(conn.getHeaderField("Expires"),conn.getHeaderField("Date"));
    assertEquals("DENY",conn.getHeaderField("X-Frame-Options"));
  }
  @Test public void testHttpMethods() throws Exception {
    URL url=new URL(baseUrl,"/echo?a=b");
    HttpURLConnection conn=(HttpURLConnection)url.openConnection();
    conn.setRequestMethod("TRACE");
    conn.connect();
    assertEquals(HttpURLConnection.HTTP_FORBIDDEN,conn.getResponseCode());
  }
}
