@Category({MasterTests.class,MediumTests.class}) public class TestModifyTableProcedure extends TestTableDDLProcedureBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestModifyTableProcedure.class);
  @Rule public TestName name=new TestName();
  @Test public void testModifyTable() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    MasterProcedureTestingUtility.createTable(procExec,tableName,null,"cf");
    UTIL.getAdmin().disableTable(tableName);
    HTableDescriptor htd=new HTableDescriptor(UTIL.getAdmin().getTableDescriptor(tableName));
    long newMaxFileSize=htd.getMaxFileSize() * 2;
    htd.setMaxFileSize(newMaxFileSize);
    htd.setRegionReplication(3);
    long procId1=ProcedureTestingUtility.submitAndWait(procExec,new ModifyTableProcedure(procExec.getEnvironment(),htd));
    ProcedureTestingUtility.assertProcNotFailed(procExec.getResult(procId1));
    HTableDescriptor currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(newMaxFileSize,currentHtd.getMaxFileSize());
    boolean newReadOnlyOption=htd.isReadOnly() ? false : true;
    long newMemStoreFlushSize=htd.getMemStoreFlushSize() * 2;
    htd.setReadOnly(newReadOnlyOption);
    htd.setMemStoreFlushSize(newMemStoreFlushSize);
    long procId2=ProcedureTestingUtility.submitAndWait(procExec,new ModifyTableProcedure(procExec.getEnvironment(),htd));
    ProcedureTestingUtility.assertProcNotFailed(procExec.getResult(procId2));
    currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(newReadOnlyOption,currentHtd.isReadOnly());
    assertEquals(newMemStoreFlushSize,currentHtd.getMemStoreFlushSize());
  }
  @Test public void testModifyTableAddCF() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    MasterProcedureTestingUtility.createTable(procExec,tableName,null,"cf1");
    HTableDescriptor currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(1,currentHtd.getFamiliesKeys().size());
    String cf2="cf2";
    HTableDescriptor htd=new HTableDescriptor(UTIL.getAdmin().getTableDescriptor(tableName));
    htd.addFamily(new HColumnDescriptor(cf2));
    long procId=ProcedureTestingUtility.submitAndWait(procExec,new ModifyTableProcedure(procExec.getEnvironment(),htd));
    ProcedureTestingUtility.assertProcNotFailed(procExec.getResult(procId));
    currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(2,currentHtd.getFamiliesKeys().size());
    assertTrue(currentHtd.hasFamily(Bytes.toBytes(cf2)));
    UTIL.getAdmin().disableTable(tableName);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    String cf3="cf3";
    HTableDescriptor htd2=new HTableDescriptor(UTIL.getAdmin().getTableDescriptor(tableName));
    htd2.addFamily(new HColumnDescriptor(cf3));
    long procId2=ProcedureTestingUtility.submitAndWait(procExec,new ModifyTableProcedure(procExec.getEnvironment(),htd2));
    ProcedureTestingUtility.assertProcNotFailed(procExec.getResult(procId2));
    currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertTrue(currentHtd.hasFamily(Bytes.toBytes(cf3)));
    assertEquals(3,currentHtd.getFamiliesKeys().size());
  }
  @Test public void testModifyTableDeleteCF() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final String cf1="cf1";
    final String cf2="cf2";
    final String cf3="cf3";
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    MasterProcedureTestingUtility.createTable(procExec,tableName,null,cf1,cf2,cf3);
    HTableDescriptor currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(3,currentHtd.getFamiliesKeys().size());
    HTableDescriptor htd=new HTableDescriptor(UTIL.getAdmin().getTableDescriptor(tableName));
    htd.removeFamily(Bytes.toBytes(cf2));
    long procId=ProcedureTestingUtility.submitAndWait(procExec,new ModifyTableProcedure(procExec.getEnvironment(),htd));
    ProcedureTestingUtility.assertProcNotFailed(procExec.getResult(procId));
    currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(2,currentHtd.getFamiliesKeys().size());
    assertFalse(currentHtd.hasFamily(Bytes.toBytes(cf2)));
    UTIL.getAdmin().disableTable(tableName);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    HTableDescriptor htd2=new HTableDescriptor(UTIL.getAdmin().getTableDescriptor(tableName));
    htd2.removeFamily(Bytes.toBytes(cf3));
    htd2.setConfiguration("hbase.table.sanity.checks",Boolean.FALSE.toString());
    long procId2=ProcedureTestingUtility.submitAndWait(procExec,new ModifyTableProcedure(procExec.getEnvironment(),htd2));
    ProcedureTestingUtility.assertProcNotFailed(procExec.getResult(procId2));
    currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(1,currentHtd.getFamiliesKeys().size());
    assertFalse(currentHtd.hasFamily(Bytes.toBytes(cf3)));
    HTableDescriptor htd3=new HTableDescriptor(UTIL.getAdmin().getTableDescriptor(tableName));
    htd3.removeFamily(Bytes.toBytes(cf1));
    long procId3=ProcedureTestingUtility.submitAndWait(procExec,new ModifyTableProcedure(procExec.getEnvironment(),htd3));
    final Procedure<?> result=procExec.getResult(procId3);
    assertEquals(true,result.isFailed());
    Throwable cause=ProcedureTestingUtility.getExceptionCause(result);
    assertTrue("expected DoNotRetryIOException, got " + cause,cause instanceof DoNotRetryIOException);
    assertEquals(1,currentHtd.getFamiliesKeys().size());
    assertTrue(currentHtd.hasFamily(Bytes.toBytes(cf1)));
  }
  @Test public void testRecoveryAndDoubleExecutionOffline() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final String cf2="cf2";
    final String cf3="cf3";
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    RegionInfo[] regions=MasterProcedureTestingUtility.createTable(procExec,tableName,null,"cf1",cf3);
    UTIL.getAdmin().disableTable(tableName);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    TableDescriptor oldDescriptor=UTIL.getAdmin().getDescriptor(tableName);
    TableDescriptor newDescriptor=TableDescriptorBuilder.newBuilder(oldDescriptor).setCompactionEnabled(!oldDescriptor.isCompactionEnabled()).setColumnFamily(ColumnFamilyDescriptorBuilder.of(cf2)).removeColumnFamily(Bytes.toBytes(cf3)).setRegionReplication(3).build();
    long procId=procExec.submitProcedure(new ModifyTableProcedure(procExec.getEnvironment(),newDescriptor));
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec,procId);
    TableDescriptor currentDescriptor=UTIL.getAdmin().getDescriptor(tableName);
    assertEquals(newDescriptor.isCompactionEnabled(),currentDescriptor.isCompactionEnabled());
    assertEquals(2,newDescriptor.getColumnFamilyNames().size());
    MasterProcedureTestingUtility.validateTableCreation(UTIL.getHBaseCluster().getMaster(),tableName,regions,false,"cf1",cf2);
  }
  @Test public void testRecoveryAndDoubleExecutionOnline() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final String cf2="cf2";
    final String cf3="cf3";
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    RegionInfo[] regions=MasterProcedureTestingUtility.createTable(procExec,tableName,null,"cf1",cf3);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    HTableDescriptor htd=new HTableDescriptor(UTIL.getAdmin().getTableDescriptor(tableName));
    boolean newCompactionEnableOption=htd.isCompactionEnabled() ? false : true;
    htd.setCompactionEnabled(newCompactionEnableOption);
    htd.addFamily(new HColumnDescriptor(cf2));
    htd.removeFamily(Bytes.toBytes(cf3));
    long procId=procExec.submitProcedure(new ModifyTableProcedure(procExec.getEnvironment(),htd));
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec,procId);
    HTableDescriptor currentHtd=UTIL.getAdmin().getTableDescriptor(tableName);
    assertEquals(newCompactionEnableOption,currentHtd.isCompactionEnabled());
    assertEquals(2,currentHtd.getFamiliesKeys().size());
    assertTrue(currentHtd.hasFamily(Bytes.toBytes(cf2)));
    assertFalse(currentHtd.hasFamily(Bytes.toBytes(cf3)));
    MasterProcedureTestingUtility.validateTableCreation(UTIL.getHBaseCluster().getMaster(),tableName,regions,"cf1",cf2);
  }
  @Test public void testColumnFamilyAdditionTwiceWithNonce() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final String cf2="cf2";
    final String cf3="cf3";
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    RegionInfo[] regions=MasterProcedureTestingUtility.createTable(procExec,tableName,null,"cf1",cf3);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    TableDescriptor td=UTIL.getAdmin().getDescriptor(tableName);
    TableDescriptor newTd=TableDescriptorBuilder.newBuilder(td).setCompactionEnabled(!td.isCompactionEnabled()).setColumnFamily(ColumnFamilyDescriptorBuilder.of(cf2)).build();
    PerClientRandomNonceGenerator nonceGenerator=PerClientRandomNonceGenerator.get();
    long nonceGroup=nonceGenerator.getNonceGroup();
    long newNonce=nonceGenerator.newNonce();
    NonceKey nonceKey=new NonceKey(nonceGroup,newNonce);
    procExec.registerNonce(nonceKey);
    final long procId=procExec.submitProcedure(new ModifyTableProcedure(procExec.getEnvironment(),newTd),nonceKey);
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec,procId,new StepHook(){
      @Override public boolean execute(      int step) throws IOException {
        if (step == 3) {
          return procId == UTIL.getHBaseCluster().getMaster().addColumn(tableName,ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(cf2)).build(),nonceGroup,newNonce);
        }
        return true;
      }
    }
);
    try {
      UTIL.getHBaseCluster().getMaster().addColumn(tableName,ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(cf2)).build(),nonceGroup,nonceGenerator.newNonce());
      Assert.fail();
    }
 catch (    InvalidFamilyOperationException e) {
    }
    TableDescriptor currentHtd=UTIL.getAdmin().getDescriptor(tableName);
    assertEquals(!td.isCompactionEnabled(),currentHtd.isCompactionEnabled());
    assertEquals(3,currentHtd.getColumnFamilyCount());
    assertTrue(currentHtd.hasColumnFamily(Bytes.toBytes(cf2)));
    assertTrue(currentHtd.hasColumnFamily(Bytes.toBytes(cf3)));
    MasterProcedureTestingUtility.validateTableCreation(UTIL.getHBaseCluster().getMaster(),tableName,regions,"cf1",cf2,cf3);
  }
  @Test public void testRollbackAndDoubleExecutionOnline() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final String familyName="cf2";
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    RegionInfo[] regions=MasterProcedureTestingUtility.createTable(procExec,tableName,null,"cf1");
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    TableDescriptor td=UTIL.getAdmin().getDescriptor(tableName);
    TableDescriptor newTd=TableDescriptorBuilder.newBuilder(td).setCompactionEnabled(!td.isCompactionEnabled()).setColumnFamily(ColumnFamilyDescriptorBuilder.of(familyName)).build();
    long procId=procExec.submitProcedure(new ModifyTableProcedure(procExec.getEnvironment(),newTd));
    int lastStep=3;
    MasterProcedureTestingUtility.testRollbackAndDoubleExecution(procExec,procId,lastStep);
    MasterProcedureTestingUtility.validateTableCreation(UTIL.getHBaseCluster().getMaster(),tableName,regions,"cf1");
  }
  @Test public void testRollbackAndDoubleExecutionOffline() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final String familyName="cf2";
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    RegionInfo[] regions=MasterProcedureTestingUtility.createTable(procExec,tableName,null,"cf1");
    UTIL.getAdmin().disableTable(tableName);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    TableDescriptor td=UTIL.getAdmin().getDescriptor(tableName);
    TableDescriptor newTd=TableDescriptorBuilder.newBuilder(td).setCompactionEnabled(!td.isCompactionEnabled()).setColumnFamily(ColumnFamilyDescriptorBuilder.of(familyName)).setRegionReplication(3).build();
    long procId=procExec.submitProcedure(new ModifyTableProcedure(procExec.getEnvironment(),newTd));
    int lastStep=3;
    MasterProcedureTestingUtility.testRollbackAndDoubleExecution(procExec,procId,lastStep);
    MasterProcedureTestingUtility.validateTableCreation(UTIL.getHBaseCluster().getMaster(),tableName,regions,"cf1");
  }
}
