/** 
 * Provides FSHLog test cases.
 */
@Category({RegionServerTests.class,MediumTests.class}) public class TestFSHLog extends AbstractTestFSWAL {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestFSHLog.class);
  @Rule public TestName name=new TestName();
  @Override protected AbstractFSWAL<?> newWAL(  FileSystem fs,  Path rootDir,  String walDir,  String archiveDir,  Configuration conf,  List<WALActionsListener> listeners,  boolean failIfWALExists,  String prefix,  String suffix) throws IOException {
    return new FSHLog(fs,rootDir,walDir,archiveDir,conf,listeners,failIfWALExists,prefix,suffix);
  }
  @Override protected AbstractFSWAL<?> newSlowWAL(  FileSystem fs,  Path rootDir,  String walDir,  String archiveDir,  Configuration conf,  List<WALActionsListener> listeners,  boolean failIfWALExists,  String prefix,  String suffix,  final Runnable action) throws IOException {
    return new FSHLog(fs,rootDir,walDir,archiveDir,conf,listeners,failIfWALExists,prefix,suffix){
      @Override void atHeadOfRingBufferEventHandlerAppend(){
        action.run();
        super.atHeadOfRingBufferEventHandlerAppend();
      }
    }
;
  }
  @Test public void testSyncRunnerIndexOverflow() throws IOException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    final String name=this.name.getMethodName();
    FSHLog log=new FSHLog(FS,FSUtils.getRootDir(CONF),name,HConstants.HREGION_OLDLOGDIR_NAME,CONF,null,true,null,null);
    try {
      Field ringBufferEventHandlerField=FSHLog.class.getDeclaredField("ringBufferEventHandler");
      ringBufferEventHandlerField.setAccessible(true);
      FSHLog.RingBufferEventHandler ringBufferEventHandler=(FSHLog.RingBufferEventHandler)ringBufferEventHandlerField.get(log);
      Field syncRunnerIndexField=FSHLog.RingBufferEventHandler.class.getDeclaredField("syncRunnerIndex");
      syncRunnerIndexField.setAccessible(true);
      syncRunnerIndexField.set(ringBufferEventHandler,Integer.MAX_VALUE - 1);
      TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(this.name.getMethodName())).setColumnFamily(ColumnFamilyDescriptorBuilder.of("row")).build();
      NavigableMap<byte[],Integer> scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
      for (      byte[] fam : htd.getColumnFamilyNames()) {
        scopes.put(fam,0);
      }
      RegionInfo hri=RegionInfoBuilder.newBuilder(htd.getTableName()).build();
      MultiVersionConcurrencyControl mvcc=new MultiVersionConcurrencyControl();
      for (int i=0; i < 10; i++) {
        addEdits(log,hri,htd,1,mvcc,scopes);
      }
    }
  finally {
      log.close();
    }
  }
  /** 
 * Test case for https://issues.apache.org/jira/browse/HBASE-16721
 */
  @Test public void testUnflushedSeqIdTracking() throws IOException, InterruptedException {
    final String name=this.name.getMethodName();
    final byte[] b=Bytes.toBytes("b");
    final AtomicBoolean startHoldingForAppend=new AtomicBoolean(false);
    final CountDownLatch holdAppend=new CountDownLatch(1);
    final CountDownLatch flushFinished=new CountDownLatch(1);
    final CountDownLatch putFinished=new CountDownLatch(1);
    try (FSHLog log=new FSHLog(FS,FSUtils.getRootDir(CONF),name,HConstants.HREGION_OLDLOGDIR_NAME,CONF,null,true,null,null)){
      log.registerWALActionsListener(new WALActionsListener(){
        @Override public void visitLogEntryBeforeWrite(        WALKey logKey,        WALEdit logEdit) throws IOException {
          if (startHoldingForAppend.get()) {
            try {
              holdAppend.await();
            }
 catch (            InterruptedException e) {
              LOG.error(e.toString(),e);
            }
          }
        }
      }
);
      TableDescriptor htd=TableDescriptorBuilder.newBuilder(TableName.valueOf(this.name.getMethodName())).setColumnFamily(ColumnFamilyDescriptorBuilder.of(b)).build();
      RegionInfo hri=RegionInfoBuilder.newBuilder(htd.getTableName()).build();
      ChunkCreator.initialize(MemStoreLABImpl.CHUNK_SIZE_DEFAULT,false,0,0,0,null);
      final HRegion region=TEST_UTIL.createLocalHRegion(hri,htd,log);
      ExecutorService exec=Executors.newFixedThreadPool(2);
      region.put(new Put(b).addColumn(b,b,b));
      startHoldingForAppend.set(true);
      exec.submit(new Runnable(){
        @Override public void run(){
          try {
            region.put(new Put(b).addColumn(b,b,b));
            putFinished.countDown();
          }
 catch (          IOException e) {
            LOG.error(e.toString(),e);
          }
        }
      }
);
      Threads.sleep(3000);
      exec.submit(new Runnable(){
        @Override public void run(){
          try {
            HRegion.FlushResult flushResult=region.flush(true);
            LOG.info("Flush result:" + flushResult.getResult());
            LOG.info("Flush succeeded:" + flushResult.isFlushSucceeded());
            flushFinished.countDown();
          }
 catch (          IOException e) {
            LOG.error(e.toString(),e);
          }
        }
      }
);
      Threads.sleep(3000);
      holdAppend.countDown();
      putFinished.await();
      flushFinished.await();
      assertEquals("Region did not flush?",1,region.getStoreFileList(new byte[][]{b}).size());
      long seqId=log.getEarliestMemStoreSeqNum(hri.getEncodedNameAsBytes());
      assertEquals("Found seqId for the region which is already flushed",HConstants.NO_SEQNUM,seqId);
      region.close();
    }
   }
}
