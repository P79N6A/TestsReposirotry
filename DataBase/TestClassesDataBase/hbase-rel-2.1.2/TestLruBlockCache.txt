/** 
 * Tests the concurrent LruBlockCache.<p> Tests will ensure it grows and shrinks in size properly, evictions run when they're supposed to and do what they should, and that cached blocks are accessible when expected to be.
 */
@Category({IOTests.class,SmallTests.class}) public class TestLruBlockCache {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestLruBlockCache.class);
  @Test public void testCacheEvictionThreadSafe() throws Exception {
    long maxSize=100000;
    int numBlocks=9;
    int testRuns=10;
    final long blockSize=calculateBlockSizeDefault(maxSize,numBlocks);
    assertTrue("calculateBlockSize appears broken.",blockSize * numBlocks <= maxSize);
    final Configuration conf=HBaseConfiguration.create();
    final LruBlockCache cache=new LruBlockCache(maxSize,blockSize);
    EvictionThread evictionThread=cache.getEvictionThread();
    assertTrue(evictionThread != null);
    while (!evictionThread.isEnteringRun()) {
      Thread.sleep(1);
    }
    final String hfileName="hfile";
    int threads=10;
    final int blocksPerThread=5 * numBlocks;
    for (int run=0; run != testRuns; ++run) {
      final AtomicInteger blockCount=new AtomicInteger(0);
      ExecutorService service=Executors.newFixedThreadPool(threads);
      for (int i=0; i != threads; ++i) {
        service.execute(new Runnable(){
          @Override public void run(){
            for (int blockIndex=0; blockIndex < blocksPerThread || (!cache.isEvictionInProgress()); ++blockIndex) {
              CachedItem block=new CachedItem(hfileName,(int)blockSize,blockCount.getAndIncrement());
              boolean inMemory=Math.random() > 0.5;
              cache.cacheBlock(block.cacheKey,block,inMemory);
            }
            cache.evictBlocksByHfileName(hfileName);
          }
        }
);
      }
      service.shutdown();
      service.awaitTermination(10,TimeUnit.MINUTES);
      Waiter.waitFor(conf,10000,100,new ExplainingPredicate<Exception>(){
        @Override public boolean evaluate() throws Exception {
          return cache.getBlockCount() == 0;
        }
        @Override public String explainFailure() throws Exception {
          return "Cache block count failed to return to 0";
        }
      }
);
      assertEquals(0,cache.getBlockCount());
      assertEquals(cache.getOverhead(),cache.getCurrentSize());
    }
  }
  @Test public void testBackgroundEvictionThread() throws Exception {
    long maxSize=100000;
    int numBlocks=9;
    long blockSize=calculateBlockSizeDefault(maxSize,numBlocks);
    assertTrue("calculateBlockSize appears broken.",blockSize * numBlocks <= maxSize);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize);
    EvictionThread evictionThread=cache.getEvictionThread();
    assertTrue(evictionThread != null);
    CachedItem[] blocks=generateFixedBlocks(numBlocks + 1,blockSize,"block");
    while (!evictionThread.isEnteringRun()) {
      Thread.sleep(1);
    }
    for (    CachedItem block : blocks) {
      cache.cacheBlock(block.cacheKey,block);
    }
    int n=0;
    while (cache.getStats().getEvictionCount() == 0) {
      Thread.sleep(200);
      assertTrue("Eviction never happened.",n++ < 20);
    }
    n=0;
    for (long prevCnt=0, curCnt=cache.getBlockCount(); prevCnt != curCnt; prevCnt=curCnt, curCnt=cache.getBlockCount()) {
      Thread.sleep(200);
      assertTrue("Cache never stabilized.",n++ < 20);
    }
    long evictionCount=cache.getStats().getEvictionCount();
    assertTrue(evictionCount >= 1);
    System.out.println("Background Evictions run: " + evictionCount);
  }
  @Test public void testCacheSimple() throws Exception {
    long maxSize=1000000;
    long blockSize=calculateBlockSizeDefault(maxSize,101);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize);
    CachedItem[] blocks=generateRandomBlocks(100,blockSize);
    long expectedCacheSize=cache.heapSize();
    for (    CachedItem block : blocks) {
      assertTrue(cache.getBlock(block.cacheKey,true,false,true) == null);
    }
    for (    CachedItem block : blocks) {
      cache.cacheBlock(block.cacheKey,block);
      expectedCacheSize+=block.cacheBlockHeapSize();
    }
    assertEquals(expectedCacheSize,cache.heapSize());
    for (    CachedItem block : blocks) {
      HeapSize buf=cache.getBlock(block.cacheKey,true,false,true);
      assertTrue(buf != null);
      assertEquals(buf.heapSize(),block.heapSize());
    }
    long expectedBlockCount=cache.getBlockCount();
    for (    CachedItem block : blocks) {
      cache.cacheBlock(block.cacheKey,block);
    }
    assertEquals("Cache should ignore cache requests for blocks already in cache",expectedBlockCount,cache.getBlockCount());
    assertEquals(expectedCacheSize,cache.heapSize());
    for (    CachedItem block : blocks) {
      HeapSize buf=cache.getBlock(block.cacheKey,true,false,true);
      assertTrue(buf != null);
      assertEquals(buf.heapSize(),block.heapSize());
    }
    assertEquals(0,cache.getStats().getEvictionCount());
    Thread t=new LruBlockCache.StatisticsThread(cache);
    t.start();
    t.join();
  }
  @Test public void testCacheEvictionSimple() throws Exception {
    long maxSize=100000;
    long blockSize=calculateBlockSizeDefault(maxSize,10);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false);
    CachedItem[] blocks=generateFixedBlocks(10,blockSize,"block");
    long expectedCacheSize=cache.heapSize();
    for (    CachedItem block : blocks) {
      cache.cacheBlock(block.cacheKey,block);
      expectedCacheSize+=block.cacheBlockHeapSize();
    }
    assertEquals(1,cache.getStats().getEvictionCount());
    assertTrue(expectedCacheSize > (maxSize * LruBlockCache.DEFAULT_ACCEPTABLE_FACTOR));
    assertTrue(cache.heapSize() < maxSize);
    assertTrue(cache.heapSize() < (maxSize * LruBlockCache.DEFAULT_ACCEPTABLE_FACTOR));
    assertTrue(cache.getBlock(blocks[0].cacheKey,true,false,true) == null);
    for (int i=1; i < blocks.length; i++) {
      assertEquals(cache.getBlock(blocks[i].cacheKey,true,false,true),blocks[i]);
    }
  }
  @Test public void testCacheEvictionTwoPriorities() throws Exception {
    long maxSize=100000;
    long blockSize=calculateBlockSizeDefault(maxSize,10);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false);
    CachedItem[] singleBlocks=generateFixedBlocks(5,10000,"single");
    CachedItem[] multiBlocks=generateFixedBlocks(5,10000,"multi");
    long expectedCacheSize=cache.heapSize();
    for (    CachedItem block : multiBlocks) {
      cache.cacheBlock(block.cacheKey,block);
      expectedCacheSize+=block.cacheBlockHeapSize();
      assertEquals(cache.getBlock(block.cacheKey,true,false,true),block);
    }
    for (    CachedItem block : singleBlocks) {
      cache.cacheBlock(block.cacheKey,block);
      expectedCacheSize+=block.heapSize();
    }
    assertEquals(1,cache.getStats().getEvictionCount());
    assertEquals(2,cache.getStats().getEvictedCount());
    assertTrue(expectedCacheSize > (maxSize * LruBlockCache.DEFAULT_ACCEPTABLE_FACTOR));
    assertTrue(cache.heapSize() <= maxSize);
    assertTrue(cache.heapSize() <= (maxSize * LruBlockCache.DEFAULT_ACCEPTABLE_FACTOR));
    assertTrue(cache.getBlock(singleBlocks[0].cacheKey,true,false,true) == null);
    assertTrue(cache.getBlock(multiBlocks[0].cacheKey,true,false,true) == null);
    for (int i=1; i < 4; i++) {
      assertEquals(cache.getBlock(singleBlocks[i].cacheKey,true,false,true),singleBlocks[i]);
      assertEquals(cache.getBlock(multiBlocks[i].cacheKey,true,false,true),multiBlocks[i]);
    }
  }
  @Test public void testCacheEvictionThreePriorities() throws Exception {
    long maxSize=100000;
    long blockSize=calculateBlockSize(maxSize,10);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false,(int)Math.ceil(1.2 * maxSize / blockSize),LruBlockCache.DEFAULT_LOAD_FACTOR,LruBlockCache.DEFAULT_CONCURRENCY_LEVEL,0.98f,0.99f,0.33f,0.33f,0.34f,1.2f,false,16 * 1024 * 1024);
    CachedItem[] singleBlocks=generateFixedBlocks(5,blockSize,"single");
    CachedItem[] multiBlocks=generateFixedBlocks(5,blockSize,"multi");
    CachedItem[] memoryBlocks=generateFixedBlocks(5,blockSize,"memory");
    long expectedCacheSize=cache.heapSize();
    for (int i=0; i < 3; i++) {
      cache.cacheBlock(singleBlocks[i].cacheKey,singleBlocks[i]);
      expectedCacheSize+=singleBlocks[i].cacheBlockHeapSize();
      cache.cacheBlock(multiBlocks[i].cacheKey,multiBlocks[i]);
      expectedCacheSize+=multiBlocks[i].cacheBlockHeapSize();
      cache.getBlock(multiBlocks[i].cacheKey,true,false,true);
      cache.cacheBlock(memoryBlocks[i].cacheKey,memoryBlocks[i],true);
      expectedCacheSize+=memoryBlocks[i].cacheBlockHeapSize();
    }
    assertEquals(0,cache.getStats().getEvictionCount());
    assertEquals(expectedCacheSize,cache.heapSize());
    cache.cacheBlock(singleBlocks[3].cacheKey,singleBlocks[3]);
    assertEquals(1,cache.getStats().getEvictionCount());
    assertEquals(1,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[0].cacheKey,true,false,true));
    cache.getBlock(singleBlocks[1].cacheKey,true,false,true);
    cache.cacheBlock(singleBlocks[4].cacheKey,singleBlocks[4]);
    assertEquals(2,cache.getStats().getEvictionCount());
    assertEquals(2,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(multiBlocks[0].cacheKey,true,false,true));
    cache.cacheBlock(memoryBlocks[3].cacheKey,memoryBlocks[3],true);
    assertEquals(3,cache.getStats().getEvictionCount());
    assertEquals(3,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(memoryBlocks[0].cacheKey,true,false,true));
    CachedItem[] bigBlocks=generateFixedBlocks(3,blockSize * 3,"big");
    cache.cacheBlock(bigBlocks[0].cacheKey,bigBlocks[0]);
    assertEquals(4,cache.getStats().getEvictionCount());
    assertEquals(6,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[2].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(singleBlocks[3].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(singleBlocks[4].cacheKey,true,false,true));
    cache.getBlock(bigBlocks[0].cacheKey,true,false,true);
    cache.cacheBlock(bigBlocks[1].cacheKey,bigBlocks[1]);
    assertEquals(5,cache.getStats().getEvictionCount());
    assertEquals(9,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[1].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[1].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[2].cacheKey,true,false,true));
    cache.cacheBlock(bigBlocks[2].cacheKey,bigBlocks[2],true);
    assertEquals(6,cache.getStats().getEvictionCount());
    assertEquals(12,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(memoryBlocks[1].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(memoryBlocks[2].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(memoryBlocks[3].cacheKey,true,false,true));
  }
  @Test public void testCacheEvictionInMemoryForceMode() throws Exception {
    long maxSize=100000;
    long blockSize=calculateBlockSize(maxSize,10);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false,(int)Math.ceil(1.2 * maxSize / blockSize),LruBlockCache.DEFAULT_LOAD_FACTOR,LruBlockCache.DEFAULT_CONCURRENCY_LEVEL,0.98f,0.99f,0.2f,0.3f,0.5f,1.2f,true,16 * 1024 * 1024);
    CachedItem[] singleBlocks=generateFixedBlocks(10,blockSize,"single");
    CachedItem[] multiBlocks=generateFixedBlocks(10,blockSize,"multi");
    CachedItem[] memoryBlocks=generateFixedBlocks(10,blockSize,"memory");
    long expectedCacheSize=cache.heapSize();
    for (int i=0; i < 4; i++) {
      cache.cacheBlock(singleBlocks[i].cacheKey,singleBlocks[i]);
      expectedCacheSize+=singleBlocks[i].cacheBlockHeapSize();
      cache.cacheBlock(multiBlocks[i].cacheKey,multiBlocks[i]);
      expectedCacheSize+=multiBlocks[i].cacheBlockHeapSize();
      cache.getBlock(multiBlocks[i].cacheKey,true,false,true);
    }
    cache.cacheBlock(singleBlocks[4].cacheKey,singleBlocks[4]);
    expectedCacheSize+=singleBlocks[4].cacheBlockHeapSize();
    assertEquals(0,cache.getStats().getEvictionCount());
    assertEquals(expectedCacheSize,cache.heapSize());
    cache.cacheBlock(memoryBlocks[0].cacheKey,memoryBlocks[0],true);
    assertEquals(1,cache.getStats().getEvictionCount());
    assertEquals(1,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[0].cacheKey,true,false,true));
    cache.cacheBlock(memoryBlocks[1].cacheKey,memoryBlocks[1],true);
    assertEquals(2,cache.getStats().getEvictionCount());
    assertEquals(2,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[1].cacheKey,true,false,true));
    cache.cacheBlock(memoryBlocks[2].cacheKey,memoryBlocks[2],true);
    cache.cacheBlock(memoryBlocks[3].cacheKey,memoryBlocks[3],true);
    cache.cacheBlock(memoryBlocks[4].cacheKey,memoryBlocks[4],true);
    cache.cacheBlock(memoryBlocks[5].cacheKey,memoryBlocks[5],true);
    assertEquals(6,cache.getStats().getEvictionCount());
    assertEquals(6,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[2].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(singleBlocks[3].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[0].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[1].cacheKey,true,false,true));
    cache.cacheBlock(memoryBlocks[6].cacheKey,memoryBlocks[6],true);
    cache.cacheBlock(memoryBlocks[7].cacheKey,memoryBlocks[7],true);
    cache.cacheBlock(memoryBlocks[8].cacheKey,memoryBlocks[8],true);
    assertEquals(9,cache.getStats().getEvictionCount());
    assertEquals(9,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[4].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[2].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[3].cacheKey,true,false,true));
    cache.cacheBlock(memoryBlocks[9].cacheKey,memoryBlocks[9],true);
    assertEquals(10,cache.getStats().getEvictionCount());
    assertEquals(10,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(memoryBlocks[0].cacheKey,true,false,true));
    cache.cacheBlock(singleBlocks[9].cacheKey,singleBlocks[9]);
    assertEquals(11,cache.getStats().getEvictionCount());
    assertEquals(11,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[9].cacheKey,true,false,true));
  }
  @Test public void testScanResistance() throws Exception {
    long maxSize=100000;
    long blockSize=calculateBlockSize(maxSize,10);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false,(int)Math.ceil(1.2 * maxSize / blockSize),LruBlockCache.DEFAULT_LOAD_FACTOR,LruBlockCache.DEFAULT_CONCURRENCY_LEVEL,0.66f,0.99f,0.33f,0.33f,0.34f,1.2f,false,16 * 1024 * 1024);
    CachedItem[] singleBlocks=generateFixedBlocks(20,blockSize,"single");
    CachedItem[] multiBlocks=generateFixedBlocks(5,blockSize,"multi");
    for (    CachedItem block : multiBlocks) {
      cache.cacheBlock(block.cacheKey,block);
      cache.getBlock(block.cacheKey,true,false,true);
    }
    for (int i=0; i < 5; i++) {
      cache.cacheBlock(singleBlocks[i].cacheKey,singleBlocks[i]);
    }
    assertEquals(1,cache.getStats().getEvictionCount());
    assertEquals(4,cache.getStats().getEvictedCount());
    assertEquals(null,cache.getBlock(singleBlocks[0].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(singleBlocks[1].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[0].cacheKey,true,false,true));
    assertEquals(null,cache.getBlock(multiBlocks[1].cacheKey,true,false,true));
    for (int i=5; i < 18; i++) {
      cache.cacheBlock(singleBlocks[i].cacheKey,singleBlocks[i]);
    }
    assertEquals(4,cache.getStats().getEvictionCount());
    assertEquals(16,cache.getStats().getEvictedCount());
    assertEquals(7,cache.getBlockCount());
  }
  @Test public void testMaxBlockSize() throws Exception {
    long maxSize=100000;
    long blockSize=calculateBlockSize(maxSize,10);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false,(int)Math.ceil(1.2 * maxSize / blockSize),LruBlockCache.DEFAULT_LOAD_FACTOR,LruBlockCache.DEFAULT_CONCURRENCY_LEVEL,0.66f,0.99f,0.33f,0.33f,0.34f,1.2f,false,1024);
    CachedItem[] tooLong=generateFixedBlocks(10,1024 + 5,"long");
    CachedItem[] small=generateFixedBlocks(15,600,"small");
    for (    CachedItem i : tooLong) {
      cache.cacheBlock(i.cacheKey,i);
    }
    for (    CachedItem i : small) {
      cache.cacheBlock(i.cacheKey,i);
    }
    assertEquals(15,cache.getBlockCount());
    for (    CachedItem i : small) {
      assertNotNull(cache.getBlock(i.cacheKey,true,false,false));
    }
    for (    CachedItem i : tooLong) {
      assertNull(cache.getBlock(i.cacheKey,true,false,false));
    }
    assertEquals(10,cache.getStats().getFailedInserts());
  }
  @Test public void testResizeBlockCache() throws Exception {
    long maxSize=300000;
    long blockSize=calculateBlockSize(maxSize,31);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false,(int)Math.ceil(1.2 * maxSize / blockSize),LruBlockCache.DEFAULT_LOAD_FACTOR,LruBlockCache.DEFAULT_CONCURRENCY_LEVEL,0.98f,0.99f,0.33f,0.33f,0.34f,1.2f,false,16 * 1024 * 1024);
    CachedItem[] singleBlocks=generateFixedBlocks(10,blockSize,"single");
    CachedItem[] multiBlocks=generateFixedBlocks(10,blockSize,"multi");
    CachedItem[] memoryBlocks=generateFixedBlocks(10,blockSize,"memory");
    for (int i=0; i < 10; i++) {
      cache.cacheBlock(singleBlocks[i].cacheKey,singleBlocks[i]);
      cache.cacheBlock(multiBlocks[i].cacheKey,multiBlocks[i]);
      cache.getBlock(multiBlocks[i].cacheKey,true,false,true);
      cache.cacheBlock(memoryBlocks[i].cacheKey,memoryBlocks[i],true);
    }
    assertEquals(0,cache.getStats().getEvictionCount());
    cache.setMaxSize((long)(maxSize * 0.5f));
    assertEquals(1,cache.getStats().getEvictionCount());
    assertEquals(15,cache.getStats().getEvictedCount());
    for (int i=0; i < 5; i++) {
      assertEquals(null,cache.getBlock(singleBlocks[i].cacheKey,true,false,true));
      assertEquals(null,cache.getBlock(multiBlocks[i].cacheKey,true,false,true));
      assertEquals(null,cache.getBlock(memoryBlocks[i].cacheKey,true,false,true));
    }
    for (int i=5; i < 10; i++) {
      assertEquals(singleBlocks[i],cache.getBlock(singleBlocks[i].cacheKey,true,false,true));
      assertEquals(multiBlocks[i],cache.getBlock(multiBlocks[i].cacheKey,true,false,true));
      assertEquals(memoryBlocks[i],cache.getBlock(memoryBlocks[i].cacheKey,true,false,true));
    }
  }
  @Test public void testPastNPeriodsMetrics() throws Exception {
    double delta=0.01;
    CacheStats stats=new CacheStats("test",3);
    stats.rollMetricsPeriod();
    assertEquals(0.0,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.0,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.hit(false,true,BlockType.DATA);
    stats.hit(true,true,BlockType.DATA);
    stats.miss(false,false,BlockType.DATA);
    stats.miss(false,false,BlockType.DATA);
    stats.rollMetricsPeriod();
    assertEquals(0.5,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(1.0,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.miss(true,false,BlockType.DATA);
    stats.miss(false,false,BlockType.DATA);
    stats.miss(false,false,BlockType.DATA);
    stats.miss(false,false,BlockType.DATA);
    stats.rollMetricsPeriod();
    assertEquals(0.25,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.5,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.hit(false,true,BlockType.DATA);
    stats.hit(true,true,BlockType.DATA);
    stats.hit(false,true,BlockType.DATA);
    stats.hit(true,true,BlockType.DATA);
    stats.rollMetricsPeriod();
    assertEquals(0.5,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.75,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.miss(true,false,BlockType.DATA);
    stats.miss(true,false,BlockType.DATA);
    stats.rollMetricsPeriod();
    assertEquals(0.4,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.4,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.miss(true,false,BlockType.DATA);
    stats.miss(true,false,BlockType.DATA);
    stats.hit(false,true,BlockType.DATA);
    stats.hit(false,true,BlockType.DATA);
    stats.rollMetricsPeriod();
    assertEquals(0.6,stats.getHitRatioPastNPeriods(),delta);
    assertEquals((double)1 / 3,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.rollMetricsPeriod();
    assertEquals((double)1 / 3,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.0,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.rollMetricsPeriod();
    assertEquals(0.5,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.0,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.rollMetricsPeriod();
    assertEquals(0.0,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.0,stats.getHitCachingRatioPastNPeriods(),delta);
    stats.miss(true,false,BlockType.DATA);
    stats.miss(false,false,BlockType.DATA);
    stats.hit(true,true,BlockType.DATA);
    stats.hit(false,true,BlockType.DATA);
    stats.rollMetricsPeriod();
    assertEquals(0.5,stats.getHitRatioPastNPeriods(),delta);
    assertEquals(0.5,stats.getHitCachingRatioPastNPeriods(),delta);
  }
  @Test public void testCacheBlockNextBlockMetadataMissing(){
    long maxSize=100000;
    long blockSize=calculateBlockSize(maxSize,10);
    int size=100;
    int length=HConstants.HFILEBLOCK_HEADER_SIZE + size;
    byte[] byteArr=new byte[length];
    ByteBuffer buf=ByteBuffer.wrap(byteArr,0,size);
    HFileContext meta=new HFileContextBuilder().build();
    HFileBlock blockWithNextBlockMetadata=new HFileBlock(BlockType.DATA,size,size,-1,buf,HFileBlock.FILL_HEADER,-1,52,-1,meta);
    HFileBlock blockWithoutNextBlockMetadata=new HFileBlock(BlockType.DATA,size,size,-1,buf,HFileBlock.FILL_HEADER,-1,-1,-1,meta);
    LruBlockCache cache=new LruBlockCache(maxSize,blockSize,false,(int)Math.ceil(1.2 * maxSize / blockSize),LruBlockCache.DEFAULT_LOAD_FACTOR,LruBlockCache.DEFAULT_CONCURRENCY_LEVEL,0.66f,0.99f,0.33f,0.33f,0.34f,1.2f,false,1024);
    BlockCacheKey key=new BlockCacheKey("key1",0);
    ByteBuffer actualBuffer=ByteBuffer.allocate(length);
    ByteBuffer block1Buffer=ByteBuffer.allocate(length);
    ByteBuffer block2Buffer=ByteBuffer.allocate(length);
    blockWithNextBlockMetadata.serialize(block1Buffer,true);
    blockWithoutNextBlockMetadata.serialize(block2Buffer,true);
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithNextBlockMetadata,actualBuffer,block1Buffer);
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithoutNextBlockMetadata,actualBuffer,block1Buffer);
    cache.clearCache();
    assertNull(cache.getBlock(key,false,false,false));
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithoutNextBlockMetadata,actualBuffer,block2Buffer);
    CacheTestUtils.getBlockAndAssertEquals(cache,key,blockWithNextBlockMetadata,actualBuffer,block1Buffer);
  }
  private CachedItem[] generateFixedBlocks(  int numBlocks,  int size,  String pfx){
    CachedItem[] blocks=new CachedItem[numBlocks];
    for (int i=0; i < numBlocks; i++) {
      blocks[i]=new CachedItem(pfx + i,size);
    }
    return blocks;
  }
  private CachedItem[] generateFixedBlocks(  int numBlocks,  long size,  String pfx){
    return generateFixedBlocks(numBlocks,(int)size,pfx);
  }
  private CachedItem[] generateRandomBlocks(  int numBlocks,  long maxSize){
    CachedItem[] blocks=new CachedItem[numBlocks];
    Random r=new Random();
    for (int i=0; i < numBlocks; i++) {
      blocks[i]=new CachedItem("block" + i,r.nextInt((int)maxSize) + 1);
    }
    return blocks;
  }
  private long calculateBlockSize(  long maxSize,  int numBlocks){
    long roughBlockSize=maxSize / numBlocks;
    int numEntries=(int)Math.ceil((1.2) * maxSize / roughBlockSize);
    long totalOverhead=LruBlockCache.CACHE_FIXED_OVERHEAD + ClassSize.CONCURRENT_HASHMAP + (numEntries * ClassSize.CONCURRENT_HASHMAP_ENTRY)+ (LruBlockCache.DEFAULT_CONCURRENCY_LEVEL * ClassSize.CONCURRENT_HASHMAP_SEGMENT);
    long negateBlockSize=(long)(totalOverhead / numEntries);
    negateBlockSize+=LruCachedBlock.PER_BLOCK_OVERHEAD;
    return ClassSize.align((long)Math.floor((roughBlockSize - negateBlockSize) * 0.99f));
  }
  private long calculateBlockSizeDefault(  long maxSize,  int numBlocks){
    long roughBlockSize=maxSize / numBlocks;
    int numEntries=(int)Math.ceil((1.2) * maxSize / roughBlockSize);
    long totalOverhead=LruBlockCache.CACHE_FIXED_OVERHEAD + ClassSize.CONCURRENT_HASHMAP + (numEntries * ClassSize.CONCURRENT_HASHMAP_ENTRY)+ (LruBlockCache.DEFAULT_CONCURRENCY_LEVEL * ClassSize.CONCURRENT_HASHMAP_SEGMENT);
    long negateBlockSize=totalOverhead / numEntries;
    negateBlockSize+=LruCachedBlock.PER_BLOCK_OVERHEAD;
    return ClassSize.align((long)Math.floor((roughBlockSize - negateBlockSize) * LruBlockCache.DEFAULT_ACCEPTABLE_FACTOR));
  }
private static class CachedItem implements Cacheable {
    BlockCacheKey cacheKey;
    int size;
    CachedItem(    String blockName,    int size,    int offset){
      this.cacheKey=new BlockCacheKey(blockName,offset);
      this.size=size;
    }
    CachedItem(    String blockName,    int size){
      this.cacheKey=new BlockCacheKey(blockName,0);
      this.size=size;
    }
    /** 
 * The size of this item reported to the block cache layer 
 */
    @Override public long heapSize(){
      return ClassSize.align(size);
    }
    /** 
 * Size of the cache block holding this item. Used for verification. 
 */
    public long cacheBlockHeapSize(){
      return LruCachedBlock.PER_BLOCK_OVERHEAD + ClassSize.align(cacheKey.heapSize()) + ClassSize.align(size);
    }
    @Override public int getSerializedLength(){
      return 0;
    }
    @Override public CacheableDeserializer<Cacheable> getDeserializer(){
      return null;
    }
    @Override public void serialize(    ByteBuffer destination,    boolean includeNextBlockMetadata){
    }
    @Override public BlockType getBlockType(){
      return BlockType.DATA;
    }
    @Override public MemoryType getMemoryType(){
      return MemoryType.EXCLUSIVE;
    }
  }
}
