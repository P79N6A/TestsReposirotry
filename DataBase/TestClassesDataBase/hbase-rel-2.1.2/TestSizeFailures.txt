@Category(LargeTests.class) public class TestSizeFailures {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSizeFailures.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestSizeFailures.class);
  protected final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static byte[] FAMILY=Bytes.toBytes("testFamily");
  protected static int SLAVES=1;
  private static TableName TABLENAME;
  private static final int NUM_ROWS=1000 * 1000, NUM_COLS=9;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setBoolean("hbase.table.sanity.checks",true);
    TEST_UTIL.startMiniCluster(SLAVES);
    TABLENAME=TableName.valueOf("testSizeFailures");
    List<byte[]> qualifiers=new ArrayList<>();
    for (int i=1; i <= 10; i++) {
      qualifiers.add(Bytes.toBytes(Integer.toString(i)));
    }
    HColumnDescriptor hcd=new HColumnDescriptor(FAMILY);
    HTableDescriptor desc=new HTableDescriptor(TABLENAME);
    desc.addFamily(hcd);
    byte[][] splits=new byte[9][2];
    for (int i=1; i < 10; i++) {
      int split=48 + i;
      splits[i - 1][0]=(byte)(split >>> 8);
      splits[i - 1][0]=(byte)(split);
    }
    TEST_UTIL.getAdmin().createTable(desc,splits);
    Connection conn=TEST_UTIL.getConnection();
    try (Table table=conn.getTable(TABLENAME)){
      List<Put> puts=new LinkedList<>();
      for (int i=0; i < NUM_ROWS; i++) {
        Put p=new Put(Bytes.toBytes(Integer.toString(i)));
        for (int j=0; j < NUM_COLS; j++) {
          byte[] value=new byte[50];
          Bytes.random(value);
          p.addColumn(FAMILY,Bytes.toBytes(Integer.toString(j)),value);
        }
        puts.add(p);
        if (puts.size() == 1000) {
          table.batch(puts,null);
          puts.clear();
        }
      }
      if (puts.size() > 0) {
        table.batch(puts,null);
      }
    }
   }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  /** 
 * Basic client side validation of HBASE-13262
 */
  @Test public void testScannerSeesAllRecords() throws Exception {
    Connection conn=TEST_UTIL.getConnection();
    try (Table table=conn.getTable(TABLENAME)){
      Scan s=new Scan();
      s.addFamily(FAMILY);
      s.setMaxResultSize(-1);
      s.setBatch(-1);
      s.setCaching(500);
      Entry<Long,Long> entry=sumTable(table.getScanner(s));
      long rowsObserved=entry.getKey();
      long entriesObserved=entry.getValue();
      assertEquals(NUM_ROWS,rowsObserved);
      assertEquals(NUM_ROWS * NUM_COLS,entriesObserved);
    }
   }
  /** 
 * Basic client side validation of HBASE-13262
 */
  @Test public void testSmallScannerSeesAllRecords() throws Exception {
    Connection conn=TEST_UTIL.getConnection();
    try (Table table=conn.getTable(TABLENAME)){
      Scan s=new Scan();
      s.setSmall(true);
      s.addFamily(FAMILY);
      s.setMaxResultSize(-1);
      s.setBatch(-1);
      s.setCaching(500);
      Entry<Long,Long> entry=sumTable(table.getScanner(s));
      long rowsObserved=entry.getKey();
      long entriesObserved=entry.getValue();
      assertEquals(NUM_ROWS,rowsObserved);
      assertEquals(NUM_ROWS * NUM_COLS,entriesObserved);
    }
   }
  /** 
 * Count the number of rows and the number of entries from a scanner
 * @param scanner The Scanner
 * @return An entry where the first item is rows observed and the second is entries observed.
 */
  private Entry<Long,Long> sumTable(  ResultScanner scanner){
    long rowsObserved=0L;
    long entriesObserved=0L;
    for (    Result result : scanner) {
      rowsObserved++;
      while (result.advance()) {
        entriesObserved++;
      }
    }
    return Maps.immutableEntry(rowsObserved,entriesObserved);
  }
}
