public class TestCompactor {
  public static HStoreFile createDummyStoreFile(  long maxSequenceId) throws Exception {
    HStoreFile sf=mock(HStoreFile.class);
    StoreFileReader r=mock(StoreFileReader.class);
    when(r.length()).thenReturn(1L);
    when(r.getBloomFilterType()).thenReturn(BloomType.NONE);
    when(r.getHFileReader()).thenReturn(mock(HFile.Reader.class));
    when(r.getStoreFileScanner(anyBoolean(),anyBoolean(),anyBoolean(),anyLong(),anyLong(),anyBoolean())).thenReturn(mock(StoreFileScanner.class));
    when(sf.getReader()).thenReturn(r);
    when(sf.getMaxSequenceId()).thenReturn(maxSequenceId);
    return sf;
  }
  public static CompactionRequestImpl createDummyRequest() throws Exception {
    return new CompactionRequestImpl(Arrays.asList(createDummyStoreFile(1L)));
  }
public static class StoreFileWritersCapture implements Answer<StoreFileWriter>, StripeMultiFileWriter.WriterFactory {
public static class Writer {
      public ArrayList<KeyValue> kvs=new ArrayList<>();
      public TreeMap<byte[],byte[]> data=new TreeMap<>(Bytes.BYTES_COMPARATOR);
      public boolean hasMetadata;
    }
    private List<Writer> writers=new ArrayList<>();
    @Override public StoreFileWriter createWriter() throws IOException {
      final Writer realWriter=new Writer();
      writers.add(realWriter);
      StoreFileWriter writer=mock(StoreFileWriter.class);
      doAnswer(new Answer<Object>(){
        @Override public Object answer(        InvocationOnMock invocation){
          return realWriter.kvs.add((KeyValue)invocation.getArgument(0));
        }
      }
).when(writer).append(any());
      doAnswer(new Answer<Object>(){
        @Override public Object answer(        InvocationOnMock invocation){
          Object[] args=invocation.getArguments();
          return realWriter.data.put((byte[])args[0],(byte[])args[1]);
        }
      }
).when(writer).appendFileInfo(any(),any());
      doAnswer(new Answer<Void>(){
        @Override public Void answer(        InvocationOnMock invocation) throws Throwable {
          realWriter.hasMetadata=true;
          return null;
        }
      }
).when(writer).appendMetadata(anyLong(),anyBoolean());
      doAnswer(new Answer<Path>(){
        @Override public Path answer(        InvocationOnMock invocation) throws Throwable {
          return new Path("foo");
        }
      }
).when(writer).getPath();
      return writer;
    }
    @Override public StoreFileWriter answer(    InvocationOnMock invocation) throws Throwable {
      return createWriter();
    }
    public void verifyKvs(    KeyValue[][] kvss,    boolean allFiles,    boolean requireMetadata){
      if (allFiles) {
        assertEquals(kvss.length,writers.size());
      }
      int skippedWriters=0;
      for (int i=0; i < kvss.length; ++i) {
        KeyValue[] kvs=kvss[i];
        if (kvs != null) {
          Writer w=writers.get(i - skippedWriters);
          if (requireMetadata) {
            assertNotNull(w.data.get(STRIPE_START_KEY));
            assertNotNull(w.data.get(STRIPE_END_KEY));
          }
 else {
            assertNull(w.data.get(STRIPE_START_KEY));
            assertNull(w.data.get(STRIPE_END_KEY));
          }
          assertEquals(kvs.length,w.kvs.size());
          for (int j=0; j < kvs.length; ++j) {
            assertEquals(kvs[j],w.kvs.get(j));
          }
        }
 else {
          assertFalse(allFiles);
          ++skippedWriters;
        }
      }
    }
    public void verifyBoundaries(    byte[][] boundaries){
      assertEquals(boundaries.length - 1,writers.size());
      for (int i=0; i < writers.size(); ++i) {
        assertArrayEquals("i = " + i,boundaries[i],writers.get(i).data.get(STRIPE_START_KEY));
        assertArrayEquals("i = " + i,boundaries[i + 1],writers.get(i).data.get(STRIPE_END_KEY));
      }
    }
    public void verifyKvs(    KeyValue[][] kvss,    boolean allFiles,    List<Long> boundaries){
      if (allFiles) {
        assertEquals(kvss.length,writers.size());
      }
      int skippedWriters=0;
      for (int i=0; i < kvss.length; ++i) {
        KeyValue[] kvs=kvss[i];
        if (kvs != null) {
          Writer w=writers.get(i - skippedWriters);
          assertEquals(kvs.length,w.kvs.size());
          for (int j=0; j < kvs.length; ++j) {
            assertTrue(kvs[j].getTimestamp() >= boundaries.get(i));
            assertTrue(kvs[j].getTimestamp() < boundaries.get(i + 1));
            assertEquals(kvs[j],w.kvs.get(j));
          }
        }
 else {
          assertFalse(allFiles);
          ++skippedWriters;
        }
      }
    }
    public List<Writer> getWriters(){
      return writers;
    }
  }
public static class Scanner implements InternalScanner {
    private final ArrayList<KeyValue> kvs;
    public Scanner(    KeyValue... kvs){
      this.kvs=new ArrayList<>(Arrays.asList(kvs));
    }
    @Override public boolean next(    List<Cell> result,    ScannerContext scannerContext) throws IOException {
      if (kvs.isEmpty())       return false;
      result.add(kvs.remove(0));
      return !kvs.isEmpty();
    }
    @Override public void close() throws IOException {
    }
  }
}
