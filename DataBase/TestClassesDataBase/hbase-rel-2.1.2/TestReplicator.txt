@Category(MediumTests.class) public class TestReplicator extends TestReplicationBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestReplicator.class);
  static final Logger LOG=LoggerFactory.getLogger(TestReplicator.class);
  static final int NUM_ROWS=10;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    conf1.setInt(RpcServer.MAX_REQUEST_SIZE,1024 * 10);
    TestReplicationBase.setUpBeforeClass();
  }
  @Test public void testReplicatorBatching() throws Exception {
    truncateTable(utility1,tableName);
    truncateTable(utility2,tableName);
    admin.addPeer("testReplicatorBatching",new ReplicationPeerConfig().setClusterKey(utility2.getClusterKey()).setReplicationEndpointImpl(ReplicationEndpointForTest.class.getName()),null);
    ReplicationEndpointForTest.setBatchCount(0);
    ReplicationEndpointForTest.setEntriesCount(0);
    try {
      ReplicationEndpointForTest.pause();
      try {
        final byte[] valueBytes=new byte[8 * 1024];
        for (int i=0; i < NUM_ROWS; i++) {
          htable1.put(new Put(Bytes.toBytes("row" + Integer.toString(i))).addColumn(famName,null,valueBytes));
        }
      }
  finally {
        ReplicationEndpointForTest.resume();
      }
      Waiter.waitFor(conf1,60000,new Waiter.ExplainingPredicate<Exception>(){
        @Override public boolean evaluate() throws Exception {
          LOG.info("Count=" + ReplicationEndpointForTest.getBatchCount());
          return ReplicationEndpointForTest.getBatchCount() >= NUM_ROWS;
        }
        @Override public String explainFailure() throws Exception {
          return "We waited too long for expected replication of " + NUM_ROWS + " entries";
        }
      }
);
      assertEquals("We sent an incorrect number of batches",NUM_ROWS,ReplicationEndpointForTest.getBatchCount());
      assertEquals("We did not replicate enough rows",NUM_ROWS,utility2.countRows(htable2));
    }
  finally {
      admin.removePeer("testReplicatorBatching");
    }
  }
  @Test public void testReplicatorWithErrors() throws Exception {
    truncateTable(utility1,tableName);
    truncateTable(utility2,tableName);
    admin.addPeer("testReplicatorWithErrors",new ReplicationPeerConfig().setClusterKey(utility2.getClusterKey()).setReplicationEndpointImpl(FailureInjectingReplicationEndpointForTest.class.getName()),null);
    FailureInjectingReplicationEndpointForTest.setBatchCount(0);
    FailureInjectingReplicationEndpointForTest.setEntriesCount(0);
    try {
      FailureInjectingReplicationEndpointForTest.pause();
      try {
        final byte[] valueBytes=new byte[8 * 1024];
        for (int i=0; i < NUM_ROWS; i++) {
          htable1.put(new Put(Bytes.toBytes("row" + Integer.toString(i))).addColumn(famName,null,valueBytes));
        }
      }
  finally {
        FailureInjectingReplicationEndpointForTest.resume();
      }
      Waiter.waitFor(conf1,60000,new Waiter.ExplainingPredicate<Exception>(){
        @Override public boolean evaluate() throws Exception {
          return FailureInjectingReplicationEndpointForTest.getEntriesCount() >= NUM_ROWS;
        }
        @Override public String explainFailure() throws Exception {
          return "We waited too long for expected replication of " + NUM_ROWS + " entries";
        }
      }
);
      assertEquals("We did not replicate enough rows",NUM_ROWS,utility2.countRows(htable2));
    }
  finally {
      admin.removePeer("testReplicatorWithErrors");
    }
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TestReplicationBase.tearDownAfterClass();
  }
  private void truncateTable(  HBaseTestingUtility util,  TableName tablename) throws IOException {
    HBaseAdmin admin=util.getHBaseAdmin();
    admin.disableTable(tableName);
    admin.truncateTable(tablename,false);
  }
public static class ReplicationEndpointForTest extends HBaseInterClusterReplicationEndpoint {
    protected static AtomicInteger batchCount=new AtomicInteger(0);
    protected static int entriesCount;
    private static final Object latch=new Object();
    private static AtomicBoolean useLatch=new AtomicBoolean(false);
    public static void resume(){
      useLatch.set(false);
synchronized (latch) {
        latch.notifyAll();
      }
    }
    public static void pause(){
      useLatch.set(true);
    }
    public static void await() throws InterruptedException {
      if (useLatch.get()) {
        LOG.info("Waiting on latch");
synchronized (latch) {
          latch.wait();
        }
        LOG.info("Waited on latch, now proceeding");
      }
    }
    public static int getBatchCount(){
      return batchCount.get();
    }
    public static void setBatchCount(    int i){
      LOG.info("SetBatchCount=" + i + ", old="+ getBatchCount());
      batchCount.set(i);
    }
    public static int getEntriesCount(){
      return entriesCount;
    }
    public static void setEntriesCount(    int i){
      LOG.info("SetEntriesCount=" + i);
      entriesCount=i;
    }
    @Override public boolean replicate(    ReplicateContext replicateContext){
      try {
        await();
      }
 catch (      InterruptedException e) {
        LOG.warn("Interrupted waiting for latch",e);
      }
      return super.replicate(replicateContext);
    }
    @Override protected Callable<Integer> createReplicator(    List<Entry> entries,    int ordinal){
      return () -> {
        int batchIndex=replicateEntries(entries,ordinal);
        entriesCount+=entries.size();
        int count=batchCount.incrementAndGet();
        LOG.info("Completed replicating batch " + System.identityHashCode(entries) + " count="+ count);
        return batchIndex;
      }
;
    }
  }
public static class FailureInjectingReplicationEndpointForTest extends ReplicationEndpointForTest {
    private final AtomicBoolean failNext=new AtomicBoolean(false);
    @Override protected Callable<Integer> createReplicator(    List<Entry> entries,    int ordinal){
      return () -> {
        if (failNext.compareAndSet(false,true)) {
          int batchIndex=replicateEntries(entries,ordinal);
          entriesCount+=entries.size();
          int count=batchCount.incrementAndGet();
          LOG.info("Completed replicating batch " + System.identityHashCode(entries) + " count="+ count);
          return batchIndex;
        }
 else         if (failNext.compareAndSet(true,false)) {
          throw new ServiceException("Injected failure");
        }
        return ordinal;
      }
;
    }
  }
}
