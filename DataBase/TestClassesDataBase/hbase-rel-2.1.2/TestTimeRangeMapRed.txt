@Category({MapReduceTests.class,LargeTests.class}) public class TestTimeRangeMapRed {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestTimeRangeMapRed.class);
  private final static Logger log=LoggerFactory.getLogger(TestTimeRangeMapRed.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private Admin admin;
  private static final byte[] KEY=Bytes.toBytes("row1");
  private static final NavigableMap<Long,Boolean> TIMESTAMP=new TreeMap<>();
static {
    TIMESTAMP.put((long)1245620000,false);
    TIMESTAMP.put((long)1245620005,true);
    TIMESTAMP.put((long)1245620010,true);
    TIMESTAMP.put((long)1245620055,true);
    TIMESTAMP.put((long)1245620100,true);
    TIMESTAMP.put((long)1245620150,false);
    TIMESTAMP.put((long)1245620250,false);
  }
  static final long MINSTAMP=1245620005;
  static final long MAXSTAMP=1245620100 + 1;
  static final TableName TABLE_NAME=TableName.valueOf("table123");
  static final byte[] FAMILY_NAME=Bytes.toBytes("text");
  static final byte[] COLUMN_NAME=Bytes.toBytes("input");
  @BeforeClass public static void beforeClass() throws Exception {
    UTIL.startMiniCluster();
  }
  @AfterClass public static void afterClass() throws Exception {
    UTIL.shutdownMiniCluster();
  }
  @Before public void before() throws Exception {
    this.admin=UTIL.getAdmin();
  }
private static class ProcessTimeRangeMapper extends TableMapper<ImmutableBytesWritable,MapWritable> implements Configurable {
    private Configuration conf=null;
    private Table table=null;
    @Override public void map(    ImmutableBytesWritable key,    Result result,    Context context) throws IOException {
      List<Long> tsList=new ArrayList<>();
      for (      Cell kv : result.listCells()) {
        tsList.add(kv.getTimestamp());
      }
      List<Put> puts=new ArrayList<>();
      for (      Long ts : tsList) {
        Put put=new Put(key.get());
        put.setDurability(Durability.SKIP_WAL);
        put.addColumn(FAMILY_NAME,COLUMN_NAME,ts,Bytes.toBytes(true));
        puts.add(put);
      }
      table.put(puts);
    }
    @Override public Configuration getConf(){
      return conf;
    }
    @Override public void setConf(    Configuration configuration){
      this.conf=configuration;
      try {
        Connection connection=ConnectionFactory.createConnection(conf);
        table=connection.getTable(TABLE_NAME);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  @Test public void testTimeRangeMapRed() throws IOException, InterruptedException, ClassNotFoundException {
    final HTableDescriptor desc=new HTableDescriptor(TABLE_NAME);
    final HColumnDescriptor col=new HColumnDescriptor(FAMILY_NAME);
    col.setMaxVersions(Integer.MAX_VALUE);
    desc.addFamily(col);
    admin.createTable(desc);
    List<Put> puts=new ArrayList<>();
    for (    Map.Entry<Long,Boolean> entry : TIMESTAMP.entrySet()) {
      Put put=new Put(KEY);
      put.setDurability(Durability.SKIP_WAL);
      put.addColumn(FAMILY_NAME,COLUMN_NAME,entry.getKey(),Bytes.toBytes(false));
      puts.add(put);
    }
    Table table=UTIL.getConnection().getTable(desc.getTableName());
    table.put(puts);
    runTestOnTable();
    verify(table);
    table.close();
  }
  private void runTestOnTable() throws IOException, InterruptedException, ClassNotFoundException {
    Job job=null;
    try {
      job=new Job(UTIL.getConfiguration(),"test123");
      job.setOutputFormatClass(NullOutputFormat.class);
      job.setNumReduceTasks(0);
      Scan scan=new Scan();
      scan.addColumn(FAMILY_NAME,COLUMN_NAME);
      scan.setTimeRange(MINSTAMP,MAXSTAMP);
      scan.setMaxVersions();
      TableMapReduceUtil.initTableMapperJob(TABLE_NAME,scan,ProcessTimeRangeMapper.class,Text.class,Text.class,job);
      job.waitForCompletion(true);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      if (job != null) {
        FileUtil.fullyDelete(new File(job.getConfiguration().get("hadoop.tmp.dir")));
      }
    }
  }
  private void verify(  final Table table) throws IOException {
    Scan scan=new Scan();
    scan.addColumn(FAMILY_NAME,COLUMN_NAME);
    scan.setMaxVersions(1);
    ResultScanner scanner=table.getScanner(scan);
    for (    Result r : scanner) {
      for (      Cell kv : r.listCells()) {
        log.debug(Bytes.toString(r.getRow()) + "\t" + Bytes.toString(CellUtil.cloneFamily(kv))+ "\t"+ Bytes.toString(CellUtil.cloneQualifier(kv))+ "\t"+ kv.getTimestamp()+ "\t"+ Bytes.toBoolean(CellUtil.cloneValue(kv)));
        org.junit.Assert.assertEquals(TIMESTAMP.get(kv.getTimestamp()),Bytes.toBoolean(CellUtil.cloneValue(kv)));
      }
    }
    scanner.close();
  }
}
