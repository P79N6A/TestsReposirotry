/** 
 * This is a hammer test that verifies MultiVersionConcurrencyControl in a multiple writer single reader scenario.
 */
@Category({RegionServerTests.class,MediumTests.class}) public class TestMultiVersionConcurrencyControl {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMultiVersionConcurrencyControl.class);
static class Writer implements Runnable {
    final AtomicBoolean finished;
    final MultiVersionConcurrencyControl mvcc;
    final AtomicBoolean status;
    Writer(    AtomicBoolean finished,    MultiVersionConcurrencyControl mvcc,    AtomicBoolean status){
      this.finished=finished;
      this.mvcc=mvcc;
      this.status=status;
    }
    private Random rnd=new Random();
    public boolean failed=false;
    @Override public void run(){
      while (!finished.get()) {
        MultiVersionConcurrencyControl.WriteEntry e=mvcc.begin();
        int sleepTime=rnd.nextInt(500);
        try {
          if (sleepTime > 0)           Thread.sleep(0,sleepTime * 1000);
        }
 catch (        InterruptedException e1) {
        }
        try {
          mvcc.completeAndWait(e);
        }
 catch (        RuntimeException ex) {
          System.out.println(ex.toString());
          ex.printStackTrace();
          status.set(false);
          return;
        }
      }
    }
  }
  public void testParallelism() throws Exception {
    final MultiVersionConcurrencyControl mvcc=new MultiVersionConcurrencyControl();
    final AtomicBoolean finished=new AtomicBoolean(false);
    final AtomicBoolean readerFailed=new AtomicBoolean(false);
    final AtomicLong failedAt=new AtomicLong();
    Runnable reader=new Runnable(){
      @Override public void run(){
        long prev=mvcc.getReadPoint();
        while (!finished.get()) {
          long newPrev=mvcc.getReadPoint();
          if (newPrev < prev) {
            System.out.println("Reader got out of order, prev: " + prev + " next was: "+ newPrev);
            readerFailed.set(true);
            failedAt.set(newPrev);
            return;
          }
        }
      }
    }
;
    int n=20;
    Thread[] writers=new Thread[n];
    AtomicBoolean[] statuses=new AtomicBoolean[n];
    Thread readThread=new Thread(reader);
    for (int i=0; i < n; ++i) {
      statuses[i]=new AtomicBoolean(true);
      writers[i]=new Thread(new Writer(finished,mvcc,statuses[i]));
      writers[i].start();
    }
    readThread.start();
    try {
      Thread.sleep(10 * 1000);
    }
 catch (    InterruptedException ex) {
    }
    finished.set(true);
    readThread.join();
    for (int i=0; i < n; ++i) {
      writers[i].join();
    }
    Assert.assertFalse(readerFailed.get());
    for (int i=0; i < n; ++i) {
      Assert.assertTrue(statuses[i].get());
    }
  }
}
