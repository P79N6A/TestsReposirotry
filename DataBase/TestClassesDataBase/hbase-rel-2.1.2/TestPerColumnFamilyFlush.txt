/** 
 * This test verifies the correctness of the Per Column Family flushing strategy
 */
@Category({RegionServerTests.class,LargeTests.class}) public class TestPerColumnFamilyFlush {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestPerColumnFamilyFlush.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestPerColumnFamilyFlush.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final Path DIR=TEST_UTIL.getDataTestDir("TestHRegion");
  public static final TableName TABLENAME=TableName.valueOf("TestPerColumnFamilyFlush","t1");
  public static final byte[][] FAMILIES={Bytes.toBytes("f1"),Bytes.toBytes("f2"),Bytes.toBytes("f3"),Bytes.toBytes("f4"),Bytes.toBytes("f5")};
  public static final byte[] FAMILY1=FAMILIES[0];
  public static final byte[] FAMILY2=FAMILIES[1];
  public static final byte[] FAMILY3=FAMILIES[2];
  private HRegion initHRegion(  String callingMethod,  Configuration conf) throws IOException {
    HTableDescriptor htd=new HTableDescriptor(TABLENAME);
    for (    byte[] family : FAMILIES) {
      htd.addFamily(new HColumnDescriptor(family));
    }
    HRegionInfo info=new HRegionInfo(TABLENAME,null,null,false);
    Path path=new Path(DIR,callingMethod);
    return HBaseTestingUtility.createRegionAndWAL(info,path,conf,htd);
  }
  private Put createPut(  int familyNum,  int putNum){
    byte[] qf=Bytes.toBytes("q" + familyNum);
    byte[] row=Bytes.toBytes("row" + familyNum + "-"+ putNum);
    byte[] val=Bytes.toBytes("val" + familyNum + "-"+ putNum);
    Put p=new Put(row);
    p.addColumn(FAMILIES[familyNum - 1],qf,val);
    return p;
  }
  private Get createGet(  int familyNum,  int putNum){
    byte[] row=Bytes.toBytes("row" + familyNum + "-"+ putNum);
    return new Get(row);
  }
  void verifyEdit(  int familyNum,  int putNum,  Table table) throws IOException {
    Result r=table.get(createGet(familyNum,putNum));
    byte[] family=FAMILIES[familyNum - 1];
    byte[] qf=Bytes.toBytes("q" + familyNum);
    byte[] val=Bytes.toBytes("val" + familyNum + "-"+ putNum);
    assertNotNull(("Missing Put#" + putNum + " for CF# "+ familyNum),r.getFamilyMap(family));
    assertNotNull(("Missing Put#" + putNum + " for CF# "+ familyNum),r.getFamilyMap(family).get(qf));
    assertTrue(("Incorrect value for Put#" + putNum + " for CF# "+ familyNum),Arrays.equals(r.getFamilyMap(family).get(qf),val));
  }
  @Test public void testSelectiveFlushWhenEnabled() throws IOException {
    Configuration conf=new HBaseTestingUtility().getConfiguration();
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,200 * 1024);
    conf.set(FlushPolicyFactory.HBASE_FLUSH_POLICY_KEY,FlushAllLargeStoresPolicy.class.getName());
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,40 * 1024);
    HRegion region=initHRegion("testSelectiveFlushWithDataCompaction",conf);
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createPut(3,i));
        }
      }
    }
    long totalMemstoreSize=region.getMemStoreDataSize();
    long smallestSeqCF1=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3=region.getOldestSeqIdOfStore(FAMILY3);
    MemStoreSize cf1MemstoreSize=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSize=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSize=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstore=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    assertEquals(smallestSeqCF1,smallestSeqInRegionCurrentMemstore);
    assertTrue(smallestSeqCF1 < smallestSeqCF2);
    assertTrue(smallestSeqCF2 < smallestSeqCF3);
    assertTrue(cf1MemstoreSize.getDataSize() > 0);
    assertTrue(cf2MemstoreSize.getDataSize() > 0);
    assertTrue(cf3MemstoreSize.getDataSize() > 0);
    assertEquals(totalMemstoreSize,cf1MemstoreSize.getDataSize() + cf2MemstoreSize.getDataSize() + cf3MemstoreSize.getDataSize());
    region.flush(false);
    MemStoreSize oldCF2MemstoreSize=cf2MemstoreSize;
    MemStoreSize oldCF3MemstoreSize=cf3MemstoreSize;
    cf1MemstoreSize=region.getStore(FAMILY1).getMemStoreSize();
    cf2MemstoreSize=region.getStore(FAMILY2).getMemStoreSize();
    cf3MemstoreSize=region.getStore(FAMILY3).getMemStoreSize();
    totalMemstoreSize=region.getMemStoreDataSize();
    smallestSeqInRegionCurrentMemstore=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    assertEquals(0,cf1MemstoreSize.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf1MemstoreSize.getHeapSize());
    assertEquals(cf2MemstoreSize,oldCF2MemstoreSize);
    assertEquals(cf3MemstoreSize,oldCF3MemstoreSize);
    assertEquals(smallestSeqInRegionCurrentMemstore,smallestSeqCF2);
    assertEquals(totalMemstoreSize,cf2MemstoreSize.getDataSize() + cf3MemstoreSize.getDataSize());
    for (int i=1200; i < 2400; i++) {
      region.put(createPut(2,i));
      if (i - 1200 < 100) {
        region.put(createPut(3,i));
      }
    }
    oldCF3MemstoreSize=region.getStore(FAMILY3).getMemStoreSize();
    region.flush(false);
    cf1MemstoreSize=region.getStore(FAMILY1).getMemStoreSize();
    cf2MemstoreSize=region.getStore(FAMILY2).getMemStoreSize();
    cf3MemstoreSize=region.getStore(FAMILY3).getMemStoreSize();
    totalMemstoreSize=region.getMemStoreDataSize();
    smallestSeqInRegionCurrentMemstore=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    assertEquals(0,cf1MemstoreSize.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf1MemstoreSize.getHeapSize());
    assertEquals(0,cf2MemstoreSize.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSize.getHeapSize());
    assertEquals(cf3MemstoreSize,oldCF3MemstoreSize);
    assertEquals(totalMemstoreSize,cf3MemstoreSize.getDataSize());
    region.flush(true);
    for (int i=1; i <= 300; i++) {
      region.put(createPut(1,i));
      region.put(createPut(2,i));
      region.put(createPut(3,i));
      region.put(createPut(4,i));
      region.put(createPut(5,i));
    }
    region.flush(false);
    assertEquals(0,region.getMemStoreDataSize());
    HBaseTestingUtility.closeRegionAndWAL(region);
  }
  @Test public void testSelectiveFlushWhenNotEnabled() throws IOException {
    Configuration conf=new HBaseTestingUtility().getConfiguration();
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,200 * 1024);
    conf.set(FlushPolicyFactory.HBASE_FLUSH_POLICY_KEY,FlushAllStoresPolicy.class.getName());
    HRegion region=initHRegion("testSelectiveFlushWhenNotEnabled",conf);
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createPut(3,i));
        }
      }
    }
    long totalMemstoreSize=region.getMemStoreDataSize();
    MemStoreSize cf1MemstoreSize=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSize=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSize=region.getStore(FAMILY3).getMemStoreSize();
    assertTrue(cf1MemstoreSize.getDataSize() > 0);
    assertTrue(cf2MemstoreSize.getDataSize() > 0);
    assertTrue(cf3MemstoreSize.getDataSize() > 0);
    assertEquals(totalMemstoreSize,cf1MemstoreSize.getDataSize() + cf2MemstoreSize.getDataSize() + cf3MemstoreSize.getDataSize());
    region.flush(false);
    cf1MemstoreSize=region.getStore(FAMILY1).getMemStoreSize();
    cf2MemstoreSize=region.getStore(FAMILY2).getMemStoreSize();
    cf3MemstoreSize=region.getStore(FAMILY3).getMemStoreSize();
    totalMemstoreSize=region.getMemStoreDataSize();
    long smallestSeqInRegionCurrentMemstore=region.getWAL().getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    assertEquals(0,cf1MemstoreSize.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf1MemstoreSize.getHeapSize());
    assertEquals(0,cf2MemstoreSize.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSize.getHeapSize());
    assertEquals(0,cf3MemstoreSize.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf3MemstoreSize.getHeapSize());
    assertEquals(0,totalMemstoreSize);
    assertEquals(HConstants.NO_SEQNUM,smallestSeqInRegionCurrentMemstore);
    HBaseTestingUtility.closeRegionAndWAL(region);
  }
  private static Pair<HRegion,HRegionServer> getRegionWithName(  TableName tableName){
    MiniHBaseCluster cluster=TEST_UTIL.getMiniHBaseCluster();
    List<JVMClusterUtil.RegionServerThread> rsts=cluster.getRegionServerThreads();
    for (int i=0; i < cluster.getRegionServerThreads().size(); i++) {
      HRegionServer hrs=rsts.get(i).getRegionServer();
      for (      HRegion region : hrs.getRegions(tableName)) {
        return Pair.newPair(region,hrs);
      }
    }
    return null;
  }
  private void doTestLogReplay() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,10000);
    conf.set(FlushPolicyFactory.HBASE_FLUSH_POLICY_KEY,FlushAllLargeStoresPolicy.class.getName());
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,2500);
    final int numRegionServers=4;
    try {
      TEST_UTIL.startMiniCluster(numRegionServers);
      TEST_UTIL.getAdmin().createNamespace(NamespaceDescriptor.create(TABLENAME.getNamespaceAsString()).build());
      Table table=TEST_UTIL.createTable(TABLENAME,FAMILIES);
      HTableDescriptor htd=table.getTableDescriptor();
      for (      byte[] family : FAMILIES) {
        if (!htd.hasFamily(family)) {
          htd.addFamily(new HColumnDescriptor(family));
        }
      }
      for (int i=1; i <= 80; i++) {
        table.put(createPut(1,i));
        if (i <= 10) {
          table.put(createPut(2,i));
          table.put(createPut(3,i));
        }
      }
      Thread.sleep(1000);
      Pair<HRegion,HRegionServer> desiredRegionAndServer=getRegionWithName(TABLENAME);
      HRegion desiredRegion=desiredRegionAndServer.getFirst();
      assertTrue("Could not find a region which hosts the new region.",desiredRegion != null);
      desiredRegion.flush(false);
      long totalMemstoreSize;
      long cf1MemstoreSize, cf2MemstoreSize, cf3MemstoreSize;
      totalMemstoreSize=desiredRegion.getMemStoreDataSize();
      cf1MemstoreSize=desiredRegion.getStore(FAMILY1).getMemStoreSize().getDataSize();
      cf2MemstoreSize=desiredRegion.getStore(FAMILY2).getMemStoreSize().getDataSize();
      cf3MemstoreSize=desiredRegion.getStore(FAMILY3).getMemStoreSize().getDataSize();
      assertEquals(0,cf1MemstoreSize);
      assertTrue(cf2MemstoreSize >= 0);
      assertTrue(cf3MemstoreSize >= 0);
      assertEquals(totalMemstoreSize,cf2MemstoreSize + cf3MemstoreSize);
      Thread.sleep(2000);
      HRegionServer rs=desiredRegionAndServer.getSecond();
      rs.abort("testing");
      for (int i=1; i <= 80; i++) {
        verifyEdit(1,i,table);
        if (i <= 10) {
          verifyEdit(2,i,table);
          verifyEdit(3,i,table);
        }
      }
    }
  finally {
      TEST_UTIL.shutdownMiniCluster();
    }
  }
  @Test public void testLogReplayWithDistributedLogSplit() throws Exception {
    doTestLogReplay();
  }
  private WAL getWAL(  Region region){
    return ((HRegion)region).getWAL();
  }
  private int getNumRolledLogFiles(  Region region){
    return AbstractFSWALProvider.getNumRolledLogFiles(getWAL(region));
  }
  /** 
 * When a log roll is about to happen, we do a flush of the regions who will be affected by the log roll. These flushes cannot be a selective flushes, otherwise we cannot roll the logs. This test ensures that we do a full-flush in that scenario.
 * @throws IOException
 */
  @Test public void testFlushingWhenLogRolling() throws Exception {
    TableName tableName=TableName.valueOf("testFlushingWhenLogRolling");
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,128 * 1024 * 1024);
    conf.set(FlushPolicyFactory.HBASE_FLUSH_POLICY_KEY,FlushAllLargeStoresPolicy.class.getName());
    long cfFlushSizeLowerBound=2048;
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,cfFlushSizeLowerBound);
    conf.setLong("hbase.regionserver.logroll.period",60L * 60 * 1000);
    conf.setLong("hbase.regionserver.hlog.blocksize",128L * 1024 * 1024);
    final int maxLogs=10;
    conf.setInt("hbase.regionserver.maxlogs",maxLogs);
    final int numRegionServers=1;
    TEST_UTIL.startMiniCluster(numRegionServers);
    try {
      Table table=TEST_UTIL.createTable(tableName,FAMILIES);
      try (Admin admin=TEST_UTIL.getConnection().getAdmin()){
        admin.flush(TableName.NAMESPACE_TABLE_NAME);
      }
       Pair<HRegion,HRegionServer> desiredRegionAndServer=getRegionWithName(tableName);
      final HRegion desiredRegion=desiredRegionAndServer.getFirst();
      assertTrue("Could not find a region which hosts the new region.",desiredRegion != null);
      LOG.info("Writing to region=" + desiredRegion);
      for (int i=1; i <= 3; i++) {
        table.put(createPut(i,0));
      }
      for (int i=0; i < maxLogs; i++) {
        for (int j=0; j < 100; j++) {
          table.put(createPut(1,i * 100 + j));
        }
        int currentNumRolledLogFiles=getNumRolledLogFiles(desiredRegion);
        assertNull(getWAL(desiredRegion).rollWriter());
        while (getNumRolledLogFiles(desiredRegion) <= currentNumRolledLogFiles) {
          Thread.sleep(100);
        }
      }
      assertEquals(maxLogs,getNumRolledLogFiles(desiredRegion));
      assertTrue(desiredRegion.getStore(FAMILY1).getMemStoreSize().getHeapSize() > cfFlushSizeLowerBound);
      assertTrue(desiredRegion.getStore(FAMILY2).getMemStoreSize().getHeapSize() < cfFlushSizeLowerBound);
      assertTrue(desiredRegion.getStore(FAMILY3).getMemStoreSize().getHeapSize() < cfFlushSizeLowerBound);
      table.put(createPut(1,12345678));
      desiredRegionAndServer.getSecond().walRoller.requestRollAll();
      TEST_UTIL.waitFor(30000,new Waiter.ExplainingPredicate<Exception>(){
        @Override public boolean evaluate() throws Exception {
          return desiredRegion.getMemStoreDataSize() == 0;
        }
        @Override public String explainFailure() throws Exception {
          long memstoreSize=desiredRegion.getMemStoreDataSize();
          if (memstoreSize > 0) {
            return "Still have unflushed entries in memstore, memstore size is " + memstoreSize;
          }
          return "Unknown";
        }
      }
);
      LOG.info("Finished waiting on flush after too many WALs...");
      assertEquals(MutableSegment.DEEP_OVERHEAD,desiredRegion.getStore(FAMILY1).getMemStoreSize().getHeapSize());
      assertEquals(MutableSegment.DEEP_OVERHEAD,desiredRegion.getStore(FAMILY2).getMemStoreSize().getHeapSize());
      assertEquals(MutableSegment.DEEP_OVERHEAD,desiredRegion.getStore(FAMILY3).getMemStoreSize().getHeapSize());
      assertNull(getWAL(desiredRegion).rollWriter(true));
      assertTrue(getNumRolledLogFiles(desiredRegion) < maxLogs);
    }
  finally {
      TEST_UTIL.shutdownMiniCluster();
    }
  }
  private void doPut(  Table table,  long memstoreFlushSize) throws IOException, InterruptedException {
    Region region=getRegionWithName(table.getName()).getFirst();
    byte[] qf=Bytes.toBytes("qf");
    Random rand=new Random();
    byte[] value1=new byte[100];
    byte[] value2=new byte[200];
    byte[] value3=new byte[400];
    for (int i=0; i < 10000; i++) {
      Put put=new Put(Bytes.toBytes("row-" + i));
      rand.setSeed(i);
      rand.nextBytes(value1);
      rand.nextBytes(value2);
      rand.nextBytes(value3);
      put.addColumn(FAMILY1,qf,value1);
      put.addColumn(FAMILY2,qf,value2);
      put.addColumn(FAMILY3,qf,value3);
      table.put(put);
      while (region.getMemStoreHeapSize() > memstoreFlushSize) {
        Thread.sleep(100);
      }
    }
  }
  @Test public void testCompareStoreFileCount() throws Exception {
    long memstoreFlushSize=1024L * 1024;
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,memstoreFlushSize);
    conf.set(FlushPolicyFactory.HBASE_FLUSH_POLICY_KEY,FlushAllStoresPolicy.class.getName());
    conf.setInt(HStore.BLOCKING_STOREFILES_KEY,10000);
    conf.set(HConstants.HBASE_REGION_SPLIT_POLICY_KEY,ConstantSizeRegionSplitPolicy.class.getName());
    HTableDescriptor htd=new HTableDescriptor(TABLENAME);
    htd.setCompactionEnabled(false);
    htd.addFamily(new HColumnDescriptor(FAMILY1));
    htd.addFamily(new HColumnDescriptor(FAMILY2));
    htd.addFamily(new HColumnDescriptor(FAMILY3));
    LOG.info("==============Test with selective flush disabled===============");
    int cf1StoreFileCount=-1;
    int cf2StoreFileCount=-1;
    int cf3StoreFileCount=-1;
    int cf1StoreFileCount1=-1;
    int cf2StoreFileCount1=-1;
    int cf3StoreFileCount1=-1;
    try {
      TEST_UTIL.startMiniCluster(1);
      TEST_UTIL.getAdmin().createNamespace(NamespaceDescriptor.create(TABLENAME.getNamespaceAsString()).build());
      TEST_UTIL.getAdmin().createTable(htd);
      TEST_UTIL.waitTableAvailable(TABLENAME);
      Connection conn=ConnectionFactory.createConnection(conf);
      Table table=conn.getTable(TABLENAME);
      doPut(table,memstoreFlushSize);
      table.close();
      conn.close();
      Region region=getRegionWithName(TABLENAME).getFirst();
      cf1StoreFileCount=region.getStore(FAMILY1).getStorefilesCount();
      cf2StoreFileCount=region.getStore(FAMILY2).getStorefilesCount();
      cf3StoreFileCount=region.getStore(FAMILY3).getStorefilesCount();
    }
  finally {
      TEST_UTIL.shutdownMiniCluster();
    }
    LOG.info("==============Test with selective flush enabled===============");
    conf.set(FlushPolicyFactory.HBASE_FLUSH_POLICY_KEY,FlushAllLargeStoresPolicy.class.getName());
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,0);
    try {
      TEST_UTIL.startMiniCluster(1);
      TEST_UTIL.getAdmin().createNamespace(NamespaceDescriptor.create(TABLENAME.getNamespaceAsString()).build());
      TEST_UTIL.getAdmin().createTable(htd);
      Connection conn=ConnectionFactory.createConnection(conf);
      Table table=conn.getTable(TABLENAME);
      doPut(table,memstoreFlushSize);
      table.close();
      conn.close();
      Region region=getRegionWithName(TABLENAME).getFirst();
      cf1StoreFileCount1=region.getStore(FAMILY1).getStorefilesCount();
      cf2StoreFileCount1=region.getStore(FAMILY2).getStorefilesCount();
      cf3StoreFileCount1=region.getStore(FAMILY3).getStorefilesCount();
    }
  finally {
      TEST_UTIL.shutdownMiniCluster();
    }
    LOG.info("disable selective flush: " + Bytes.toString(FAMILY1) + "=>"+ cf1StoreFileCount+ ", "+ Bytes.toString(FAMILY2)+ "=>"+ cf2StoreFileCount+ ", "+ Bytes.toString(FAMILY3)+ "=>"+ cf3StoreFileCount);
    LOG.info("enable selective flush: " + Bytes.toString(FAMILY1) + "=>"+ cf1StoreFileCount1+ ", "+ Bytes.toString(FAMILY2)+ "=>"+ cf2StoreFileCount1+ ", "+ Bytes.toString(FAMILY3)+ "=>"+ cf3StoreFileCount1);
    assertTrue(cf1StoreFileCount1 < cf1StoreFileCount);
    assertTrue(cf2StoreFileCount1 < cf2StoreFileCount);
  }
  public static void main(  String[] args) throws Exception {
    int numRegions=Integer.parseInt(args[0]);
    long numRows=Long.parseLong(args[1]);
    HTableDescriptor htd=new HTableDescriptor(TABLENAME);
    htd.setMaxFileSize(10L * 1024 * 1024* 1024);
    htd.setValue(HTableDescriptor.SPLIT_POLICY,ConstantSizeRegionSplitPolicy.class.getName());
    htd.addFamily(new HColumnDescriptor(FAMILY1));
    htd.addFamily(new HColumnDescriptor(FAMILY2));
    htd.addFamily(new HColumnDescriptor(FAMILY3));
    Configuration conf=HBaseConfiguration.create();
    Connection conn=ConnectionFactory.createConnection(conf);
    Admin admin=conn.getAdmin();
    if (admin.tableExists(TABLENAME)) {
      admin.disableTable(TABLENAME);
      admin.deleteTable(TABLENAME);
    }
    if (numRegions >= 3) {
      byte[] startKey=new byte[16];
      byte[] endKey=new byte[16];
      Arrays.fill(endKey,(byte)0xFF);
      admin.createTable(htd,startKey,endKey,numRegions);
    }
 else {
      admin.createTable(htd);
    }
    admin.close();
    Table table=conn.getTable(TABLENAME);
    byte[] qf=Bytes.toBytes("qf");
    Random rand=new Random();
    byte[] value1=new byte[16];
    byte[] value2=new byte[256];
    byte[] value3=new byte[4096];
    for (long i=0; i < numRows; i++) {
      Put put=new Put(Hashing.md5().hashLong(i).asBytes());
      rand.setSeed(i);
      rand.nextBytes(value1);
      rand.nextBytes(value2);
      rand.nextBytes(value3);
      put.addColumn(FAMILY1,qf,value1);
      put.addColumn(FAMILY2,qf,value2);
      put.addColumn(FAMILY3,qf,value3);
      table.put(put);
      if (i % 10000 == 0) {
        LOG.info(i + " rows put");
      }
    }
    table.close();
    conn.close();
  }
}
