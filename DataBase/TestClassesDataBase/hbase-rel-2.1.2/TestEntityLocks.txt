@Category({ClientTests.class,SmallTests.class}) public class TestEntityLocks {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestEntityLocks.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestEntityLocks.class);
  private final Configuration conf=HBaseConfiguration.create();
  private final LockService.BlockingInterface master=Mockito.mock(LockService.BlockingInterface.class);
  private LockServiceClient admin;
  private ArgumentCaptor<LockRequest> lockReqArgCaptor;
  private ArgumentCaptor<LockHeartbeatRequest> lockHeartbeatReqArgCaptor;
  private static final LockHeartbeatResponse UNLOCKED_RESPONSE=LockHeartbeatResponse.newBuilder().setLockStatus(LockHeartbeatResponse.LockStatus.UNLOCKED).build();
  private static final LockHeartbeatResponse LOCKED_RESPONSE=LockHeartbeatResponse.newBuilder().setLockStatus(LockHeartbeatResponse.LockStatus.LOCKED).setTimeoutMs(10000).build();
  private long procId;
  LockServiceClient getAdmin() throws Exception {
    conf.setInt("hbase.client.retries.number",3);
    conf.setInt("hbase.client.pause",1);
    return new LockServiceClient(conf,master,PerClientRandomNonceGenerator.get());
  }
  @Before public void setUp() throws Exception {
    admin=getAdmin();
    lockReqArgCaptor=ArgumentCaptor.forClass(LockRequest.class);
    lockHeartbeatReqArgCaptor=ArgumentCaptor.forClass(LockHeartbeatRequest.class);
    procId=new Random().nextLong();
  }
  private boolean waitLockTimeOut(  EntityLock lock,  long maxWaitTimeMillis){
    long startMillis=System.currentTimeMillis();
    while (lock.isLocked()) {
      LOG.info("Sleeping...");
      Threads.sleepWithoutInterrupt(100);
      if (!lock.isLocked()) {
        return true;
      }
      if (System.currentTimeMillis() - startMillis > maxWaitTimeMillis) {
        LOG.info("Timedout...");
        return false;
      }
    }
    return true;
  }
  /** 
 * Test basic lock function - requestLock, await, unlock.
 * @throws Exception
 */
  @Test public void testEntityLock() throws Exception {
    final long procId=100;
    final long workerSleepTime=200;
    EntityLock lock=admin.namespaceLock("namespace","description",null);
    lock.setTestingSleepTime(workerSleepTime);
    when(master.requestLock(any(),any())).thenReturn(LockResponse.newBuilder().setProcId(procId).build());
    when(master.lockHeartbeat(any(),any())).thenReturn(UNLOCKED_RESPONSE,UNLOCKED_RESPONSE,UNLOCKED_RESPONSE,LOCKED_RESPONSE);
    lock.requestLock();
    lock.await(4 * workerSleepTime,TimeUnit.MILLISECONDS);
    assertTrue(lock.isLocked());
    lock.unlock();
    assertTrue(!lock.getWorker().isAlive());
    assertFalse(lock.isLocked());
    verify(master,times(1)).requestLock(any(),lockReqArgCaptor.capture());
    LockRequest request=lockReqArgCaptor.getValue();
    assertEquals("namespace",request.getNamespace());
    assertEquals("description",request.getDescription());
    assertEquals(LockType.EXCLUSIVE,request.getLockType());
    assertEquals(0,request.getRegionInfoCount());
    verify(master,atLeastOnce()).lockHeartbeat(any(),lockHeartbeatReqArgCaptor.capture());
    for (    LockHeartbeatRequest req : lockHeartbeatReqArgCaptor.getAllValues()) {
      assertEquals(procId,req.getProcId());
    }
  }
  /** 
 * Test that abort is called when lock times out.
 */
  @Test public void testEntityLockTimeout() throws Exception {
    final long workerSleepTime=200;
    Abortable abortable=Mockito.mock(Abortable.class);
    EntityLock lock=admin.namespaceLock("namespace","description",abortable);
    lock.setTestingSleepTime(workerSleepTime);
    when(master.requestLock(any(),any())).thenReturn(LockResponse.newBuilder().setProcId(procId).build());
    when(master.lockHeartbeat(any(),any())).thenReturn(LOCKED_RESPONSE,UNLOCKED_RESPONSE);
    lock.requestLock();
    lock.await();
    assertTrue(lock.isLocked());
    assertTrue(waitLockTimeOut(lock,2 * workerSleepTime));
    assertFalse(lock.getWorker().isAlive());
    verify(abortable,times(1)).abort(any(),eq(null));
  }
  /** 
 * Test that abort is called when lockHeartbeat fails with IOException.
 */
  @Test public void testHeartbeatException() throws Exception {
    final long workerSleepTime=100;
    Abortable abortable=Mockito.mock(Abortable.class);
    EntityLock lock=admin.namespaceLock("namespace","description",abortable);
    lock.setTestingSleepTime(workerSleepTime);
    when(master.requestLock(any(),any())).thenReturn(LockResponse.newBuilder().setProcId(procId).build());
    when(master.lockHeartbeat(any(),any())).thenReturn(LOCKED_RESPONSE).thenThrow(new ServiceException("Failed heartbeat!"));
    lock.requestLock();
    lock.await();
    assertTrue(waitLockTimeOut(lock,100 * workerSleepTime));
    while (lock.getWorker().isAlive()) {
      TimeUnit.MILLISECONDS.sleep(100);
    }
    verify(abortable,times(1)).abort(any(),isA(HBaseIOException.class));
    assertFalse(lock.getWorker().isAlive());
  }
}
