/** 
 * Tests for WAL write durability
 */
@RunWith(Parameterized.class) @Category({RegionServerTests.class,MediumTests.class}) public class TestDurability {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestDurability.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static FileSystem FS;
  private static MiniDFSCluster CLUSTER;
  private static Configuration CONF;
  private static Path DIR;
  private static byte[] FAMILY=Bytes.toBytes("family");
  private static byte[] ROW=Bytes.toBytes("row");
  private static byte[] COL=Bytes.toBytes("col");
  @Parameter public String walProvider;
  @Rule public TestName name=new TestName();
  @Parameters(name="{index}: provider={0}") public static Iterable<Object[]> data(){
    return Arrays.asList(new Object[]{"defaultProvider"},new Object[]{"asyncfs"});
  }
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    CONF=TEST_UTIL.getConfiguration();
    TEST_UTIL.startMiniDFSCluster(1);
    CLUSTER=TEST_UTIL.getDFSCluster();
    FS=CLUSTER.getFileSystem();
    DIR=TEST_UTIL.getDataTestDirOnTestFS("TestDurability");
    FSUtils.setRootDir(CONF,DIR);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Before public void setUp(){
    CONF.set(WALFactory.WAL_PROVIDER,walProvider);
  }
  @After public void tearDown() throws IOException {
    FS.delete(DIR,true);
  }
  @Test public void testDurability() throws Exception {
    WALFactory wals=new WALFactory(CONF,ServerName.valueOf("TestDurability",16010,System.currentTimeMillis()).toString());
    HRegion region=createHRegion(wals,Durability.USE_DEFAULT);
    WAL wal=region.getWAL();
    HRegion deferredRegion=createHRegion(region.getTableDescriptor(),region.getRegionInfo(),"deferredRegion",wal,Durability.ASYNC_WAL);
    region.put(newPut(null));
    verifyWALCount(wals,wal,1);
    deferredRegion.put(newPut(null));
    wal.sync();
    verifyWALCount(wals,wal,2);
    deferredRegion.put(newPut(null));
    wal.sync();
    verifyWALCount(wals,wal,3);
    region.put(newPut(null));
    verifyWALCount(wals,wal,4);
    deferredRegion.put(newPut(Durability.USE_DEFAULT));
    wal.sync();
    verifyWALCount(wals,wal,5);
    region.put(newPut(Durability.USE_DEFAULT));
    verifyWALCount(wals,wal,6);
    region.put(newPut(Durability.SKIP_WAL));
    deferredRegion.put(newPut(Durability.SKIP_WAL));
    verifyWALCount(wals,wal,6);
    wal.sync();
    verifyWALCount(wals,wal,6);
    region.put(newPut(Durability.ASYNC_WAL));
    deferredRegion.put(newPut(Durability.ASYNC_WAL));
    wal.sync();
    verifyWALCount(wals,wal,8);
    region.put(newPut(Durability.SYNC_WAL));
    deferredRegion.put(newPut(Durability.SYNC_WAL));
    verifyWALCount(wals,wal,10);
    region.put(newPut(Durability.FSYNC_WAL));
    deferredRegion.put(newPut(Durability.FSYNC_WAL));
    verifyWALCount(wals,wal,12);
  }
  @Test public void testIncrement() throws Exception {
    byte[] row1=Bytes.toBytes("row1");
    byte[] col1=Bytes.toBytes("col1");
    byte[] col2=Bytes.toBytes("col2");
    byte[] col3=Bytes.toBytes("col3");
    WALFactory wals=new WALFactory(CONF,ServerName.valueOf("TestIncrement",16010,System.currentTimeMillis()).toString());
    HRegion region=createHRegion(wals,Durability.USE_DEFAULT);
    WAL wal=region.getWAL();
    Increment inc1=new Increment(row1);
    inc1.addColumn(FAMILY,col1,0);
    Result res=region.increment(inc1);
    assertEquals(1,res.size());
    assertEquals(0,Bytes.toLong(res.getValue(FAMILY,col1)));
    verifyWALCount(wals,wal,1);
    inc1=new Increment(row1);
    inc1.addColumn(FAMILY,col1,1);
    res=region.increment(inc1);
    assertEquals(1,res.size());
    assertEquals(1,Bytes.toLong(res.getValue(FAMILY,col1)));
    verifyWALCount(wals,wal,2);
    inc1=new Increment(row1);
    inc1.addColumn(FAMILY,col1,0);
    res=region.increment(inc1);
    assertEquals(1,res.size());
    assertEquals(1,Bytes.toLong(res.getValue(FAMILY,col1)));
    verifyWALCount(wals,wal,3);
    inc1=new Increment(row1);
    inc1.addColumn(FAMILY,col1,0);
    inc1.addColumn(FAMILY,col2,0);
    inc1.addColumn(FAMILY,col3,0);
    res=region.increment(inc1);
    assertEquals(3,res.size());
    assertEquals(1,Bytes.toLong(res.getValue(FAMILY,col1)));
    assertEquals(0,Bytes.toLong(res.getValue(FAMILY,col2)));
    assertEquals(0,Bytes.toLong(res.getValue(FAMILY,col3)));
    verifyWALCount(wals,wal,4);
    inc1=new Increment(row1);
    inc1.addColumn(FAMILY,col1,5);
    inc1.addColumn(FAMILY,col2,4);
    inc1.addColumn(FAMILY,col3,3);
    res=region.increment(inc1);
    assertEquals(3,res.size());
    assertEquals(6,Bytes.toLong(res.getValue(FAMILY,col1)));
    assertEquals(4,Bytes.toLong(res.getValue(FAMILY,col2)));
    assertEquals(3,Bytes.toLong(res.getValue(FAMILY,col3)));
    verifyWALCount(wals,wal,5);
  }
  /** 
 * Test when returnResults set to false in increment it should not return the result instead it resturn null.
 */
  @Test public void testIncrementWithReturnResultsSetToFalse() throws Exception {
    byte[] row1=Bytes.toBytes("row1");
    byte[] col1=Bytes.toBytes("col1");
    WALFactory wals=new WALFactory(CONF,ServerName.valueOf("testIncrementWithReturnResultsSetToFalse",16010,System.currentTimeMillis()).toString());
    HRegion region=createHRegion(wals,Durability.USE_DEFAULT);
    Increment inc1=new Increment(row1);
    inc1.setReturnResults(false);
    inc1.addColumn(FAMILY,col1,1);
    Result res=region.increment(inc1);
    assertTrue(res.isEmpty());
  }
  private Put newPut(  Durability durability){
    Put p=new Put(ROW);
    p.addColumn(FAMILY,COL,COL);
    if (durability != null) {
      p.setDurability(durability);
    }
    return p;
  }
  private void verifyWALCount(  WALFactory wals,  WAL log,  int expected) throws Exception {
    Path walPath=AbstractFSWALProvider.getCurrentFileName(log);
    WAL.Reader reader=wals.createReader(FS,walPath);
    int count=0;
    WAL.Entry entry=new WAL.Entry();
    while (reader.next(entry) != null) {
      count++;
    }
    reader.close();
    assertEquals(expected,count);
  }
  private HRegion createHRegion(  WALFactory wals,  Durability durability) throws IOException {
    TableName tableName=TableName.valueOf(name.getMethodName().replaceAll("[^A-Za-z0-9-_]","_"));
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(tableName).setColumnFamily(ColumnFamilyDescriptorBuilder.of(FAMILY)).build();
    RegionInfo info=RegionInfoBuilder.newBuilder(tableName).build();
    Path path=new Path(DIR,tableName.getNameAsString());
    if (FS.exists(path)) {
      if (!FS.delete(path,true)) {
        throw new IOException("Failed delete of " + path);
      }
    }
    ChunkCreator.initialize(MemStoreLABImpl.CHUNK_SIZE_DEFAULT,false,0,0,0,null);
    return HRegion.createHRegion(info,path,CONF,htd,wals.getWAL(info));
  }
  private HRegion createHRegion(  TableDescriptor td,  RegionInfo info,  String dir,  WAL wal,  Durability durability) throws IOException {
    Path path=new Path(DIR,dir);
    if (FS.exists(path)) {
      if (!FS.delete(path,true)) {
        throw new IOException("Failed delete of " + path);
      }
    }
    ChunkCreator.initialize(MemStoreLABImpl.CHUNK_SIZE_DEFAULT,false,0,0,0,null);
    return HRegion.createHRegion(info,path,CONF,td,wal);
  }
}
