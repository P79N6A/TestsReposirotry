@Category({MapReduceTests.class,LargeTests.class}) public class TestImportTSVWithVisibilityLabels implements Configurable {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestImportTSVWithVisibilityLabels.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestImportTSVWithVisibilityLabels.class);
  protected static final String NAME=TestImportTsv.class.getSimpleName();
  protected static HBaseTestingUtility util=new HBaseTestingUtility();
  /** 
 * Delete the tmp directory after running doMROnTableTest. Boolean. Default is false.
 */
  protected static final String DELETE_AFTER_LOAD_CONF=NAME + ".deleteAfterLoad";
  /** 
 * Force use of combiner in doMROnTableTest. Boolean. Default is true.
 */
  protected static final String FORCE_COMBINER_CONF=NAME + ".forceCombiner";
  private final String FAMILY="FAM";
  private final static String TOPSECRET="topsecret";
  private final static String PUBLIC="public";
  private final static String PRIVATE="private";
  private final static String CONFIDENTIAL="confidential";
  private final static String SECRET="secret";
  private static User SUPERUSER;
  private static Configuration conf;
  @Rule public TestName name=new TestName();
  @Override public Configuration getConf(){
    return util.getConfiguration();
  }
  @Override public void setConf(  Configuration conf){
    throw new IllegalArgumentException("setConf not supported");
  }
  @BeforeClass public static void provisionCluster() throws Exception {
    conf=util.getConfiguration();
    SUPERUSER=User.createUserForTesting(conf,"admin",new String[]{"supergroup"});
    conf.set("hbase.superuser","admin," + User.getCurrent().getName());
    VisibilityTestUtil.enableVisiblityLabels(conf);
    conf.setClass(VisibilityUtils.VISIBILITY_LABEL_GENERATOR_CLASS,SimpleScanLabelGenerator.class,ScanLabelGenerator.class);
    util.startMiniCluster();
    util.waitTableEnabled(VisibilityConstants.LABELS_TABLE_NAME.getName(),50000);
    createLabels();
  }
  private static void createLabels() throws IOException, InterruptedException {
    PrivilegedExceptionAction<VisibilityLabelsResponse> action=new PrivilegedExceptionAction<VisibilityLabelsResponse>(){
      @Override public VisibilityLabelsResponse run() throws Exception {
        String[] labels={SECRET,TOPSECRET,CONFIDENTIAL,PUBLIC,PRIVATE};
        try (Connection conn=ConnectionFactory.createConnection(conf)){
          VisibilityClient.addLabels(conn,labels);
          LOG.info("Added labels ");
        }
 catch (        Throwable t) {
          LOG.error("Error in adding labels",t);
          throw new IOException(t);
        }
        return null;
      }
    }
;
    SUPERUSER.runAs(action);
  }
  @AfterClass public static void releaseCluster() throws Exception {
    util.shutdownMiniCluster();
  }
  @Test public void testMROnTable() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName() + util.getRandomUUID());
    String[] args=new String[]{"-D" + ImportTsv.MAPPER_CONF_KEY + "=org.apache.hadoop.hbase.mapreduce.TsvImporterMapper","-D" + ImportTsv.COLUMNS_CONF_KEY + "=HBASE_ROW_KEY,FAM:A,FAM:B,HBASE_CELL_VISIBILITY","-D" + ImportTsv.SEPARATOR_CONF_KEY + "=\u001b",tableName.getNameAsString()};
    String data="KEY\u001bVALUE1\u001bVALUE2\u001bsecret&private\n";
    util.createTable(tableName,FAMILY);
    doMROnTableTest(util,FAMILY,data,args,1);
    util.deleteTable(tableName);
  }
  @Test public void testMROnTableWithDeletes() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName() + util.getRandomUUID());
    String[] args=new String[]{"-D" + ImportTsv.MAPPER_CONF_KEY + "=org.apache.hadoop.hbase.mapreduce.TsvImporterMapper","-D" + ImportTsv.COLUMNS_CONF_KEY + "=HBASE_ROW_KEY,FAM:A,FAM:B,HBASE_CELL_VISIBILITY","-D" + ImportTsv.SEPARATOR_CONF_KEY + "=\u001b",tableName.getNameAsString()};
    String data="KEY\u001bVALUE1\u001bVALUE2\u001bsecret&private\n";
    util.createTable(tableName,FAMILY);
    doMROnTableTest(util,FAMILY,data,args,1);
    issueDeleteAndVerifyData(tableName);
    util.deleteTable(tableName);
  }
  private void issueDeleteAndVerifyData(  TableName tableName) throws IOException {
    LOG.debug("Validating table after delete.");
    Table table=util.getConnection().getTable(tableName);
    boolean verified=false;
    long pause=conf.getLong("hbase.client.pause",5 * 1000);
    int numRetries=conf.getInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,5);
    for (int i=0; i < numRetries; i++) {
      try {
        Delete d=new Delete(Bytes.toBytes("KEY"));
        d.addFamily(Bytes.toBytes(FAMILY));
        d.setCellVisibility(new CellVisibility("private&secret"));
        table.delete(d);
        Scan scan=new Scan();
        scan.addFamily(Bytes.toBytes(FAMILY));
        scan.setAuthorizations(new Authorizations("secret","private"));
        ResultScanner resScanner=table.getScanner(scan);
        Result[] next=resScanner.next(5);
        assertEquals(0,next.length);
        verified=true;
        break;
      }
 catch (      NullPointerException e) {
      }
      try {
        Thread.sleep(pause);
      }
 catch (      InterruptedException e) {
      }
    }
    table.close();
    assertTrue(verified);
  }
  @Test public void testMROnTableWithBulkload() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName() + util.getRandomUUID());
    Path hfiles=new Path(util.getDataTestDirOnTestFS(tableName.getNameAsString()),"hfiles");
    String[] args=new String[]{"-D" + ImportTsv.BULK_OUTPUT_CONF_KEY + "="+ hfiles.toString(),"-D" + ImportTsv.COLUMNS_CONF_KEY + "=HBASE_ROW_KEY,FAM:A,FAM:B,HBASE_CELL_VISIBILITY","-D" + ImportTsv.SEPARATOR_CONF_KEY + "=\u001b",tableName.getNameAsString()};
    String data="KEY\u001bVALUE1\u001bVALUE2\u001bsecret&private\n";
    util.createTable(tableName,FAMILY);
    doMROnTableTest(util,FAMILY,data,args,1);
    util.deleteTable(tableName);
  }
  @Test public void testBulkOutputWithTsvImporterTextMapper() throws Exception {
    final TableName table=TableName.valueOf(name.getMethodName() + util.getRandomUUID());
    String FAMILY="FAM";
    Path bulkOutputPath=new Path(util.getDataTestDirOnTestFS(table.getNameAsString()),"hfiles");
    String[] args=new String[]{"-D" + ImportTsv.MAPPER_CONF_KEY + "=org.apache.hadoop.hbase.mapreduce.TsvImporterTextMapper","-D" + ImportTsv.COLUMNS_CONF_KEY + "=HBASE_ROW_KEY,FAM:A,FAM:B,HBASE_CELL_VISIBILITY","-D" + ImportTsv.SEPARATOR_CONF_KEY + "=\u001b","-D" + ImportTsv.BULK_OUTPUT_CONF_KEY + "="+ bulkOutputPath.toString(),table.getNameAsString()};
    String data="KEY\u001bVALUE4\u001bVALUE8\u001bsecret&private\n";
    doMROnTableTest(util,FAMILY,data,args,4);
    util.deleteTable(table);
  }
  @Test public void testMRWithOutputFormat() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName() + util.getRandomUUID());
    Path hfiles=new Path(util.getDataTestDirOnTestFS(tableName.getNameAsString()),"hfiles");
    String[] args=new String[]{"-D" + ImportTsv.MAPPER_CONF_KEY + "=org.apache.hadoop.hbase.mapreduce.TsvImporterMapper","-D" + ImportTsv.BULK_OUTPUT_CONF_KEY + "="+ hfiles.toString(),"-D" + ImportTsv.COLUMNS_CONF_KEY + "=HBASE_ROW_KEY,FAM:A,FAM:B,HBASE_CELL_VISIBILITY","-D" + ImportTsv.SEPARATOR_CONF_KEY + "=\u001b",tableName.getNameAsString()};
    String data="KEY\u001bVALUE4\u001bVALUE8\u001bsecret&private\n";
    util.createTable(tableName,FAMILY);
    doMROnTableTest(util,FAMILY,data,args,1);
    util.deleteTable(tableName);
  }
  @Test public void testBulkOutputWithInvalidLabels() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName() + util.getRandomUUID());
    Path hfiles=new Path(util.getDataTestDirOnTestFS(tableName.getNameAsString()),"hfiles");
    String[] args=new String[]{"-D" + ImportTsv.BULK_OUTPUT_CONF_KEY + "="+ hfiles.toString(),"-D" + ImportTsv.COLUMNS_CONF_KEY + "=HBASE_ROW_KEY,FAM:A,FAM:B,HBASE_CELL_VISIBILITY","-D" + ImportTsv.SEPARATOR_CONF_KEY + "=\u001b",tableName.getNameAsString()};
    String data="KEY\u001bVALUE1\u001bVALUE2\u001bprivate\nKEY1\u001bVALUE1\u001bVALUE2\u001binvalid\n";
    util.createTable(tableName,FAMILY);
    doMROnTableTest(util,FAMILY,data,args,1,2);
    util.deleteTable(tableName);
  }
  @Test public void testBulkOutputWithTsvImporterTextMapperWithInvalidLabels() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName() + util.getRandomUUID());
    Path hfiles=new Path(util.getDataTestDirOnTestFS(tableName.getNameAsString()),"hfiles");
    String[] args=new String[]{"-D" + ImportTsv.MAPPER_CONF_KEY + "=org.apache.hadoop.hbase.mapreduce.TsvImporterTextMapper","-D" + ImportTsv.BULK_OUTPUT_CONF_KEY + "="+ hfiles.toString(),"-D" + ImportTsv.COLUMNS_CONF_KEY + "=HBASE_ROW_KEY,FAM:A,FAM:B,HBASE_CELL_VISIBILITY","-D" + ImportTsv.SEPARATOR_CONF_KEY + "=\u001b",tableName.getNameAsString()};
    String data="KEY\u001bVALUE1\u001bVALUE2\u001bprivate\nKEY1\u001bVALUE1\u001bVALUE2\u001binvalid\n";
    util.createTable(tableName,FAMILY);
    doMROnTableTest(util,FAMILY,data,args,1,2);
    util.deleteTable(tableName);
  }
  protected static Tool doMROnTableTest(  HBaseTestingUtility util,  String family,  String data,  String[] args,  int valueMultiplier) throws Exception {
    return doMROnTableTest(util,family,data,args,valueMultiplier,-1);
  }
  /** 
 * Run an ImportTsv job and perform basic validation on the results. Returns the ImportTsv <code>Tool</code> instance so that other tests can inspect it for further validation as necessary. This method is static to insure non-reliance on instance's util/conf facilities.
 * @param args Any arguments to pass BEFORE inputFile path is appended.
 * @param expectedKVCount Expected KV count. pass -1 to skip the kvcount check
 * @return The Tool instance used to run the test.
 */
  protected static Tool doMROnTableTest(  HBaseTestingUtility util,  String family,  String data,  String[] args,  int valueMultiplier,  int expectedKVCount) throws Exception {
    TableName table=TableName.valueOf(args[args.length - 1]);
    Configuration conf=new Configuration(util.getConfiguration());
    FileSystem fs=FileSystem.get(conf);
    Path inputPath=fs.makeQualified(new Path(util.getDataTestDirOnTestFS(table.getNameAsString()),"input.dat"));
    FSDataOutputStream op=fs.create(inputPath,true);
    if (data == null) {
      data="KEY\u001bVALUE1\u001bVALUE2\n";
    }
    op.write(Bytes.toBytes(data));
    op.close();
    LOG.debug(String.format("Wrote test data to file: %s",inputPath));
    if (conf.getBoolean(FORCE_COMBINER_CONF,true)) {
      LOG.debug("Forcing combiner.");
      conf.setInt("mapreduce.map.combine.minspills",1);
    }
    List<String> argv=new ArrayList<>(Arrays.asList(args));
    argv.add(inputPath.toString());
    Tool tool=new ImportTsv();
    LOG.debug("Running ImportTsv with arguments: " + argv);
    assertEquals(0,ToolRunner.run(conf,tool,argv.toArray(args)));
    boolean createdHFiles=false;
    String outputPath=null;
    for (    String arg : argv) {
      if (arg.contains(ImportTsv.BULK_OUTPUT_CONF_KEY)) {
        createdHFiles=true;
        outputPath=arg.split("=")[1];
        break;
      }
    }
    LOG.debug("validating the table " + createdHFiles);
    if (createdHFiles)     validateHFiles(fs,outputPath,family,expectedKVCount);
 else     validateTable(conf,table,family,valueMultiplier);
    if (conf.getBoolean(DELETE_AFTER_LOAD_CONF,true)) {
      LOG.debug("Deleting test subdirectory");
      util.cleanupDataTestDirOnTestFS(table.getNameAsString());
    }
    return tool;
  }
  /** 
 * Confirm ImportTsv via HFiles on fs.
 */
  private static void validateHFiles(  FileSystem fs,  String outputPath,  String family,  int expectedKVCount) throws IOException {
    LOG.debug("Validating HFiles.");
    Set<String> configFamilies=new HashSet<>();
    configFamilies.add(family);
    Set<String> foundFamilies=new HashSet<>();
    int actualKVCount=0;
    for (    FileStatus cfStatus : fs.listStatus(new Path(outputPath),new OutputFilesFilter())) {
      LOG.debug("The output path has files");
      String[] elements=cfStatus.getPath().toString().split(Path.SEPARATOR);
      String cf=elements[elements.length - 1];
      foundFamilies.add(cf);
      assertTrue(String.format("HFile ouput contains a column family (%s) not present in input families (%s)",cf,configFamilies),configFamilies.contains(cf));
      for (      FileStatus hfile : fs.listStatus(cfStatus.getPath())) {
        assertTrue(String.format("HFile %s appears to contain no data.",hfile.getPath()),hfile.getLen() > 0);
        if (expectedKVCount > -1) {
          actualKVCount+=getKVCountFromHfile(fs,hfile.getPath());
        }
      }
    }
    if (expectedKVCount > -1) {
      assertTrue(String.format("KV count in output hfile=<%d> doesn't match with expected KV count=<%d>",actualKVCount,expectedKVCount),actualKVCount == expectedKVCount);
    }
  }
  /** 
 * Confirm ImportTsv via data in online table.
 */
  private static void validateTable(  Configuration conf,  TableName tableName,  String family,  int valueMultiplier) throws IOException {
    LOG.debug("Validating table.");
    Table table=util.getConnection().getTable(tableName);
    boolean verified=false;
    long pause=conf.getLong("hbase.client.pause",5 * 1000);
    int numRetries=conf.getInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,5);
    for (int i=0; i < numRetries; i++) {
      try {
        Scan scan=new Scan();
        scan.addFamily(Bytes.toBytes(family));
        scan.setAuthorizations(new Authorizations("secret","private"));
        ResultScanner resScanner=table.getScanner(scan);
        Result[] next=resScanner.next(5);
        assertEquals(1,next.length);
        for (        Result res : resScanner) {
          LOG.debug("Getting results " + res.size());
          assertTrue(res.size() == 2);
          List<Cell> kvs=res.listCells();
          assertTrue(CellUtil.matchingRows(kvs.get(0),Bytes.toBytes("KEY")));
          assertTrue(CellUtil.matchingRows(kvs.get(1),Bytes.toBytes("KEY")));
          assertTrue(CellUtil.matchingValue(kvs.get(0),Bytes.toBytes("VALUE" + valueMultiplier)));
          assertTrue(CellUtil.matchingValue(kvs.get(1),Bytes.toBytes("VALUE" + 2 * valueMultiplier)));
        }
        verified=true;
        break;
      }
 catch (      NullPointerException e) {
      }
      try {
        Thread.sleep(pause);
      }
 catch (      InterruptedException e) {
      }
    }
    table.close();
    assertTrue(verified);
  }
  /** 
 * Method returns the total KVs in given hfile
 * @param fs File System
 * @param p HFile path
 * @return KV count in the given hfile
 * @throws IOException
 */
  private static int getKVCountFromHfile(  FileSystem fs,  Path p) throws IOException {
    Configuration conf=util.getConfiguration();
    HFile.Reader reader=HFile.createReader(fs,p,new CacheConfig(conf),true,conf);
    reader.loadFileInfo();
    HFileScanner scanner=reader.getScanner(false,false);
    scanner.seekTo();
    int count=0;
    do {
      count++;
    }
 while (scanner.next());
    reader.close();
    return count;
  }
}
