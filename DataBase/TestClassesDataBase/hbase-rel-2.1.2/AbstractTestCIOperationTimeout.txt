/** 
 * Based class for testing operation timeout logic for  {@link ConnectionImplementation}.
 */
public abstract class AbstractTestCIOperationTimeout extends AbstractTestCITimeout {
  private static final Logger LOG=LoggerFactory.getLogger(AbstractTestCIOperationTimeout.class);
  private TableName tableName;
  @Before public void setUp() throws IOException {
    tableName=TableName.valueOf(name.getMethodName());
    TableDescriptor htd=TableDescriptorBuilder.newBuilder(tableName).setCoprocessor(SleepAndFailFirstTime.class.getName()).setColumnFamily(ColumnFamilyDescriptorBuilder.of(FAM_NAM)).build();
    TEST_UTIL.getAdmin().createTable(htd);
  }
  protected abstract void execute(  Table table) throws IOException ;
  /** 
 * Test that an operation can fail if we read the global operation timeout, even if the individual timeout is fine. We do that with: <ul> <li>client side: an operation timeout of 30 seconds</li> <li>server side: we sleep 20 second at each attempt. The first work fails, the second one succeeds. But the client won't wait that much, because 20 + 20 > 30, so the client timed out when the server answers.</li> </ul>
 */
  @Test public void testOperationTimeout() throws IOException {
    TableBuilder builder=TEST_UTIL.getConnection().getTableBuilder(tableName,null).setRpcTimeout(Integer.MAX_VALUE).setReadRpcTimeout(Integer.MAX_VALUE).setWriteRpcTimeout(Integer.MAX_VALUE);
    SleepAndFailFirstTime.ct.set(0);
    try (Table table=builder.setOperationTimeout(120 * 1000).build()){
      execute(table);
    }
     SleepAndFailFirstTime.ct.set(0);
    try (Table table=builder.setOperationTimeout(30 * 1000).build()){
      SleepAndFailFirstTime.ct.set(0);
      execute(table);
      fail("We expect an exception here");
    }
 catch (    SocketTimeoutException|RetriesExhaustedWithDetailsException e) {
      LOG.info("We received an exception, as expected ",e);
    }
  }
}
