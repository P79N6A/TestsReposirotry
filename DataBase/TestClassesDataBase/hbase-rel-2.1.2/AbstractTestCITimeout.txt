/** 
 * Based class for testing timeout logic for  {@link ConnectionImplementation}.
 */
public abstract class AbstractTestCITimeout {
  protected static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  protected static final byte[] FAM_NAM=Bytes.toBytes("f");
  @Rule public final TestName name=new TestName();
  /** 
 * This copro sleeps 20 second. The first call it fails. The second time, it works.
 */
public static class SleepAndFailFirstTime implements RegionCoprocessor, RegionObserver {
    static final AtomicLong ct=new AtomicLong(0);
    static final String SLEEP_TIME_CONF_KEY="hbase.coprocessor.SleepAndFailFirstTime.sleepTime";
    static final long DEFAULT_SLEEP_TIME=20000;
    static final AtomicLong sleepTime=new AtomicLong(DEFAULT_SLEEP_TIME);
    public SleepAndFailFirstTime(){
    }
    @Override public Optional<RegionObserver> getRegionObserver(){
      return Optional.of(this);
    }
    @Override public void postOpen(    ObserverContext<RegionCoprocessorEnvironment> c){
      RegionCoprocessorEnvironment env=c.getEnvironment();
      Configuration conf=env.getConfiguration();
      sleepTime.set(conf.getLong(SLEEP_TIME_CONF_KEY,DEFAULT_SLEEP_TIME));
    }
    @Override public void preGetOp(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Get get,    final List<Cell> results) throws IOException {
      Threads.sleep(sleepTime.get());
      if (ct.incrementAndGet() == 1) {
        throw new IOException("first call I fail");
      }
    }
    @Override public void prePut(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Put put,    final WALEdit edit,    final Durability durability) throws IOException {
      Threads.sleep(sleepTime.get());
      if (ct.incrementAndGet() == 1) {
        throw new IOException("first call I fail");
      }
    }
    @Override public void preDelete(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Delete delete,    final WALEdit edit,    final Durability durability) throws IOException {
      Threads.sleep(sleepTime.get());
      if (ct.incrementAndGet() == 1) {
        throw new IOException("first call I fail");
      }
    }
    @Override public Result preIncrement(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Increment increment) throws IOException {
      Threads.sleep(sleepTime.get());
      if (ct.incrementAndGet() == 1) {
        throw new IOException("first call I fail");
      }
      return null;
    }
  }
public static class SleepCoprocessor implements RegionCoprocessor, RegionObserver {
    public static final int SLEEP_TIME=5000;
    @Override public Optional<RegionObserver> getRegionObserver(){
      return Optional.of(this);
    }
    @Override public void preGetOp(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Get get,    final List<Cell> results) throws IOException {
      Threads.sleep(SLEEP_TIME);
    }
    @Override public void prePut(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Put put,    final WALEdit edit,    final Durability durability) throws IOException {
      Threads.sleep(SLEEP_TIME);
    }
    @Override public Result preIncrement(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Increment increment) throws IOException {
      Threads.sleep(SLEEP_TIME);
      return null;
    }
    @Override public void preDelete(    final ObserverContext<RegionCoprocessorEnvironment> e,    final Delete delete,    final WALEdit edit,    final Durability durability) throws IOException {
      Threads.sleep(SLEEP_TIME);
    }
  }
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    TEST_UTIL.getConfiguration().setBoolean(HConstants.STATUS_PUBLISHED,true);
    TEST_UTIL.getConfiguration().setInt(HConstants.REGION_SERVER_HIGH_PRIORITY_HANDLER_COUNT,10);
    TEST_UTIL.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,5);
    TEST_UTIL.getConfiguration().setInt(HConstants.REGION_SERVER_HANDLER_COUNT,3);
    TEST_UTIL.startMiniCluster(2);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
}
