@Category({IOTests.class,SmallTests.class}) public class TestBucketWriterThread {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestBucketWriterThread.class);
  private BucketCache bc;
  private BucketCache.WriterThread wt;
  private BlockingQueue<RAMQueueEntry> q;
  private Cacheable plainCacheable;
  private BlockCacheKey plainKey;
  /** 
 * A BucketCache that does not start its writer threads. 
 */
private static class MockBucketCache extends BucketCache {
    public MockBucketCache(    String ioEngineName,    long capacity,    int blockSize,    int[] bucketSizes,    int writerThreadNum,    int writerQLen,    String persistencePath,    int ioErrorsTolerationDuration) throws FileNotFoundException, IOException {
      super(ioEngineName,capacity,blockSize,bucketSizes,writerThreadNum,writerQLen,persistencePath,ioErrorsTolerationDuration,HBaseConfiguration.create());
    }
    @Override protected void startWriterThreads(){
    }
  }
  /** 
 * Set up variables and get BucketCache and WriterThread into state where tests can  manually control the running of WriterThread and BucketCache is empty.
 * @throws Exception
 */
  @Before public void setUp() throws Exception {
    final int capacity=16;
    final int writerThreadsCount=1;
    this.bc=new MockBucketCache("offheap",capacity,1,new int[]{1},writerThreadsCount,capacity,null,100);
    assertEquals(writerThreadsCount,bc.writerThreads.length);
    assertEquals(writerThreadsCount,bc.writerQueues.size());
    this.wt=bc.writerThreads[0];
    this.q=bc.writerQueues.get(0);
    wt.disableWriter();
    this.plainKey=new BlockCacheKey("f",0);
    this.plainCacheable=Mockito.mock(Cacheable.class);
    assertThat(bc.ramCache.isEmpty(),is(true));
    assertTrue(q.isEmpty());
  }
  @After public void tearDown() throws Exception {
    if (this.bc != null)     this.bc.shutdown();
  }
  /** 
 * Test non-error case just works.
 * @throws FileNotFoundException
 * @throws IOException
 * @throws InterruptedException
 */
  @Test public void testNonErrorCase() throws IOException, InterruptedException {
    bc.cacheBlock(this.plainKey,this.plainCacheable);
    doDrainOfOneEntry(this.bc,this.wt,this.q);
  }
  /** 
 * Pass through a too big entry and ensure it is cleared from queues and ramCache. Manually run the WriterThread.
 * @throws InterruptedException
 */
  @Test public void testTooBigEntry() throws InterruptedException {
    Cacheable tooBigCacheable=Mockito.mock(Cacheable.class);
    Mockito.when(tooBigCacheable.getSerializedLength()).thenReturn(Integer.MAX_VALUE);
    this.bc.cacheBlock(this.plainKey,tooBigCacheable);
    doDrainOfOneEntry(this.bc,this.wt,this.q);
  }
  /** 
 * Do IOE. Take the RAMQueueEntry that was on the queue, doctor it to throw exception, then put it back and process it.
 * @throws IOException
 * @throws InterruptedException
 */
  @SuppressWarnings("unchecked") @Test public void testIOE() throws IOException, InterruptedException {
    this.bc.cacheBlock(this.plainKey,plainCacheable);
    RAMQueueEntry rqe=q.remove();
    RAMQueueEntry spiedRqe=Mockito.spy(rqe);
    Mockito.doThrow(new IOException("Mocked!")).when(spiedRqe).writeToCache((IOEngine)Mockito.any(),(BucketAllocator)Mockito.any(),(UniqueIndexMap<Integer>)Mockito.any(),(LongAdder)Mockito.any());
    this.q.add(spiedRqe);
    doDrainOfOneEntry(bc,wt,q);
    assertTrue(!bc.isCacheEnabled());
  }
  /** 
 * Do Cache full exception
 * @throws IOException
 * @throws InterruptedException
 */
  @Test public void testCacheFullException() throws IOException, InterruptedException {
    this.bc.cacheBlock(this.plainKey,plainCacheable);
    RAMQueueEntry rqe=q.remove();
    RAMQueueEntry spiedRqe=Mockito.spy(rqe);
    final CacheFullException cfe=new CacheFullException(0,0);
    BucketEntry mockedBucketEntry=Mockito.mock(BucketEntry.class);
    Mockito.doThrow(cfe).doReturn(mockedBucketEntry).when(spiedRqe).writeToCache((IOEngine)Mockito.any(),(BucketAllocator)Mockito.any(),(UniqueIndexMap<Integer>)Mockito.any(),(LongAdder)Mockito.any());
    this.q.add(spiedRqe);
    doDrainOfOneEntry(bc,wt,q);
  }
  private static void doDrainOfOneEntry(  final BucketCache bc,  final BucketCache.WriterThread wt,  final BlockingQueue<RAMQueueEntry> q) throws InterruptedException {
    List<RAMQueueEntry> rqes=BucketCache.getRAMQueueEntries(q,new ArrayList<>(1));
    wt.doDrain(rqes);
    assertTrue(q.isEmpty());
    assertTrue(bc.ramCache.isEmpty());
    assertEquals(0,bc.heapSize());
  }
}
