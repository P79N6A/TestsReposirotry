/** 
 * Test the master-related aspects of a snapshot
 */
@Category({MasterTests.class,MediumTests.class}) public class TestSnapshotFromMaster {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSnapshotFromMaster.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestSnapshotFromMaster.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final int NUM_RS=2;
  private static Path rootDir;
  private static FileSystem fs;
  private static HMaster master;
  private static Path archiveDir;
  private static final byte[] TEST_FAM=Bytes.toBytes("fam");
  private static final TableName TABLE_NAME=TableName.valueOf("test");
  private static final long cacheRefreshPeriod=500;
  private static final int blockingStoreFiles=12;
  /** 
 * Setup the config for the cluster
 */
  @BeforeClass public static void setupCluster() throws Exception {
    setupConf(UTIL.getConfiguration());
    UTIL.startMiniCluster(NUM_RS);
    fs=UTIL.getDFSCluster().getFileSystem();
    master=UTIL.getMiniHBaseCluster().getMaster();
    rootDir=master.getMasterFileSystem().getRootDir();
    archiveDir=new Path(rootDir,HConstants.HFILE_ARCHIVE_DIRECTORY);
  }
  private static void setupConf(  Configuration conf){
    conf.setInt("hbase.regionsever.info.port",-1);
    conf.setInt("hbase.hregion.memstore.flush.size",25000);
    conf.setInt("hbase.hstore.compaction.min",2);
    conf.setInt("hbase.hstore.compactionThreshold",5);
    conf.setInt("hbase.hstore.blockingStoreFiles",blockingStoreFiles);
    conf.set(HFileCleaner.MASTER_HFILE_CLEANER_PLUGINS,"");
    conf.set(HConstants.HBASE_MASTER_LOGCLEANER_PLUGINS,"");
    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED,true);
    conf.setLong(SnapshotManager.HBASE_SNAPSHOT_SENTINELS_CLEANUP_TIMEOUT_MILLIS,3 * 1000L);
    conf.setLong(SnapshotHFileCleaner.HFILE_CACHE_REFRESH_PERIOD_CONF_KEY,cacheRefreshPeriod);
    conf.set(HConstants.HBASE_REGION_SPLIT_POLICY_KEY,ConstantSizeRegionSplitPolicy.class.getName());
    conf.setInt("hbase.hfile.compactions.cleaner.interval",20 * 1000);
  }
  @Before public void setup() throws Exception {
    UTIL.createTable(TABLE_NAME,TEST_FAM);
    master.getSnapshotManager().setSnapshotHandlerForTesting(TABLE_NAME,null);
  }
  @After public void tearDown() throws Exception {
    UTIL.deleteTable(TABLE_NAME);
    SnapshotTestingUtils.deleteAllSnapshots(UTIL.getAdmin());
    SnapshotTestingUtils.deleteArchiveDirectory(UTIL);
  }
  @AfterClass public static void cleanupTest() throws Exception {
    try {
      UTIL.shutdownMiniCluster();
    }
 catch (    Exception e) {
    }
  }
  /** 
 * Test that the contract from the master for checking on a snapshot are valid. <p> <ol> <li>If a snapshot fails with an error, we expect to get the source error.</li> <li>If there is no snapshot name supplied, we should get an error.</li> <li>If asking about a snapshot has hasn't occurred, you should get an error.</li> </ol>
 */
  @Test public void testIsDoneContract() throws Exception {
    IsSnapshotDoneRequest.Builder builder=IsSnapshotDoneRequest.newBuilder();
    String snapshotName="asyncExpectedFailureTest";
    SnapshotTestingUtils.expectSnapshotDoneException(master,builder.build(),UnknownSnapshotException.class);
    SnapshotDescription desc=SnapshotDescription.newBuilder().setName(snapshotName).setTable(TABLE_NAME.getNameAsString()).build();
    builder.setSnapshot(desc);
    SnapshotTestingUtils.expectSnapshotDoneException(master,builder.build(),UnknownSnapshotException.class);
    DisabledTableSnapshotHandler mockHandler=Mockito.mock(DisabledTableSnapshotHandler.class);
    Mockito.when(mockHandler.getException()).thenReturn(null);
    Mockito.when(mockHandler.getSnapshot()).thenReturn(desc);
    Mockito.when(mockHandler.isFinished()).thenReturn(Boolean.TRUE);
    Mockito.when(mockHandler.getCompletionTimestamp()).thenReturn(EnvironmentEdgeManager.currentTime());
    master.getSnapshotManager().setSnapshotHandlerForTesting(TABLE_NAME,mockHandler);
    builder=IsSnapshotDoneRequest.newBuilder();
    SnapshotTestingUtils.expectSnapshotDoneException(master,builder.build(),UnknownSnapshotException.class);
    builder.setSnapshot(desc);
    IsSnapshotDoneResponse response=master.getMasterRpcServices().isSnapshotDone(null,builder.build());
    assertTrue("Snapshot didn't complete when it should have.",response.getDone());
    builder.setSnapshot(SnapshotDescription.newBuilder().setName("Not A Snapshot").build());
    SnapshotTestingUtils.expectSnapshotDoneException(master,builder.build(),UnknownSnapshotException.class);
    snapshotName="completed";
    desc=createSnapshot(snapshotName);
    builder.setSnapshot(desc);
    response=master.getMasterRpcServices().isSnapshotDone(null,builder.build());
    assertTrue("Completed, on-disk snapshot not found",response.getDone());
  }
  @Test public void testGetCompletedSnapshots() throws Exception {
    GetCompletedSnapshotsRequest request=GetCompletedSnapshotsRequest.newBuilder().build();
    GetCompletedSnapshotsResponse response=master.getMasterRpcServices().getCompletedSnapshots(null,request);
    assertEquals("Found unexpected number of snapshots",0,response.getSnapshotsCount());
    String snapshotName="completed";
    SnapshotDescription snapshot=createSnapshot(snapshotName);
    response=master.getMasterRpcServices().getCompletedSnapshots(null,request);
    assertEquals("Found unexpected number of snapshots",1,response.getSnapshotsCount());
    List<SnapshotDescription> snapshots=response.getSnapshotsList();
    List<SnapshotDescription> expected=Lists.newArrayList(snapshot);
    assertEquals("Returned snapshots don't match created snapshots",expected,snapshots);
    snapshotName="completed_two";
    snapshot=createSnapshot(snapshotName);
    expected.add(snapshot);
    response=master.getMasterRpcServices().getCompletedSnapshots(null,request);
    assertEquals("Found unexpected number of snapshots",2,response.getSnapshotsCount());
    snapshots=response.getSnapshotsList();
    assertEquals("Returned snapshots don't match created snapshots",expected,snapshots);
  }
  @Test public void testDeleteSnapshot() throws Exception {
    String snapshotName="completed";
    SnapshotDescription snapshot=SnapshotDescription.newBuilder().setName(snapshotName).build();
    DeleteSnapshotRequest request=DeleteSnapshotRequest.newBuilder().setSnapshot(snapshot).build();
    try {
      master.getMasterRpcServices().deleteSnapshot(null,request);
      fail("Master didn't throw exception when attempting to delete snapshot that doesn't exist");
    }
 catch (    org.apache.hbase.thirdparty.com.google.protobuf.ServiceException e) {
    }
    createSnapshot(snapshotName);
    master.getMasterRpcServices().deleteSnapshot(null,request);
  }
  /** 
 * Test that the snapshot hfile archive cleaner works correctly. HFiles that are in snapshots should be retained, while those that are not in a snapshot should be deleted.
 * @throws Exception on failure
 */
  @Test public void testSnapshotHFileArchiving() throws Exception {
    Admin admin=UTIL.getAdmin();
    SnapshotTestingUtils.assertNoSnapshots(admin);
    UTIL.deleteTable(TABLE_NAME);
    TableDescriptor td=TableDescriptorBuilder.newBuilder(TABLE_NAME).setColumnFamily(ColumnFamilyDescriptorBuilder.of(TEST_FAM)).setCompactionEnabled(false).build();
    UTIL.getAdmin().createTable(td);
    for (int i=0; i < blockingStoreFiles / 2; i++) {
      UTIL.loadTable(UTIL.getConnection().getTable(TABLE_NAME),TEST_FAM);
      UTIL.flush(TABLE_NAME);
    }
    admin.disableTable(TABLE_NAME);
    String snapshotName="snapshot";
    byte[] snapshotNameBytes=Bytes.toBytes(snapshotName);
    admin.snapshot(snapshotNameBytes,TABLE_NAME);
    LOG.info("After snapshot File-System state");
    FSUtils.logFileSystemState(fs,rootDir,LOG);
    SnapshotTestingUtils.assertOneSnapshotThatMatches(admin,snapshotNameBytes,TABLE_NAME);
    td=TableDescriptorBuilder.newBuilder(td).setCompactionEnabled(true).build();
    admin.modifyTable(td);
    admin.enableTable(TABLE_NAME);
    List<HRegion> regions=UTIL.getHBaseCluster().getRegions(TABLE_NAME);
    for (    HRegion region : regions) {
      region.waitForFlushesAndCompactions();
      region.compactStores();
    }
    List<RegionServerThread> regionServerThreads=UTIL.getMiniHBaseCluster().getRegionServerThreads();
    HRegionServer hrs=null;
    for (    RegionServerThread rs : regionServerThreads) {
      if (!rs.getRegionServer().getRegions(TABLE_NAME).isEmpty()) {
        hrs=rs.getRegionServer();
        break;
      }
    }
    CompactedHFilesDischarger cleaner=new CompactedHFilesDischarger(100,null,hrs,false);
    cleaner.chore();
    LOG.info("After compaction File-System state");
    FSUtils.logFileSystemState(fs,rootDir,LOG);
    LOG.debug("Running hfile cleaners");
    ensureHFileCleanersRun();
    LOG.info("After cleaners File-System state: " + rootDir);
    FSUtils.logFileSystemState(fs,rootDir,LOG);
    Path snapshotTable=SnapshotDescriptionUtils.getCompletedSnapshotDir(snapshotName,rootDir);
    Set<String> snapshotHFiles=SnapshotReferenceUtil.getHFileNames(UTIL.getConfiguration(),fs,snapshotTable);
    LOG.debug("Have snapshot hfiles:");
    for (    String fileName : snapshotHFiles) {
      LOG.debug(fileName);
    }
    Collection<String> archives=getHFiles(archiveDir,fs,TABLE_NAME);
    Collection<String> hfiles=getHFiles(rootDir,fs,TABLE_NAME);
    for (    String fileName : snapshotHFiles) {
      boolean exist=archives.contains(fileName) || hfiles.contains(fileName);
      assertTrue("Archived hfiles " + archives + " and table hfiles "+ hfiles+ " is missing snapshot file:"+ fileName,exist);
    }
    admin.deleteSnapshot(snapshotNameBytes);
    SnapshotTestingUtils.assertNoSnapshots(admin);
    List<BaseHFileCleanerDelegate> delegates=UTIL.getMiniHBaseCluster().getMaster().getHFileCleaner().cleanersChain;
    for (    BaseHFileCleanerDelegate delegate : delegates) {
      if (delegate instanceof SnapshotHFileCleaner) {
        ((SnapshotHFileCleaner)delegate).getFileCacheForTesting().triggerCacheRefreshForTesting();
      }
    }
    LOG.debug("Running hfile cleaners");
    ensureHFileCleanersRun();
    LOG.info("After delete snapshot cleaners run File-System state");
    FSUtils.logFileSystemState(fs,rootDir,LOG);
    archives=getHFiles(archiveDir,fs,TABLE_NAME);
    assertEquals("Still have some hfiles in the archive, when their snapshot has been deleted.",0,archives.size());
  }
  /** 
 * @return all the HFiles for a given table in the specified dir
 * @throws IOException on expected failure
 */
  private final Collection<String> getHFiles(  Path dir,  FileSystem fs,  TableName tableName) throws IOException {
    Path tableDir=FSUtils.getTableDir(dir,tableName);
    return SnapshotTestingUtils.listHFileNames(fs,tableDir);
  }
  /** 
 * Make sure the  {@link HFileCleaner HFileCleaners} run at least once
 */
  private static void ensureHFileCleanersRun(){
    UTIL.getHBaseCluster().getMaster().getHFileCleaner().chore();
  }
  private SnapshotDescription createSnapshot(  final String snapshotName) throws IOException {
    SnapshotTestingUtils.SnapshotMock snapshotMock=new SnapshotTestingUtils.SnapshotMock(UTIL.getConfiguration(),fs,rootDir);
    SnapshotTestingUtils.SnapshotMock.SnapshotBuilder builder=snapshotMock.createSnapshotV2(snapshotName,"test",0);
    builder.commit();
    return builder.getSnapshotDescription();
  }
  @Test public void testAsyncSnapshotWillNotBlockSnapshotHFileCleaner() throws Exception {
    Table table=UTIL.getConnection().getTable(TABLE_NAME);
    for (int i=0; i < 10; i++) {
      Put put=new Put(Bytes.toBytes(i)).addColumn(TEST_FAM,Bytes.toBytes("q"),Bytes.toBytes(i));
      table.put(put);
    }
    String snapshotName="testAsyncSnapshotWillNotBlockSnapshotHFileCleaner01";
    UTIL.getAdmin().snapshotAsync(new org.apache.hadoop.hbase.client.SnapshotDescription(snapshotName,TABLE_NAME,SnapshotType.FLUSH));
    Waiter.waitFor(UTIL.getConfiguration(),10 * 1000L,200L,() -> UTIL.getAdmin().listSnapshots(Pattern.compile(snapshotName)).size() == 1);
    assertTrue(master.getSnapshotManager().isTakingAnySnapshot());
    Thread.sleep(11 * 1000L);
    assertFalse(master.getSnapshotManager().isTakingAnySnapshot());
  }
}
