@Category({RegionServerTests.class,MediumTests.class}) public class TestEncryptionKeyRotation {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestEncryptionKeyRotation.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestEncryptionKeyRotation.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final Configuration conf=TEST_UTIL.getConfiguration();
  private static final Key initialCFKey;
  private static final Key secondCFKey;
  @Rule public TestName name=new TestName();
static {
    SecureRandom rng=new SecureRandom();
    byte[] keyBytes=new byte[AES.KEY_LENGTH];
    rng.nextBytes(keyBytes);
    String algorithm=conf.get(HConstants.CRYPTO_KEY_ALGORITHM_CONF_KEY,HConstants.CIPHER_AES);
    initialCFKey=new SecretKeySpec(keyBytes,algorithm);
    rng.nextBytes(keyBytes);
    secondCFKey=new SecretKeySpec(keyBytes,algorithm);
  }
  @BeforeClass public static void setUp() throws Exception {
    conf.setInt("hfile.format.version",3);
    conf.set(HConstants.CRYPTO_KEYPROVIDER_CONF_KEY,KeyProviderForTesting.class.getName());
    conf.set(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY,"hbase");
    TEST_UTIL.startMiniCluster(1);
  }
  @AfterClass public static void tearDown() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testCFKeyRotation() throws Exception {
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf("default",name.getMethodName()));
    HColumnDescriptor hcd=new HColumnDescriptor("cf");
    String algorithm=conf.get(HConstants.CRYPTO_KEY_ALGORITHM_CONF_KEY,HConstants.CIPHER_AES);
    hcd.setEncryptionType(algorithm);
    hcd.setEncryptionKey(EncryptionUtil.wrapKey(conf,"hbase",initialCFKey));
    htd.addFamily(hcd);
    createTableAndFlush(htd);
    final List<Path> initialPaths=findStorefilePaths(htd.getTableName());
    assertTrue(initialPaths.size() > 0);
    for (    Path path : initialPaths) {
      assertTrue("Store file " + path + " has incorrect key",Bytes.equals(initialCFKey.getEncoded(),extractHFileKey(path)));
    }
    hcd=htd.getFamily(Bytes.toBytes("cf"));
    hcd.setEncryptionKey(EncryptionUtil.wrapKey(conf,conf.get(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY,User.getCurrent().getShortName()),secondCFKey));
    TEST_UTIL.getAdmin().modifyColumnFamily(htd.getTableName(),hcd);
    Thread.sleep(5000);
    TEST_UTIL.getAdmin().majorCompact(htd.getTableName());
    final List<Path> updatePaths=findCompactedStorefilePaths(htd.getTableName());
    TEST_UTIL.waitFor(30000,1000,true,new Predicate<Exception>(){
      @Override public boolean evaluate() throws Exception {
        boolean found=false;
        for (        Path path : updatePaths) {
          found=TEST_UTIL.getTestFileSystem().exists(path);
          if (found) {
            LOG.info("Found " + path);
            break;
          }
        }
        return !found;
      }
    }
);
    Thread.sleep(1000);
    waitForCompaction(htd.getTableName());
    List<Path> pathsAfterCompaction=findStorefilePaths(htd.getTableName());
    assertTrue(pathsAfterCompaction.size() > 0);
    for (    Path path : pathsAfterCompaction) {
      assertTrue("Store file " + path + " has incorrect key",Bytes.equals(secondCFKey.getEncoded(),extractHFileKey(path)));
    }
    List<Path> compactedPaths=findCompactedStorefilePaths(htd.getTableName());
    assertTrue(compactedPaths.size() > 0);
    for (    Path path : compactedPaths) {
      assertTrue("Store file " + path + " retains initial key",Bytes.equals(initialCFKey.getEncoded(),extractHFileKey(path)));
    }
  }
  @Test public void testMasterKeyRotation() throws Exception {
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf("default",name.getMethodName()));
    HColumnDescriptor hcd=new HColumnDescriptor("cf");
    String algorithm=conf.get(HConstants.CRYPTO_KEY_ALGORITHM_CONF_KEY,HConstants.CIPHER_AES);
    hcd.setEncryptionType(algorithm);
    hcd.setEncryptionKey(EncryptionUtil.wrapKey(conf,"hbase",initialCFKey));
    htd.addFamily(hcd);
    createTableAndFlush(htd);
    List<Path> storeFilePaths=findStorefilePaths(htd.getTableName());
    assertTrue(storeFilePaths.size() > 0);
    for (    Path path : storeFilePaths) {
      assertTrue("Store file " + path + " has incorrect key",Bytes.equals(initialCFKey.getEncoded(),extractHFileKey(path)));
    }
    TEST_UTIL.shutdownMiniHBaseCluster();
    conf.set(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY,"other");
    conf.set(HConstants.CRYPTO_MASTERKEY_ALTERNATE_NAME_CONF_KEY,"hbase");
    TEST_UTIL.startMiniHBaseCluster(1,1);
    TEST_UTIL.waitTableAvailable(htd.getTableName(),5000);
    storeFilePaths=findStorefilePaths(htd.getTableName());
    assertTrue(storeFilePaths.size() > 0);
    for (    Path path : storeFilePaths) {
      assertTrue("Store file " + path + " has incorrect key",Bytes.equals(initialCFKey.getEncoded(),extractHFileKey(path)));
    }
  }
  private static void waitForCompaction(  TableName tableName) throws IOException, InterruptedException {
    boolean compacted=false;
    for (    Region region : TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegions(tableName)) {
      for (      HStore store : ((HRegion)region).getStores()) {
        compacted=false;
        while (!compacted) {
          if (store.getStorefiles() != null) {
            while (store.getStorefilesCount() != 1) {
              Thread.sleep(100);
            }
            for (            HStoreFile storefile : store.getStorefiles()) {
              if (!storefile.isCompactedAway()) {
                compacted=true;
                break;
              }
              Thread.sleep(100);
            }
          }
 else {
            break;
          }
        }
      }
    }
  }
  private static List<Path> findStorefilePaths(  TableName tableName) throws Exception {
    List<Path> paths=new ArrayList<>();
    for (    Region region : TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegions(tableName)) {
      for (      HStore store : ((HRegion)region).getStores()) {
        for (        HStoreFile storefile : store.getStorefiles()) {
          paths.add(storefile.getPath());
        }
      }
    }
    return paths;
  }
  private static List<Path> findCompactedStorefilePaths(  TableName tableName) throws Exception {
    List<Path> paths=new ArrayList<>();
    for (    Region region : TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegions(tableName)) {
      for (      HStore store : ((HRegion)region).getStores()) {
        Collection<HStoreFile> compactedfiles=store.getStoreEngine().getStoreFileManager().getCompactedfiles();
        if (compactedfiles != null) {
          for (          HStoreFile storefile : compactedfiles) {
            paths.add(storefile.getPath());
          }
        }
      }
    }
    return paths;
  }
  private void createTableAndFlush(  HTableDescriptor htd) throws Exception {
    HColumnDescriptor hcd=htd.getFamilies().iterator().next();
    TEST_UTIL.getAdmin().createTable(htd);
    TEST_UTIL.waitTableAvailable(htd.getTableName(),5000);
    Table table=TEST_UTIL.getConnection().getTable(htd.getTableName());
    try {
      table.put(new Put(Bytes.toBytes("testrow")).addColumn(hcd.getName(),Bytes.toBytes("q"),Bytes.toBytes("value")));
    }
  finally {
      table.close();
    }
    TEST_UTIL.getAdmin().flush(htd.getTableName());
  }
  private static byte[] extractHFileKey(  Path path) throws Exception {
    HFile.Reader reader=HFile.createReader(TEST_UTIL.getTestFileSystem(),path,new CacheConfig(conf),true,conf);
    try {
      reader.loadFileInfo();
      Encryption.Context cryptoContext=reader.getFileContext().getEncryptionContext();
      assertNotNull("Reader has a null crypto context",cryptoContext);
      Key key=cryptoContext.getKey();
      assertNotNull("Crypto context has no key",key);
      return key.getEncoded();
    }
  finally {
      reader.close();
    }
  }
}
