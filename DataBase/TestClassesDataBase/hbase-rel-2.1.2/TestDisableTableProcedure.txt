@Category({MasterTests.class,MediumTests.class}) public class TestDisableTableProcedure extends TestTableDDLProcedureBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestDisableTableProcedure.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestDisableTableProcedure.class);
  @Rule public TestName name=new TestName();
  @Test public void testDisableTable() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    MasterProcedureTestingUtility.createTable(procExec,tableName,null,"f1","f2");
    long procId=procExec.submitProcedure(new DisableTableProcedure(procExec.getEnvironment(),tableName,false));
    ProcedureTestingUtility.waitProcedure(procExec,procId);
    ProcedureTestingUtility.assertProcNotFailed(procExec,procId);
    MasterProcedureTestingUtility.validateTableIsDisabled(getMaster(),tableName);
  }
  @Test public void testDisableTableMultipleTimes() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    MasterProcedureTestingUtility.createTable(procExec,tableName,null,"f1","f2");
    long procId1=procExec.submitProcedure(new DisableTableProcedure(procExec.getEnvironment(),tableName,false));
    ProcedureTestingUtility.waitProcedure(procExec,procId1);
    ProcedureTestingUtility.assertProcNotFailed(procExec,procId1);
    MasterProcedureTestingUtility.validateTableIsDisabled(getMaster(),tableName);
    Throwable e=null;
    Throwable cause=null;
    try {
      long procId2=procExec.submitProcedure(new DisableTableProcedure(procExec.getEnvironment(),tableName,false));
      ProcedureTestingUtility.waitProcedure(procExec,procId2);
      Procedure<?> result=procExec.getResult(procId2);
      assertTrue(result.isFailed());
      cause=ProcedureTestingUtility.getExceptionCause(result);
      e=result.getException();
    }
 catch (    TableNotEnabledException tnde) {
      e=tnde;
      cause=tnde;
    }
    LOG.debug("Disable failed with exception {}" + e);
    assertTrue(cause instanceof TableNotEnabledException);
    try {
      final ProcedurePrepareLatch prepareLatch=new ProcedurePrepareLatch.CompatibilityLatch();
      long procId3=procExec.submitProcedure(new DisableTableProcedure(procExec.getEnvironment(),tableName,false,prepareLatch));
      prepareLatch.await();
      Assert.fail("Disable should throw exception through latch.");
    }
 catch (    TableNotEnabledException tnee) {
      LOG.debug("Disable failed with expected exception {}",tnee);
    }
    try {
      long procId4=procExec.submitProcedure(new DisableTableProcedure(procExec.getEnvironment(),tableName,true));
      ProcedureTestingUtility.waitProcedure(procExec,procId4);
      ProcedureTestingUtility.assertProcNotFailed(procExec,procId4);
    }
 catch (    TableNotEnabledException tnee) {
      LOG.debug("Disable failed with expected exception {}",tnee);
    }
    MasterProcedureTestingUtility.validateTableIsDisabled(getMaster(),tableName);
  }
  @Test public void testRecoveryAndDoubleExecution() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    final byte[][] splitKeys=new byte[][]{Bytes.toBytes("a"),Bytes.toBytes("b"),Bytes.toBytes("c")};
    MasterProcedureTestingUtility.createTable(procExec,tableName,splitKeys,"f1","f2");
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    long procId=procExec.submitProcedure(new DisableTableProcedure(procExec.getEnvironment(),tableName,false));
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec,procId);
    MasterProcedureTestingUtility.validateTableIsDisabled(getMaster(),tableName);
  }
}
