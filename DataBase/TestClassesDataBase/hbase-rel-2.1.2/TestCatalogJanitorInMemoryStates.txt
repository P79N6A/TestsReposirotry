@Category({MasterTests.class,MediumTests.class}) public class TestCatalogJanitorInMemoryStates {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestCatalogJanitorInMemoryStates.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestCatalogJanitorInMemoryStates.class);
  @Rule public final TestName name=new TestName();
  protected final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static byte[] ROW=Bytes.toBytes("testRow");
  private static byte[] FAMILY=Bytes.toBytes("testFamily");
  private static byte[] QUALIFIER=Bytes.toBytes("testQualifier");
  private static byte[] VALUE=Bytes.toBytes("testValue");
  /** 
 * @throws java.lang.Exception
 */
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    TEST_UTIL.startMiniCluster(1);
  }
  /** 
 * @throws java.lang.Exception
 */
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  /** 
 * Test clearing a split parent from memory.
 */
  @Test public void testInMemoryParentCleanup() throws IOException, InterruptedException {
    final AssignmentManager am=TEST_UTIL.getHBaseCluster().getMaster().getAssignmentManager();
    final ServerManager sm=TEST_UTIL.getHBaseCluster().getMaster().getServerManager();
    final CatalogJanitor janitor=TEST_UTIL.getHBaseCluster().getMaster().getCatalogJanitor();
    Admin admin=TEST_UTIL.getAdmin();
    admin.enableCatalogJanitor(false);
    final TableName tableName=TableName.valueOf(name.getMethodName());
    Table t=TEST_UTIL.createTable(tableName,FAMILY);
    int rowCount=TEST_UTIL.loadTable(t,FAMILY,false);
    RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
    List<HRegionLocation> allRegionLocations=locator.getAllRegionLocations();
    HRegionLocation parent=allRegionLocations.get(0);
    List<HRegionLocation> daughters=splitRegion(parent.getRegionInfo());
    LOG.info("Parent region: " + parent);
    LOG.info("Daughter regions: " + daughters);
    assertNotNull("Should have found daughter regions for " + parent,daughters);
    assertTrue("Parent region should exist in RegionStates",am.getRegionStates().isRegionInRegionStates(parent.getRegionInfo()));
    assertTrue("Parent region should exist in ServerManager",sm.isRegionInServerManagerStates(parent.getRegionInfo()));
    Result r=MetaMockingUtil.getMetaTableRowResult(parent.getRegionInfo(),null,daughters.get(0).getRegionInfo(),daughters.get(1).getRegionInfo());
    janitor.cleanParent(parent.getRegionInfo(),r);
    assertFalse("Parent region should have been removed from RegionStates",am.getRegionStates().isRegionInRegionStates(parent.getRegionInfo()));
    assertFalse("Parent region should have been removed from ServerManager",sm.isRegionInServerManagerStates(parent.getRegionInfo()));
  }
  private List<HRegionLocation> splitRegion(  final RegionInfo r) throws IOException, InterruptedException {
    List<HRegionLocation> locations=new ArrayList<>();
    Admin admin=TEST_UTIL.getAdmin();
    Connection connection=TEST_UTIL.getConnection();
    admin.splitRegion(r.getEncodedNameAsBytes());
    admin.close();
    PairOfSameType<RegionInfo> regions=waitOnDaughters(r);
    if (regions != null) {
      try (RegionLocator rl=connection.getRegionLocator(r.getTable())){
        locations.add(rl.getRegionLocation(regions.getFirst().getEncodedNameAsBytes()));
        locations.add(rl.getRegionLocation(regions.getSecond().getEncodedNameAsBytes()));
      }
       return locations;
    }
    return locations;
  }
  private PairOfSameType<RegionInfo> waitOnDaughters(  final RegionInfo r) throws IOException {
    long start=System.currentTimeMillis();
    PairOfSameType<RegionInfo> pair=null;
    try (Connection conn=ConnectionFactory.createConnection(TEST_UTIL.getConfiguration());Table metaTable=conn.getTable(TableName.META_TABLE_NAME)){
      Result result=null;
      RegionInfo region=null;
      while ((System.currentTimeMillis() - start) < 60000) {
        result=metaTable.get(new Get(r.getRegionName()));
        if (result == null) {
          break;
        }
        region=MetaTableAccessor.getRegionInfo(result);
        if (region.isSplitParent()) {
          LOG.debug(region.toString() + " IS a parent!");
          pair=MetaTableAccessor.getDaughterRegions(result);
          break;
        }
        Threads.sleep(100);
      }
      if (pair.getFirst() == null || pair.getSecond() == null) {
        throw new IOException("Failed to get daughters, for parent region: " + r);
      }
      return pair;
    }
   }
}
