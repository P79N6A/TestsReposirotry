@Category({IOTests.class,SmallTests.class}) public class TestBlockCacheReporting {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestBlockCacheReporting.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestBlockCacheReporting.class);
  private Configuration conf;
  @Before public void setUp() throws Exception {
    CacheConfig.clearGlobalInstances();
    this.conf=HBaseConfiguration.create();
  }
  @After public void tearDown() throws Exception {
    CacheConfig.clearGlobalInstances();
  }
  private void addDataAndHits(  final BlockCache bc,  final int count){
    Cacheable dce=new DataCacheEntry();
    Cacheable ice=new IndexCacheEntry();
    for (int i=0; i < count; i++) {
      BlockCacheKey bckd=new BlockCacheKey("f",i);
      BlockCacheKey bcki=new BlockCacheKey("f",i + count);
      bc.getBlock(bckd,true,false,true);
      bc.cacheBlock(bckd,dce);
      bc.cacheBlock(bcki,ice);
      bc.getBlock(bckd,true,false,true);
      bc.getBlock(bcki,true,false,true);
    }
    assertEquals(2 * count,bc.getStats().getHitCount());
    BlockCacheKey bckd=new BlockCacheKey("f",0);
    BlockCacheKey bcki=new BlockCacheKey("f",0 + count);
    bc.evictBlock(bckd);
    bc.evictBlock(bcki);
    bc.getStats().getEvictedCount();
  }
  @Test public void testBucketCache() throws IOException {
    this.conf.set(HConstants.BUCKET_CACHE_IOENGINE_KEY,"offheap");
    this.conf.setInt(HConstants.BUCKET_CACHE_SIZE_KEY,100);
    CacheConfig.instantiateBlockCache(this.conf);
    CacheConfig cc=new CacheConfig(this.conf);
    assertTrue(cc.getBlockCache() instanceof CombinedBlockCache);
    logPerBlock(cc.getBlockCache());
    final int count=3;
    addDataAndHits(cc.getBlockCache(),count);
    LOG.info(Objects.toString(cc.getBlockCache().getStats()));
    BlockCacheUtil.CachedBlocksByFile cbsbf=logPerBlock(cc.getBlockCache());
    LOG.info(Objects.toString(cbsbf));
    logPerFile(cbsbf);
    bucketCacheReport(cc.getBlockCache());
    LOG.info(BlockCacheUtil.toJSON(cbsbf));
  }
  @Test public void testLruBlockCache() throws IOException {
    CacheConfig.instantiateBlockCache(this.conf);
    CacheConfig cc=new CacheConfig(this.conf);
    assertTrue(cc.isBlockCacheEnabled());
    assertTrue(CacheConfig.DEFAULT_IN_MEMORY == cc.isInMemory());
    assertTrue(cc.getBlockCache() instanceof LruBlockCache);
    logPerBlock(cc.getBlockCache());
    addDataAndHits(cc.getBlockCache(),3);
    BlockCache bc=cc.getBlockCache();
    LOG.info("count=" + bc.getBlockCount() + ", currentSize="+ bc.getCurrentSize()+ ", freeSize="+ bc.getFreeSize());
    LOG.info(Objects.toString(cc.getBlockCache().getStats()));
    BlockCacheUtil.CachedBlocksByFile cbsbf=logPerBlock(cc.getBlockCache());
    LOG.info(Objects.toString(cbsbf));
    logPerFile(cbsbf);
    bucketCacheReport(cc.getBlockCache());
    LOG.info(BlockCacheUtil.toJSON(cbsbf));
  }
  private void bucketCacheReport(  final BlockCache bc){
    LOG.info(bc.getClass().getSimpleName() + ": " + bc.getStats());
    BlockCache[] bcs=bc.getBlockCaches();
    if (bcs != null) {
      for (      BlockCache sbc : bc.getBlockCaches()) {
        LOG.info(bc.getClass().getSimpleName() + ": " + sbc.getStats());
      }
    }
  }
  private void logPerFile(  final BlockCacheUtil.CachedBlocksByFile cbsbf) throws IOException {
    for (    Map.Entry<String,NavigableSet<CachedBlock>> e : cbsbf.getCachedBlockStatsByFile().entrySet()) {
      int count=0;
      long size=0;
      int countData=0;
      long sizeData=0;
      for (      CachedBlock cb : e.getValue()) {
        count++;
        size+=cb.getSize();
        BlockType bt=cb.getBlockType();
        if (bt != null && bt.isData()) {
          countData++;
          sizeData+=cb.getSize();
        }
      }
      LOG.info("filename=" + e.getKey() + ", count="+ count+ ", countData="+ countData+ ", size="+ size+ ", sizeData="+ sizeData);
      LOG.info(BlockCacheUtil.toJSON(e.getKey(),e.getValue()));
    }
  }
  private BlockCacheUtil.CachedBlocksByFile logPerBlock(  final BlockCache bc) throws IOException {
    BlockCacheUtil.CachedBlocksByFile cbsbf=new BlockCacheUtil.CachedBlocksByFile();
    for (    CachedBlock cb : bc) {
      LOG.info(cb.toString());
      LOG.info(BlockCacheUtil.toJSON(bc));
      cbsbf.update(cb);
    }
    return cbsbf;
  }
}
