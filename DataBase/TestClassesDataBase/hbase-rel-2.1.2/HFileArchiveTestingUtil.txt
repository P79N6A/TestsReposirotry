/** 
 * Test helper for testing archiving of HFiles
 */
public class HFileArchiveTestingUtil {
  private static final Logger LOG=LoggerFactory.getLogger(HFileArchiveTestingUtil.class);
  private HFileArchiveTestingUtil(){
  }
  public static boolean compareArchiveToOriginal(  FileStatus[] previous,  FileStatus[] archived,  FileSystem fs,  boolean hasTimedBackup){
    List<List<String>> lists=getFileLists(previous,archived);
    List<String> original=lists.get(0);
    Collections.sort(original);
    List<String> currentFiles=lists.get(1);
    Collections.sort(currentFiles);
    List<String> backedup=lists.get(2);
    Collections.sort(backedup);
    if (!hasTimedBackup == (backedup.size() > 0)) {
      LOG.debug("backedup files doesn't match expected.");
      return false;
    }
    String msg=null;
    if (hasTimedBackup) {
      msg=assertArchiveEquality(original,backedup);
      if (msg != null) {
        LOG.debug(msg);
        return false;
      }
    }
    msg=assertArchiveEquality(original,currentFiles);
    if (msg != null) {
      LOG.debug(msg);
      return false;
    }
    return true;
  }
  /** 
 * Compare the archived files to the files in the original directory
 * @param expected original files that should have been archived
 * @param actual files that were archived
 * @param fs filessystem on which the archiving took place
 * @throws IOException
 */
  public static void assertArchiveEqualToOriginal(  FileStatus[] expected,  FileStatus[] actual,  FileSystem fs) throws IOException {
    assertArchiveEqualToOriginal(expected,actual,fs,false);
  }
  /** 
 * Compare the archived files to the files in the original directory
 * @param expected original files that should have been archived
 * @param actual files that were archived
 * @param fs {@link FileSystem} on which the archiving took place
 * @param hasTimedBackup <tt>true</tt> if we expect to find an archive backup directory with acopy of the files in the archive directory (and the original files).
 * @throws IOException
 */
  public static void assertArchiveEqualToOriginal(  FileStatus[] expected,  FileStatus[] actual,  FileSystem fs,  boolean hasTimedBackup) throws IOException {
    List<List<String>> lists=getFileLists(expected,actual);
    List<String> original=lists.get(0);
    Collections.sort(original);
    List<String> currentFiles=lists.get(1);
    Collections.sort(currentFiles);
    List<String> backedup=lists.get(2);
    Collections.sort(backedup);
    assertEquals("Didn't expect any backup files, but got: " + backedup,hasTimedBackup,backedup.size() > 0);
    String msg=null;
    if (hasTimedBackup) {
      assertArchiveEquality(original,backedup);
      assertNull(msg,msg);
    }
    msg=assertArchiveEquality(original,currentFiles);
    assertNull(msg,msg);
  }
  private static String assertArchiveEquality(  List<String> expected,  List<String> archived){
    String compare=compareFileLists(expected,archived);
    if (!(expected.size() == archived.size()))     return "Not the same number of current files\n" + compare;
    if (!expected.equals(archived))     return "Different backup files, but same amount\n" + compare;
    return null;
  }
  /** 
 * @return &lt;expected, gotten, backup&gt;, where each is sorted
 */
  private static List<List<String>> getFileLists(  FileStatus[] previous,  FileStatus[] archived){
    List<List<String>> files=new ArrayList<>(3);
    List<String> originalFileNames=convertToString(previous);
    files.add(originalFileNames);
    List<String> currentFiles=new ArrayList<>(previous.length);
    List<FileStatus> backedupFiles=new ArrayList<>(previous.length);
    for (    FileStatus f : archived) {
      String name=f.getPath().getName();
      if (name.contains(".")) {
        Path parent=f.getPath().getParent();
        String shortName=name.split("[.]")[0];
        Path modPath=new Path(parent,shortName);
        FileStatus file=new FileStatus(f.getLen(),f.isDirectory(),f.getReplication(),f.getBlockSize(),f.getModificationTime(),modPath);
        backedupFiles.add(file);
      }
 else {
        currentFiles.add(name);
      }
    }
    files.add(currentFiles);
    files.add(convertToString(backedupFiles));
    return files;
  }
  private static List<String> convertToString(  FileStatus[] files){
    return convertToString(Arrays.asList(files));
  }
  private static List<String> convertToString(  List<FileStatus> files){
    List<String> originalFileNames=new ArrayList<>(files.size());
    for (    FileStatus f : files) {
      originalFileNames.add(f.getPath().getName());
    }
    return originalFileNames;
  }
  private static String compareFileLists(  List<String> expected,  List<String> gotten){
    StringBuilder sb=new StringBuilder("Expected (" + expected.size() + "): \t\t Gotten ("+ gotten.size()+ "):\n");
    List<String> notFound=new ArrayList<>();
    for (    String s : expected) {
      if (gotten.contains(s))       sb.append(s + "\t\t" + s+ "\n");
 else       notFound.add(s);
    }
    sb.append("Not Found:\n");
    for (    String s : notFound) {
      sb.append(s + "\n");
    }
    sb.append("\nExtra:\n");
    for (    String s : gotten) {
      if (!expected.contains(s))       sb.append(s + "\n");
    }
    return sb.toString();
  }
  /** 
 * Helper method to get the archive directory for the specified region
 * @param conf {@link Configuration} to check for the name of the archive directory
 * @param region region that is being archived
 * @return {@link Path} to the archive directory for the given region
 */
  public static Path getRegionArchiveDir(  Configuration conf,  HRegion region) throws IOException {
    return HFileArchiveUtil.getRegionArchiveDir(FSUtils.getRootDir(conf),region.getTableDescriptor().getTableName(),region.getRegionInfo().getEncodedName());
  }
  /** 
 * Helper method to get the store archive directory for the specified region
 * @param conf {@link Configuration} to check for the name of the archive directory
 * @param region region that is being archived
 * @param store store that is archiving files
 * @return {@link Path} to the store archive directory for the given region
 */
  public static Path getStoreArchivePath(  Configuration conf,  HRegion region,  Store store) throws IOException {
    return HFileArchiveUtil.getStoreArchivePath(conf,region.getRegionInfo(),region.getRegionFileSystem().getTableDir(),store.getColumnFamilyDescriptor().getName());
  }
  public static Path getStoreArchivePath(  HBaseTestingUtility util,  String tableName,  byte[] storeName) throws IOException {
    byte[] table=Bytes.toBytes(tableName);
    List<HRegion> servingRegions=util.getHBaseCluster().getRegions(table);
    HRegion region=servingRegions.get(0);
    Store store=region.getStore(storeName);
    return HFileArchiveTestingUtil.getStoreArchivePath(util.getConfiguration(),region,store);
  }
}
