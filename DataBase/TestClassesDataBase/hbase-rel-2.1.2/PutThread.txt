protected class PutThread extends Thread {
  private volatile boolean done;
  private volatile int numPutsFinished=0;
  private Throwable error=null;
  private int numRows;
  private byte[][] families;
  private byte[][] qualifiers;
  private PutThread(  int numRows,  byte[][] families,  byte[][] qualifiers){
    super("PutThread");
    this.numRows=numRows;
    this.families=families;
    this.qualifiers=qualifiers;
  }
  /** 
 * Block calling thread until this instance of PutThread has put at least one row.
 */
  public void waitForFirstPut() throws InterruptedException {
    while (isAlive() && numPutsFinished == 0) {
      checkNoError();
      Thread.sleep(50);
    }
  }
  public void done(){
    done=true;
synchronized (this) {
      interrupt();
    }
  }
  public void checkNoError(){
    if (error != null) {
      assertNull(error);
    }
  }
  @Override public void run(){
    done=false;
    while (!done) {
      try {
        for (int r=0; r < numRows; r++) {
          byte[] row=Bytes.toBytes("row" + r);
          Put put=new Put(row);
          put.setDurability(Durability.SKIP_WAL);
          byte[] value=Bytes.toBytes(String.valueOf(numPutsFinished));
          for (          byte[] family : families) {
            for (            byte[] qualifier : qualifiers) {
              put.addColumn(family,qualifier,numPutsFinished,value);
            }
          }
          region.put(put);
          numPutsFinished++;
          if (numPutsFinished > 0 && numPutsFinished % 47 == 0) {
            System.out.println("put iteration = " + numPutsFinished);
            Delete delete=new Delete(row,(long)numPutsFinished - 30);
            region.delete(delete);
          }
          numPutsFinished++;
        }
      }
 catch (      InterruptedIOException e) {
        LOG.info("Interrupted",e);
      }
catch (      IOException e) {
        LOG.error("Error while putting records",e);
        error=e;
        break;
      }
    }
  }
}
