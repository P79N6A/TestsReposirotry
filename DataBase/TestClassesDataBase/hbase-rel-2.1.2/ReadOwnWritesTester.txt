private static class ReadOwnWritesTester extends Thread {
  static final int NUM_TRIES=1000;
  final byte[] row;
  final byte[] f=Bytes.toBytes("family");
  final byte[] q1=Bytes.toBytes("q1");
  final MultiVersionConcurrencyControl mvcc;
  final MemStore memstore;
  AtomicReference<Throwable> caughtException;
  public ReadOwnWritesTester(  int id,  MemStore memstore,  MultiVersionConcurrencyControl mvcc,  AtomicReference<Throwable> caughtException){
    this.mvcc=mvcc;
    this.memstore=memstore;
    this.caughtException=caughtException;
    row=Bytes.toBytes(id);
  }
  @Override public void run(){
    try {
      internalRun();
    }
 catch (    Throwable t) {
      caughtException.compareAndSet(null,t);
    }
  }
  private void internalRun() throws IOException {
    for (long i=0; i < NUM_TRIES && caughtException.get() == null; i++) {
      MultiVersionConcurrencyControl.WriteEntry w=mvcc.begin();
      byte[] v=Bytes.toBytes(i);
      KeyValue kv=new KeyValue(row,f,q1,i,v);
      kv.setSequenceId(w.getWriteNumber());
      memstore.add(kv,null);
      mvcc.completeAndWait(w);
      KeyValueScanner s=this.memstore.getScanners(mvcc.getReadPoint()).get(0);
      s.seek(kv);
      Cell ret=s.next();
      assertNotNull("Didnt find own write at all",ret);
      assertEquals("Didnt read own writes",kv.getTimestamp(),ret.getTimestamp());
    }
  }
}
