/** 
 * Test  {@link org.apache.hadoop.hbase.zookeeper.MetaTableLocator}
 */
@Category({MiscTests.class,MediumTests.class}) public class TestMetaTableLocator {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMetaTableLocator.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestMetaTableLocator.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final ServerName SN=ServerName.valueOf("example.org",1234,System.currentTimeMillis());
  private ZKWatcher watcher;
  private Abortable abortable;
  @BeforeClass public static void beforeClass() throws Exception {
    UTIL.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,3);
    UTIL.startMiniZKCluster();
  }
  @AfterClass public static void afterClass() throws IOException {
    UTIL.getZkCluster().shutdown();
  }
  @Before public void before() throws IOException {
    this.abortable=new Abortable(){
      @Override public void abort(      String why,      Throwable e){
        LOG.info(why,e);
      }
      @Override public boolean isAborted(){
        return false;
      }
    }
;
    this.watcher=new ZKWatcher(UTIL.getConfiguration(),this.getClass().getSimpleName(),this.abortable,true);
  }
  @After public void after(){
    try {
      new MetaTableLocator().deleteMetaLocation(this.watcher);
    }
 catch (    KeeperException e) {
      LOG.warn("Unable to delete hbase:meta location",e);
    }
    this.watcher.close();
  }
  /** 
 * Test normal operations
 */
  @Test public void testMetaLookup() throws IOException, InterruptedException, ServiceException, KeeperException {
    final ClientProtos.ClientService.BlockingInterface client=Mockito.mock(ClientProtos.ClientService.BlockingInterface.class);
    Mockito.when(client.get((RpcController)Mockito.any(),(GetRequest)Mockito.any())).thenReturn(GetResponse.newBuilder().build());
    final MetaTableLocator mtl=new MetaTableLocator();
    assertNull(mtl.getMetaRegionLocation(this.watcher));
    for (    RegionState.State state : RegionState.State.values()) {
      if (state.equals(RegionState.State.OPEN))       continue;
      MetaTableLocator.setMetaLocation(this.watcher,SN,state);
      assertNull(mtl.getMetaRegionLocation(this.watcher));
      assertEquals(state,MetaTableLocator.getMetaRegionState(this.watcher).getState());
    }
    MetaTableLocator.setMetaLocation(this.watcher,SN,RegionState.State.OPEN);
    assertEquals(SN,mtl.getMetaRegionLocation(this.watcher));
    assertEquals(RegionState.State.OPEN,MetaTableLocator.getMetaRegionState(this.watcher).getState());
    mtl.deleteMetaLocation(this.watcher);
    assertNull(MetaTableLocator.getMetaRegionState(this.watcher).getServerName());
    assertEquals(RegionState.State.OFFLINE,MetaTableLocator.getMetaRegionState(this.watcher).getState());
    assertNull(mtl.getMetaRegionLocation(this.watcher));
  }
  /** 
 * Test interruptable while blocking wait on meta.
 * @throws IOException
 * @throws ServiceException
 * @throws InterruptedException
 */
  @Test public void testInterruptWaitOnMeta() throws IOException, InterruptedException, ServiceException {
    final ClientProtos.ClientService.BlockingInterface client=Mockito.mock(ClientProtos.ClientService.BlockingInterface.class);
    Mockito.when(client.get((RpcController)Mockito.any(),(GetRequest)Mockito.any())).thenReturn(GetResponse.newBuilder().build());
    final MetaTableLocator mtl=new MetaTableLocator();
    ServerName meta=new MetaTableLocator().getMetaRegionLocation(this.watcher);
    assertNull(meta);
    Thread t=new Thread(){
      @Override public void run(){
        try {
          mtl.waitMetaRegionLocation(watcher);
        }
 catch (        InterruptedException e) {
          throw new RuntimeException("Interrupted",e);
        }
      }
    }
;
    t.start();
    while (!t.isAlive())     Threads.sleep(1);
    Threads.sleep(1);
    assertTrue(t.isAlive());
    mtl.stop();
    t.join();
  }
  private void testVerifyMetaRegionLocationWithException(  Exception ex) throws IOException, InterruptedException, KeeperException, ServiceException {
    final ClientProtos.ClientService.BlockingInterface implementation=Mockito.mock(ClientProtos.ClientService.BlockingInterface.class);
    ClusterConnection connection=mockConnection(null,implementation);
    Mockito.when(implementation.get((RpcController)Mockito.any(),(GetRequest)Mockito.any())).thenThrow(new ServiceException(ex));
    long timeout=UTIL.getConfiguration().getLong("hbase.catalog.verification.timeout",1000);
    MetaTableLocator.setMetaLocation(this.watcher,SN,RegionState.State.OPENING);
    assertFalse(new MetaTableLocator().verifyMetaRegionLocation(connection,watcher,timeout));
    MetaTableLocator.setMetaLocation(this.watcher,SN,RegionState.State.OPEN);
    assertFalse(new MetaTableLocator().verifyMetaRegionLocation(connection,watcher,timeout));
  }
  /** 
 * Test we survive a connection refused  {@link ConnectException}
 * @throws IOException
 * @throws InterruptedException
 * @throws KeeperException
 * @throws ServiceException
 */
  @Test public void testGetMetaServerConnectionFails() throws IOException, InterruptedException, KeeperException, ServiceException {
    testVerifyMetaRegionLocationWithException(new ConnectException("Connection refused"));
  }
  /** 
 * Test that verifyMetaRegionLocation properly handles getting a ServerNotRunningException. See HBASE-4470. Note this doesn't check the exact exception thrown in the HBASE-4470 as there it is thrown from getHConnection() and here it is thrown from get() -- but those are both called from the same function anyway, and this way is less invasive than throwing from getHConnection would be.
 * @throws IOException
 * @throws InterruptedException
 * @throws KeeperException
 * @throws ServiceException
 */
  @Test public void testVerifyMetaRegionServerNotRunning() throws IOException, InterruptedException, KeeperException, ServiceException {
    testVerifyMetaRegionLocationWithException(new ServerNotRunningYetException("mock"));
  }
  /** 
 * Test get of meta region fails properly if nothing to connect to.
 * @throws IOException
 * @throws InterruptedException
 * @throws KeeperException
 * @throws ServiceException
 */
  @Test public void testVerifyMetaRegionLocationFails() throws IOException, InterruptedException, KeeperException, ServiceException {
    ClusterConnection connection=Mockito.mock(ClusterConnection.class);
    ServiceException connectException=new ServiceException(new ConnectException("Connection refused"));
    final AdminProtos.AdminService.BlockingInterface implementation=Mockito.mock(AdminProtos.AdminService.BlockingInterface.class);
    Mockito.when(implementation.getRegionInfo((RpcController)Mockito.any(),(GetRegionInfoRequest)Mockito.any())).thenThrow(connectException);
    Mockito.when(connection.getAdmin(Mockito.any())).thenReturn(implementation);
    RpcControllerFactory controllerFactory=Mockito.mock(RpcControllerFactory.class);
    Mockito.when(controllerFactory.newController()).thenReturn(Mockito.mock(HBaseRpcController.class));
    Mockito.when(connection.getRpcControllerFactory()).thenReturn(controllerFactory);
    ServerName sn=ServerName.valueOf("example.com",1234,System.currentTimeMillis());
    MetaTableLocator.setMetaLocation(this.watcher,sn,RegionState.State.OPENING);
    assertFalse(new MetaTableLocator().verifyMetaRegionLocation(connection,watcher,100));
    MetaTableLocator.setMetaLocation(this.watcher,sn,RegionState.State.OPEN);
    assertFalse(new MetaTableLocator().verifyMetaRegionLocation(connection,watcher,100));
  }
  @Test(expected=NotAllMetaRegionsOnlineException.class) public void testTimeoutWaitForMeta() throws IOException, InterruptedException {
    new MetaTableLocator().waitMetaRegionLocation(watcher,100);
  }
  /** 
 * Test waiting on meat w/ no timeout specified.
 * @throws IOException
 * @throws InterruptedException
 * @throws KeeperException
 */
  @Test public void testNoTimeoutWaitForMeta() throws IOException, InterruptedException, KeeperException {
    final MetaTableLocator mtl=new MetaTableLocator();
    ServerName hsa=mtl.getMetaRegionLocation(watcher);
    assertNull(hsa);
    Thread t=new WaitOnMetaThread();
    startWaitAliveThenWaitItLives(t,1);
    MetaTableLocator.setMetaLocation(this.watcher,SN,RegionState.State.OPEN);
    hsa=SN;
    t.join();
    assertTrue(mtl.getMetaRegionLocation(watcher).equals(hsa));
  }
  /** 
 * @param admin An {@link AdminProtos.AdminService.BlockingInterface} instance; you'll likelywant to pass a mocked HRS; can be null.
 * @param client A mocked ClientProtocol instance, can be null
 * @return Mock up a connection that returns a {@link Configuration} when{@link org.apache.hadoop.hbase.client.ClusterConnection#getConfiguration()} is called, a 'location' when{@link org.apache.hadoop.hbase.client.RegionLocator#getRegionLocation(byte[],boolean)} is called,and that returns the passed  {@link AdminProtos.AdminService.BlockingInterface} instance when{@link org.apache.hadoop.hbase.client.ClusterConnection#getAdmin(ServerName)} is called, returns the passed{@link ClientProtos.ClientService.BlockingInterface} instance when{@link org.apache.hadoop.hbase.client.ClusterConnection#getClient(ServerName)} is called.
 * @throws IOException
 */
  private ClusterConnection mockConnection(  final AdminProtos.AdminService.BlockingInterface admin,  final ClientProtos.ClientService.BlockingInterface client) throws IOException {
    ClusterConnection connection=HConnectionTestingUtility.getMockedConnection(UTIL.getConfiguration());
    Mockito.doNothing().when(connection).close();
    final HRegionLocation anyLocation=new HRegionLocation(HRegionInfo.FIRST_META_REGIONINFO,SN);
    Mockito.when(connection.getRegionLocation((TableName)Mockito.any(),(byte[])Mockito.any(),Mockito.anyBoolean())).thenReturn(anyLocation);
    Mockito.when(connection.locateRegion((TableName)Mockito.any(),(byte[])Mockito.any())).thenReturn(anyLocation);
    if (admin != null) {
      Mockito.when(connection.getAdmin(Mockito.any())).thenReturn(admin);
    }
    if (client != null) {
      Mockito.when(connection.getClient(Mockito.any())).thenReturn(client);
    }
    return connection;
  }
  private void startWaitAliveThenWaitItLives(  final Thread t,  final int ms){
    t.start();
    while (!t.isAlive()) {
    }
    Threads.sleep(ms);
    assertTrue("Assert " + t.getName() + " still waiting",t.isAlive());
  }
  /** 
 * Wait on META.
 */
class WaitOnMetaThread extends Thread {
    WaitOnMetaThread(){
      super("WaitOnMeta");
    }
    @Override public void run(){
      try {
        doWaiting();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Failed wait",e);
      }
      LOG.info("Exiting " + getName());
    }
    void doWaiting() throws InterruptedException {
      try {
        while (new MetaTableLocator().waitMetaRegionLocation(watcher,10000) == null)         ;
      }
 catch (      NotAllMetaRegionsOnlineException e) {
      }
    }
  }
}
