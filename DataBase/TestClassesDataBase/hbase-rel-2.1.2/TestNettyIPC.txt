@RunWith(Parameterized.class) @Category({RPCTests.class,SmallTests.class}) public class TestNettyIPC extends AbstractTestIPC {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestNettyIPC.class);
  @Parameters(name="{index}: EventLoop={0}") public static Collection<Object[]> parameters(){
    List<Object[]> params=new ArrayList<>();
    params.add(new Object[]{"nio"});
    params.add(new Object[]{"perClientNio"});
    if (JVM.isLinux() && JVM.isAmd64()) {
      params.add(new Object[]{"epoll"});
    }
    return params;
  }
  @Parameter public String eventLoopType;
  private static NioEventLoopGroup NIO;
  private static EpollEventLoopGroup EPOLL;
  @BeforeClass public static void setUpBeforeClass(){
    NIO=new NioEventLoopGroup();
    if (JVM.isLinux() && JVM.isAmd64()) {
      EPOLL=new EpollEventLoopGroup();
    }
  }
  @AfterClass public static void tearDownAfterClass(){
    if (NIO != null) {
      NIO.shutdownGracefully();
    }
    if (EPOLL != null) {
      EPOLL.shutdownGracefully();
    }
  }
  private void setConf(  Configuration conf){
switch (eventLoopType) {
case "nio":
      NettyRpcClientConfigHelper.setEventLoopConfig(conf,NIO,NioSocketChannel.class);
    break;
case "epoll":
  NettyRpcClientConfigHelper.setEventLoopConfig(conf,EPOLL,EpollSocketChannel.class);
break;
case "perClientNio":
NettyRpcClientConfigHelper.createEventLoopPerClient(conf);
break;
default :
break;
}
}
@Override protected RpcServer createRpcServer(Server server,String name,List<RpcServer.BlockingServiceAndInterface> services,InetSocketAddress bindAddress,Configuration conf,RpcScheduler scheduler) throws IOException {
return new NettyRpcServer(server,name,services,bindAddress,conf,scheduler,true);
}
@Override protected NettyRpcClient createRpcClientNoCodec(Configuration conf){
setConf(conf);
return new NettyRpcClient(conf){
@Override Codec getCodec(){
return null;
}
}
;
}
@Override protected NettyRpcClient createRpcClient(Configuration conf){
setConf(conf);
return new NettyRpcClient(conf);
}
@Override protected NettyRpcClient createRpcClientRTEDuringConnectionSetup(Configuration conf){
setConf(conf);
return new NettyRpcClient(conf){
@Override boolean isTcpNoDelay(){
throw new RuntimeException("Injected fault");
}
}
;
}
private static class TestFailingRpcServer extends NettyRpcServer {
TestFailingRpcServer(Server server,String name,List<RpcServer.BlockingServiceAndInterface> services,InetSocketAddress bindAddress,Configuration conf,RpcScheduler scheduler) throws IOException {
super(server,name,services,bindAddress,conf,scheduler,true);
}
static final class FailingConnection extends NettyServerRpcConnection {
private FailingConnection(TestFailingRpcServer rpcServer,Channel channel){
super(rpcServer,channel);
}
@Override public void processRequest(ByteBuff buf) throws IOException, InterruptedException {
throw new DoNotRetryIOException("Failing for test");
}
}
@Override protected NettyRpcServerPreambleHandler createNettyRpcServerPreambleHandler(){
return new NettyRpcServerPreambleHandler(TestFailingRpcServer.this){
@Override protected NettyServerRpcConnection createNettyServerRpcConnection(Channel channel){
return new FailingConnection(TestFailingRpcServer.this,channel);
}
}
;
}
}
@Override protected RpcServer createTestFailingRpcServer(Server server,String name,List<RpcServer.BlockingServiceAndInterface> services,InetSocketAddress bindAddress,Configuration conf,RpcScheduler scheduler) throws IOException {
return new TestFailingRpcServer(server,name,services,bindAddress,conf,scheduler);
}
}
