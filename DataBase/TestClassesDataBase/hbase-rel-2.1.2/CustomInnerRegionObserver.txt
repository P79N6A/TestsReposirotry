public static class CustomInnerRegionObserver implements RegionCoprocessor, RegionObserver {
  static final AtomicLong sleepTime=new AtomicLong(0);
  static final AtomicBoolean slowDownNext=new AtomicBoolean(false);
  static final AtomicInteger countOfNext=new AtomicInteger(0);
  static final AtomicInteger countOfGets=new AtomicInteger(0);
  static final AtomicBoolean waitForGets=new AtomicBoolean(false);
  static final AtomicBoolean throwException=new AtomicBoolean(false);
  private static final AtomicReference<CountDownLatch> cdl=new AtomicReference<>(new CountDownLatch(0));
  @Override public Optional<RegionObserver> getRegionObserver(){
    return Optional.of(this);
  }
  @Override public boolean postScannerNext(  ObserverContext<RegionCoprocessorEnvironment> e,  InternalScanner s,  List<Result> results,  int limit,  boolean hasMore) throws IOException {
    slowdownCode(e,false);
    if (getLatch != null && getLatch.getCount() > 0) {
      try {
        getLatch.await();
      }
 catch (      InterruptedException e1) {
      }
    }
    return hasMore;
  }
  @Override public void postGetOp(  ObserverContext<RegionCoprocessorEnvironment> e,  Get get,  List<Cell> results) throws IOException {
    slowdownCode(e,true);
  }
  public static AtomicReference<CountDownLatch> getCdl(){
    return cdl;
  }
  private void slowdownCode(  final ObserverContext<RegionCoprocessorEnvironment> e,  boolean isGet){
    CountDownLatch latch=getCdl().get();
    try {
      System.out.println(latch.getCount() + " is the count " + isGet);
      if (latch.getCount() > 0) {
        if (isGet) {
          countOfGets.incrementAndGet();
        }
 else {
          countOfNext.incrementAndGet();
        }
        LOG.info("Waiting for the counterCountDownLatch");
        latch.await(2,TimeUnit.MINUTES);
        if (latch.getCount() > 0) {
          throw new RuntimeException("Can't wait more");
        }
      }
    }
 catch (    InterruptedException e1) {
      LOG.error(e1.toString(),e1);
    }
  }
}
