/** 
 * Tests that verifies that the log is forced to be rolled every "hbase.regionserver.logroll.period"
 */
public abstract class AbstractTestLogRollPeriod {
  private static final Logger LOG=LoggerFactory.getLogger(AbstractTestLogRollPeriod.class);
  protected final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private final static long LOG_ROLL_PERIOD=4000;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    TEST_UTIL.getConfiguration().setInt("hbase.regionsever.info.port",-1);
    TEST_UTIL.getConfiguration().setLong("hbase.regionserver.logroll.period",LOG_ROLL_PERIOD);
    TEST_UTIL.startMiniCluster();
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  /** 
 * Tests that the LogRoller perform the roll even if there are no edits
 */
  @Test public void testNoEdits() throws Exception {
    TableName tableName=TableName.valueOf("TestLogRollPeriodNoEdits");
    TEST_UTIL.createTable(tableName,"cf");
    try {
      Table table=TEST_UTIL.getConnection().getTable(tableName);
      try {
        HRegionServer server=TEST_UTIL.getRSForFirstRegionInTable(tableName);
        WAL log=server.getWAL(null);
        checkMinLogRolls(log,5);
      }
  finally {
        table.close();
      }
    }
  finally {
      TEST_UTIL.deleteTable(tableName);
    }
  }
  /** 
 * Tests that the LogRoller perform the roll with some data in the log
 */
  @Test public void testWithEdits() throws Exception {
    final TableName tableName=TableName.valueOf("TestLogRollPeriodWithEdits");
    final String family="cf";
    TEST_UTIL.createTable(tableName,family);
    try {
      HRegionServer server=TEST_UTIL.getRSForFirstRegionInTable(tableName);
      WAL log=server.getWAL(null);
      final Table table=TEST_UTIL.getConnection().getTable(tableName);
      Thread writerThread=new Thread("writer"){
        @Override public void run(){
          try {
            long row=0;
            while (!interrupted()) {
              Put p=new Put(Bytes.toBytes(String.format("row%d",row)));
              p.addColumn(Bytes.toBytes(family),Bytes.toBytes("col"),Bytes.toBytes(row));
              table.put(p);
              row++;
              Thread.sleep(LOG_ROLL_PERIOD / 16);
            }
          }
 catch (          Exception e) {
            LOG.warn(e.toString(),e);
          }
        }
      }
;
      try {
        writerThread.start();
        checkMinLogRolls(log,5);
      }
  finally {
        writerThread.interrupt();
        writerThread.join();
        table.close();
      }
    }
  finally {
      TEST_UTIL.deleteTable(tableName);
    }
  }
  private void checkMinLogRolls(  final WAL log,  final int minRolls) throws Exception {
    final List<Path> paths=new ArrayList<>();
    log.registerWALActionsListener(new WALActionsListener(){
      @Override public void postLogRoll(      Path oldFile,      Path newFile){
        LOG.debug("postLogRoll: oldFile=" + oldFile + " newFile="+ newFile);
        paths.add(newFile);
      }
    }
);
    long wtime=System.currentTimeMillis();
    Thread.sleep((minRolls + 1) * LOG_ROLL_PERIOD);
    final int NUM_RETRIES=1 + 8 * (minRolls - paths.size());
    for (int retry=0; paths.size() < minRolls && retry < NUM_RETRIES; ++retry) {
      Thread.sleep(LOG_ROLL_PERIOD / 4);
    }
    wtime=System.currentTimeMillis() - wtime;
    LOG.info(String.format("got %d rolls after %dms (%dms each) - expected at least %d rolls",paths.size(),wtime,wtime / paths.size(),minRolls));
    assertFalse(paths.size() < minRolls);
  }
}
