@RunWith(Parameterized.class) @Category({ReplicationTests.class,LargeTests.class}) public class TestReplicationSmallTests extends TestReplicationBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestReplicationSmallTests.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestReplicationSmallTests.class);
  private static final String PEER_ID="2";
  @Parameter public boolean serialPeer;
  @Override protected boolean isSerialPeer(){
    return serialPeer;
  }
  @Parameters(name="{index}: serialPeer={0}") public static List<Boolean> parameters(){
    return ImmutableList.of(true,false);
  }
  @Before public void setUp() throws Exception {
    cleanUp();
  }
  /** 
 * Verify that version and column delete marker types are replicated correctly.
 */
  @Test public void testDeleteTypes() throws Exception {
    LOG.info("testDeleteTypes");
    final byte[] v1=Bytes.toBytes("v1");
    final byte[] v2=Bytes.toBytes("v2");
    final byte[] v3=Bytes.toBytes("v3");
    htable1=utility1.getConnection().getTable(tableName);
    long t=EnvironmentEdgeManager.currentTime();
    Put put=new Put(row);
    put.addColumn(famName,row,t,v1);
    htable1.put(put);
    put=new Put(row);
    put.addColumn(famName,row,t + 1,v2);
    htable1.put(put);
    put=new Put(row);
    put.addColumn(famName,row,t + 2,v3);
    htable1.put(put);
    Get get=new Get(row);
    get.readAllVersions();
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        fail("Waited too much time for put replication");
      }
      Result res=htable2.get(get);
      if (res.size() < 3) {
        LOG.info("Rows not available");
        Thread.sleep(SLEEP_TIME);
      }
 else {
        assertArrayEquals(CellUtil.cloneValue(res.rawCells()[0]),v3);
        assertArrayEquals(CellUtil.cloneValue(res.rawCells()[1]),v2);
        assertArrayEquals(CellUtil.cloneValue(res.rawCells()[2]),v1);
        break;
      }
    }
    Delete d=new Delete(row);
    d.addColumn(famName,row,t);
    htable1.delete(d);
    get=new Get(row);
    get.readAllVersions();
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        fail("Waited too much time for put replication");
      }
      Result res=htable2.get(get);
      if (res.size() > 2) {
        LOG.info("Version not deleted");
        Thread.sleep(SLEEP_TIME);
      }
 else {
        assertArrayEquals(CellUtil.cloneValue(res.rawCells()[0]),v3);
        assertArrayEquals(CellUtil.cloneValue(res.rawCells()[1]),v2);
        break;
      }
    }
    d=new Delete(row);
    d.addColumns(famName,row,t + 2);
    htable1.delete(d);
    get=new Get(row);
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        fail("Waited too much time for del replication");
      }
      Result res=htable2.get(get);
      if (res.size() >= 1) {
        LOG.info("Rows not deleted");
        Thread.sleep(SLEEP_TIME);
      }
 else {
        break;
      }
    }
  }
  /** 
 * Add a row, check it's replicated, delete it, check's gone
 */
  @Test public void testSimplePutDelete() throws Exception {
    LOG.info("testSimplePutDelete");
    runSimplePutDeleteTest();
  }
  /** 
 * Try a small batch upload using the write buffer, check it's replicated
 */
  @Test public void testSmallBatch() throws Exception {
    LOG.info("testSmallBatch");
    runSmallBatchTest();
  }
  /** 
 * Test disable/enable replication, trying to insert, make sure nothing's replicated, enable it, the insert should be replicated
 */
  @Test public void testDisableEnable() throws Exception {
    hbaseAdmin.disableReplicationPeer(PEER_ID);
    byte[] rowkey=Bytes.toBytes("disable enable");
    Put put=new Put(rowkey);
    put.addColumn(famName,row,row);
    htable1.put(put);
    Get get=new Get(rowkey);
    for (int i=0; i < NB_RETRIES; i++) {
      Result res=htable2.get(get);
      if (res.size() >= 1) {
        fail("Replication wasn't disabled");
      }
 else {
        LOG.info("Row not replicated, let's wait a bit more...");
        Thread.sleep(SLEEP_TIME);
      }
    }
    hbaseAdmin.enableReplicationPeer(PEER_ID);
    for (int i=0; i < NB_RETRIES; i++) {
      Result res=htable2.get(get);
      if (res.isEmpty()) {
        LOG.info("Row not available");
        Thread.sleep(SLEEP_TIME);
      }
 else {
        assertArrayEquals(row,res.value());
        return;
      }
    }
    fail("Waited too much time for put replication");
  }
  /** 
 * Integration test for TestReplicationAdmin, removes and re-add a peer cluster
 */
  @Test public void testAddAndRemoveClusters() throws Exception {
    LOG.info("testAddAndRemoveClusters");
    hbaseAdmin.removeReplicationPeer(PEER_ID);
    Thread.sleep(SLEEP_TIME);
    byte[] rowKey=Bytes.toBytes("Won't be replicated");
    Put put=new Put(rowKey);
    put.addColumn(famName,row,row);
    htable1.put(put);
    Get get=new Get(rowKey);
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        break;
      }
      Result res=htable2.get(get);
      if (res.size() >= 1) {
        fail("Not supposed to be replicated");
      }
 else {
        LOG.info("Row not replicated, let's wait a bit more...");
        Thread.sleep(SLEEP_TIME);
      }
    }
    ReplicationPeerConfig rpc=ReplicationPeerConfig.newBuilder().setClusterKey(utility2.getClusterKey()).build();
    hbaseAdmin.addReplicationPeer(PEER_ID,rpc);
    Thread.sleep(SLEEP_TIME);
    rowKey=Bytes.toBytes("do rep");
    put=new Put(rowKey);
    put.addColumn(famName,row,row);
    LOG.info("Adding new row");
    htable1.put(put);
    get=new Get(rowKey);
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        fail("Waited too much time for put replication");
      }
      Result res=htable2.get(get);
      if (res.isEmpty()) {
        LOG.info("Row not available");
        Thread.sleep(SLEEP_TIME * i);
      }
 else {
        assertArrayEquals(row,res.value());
        break;
      }
    }
  }
  /** 
 * Do a more intense version testSmallBatch, one that will trigger wal rolling and other non-trivial code paths
 */
  @Test public void testLoading() throws Exception {
    LOG.info("Writing out rows to table1 in testLoading");
    List<Put> puts=new ArrayList<>(NB_ROWS_IN_BIG_BATCH);
    for (int i=0; i < NB_ROWS_IN_BIG_BATCH; i++) {
      Put put=new Put(Bytes.toBytes(i));
      put.addColumn(famName,row,row);
      puts.add(put);
    }
    htable1.put(puts);
    Scan scan=new Scan();
    ResultScanner scanner=htable1.getScanner(scan);
    Result[] res=scanner.next(NB_ROWS_IN_BIG_BATCH);
    scanner.close();
    assertEquals(NB_ROWS_IN_BIG_BATCH,res.length);
    LOG.info("Looking in table2 for replicated rows in testLoading");
    long start=System.currentTimeMillis();
    final long retries=NB_RETRIES * 10;
    for (int i=0; i < retries; i++) {
      scan=new Scan();
      scanner=htable2.getScanner(scan);
      res=scanner.next(NB_ROWS_IN_BIG_BATCH);
      scanner.close();
      if (res.length != NB_ROWS_IN_BIG_BATCH) {
        if (i == retries - 1) {
          int lastRow=-1;
          for (          Result result : res) {
            int currentRow=Bytes.toInt(result.getRow());
            for (int row=lastRow + 1; row < currentRow; row++) {
              LOG.error("Row missing: " + row);
            }
            lastRow=currentRow;
          }
          LOG.error("Last row: " + lastRow);
          fail("Waited too much time for normal batch replication, " + res.length + " instead of "+ NB_ROWS_IN_BIG_BATCH+ "; waited="+ (System.currentTimeMillis() - start)+ "ms");
        }
 else {
          LOG.info("Only got " + res.length + " rows... retrying");
          Thread.sleep(SLEEP_TIME);
        }
      }
 else {
        break;
      }
    }
  }
  /** 
 * Test for HBASE-8663 <p> Create two new Tables with colfamilies enabled for replication then run ReplicationAdmin.listReplicated(). Finally verify the table:colfamilies. Note: TestReplicationAdmin is a better place for this testing but it would need mocks.
 */
  @Test public void testVerifyListReplicatedTable() throws Exception {
    LOG.info("testVerifyListReplicatedTable");
    final String tName="VerifyListReplicated_";
    final String colFam="cf1";
    final int numOfTables=3;
    Admin hadmin=utility1.getAdmin();
    for (int i=0; i < numOfTables; i++) {
      hadmin.createTable(TableDescriptorBuilder.newBuilder(TableName.valueOf(tName + i)).setColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(colFam)).setScope(HConstants.REPLICATION_SCOPE_GLOBAL).build()).build());
    }
    List<TableCFs> replicationColFams=hbaseAdmin.listReplicatedTableCFs();
    int[] match=new int[numOfTables];
    for (int i=0; i < replicationColFams.size(); i++) {
      TableCFs replicationEntry=replicationColFams.get(i);
      String tn=replicationEntry.getTable().getNameAsString();
      if (tn.startsWith(tName) && replicationEntry.getColumnFamilyMap().containsKey(colFam)) {
        int m=Integer.parseInt(tn.substring(tn.length() - 1));
        match[m]++;
      }
    }
    for (int i=0; i < match.length; i++) {
      assertTrue("listReplicated() does not match table " + i,(match[i] == 1));
    }
    for (int i=0; i < numOfTables; i++) {
      TableName tableName=TableName.valueOf(tName + i);
      hadmin.disableTable(tableName);
      hadmin.deleteTable(tableName);
    }
    hadmin.close();
  }
  /** 
 * Test for HBase-15259 WALEdits under replay will also be replicated
 */
  @Test public void testReplicationInReplay() throws Exception {
    final TableName tableName=htable1.getName();
    HRegion region=utility1.getMiniHBaseCluster().getRegions(tableName).get(0);
    RegionInfo hri=region.getRegionInfo();
    NavigableMap<byte[],Integer> scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
    for (    byte[] fam : htable1.getDescriptor().getColumnFamilyNames()) {
      scopes.put(fam,1);
    }
    final MultiVersionConcurrencyControl mvcc=new MultiVersionConcurrencyControl();
    int index=utility1.getMiniHBaseCluster().getServerWith(hri.getRegionName());
    WAL wal=utility1.getMiniHBaseCluster().getRegionServer(index).getWAL(region.getRegionInfo());
    final byte[] rowName=Bytes.toBytes("testReplicationInReplay");
    final byte[] qualifier=Bytes.toBytes("q");
    final byte[] value=Bytes.toBytes("v");
    WALEdit edit=new WALEdit(true);
    long now=EnvironmentEdgeManager.currentTime();
    edit.add(new KeyValue(rowName,famName,qualifier,now,value));
    WALKeyImpl walKey=new WALKeyImpl(hri.getEncodedNameAsBytes(),tableName,now,mvcc,scopes);
    wal.append(hri,walKey,edit,true);
    wal.sync();
    Get get=new Get(rowName);
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        break;
      }
      Result res=htable2.get(get);
      if (res.size() >= 1) {
        fail("Not supposed to be replicated for " + Bytes.toString(res.getRow()));
      }
 else {
        LOG.info("Row not replicated, let's wait a bit more...");
        Thread.sleep(SLEEP_TIME);
      }
    }
  }
}
