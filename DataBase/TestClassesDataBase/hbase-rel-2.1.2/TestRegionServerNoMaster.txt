/** 
 * Tests on the region server, without the master.
 */
@Category({RegionServerTests.class,MediumTests.class}) public class TestRegionServerNoMaster {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRegionServerNoMaster.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRegionServerNoMaster.class);
  private static final int NB_SERVERS=1;
  private static Table table;
  private static final byte[] row=Bytes.toBytes("ee");
  private static HRegionInfo hri;
  private static byte[] regionName;
  private static final HBaseTestingUtility HTU=new HBaseTestingUtility();
  @BeforeClass public static void before() throws Exception {
    HTU.startMiniCluster(NB_SERVERS);
    final TableName tableName=TableName.valueOf(TestRegionServerNoMaster.class.getSimpleName());
    table=HTU.createTable(tableName,HConstants.CATALOG_FAMILY);
    Put p=new Put(row);
    p.addColumn(HConstants.CATALOG_FAMILY,row,row);
    table.put(p);
    try (RegionLocator locator=HTU.getConnection().getRegionLocator(tableName)){
      hri=locator.getRegionLocation(row,false).getRegionInfo();
    }
     regionName=hri.getRegionName();
    stopMasterAndAssignMeta(HTU);
  }
  public static void stopMasterAndAssignMeta(  HBaseTestingUtility HTU) throws IOException, InterruptedException {
    HMaster master=HTU.getHBaseCluster().getMaster();
    Thread masterThread=HTU.getHBaseCluster().getMasterThread();
    ServerName masterAddr=master.getServerName();
    master.stopMaster();
    LOG.info("Waiting until master thread exits");
    while (masterThread != null && masterThread.isAlive()) {
      Threads.sleep(100);
    }
    HRegionServer.TEST_SKIP_REPORTING_TRANSITION=true;
    HRegionServer hrs=HTU.getHBaseCluster().getLiveRegionServerThreads().get(0).getRegionServer();
    ZKWatcher zkw=hrs.getZooKeeper();
    MetaTableLocator mtl=new MetaTableLocator();
    ServerName sn=mtl.getMetaRegionLocation(zkw);
    if (sn != null && !masterAddr.equals(sn)) {
      return;
    }
    ProtobufUtil.openRegion(null,hrs.getRSRpcServices(),hrs.getServerName(),HRegionInfo.FIRST_META_REGIONINFO);
    while (true) {
      sn=mtl.getMetaRegionLocation(zkw);
      if (sn != null && sn.equals(hrs.getServerName()) && hrs.onlineRegions.containsKey(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName())) {
        break;
      }
      Thread.sleep(100);
    }
  }
  /** 
 * Flush the given region in the mini cluster. Since no master, we cannot use HBaseAdmin.flush() 
 */
  public static void flushRegion(  HBaseTestingUtility HTU,  HRegionInfo regionInfo) throws IOException {
    for (    RegionServerThread rst : HTU.getMiniHBaseCluster().getRegionServerThreads()) {
      HRegion region=rst.getRegionServer().getRegionByEncodedName(regionInfo.getEncodedName());
      if (region != null) {
        region.flush(true);
        return;
      }
    }
    throw new IOException("Region to flush cannot be found");
  }
  @AfterClass public static void afterClass() throws Exception {
    HRegionServer.TEST_SKIP_REPORTING_TRANSITION=false;
    table.close();
    HTU.shutdownMiniCluster();
  }
  private static HRegionServer getRS(){
    return HTU.getHBaseCluster().getLiveRegionServerThreads().get(0).getRegionServer();
  }
  public static void openRegion(  HBaseTestingUtility HTU,  HRegionServer rs,  HRegionInfo hri) throws Exception {
    AdminProtos.OpenRegionRequest orr=RequestConverter.buildOpenRegionRequest(rs.getServerName(),hri,null);
    AdminProtos.OpenRegionResponse responseOpen=rs.rpcServices.openRegion(null,orr);
    Assert.assertTrue(responseOpen.getOpeningStateCount() == 1);
    Assert.assertTrue(responseOpen.getOpeningState(0).equals(AdminProtos.OpenRegionResponse.RegionOpeningState.OPENED));
    checkRegionIsOpened(HTU,rs,hri);
  }
  public static void checkRegionIsOpened(  HBaseTestingUtility HTU,  HRegionServer rs,  HRegionInfo hri) throws Exception {
    while (!rs.getRegionsInTransitionInRS().isEmpty()) {
      Thread.sleep(1);
    }
    Assert.assertTrue(rs.getRegion(hri.getRegionName()).isAvailable());
  }
  public static void closeRegion(  HBaseTestingUtility HTU,  HRegionServer rs,  HRegionInfo hri) throws Exception {
    AdminProtos.CloseRegionRequest crr=ProtobufUtil.buildCloseRegionRequest(rs.getServerName(),hri.getRegionName());
    AdminProtos.CloseRegionResponse responseClose=rs.rpcServices.closeRegion(null,crr);
    Assert.assertTrue(responseClose.getClosed());
    checkRegionIsClosed(HTU,rs,hri);
  }
  public static void checkRegionIsClosed(  HBaseTestingUtility HTU,  HRegionServer rs,  HRegionInfo hri) throws Exception {
    while (!rs.getRegionsInTransitionInRS().isEmpty()) {
      Thread.sleep(1);
    }
    try {
      Assert.assertFalse(rs.getRegion(hri.getRegionName()).isAvailable());
    }
 catch (    NotServingRegionException expected) {
    }
  }
  /** 
 * Close the region without using ZK
 */
  private void closeRegionNoZK() throws Exception {
    AdminProtos.CloseRegionRequest crr=ProtobufUtil.buildCloseRegionRequest(getRS().getServerName(),regionName);
    AdminProtos.CloseRegionResponse responseClose=getRS().rpcServices.closeRegion(null,crr);
    Assert.assertTrue(responseClose.getClosed());
    checkRegionIsClosed(HTU,getRS(),hri);
  }
  @Test public void testCloseByRegionServer() throws Exception {
    closeRegionNoZK();
    openRegion(HTU,getRS(),hri);
  }
  @Test public void testMultipleCloseFromMaster() throws Exception {
    for (int i=0; i < 10; i++) {
      AdminProtos.CloseRegionRequest crr=ProtobufUtil.buildCloseRegionRequest(getRS().getServerName(),regionName,null);
      try {
        AdminProtos.CloseRegionResponse responseClose=getRS().rpcServices.closeRegion(null,crr);
        Assert.assertTrue("request " + i + " failed",responseClose.getClosed() || responseClose.hasClosed());
      }
 catch (      org.apache.hbase.thirdparty.com.google.protobuf.ServiceException se) {
        Assert.assertTrue("The next queries may throw an exception.",i > 0);
      }
    }
    checkRegionIsClosed(HTU,getRS(),hri);
    openRegion(HTU,getRS(),hri);
  }
  /** 
 * Test that if we do a close while opening it stops the opening.
 */
  @Test public void testCancelOpeningWithoutZK() throws Exception {
    closeRegionNoZK();
    checkRegionIsClosed(HTU,getRS(),hri);
    getRS().getRegionsInTransitionInRS().put(hri.getEncodedNameAsBytes(),Boolean.TRUE);
    AdminProtos.CloseRegionRequest crr=ProtobufUtil.buildCloseRegionRequest(getRS().getServerName(),regionName);
    try {
      getRS().rpcServices.closeRegion(null,crr);
      Assert.assertTrue(false);
    }
 catch (    org.apache.hbase.thirdparty.com.google.protobuf.ServiceException expected) {
    }
    Assert.assertEquals(Boolean.FALSE,getRS().getRegionsInTransitionInRS().get(hri.getEncodedNameAsBytes()));
    TableDescriptor htd=getRS().tableDescriptors.get(hri.getTable());
    getRS().executorService.submit(new OpenRegionHandler(getRS(),getRS(),hri,htd,-1));
    checkRegionIsClosed(HTU,getRS(),hri);
    openRegion(HTU,getRS(),hri);
  }
  /** 
 * Tests an on-the-fly RPC that was scheduled for the earlier RS on the same port for openRegion. The region server should reject this RPC. (HBASE-9721)
 */
  @Test public void testOpenCloseRegionRPCIntendedForPreviousServer() throws Exception {
    Assert.assertTrue(getRS().getRegion(regionName).isAvailable());
    ServerName sn=getRS().getServerName();
    ServerName earlierServerName=ServerName.valueOf(sn.getHostname(),sn.getPort(),1);
    try {
      CloseRegionRequest request=ProtobufUtil.buildCloseRegionRequest(earlierServerName,regionName);
      getRS().getRSRpcServices().closeRegion(null,request);
      Assert.fail("The closeRegion should have been rejected");
    }
 catch (    org.apache.hbase.thirdparty.com.google.protobuf.ServiceException se) {
      Assert.assertTrue(se.getCause() instanceof IOException);
      Assert.assertTrue(se.getCause().getMessage().contains("This RPC was intended for a different server"));
    }
    closeRegionNoZK();
    try {
      AdminProtos.OpenRegionRequest orr=RequestConverter.buildOpenRegionRequest(earlierServerName,hri,null);
      getRS().getRSRpcServices().openRegion(null,orr);
      Assert.fail("The openRegion should have been rejected");
    }
 catch (    org.apache.hbase.thirdparty.com.google.protobuf.ServiceException se) {
      Assert.assertTrue(se.getCause() instanceof IOException);
      Assert.assertTrue(se.getCause().getMessage().contains("This RPC was intended for a different server"));
    }
 finally {
      openRegion(HTU,getRS(),hri);
    }
  }
}
