/** 
 * Testing the sizing that HeapSize offers and compares to the size given by ClassSize.
 */
@Category({IOTests.class,SmallTests.class}) public class TestHeapSize {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestHeapSize.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestHeapSize.class);
  @BeforeClass public static void beforeClass() throws Exception {
    RuntimeMXBean b=ManagementFactory.getRuntimeMXBean();
    LOG.info("name=" + b.getName());
    LOG.info("specname=" + b.getSpecName());
    LOG.info("specvendor=" + b.getSpecVendor());
    LOG.info("vmname=" + b.getVmName());
    LOG.info("vmversion=" + b.getVmVersion());
    LOG.info("vmvendor=" + b.getVmVendor());
    Map<String,String> p=b.getSystemProperties();
    LOG.info("properties=" + p);
  }
  /** 
 * Test our hard-coded sizing of native java objects
 */
  @Test public void testNativeSizes() throws IOException {
    Class<?> cl;
    long expected;
    long actual;
    cl=ArrayList.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.ARRAYLIST;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=ByteBuffer.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.BYTE_BUFFER;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=Integer.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.INTEGER;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=Object.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.align(ClassSize.OBJECT);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=TreeMap.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.TREEMAP;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=String.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.STRING;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=ConcurrentHashMap.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.CONCURRENT_HASHMAP;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=ConcurrentSkipListMap.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.CONCURRENT_SKIPLISTMAP;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=CellArrayMap.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.CELL_ARRAY_MAP;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=ReentrantReadWriteLock.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.REENTRANT_LOCK;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=AtomicLong.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.ATOMIC_LONG;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=AtomicInteger.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.ATOMIC_INTEGER;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=AtomicBoolean.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.ATOMIC_BOOLEAN;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=CopyOnWriteArraySet.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.COPYONWRITE_ARRAYSET;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=CopyOnWriteArrayList.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.COPYONWRITE_ARRAYLIST;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=SyncTimeRangeTracker.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.SYNC_TIMERANGE_TRACKER;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=NonSyncTimeRangeTracker.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.NON_SYNC_TIMERANGE_TRACKER;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=CellSet.class;
    expected=ClassSize.estimateBase(cl,false);
    actual=ClassSize.CELL_SET;
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
  }
  /** 
 * Testing the classes that implements HeapSize and are a part of 0.20. Some are not tested here for example BlockIndex which is tested in TestHFile since it is a non public class
 * @throws IOException
 */
  @Test public void testSizes() throws IOException {
    Class<?> cl;
    long expected;
    long actual;
    cl=KeyValue.class;
    expected=ClassSize.estimateBase(cl,false);
    KeyValue kv=new KeyValue();
    actual=kv.heapSize();
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=LruBlockCache.class;
    actual=LruBlockCache.CACHE_FIXED_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=LruCachedBlock.class;
    actual=LruCachedBlock.PER_BLOCK_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    expected+=ClassSize.estimateBase(String.class,false);
    expected+=ClassSize.estimateBase(ByteBuffer.class,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      ClassSize.estimateBase(String.class,true);
      ClassSize.estimateBase(ByteBuffer.class,true);
      assertEquals(expected,actual);
    }
    cl=DefaultMemStore.class;
    actual=DefaultMemStore.FIXED_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    actual=DefaultMemStore.DEEP_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=CompactingMemStore.class;
    actual=CompactingMemStore.DEEP_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    expected+=ClassSize.estimateBase(AtomicBoolean.class,false);
    expected+=ClassSize.estimateBase(AtomicBoolean.class,false);
    expected+=ClassSize.estimateBase(CompactionPipeline.class,false);
    expected+=ClassSize.estimateBase(LinkedList.class,false);
    expected+=ClassSize.estimateBase(LinkedList.class,false);
    expected+=ClassSize.estimateBase(MemStoreCompactor.class,false);
    expected+=ClassSize.estimateBase(AtomicBoolean.class,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      ClassSize.estimateBase(AtomicBoolean.class,true);
      ClassSize.estimateBase(AtomicBoolean.class,true);
      ClassSize.estimateBase(CompactionPipeline.class,true);
      ClassSize.estimateBase(LinkedList.class,true);
      ClassSize.estimateBase(LinkedList.class,true);
      ClassSize.estimateBase(MemStoreCompactor.class,true);
      ClassSize.estimateBase(AtomicBoolean.class,true);
      assertEquals(expected,actual);
    }
    cl=Segment.class;
    actual=Segment.DEEP_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    expected+=2 * ClassSize.estimateBase(AtomicLong.class,false);
    expected+=ClassSize.estimateBase(AtomicReference.class,false);
    expected+=ClassSize.estimateBase(CellSet.class,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicReference.class,true);
      ClassSize.estimateBase(CellSet.class,true);
      assertEquals(expected,actual);
    }
    cl=MutableSegment.class;
    actual=MutableSegment.DEEP_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    expected+=2 * ClassSize.estimateBase(AtomicLong.class,false);
    expected+=ClassSize.estimateBase(AtomicReference.class,false);
    expected+=ClassSize.estimateBase(CellSet.class,false);
    expected+=ClassSize.estimateBase(SyncTimeRangeTracker.class,false);
    expected+=ClassSize.estimateBase(ConcurrentSkipListMap.class,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicReference.class,true);
      ClassSize.estimateBase(CellSet.class,true);
      ClassSize.estimateBase(SyncTimeRangeTracker.class,true);
      ClassSize.estimateBase(ConcurrentSkipListMap.class,true);
      assertEquals(expected,actual);
    }
    cl=ImmutableSegment.class;
    actual=ImmutableSegment.DEEP_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    expected+=2 * ClassSize.estimateBase(AtomicLong.class,false);
    expected+=ClassSize.estimateBase(AtomicReference.class,false);
    expected+=ClassSize.estimateBase(CellSet.class,false);
    expected+=ClassSize.estimateBase(NonSyncTimeRangeTracker.class,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicReference.class,true);
      ClassSize.estimateBase(CellSet.class,true);
      ClassSize.estimateBase(NonSyncTimeRangeTracker.class,true);
      assertEquals(expected,actual);
    }
    cl=CSLMImmutableSegment.class;
    actual=CSLMImmutableSegment.DEEP_OVERHEAD_CSLM;
    expected=ClassSize.estimateBase(cl,false);
    expected+=2 * ClassSize.estimateBase(AtomicLong.class,false);
    expected+=ClassSize.estimateBase(AtomicReference.class,false);
    expected+=ClassSize.estimateBase(CellSet.class,false);
    expected+=ClassSize.estimateBase(NonSyncTimeRangeTracker.class,false);
    expected+=ClassSize.estimateBase(ConcurrentSkipListMap.class,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicReference.class,true);
      ClassSize.estimateBase(CellSet.class,true);
      ClassSize.estimateBase(NonSyncTimeRangeTracker.class,true);
      ClassSize.estimateBase(ConcurrentSkipListMap.class,true);
      assertEquals(expected,actual);
    }
    cl=CellArrayImmutableSegment.class;
    actual=CellArrayImmutableSegment.DEEP_OVERHEAD_CAM;
    expected=ClassSize.estimateBase(cl,false);
    expected+=2 * ClassSize.estimateBase(AtomicLong.class,false);
    expected+=ClassSize.estimateBase(AtomicReference.class,false);
    expected+=ClassSize.estimateBase(CellSet.class,false);
    expected+=ClassSize.estimateBase(NonSyncTimeRangeTracker.class,false);
    expected+=ClassSize.estimateBase(CellArrayMap.class,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicLong.class,true);
      ClassSize.estimateBase(AtomicReference.class,true);
      ClassSize.estimateBase(CellSet.class,true);
      ClassSize.estimateBase(NonSyncTimeRangeTracker.class,true);
      ClassSize.estimateBase(CellArrayMap.class,true);
      assertEquals(expected,actual);
    }
    cl=HStore.class;
    actual=HStore.FIXED_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=HRegion.class;
    actual=HRegion.FIXED_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=StoreHotnessProtector.class;
    actual=StoreHotnessProtector.FIXED_SIZE;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=BlockCacheKey.class;
    actual=BlockCacheKey.FIXED_OVERHEAD;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
  }
  @Test public void testMutations(){
    Class<?> cl;
    long expected;
    long actual;
    cl=TimeRange.class;
    actual=ClassSize.TIMERANGE;
    expected=ClassSize.estimateBase(cl,false);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    byte[] row=new byte[]{0};
    cl=Put.class;
    actual=Mutation.MUTATION_OVERHEAD + ClassSize.align(ClassSize.ARRAY);
    expected=ClassSize.estimateBase(cl,false);
    expected+=ClassSize.align(ClassSize.TREEMAP);
    expected+=ClassSize.align(ClassSize.INTEGER);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
    cl=Delete.class;
    actual=Mutation.MUTATION_OVERHEAD + ClassSize.align(ClassSize.ARRAY);
    expected=ClassSize.estimateBase(cl,false);
    expected+=ClassSize.align(ClassSize.TREEMAP);
    expected+=ClassSize.align(ClassSize.INTEGER);
    if (expected != actual) {
      ClassSize.estimateBase(cl,true);
      assertEquals(expected,actual);
    }
  }
  @Test public void testReferenceSize(){
    LOG.info("ClassSize.REFERENCE is " + ClassSize.REFERENCE);
    assertTrue(ClassSize.REFERENCE == 4 || ClassSize.REFERENCE == 8);
  }
  @Test public void testObjectSize() throws IOException {
    LOG.info("header:" + ClassSize.OBJECT);
    LOG.info("array header:" + ClassSize.ARRAY);
    if (ClassSize.is32BitJVM()) {
      assertEquals(ClassSize.OBJECT,8);
    }
 else {
      assertTrue(ClassSize.OBJECT == 12 || ClassSize.OBJECT == 16);
    }
    if (ClassSize.useUnsafeLayout()) {
      assertEquals(ClassSize.ARRAY,ClassSize.OBJECT + 4);
    }
 else {
      assertEquals(ClassSize.ARRAY,ClassSize.OBJECT + 8);
    }
  }
}
