/** 
 * compacted memstore test case
 */
@Category({RegionServerTests.class,MediumTests.class}) @RunWith(Parameterized.class) public class TestCompactingToCellFlatMapMemStore extends TestCompactingMemStore {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestCompactingToCellFlatMapMemStore.class);
  @Parameterized.Parameters public static Object[] data(){
    return new Object[]{"CHUNK_MAP","ARRAY_MAP"};
  }
  private static final Logger LOG=LoggerFactory.getLogger(TestCompactingToCellFlatMapMemStore.class);
  public final boolean toCellChunkMap;
  Configuration conf;
  public TestCompactingToCellFlatMapMemStore(  String type){
    if (type == "CHUNK_MAP") {
      toCellChunkMap=true;
    }
 else {
      toCellChunkMap=false;
    }
  }
  @Override public void tearDown() throws Exception {
    chunkCreator.clearChunksInPool();
  }
  @Override public void setUp() throws Exception {
    compactingSetUp();
    this.conf=HBaseConfiguration.create();
    conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.EAGER));
    conf.setDouble(CompactingMemStore.IN_MEMORY_FLUSH_THRESHOLD_FACTOR_KEY,0.02);
    this.memstore=new MyCompactingMemStore(conf,CellComparatorImpl.COMPARATOR,store,regionServicesForStores,MemoryCompactionPolicy.EAGER);
  }
  @Override public void testCompaction1Bucket() throws IOException {
    int counter=0;
    String[] keys1={"A","A","B","C"};
    if (toCellChunkMap) {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    }
 else {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.ARRAY_MAP);
    }
    long totalCellsLen=addRowsByKeysDataSize(memstore,keys1);
    long cellBeforeFlushSize=cellBeforeFlushSize();
    long cellAfterFlushSize=cellAfterFlushSize();
    long totalHeapSize=MutableSegment.DEEP_OVERHEAD + 4 * cellBeforeFlushSize;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    assertEquals(4,memstore.getActive().getCellsCount());
    ((CompactingMemStore)memstore).flushInMemory();
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    totalCellsLen=(totalCellsLen * 3) / 4;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    totalHeapSize=3 * cellAfterFlushSize + MutableSegment.DEEP_OVERHEAD + (toCellChunkMap ? CellChunkImmutableSegment.DEEP_OVERHEAD_CCM : CellArrayImmutableSegment.DEEP_OVERHEAD_CAM);
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    for (    Segment s : memstore.getSegments()) {
      counter+=s.getCellsCount();
    }
    assertEquals(3,counter);
    MemStoreSize mss=memstore.getFlushableSize();
    MemStoreSnapshot snapshot=memstore.snapshot();
    region.decrMemStoreSize(mss);
    ImmutableSegment s=memstore.getSnapshot();
    assertEquals(3,s.getCellsCount());
    assertEquals(0,regionServicesForStores.getMemStoreSize());
    memstore.clearSnapshot(snapshot.getId());
  }
  @Override public void testCompaction2Buckets() throws IOException {
    if (toCellChunkMap) {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    }
 else {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.ARRAY_MAP);
    }
    String[] keys1={"A","A","B","C"};
    String[] keys2={"A","B","D"};
    long totalCellsLen1=addRowsByKeysDataSize(memstore,keys1);
    long cellBeforeFlushSize=cellBeforeFlushSize();
    long cellAfterFlushSize=cellAfterFlushSize();
    long totalHeapSize1=MutableSegment.DEEP_OVERHEAD + 4 * cellBeforeFlushSize;
    assertEquals(totalCellsLen1,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize1,((CompactingMemStore)memstore).heapSize());
    ((CompactingMemStore)memstore).flushInMemory();
    int counter=0;
    for (    Segment s : memstore.getSegments()) {
      counter+=s.getCellsCount();
    }
    assertEquals(3,counter);
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    totalCellsLen1=(totalCellsLen1 * 3) / 4;
    totalHeapSize1=3 * cellAfterFlushSize + MutableSegment.DEEP_OVERHEAD + (toCellChunkMap ? CellChunkImmutableSegment.DEEP_OVERHEAD_CCM : CellArrayImmutableSegment.DEEP_OVERHEAD_CAM);
    assertEquals(totalCellsLen1,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize1,((CompactingMemStore)memstore).heapSize());
    long totalCellsLen2=addRowsByKeysDataSize(memstore,keys2);
    long totalHeapSize2=3 * cellBeforeFlushSize;
    assertEquals(totalCellsLen1 + totalCellsLen2,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize1 + totalHeapSize2,((CompactingMemStore)memstore).heapSize());
    ((CompactingMemStore)memstore).flushInMemory();
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    counter=0;
    for (    Segment s : memstore.getSegments()) {
      counter+=s.getCellsCount();
    }
    assertEquals(4,counter);
    totalCellsLen2=totalCellsLen2 / 3;
    assertEquals(totalCellsLen1 + totalCellsLen2,regionServicesForStores.getMemStoreSize());
    totalHeapSize2=1 * cellAfterFlushSize;
    assertEquals(totalHeapSize1 + totalHeapSize2,((CompactingMemStore)memstore).heapSize());
    MemStoreSize mss=memstore.getFlushableSize();
    MemStoreSnapshot snapshot=memstore.snapshot();
    region.decrMemStoreSize(mss);
    ImmutableSegment s=memstore.getSnapshot();
    assertEquals(4,s.getCellsCount());
    assertEquals(0,regionServicesForStores.getMemStoreSize());
    memstore.clearSnapshot(snapshot.getId());
  }
  @Override public void testCompaction3Buckets() throws IOException {
    if (toCellChunkMap) {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    }
 else {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.ARRAY_MAP);
    }
    String[] keys1={"A","A","B","C"};
    String[] keys2={"A","B","D"};
    String[] keys3={"D","B","B"};
    long totalCellsLen1=addRowsByKeysDataSize(memstore,keys1);
    long cellBeforeFlushSize=cellBeforeFlushSize();
    long cellAfterFlushSize=cellAfterFlushSize();
    long totalHeapSize1=MutableSegment.DEEP_OVERHEAD + 4 * cellBeforeFlushSize;
    assertEquals(totalCellsLen1,region.getMemStoreDataSize());
    assertEquals(totalHeapSize1,((CompactingMemStore)memstore).heapSize());
    MemStoreSize mss=memstore.getFlushableSize();
    ((CompactingMemStore)memstore).flushInMemory();
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    totalCellsLen1=(totalCellsLen1 * 3) / 4;
    totalHeapSize1=3 * cellAfterFlushSize + MutableSegment.DEEP_OVERHEAD + (toCellChunkMap ? CellChunkImmutableSegment.DEEP_OVERHEAD_CCM : CellArrayImmutableSegment.DEEP_OVERHEAD_CAM);
    assertEquals(totalCellsLen1,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize1,((CompactingMemStore)memstore).heapSize());
    long totalCellsLen2=addRowsByKeysDataSize(memstore,keys2);
    long totalHeapSize2=3 * cellBeforeFlushSize;
    assertEquals(totalCellsLen1 + totalCellsLen2,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize1 + totalHeapSize2,((CompactingMemStore)memstore).heapSize());
    ((MyCompactingMemStore)memstore).disableCompaction();
    mss=memstore.getFlushableSize();
    ((CompactingMemStore)memstore).flushInMemory();
    totalHeapSize2=totalHeapSize2 + CSLMImmutableSegment.DEEP_OVERHEAD_CSLM;
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    assertEquals(totalCellsLen1 + totalCellsLen2,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize1 + totalHeapSize2,((CompactingMemStore)memstore).heapSize());
    long totalCellsLen3=addRowsByKeysDataSize(memstore,keys3);
    long totalHeapSize3=3 * cellBeforeFlushSize;
    assertEquals(totalCellsLen1 + totalCellsLen2 + totalCellsLen3,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize1 + totalHeapSize2 + totalHeapSize3,((CompactingMemStore)memstore).heapSize());
    ((MyCompactingMemStore)memstore).enableCompaction();
    mss=memstore.getFlushableSize();
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    totalCellsLen2=totalCellsLen2 / 3;
    totalCellsLen3=0;
    assertEquals(totalCellsLen1 + totalCellsLen2 + totalCellsLen3,regionServicesForStores.getMemStoreSize());
    long totalHeapSize4=4 * cellAfterFlushSize + MutableSegment.DEEP_OVERHEAD + (toCellChunkMap ? CellChunkImmutableSegment.DEEP_OVERHEAD_CCM : CellArrayImmutableSegment.DEEP_OVERHEAD_CAM);
    assertEquals(totalHeapSize4,((CompactingMemStore)memstore).heapSize());
    mss=memstore.getFlushableSize();
    MemStoreSnapshot snapshot=memstore.snapshot();
    region.decrMemStoreSize(mss.getDataSize(),mss.getHeapSize(),mss.getOffHeapSize());
    ImmutableSegment s=memstore.getSnapshot();
    assertEquals(4,s.getCellsCount());
    assertEquals(0,regionServicesForStores.getMemStoreSize());
    memstore.clearSnapshot(snapshot.getId());
  }
  @Test public void testMerging() throws IOException {
    if (toCellChunkMap) {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    }
    String[] keys1={"A","A","B","C","F","H"};
    String[] keys2={"A","B","D","G","I","J"};
    String[] keys3={"D","B","B","E"};
    MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
    memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
    ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
    addRowsByKeysDataSize(memstore,keys1);
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    addRowsByKeysDataSize(memstore,keys2);
    int counter2=0;
    for (    Segment s : memstore.getSegments()) {
      counter2+=s.getCellsCount();
    }
    assertEquals(12,counter2);
    ((MyCompactingMemStore)memstore).disableCompaction();
    ((CompactingMemStore)memstore).flushInMemory();
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    int counter3=0;
    for (    Segment s : memstore.getSegments()) {
      counter3+=s.getCellsCount();
    }
    assertEquals(12,counter3);
    addRowsByKeysDataSize(memstore,keys3);
    int counter4=0;
    for (    Segment s : memstore.getSegments()) {
      counter4+=s.getCellsCount();
    }
    assertEquals(16,counter4);
    ((MyCompactingMemStore)memstore).enableCompaction();
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    int counter=0;
    for (    Segment s : memstore.getSegments()) {
      counter+=s.getCellsCount();
    }
    assertEquals(16,counter);
    MemStoreSnapshot snapshot=memstore.snapshot();
    ImmutableSegment s=memstore.getSnapshot();
    memstore.clearSnapshot(snapshot.getId());
  }
  @Test public void testTimeRangeAfterCompaction() throws IOException {
    if (toCellChunkMap) {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    }
    testTimeRange(true);
  }
  @Test public void testTimeRangeAfterMerge() throws IOException {
    if (toCellChunkMap) {
      ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    }
    MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
    memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
    ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
    testTimeRange(false);
  }
  private void testTimeRange(  boolean isCompaction) throws IOException {
    final long initTs=100;
    long currentTs=initTs;
    byte[] row=Bytes.toBytes("row");
    byte[] family=Bytes.toBytes("family");
    byte[] qf1=Bytes.toBytes("qf1");
    this.memstore.add(new KeyValue(row,family,qf1,++currentTs,(byte[])null),null);
    long minTs=currentTs;
    this.memstore.add(new KeyValue(row,family,qf1,++currentTs,(byte[])null),null);
    long numberOfCell=2;
    assertEquals(numberOfCell,memstore.getSegments().stream().mapToInt(Segment::getCellsCount).sum());
    assertEquals(minTs,memstore.getSegments().stream().mapToLong(m -> m.getTimeRangeTracker().getMin()).min().getAsLong());
    assertEquals(currentTs,memstore.getSegments().stream().mapToLong(m -> m.getTimeRangeTracker().getMax()).max().getAsLong());
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    if (isCompaction) {
      numberOfCell=1;
      minTs=currentTs;
    }
    this.memstore.add(new KeyValue(row,family,qf1,++currentTs,(byte[])null),null);
    this.memstore.add(new KeyValue(row,family,qf1,++currentTs,(byte[])null),null);
    numberOfCell+=2;
    assertEquals(numberOfCell,memstore.getSegments().stream().mapToInt(Segment::getCellsCount).sum());
    assertEquals(minTs,memstore.getSegments().stream().mapToLong(m -> m.getTimeRangeTracker().getMin()).min().getAsLong());
    assertEquals(currentTs,memstore.getSegments().stream().mapToLong(m -> m.getTimeRangeTracker().getMax()).max().getAsLong());
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    if (isCompaction) {
      numberOfCell=1;
      minTs=currentTs;
    }
    assertEquals(numberOfCell,memstore.getSegments().stream().mapToInt(Segment::getCellsCount).sum());
    assertEquals(minTs,memstore.getSegments().stream().mapToLong(m -> m.getTimeRangeTracker().getMin()).min().getAsLong());
    assertEquals(currentTs,memstore.getSegments().stream().mapToLong(m -> m.getTimeRangeTracker().getMax()).max().getAsLong());
  }
  @Test public void testCountOfCellsAfterFlatteningByScan() throws IOException {
    String[] keys1={"A","B","C"};
    addRowsByKeysWith50Cols(memstore,keys1);
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    List<KeyValueScanner> scanners=memstore.getScanners(Long.MAX_VALUE);
    int count=0;
    for (int i=0; i < scanners.size(); i++) {
      scanners.get(i).seek(KeyValue.LOWESTKEY);
      while (scanners.get(i).next() != null) {
        count++;
      }
    }
    assertEquals("the count should be ",150,count);
    for (int i=0; i < scanners.size(); i++) {
      scanners.get(i).close();
    }
  }
  @Test public void testCountOfCellsAfterFlatteningByIterator() throws IOException {
    String[] keys1={"A","B","C"};
    addRowsByKeysWith50Cols(memstore,keys1);
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    MemStoreSegmentsIterator itr=new MemStoreMergerSegmentsIterator(((CompactingMemStore)memstore).getImmutableSegments().getStoreSegments(),CellComparatorImpl.COMPARATOR,10);
    int cnt=0;
    try {
      while (itr.next() != null) {
        cnt++;
      }
    }
  finally {
      itr.close();
    }
    assertEquals("the count should be ",150,cnt);
  }
  private void addRowsByKeysWith50Cols(  AbstractMemStore hmc,  String[] keys){
    byte[] fam=Bytes.toBytes("testfamily");
    for (int i=0; i < keys.length; i++) {
      long timestamp=System.currentTimeMillis();
      Threads.sleep(1);
      byte[] row=Bytes.toBytes(keys[i]);
      for (int j=0; j < 50; j++) {
        byte[] qf=Bytes.toBytes("testqualifier" + j);
        byte[] val=Bytes.toBytes(keys[i] + j);
        KeyValue kv=new KeyValue(row,fam,qf,timestamp,val);
        hmc.add(kv,null);
      }
    }
  }
  @Override @Test public void testPuttingBackChunksWithOpeningScanner() throws IOException {
    byte[] row=Bytes.toBytes("testrow");
    byte[] fam=Bytes.toBytes("testfamily");
    byte[] qf1=Bytes.toBytes("testqualifier1");
    byte[] qf2=Bytes.toBytes("testqualifier2");
    byte[] qf3=Bytes.toBytes("testqualifier3");
    byte[] qf4=Bytes.toBytes("testqualifier4");
    byte[] qf5=Bytes.toBytes("testqualifier5");
    byte[] qf6=Bytes.toBytes("testqualifier6");
    byte[] qf7=Bytes.toBytes("testqualifier7");
    byte[] val=Bytes.toBytes("testval");
    memstore.add(new KeyValue(row,fam,qf1,val),null);
    memstore.add(new KeyValue(row,fam,qf2,val),null);
    memstore.add(new KeyValue(row,fam,qf3,val),null);
    MemStoreSnapshot snapshot=memstore.snapshot();
    assertEquals(3,memstore.getSnapshot().getCellsCount());
    assertEquals(0,memstore.getActive().getCellsCount());
    memstore.add(new KeyValue(row,fam,qf4,val),null);
    memstore.add(new KeyValue(row,fam,qf5,val),null);
    assertEquals(2,memstore.getActive().getCellsCount());
    List<KeyValueScanner> scanners=memstore.getScanners(0);
    for (    KeyValueScanner scanner : snapshot.getScanners()) {
      scanner.close();
    }
    memstore.clearSnapshot(snapshot.getId());
    assertTrue(chunkCreator.getPoolSize() == 0);
    for (    KeyValueScanner scanner : scanners) {
      scanner.close();
    }
    assertTrue(chunkCreator.getPoolSize() > 0);
    chunkCreator.clearChunksInPool();
    snapshot=memstore.snapshot();
    memstore.add(new KeyValue(row,fam,qf6,val),null);
    memstore.add(new KeyValue(row,fam,qf7,val),null);
    scanners=memstore.getScanners(0);
    for (    KeyValueScanner scanner : scanners) {
      scanner.close();
    }
    for (    KeyValueScanner scanner : snapshot.getScanners()) {
      scanner.close();
    }
    memstore.clearSnapshot(snapshot.getId());
    assertTrue(chunkCreator.getPoolSize() > 0);
  }
  @Override @Test public void testPuttingBackChunksAfterFlushing() throws IOException {
    byte[] row=Bytes.toBytes("testrow");
    byte[] fam=Bytes.toBytes("testfamily");
    byte[] qf1=Bytes.toBytes("testqualifier1");
    byte[] qf2=Bytes.toBytes("testqualifier2");
    byte[] qf3=Bytes.toBytes("testqualifier3");
    byte[] qf4=Bytes.toBytes("testqualifier4");
    byte[] qf5=Bytes.toBytes("testqualifier5");
    byte[] val=Bytes.toBytes("testval");
    memstore.add(new KeyValue(row,fam,qf1,val),null);
    memstore.add(new KeyValue(row,fam,qf2,val),null);
    memstore.add(new KeyValue(row,fam,qf3,val),null);
    MemStoreSnapshot snapshot=memstore.snapshot();
    assertEquals(3,memstore.getSnapshot().getCellsCount());
    assertEquals(0,memstore.getActive().getCellsCount());
    memstore.add(new KeyValue(row,fam,qf4,val),null);
    memstore.add(new KeyValue(row,fam,qf5,val),null);
    assertEquals(2,memstore.getActive().getCellsCount());
    for (    KeyValueScanner scanner : snapshot.getScanners()) {
      scanner.close();
    }
    memstore.clearSnapshot(snapshot.getId());
    int chunkCount=chunkCreator.getPoolSize();
    assertTrue(chunkCount > 0);
  }
  @Test public void testFlatteningToCellChunkMap() throws IOException {
    if (!toCellChunkMap) {
      return;
    }
    MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
    memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
    ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
    ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    int numOfCells=8;
    String[] keys1={"A","A","B","C","D","D","E","F"};
    byte[] row=Bytes.toBytes(keys1[0]);
    byte[] val=Bytes.toBytes(keys1[0] + 0);
    KeyValue kv=new KeyValue(row,Bytes.toBytes("testfamily"),Bytes.toBytes("testqualifier"),System.currentTimeMillis(),val);
    int totalCellsLen=addRowsByKeys(memstore,keys1);
    long oneCellOnCSLMHeapSize=ClassSize.align(ClassSize.CONCURRENT_SKIPLISTMAP_ENTRY + KeyValue.FIXED_OVERHEAD + KeyValueUtil.length(kv));
    long totalHeapSize=numOfCells * oneCellOnCSLMHeapSize + MutableSegment.DEEP_OVERHEAD;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    ((CompactingMemStore)memstore).flushInMemory();
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    long oneCellOnCCMHeapSize=ClassSize.CELL_CHUNK_MAP_ENTRY + ClassSize.align(KeyValueUtil.length(kv));
    totalHeapSize=MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + numOfCells * oneCellOnCCMHeapSize;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    MemStoreSize mss=memstore.getFlushableSize();
    MemStoreSnapshot snapshot=memstore.snapshot();
    region.decrMemStoreSize(mss);
    ImmutableSegment s=memstore.getSnapshot();
    assertEquals(numOfCells,s.getCellsCount());
    assertEquals(0,regionServicesForStores.getMemStoreSize());
    memstore.clearSnapshot(snapshot.getId());
  }
  /** 
 * CellChunkMap Segment index requires all cell data to be written in the MSLAB Chunks. Even though MSLAB is enabled, cells bigger than maxAlloc (even if smaller than the size of a chunk) are not written in the MSLAB Chunks. If such cells are found in the process of flattening into CellChunkMap (in-memory-flush) they need to be copied into MSLAB. testFlatteningToBigCellChunkMap checks that the process of flattening into CellChunkMap succeeds, even when such big cells are allocated.
 */
  @Test public void testFlatteningToBigCellChunkMap() throws IOException {
    if (toCellChunkMap == false) {
      return;
    }
    MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
    memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
    ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
    ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    int numOfCells=4;
    char[] chars=new char[MemStoreLAB.MAX_ALLOC_DEFAULT];
    for (int i=0; i < chars.length; i++) {
      chars[i]='A';
    }
    String bigVal=new String(chars);
    String[] keys1={"A","B","C","D"};
    byte[] row=Bytes.toBytes(keys1[0]);
    byte[] val=Bytes.toBytes(bigVal);
    KeyValue kv=new KeyValue(row,Bytes.toBytes("testfamily"),Bytes.toBytes("testqualifier"),System.currentTimeMillis(),val);
    int totalCellsLen=addRowsByKeys(memstore,keys1,val);
    long oneCellOnCSLMHeapSize=ClassSize.align(ClassSize.CONCURRENT_SKIPLISTMAP_ENTRY + kv.heapSize());
    long totalHeapSize=numOfCells * oneCellOnCSLMHeapSize + MutableSegment.DEEP_OVERHEAD;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    long oneCellOnCCMHeapSize=ClassSize.CELL_CHUNK_MAP_ENTRY + ClassSize.align(KeyValueUtil.length(kv));
    totalHeapSize=MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + numOfCells * oneCellOnCCMHeapSize;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    MemStoreSize mss=memstore.getFlushableSize();
    MemStoreSnapshot snapshot=memstore.snapshot();
    region.decrMemStoreSize(mss);
    ImmutableSegment s=memstore.getSnapshot();
    assertEquals(numOfCells,s.getCellsCount());
    assertEquals(0,regionServicesForStores.getMemStoreSize());
    memstore.clearSnapshot(snapshot.getId());
  }
  /** 
 * CellChunkMap Segment index requires all cell data to be written in the MSLAB Chunks. Even though MSLAB is enabled, cells bigger than the size of a chunk are not written in the MSLAB Chunks. If such cells are found in the process of flattening into CellChunkMap (in-memory-flush) they need to be copied into MSLAB. testFlatteningToJumboCellChunkMap checks that the process of flattening into CellChunkMap succeeds, even when such big cells are allocated.
 */
  @Test public void testFlatteningToJumboCellChunkMap() throws IOException {
    if (toCellChunkMap == false) {
      return;
    }
    MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
    memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
    ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
    ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    int numOfCells=1;
    char[] chars=new char[MemStoreLAB.CHUNK_SIZE_DEFAULT];
    for (int i=0; i < chars.length; i++) {
      chars[i]='A';
    }
    String bigVal=new String(chars);
    String[] keys1={"A"};
    byte[] row=Bytes.toBytes(keys1[0]);
    byte[] val=Bytes.toBytes(bigVal);
    KeyValue kv=new KeyValue(row,Bytes.toBytes("testfamily"),Bytes.toBytes("testqualifier"),System.currentTimeMillis(),val);
    int totalCellsLen=addRowsByKeys(memstore,keys1,val);
    long oneCellOnCSLMHeapSize=ClassSize.align(ClassSize.CONCURRENT_SKIPLISTMAP_ENTRY + kv.heapSize());
    long totalHeapSize=numOfCells * oneCellOnCSLMHeapSize + MutableSegment.DEEP_OVERHEAD;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    ((CompactingMemStore)memstore).flushInMemory();
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    assertEquals(0,memstore.getSnapshot().getCellsCount());
    long oneCellOnCCMHeapSize=ClassSize.CELL_CHUNK_MAP_ENTRY + ClassSize.align(KeyValueUtil.length(kv));
    totalHeapSize=MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + numOfCells * oneCellOnCCMHeapSize;
    assertEquals(totalCellsLen,regionServicesForStores.getMemStoreSize());
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    MemStoreSize mss=memstore.getFlushableSize();
    MemStoreSnapshot snapshot=memstore.snapshot();
    region.decrMemStoreSize(mss);
    ImmutableSegment s=memstore.getSnapshot();
    assertEquals(numOfCells,s.getCellsCount());
    assertEquals(0,regionServicesForStores.getMemStoreSize());
    memstore.clearSnapshot(snapshot.getId());
    String[] keys2={"C","D"};
    addRowsByKeys(memstore,keys2,val);
    while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    totalHeapSize=MutableSegment.DEEP_OVERHEAD + CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + 2 * oneCellOnCCMHeapSize;
    assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
  }
  /** 
 * CellChunkMap Segment index requires all cell data to be written in the MSLAB Chunks. Even though MSLAB is enabled, cells bigger than the size of a chunk are not written in the MSLAB Chunks. If such cells are found in the process of a merge they need to be copied into MSLAB. testForceCopyOfBigCellIntoImmutableSegment checks that the ImmutableMemStoreLAB's forceCopyOfBigCellInto does what it's supposed to do.
 */
  @Test public void testForceCopyOfBigCellIntoImmutableSegment() throws IOException {
    if (toCellChunkMap == false) {
      return;
    }
    MemoryCompactionPolicy compactionType=MemoryCompactionPolicy.BASIC;
    memstore.getConfiguration().setInt(MemStoreCompactionStrategy.COMPACTING_MEMSTORE_THRESHOLD_KEY,4);
    memstore.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(compactionType));
    ((MyCompactingMemStore)memstore).initiateType(compactionType,memstore.getConfiguration());
    ((CompactingMemStore)memstore).setIndexType(CompactingMemStore.IndexType.CHUNK_MAP);
    char[] chars=new char[MemStoreLAB.CHUNK_SIZE_DEFAULT];
    for (int i=0; i < chars.length; i++) {
      chars[i]='A';
    }
    String bigVal=new String(chars);
    byte[] val=Bytes.toBytes(bigVal);
    List<String[]> keysList=new ArrayList<>();
    keysList.add(new String[]{"A","B"});
    keysList.add(new String[]{"C","D"});
    keysList.add(new String[]{"E","F"});
    keysList.add(new String[]{"G","H"});
    keysList.add(new String[]{"I","J"});
    KeyValue kv=new KeyValue(Bytes.toBytes("A"),Bytes.toBytes("testfamily"),Bytes.toBytes("testqualifier"),System.currentTimeMillis(),val);
    long oneCellOnCCMHeapSize=ClassSize.CELL_CHUNK_MAP_ENTRY + ClassSize.align(KeyValueUtil.length(kv));
    long totalHeapSize=MutableSegment.DEEP_OVERHEAD;
    for (int i=0; i < 5; i++) {
      addRowsByKeys(memstore,keysList.get(i),val);
      while (((CompactingMemStore)memstore).isMemStoreFlushingInMemory()) {
        Threads.sleep(10);
      }
      totalHeapSize+=CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + 2 * oneCellOnCCMHeapSize;
      if (i == 4) {
        totalHeapSize-=(3 * CellChunkImmutableSegment.DEEP_OVERHEAD_CCM + MutableSegment.DEEP_OVERHEAD);
      }
      assertEquals(totalHeapSize,((CompactingMemStore)memstore).heapSize());
    }
  }
  private long addRowsByKeysDataSize(  final AbstractMemStore hmc,  String[] keys){
    byte[] fam=Bytes.toBytes("testfamily");
    byte[] qf=Bytes.toBytes("testqualifier");
    MemStoreSizing memstoreSizing=new NonThreadSafeMemStoreSizing();
    for (int i=0; i < keys.length; i++) {
      long timestamp=System.currentTimeMillis();
      Threads.sleep(1);
      byte[] row=Bytes.toBytes(keys[i]);
      byte[] val=Bytes.toBytes(keys[i] + i);
      KeyValue kv=new KeyValue(row,fam,qf,timestamp,val);
      hmc.add(kv,memstoreSizing);
      LOG.debug("added kv: " + kv.getKeyString() + ", timestamp"+ kv.getTimestamp());
    }
    MemStoreSize mss=memstoreSizing.getMemStoreSize();
    regionServicesForStores.addMemStoreSize(mss.getDataSize(),mss.getHeapSize(),mss.getOffHeapSize());
    return mss.getDataSize();
  }
  private long cellBeforeFlushSize(){
    byte[] row=Bytes.toBytes("A");
    byte[] val=Bytes.toBytes("A" + 0);
    KeyValue kv=new KeyValue(row,Bytes.toBytes("testfamily"),Bytes.toBytes("testqualifier"),System.currentTimeMillis(),val);
    return ClassSize.align(ClassSize.CONCURRENT_SKIPLISTMAP_ENTRY + KeyValue.FIXED_OVERHEAD + KeyValueUtil.length(kv));
  }
  private long cellAfterFlushSize(){
    byte[] row=Bytes.toBytes("A");
    byte[] val=Bytes.toBytes("A" + 0);
    KeyValue kv=new KeyValue(row,Bytes.toBytes("testfamily"),Bytes.toBytes("testqualifier"),System.currentTimeMillis(),val);
    return toCellChunkMap ? ClassSize.align(ClassSize.CELL_CHUNK_MAP_ENTRY + KeyValueUtil.length(kv)) : ClassSize.align(ClassSize.CELL_ARRAY_MAP_ENTRY + KeyValue.FIXED_OVERHEAD + KeyValueUtil.length(kv));
  }
}
