@Category(MediumTests.class) public class TestRegionServerReportForDuty {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRegionServerReportForDuty.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRegionServerReportForDuty.class);
  private static final long SLEEP_INTERVAL=500;
  private HBaseTestingUtility testUtil;
  private LocalHBaseCluster cluster;
  private RegionServerThread rs;
  private RegionServerThread rs2;
  private MasterThread master;
  private MasterThread backupMaster;
  @Before public void setUp() throws Exception {
    testUtil=new HBaseTestingUtility();
    testUtil.startMiniDFSCluster(1);
    testUtil.startMiniZKCluster(1);
    testUtil.createRootDir();
    cluster=new LocalHBaseCluster(testUtil.getConfiguration(),0,0);
  }
  @After public void tearDown() throws Exception {
    cluster.shutdown();
    cluster.join();
    testUtil.shutdownMiniZKCluster();
    testUtil.shutdownMiniDFSCluster();
  }
  /** 
 * LogCapturer is similar to  {@link org.apache.hadoop.test.GenericTestUtils.LogCapturer}except that this implementation has a default appender to the root logger. Hadoop 2.8+ supports the default appender in the LogCapture it ships and this can be replaced. TODO: This class can be removed after we upgrade Hadoop dependency.
 */
static class LogCapturer {
    private StringWriter sw=new StringWriter();
    private WriterAppender appender;
    private org.apache.log4j.Logger logger;
    LogCapturer(    org.apache.log4j.Logger logger){
      this.logger=logger;
      Appender defaultAppender=org.apache.log4j.Logger.getRootLogger().getAppender("stdout");
      if (defaultAppender == null) {
        defaultAppender=org.apache.log4j.Logger.getRootLogger().getAppender("console");
      }
      final Layout layout=(defaultAppender == null) ? new PatternLayout() : defaultAppender.getLayout();
      this.appender=new WriterAppender(layout,sw);
      this.logger.addAppender(this.appender);
    }
    String getOutput(){
      return sw.toString();
    }
    public void stopCapturing(){
      this.logger.removeAppender(this.appender);
    }
  }
  /** 
 * This test HMaster class will always throw ServerNotRunningYetException if checked.
 */
public static class NeverInitializedMaster extends HMaster {
    public NeverInitializedMaster(    Configuration conf) throws IOException, KeeperException {
      super(conf);
    }
    @Override protected void checkServiceStarted() throws ServerNotRunningYetException {
      throw new ServerNotRunningYetException("Server is not running yet");
    }
  }
  /** 
 * Tests region server should backoff to report for duty if master is not ready.
 */
  @Test public void testReportForDutyBackoff() throws IOException, InterruptedException {
    cluster.getConfiguration().set(HConstants.MASTER_IMPL,NeverInitializedMaster.class.getName());
    master=cluster.addMaster();
    master.start();
    LogCapturer capturer=new LogCapturer(org.apache.log4j.Logger.getLogger(HRegionServer.class));
    int msginterval=100;
    cluster.getConfiguration().setInt("hbase.regionserver.msginterval",msginterval);
    rs=cluster.addRegionServer();
    rs.start();
    int interval=10_000;
    Thread.sleep(interval);
    capturer.stopCapturing();
    String output=capturer.getOutput();
    LOG.info("{}",output);
    String failMsg="reportForDuty failed;";
    int count=StringUtils.countMatches(output,failMsg);
    int expectedRetry=(int)Math.ceil(Math.log(interval - msginterval));
    assertTrue(String.format("reportForDuty retries %d times, less than expected min %d",count,expectedRetry / 2),count > expectedRetry / 2);
    assertTrue(String.format("reportForDuty retries %d times, more than expected max %d",count,expectedRetry * 2),count < expectedRetry * 2);
  }
  /** 
 * Tests region sever reportForDuty with backup master becomes primary master after the first master goes away.
 */
  @Test public void testReportForDutyWithMasterChange() throws Exception {
    cluster.getConfiguration().setInt(HConstants.MASTER_PORT,HBaseTestingUtility.randomFreePort());
    boolean tablesOnMaster=LoadBalancer.isTablesOnMaster(testUtil.getConfiguration());
    cluster.getConfiguration().setInt(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART,tablesOnMaster ? 2 : 1);
    cluster.getConfiguration().setInt(ServerManager.WAIT_ON_REGIONSERVERS_MAXTOSTART,tablesOnMaster ? 2 : 1);
    master=cluster.addMaster();
    rs=cluster.addRegionServer();
    LOG.debug("Starting master: " + master.getMaster().getServerName());
    master.start();
    rs.start();
    waitForClusterOnline(master);
    cluster.getConfiguration().set(HConstants.REGION_SERVER_IMPL,MyRegionServer.class.getName());
    rs2=cluster.addRegionServer();
    LOG.debug("Starting 2nd region server: " + rs2.getRegionServer().getServerName());
    rs2.start();
    waitForSecondRsStarted();
    master.getMaster().stop("Stopping master");
    cluster.getConfiguration().setInt(HConstants.MASTER_PORT,HBaseTestingUtility.randomFreePort());
    cluster.getConfiguration().setInt(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART,tablesOnMaster ? 3 : 2);
    cluster.getConfiguration().setInt(ServerManager.WAIT_ON_REGIONSERVERS_MAXTOSTART,tablesOnMaster ? 3 : 2);
    backupMaster=cluster.addMaster();
    LOG.debug("Starting new master: " + backupMaster.getMaster().getServerName());
    backupMaster.start();
    waitForClusterOnline(backupMaster);
    assertTrue(backupMaster.getMaster().isActiveMaster());
    assertTrue(backupMaster.getMaster().isInitialized());
    assertEquals(backupMaster.getMaster().getServerManager().getOnlineServersList().size(),tablesOnMaster ? 3 : 2);
  }
  private void waitForClusterOnline(  MasterThread master) throws InterruptedException {
    while (true) {
      if (master.getMaster().isInitialized()) {
        break;
      }
      Thread.sleep(SLEEP_INTERVAL);
      LOG.debug("Waiting for master to come online ...");
    }
    rs.waitForServerOnline();
  }
  private void waitForSecondRsStarted() throws InterruptedException {
    while (true) {
      if (((MyRegionServer)rs2.getRegionServer()).getRpcStubCreatedFlag() == true) {
        break;
      }
      Thread.sleep(SLEEP_INTERVAL);
      LOG.debug("Waiting 2nd RS to be started ...");
    }
  }
public static class MyRegionServer extends MiniHBaseClusterRegionServer {
    private ServerName sn;
    private boolean rpcStubCreatedFlag=false;
    private boolean masterChanged=false;
    public MyRegionServer(    Configuration conf) throws IOException, KeeperException, InterruptedException {
      super(conf);
    }
    @Override protected synchronized ServerName createRegionServerStatusStub(    boolean refresh){
      sn=super.createRegionServerStatusStub(refresh);
      rpcStubCreatedFlag=true;
      while (!masterChanged) {
        ServerName newSn=super.getMasterAddressTracker().getMasterAddress(true);
        if (newSn != null && !newSn.equals(sn)) {
          masterChanged=true;
          break;
        }
        try {
          Thread.sleep(SLEEP_INTERVAL);
        }
 catch (        InterruptedException e) {
          return null;
        }
        LOG.debug("Waiting for master switch over ... ");
      }
      return sn;
    }
    public boolean getRpcStubCreatedFlag(){
      return rpcStubCreatedFlag;
    }
  }
}
