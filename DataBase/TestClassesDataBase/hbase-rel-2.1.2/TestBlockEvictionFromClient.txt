@Category({LargeTests.class,ClientTests.class}) @SuppressWarnings("deprecation") public class TestBlockEvictionFromClient {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestBlockEvictionFromClient.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestBlockEvictionFromClient.class);
  protected final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  static byte[][] ROWS=new byte[2][];
  private static int NO_OF_THREADS=3;
  private static byte[] ROW=Bytes.toBytes("testRow");
  private static byte[] ROW1=Bytes.toBytes("testRow1");
  private static byte[] ROW2=Bytes.toBytes("testRow2");
  private static byte[] ROW3=Bytes.toBytes("testRow3");
  private static byte[] FAMILY=Bytes.toBytes("testFamily");
  private static byte[][] FAMILIES_1=new byte[1][0];
  private static byte[] QUALIFIER=Bytes.toBytes("testQualifier");
  private static byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
  private static byte[] data=new byte[1000];
  private static byte[] data2=Bytes.add(data,data);
  protected static int SLAVES=1;
  private static CountDownLatch latch;
  private static CountDownLatch getLatch;
  private static CountDownLatch compactionLatch;
  private static CountDownLatch exceptionLatch;
  @Rule public TestName name=new TestName();
  /** 
 * @throws java.lang.Exception
 */
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    ROWS[0]=ROW;
    ROWS[1]=ROW1;
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setStrings(CoprocessorHost.REGION_COPROCESSOR_CONF_KEY,MultiRowMutationEndpoint.class.getName());
    conf.setBoolean("hbase.table.sanity.checks",true);
    conf.setInt("hbase.regionserver.handler.count",20);
    conf.setInt("hbase.bucketcache.size",400);
    conf.setStrings(HConstants.BUCKET_CACHE_IOENGINE_KEY,"offheap");
    conf.setFloat("hfile.block.cache.size",0.2f);
    conf.setFloat("hbase.regionserver.global.memstore.size",0.1f);
    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,0);
    conf.setInt(HConstants.HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD,5000);
    FAMILIES_1[0]=FAMILY;
    TEST_UTIL.startMiniCluster(SLAVES);
  }
  /** 
 * @throws java.lang.Exception
 */
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  /** 
 * @throws java.lang.Exception
 */
  @Before public void setUp() throws Exception {
    CustomInnerRegionObserver.waitForGets.set(false);
    CustomInnerRegionObserver.countOfNext.set(0);
    CustomInnerRegionObserver.countOfGets.set(0);
  }
  /** 
 * @throws java.lang.Exception
 */
  @After public void tearDown() throws Exception {
    if (latch != null) {
      while (latch.getCount() > 0) {
        latch.countDown();
      }
    }
    if (getLatch != null) {
      getLatch.countDown();
    }
    if (compactionLatch != null) {
      compactionLatch.countDown();
    }
    if (exceptionLatch != null) {
      exceptionLatch.countDown();
    }
    latch=null;
    getLatch=null;
    compactionLatch=null;
    exceptionLatch=null;
    CustomInnerRegionObserver.throwException.set(false);
    TableName[] listTableNames=TEST_UTIL.getAdmin().listTableNames();
    for (    TableName tableName : listTableNames) {
      if (!tableName.isSystemTable()) {
        TEST_UTIL.getAdmin().disableTable(tableName);
        TEST_UTIL.getAdmin().deleteTable(tableName);
      }
    }
  }
  @Test public void testBlockEvictionWithParallelScans() throws Exception {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserver.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      assertTrue(Bytes.equals(table.get(new Get(ROW)).value(),data));
      region.flush(true);
      ScanThread[] scanThreads=initiateScan(table,false);
      Thread.sleep(100);
      checkForBlockEviction(cache,false,false);
      for (      ScanThread thread : scanThreads) {
        thread.join();
      }
      Iterator<CachedBlock> iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      assertTrue(Bytes.equals(table.get(new Get(ROW)).value(),data));
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      byte[] data2=Bytes.add(data,data);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      Result r=table.get(new Get(ROW));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),data));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER2),data2));
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      System.out.println("Flushing cache");
      region.flush(true);
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      System.out.println("Compacting");
      assertEquals(2,store.getStorefilesCount());
      store.triggerMajorCompaction();
      region.compact(true);
      waitForStoreFileCount(store,1,10000);
      assertEquals(1,store.getStorefilesCount());
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      r=table.get(new Get(ROW));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),data));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER2),data2));
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testParallelGetsAndScans() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(2);
      getLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserver.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      insertData(table);
      System.out.println("Flushing cache");
      region.flush(true);
      CustomInnerRegionObserver.waitForGets.set(true);
      ScanThread[] scanThreads=initiateScan(table,false);
      GetThread[] getThreads=initiateGet(table,false,false);
      checkForBlockEviction(cache,false,false);
      CustomInnerRegionObserver.waitForGets.set(false);
      checkForBlockEviction(cache,false,false);
      for (      GetThread thread : getThreads) {
        thread.join();
      }
      CustomInnerRegionObserver.waitForGets.set(true);
      checkForBlockEviction(cache,true,false);
      getLatch.countDown();
      for (      ScanThread thread : scanThreads) {
        thread.join();
      }
      System.out.println("Scans should have returned the bloks");
      CustomInnerRegionObserver.waitForGets.set(false);
      checkForBlockEviction(cache,true,true);
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testGetWithCellsInDifferentFiles() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      getLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserver.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      region.flush(true);
      System.out.println("Flushing cache");
      CustomInnerRegionObserver.waitForGets.set(true);
      GetThread[] getThreads=initiateGet(table,false,false);
      Thread.sleep(200);
      CustomInnerRegionObserver.getCdl().get().countDown();
      for (      GetThread thread : getThreads) {
        thread.join();
      }
      CustomInnerRegionObserver.waitForGets.set(true);
      checkForBlockEviction(cache,true,false);
      getLatch.countDown();
      System.out.println("Gets should have returned the bloks");
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testGetsWithMultiColumnsAndExplicitTracker() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      getLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserver.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      BlockCache cache=setCacheProperties(region);
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      for (int i=1; i < 10; i++) {
        put=new Put(ROW);
        put.addColumn(FAMILY,Bytes.toBytes("testQualifier" + i),data2);
        table.put(put);
        if (i % 2 == 0) {
          region.flush(true);
        }
      }
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      region.flush(true);
      System.out.println("Flushing cache");
      CustomInnerRegionObserver.waitForGets.set(true);
      GetThread[] getThreads=initiateGet(table,true,false);
      Thread.sleep(200);
      Iterator<CachedBlock> iterator=cache.iterator();
      boolean usedBlocksFound=false;
      int refCount=0;
      int noOfBlocksWithRef=0;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          System.out.println("The refCount is " + refCount);
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
          noOfBlocksWithRef++;
        }
      }
      assertTrue(usedBlocksFound);
      assertEquals(10,noOfBlocksWithRef);
      CustomInnerRegionObserver.getCdl().get().countDown();
      for (      GetThread thread : getThreads) {
        thread.join();
      }
      CustomInnerRegionObserver.waitForGets.set(true);
      checkForBlockEviction(cache,true,false);
      getLatch.countDown();
      System.out.println("Gets should have returned the bloks");
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testGetWithMultipleColumnFamilies() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      getLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      byte[][] fams=new byte[10][];
      fams[0]=FAMILY;
      for (int i=1; i < 10; i++) {
        fams[i]=(Bytes.toBytes("testFamily" + i));
      }
      table=TEST_UTIL.createTable(tableName,fams,1,1024,CustomInnerRegionObserver.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      BlockCache cache=setCacheProperties(region);
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      for (int i=1; i < 10; i++) {
        put=new Put(ROW);
        put.addColumn(Bytes.toBytes("testFamily" + i),Bytes.toBytes("testQualifier" + i),data2);
        table.put(put);
        if (i % 2 == 0) {
          region.flush(true);
        }
      }
      region.flush(true);
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      region.flush(true);
      System.out.println("Flushing cache");
      CustomInnerRegionObserver.waitForGets.set(true);
      GetThread[] getThreads=initiateGet(table,true,true);
      Thread.sleep(200);
      Iterator<CachedBlock> iterator=cache.iterator();
      boolean usedBlocksFound=false;
      int refCount=0;
      int noOfBlocksWithRef=0;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          System.out.println("The refCount is " + refCount);
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
          noOfBlocksWithRef++;
        }
      }
      assertTrue(usedBlocksFound);
      assertEquals(3,noOfBlocksWithRef);
      CustomInnerRegionObserver.getCdl().get().countDown();
      for (      GetThread thread : getThreads) {
        thread.join();
      }
      CustomInnerRegionObserver.waitForGets.set(true);
      checkForBlockEviction(cache,true,false);
      getLatch.countDown();
      System.out.println("Gets should have returned the bloks");
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testBlockRefCountAfterSplits() throws IOException, InterruptedException {
    Table table=null;
    try {
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024);
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      put=new Put(ROW2);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      put=new Put(ROW3);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      region.flush(true);
      LOG.info("About to SPLIT on " + Bytes.toString(ROW1));
      TEST_UTIL.getAdmin().split(tableName,ROW1);
      Collection<ServerName> regionServers=TEST_UTIL.getAdmin().getRegionServers();
      Iterator<ServerName> serverItr=regionServers.iterator();
      serverItr.hasNext();
      ServerName rs=serverItr.next();
      List<RegionInfo> onlineRegions=TEST_UTIL.getAdmin().getRegions(rs);
      while (onlineRegions.size() != 2) {
        onlineRegions=TEST_UTIL.getAdmin().getRegions(rs);
        Thread.sleep(100);
        LOG.info("Waiting on SPLIT to complete...");
      }
      region.compact(true);
      Iterator<CachedBlock> iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testMultiGets() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(2);
      getLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserver.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      region.flush(true);
      System.out.println("Flushing cache");
      CustomInnerRegionObserver.waitForGets.set(true);
      MultiGetThread[] getThreads=initiateMultiGet(table);
      Thread.sleep(200);
      int refCount;
      Iterator<CachedBlock> iterator=cache.iterator();
      boolean foundNonZeroBlock=false;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          assertEquals(NO_OF_THREADS,refCount);
          foundNonZeroBlock=true;
        }
      }
      assertTrue("Should have found nonzero ref count block",foundNonZeroBlock);
      CustomInnerRegionObserver.getCdl().get().countDown();
      CustomInnerRegionObserver.getCdl().get().countDown();
      for (      MultiGetThread thread : getThreads) {
        thread.join();
      }
      CustomInnerRegionObserver.waitForGets.set(true);
      iterateBlockCache(cache,iterator);
      getLatch.countDown();
      System.out.println("Gets should have returned the bloks");
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testScanWithMultipleColumnFamilies() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      byte[][] fams=new byte[10][];
      fams[0]=FAMILY;
      for (int i=1; i < 10; i++) {
        fams[i]=(Bytes.toBytes("testFamily" + i));
      }
      table=TEST_UTIL.createTable(tableName,fams,1,1024,CustomInnerRegionObserver.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      BlockCache cache=setCacheProperties(region);
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      region.flush(true);
      for (int i=1; i < 10; i++) {
        put=new Put(ROW);
        put.addColumn(Bytes.toBytes("testFamily" + i),Bytes.toBytes("testQualifier" + i),data2);
        table.put(put);
        if (i % 2 == 0) {
          region.flush(true);
        }
      }
      region.flush(true);
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      region.flush(true);
      System.out.println("Flushing cache");
      ScanThread[] scanThreads=initiateScan(table,true);
      Thread.sleep(200);
      Iterator<CachedBlock> iterator=cache.iterator();
      boolean usedBlocksFound=false;
      int refCount=0;
      int noOfBlocksWithRef=0;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          System.out.println("The refCount is " + refCount);
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
          noOfBlocksWithRef++;
        }
      }
      assertTrue(usedBlocksFound);
      assertEquals(12,noOfBlocksWithRef);
      CustomInnerRegionObserver.getCdl().get().countDown();
      for (      ScanThread thread : scanThreads) {
        thread.join();
      }
      checkForBlockEviction(cache,true,false);
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  private BlockCache setCacheProperties(  HRegion region){
    Iterator<HStore> strItr=region.getStores().iterator();
    BlockCache cache=null;
    while (strItr.hasNext()) {
      HStore store=strItr.next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      cache=cacheConf.getBlockCache();
    }
    return cache;
  }
  @Test public void testParallelGetsAndScanWithWrappedRegionScanner() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(2);
      getLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserverWrapper.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      insertData(table);
      System.out.println("Flushing cache");
      region.flush(true);
      CustomInnerRegionObserver.waitForGets.set(true);
      ScanThread[] scanThreads=initiateScan(table,false);
      GetThread[] getThreads=initiateGet(table,false,false);
      Thread.sleep(100);
      CustomInnerRegionObserver.waitForGets.set(false);
      checkForBlockEviction(cache,false,false);
      CustomInnerRegionObserver.getCdl().get().countDown();
      for (      GetThread thread : getThreads) {
        thread.join();
      }
      getLatch.countDown();
      for (      ScanThread thread : scanThreads) {
        thread.join();
      }
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testScanWithCompaction() throws IOException, InterruptedException {
    testScanWithCompactionInternals(name.getMethodName(),false);
  }
  @Test public void testReverseScanWithCompaction() throws IOException, InterruptedException {
    testScanWithCompactionInternals(name.getMethodName(),true);
  }
  private void testScanWithCompactionInternals(  String tableNameStr,  boolean reversed) throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      compactionLatch=new CountDownLatch(1);
      TableName tableName=TableName.valueOf(tableNameStr);
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserverWrapper.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      assertTrue(Bytes.equals(table.get(new Get(ROW)).value(),data));
      region.flush(true);
      int refCount=0;
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      byte[] data2=Bytes.add(data,data);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      System.out.println("Flushing cache");
      region.flush(true);
      Iterator<CachedBlock> iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      ScanThread[] scanThreads=initiateScan(table,reversed);
      Thread.sleep(100);
      iterator=cache.iterator();
      boolean usedBlocksFound=false;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
        }
      }
      assertTrue("Blocks with non zero ref count should be found ",usedBlocksFound);
      usedBlocksFound=false;
      System.out.println("Compacting");
      assertEquals(2,store.getStorefilesCount());
      store.triggerMajorCompaction();
      region.compact(true);
      waitForStoreFileCount(store,1,10000);
      assertEquals(1,store.getStorefilesCount());
      iterator=cache.iterator();
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
        }
      }
      assertTrue("Blocks with non zero ref count should be found ",usedBlocksFound);
      compactionLatch.countDown();
      latch.countDown();
      for (      ScanThread thread : scanThreads) {
        thread.join();
      }
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      Result r=table.get(new Get(ROW));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),data));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER2),data2));
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testBlockEvictionAfterHBASE13082WithCompactionAndFlush() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      compactionLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserverWrapper.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER,data);
      table.put(put);
      assertTrue(Bytes.equals(table.get(new Get(ROW)).value(),data));
      region.flush(true);
      int refCount=0;
      byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      byte[] data2=Bytes.add(data,data);
      put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      System.out.println("Flushing cache");
      region.flush(true);
      Iterator<CachedBlock> iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      ScanThread[] scanThreads=initiateScan(table,false);
      Thread.sleep(100);
      iterator=cache.iterator();
      boolean usedBlocksFound=false;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
        }
      }
      QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
      data2=Bytes.add(data,data);
      put=new Put(ROW1);
      put.addColumn(FAMILY,QUALIFIER2,data2);
      table.put(put);
      System.out.println("Flushing cache");
      region.flush(true);
      assertTrue("Blocks with non zero ref count should be found ",usedBlocksFound);
      usedBlocksFound=false;
      System.out.println("Compacting");
      assertEquals(3,store.getStorefilesCount());
      store.triggerMajorCompaction();
      region.compact(true);
      waitForStoreFileCount(store,1,10000);
      assertEquals(1,store.getStorefilesCount());
      iterator=cache.iterator();
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
        }
      }
      assertTrue("Blocks with non zero ref count should be found ",usedBlocksFound);
      compactionLatch.countDown();
      latch.countDown();
      for (      ScanThread thread : scanThreads) {
        thread.join();
      }
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
      Result r=table.get(new Get(ROW));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),data));
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER2),data2));
      iterator=cache.iterator();
      iterateBlockCache(cache,iterator);
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  @Test public void testScanWithException() throws IOException, InterruptedException {
    Table table=null;
    try {
      latch=new CountDownLatch(1);
      exceptionLatch=new CountDownLatch(1);
      final TableName tableName=TableName.valueOf(name.getMethodName());
      table=TEST_UTIL.createTable(tableName,FAMILIES_1,1,1024,CustomInnerRegionObserverWrapper.class.getName());
      RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName);
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      HRegion region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getRegion(regionName);
      HStore store=region.getStores().iterator().next();
      CacheConfig cacheConf=store.getCacheConfig();
      cacheConf.setCacheDataOnWrite(true);
      cacheConf.setEvictOnClose(true);
      BlockCache cache=cacheConf.getBlockCache();
      insertData(table);
      System.out.println("Flushing cache");
      region.flush(true);
      CustomInnerRegionObserver.throwException.set(true);
      ScanThread[] scanThreads=initiateScan(table,false);
      Thread.sleep(100);
      Iterator<CachedBlock> iterator=cache.iterator();
      boolean usedBlocksFound=false;
      int refCount=0;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
        }
      }
      assertTrue(usedBlocksFound);
      exceptionLatch.countDown();
      CustomInnerRegionObserver.getCdl().get().countDown();
      for (      ScanThread thread : scanThreads) {
        thread.join();
      }
      iterator=cache.iterator();
      usedBlocksFound=false;
      refCount=0;
      while (iterator.hasNext()) {
        CachedBlock next=iterator.next();
        BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
        if (cache instanceof BucketCache) {
          refCount=((BucketCache)cache).getRefCount(cacheKey);
        }
 else         if (cache instanceof CombinedBlockCache) {
          refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
        }
 else {
          continue;
        }
        if (refCount != 0) {
          assertEquals(NO_OF_THREADS,refCount);
          usedBlocksFound=true;
        }
      }
      assertFalse(usedBlocksFound);
      assertEquals(0,refCount);
    }
  finally {
      if (table != null) {
        table.close();
      }
    }
  }
  private void iterateBlockCache(  BlockCache cache,  Iterator<CachedBlock> iterator){
    int refCount;
    while (iterator.hasNext()) {
      CachedBlock next=iterator.next();
      BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
      if (cache instanceof BucketCache) {
        refCount=((BucketCache)cache).getRefCount(cacheKey);
      }
 else       if (cache instanceof CombinedBlockCache) {
        refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
      }
 else {
        continue;
      }
      assertEquals(0,refCount);
    }
  }
  private void insertData(  Table table) throws IOException {
    Put put=new Put(ROW);
    put.addColumn(FAMILY,QUALIFIER,data);
    table.put(put);
    put=new Put(ROW1);
    put.addColumn(FAMILY,QUALIFIER,data);
    table.put(put);
    byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
    put=new Put(ROW);
    put.addColumn(FAMILY,QUALIFIER2,data2);
    table.put(put);
  }
  private ScanThread[] initiateScan(  Table table,  boolean reverse) throws IOException, InterruptedException {
    ScanThread[] scanThreads=new ScanThread[NO_OF_THREADS];
    for (int i=0; i < NO_OF_THREADS; i++) {
      scanThreads[i]=new ScanThread(table,reverse);
    }
    for (    ScanThread thread : scanThreads) {
      thread.start();
    }
    return scanThreads;
  }
  private GetThread[] initiateGet(  Table table,  boolean tracker,  boolean multipleCFs) throws IOException, InterruptedException {
    GetThread[] getThreads=new GetThread[NO_OF_THREADS];
    for (int i=0; i < NO_OF_THREADS; i++) {
      getThreads[i]=new GetThread(table,tracker,multipleCFs);
    }
    for (    GetThread thread : getThreads) {
      thread.start();
    }
    return getThreads;
  }
  private MultiGetThread[] initiateMultiGet(  Table table) throws IOException, InterruptedException {
    MultiGetThread[] multiGetThreads=new MultiGetThread[NO_OF_THREADS];
    for (int i=0; i < NO_OF_THREADS; i++) {
      multiGetThreads[i]=new MultiGetThread(table);
    }
    for (    MultiGetThread thread : multiGetThreads) {
      thread.start();
    }
    return multiGetThreads;
  }
  private void checkForBlockEviction(  BlockCache cache,  boolean getClosed,  boolean expectOnlyZero) throws InterruptedException {
    int counter=NO_OF_THREADS;
    if (CustomInnerRegionObserver.waitForGets.get()) {
      counter=counter - 1;
      while (CustomInnerRegionObserver.countOfGets.get() < NO_OF_THREADS) {
        Thread.sleep(100);
      }
    }
 else {
      while (CustomInnerRegionObserver.countOfNext.get() < NO_OF_THREADS) {
        Thread.sleep(100);
      }
    }
    Iterator<CachedBlock> iterator=cache.iterator();
    int refCount=0;
    while (iterator.hasNext()) {
      CachedBlock next=iterator.next();
      BlockCacheKey cacheKey=new BlockCacheKey(next.getFilename(),next.getOffset());
      if (cache instanceof BucketCache) {
        refCount=((BucketCache)cache).getRefCount(cacheKey);
      }
 else       if (cache instanceof CombinedBlockCache) {
        refCount=((CombinedBlockCache)cache).getRefCount(cacheKey);
      }
 else {
        continue;
      }
      System.out.println(" the refcount is " + refCount + " block is "+ cacheKey);
      if (CustomInnerRegionObserver.waitForGets.get()) {
        if (expectOnlyZero) {
          assertTrue(refCount == 0);
        }
        if (refCount != 0) {
          if (getClosed) {
            assertEquals(refCount,CustomInnerRegionObserver.countOfGets.get());
          }
 else {
            assertEquals(refCount,CustomInnerRegionObserver.countOfGets.get() + (NO_OF_THREADS));
          }
        }
      }
 else {
        if (expectOnlyZero) {
          assertTrue(refCount == 0);
        }
        if (refCount != 0) {
          if (getLatch == null) {
            assertEquals(refCount,CustomInnerRegionObserver.countOfNext.get());
          }
 else {
            assertEquals(refCount,CustomInnerRegionObserver.countOfNext.get() + (NO_OF_THREADS));
          }
        }
      }
    }
    CustomInnerRegionObserver.getCdl().get().countDown();
  }
private static class MultiGetThread extends Thread {
    private final Table table;
    private final List<Get> gets=new ArrayList<>();
    public MultiGetThread(    Table table){
      this.table=table;
    }
    @Override public void run(){
      gets.add(new Get(ROW));
      gets.add(new Get(ROW1));
      try {
        CustomInnerRegionObserver.getCdl().set(latch);
        Result[] r=table.get(gets);
        assertTrue(Bytes.equals(r[0].getRow(),ROW));
        assertTrue(Bytes.equals(r[1].getRow(),ROW1));
      }
 catch (      IOException e) {
      }
    }
  }
private static class GetThread extends Thread {
    private final Table table;
    private final boolean tracker;
    private final boolean multipleCFs;
    public GetThread(    Table table,    boolean tracker,    boolean multipleCFs){
      this.table=table;
      this.tracker=tracker;
      this.multipleCFs=multipleCFs;
    }
    @Override public void run(){
      try {
        initiateGet(table);
      }
 catch (      IOException e) {
      }
    }
    private void initiateGet(    Table table) throws IOException {
      Get get=new Get(ROW);
      if (tracker) {
        if (!multipleCFs) {
          get.addColumn(FAMILY,Bytes.toBytes("testQualifier" + 3));
          get.addColumn(FAMILY,Bytes.toBytes("testQualifier" + 8));
          get.addColumn(FAMILY,Bytes.toBytes("testQualifier" + 9));
          get.addColumn(FAMILY,Bytes.toBytes("testQualifier" + 900));
        }
 else {
          get.addColumn(Bytes.toBytes("testFamily" + 3),Bytes.toBytes("testQualifier" + 3));
          get.addColumn(Bytes.toBytes("testFamily" + 8),Bytes.toBytes("testQualifier" + 8));
          get.addColumn(Bytes.toBytes("testFamily" + 9),Bytes.toBytes("testQualifier" + 9));
          get.addColumn(Bytes.toBytes("testFamily" + 9),Bytes.toBytes("testQualifier" + 900));
        }
      }
      CustomInnerRegionObserver.getCdl().set(latch);
      Result r=table.get(get);
      System.out.println(r);
      if (!tracker) {
        assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),data));
        assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER2),data2));
      }
 else {
        if (!multipleCFs) {
          assertTrue(Bytes.equals(r.getValue(FAMILY,Bytes.toBytes("testQualifier" + 3)),data2));
          assertTrue(Bytes.equals(r.getValue(FAMILY,Bytes.toBytes("testQualifier" + 8)),data2));
          assertTrue(Bytes.equals(r.getValue(FAMILY,Bytes.toBytes("testQualifier" + 9)),data2));
        }
 else {
          assertTrue(Bytes.equals(r.getValue(Bytes.toBytes("testFamily" + 3),Bytes.toBytes("testQualifier" + 3)),data2));
          assertTrue(Bytes.equals(r.getValue(Bytes.toBytes("testFamily" + 8),Bytes.toBytes("testQualifier" + 8)),data2));
          assertTrue(Bytes.equals(r.getValue(Bytes.toBytes("testFamily" + 9),Bytes.toBytes("testQualifier" + 9)),data2));
        }
      }
    }
  }
private static class ScanThread extends Thread {
    private final Table table;
    private final boolean reverse;
    public ScanThread(    Table table,    boolean reverse){
      this.table=table;
      this.reverse=reverse;
    }
    @Override public void run(){
      try {
        initiateScan(table);
      }
 catch (      IOException e) {
      }
    }
    private void initiateScan(    Table table) throws IOException {
      Scan scan=new Scan();
      if (reverse) {
        scan.setReversed(true);
      }
      CustomInnerRegionObserver.getCdl().set(latch);
      ResultScanner resScanner=table.getScanner(scan);
      int i=(reverse ? ROWS.length - 1 : 0);
      boolean resultFound=false;
      for (      Result result : resScanner) {
        resultFound=true;
        System.out.println(result);
        if (!reverse) {
          assertTrue(Bytes.equals(result.getRow(),ROWS[i]));
          i++;
        }
 else {
          assertTrue(Bytes.equals(result.getRow(),ROWS[i]));
          i--;
        }
      }
      assertTrue(resultFound);
    }
  }
  private void waitForStoreFileCount(  HStore store,  int count,  int timeout) throws InterruptedException {
    long start=System.currentTimeMillis();
    while (start + timeout > System.currentTimeMillis() && store.getStorefilesCount() != count) {
      Thread.sleep(100);
    }
    System.out.println("start=" + start + ", now="+ System.currentTimeMillis()+ ", cur="+ store.getStorefilesCount());
    assertEquals(count,store.getStorefilesCount());
  }
private static class CustomScanner implements RegionScanner {
    private RegionScanner delegate;
    public CustomScanner(    RegionScanner delegate){
      this.delegate=delegate;
    }
    @Override public boolean next(    List<Cell> results) throws IOException {
      return delegate.next(results);
    }
    @Override public boolean next(    List<Cell> result,    ScannerContext scannerContext) throws IOException {
      return delegate.next(result,scannerContext);
    }
    @Override public boolean nextRaw(    List<Cell> result) throws IOException {
      return delegate.nextRaw(result);
    }
    @Override public boolean nextRaw(    List<Cell> result,    ScannerContext context) throws IOException {
      boolean nextRaw=delegate.nextRaw(result,context);
      if (compactionLatch != null && compactionLatch.getCount() > 0) {
        try {
          compactionLatch.await();
        }
 catch (        InterruptedException ie) {
        }
      }
      if (CustomInnerRegionObserver.throwException.get()) {
        if (exceptionLatch.getCount() > 0) {
          try {
            exceptionLatch.await();
          }
 catch (          InterruptedException e) {
          }
          throw new IOException("throw exception");
        }
      }
      return nextRaw;
    }
    @Override public void close() throws IOException {
      delegate.close();
    }
    @Override public RegionInfo getRegionInfo(){
      return delegate.getRegionInfo();
    }
    @Override public boolean isFilterDone() throws IOException {
      return delegate.isFilterDone();
    }
    @Override public boolean reseek(    byte[] row) throws IOException {
      return false;
    }
    @Override public long getMaxResultSize(){
      return delegate.getMaxResultSize();
    }
    @Override public long getMvccReadPoint(){
      return delegate.getMvccReadPoint();
    }
    @Override public int getBatch(){
      return delegate.getBatch();
    }
  }
public static class CustomInnerRegionObserverWrapper extends CustomInnerRegionObserver {
    @Override public RegionScanner postScannerOpen(    ObserverContext<RegionCoprocessorEnvironment> e,    Scan scan,    RegionScanner s) throws IOException {
      return new CustomScanner(s);
    }
  }
public static class CustomInnerRegionObserver implements RegionCoprocessor, RegionObserver {
    static final AtomicLong sleepTime=new AtomicLong(0);
    static final AtomicBoolean slowDownNext=new AtomicBoolean(false);
    static final AtomicInteger countOfNext=new AtomicInteger(0);
    static final AtomicInteger countOfGets=new AtomicInteger(0);
    static final AtomicBoolean waitForGets=new AtomicBoolean(false);
    static final AtomicBoolean throwException=new AtomicBoolean(false);
    private static final AtomicReference<CountDownLatch> cdl=new AtomicReference<>(new CountDownLatch(0));
    @Override public Optional<RegionObserver> getRegionObserver(){
      return Optional.of(this);
    }
    @Override public boolean postScannerNext(    ObserverContext<RegionCoprocessorEnvironment> e,    InternalScanner s,    List<Result> results,    int limit,    boolean hasMore) throws IOException {
      slowdownCode(e,false);
      if (getLatch != null && getLatch.getCount() > 0) {
        try {
          getLatch.await();
        }
 catch (        InterruptedException e1) {
        }
      }
      return hasMore;
    }
    @Override public void postGetOp(    ObserverContext<RegionCoprocessorEnvironment> e,    Get get,    List<Cell> results) throws IOException {
      slowdownCode(e,true);
    }
    public static AtomicReference<CountDownLatch> getCdl(){
      return cdl;
    }
    private void slowdownCode(    final ObserverContext<RegionCoprocessorEnvironment> e,    boolean isGet){
      CountDownLatch latch=getCdl().get();
      try {
        System.out.println(latch.getCount() + " is the count " + isGet);
        if (latch.getCount() > 0) {
          if (isGet) {
            countOfGets.incrementAndGet();
          }
 else {
            countOfNext.incrementAndGet();
          }
          LOG.info("Waiting for the counterCountDownLatch");
          latch.await(2,TimeUnit.MINUTES);
          if (latch.getCount() > 0) {
            throw new RuntimeException("Can't wait more");
          }
        }
      }
 catch (      InterruptedException e1) {
        LOG.error(e1.toString(),e1);
      }
    }
  }
}
