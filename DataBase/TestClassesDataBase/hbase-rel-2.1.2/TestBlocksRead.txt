@Category({RegionServerTests.class,MediumTests.class}) public class TestBlocksRead {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestBlocksRead.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestBlocksRead.class);
  @Rule public TestName testName=new TestName();
  static final BloomType[] BLOOM_TYPE=new BloomType[]{BloomType.ROWCOL,BloomType.ROW,BloomType.NONE};
  private static BlockCache blockCache;
  HRegion region=null;
  private static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private final String DIR=TEST_UTIL.getDataTestDir("TestBlocksRead").toString();
  private Configuration conf=TEST_UTIL.getConfiguration();
  @BeforeClass public static void setUp() throws Exception {
    TEST_UTIL.getConfiguration().setInt("hbase.hstore.compactionThreshold",10000);
    CacheConfig.instantiateBlockCache(TEST_UTIL.getConfiguration());
  }
  @AfterClass public static void tearDown() throws Exception {
    EnvironmentEdgeManagerTestHelper.reset();
  }
  /** 
 * Callers must afterward call  {@link HBaseTestingUtility#closeRegionAndWAL(HRegion)}
 * @param tableName
 * @param callingMethod
 * @param conf
 * @param family
 * @throws IOException
 * @return created and initialized region.
 */
  private HRegion initHRegion(  byte[] tableName,  String callingMethod,  Configuration conf,  String family) throws IOException {
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(tableName));
    HColumnDescriptor familyDesc;
    for (int i=0; i < BLOOM_TYPE.length; i++) {
      BloomType bloomType=BLOOM_TYPE[i];
      familyDesc=new HColumnDescriptor(family + "_" + bloomType).setBlocksize(1).setBloomFilterType(BLOOM_TYPE[i]);
      htd.addFamily(familyDesc);
    }
    HRegionInfo info=new HRegionInfo(htd.getTableName(),null,null,false);
    Path path=new Path(DIR + callingMethod);
    HRegion r=HBaseTestingUtility.createRegionAndWAL(info,path,conf,htd);
    blockCache=new CacheConfig(conf).getBlockCache();
    return r;
  }
  private void putData(  String family,  String row,  String col,  long version) throws IOException {
    for (int i=0; i < BLOOM_TYPE.length; i++) {
      putData(Bytes.toBytes(family + "_" + BLOOM_TYPE[i]),row,col,version,version);
    }
  }
  private static byte[] genValue(  String row,  String col,  long version){
    return Bytes.toBytes("Value:" + row + "#"+ col+ "#"+ version);
  }
  private void putData(  byte[] cf,  String row,  String col,  long versionStart,  long versionEnd) throws IOException {
    byte columnBytes[]=Bytes.toBytes(col);
    Put put=new Put(Bytes.toBytes(row));
    put.setDurability(Durability.SKIP_WAL);
    for (long version=versionStart; version <= versionEnd; version++) {
      put.addColumn(cf,columnBytes,version,genValue(row,col,version));
    }
    region.put(put);
  }
  private Cell[] getData(  String family,  String row,  List<String> columns,  int expBlocks) throws IOException {
    return getData(family,row,columns,expBlocks,expBlocks,expBlocks);
  }
  private Cell[] getData(  String family,  String row,  List<String> columns,  int expBlocksRowCol,  int expBlocksRow,  int expBlocksNone) throws IOException {
    int[] expBlocks=new int[]{expBlocksRowCol,expBlocksRow,expBlocksNone};
    Cell[] kvs=null;
    for (int i=0; i < BLOOM_TYPE.length; i++) {
      BloomType bloomType=BLOOM_TYPE[i];
      byte[] cf=Bytes.toBytes(family + "_" + bloomType);
      long blocksStart=getBlkAccessCount(cf);
      Get get=new Get(Bytes.toBytes(row));
      for (      String column : columns) {
        get.addColumn(cf,Bytes.toBytes(column));
      }
      kvs=region.get(get).rawCells();
      long blocksEnd=getBlkAccessCount(cf);
      if (expBlocks[i] != -1) {
        assertEquals("Blocks Read Check for Bloom: " + bloomType,expBlocks[i],blocksEnd - blocksStart);
      }
      System.out.println("Blocks Read for Bloom: " + bloomType + " = "+ (blocksEnd - blocksStart)+ "Expected = "+ expBlocks[i]);
    }
    return kvs;
  }
  private Cell[] getData(  String family,  String row,  String column,  int expBlocks) throws IOException {
    return getData(family,row,Arrays.asList(column),expBlocks,expBlocks,expBlocks);
  }
  private Cell[] getData(  String family,  String row,  String column,  int expBlocksRowCol,  int expBlocksRow,  int expBlocksNone) throws IOException {
    return getData(family,row,Arrays.asList(column),expBlocksRowCol,expBlocksRow,expBlocksNone);
  }
  private void deleteFamily(  String family,  String row,  long version) throws IOException {
    Delete del=new Delete(Bytes.toBytes(row));
    del.addFamily(Bytes.toBytes(family + "_ROWCOL"),version);
    del.addFamily(Bytes.toBytes(family + "_ROW"),version);
    del.addFamily(Bytes.toBytes(family + "_NONE"),version);
    region.delete(del);
  }
  private static void verifyData(  Cell kv,  String expectedRow,  String expectedCol,  long expectedVersion){
    assertTrue("RowCheck",CellUtil.matchingRows(kv,Bytes.toBytes(expectedRow)));
    assertTrue("ColumnCheck",CellUtil.matchingQualifier(kv,Bytes.toBytes(expectedCol)));
    assertEquals("TSCheck",expectedVersion,kv.getTimestamp());
    assertTrue("ValueCheck",CellUtil.matchingValue(kv,genValue(expectedRow,expectedCol,expectedVersion)));
  }
  private static long getBlkAccessCount(  byte[] cf){
    return HFile.DATABLOCK_READ_COUNT.sum();
  }
  private static long getBlkCount(){
    return blockCache.getBlockCount();
  }
  /** 
 * Test # of blocks read for some simple seek cases.
 * @throws Exception
 */
  @Test public void testBlocksRead() throws Exception {
    byte[] TABLE=Bytes.toBytes("testBlocksRead");
    String FAMILY="cf1";
    Cell kvs[];
    this.region=initHRegion(TABLE,testName.getMethodName(),conf,FAMILY);
    try {
      putData(FAMILY,"row","col1",1);
      putData(FAMILY,"row","col2",2);
      putData(FAMILY,"row","col3",3);
      putData(FAMILY,"row","col4",4);
      putData(FAMILY,"row","col5",5);
      putData(FAMILY,"row","col6",6);
      putData(FAMILY,"row","col7",7);
      region.flush(true);
      kvs=getData(FAMILY,"row","col1",1);
      assertEquals(1,kvs.length);
      verifyData(kvs[0],"row","col1",1);
      kvs=getData(FAMILY,"row",Arrays.asList("col1","col2"),2);
      assertEquals(2,kvs.length);
      verifyData(kvs[0],"row","col1",1);
      verifyData(kvs[1],"row","col2",2);
      kvs=getData(FAMILY,"row",Arrays.asList("col2","col3"),2);
      assertEquals(2,kvs.length);
      verifyData(kvs[0],"row","col2",2);
      verifyData(kvs[1],"row","col3",3);
      kvs=getData(FAMILY,"row",Arrays.asList("col5"),1);
      assertEquals(1,kvs.length);
      verifyData(kvs[0],"row","col5",5);
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
      this.region=null;
    }
  }
  /** 
 * Test # of blocks read (targeted at some of the cases Lazy Seek optimizes).
 * @throws Exception
 */
  @Test public void testLazySeekBlocksRead() throws Exception {
    byte[] TABLE=Bytes.toBytes("testLazySeekBlocksRead");
    String FAMILY="cf1";
    Cell kvs[];
    this.region=initHRegion(TABLE,testName.getMethodName(),conf,FAMILY);
    try {
      putData(FAMILY,"row","col1",1);
      putData(FAMILY,"row","col2",2);
      region.flush(true);
      putData(FAMILY,"row","col1",3);
      putData(FAMILY,"row","col2",4);
      region.flush(true);
      kvs=getData(FAMILY,"row",Arrays.asList("col1"),1);
      assertEquals(1,kvs.length);
      verifyData(kvs[0],"row","col1",3);
      kvs=getData(FAMILY,"row",Arrays.asList("col1","col2"),2);
      assertEquals(2,kvs.length);
      verifyData(kvs[0],"row","col1",3);
      verifyData(kvs[1],"row","col2",4);
      putData(FAMILY,"row","col3",5);
      region.flush(true);
      kvs=getData(FAMILY,"row","col3",1);
      assertEquals(1,kvs.length);
      verifyData(kvs[0],"row","col3",5);
      kvs=getData(FAMILY,"row",Arrays.asList("col1"),1,2,2);
      assertEquals(1,kvs.length);
      verifyData(kvs[0],"row","col1",3);
      deleteFamily(FAMILY,"row",6);
      region.flush(true);
      kvs=getData(FAMILY,"row","col1",2,3,3);
      assertEquals(0,kvs.length);
      kvs=getData(FAMILY,"row","col2",2,3,3);
      assertEquals(0,kvs.length);
      kvs=getData(FAMILY,"row","col3",2);
      assertEquals(0,kvs.length);
      kvs=getData(FAMILY,"row",Arrays.asList("col1","col2","col3"),4);
      assertEquals(0,kvs.length);
      deleteFamily(FAMILY,"row",10);
      region.flush(true);
      putData(FAMILY,"row","col1",7);
      putData(FAMILY,"row","col2",8);
      putData(FAMILY,"row","col3",9);
      region.flush(true);
      kvs=getData(FAMILY,"row",Arrays.asList("col1","col2","col3"),6,7,7);
      assertEquals(0,kvs.length);
      putData(FAMILY,"row","col1",11);
      putData(FAMILY,"row","col2",12);
      putData(FAMILY,"row","col3",13);
      region.flush(true);
      kvs=getData(FAMILY,"row",Arrays.asList("col1","col2","col3"),8,9,9);
      assertEquals(3,kvs.length);
      verifyData(kvs[0],"row","col1",11);
      verifyData(kvs[1],"row","col2",12);
      verifyData(kvs[2],"row","col3",13);
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
      this.region=null;
    }
  }
  /** 
 * Test # of blocks read to ensure disabling cache-fill on Scan works.
 * @throws Exception
 */
  @Test public void testBlocksStoredWhenCachingDisabled() throws Exception {
    byte[] TABLE=Bytes.toBytes("testBlocksReadWhenCachingDisabled");
    String FAMILY="cf1";
    this.region=initHRegion(TABLE,testName.getMethodName(),conf,FAMILY);
    try {
      putData(FAMILY,"row","col1",1);
      putData(FAMILY,"row","col2",2);
      region.flush(true);
      long blocksStart=getBlkCount();
      Scan scan=new Scan();
      scan.setCacheBlocks(false);
      RegionScanner rs=region.getScanner(scan);
      List<Cell> result=new ArrayList<>(2);
      rs.next(result);
      assertEquals(2 * BLOOM_TYPE.length,result.size());
      rs.close();
      long blocksEnd=getBlkCount();
      assertEquals(blocksStart,blocksEnd);
      blocksStart=blocksEnd;
      scan.setCacheBlocks(true);
      rs=region.getScanner(scan);
      result=new ArrayList<>(2);
      rs.next(result);
      assertEquals(2 * BLOOM_TYPE.length,result.size());
      rs.close();
      blocksEnd=getBlkCount();
      assertEquals(2 * BLOOM_TYPE.length,blocksEnd - blocksStart);
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
      this.region=null;
    }
  }
  @Test public void testLazySeekBlocksReadWithDelete() throws Exception {
    byte[] TABLE=Bytes.toBytes("testLazySeekBlocksReadWithDelete");
    String FAMILY="cf1";
    Cell kvs[];
    this.region=initHRegion(TABLE,testName.getMethodName(),conf,FAMILY);
    try {
      deleteFamily(FAMILY,"row",200);
      for (int i=0; i < 100; i++) {
        putData(FAMILY,"row","col" + i,i);
      }
      putData(FAMILY,"row","col99",201);
      region.flush(true);
      kvs=getData(FAMILY,"row",Arrays.asList("col0"),2);
      assertEquals(0,kvs.length);
      kvs=getData(FAMILY,"row",Arrays.asList("col99"),2);
      assertEquals(1,kvs.length);
      verifyData(kvs[0],"row","col99",201);
    }
  finally {
      HBaseTestingUtility.closeRegionAndWAL(this.region);
      this.region=null;
    }
  }
}
