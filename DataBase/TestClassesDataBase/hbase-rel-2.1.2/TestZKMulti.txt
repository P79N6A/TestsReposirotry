/** 
 * Test ZooKeeper multi-update functionality
 */
@Category({ZKTests.class,MediumTests.class}) public class TestZKMulti {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestZKMulti.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestZKMulti.class);
  private final static HBaseZKTestingUtility TEST_UTIL=new HBaseZKTestingUtility();
  private static ZKWatcher zkw=null;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    TEST_UTIL.startMiniZKCluster();
    Configuration conf=TEST_UTIL.getConfiguration();
    Abortable abortable=new Abortable(){
      @Override public void abort(      String why,      Throwable e){
        LOG.info(why,e);
      }
      @Override public boolean isAborted(){
        return false;
      }
    }
;
    zkw=new ZKWatcher(conf,"TestZKMulti",abortable,true);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniZKCluster();
  }
  @Test public void testSimpleMulti() throws Exception {
    ZKUtil.multiOrSequential(zkw,null,false);
    ZKUtil.multiOrSequential(zkw,new LinkedList<>(),false);
    String path=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testSimpleMulti");
    LinkedList<ZKUtilOp> singleCreate=new LinkedList<>();
    singleCreate.add(ZKUtilOp.createAndFailSilent(path,new byte[0]));
    ZKUtil.multiOrSequential(zkw,singleCreate,false);
    assertTrue(ZKUtil.checkExists(zkw,path) != -1);
    LinkedList<ZKUtilOp> singleSetData=new LinkedList<>();
    byte[] data=Bytes.toBytes("foobar");
    singleSetData.add(ZKUtilOp.setData(path,data));
    ZKUtil.multiOrSequential(zkw,singleSetData,false);
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path),data));
    LinkedList<ZKUtilOp> singleDelete=new LinkedList<>();
    singleDelete.add(ZKUtilOp.deleteNodeFailSilent(path));
    ZKUtil.multiOrSequential(zkw,singleDelete,false);
    assertTrue(ZKUtil.checkExists(zkw,path) == -1);
  }
  @Test public void testComplexMulti() throws Exception {
    String path1=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testComplexMulti1");
    String path2=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testComplexMulti2");
    String path3=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testComplexMulti3");
    String path4=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testComplexMulti4");
    String path5=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testComplexMulti5");
    String path6=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testComplexMulti6");
    LinkedList<ZKUtilOp> create4Nodes=new LinkedList<>();
    create4Nodes.add(ZKUtilOp.createAndFailSilent(path1,Bytes.toBytes(path1)));
    create4Nodes.add(ZKUtilOp.createAndFailSilent(path2,Bytes.toBytes(path2)));
    create4Nodes.add(ZKUtilOp.createAndFailSilent(path3,Bytes.toBytes(path3)));
    create4Nodes.add(ZKUtilOp.createAndFailSilent(path4,Bytes.toBytes(path4)));
    ZKUtil.multiOrSequential(zkw,create4Nodes,false);
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path1),Bytes.toBytes(path1)));
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path2),Bytes.toBytes(path2)));
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path3),Bytes.toBytes(path3)));
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path4),Bytes.toBytes(path4)));
    LinkedList<ZKUtilOp> ops=new LinkedList<>();
    ops.add(ZKUtilOp.setData(path1,Bytes.add(Bytes.toBytes(path1),Bytes.toBytes(path1))));
    ops.add(ZKUtilOp.setData(path2,Bytes.add(Bytes.toBytes(path2),Bytes.toBytes(path2))));
    ops.add(ZKUtilOp.deleteNodeFailSilent(path3));
    ops.add(ZKUtilOp.deleteNodeFailSilent(path4));
    ops.add(ZKUtilOp.createAndFailSilent(path5,Bytes.toBytes(path5)));
    ops.add(ZKUtilOp.createAndFailSilent(path6,Bytes.toBytes(path6)));
    ZKUtil.multiOrSequential(zkw,ops,false);
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path1),Bytes.add(Bytes.toBytes(path1),Bytes.toBytes(path1))));
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path2),Bytes.add(Bytes.toBytes(path2),Bytes.toBytes(path2))));
    assertTrue(ZKUtil.checkExists(zkw,path3) == -1);
    assertTrue(ZKUtil.checkExists(zkw,path4) == -1);
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path5),Bytes.toBytes(path5)));
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path6),Bytes.toBytes(path6)));
  }
  @Test public void testSingleFailure() throws Exception {
    boolean caughtNoNode=false;
    String path=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testSingleFailureZ");
    LinkedList<ZKUtilOp> ops=new LinkedList<>();
    ops.add(ZKUtilOp.deleteNodeFailSilent(path));
    try {
      ZKUtil.multiOrSequential(zkw,ops,false);
    }
 catch (    KeeperException.NoNodeException nne) {
      caughtNoNode=true;
    }
    assertTrue(caughtNoNode);
    caughtNoNode=false;
    ops=new LinkedList<>();
    ops.add(ZKUtilOp.setData(path,Bytes.toBytes(path)));
    try {
      ZKUtil.multiOrSequential(zkw,ops,false);
    }
 catch (    KeeperException.NoNodeException nne) {
      caughtNoNode=true;
    }
    assertTrue(caughtNoNode);
    boolean caughtNodeExists=false;
    ops=new LinkedList<>();
    ops.add(ZKUtilOp.createAndFailSilent(path,Bytes.toBytes(path)));
    ZKUtil.multiOrSequential(zkw,ops,false);
    try {
      ZKUtil.multiOrSequential(zkw,ops,false);
    }
 catch (    KeeperException.NodeExistsException nee) {
      caughtNodeExists=true;
    }
    assertTrue(caughtNodeExists);
  }
  @Test public void testSingleFailureInMulti() throws Exception {
    String pathA=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testSingleFailureInMultiA");
    String pathB=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testSingleFailureInMultiB");
    String pathC=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testSingleFailureInMultiC");
    LinkedList<ZKUtilOp> ops=new LinkedList<>();
    ops.add(ZKUtilOp.createAndFailSilent(pathA,Bytes.toBytes(pathA)));
    ops.add(ZKUtilOp.createAndFailSilent(pathB,Bytes.toBytes(pathB)));
    ops.add(ZKUtilOp.deleteNodeFailSilent(pathC));
    boolean caughtNoNode=false;
    try {
      ZKUtil.multiOrSequential(zkw,ops,false);
    }
 catch (    KeeperException.NoNodeException nne) {
      caughtNoNode=true;
    }
    assertTrue(caughtNoNode);
    assertTrue(ZKUtil.checkExists(zkw,pathA) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathB) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathC) == -1);
  }
  @Test public void testMultiFailure() throws Exception {
    String pathX=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testMultiFailureX");
    String pathY=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testMultiFailureY");
    String pathZ=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testMultiFailureZ");
    LinkedList<ZKUtilOp> ops=new LinkedList<>();
    ops.add(ZKUtilOp.createAndFailSilent(pathX,Bytes.toBytes(pathX)));
    ZKUtil.multiOrSequential(zkw,ops,false);
    String pathV=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testMultiFailureV");
    String pathW=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"testMultiFailureW");
    ops=new LinkedList<>();
    ops.add(ZKUtilOp.createAndFailSilent(pathX,Bytes.toBytes(pathX)));
    ops.add(ZKUtilOp.setData(pathY,Bytes.toBytes(pathY)));
    ops.add(ZKUtilOp.deleteNodeFailSilent(pathZ));
    ops.add(ZKUtilOp.createAndFailSilent(pathX,Bytes.toBytes(pathV)));
    ops.add(ZKUtilOp.createAndFailSilent(pathX,Bytes.toBytes(pathW)));
    boolean caughtNodeExists=false;
    try {
      ZKUtil.multiOrSequential(zkw,ops,false);
    }
 catch (    KeeperException.NodeExistsException nee) {
      caughtNodeExists=true;
    }
    assertTrue(caughtNodeExists);
    assertFalse(ZKUtil.checkExists(zkw,pathX) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathY) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathZ) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathW) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathV) == -1);
    ops=new LinkedList<>();
    ops.add(ZKUtilOp.setData(pathY,Bytes.toBytes(pathY)));
    ops.add(ZKUtilOp.createAndFailSilent(pathX,Bytes.toBytes(pathX)));
    boolean caughtNoNode=false;
    try {
      ZKUtil.multiOrSequential(zkw,ops,false);
    }
 catch (    KeeperException.NoNodeException nne) {
      caughtNoNode=true;
    }
    assertTrue(caughtNoNode);
    assertFalse(ZKUtil.checkExists(zkw,pathX) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathY) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathZ) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathW) == -1);
    assertTrue(ZKUtil.checkExists(zkw,pathV) == -1);
  }
  @Test public void testRunSequentialOnMultiFailure() throws Exception {
    String path1=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"runSequential1");
    String path2=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"runSequential2");
    String path3=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"runSequential3");
    String path4=ZNodePaths.joinZNode(zkw.getZNodePaths().baseZNode,"runSequential4");
    LinkedList<ZKUtilOp> ops=new LinkedList<>();
    ops.add(ZKUtilOp.createAndFailSilent(path1,Bytes.toBytes(path1)));
    ops.add(ZKUtilOp.createAndFailSilent(path2,Bytes.toBytes(path2)));
    ZKUtil.multiOrSequential(zkw,ops,false);
    ops=new LinkedList<>();
    ops.add(ZKUtilOp.setData(path1,Bytes.add(Bytes.toBytes(path1),Bytes.toBytes(path1))));
    ops.add(ZKUtilOp.deleteNodeFailSilent(path2));
    ops.add(ZKUtilOp.deleteNodeFailSilent(path3));
    ops.add(ZKUtilOp.createAndFailSilent(path4,Bytes.add(Bytes.toBytes(path4),Bytes.toBytes(path4))));
    ZKUtil.multiOrSequential(zkw,ops,true);
    assertTrue(Bytes.equals(ZKUtil.getData(zkw,path1),Bytes.add(Bytes.toBytes(path1),Bytes.toBytes(path1))));
    assertTrue(ZKUtil.checkExists(zkw,path2) == -1);
    assertTrue(ZKUtil.checkExists(zkw,path3) == -1);
    assertFalse(ZKUtil.checkExists(zkw,path4) == -1);
  }
  /** 
 * Verifies that for the given root node, it should delete all the child nodes recursively using multi-update api.
 */
  @Test public void testdeleteChildrenRecursivelyMulti() throws Exception {
    String parentZNode="/testRootMulti";
    createZNodeTree(parentZNode);
    ZKUtil.deleteChildrenRecursivelyMultiOrSequential(zkw,true,parentZNode);
    assertTrue("Wrongly deleted parent znode!",ZKUtil.checkExists(zkw,parentZNode) > -1);
    List<String> children=zkw.getRecoverableZooKeeper().getChildren(parentZNode,false);
    assertTrue("Failed to delete child znodes!",0 == children.size());
  }
  /** 
 * Verifies that for the given root node, it should delete all the nodes recursively using multi-update api.
 */
  @Test public void testDeleteNodeRecursivelyMulti() throws Exception {
    String parentZNode="/testdeleteNodeRecursivelyMulti";
    createZNodeTree(parentZNode);
    ZKUtil.deleteNodeRecursively(zkw,parentZNode);
    assertTrue("Parent znode should be deleted.",ZKUtil.checkExists(zkw,parentZNode) == -1);
  }
  @Test public void testDeleteNodeRecursivelyMultiOrSequential() throws Exception {
    String parentZNode1="/testdeleteNode1";
    String parentZNode2="/testdeleteNode2";
    String parentZNode3="/testdeleteNode3";
    createZNodeTree(parentZNode1);
    createZNodeTree(parentZNode2);
    createZNodeTree(parentZNode3);
    ZKUtil.deleteNodeRecursivelyMultiOrSequential(zkw,false,parentZNode1,parentZNode2,parentZNode3);
    assertTrue("Parent znode 1 should be deleted.",ZKUtil.checkExists(zkw,parentZNode1) == -1);
    assertTrue("Parent znode 2 should be deleted.",ZKUtil.checkExists(zkw,parentZNode2) == -1);
    assertTrue("Parent znode 3 should be deleted.",ZKUtil.checkExists(zkw,parentZNode3) == -1);
  }
  @Test public void testDeleteChildrenRecursivelyMultiOrSequential() throws Exception {
    String parentZNode1="/testdeleteChildren1";
    String parentZNode2="/testdeleteChildren2";
    String parentZNode3="/testdeleteChildren3";
    createZNodeTree(parentZNode1);
    createZNodeTree(parentZNode2);
    createZNodeTree(parentZNode3);
    ZKUtil.deleteChildrenRecursivelyMultiOrSequential(zkw,true,parentZNode1,parentZNode2,parentZNode3);
    assertTrue("Wrongly deleted parent znode 1!",ZKUtil.checkExists(zkw,parentZNode1) > -1);
    List<String> children=zkw.getRecoverableZooKeeper().getChildren(parentZNode1,false);
    assertTrue("Failed to delete child znodes of parent znode 1!",0 == children.size());
    assertTrue("Wrongly deleted parent znode 2!",ZKUtil.checkExists(zkw,parentZNode2) > -1);
    children=zkw.getRecoverableZooKeeper().getChildren(parentZNode2,false);
    assertTrue("Failed to delete child znodes of parent znode 1!",0 == children.size());
    assertTrue("Wrongly deleted parent znode 3!",ZKUtil.checkExists(zkw,parentZNode3) > -1);
    children=zkw.getRecoverableZooKeeper().getChildren(parentZNode3,false);
    assertTrue("Failed to delete child znodes of parent znode 1!",0 == children.size());
  }
  private void createZNodeTree(  String rootZNode) throws KeeperException, InterruptedException {
    List<Op> opList=new ArrayList<>();
    opList.add(Op.create(rootZNode,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT));
    int level=0;
    String parentZNode=rootZNode;
    while (level < 10) {
      parentZNode=parentZNode + "/" + level;
      opList.add(Op.create(parentZNode,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT));
      int elements=0;
      while (elements < level) {
        opList.add(Op.create(parentZNode + "/" + elements,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT));
        elements++;
      }
      level++;
    }
    zkw.getRecoverableZooKeeper().multi(opList);
  }
}
