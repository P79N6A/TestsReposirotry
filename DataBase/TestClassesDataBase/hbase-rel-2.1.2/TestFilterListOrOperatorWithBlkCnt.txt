@Category(MediumTests.class) public class TestFilterListOrOperatorWithBlkCnt {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestFilterListOrOperatorWithBlkCnt.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final Logger LOG=LoggerFactory.getLogger(TestFilterListOrOperatorWithBlkCnt.class);
  private byte[] family=Bytes.toBytes("family");
  private byte[] qf=Bytes.toBytes("qf");
  private byte[] value=Bytes.toBytes("val");
  private TableName tableName;
  private int numRows=10000;
  @Rule public TestName name=new TestName();
  /** 
 * @throws Exception
 */
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    long blkSize=4096;
    TEST_UTIL.getConfiguration().setLong("dfs.blocksize",blkSize);
    TEST_UTIL.getConfiguration().setLong("dfs.bytes-per-checksum",blkSize);
    TEST_UTIL.startMiniCluster();
  }
  /** 
 * @throws Exception
 */
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  private static long getBlkAccessCount(){
    return HFile.DATABLOCK_READ_COUNT.sum();
  }
  @Test public void testMultiRowRangeWithFilterListOrOperatorWithBlkCnt() throws IOException {
    tableName=TableName.valueOf(name.getMethodName());
    Table ht=TEST_UTIL.createTable(tableName,family,Integer.MAX_VALUE);
    generateRows(numRows,ht,family,qf,value);
    Scan scan=new Scan();
    scan.setMaxVersions();
    long blocksStart=getBlkAccessCount();
    List<RowRange> ranges1=new ArrayList<>();
    ranges1.add(new RowRange(Bytes.toBytes(10),true,Bytes.toBytes(15),false));
    ranges1.add(new RowRange(Bytes.toBytes(9980),true,Bytes.toBytes(9985),false));
    MultiRowRangeFilter filter1=new MultiRowRangeFilter(ranges1);
    List<RowRange> ranges2=new ArrayList<>();
    ranges2.add(new RowRange(Bytes.toBytes(15),true,Bytes.toBytes(20),false));
    ranges2.add(new RowRange(Bytes.toBytes(9985),true,Bytes.toBytes(9990),false));
    MultiRowRangeFilter filter2=new MultiRowRangeFilter(ranges2);
    FilterList filterList=new FilterList(FilterList.Operator.MUST_PASS_ONE);
    filterList.addFilter(filter1);
    filterList.addFilter(filter2);
    scan.setFilter(filterList);
    int resultsSize=getResultsSize(ht,scan);
    LOG.info("found " + resultsSize + " results");
    List<Cell> results1=getScanResult(Bytes.toBytes(10),Bytes.toBytes(20),ht);
    List<Cell> results2=getScanResult(Bytes.toBytes(9980),Bytes.toBytes(9990),ht);
    assertEquals(results1.size() + results2.size(),resultsSize);
    long blocksEnd=getBlkAccessCount();
    long diff=blocksEnd - blocksStart;
    LOG.info("Diff in number of blocks " + diff);
    assertEquals(4,diff);
    ht.close();
  }
  private void generateRows(  int numberOfRows,  Table ht,  byte[] family,  byte[] qf,  byte[] value) throws IOException {
    for (int i=0; i < numberOfRows; i++) {
      byte[] row=Bytes.toBytes(i);
      Put p=new Put(row);
      p.addColumn(family,qf,value);
      p.setDurability(Durability.SKIP_WAL);
      ht.put(p);
    }
    TEST_UTIL.flush();
  }
  private List<Cell> getScanResult(  byte[] startRow,  byte[] stopRow,  Table ht) throws IOException {
    Scan scan=new Scan();
    scan.setMaxVersions();
    if (!Bytes.toString(startRow).isEmpty()) {
      scan.setStartRow(startRow);
    }
    if (!Bytes.toString(stopRow).isEmpty()) {
      scan.setStopRow(stopRow);
    }
    ResultScanner scanner=ht.getScanner(scan);
    List<Cell> kvList=new ArrayList<>();
    Result r;
    while ((r=scanner.next()) != null) {
      for (      Cell kv : r.listCells()) {
        kvList.add(kv);
      }
    }
    return kvList;
  }
  private int getResultsSize(  Table ht,  Scan scan) throws IOException {
    ResultScanner scanner=ht.getScanner(scan);
    List<Cell> results=new ArrayList<>();
    Result r;
    while ((r=scanner.next()) != null) {
      for (      Cell kv : r.listCells()) {
        results.add(kv);
      }
    }
    return results.size();
  }
}
