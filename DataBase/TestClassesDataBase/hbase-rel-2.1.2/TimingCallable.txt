/** 
 * Base class for actions that need to record the time needed to recover from a failure.
 */
static abstract class TimingCallable implements Callable<TimingResult> {
  protected final Future<?> future;
  public TimingCallable(  Future<?> f){
    future=f;
  }
  @Override public TimingResult call() throws Exception {
    TimingResult result=new TimingResult();
    final int maxIterations=10;
    int numAfterDone=0;
    int resetCount=0;
    TraceUtil.addSampler(AlwaysSampler.INSTANCE);
    while (numAfterDone < maxIterations) {
      long start=System.nanoTime();
      Span span=null;
      try (TraceScope scope=TraceUtil.createTrace(getSpanName())){
        if (scope != null) {
          span=scope.getSpan();
        }
        boolean actionResult=doAction();
        if (actionResult && future.isDone()) {
          numAfterDone++;
        }
      }
 catch (      AccessDeniedException e) {
        throw e;
      }
catch (      CoprocessorException e) {
        throw e;
      }
catch (      FatalConnectionException e) {
        throw e;
      }
catch (      InvalidFamilyOperationException e) {
        throw e;
      }
catch (      NamespaceExistException e) {
        throw e;
      }
catch (      NamespaceNotFoundException e) {
        throw e;
      }
catch (      NoSuchColumnFamilyException e) {
        throw e;
      }
catch (      TableExistsException e) {
        throw e;
      }
catch (      TableNotFoundException e) {
        throw e;
      }
catch (      RetriesExhaustedException e) {
        throw e;
      }
catch (      Exception e) {
        resetCount++;
        if (resetCount < maxIterations) {
          LOG.info("Non-fatal exception while running " + this.toString() + ". Resetting loop counter",e);
          numAfterDone=0;
        }
 else {
          LOG.info("Too many unexpected Exceptions. Aborting.",e);
          throw e;
        }
      }
      result.addResult(System.nanoTime() - start,span);
    }
    return result;
  }
  protected abstract boolean doAction() throws Exception ;
  protected String getSpanName(){
    return this.getClass().getSimpleName();
  }
  @Override public String toString(){
    return this.getSpanName();
  }
}
