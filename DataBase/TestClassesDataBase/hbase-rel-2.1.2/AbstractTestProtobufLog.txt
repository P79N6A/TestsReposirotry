/** 
 * WAL tests that can be reused across providers.
 */
public abstract class AbstractTestProtobufLog<W extends Closeable> {
  protected final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  protected FileSystem fs;
  protected Path dir;
  protected WALFactory wals;
  @Rule public final TestName currentTest=new TestName();
  @Before public void setUp() throws Exception {
    fs=TEST_UTIL.getDFSCluster().getFileSystem();
    dir=new Path(TEST_UTIL.createRootDir(),currentTest.getMethodName());
    wals=new WALFactory(TEST_UTIL.getConfiguration(),currentTest.getMethodName());
  }
  @After public void tearDown() throws Exception {
    wals.close();
    FileStatus[] entries=fs.listStatus(new Path("/"));
    for (    FileStatus dir : entries) {
      fs.delete(dir.getPath(),true);
    }
  }
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    TEST_UTIL.getConfiguration().setInt("dfs.blocksize",1024 * 1024);
    TEST_UTIL.getConfiguration().setInt("dfs.namenode.heartbeat.recheck-interval",5000);
    TEST_UTIL.getConfiguration().setInt("dfs.heartbeat.interval",1);
    TEST_UTIL.getConfiguration().setInt("dfs.client.socket-timeout",5000);
    TEST_UTIL.getConfiguration().setInt("hbase.ipc.client.connect.max.retries",1);
    TEST_UTIL.getConfiguration().setInt("dfs.client.block.recovery.retries",1);
    TEST_UTIL.getConfiguration().setInt("hbase.ipc.client.connection.maxidletime",500);
    TEST_UTIL.getConfiguration().set(CoprocessorHost.WAL_COPROCESSOR_CONF_KEY,SampleRegionWALCoprocessor.class.getName());
    TEST_UTIL.startMiniDFSCluster(3);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  /** 
 * Reads the WAL with and without WALTrailer.
 * @throws IOException
 */
  @Test public void testWALTrailer() throws IOException {
    doRead(true);
    doRead(false);
  }
  /** 
 * Appends entries in the WAL and reads it.
 * @param withTrailer If 'withTrailer' is true, it calls a close on the WALwriter before readingso that a trailer is appended to the WAL. Otherwise, it starts reading after the sync call. This means that reader is not aware of the trailer. In this scenario, if the reader tries to read the trailer in its next() call, it returns false from ProtoBufLogReader.
 * @throws IOException
 */
  private void doRead(  boolean withTrailer) throws IOException {
    final int columnCount=5;
    final int recordCount=5;
    final TableName tableName=TableName.valueOf("tablename");
    final byte[] row=Bytes.toBytes("row");
    long timestamp=System.currentTimeMillis();
    Path path=new Path(dir,"tempwal");
    fs.delete(path,true);
    W writer=null;
    ProtobufLogReader reader=null;
    try {
      HRegionInfo hri=new HRegionInfo(tableName,HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW);
      HTableDescriptor htd=new HTableDescriptor(tableName);
      fs.mkdirs(dir);
      writer=createWriter(path);
      for (int i=0; i < recordCount; ++i) {
        WALKeyImpl key=new WALKeyImpl(hri.getEncodedNameAsBytes(),tableName,i,timestamp,HConstants.DEFAULT_CLUSTER_ID);
        WALEdit edit=new WALEdit();
        for (int j=0; j < columnCount; ++j) {
          if (i == 0) {
            htd.addFamily(new HColumnDescriptor("column" + j));
          }
          String value=i + "" + j;
          edit.add(new KeyValue(row,row,row,timestamp,Bytes.toBytes(value)));
        }
        append(writer,new WAL.Entry(key,edit));
      }
      sync(writer);
      if (withTrailer)       writer.close();
      reader=(ProtobufLogReader)wals.createReader(fs,path);
      if (withTrailer) {
        assertNotNull(reader.trailer);
      }
 else {
        assertNull(reader.trailer);
      }
      for (int i=0; i < recordCount; ++i) {
        WAL.Entry entry=reader.next();
        assertNotNull(entry);
        assertEquals(columnCount,entry.getEdit().size());
        assertArrayEquals(hri.getEncodedNameAsBytes(),entry.getKey().getEncodedRegionName());
        assertEquals(tableName,entry.getKey().getTableName());
        int idx=0;
        for (        Cell val : entry.getEdit().getCells()) {
          assertTrue(Bytes.equals(row,0,row.length,val.getRowArray(),val.getRowOffset(),val.getRowLength()));
          String value=i + "" + idx;
          assertArrayEquals(Bytes.toBytes(value),CellUtil.cloneValue(val));
          idx++;
        }
      }
      WAL.Entry entry=reader.next();
      assertNull(entry);
    }
  finally {
      if (writer != null) {
        writer.close();
      }
      if (reader != null) {
        reader.close();
      }
    }
  }
  protected abstract W createWriter(  Path path) throws IOException ;
  protected abstract void append(  W writer,  WAL.Entry entry) throws IOException ;
  protected abstract void sync(  W writer) throws IOException ;
}
