/** 
 * Test handling of changes to the number of a peer's regionservers.
 */
@RunWith(Parameterized.class) @Category({ReplicationTests.class,LargeTests.class}) public class TestReplicationChangingPeerRegionservers extends TestReplicationBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestReplicationChangingPeerRegionservers.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestReplicationChangingPeerRegionservers.class);
  @Parameter public boolean serialPeer;
  @Override protected boolean isSerialPeer(){
    return serialPeer;
  }
  @Parameters(name="{index}: serialPeer={0}") public static List<Boolean> parameters(){
    return ImmutableList.of(true,false);
  }
  /** 
 * @throws java.lang.Exception
 */
  @Before public void setUp() throws Exception {
    for (    JVMClusterUtil.RegionServerThread r : utility1.getHBaseCluster().getRegionServerThreads()) {
      utility1.getAdmin().rollWALWriter(r.getRegionServer().getServerName());
    }
    utility1.deleteTableData(tableName);
    Scan scan=new Scan();
    int lastCount=0;
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        fail("Waited too much time for truncate");
      }
      ResultScanner scanner=htable2.getScanner(scan);
      Result[] res=scanner.next(NB_ROWS_IN_BIG_BATCH);
      scanner.close();
      if (res.length != 0) {
        if (res.length < lastCount) {
          i--;
        }
        lastCount=res.length;
        LOG.info("Still got " + res.length + " rows");
        Thread.sleep(SLEEP_TIME);
      }
 else {
        break;
      }
    }
  }
  @Test public void testChangingNumberOfPeerRegionServers() throws IOException, InterruptedException {
    LOG.info("testSimplePutDelete");
    MiniHBaseCluster peerCluster=utility2.getMiniHBaseCluster();
    int numRS=peerCluster.getRegionServerThreads().size();
    doPutTest(Bytes.toBytes(1));
    int rsToStop=peerCluster.getServerWithMeta() == 0 ? 1 : 0;
    peerCluster.stopRegionServer(rsToStop);
    peerCluster.waitOnRegionServer(rsToStop);
    assertEquals(numRS - 1,peerCluster.getRegionServerThreads().size());
    doPutTest(Bytes.toBytes(2));
    peerCluster.startRegionServer();
    assertEquals(numRS,peerCluster.getRegionServerThreads().size());
    doPutTest(Bytes.toBytes(3));
  }
  private void doPutTest(  byte[] row) throws IOException, InterruptedException {
    Put put=new Put(row);
    put.addColumn(famName,row,row);
    if (htable1 == null) {
      htable1=utility1.getConnection().getTable(tableName);
    }
    htable1.put(put);
    Get get=new Get(row);
    for (int i=0; i < NB_RETRIES; i++) {
      if (i == NB_RETRIES - 1) {
        fail("Waited too much time for put replication");
      }
      Result res=htable2.get(get);
      if (res.isEmpty()) {
        LOG.info("Row not available");
        Thread.sleep(SLEEP_TIME);
      }
 else {
        assertArrayEquals(res.value(),row);
        break;
      }
    }
  }
}
