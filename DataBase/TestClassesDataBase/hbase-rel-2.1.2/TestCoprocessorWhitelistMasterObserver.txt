/** 
 * Performs coprocessor loads for various paths and malformed strings
 */
@Category({SecurityTests.class,LargeTests.class}) public class TestCoprocessorWhitelistMasterObserver extends SecureTestUtil {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestCoprocessorWhitelistMasterObserver.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestCoprocessorWhitelistMasterObserver.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final TableName TEST_TABLE=TableName.valueOf("testTable");
  private static final byte[] TEST_FAMILY=Bytes.toBytes("fam1");
  @After public void tearDownTestCoprocessorWhitelistMasterObserver() throws Exception {
    Admin admin=UTIL.getAdmin();
    try {
      try {
        admin.disableTable(TEST_TABLE);
      }
 catch (      TableNotEnabledException ex) {
        LOG.info("Table was left disabled by test");
      }
      admin.deleteTable(TEST_TABLE);
    }
 catch (    TableNotFoundException ex) {
      LOG.info("Table was not created for some reason");
    }
    UTIL.shutdownMiniCluster();
  }
  /** 
 * Test a table modification adding a coprocessor path which is not whitelisted
 * @result An IOException should be thrown and caughtto show coprocessor is working as desired
 * @param whitelistedPaths A String array of paths to add infor the whitelisting configuration
 * @param coprocessorPath A String to use as thepath for a mock coprocessor
 */
  private static void positiveTestCase(  String[] whitelistedPaths,  String coprocessorPath) throws Exception {
    Configuration conf=UTIL.getConfiguration();
    conf.set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,CoprocessorWhitelistMasterObserver.class.getName());
    conf.setStrings(CoprocessorWhitelistMasterObserver.CP_COPROCESSOR_WHITELIST_PATHS_KEY,whitelistedPaths);
    conf.setInt("hbase.client.retries.number",5);
    UTIL.startMiniCluster();
    UTIL.createTable(TEST_TABLE,new byte[][]{TEST_FAMILY});
    UTIL.waitUntilAllRegionsAssigned(TEST_TABLE);
    Connection connection=ConnectionFactory.createConnection(conf);
    Table t=connection.getTable(TEST_TABLE);
    HTableDescriptor htd=new HTableDescriptor(t.getTableDescriptor());
    htd.addCoprocessor("net.clayb.hbase.coprocessor.NotWhitelisted",new Path(coprocessorPath),Coprocessor.PRIORITY_USER,null);
    LOG.info("Modifying Table");
    try {
      connection.getAdmin().modifyTable(TEST_TABLE,htd);
      fail("Expected coprocessor to raise IOException");
    }
 catch (    IOException e) {
    }
    LOG.info("Done Modifying Table");
    assertEquals(0,t.getTableDescriptor().getCoprocessors().size());
  }
  /** 
 * Test a table modification adding a coprocessor path which is whitelisted
 * @result The coprocessor should be added to the tabledescriptor successfully
 * @param whitelistedPaths A String array of paths to add infor the whitelisting configuration
 * @param coprocessorPath A String to use as thepath for a mock coprocessor
 */
  private static void negativeTestCase(  String[] whitelistedPaths,  String coprocessorPath) throws Exception {
    Configuration conf=UTIL.getConfiguration();
    conf.setInt("hbase.client.retries.number",5);
    conf.set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,CoprocessorWhitelistMasterObserver.class.getName());
    conf.setStrings(CoprocessorWhitelistMasterObserver.CP_COPROCESSOR_WHITELIST_PATHS_KEY,whitelistedPaths);
    UTIL.startMiniCluster();
    UTIL.createTable(TEST_TABLE,new byte[][]{TEST_FAMILY});
    UTIL.waitUntilAllRegionsAssigned(TEST_TABLE);
    Connection connection=ConnectionFactory.createConnection(conf);
    Admin admin=connection.getAdmin();
    admin.disableTable(TEST_TABLE);
    Table t=connection.getTable(TEST_TABLE);
    HTableDescriptor htd=new HTableDescriptor(t.getTableDescriptor());
    htd.addCoprocessor("net.clayb.hbase.coprocessor.Whitelisted",new Path(coprocessorPath),Coprocessor.PRIORITY_USER,null);
    LOG.info("Modifying Table");
    admin.modifyTable(TEST_TABLE,htd);
    assertEquals(1,t.getTableDescriptor().getCoprocessors().size());
    LOG.info("Done Modifying Table");
  }
  /** 
 * Test a table modification adding a coprocessor path which is not whitelisted
 * @result An IOException should be thrown and caughtto show coprocessor is working as desired
 */
  @Test public void testSubstringNonWhitelisted() throws Exception {
    positiveTestCase(new String[]{"/permitted/*"},"file:///notpermitted/couldnotpossiblyexist.jar");
  }
  /** 
 * Test a table creation including a coprocessor path which is not whitelisted
 * @result Coprocessor should be added to table descriptorTable is disabled to avoid an IOException due to the added coprocessor not actually existing on disk
 */
  @Test public void testDifferentFileSystemNonWhitelisted() throws Exception {
    positiveTestCase(new String[]{"hdfs://foo/bar"},"file:///notpermitted/couldnotpossiblyexist.jar");
  }
  /** 
 * Test a table modification adding a coprocessor path which is whitelisted
 * @result Coprocessor should be added to table descriptorTable is disabled to avoid an IOException due to the added coprocessor not actually existing on disk
 */
  @Test public void testSchemeAndDirectorywhitelisted() throws Exception {
    negativeTestCase(new String[]{"/tmp","file:///permitted/*"},"file:///permitted/couldnotpossiblyexist.jar");
  }
  /** 
 * Test a table modification adding a coprocessor path which is whitelisted
 * @result Coprocessor should be added to table descriptorTable is disabled to avoid an IOException due to the added coprocessor not actually existing on disk
 */
  @Test public void testSchemeWhitelisted() throws Exception {
    negativeTestCase(new String[]{"file:///"},"file:///permitted/couldnotpossiblyexist.jar");
  }
  /** 
 * Test a table modification adding a coprocessor path which is whitelisted
 * @result Coprocessor should be added to table descriptorTable is disabled to avoid an IOException due to the added coprocessor not actually existing on disk
 */
  @Test public void testDFSNameWhitelistedWorks() throws Exception {
    negativeTestCase(new String[]{"hdfs://Your-FileSystem"},"hdfs://Your-FileSystem/permitted/couldnotpossiblyexist.jar");
  }
  /** 
 * Test a table modification adding a coprocessor path which is whitelisted
 * @result Coprocessor should be added to table descriptorTable is disabled to avoid an IOException due to the added coprocessor not actually existing on disk
 */
  @Test public void testDFSNameNotWhitelistedFails() throws Exception {
    positiveTestCase(new String[]{"hdfs://Your-FileSystem"},"hdfs://My-FileSystem/permitted/couldnotpossiblyexist.jar");
  }
  /** 
 * Test a table modification adding a coprocessor path which is whitelisted
 * @result Coprocessor should be added to table descriptorTable is disabled to avoid an IOException due to the added coprocessor not actually existing on disk
 */
  @Test public void testBlanketWhitelist() throws Exception {
    negativeTestCase(new String[]{"*"},"hdfs:///permitted/couldnotpossiblyexist.jar");
  }
  /** 
 * Test a table creation including a coprocessor path which is not whitelisted
 * @result Table will not be created due to the offending coprocessor
 */
  @Test public void testCreationNonWhitelistedCoprocessorPath() throws Exception {
    Configuration conf=UTIL.getConfiguration();
    conf.set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,CoprocessorWhitelistMasterObserver.class.getName());
    conf.setStrings(CoprocessorWhitelistMasterObserver.CP_COPROCESSOR_WHITELIST_PATHS_KEY,new String[]{});
    conf.setInt("hbase.client.retries.number",5);
    UTIL.startMiniCluster();
    HTableDescriptor htd=new HTableDescriptor(TEST_TABLE);
    HColumnDescriptor hcd=new HColumnDescriptor(TEST_FAMILY);
    htd.addFamily(hcd);
    htd.addCoprocessor("net.clayb.hbase.coprocessor.NotWhitelisted",new Path("file:///notpermitted/couldnotpossiblyexist.jar"),Coprocessor.PRIORITY_USER,null);
    Connection connection=ConnectionFactory.createConnection(conf);
    Admin admin=connection.getAdmin();
    LOG.info("Creating Table");
    try {
      admin.createTable(htd);
      fail("Expected coprocessor to raise IOException");
    }
 catch (    IOException e) {
    }
    LOG.info("Done Creating Table");
    assertEquals(new HTableDescriptor[0],admin.listTables("^" + TEST_TABLE.getNameAsString() + "$"));
  }
public static class TestRegionObserver implements RegionCoprocessor, RegionObserver {
    @Override public Optional<RegionObserver> getRegionObserver(){
      return Optional.of(this);
    }
  }
  /** 
 * Test a table creation including a coprocessor path which is on the classpath
 * @result Table will be created with the coprocessor
 */
  @Test public void testCreationClasspathCoprocessor() throws Exception {
    Configuration conf=UTIL.getConfiguration();
    conf.set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,CoprocessorWhitelistMasterObserver.class.getName());
    conf.setStrings(CoprocessorWhitelistMasterObserver.CP_COPROCESSOR_WHITELIST_PATHS_KEY,new String[]{});
    conf.setInt("hbase.client.retries.number",5);
    UTIL.startMiniCluster();
    HTableDescriptor htd=new HTableDescriptor(TEST_TABLE);
    HColumnDescriptor hcd=new HColumnDescriptor(TEST_FAMILY);
    htd.addFamily(hcd);
    htd.addCoprocessor(TestRegionObserver.class.getName());
    Connection connection=ConnectionFactory.createConnection(conf);
    Admin admin=connection.getAdmin();
    LOG.info("Creating Table");
    admin.createTable(htd);
    LOG.info("Done Creating Table");
    Table t=connection.getTable(TEST_TABLE);
    assertEquals(1,t.getTableDescriptor().getCoprocessors().size());
  }
}
