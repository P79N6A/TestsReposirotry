/** 
 * Testing sync/append failures. Copied from TestHRegion.
 */
@Category({MediumTests.class}) public class TestFailedAppendAndSync {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestFailedAppendAndSync.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestFailedAppendAndSync.class);
  @Rule public TestName name=new TestName();
  private static final String COLUMN_FAMILY="MyCF";
  private static final byte[] COLUMN_FAMILY_BYTES=Bytes.toBytes(COLUMN_FAMILY);
  HRegion region=null;
  private static HBaseTestingUtility TEST_UTIL;
  public static Configuration CONF;
  private String dir;
  protected TableName tableName;
  @Before public void setup() throws IOException {
    TEST_UTIL=HBaseTestingUtility.createLocalHTU();
    CONF=TEST_UTIL.getConfiguration();
    CONF.setFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY,0f);
    dir=TEST_UTIL.getDataTestDir("TestHRegion").toString();
    tableName=TableName.valueOf(name.getMethodName());
  }
  @After public void tearDown() throws Exception {
    EnvironmentEdgeManagerTestHelper.reset();
    LOG.info("Cleaning test directory: " + TEST_UTIL.getDataTestDir());
    TEST_UTIL.cleanupTestDir();
  }
  String getName(){
    return name.getMethodName();
  }
  /** 
 * Reproduce locking up that happens when we get an exceptions appending and syncing. See HBASE-14317. First I need to set up some mocks for Server and RegionServerServices. I also need to set up a dodgy WAL that will throw an exception when we go to append to it.
 */
  @Test public void testLockupAroundBadAssignSync() throws IOException {
    final AtomicLong rolls=new AtomicLong(0);
class DodgyFSLog extends FSHLog {
      volatile boolean throwSyncException=false;
      volatile boolean throwAppendException=false;
      public DodgyFSLog(      FileSystem fs,      Path root,      String logDir,      Configuration conf) throws IOException {
        super(fs,root,logDir,conf);
      }
      @Override public byte[][] rollWriter(      boolean force) throws FailedLogCloseException, IOException {
        byte[][] regions=super.rollWriter(force);
        rolls.getAndIncrement();
        return regions;
      }
      @Override protected Writer createWriterInstance(      Path path) throws IOException {
        final Writer w=super.createWriterInstance(path);
        return new Writer(){
          @Override public void close() throws IOException {
            w.close();
          }
          @Override public void sync(          boolean forceSync) throws IOException {
            if (throwSyncException) {
              throw new IOException("FAKE! Failed to replace a bad datanode...");
            }
            w.sync(forceSync);
          }
          @Override public void append(          Entry entry) throws IOException {
            if (throwAppendException) {
              throw new IOException("FAKE! Failed to replace a bad datanode...");
            }
            w.append(entry);
          }
          @Override public long getLength(){
            return w.getLength();
          }
        }
;
      }
    }
    Server server=mock(Server.class);
    when(server.getConfiguration()).thenReturn(CONF);
    when(server.isStopped()).thenReturn(false);
    when(server.isAborted()).thenReturn(false);
    RegionServerServices services=mock(RegionServerServices.class);
    FileSystem fs=FileSystem.get(CONF);
    Path rootDir=new Path(dir + getName());
    DodgyFSLog dodgyWAL=new DodgyFSLog(fs,rootDir,getName(),CONF);
    LogRoller logRoller=new LogRoller(server,services);
    logRoller.addWAL(dodgyWAL);
    logRoller.start();
    boolean threwOnSync=false;
    boolean threwOnAppend=false;
    boolean threwOnBoth=false;
    HRegion region=initHRegion(tableName,null,null,dodgyWAL);
    try {
      byte[] value=Bytes.toBytes(getName());
      try {
        Put put=new Put(value);
        put.addColumn(COLUMN_FAMILY_BYTES,Bytes.toBytes("1"),value);
        region.put(put);
      }
 catch (      IOException ioe) {
        fail();
      }
      long rollsCount=rolls.get();
      try {
        dodgyWAL.throwAppendException=true;
        dodgyWAL.throwSyncException=false;
        Put put=new Put(value);
        put.addColumn(COLUMN_FAMILY_BYTES,Bytes.toBytes("3"),value);
        region.put(put);
      }
 catch (      IOException ioe) {
        threwOnAppend=true;
      }
      while (rollsCount == rolls.get())       Threads.sleep(100);
      rollsCount=rolls.get();
      try {
        dodgyWAL.throwAppendException=true;
        dodgyWAL.throwSyncException=true;
        Put put=new Put(value);
        put.addColumn(COLUMN_FAMILY_BYTES,Bytes.toBytes("4"),value);
        region.put(put);
      }
 catch (      IOException ioe) {
        threwOnBoth=true;
      }
      while (rollsCount == rolls.get())       Threads.sleep(100);
      Mockito.verify(server,Mockito.atLeast(0)).abort(Mockito.anyString(),(Throwable)Mockito.anyObject());
      try {
        dodgyWAL.throwAppendException=false;
        dodgyWAL.throwSyncException=true;
        Put put=new Put(value);
        put.addColumn(COLUMN_FAMILY_BYTES,Bytes.toBytes("2"),value);
        region.put(put);
      }
 catch (      IOException ioe) {
        threwOnSync=true;
      }
      while (true) {
        try {
          Mockito.verify(server,Mockito.atLeast(1)).abort(Mockito.anyString(),(Throwable)Mockito.anyObject());
          break;
        }
 catch (        WantedButNotInvoked t) {
          Threads.sleep(1);
        }
      }
    }
  finally {
      Mockito.when(server.isStopped()).thenReturn(true);
      if (logRoller != null)       logRoller.close();
      if (region != null) {
        try {
          region.close(true);
        }
 catch (        DroppedSnapshotException e) {
          LOG.info("On way out; expected!",e);
        }
      }
      if (dodgyWAL != null)       dodgyWAL.close();
      assertTrue("The regionserver should have thrown an exception",threwOnBoth);
      assertTrue("The regionserver should have thrown an exception",threwOnAppend);
      assertTrue("The regionserver should have thrown an exception",threwOnSync);
    }
  }
  /** 
 * @return A region on which you must call{@link HBaseTestingUtility#closeRegionAndWAL(HRegion)} when done.
 */
  public static HRegion initHRegion(  TableName tableName,  byte[] startKey,  byte[] stopKey,  WAL wal) throws IOException {
    ChunkCreator.initialize(MemStoreLABImpl.CHUNK_SIZE_DEFAULT,false,0,0,0,null);
    return TEST_UTIL.createLocalHRegion(tableName,startKey,stopKey,false,Durability.SYNC_WAL,wal,COLUMN_FAMILY_BYTES);
  }
}
