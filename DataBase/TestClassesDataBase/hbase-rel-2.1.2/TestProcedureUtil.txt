@Category({MasterTests.class,SmallTests.class}) public class TestProcedureUtil {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestProcedureUtil.class);
  @Test public void testValidation() throws Exception {
    ProcedureUtil.validateClass(new TestProcedure(10));
  }
  @Test(expected=BadProcedureException.class) public void testNoDefaultConstructorValidation() throws Exception {
    ProcedureUtil.validateClass(new TestProcedureNoDefaultConstructor(1));
  }
  @Test public void testConvert() throws Exception {
    final TestProcedure proc1=new TestProcedure(10,1,new byte[]{65});
    final ProcedureProtos.Procedure proto1=ProcedureUtil.convertToProtoProcedure(proc1);
    final TestProcedure proc2=(TestProcedure)ProcedureUtil.convertToProcedure(proto1);
    final ProcedureProtos.Procedure proto2=ProcedureUtil.convertToProtoProcedure(proc2);
    assertEquals(false,proto2.hasResult());
    assertEquals("Procedure protobuf does not match",proto1,proto2);
  }
  @Test public void testGetBackoffTimeMs(){
    for (int i=30; i < 1000; i++) {
      assertEquals(TimeUnit.MINUTES.toMillis(10),ProcedureUtil.getBackoffTimeMs(30));
    }
    long backoffTimeMs=ProcedureUtil.getBackoffTimeMs(0);
    assertTrue(backoffTimeMs >= 1000);
    assertTrue(backoffTimeMs <= 1000 * 1.01f);
    backoffTimeMs=ProcedureUtil.getBackoffTimeMs(1);
    assertTrue(backoffTimeMs >= 2000);
    assertTrue(backoffTimeMs <= 2000 * 1.01f);
    backoffTimeMs=ProcedureUtil.getBackoffTimeMs(5);
    assertTrue(backoffTimeMs >= 32000);
    assertTrue(backoffTimeMs <= 32000 * 1.01f);
  }
public static class TestProcedureNoDefaultConstructor extends TestProcedure {
    public TestProcedureNoDefaultConstructor(    int x){
    }
  }
}
