@Category({LargeTests.class,ClientTests.class}) public class TestIllegalTableDescriptor {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestIllegalTableDescriptor.class);
  private static final Logger masterLogger;
  protected final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static byte[] FAMILY=Bytes.toBytes("testFamily");
  @Rule public TestName name=new TestName();
static {
    masterLogger=mock(Logger.class);
  }
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    Field field=HMaster.class.getDeclaredField("LOG");
    field.setAccessible(true);
    field.set(null,masterLogger);
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setBoolean("hbase.table.sanity.checks",true);
    TEST_UTIL.startMiniCluster(1);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testIllegalTableDescriptor() throws Exception {
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(name.getMethodName()));
    HColumnDescriptor hcd=new HColumnDescriptor(FAMILY);
    checkTableIsIllegal(htd);
    htd.addFamily(hcd);
    checkTableIsLegal(htd);
    htd.setMaxFileSize(1024);
    checkTableIsIllegal(htd);
    htd.setMaxFileSize(0);
    checkTableIsIllegal(htd);
    htd.setMaxFileSize(1024 * 1024 * 1024);
    checkTableIsLegal(htd);
    htd.setMemStoreFlushSize(1024);
    checkTableIsIllegal(htd);
    htd.setMemStoreFlushSize(0);
    checkTableIsIllegal(htd);
    htd.setMemStoreFlushSize(128 * 1024 * 1024);
    checkTableIsLegal(htd);
    htd.setRegionSplitPolicyClassName("nonexisting.foo.class");
    checkTableIsIllegal(htd);
    htd.setRegionSplitPolicyClassName(null);
    checkTableIsLegal(htd);
    hcd.setBlocksize(0);
    checkTableIsIllegal(htd);
    hcd.setBlocksize(1024 * 1024 * 128);
    checkTableIsIllegal(htd);
    hcd.setBlocksize(1024);
    checkTableIsLegal(htd);
    hcd.setTimeToLive(0);
    checkTableIsIllegal(htd);
    hcd.setTimeToLive(-1);
    checkTableIsIllegal(htd);
    hcd.setTimeToLive(1);
    checkTableIsLegal(htd);
    hcd.setMinVersions(-1);
    checkTableIsIllegal(htd);
    hcd.setMinVersions(3);
    try {
      hcd.setMaxVersions(2);
      fail();
    }
 catch (    IllegalArgumentException ex) {
      hcd.setMaxVersions(10);
    }
    checkTableIsLegal(htd);
    hcd.setMaxVersions(4);
    hcd.setMinVersions(5);
    checkTableIsIllegal(htd);
    hcd.setMinVersions(3);
    hcd.setScope(-1);
    checkTableIsIllegal(htd);
    hcd.setScope(0);
    checkTableIsLegal(htd);
    try {
      hcd.setDFSReplication((short)-1);
      fail("Illegal value for setDFSReplication did not throw");
    }
 catch (    IllegalArgumentException e) {
    }
    hcd.setValue(HColumnDescriptor.DFS_REPLICATION,"-1");
    checkTableIsIllegal(htd);
    try {
      hcd.setDFSReplication((short)-1);
      fail("Should throw exception if an illegal value is explicitly being set");
    }
 catch (    IllegalArgumentException e) {
    }
    htd.setMemStoreFlushSize(0);
    htd.setConfiguration("hbase.table.sanity.checks",Boolean.FALSE.toString());
    checkTableIsLegal(htd);
    verify(masterLogger).warn(contains("MEMSTORE_FLUSHSIZE for table " + "descriptor or \"hbase.hregion.memstore.flush.size\" (0) is too small, which might " + "cause very frequent flushing."));
  }
  private void checkTableIsLegal(  HTableDescriptor htd) throws IOException {
    Admin admin=TEST_UTIL.getAdmin();
    admin.createTable(htd);
    assertTrue(admin.tableExists(htd.getTableName()));
    TEST_UTIL.deleteTable(htd.getTableName());
  }
  private void checkTableIsIllegal(  HTableDescriptor htd) throws IOException {
    Admin admin=TEST_UTIL.getAdmin();
    try {
      admin.createTable(htd);
      fail();
    }
 catch (    Exception ex) {
    }
    assertFalse(admin.tableExists(htd.getTableName()));
  }
}
