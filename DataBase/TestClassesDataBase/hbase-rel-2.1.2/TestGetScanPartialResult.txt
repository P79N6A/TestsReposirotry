/** 
 * Testcase for HBASE-21032, where use the wrong readType from a Scan instance which is actually a get scan and cause returning only 1 cell per rpc call.
 */
@Category({ClientTests.class,MediumTests.class}) public class TestGetScanPartialResult {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestGetScanPartialResult.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final TableName TABLE=TableName.valueOf("table");
  private static final byte[] CF={'c','f'};
  private static final byte[] ROW={'r','o','w'};
  private static final int VALUE_SIZE=10000;
  private static final int NUM_COLUMNS=300;
  @BeforeClass public static void setUp() throws Exception {
    TEST_UTIL.startMiniCluster(1);
    TEST_UTIL.createTable(TABLE,CF);
  }
  @AfterClass public static void tearDown() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  private static byte[] makeLargeValue(  int size){
    byte[] v=new byte[size];
    for (int i=0; i < size; i++) {
      v[i]=0;
    }
    return v;
  }
  @Test public void test() throws IOException {
    try (Table t=TEST_UTIL.getConnection().getTable(TABLE)){
      byte[] val=makeLargeValue(VALUE_SIZE);
      Put p=new Put(ROW);
      for (int i=0; i < NUM_COLUMNS; i++) {
        p.addColumn(CF,Integer.toString(i).getBytes(),val);
      }
      t.put(p);
      Scan scan=new Scan();
      scan.withStartRow(ROW);
      scan.withStopRow(ROW,true);
      scan.setAllowPartialResults(true);
      scan.setMaxResultSize(2L * 1024 * 1024);
      scan.readVersions(1);
      ResultScanner scanner=t.getScanner(scan);
      int nResults=0;
      int nCells=0;
      for (Result result=scanner.next(); (result != null); result=scanner.next()) {
        nResults++;
        nCells+=result.listCells().size();
      }
      assertEquals(NUM_COLUMNS,nCells);
      assertTrue(nResults < 5);
    }
   }
}
