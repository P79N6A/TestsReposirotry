/** 
 * Test the procedure member, and it's error handling mechanisms.
 */
@Category({MasterTests.class,SmallTests.class}) public class TestProcedureMember {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestProcedureMember.class);
  private static final long WAKE_FREQUENCY=100;
  private static final long TIMEOUT=100000;
  private static final long POOL_KEEP_ALIVE=1;
  private final String op="some op";
  private final byte[] data=new byte[0];
  private final ForeignExceptionDispatcher mockListener=Mockito.spy(new ForeignExceptionDispatcher());
  private final SubprocedureFactory mockBuilder=mock(SubprocedureFactory.class);
  private final ProcedureMemberRpcs mockMemberComms=Mockito.mock(ProcedureMemberRpcs.class);
  private ProcedureMember member;
  private ForeignExceptionDispatcher dispatcher;
  Subprocedure spySub;
  /** 
 * Reset all the mock objects
 */
  @After public void resetTest(){
    reset(mockListener,mockBuilder,mockMemberComms);
    if (member != null)     try {
      member.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  /** 
 * Build a member using the class level mocks
 * @return member to use for tests
 */
  private ProcedureMember buildCohortMember(){
    String name="node";
    ThreadPoolExecutor pool=ProcedureMember.defaultPool(name,1,POOL_KEEP_ALIVE);
    return new ProcedureMember(mockMemberComms,pool,mockBuilder);
  }
  /** 
 * Setup a procedure member that returns the spied-upon  {@link Subprocedure}.
 */
  private void buildCohortMemberPair() throws IOException {
    dispatcher=new ForeignExceptionDispatcher();
    String name="node";
    ThreadPoolExecutor pool=ProcedureMember.defaultPool(name,1,POOL_KEEP_ALIVE);
    member=new ProcedureMember(mockMemberComms,pool,mockBuilder);
    when(mockMemberComms.getMemberName()).thenReturn("membername");
    Subprocedure subproc=new EmptySubprocedure(member,dispatcher);
    spySub=spy(subproc);
    when(mockBuilder.buildSubprocedure(op,data)).thenReturn(spySub);
    addCommitAnswer();
  }
  /** 
 * Add a 'in barrier phase' response to the mock controller when it gets a acquired notification
 */
  private void addCommitAnswer() throws IOException {
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        member.receivedReachedGlobalBarrier(op);
        return null;
      }
    }
).when(mockMemberComms).sendMemberAcquired(any());
  }
  /** 
 * Test the normal sub procedure execution case.
 */
  @Test public void testSimpleRun() throws Exception {
    member=buildCohortMember();
    EmptySubprocedure subproc=new EmptySubprocedure(member,mockListener);
    EmptySubprocedure spy=spy(subproc);
    when(mockBuilder.buildSubprocedure(op,data)).thenReturn(spy);
    addCommitAnswer();
    Subprocedure subproc1=member.createSubprocedure(op,data);
    member.submitSubprocedure(subproc1);
    subproc.waitForLocallyCompleted();
    InOrder order=inOrder(mockMemberComms,spy);
    order.verify(spy).acquireBarrier();
    order.verify(mockMemberComms).sendMemberAcquired(eq(spy));
    order.verify(spy).insideBarrier();
    order.verify(mockMemberComms).sendMemberCompleted(eq(spy),eq(data));
    order.verify(mockMemberComms,never()).sendMemberAborted(eq(spy),any());
  }
  /** 
 * Make sure we call cleanup etc, when we have an exception during {@link Subprocedure#acquireBarrier()}.
 */
  @Test public void testMemberPrepareException() throws Exception {
    buildCohortMemberPair();
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        throw new IOException("Forced IOException in member acquireBarrier");
      }
    }
).when(spySub).acquireBarrier();
    Subprocedure subproc=member.createSubprocedure(op,data);
    member.submitSubprocedure(subproc);
    member.closeAndWait(TIMEOUT);
    InOrder order=inOrder(mockMemberComms,spySub);
    order.verify(spySub).acquireBarrier();
    order.verify(mockMemberComms,never()).sendMemberAcquired(eq(spySub));
    order.verify(spySub,never()).insideBarrier();
    order.verify(mockMemberComms,never()).sendMemberCompleted(eq(spySub),eq(data));
    order.verify(spySub).cancel(anyString(),any());
    order.verify(spySub).cleanup(any());
  }
  /** 
 * Make sure we call cleanup etc, when we have an exception during prepare.
 */
  @Test public void testSendMemberAcquiredCommsFailure() throws Exception {
    buildCohortMemberPair();
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        throw new IOException("Forced IOException in memeber prepare");
      }
    }
).when(mockMemberComms).sendMemberAcquired(any());
    Subprocedure subproc=member.createSubprocedure(op,data);
    member.submitSubprocedure(subproc);
    member.closeAndWait(TIMEOUT);
    InOrder order=inOrder(mockMemberComms,spySub);
    order.verify(spySub).acquireBarrier();
    order.verify(mockMemberComms).sendMemberAcquired(eq(spySub));
    order.verify(spySub,never()).insideBarrier();
    order.verify(mockMemberComms,never()).sendMemberCompleted(eq(spySub),eq(data));
    order.verify(spySub).cancel(anyString(),any());
    order.verify(spySub).cleanup(any());
  }
  /** 
 * Fail correctly if coordinator aborts the procedure.  The subprocedure will not interrupt a running  {@link Subprocedure#acquireBarrier()} -- prepare needs to finish first, and the the abortis checked.  Thus, the  {@link Subprocedure#acquireBarrier()} should succeed but later get rolled backvia  {@link Subprocedure#cleanup}.
 */
  @Test public void testCoordinatorAbort() throws Exception {
    buildCohortMemberPair();
    final TimeoutException oate=new TimeoutException("bogus timeout",1,2,0);
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        spySub.cancel("bogus message",oate);
        Thread.sleep(WAKE_FREQUENCY);
        return null;
      }
    }
).when(spySub).waitForReachedGlobalBarrier();
    Subprocedure subproc=member.createSubprocedure(op,data);
    member.submitSubprocedure(subproc);
    member.closeAndWait(TIMEOUT);
    InOrder order=inOrder(mockMemberComms,spySub);
    order.verify(spySub).acquireBarrier();
    order.verify(mockMemberComms).sendMemberAcquired(eq(spySub));
    order.verify(spySub,never()).insideBarrier();
    order.verify(mockMemberComms,never()).sendMemberCompleted(eq(spySub),eq(data));
    order.verify(spySub).cancel(anyString(),any());
    order.verify(spySub).cleanup(any());
  }
  /** 
 * Handle failures if a member's commit phase fails. NOTE: This is the core difference that makes this different from traditional 2PC.  In true 2PC the transaction is committed just before the coordinator sends commit messages to the member.  Members are then responsible for reading its TX log.  This implementation actually rolls back, and thus breaks the normal TX guarantees.
 */
  @Test public void testMemberCommitException() throws Exception {
    buildCohortMemberPair();
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        throw new IOException("Forced IOException in memeber prepare");
      }
    }
).when(spySub).insideBarrier();
    Subprocedure subproc=member.createSubprocedure(op,data);
    member.submitSubprocedure(subproc);
    member.closeAndWait(TIMEOUT);
    InOrder order=inOrder(mockMemberComms,spySub);
    order.verify(spySub).acquireBarrier();
    order.verify(mockMemberComms).sendMemberAcquired(eq(spySub));
    order.verify(spySub).insideBarrier();
    order.verify(mockMemberComms,never()).sendMemberCompleted(eq(spySub),eq(data));
    order.verify(spySub).cancel(anyString(),any());
    order.verify(spySub).cleanup(any());
  }
  /** 
 * Handle Failures if a member's commit phase succeeds but notification to coordinator fails NOTE: This is the core difference that makes this different from traditional 2PC.  In true 2PC the transaction is committed just before the coordinator sends commit messages to the member.  Members are then responsible for reading its TX log.  This implementation actually rolls back, and thus breaks the normal TX guarantees.
 */
  @Test public void testMemberCommitCommsFailure() throws Exception {
    buildCohortMemberPair();
    final TimeoutException oate=new TimeoutException("bogus timeout",1,2,0);
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        spySub.cancel("commit comms fail",oate);
        Thread.sleep(WAKE_FREQUENCY);
        return null;
      }
    }
).when(mockMemberComms).sendMemberCompleted(any(),eq(data));
    Subprocedure subproc=member.createSubprocedure(op,data);
    member.submitSubprocedure(subproc);
    member.closeAndWait(TIMEOUT);
    InOrder order=inOrder(mockMemberComms,spySub);
    order.verify(spySub).acquireBarrier();
    order.verify(mockMemberComms).sendMemberAcquired(eq(spySub));
    order.verify(spySub).insideBarrier();
    order.verify(mockMemberComms).sendMemberCompleted(eq(spySub),eq(data));
    order.verify(spySub).cancel(anyString(),any());
    order.verify(spySub).cleanup(any());
  }
  /** 
 * Fail correctly on getting an external error while waiting for the prepared latch
 * @throws Exception on failure
 */
  @Test public void testPropagateConnectionErrorBackToManager() throws Exception {
    member=buildCohortMember();
    ProcedureMember memberSpy=spy(member);
    final ForeignExceptionDispatcher dispatcher=new ForeignExceptionDispatcher();
    ForeignExceptionDispatcher dispSpy=spy(dispatcher);
    Subprocedure commit=new EmptySubprocedure(member,dispatcher);
    Subprocedure spy=spy(commit);
    when(mockBuilder.buildSubprocedure(op,data)).thenReturn(spy);
    doThrow(new ForeignException("SRC","prepare exception")).when(spy).acquireBarrier();
    doThrow(new IOException("Controller is down!")).when(mockMemberComms).sendMemberAborted(eq(spy),any());
    Subprocedure subproc=memberSpy.createSubprocedure(op,data);
    memberSpy.submitSubprocedure(subproc);
    memberSpy.closeAndWait(TIMEOUT);
    InOrder order=inOrder(mockMemberComms,spy,dispSpy);
    order.verify(spy).acquireBarrier();
    order.verify(mockMemberComms,never()).sendMemberAcquired(spy);
  }
  /** 
 * Test that the cohort member correctly doesn't attempt to start a task when the builder cannot correctly build a new task for the requested operation
 * @throws Exception on failure
 */
  @Test public void testNoTaskToBeRunFromRequest() throws Exception {
    ThreadPoolExecutor pool=mock(ThreadPoolExecutor.class);
    when(mockBuilder.buildSubprocedure(op,data)).thenReturn(null).thenThrow(new IllegalStateException("Wrong state!"),new IllegalArgumentException("can't understand the args"));
    member=new ProcedureMember(mockMemberComms,pool,mockBuilder);
    Subprocedure subproc=member.createSubprocedure(op,data);
    member.submitSubprocedure(subproc);
    try {
      Subprocedure subproc2=member.createSubprocedure(op,data);
      member.submitSubprocedure(subproc2);
    }
 catch (    IllegalStateException ise) {
    }
    try {
      Subprocedure subproc3=member.createSubprocedure(op,data);
      member.submitSubprocedure(subproc3);
    }
 catch (    IllegalArgumentException iae) {
    }
    verifyZeroInteractions(pool);
  }
  /** 
 * Helper  {@link Procedure} who's phase for each step is just empty
 */
public class EmptySubprocedure extends SubprocedureImpl {
    public EmptySubprocedure(    ProcedureMember member,    ForeignExceptionDispatcher dispatcher){
      super(member,op,dispatcher,WAKE_FREQUENCY,TIMEOUT);
    }
  }
}
