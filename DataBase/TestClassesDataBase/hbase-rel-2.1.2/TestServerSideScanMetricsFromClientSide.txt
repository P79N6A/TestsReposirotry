@Category(MediumTests.class) public class TestServerSideScanMetricsFromClientSide {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestServerSideScanMetricsFromClientSide.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static Table TABLE=null;
  /** 
 * Table configuration
 */
  private static TableName TABLE_NAME=TableName.valueOf("testTable");
  private static int NUM_ROWS=10;
  private static byte[] ROW=Bytes.toBytes("testRow");
  private static byte[][] ROWS=HTestConst.makeNAscii(ROW,NUM_ROWS);
  private static int NUM_FAMILIES=1;
  private static byte[] FAMILY=Bytes.toBytes("testFamily");
  private static byte[][] FAMILIES=HTestConst.makeNAscii(FAMILY,NUM_FAMILIES);
  private static int NUM_QUALIFIERS=1;
  private static byte[] QUALIFIER=Bytes.toBytes("testQualifier");
  private static byte[][] QUALIFIERS=HTestConst.makeNAscii(QUALIFIER,NUM_QUALIFIERS);
  private static int VALUE_SIZE=10;
  private static byte[] VALUE=Bytes.createMaxByteArray(VALUE_SIZE);
  private static int NUM_COLS=NUM_FAMILIES * NUM_QUALIFIERS;
  private static long CELL_HEAP_SIZE=-1;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    TEST_UTIL.startMiniCluster(3);
    TABLE=createTestTable(TABLE_NAME,ROWS,FAMILIES,QUALIFIERS,VALUE);
  }
  static Table createTestTable(  TableName name,  byte[][] rows,  byte[][] families,  byte[][] qualifiers,  byte[] cellValue) throws IOException {
    Table ht=TEST_UTIL.createTable(name,families);
    List<Put> puts=createPuts(rows,families,qualifiers,cellValue);
    ht.put(puts);
    return ht;
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  /** 
 * Make puts to put the input value into each combination of row, family, and qualifier
 * @param rows
 * @param families
 * @param qualifiers
 * @param value
 * @return
 * @throws IOException
 */
  static ArrayList<Put> createPuts(  byte[][] rows,  byte[][] families,  byte[][] qualifiers,  byte[] value) throws IOException {
    Put put;
    ArrayList<Put> puts=new ArrayList<>();
    for (int row=0; row < rows.length; row++) {
      put=new Put(rows[row]);
      for (int fam=0; fam < families.length; fam++) {
        for (int qual=0; qual < qualifiers.length; qual++) {
          KeyValue kv=new KeyValue(rows[row],families[fam],qualifiers[qual],qual,value);
          put.add(kv);
        }
      }
      puts.add(put);
    }
    return puts;
  }
  /** 
 * @return The approximate heap size of a cell in the test table. All cells should haveapproximately the same heap size, so the value is cached to avoid repeating the calculation
 * @throws Exception
 */
  private long getCellHeapSize() throws Exception {
    if (CELL_HEAP_SIZE == -1) {
      Scan scan=new Scan();
      scan.setMaxResultSize(1);
      scan.setAllowPartialResults(true);
      ResultScanner scanner=TABLE.getScanner(scan);
      Result result=scanner.next();
      assertTrue(result != null);
      assertTrue(result.rawCells() != null);
      assertTrue(result.rawCells().length == 1);
      CELL_HEAP_SIZE=PrivateCellUtil.estimatedSizeOfCell(result.rawCells()[0]);
      scanner.close();
    }
    return CELL_HEAP_SIZE;
  }
  @Test public void testRowsSeenMetricWithSync() throws Exception {
    testRowsSeenMetric(false);
  }
  @Test public void testRowsSeenMetricWithAsync() throws Exception {
    testRowsSeenMetric(true);
  }
  private void testRowsSeenMetric(  boolean async) throws Exception {
    Scan baseScan;
    baseScan=new Scan();
    baseScan.setScanMetricsEnabled(true);
    baseScan.setAsyncPrefetch(async);
    testRowsSeenMetric(baseScan);
    baseScan.setCaching(1);
    testRowsSeenMetric(baseScan);
    baseScan.setMaxResultSize(1);
    testRowsSeenMetric(baseScan);
    baseScan.setCaching(NUM_ROWS);
    baseScan.setMaxResultSize(getCellHeapSize() * (NUM_COLS - 1));
    testRowsSeenMetric(baseScan);
  }
  public void testRowsSeenMetric(  Scan baseScan) throws Exception {
    Scan scan;
    scan=new Scan(baseScan);
    testMetric(scan,ServerSideScanMetrics.COUNT_OF_ROWS_SCANNED_KEY_METRIC_NAME,NUM_ROWS);
    for (int i=0; i < ROWS.length - 1; i++) {
      scan=new Scan(baseScan);
      scan.withStartRow(ROWS[0]);
      scan.withStopRow(ROWS[i + 1]);
      testMetric(scan,ServerSideScanMetrics.COUNT_OF_ROWS_SCANNED_KEY_METRIC_NAME,i + 1);
    }
    for (int i=ROWS.length - 1; i > 0; i--) {
      scan=new Scan(baseScan);
      scan.withStartRow(ROWS[i - 1]);
      scan.withStopRow(ROWS[ROWS.length - 1]);
      testMetric(scan,ServerSideScanMetrics.COUNT_OF_ROWS_SCANNED_KEY_METRIC_NAME,ROWS.length - i);
    }
    Filter filter=new RowFilter(CompareOperator.EQUAL,new BinaryComparator(Bytes.toBytes("xyz")));
    scan=new Scan(baseScan);
    scan.setFilter(filter);
    testMetric(scan,ServerSideScanMetrics.COUNT_OF_ROWS_SCANNED_KEY_METRIC_NAME,ROWS.length);
    SingleColumnValueFilter singleColumnValueFilter=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS[0],CompareOperator.EQUAL,VALUE);
    scan=new Scan(baseScan);
    scan.setFilter(singleColumnValueFilter);
    testMetric(scan,ServerSideScanMetrics.COUNT_OF_ROWS_SCANNED_KEY_METRIC_NAME,ROWS.length);
    singleColumnValueFilter=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS[0],CompareOperator.NOT_EQUAL,VALUE);
    scan=new Scan(baseScan);
    scan.setFilter(singleColumnValueFilter);
    testMetric(scan,ServerSideScanMetrics.COUNT_OF_ROWS_SCANNED_KEY_METRIC_NAME,ROWS.length);
  }
  @Test public void testRowsFilteredMetric() throws Exception {
    Scan baseScan;
    baseScan=new Scan();
    baseScan.setScanMetricsEnabled(true);
    testRowsFilteredMetric(baseScan);
    baseScan.setCaching(1);
    testRowsFilteredMetric(baseScan);
    baseScan.setMaxResultSize(1);
    testRowsFilteredMetric(baseScan);
    baseScan.setCaching(NUM_ROWS);
    baseScan.setMaxResultSize(getCellHeapSize() * (NUM_COLS - 1));
    testRowsSeenMetric(baseScan);
  }
  public void testRowsFilteredMetric(  Scan baseScan) throws Exception {
    testRowsFilteredMetric(baseScan,null,0);
    Filter filter=new RowFilter(CompareOperator.EQUAL,new BinaryComparator(Bytes.toBytes("xyz")));
    testRowsFilteredMetric(baseScan,filter,ROWS.length);
    filter=new FirstKeyOnlyFilter();
    testRowsFilteredMetric(baseScan,filter,0);
    filter=new ColumnPrefixFilter(QUALIFIERS[0]);
    testRowsFilteredMetric(baseScan,filter,0);
    filter=new ColumnPrefixFilter(Bytes.toBytes("xyz"));
    testRowsFilteredMetric(baseScan,filter,ROWS.length);
    filter=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS[0],CompareOperator.EQUAL,VALUE);
    testRowsFilteredMetric(baseScan,filter,0);
    filter=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS[0],CompareOperator.NOT_EQUAL,VALUE);
    testRowsFilteredMetric(baseScan,filter,ROWS.length);
    List<Filter> filters=new ArrayList<>();
    filters.add(new RowFilter(CompareOperator.EQUAL,new BinaryComparator(ROWS[0])));
    filters.add(new RowFilter(CompareOperator.EQUAL,new BinaryComparator(ROWS[3])));
    int numberOfMatchingRowFilters=filters.size();
    filter=new FilterList(Operator.MUST_PASS_ONE,filters);
    testRowsFilteredMetric(baseScan,filter,ROWS.length - numberOfMatchingRowFilters);
    filters.clear();
    for (int family=0; family < FAMILIES.length; family++) {
      for (int qualifier=0; qualifier < QUALIFIERS.length; qualifier++) {
        filters.add(new SingleColumnValueExcludeFilter(FAMILIES[family],QUALIFIERS[qualifier],CompareOperator.EQUAL,VALUE));
      }
    }
    filter=new FilterList(Operator.MUST_PASS_ONE,filters);
    testRowsFilteredMetric(baseScan,filter,ROWS.length);
  }
  public void testRowsFilteredMetric(  Scan baseScan,  Filter filter,  int expectedNumFiltered) throws Exception {
    Scan scan=new Scan(baseScan);
    if (filter != null)     scan.setFilter(filter);
    testMetric(scan,ServerSideScanMetrics.COUNT_OF_ROWS_FILTERED_KEY_METRIC_NAME,expectedNumFiltered);
  }
  /** 
 * Run the scan to completetion and check the metric against the specified value
 * @param scan
 * @param metricKey
 * @param expectedValue
 * @throws Exception
 */
  public void testMetric(  Scan scan,  String metricKey,  long expectedValue) throws Exception {
    assertTrue("Scan should be configured to record metrics",scan.isScanMetricsEnabled());
    ResultScanner scanner=TABLE.getScanner(scan);
    while (scanner.next() != null) {
    }
    scanner.close();
    ScanMetrics metrics=scanner.getScanMetrics();
    assertTrue("Metrics are null",metrics != null);
    assertTrue("Metric : " + metricKey + " does not exist",metrics.hasCounter(metricKey));
    final long actualMetricValue=metrics.getCounter(metricKey).get();
    assertEquals("Metric: " + metricKey + " Expected: "+ expectedValue+ " Actual: "+ actualMetricValue,expectedValue,actualMetricValue);
  }
}
