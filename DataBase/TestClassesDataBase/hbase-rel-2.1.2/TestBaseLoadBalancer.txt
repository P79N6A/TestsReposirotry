@Category({MasterTests.class,MediumTests.class}) public class TestBaseLoadBalancer extends BalancerTestBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestBaseLoadBalancer.class);
  private static LoadBalancer loadBalancer;
  private static final Logger LOG=LoggerFactory.getLogger(TestBaseLoadBalancer.class);
  private static final ServerName master=ServerName.valueOf("fake-master",0,1L);
  private static RackManager rackManager;
  private static final int NUM_SERVERS=15;
  private static ServerName[] servers=new ServerName[NUM_SERVERS];
  int[][] regionsAndServersMocks=new int[][]{new int[]{0,0},new int[]{0,1},new int[]{1,1},new int[]{2,1},new int[]{10,1},new int[]{1,2},new int[]{2,2},new int[]{3,2},new int[]{1,3},new int[]{2,3},new int[]{3,3},new int[]{25,3},new int[]{2,10},new int[]{2,100},new int[]{12,10},new int[]{12,100}};
  @Rule public TestName name=new TestName();
  @BeforeClass public static void beforeAllTests() throws Exception {
    Configuration conf=HBaseConfiguration.create();
    conf.setClass("hbase.util.ip.to.rack.determiner",MockMapping.class,DNSToSwitchMapping.class);
    loadBalancer=new MockBalancer();
    loadBalancer.setConf(conf);
    MasterServices st=Mockito.mock(MasterServices.class);
    Mockito.when(st.getServerName()).thenReturn(master);
    loadBalancer.setMasterServices(st);
    rackManager=Mockito.mock(RackManager.class);
    for (int i=0; i < NUM_SERVERS; i++) {
      servers[i]=ServerName.valueOf("foo" + i + ":1234",-1);
      if (i < 5) {
        Mockito.when(rackManager.getRack(servers[i])).thenReturn("rack1");
      }
      if (i >= 5 && i < 10) {
        Mockito.when(rackManager.getRack(servers[i])).thenReturn("rack2");
      }
      if (i >= 10) {
        Mockito.when(rackManager.getRack(servers[i])).thenReturn("rack3");
      }
    }
  }
public static class MockBalancer extends BaseLoadBalancer {
    @Override public List<RegionPlan> balanceCluster(    Map<ServerName,List<RegionInfo>> clusterState){
      return null;
    }
    @Override public List<RegionPlan> balanceCluster(    TableName tableName,    Map<ServerName,List<RegionInfo>> clusterState) throws HBaseIOException {
      return null;
    }
  }
  /** 
 * All regions have an assignment.
 * @param regions
 * @param servers
 * @param assignments
 */
  private void assertImmediateAssignment(  List<RegionInfo> regions,  List<ServerName> servers,  Map<RegionInfo,ServerName> assignments){
    for (    RegionInfo region : regions) {
      assertTrue(assignments.containsKey(region));
    }
  }
  /** 
 * Tests the bulk assignment used during cluster startup. Round-robin. Should yield a balanced cluster so same invariant as the load balancer holds, all servers holding either floor(avg) or ceiling(avg).
 * @throws Exception
 */
  @Test public void testBulkAssignment() throws Exception {
    List<ServerName> tmp=getListOfServerNames(randomServers(5,0));
    List<RegionInfo> hris=randomRegions(20);
    hris.add(RegionInfoBuilder.FIRST_META_REGIONINFO);
    tmp.add(master);
    Map<ServerName,List<RegionInfo>> plans=loadBalancer.roundRobinAssignment(hris,tmp);
    if (LoadBalancer.isTablesOnMaster(loadBalancer.getConf())) {
      assertTrue(plans.get(master).contains(RegionInfoBuilder.FIRST_META_REGIONINFO));
      assertEquals(1,plans.get(master).size());
    }
    int totalRegion=0;
    for (    List<RegionInfo> regions : plans.values()) {
      totalRegion+=regions.size();
    }
    assertEquals(hris.size(),totalRegion);
    for (    int[] mock : regionsAndServersMocks) {
      LOG.debug("testBulkAssignment with " + mock[0] + " regions and "+ mock[1]+ " servers");
      List<RegionInfo> regions=randomRegions(mock[0]);
      List<ServerAndLoad> servers=randomServers(mock[1],0);
      List<ServerName> list=getListOfServerNames(servers);
      Map<ServerName,List<RegionInfo>> assignments=loadBalancer.roundRobinAssignment(regions,list);
      float average=(float)regions.size() / servers.size();
      int min=(int)Math.floor(average);
      int max=(int)Math.ceil(average);
      if (assignments != null && !assignments.isEmpty()) {
        for (        List<RegionInfo> regionList : assignments.values()) {
          assertTrue(regionList.size() == min || regionList.size() == max);
        }
      }
      returnRegions(regions);
      returnServers(list);
    }
  }
  /** 
 * Test the cluster startup bulk assignment which attempts to retain assignment info.
 * @throws Exception
 */
  @Test public void testRetainAssignment() throws Exception {
    List<ServerAndLoad> servers=randomServers(10,10);
    List<RegionInfo> regions=randomRegions(100);
    Map<RegionInfo,ServerName> existing=new TreeMap<>(RegionInfo.COMPARATOR);
    for (int i=0; i < regions.size(); i++) {
      ServerName sn=servers.get(i % servers.size()).getServerName();
      ServerName snWithOldStartCode=ServerName.valueOf(sn.getHostname(),sn.getPort(),sn.getStartcode() - 10);
      existing.put(regions.get(i),snWithOldStartCode);
    }
    List<ServerName> listOfServerNames=getListOfServerNames(servers);
    Map<ServerName,List<RegionInfo>> assignment=loadBalancer.retainAssignment(existing,listOfServerNames);
    assertRetainedAssignment(existing,listOfServerNames,assignment);
    List<ServerAndLoad> servers2=new ArrayList<>(servers);
    servers2.add(randomServer(10));
    servers2.add(randomServer(10));
    listOfServerNames=getListOfServerNames(servers2);
    assignment=loadBalancer.retainAssignment(existing,listOfServerNames);
    assertRetainedAssignment(existing,listOfServerNames,assignment);
    List<ServerAndLoad> servers3=new ArrayList<>(servers);
    servers3.remove(0);
    servers3.remove(0);
    listOfServerNames=getListOfServerNames(servers3);
    assignment=loadBalancer.retainAssignment(existing,listOfServerNames);
    assertRetainedAssignment(existing,listOfServerNames,assignment);
  }
  @Test public void testRandomAssignment() throws Exception {
    for (int i=1; i != 5; ++i) {
      LOG.info("run testRandomAssignment() with idle servers:" + i);
      testRandomAssignment(i);
    }
  }
  private void testRandomAssignment(  int numberOfIdleServers) throws Exception {
    assert numberOfIdleServers > 0;
    List<ServerName> idleServers=new ArrayList<>(numberOfIdleServers);
    for (int i=0; i != numberOfIdleServers; ++i) {
      idleServers.add(ServerName.valueOf("server-" + i,1000,1L));
    }
    List<ServerName> allServers=new ArrayList<>(idleServers.size() + 1);
    allServers.add(ServerName.valueOf("server-" + numberOfIdleServers,1000,1L));
    allServers.addAll(idleServers);
    LoadBalancer balancer=new MockBalancer(){
      @Override public boolean shouldBeOnMaster(      RegionInfo region){
        return false;
      }
    }
;
    Configuration conf=HBaseConfiguration.create();
    conf.setClass("hbase.util.ip.to.rack.determiner",MockMapping.class,DNSToSwitchMapping.class);
    balancer.setConf(conf);
    ServerManager sm=Mockito.mock(ServerManager.class);
    Mockito.when(sm.getOnlineServersListWithPredicator(allServers,BaseLoadBalancer.IDLE_SERVER_PREDICATOR)).thenReturn(idleServers);
    MasterServices services=Mockito.mock(MasterServices.class);
    Mockito.when(services.getServerManager()).thenReturn(sm);
    balancer.setMasterServices(services);
    RegionInfo hri1=RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).setStartKey("key1".getBytes()).setEndKey("key2".getBytes()).setSplit(false).setRegionId(100).build();
    assertNull(balancer.randomAssignment(hri1,Collections.EMPTY_LIST));
    assertNull(balancer.randomAssignment(hri1,null));
    for (int i=0; i != 3; ++i) {
      ServerName sn=balancer.randomAssignment(hri1,allServers);
      assertTrue("actual:" + sn + ", except:"+ idleServers,idleServers.contains(sn));
    }
  }
  @Test public void testRegionAvailability() throws Exception {
    List<RegionInfo> list0=new ArrayList<>();
    List<RegionInfo> list1=new ArrayList<>();
    List<RegionInfo> list2=new ArrayList<>();
    RegionInfo hri1=RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).setStartKey("key1".getBytes()).setEndKey("key2".getBytes()).setSplit(false).setRegionId(100).build();
    RegionInfo hri2=RegionReplicaUtil.getRegionInfoForReplica(hri1,1);
    RegionInfo hri3=RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).setStartKey("key2".getBytes()).setEndKey("key3".getBytes()).setSplit(false).setRegionId(101).build();
    list0.add(hri1);
    list1.add(hri2);
    list2.add(hri3);
    Map<ServerName,List<RegionInfo>> clusterState=new LinkedHashMap<>();
    clusterState.put(servers[0],list0);
    clusterState.put(servers[1],list1);
    clusterState.put(servers[2],list2);
    Cluster cluster=new Cluster(clusterState,null,null,rackManager);
    assertTrue(cluster.wouldLowerAvailability(hri1,servers[1]));
    assertTrue(!cluster.wouldLowerAvailability(hri1,servers[2]));
    assertTrue(!cluster.wouldLowerAvailability(hri2,servers[2]));
    assertTrue(!cluster.wouldLowerAvailability(hri3,servers[1]));
    list1.add(RegionReplicaUtil.getRegionInfoForReplica(hri3,1));
    cluster=new Cluster(clusterState,null,null,rackManager);
    assertTrue(cluster.wouldLowerAvailability(hri3,servers[1]));
    clusterState.clear();
    clusterState.put(servers[0],list0);
    clusterState.put(servers[5],list1);
    clusterState.put(servers[6],list2);
    clusterState.put(servers[10],new ArrayList<>());
    cluster=new Cluster(clusterState,null,null,rackManager);
    assertTrue(cluster.wouldLowerAvailability(hri1,servers[0]));
    cluster=new Cluster(clusterState,null,null,null);
    assertTrue(!cluster.wouldLowerAvailability(hri1,servers[6]));
  }
  @Test public void testRegionAvailabilityWithRegionMoves() throws Exception {
    List<RegionInfo> list0=new ArrayList<>();
    List<RegionInfo> list1=new ArrayList<>();
    List<RegionInfo> list2=new ArrayList<>();
    RegionInfo hri1=RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).setStartKey("key1".getBytes()).setEndKey("key2".getBytes()).setSplit(false).setRegionId(100).build();
    RegionInfo hri2=RegionReplicaUtil.getRegionInfoForReplica(hri1,1);
    RegionInfo hri3=RegionInfoBuilder.newBuilder(TableName.valueOf(name.getMethodName())).setStartKey("key2".getBytes()).setEndKey("key3".getBytes()).setSplit(false).setRegionId(101).build();
    list0.add(hri1);
    list1.add(hri2);
    list2.add(hri3);
    Map<ServerName,List<RegionInfo>> clusterState=new LinkedHashMap<>();
    clusterState.put(servers[0],list0);
    clusterState.put(servers[1],list1);
    clusterState.put(servers[2],list2);
    Cluster cluster=new Cluster(clusterState,null,null,rackManager);
    assertTrue(!cluster.wouldLowerAvailability(hri1,servers[2]));
    cluster.doAction(new MoveRegionAction(0,0,2));
    assertEquals(2,cluster.numMaxRegionsPerTable[0]);
    assertTrue(cluster.wouldLowerAvailability(hri1,servers[2]));
    clusterState.clear();
    List<RegionInfo> list3=new ArrayList<>();
    RegionInfo hri4=RegionReplicaUtil.getRegionInfoForReplica(hri3,1);
    list3.add(hri4);
    clusterState.put(servers[0],list0);
    clusterState.put(servers[5],list1);
    clusterState.put(servers[6],list2);
    clusterState.put(servers[12],list3);
    cluster=new Cluster(clusterState,null,null,rackManager);
    assertTrue(!cluster.wouldLowerAvailability(hri4,servers[0]));
    cluster.doAction(new MoveRegionAction(2,2,0));
    assertTrue(cluster.wouldLowerAvailability(hri3,servers[0]));
  }
  private List<ServerName> getListOfServerNames(  final List<ServerAndLoad> sals){
    return sals.stream().map(ServerAndLoad::getServerName).collect(Collectors.toList());
  }
  /** 
 * Asserts a valid retained assignment plan. <p> Must meet the following conditions: <ul> <li>Every input region has an assignment, and to an online server <li>If a region had an existing assignment to a server with the same address a a currently online server, it will be assigned to it </ul>
 * @param existing
 * @param servers
 * @param assignment
 */
  private void assertRetainedAssignment(  Map<RegionInfo,ServerName> existing,  List<ServerName> servers,  Map<ServerName,List<RegionInfo>> assignment){
    Set<ServerName> onlineServerSet=new TreeSet<>(servers);
    Set<RegionInfo> assignedRegions=new TreeSet<>(RegionInfo.COMPARATOR);
    for (    Map.Entry<ServerName,List<RegionInfo>> a : assignment.entrySet()) {
      assertTrue("Region assigned to server that was not listed as online",onlineServerSet.contains(a.getKey()));
      for (      RegionInfo r : a.getValue())       assignedRegions.add(r);
    }
    assertEquals(existing.size(),assignedRegions.size());
    Set<String> onlineHostNames=new TreeSet<>();
    for (    ServerName s : servers) {
      onlineHostNames.add(s.getHostname());
    }
    for (    Map.Entry<ServerName,List<RegionInfo>> a : assignment.entrySet()) {
      ServerName assignedTo=a.getKey();
      for (      RegionInfo r : a.getValue()) {
        ServerName address=existing.get(r);
        if (address != null && onlineHostNames.contains(address.getHostname())) {
          assertEquals(address.getHostname(),assignedTo.getHostname());
        }
      }
    }
  }
  @Test public void testClusterServersWithSameHostPort(){
    List<ServerName> servers=getListOfServerNames(randomServers(10,10));
    List<RegionInfo> regions=randomRegions(101);
    Map<ServerName,List<RegionInfo>> clusterState=new HashMap<>();
    assignRegions(regions,servers,clusterState);
    List<ServerName> oldServers=new ArrayList<>(servers.size());
    for (    ServerName sn : servers) {
      oldServers.add(ServerName.valueOf(sn.getHostname(),sn.getPort(),sn.getStartcode() - 10));
    }
    regions=randomRegions(9);
    assignRegions(regions,oldServers,clusterState);
    BaseLoadBalancer.Cluster cluster=new Cluster(clusterState,null,null,null);
    assertEquals(101 + 9,cluster.numRegions);
    assertEquals(10,cluster.numServers);
  }
  private void assignRegions(  List<RegionInfo> regions,  List<ServerName> servers,  Map<ServerName,List<RegionInfo>> clusterState){
    for (int i=0; i < regions.size(); i++) {
      ServerName sn=servers.get(i % servers.size());
      List<RegionInfo> regionsOfServer=clusterState.get(sn);
      if (regionsOfServer == null) {
        regionsOfServer=new ArrayList<>(10);
        clusterState.put(sn,regionsOfServer);
      }
      regionsOfServer.add(regions.get(i));
    }
  }
  @Test public void testClusterRegionLocations(){
    List<ServerName> servers=getListOfServerNames(randomServers(10,10));
    List<RegionInfo> regions=randomRegions(101);
    Map<ServerName,List<RegionInfo>> clusterState=new HashMap<>();
    assignRegions(regions,servers,clusterState);
    RegionLocationFinder locationFinder=mock(RegionLocationFinder.class);
    when(locationFinder.getTopBlockLocations(regions.get(0))).thenReturn(Lists.newArrayList(servers.get(0)));
    when(locationFinder.getTopBlockLocations(regions.get(1))).thenReturn(Lists.newArrayList(servers.get(0),servers.get(1)));
    when(locationFinder.getTopBlockLocations(regions.get(42))).thenReturn(Lists.newArrayList(servers.get(4),servers.get(9),servers.get(5)));
    when(locationFinder.getTopBlockLocations(regions.get(43))).thenReturn(Lists.newArrayList(ServerName.valueOf("foo",0,0)));
    BaseLoadBalancer.Cluster cluster=new Cluster(clusterState,null,locationFinder,null);
    int r0=ArrayUtils.indexOf(cluster.regions,regions.get(0));
    int r1=ArrayUtils.indexOf(cluster.regions,regions.get(1));
    int r10=ArrayUtils.indexOf(cluster.regions,regions.get(10));
    int r42=ArrayUtils.indexOf(cluster.regions,regions.get(42));
    int r43=ArrayUtils.indexOf(cluster.regions,regions.get(43));
    int s0=cluster.serversToIndex.get(servers.get(0).getHostAndPort());
    int s1=cluster.serversToIndex.get(servers.get(1).getHostAndPort());
    int s4=cluster.serversToIndex.get(servers.get(4).getHostAndPort());
    int s5=cluster.serversToIndex.get(servers.get(5).getHostAndPort());
    int s9=cluster.serversToIndex.get(servers.get(9).getHostAndPort());
    assertEquals(1,cluster.regionLocations[r0].length);
    assertEquals(s0,cluster.regionLocations[r0][0]);
    assertEquals(2,cluster.regionLocations[r1].length);
    assertEquals(s0,cluster.regionLocations[r1][0]);
    assertEquals(s1,cluster.regionLocations[r1][1]);
    assertEquals(0,cluster.regionLocations[r10].length);
    assertEquals(3,cluster.regionLocations[r42].length);
    assertEquals(s4,cluster.regionLocations[r42][0]);
    assertEquals(s9,cluster.regionLocations[r42][1]);
    assertEquals(s5,cluster.regionLocations[r42][2]);
    assertEquals(1,cluster.regionLocations[r43].length);
    assertEquals(-1,cluster.regionLocations[r43][0]);
  }
}
