private class RandRsExecutor extends NoopRsExecutor {
  private final Random rand=new Random();
  @Override public ExecuteProceduresResponse sendRequest(  ServerName server,  ExecuteProceduresRequest req) throws IOException {
switch (rand.nextInt(5)) {
case 0:
      throw new ServerNotRunningYetException("wait on server startup");
case 1:
    throw new SocketTimeoutException("simulate socket timeout");
case 2:
  throw new RemoteException("java.io.IOException","unexpected exception");
default :
}
return super.sendRequest(server,req);
}
@Override protected RegionOpeningState execOpenRegion(final ServerName server,RegionOpenInfo openReq) throws IOException {
switch (rand.nextInt(6)) {
case 0:
LOG.info("Return OPENED response");
sendTransitionReport(server,openReq.getRegion(),TransitionCode.OPENED);
return OpenRegionResponse.RegionOpeningState.OPENED;
case 1:
LOG.info("Return transition report that OPENED/ALREADY_OPENED response");
sendTransitionReport(server,openReq.getRegion(),TransitionCode.OPENED);
return OpenRegionResponse.RegionOpeningState.ALREADY_OPENED;
case 2:
LOG.info("Return transition report that FAILED_OPEN/FAILED_OPENING response");
sendTransitionReport(server,openReq.getRegion(),TransitionCode.FAILED_OPEN);
return OpenRegionResponse.RegionOpeningState.FAILED_OPENING;
default :
}
LOG.info("Return null as response; means proc stuck so we send in a crash report after a few seconds...");
executor.schedule(new Runnable(){
@Override public void run(){
LOG.info("Delayed CRASHING of " + server);
doCrash(server);
}
}
,5,TimeUnit.SECONDS);
return null;
}
@Override protected CloseRegionResponse execCloseRegion(ServerName server,byte[] regionName) throws IOException {
CloseRegionResponse.Builder resp=CloseRegionResponse.newBuilder();
boolean closed=rand.nextBoolean();
if (closed) {
RegionInfo hri=am.getRegionInfo(regionName);
sendTransitionReport(server,ProtobufUtil.toRegionInfo(hri),TransitionCode.CLOSED);
}
resp.setClosed(closed);
return resp.build();
}
}
