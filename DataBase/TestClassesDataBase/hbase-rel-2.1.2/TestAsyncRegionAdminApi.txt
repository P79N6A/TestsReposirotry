/** 
 * Class to test asynchronous region admin operations.
 * @see TestAsyncRegionAdminApi2 This test and it used to be joined it was taking longer than ourten minute timeout so they were split.
 */
@RunWith(Parameterized.class) @Category({LargeTests.class,ClientTests.class}) public class TestAsyncRegionAdminApi extends TestAsyncAdminBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestAsyncRegionAdminApi.class);
  @Test public void testAssignRegionAndUnassignRegion() throws Exception {
    createTableWithDefaultConf(tableName);
    HMaster master=TEST_UTIL.getHBaseCluster().getMaster();
    AssignmentManager am=master.getAssignmentManager();
    RegionInfo hri=am.getRegionStates().getRegionsOfTable(tableName).get(0);
    RegionStates regionStates=am.getRegionStates();
    ServerName serverName=regionStates.getRegionServerOfRegion(hri);
    TEST_UTIL.assertRegionOnServer(hri,serverName,200);
    assertTrue(regionStates.getRegionState(hri).isOpened());
    admin.assign(hri.getRegionName()).get();
    assertTrue(regionStates.getRegionState(hri).isOpened());
    admin.unassign(hri.getRegionName(),true).get();
    assertTrue(regionStates.getRegionState(hri).isClosed());
  }
  RegionInfo createTableAndGetOneRegion(  final TableName tableName) throws IOException, InterruptedException, ExecutionException {
    TableDescriptor desc=TableDescriptorBuilder.newBuilder(tableName).setColumnFamily(ColumnFamilyDescriptorBuilder.of(FAMILY)).build();
    admin.createTable(desc,Bytes.toBytes("A"),Bytes.toBytes("Z"),5).get();
    HMaster master=TEST_UTIL.getHBaseCluster().getMaster();
    long timeoutTime=System.currentTimeMillis() + 3000;
    while (true) {
      List<RegionInfo> regions=master.getAssignmentManager().getRegionStates().getRegionsOfTable(tableName);
      if (regions.size() > 3) {
        return regions.get(2);
      }
      long now=System.currentTimeMillis();
      if (now > timeoutTime) {
        fail("Could not find an online region");
      }
      Thread.sleep(10);
    }
  }
  @Test public void testGetRegionByStateOfTable() throws Exception {
    RegionInfo hri=createTableAndGetOneRegion(tableName);
    RegionStates regionStates=TEST_UTIL.getHBaseCluster().getMaster().getAssignmentManager().getRegionStates();
    assertTrue(regionStates.getRegionByStateOfTable(tableName).get(RegionState.State.OPEN).stream().anyMatch(r -> RegionInfo.COMPARATOR.compare(r,hri) == 0));
    assertFalse(regionStates.getRegionByStateOfTable(TableName.valueOf("I_am_the_phantom")).get(RegionState.State.OPEN).stream().anyMatch(r -> RegionInfo.COMPARATOR.compare(r,hri) == 0));
  }
  @Test public void testMoveRegion() throws Exception {
    admin.balancerSwitch(false).join();
    RegionInfo hri=createTableAndGetOneRegion(tableName);
    RawAsyncHBaseAdmin rawAdmin=(RawAsyncHBaseAdmin)ASYNC_CONN.getAdmin();
    ServerName serverName=rawAdmin.getRegionLocation(hri.getRegionName()).get().getServerName();
    HMaster master=TEST_UTIL.getHBaseCluster().getMaster();
    ServerManager serverManager=master.getServerManager();
    ServerName destServerName=null;
    List<JVMClusterUtil.RegionServerThread> regionServers=TEST_UTIL.getHBaseCluster().getLiveRegionServerThreads();
    for (    JVMClusterUtil.RegionServerThread regionServer : regionServers) {
      HRegionServer destServer=regionServer.getRegionServer();
      destServerName=destServer.getServerName();
      if (!destServerName.equals(serverName) && serverManager.isServerOnline(destServerName)) {
        break;
      }
    }
    assertTrue(destServerName != null && !destServerName.equals(serverName));
    admin.move(hri.getRegionName(),destServerName).get();
    long timeoutTime=System.currentTimeMillis() + 30000;
    while (true) {
      ServerName sn=rawAdmin.getRegionLocation(hri.getRegionName()).get().getServerName();
      if (sn != null && sn.equals(destServerName)) {
        break;
      }
      long now=System.currentTimeMillis();
      if (now > timeoutTime) {
        fail("Failed to move the region in time: " + hri);
      }
      Thread.sleep(100);
    }
    admin.balancerSwitch(true).join();
  }
  @Test public void testGetOnlineRegions() throws Exception {
    createTableAndGetOneRegion(tableName);
    AtomicInteger regionServerCount=new AtomicInteger(0);
    TEST_UTIL.getHBaseCluster().getLiveRegionServerThreads().stream().map(rsThread -> rsThread.getRegionServer()).forEach(rs -> {
      ServerName serverName=rs.getServerName();
      try {
        assertEquals(admin.getRegions(serverName).get().size(),rs.getRegions().size());
      }
 catch (      Exception e) {
        fail("admin.getOnlineRegions() method throws a exception: " + e.getMessage());
      }
      regionServerCount.incrementAndGet();
    }
);
    assertEquals(2,regionServerCount.get());
  }
  @Test public void testFlushTableAndRegion() throws Exception {
    RegionInfo hri=createTableAndGetOneRegion(tableName);
    ServerName serverName=TEST_UTIL.getHBaseCluster().getMaster().getAssignmentManager().getRegionStates().getRegionServerOfRegion(hri);
    HRegionServer regionServer=TEST_UTIL.getHBaseCluster().getLiveRegionServerThreads().stream().map(rsThread -> rsThread.getRegionServer()).filter(rs -> rs.getServerName().equals(serverName)).findFirst().get();
    ASYNC_CONN.getTable(tableName).put(new Put(hri.getStartKey()).addColumn(FAMILY,FAMILY_0,Bytes.toBytes("value-1"))).join();
    assertTrue(regionServer.getOnlineRegion(hri.getRegionName()).getMemStoreDataSize() > 0);
    LOG.info("flushing region: " + Bytes.toStringBinary(hri.getRegionName()));
    admin.flushRegion(hri.getRegionName()).get();
    LOG.info("blocking until flush is complete: " + Bytes.toStringBinary(hri.getRegionName()));
    Threads.sleepWithoutInterrupt(500);
    while (regionServer.getOnlineRegion(hri.getRegionName()).getMemStoreDataSize() > 0) {
      Threads.sleep(50);
    }
    assertEquals(regionServer.getOnlineRegion(hri.getRegionName()).getMemStoreDataSize(),0);
    ASYNC_CONN.getTable(tableName).put(new Put(hri.getStartKey()).addColumn(FAMILY,FAMILY_0,Bytes.toBytes("value-2"))).join();
    assertTrue(regionServer.getOnlineRegion(hri.getRegionName()).getMemStoreDataSize() > 0);
    admin.flush(tableName).get();
    Threads.sleepWithoutInterrupt(500);
    while (regionServer.getOnlineRegion(hri.getRegionName()).getMemStoreDataSize() > 0) {
      Threads.sleep(50);
    }
    assertEquals(regionServer.getOnlineRegion(hri.getRegionName()).getMemStoreDataSize(),0);
  }
  private void waitUntilMobCompactionFinished(  TableName tableName) throws ExecutionException, InterruptedException {
    long finished=EnvironmentEdgeManager.currentTime() + 60000;
    CompactionState state=admin.getCompactionState(tableName,CompactType.MOB).get();
    while (EnvironmentEdgeManager.currentTime() < finished) {
      if (state == CompactionState.NONE) {
        break;
      }
      Thread.sleep(10);
      state=admin.getCompactionState(tableName,CompactType.MOB).get();
    }
    assertEquals(CompactionState.NONE,state);
  }
  @Test public void testCompactMob() throws Exception {
    ColumnFamilyDescriptor columnDescriptor=ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes("mob")).setMobEnabled(true).setMobThreshold(0).build();
    TableDescriptor tableDescriptor=TableDescriptorBuilder.newBuilder(tableName).setColumnFamily(columnDescriptor).build();
    admin.createTable(tableDescriptor).get();
    byte[][] families={Bytes.toBytes("mob")};
    loadData(tableName,families,3000,8);
    admin.majorCompact(tableName,CompactType.MOB).get();
    CompactionState state=admin.getCompactionState(tableName,CompactType.MOB).get();
    assertNotEquals(CompactionState.NONE,state);
    waitUntilMobCompactionFinished(tableName);
  }
  @Test public void testCompactRegionServer() throws Exception {
    byte[][] families={Bytes.toBytes("f1"),Bytes.toBytes("f2"),Bytes.toBytes("f3")};
    createTableWithDefaultConf(tableName,null,families);
    loadData(tableName,families,3000,8);
    List<HRegionServer> rsList=TEST_UTIL.getHBaseCluster().getLiveRegionServerThreads().stream().map(rsThread -> rsThread.getRegionServer()).collect(Collectors.toList());
    List<Region> regions=new ArrayList<>();
    rsList.forEach(rs -> regions.addAll(rs.getRegions(tableName)));
    assertEquals(1,regions.size());
    int countBefore=countStoreFilesInFamilies(regions,families);
    assertTrue(countBefore > 0);
    for (    HRegionServer rs : rsList)     admin.compactRegionServer(rs.getServerName()).get();
    Thread.sleep(5000);
    int countAfterMinorCompaction=countStoreFilesInFamilies(regions,families);
    assertTrue(countAfterMinorCompaction < countBefore);
    for (    HRegionServer rs : rsList)     admin.majorCompactRegionServer(rs.getServerName()).get();
    Thread.sleep(5000);
    int countAfterMajorCompaction=countStoreFilesInFamilies(regions,families);
    assertEquals(3,countAfterMajorCompaction);
  }
  @Test public void testCompact() throws Exception {
    compactionTest(TableName.valueOf("testCompact1"),8,CompactionState.MAJOR,false);
    compactionTest(TableName.valueOf("testCompact2"),15,CompactionState.MINOR,false);
    compactionTest(TableName.valueOf("testCompact3"),8,CompactionState.MAJOR,true);
    compactionTest(TableName.valueOf("testCompact4"),15,CompactionState.MINOR,true);
  }
  private void compactionTest(  final TableName tableName,  final int flushes,  final CompactionState expectedState,  boolean singleFamily) throws Exception {
    byte[] family=Bytes.toBytes("family");
    byte[][] families={family,Bytes.add(family,Bytes.toBytes("2")),Bytes.add(family,Bytes.toBytes("3"))};
    createTableWithDefaultConf(tableName,null,families);
    loadData(tableName,families,3000,flushes);
    List<Region> regions=new ArrayList<>();
    TEST_UTIL.getHBaseCluster().getLiveRegionServerThreads().forEach(rsThread -> regions.addAll(rsThread.getRegionServer().getRegions(tableName)));
    assertEquals(1,regions.size());
    int countBefore=countStoreFilesInFamilies(regions,families);
    int countBeforeSingleFamily=countStoreFilesInFamily(regions,family);
    assertTrue(countBefore > 0);
    if (expectedState == CompactionState.MINOR) {
      if (singleFamily) {
        admin.compact(tableName,family).get();
      }
 else {
        admin.compact(tableName).get();
      }
    }
 else {
      if (singleFamily) {
        admin.majorCompact(tableName,family).get();
      }
 else {
        admin.majorCompact(tableName).get();
      }
    }
    long curt=System.currentTimeMillis();
    long waitTime=5000;
    long endt=curt + waitTime;
    CompactionState state=admin.getCompactionState(tableName).get();
    while (state == CompactionState.NONE && curt < endt) {
      Thread.sleep(10);
      state=admin.getCompactionState(tableName).get();
      curt=System.currentTimeMillis();
    }
    if (expectedState != state) {
      for (      Region region : regions) {
        state=CompactionState.valueOf(region.getCompactionState().toString());
        assertEquals(CompactionState.NONE,state);
      }
    }
 else {
      state=admin.getCompactionState(tableName).get();
      while (state != CompactionState.NONE && curt < endt) {
        Thread.sleep(10);
        state=admin.getCompactionState(tableName).get();
      }
      assertEquals(CompactionState.NONE,state);
    }
    int countAfter=countStoreFilesInFamilies(regions,families);
    int countAfterSingleFamily=countStoreFilesInFamily(regions,family);
    assertTrue(countAfter < countBefore);
    if (!singleFamily) {
      if (expectedState == CompactionState.MAJOR)       assertTrue(families.length == countAfter);
 else       assertTrue(families.length < countAfter);
    }
 else {
      int singleFamDiff=countBeforeSingleFamily - countAfterSingleFamily;
      assertTrue(singleFamDiff == (countBefore - countAfter));
      if (expectedState == CompactionState.MAJOR) {
        assertTrue(1 == countAfterSingleFamily);
      }
 else {
        assertTrue(1 < countAfterSingleFamily);
      }
    }
  }
  private static int countStoreFilesInFamily(  List<Region> regions,  final byte[] family){
    return countStoreFilesInFamilies(regions,new byte[][]{family});
  }
  private static int countStoreFilesInFamilies(  List<Region> regions,  final byte[][] families){
    int count=0;
    for (    Region region : regions) {
      count+=region.getStoreFileList(families).size();
    }
    return count;
  }
  static void loadData(  final TableName tableName,  final byte[][] families,  final int rows) throws IOException {
    loadData(tableName,families,rows,1);
  }
  static void loadData(  final TableName tableName,  final byte[][] families,  final int rows,  final int flushes) throws IOException {
    AsyncTable<?> table=ASYNC_CONN.getTable(tableName);
    List<Put> puts=new ArrayList<>(rows);
    byte[] qualifier=Bytes.toBytes("val");
    for (int i=0; i < flushes; i++) {
      for (int k=0; k < rows; k++) {
        byte[] row=Bytes.add(Bytes.toBytes(k),Bytes.toBytes(i));
        Put p=new Put(row);
        for (int j=0; j < families.length; ++j) {
          p.addColumn(families[j],qualifier,row);
        }
        puts.add(p);
      }
      table.putAll(puts).join();
      TEST_UTIL.flush();
      puts.clear();
    }
  }
}
