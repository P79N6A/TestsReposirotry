/** 
 * Test that we correctly serialize exceptions from a remote source
 */
@Category({MasterTests.class,SmallTests.class}) public class TestForeignExceptionSerialization {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestForeignExceptionSerialization.class);
  private static final String srcName="someNode";
  /** 
 * Verify that we get back similar stack trace information before an after serialization.
 */
  @Test public void testSimpleException() throws IOException {
    String data="some bytes";
    ForeignException in=new ForeignException("SRC",new IllegalArgumentException(data));
    ForeignException e=ForeignException.deserialize(ForeignException.serialize(srcName,in));
    assertNotNull(e);
    StackTraceElement elem=new StackTraceElement(this.getClass().toString(),"method","file",1);
    in.setStackTrace(new StackTraceElement[]{elem});
    e=ForeignException.deserialize(ForeignException.serialize(srcName,in));
    assertNotNull(e);
    assertEquals("Stack trace got corrupted",elem,e.getCause().getStackTrace()[0]);
    assertEquals("Got an unexpectedly long stack trace",1,e.getCause().getStackTrace().length);
  }
  /** 
 * Compare that a generic exception's stack trace has the same stack trace elements after serialization and deserialization
 */
  @Test public void testRemoteFromLocal() throws IOException {
    String errorMsg="some message";
    Exception generic=new Exception(errorMsg);
    generic.printStackTrace();
    assertTrue(generic.getMessage().contains(errorMsg));
    ForeignException e=ForeignException.deserialize(ForeignException.serialize(srcName,generic));
    assertArrayEquals("Local stack trace got corrupted",generic.getStackTrace(),e.getCause().getStackTrace());
    e.printStackTrace();
    assertTrue(e.getCause().getCause() == null);
    assertTrue(e.getCause().getMessage().contains(errorMsg));
  }
}
