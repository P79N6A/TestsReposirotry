/** 
 * Tests user specifiable time stamps putting, getting and scanning.  Also tests same in presence of deletes.  Test cores are written so can be run against an HRegion and against an HTable: i.e. both local and remote.
 */
public class TimestampTestBase {
  private static final long T0=10L;
  private static final long T1=100L;
  private static final long T2=200L;
  public static final byte[] FAMILY_NAME=Bytes.toBytes("colfamily11");
  private static final byte[] QUALIFIER_NAME=Bytes.toBytes("contents");
  private static final byte[] ROW=Bytes.toBytes("row");
interface FlushCache {
    void flushcache() throws IOException ;
  }
  public static void doTestDelete(  final Table table,  FlushCache flusher) throws IOException {
    put(table,T0);
    put(table,T1);
    put(table,T2);
    put(table);
    assertVersions(table,new long[]{HConstants.LATEST_TIMESTAMP,T2,T1});
    delete(table);
    assertVersions(table,new long[]{T2,T1,T0});
    flusher.flushcache();
    assertVersions(table,new long[]{T2,T1,T0});
    put(table);
    assertVersions(table,new long[]{HConstants.LATEST_TIMESTAMP,T2,T1});
    delete(table,T2);
    assertVersions(table,new long[]{HConstants.LATEST_TIMESTAMP,T1,T0});
    flusher.flushcache();
    assertVersions(table,new long[]{HConstants.LATEST_TIMESTAMP,T1,T0});
    put(table,T2);
    delete(table,T1);
    put(table,T1);
    Delete delete=new Delete(ROW);
    delete.addColumns(FAMILY_NAME,QUALIFIER_NAME,T2);
    table.delete(delete);
    assertOnlyLatest(table,HConstants.LATEST_TIMESTAMP);
    flusher.flushcache();
    assertOnlyLatest(table,HConstants.LATEST_TIMESTAMP);
  }
  private static void assertOnlyLatest(  final Table incommon,  final long currentTime) throws IOException {
    Get get=null;
    get=new Get(ROW);
    get.addColumn(FAMILY_NAME,QUALIFIER_NAME);
    get.setMaxVersions(3);
    Result result=incommon.get(get);
    Assert.assertEquals(1,result.size());
    long time=Bytes.toLong(CellUtil.cloneValue(result.rawCells()[0]));
    Assert.assertEquals(time,currentTime);
  }
  public static void assertVersions(  final Table incommon,  final long[] tss) throws IOException {
    Get get=null;
    get=new Get(ROW);
    get.addColumn(FAMILY_NAME,QUALIFIER_NAME);
    Result r=incommon.get(get);
    byte[] bytes=r.getValue(FAMILY_NAME,QUALIFIER_NAME);
    long t=Bytes.toLong(bytes);
    Assert.assertEquals(tss[0],t);
    get=new Get(ROW);
    get.addColumn(FAMILY_NAME,QUALIFIER_NAME);
    get.setMaxVersions(tss.length);
    Result result=incommon.get(get);
    Cell[] kvs=result.rawCells();
    Assert.assertEquals(kvs.length,tss.length);
    for (int i=0; i < kvs.length; i++) {
      t=Bytes.toLong(CellUtil.cloneValue(kvs[i]));
      Assert.assertEquals(tss[i],t);
    }
    long maxStamp=kvs[0].getTimestamp();
    get=new Get(ROW);
    get.addColumn(FAMILY_NAME,QUALIFIER_NAME);
    get.setTimeRange(0,maxStamp);
    get.setMaxVersions(kvs.length - 1);
    result=incommon.get(get);
    kvs=result.rawCells();
    Assert.assertEquals(kvs.length,tss.length - 1);
    for (int i=1; i < kvs.length; i++) {
      t=Bytes.toLong(CellUtil.cloneValue(kvs[i - 1]));
      Assert.assertEquals(tss[i],t);
    }
    assertScanContentTimestamp(incommon,tss[0]);
  }
  public static void doTestTimestampScanning(  final Table incommon,  final FlushCache flusher) throws IOException {
    put(incommon,T0);
    put(incommon,T1);
    put(incommon,HConstants.LATEST_TIMESTAMP);
    int count=assertScanContentTimestamp(incommon,HConstants.LATEST_TIMESTAMP);
    Assert.assertEquals(count,assertScanContentTimestamp(incommon,T0));
    Assert.assertEquals(count,assertScanContentTimestamp(incommon,T1));
    flusher.flushcache();
    Assert.assertEquals(count,assertScanContentTimestamp(incommon,T0));
    Assert.assertEquals(count,assertScanContentTimestamp(incommon,T1));
  }
  public static int assertScanContentTimestamp(  final Table in,  final long ts) throws IOException {
    Scan scan=new Scan(HConstants.EMPTY_START_ROW);
    scan.addFamily(FAMILY_NAME);
    scan.setTimeRange(0,ts);
    ResultScanner scanner=in.getScanner(scan);
    int count=0;
    try {
    }
  finally {
      scanner.close();
    }
    return count;
  }
  public static void put(  final Table loader,  final long ts) throws IOException {
    put(loader,Bytes.toBytes(ts),ts);
  }
  public static void put(  final Table loader) throws IOException {
    long ts=HConstants.LATEST_TIMESTAMP;
    put(loader,Bytes.toBytes(ts),ts);
  }
  public static void put(  final Table loader,  final byte[] bytes,  final long ts) throws IOException {
    Put put=new Put(ROW,ts);
    put.setDurability(Durability.SKIP_WAL);
    put.addColumn(FAMILY_NAME,QUALIFIER_NAME,bytes);
    loader.put(put);
  }
  public static void delete(  final Table loader) throws IOException {
    delete(loader,null);
  }
  public static void delete(  final Table loader,  final byte[] column) throws IOException {
    delete(loader,column,HConstants.LATEST_TIMESTAMP);
  }
  public static void delete(  final Table loader,  final long ts) throws IOException {
    delete(loader,null,ts);
  }
  public static void delete(  final Table loader,  final byte[] column,  final long ts) throws IOException {
    Delete delete=ts == HConstants.LATEST_TIMESTAMP ? new Delete(ROW) : new Delete(ROW,ts);
    delete.addColumn(FAMILY_NAME,QUALIFIER_NAME,ts);
    loader.delete(delete);
  }
  public static Result get(  final Table loader) throws IOException {
    return loader.get(new Get(ROW));
  }
}
