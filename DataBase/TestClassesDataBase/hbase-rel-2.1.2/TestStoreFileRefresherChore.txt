@Category({RegionServerTests.class,SmallTests.class}) public class TestStoreFileRefresherChore {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestStoreFileRefresherChore.class);
  private HBaseTestingUtility TEST_UTIL;
  private Path testDir;
  @Rule public TestName name=new TestName();
  @Before public void setUp() throws IOException {
    TEST_UTIL=new HBaseTestingUtility();
    testDir=TEST_UTIL.getDataTestDir("TestStoreFileRefresherChore");
    FSUtils.setRootDir(TEST_UTIL.getConfiguration(),testDir);
  }
  private TableDescriptor getTableDesc(  TableName tableName,  int regionReplication,  byte[]... families){
    TableDescriptorBuilder builder=TableDescriptorBuilder.newBuilder(tableName).setRegionReplication(regionReplication);
    Arrays.stream(families).map(family -> ColumnFamilyDescriptorBuilder.newBuilder(family).setMaxVersions(Integer.MAX_VALUE).build()).forEachOrdered(builder::setColumnFamily);
    return builder.build();
  }
static class FailingHRegionFileSystem extends HRegionFileSystem {
    boolean fail=false;
    FailingHRegionFileSystem(    Configuration conf,    FileSystem fs,    Path tableDir,    RegionInfo regionInfo){
      super(conf,fs,tableDir,regionInfo);
    }
    @Override public Collection<StoreFileInfo> getStoreFiles(    String familyName) throws IOException {
      if (fail) {
        throw new IOException("simulating FS failure");
      }
      return super.getStoreFiles(familyName);
    }
  }
  private HRegion initHRegion(  TableDescriptor htd,  byte[] startKey,  byte[] stopKey,  int replicaId) throws IOException {
    Configuration conf=TEST_UTIL.getConfiguration();
    Path tableDir=FSUtils.getTableDir(testDir,htd.getTableName());
    RegionInfo info=RegionInfoBuilder.newBuilder(htd.getTableName()).setStartKey(startKey).setEndKey(stopKey).setRegionId(0L).setReplicaId(replicaId).build();
    HRegionFileSystem fs=new FailingHRegionFileSystem(conf,tableDir.getFileSystem(conf),tableDir,info);
    final Configuration walConf=new Configuration(conf);
    FSUtils.setRootDir(walConf,tableDir);
    final WALFactory wals=new WALFactory(walConf,"log_" + replicaId);
    ChunkCreator.initialize(MemStoreLABImpl.CHUNK_SIZE_DEFAULT,false,0,0,0,null);
    HRegion region=new HRegion(fs,wals.getWAL(info),conf,htd,null);
    region.initialize();
    return region;
  }
  private void putData(  Region region,  int startRow,  int numRows,  byte[] qf,  byte[]... families) throws IOException {
    for (int i=startRow; i < startRow + numRows; i++) {
      Put put=new Put(Bytes.toBytes("" + i));
      put.setDurability(Durability.SKIP_WAL);
      for (      byte[] family : families) {
        put.addColumn(family,qf,null);
      }
      region.put(put);
    }
  }
  private void verifyDataExpectFail(  Region newReg,  int startRow,  int numRows,  byte[] qf,  byte[]... families) throws IOException {
    boolean threw=false;
    try {
      verifyData(newReg,startRow,numRows,qf,families);
    }
 catch (    AssertionError e) {
      threw=true;
    }
    if (!threw) {
      fail("Expected data verification to fail");
    }
  }
  private void verifyData(  Region newReg,  int startRow,  int numRows,  byte[] qf,  byte[]... families) throws IOException {
    for (int i=startRow; i < startRow + numRows; i++) {
      byte[] row=Bytes.toBytes("" + i);
      Get get=new Get(row);
      for (      byte[] family : families) {
        get.addColumn(family,qf);
      }
      Result result=newReg.get(get);
      Cell[] raw=result.rawCells();
      assertEquals(families.length,result.size());
      for (int j=0; j < families.length; j++) {
        assertTrue(CellUtil.matchingRows(raw[j],row));
        assertTrue(CellUtil.matchingFamily(raw[j],families[j]));
        assertTrue(CellUtil.matchingQualifier(raw[j],qf));
      }
    }
  }
static class StaleStorefileRefresherChore extends StorefileRefresherChore {
    boolean isStale=false;
    public StaleStorefileRefresherChore(    int period,    HRegionServer regionServer,    Stoppable stoppable){
      super(period,false,regionServer,stoppable);
    }
    @Override protected boolean isRegionStale(    String encodedName,    long time){
      return isStale;
    }
  }
  @Test public void testIsStale() throws IOException {
    int period=0;
    byte[][] families=new byte[][]{Bytes.toBytes("cf")};
    byte[] qf=Bytes.toBytes("cq");
    HRegionServer regionServer=mock(HRegionServer.class);
    List<HRegion> regions=new ArrayList<>();
    when(regionServer.getOnlineRegionsLocalContext()).thenReturn(regions);
    when(regionServer.getConfiguration()).thenReturn(TEST_UTIL.getConfiguration());
    TableDescriptor htd=getTableDesc(TableName.valueOf(name.getMethodName()),2,families);
    HRegion primary=initHRegion(htd,HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW,0);
    HRegion replica1=initHRegion(htd,HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW,1);
    regions.add(primary);
    regions.add(replica1);
    StaleStorefileRefresherChore chore=new StaleStorefileRefresherChore(period,regionServer,new StoppableImplementation());
    putData(primary,0,100,qf,families);
    primary.flush(true);
    verifyData(primary,0,100,qf,families);
    verifyDataExpectFail(replica1,0,100,qf,families);
    chore.chore();
    verifyData(replica1,0,100,qf,families);
    ((FailingHRegionFileSystem)replica1.getRegionFileSystem()).fail=true;
    putData(primary,100,100,qf,families);
    primary.flush(true);
    verifyData(primary,0,200,qf,families);
    chore.chore();
    verifyData(replica1,0,100,qf,families);
    verifyDataExpectFail(replica1,100,100,qf,families);
    chore.isStale=true;
    chore.chore();
    try {
      verifyData(replica1,0,100,qf,families);
      fail("should have failed with IOException");
    }
 catch (    IOException ex) {
    }
  }
}
