public static class LoadCounter implements ProcedureStore.ProcedureLoader {
  private final ArrayList<Procedure> corrupted=new ArrayList<>();
  private final ArrayList<Procedure> completed=new ArrayList<>();
  private final ArrayList<Procedure> runnable=new ArrayList<>();
  private Set<Long> procIds;
  private long maxProcId=0;
  public LoadCounter(){
    this(null);
  }
  public LoadCounter(  final Set<Long> procIds){
    this.procIds=procIds;
  }
  public void reset(){
    reset(null);
  }
  public void reset(  final Set<Long> procIds){
    corrupted.clear();
    completed.clear();
    runnable.clear();
    this.procIds=procIds;
    this.maxProcId=0;
  }
  public long getMaxProcId(){
    return maxProcId;
  }
  public ArrayList<Procedure> getRunnables(){
    return runnable;
  }
  public int getRunnableCount(){
    return runnable.size();
  }
  public ArrayList<Procedure> getCompleted(){
    return completed;
  }
  public int getCompletedCount(){
    return completed.size();
  }
  public int getLoadedCount(){
    return runnable.size() + completed.size();
  }
  public ArrayList<Procedure> getCorrupted(){
    return corrupted;
  }
  public int getCorruptedCount(){
    return corrupted.size();
  }
  public boolean isRunnable(  final long procId){
    for (    Procedure proc : runnable) {
      if (proc.getProcId() == procId) {
        return true;
      }
    }
    return false;
  }
  @Override public void setMaxProcId(  long maxProcId){
    this.maxProcId=maxProcId;
  }
  @Override public void load(  ProcedureIterator procIter) throws IOException {
    while (procIter.hasNext()) {
      long procId;
      if (procIter.isNextFinished()) {
        Procedure<?> proc=procIter.next();
        procId=proc.getProcId();
        LOG.debug("loading completed procId=" + procId + ": "+ proc);
        completed.add(proc);
      }
 else {
        Procedure proc=procIter.next();
        procId=proc.getProcId();
        LOG.debug("loading runnable procId=" + procId + ": "+ proc);
        runnable.add(proc);
      }
      if (procIds != null) {
        assertTrue("procId=" + procId + " unexpected",procIds.contains(procId));
      }
    }
  }
  @Override public void handleCorrupted(  ProcedureIterator procIter) throws IOException {
    while (procIter.hasNext()) {
      Procedure proc=procIter.next();
      LOG.debug("corrupted procId=" + proc.getProcId() + ": "+ proc);
      corrupted.add(proc);
    }
  }
}
