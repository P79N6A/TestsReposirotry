@Category({MasterTests.class,MediumTests.class}) public class TestMasterOperationsForRegionReplicas {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMasterOperationsForRegionReplicas.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRegionPlacement.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static Connection CONNECTION=null;
  private static Admin ADMIN;
  private static int numSlaves=2;
  private static Configuration conf;
  @Rule public TestName name=new TestName();
  @BeforeClass public static void setupBeforeClass() throws Exception {
    conf=TEST_UTIL.getConfiguration();
    conf.setBoolean("hbase.tests.use.shortcircuit.reads",false);
    TEST_UTIL.startMiniCluster(numSlaves);
    CONNECTION=ConnectionFactory.createConnection(TEST_UTIL.getConfiguration());
    ADMIN=CONNECTION.getAdmin();
    while (ADMIN.getClusterMetrics(EnumSet.of(Option.LIVE_SERVERS)).getLiveServerMetrics().size() < numSlaves) {
      Thread.sleep(100);
    }
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    if (ADMIN != null)     ADMIN.close();
    if (CONNECTION != null && !CONNECTION.isClosed())     CONNECTION.close();
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testCreateTableWithSingleReplica() throws Exception {
    final int numRegions=3;
    final int numReplica=1;
    final TableName tableName=TableName.valueOf(name.getMethodName());
    try {
      HTableDescriptor desc=new HTableDescriptor(tableName);
      desc.setRegionReplication(numReplica);
      desc.addFamily(new HColumnDescriptor("family"));
      ADMIN.createTable(desc,Bytes.toBytes("A"),Bytes.toBytes("Z"),numRegions);
      validateNumberOfRowsInMeta(tableName,numRegions,ADMIN.getConnection());
      List<RegionInfo> hris=MetaTableAccessor.getTableRegions(ADMIN.getConnection(),tableName);
      assert (hris.size() == numRegions * numReplica);
    }
  finally {
      ADMIN.disableTable(tableName);
      ADMIN.deleteTable(tableName);
    }
  }
  @Test public void testCreateTableWithMultipleReplicas() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final int numRegions=3;
    final int numReplica=2;
    try {
      HTableDescriptor desc=new HTableDescriptor(tableName);
      desc.setRegionReplication(numReplica);
      desc.addFamily(new HColumnDescriptor("family"));
      ADMIN.createTable(desc,Bytes.toBytes("A"),Bytes.toBytes("Z"),numRegions);
      TEST_UTIL.waitTableEnabled(tableName);
      validateNumberOfRowsInMeta(tableName,numRegions,ADMIN.getConnection());
      List<RegionInfo> hris=MetaTableAccessor.getTableRegions(ADMIN.getConnection(),tableName);
      assert (hris.size() == numRegions * numReplica);
      for (int i=0; i < numRegions; i++) {
        for (int j=0; j < numReplica; j++) {
          RegionInfo replica=RegionReplicaUtil.getRegionInfoForReplica(hris.get(i),j);
          RegionState state=TEST_UTIL.getHBaseCluster().getMaster().getAssignmentManager().getRegionStates().getRegionState(replica);
          assert (state != null);
        }
      }
      List<Result> metaRows=MetaTableAccessor.fullScanRegions(ADMIN.getConnection());
      int numRows=0;
      for (      Result result : metaRows) {
        RegionLocations locations=MetaTableAccessor.getRegionLocations(result);
        RegionInfo hri=locations.getRegionLocation().getRegionInfo();
        if (!hri.getTable().equals(tableName))         continue;
        numRows+=1;
        HRegionLocation[] servers=locations.getRegionLocations();
        assert (servers.length == 2);
        assert (!servers[0].equals(servers[1]));
      }
      assert (numRows == numRegions);
      validateFromSnapshotFromMeta(TEST_UTIL,tableName,numRegions,numReplica,ADMIN.getConnection());
      ServerName master=TEST_UTIL.getHBaseClusterInterface().getClusterMetrics().getMasterName();
      TEST_UTIL.getHBaseClusterInterface().stopMaster(master);
      TEST_UTIL.getHBaseClusterInterface().waitForMasterToStop(master,30000);
      TEST_UTIL.getHBaseClusterInterface().startMaster(master.getHostname(),master.getPort());
      TEST_UTIL.getHBaseClusterInterface().waitForActiveAndReadyMaster();
      for (int i=0; i < numRegions; i++) {
        for (int j=0; j < numReplica; j++) {
          RegionInfo replica=RegionReplicaUtil.getRegionInfoForReplica(hris.get(i),j);
          RegionState state=TEST_UTIL.getHBaseCluster().getMaster().getAssignmentManager().getRegionStates().getRegionState(replica);
          assert (state != null);
        }
      }
      validateFromSnapshotFromMeta(TEST_UTIL,tableName,numRegions,numReplica,ADMIN.getConnection());
      List<Integer> rsports=new ArrayList<>();
      for (      JVMClusterUtil.RegionServerThread rst : TEST_UTIL.getHBaseCluster().getLiveRegionServerThreads()) {
        rsports.add(rst.getRegionServer().getRpcServer().getListenerAddress().getPort());
      }
      TEST_UTIL.shutdownMiniHBaseCluster();
      TEST_UTIL.startMiniHBaseCluster(1,numSlaves,rsports);
      TEST_UTIL.waitTableEnabled(tableName);
      validateFromSnapshotFromMeta(TEST_UTIL,tableName,numRegions,numReplica,ADMIN.getConnection());
      TEST_UTIL.shutdownMiniHBaseCluster();
      TEST_UTIL.startMiniHBaseCluster(1,1);
      TEST_UTIL.waitTableEnabled(tableName);
      validateSingleRegionServerAssignment(ADMIN.getConnection(),numRegions,numReplica);
      for (int i=1; i < numSlaves; i++) {
        TEST_UTIL.getMiniHBaseCluster().startRegionServer();
      }
      ADMIN.disableTable(tableName);
      assert (ADMIN.isTableDisabled(tableName));
      desc.setRegionReplication(numReplica + 1);
      ADMIN.modifyTable(tableName,desc);
      ADMIN.enableTable(tableName);
      LOG.info(ADMIN.getTableDescriptor(tableName).toString());
      assert (ADMIN.isTableEnabled(tableName));
      List<RegionInfo> regions=TEST_UTIL.getMiniHBaseCluster().getMaster().getAssignmentManager().getRegionStates().getRegionsOfTable(tableName);
      assertTrue("regions.size=" + regions.size() + ", numRegions="+ numRegions+ ", numReplica="+ numReplica,regions.size() == numRegions * (numReplica + 1));
      ADMIN.disableTable(tableName);
      desc.setRegionReplication(numReplica);
      ADMIN.modifyTable(tableName,desc);
      ADMIN.enableTable(tableName);
      assert (ADMIN.isTableEnabled(tableName));
      regions=TEST_UTIL.getMiniHBaseCluster().getMaster().getAssignmentManager().getRegionStates().getRegionsOfTable(tableName);
      assert (regions.size() == numRegions * numReplica);
      hris=MetaTableAccessor.getTableRegions(ADMIN.getConnection(),tableName);
      assert (hris.size() == numRegions * numReplica);
      Map<RegionInfo,Integer> defaultReplicas=new HashMap<>();
      for (      RegionInfo hri : hris) {
        Integer i;
        RegionInfo regionReplica0=RegionReplicaUtil.getRegionInfoForDefaultReplica(hri);
        defaultReplicas.put(regionReplica0,(i=defaultReplicas.get(regionReplica0)) == null ? 1 : i + 1);
      }
      assert (defaultReplicas.size() == numRegions);
      Collection<Integer> counts=new HashSet<>(defaultReplicas.values());
      assert (counts.size() == 1 && counts.contains(numReplica));
    }
  finally {
      ADMIN.disableTable(tableName);
      ADMIN.deleteTable(tableName);
    }
  }
  @Test @Ignore("Enable when we have support for alter_table- HBASE-10361") public void testIncompleteMetaTableReplicaInformation() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    final int numRegions=3;
    final int numReplica=2;
    try {
      HTableDescriptor desc=new HTableDescriptor(tableName);
      desc.setRegionReplication(numReplica);
      desc.addFamily(new HColumnDescriptor("family"));
      ADMIN.createTable(desc,Bytes.toBytes("A"),Bytes.toBytes("Z"),numRegions);
      TEST_UTIL.waitTableEnabled(tableName);
      Set<byte[]> tableRows=new HashSet<>();
      List<RegionInfo> hris=MetaTableAccessor.getTableRegions(ADMIN.getConnection(),tableName);
      for (      RegionInfo hri : hris) {
        tableRows.add(hri.getRegionName());
      }
      ADMIN.disableTable(tableName);
      Table metaTable=ADMIN.getConnection().getTable(TableName.META_TABLE_NAME);
      for (      byte[] row : tableRows) {
        Delete deleteOneReplicaLocation=new Delete(row);
        deleteOneReplicaLocation.addColumns(HConstants.CATALOG_FAMILY,MetaTableAccessor.getServerColumn(1));
        deleteOneReplicaLocation.addColumns(HConstants.CATALOG_FAMILY,MetaTableAccessor.getSeqNumColumn(1));
        deleteOneReplicaLocation.addColumns(HConstants.CATALOG_FAMILY,MetaTableAccessor.getStartCodeColumn(1));
        metaTable.delete(deleteOneReplicaLocation);
      }
      metaTable.close();
      ADMIN.enableTable(tableName);
      assert (ADMIN.isTableEnabled(tableName));
      List<RegionInfo> regions=TEST_UTIL.getMiniHBaseCluster().getMaster().getAssignmentManager().getRegionStates().getRegionsOfTable(tableName);
      assert (regions.size() == numRegions * numReplica);
    }
  finally {
      ADMIN.disableTable(tableName);
      ADMIN.deleteTable(tableName);
    }
  }
  private String printRegions(  List<RegionInfo> regions){
    StringBuilder strBuf=new StringBuilder();
    for (    RegionInfo r : regions) {
      strBuf.append(" ____ " + r.toString());
    }
    return strBuf.toString();
  }
  private void validateNumberOfRowsInMeta(  final TableName table,  int numRegions,  Connection connection) throws IOException {
    assert (ADMIN.tableExists(table));
    final AtomicInteger count=new AtomicInteger();
    Visitor visitor=new Visitor(){
      @Override public boolean visit(      Result r) throws IOException {
        if (MetaTableAccessor.getRegionInfo(r).getTable().equals(table))         count.incrementAndGet();
        return true;
      }
    }
;
    MetaTableAccessor.fullScanRegions(connection,visitor);
    assert (count.get() == numRegions);
  }
  private void validateFromSnapshotFromMeta(  HBaseTestingUtility util,  TableName table,  int numRegions,  int numReplica,  Connection connection) throws IOException {
    SnapshotOfRegionAssignmentFromMeta snapshot=new SnapshotOfRegionAssignmentFromMeta(connection);
    snapshot.initialize();
    Map<RegionInfo,ServerName> regionToServerMap=snapshot.getRegionToRegionServerMap();
    assert (regionToServerMap.size() == numRegions * numReplica + 1);
    Map<ServerName,List<RegionInfo>> serverToRegionMap=snapshot.getRegionServerToRegionMap();
    for (    Map.Entry<ServerName,List<RegionInfo>> entry : serverToRegionMap.entrySet()) {
      if (entry.getKey().equals(util.getHBaseCluster().getMaster().getServerName())) {
        continue;
      }
      List<RegionInfo> regions=entry.getValue();
      Set<byte[]> setOfStartKeys=new HashSet<>();
      for (      RegionInfo region : regions) {
        byte[] startKey=region.getStartKey();
        if (region.getTable().equals(table)) {
          setOfStartKeys.add(startKey);
          LOG.info("--STARTKEY {}--",new String(startKey,StandardCharsets.UTF_8));
        }
      }
      assertEquals(numRegions,setOfStartKeys.size());
    }
  }
  private void validateSingleRegionServerAssignment(  Connection connection,  int numRegions,  int numReplica) throws IOException {
    SnapshotOfRegionAssignmentFromMeta snapshot=new SnapshotOfRegionAssignmentFromMeta(connection);
    snapshot.initialize();
    Map<RegionInfo,ServerName> regionToServerMap=snapshot.getRegionToRegionServerMap();
    assertEquals(regionToServerMap.size(),numRegions * numReplica + 1);
    Map<ServerName,List<RegionInfo>> serverToRegionMap=snapshot.getRegionServerToRegionMap();
    assertEquals("One Region Only",1,serverToRegionMap.keySet().size());
    for (    Map.Entry<ServerName,List<RegionInfo>> entry : serverToRegionMap.entrySet()) {
      if (entry.getKey().equals(TEST_UTIL.getHBaseCluster().getMaster().getServerName())) {
        continue;
      }
      assertEquals(entry.getValue().size(),numRegions * numReplica + 1);
    }
  }
}
