/** 
 * Test that the  {@link HFileArchiver} correctly removes all the parts of a region when cleaning upa region
 */
@Category({MediumTests.class,MiscTests.class}) public class TestHFileArchiving {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestHFileArchiving.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestHFileArchiving.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final byte[] TEST_FAM=Bytes.toBytes("fam");
  @Rule public TestName name=new TestName();
  /** 
 * Setup the config for the cluster
 */
  @BeforeClass public static void setupCluster() throws Exception {
    setupConf(UTIL.getConfiguration());
    UTIL.startMiniCluster();
    UTIL.getMiniHBaseCluster().getMaster().getHFileCleaner().cancel(true);
  }
  private static void setupConf(  Configuration conf){
    conf.setInt("hbase.regionsever.info.port",-1);
    conf.setInt("hbase.hregion.memstore.flush.size",25000);
    conf.setInt(HConstants.MAJOR_COMPACTION_PERIOD,0);
    conf.set(HConstants.HBASE_REGION_SPLIT_POLICY_KEY,ConstantSizeRegionSplitPolicy.class.getName());
  }
  @After public void tearDown() throws Exception {
    try {
      clearArchiveDirectory();
    }
 catch (    IOException e) {
      Assert.fail("Failure to delete archive directory:" + e.getMessage());
    }
  }
  @AfterClass public static void cleanupTest() throws Exception {
    try {
      UTIL.shutdownMiniCluster();
    }
 catch (    Exception e) {
    }
  }
  @Test public void testRemovesRegionDirOnArchive() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    UTIL.createTable(tableName,TEST_FAM);
    final Admin admin=UTIL.getAdmin();
    List<HRegion> servingRegions=UTIL.getHBaseCluster().getRegions(tableName);
    assertEquals(1,servingRegions.size());
    HRegion region=servingRegions.get(0);
    UTIL.loadRegion(region,TEST_FAM);
    admin.disableTable(tableName);
    FileSystem fs=UTIL.getTestFileSystem();
    Path rootDir=region.getRegionFileSystem().getTableDir().getParent();
    Path regionDir=HRegion.getRegionDir(rootDir,region.getRegionInfo());
    HFileArchiver.archiveRegion(UTIL.getConfiguration(),fs,region.getRegionInfo());
    Path archiveDir=HFileArchiveTestingUtil.getRegionArchiveDir(UTIL.getConfiguration(),region);
    assertTrue(fs.exists(archiveDir));
    FileStatus[] stores=fs.listStatus(archiveDir,new PathFilter(){
      @Override public boolean accept(      Path p){
        if (p.getName().contains(HConstants.RECOVERED_EDITS_DIR)) {
          return false;
        }
        return true;
      }
    }
);
    assertTrue(stores.length == 1);
    FileStatus[] storeFiles=fs.listStatus(stores[0].getPath());
    assertTrue(storeFiles.length > 0);
    assertFalse(fs.exists(regionDir));
    UTIL.deleteTable(tableName);
  }
  /** 
 * Test that the region directory is removed when we archive a region without store files, but still has hidden files.
 * @throws Exception
 */
  @Test public void testDeleteRegionWithNoStoreFiles() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    UTIL.createTable(tableName,TEST_FAM);
    List<HRegion> servingRegions=UTIL.getHBaseCluster().getRegions(tableName);
    assertEquals(1,servingRegions.size());
    HRegion region=servingRegions.get(0);
    FileSystem fs=region.getRegionFileSystem().getFileSystem();
    Path rootDir=FSUtils.getRootDir(fs.getConf());
    Path regionDir=HRegion.getRegionDir(rootDir,region.getRegionInfo());
    FileStatus[] regionFiles=FSUtils.listStatus(fs,regionDir,null);
    Assert.assertNotNull("No files in the region directory",regionFiles);
    if (LOG.isDebugEnabled()) {
      List<Path> files=new ArrayList<>();
      for (      FileStatus file : regionFiles) {
        files.add(file.getPath());
      }
      LOG.debug("Current files:" + files);
    }
    final PathFilter dirFilter=new FSUtils.DirFilter(fs);
    PathFilter nonHidden=new PathFilter(){
      @Override public boolean accept(      Path file){
        return dirFilter.accept(file) && !file.getName().toString().startsWith(".");
      }
    }
;
    FileStatus[] storeDirs=FSUtils.listStatus(fs,regionDir,nonHidden);
    for (    FileStatus store : storeDirs) {
      LOG.debug("Deleting store for test");
      fs.delete(store.getPath(),true);
    }
    HFileArchiver.archiveRegion(UTIL.getConfiguration(),fs,region.getRegionInfo());
    assertFalse("Region directory (" + regionDir + "), still exists.",fs.exists(regionDir));
    UTIL.deleteTable(tableName);
  }
  @Test public void testArchiveOnTableDelete() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    UTIL.createTable(tableName,TEST_FAM);
    List<HRegion> servingRegions=UTIL.getHBaseCluster().getRegions(tableName);
    assertEquals(1,servingRegions.size());
    HRegion region=servingRegions.get(0);
    HRegionServer hrs=UTIL.getRSForFirstRegionInTable(tableName);
    FileSystem fs=hrs.getFileSystem();
    LOG.debug("-------Loading table");
    UTIL.loadRegion(region,TEST_FAM);
    List<HRegion> regions=hrs.getRegions(tableName);
    assertEquals("More that 1 region for test table.",1,regions.size());
    region=regions.get(0);
    region.waitForFlushesAndCompactions();
    UTIL.getAdmin().disableTable(tableName);
    LOG.debug("Disabled table");
    clearArchiveDirectory();
    byte[][] columns=region.getTableDescriptor().getColumnFamilyNames().toArray(new byte[0][]);
    List<String> storeFiles=region.getStoreFileList(columns);
    UTIL.deleteTable(tableName);
    LOG.debug("Deleted table");
    assertArchiveFiles(fs,storeFiles,30000);
  }
  private void assertArchiveFiles(  FileSystem fs,  List<String> storeFiles,  long timeout) throws IOException {
    long end=System.currentTimeMillis() + timeout;
    Path archiveDir=HFileArchiveUtil.getArchivePath(UTIL.getConfiguration());
    List<String> archivedFiles=new ArrayList<>();
    while (System.currentTimeMillis() < end) {
      archivedFiles=getAllFileNames(fs,archiveDir);
      if (archivedFiles.size() >= storeFiles.size()) {
        break;
      }
    }
    Collections.sort(storeFiles);
    Collections.sort(archivedFiles);
    LOG.debug("Store files:");
    for (int i=0; i < storeFiles.size(); i++) {
      LOG.debug(i + " - " + storeFiles.get(i));
    }
    LOG.debug("Archive files:");
    for (int i=0; i < archivedFiles.size(); i++) {
      LOG.debug(i + " - " + archivedFiles.get(i));
    }
    assertTrue("Archived files are missing some of the store files!",archivedFiles.containsAll(storeFiles));
  }
  /** 
 * Test that the store files are archived when a column family is removed.
 * @throws Exception
 */
  @Test public void testArchiveOnTableFamilyDelete() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    UTIL.createTable(tableName,new byte[][]{TEST_FAM,Bytes.toBytes("fam2")});
    List<HRegion> servingRegions=UTIL.getHBaseCluster().getRegions(tableName);
    assertEquals(1,servingRegions.size());
    HRegion region=servingRegions.get(0);
    HRegionServer hrs=UTIL.getRSForFirstRegionInTable(tableName);
    FileSystem fs=hrs.getFileSystem();
    LOG.debug("-------Loading table");
    UTIL.loadRegion(region,TEST_FAM);
    List<HRegion> regions=hrs.getRegions(tableName);
    assertEquals("More that 1 region for test table.",1,regions.size());
    region=regions.get(0);
    region.waitForFlushesAndCompactions();
    UTIL.getAdmin().disableTable(tableName);
    LOG.debug("Disabled table");
    clearArchiveDirectory();
    byte[][] columns=region.getTableDescriptor().getColumnFamilyNames().toArray(new byte[0][]);
    List<String> storeFiles=region.getStoreFileList(columns);
    UTIL.getAdmin().deleteColumnFamily(tableName,TEST_FAM);
    assertArchiveFiles(fs,storeFiles,30000);
    UTIL.deleteTable(tableName);
  }
  /** 
 * Test HFileArchiver.resolveAndArchive() race condition HBASE-7643
 */
  @Test public void testCleaningRace() throws Exception {
    final long TEST_TIME=20 * 1000;
    final ChoreService choreService=new ChoreService("TEST_SERVER_NAME");
    Configuration conf=UTIL.getMiniHBaseCluster().getMaster().getConfiguration();
    Path rootDir=UTIL.getDataTestDirOnTestFS("testCleaningRace");
    FileSystem fs=UTIL.getTestFileSystem();
    Path archiveDir=new Path(rootDir,HConstants.HFILE_ARCHIVE_DIRECTORY);
    Path regionDir=new Path(FSUtils.getTableDir(new Path("./"),TableName.valueOf(name.getMethodName())),"abcdef");
    Path familyDir=new Path(regionDir,"cf");
    Path sourceRegionDir=new Path(rootDir,regionDir);
    fs.mkdirs(sourceRegionDir);
    Stoppable stoppable=new StoppableImplementation();
    HFileCleaner cleaner=new HFileCleaner(1,stoppable,conf,fs,archiveDir);
    try {
      choreService.scheduleChore(cleaner);
      long startTime=System.currentTimeMillis();
      for (long fid=0; (System.currentTimeMillis() - startTime) < TEST_TIME; ++fid) {
        Path file=new Path(familyDir,String.valueOf(fid));
        Path sourceFile=new Path(rootDir,file);
        Path archiveFile=new Path(archiveDir,file);
        fs.createNewFile(sourceFile);
        try {
          HFileArchiver.archiveRegion(fs,rootDir,sourceRegionDir.getParent(),sourceRegionDir);
          LOG.debug("hfile=" + fid + " should be in the archive");
          assertTrue(fs.exists(archiveFile));
          assertFalse(fs.exists(sourceFile));
        }
 catch (        IOException e) {
          LOG.debug("hfile=" + fid + " should be in the source location");
          assertFalse(fs.exists(archiveFile));
          assertTrue(fs.exists(sourceFile));
          fs.delete(sourceFile,false);
        }
      }
    }
  finally {
      stoppable.stop("test end");
      cleaner.cancel(true);
      choreService.shutdown();
      fs.delete(rootDir,true);
    }
  }
  private void clearArchiveDirectory() throws IOException {
    UTIL.getTestFileSystem().delete(new Path(UTIL.getDefaultRootDirPath(),HConstants.HFILE_ARCHIVE_DIRECTORY),true);
  }
  /** 
 * Get the names of all the files below the given directory
 * @param fs the file system to inspect
 * @param archiveDir the directory in which to look
 * @return a list of all files in the directory and sub-directories
 * @throws IOException
 */
  private List<String> getAllFileNames(  final FileSystem fs,  Path archiveDir) throws IOException {
    FileStatus[] files=FSUtils.listStatus(fs,archiveDir,new PathFilter(){
      @Override public boolean accept(      Path p){
        if (p.getName().contains(HConstants.RECOVERED_EDITS_DIR)) {
          return false;
        }
        return true;
      }
    }
);
    return recurseOnFiles(fs,files,new ArrayList<>());
  }
  /** 
 * Recursively lookup all the file names under the file[] array 
 */
  private List<String> recurseOnFiles(  FileSystem fs,  FileStatus[] files,  List<String> fileNames) throws IOException {
    if (files == null || files.length == 0)     return fileNames;
    for (    FileStatus file : files) {
      if (file.isDirectory()) {
        recurseOnFiles(fs,FSUtils.listStatus(fs,file.getPath(),null),fileNames);
      }
 else       fileNames.add(file.getPath().getName());
    }
    return fileNames;
  }
}
