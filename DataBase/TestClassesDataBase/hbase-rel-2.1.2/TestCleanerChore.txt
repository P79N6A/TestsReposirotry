@Category({MasterTests.class,SmallTests.class}) public class TestCleanerChore {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestCleanerChore.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestCleanerChore.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  @BeforeClass public static void setup(){
    CleanerChore.initChorePool(UTIL.getConfiguration());
  }
  @AfterClass public static void cleanup() throws Exception {
    UTIL.cleanupTestDir();
    CleanerChore.shutDownChorePool();
  }
  @Test public void testSavesFilesOnRequest() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,NeverDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    Path parent=new Path(testDir,"parent");
    Path file=new Path(parent,"someFile");
    fs.mkdirs(parent);
    fs.create(file).close();
    assertTrue("Test file didn't get created.",fs.exists(file));
    chore.chore();
    assertTrue("File shouldn't have been deleted",fs.exists(file));
    assertTrue("directory shouldn't have been deleted",fs.exists(parent));
  }
  @Test public void retriesIOExceptionInStatus() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    Path child=new Path(testDir,"child");
    Path file=new Path(child,"file");
    fs.mkdirs(child);
    fs.create(file).close();
    assertTrue("test file didn't get created.",fs.exists(file));
    final AtomicBoolean fails=new AtomicBoolean(true);
    FilterFileSystem filtered=new FilterFileSystem(fs){
      public FileStatus[] listStatus(      Path f) throws IOException {
        if (fails.get()) {
          throw new IOException("whomp whomp.");
        }
        return fs.listStatus(f);
      }
    }
;
    AllValidPaths chore=new AllValidPaths("test-retry-ioe",stop,conf,filtered,testDir,confKey);
    Boolean result=chore.runCleaner();
    assertTrue("test rig failed to inject failure.",fs.exists(file));
    assertTrue("test rig failed to inject failure.",fs.exists(child));
    assertFalse("chore should report that it failed.",result);
    fails.set(false);
    result=chore.runCleaner();
    assertFalse("file should have been destroyed.",fs.exists(file));
    assertFalse("directory should have been destroyed.",fs.exists(child));
    assertTrue("chore should claim it succeeded.",result);
  }
  @Test public void testDeletesEmptyDirectories() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    Path parent=new Path(testDir,"parent");
    Path child=new Path(parent,"child");
    Path emptyChild=new Path(parent,"emptyChild");
    Path file=new Path(child,"someFile");
    fs.mkdirs(child);
    fs.mkdirs(emptyChild);
    fs.create(file).close();
    Path topFile=new Path(testDir,"topFile");
    fs.create(topFile).close();
    assertTrue("Test file didn't get created.",fs.exists(file));
    assertTrue("Test file didn't get created.",fs.exists(topFile));
    chore.chore();
    assertFalse("File didn't get deleted",fs.exists(topFile));
    assertFalse("File didn't get deleted",fs.exists(file));
    assertFalse("Empty directory didn't get deleted",fs.exists(child));
    assertFalse("Empty directory didn't get deleted",fs.exists(parent));
  }
  /** 
 * Test to make sure that we don't attempt to ask the delegate whether or not we should preserve a directory.
 * @throws Exception on failure
 */
  @Test public void testDoesNotCheckDirectories() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    AlwaysDelete delegate=(AlwaysDelete)chore.cleanersChain.get(0);
    AlwaysDelete spy=Mockito.spy(delegate);
    chore.cleanersChain.set(0,spy);
    Path parent=new Path(testDir,"parent");
    Path file=new Path(parent,"someFile");
    fs.mkdirs(parent);
    assertTrue("Test parent didn't get created.",fs.exists(parent));
    fs.create(file).close();
    assertTrue("Test file didn't get created.",fs.exists(file));
    FileStatus fStat=fs.getFileStatus(parent);
    chore.chore();
    Mockito.verify(spy,Mockito.never()).isFileDeletable(fStat);
    Mockito.reset(spy);
  }
  @Test public void testStoppedCleanerDoesNotDeleteFiles() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    Path topFile=new Path(testDir,"topFile");
    fs.create(topFile).close();
    assertTrue("Test file didn't get created.",fs.exists(topFile));
    stop.stop("testing stop");
    chore.chore();
    assertTrue("File got deleted while chore was stopped",fs.exists(topFile));
  }
  /** 
 * While cleaning a directory, all the files in the directory may be deleted, but there may be another file added, in which case the directory shouldn't be deleted.
 * @throws IOException on failure
 */
  @Test public void testCleanerDoesNotDeleteDirectoryWithLateAddedFiles() throws IOException {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    final Path testDir=UTIL.getDataTestDir();
    final FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    AlwaysDelete delegate=(AlwaysDelete)chore.cleanersChain.get(0);
    AlwaysDelete spy=Mockito.spy(delegate);
    chore.cleanersChain.set(0,spy);
    final Path parent=new Path(testDir,"parent");
    Path file=new Path(parent,"someFile");
    fs.mkdirs(parent);
    fs.create(file).close();
    assertTrue("Test file didn't get created.",fs.exists(file));
    final Path addedFile=new Path(parent,"addedFile");
    Mockito.doAnswer(new Answer<Boolean>(){
      @Override public Boolean answer(      InvocationOnMock invocation) throws Throwable {
        fs.create(addedFile).close();
        FSUtils.logFileSystemState(fs,testDir,LOG);
        return (Boolean)invocation.callRealMethod();
      }
    }
).when(spy).isFileDeletable(Mockito.any());
    chore.chore();
    assertTrue("Added file unexpectedly deleted",fs.exists(addedFile));
    assertTrue("Parent directory deleted unexpectedly",fs.exists(parent));
    assertFalse("Original file unexpectedly retained",fs.exists(file));
    Mockito.verify(spy,Mockito.times(1)).isFileDeletable(Mockito.any());
    Mockito.reset(spy);
  }
  /** 
 * The cleaner runs in a loop, where it first checks to see all the files under a directory can be deleted. If they all can, then we try to delete the directory. However, a file may be added that directory to after the original check. This ensures that we don't accidentally delete that directory on and don't get spurious IOExceptions. <p> This was from HBASE-7465.
 * @throws Exception on failure
 */
  @Test public void testNoExceptionFromDirectoryWithRacyChildren() throws Exception {
    UTIL.cleanupTestDir();
    Stoppable stop=new StoppableImplementation();
    HBaseTestingUtility localUtil=new HBaseTestingUtility();
    Configuration conf=localUtil.getConfiguration();
    final Path testDir=UTIL.getDataTestDir();
    final FileSystem fs=UTIL.getTestFileSystem();
    LOG.debug("Writing test data to: " + testDir);
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    AlwaysDelete delegate=(AlwaysDelete)chore.cleanersChain.get(0);
    AlwaysDelete spy=Mockito.spy(delegate);
    chore.cleanersChain.set(0,spy);
    final Path parent=new Path(testDir,"parent");
    Path file=new Path(parent,"someFile");
    fs.mkdirs(parent);
    fs.create(file).close();
    assertTrue("Test file didn't get created.",fs.exists(file));
    final Path racyFile=new Path(parent,"addedFile");
    Mockito.doAnswer(new Answer<Boolean>(){
      @Override public Boolean answer(      InvocationOnMock invocation) throws Throwable {
        fs.create(racyFile).close();
        FSUtils.logFileSystemState(fs,testDir,LOG);
        return (Boolean)invocation.callRealMethod();
      }
    }
).when(spy).isFileDeletable(Mockito.any());
    chore.chore();
    assertTrue("Added file unexpectedly deleted",fs.exists(racyFile));
    assertTrue("Parent directory deleted unexpectedly",fs.exists(parent));
    assertFalse("Original file unexpectedly retained",fs.exists(file));
    Mockito.verify(spy,Mockito.times(1)).isFileDeletable(Mockito.any());
  }
  @Test public void testDeleteFileWithCleanerEnabled() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    chore.setEnabled(true);
    Path parent=new Path(testDir,"parent");
    Path child=new Path(parent,"child");
    Path file=new Path(child,"someFile");
    fs.mkdirs(child);
    fs.create(file).close();
    assertTrue("Test file didn't get created.",fs.exists(file));
    chore.chore();
    assertFalse("File didn't get deleted",fs.exists(file));
    assertFalse("Empty directory didn't get deleted",fs.exists(child));
    assertFalse("Empty directory didn't get deleted",fs.exists(parent));
  }
  @Test public void testDeleteFileWithCleanerDisabled() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    chore.setEnabled(false);
    Path parent=new Path(testDir,"parent");
    Path child=new Path(parent,"child");
    Path file=new Path(child,"someFile");
    fs.mkdirs(child);
    fs.create(file).close();
    assertTrue("Test file didn't get created.",fs.exists(file));
    chore.chore();
    assertTrue("File got deleted with cleaner disabled",fs.exists(file));
    assertTrue("Directory got deleted",fs.exists(child));
    assertTrue("Directory got deleted",fs.exists(parent));
  }
  @Test public void testOnConfigurationChange() throws Exception {
    int availableProcessorNum=Runtime.getRuntime().availableProcessors();
    if (availableProcessorNum == 1) {
      return;
    }
    int initPoolSize=availableProcessorNum / 2;
    int changedPoolSize=availableProcessorNum;
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    conf.set(CleanerChore.CHORE_POOL_SIZE,String.valueOf(initPoolSize));
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    chore.setEnabled(true);
    int dirNums=6;
    Path[] subdirs=new Path[dirNums];
    for (int i=0; i < dirNums; i++) {
      subdirs[i]=new Path(testDir,"subdir-" + i);
      fs.mkdirs(subdirs[i]);
    }
    for (    Path subdir : subdirs) {
      createFiles(fs,subdir,6);
    }
    Thread t=new Thread(() -> chore.chore());
    t.setDaemon(true);
    t.start();
    conf.set(CleanerChore.CHORE_POOL_SIZE,String.valueOf(changedPoolSize));
    chore.onConfigurationChange(conf);
    assertEquals(changedPoolSize,chore.getChorePoolSize());
    t.join();
  }
  @Test public void testMinimumNumberOfThreads() throws Exception {
    Stoppable stop=new StoppableImplementation();
    Configuration conf=UTIL.getConfiguration();
    Path testDir=UTIL.getDataTestDir();
    FileSystem fs=UTIL.getTestFileSystem();
    String confKey="hbase.test.cleaner.delegates";
    conf.set(confKey,AlwaysDelete.class.getName());
    conf.set(CleanerChore.CHORE_POOL_SIZE,"2");
    AllValidPaths chore=new AllValidPaths("test-file-cleaner",stop,conf,fs,testDir,confKey);
    int numProcs=Runtime.getRuntime().availableProcessors();
    assertEquals(numProcs,chore.calculatePoolSize(Integer.toString(numProcs)));
    assertEquals(numProcs,chore.calculatePoolSize(Integer.toString(numProcs + 2)));
    assertEquals(1,chore.calculatePoolSize("0.0"));
  }
  private void createFiles(  FileSystem fs,  Path parentDir,  int numOfFiles) throws IOException {
    Random random=new Random();
    for (int i=0; i < numOfFiles; i++) {
      int xMega=1 + random.nextInt(3);
      try (FSDataOutputStream fsdos=fs.create(new Path(parentDir,"file-" + i))){
        for (int m=0; m < xMega; m++) {
          byte[] M=new byte[1024 * 1024];
          random.nextBytes(M);
          fsdos.write(M);
        }
      }
     }
  }
private static class AllValidPaths extends CleanerChore<BaseHFileCleanerDelegate> {
    public AllValidPaths(    String name,    Stoppable s,    Configuration conf,    FileSystem fs,    Path oldFileDir,    String confkey){
      super(name,Integer.MAX_VALUE,s,conf,fs,oldFileDir,confkey);
    }
    @Override protected boolean validate(    Path file){
      return true;
    }
  }
public static class AlwaysDelete extends BaseHFileCleanerDelegate {
    @Override public boolean isFileDeletable(    FileStatus fStat){
      return true;
    }
  }
public static class NeverDelete extends BaseHFileCleanerDelegate {
    @Override public boolean isFileDeletable(    FileStatus fStat){
      return false;
    }
  }
}
