@Category({MasterTests.class,LargeTests.class}) public class TestSchedulerQueueDeadLock {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSchedulerQueueDeadLock.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final TableName TABLE_NAME=TableName.valueOf("deadlock");
private static final class TestEnv {
    private final MasterProcedureScheduler scheduler;
    public TestEnv(    MasterProcedureScheduler scheduler){
      this.scheduler=scheduler;
    }
    public MasterProcedureScheduler getScheduler(){
      return scheduler;
    }
  }
public static class TableSharedProcedure extends NoopProcedure<TestEnv> implements TableProcedureInterface {
    private final Semaphore latch=new Semaphore(0);
    @Override protected Procedure<TestEnv>[] execute(    TestEnv env) throws ProcedureYieldException, ProcedureSuspendedException, InterruptedException {
      latch.acquire();
      return null;
    }
    @Override protected LockState acquireLock(    TestEnv env){
      if (env.getScheduler().waitTableSharedLock(this,getTableName())) {
        return LockState.LOCK_EVENT_WAIT;
      }
      return LockState.LOCK_ACQUIRED;
    }
    @Override protected void releaseLock(    TestEnv env){
      env.getScheduler().wakeTableSharedLock(this,getTableName());
    }
    @Override protected boolean holdLock(    TestEnv env){
      return true;
    }
    @Override public TableName getTableName(){
      return TABLE_NAME;
    }
    @Override public TableOperationType getTableOperationType(){
      return TableOperationType.READ;
    }
  }
public static class TableExclusiveProcedure extends NoopProcedure<TestEnv> implements TableProcedureInterface {
    private final Semaphore latch=new Semaphore(0);
    @Override protected Procedure<TestEnv>[] execute(    TestEnv env) throws ProcedureYieldException, ProcedureSuspendedException, InterruptedException {
      latch.acquire();
      return null;
    }
    @Override protected LockState acquireLock(    TestEnv env){
      if (env.getScheduler().waitTableExclusiveLock(this,getTableName())) {
        return LockState.LOCK_EVENT_WAIT;
      }
      return LockState.LOCK_ACQUIRED;
    }
    @Override protected void releaseLock(    TestEnv env){
      env.getScheduler().wakeTableExclusiveLock(this,getTableName());
    }
    @Override protected boolean holdLock(    TestEnv env){
      return true;
    }
    @Override public TableName getTableName(){
      return TABLE_NAME;
    }
    @Override public TableOperationType getTableOperationType(){
      return TableOperationType.EDIT;
    }
  }
  @AfterClass public static void tearDownAfterClass() throws IOException {
    UTIL.cleanupTestDir();
  }
  private WALProcedureStore procStore;
  private ProcedureExecutor<TestEnv> procExec;
  @Rule public final TestName name=new TestName();
  @Before public void setUp() throws IOException {
    UTIL.getConfiguration().setInt("hbase.procedure.worker.stuck.threshold.msec",6000000);
    procStore=ProcedureTestingUtility.createWalStore(UTIL.getConfiguration(),UTIL.getDataTestDir(name.getMethodName()));
    procStore.start(1);
    MasterProcedureScheduler scheduler=new MasterProcedureScheduler(pid -> null);
    procExec=new ProcedureExecutor<>(UTIL.getConfiguration(),new TestEnv(scheduler),procStore,scheduler);
    procExec.init(1,false);
  }
  @After public void tearDown(){
    procExec.stop();
    procStore.stop(false);
  }
public static final class TableSharedProcedureWithId extends TableSharedProcedure {
    @Override protected void setProcId(    long procId){
      super.setProcId(2L);
    }
  }
public static final class TableExclusiveProcedureWithId extends TableExclusiveProcedure {
    @Override protected void setProcId(    long procId){
      super.setProcId(1L);
    }
  }
  @Test public void testTableProcedureDeadLockAfterRestarting() throws Exception {
    long procId1=procExec.submitProcedure(new TableSharedProcedureWithId());
    long procId2=procExec.submitProcedure(new TableExclusiveProcedureWithId());
    procExec.startWorkers();
    UTIL.waitFor(10000,() -> ((TableSharedProcedure)procExec.getProcedure(procId1)).latch.hasQueuedThreads());
    ProcedureTestingUtility.restart(procExec);
    ((TableSharedProcedure)procExec.getProcedure(procId1)).latch.release();
    ((TableExclusiveProcedure)procExec.getProcedure(procId2)).latch.release();
    UTIL.waitFor(10000,() -> procExec.isFinished(procId1));
    UTIL.waitFor(10000,() -> procExec.isFinished(procId2));
  }
public static final class TableShardParentProcedure extends NoopProcedure<TestEnv> implements TableProcedureInterface {
    private boolean scheduled;
    @Override protected Procedure<TestEnv>[] execute(    TestEnv env) throws ProcedureYieldException, ProcedureSuspendedException, InterruptedException {
      if (!scheduled) {
        scheduled=true;
        return new Procedure[]{new TableSharedProcedure()};
      }
      return null;
    }
    @Override protected LockState acquireLock(    TestEnv env){
      if (env.getScheduler().waitTableSharedLock(this,getTableName())) {
        return LockState.LOCK_EVENT_WAIT;
      }
      return LockState.LOCK_ACQUIRED;
    }
    @Override protected void releaseLock(    TestEnv env){
      env.getScheduler().wakeTableSharedLock(this,getTableName());
    }
    @Override protected boolean holdLock(    TestEnv env){
      return true;
    }
    @Override public TableName getTableName(){
      return TABLE_NAME;
    }
    @Override public TableOperationType getTableOperationType(){
      return TableOperationType.READ;
    }
  }
  @Test public void testTableProcedureSubProcedureDeadLock() throws Exception {
    long procId1=procExec.submitProcedure(new TableShardParentProcedure());
    long procId2=procExec.submitProcedure(new TableExclusiveProcedure());
    procExec.startWorkers();
    UTIL.waitFor(10000,() -> procExec.getProcedures().stream().anyMatch(p -> p instanceof TableSharedProcedure));
    procExec.getProcedures().stream().filter(p -> p instanceof TableSharedProcedure).map(p -> (TableSharedProcedure)p).forEach(p -> p.latch.release());
    ((TableExclusiveProcedure)procExec.getProcedure(procId2)).latch.release();
    UTIL.waitFor(10000,() -> procExec.isFinished(procId1));
    UTIL.waitFor(10000,() -> procExec.isFinished(procId2));
  }
}
