public class TimeBoundedMultiThreadedReaderThread extends MultiThreadedReader.HBaseReaderThread {
  public TimeBoundedMultiThreadedReaderThread(  int readerId) throws IOException {
    super(readerId);
  }
  @Override protected Get createGet(  long keyToRead) throws IOException {
    Get get=super.createGet(keyToRead);
    get.setConsistency(Consistency.TIMELINE);
    return get;
  }
  @Override protected long getNextKeyToRead(){
    long key=startKey + Math.abs(RandomUtils.nextLong()) % (endKey - startKey);
    return key;
  }
  @Override protected void verifyResultsAndUpdateMetrics(  boolean verify,  Get[] gets,  long elapsedNano,  Result[] results,  Table table,  boolean isNullExpected) throws IOException {
    super.verifyResultsAndUpdateMetrics(verify,gets,elapsedNano,results,table,isNullExpected);
    for (    Result r : results) {
      if (r.isStale())       staleReads.incrementAndGet();
    }
    if (elapsedNano > timeoutNano) {
      timedOutReads.incrementAndGet();
      numReadFailures.addAndGet(1);
      for (      Result r : results) {
        LOG.error("FAILED FOR " + r);
        RegionLocations rl=((ClusterConnection)connection).locateRegion(tableName,r.getRow(),true,true);
        HRegionLocation locations[]=rl.getRegionLocations();
        for (        HRegionLocation h : locations) {
          LOG.error("LOCATION " + h);
        }
      }
    }
  }
}
