@Category({MasterTests.class,LargeTests.class}) public class TestRestartCluster {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRestartCluster.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestRestartCluster.class);
  private HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final TableName[] TABLES={TableName.valueOf("restartTableOne"),TableName.valueOf("restartTableTwo"),TableName.valueOf("restartTableThree")};
  private static final byte[] FAMILY=Bytes.toBytes("family");
  @After public void tearDown() throws Exception {
    UTIL.shutdownMiniCluster();
  }
  @Test public void testClusterRestart() throws Exception {
    UTIL.startMiniCluster(3);
    while (!UTIL.getMiniHBaseCluster().getMaster().isInitialized()) {
      Threads.sleep(1);
    }
    LOG.info("\n\nCreating tables");
    for (    TableName TABLE : TABLES) {
      UTIL.createTable(TABLE,FAMILY);
    }
    for (    TableName TABLE : TABLES) {
      UTIL.waitTableEnabled(TABLE);
    }
    List<RegionInfo> allRegions=MetaTableAccessor.getAllRegions(UTIL.getConnection(),false);
    assertEquals(4,allRegions.size());
    LOG.info("\n\nShutting down cluster");
    UTIL.shutdownMiniHBaseCluster();
    LOG.info("\n\nSleeping a bit");
    Thread.sleep(2000);
    LOG.info("\n\nStarting cluster the second time");
    UTIL.restartHBaseCluster(3);
    allRegions=MetaTableAccessor.getAllRegions(UTIL.getConnection(),false);
    assertEquals(4,allRegions.size());
    LOG.info("\n\nWaiting for tables to be available");
    for (    TableName TABLE : TABLES) {
      try {
        UTIL.createTable(TABLE,FAMILY);
        assertTrue("Able to create table that should already exist",false);
      }
 catch (      TableExistsException tee) {
        LOG.info("Table already exists as expected");
      }
      UTIL.waitTableAvailable(TABLE);
    }
  }
  /** 
 * This tests retaining assignments on a cluster restart
 */
  @Test public void testRetainAssignmentOnRestart() throws Exception {
    UTIL.startMiniCluster(2);
    UTIL.getMiniHBaseCluster().getMaster().getMasterRpcServices().synchronousBalanceSwitch(false);
    LOG.info("\n\nCreating tables");
    for (    TableName TABLE : TABLES) {
      UTIL.createTable(TABLE,FAMILY);
    }
    for (    TableName TABLE : TABLES) {
      UTIL.waitTableEnabled(TABLE);
    }
    HMaster master=UTIL.getMiniHBaseCluster().getMaster();
    UTIL.waitUntilNoRegionsInTransition(120000);
    SnapshotOfRegionAssignmentFromMeta snapshot=new SnapshotOfRegionAssignmentFromMeta(master.getConnection());
    snapshot.initialize();
    Map<RegionInfo,ServerName> regionToRegionServerMap=snapshot.getRegionToRegionServerMap();
    MiniHBaseCluster cluster=UTIL.getHBaseCluster();
    List<JVMClusterUtil.RegionServerThread> threads=cluster.getLiveRegionServerThreads();
    assertEquals(2,threads.size());
    int[] rsPorts=new int[3];
    for (int i=0; i < 2; i++) {
      rsPorts[i]=threads.get(i).getRegionServer().getServerName().getPort();
    }
    rsPorts[2]=cluster.getMaster().getServerName().getPort();
    for (    ServerName serverName : regionToRegionServerMap.values()) {
      boolean found=false;
      for (int k=0; k < 3 && !found; k++) {
        found=serverName.getPort() == rsPorts[k];
      }
      assertTrue(found);
    }
    LOG.info("\n\nShutting down HBase cluster");
    cluster.stopMaster(0);
    cluster.shutdown();
    cluster.waitUntilShutDown();
    LOG.info("\n\nSleeping a bit");
    Thread.sleep(2000);
    LOG.info("\n\nStarting cluster the second time with the same ports");
    try {
      cluster.getConf().setInt(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART,3);
      master=cluster.startMaster().getMaster();
      for (int i=0; i < 3; i++) {
        cluster.getConf().setInt(HConstants.REGIONSERVER_PORT,rsPorts[i]);
        cluster.startRegionServer();
      }
    }
  finally {
      cluster.getConf().setInt(HConstants.REGIONSERVER_PORT,0);
      cluster.getConf().setInt(ServerManager.WAIT_ON_REGIONSERVERS_MINTOSTART,2);
    }
    List<ServerName> localServers=master.getServerManager().getOnlineServersList();
    assertEquals(3,localServers.size());
    for (int i=0; i < 3; i++) {
      boolean found=false;
      for (      ServerName serverName : localServers) {
        if (serverName.getPort() == rsPorts[i]) {
          found=true;
          break;
        }
      }
      assertTrue(found);
    }
    for (    TableName TABLE : TABLES) {
      UTIL.waitTableAvailable(TABLE);
    }
    snapshot=new SnapshotOfRegionAssignmentFromMeta(master.getConnection());
    snapshot.initialize();
    Map<RegionInfo,ServerName> newRegionToRegionServerMap=snapshot.getRegionToRegionServerMap();
    assertEquals(regionToRegionServerMap.size(),newRegionToRegionServerMap.size());
    for (    Map.Entry<RegionInfo,ServerName> entry : newRegionToRegionServerMap.entrySet()) {
      if (TableName.NAMESPACE_TABLE_NAME.equals(entry.getKey().getTable())) {
        continue;
      }
      ServerName oldServer=regionToRegionServerMap.get(entry.getKey());
      ServerName currentServer=entry.getValue();
      LOG.info("Key=" + entry.getKey() + " oldServer="+ oldServer+ ", currentServer="+ currentServer);
      assertEquals(entry.getKey().toString(),oldServer.getAddress(),currentServer.getAddress());
      assertNotEquals(oldServer.getStartcode(),currentServer.getStartcode());
    }
  }
  @Test public void testNewStartedRegionServerVersion() throws Exception {
    UTIL.startMiniCluster(1);
    Thread t=new Thread(() -> {
      for (int i=0; i < 3; i++) {
        try {
          JVMClusterUtil.RegionServerThread newRS=UTIL.getMiniHBaseCluster().startRegionServer();
          newRS.waitForServerOnline();
        }
 catch (        IOException e) {
          LOG.error("Failed to start a new RS",e);
        }
      }
    }
);
    t.start();
    HMaster master=UTIL.getMiniHBaseCluster().getMaster();
    while (t.isAlive()) {
      List<ServerName> serverNames=master.getServerManager().getOnlineServersList();
      for (      ServerName serverName : serverNames) {
        assertNotEquals(0,master.getServerManager().getVersionNumber(serverName));
      }
      Thread.sleep(100);
    }
  }
}
