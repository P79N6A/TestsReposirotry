@Category({MasterTests.class,MediumTests.class}) public class TestSnapshotWhileRSCrashes {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSnapshotWhileRSCrashes.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static TableName NAME=TableName.valueOf("Cleanup");
  private static byte[] CF=Bytes.toBytes("cf");
  @BeforeClass public static void setUp() throws Exception {
    UTIL.startMiniCluster(3);
    UTIL.createMultiRegionTable(NAME,CF);
    UTIL.waitTableAvailable(NAME);
  }
  @AfterClass public static void tearDown() throws Exception {
    UTIL.shutdownMiniCluster();
  }
  @Test public void test() throws InterruptedException, IOException {
    String snName="sn";
    MasterLock lock=UTIL.getMiniHBaseCluster().getMaster().getLockManager().createMasterLock(NAME,LockType.EXCLUSIVE,"for testing");
    lock.acquire();
    Thread t=new Thread(() -> {
      try {
        UTIL.getAdmin().snapshot(snName,NAME);
      }
 catch (      IOException e) {
        throw new UncheckedIOException(e);
      }
    }
);
    t.setDaemon(true);
    t.start();
    ProcedureExecutor<MasterProcedureEnv> procExec=UTIL.getMiniHBaseCluster().getMaster().getMasterProcedureExecutor();
    UTIL.waitFor(10000,() -> procExec.getProcedures().stream().filter(p -> !p.isFinished()).filter(p -> p instanceof LockProcedure).map(p -> (LockProcedure)p).filter(p -> NAME.equals(p.getTableName())).anyMatch(p -> !p.isLocked()));
    UTIL.getMiniHBaseCluster().stopRegionServer(0);
    lock.release();
    try (Table table=UTIL.getConnection().getTable(NAME);ResultScanner scanner=table.getScanner(CF)){
      assertNull(scanner.next());
    }
   }
}
