@Category({VerySlowMapReduceTests.class,LargeTests.class}) public class TestMultiTableSnapshotInputFormat extends MultiTableInputFormatTestBase {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMultiTableSnapshotInputFormat.class);
  protected Path restoreDir;
  @BeforeClass public static void setUpSnapshots() throws Exception {
    TEST_UTIL.enableDebug(MultiTableSnapshotInputFormat.class);
    TEST_UTIL.enableDebug(MultiTableSnapshotInputFormatImpl.class);
    for (    String tableName : TABLES) {
      SnapshotTestingUtils.createSnapshotAndValidate(TEST_UTIL.getAdmin(),TableName.valueOf(tableName),ImmutableList.of(INPUT_FAMILY),null,snapshotNameForTable(tableName),FSUtils.getRootDir(TEST_UTIL.getConfiguration()),TEST_UTIL.getTestFileSystem(),true);
    }
  }
  @Before public void setUp() throws Exception {
    this.restoreDir=TEST_UTIL.getRandomDir();
  }
  @Override protected void initJob(  List<Scan> scans,  Job job) throws IOException {
    TableMapReduceUtil.initMultiTableSnapshotMapperJob(getSnapshotScanMapping(scans),ScanMapper.class,ImmutableBytesWritable.class,ImmutableBytesWritable.class,job,true,restoreDir);
  }
  protected Map<String,Collection<Scan>> getSnapshotScanMapping(  final List<Scan> scans){
    return Multimaps.index(scans,new Function<Scan,String>(){
      @Nullable @Override public String apply(      Scan input){
        return snapshotNameForTable(Bytes.toStringBinary(input.getAttribute(Scan.SCAN_ATTRIBUTES_TABLE_NAME)));
      }
    }
).asMap();
  }
  public static String snapshotNameForTable(  String tableName){
    return tableName + "_snapshot";
  }
}
