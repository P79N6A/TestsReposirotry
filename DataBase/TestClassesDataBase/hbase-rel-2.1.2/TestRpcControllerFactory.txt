@Category({MediumTests.class,ClientTests.class}) public class TestRpcControllerFactory {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRpcControllerFactory.class);
public static class StaticRpcControllerFactory extends RpcControllerFactory {
    public StaticRpcControllerFactory(    Configuration conf){
      super(conf);
    }
    @Override public HBaseRpcController newController(){
      return new CountingRpcController(super.newController());
    }
    @Override public HBaseRpcController newController(    final CellScanner cellScanner){
      return new CountingRpcController(super.newController(cellScanner));
    }
    @Override public HBaseRpcController newController(    final List<CellScannable> cellIterables){
      return new CountingRpcController(super.newController(cellIterables));
    }
  }
public static class CountingRpcController extends DelegatingHBaseRpcController {
    private static Multiset<Integer> GROUPED_PRIORITY=ConcurrentHashMultiset.create();
    private static AtomicInteger INT_PRIORITY=new AtomicInteger();
    private static AtomicInteger TABLE_PRIORITY=new AtomicInteger();
    public CountingRpcController(    HBaseRpcController delegate){
      super(delegate);
    }
    @Override public void setPriority(    int priority){
      int oldPriority=getPriority();
      super.setPriority(priority);
      int newPriority=getPriority();
      if (newPriority != oldPriority) {
        INT_PRIORITY.incrementAndGet();
        GROUPED_PRIORITY.add(priority);
      }
    }
    @Override public void setPriority(    TableName tn){
      super.setPriority(tn);
      if (tn != null && !tn.isSystemTable()) {
        TABLE_PRIORITY.incrementAndGet();
      }
    }
  }
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  @Rule public TestName name=new TestName();
  @BeforeClass public static void setup() throws Exception {
    Configuration conf=UTIL.getConfiguration();
    conf.set(CoprocessorHost.REGION_COPROCESSOR_CONF_KEY,ProtobufCoprocessorService.class.getName());
    UTIL.startMiniCluster();
  }
  @AfterClass public static void teardown() throws Exception {
    UTIL.shutdownMiniCluster();
  }
  /** 
 * check some of the methods and make sure we are incrementing each time. Its a bit tediuous to cover all methods here and really is a bit brittle since we can always add new methods but won't be sure to add them here. So we just can cover the major ones.
 * @throws Exception on failure
 */
  @Test public void testCountController() throws Exception {
    Configuration conf=new Configuration(UTIL.getConfiguration());
    conf.set(RpcControllerFactory.CUSTOM_CONTROLLER_CONF_KEY,StaticRpcControllerFactory.class.getName());
    final TableName tableName=TableName.valueOf(name.getMethodName());
    UTIL.createTable(tableName,fam1).close();
    conf.setInt(HConstants.HBASE_RPC_TIMEOUT_KEY,HConstants.DEFAULT_HBASE_RPC_TIMEOUT + 1);
    Connection connection=ConnectionFactory.createConnection(conf);
    Table table=connection.getTable(tableName);
    byte[] row=Bytes.toBytes("row");
    Put p=new Put(row);
    p.addColumn(fam1,fam1,Bytes.toBytes("val0"));
    table.put(p);
    Integer counter=1;
    counter=verifyCount(counter);
    Delete d=new Delete(row);
    d.addColumn(fam1,fam1);
    table.delete(d);
    counter=verifyCount(counter);
    Put p2=new Put(row);
    p2.addColumn(fam1,Bytes.toBytes("qual"),Bytes.toBytes("val1"));
    table.batch(Lists.newArrayList(p,p2),null);
    counter=verifyCount(counter);
    Append append=new Append(row);
    append.addColumn(fam1,fam1,Bytes.toBytes("val2"));
    table.append(append);
    counter=verifyCount(counter);
    Get g=new Get(row);
    table.get(g);
    counter=verifyCount(counter);
    ResultScanner scan=table.getScanner(fam1);
    scan.next();
    scan.close();
    counter=verifyCount(counter + 1);
    Get g2=new Get(row);
    table.get(Lists.newArrayList(g,g2));
    counter=verifyCount(counter);
    Scan scanInfo=new Scan(row);
    scanInfo.setSmall(true);
    counter=doScan(table,scanInfo,counter);
    scanInfo.setReversed(true);
    counter=doScan(table,scanInfo,counter);
    scanInfo.setSmall(false);
    counter=doScan(table,scanInfo,counter + 1);
    verifyPriorityGroupCount(HConstants.ADMIN_QOS,0);
    Get get=new Get(row);
    get.setPriority(HConstants.ADMIN_QOS);
    table.get(get);
    verifyPriorityGroupCount(HConstants.ADMIN_QOS,1);
    table.close();
    connection.close();
  }
  int doScan(  Table table,  Scan scan,  int expectedCount) throws IOException {
    ResultScanner results=table.getScanner(scan);
    results.next();
    results.close();
    return verifyCount(expectedCount);
  }
  int verifyCount(  Integer counter){
    assertTrue(CountingRpcController.TABLE_PRIORITY.get() >= counter);
    assertEquals(0,CountingRpcController.INT_PRIORITY.get());
    return CountingRpcController.TABLE_PRIORITY.get() + 1;
  }
  void verifyPriorityGroupCount(  int priorityLevel,  int count){
    assertEquals(count,CountingRpcController.GROUPED_PRIORITY.count(priorityLevel));
  }
  @Test public void testFallbackToDefaultRpcControllerFactory(){
    Configuration conf=new Configuration(UTIL.getConfiguration());
    conf.set(RpcControllerFactory.CUSTOM_CONTROLLER_CONF_KEY,"foo.bar.Baz");
    RpcControllerFactory factory=RpcControllerFactory.instantiate(conf);
    assertNotNull(factory);
    assertEquals(factory.getClass(),RpcControllerFactory.class);
  }
}
