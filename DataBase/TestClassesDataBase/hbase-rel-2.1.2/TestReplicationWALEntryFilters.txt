@Category({ReplicationTests.class,SmallTests.class}) public class TestReplicationWALEntryFilters {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestReplicationWALEntryFilters.class);
  static byte[] a=new byte[]{'a'};
  static byte[] b=new byte[]{'b'};
  static byte[] c=new byte[]{'c'};
  static byte[] d=new byte[]{'d'};
  @Test public void testSystemTableWALEntryFilter(){
    SystemTableWALEntryFilter filter=new SystemTableWALEntryFilter();
    WALKeyImpl key1=new WALKeyImpl(RegionInfoBuilder.FIRST_META_REGIONINFO.getEncodedNameAsBytes(),TableName.META_TABLE_NAME,System.currentTimeMillis());
    Entry metaEntry=new Entry(key1,null);
    assertNull(filter.filter(metaEntry));
    WALKeyImpl key2=new WALKeyImpl(new byte[0],TableName.NAMESPACE_TABLE_NAME,System.currentTimeMillis());
    Entry nsEntry=new Entry(key2,null);
    assertNull(filter.filter(nsEntry));
    WALKeyImpl key3=new WALKeyImpl(new byte[0],TableName.valueOf("foo"),System.currentTimeMillis());
    Entry userEntry=new Entry(key3,null);
    assertEquals(userEntry,filter.filter(userEntry));
  }
  @Test public void testScopeWALEntryFilter(){
    WALEntryFilter filter=new ChainWALEntryFilter(new ScopeWALEntryFilter());
    Entry userEntry=createEntry(null,a,b);
    Entry userEntryA=createEntry(null,a);
    Entry userEntryB=createEntry(null,b);
    Entry userEntryEmpty=createEntry(null);
    assertTrue(filter.filter(userEntry).getEdit().isEmpty());
    TreeMap<byte[],Integer> scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
    userEntry=createEntry(scopes,a,b);
    assertTrue(filter.filter(userEntry).getEdit().isEmpty());
    scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
    scopes.put(c,HConstants.REPLICATION_SCOPE_GLOBAL);
    userEntry=createEntry(scopes,a,b);
    assertEquals(userEntryEmpty,filter.filter(userEntry));
    scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
    scopes.put(a,HConstants.REPLICATION_SCOPE_LOCAL);
    userEntry=createEntry(scopes,a,b);
    assertEquals(userEntryEmpty,filter.filter(userEntry));
    scopes.put(b,HConstants.REPLICATION_SCOPE_LOCAL);
    assertEquals(userEntryEmpty,filter.filter(userEntry));
    scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
    scopes.put(a,HConstants.REPLICATION_SCOPE_GLOBAL);
    userEntry=createEntry(scopes,a,b);
    assertEquals(userEntryA,filter.filter(userEntry));
    scopes.put(b,HConstants.REPLICATION_SCOPE_LOCAL);
    assertEquals(userEntryA,filter.filter(userEntry));
    scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
    scopes.put(b,HConstants.REPLICATION_SCOPE_GLOBAL);
    userEntry=createEntry(scopes,a,b);
    assertEquals(userEntryB,filter.filter(userEntry));
    scopes.put(a,HConstants.REPLICATION_SCOPE_LOCAL);
    assertEquals(userEntryB,filter.filter(userEntry));
    scopes=new TreeMap<>(Bytes.BYTES_COMPARATOR);
    scopes.put(b,HConstants.REPLICATION_SCOPE_GLOBAL);
    userEntry=createEntry(scopes,a,b);
    assertEquals(userEntryB,filter.filter(userEntry));
    scopes.put(a,HConstants.REPLICATION_SCOPE_LOCAL);
    assertEquals(userEntryB,filter.filter(userEntry));
  }
  WALEntryFilter nullFilter=new WALEntryFilter(){
    @Override public Entry filter(    Entry entry){
      return null;
    }
  }
;
  WALEntryFilter passFilter=new WALEntryFilter(){
    @Override public Entry filter(    Entry entry){
      return entry;
    }
  }
;
  @Test public void testChainWALEntryFilter(){
    Entry userEntry=createEntry(null,a,b,c);
    ChainWALEntryFilter filter=new ChainWALEntryFilter(passFilter);
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    filter=new ChainWALEntryFilter(passFilter,passFilter);
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    filter=new ChainWALEntryFilter(passFilter,passFilter,passFilter);
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    filter=new ChainWALEntryFilter(nullFilter);
    assertEquals(null,filter.filter(userEntry));
    filter=new ChainWALEntryFilter(nullFilter,passFilter);
    assertEquals(null,filter.filter(userEntry));
    filter=new ChainWALEntryFilter(passFilter,nullFilter);
    assertEquals(null,filter.filter(userEntry));
    filter=new ChainWALEntryFilter(nullFilter,passFilter,nullFilter);
    assertEquals(null,filter.filter(userEntry));
    filter=new ChainWALEntryFilter(nullFilter,nullFilter);
    assertEquals(null,filter.filter(userEntry));
    filter=new ChainWALEntryFilter(new ChainWALEntryFilter(passFilter,new ChainWALEntryFilter(passFilter,passFilter),new ChainWALEntryFilter(passFilter),new ChainWALEntryFilter(passFilter)),new ChainWALEntryFilter(passFilter));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    filter=new ChainWALEntryFilter(new ChainWALEntryFilter(passFilter,new ChainWALEntryFilter(passFilter,new ChainWALEntryFilter(nullFilter))),new ChainWALEntryFilter(passFilter));
    assertEquals(null,filter.filter(userEntry));
  }
  @Test public void testNamespaceTableCfWALEntryFilter(){
    ReplicationPeer peer=mock(ReplicationPeer.class);
    ReplicationPeerConfig peerConfig=mock(ReplicationPeerConfig.class);
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getNamespaces()).thenReturn(null);
    when(peerConfig.getTableCFsMap()).thenReturn(null);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    Entry userEntry=createEntry(null,a,b,c);
    ChainWALEntryFilter filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
    userEntry=createEntry(null,a,b,c);
    Map<TableName,List<String>> tableCfs=new HashMap<>();
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
    userEntry=createEntry(null,a,b,c);
    tableCfs=new HashMap<>();
    tableCfs.put(TableName.valueOf("bar"),null);
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
    userEntry=createEntry(null,a,b,c);
    tableCfs=new HashMap<>();
    tableCfs.put(TableName.valueOf("foo"),Lists.newArrayList("a"));
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a),filter.filter(userEntry));
    userEntry=createEntry(null,a,b,c,d);
    tableCfs=new HashMap<>();
    tableCfs.put(TableName.valueOf("foo"),Lists.newArrayList("a","c"));
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,c),filter.filter(userEntry));
    when(peer.getTableCFs()).thenReturn(null);
    Set<String> namespaces=new HashSet<>();
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getNamespaces()).thenReturn(namespaces);
    when(peerConfig.getTableCFsMap()).thenReturn(null);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
    namespaces.add("default");
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getNamespaces()).thenReturn(namespaces);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    namespaces=new HashSet<>();
    namespaces.add("ns1");
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getNamespaces()).thenReturn(namespaces);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
    namespaces=new HashSet<>();
    tableCfs=new HashMap<>();
    namespaces.add("ns1");
    tableCfs.put(TableName.valueOf("foo"),Lists.newArrayList("a","c"));
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getNamespaces()).thenReturn(namespaces);
    when(peerConfig.getTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,c),filter.filter(userEntry));
    namespaces=new HashSet<>();
    tableCfs=new HashMap<>();
    namespaces.add("default");
    tableCfs.put(TableName.valueOf("ns1:foo"),Lists.newArrayList("a","c"));
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getNamespaces()).thenReturn(namespaces);
    when(peerConfig.getTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    namespaces=new HashSet<>();
    tableCfs=new HashMap<>();
    namespaces.add("ns1");
    tableCfs.put(TableName.valueOf("bar"),null);
    when(peerConfig.replicateAllUserTables()).thenReturn(false);
    when(peerConfig.getNamespaces()).thenReturn(namespaces);
    when(peerConfig.getTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
  }
  @Test public void testNamespaceTableCfWALEntryFilter2(){
    ReplicationPeer peer=mock(ReplicationPeer.class);
    ReplicationPeerConfig peerConfig=mock(ReplicationPeerConfig.class);
    when(peerConfig.replicateAllUserTables()).thenReturn(true);
    when(peerConfig.getExcludeNamespaces()).thenReturn(null);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(null);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    Entry userEntry=createEntry(null,a,b,c);
    ChainWALEntryFilter filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    Set<String> namespaces=new HashSet<String>();
    when(peerConfig.getExcludeNamespaces()).thenReturn(namespaces);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(null);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    namespaces.add("default");
    when(peerConfig.getExcludeNamespaces()).thenReturn(namespaces);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(null);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
    namespaces=new HashSet<String>();
    namespaces.add("ns1");
    when(peerConfig.getExcludeNamespaces()).thenReturn(namespaces);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(null);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    Map<TableName,List<String>> tableCfs=new HashMap<TableName,List<String>>();
    when(peerConfig.getExcludeNamespaces()).thenReturn(null);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    tableCfs=new HashMap<TableName,List<String>>();
    tableCfs.put(TableName.valueOf("bar"),null);
    when(peerConfig.getExcludeNamespaces()).thenReturn(null);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,a,b,c),filter.filter(userEntry));
    tableCfs=new HashMap<TableName,List<String>>();
    tableCfs.put(TableName.valueOf("foo"),Lists.newArrayList("a"));
    when(peerConfig.getExcludeNamespaces()).thenReturn(null);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,b,c),filter.filter(userEntry));
    namespaces=new HashSet<String>();
    tableCfs=new HashMap<TableName,List<String>>();
    namespaces.add("ns1");
    tableCfs.put(TableName.valueOf("foo"),Lists.newArrayList("a","c"));
    when(peerConfig.getExcludeNamespaces()).thenReturn(namespaces);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(createEntry(null,b),filter.filter(userEntry));
    namespaces=new HashSet<String>();
    tableCfs=new HashMap<TableName,List<String>>();
    namespaces.add("default");
    tableCfs.put(TableName.valueOf("ns1:bar"),new ArrayList<String>());
    when(peerConfig.getExcludeNamespaces()).thenReturn(namespaces);
    when(peerConfig.getExcludeTableCFsMap()).thenReturn(tableCfs);
    when(peer.getPeerConfig()).thenReturn(peerConfig);
    userEntry=createEntry(null,a,b,c);
    filter=new ChainWALEntryFilter(new NamespaceTableCfWALEntryFilter(peer));
    assertEquals(null,filter.filter(userEntry));
  }
  private Entry createEntry(  TreeMap<byte[],Integer> scopes,  byte[]... kvs){
    WALKeyImpl key1=new WALKeyImpl(new byte[0],TableName.valueOf("foo"),System.currentTimeMillis(),scopes);
    WALEdit edit1=new WALEdit();
    for (    byte[] kv : kvs) {
      edit1.add(new KeyValue(kv,kv,kv));
    }
    return new Entry(key1,edit1);
  }
  private void assertEquals(  Entry e1,  Entry e2){
    Assert.assertEquals(e1 == null,e2 == null);
    if (e1 == null) {
      return;
    }
    Assert.assertEquals(e1.getEdit() == null,e2.getEdit() == null);
    if (e1.getEdit() == null) {
      return;
    }
    List<Cell> cells1=e1.getEdit().getCells();
    List<Cell> cells2=e2.getEdit().getCells();
    Assert.assertEquals(cells1.size(),cells2.size());
    for (int i=0; i < cells1.size(); i++) {
      CellComparatorImpl.COMPARATOR.compare(cells1.get(i),cells2.get(i));
    }
  }
}
