/** 
 * Test snapshot logic from the client
 */
@Category({SmallTests.class,ClientTests.class}) public class TestSnapshotFromAdmin {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSnapshotFromAdmin.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestSnapshotFromAdmin.class);
  @Rule public TestName name=new TestName();
  /** 
 * Test that the logic for doing 'correct' back-off based on exponential increase and the max-time passed from the server ensures the correct overall waiting for the snapshot to finish.
 * @throws Exception
 */
  @Test public void testBackoffLogic() throws Exception {
    final int pauseTime=100;
    final int maxWaitTime=HConstants.RETRY_BACKOFF[HConstants.RETRY_BACKOFF.length - 1] * pauseTime;
    final int numRetries=HConstants.RETRY_BACKOFF.length;
    long ignoreExpectedTime=0;
    for (int i=0; i < HConstants.RETRY_BACKOFF.length; i++) {
      ignoreExpectedTime+=HConstants.RETRY_BACKOFF[i] * pauseTime;
    }
    final long time=pauseTime * 3L + ((maxWaitTime / numRetries) * 3) + 300L;
    assertTrue("Capped snapshot wait time isn't less that the uncapped backoff time " + "- further testing won't prove anything.",time < ignoreExpectedTime);
    ConnectionImplementation mockConnection=Mockito.mock(ConnectionImplementation.class);
    Configuration conf=HBaseConfiguration.create();
    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,numRetries);
    conf.setLong("hbase.client.pause",pauseTime);
    MasterKeepAliveConnection mockMaster=Mockito.mock(MasterKeepAliveConnection.class);
    Mockito.when(mockConnection.getConfiguration()).thenReturn(conf);
    Mockito.when(mockConnection.getMaster()).thenReturn(mockMaster);
    RpcRetryingCallerFactory callerFactory=new RpcRetryingCallerFactory(conf);
    RpcControllerFactory controllerFactory=Mockito.mock(RpcControllerFactory.class);
    Mockito.when(controllerFactory.newController()).thenReturn(Mockito.mock(HBaseRpcController.class));
    Mockito.when(mockConnection.getRpcRetryingCallerFactory()).thenReturn(callerFactory);
    Mockito.when(mockConnection.getRpcControllerFactory()).thenReturn(controllerFactory);
    SnapshotResponse response=SnapshotResponse.newBuilder().setExpectedTimeout(maxWaitTime).build();
    Mockito.when(mockMaster.snapshot((RpcController)Mockito.any(),Mockito.any())).thenReturn(response);
    IsSnapshotDoneResponse.Builder builder=IsSnapshotDoneResponse.newBuilder();
    builder.setDone(false);
    Mockito.when(mockMaster.isSnapshotDone((RpcController)Mockito.any(),Mockito.any())).thenReturn(builder.build(),builder.build(),builder.build(),builder.build(),builder.build(),builder.setDone(true).build());
    Admin admin=new HBaseAdmin(mockConnection);
    String snapshot="snapshot";
    final TableName table=TableName.valueOf(name.getMethodName());
    long start=System.currentTimeMillis();
    admin.snapshot(snapshot,table);
    long finish=System.currentTimeMillis();
    long elapsed=(finish - start);
    assertTrue("Elapsed time:" + elapsed + " is more than expected max:"+ time,elapsed <= time);
    admin.close();
  }
  /** 
 * Make sure that we validate the snapshot name and the table name before we pass anything across the wire
 * @throws Exception on failure
 */
  @Test public void testValidateSnapshotName() throws Exception {
    ConnectionImplementation mockConnection=Mockito.mock(ConnectionImplementation.class);
    Configuration conf=HBaseConfiguration.create();
    Mockito.when(mockConnection.getConfiguration()).thenReturn(conf);
    RpcRetryingCallerFactory callerFactory=new RpcRetryingCallerFactory(conf);
    RpcControllerFactory controllerFactory=Mockito.mock(RpcControllerFactory.class);
    Mockito.when(controllerFactory.newController()).thenReturn(Mockito.mock(HBaseRpcController.class));
    Mockito.when(mockConnection.getRpcRetryingCallerFactory()).thenReturn(callerFactory);
    Mockito.when(mockConnection.getRpcControllerFactory()).thenReturn(controllerFactory);
    Admin admin=new HBaseAdmin(mockConnection);
    failSnapshotStart(admin,new SnapshotDescription(HConstants.SNAPSHOT_DIR_NAME));
    failSnapshotStart(admin,new SnapshotDescription("-snapshot"));
    failSnapshotStart(admin,new SnapshotDescription("snapshot fails"));
    failSnapshotStart(admin,new SnapshotDescription("snap$hot"));
    failSnapshotStart(admin,new SnapshotDescription("snap:hot"));
    failSnapshotDescriptorCreation("snapshot",".table");
    failSnapshotDescriptorCreation("snapshot","-table");
    failSnapshotDescriptorCreation("snapshot","table fails");
    failSnapshotDescriptorCreation("snapshot","tab%le");
    MasterKeepAliveConnection master=Mockito.mock(MasterKeepAliveConnection.class);
    Mockito.when(mockConnection.getMaster()).thenReturn(master);
    SnapshotResponse response=SnapshotResponse.newBuilder().setExpectedTimeout(0).build();
    Mockito.when(master.snapshot((RpcController)Mockito.any(),Mockito.any())).thenReturn(response);
    IsSnapshotDoneResponse doneResponse=IsSnapshotDoneResponse.newBuilder().setDone(true).build();
    Mockito.when(master.isSnapshotDone((RpcController)Mockito.any(),Mockito.any())).thenReturn(doneResponse);
    admin.snapshot(new SnapshotDescription("snapshot",TableName.valueOf(name.getMethodName())));
  }
  private void failSnapshotStart(  Admin admin,  SnapshotDescription snapshot) throws IOException {
    try {
      admin.snapshot(snapshot);
      fail("Snapshot should not have succeed with name:" + snapshot.getName());
    }
 catch (    IllegalArgumentException e) {
      LOG.debug("Correctly failed to start snapshot:" + e.getMessage());
    }
  }
  private void failSnapshotDescriptorCreation(  final String snapshotName,  final String tableName){
    try {
      new SnapshotDescription(snapshotName,tableName);
      fail("SnapshotDescription should not have succeed with name:" + snapshotName);
    }
 catch (    IllegalArgumentException e) {
      LOG.debug("Correctly failed to create SnapshotDescription:" + e.getMessage());
    }
  }
}
