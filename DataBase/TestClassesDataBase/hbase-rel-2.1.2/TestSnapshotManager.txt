/** 
 * Test basic snapshot manager functionality
 */
@Category({MasterTests.class,SmallTests.class}) public class TestSnapshotManager {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSnapshotManager.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  @Rule public TestName name=new TestName();
  MasterServices services=Mockito.mock(MasterServices.class);
  ProcedureCoordinator coordinator=Mockito.mock(ProcedureCoordinator.class);
  ExecutorService pool=Mockito.mock(ExecutorService.class);
  MasterFileSystem mfs=Mockito.mock(MasterFileSystem.class);
  FileSystem fs;
{
    try {
      fs=UTIL.getTestFileSystem();
    }
 catch (    IOException e) {
      throw new RuntimeException("Couldn't get test filesystem",e);
    }
  }
  private SnapshotManager getNewManager() throws IOException, KeeperException {
    return getNewManager(UTIL.getConfiguration());
  }
  private SnapshotManager getNewManager(  Configuration conf) throws IOException, KeeperException {
    return getNewManager(conf,1);
  }
  private SnapshotManager getNewManager(  Configuration conf,  int intervalSeconds) throws IOException, KeeperException {
    Mockito.reset(services);
    Mockito.when(services.getConfiguration()).thenReturn(conf);
    Mockito.when(services.getMasterFileSystem()).thenReturn(mfs);
    Mockito.when(mfs.getFileSystem()).thenReturn(fs);
    Mockito.when(mfs.getRootDir()).thenReturn(UTIL.getDataTestDir());
    return new SnapshotManager(services,coordinator,pool,intervalSeconds);
  }
  @Test public void testCleanFinishedHandler() throws Exception {
    TableName tableName=TableName.valueOf(name.getMethodName());
    Configuration conf=UTIL.getConfiguration();
    try {
      conf.setLong(SnapshotManager.HBASE_SNAPSHOT_SENTINELS_CLEANUP_TIMEOUT_MILLIS,5 * 1000L);
      SnapshotManager manager=getNewManager(conf,1);
      TakeSnapshotHandler handler=Mockito.mock(TakeSnapshotHandler.class);
      assertFalse("Manager is in process when there is no current handler",manager.isTakingSnapshot(tableName));
      manager.setSnapshotHandlerForTesting(tableName,handler);
      Mockito.when(handler.isFinished()).thenReturn(false);
      assertTrue(manager.isTakingAnySnapshot());
      assertTrue("Manager isn't in process when handler is running",manager.isTakingSnapshot(tableName));
      Mockito.when(handler.isFinished()).thenReturn(true);
      assertFalse("Manager is process when handler isn't running",manager.isTakingSnapshot(tableName));
      assertTrue(manager.isTakingAnySnapshot());
      Thread.sleep(6 * 1000);
      assertFalse(manager.isTakingAnySnapshot());
    }
  finally {
      conf.unset(SnapshotManager.HBASE_SNAPSHOT_SENTINELS_CLEANUP_TIMEOUT_MILLIS);
    }
  }
  @Test public void testInProcess() throws KeeperException, IOException {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    SnapshotManager manager=getNewManager();
    TakeSnapshotHandler handler=Mockito.mock(TakeSnapshotHandler.class);
    assertFalse("Manager is in process when there is no current handler",manager.isTakingSnapshot(tableName));
    manager.setSnapshotHandlerForTesting(tableName,handler);
    Mockito.when(handler.isFinished()).thenReturn(false);
    assertTrue("Manager isn't in process when handler is running",manager.isTakingSnapshot(tableName));
    Mockito.when(handler.isFinished()).thenReturn(true);
    assertFalse("Manager is process when handler isn't running",manager.isTakingSnapshot(tableName));
  }
  /** 
 * Verify the snapshot support based on the configuration.
 */
  @Test public void testSnapshotSupportConfiguration() throws Exception {
    Configuration conf=new Configuration();
    SnapshotManager manager=getNewManager(conf);
    assertFalse("Snapshot should be disabled with no configuration",isSnapshotSupported(manager));
    conf=new Configuration();
    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED,true);
    manager=getNewManager(conf);
    assertTrue("Snapshot should be enabled",isSnapshotSupported(manager));
    conf=new Configuration();
    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED,false);
    manager=getNewManager(conf);
    assertFalse("Snapshot should be disabled",isSnapshotSupported(manager));
    conf=new Configuration();
    conf.setStrings(HFileCleaner.MASTER_HFILE_CLEANER_PLUGINS,SnapshotHFileCleaner.class.getName(),HFileLinkCleaner.class.getName());
    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED,false);
    manager=getNewManager(conf);
    assertFalse("Snapshot should be disabled",isSnapshotSupported(manager));
    conf=new Configuration();
    conf.setStrings(HFileCleaner.MASTER_HFILE_CLEANER_PLUGINS,SnapshotHFileCleaner.class.getName(),HFileLinkCleaner.class.getName());
    manager=getNewManager(conf);
    assertTrue("Snapshot should be enabled, because cleaners are present",isSnapshotSupported(manager));
    Path rootDir=UTIL.getDataTestDir();
    Path testSnapshotDir=SnapshotDescriptionUtils.getCompletedSnapshotDir("testSnapshotSupportConfiguration",rootDir);
    fs.mkdirs(testSnapshotDir);
    try {
      conf=new Configuration();
      conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED,false);
      manager=getNewManager(conf);
      fail("Master should not start when snapshot is disabled, but snapshots are present");
    }
 catch (    UnsupportedOperationException e) {
    }
 finally {
      fs.delete(testSnapshotDir,true);
    }
  }
  private boolean isSnapshotSupported(  final SnapshotManager manager){
    try {
      manager.checkSnapshotSupport();
      return true;
    }
 catch (    UnsupportedOperationException e) {
      return false;
    }
  }
}
