/** 
 * This test verifies the correctness of the Per Column Family flushing strategy when part of the memstores are compacted memstores
 */
@Category({RegionServerTests.class,LargeTests.class}) public class TestWalAndCompactingMemStoreFlush {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestWalAndCompactingMemStoreFlush.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final Path DIR=TEST_UTIL.getDataTestDir("TestHRegion");
  public static final TableName TABLENAME=TableName.valueOf("TestWalAndCompactingMemStoreFlush","t1");
  public static final byte[][] FAMILIES={Bytes.toBytes("f1"),Bytes.toBytes("f2"),Bytes.toBytes("f3"),Bytes.toBytes("f4"),Bytes.toBytes("f5")};
  public static final byte[] FAMILY1=FAMILIES[0];
  public static final byte[] FAMILY2=FAMILIES[1];
  public static final byte[] FAMILY3=FAMILIES[2];
  private Configuration conf;
  private HRegion initHRegion(  String callingMethod,  Configuration conf) throws IOException {
    int i=0;
    HTableDescriptor htd=new HTableDescriptor(TABLENAME);
    for (    byte[] family : FAMILIES) {
      HColumnDescriptor hcd=new HColumnDescriptor(family);
      if (i % 2 == 0) {
        hcd.setInMemoryCompaction(MemoryCompactionPolicy.valueOf(conf.get(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY)));
      }
 else {
        hcd.setInMemoryCompaction(MemoryCompactionPolicy.NONE);
      }
      htd.addFamily(hcd);
      i++;
    }
    HRegionInfo info=new HRegionInfo(TABLENAME,null,null,false);
    Path path=new Path(DIR,callingMethod);
    return HBaseTestingUtility.createRegionAndWAL(info,path,conf,htd);
  }
  private Put createPut(  int familyNum,  int putNum){
    byte[] qf=Bytes.toBytes("q" + familyNum);
    byte[] row=Bytes.toBytes("row" + familyNum + "-"+ putNum);
    byte[] val=Bytes.toBytes("val" + familyNum + "-"+ putNum);
    Put p=new Put(row);
    p.addColumn(FAMILIES[familyNum - 1],qf,val);
    return p;
  }
  private Put createDoublePut(  int familyNum,  int putNum){
    byte[] qf=Bytes.toBytes("q" + familyNum);
    byte[] row=Bytes.toBytes("row" + familyNum + "-"+ putNum);
    byte[] val=Bytes.toBytes("val" + familyNum + "-"+ putNum);
    Put p=new Put(row);
    p.addColumn(FAMILIES[familyNum - 1],qf,10,val);
    p.addColumn(FAMILIES[familyNum - 1],qf,20,val);
    return p;
  }
  private Get createGet(  int familyNum,  int putNum){
    byte[] row=Bytes.toBytes("row" + familyNum + "-"+ putNum);
    return new Get(row);
  }
  private void verifyInMemoryFlushSize(  Region region){
    assertEquals(((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).getInmemoryFlushSize(),((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).getInmemoryFlushSize());
  }
  void verifyEdit(  int familyNum,  int putNum,  Table table) throws IOException {
    Result r=table.get(createGet(familyNum,putNum));
    byte[] family=FAMILIES[familyNum - 1];
    byte[] qf=Bytes.toBytes("q" + familyNum);
    byte[] val=Bytes.toBytes("val" + familyNum + "-"+ putNum);
    assertNotNull(("Missing Put#" + putNum + " for CF# "+ familyNum),r.getFamilyMap(family));
    assertNotNull(("Missing Put#" + putNum + " for CF# "+ familyNum),r.getFamilyMap(family).get(qf));
    assertTrue(("Incorrect value for Put#" + putNum + " for CF# "+ familyNum),Arrays.equals(r.getFamilyMap(family).get(qf),val));
  }
  @Before public void setup(){
    conf=HBaseConfiguration.create(TEST_UTIL.getConfiguration());
    conf.set(FlushPolicyFactory.HBASE_FLUSH_POLICY_KEY,FlushNonSloppyStoresFirstPolicy.class.getName());
    conf.setDouble(CompactingMemStore.IN_MEMORY_FLUSH_THRESHOLD_FACTOR_KEY,0.5);
  }
  @Test public void testSelectiveFlushWithEager() throws IOException {
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,300 * 1024);
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,75 * 1024);
    conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.EAGER));
    HRegion region=initHRegion("testSelectiveFlushWithEager",conf);
    verifyInMemoryFlushSize(region);
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createDoublePut(3,i));
        }
      }
    }
    for (int i=100; i < 2000; i++) {
      region.put(createPut(2,i));
    }
    long totalMemstoreSize=region.getMemStoreDataSize();
    long smallestSeqCF1PhaseI=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2PhaseI=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3PhaseI=region.getOldestSeqIdOfStore(FAMILY3);
    MemStoreSize cf1MemstoreSizePhaseI=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseI=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseI=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseI=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    String s="\n\n----------------------------------\n" + "Upon initial insert and before any flush, size of CF1 is:" + cf1MemstoreSizePhaseI + ", is CF1 compacted memstore?:"+ region.getStore(FAMILY1).isSloppyMemStore()+ ". Size of CF2 is:"+ cf2MemstoreSizePhaseI+ ", is CF2 compacted memstore?:"+ region.getStore(FAMILY2).isSloppyMemStore()+ ". Size of CF3 is:"+ cf3MemstoreSizePhaseI+ ", is CF3 compacted memstore?:"+ region.getStore(FAMILY3).isSloppyMemStore()+ "\n";
    assertEquals(smallestSeqCF1PhaseI,smallestSeqInRegionCurrentMemstorePhaseI);
    assertTrue(smallestSeqCF1PhaseI < smallestSeqCF2PhaseI);
    assertTrue(smallestSeqCF2PhaseI < smallestSeqCF3PhaseI);
    assertTrue(cf1MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf2MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf3MemstoreSizePhaseI.getDataSize() > 0);
    String msg="totalMemstoreSize=" + totalMemstoreSize + " cf1MemstoreSizePhaseI="+ cf1MemstoreSizePhaseI+ " cf2MemstoreSizePhaseI="+ cf2MemstoreSizePhaseI+ " cf3MemstoreSizePhaseI="+ cf3MemstoreSizePhaseI;
    assertEquals(msg,totalMemstoreSize,cf1MemstoreSizePhaseI.getDataSize() + cf2MemstoreSizePhaseI.getDataSize() + cf3MemstoreSizePhaseI.getDataSize());
    CompactingMemStore cms1=(CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore;
    CompactingMemStore cms3=(CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore;
    cms1.flushInMemory();
    cms3.flushInMemory();
    region.flush(false);
    MemStoreSize cf1MemstoreSizePhaseII=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseII=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseII=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseII=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long smallestSeqCF1PhaseII=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2PhaseII=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3PhaseII=region.getOldestSeqIdOfStore(FAMILY3);
    s=s + "\n----After first flush! CF1 should be flushed to memory, but not compacted.---\n" + "Size of CF1 is:"+ cf1MemstoreSizePhaseII+ ", size of CF2 is:"+ cf2MemstoreSizePhaseII+ ", size of CF3 is:"+ cf3MemstoreSizePhaseII+ "\n";
    assertTrue(cf1MemstoreSizePhaseII.getDataSize() == cf1MemstoreSizePhaseI.getDataSize());
    assertTrue(cf1MemstoreSizePhaseII.getHeapSize() < cf1MemstoreSizePhaseI.getHeapSize());
    assertEquals(0,cf2MemstoreSizePhaseII.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSizePhaseII.getHeapSize());
    assertTrue(cf3MemstoreSizePhaseI.getDataSize() > cf3MemstoreSizePhaseII.getDataSize());
    assertTrue(cf3MemstoreSizePhaseI.getHeapSize() / 2 > cf3MemstoreSizePhaseII.getHeapSize());
    assertEquals(smallestSeqInRegionCurrentMemstorePhaseII,smallestSeqCF1PhaseI);
    for (int i=1200; i < 3000; i++) {
      region.put(createPut(1,i));
    }
    s=s + "The smallest sequence in region WAL is: " + smallestSeqInRegionCurrentMemstorePhaseII+ ", the smallest sequence in CF1:"+ smallestSeqCF1PhaseII+ ", "+ "the smallest sequence in CF2:"+ smallestSeqCF2PhaseII+ ", the smallest sequence in CF3:"+ smallestSeqCF3PhaseII+ "\n";
    MemStoreSize cf1MemstoreSizePhaseIII=region.getStore(FAMILY1).getMemStoreSize();
    long smallestSeqCF1PhaseIII=region.getOldestSeqIdOfStore(FAMILY1);
    s=s + "----After more puts into CF1 its size is:" + cf1MemstoreSizePhaseIII+ ", and its sequence is:"+ smallestSeqCF1PhaseIII+ " ----\n";
    region.flush(false);
    MemStoreSize cf1MemstoreSizePhaseIV=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseIV=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseIV=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseIV=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long smallestSeqCF1PhaseIV=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2PhaseIV=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3PhaseIV=region.getOldestSeqIdOfStore(FAMILY3);
    s=s + "----After SECOND FLUSH, CF1 size is:" + cf1MemstoreSizePhaseIV+ ", CF2 size is:"+ cf2MemstoreSizePhaseIV+ " and CF3 size is:"+ cf3MemstoreSizePhaseIV+ "\n";
    s=s + "The smallest sequence in region WAL is: " + smallestSeqInRegionCurrentMemstorePhaseIV+ ", the smallest sequence in CF1:"+ smallestSeqCF1PhaseIV+ ", "+ "the smallest sequence in CF2:"+ smallestSeqCF2PhaseIV+ ", the smallest sequence in CF3:"+ smallestSeqCF3PhaseIV+ "\n";
    assertTrue(cf1MemstoreSizePhaseIII.getDataSize() > cf1MemstoreSizePhaseIV.getDataSize());
    assertEquals(0,cf2MemstoreSizePhaseIV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSizePhaseIV.getHeapSize());
    assertEquals(cf3MemstoreSizePhaseIV,cf3MemstoreSizePhaseII);
    assertEquals(smallestSeqCF3PhaseII,smallestSeqCF3PhaseIV);
    assertEquals(s,smallestSeqInRegionCurrentMemstorePhaseIV,smallestSeqCF3PhaseIV);
    region.flush(true);
    MemStoreSize cf1MemstoreSizePhaseV=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseV=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseV=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseV=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    assertEquals(0,cf1MemstoreSizePhaseV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf1MemstoreSizePhaseV.getHeapSize());
    assertEquals(0,cf2MemstoreSizePhaseV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSizePhaseV.getHeapSize());
    assertEquals(0,cf3MemstoreSizePhaseV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf3MemstoreSizePhaseV.getHeapSize());
    for (int i=1; i <= 300; i++) {
      region.put(createPut(1,i));
      region.put(createPut(2,i));
      region.put(createPut(3,i));
      region.put(createPut(4,i));
      region.put(createPut(5,i));
    }
    region.flush(false);
    s=s + "----AFTER THIRD AND FORTH FLUSH, The smallest sequence in region WAL is: " + smallestSeqInRegionCurrentMemstorePhaseV+ ". After additional inserts and last flush, the entire region size is:"+ region.getMemStoreDataSize()+ "\n----------------------------------\n";
    assertEquals(0,region.getMemStoreDataSize());
    System.out.println(s);
    HBaseTestingUtility.closeRegionAndWAL(region);
  }
  @Test public void testSelectiveFlushWithIndexCompaction() throws IOException {
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,300 * 1024);
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,75 * 1024);
    conf.setDouble(CompactingMemStore.IN_MEMORY_FLUSH_THRESHOLD_FACTOR_KEY,0.5);
    conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.BASIC));
    HRegion region=initHRegion("testSelectiveFlushWithIndexCompaction",conf);
    verifyInMemoryFlushSize(region);
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createDoublePut(3,i));
        }
      }
    }
    for (int i=100; i < 2000; i++) {
      region.put(createPut(2,i));
    }
    long totalMemstoreSizePhaseI=region.getMemStoreDataSize();
    long smallestSeqCF1PhaseI=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2PhaseI=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3PhaseI=region.getOldestSeqIdOfStore(FAMILY3);
    MemStoreSize cf1MemstoreSizePhaseI=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseI=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseI=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseI=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    assertEquals(smallestSeqCF1PhaseI,smallestSeqInRegionCurrentMemstorePhaseI);
    assertTrue(smallestSeqCF1PhaseI < smallestSeqCF2PhaseI);
    assertTrue(smallestSeqCF2PhaseI < smallestSeqCF3PhaseI);
    assertTrue(cf1MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf2MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf3MemstoreSizePhaseI.getDataSize() > 0);
    assertEquals(totalMemstoreSizePhaseI,cf1MemstoreSizePhaseI.getDataSize() + cf2MemstoreSizePhaseI.getDataSize() + cf3MemstoreSizePhaseI.getDataSize());
    region.flush(false);
    CompactingMemStore cms1=(CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore;
    CompactingMemStore cms3=(CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore;
    cms1.flushInMemory();
    cms3.flushInMemory();
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    MemStoreSize cf1MemstoreSizePhaseII=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseII=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseII=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseII=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long smallestSeqCF3PhaseII=region.getOldestSeqIdOfStore(FAMILY3);
    long totalMemstoreSizePhaseII=region.getMemStoreDataSize();
    assertEquals(cf1MemstoreSizePhaseII.getDataSize(),cf1MemstoreSizePhaseI.getDataSize());
    assertTrue(cf1MemstoreSizePhaseII.getHeapSize() < cf1MemstoreSizePhaseI.getHeapSize());
    assertEquals(0,cf2MemstoreSizePhaseII.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSizePhaseII.getHeapSize());
    assertEquals(cf3MemstoreSizePhaseII.getDataSize(),cf3MemstoreSizePhaseI.getDataSize());
    assertTrue(cf3MemstoreSizePhaseI.getHeapSize() / 2 < cf3MemstoreSizePhaseII.getHeapSize());
    assertEquals(smallestSeqInRegionCurrentMemstorePhaseII,smallestSeqCF1PhaseI);
    assertEquals(totalMemstoreSizePhaseII,cf1MemstoreSizePhaseII.getDataSize() + cf2MemstoreSizePhaseII.getDataSize() + cf3MemstoreSizePhaseII.getDataSize());
    for (int i=1200; i < 8000; i++) {
      region.put(createPut(1,i));
    }
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    MemStoreSize cf1MemstoreSizePhaseIII=region.getStore(FAMILY1).getMemStoreSize();
    long totalMemstoreSizePhaseIII=region.getMemStoreDataSize();
    assertEquals(totalMemstoreSizePhaseIII,cf1MemstoreSizePhaseIII.getDataSize() + cf2MemstoreSizePhaseII.getDataSize() + cf3MemstoreSizePhaseII.getDataSize());
    region.flush(false);
    MemStoreSize cf1MemstoreSizePhaseIV=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseIV=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseIV=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseIV=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long smallestSeqCF3PhaseIV=region.getOldestSeqIdOfStore(FAMILY3);
    assertTrue(cf1MemstoreSizePhaseIII.getDataSize() > cf1MemstoreSizePhaseIV.getDataSize());
    assertEquals(0,cf2MemstoreSizePhaseIV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSizePhaseIV.getHeapSize());
    assertEquals(cf3MemstoreSizePhaseIV,cf3MemstoreSizePhaseII);
    assertEquals(smallestSeqCF3PhaseII,smallestSeqCF3PhaseIV);
    assertEquals(smallestSeqInRegionCurrentMemstorePhaseIV,smallestSeqCF3PhaseIV);
    region.flush(true);
    MemStoreSize cf1MemstoreSizePhaseV=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseV=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseV=region.getStore(FAMILY3).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseV=getWAL(region).getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long totalMemstoreSizePhaseV=region.getMemStoreDataSize();
    assertEquals(0,cf1MemstoreSizePhaseV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf1MemstoreSizePhaseV.getHeapSize());
    assertEquals(0,cf2MemstoreSizePhaseV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSizePhaseV.getHeapSize());
    assertEquals(0,cf3MemstoreSizePhaseV.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf3MemstoreSizePhaseV.getHeapSize());
    assertEquals(0,totalMemstoreSizePhaseV);
    assertEquals(HConstants.NO_SEQNUM,smallestSeqInRegionCurrentMemstorePhaseV);
    for (int i=1; i <= 300; i++) {
      region.put(createPut(1,i));
      region.put(createPut(2,i));
      region.put(createPut(3,i));
      region.put(createPut(4,i));
      region.put(createPut(5,i));
    }
    MemStoreSize cf1ActiveSizePhaseVI=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf3ActiveSizePhaseVI=region.getStore(FAMILY3).getMemStoreSize();
    MemStoreSize cf5ActiveSizePhaseVI=region.getStore(FAMILIES[4]).getMemStoreSize();
    region.flush(false);
    MemStoreSize cf1ActiveSizePhaseVII=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf3ActiveSizePhaseVII=region.getStore(FAMILY3).getMemStoreSize();
    MemStoreSize cf5ActiveSizePhaseVII=region.getStore(FAMILIES[4]).getMemStoreSize();
    assertTrue(cf1ActiveSizePhaseVII.getDataSize() < cf1ActiveSizePhaseVI.getDataSize());
    assertTrue(cf3ActiveSizePhaseVII.getDataSize() < cf3ActiveSizePhaseVI.getDataSize());
    assertTrue(cf5ActiveSizePhaseVII.getDataSize() < cf5ActiveSizePhaseVI.getDataSize());
    HBaseTestingUtility.closeRegionAndWAL(region);
  }
  @Test public void testSelectiveFlushAndWALinDataCompaction() throws IOException {
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,300 * 1024);
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,75 * 1024);
    conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.EAGER));
    HRegion region=initHRegion("testSelectiveFlushAndWALinDataCompaction",conf);
    verifyInMemoryFlushSize(region);
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createPut(3,i));
        }
      }
    }
    for (int i=100; i < 2000; i++) {
      region.put(createPut(2,i));
    }
    ((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).setCompositeSnapshot(false);
    ((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).setCompositeSnapshot(false);
    long totalMemstoreSize=region.getMemStoreDataSize();
    MemStoreSize cf1MemstoreSizePhaseI=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseI=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseI=region.getStore(FAMILY3).getMemStoreSize();
    assertTrue(cf1MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf2MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf3MemstoreSizePhaseI.getDataSize() > 0);
    String msg="totalMemstoreSize=" + totalMemstoreSize + " DefaultMemStore.DEEP_OVERHEAD="+ DefaultMemStore.DEEP_OVERHEAD+ " cf1MemstoreSizePhaseI="+ cf1MemstoreSizePhaseI+ " cf2MemstoreSizePhaseI="+ cf2MemstoreSizePhaseI+ " cf3MemstoreSizePhaseI="+ cf3MemstoreSizePhaseI;
    assertEquals(msg,totalMemstoreSize,cf1MemstoreSizePhaseI.getDataSize() + cf2MemstoreSizePhaseI.getDataSize() + cf3MemstoreSizePhaseI.getDataSize());
    CompactingMemStore cms1=(CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore;
    CompactingMemStore cms3=(CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore;
    cms1.flushInMemory();
    cms3.flushInMemory();
    region.flush(false);
    MemStoreSize cf2MemstoreSizePhaseII=region.getStore(FAMILY2).getMemStoreSize();
    long smallestSeqInRegionCurrentMemstorePhaseII=region.getWAL().getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long smallestSeqCF1PhaseII=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2PhaseII=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3PhaseII=region.getOldestSeqIdOfStore(FAMILY3);
    assertEquals(0,cf2MemstoreSizePhaseII.getDataSize());
    assertEquals(MutableSegment.DEEP_OVERHEAD,cf2MemstoreSizePhaseII.getHeapSize());
    String s="\n\n----------------------------------\n" + "Upon initial insert and flush, LSN of CF1 is:" + smallestSeqCF1PhaseII + ". LSN of CF2 is:"+ smallestSeqCF2PhaseII+ ". LSN of CF3 is:"+ smallestSeqCF3PhaseII+ ", smallestSeqInRegionCurrentMemstore:"+ smallestSeqInRegionCurrentMemstorePhaseII+ "\n";
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createPut(3,i));
        }
      }
    }
    for (int i=100; i < 2000; i++) {
      region.put(createPut(2,i));
    }
    long smallestSeqInRegionCurrentMemstorePhaseIII=region.getWAL().getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long smallestSeqCF1PhaseIII=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2PhaseIII=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3PhaseIII=region.getOldestSeqIdOfStore(FAMILY3);
    s=s + "The smallest sequence in region WAL is: " + smallestSeqInRegionCurrentMemstorePhaseIII+ ", the smallest sequence in CF1:"+ smallestSeqCF1PhaseIII+ ", "+ "the smallest sequence in CF2:"+ smallestSeqCF2PhaseIII+ ", the smallest sequence in CF3:"+ smallestSeqCF3PhaseIII+ "\n";
    cms1=(CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore;
    cms3=(CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore;
    cms1.flushInMemory();
    cms3.flushInMemory();
    region.flush(false);
    long smallestSeqInRegionCurrentMemstorePhaseIV=region.getWAL().getEarliestMemStoreSeqNum(region.getRegionInfo().getEncodedNameAsBytes());
    long smallestSeqCF1PhaseIV=region.getOldestSeqIdOfStore(FAMILY1);
    long smallestSeqCF2PhaseIV=region.getOldestSeqIdOfStore(FAMILY2);
    long smallestSeqCF3PhaseIV=region.getOldestSeqIdOfStore(FAMILY3);
    s=s + "The smallest sequence in region WAL is: " + smallestSeqInRegionCurrentMemstorePhaseIV+ ", the smallest sequence in CF1:"+ smallestSeqCF1PhaseIV+ ", "+ "the smallest sequence in CF2:"+ smallestSeqCF2PhaseIV+ ", the smallest sequence in CF3:"+ smallestSeqCF3PhaseIV+ "\n";
    assertTrue(s,smallestSeqInRegionCurrentMemstorePhaseIV > smallestSeqInRegionCurrentMemstorePhaseIII);
    assertTrue(smallestSeqCF1PhaseIV > smallestSeqCF1PhaseIII);
    assertTrue(smallestSeqCF3PhaseIV > smallestSeqCF3PhaseIII);
    HBaseTestingUtility.closeRegionAndWAL(region);
  }
  @Test public void testSelectiveFlushWithBasicAndMerge() throws IOException {
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,300 * 1024);
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,75 * 1024);
    conf.setDouble(CompactingMemStore.IN_MEMORY_FLUSH_THRESHOLD_FACTOR_KEY,0.8);
    conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.BASIC));
    conf.setInt(MemStoreCompactionStrategy.COMPACTING_MEMSTORE_THRESHOLD_KEY,1);
    HRegion region=initHRegion("testSelectiveFlushWithBasicAndMerge",conf);
    verifyInMemoryFlushSize(region);
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createPut(3,i));
        }
      }
    }
    for (int i=100; i < 2000; i++) {
      region.put(createPut(2,i));
    }
    long totalMemstoreSize=region.getMemStoreDataSize();
    ((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).setIndexType(CompactingMemStore.IndexType.ARRAY_MAP);
    ((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).setIndexType(CompactingMemStore.IndexType.ARRAY_MAP);
    MemStoreSize cf1MemstoreSizePhaseI=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseI=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseI=region.getStore(FAMILY3).getMemStoreSize();
    assertTrue(cf1MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf2MemstoreSizePhaseI.getDataSize() > 0);
    assertTrue(cf3MemstoreSizePhaseI.getDataSize() > 0);
    assertEquals(totalMemstoreSize,cf1MemstoreSizePhaseI.getDataSize() + cf2MemstoreSizePhaseI.getDataSize() + cf3MemstoreSizePhaseI.getDataSize());
    ((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).flushInMemory();
    ((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).flushInMemory();
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    region.flush(false);
    MemStoreSize cf1MemstoreSizePhaseII=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseII=region.getStore(FAMILY2).getMemStoreSize();
    MemStoreSize cf3MemstoreSizePhaseII=region.getStore(FAMILY3).getMemStoreSize();
    assertTrue(cf1MemstoreSizePhaseI.getHeapSize() > cf1MemstoreSizePhaseII.getHeapSize());
    assertEquals(cf1MemstoreSizePhaseI.getDataSize(),cf1MemstoreSizePhaseII.getDataSize());
    assertEquals(0,cf2MemstoreSizePhaseII.getDataSize());
    for (int i=1; i <= 1200; i++) {
      region.put(createPut(1,i));
      if (i <= 100) {
        region.put(createPut(2,i));
        if (i <= 50) {
          region.put(createPut(3,i));
        }
      }
    }
    for (int i=100; i < 2000; i++) {
      region.put(createPut(2,i));
    }
    MemStoreSize cf1MemstoreSizePhaseIII=region.getStore(FAMILY1).getMemStoreSize();
    ((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).flushInMemory();
    ((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).flushInMemory();
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    region.flush(false);
    MemStoreSize cf1MemstoreSizePhaseIV=region.getStore(FAMILY1).getMemStoreSize();
    MemStoreSize cf2MemstoreSizePhaseIV=region.getStore(FAMILY2).getMemStoreSize();
    assertEquals(2 * cf1MemstoreSizePhaseI.getDataSize(),cf1MemstoreSizePhaseIV.getDataSize());
    assertEquals(cf1MemstoreSizePhaseI.getHeapSize() - cf1MemstoreSizePhaseII.getHeapSize(),cf1MemstoreSizePhaseIII.getHeapSize() - cf1MemstoreSizePhaseIV.getHeapSize() - CellArrayImmutableSegment.DEEP_OVERHEAD_CAM);
    assertEquals(3,((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).getSegments().size());
    assertEquals("\n<<< DEBUG: The data--heap sizes of stores before/after first flushes," + " CF1: " + cf1MemstoreSizePhaseI.getDataSize() + "/"+ cf1MemstoreSizePhaseII.getDataSize()+ "--"+ cf1MemstoreSizePhaseI.getHeapSize()+ "/"+ cf1MemstoreSizePhaseII.getHeapSize()+ ", CF2: "+ cf2MemstoreSizePhaseI.getDataSize()+ "/"+ cf2MemstoreSizePhaseII.getDataSize()+ "--"+ cf2MemstoreSizePhaseI.getHeapSize()+ "/"+ cf2MemstoreSizePhaseII.getHeapSize()+ ", CF3: "+ cf3MemstoreSizePhaseI.getDataSize()+ "/"+ cf3MemstoreSizePhaseII.getDataSize()+ "--"+ cf3MemstoreSizePhaseI.getHeapSize()+ "/"+ cf3MemstoreSizePhaseII.getHeapSize()+ "\n<<< AND before/after second flushes "+ " CF1: "+ cf1MemstoreSizePhaseIII.getDataSize()+ "/"+ cf1MemstoreSizePhaseIV.getDataSize()+ "--"+ cf1MemstoreSizePhaseIII.getHeapSize()+ "/"+ cf1MemstoreSizePhaseIV.getHeapSize()+ "\n",0,cf2MemstoreSizePhaseIV.getDataSize());
    HBaseTestingUtility.closeRegionAndWAL(region);
  }
  @Test public void testStressFlushAndWALinIndexCompaction() throws IOException {
    conf.setLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,600 * 1024);
    conf.setLong(FlushLargeStoresPolicy.HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN,200 * 1024);
    conf.set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(MemoryCompactionPolicy.BASIC));
    HRegion region=initHRegion("testSelectiveFlushAndWALinDataCompaction",conf);
    verifyInMemoryFlushSize(region);
    Thread[] threads=new Thread[25];
    for (int i=0; i < threads.length; i++) {
      int id=i * 10000;
      ConcurrentPutRunnable runnable=new ConcurrentPutRunnable(region,id);
      threads[i]=new Thread(runnable);
      threads[i].start();
    }
    Threads.sleep(10000);
    region.flush(true);
    Threads.sleep(10000);
    region.flush(true);
    ((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).flushInMemory();
    ((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).flushInMemory();
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY1)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    while (((CompactingMemStore)((HStore)region.getStore(FAMILY3)).memstore).isMemStoreFlushingInMemory()) {
      Threads.sleep(10);
    }
    for (int i=0; i < threads.length; i++) {
      try {
        threads[i].join();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  /** 
 * The in-memory-flusher thread performs the flush asynchronously. There is at most one thread per memstore instance. It takes the updatesLock exclusively, pushes active into the pipeline, releases updatesLock and compacts the pipeline.
 */
private class ConcurrentPutRunnable implements Runnable {
    private final HRegion stressedRegion;
    private final int startNumber;
    ConcurrentPutRunnable(    HRegion r,    int i){
      this.stressedRegion=r;
      this.startNumber=i;
    }
    @Override public void run(){
      try {
        int dummy=startNumber / 10000;
        System.out.print("Thread " + dummy + " with start number "+ startNumber+ " starts\n");
        for (int i=startNumber; i <= startNumber + 3000; i++) {
          stressedRegion.put(createPut(1,i));
          if (i <= startNumber + 2000) {
            stressedRegion.put(createPut(2,i));
            if (i <= startNumber + 1000) {
              stressedRegion.put(createPut(3,i));
            }
          }
        }
        System.out.print("Thread with start number " + startNumber + " continues to more puts\n");
        for (int i=startNumber + 3000; i < startNumber + 5000; i++) {
          stressedRegion.put(createPut(2,i));
        }
        for (int i=startNumber + 5000; i < startNumber + 7000; i++) {
          stressedRegion.put(createPut(1,i));
        }
        System.out.print("Thread with start number " + startNumber + " flushes\n");
        if (startNumber == 0) {
          ((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY1)).memstore).flushInMemory();
          while (((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY1)).memstore).isMemStoreFlushingInMemory()) {
            Threads.sleep(10);
          }
        }
        if (startNumber == 10000) {
          ((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY2)).memstore).flushInMemory();
          while (((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY2)).memstore).isMemStoreFlushingInMemory()) {
            Threads.sleep(10);
          }
        }
        if (startNumber == 20000) {
          ((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY3)).memstore).flushInMemory();
          while (((CompactingMemStore)((HStore)stressedRegion.getStore(FAMILY3)).memstore).isMemStoreFlushingInMemory()) {
            Threads.sleep(10);
          }
        }
        System.out.print("Thread with start number " + startNumber + " finishes\n");
      }
 catch (      IOException e) {
        assert false;
      }
    }
  }
  private WAL getWAL(  Region region){
    return ((HRegion)region).getWAL();
  }
}
