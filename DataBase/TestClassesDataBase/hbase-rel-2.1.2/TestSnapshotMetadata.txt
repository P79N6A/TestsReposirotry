/** 
 * Test class to verify that metadata is consistent before and after a snapshot attempt.
 */
@Category({MediumTests.class,ClientTests.class}) public class TestSnapshotMetadata {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSnapshotMetadata.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestSnapshotMetadata.class);
  private static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final int NUM_RS=2;
  private static final String STRING_TABLE_NAME="TestSnapshotMetadata";
  private static final String MAX_VERSIONS_FAM_STR="fam_max_columns";
  private static final byte[] MAX_VERSIONS_FAM=Bytes.toBytes(MAX_VERSIONS_FAM_STR);
  private static final String COMPRESSED_FAM_STR="fam_compressed";
  private static final byte[] COMPRESSED_FAM=Bytes.toBytes(COMPRESSED_FAM_STR);
  private static final String BLOCKSIZE_FAM_STR="fam_blocksize";
  private static final byte[] BLOCKSIZE_FAM=Bytes.toBytes(BLOCKSIZE_FAM_STR);
  private static final String BLOOMFILTER_FAM_STR="fam_bloomfilter";
  private static final byte[] BLOOMFILTER_FAM=Bytes.toBytes(BLOOMFILTER_FAM_STR);
  private static final String TEST_CONF_CUSTOM_VALUE="TestCustomConf";
  private static final String TEST_CUSTOM_VALUE="TestCustomValue";
  private static final byte[][] families={MAX_VERSIONS_FAM,BLOOMFILTER_FAM,COMPRESSED_FAM,BLOCKSIZE_FAM};
  private static final DataBlockEncoding DATA_BLOCK_ENCODING_TYPE=DataBlockEncoding.FAST_DIFF;
  private static final BloomType BLOOM_TYPE=BloomType.ROW;
  private static final int BLOCK_SIZE=98;
  private static final int MAX_VERSIONS=8;
  private Admin admin;
  private String originalTableDescription;
  private HTableDescriptor originalTableDescriptor;
  TableName originalTableName;
  private static FileSystem fs;
  private static Path rootDir;
  @BeforeClass public static void setupCluster() throws Exception {
    setupConf(UTIL.getConfiguration());
    UTIL.startMiniCluster(NUM_RS);
    fs=UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getFileSystem();
    rootDir=UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();
  }
  @AfterClass public static void cleanupTest() throws Exception {
    try {
      UTIL.shutdownMiniCluster();
    }
 catch (    Exception e) {
      LOG.warn("failure shutting down cluster",e);
    }
  }
  private static void setupConf(  Configuration conf){
    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED,true);
    conf.setInt("hbase.regionsever.info.port",-1);
    conf.setInt("hbase.hregion.memstore.flush.size",25000);
    conf.setInt("hbase.hstore.compaction.min",10);
    conf.setInt("hbase.hstore.compactionThreshold",10);
    conf.setInt("hbase.hstore.blockingStoreFiles",12);
    conf.setInt("hbase.regionserver.msginterval",100);
    conf.setBoolean("hbase.master.enabletable.roundrobin",true);
    conf.set(HConstants.HBASE_REGION_SPLIT_POLICY_KEY,ConstantSizeRegionSplitPolicy.class.getName());
  }
  @Before public void setup() throws Exception {
    admin=UTIL.getAdmin();
    createTableWithNonDefaultProperties();
  }
  @After public void tearDown() throws Exception {
    SnapshotTestingUtils.deleteAllSnapshots(admin);
  }
  private void createTableWithNonDefaultProperties() throws Exception {
    final long startTime=System.currentTimeMillis();
    final String sourceTableNameAsString=STRING_TABLE_NAME + startTime;
    originalTableName=TableName.valueOf(sourceTableNameAsString);
    HColumnDescriptor maxVersionsColumn=new HColumnDescriptor(MAX_VERSIONS_FAM);
    HColumnDescriptor bloomFilterColumn=new HColumnDescriptor(BLOOMFILTER_FAM);
    HColumnDescriptor dataBlockColumn=new HColumnDescriptor(COMPRESSED_FAM);
    HColumnDescriptor blockSizeColumn=new HColumnDescriptor(BLOCKSIZE_FAM);
    maxVersionsColumn.setMaxVersions(MAX_VERSIONS);
    bloomFilterColumn.setBloomFilterType(BLOOM_TYPE);
    dataBlockColumn.setDataBlockEncoding(DATA_BLOCK_ENCODING_TYPE);
    blockSizeColumn.setBlocksize(BLOCK_SIZE);
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(sourceTableNameAsString));
    htd.addFamily(maxVersionsColumn);
    htd.addFamily(bloomFilterColumn);
    htd.addFamily(dataBlockColumn);
    htd.addFamily(blockSizeColumn);
    htd.setValue(TEST_CUSTOM_VALUE,TEST_CUSTOM_VALUE);
    htd.setConfiguration(TEST_CONF_CUSTOM_VALUE,TEST_CONF_CUSTOM_VALUE);
    assertTrue(htd.getConfiguration().size() > 0);
    admin.createTable(htd);
    Table original=UTIL.getConnection().getTable(originalTableName);
    originalTableName=TableName.valueOf(sourceTableNameAsString);
    originalTableDescriptor=admin.getTableDescriptor(originalTableName);
    originalTableDescription=originalTableDescriptor.toStringCustomizedValues();
    original.close();
  }
  /** 
 * Verify that the describe for a cloned table matches the describe from the original.
 */
  @Test public void testDescribeMatchesAfterClone() throws Exception {
    final String clonedTableNameAsString="clone" + originalTableName;
    final TableName clonedTableName=TableName.valueOf(clonedTableNameAsString);
    final String snapshotNameAsString="snapshot" + originalTableName + System.currentTimeMillis();
    final byte[] snapshotName=Bytes.toBytes(snapshotNameAsString);
    List<byte[]> familiesList=new ArrayList<>();
    Collections.addAll(familiesList,families);
    SnapshotTestingUtils.createSnapshotAndValidate(admin,originalTableName,null,familiesList,snapshotNameAsString,rootDir,fs,false);
    admin.cloneSnapshot(snapshotName,clonedTableName);
    Table clonedTable=UTIL.getConnection().getTable(clonedTableName);
    HTableDescriptor cloneHtd=admin.getTableDescriptor(clonedTableName);
    assertEquals(originalTableDescription.replace(originalTableName.getNameAsString(),clonedTableNameAsString),cloneHtd.toStringCustomizedValues());
    assertEquals(originalTableDescriptor.getValues().size(),cloneHtd.getValues().size());
    assertEquals(originalTableDescriptor.getConfiguration().size(),cloneHtd.getConfiguration().size());
    assertEquals(TEST_CUSTOM_VALUE,cloneHtd.getValue(TEST_CUSTOM_VALUE));
    assertEquals(TEST_CONF_CUSTOM_VALUE,cloneHtd.getConfigurationValue(TEST_CONF_CUSTOM_VALUE));
    assertEquals(originalTableDescriptor.getValues(),cloneHtd.getValues());
    assertEquals(originalTableDescriptor.getConfiguration(),cloneHtd.getConfiguration());
    admin.enableTable(originalTableName);
    clonedTable.close();
  }
  /** 
 * Verify that the describe for a restored table matches the describe for one the original.
 */
  @Test public void testDescribeMatchesAfterRestore() throws Exception {
    runRestoreWithAdditionalMetadata(false);
  }
  /** 
 * Verify that if metadata changed after a snapshot was taken, that the old metadata replaces the new metadata during a restore
 */
  @Test public void testDescribeMatchesAfterMetadataChangeAndRestore() throws Exception {
    runRestoreWithAdditionalMetadata(true);
  }
  /** 
 * Verify that when the table is empty, making metadata changes after the restore does not affect the restored table's original metadata
 * @throws Exception
 */
  @Test public void testDescribeOnEmptyTableMatchesAfterMetadataChangeAndRestore() throws Exception {
    runRestoreWithAdditionalMetadata(true,false);
  }
  private void runRestoreWithAdditionalMetadata(  boolean changeMetadata) throws Exception {
    runRestoreWithAdditionalMetadata(changeMetadata,true);
  }
  private void runRestoreWithAdditionalMetadata(  boolean changeMetadata,  boolean addData) throws Exception {
    if (admin.isTableDisabled(originalTableName)) {
      admin.enableTable(originalTableName);
    }
    final byte[] familyForUpdate=BLOCKSIZE_FAM;
    List<byte[]> familiesWithDataList=new ArrayList<>();
    List<byte[]> emptyFamiliesList=new ArrayList<>();
    if (addData) {
      Table original=UTIL.getConnection().getTable(originalTableName);
      UTIL.loadTable(original,familyForUpdate);
      original.close();
      for (      byte[] family : families) {
        if (family != familyForUpdate) {
          emptyFamiliesList.add(family);
        }
      }
      familiesWithDataList.add(familyForUpdate);
    }
 else {
      Collections.addAll(emptyFamiliesList,families);
    }
    final String snapshotNameAsString="snapshot" + originalTableName + System.currentTimeMillis();
    final byte[] snapshotName=Bytes.toBytes(snapshotNameAsString);
    SnapshotTestingUtils.createSnapshotAndValidate(admin,originalTableName,familiesWithDataList,emptyFamiliesList,snapshotNameAsString,rootDir,fs,false);
    admin.enableTable(originalTableName);
    if (changeMetadata) {
      final String newFamilyNameAsString="newFamily" + System.currentTimeMillis();
      final byte[] newFamilyName=Bytes.toBytes(newFamilyNameAsString);
      admin.disableTable(originalTableName);
      HColumnDescriptor hcd=new HColumnDescriptor(newFamilyName);
      admin.addColumnFamily(originalTableName,hcd);
      assertTrue("New column family was not added.",admin.getTableDescriptor(originalTableName).toString().contains(newFamilyNameAsString));
    }
    if (!admin.isTableDisabled(originalTableName)) {
      admin.disableTable(originalTableName);
    }
    admin.restoreSnapshot(snapshotName);
    admin.enableTable(originalTableName);
    Table original=UTIL.getConnection().getTable(originalTableName);
    try {
      assertTrue(originalTableDescriptor.equals(admin.getTableDescriptor(originalTableName)));
      assertTrue(originalTableDescriptor.equals(original.getTableDescriptor()));
    }
  finally {
      original.close();
    }
  }
}
