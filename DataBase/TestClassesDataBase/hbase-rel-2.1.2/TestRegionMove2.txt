/** 
 * Like TestRegionMove in regionserver package but in here in this package so I can get access to Procedure internals to mess with the assignment to manufacture states seen out on clusters.
 */
@Category({LargeTests.class}) public class TestRegionMove2 {
  private final static Logger LOG=LoggerFactory.getLogger(TestRegionMove2.class);
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRegionMove2.class);
  @Rule public TestName name=new TestName();
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  @BeforeClass public static void startCluster() throws Exception {
    TEST_UTIL.startMiniCluster(2);
  }
  @AfterClass public static void stopCluster() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  /** 
 * Test that we make it through to the end if parent Region is offlined between start of this Move and when we go to run the move UnassignProcedure.
 */
  @Test public void testMoveOfRegionOfflinedPostStart() throws Exception {
    TableName tableName=TableName.valueOf(this.name.getMethodName());
    byte[] cf=Bytes.toBytes("cf");
    Table t=TEST_UTIL.createMultiRegionTable(tableName,cf,10);
    TEST_UTIL.waitUntilAllRegionsAssigned(tableName);
    HRegionServer rs1=null;
    HRegionServer rs2=null;
    List<RegionInfo> regionsOnRS1ForTable=null;
    try (Admin admin=TEST_UTIL.getAdmin()){
      for (      RegionInfo regionInfo : admin.getRegions(tableName)) {
        byte[] startKey=regionInfo.getStartKey();
        byte[] rowKey=org.apache.hbase.thirdparty.com.google.common.primitives.Bytes.concat(startKey,Bytes.toBytes("1"));
        Put p=new Put(rowKey);
        p.addColumn(cf,Bytes.toBytes("q1"),Bytes.toBytes("value"));
        t.put(p);
      }
      rs1=TEST_UTIL.getRSForFirstRegionInTable(tableName);
      rs2=TEST_UTIL.getOtherRegionServer(rs1);
      regionsOnRS1ForTable=admin.getRegions(rs1.getServerName()).stream().filter((regionInfo) -> regionInfo.getTable().equals(tableName)).collect(Collectors.toList());
    }
     assertTrue("Expected to find at least one region for " + tableName + " on "+ rs1.getServerName()+ ", but found none",!regionsOnRS1ForTable.isEmpty());
    final RegionInfo regionToMove=regionsOnRS1ForTable.get(0);
    HMaster master=TEST_UTIL.getHBaseCluster().getMaster();
    RegionPlan rp=new RegionPlan(regionToMove,rs1.getServerName(),rs2.getServerName());
    MasterProcedureEnv env=master.getMasterProcedureExecutor().getEnvironment();
    HackedMoveRegionProcedure p=new HackedMoveRegionProcedure(env,rp);
    master.getMasterProcedureExecutor().submitProcedure(p);
    ProcedureTestingUtility.waitProcedure(master.getMasterProcedureExecutor(),p);
    assertTrue(p.split.get());
    assertTrue(rs1.getOnlineRegion(regionToMove.getRegionName()) != null);
  }
  /** 
 * Class just so we can mess around with RegionStateNode state at a particular point in the Procedure to try and mess it up.
 */
public static class HackedMoveRegionProcedure extends MoveRegionProcedure {
    /** 
 * Set to true after we hack this regions RSN to SPLIT
 */
    public static AtomicBoolean split=new AtomicBoolean(false);
    public HackedMoveRegionProcedure(){
      super();
    }
    public HackedMoveRegionProcedure(    MasterProcedureEnv env,    RegionPlan plan) throws HBaseIOException {
      super(env,plan,false);
    }
    @Override protected Flow executeFromState(    MasterProcedureEnv env,    MasterProcedureProtos.MoveRegionState state) throws InterruptedException {
      Flow flow=null;
switch (state) {
case MOVE_REGION_UNASSIGN:
        RegionStates.RegionStateNode rsn=env.getAssignmentManager().getRegionStates().getOrCreateRegionStateNode(getRegion());
      rsn.setState(RegionState.State.SPLIT);
    LOG.info("HACKED RSN, setting it to SPLIT: {}",rsn);
  split.set(true);
default :
flow=super.executeFromState(env,state);
}
return flow;
}
}
}
