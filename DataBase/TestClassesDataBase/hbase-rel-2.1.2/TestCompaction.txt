/** 
 * Test compaction framework and common functions
 */
@Category({RegionServerTests.class,MediumTests.class}) public class TestCompaction {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestCompaction.class);
  @Rule public TestName name=new TestName();
  private static final HBaseTestingUtility UTIL=HBaseTestingUtility.createLocalHTU();
  protected Configuration conf=UTIL.getConfiguration();
  private HRegion r=null;
  private HTableDescriptor htd=null;
  private static final byte[] COLUMN_FAMILY=fam1;
  private final byte[] STARTROW=Bytes.toBytes(START_KEY);
  private static final byte[] COLUMN_FAMILY_TEXT=COLUMN_FAMILY;
  private int compactionThreshold;
  private byte[] secondRowBytes, thirdRowBytes;
  private static final long MAX_FILES_TO_COMPACT=10;
  private final byte[] FAMILY=Bytes.toBytes("cf");
  /** 
 * constructor 
 */
  public TestCompaction(){
    super();
    conf.setInt(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,1024 * 1024);
    conf.setInt(HConstants.HREGION_MEMSTORE_BLOCK_MULTIPLIER,100);
    conf.set(CompactionThroughputControllerFactory.HBASE_THROUGHPUT_CONTROLLER_KEY,NoLimitThroughputController.class.getName());
    compactionThreshold=conf.getInt("hbase.hstore.compactionThreshold",3);
    secondRowBytes=START_KEY_BYTES.clone();
    secondRowBytes[START_KEY_BYTES.length - 1]++;
    thirdRowBytes=START_KEY_BYTES.clone();
    thirdRowBytes[START_KEY_BYTES.length - 1]=(byte)(thirdRowBytes[START_KEY_BYTES.length - 1] + 2);
  }
  @Before public void setUp() throws Exception {
    this.htd=UTIL.createTableDescriptor(name.getMethodName());
    if (name.getMethodName().equals("testCompactionSeqId")) {
      UTIL.getConfiguration().set("hbase.hstore.compaction.kv.max","10");
      UTIL.getConfiguration().set(DefaultStoreEngine.DEFAULT_COMPACTOR_CLASS_KEY,DummyCompactor.class.getName());
      HColumnDescriptor hcd=new HColumnDescriptor(FAMILY);
      hcd.setMaxVersions(65536);
      this.htd.addFamily(hcd);
    }
    this.r=UTIL.createLocalHRegion(htd,null,null);
  }
  @After public void tearDown() throws Exception {
    WAL wal=r.getWAL();
    this.r.close();
    wal.close();
  }
  /** 
 * Verify that you can stop a long-running compaction (used during RS shutdown)
 * @throws Exception
 */
  @Test public void testInterruptCompaction() throws Exception {
    assertEquals(0,count());
    int origWI=HStore.closeCheckInterval;
    HStore.closeCheckInterval=10 * 1000;
    try {
      int jmax=(int)Math.ceil(15.0 / compactionThreshold);
      byte[] pad=new byte[1000];
      for (int i=0; i < compactionThreshold; i++) {
        Table loader=new RegionAsTable(r);
        Put p=new Put(Bytes.add(STARTROW,Bytes.toBytes(i)));
        p.setDurability(Durability.SKIP_WAL);
        for (int j=0; j < jmax; j++) {
          p.addColumn(COLUMN_FAMILY,Bytes.toBytes(j),pad);
        }
        HBaseTestCase.addContent(loader,Bytes.toString(COLUMN_FAMILY));
        loader.put(p);
        r.flush(true);
      }
      HRegion spyR=spy(r);
      doAnswer(new Answer(){
        @Override public Object answer(        InvocationOnMock invocation) throws Throwable {
          r.writestate.writesEnabled=false;
          return invocation.callRealMethod();
        }
      }
).when(spyR).doRegionCompactionPrep();
      spyR.compactStores();
      HStore s=r.getStore(COLUMN_FAMILY);
      assertEquals(compactionThreshold,s.getStorefilesCount());
      assertTrue(s.getStorefilesSize() > 15 * 1000);
      FileStatus[] ls=r.getFilesystem().listStatus(r.getRegionFileSystem().getTempDir());
      assertEquals(1,ls.length);
      Path storeTempDir=new Path(r.getRegionFileSystem().getTempDir(),Bytes.toString(COLUMN_FAMILY));
      assertTrue(r.getFilesystem().exists(storeTempDir));
      ls=r.getFilesystem().listStatus(storeTempDir);
      assertEquals(0,ls.length);
    }
  finally {
      r.writestate.writesEnabled=true;
      HStore.closeCheckInterval=origWI;
      for (int i=0; i < compactionThreshold; i++) {
        Delete delete=new Delete(Bytes.add(STARTROW,Bytes.toBytes(i)));
        byte[][] famAndQf={COLUMN_FAMILY,null};
        delete.addFamily(famAndQf[0]);
        r.delete(delete);
      }
      r.flush(true);
      final int ttl=1000;
      for (      HStore store : this.r.stores.values()) {
        ScanInfo old=store.getScanInfo();
        ScanInfo si=old.customize(old.getMaxVersions(),ttl,old.getKeepDeletedCells());
        store.setScanInfo(si);
      }
      Thread.sleep(ttl);
      r.compact(true);
      assertEquals(0,count());
    }
  }
  private int count() throws IOException {
    int count=0;
    for (    HStoreFile f : this.r.stores.get(COLUMN_FAMILY_TEXT).getStorefiles()) {
      HFileScanner scanner=f.getReader().getScanner(false,false);
      if (!scanner.seekTo()) {
        continue;
      }
      do {
        count++;
      }
 while (scanner.next());
    }
    return count;
  }
  private void createStoreFile(  final HRegion region) throws IOException {
    createStoreFile(region,Bytes.toString(COLUMN_FAMILY));
  }
  private void createStoreFile(  final HRegion region,  String family) throws IOException {
    Table loader=new RegionAsTable(region);
    HBaseTestCase.addContent(loader,family);
    region.flush(true);
  }
  @Test public void testCompactionWithCorruptResult() throws Exception {
    int nfiles=10;
    for (int i=0; i < nfiles; i++) {
      createStoreFile(r);
    }
    HStore store=r.getStore(COLUMN_FAMILY);
    Collection<HStoreFile> storeFiles=store.getStorefiles();
    DefaultCompactor tool=(DefaultCompactor)store.storeEngine.getCompactor();
    tool.compactForTesting(storeFiles,false);
    FileSystem fs=store.getFileSystem();
    Path dstPath=store.getRegionFileSystem().createTempName();
    FSDataOutputStream stream=fs.create(dstPath,null,true,512,(short)3,1024L,null);
    stream.writeChars("CORRUPT FILE!!!!");
    stream.close();
    Path origPath=store.getRegionFileSystem().commitStoreFile(Bytes.toString(COLUMN_FAMILY),dstPath);
    try {
      ((HStore)store).moveFileIntoPlace(origPath);
    }
 catch (    Exception e) {
      assertTrue(fs.exists(origPath));
      assertFalse(fs.exists(dstPath));
      System.out.println("testCompactionWithCorruptResult Passed");
      return;
    }
    fail("testCompactionWithCorruptResult failed since no exception was" + "thrown while completing a corrupt file");
  }
  /** 
 * Create a custom compaction request and be sure that we can track it through the queue, knowing when the compaction is completed.
 */
  @Test public void testTrackingCompactionRequest() throws Exception {
    HRegionServer mockServer=Mockito.mock(HRegionServer.class);
    Mockito.when(mockServer.getConfiguration()).thenReturn(r.getBaseConf());
    CompactSplit thread=new CompactSplit(mockServer);
    Mockito.when(mockServer.getCompactSplitThread()).thenReturn(thread);
    HStore store=r.getStore(COLUMN_FAMILY);
    createStoreFile(r);
    for (int i=0; i < MAX_FILES_TO_COMPACT + 1; i++) {
      createStoreFile(r);
    }
    CountDownLatch latch=new CountDownLatch(1);
    Tracker tracker=new Tracker(latch);
    thread.requestCompaction(r,store,"test custom comapction",PRIORITY_USER,tracker,null);
    latch.await();
    thread.interruptIfNecessary();
  }
  @Test public void testCompactionFailure() throws Exception {
    HRegionServer mockServer=Mockito.mock(HRegionServer.class);
    Mockito.when(mockServer.getConfiguration()).thenReturn(r.getBaseConf());
    CompactSplit thread=new CompactSplit(mockServer);
    Mockito.when(mockServer.getCompactSplitThread()).thenReturn(thread);
    HStore store=r.getStore(COLUMN_FAMILY);
    createStoreFile(r);
    for (int i=0; i < HStore.DEFAULT_BLOCKING_STOREFILE_COUNT - 1; i++) {
      createStoreFile(r);
    }
    HRegion mockRegion=Mockito.spy(r);
    Mockito.when(mockRegion.checkSplit()).thenThrow(new IndexOutOfBoundsException());
    MetricsRegionWrapper metricsWrapper=new MetricsRegionWrapperImpl(r);
    long preCompletedCount=metricsWrapper.getNumCompactionsCompleted();
    long preFailedCount=metricsWrapper.getNumCompactionsFailed();
    CountDownLatch latch=new CountDownLatch(1);
    Tracker tracker=new Tracker(latch);
    thread.requestCompaction(mockRegion,store,"test custom comapction",PRIORITY_USER,tracker,null);
    latch.await(120,TimeUnit.SECONDS);
    long postCompletedCount=metricsWrapper.getNumCompactionsCompleted();
    long postFailedCount=metricsWrapper.getNumCompactionsFailed();
    assertTrue("Completed count should have increased (pre=" + preCompletedCount + ", post="+ postCompletedCount+ ")",postCompletedCount > preCompletedCount);
    assertTrue("Failed count should have increased (pre=" + preFailedCount + ", post="+ postFailedCount+ ")",postFailedCount > preFailedCount);
  }
  /** 
 * HBASE-7947: Regression test to ensure adding to the correct list in the {@link CompactSplit}
 * @throws Exception on failure
 */
  @Test public void testMultipleCustomCompactionRequests() throws Exception {
    HRegionServer mockServer=Mockito.mock(HRegionServer.class);
    Mockito.when(mockServer.getConfiguration()).thenReturn(r.getBaseConf());
    CompactSplit thread=new CompactSplit(mockServer);
    Mockito.when(mockServer.getCompactSplitThread()).thenReturn(thread);
    int numStores=r.getStores().size();
    CountDownLatch latch=new CountDownLatch(numStores);
    Tracker tracker=new Tracker(latch);
    for (    HStore store : r.getStores()) {
      createStoreFile(r,store.getColumnFamilyName());
      createStoreFile(r,store.getColumnFamilyName());
      createStoreFile(r,store.getColumnFamilyName());
      thread.requestCompaction(r,store,"test mulitple custom comapctions",PRIORITY_USER,tracker,null);
    }
    latch.await();
    thread.interruptIfNecessary();
  }
class StoreMockMaker extends StatefulStoreMockMaker {
    public ArrayList<HStoreFile> compacting=new ArrayList<>();
    public ArrayList<HStoreFile> notCompacting=new ArrayList<>();
    private final ArrayList<Integer> results;
    public StoreMockMaker(    ArrayList<Integer> results){
      this.results=results;
    }
public class TestCompactionContext extends CompactionContext {
      private List<HStoreFile> selectedFiles;
      public TestCompactionContext(      List<HStoreFile> selectedFiles){
        super();
        this.selectedFiles=selectedFiles;
      }
      @Override public List<HStoreFile> preSelect(      List<HStoreFile> filesCompacting){
        return new ArrayList<>();
      }
      @Override public boolean select(      List<HStoreFile> filesCompacting,      boolean isUserCompaction,      boolean mayUseOffPeak,      boolean forceMajor) throws IOException {
        this.request=new CompactionRequestImpl(selectedFiles);
        this.request.setPriority(getPriority());
        return true;
      }
      @Override public List<Path> compact(      ThroughputController throughputController,      User user) throws IOException {
        finishCompaction(this.selectedFiles);
        return new ArrayList<>();
      }
    }
    @Override public synchronized Optional<CompactionContext> selectCompaction(){
      CompactionContext ctx=new TestCompactionContext(new ArrayList<>(notCompacting));
      compacting.addAll(notCompacting);
      notCompacting.clear();
      try {
        ctx.select(null,false,false,false);
      }
 catch (      IOException ex) {
        fail("Shouldn't happen");
      }
      return Optional.of(ctx);
    }
    @Override public synchronized void cancelCompaction(    Object object){
      TestCompactionContext ctx=(TestCompactionContext)object;
      compacting.removeAll(ctx.selectedFiles);
      notCompacting.addAll(ctx.selectedFiles);
    }
    public synchronized void finishCompaction(    List<HStoreFile> sfs){
      if (sfs.isEmpty())       return;
synchronized (results) {
        results.add(sfs.size());
      }
      compacting.removeAll(sfs);
    }
    @Override public int getPriority(){
      return 7 - compacting.size() - notCompacting.size();
    }
  }
public class BlockingStoreMockMaker extends StatefulStoreMockMaker {
    BlockingCompactionContext blocked=null;
public class BlockingCompactionContext extends CompactionContext {
      public volatile boolean isInCompact=false;
      public void unblock(){
synchronized (this) {
          this.notifyAll();
        }
      }
      @Override public List<Path> compact(      ThroughputController throughputController,      User user) throws IOException {
        try {
          isInCompact=true;
synchronized (this) {
            this.wait();
          }
        }
 catch (        InterruptedException e) {
          Assume.assumeNoException(e);
        }
        return new ArrayList<>();
      }
      @Override public List<HStoreFile> preSelect(      List<HStoreFile> filesCompacting){
        return new ArrayList<>();
      }
      @Override public boolean select(      List<HStoreFile> f,      boolean i,      boolean m,      boolean e) throws IOException {
        this.request=new CompactionRequestImpl(new ArrayList<>());
        return true;
      }
    }
    @Override public Optional<CompactionContext> selectCompaction(){
      this.blocked=new BlockingCompactionContext();
      try {
        this.blocked.select(null,false,false,false);
      }
 catch (      IOException ex) {
        fail("Shouldn't happen");
      }
      return Optional.of(blocked);
    }
    @Override public void cancelCompaction(    Object object){
    }
    @Override public int getPriority(){
      return Integer.MIN_VALUE;
    }
    public BlockingCompactionContext waitForBlocking(){
      while (this.blocked == null || !this.blocked.isInCompact) {
        Threads.sleepWithoutInterrupt(50);
      }
      BlockingCompactionContext ctx=this.blocked;
      this.blocked=null;
      return ctx;
    }
    @Override public HStore createStoreMock(    String name) throws Exception {
      return createStoreMock(Integer.MIN_VALUE,name);
    }
    public HStore createStoreMock(    int priority,    String name) throws Exception {
      HStore s=super.createStoreMock(name);
      when(s.getCompactPriority()).thenReturn(priority);
      return s;
    }
  }
  /** 
 * Test compaction priority management and multiple compactions per store (HBASE-8665). 
 */
  @Test public void testCompactionQueuePriorities() throws Exception {
    final Configuration conf=HBaseConfiguration.create();
    HRegionServer mockServer=mock(HRegionServer.class);
    when(mockServer.isStopped()).thenReturn(false);
    when(mockServer.getConfiguration()).thenReturn(conf);
    when(mockServer.getChoreService()).thenReturn(new ChoreService("test"));
    CompactSplit cst=new CompactSplit(mockServer);
    when(mockServer.getCompactSplitThread()).thenReturn(cst);
    cst.shutdownLongCompactions();
    HRegion r=mock(HRegion.class);
    when(r.compact(any(),any(),any(),any())).then(new Answer<Boolean>(){
      @Override public Boolean answer(      InvocationOnMock invocation) throws Throwable {
        invocation.<CompactionContext>getArgument(0).compact(invocation.getArgument(2),null);
        return true;
      }
    }
);
    ArrayList<Integer> results=new ArrayList<>();
    StoreMockMaker sm=new StoreMockMaker(results), sm2=new StoreMockMaker(results);
    HStore store=sm.createStoreMock("store1");
    HStore store2=sm2.createStoreMock("store2");
    BlockingStoreMockMaker blocker=new BlockingStoreMockMaker();
    cst.requestSystemCompaction(r,blocker.createStoreMock(1,"b-pri1"),"b-pri1");
    BlockingStoreMockMaker.BlockingCompactionContext currentBlock=blocker.waitForBlocking();
    for (int i=0; i < 4; ++i) {
      sm.notCompacting.add(createFile());
    }
    cst.requestSystemCompaction(r,store,"s1-pri3");
    for (int i=0; i < 3; ++i) {
      sm2.notCompacting.add(createFile());
    }
    cst.requestSystemCompaction(r,store2,"s2-pri4");
    for (int i=0; i < 2; ++i) {
      sm.notCompacting.add(createFile());
    }
    cst.requestSystemCompaction(r,store,"s1-pri1");
    cst.requestSystemCompaction(r,blocker.createStoreMock(2,"b-pri2"),"b-pri2");
    currentBlock.unblock();
    currentBlock=blocker.waitForBlocking();
    assertEquals(1,results.size());
    assertEquals(6,results.get(0).intValue());
    for (int i=0; i < 2; ++i) {
      sm.notCompacting.add(createFile());
    }
    cst.requestSystemCompaction(r,blocker.createStoreMock(7,"b-pri7"),"b-pri7");
    currentBlock.unblock();
    currentBlock=blocker.waitForBlocking();
    assertEquals(3,results.size());
    assertEquals(3,results.get(1).intValue());
    assertEquals(2,results.get(2).intValue());
    currentBlock.unblock();
    cst.interruptIfNecessary();
  }
  /** 
 * Firstly write 10 cells (with different time stamp) to a qualifier and flush to hfile1, then write 10 cells (with different time stamp) to the same qualifier and flush to hfile2. The latest cell (cell-A) in hfile1 and the oldest cell (cell-B) in hfile2 are with the same time stamp but different sequence id, and will get scanned successively during compaction. <p/> We set compaction.kv.max to 10 so compaction will scan 10 versions each round, meanwhile we set keepSeqIdPeriod=0 in  {@link DummyCompactor} so all10 versions of hfile2 will be written out with seqId cleaned (set to 0) including cell-B, then when scanner goes to cell-A it will cause a scan out-of-order assertion error before HBASE-16931
 * @throws Exception if error occurs during the test
 */
  @Test public void testCompactionSeqId() throws Exception {
    final byte[] ROW=Bytes.toBytes("row");
    final byte[] QUALIFIER=Bytes.toBytes("qualifier");
    long timestamp=10000;
    for (int i=0; i < 10; i++) {
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,timestamp + i,Bytes.toBytes("v" + i));
      r.put(put);
    }
    r.flush(true);
    for (int i=18; i > 8; i--) {
      Put put=new Put(ROW);
      put.addColumn(FAMILY,QUALIFIER,timestamp + i,Bytes.toBytes("v" + i));
      r.put(put);
    }
    r.flush(true);
    r.compact(true);
  }
public static class DummyCompactor extends DefaultCompactor {
    public DummyCompactor(    Configuration conf,    HStore store){
      super(conf,store);
      this.keepSeqIdPeriod=0;
    }
  }
  private static HStoreFile createFile() throws Exception {
    HStoreFile sf=mock(HStoreFile.class);
    when(sf.getPath()).thenReturn(new Path("file"));
    StoreFileReader r=mock(StoreFileReader.class);
    when(r.length()).thenReturn(10L);
    when(sf.getReader()).thenReturn(r);
    return sf;
  }
  /** 
 * Simple  {@link CompactionLifeCycleTracker} on which you can wait until the requested compactionfinishes.
 */
public static class Tracker implements CompactionLifeCycleTracker {
    private final CountDownLatch done;
    public Tracker(    CountDownLatch done){
      this.done=done;
    }
    @Override public void afterExecution(    Store store){
      done.countDown();
    }
  }
}
