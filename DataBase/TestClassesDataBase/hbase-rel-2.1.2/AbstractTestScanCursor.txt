public abstract class AbstractTestScanCursor {
  protected final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  /** 
 * Table configuration
 */
  protected static TableName TABLE_NAME=TableName.valueOf("TestScanCursor");
  protected static int NUM_ROWS=5;
  protected static byte[] ROW=Bytes.toBytes("testRow");
  protected static byte[][] ROWS=HTestConst.makeNAscii(ROW,NUM_ROWS);
  protected static int NUM_FAMILIES=2;
  protected static byte[] FAMILY=Bytes.toBytes("testFamily");
  protected static byte[][] FAMILIES=HTestConst.makeNAscii(FAMILY,NUM_FAMILIES);
  protected static int NUM_QUALIFIERS=2;
  protected static byte[] QUALIFIER=Bytes.toBytes("testQualifier");
  protected static byte[][] QUALIFIERS=HTestConst.makeNAscii(QUALIFIER,NUM_QUALIFIERS);
  protected static int VALUE_SIZE=10;
  protected static byte[] VALUE=Bytes.createMaxByteArray(VALUE_SIZE);
  protected static final int TIMEOUT=4000;
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setInt(HConstants.HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD,TIMEOUT);
    conf.setInt(HConstants.HBASE_RPC_TIMEOUT_KEY,TIMEOUT);
    conf.setLong(StoreScanner.HBASE_CELLS_SCANNED_PER_HEARTBEAT_CHECK,1);
    TEST_UTIL.startMiniCluster(1);
    createTestTable(TABLE_NAME,ROWS,FAMILIES,QUALIFIERS,VALUE);
  }
  private static void createTestTable(  TableName name,  byte[][] rows,  byte[][] families,  byte[][] qualifiers,  byte[] cellValue) throws IOException {
    TEST_UTIL.createTable(name,families).put(createPuts(rows,families,qualifiers,cellValue));
  }
  private static List<Put> createPuts(  byte[][] rows,  byte[][] families,  byte[][] qualifiers,  byte[] value) throws IOException {
    List<Put> puts=new ArrayList<>();
    for (int row=0; row < rows.length; row++) {
      Put put=new Put(rows[row]);
      for (int fam=0; fam < families.length; fam++) {
        for (int qual=0; qual < qualifiers.length; qual++) {
          KeyValue kv=new KeyValue(rows[row],families[fam],qualifiers[qual],qual,value);
          put.add(kv);
        }
      }
      puts.add(put);
    }
    return puts;
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
public static final class SparseFilter extends FilterBase {
    private final boolean reversed;
    public SparseFilter(    boolean reversed){
      this.reversed=reversed;
    }
    @Override public ReturnCode filterCell(    final Cell c) throws IOException {
      Threads.sleep(TIMEOUT / 2 + 100);
      return Bytes.equals(CellUtil.cloneRow(c),ROWS[reversed ? 0 : NUM_ROWS - 1]) ? ReturnCode.INCLUDE : ReturnCode.SKIP;
    }
    @Override public byte[] toByteArray() throws IOException {
      return reversed ? new byte[]{1} : new byte[]{0};
    }
    public static Filter parseFrom(    final byte[] pbBytes){
      return new SparseFilter(pbBytes[0] != 0);
    }
  }
  protected Scan createScanWithSparseFilter(){
    return new Scan().setMaxResultSize(Long.MAX_VALUE).setCaching(Integer.MAX_VALUE).setNeedCursorResult(true).setAllowPartialResults(true).setFilter(new SparseFilter(false));
  }
  protected Scan createReversedScanWithSparseFilter(){
    return new Scan().setMaxResultSize(Long.MAX_VALUE).setCaching(Integer.MAX_VALUE).setReversed(true).setNeedCursorResult(true).setAllowPartialResults(true).setFilter(new SparseFilter(true));
  }
  protected Scan createScanWithSizeLimit(){
    return new Scan().setMaxResultSize(1).setCaching(Integer.MAX_VALUE).setNeedCursorResult(true);
  }
}
