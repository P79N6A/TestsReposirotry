/** 
 * Test HBase Writables serializations
 */
@Category({MiscTests.class,SmallTests.class}) public class TestSerialization {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSerialization.class);
  @Test public void testKeyValue() throws Exception {
    final String name="testKeyValue2";
    byte[] row=name.getBytes();
    byte[] fam="fam".getBytes();
    byte[] qf="qf".getBytes();
    long ts=System.currentTimeMillis();
    byte[] val="val".getBytes();
    KeyValue kv=new KeyValue(row,fam,qf,ts,val);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    long l=KeyValueUtil.write(kv,dos);
    dos.close();
    byte[] mb=baos.toByteArray();
    ByteArrayInputStream bais=new ByteArrayInputStream(mb);
    DataInputStream dis=new DataInputStream(bais);
    KeyValue deserializedKv=KeyValueUtil.create(dis);
    assertTrue(Bytes.equals(kv.getBuffer(),deserializedKv.getBuffer()));
    assertEquals(kv.getOffset(),deserializedKv.getOffset());
    assertEquals(kv.getLength(),deserializedKv.getLength());
  }
  @Test public void testCreateKeyValueInvalidNegativeLength(){
    KeyValue kv_0=new KeyValue(Bytes.toBytes("myRow"),Bytes.toBytes("myCF"),Bytes.toBytes("myQualifier"),12345L,Bytes.toBytes("my12345"));
    KeyValue kv_1=new KeyValue(Bytes.toBytes("myRow"),Bytes.toBytes("myCF"),Bytes.toBytes("myQualifier"),12345L,Bytes.toBytes("my123"));
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    long l=0;
    try {
      l=KeyValue.oswrite(kv_0,dos,false);
      l+=KeyValue.oswrite(kv_1,dos,false);
      assertEquals(100L,l);
    }
 catch (    IOException e) {
      fail("Unexpected IOException" + e.getMessage());
    }
    ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());
    DataInputStream dis=new DataInputStream(bais);
    try {
      KeyValueUtil.create(dis);
      assertTrue(kv_0.equals(kv_1));
    }
 catch (    Exception e) {
      fail("Unexpected Exception" + e.getMessage());
    }
    try {
      KeyValueUtil.create(-1,dis);
      fail("Expected corrupt stream");
    }
 catch (    Exception e) {
      assertEquals("Failed read -1 bytes, stream corrupt?",e.getMessage());
    }
  }
  @Test public void testCompareFilter() throws Exception {
    Filter f=new RowFilter(CompareOperator.EQUAL,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
    byte[] bytes=f.toByteArray();
    Filter ff=RowFilter.parseFrom(bytes);
    assertNotNull(ff);
  }
  @Test public void testTableDescriptor() throws Exception {
    final String name="testTableDescriptor";
    HTableDescriptor htd=createTableDescriptor(name);
    byte[] mb=htd.toByteArray();
    HTableDescriptor deserializedHtd=HTableDescriptor.parseFrom(mb);
    assertEquals(htd.getTableName(),deserializedHtd.getTableName());
  }
  /** 
 * Test RegionInfo serialization
 * @throws Exception
 */
  @Test public void testRegionInfo() throws Exception {
    HRegionInfo hri=createRandomRegion("testRegionInfo");
    byte[] hrib=hri.toByteArray();
    HRegionInfo deserializedHri=HRegionInfo.parseFrom(hrib);
    assertEquals(hri.getEncodedName(),deserializedHri.getEncodedName());
    assertEquals(hri,deserializedHri);
    hrib=hri.toDelimitedByteArray();
    DataInputBuffer buf=new DataInputBuffer();
    try {
      buf.reset(hrib,hrib.length);
      deserializedHri=HRegionInfo.parseFrom(buf);
      assertEquals(hri.getEncodedName(),deserializedHri.getEncodedName());
      assertEquals(hri,deserializedHri);
    }
  finally {
      buf.close();
    }
  }
  @Test public void testRegionInfos() throws Exception {
    HRegionInfo hri=createRandomRegion("testRegionInfos");
    byte[] triple=HRegionInfo.toDelimitedByteArray(hri,hri,hri);
    List<HRegionInfo> regions=HRegionInfo.parseDelimitedFrom(triple,0,triple.length);
    assertTrue(regions.size() == 3);
    assertTrue(regions.get(0).equals(regions.get(1)));
    assertTrue(regions.get(0).equals(regions.get(2)));
  }
  private HRegionInfo createRandomRegion(  final String name){
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(name));
    String[] families=new String[]{"info","anchor"};
    for (int i=0; i < families.length; i++) {
      htd.addFamily(new HColumnDescriptor(families[i]));
    }
    return new HRegionInfo(htd.getTableName(),HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW);
  }
  @Test public void testGet() throws Exception {
    byte[] row="row".getBytes();
    byte[] fam="fam".getBytes();
    byte[] qf1="qf1".getBytes();
    long ts=System.currentTimeMillis();
    int maxVersions=2;
    Get get=new Get(row);
    get.addColumn(fam,qf1);
    get.setTimeRange(ts,ts + 1);
    get.setMaxVersions(maxVersions);
    ClientProtos.Get getProto=ProtobufUtil.toGet(get);
    Get desGet=ProtobufUtil.toGet(getProto);
    assertTrue(Bytes.equals(get.getRow(),desGet.getRow()));
    Set<byte[]> set=null;
    Set<byte[]> desSet=null;
    for (    Map.Entry<byte[],NavigableSet<byte[]>> entry : get.getFamilyMap().entrySet()) {
      assertTrue(desGet.getFamilyMap().containsKey(entry.getKey()));
      set=entry.getValue();
      desSet=desGet.getFamilyMap().get(entry.getKey());
      for (      byte[] qualifier : set) {
        assertTrue(desSet.contains(qualifier));
      }
    }
    assertEquals(get.getMaxVersions(),desGet.getMaxVersions());
    TimeRange tr=get.getTimeRange();
    TimeRange desTr=desGet.getTimeRange();
    assertEquals(tr.getMax(),desTr.getMax());
    assertEquals(tr.getMin(),desTr.getMin());
  }
  @Test public void testScan() throws Exception {
    byte[] startRow="startRow".getBytes();
    byte[] stopRow="stopRow".getBytes();
    byte[] fam="fam".getBytes();
    byte[] qf1="qf1".getBytes();
    long ts=System.currentTimeMillis();
    int maxVersions=2;
    Scan scan=new Scan(startRow,stopRow);
    scan.addColumn(fam,qf1);
    scan.setTimeRange(ts,ts + 1);
    scan.setMaxVersions(maxVersions);
    ClientProtos.Scan scanProto=ProtobufUtil.toScan(scan);
    Scan desScan=ProtobufUtil.toScan(scanProto);
    assertTrue(Bytes.equals(scan.getStartRow(),desScan.getStartRow()));
    assertTrue(Bytes.equals(scan.getStopRow(),desScan.getStopRow()));
    assertEquals(scan.getCacheBlocks(),desScan.getCacheBlocks());
    Set<byte[]> set=null;
    Set<byte[]> desSet=null;
    for (    Map.Entry<byte[],NavigableSet<byte[]>> entry : scan.getFamilyMap().entrySet()) {
      assertTrue(desScan.getFamilyMap().containsKey(entry.getKey()));
      set=entry.getValue();
      desSet=desScan.getFamilyMap().get(entry.getKey());
      for (      byte[] column : set) {
        assertTrue(desSet.contains(column));
      }
      scan=new Scan(startRow);
      final String name="testScan";
      byte[] prefix=Bytes.toBytes(name);
      scan.setFilter(new PrefixFilter(prefix));
      scanProto=ProtobufUtil.toScan(scan);
      desScan=ProtobufUtil.toScan(scanProto);
      Filter f=desScan.getFilter();
      assertTrue(f instanceof PrefixFilter);
    }
    assertEquals(scan.getMaxVersions(),desScan.getMaxVersions());
    TimeRange tr=scan.getTimeRange();
    TimeRange desTr=desScan.getTimeRange();
    assertEquals(tr.getMax(),desTr.getMax());
    assertEquals(tr.getMin(),desTr.getMin());
  }
  protected static final int MAXVERSIONS=3;
  protected final static byte[] fam1=Bytes.toBytes("colfamily1");
  protected final static byte[] fam2=Bytes.toBytes("colfamily2");
  protected final static byte[] fam3=Bytes.toBytes("colfamily3");
  protected static final byte[][] COLUMNS={fam1,fam2,fam3};
  /** 
 * Create a table of name <code>name</code> with  {@link #COLUMNS} forfamilies.
 * @param name Name to give table.
 * @return Column descriptor.
 */
  protected HTableDescriptor createTableDescriptor(  final String name){
    return createTableDescriptor(name,MAXVERSIONS);
  }
  /** 
 * Create a table of name <code>name</code> with  {@link #COLUMNS} forfamilies.
 * @param name Name to give table.
 * @param versions How many versions to allow per column.
 * @return Column descriptor.
 */
  protected HTableDescriptor createTableDescriptor(  final String name,  final int versions){
    HTableDescriptor htd=new HTableDescriptor(TableName.valueOf(name));
    htd.addFamily(new HColumnDescriptor(fam1).setMaxVersions(versions).setBlockCacheEnabled(false));
    htd.addFamily(new HColumnDescriptor(fam2).setMaxVersions(versions).setBlockCacheEnabled(false));
    htd.addFamily(new HColumnDescriptor(fam3).setMaxVersions(versions).setBlockCacheEnabled(false));
    return htd;
  }
}
