@Category({MiscTests.class,MediumTests.class}) public class TestCounter {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestCounter.class);
  private static final int[] THREAD_COUNTS={1,10,100};
  private static final int DATA_COUNT=1000000;
private interface Operation {
    void execute();
  }
  @Test public void testIncrement() throws Exception {
    for (    int threadCount : THREAD_COUNTS) {
      final Counter counter=new Counter();
      execute(new Operation(){
        @Override public void execute(){
          counter.increment();
        }
      }
,threadCount);
      Assert.assertEquals(threadCount * (long)DATA_COUNT,counter.get());
    }
  }
  @Test public void testIncrementAndGet() throws Exception {
    for (    int threadCount : THREAD_COUNTS) {
      final Counter counter=new Counter();
      execute(new Operation(){
        @Override public void execute(){
          counter.increment();
          counter.get();
        }
      }
,threadCount);
      Assert.assertEquals(threadCount * (long)DATA_COUNT,counter.get());
    }
  }
  private static void execute(  final Operation op,  int threadCount) throws InterruptedException {
    final CountDownLatch prepareLatch=new CountDownLatch(threadCount);
    final CountDownLatch startLatch=new CountDownLatch(1);
    final CountDownLatch endLatch=new CountDownLatch(threadCount);
class OperationThread extends Thread {
      @Override public void run(){
        try {
          prepareLatch.countDown();
          startLatch.await();
          for (int i=0; i < DATA_COUNT; i++) {
            op.execute();
          }
          endLatch.countDown();
        }
 catch (        Exception e) {
        }
      }
    }
    for (int j=0; j < threadCount; j++) {
      new OperationThread().start();
    }
    prepareLatch.await();
    startLatch.countDown();
    endLatch.await();
  }
}
