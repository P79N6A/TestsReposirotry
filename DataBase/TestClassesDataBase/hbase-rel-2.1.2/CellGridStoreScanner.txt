/** 
 * A StoreScanner for our CELL_GRID above. Fakes the block transitions. Does counts of calls to optimize and counts of when optimize actually did an optimize.
 */
private static class CellGridStoreScanner extends StoreScanner {
  AtomicInteger count;
  final AtomicInteger optimization=new AtomicInteger(0);
  CellGridStoreScanner(  final Scan scan,  ScanInfo scanInfo) throws IOException {
    super(scan,scanInfo,scan.getFamilyMap().get(CF),Arrays.<KeyValueScanner>asList(new KeyValueScanner[]{new KeyValueScanFixture(CellComparator.getInstance(),CELL_GRID)}));
  }
  @Override protected void resetKVHeap(  List<? extends KeyValueScanner> scanners,  CellComparator comparator) throws IOException {
    if (count == null) {
      count=new AtomicInteger(0);
    }
    heap=newKVHeap(scanners,comparator);
  }
  @Override protected KeyValueHeap newKVHeap(  List<? extends KeyValueScanner> scanners,  CellComparator comparator) throws IOException {
    return new KeyValueHeapWithCount(scanners,comparator,count);
  }
  @Override protected boolean trySkipToNextRow(  Cell cell) throws IOException {
    boolean optimized=super.trySkipToNextRow(cell);
    LOG.info("Cell=" + cell + ", nextIndex="+ CellUtil.toString(getNextIndexedKey(),false)+ ", optimized="+ optimized);
    if (optimized) {
      optimization.incrementAndGet();
    }
    return optimized;
  }
  @Override protected boolean trySkipToNextColumn(  Cell cell) throws IOException {
    boolean optimized=super.trySkipToNextColumn(cell);
    LOG.info("Cell=" + cell + ", nextIndex="+ CellUtil.toString(getNextIndexedKey(),false)+ ", optimized="+ optimized);
    if (optimized) {
      optimization.incrementAndGet();
    }
    return optimized;
  }
  @Override public Cell getNextIndexedKey(){
    return count.get() > CELL_GRID_BLOCK4_BOUNDARY ? PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK5_BOUNDARY]) : count.get() > CELL_GRID_BLOCK3_BOUNDARY ? PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK4_BOUNDARY]) : count.get() > CELL_GRID_BLOCK2_BOUNDARY ? PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK3_BOUNDARY]) : PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK2_BOUNDARY]);
  }
}
