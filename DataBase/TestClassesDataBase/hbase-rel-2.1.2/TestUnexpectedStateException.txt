/** 
 * Tests for HBASE-18408 "AM consumes CPU and fills up the logs really fast when there is no RS to assign". If an  {@link org.apache.hadoop.hbase.exceptions.UnexpectedStateException}, we'd spin on the ProcedureExecutor consuming CPU and filling logs. Test new back-off facility.
 */
@Category({MasterTests.class,MediumTests.class}) public class TestUnexpectedStateException {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestUnexpectedStateException.class);
  @Rule public final TestName name=new TestName();
  private static final Logger LOG=LoggerFactory.getLogger(TestUnexpectedStateException.class);
  private static final HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final byte[] FAMILY=Bytes.toBytes("family");
  private TableName tableName;
  private static final int REGIONS=10;
  @BeforeClass public static void beforeClass() throws Exception {
    TEST_UTIL.startMiniCluster();
  }
  @AfterClass public static void afterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Before public void before() throws IOException {
    this.tableName=TableName.valueOf(this.name.getMethodName());
    TEST_UTIL.createMultiRegionTable(this.tableName,FAMILY,REGIONS);
  }
  private RegionInfo pickArbitraryRegion(  Admin admin) throws IOException {
    List<RegionInfo> regions=admin.getRegions(this.tableName);
    return regions.get(3);
  }
  /** 
 * Manufacture a state that will throw UnexpectedStateException. Change an assigned region's 'state' to be OPENING. That'll mess up a subsequent unassign causing it to throw UnexpectedStateException. We can easily manufacture this infinite retry state in UnassignProcedure because it has no startTransition. AssignProcedure does where it squashes whatever the current region state is making it OFFLINE. That makes it harder to mess it up. Make do with UnassignProcedure for now.
 */
  @Test public void testUnableToAssign() throws Exception {
    try (Admin admin=TEST_UTIL.getAdmin()){
      final RegionInfo region=pickArbitraryRegion(admin);
      AssignmentManager am=TEST_UTIL.getHBaseCluster().getMaster().getAssignmentManager();
      RegionStates.RegionStateNode rsn=am.getRegionStates().getRegionStateNode(region);
      am.markRegionAsOpening(rsn);
      Runnable unassign=() -> {
        try {
          admin.unassign(region.getRegionName(),true);
        }
 catch (        IOException ioe) {
          fail("Failed assign");
        }
      }
;
      Thread t=new Thread(unassign,"unassign");
      t.start();
      while (!t.isAlive()) {
        Threads.sleep(100);
      }
      Threads.sleep(1000);
      JsonParser parser=new JsonParser();
      long oldTimeout=0;
      int timeoutIncrements=0;
      while (true) {
        long timeout=getUnassignTimeout(parser,admin.getProcedures());
        if (timeout > oldTimeout) {
          LOG.info("Timeout incremented, was {}, now is {}, increments={}",timeout,oldTimeout,timeoutIncrements);
          oldTimeout=timeout;
          timeoutIncrements++;
          if (timeoutIncrements > 3) {
            break;
          }
        }
        Thread.sleep(1000);
      }
      TEST_UTIL.getMiniHBaseCluster().stopMaster(0).join();
      HMaster master=TEST_UTIL.getMiniHBaseCluster().startMaster().getMaster();
      TEST_UTIL.waitFor(30000,() -> master.isInitialized());
      am=master.getAssignmentManager();
      rsn=am.getRegionStates().getRegionStateNode(region);
      am.markRegionAsOpened(rsn);
      t.join();
    }
   }
  /** 
 * @param proceduresAsJSON This is String returned by admin.getProcedures call... an array ofProcedures as JSON.
 * @return The Procedure timeout value parsed from the Unassign Procedure.
 * @Exception Thrown if we do not find UnassignProcedure or fail to parse timeout.
 */
  private long getUnassignTimeout(  JsonParser parser,  String proceduresAsJSON) throws Exception {
    JsonArray array=parser.parse(proceduresAsJSON).getAsJsonArray();
    Iterator<JsonElement> iterator=array.iterator();
    while (iterator.hasNext()) {
      JsonElement element=iterator.next();
      JsonObject obj=element.getAsJsonObject();
      String className=obj.get("className").getAsString();
      String actualClassName=UnassignProcedure.class.getName();
      if (className.equals(actualClassName)) {
        return obj.get("timeout").getAsLong();
      }
    }
    throw new Exception("Failed to find UnassignProcedure or timeout in " + proceduresAsJSON);
  }
}
