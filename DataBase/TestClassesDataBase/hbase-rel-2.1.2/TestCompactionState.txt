/** 
 * Unit tests to test retrieving table/region compaction state
 */
@Category({VerySlowRegionServerTests.class,LargeTests.class}) public class TestCompactionState {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestCompactionState.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestCompactionState.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private final static Random random=new Random();
  @Rule public TestName name=new TestName();
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    TEST_UTIL.startMiniCluster();
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testMajorCompaction() throws IOException, InterruptedException {
    compaction(name.getMethodName(),8,CompactionState.MAJOR,false);
  }
  @Test public void testMinorCompaction() throws IOException, InterruptedException {
    compaction(name.getMethodName(),15,CompactionState.MINOR,false);
  }
  @Test public void testMajorCompactionOnFamily() throws IOException, InterruptedException {
    compaction(name.getMethodName(),8,CompactionState.MAJOR,true);
  }
  @Test public void testMinorCompactionOnFamily() throws IOException, InterruptedException {
    compaction(name.getMethodName(),15,CompactionState.MINOR,true);
  }
  @Test public void testInvalidColumnFamily() throws IOException, InterruptedException {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    byte[] family=Bytes.toBytes("family");
    byte[] fakecf=Bytes.toBytes("fakecf");
    boolean caughtMinorCompact=false;
    boolean caughtMajorCompact=false;
    Table ht=null;
    try {
      ht=TEST_UTIL.createTable(tableName,family);
      Admin admin=TEST_UTIL.getAdmin();
      try {
        admin.compact(tableName,fakecf);
      }
 catch (      IOException ioe) {
        caughtMinorCompact=true;
      }
      try {
        admin.majorCompact(tableName,fakecf);
      }
 catch (      IOException ioe) {
        caughtMajorCompact=true;
      }
    }
  finally {
      if (ht != null) {
        TEST_UTIL.deleteTable(tableName);
      }
      assertTrue(caughtMinorCompact);
      assertTrue(caughtMajorCompact);
    }
  }
  /** 
 * Load data to a table, flush it to disk, trigger compaction, confirm the compaction state is right and wait till it is done.
 * @param tableName
 * @param flushes
 * @param expectedState
 * @param singleFamily otherwise, run compaction on all cfs
 * @throws IOException
 * @throws InterruptedException
 */
  private void compaction(  final String tableName,  final int flushes,  final CompactionState expectedState,  boolean singleFamily) throws IOException, InterruptedException {
    TableName table=TableName.valueOf(tableName);
    byte[] family=Bytes.toBytes("family");
    byte[][] families={family,Bytes.add(family,Bytes.toBytes("2")),Bytes.add(family,Bytes.toBytes("3"))};
    Table ht=null;
    try {
      ht=TEST_UTIL.createTable(table,families);
      loadData(ht,families,3000,flushes);
      HRegionServer rs=TEST_UTIL.getMiniHBaseCluster().getRegionServer(0);
      List<HRegion> regions=rs.getRegions(table);
      int countBefore=countStoreFilesInFamilies(regions,families);
      int countBeforeSingleFamily=countStoreFilesInFamily(regions,family);
      assertTrue(countBefore > 0);
      Admin admin=TEST_UTIL.getAdmin();
      if (expectedState == CompactionState.MINOR) {
        if (singleFamily) {
          admin.compact(table,family);
        }
 else {
          admin.compact(table);
        }
      }
 else {
        if (singleFamily) {
          admin.majorCompact(table,family);
        }
 else {
          admin.majorCompact(table);
        }
      }
      long curt=System.currentTimeMillis();
      long waitTime=5000;
      long endt=curt + waitTime;
      CompactionState state=admin.getCompactionState(table);
      while (state == CompactionState.NONE && curt < endt) {
        Thread.sleep(10);
        state=admin.getCompactionState(table);
        curt=System.currentTimeMillis();
      }
      if (expectedState != state) {
        for (        Region region : regions) {
          state=CompactionState.valueOf(region.getCompactionState().toString());
          assertEquals(CompactionState.NONE,state);
        }
      }
 else {
        state=admin.getCompactionState(table);
        while (state != CompactionState.NONE && curt < endt) {
          Thread.sleep(10);
          state=admin.getCompactionState(table);
        }
        assertEquals(CompactionState.NONE,state);
      }
      int countAfter=countStoreFilesInFamilies(regions,families);
      int countAfterSingleFamily=countStoreFilesInFamily(regions,family);
      assertTrue(countAfter < countBefore);
      if (!singleFamily) {
        if (expectedState == CompactionState.MAJOR)         assertTrue(families.length == countAfter);
 else         assertTrue(families.length < countAfter);
      }
 else {
        int singleFamDiff=countBeforeSingleFamily - countAfterSingleFamily;
        assertTrue(singleFamDiff == (countBefore - countAfter));
        if (expectedState == CompactionState.MAJOR) {
          assertTrue(1 == countAfterSingleFamily);
        }
 else {
          assertTrue(1 < countAfterSingleFamily);
        }
      }
    }
  finally {
      if (ht != null) {
        TEST_UTIL.deleteTable(table);
      }
    }
  }
  private static int countStoreFilesInFamily(  List<HRegion> regions,  final byte[] family){
    return countStoreFilesInFamilies(regions,new byte[][]{family});
  }
  private static int countStoreFilesInFamilies(  List<HRegion> regions,  final byte[][] families){
    int count=0;
    for (    HRegion region : regions) {
      count+=region.getStoreFileList(families).size();
    }
    return count;
  }
  private static void loadData(  final Table ht,  final byte[][] families,  final int rows,  final int flushes) throws IOException {
    List<Put> puts=new ArrayList<>(rows);
    byte[] qualifier=Bytes.toBytes("val");
    for (int i=0; i < flushes; i++) {
      for (int k=0; k < rows; k++) {
        byte[] row=Bytes.toBytes(random.nextLong());
        Put p=new Put(row);
        for (int j=0; j < families.length; ++j) {
          p.addColumn(families[j],qualifier,row);
        }
        puts.add(p);
      }
      ht.put(puts);
      TEST_UTIL.flush();
      puts.clear();
    }
  }
}
