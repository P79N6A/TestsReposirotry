@Category({MasterTests.class,MediumTests.class}) public class TestMergeTableRegionsProcedure {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestMergeTableRegionsProcedure.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestMergeTableRegionsProcedure.class);
  @Rule public final TestName name=new TestName();
  protected static final HBaseTestingUtility UTIL=new HBaseTestingUtility();
  private static final int initialRegionCount=4;
  private final static byte[] FAMILY=Bytes.toBytes("FAMILY");
  final static Configuration conf=UTIL.getConfiguration();
  private static Admin admin;
  private AssignmentManager am;
  private ProcedureMetrics mergeProcMetrics;
  private ProcedureMetrics assignProcMetrics;
  private ProcedureMetrics unassignProcMetrics;
  private long mergeSubmittedCount=0;
  private long mergeFailedCount=0;
  private long assignSubmittedCount=0;
  private long assignFailedCount=0;
  private long unassignSubmittedCount=0;
  private long unassignFailedCount=0;
  private static void setupConf(  Configuration conf){
    conf.setInt("hbase.assignment.maximum.attempts",3);
    conf.setInt("hbase.master.maximum.ping.server.attempts",3);
    conf.setInt("hbase.master.ping.server.retry.sleep.interval",1);
    conf.setInt(MasterProcedureConstants.MASTER_PROCEDURE_THREADS,1);
    conf.setInt(MasterProcedureConstants.MASTER_URGENT_PROCEDURE_THREADS,0);
  }
  @BeforeClass public static void setupCluster() throws Exception {
    setupConf(conf);
    UTIL.startMiniCluster(1);
    admin=UTIL.getHBaseAdmin();
  }
  @AfterClass public static void cleanupTest() throws Exception {
    try {
      UTIL.shutdownMiniCluster();
    }
 catch (    Exception e) {
      LOG.warn("failure shutting down cluster",e);
    }
  }
  @Before public void setup() throws Exception {
    resetProcExecutorTestingKillFlag();
    MasterProcedureTestingUtility.generateNonceGroup(UTIL.getHBaseCluster().getMaster());
    MasterProcedureTestingUtility.generateNonce(UTIL.getHBaseCluster().getMaster());
    UTIL.getHBaseAdmin().setBalancerRunning(false,true);
    UTIL.getHBaseCluster().getMaster().setCatalogJanitorEnabled(false);
    resetProcExecutorTestingKillFlag();
    am=UTIL.getHBaseCluster().getMaster().getAssignmentManager();
    mergeProcMetrics=am.getAssignmentManagerMetrics().getMergeProcMetrics();
    assignProcMetrics=am.getAssignmentManagerMetrics().getAssignProcMetrics();
    unassignProcMetrics=am.getAssignmentManagerMetrics().getUnassignProcMetrics();
  }
  @After public void tearDown() throws Exception {
    resetProcExecutorTestingKillFlag();
    for (    HTableDescriptor htd : UTIL.getHBaseAdmin().listTables()) {
      LOG.info("Tear down, remove table=" + htd.getTableName());
      UTIL.deleteTable(htd.getTableName());
    }
  }
  private void resetProcExecutorTestingKillFlag(){
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,false);
    assertTrue("expected executor to be running",procExec.isRunning());
  }
  /** 
 * This tests two region merges
 */
  @Test public void testMergeTwoRegions() throws Exception {
    final TableName tableName=TableName.valueOf(this.name.getMethodName());
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    List<RegionInfo> tableRegions=createTable(tableName);
    RegionInfo[] regionsToMerge=new RegionInfo[2];
    regionsToMerge[0]=tableRegions.get(0);
    regionsToMerge[1]=tableRegions.get(1);
    collectAssignmentManagerMetrics();
    MergeTableRegionsProcedure proc=new MergeTableRegionsProcedure(procExec.getEnvironment(),regionsToMerge,true);
    long procId=procExec.submitProcedure(proc);
    ProcedureTestingUtility.waitProcedure(procExec,procId);
    ProcedureTestingUtility.assertProcNotFailed(procExec,procId);
    assertRegionCount(tableName,initialRegionCount - 1);
    assertEquals(mergeSubmittedCount + 1,mergeProcMetrics.getSubmittedCounter().getCount());
    assertEquals(mergeFailedCount,mergeProcMetrics.getFailedCounter().getCount());
    assertEquals(assignSubmittedCount + 1,assignProcMetrics.getSubmittedCounter().getCount());
    assertEquals(assignFailedCount,assignProcMetrics.getFailedCounter().getCount());
    assertEquals(unassignSubmittedCount + 2,unassignProcMetrics.getSubmittedCounter().getCount());
    assertEquals(unassignFailedCount,unassignProcMetrics.getFailedCounter().getCount());
    Pair<RegionInfo,RegionInfo> pair=MetaTableAccessor.getRegionsFromMergeQualifier(UTIL.getConnection(),proc.getMergedRegion().getRegionName());
    assertTrue(pair.getFirst() != null && pair.getSecond() != null);
    UTIL.getHBaseCluster().getMaster().setCatalogJanitorEnabled(true);
    UTIL.getHBaseCluster().getMaster().getCatalogJanitor().triggerNow();
    while (pair != null && pair.getFirst() != null && pair.getSecond() != null) {
      pair=MetaTableAccessor.getRegionsFromMergeQualifier(UTIL.getConnection(),proc.getMergedRegion().getRegionName());
    }
  }
  /** 
 * This tests two concurrent region merges
 */
  @Test public void testMergeRegionsConcurrently() throws Exception {
    final TableName tableName=TableName.valueOf("testMergeRegionsConcurrently");
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    List<RegionInfo> tableRegions=createTable(tableName);
    RegionInfo[] regionsToMerge1=new RegionInfo[2];
    RegionInfo[] regionsToMerge2=new RegionInfo[2];
    regionsToMerge1[0]=tableRegions.get(0);
    regionsToMerge1[1]=tableRegions.get(1);
    regionsToMerge2[0]=tableRegions.get(2);
    regionsToMerge2[1]=tableRegions.get(3);
    collectAssignmentManagerMetrics();
    long procId1=procExec.submitProcedure(new MergeTableRegionsProcedure(procExec.getEnvironment(),regionsToMerge1,true));
    long procId2=procExec.submitProcedure(new MergeTableRegionsProcedure(procExec.getEnvironment(),regionsToMerge2,true));
    ProcedureTestingUtility.waitProcedure(procExec,procId1);
    ProcedureTestingUtility.waitProcedure(procExec,procId2);
    ProcedureTestingUtility.assertProcNotFailed(procExec,procId1);
    ProcedureTestingUtility.assertProcNotFailed(procExec,procId2);
    assertRegionCount(tableName,initialRegionCount - 2);
    assertEquals(mergeSubmittedCount + 2,mergeProcMetrics.getSubmittedCounter().getCount());
    assertEquals(mergeFailedCount,mergeProcMetrics.getFailedCounter().getCount());
    assertEquals(assignSubmittedCount + 2,assignProcMetrics.getSubmittedCounter().getCount());
    assertEquals(assignFailedCount,assignProcMetrics.getFailedCounter().getCount());
    assertEquals(unassignSubmittedCount + 4,unassignProcMetrics.getSubmittedCounter().getCount());
    assertEquals(unassignFailedCount,unassignProcMetrics.getFailedCounter().getCount());
  }
  @Test public void testRecoveryAndDoubleExecution() throws Exception {
    final TableName tableName=TableName.valueOf("testRecoveryAndDoubleExecution");
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    List<RegionInfo> tableRegions=createTable(tableName);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    RegionInfo[] regionsToMerge=new RegionInfo[2];
    regionsToMerge[0]=tableRegions.get(0);
    regionsToMerge[1]=tableRegions.get(1);
    long procId=procExec.submitProcedure(new MergeTableRegionsProcedure(procExec.getEnvironment(),regionsToMerge,true));
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec,procId);
    ProcedureTestingUtility.assertProcNotFailed(procExec,procId);
    assertRegionCount(tableName,initialRegionCount - 1);
  }
  @Test public void testRollbackAndDoubleExecution() throws Exception {
    final TableName tableName=TableName.valueOf("testRollbackAndDoubleExecution");
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    List<RegionInfo> tableRegions=createTable(tableName);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    RegionInfo[] regionsToMerge=new RegionInfo[2];
    regionsToMerge[0]=tableRegions.get(0);
    regionsToMerge[1]=tableRegions.get(1);
    long procId=procExec.submitProcedure(new MergeTableRegionsProcedure(procExec.getEnvironment(),regionsToMerge,true));
    int lastStep=8;
    MasterProcedureTestingUtility.testRollbackAndDoubleExecution(procExec,procId,lastStep,true);
    assertEquals(initialRegionCount,UTIL.getAdmin().getRegions(tableName).size());
    UTIL.waitUntilAllRegionsAssigned(tableName);
    List<HRegion> regions=UTIL.getMiniHBaseCluster().getRegions(tableName);
    assertEquals(initialRegionCount,regions.size());
  }
  @Test public void testMergeWithoutPONR() throws Exception {
    final TableName tableName=TableName.valueOf("testMergeWithoutPONR");
    final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
    List<RegionInfo> tableRegions=createTable(tableName);
    ProcedureTestingUtility.waitNoProcedureRunning(procExec);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
    RegionInfo[] regionsToMerge=new RegionInfo[2];
    regionsToMerge[0]=tableRegions.get(0);
    regionsToMerge[1]=tableRegions.get(1);
    long procId=procExec.submitProcedure(new MergeTableRegionsProcedure(procExec.getEnvironment(),regionsToMerge,true));
    MasterProcedureTestingUtility.testRecoveryAndDoubleExecution(procExec,procId,9,false);
    ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,false);
    MasterProcedureTestingUtility.restartMasterProcedureExecutor(procExec);
    ProcedureTestingUtility.waitProcedure(procExec,procId);
    assertRegionCount(tableName,initialRegionCount - 1);
  }
  private List<RegionInfo> createTable(  final TableName tableName) throws Exception {
    HTableDescriptor desc=new HTableDescriptor(tableName);
    desc.addFamily(new HColumnDescriptor(FAMILY));
    byte[][] splitRows=new byte[initialRegionCount - 1][];
    for (int i=0; i < splitRows.length; ++i) {
      splitRows[i]=Bytes.toBytes(String.format("%d",i));
    }
    admin.createTable(desc,splitRows);
    return assertRegionCount(tableName,initialRegionCount);
  }
  public List<RegionInfo> assertRegionCount(  final TableName tableName,  final int nregions) throws Exception {
    UTIL.waitUntilNoRegionsInTransition();
    List<RegionInfo> tableRegions=admin.getRegions(tableName);
    assertEquals(nregions,tableRegions.size());
    return tableRegions;
  }
  private ProcedureExecutor<MasterProcedureEnv> getMasterProcedureExecutor(){
    return UTIL.getHBaseCluster().getMaster().getMasterProcedureExecutor();
  }
  private void collectAssignmentManagerMetrics(){
    mergeSubmittedCount=mergeProcMetrics.getSubmittedCounter().getCount();
    mergeFailedCount=mergeProcMetrics.getFailedCounter().getCount();
    assignSubmittedCount=assignProcMetrics.getSubmittedCounter().getCount();
    assignFailedCount=assignProcMetrics.getFailedCounter().getCount();
    unassignSubmittedCount=unassignProcMetrics.getSubmittedCounter().getCount();
    unassignFailedCount=unassignProcMetrics.getFailedCounter().getCount();
  }
}
