/** 
 * Test the scenario where a HRegionServer#scan() call, while scanning, timeout at client side and getting retried. This scenario should not result in some data being skipped at RS side.
 */
@Category({MediumTests.class,ClientTests.class}) public class TestClientScannerRPCTimeout {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestClientScannerRPCTimeout.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestClientScannerRPCTimeout.class);
  private final static HBaseTestingUtility TEST_UTIL=new HBaseTestingUtility();
  private static final byte[] FAMILY=Bytes.toBytes("testFamily");
  private static final byte[] QUALIFIER=Bytes.toBytes("testQualifier");
  private static final byte[] VALUE=Bytes.toBytes("testValue");
  private static final int rpcTimeout=2 * 1000;
  private static final int CLIENT_RETRIES_NUMBER=3;
  @Rule public TestName name=new TestName();
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    Configuration conf=TEST_UTIL.getConfiguration();
    conf.setInt("hbase.regionserver.msginterval",3 * 10000);
    conf.setInt(HConstants.HBASE_RPC_TIMEOUT_KEY,rpcTimeout);
    conf.setStrings(HConstants.REGION_SERVER_IMPL,RegionServerWithScanTimeout.class.getName());
    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,CLIENT_RETRIES_NUMBER);
    conf.setInt(HConstants.HBASE_CLIENT_PAUSE,1000);
    TEST_UTIL.startMiniCluster(1);
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    TEST_UTIL.shutdownMiniCluster();
  }
  @Test public void testScannerNextRPCTimesout() throws Exception {
    final TableName tableName=TableName.valueOf(name.getMethodName());
    Table ht=TEST_UTIL.createTable(tableName,FAMILY);
    byte[] r0=Bytes.toBytes("row-0");
    byte[] r1=Bytes.toBytes("row-1");
    byte[] r2=Bytes.toBytes("row-2");
    byte[] r3=Bytes.toBytes("row-3");
    putToTable(ht,r0);
    putToTable(ht,r1);
    putToTable(ht,r2);
    putToTable(ht,r3);
    LOG.info("Wrote our three values");
    RSRpcServicesWithScanTimeout.seqNoToSleepOn=1;
    Scan scan=new Scan();
    scan.setCaching(1);
    ResultScanner scanner=ht.getScanner(scan);
    Result result=scanner.next();
    assertTrue("Expected row: row-0",Bytes.equals(r0,result.getRow()));
    result=scanner.next();
    assertTrue("Expected row: row-1",Bytes.equals(r1,result.getRow()));
    LOG.info("Got expected first row");
    long t1=System.currentTimeMillis();
    result=scanner.next();
    assertTrue((System.currentTimeMillis() - t1) > rpcTimeout);
    assertTrue("Expected row: row-2",Bytes.equals(r2,result.getRow()));
    RSRpcServicesWithScanTimeout.seqNoToSleepOn=-1;
    result=scanner.next();
    assertTrue("Expected row: row-3",Bytes.equals(r3,result.getRow()));
    scanner.close();
    scanner=ht.getScanner(scan);
    RSRpcServicesWithScanTimeout.sleepAlways=true;
    RSRpcServicesWithScanTimeout.tryNumber=0;
    try {
      result=scanner.next();
    }
 catch (    IOException ioe) {
      LOG.info("Failed after maximal attempts=" + CLIENT_RETRIES_NUMBER,ioe);
    }
    assertTrue("Expected maximal try number=" + CLIENT_RETRIES_NUMBER + ", actual ="+ RSRpcServicesWithScanTimeout.tryNumber,RSRpcServicesWithScanTimeout.tryNumber <= CLIENT_RETRIES_NUMBER);
  }
  private void putToTable(  Table ht,  byte[] rowkey) throws IOException {
    Put put=new Put(rowkey);
    put.addColumn(FAMILY,QUALIFIER,VALUE);
    ht.put(put);
  }
private static class RegionServerWithScanTimeout extends MiniHBaseClusterRegionServer {
    public RegionServerWithScanTimeout(    Configuration conf) throws IOException, InterruptedException {
      super(conf);
    }
    @Override protected RSRpcServices createRpcServices() throws IOException {
      return new RSRpcServicesWithScanTimeout(this);
    }
  }
private static class RSRpcServicesWithScanTimeout extends RSRpcServices {
    private long tableScannerId;
    private boolean slept;
    private static long seqNoToSleepOn=-1;
    private static boolean sleepAlways=false;
    private static int tryNumber=0;
    public RSRpcServicesWithScanTimeout(    HRegionServer rs) throws IOException {
      super(rs);
    }
    @Override public ScanResponse scan(    final RpcController controller,    final ScanRequest request) throws ServiceException {
      if (request.hasScannerId()) {
        ScanResponse scanResponse=super.scan(controller,request);
        if (this.tableScannerId == request.getScannerId() && (sleepAlways || (!slept && seqNoToSleepOn == request.getNextCallSeq()))) {
          try {
            LOG.info("SLEEPING " + (rpcTimeout + 500));
            Thread.sleep(rpcTimeout + 500);
          }
 catch (          InterruptedException e) {
          }
          slept=true;
          tryNumber++;
          if (tryNumber > 2 * CLIENT_RETRIES_NUMBER) {
            sleepAlways=false;
          }
        }
        return scanResponse;
      }
 else {
        ScanResponse scanRes=super.scan(controller,request);
        String regionName=Bytes.toString(request.getRegion().getValue().toByteArray());
        if (!regionName.contains(TableName.META_TABLE_NAME.getNameAsString())) {
          tableScannerId=scanRes.getScannerId();
        }
        return scanRes;
      }
    }
  }
}
