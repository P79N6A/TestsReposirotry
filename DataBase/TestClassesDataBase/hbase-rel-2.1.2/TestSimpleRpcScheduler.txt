@Category({RPCTests.class,SmallTests.class}) public class TestSimpleRpcScheduler {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestSimpleRpcScheduler.class);
  private static final Logger LOG=LoggerFactory.getLogger(TestSimpleRpcScheduler.class);
  private final RpcScheduler.Context CONTEXT=new RpcScheduler.Context(){
    @Override public InetSocketAddress getListenerAddress(){
      return InetSocketAddress.createUnresolved("127.0.0.1",1000);
    }
  }
;
  private Configuration conf;
  @Before public void setUp(){
    conf=HBaseConfiguration.create();
  }
  @Test public void testBasic() throws IOException, InterruptedException {
    PriorityFunction qosFunction=mock(PriorityFunction.class);
    RpcScheduler scheduler=new SimpleRpcScheduler(conf,10,0,0,qosFunction,0);
    scheduler.init(CONTEXT);
    scheduler.start();
    CallRunner task=createMockTask();
    task.setStatus(new MonitoredRPCHandlerImpl());
    scheduler.dispatch(task);
    verify(task,timeout(10000)).run();
    scheduler.stop();
  }
  private RpcScheduler disableHandlers(  RpcScheduler scheduler){
    try {
      Field ExecutorField=scheduler.getClass().getDeclaredField("callExecutor");
      ExecutorField.setAccessible(true);
      RpcExecutor rpcExecutor=(RpcExecutor)ExecutorField.get(scheduler);
      Field handlerCountField=rpcExecutor.getClass().getSuperclass().getSuperclass().getDeclaredField("handlerCount");
      handlerCountField.setAccessible(true);
      handlerCountField.set(rpcExecutor,0);
      Field numCallQueuesField=rpcExecutor.getClass().getSuperclass().getSuperclass().getDeclaredField("numCallQueues");
      numCallQueuesField.setAccessible(true);
      numCallQueuesField.set(rpcExecutor,1);
      Field currentQueueLimitField=rpcExecutor.getClass().getSuperclass().getSuperclass().getDeclaredField("currentQueueLimit");
      currentQueueLimitField.setAccessible(true);
      currentQueueLimitField.set(rpcExecutor,100);
    }
 catch (    NoSuchFieldException e) {
      LOG.error("No such field exception" + e);
    }
catch (    IllegalAccessException e) {
      LOG.error("Illegal access exception" + e);
    }
    return scheduler;
  }
  @Test public void testCallQueueInfo() throws IOException, InterruptedException {
    PriorityFunction qosFunction=mock(PriorityFunction.class);
    RpcScheduler scheduler=new SimpleRpcScheduler(conf,0,0,0,qosFunction,0);
    scheduler.init(CONTEXT);
    scheduler=disableHandlers(scheduler);
    scheduler.start();
    int totalCallMethods=10;
    for (int i=totalCallMethods; i > 0; i--) {
      CallRunner task=createMockTask();
      task.setStatus(new MonitoredRPCHandlerImpl());
      scheduler.dispatch(task);
    }
    CallQueueInfo callQueueInfo=scheduler.getCallQueueInfo();
    for (    String callQueueName : callQueueInfo.getCallQueueNames()) {
      for (      String calledMethod : callQueueInfo.getCalledMethodNames(callQueueName)) {
        assertEquals(totalCallMethods,callQueueInfo.getCallMethodCount(callQueueName,calledMethod));
      }
    }
    scheduler.stop();
  }
  @Test public void testHandlerIsolation() throws IOException, InterruptedException {
    CallRunner generalTask=createMockTask();
    CallRunner priorityTask=createMockTask();
    CallRunner replicationTask=createMockTask();
    List<CallRunner> tasks=ImmutableList.of(generalTask,priorityTask,replicationTask);
    Map<CallRunner,Integer> qos=ImmutableMap.of(generalTask,0,priorityTask,HConstants.HIGH_QOS + 1,replicationTask,HConstants.REPLICATION_QOS);
    PriorityFunction qosFunction=mock(PriorityFunction.class);
    final Map<CallRunner,Thread> handlerThreads=Maps.newHashMap();
    final CountDownLatch countDownLatch=new CountDownLatch(tasks.size());
    Answer<Void> answerToRun=new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocationOnMock) throws Throwable {
synchronized (handlerThreads) {
          handlerThreads.put((CallRunner)invocationOnMock.getMock(),Thread.currentThread());
        }
        countDownLatch.countDown();
        return null;
      }
    }
;
    for (    CallRunner task : tasks) {
      task.setStatus(new MonitoredRPCHandlerImpl());
      doAnswer(answerToRun).when(task).run();
    }
    RpcScheduler scheduler=new SimpleRpcScheduler(conf,1,1,1,qosFunction,HConstants.HIGH_QOS);
    scheduler.init(CONTEXT);
    scheduler.start();
    for (    CallRunner task : tasks) {
      when(qosFunction.getPriority(any(),any(),any())).thenReturn(qos.get(task));
      scheduler.dispatch(task);
    }
    for (    CallRunner task : tasks) {
      verify(task,timeout(10000)).run();
    }
    scheduler.stop();
    countDownLatch.await();
    assertEquals(3,ImmutableSet.copyOf(handlerThreads.values()).size());
  }
  private CallRunner createMockTask(){
    ServerCall call=mock(ServerCall.class);
    CallRunner task=mock(CallRunner.class);
    when(task.getRpcCall()).thenReturn(call);
    return task;
  }
  @Test public void testRpcScheduler() throws Exception {
    testRpcScheduler(RpcExecutor.CALL_QUEUE_TYPE_DEADLINE_CONF_VALUE);
    testRpcScheduler(RpcExecutor.CALL_QUEUE_TYPE_FIFO_CONF_VALUE);
  }
  private void testRpcScheduler(  final String queueType) throws Exception {
    Configuration schedConf=HBaseConfiguration.create();
    schedConf.set(RpcExecutor.CALL_QUEUE_TYPE_CONF_KEY,queueType);
    PriorityFunction priority=mock(PriorityFunction.class);
    when(priority.getPriority(any(),any(),any())).thenReturn(HConstants.NORMAL_QOS);
    RpcScheduler scheduler=new SimpleRpcScheduler(schedConf,1,1,1,priority,HConstants.QOS_THRESHOLD);
    try {
      scheduler.start();
      CallRunner smallCallTask=mock(CallRunner.class);
      ServerCall smallCall=mock(ServerCall.class);
      RequestHeader smallHead=RequestHeader.newBuilder().setCallId(1).build();
      when(smallCallTask.getRpcCall()).thenReturn(smallCall);
      when(smallCall.getHeader()).thenReturn(smallHead);
      CallRunner largeCallTask=mock(CallRunner.class);
      ServerCall largeCall=mock(ServerCall.class);
      RequestHeader largeHead=RequestHeader.newBuilder().setCallId(50).build();
      when(largeCallTask.getRpcCall()).thenReturn(largeCall);
      when(largeCall.getHeader()).thenReturn(largeHead);
      CallRunner hugeCallTask=mock(CallRunner.class);
      ServerCall hugeCall=mock(ServerCall.class);
      RequestHeader hugeHead=RequestHeader.newBuilder().setCallId(100).build();
      when(hugeCallTask.getRpcCall()).thenReturn(hugeCall);
      when(hugeCall.getHeader()).thenReturn(hugeHead);
      when(priority.getDeadline(eq(smallHead),any())).thenReturn(0L);
      when(priority.getDeadline(eq(largeHead),any())).thenReturn(50L);
      when(priority.getDeadline(eq(hugeHead),any())).thenReturn(100L);
      final ArrayList<Integer> work=new ArrayList<>();
      doAnswerTaskExecution(smallCallTask,work,10,250);
      doAnswerTaskExecution(largeCallTask,work,50,250);
      doAnswerTaskExecution(hugeCallTask,work,100,250);
      scheduler.dispatch(smallCallTask);
      scheduler.dispatch(smallCallTask);
      scheduler.dispatch(smallCallTask);
      scheduler.dispatch(hugeCallTask);
      scheduler.dispatch(smallCallTask);
      scheduler.dispatch(largeCallTask);
      scheduler.dispatch(smallCallTask);
      scheduler.dispatch(smallCallTask);
      while (work.size() < 8) {
        Thread.sleep(100);
      }
      int seqSum=0;
      int totalTime=0;
      for (int i=0; i < work.size(); ++i) {
        LOG.debug("Request i=" + i + " value="+ work.get(i));
        seqSum+=work.get(i);
        totalTime+=seqSum;
      }
      LOG.debug("Total Time: " + totalTime);
      if (queueType.equals(RpcExecutor.CALL_QUEUE_TYPE_DEADLINE_CONF_VALUE)) {
        assertEquals(530,totalTime);
      }
 else       if (queueType.equals(RpcExecutor.CALL_QUEUE_TYPE_FIFO_CONF_VALUE)) {
        assertEquals(930,totalTime);
      }
    }
  finally {
      scheduler.stop();
    }
  }
  @Test public void testScanQueueWithZeroScanRatio() throws Exception {
    Configuration schedConf=HBaseConfiguration.create();
    schedConf.setFloat(RpcExecutor.CALL_QUEUE_HANDLER_FACTOR_CONF_KEY,1.0f);
    schedConf.setFloat(RWQueueRpcExecutor.CALL_QUEUE_READ_SHARE_CONF_KEY,0.5f);
    schedConf.setFloat(RWQueueRpcExecutor.CALL_QUEUE_SCAN_SHARE_CONF_KEY,0f);
    PriorityFunction priority=mock(PriorityFunction.class);
    when(priority.getPriority(any(),any(),any())).thenReturn(HConstants.NORMAL_QOS);
    RpcScheduler scheduler=new SimpleRpcScheduler(schedConf,2,1,1,priority,HConstants.QOS_THRESHOLD);
    assertNotEquals(null,scheduler);
  }
  @Test public void testScanQueues() throws Exception {
    Configuration schedConf=HBaseConfiguration.create();
    schedConf.setFloat(RpcExecutor.CALL_QUEUE_HANDLER_FACTOR_CONF_KEY,1.0f);
    schedConf.setFloat(RWQueueRpcExecutor.CALL_QUEUE_READ_SHARE_CONF_KEY,0.7f);
    schedConf.setFloat(RWQueueRpcExecutor.CALL_QUEUE_SCAN_SHARE_CONF_KEY,0.5f);
    PriorityFunction priority=mock(PriorityFunction.class);
    when(priority.getPriority(any(),any(),any())).thenReturn(HConstants.NORMAL_QOS);
    RpcScheduler scheduler=new SimpleRpcScheduler(schedConf,3,1,1,priority,HConstants.QOS_THRESHOLD);
    try {
      scheduler.start();
      CallRunner putCallTask=mock(CallRunner.class);
      ServerCall putCall=mock(ServerCall.class);
      putCall.param=RequestConverter.buildMutateRequest(Bytes.toBytes("abc"),new Put(Bytes.toBytes("row")));
      RequestHeader putHead=RequestHeader.newBuilder().setMethodName("mutate").build();
      when(putCallTask.getRpcCall()).thenReturn(putCall);
      when(putCall.getHeader()).thenReturn(putHead);
      when(putCall.getParam()).thenReturn(putCall.param);
      CallRunner getCallTask=mock(CallRunner.class);
      ServerCall getCall=mock(ServerCall.class);
      RequestHeader getHead=RequestHeader.newBuilder().setMethodName("get").build();
      when(getCallTask.getRpcCall()).thenReturn(getCall);
      when(getCall.getHeader()).thenReturn(getHead);
      CallRunner scanCallTask=mock(CallRunner.class);
      ServerCall scanCall=mock(ServerCall.class);
      scanCall.param=ScanRequest.newBuilder().setScannerId(1).build();
      RequestHeader scanHead=RequestHeader.newBuilder().setMethodName("scan").build();
      when(scanCallTask.getRpcCall()).thenReturn(scanCall);
      when(scanCall.getHeader()).thenReturn(scanHead);
      when(scanCall.getParam()).thenReturn(scanCall.param);
      ArrayList<Integer> work=new ArrayList<>();
      doAnswerTaskExecution(putCallTask,work,1,1000);
      doAnswerTaskExecution(getCallTask,work,2,1000);
      doAnswerTaskExecution(scanCallTask,work,3,1000);
      scheduler.dispatch(putCallTask);
      scheduler.dispatch(putCallTask);
      scheduler.dispatch(putCallTask);
      scheduler.dispatch(getCallTask);
      scheduler.dispatch(getCallTask);
      scheduler.dispatch(getCallTask);
      scheduler.dispatch(scanCallTask);
      scheduler.dispatch(scanCallTask);
      scheduler.dispatch(scanCallTask);
      while (work.size() < 6) {
        Thread.sleep(100);
      }
      for (int i=0; i < work.size() - 2; i+=3) {
        assertNotEquals(work.get(i + 0),work.get(i + 1));
        assertNotEquals(work.get(i + 0),work.get(i + 2));
        assertNotEquals(work.get(i + 1),work.get(i + 2));
      }
    }
  finally {
      scheduler.stop();
    }
  }
  private void doAnswerTaskExecution(  final CallRunner callTask,  final ArrayList<Integer> results,  final int value,  final int sleepInterval){
    callTask.setStatus(new MonitoredRPCHandlerImpl());
    doAnswer(new Answer<Object>(){
      @Override public Object answer(      InvocationOnMock invocation){
synchronized (results) {
          results.add(value);
        }
        Threads.sleepWithoutInterrupt(sleepInterval);
        return null;
      }
    }
).when(callTask).run();
  }
  private static void waitUntilQueueEmpty(  SimpleRpcScheduler scheduler) throws InterruptedException {
    while (scheduler.getGeneralQueueLength() > 0) {
      Thread.sleep(100);
    }
  }
  @Test public void testSoftAndHardQueueLimits() throws Exception {
    Configuration schedConf=HBaseConfiguration.create();
    schedConf.setInt(HConstants.REGION_SERVER_HANDLER_COUNT,0);
    schedConf.setInt("hbase.ipc.server.max.callqueue.length",5);
    schedConf.set(RpcExecutor.CALL_QUEUE_TYPE_CONF_KEY,RpcExecutor.CALL_QUEUE_TYPE_DEADLINE_CONF_VALUE);
    PriorityFunction priority=mock(PriorityFunction.class);
    when(priority.getPriority(any(),any(),any())).thenReturn(HConstants.NORMAL_QOS);
    SimpleRpcScheduler scheduler=new SimpleRpcScheduler(schedConf,0,0,0,priority,HConstants.QOS_THRESHOLD);
    try {
      scheduler.start();
      CallRunner putCallTask=mock(CallRunner.class);
      ServerCall putCall=mock(ServerCall.class);
      putCall.param=RequestConverter.buildMutateRequest(Bytes.toBytes("abc"),new Put(Bytes.toBytes("row")));
      RequestHeader putHead=RequestHeader.newBuilder().setMethodName("mutate").build();
      when(putCallTask.getRpcCall()).thenReturn(putCall);
      when(putCall.getHeader()).thenReturn(putHead);
      assertTrue(scheduler.dispatch(putCallTask));
      schedConf.setInt("hbase.ipc.server.max.callqueue.length",0);
      scheduler.onConfigurationChange(schedConf);
      assertFalse(scheduler.dispatch(putCallTask));
      waitUntilQueueEmpty(scheduler);
      schedConf.setInt("hbase.ipc.server.max.callqueue.length",1);
      scheduler.onConfigurationChange(schedConf);
      assertTrue(scheduler.dispatch(putCallTask));
    }
  finally {
      scheduler.stop();
    }
  }
private static final class CoDelEnvironmentEdge implements EnvironmentEdge {
    private final BlockingQueue<Long> timeQ=new LinkedBlockingQueue<>();
    private long offset;
    private final Set<String> threadNamePrefixs=new HashSet<>();
    @Override public long currentTime(){
      for (      String threadNamePrefix : threadNamePrefixs) {
        String threadName=Thread.currentThread().getName();
        if (threadName.startsWith(threadNamePrefix)) {
          return timeQ.poll().longValue() + offset;
        }
      }
      return System.currentTimeMillis();
    }
  }
  @Test public void testCoDelScheduling() throws Exception {
    CoDelEnvironmentEdge envEdge=new CoDelEnvironmentEdge();
    envEdge.threadNamePrefixs.add("RpcServer.default.FPBQ.Codel.handler");
    Configuration schedConf=HBaseConfiguration.create();
    schedConf.setInt(RpcScheduler.IPC_SERVER_MAX_CALLQUEUE_LENGTH,250);
    schedConf.set(RpcExecutor.CALL_QUEUE_TYPE_CONF_KEY,RpcExecutor.CALL_QUEUE_TYPE_CODEL_CONF_VALUE);
    PriorityFunction priority=mock(PriorityFunction.class);
    when(priority.getPriority(any(),any(),any())).thenReturn(HConstants.NORMAL_QOS);
    SimpleRpcScheduler scheduler=new SimpleRpcScheduler(schedConf,1,1,1,priority,HConstants.QOS_THRESHOLD);
    try {
      getMockedCallRunner(System.currentTimeMillis(),2);
      scheduler.start();
      EnvironmentEdgeManager.injectEdge(envEdge);
      envEdge.offset=5;
      for (int i=0; i < 100; i++) {
        long time=System.currentTimeMillis();
        envEdge.timeQ.put(time);
        CallRunner cr=getMockedCallRunner(time,2);
        scheduler.dispatch(cr);
      }
      waitUntilQueueEmpty(scheduler);
      Thread.sleep(100);
      assertEquals("None of these calls should have been discarded",0,scheduler.getNumGeneralCallsDropped());
      envEdge.offset=151;
      for (int i=0; i < 20; i++) {
        long time=System.currentTimeMillis();
        envEdge.timeQ.put(time);
        CallRunner cr=getMockedCallRunner(time,2);
        scheduler.dispatch(cr);
      }
      waitUntilQueueEmpty(scheduler);
      Thread.sleep(100);
      assertEquals("None of these calls should have been discarded",0,scheduler.getNumGeneralCallsDropped());
      envEdge.offset=2000;
      for (int i=0; i < 60; i++) {
        long time=System.currentTimeMillis();
        envEdge.timeQ.put(time);
        CallRunner cr=getMockedCallRunner(time,100);
        scheduler.dispatch(cr);
      }
      waitUntilQueueEmpty(scheduler);
      Thread.sleep(100);
      assertTrue("There should have been at least 12 calls dropped however there were " + scheduler.getNumGeneralCallsDropped(),scheduler.getNumGeneralCallsDropped() > 12);
    }
  finally {
      scheduler.stop();
    }
  }
  private CallRunner getMockedCallRunner(  long timestamp,  final long sleepTime) throws IOException {
    ServerCall putCall=new ServerCall(1,null,null,RPCProtos.RequestHeader.newBuilder().setMethodName("mutate").build(),RequestConverter.buildMutateRequest(Bytes.toBytes("abc"),new Put(Bytes.toBytes("row"))),null,null,9,null,timestamp,0,null,null,null){
      @Override public void sendResponseIfReady() throws IOException {
      }
    }
;
    CallRunner cr=new CallRunner(null,putCall){
      @Override public void run(){
        if (sleepTime <= 0)         return;
        try {
          LOG.warn("Sleeping for " + sleepTime);
          Thread.sleep(sleepTime);
          LOG.warn("Done Sleeping for " + sleepTime);
        }
 catch (        InterruptedException e) {
        }
      }
      @Override public RpcCall getRpcCall(){
        return putCall;
      }
      @Override public void drop(){
      }
    }
;
    return cr;
  }
}
