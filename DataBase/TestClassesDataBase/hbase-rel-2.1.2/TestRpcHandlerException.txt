@RunWith(Parameterized.class) @Category({RPCTests.class,SmallTests.class}) public class TestRpcHandlerException {
  @ClassRule public static final HBaseClassTestRule CLASS_RULE=HBaseClassTestRule.forClass(TestRpcHandlerException.class);
  private final static Configuration CONF=HBaseConfiguration.create();
  /** 
 * Tests that the rpc scheduler is called when requests arrive. When Rpc handler thread dies, the client will hang and the test will fail. The test is meant to be a unit test to test the behavior.
 */
private class AbortServer implements Abortable {
    private boolean aborted=false;
    @Override public void abort(    String why,    Throwable e){
      aborted=true;
    }
    @Override public boolean isAborted(){
      return aborted;
    }
  }
  @Parameters(name="{index}: rpcServerImpl={0}") public static Collection<Object[]> parameters(){
    return Arrays.asList(new Object[]{SimpleRpcServer.class.getName()},new Object[]{NettyRpcServer.class.getName()});
  }
  @Parameter(0) public String rpcServerImpl;
  @Ignore @Test public void testRpcScheduler() throws IOException, InterruptedException {
    PriorityFunction qosFunction=mock(PriorityFunction.class);
    Abortable abortable=new AbortServer();
    CONF.set(RpcServerFactory.CUSTOM_RPC_SERVER_IMPL_CONF_KEY,rpcServerImpl);
    RpcScheduler scheduler=new SimpleRpcScheduler(CONF,2,0,0,qosFunction,abortable,0);
    RpcServer rpcServer=RpcServerFactory.createRpcServer(null,"testRpcServer",Lists.newArrayList(new BlockingServiceAndInterface((BlockingService)SERVICE,null)),new InetSocketAddress("localhost",0),CONF,scheduler);
    try (BlockingRpcClient client=new BlockingRpcClient(CONF)){
      rpcServer.start();
      BlockingInterface stub=newBlockingStub(client,rpcServer.getListenerAddress());
      stub.echo(null,EchoRequestProto.newBuilder().setMessage("hello").build());
    }
 catch (    Throwable e) {
      assert (abortable.isAborted() == true);
    }
 finally {
      rpcServer.stop();
    }
  }
}
