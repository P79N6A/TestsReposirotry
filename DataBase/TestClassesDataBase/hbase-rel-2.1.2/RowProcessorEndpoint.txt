/** 
 * This class defines two RowProcessors: IncrementCounterProcessor and FriendsOfFriendsProcessor. We define the RowProcessors as the inner class of the endpoint. So they can be loaded with the endpoint on the coprocessor.
 */
public static class RowProcessorEndpoint<S extends Message,T extends Message> extends BaseRowProcessorEndpoint<S,T> {
public static class IncrementCounterProcessor extends BaseRowProcessor<IncrementCounterProcessorTestProtos.IncCounterProcessorRequest,IncrementCounterProcessorTestProtos.IncCounterProcessorResponse> {
    int counter=0;
    byte[] row=new byte[0];
    /** 
 * Empty constructor for Writable
 */
    IncrementCounterProcessor(){
    }
    IncrementCounterProcessor(    byte[] row){
      this.row=row;
    }
    @Override public Collection<byte[]> getRowsToLock(){
      return Collections.singleton(row);
    }
    @Override public IncCounterProcessorResponse getResult(){
      IncCounterProcessorResponse.Builder i=IncCounterProcessorResponse.newBuilder();
      i.setResponse(counter);
      return i.build();
    }
    @Override public boolean readOnly(){
      return false;
    }
    @Override public void process(    long now,    HRegion region,    List<Mutation> mutations,    WALEdit walEdit) throws IOException {
      List<Cell> kvs=new ArrayList<>();
      Scan scan=new Scan(row,row);
      scan.addColumn(FAM,COUNTER);
      doScan(region,scan,kvs);
      counter=kvs.isEmpty() ? 0 : Bytes.toInt(CellUtil.cloneValue(kvs.iterator().next()));
      assertEquals(expectedCounter,counter);
      counter+=1;
      expectedCounter+=1;
      Put p=new Put(row);
      KeyValue kv=new KeyValue(row,FAM,COUNTER,now,Bytes.toBytes(counter));
      p.add(kv);
      mutations.add(p);
      walEdit.add(kv);
      KeyValue metaKv=new KeyValue(row,WALEdit.METAFAMILY,Bytes.toBytes("I just increment counter"),Bytes.toBytes(counter));
      walEdit.add(metaKv);
    }
    @Override public IncCounterProcessorRequest getRequestData() throws IOException {
      IncCounterProcessorRequest.Builder builder=IncCounterProcessorRequest.newBuilder();
      builder.setCounter(counter);
      builder.setRow(ByteStringer.wrap(row));
      return builder.build();
    }
    @Override public void initialize(    IncCounterProcessorRequest msg){
      this.row=msg.getRow().toByteArray();
      this.counter=msg.getCounter();
    }
  }
public static class FriendsOfFriendsProcessor extends BaseRowProcessor<FriendsOfFriendsProcessorRequest,FriendsOfFriendsProcessorResponse> {
    byte[] row=null;
    byte[] person=null;
    final Set<String> result=new HashSet<>();
    /** 
 * Empty constructor for Writable
 */
    FriendsOfFriendsProcessor(){
    }
    FriendsOfFriendsProcessor(    byte[] row,    byte[] person){
      this.row=row;
      this.person=person;
    }
    @Override public Collection<byte[]> getRowsToLock(){
      return Collections.singleton(row);
    }
    @Override public FriendsOfFriendsProcessorResponse getResult(){
      FriendsOfFriendsProcessorResponse.Builder builder=FriendsOfFriendsProcessorResponse.newBuilder();
      builder.addAllResult(result);
      return builder.build();
    }
    @Override public boolean readOnly(){
      return true;
    }
    @Override public void process(    long now,    HRegion region,    List<Mutation> mutations,    WALEdit walEdit) throws IOException {
      List<Cell> kvs=new ArrayList<>();
{
        Scan scan=new Scan(row,row);
        scan.addColumn(FAM,person);
        doScan(region,scan,kvs);
      }
      Scan scan=new Scan(row,row);
      for (      Cell kv : kvs) {
        byte[] friends=CellUtil.cloneValue(kv);
        for (        byte f : friends) {
          scan.addColumn(FAM,new byte[]{f});
        }
      }
      doScan(region,scan,kvs);
      result.clear();
      for (      Cell kv : kvs) {
        for (        byte b : CellUtil.cloneValue(kv)) {
          result.add((char)b + "");
        }
      }
    }
    @Override public FriendsOfFriendsProcessorRequest getRequestData() throws IOException {
      FriendsOfFriendsProcessorRequest.Builder builder=FriendsOfFriendsProcessorRequest.newBuilder();
      builder.setPerson(ByteStringer.wrap(person));
      builder.setRow(ByteStringer.wrap(row));
      builder.addAllResult(result);
      FriendsOfFriendsProcessorRequest f=builder.build();
      return f;
    }
    @Override public void initialize(    FriendsOfFriendsProcessorRequest request) throws IOException {
      this.person=request.getPerson().toByteArray();
      this.row=request.getRow().toByteArray();
      result.clear();
      result.addAll(request.getResultList());
    }
  }
public static class RowSwapProcessor extends BaseRowProcessor<RowSwapProcessorRequest,RowSwapProcessorResponse> {
    byte[] row1=new byte[0];
    byte[] row2=new byte[0];
    /** 
 * Empty constructor for Writable
 */
    RowSwapProcessor(){
    }
    RowSwapProcessor(    byte[] row1,    byte[] row2){
      this.row1=row1;
      this.row2=row2;
    }
    @Override public Collection<byte[]> getRowsToLock(){
      List<byte[]> rows=new ArrayList<>(2);
      rows.add(row1);
      rows.add(row2);
      return rows;
    }
    @Override public boolean readOnly(){
      return false;
    }
    @Override public RowSwapProcessorResponse getResult(){
      return RowSwapProcessorResponse.getDefaultInstance();
    }
    @Override public void process(    long now,    HRegion region,    List<Mutation> mutations,    WALEdit walEdit) throws IOException {
      now=myTimer.getAndIncrement();
      List<Cell> kvs1=new ArrayList<>();
      List<Cell> kvs2=new ArrayList<>();
      doScan(region,new Scan(row1,row1),kvs1);
      doScan(region,new Scan(row2,row2),kvs2);
      if (swapped) {
        assertEquals(rowSize,kvs2.size());
        assertEquals(row2Size,kvs1.size());
      }
 else {
        assertEquals(rowSize,kvs1.size());
        assertEquals(row2Size,kvs2.size());
      }
      swapped=!swapped;
      List<List<Cell>> kvs=new ArrayList<>(2);
      kvs.add(kvs1);
      kvs.add(kvs2);
      byte[][] rows=new byte[][]{row1,row2};
      for (int i=0; i < kvs.size(); ++i) {
        for (        Cell kv : kvs.get(i)) {
          Delete d=new Delete(rows[i]);
          KeyValue kvDelete=new KeyValue(rows[i],CellUtil.cloneFamily(kv),CellUtil.cloneQualifier(kv),kv.getTimestamp(),KeyValue.Type.Delete);
          d.add(kvDelete);
          Put p=new Put(rows[1 - i]);
          KeyValue kvAdd=new KeyValue(rows[1 - i],CellUtil.cloneFamily(kv),CellUtil.cloneQualifier(kv),now,CellUtil.cloneValue(kv));
          p.add(kvAdd);
          mutations.add(d);
          walEdit.add(kvDelete);
          mutations.add(p);
          walEdit.add(kvAdd);
        }
      }
    }
    @Override public String getName(){
      return "swap";
    }
    @Override public RowSwapProcessorRequest getRequestData() throws IOException {
      RowSwapProcessorRequest.Builder builder=RowSwapProcessorRequest.newBuilder();
      builder.setRow1(ByteStringer.wrap(row1));
      builder.setRow2(ByteStringer.wrap(row2));
      return builder.build();
    }
    @Override public void initialize(    RowSwapProcessorRequest msg){
      this.row1=msg.getRow1().toByteArray();
      this.row2=msg.getRow2().toByteArray();
    }
  }
public static class TimeoutProcessor extends BaseRowProcessor<TimeoutProcessorRequest,TimeoutProcessorResponse> {
    byte[] row=new byte[0];
    /** 
 * Empty constructor for Writable
 */
    public TimeoutProcessor(){
    }
    public TimeoutProcessor(    byte[] row){
      this.row=row;
    }
    public Collection<byte[]> getRowsToLock(){
      return Collections.singleton(row);
    }
    @Override public TimeoutProcessorResponse getResult(){
      return TimeoutProcessorResponse.getDefaultInstance();
    }
    @Override public void process(    long now,    HRegion region,    List<Mutation> mutations,    WALEdit walEdit) throws IOException {
      try {
        Thread.sleep(100 * 1000L);
      }
 catch (      Exception e) {
        throw new IOException(e);
      }
    }
    @Override public boolean readOnly(){
      return true;
    }
    @Override public String getName(){
      return "timeout";
    }
    @Override public TimeoutProcessorRequest getRequestData() throws IOException {
      TimeoutProcessorRequest.Builder builder=TimeoutProcessorRequest.newBuilder();
      builder.setRow(ByteStringer.wrap(row));
      return builder.build();
    }
    @Override public void initialize(    TimeoutProcessorRequest msg) throws IOException {
      this.row=msg.getRow().toByteArray();
    }
  }
  public static void doScan(  HRegion region,  Scan scan,  List<Cell> result) throws IOException {
    InternalScanner scanner=null;
    try {
      scan.setIsolationLevel(IsolationLevel.READ_UNCOMMITTED);
      scanner=region.getScanner(scan);
      result.clear();
      scanner.next(result);
    }
  finally {
      if (scanner != null) {
        scanner.close();
      }
    }
  }
}
