public class ExecutionConfigTest extends TestLogger {
  @Test public void testDoubleTypeRegistration(){
    ExecutionConfig config=new ExecutionConfig();
    List<Class<?>> types=Arrays.<Class<?>>asList(Double.class,Integer.class,Double.class);
    List<Class<?>> expectedTypes=Arrays.<Class<?>>asList(Double.class,Integer.class);
    for (    Class<?> tpe : types) {
      config.registerKryoType(tpe);
    }
    int counter=0;
    for (    Class<?> tpe : config.getRegisteredKryoTypes()) {
      assertEquals(tpe,expectedTypes.get(counter++));
    }
    assertEquals(expectedTypes.size(),counter);
  }
  @Test public void testConfigurationOfParallelism(){
    ExecutionConfig config=new ExecutionConfig();
    int parallelism=36;
    config.setParallelism(parallelism);
    assertEquals(parallelism,config.getParallelism());
    parallelism=ExecutionConfig.PARALLELISM_DEFAULT;
    config.setParallelism(parallelism);
    assertEquals(parallelism,config.getParallelism());
  }
  @Test public void testDisableGenericTypes(){
    ExecutionConfig conf=new ExecutionConfig();
    TypeInformation<Object> typeInfo=new GenericTypeInfo<Object>(Object.class);
    TypeSerializer<Object> serializer=typeInfo.createSerializer(conf);
    assertTrue(serializer instanceof KryoSerializer);
    conf.disableGenericTypes();
    try {
      typeInfo.createSerializer(conf);
      fail("should have failed with an exception");
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  @Test public void testExecutionConfigSerialization() throws IOException, ClassNotFoundException {
    final Random r=new Random();
    final int parallelism=1 + r.nextInt(10);
    final boolean closureCleanerEnabled=r.nextBoolean(), forceAvroEnabled=r.nextBoolean(), forceKryoEnabled=r.nextBoolean(), disableGenericTypes=r.nextBoolean(), objectReuseEnabled=r.nextBoolean(), sysoutLoggingEnabled=r.nextBoolean();
    final ExecutionConfig config=new ExecutionConfig();
    if (closureCleanerEnabled) {
      config.enableClosureCleaner();
    }
 else {
      config.disableClosureCleaner();
    }
    if (forceAvroEnabled) {
      config.enableForceAvro();
    }
 else {
      config.disableForceAvro();
    }
    if (forceKryoEnabled) {
      config.enableForceKryo();
    }
 else {
      config.disableForceKryo();
    }
    if (disableGenericTypes) {
      config.disableGenericTypes();
    }
 else {
      config.enableGenericTypes();
    }
    if (objectReuseEnabled) {
      config.enableObjectReuse();
    }
 else {
      config.disableObjectReuse();
    }
    if (sysoutLoggingEnabled) {
      config.enableSysoutLogging();
    }
 else {
      config.disableSysoutLogging();
    }
    config.setParallelism(parallelism);
    final ExecutionConfig copy1=CommonTestUtils.createCopySerializable(config);
    final ExecutionConfig copy2=new SerializedValue<>(config).deserializeValue(getClass().getClassLoader());
    assertNotNull(copy1);
    assertNotNull(copy2);
    assertEquals(config,copy1);
    assertEquals(config,copy2);
    assertEquals(closureCleanerEnabled,copy1.isClosureCleanerEnabled());
    assertEquals(forceAvroEnabled,copy1.isForceAvroEnabled());
    assertEquals(forceKryoEnabled,copy1.isForceKryoEnabled());
    assertEquals(disableGenericTypes,copy1.hasGenericTypesDisabled());
    assertEquals(objectReuseEnabled,copy1.isObjectReuseEnabled());
    assertEquals(sysoutLoggingEnabled,copy1.isSysoutLoggingEnabled());
    assertEquals(parallelism,copy1.getParallelism());
  }
}
