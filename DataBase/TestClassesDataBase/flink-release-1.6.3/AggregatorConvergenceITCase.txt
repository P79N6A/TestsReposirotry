/** 
 * Connected Components test case that uses a parameterizable convergence criterion.
 */
@RunWith(Parameterized.class) @SuppressWarnings("serial") public class AggregatorConvergenceITCase extends MultipleProgramsTestBase {
  public AggregatorConvergenceITCase(  TestExecutionMode mode){
    super(mode);
  }
  final List<Tuple2<Long,Long>> verticesInput=Arrays.asList(new Tuple2<>(1L,1L),new Tuple2<>(2L,2L),new Tuple2<>(3L,3L),new Tuple2<>(4L,4L),new Tuple2<>(5L,5L),new Tuple2<>(6L,6L),new Tuple2<>(7L,7L),new Tuple2<>(8L,8L),new Tuple2<>(9L,9L));
  final List<Tuple2<Long,Long>> edgesInput=Arrays.asList(new Tuple2<>(1L,2L),new Tuple2<>(1L,3L),new Tuple2<>(2L,3L),new Tuple2<>(2L,4L),new Tuple2<>(2L,1L),new Tuple2<>(3L,1L),new Tuple2<>(3L,2L),new Tuple2<>(4L,2L),new Tuple2<>(4L,6L),new Tuple2<>(5L,6L),new Tuple2<>(6L,4L),new Tuple2<>(6L,5L),new Tuple2<>(7L,8L),new Tuple2<>(7L,9L),new Tuple2<>(8L,7L),new Tuple2<>(8L,9L),new Tuple2<>(9L,7L),new Tuple2<>(9L,8L));
  final List<Tuple2<Long,Long>> expectedResult=Arrays.asList(new Tuple2<>(1L,1L),new Tuple2<>(2L,1L),new Tuple2<>(3L,1L),new Tuple2<>(4L,1L),new Tuple2<>(5L,2L),new Tuple2<>(6L,1L),new Tuple2<>(7L,7L),new Tuple2<>(8L,7L),new Tuple2<>(9L,7L));
  @Test public void testConnectedComponentsWithParametrizableConvergence() throws Exception {
    final String updatedElements="updated.elements.aggr";
    final long convergenceThreshold=3;
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<Tuple2<Long,Long>> initialSolutionSet=env.fromCollection(verticesInput);
    DataSet<Tuple2<Long,Long>> edges=env.fromCollection(edgesInput);
    IterativeDataSet<Tuple2<Long,Long>> iteration=initialSolutionSet.iterate(10);
    iteration.registerAggregationConvergenceCriterion(updatedElements,new LongSumAggregator(),new UpdatedElementsConvergenceCriterion(convergenceThreshold));
    DataSet<Tuple2<Long,Long>> verticesWithNewComponents=iteration.join(edges).where(0).equalTo(0).with(new NeighborWithComponentIDJoin()).groupBy(0).min(1);
    DataSet<Tuple2<Long,Long>> updatedComponentId=verticesWithNewComponents.join(iteration).where(0).equalTo(0).flatMap(new MinimumIdFilter(updatedElements));
    List<Tuple2<Long,Long>> result=iteration.closeWith(updatedComponentId).collect();
    Collections.sort(result,new TestBaseUtils.TupleComparator<Tuple2<Long,Long>>());
    assertEquals(expectedResult,result);
  }
  @Test public void testDeltaConnectedComponentsWithParametrizableConvergence() throws Exception {
    final String updatedElements="updated.elements.aggr";
    final long convergenceThreshold=3;
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<Tuple2<Long,Long>> initialSolutionSet=env.fromCollection(verticesInput);
    DataSet<Tuple2<Long,Long>> edges=env.fromCollection(edgesInput);
    DeltaIteration<Tuple2<Long,Long>,Tuple2<Long,Long>> iteration=initialSolutionSet.iterateDelta(initialSolutionSet,10,0);
    iteration.registerAggregationConvergenceCriterion(updatedElements,new LongSumAggregator(),new UpdatedElementsConvergenceCriterion(convergenceThreshold));
    DataSet<Tuple2<Long,Long>> verticesWithNewComponents=iteration.getWorkset().join(edges).where(0).equalTo(0).with(new NeighborWithComponentIDJoin()).groupBy(0).min(1);
    DataSet<Tuple2<Long,Long>> updatedComponentId=verticesWithNewComponents.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new MinimumIdFilter(updatedElements));
    List<Tuple2<Long,Long>> result=iteration.closeWith(updatedComponentId,updatedComponentId).collect();
    Collections.sort(result,new TestBaseUtils.TupleComparator<Tuple2<Long,Long>>());
    assertEquals(expectedResult,result);
  }
  @Test public void testParameterizableAggregator() throws Exception {
    final int maxIterations=5;
    final String aggregatorName="elements.in.component.aggregator";
    final long componentId=1L;
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<Tuple2<Long,Long>> initialSolutionSet=env.fromCollection(verticesInput);
    DataSet<Tuple2<Long,Long>> edges=env.fromCollection(edgesInput);
    IterativeDataSet<Tuple2<Long,Long>> iteration=initialSolutionSet.iterate(maxIterations);
    iteration.registerAggregator(aggregatorName,new LongSumAggregatorWithParameter(componentId));
    DataSet<Tuple2<Long,Long>> verticesWithNewComponents=iteration.join(edges).where(0).equalTo(0).with(new NeighborWithComponentIDJoin()).groupBy(0).min(1);
    DataSet<Tuple2<Long,Long>> updatedComponentId=verticesWithNewComponents.join(iteration).where(0).equalTo(0).flatMap(new MinimumIdFilterCounting(aggregatorName));
    List<Tuple2<Long,Long>> result=iteration.closeWith(updatedComponentId).collect();
    Collections.sort(result,new TestBaseUtils.TupleComparator<Tuple2<Long,Long>>());
    List<Tuple2<Long,Long>> expectedResult=Arrays.asList(new Tuple2<>(1L,1L),new Tuple2<>(2L,1L),new Tuple2<>(3L,1L),new Tuple2<>(4L,1L),new Tuple2<>(5L,1L),new Tuple2<>(6L,1L),new Tuple2<>(7L,7L),new Tuple2<>(8L,7L),new Tuple2<>(9L,7L));
    assertEquals(expectedResult,result);
    long[] aggrValues=MinimumIdFilterCounting.aggr_value;
    assertEquals(3,aggrValues[0]);
    assertEquals(4,aggrValues[1]);
    assertEquals(5,aggrValues[2]);
    assertEquals(6,aggrValues[3]);
  }
private static final class NeighborWithComponentIDJoin extends RichJoinFunction<Tuple2<Long,Long>,Tuple2<Long,Long>,Tuple2<Long,Long>> {
    private static final long serialVersionUID=1L;
    @Override public Tuple2<Long,Long> join(    Tuple2<Long,Long> vertexWithCompId,    Tuple2<Long,Long> edge){
      vertexWithCompId.f0=edge.f1;
      return vertexWithCompId;
    }
  }
private static class MinimumIdFilter extends RichFlatMapFunction<Tuple2<Tuple2<Long,Long>,Tuple2<Long,Long>>,Tuple2<Long,Long>> {
    private final String aggName;
    private LongSumAggregator aggr;
    public MinimumIdFilter(    String aggName){
      this.aggName=aggName;
    }
    @Override public void open(    Configuration conf){
      aggr=getIterationRuntimeContext().getIterationAggregator(aggName);
    }
    @Override public void flatMap(    Tuple2<Tuple2<Long,Long>,Tuple2<Long,Long>> vertexWithNewAndOldId,    Collector<Tuple2<Long,Long>> out){
      if (vertexWithNewAndOldId.f0.f1 < vertexWithNewAndOldId.f1.f1) {
        out.collect(vertexWithNewAndOldId.f0);
        aggr.aggregate(1L);
      }
 else {
        out.collect(vertexWithNewAndOldId.f1);
      }
    }
  }
private static final class MinimumIdFilterCounting extends RichFlatMapFunction<Tuple2<Tuple2<Long,Long>,Tuple2<Long,Long>>,Tuple2<Long,Long>> {
    private static final long[] aggr_value=new long[5];
    private final String aggName;
    private LongSumAggregatorWithParameter aggr;
    public MinimumIdFilterCounting(    String aggName){
      this.aggName=aggName;
    }
    @Override public void open(    Configuration conf){
      final int superstep=getIterationRuntimeContext().getSuperstepNumber();
      aggr=getIterationRuntimeContext().getIterationAggregator(aggName);
      if (superstep > 1 && getIterationRuntimeContext().getIndexOfThisSubtask() == 0) {
        LongValue val=getIterationRuntimeContext().getPreviousIterationAggregate(aggName);
        aggr_value[superstep - 2]=val.getValue();
      }
    }
    @Override public void flatMap(    Tuple2<Tuple2<Long,Long>,Tuple2<Long,Long>> vertexWithNewAndOldId,    Collector<Tuple2<Long,Long>> out){
      if (vertexWithNewAndOldId.f0.f1 < vertexWithNewAndOldId.f1.f1) {
        out.collect(vertexWithNewAndOldId.f0);
        if (vertexWithNewAndOldId.f0.f1 == aggr.getComponentId()) {
          aggr.aggregate(1L);
        }
      }
 else {
        out.collect(vertexWithNewAndOldId.f1);
        if (vertexWithNewAndOldId.f1.f1 == aggr.getComponentId()) {
          aggr.aggregate(1L);
        }
      }
    }
  }
  /** 
 * A Convergence Criterion with one parameter.
 */
private static class UpdatedElementsConvergenceCriterion implements ConvergenceCriterion<LongValue> {
    private final long threshold;
    public UpdatedElementsConvergenceCriterion(    long uThreshold){
      this.threshold=uThreshold;
    }
    @Override public boolean isConverged(    int iteration,    LongValue value){
      return value.getValue() < this.threshold;
    }
  }
private static final class LongSumAggregatorWithParameter extends LongSumAggregator {
    private long componentId;
    public LongSumAggregatorWithParameter(    long compId){
      this.componentId=compId;
    }
    public long getComponentId(){
      return this.componentId;
    }
  }
}
