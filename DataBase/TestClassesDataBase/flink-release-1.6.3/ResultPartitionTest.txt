/** 
 * Tests for  {@link ResultPartition}.
 */
public class ResultPartitionTest {
  /** 
 * Asynchronous I/O manager. 
 */
  private static final IOManager ioManager=new IOManagerAsync();
  @AfterClass public static void shutdown(){
    ioManager.shutdown();
  }
  /** 
 * Tests the schedule or update consumers message sending behaviour depending on the relevant flags.
 */
  @Test public void testSendScheduleOrUpdateConsumersMessage() throws Exception {
{
      ResultPartitionConsumableNotifier notifier=mock(ResultPartitionConsumableNotifier.class);
      ResultPartition partition=createPartition(notifier,ResultPartitionType.PIPELINED,true);
      partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE),0);
      verify(notifier,times(1)).notifyPartitionConsumable(eq(partition.getJobId()),eq(partition.getPartitionId()),any(TaskActions.class));
    }
{
      ResultPartitionConsumableNotifier notifier=mock(ResultPartitionConsumableNotifier.class);
      ResultPartition partition=createPartition(notifier,ResultPartitionType.PIPELINED,false);
      partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE),0);
      verify(notifier,never()).notifyPartitionConsumable(any(JobID.class),any(ResultPartitionID.class),any(TaskActions.class));
    }
{
      ResultPartitionConsumableNotifier notifier=mock(ResultPartitionConsumableNotifier.class);
      ResultPartition partition=createPartition(notifier,ResultPartitionType.BLOCKING,true);
      partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE),0);
      verify(notifier,never()).notifyPartitionConsumable(any(JobID.class),any(ResultPartitionID.class),any(TaskActions.class));
    }
{
      ResultPartitionConsumableNotifier notifier=mock(ResultPartitionConsumableNotifier.class);
      ResultPartition partition=createPartition(notifier,ResultPartitionType.BLOCKING,false);
      partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE),0);
      verify(notifier,never()).notifyPartitionConsumable(any(JobID.class),any(ResultPartitionID.class),any(TaskActions.class));
    }
  }
  @Test public void testAddOnFinishedPipelinedPartition() throws Exception {
    testAddOnFinishedPartition(ResultPartitionType.PIPELINED);
  }
  @Test public void testAddOnFinishedBlockingPartition() throws Exception {
    testAddOnFinishedPartition(ResultPartitionType.BLOCKING);
  }
  /** 
 * Tests  {@link ResultPartition#addBufferConsumer} on a partition which has already finished.
 * @param pipelined the result partition type to set up
 */
  protected void testAddOnFinishedPartition(  final ResultPartitionType pipelined) throws Exception {
    BufferConsumer bufferConsumer=createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE);
    ResultPartitionConsumableNotifier notifier=mock(ResultPartitionConsumableNotifier.class);
    try {
      ResultPartition partition=createPartition(notifier,pipelined,true);
      partition.finish();
      reset(notifier);
      partition.addBufferConsumer(bufferConsumer,0);
      Assert.fail("exception expected");
    }
 catch (    IllegalStateException e) {
    }
 finally {
      if (!bufferConsumer.isRecycled()) {
        bufferConsumer.close();
        Assert.fail("bufferConsumer not recycled");
      }
      verify(notifier,never()).notifyPartitionConsumable(any(JobID.class),any(ResultPartitionID.class),any(TaskActions.class));
    }
  }
  @Test public void testAddOnReleasedPipelinedPartition() throws Exception {
    testAddOnReleasedPartition(ResultPartitionType.PIPELINED);
  }
  @Test public void testAddOnReleasedBlockingPartition() throws Exception {
    testAddOnReleasedPartition(ResultPartitionType.BLOCKING);
  }
  /** 
 * Tests  {@link ResultPartition#addBufferConsumer} on a partition which has already been released.
 * @param pipelined the result partition type to set up
 */
  protected void testAddOnReleasedPartition(  final ResultPartitionType pipelined) throws Exception {
    BufferConsumer bufferConsumer=createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE);
    ResultPartitionConsumableNotifier notifier=mock(ResultPartitionConsumableNotifier.class);
    try {
      ResultPartition partition=createPartition(notifier,pipelined,true);
      partition.release();
      partition.addBufferConsumer(bufferConsumer,0);
    }
  finally {
      if (!bufferConsumer.isRecycled()) {
        bufferConsumer.close();
        Assert.fail("bufferConsumer not recycled");
      }
      verify(notifier,never()).notifyPartitionConsumable(any(JobID.class),any(ResultPartitionID.class),any(TaskActions.class));
    }
  }
  @Test public void testAddOnPipelinedPartition() throws Exception {
    testAddOnPartition(ResultPartitionType.PIPELINED);
  }
  @Test public void testAddOnBlockingPartition() throws Exception {
    testAddOnPartition(ResultPartitionType.BLOCKING);
  }
  /** 
 * Tests  {@link ResultPartition#addBufferConsumer(BufferConsumer,int)} on a working partition.
 * @param pipelined the result partition type to set up
 */
  protected void testAddOnPartition(  final ResultPartitionType pipelined) throws Exception {
    ResultPartitionConsumableNotifier notifier=mock(ResultPartitionConsumableNotifier.class);
    ResultPartition partition=createPartition(notifier,pipelined,true);
    BufferConsumer bufferConsumer=createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE);
    try {
      partition.addBufferConsumer(bufferConsumer,0);
      assertFalse("bufferConsumer should not be recycled (still in the queue)",bufferConsumer.isRecycled());
    }
  finally {
      if (!bufferConsumer.isRecycled()) {
        bufferConsumer.close();
      }
      if (pipelined.isPipelined()) {
        verify(notifier,times(1)).notifyPartitionConsumable(eq(partition.getJobId()),eq(partition.getPartitionId()),any(TaskActions.class));
      }
    }
  }
  @Test public void testReleaseMemoryOnBlockingPartition() throws Exception {
    testReleaseMemory(ResultPartitionType.BLOCKING);
  }
  @Test public void testReleaseMemoryOnPipelinedPartition() throws Exception {
    testReleaseMemory(ResultPartitionType.PIPELINED);
  }
  /** 
 * Tests  {@link ResultPartition#releaseMemory(int)} on a working partition.
 * @param resultPartitionType the result partition type to set up
 */
  private void testReleaseMemory(  final ResultPartitionType resultPartitionType) throws Exception {
    final int numAllBuffers=10;
    final NetworkEnvironment network=new NetworkEnvironment(numAllBuffers,128,0,0,2,8,true);
    final ResultPartitionConsumableNotifier notifier=new NoOpResultPartitionConsumableNotifier();
    final ResultPartition resultPartition=createPartition(notifier,resultPartitionType,false);
    try {
      network.setupPartition(resultPartition);
      for (int i=0; i < numAllBuffers; ++i) {
        BufferBuilder bufferBuilder=resultPartition.getBufferPool().requestBufferBuilderBlocking();
        resultPartition.addBufferConsumer(bufferBuilder.createBufferConsumer(),0);
      }
      resultPartition.finish();
      assertEquals(0,resultPartition.getBufferPool().getNumberOfAvailableMemorySegments());
      final int numLocalBuffers=4;
      resultPartition.getBufferPool().setNumBuffers(numLocalBuffers);
      if (!resultPartitionType.hasBackPressure()) {
        assertEquals(numLocalBuffers,resultPartition.getBufferPool().getNumberOfAvailableMemorySegments());
      }
 else {
        assertEquals(0,resultPartition.getBufferPool().getNumberOfAvailableMemorySegments());
      }
    }
  finally {
      resultPartition.release();
      network.shutdown();
    }
  }
  private static ResultPartition createPartition(  ResultPartitionConsumableNotifier notifier,  ResultPartitionType type,  boolean sendScheduleOrUpdateConsumersMessage){
    return new ResultPartition("TestTask",mock(TaskActions.class),new JobID(),new ResultPartitionID(),type,1,1,mock(ResultPartitionManager.class),notifier,ioManager,sendScheduleOrUpdateConsumersMessage);
  }
}
