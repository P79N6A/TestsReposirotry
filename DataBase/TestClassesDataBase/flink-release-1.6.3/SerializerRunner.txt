/** 
 * Runner to test serializer duplication via concurrency.
 * @param < T > type of the test elements.
 */
static class SerializerRunner<T> extends Thread {
  final CyclicBarrier allReadyBarrier;
  final TypeSerializer<T> serializer;
  final T[] testData;
  final long durationLimitMillis;
  Exception failure;
  SerializerRunner(  CyclicBarrier allReadyBarrier,  TypeSerializer<T> serializer,  T[] testData,  long testTargetDurationMillis){
    this.allReadyBarrier=allReadyBarrier;
    this.serializer=serializer;
    this.testData=testData;
    this.durationLimitMillis=testTargetDurationMillis;
    this.failure=null;
  }
  @Override public void run(){
    DataInputDeserializer dataInputDeserializer=new DataInputDeserializer();
    DataOutputSerializer dataOutputSerializer=new DataOutputSerializer(128);
    try {
      allReadyBarrier.await();
      final long endTimeNanos=System.nanoTime() + durationLimitMillis * 1_000_000L;
      while (true) {
        for (        T testItem : testData) {
          serializer.serialize(testItem,dataOutputSerializer);
          dataInputDeserializer.setBuffer(dataOutputSerializer.getSharedBuffer(),0,dataOutputSerializer.length());
          T serdeTestItem=serializer.deserialize(dataInputDeserializer);
          T copySerdeTestItem=serializer.copy(serdeTestItem);
          dataOutputSerializer.clear();
          Preconditions.checkState(Objects.deepEquals(testItem,copySerdeTestItem),"Serialization/Deserialization cycle resulted in an object that are not equal to the original.");
          if (System.nanoTime() >= endTimeNanos) {
            return;
          }
        }
      }
    }
 catch (    Exception ex) {
      failure=ex;
    }
  }
  void checkResult() throws Exception {
    if (failure != null) {
      throw failure;
    }
  }
}
