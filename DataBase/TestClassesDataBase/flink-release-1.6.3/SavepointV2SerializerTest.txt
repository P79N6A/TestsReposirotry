/** 
 * Various tests for the version 2 format serializer of a checkpoint. 
 */
public class SavepointV2SerializerTest {
  @Test public void testCheckpointWithNoState() throws Exception {
    final Random rnd=new Random();
    for (int i=0; i < 100; ++i) {
      final long checkpointId=rnd.nextLong() & 0x7fffffffffffffffL;
      final Collection<OperatorState> taskStates=Collections.emptyList();
      final Collection<MasterState> masterStates=Collections.emptyList();
      testCheckpointSerialization(checkpointId,taskStates,masterStates);
    }
  }
  @Test public void testCheckpointWithOnlyMasterState() throws Exception {
    final Random rnd=new Random();
    final int maxNumMasterStates=5;
    for (int i=0; i < 100; ++i) {
      final long checkpointId=rnd.nextLong() & 0x7fffffffffffffffL;
      final Collection<OperatorState> operatorStates=Collections.emptyList();
      final int numMasterStates=rnd.nextInt(maxNumMasterStates) + 1;
      final Collection<MasterState> masterStates=CheckpointTestUtils.createRandomMasterStates(rnd,numMasterStates);
      testCheckpointSerialization(checkpointId,operatorStates,masterStates);
    }
  }
  @Test public void testCheckpointWithOnlyTaskState() throws Exception {
    final Random rnd=new Random();
    final int maxTaskStates=20;
    final int maxNumSubtasks=20;
    for (int i=0; i < 100; ++i) {
      final long checkpointId=rnd.nextLong() & 0x7fffffffffffffffL;
      final int numTasks=rnd.nextInt(maxTaskStates) + 1;
      final int numSubtasks=rnd.nextInt(maxNumSubtasks) + 1;
      final Collection<OperatorState> taskStates=CheckpointTestUtils.createOperatorStates(rnd,numTasks,numSubtasks);
      final Collection<MasterState> masterStates=Collections.emptyList();
      testCheckpointSerialization(checkpointId,taskStates,masterStates);
    }
  }
  @Test public void testCheckpointWithMasterAndTaskState() throws Exception {
    final Random rnd=new Random();
    final int maxNumMasterStates=5;
    final int maxTaskStates=20;
    final int maxNumSubtasks=20;
    for (int i=0; i < 100; ++i) {
      final long checkpointId=rnd.nextLong() & 0x7fffffffffffffffL;
      final int numTasks=rnd.nextInt(maxTaskStates) + 1;
      final int numSubtasks=rnd.nextInt(maxNumSubtasks) + 1;
      final Collection<OperatorState> taskStates=CheckpointTestUtils.createOperatorStates(rnd,numTasks,numSubtasks);
      final int numMasterStates=rnd.nextInt(maxNumMasterStates) + 1;
      final Collection<MasterState> masterStates=CheckpointTestUtils.createRandomMasterStates(rnd,numMasterStates);
      testCheckpointSerialization(checkpointId,taskStates,masterStates);
    }
  }
  private void testCheckpointSerialization(  long checkpointId,  Collection<OperatorState> operatorStates,  Collection<MasterState> masterStates) throws IOException {
    SavepointV2Serializer serializer=SavepointV2Serializer.INSTANCE;
    ByteArrayOutputStreamWithPos baos=new ByteArrayOutputStreamWithPos();
    DataOutputStream out=new DataOutputViewStreamWrapper(baos);
    serializer.serialize(new SavepointV2(checkpointId,operatorStates,masterStates),out);
    out.close();
    byte[] bytes=baos.toByteArray();
    DataInputStream in=new DataInputViewStreamWrapper(new ByteArrayInputStreamWithPos(bytes));
    SavepointV2 deserialized=serializer.deserialize(in,getClass().getClassLoader());
    assertEquals(checkpointId,deserialized.getCheckpointId());
    assertEquals(operatorStates,deserialized.getOperatorStates());
    assertEquals(masterStates.size(),deserialized.getMasterStates().size());
    for (Iterator<MasterState> a=masterStates.iterator(), b=deserialized.getMasterStates().iterator(); a.hasNext(); ) {
      CheckpointTestUtils.assertMasterStateEquality(a.next(),b.next());
    }
  }
}
