/** 
 * Tests cases where accumulators: a) throw errors during runtime b) are not compatible with existing accumulator.
 */
public class AccumulatorErrorITCase extends TestLogger {
  private static final String FAULTY_CLONE_ACCUMULATOR="faulty-clone";
  private static final String FAULTY_MERGE_ACCUMULATOR="faulty-merge";
  private static final String INCOMPATIBLE_ACCUMULATORS_NAME="incompatible-accumulators";
  @ClassRule public static final MiniClusterResource MINI_CLUSTER_RESOURCE=new MiniClusterResource(new MiniClusterResourceConfiguration.Builder().setNumberTaskManagers(2).setNumberSlotsPerTaskManager(3).build());
  public static Configuration getConfiguration(){
    Configuration config=new Configuration();
    config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE,"12m");
    return config;
  }
  @Test public void testFaultyAccumulator() throws Exception {
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.getConfig().disableSysoutLogging();
    env.generateSequence(0,10000).map(new FaultyAccumulatorUsingMapper()).output(new DiscardingOutputFormat<>());
    assertAccumulatorsShouldFail(env.execute());
  }
  @Test public void testInvalidTypeAccumulator() throws Exception {
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.getConfig().disableSysoutLogging();
    env.generateSequence(0,10000).map(new IncompatibleAccumulatorTypesMapper()).map(new IncompatibleAccumulatorTypesMapper2()).output(new DiscardingOutputFormat<>());
    try {
      env.execute();
      fail("Should have failed.");
    }
 catch (    JobExecutionException e) {
      assertTrue("Root cause should be:",e.getCause() instanceof Exception);
      assertTrue("Root cause should be:",e.getCause().getCause() instanceof UnsupportedOperationException);
    }
  }
  @Test public void testFaultyMergeAccumulator() throws Exception {
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.getConfig().disableSysoutLogging();
    env.generateSequence(0,10000).map(new FaultyMergeAccumulatorUsingMapper()).output(new DiscardingOutputFormat<>());
    assertAccumulatorsShouldFail(env.execute());
  }
private static class FaultyAccumulatorUsingMapper extends RichMapFunction<Long,Long> {
    private static final long serialVersionUID=42;
    @Override public void open(    Configuration parameters) throws Exception {
      getRuntimeContext().addAccumulator(FAULTY_CLONE_ACCUMULATOR,new FaultyCloneAccumulator());
    }
    @Override public Long map(    Long value) throws Exception {
      return -1L;
    }
  }
private static class FaultyCloneAccumulator extends LongCounter {
    private static final long serialVersionUID=42;
    @Override public LongCounter clone(){
      throw new CustomException();
    }
  }
private static class IncompatibleAccumulatorTypesMapper extends RichMapFunction<Long,Long> {
    private static final long serialVersionUID=42;
    @Override public void open(    Configuration parameters) throws Exception {
      getRuntimeContext().addAccumulator(INCOMPATIBLE_ACCUMULATORS_NAME,new LongCounter());
    }
    @Override public Long map(    Long value) throws Exception {
      return -1L;
    }
  }
private static class IncompatibleAccumulatorTypesMapper2 extends RichMapFunction<Long,Long> {
    private static final long serialVersionUID=42;
    @Override public void open(    Configuration parameters) throws Exception {
      getRuntimeContext().addAccumulator(INCOMPATIBLE_ACCUMULATORS_NAME,new DoubleCounter());
    }
    @Override public Long map(    Long value) throws Exception {
      return -1L;
    }
  }
  /** 
 */
private static class FaultyMergeAccumulatorUsingMapper extends RichMapFunction<Long,Long> {
    private static final long serialVersionUID=42;
    @Override public void open(    Configuration parameters) throws Exception {
      getRuntimeContext().addAccumulator(FAULTY_MERGE_ACCUMULATOR,new FaultyMergeAccumulator());
    }
    @Override public Long map(    Long value) throws Exception {
      return -1L;
    }
  }
private static class FaultyMergeAccumulator extends LongCounter {
    private static final long serialVersionUID=42;
    @Override public void merge(    Accumulator<Long,Long> other){
      throw new CustomException();
    }
    @Override public LongCounter clone(){
      return new FaultyMergeAccumulator();
    }
  }
private static class CustomException extends RuntimeException {
    private static final long serialVersionUID=42;
  }
  private static void assertAccumulatorsShouldFail(  JobExecutionResult result){
    try {
      result.getAllAccumulatorResults();
      fail("Should have failed");
    }
 catch (    Exception ex) {
      assertTrue(ExceptionUtils.findThrowable(ex,CustomException.class).isPresent());
    }
  }
}
