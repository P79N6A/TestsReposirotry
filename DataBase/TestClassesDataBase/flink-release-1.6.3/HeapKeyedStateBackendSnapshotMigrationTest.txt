/** 
 * Tests backwards compatibility in the serialization format of heap-based KeyedStateBackends.
 */
public class HeapKeyedStateBackendSnapshotMigrationTest extends HeapStateBackendTestBase {
  @Test public void testMapStateMigrationAfterHashMapSerRemoval() throws Exception {
    ClassLoader cl=getClass().getClassLoader();
    URL resource=cl.getResource("heap_keyed_statebackend_1_5_map.snapshot");
    Preconditions.checkNotNull(resource,"Binary snapshot resource not found!");
    try (final HeapKeyedStateBackend<String> keyedBackend=createKeyedBackend()){
      final Integer namespace1=1;
      final Integer namespace2=2;
      final Integer namespace3=3;
      final SnapshotResult<KeyedStateHandle> stateHandles;
      try (BufferedInputStream bis=new BufferedInputStream((new FileInputStream(resource.getFile())))){
        stateHandles=InstantiationUtil.deserializeObject(bis,Thread.currentThread().getContextClassLoader());
      }
       final MapStateDescriptor<Long,Long> stateDescr=new MapStateDescriptor<>("my-map-state",Long.class,Long.class);
      stateDescr.initializeSerializerUnlessSet(new ExecutionConfig());
      keyedBackend.restore(StateObjectCollection.singleton(stateHandles.getJobManagerOwnedSnapshot()));
      InternalMapState<String,Integer,Long,Long> state=keyedBackend.createInternalState(IntSerializer.INSTANCE,stateDescr);
      keyedBackend.setCurrentKey("abc");
      state.setCurrentNamespace(namespace1);
      assertEquals(33L,(long)state.get(33L));
      assertEquals(55L,(long)state.get(55L));
      assertEquals(2,getStateSize(state));
      state.setCurrentNamespace(namespace2);
      assertEquals(22L,(long)state.get(22L));
      assertEquals(11L,(long)state.get(11L));
      assertEquals(2,getStateSize(state));
      state.setCurrentNamespace(namespace3);
      assertEquals(44L,(long)state.get(44L));
      assertEquals(1,getStateSize(state));
      keyedBackend.setCurrentKey("def");
      state.setCurrentNamespace(namespace1);
      assertEquals(11L,(long)state.get(11L));
      assertEquals(44L,(long)state.get(44L));
      assertEquals(2,getStateSize(state));
      state.setCurrentNamespace(namespace3);
      assertEquals(22L,(long)state.get(22L));
      assertEquals(55L,(long)state.get(55L));
      assertEquals(33L,(long)state.get(33L));
      assertEquals(3,getStateSize(state));
      keyedBackend.setCurrentKey("jkl");
      state.setCurrentNamespace(namespace1);
      assertEquals(11L,(long)state.get(11L));
      assertEquals(22L,(long)state.get(22L));
      assertEquals(33L,(long)state.get(33L));
      assertEquals(44L,(long)state.get(44L));
      assertEquals(55L,(long)state.get(55L));
      assertEquals(5,getStateSize(state));
      keyedBackend.setCurrentKey("mno");
      state.setCurrentNamespace(namespace3);
      assertEquals(11L,(long)state.get(11L));
      assertEquals(22L,(long)state.get(22L));
      assertEquals(33L,(long)state.get(33L));
      assertEquals(44L,(long)state.get(44L));
      assertEquals(55L,(long)state.get(55L));
      assertEquals(5,getStateSize(state));
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=keyedBackend.snapshot(1L,1L,new MemCheckpointStreamFactory(4 * 1024 * 1024),CheckpointOptions.forCheckpointWithDefaultLocation());
      snapshot.run();
    }
   }
  private <K,N,UK,UV>int getStateSize(  InternalMapState<K,N,UK,UV> mapState) throws Exception {
    int i=0;
    for (Iterator<Map.Entry<UK,UV>> itt=mapState.iterator(); itt.hasNext(); i++, itt.next()) {
    }
    return i;
  }
  /** 
 * [FLINK-5979] <p>This test takes a snapshot that was created with Flink 1.2 and tries to restore it in master to check the backwards compatibility of the serialization format of  {@link StateTable}s.
 */
  @Test public void testRestore1_2ToMaster() throws Exception {
    ClassLoader cl=getClass().getClassLoader();
    URL resource=cl.getResource("heap_keyed_statebackend_1_2.snapshot");
    Preconditions.checkNotNull(resource,"Binary snapshot resource not found!");
    final Integer namespace1=1;
    final Integer namespace2=2;
    final Integer namespace3=3;
    try (final HeapKeyedStateBackend<String> keyedBackend=createKeyedBackend()){
      final KeyGroupsStateHandle stateHandle;
      try (BufferedInputStream bis=new BufferedInputStream((new FileInputStream(resource.getFile())))){
        stateHandle=InstantiationUtil.deserializeObject(bis,Thread.currentThread().getContextClassLoader());
      }
       keyedBackend.restore(StateObjectCollection.singleton(stateHandle));
      final ListStateDescriptor<Long> stateDescr=new ListStateDescriptor<>("my-state",Long.class);
      stateDescr.initializeSerializerUnlessSet(new ExecutionConfig());
      InternalListState<String,Integer,Long> state=keyedBackend.createInternalState(IntSerializer.INSTANCE,stateDescr);
      assertEquals(7,keyedBackend.numKeyValueStateEntries());
      keyedBackend.setCurrentKey("abc");
      state.setCurrentNamespace(namespace1);
      assertEquals(asList(33L,55L),state.get());
      state.setCurrentNamespace(namespace2);
      assertEquals(asList(22L,11L),state.get());
      state.setCurrentNamespace(namespace3);
      assertEquals(Collections.singletonList(44L),state.get());
      keyedBackend.setCurrentKey("def");
      state.setCurrentNamespace(namespace1);
      assertEquals(asList(11L,44L),state.get());
      state.setCurrentNamespace(namespace3);
      assertEquals(asList(22L,55L,33L),state.get());
      keyedBackend.setCurrentKey("jkl");
      state.setCurrentNamespace(namespace1);
      assertEquals(asList(11L,22L,33L,44L,55L),state.get());
      keyedBackend.setCurrentKey("mno");
      state.setCurrentNamespace(namespace3);
      assertEquals(asList(11L,22L,33L,44L,55L),state.get());
    }
   }
}
