/** 
 * A test that verifies that the  {@link JavaSerializer} properly handles class loading. 
 */
public class JavaSerializerTest extends SerializerTestBase<Serializable> {
  /** 
 * Class loader for the object that is not in the test class path 
 */
  private static final ClassLoader CLASS_LOADER=new URLClassLoader(new URL[0],JavaSerializerTest.class.getClassLoader());
  /** 
 * An object that is not in the test class path 
 */
  private static final Serializable OBJECT_OUT_OF_CLASSPATH=CommonTestUtils.createObjectForClassNotInClassPath(CLASS_LOADER);
  private ClassLoader originalClassLoader;
  @Before public void setupClassLoader(){
    originalClassLoader=Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(CLASS_LOADER);
  }
  @After public void restoreOriginalClassLoader(){
    Thread.currentThread().setContextClassLoader(originalClassLoader);
  }
  @Test public void guardTest(){
    try {
      Class.forName(OBJECT_OUT_OF_CLASSPATH.getClass().getName());
      fail("Test ineffective: The test class that should not be on the classpath is actually on the classpath.");
    }
 catch (    ClassNotFoundException e) {
    }
  }
  @Override protected TypeSerializer<Serializable> createSerializer(){
    Thread.currentThread().setContextClassLoader(CLASS_LOADER);
    return new JavaSerializer<>();
  }
  @Override protected int getLength(){
    return -1;
  }
  @Override protected Class<Serializable> getTypeClass(){
    return Serializable.class;
  }
  @Override protected Serializable[] getTestData(){
    return new Serializable[]{new Integer(42),new File("/some/path/that/I/made/up"),OBJECT_OUT_OF_CLASSPATH,new Tuple1<>(OBJECT_OUT_OF_CLASSPATH)};
  }
  @Override public void testInstantiate(){
  }
}
