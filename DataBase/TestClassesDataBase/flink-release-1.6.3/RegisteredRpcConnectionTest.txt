/** 
 * Tests for RegisteredRpcConnection, validating the successful, failure and close behavior.
 */
public class RegisteredRpcConnectionTest extends TestLogger {
  private TestingRpcService rpcService;
  @Before public void setup(){
    rpcService=new TestingRpcService();
  }
  @After public void tearDown() throws ExecutionException, InterruptedException {
    if (rpcService != null) {
      rpcService.stopService().get();
    }
  }
  @Test public void testSuccessfulRpcConnection() throws Exception {
    final String testRpcConnectionEndpointAddress="<TestRpcConnectionEndpointAddress>";
    final UUID leaderId=UUID.randomUUID();
    final String connectionID="Test RPC Connection ID";
    TestRegistrationGateway testGateway=new TestRegistrationGateway(new RetryingRegistrationTest.TestRegistrationSuccess(connectionID));
    try {
      rpcService.registerGateway(testRpcConnectionEndpointAddress,testGateway);
      TestRpcConnection connection=new TestRpcConnection(testRpcConnectionEndpointAddress,leaderId,rpcService.getExecutor(),rpcService);
      connection.start();
      final String actualConnectionId=connection.getConnectionFuture().get();
      assertTrue(connection.isConnected());
      assertEquals(testRpcConnectionEndpointAddress,connection.getTargetAddress());
      assertEquals(leaderId,connection.getTargetLeaderId());
      assertEquals(testGateway,connection.getTargetGateway());
      assertEquals(connectionID,actualConnectionId);
    }
  finally {
      testGateway.stop();
    }
  }
  @Test public void testRpcConnectionFailures() throws Exception {
    final String connectionFailureMessage="Test RPC Connection failure";
    final String testRpcConnectionEndpointAddress="<TestRpcConnectionEndpointAddress>";
    final UUID leaderId=UUID.randomUUID();
    TestRegistrationGateway testGateway=mock(TestRegistrationGateway.class);
    final RuntimeException registrationException=new RuntimeException(connectionFailureMessage);
    when(testGateway.registrationCall(any(UUID.class),anyLong())).thenThrow(registrationException);
    rpcService.registerGateway(testRpcConnectionEndpointAddress,testGateway);
    TestRpcConnection connection=new TestRpcConnection(testRpcConnectionEndpointAddress,leaderId,rpcService.getExecutor(),rpcService);
    connection.start();
    try {
      connection.getConnectionFuture().get();
      fail("expected failure.");
    }
 catch (    ExecutionException ee) {
      assertEquals(registrationException,ee.getCause());
    }
    assertFalse(connection.isConnected());
    assertEquals(testRpcConnectionEndpointAddress,connection.getTargetAddress());
    assertEquals(leaderId,connection.getTargetLeaderId());
    assertNull(connection.getTargetGateway());
  }
  @Test public void testRpcConnectionClose() throws Exception {
    final String testRpcConnectionEndpointAddress="<TestRpcConnectionEndpointAddress>";
    final UUID leaderId=UUID.randomUUID();
    final String connectionID="Test RPC Connection ID";
    TestRegistrationGateway testGateway=new TestRegistrationGateway(new RetryingRegistrationTest.TestRegistrationSuccess(connectionID));
    try {
      rpcService.registerGateway(testRpcConnectionEndpointAddress,testGateway);
      TestRpcConnection connection=new TestRpcConnection(testRpcConnectionEndpointAddress,leaderId,rpcService.getExecutor(),rpcService);
      connection.start();
      connection.close();
      assertEquals(testRpcConnectionEndpointAddress,connection.getTargetAddress());
      assertEquals(leaderId,connection.getTargetLeaderId());
      assertTrue(connection.isClosed());
    }
  finally {
      testGateway.stop();
    }
  }
  @Test public void testReconnect() throws Exception {
    final String connectionId1="Test RPC Connection ID 1";
    final String connectionId2="Test RPC Connection ID 2";
    final String testRpcConnectionEndpointAddress="<TestRpcConnectionEndpointAddress>";
    final UUID leaderId=UUID.randomUUID();
    final TestRegistrationGateway testGateway=new TestRegistrationGateway(new RetryingRegistrationTest.TestRegistrationSuccess(connectionId1),new RetryingRegistrationTest.TestRegistrationSuccess(connectionId2));
    rpcService.registerGateway(testRpcConnectionEndpointAddress,testGateway);
    TestRpcConnection connection=new TestRpcConnection(testRpcConnectionEndpointAddress,leaderId,rpcService.getExecutor(),rpcService);
    connection.start();
    final String actualConnectionId1=connection.getConnectionFuture().get();
    assertEquals(actualConnectionId1,connectionId1);
    assertTrue(connection.tryReconnect());
    final String actualConnectionId2=connection.getConnectionFuture().get();
    assertEquals(actualConnectionId2,connectionId2);
  }
private static class TestRpcConnection extends RegisteredRpcConnection<UUID,TestRegistrationGateway,TestRegistrationSuccess> {
    private final Object lock=new Object();
    private final RpcService rpcService;
    private CompletableFuture<String> connectionFuture;
    public TestRpcConnection(    String targetAddress,    UUID targetLeaderId,    Executor executor,    RpcService rpcService){
      super(LoggerFactory.getLogger(RegisteredRpcConnectionTest.class),targetAddress,targetLeaderId,executor);
      this.rpcService=rpcService;
      this.connectionFuture=new CompletableFuture<>();
    }
    @Override protected RetryingRegistration<UUID,TestRegistrationGateway,RetryingRegistrationTest.TestRegistrationSuccess> generateRegistration(){
      return new RetryingRegistrationTest.TestRetryingRegistration(rpcService,getTargetAddress(),getTargetLeaderId());
    }
    @Override protected void onRegistrationSuccess(    RetryingRegistrationTest.TestRegistrationSuccess success){
synchronized (lock) {
        connectionFuture.complete(success.getCorrelationId());
      }
    }
    @Override protected void onRegistrationFailure(    Throwable failure){
synchronized (lock) {
        connectionFuture.completeExceptionally(failure);
      }
    }
    @Override public boolean tryReconnect(){
synchronized (lock) {
        connectionFuture.cancel(false);
        connectionFuture=new CompletableFuture<>();
      }
      return super.tryReconnect();
    }
    public CompletableFuture<String> getConnectionFuture(){
synchronized (lock) {
        return connectionFuture;
      }
    }
  }
}
