/** 
 * Tests for the partitioned state part of  {@link RocksDBStateBackend}.
 */
@RunWith(Parameterized.class) public class RocksDBStateBackendTest extends StateBackendTestBase<RocksDBStateBackend> {
  private OneShotLatch blocker;
  private OneShotLatch waiter;
  private BlockerCheckpointStreamFactory testStreamFactory;
  private RocksDBKeyedStateBackend<Integer> keyedStateBackend;
  private List<RocksObject> allCreatedCloseables;
  private ValueState<Integer> testState1;
  private ValueState<String> testState2;
  @Parameterized.Parameters(name="Incremental checkpointing: {0}") public static Collection<Boolean> parameters(){
    return Arrays.asList(false,true);
  }
  @Parameterized.Parameter public boolean enableIncrementalCheckpointing;
  @Rule public final TemporaryFolder tempFolder=new TemporaryFolder();
  private String dbPath;
  @Override protected RocksDBStateBackend getStateBackend() throws IOException {
    dbPath=tempFolder.newFolder().getAbsolutePath();
    String checkpointPath=tempFolder.newFolder().toURI().toString();
    RocksDBStateBackend backend=new RocksDBStateBackend(new FsStateBackend(checkpointPath),enableIncrementalCheckpointing);
    Configuration configuration=new Configuration();
    configuration.setString(RocksDBOptions.TIMER_SERVICE_FACTORY,RocksDBStateBackend.PriorityQueueStateType.ROCKSDB.toString());
    backend=backend.configure(configuration);
    backend.setDbStoragePath(dbPath);
    return backend;
  }
  @Override protected boolean isSerializerPresenceRequiredOnRestore(){
    return false;
  }
  @After public void cleanupRocksDB(){
    if (keyedStateBackend != null) {
      IOUtils.closeQuietly(keyedStateBackend);
      keyedStateBackend.dispose();
    }
    if (allCreatedCloseables != null) {
      for (      RocksObject rocksCloseable : allCreatedCloseables) {
        verify(rocksCloseable,times(1)).close();
      }
      allCreatedCloseables=null;
    }
  }
  public void setupRocksKeyedStateBackend() throws Exception {
    blocker=new OneShotLatch();
    waiter=new OneShotLatch();
    testStreamFactory=new BlockerCheckpointStreamFactory(1024 * 1024);
    testStreamFactory.setBlockerLatch(blocker);
    testStreamFactory.setWaiterLatch(waiter);
    testStreamFactory.setAfterNumberInvocations(10);
    RocksDBStateBackend backend=getStateBackend();
    Environment env=new DummyEnvironment("TestTask",1,0);
    keyedStateBackend=(RocksDBKeyedStateBackend<Integer>)backend.createKeyedStateBackend(env,new JobID(),"Test",IntSerializer.INSTANCE,2,new KeyGroupRange(0,1),mock(TaskKvStateRegistry.class));
    keyedStateBackend.restore(null);
    testState1=keyedStateBackend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,new ValueStateDescriptor<>("TestState-1",Integer.class,0));
    testState2=keyedStateBackend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,new ValueStateDescriptor<>("TestState-2",String.class,""));
    allCreatedCloseables=new ArrayList<>();
    keyedStateBackend.db=spy(keyedStateBackend.db);
    doAnswer(new Answer<Object>(){
      @Override public Object answer(      InvocationOnMock invocationOnMock) throws Throwable {
        RocksIterator rocksIterator=spy((RocksIterator)invocationOnMock.callRealMethod());
        allCreatedCloseables.add(rocksIterator);
        return rocksIterator;
      }
    }
).when(keyedStateBackend.db).newIterator(any(ColumnFamilyHandle.class),any(ReadOptions.class));
    doAnswer(new Answer<Object>(){
      @Override public Object answer(      InvocationOnMock invocationOnMock) throws Throwable {
        Snapshot snapshot=spy((Snapshot)invocationOnMock.callRealMethod());
        allCreatedCloseables.add(snapshot);
        return snapshot;
      }
    }
).when(keyedStateBackend.db).getSnapshot();
    doAnswer(new Answer<Object>(){
      @Override public Object answer(      InvocationOnMock invocationOnMock) throws Throwable {
        ColumnFamilyHandle snapshot=spy((ColumnFamilyHandle)invocationOnMock.callRealMethod());
        allCreatedCloseables.add(snapshot);
        return snapshot;
      }
    }
).when(keyedStateBackend.db).createColumnFamily(any(ColumnFamilyDescriptor.class));
    for (int i=0; i < 100; ++i) {
      keyedStateBackend.setCurrentKey(i);
      testState1.update(4200 + i);
      testState2.update("S-" + (4200 + i));
    }
  }
  @Test public void testCorrectMergeOperatorSet() throws IOException {
    final ColumnFamilyOptions columnFamilyOptions=spy(new ColumnFamilyOptions());
    RocksDBKeyedStateBackend<Integer> test=null;
    try {
      test=new RocksDBKeyedStateBackend<>("test",Thread.currentThread().getContextClassLoader(),tempFolder.newFolder(),mock(DBOptions.class),columnFamilyOptions,mock(TaskKvStateRegistry.class),IntSerializer.INSTANCE,1,new KeyGroupRange(0,0),new ExecutionConfig(),enableIncrementalCheckpointing,TestLocalRecoveryConfig.disabled(),RocksDBStateBackend.PriorityQueueStateType.HEAP,TtlTimeProvider.DEFAULT);
      verify(columnFamilyOptions,Mockito.times(1)).setMergeOperatorName(RocksDBKeyedStateBackend.MERGE_OPERATOR_NAME);
    }
  finally {
      if (test != null) {
        IOUtils.closeQuietly(test);
        test.dispose();
      }
      columnFamilyOptions.close();
    }
  }
  @Test public void testReleasingSnapshotAfterBackendClosed() throws Exception {
    setupRocksKeyedStateBackend();
    try {
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=keyedStateBackend.snapshot(0L,0L,testStreamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
      RocksDB spyDB=keyedStateBackend.db;
      if (!enableIncrementalCheckpointing) {
        verify(spyDB,times(1)).getSnapshot();
        verify(spyDB,times(0)).releaseSnapshot(any(Snapshot.class));
      }
      for (      RocksObject rocksCloseable : allCreatedCloseables) {
        verify(rocksCloseable,times(0)).close();
      }
      snapshot.cancel(true);
      this.keyedStateBackend.dispose();
      verify(spyDB,times(1)).close();
      assertEquals(null,keyedStateBackend.db);
      for (      RocksObject rocksCloseable : allCreatedCloseables) {
        verify(rocksCloseable,times(1)).close();
      }
    }
  finally {
      keyedStateBackend.dispose();
      keyedStateBackend=null;
    }
  }
  @Test public void testDismissingSnapshot() throws Exception {
    setupRocksKeyedStateBackend();
    try {
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=keyedStateBackend.snapshot(0L,0L,testStreamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
      snapshot.cancel(true);
      verifyRocksObjectsReleased();
    }
  finally {
      this.keyedStateBackend.dispose();
      this.keyedStateBackend=null;
    }
  }
  @Test public void testDismissingSnapshotNotRunnable() throws Exception {
    setupRocksKeyedStateBackend();
    try {
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=keyedStateBackend.snapshot(0L,0L,testStreamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
      snapshot.cancel(true);
      Thread asyncSnapshotThread=new Thread(snapshot);
      asyncSnapshotThread.start();
      try {
        snapshot.get();
        fail();
      }
 catch (      Exception ignored) {
      }
      asyncSnapshotThread.join();
      verifyRocksObjectsReleased();
    }
  finally {
      this.keyedStateBackend.dispose();
      this.keyedStateBackend=null;
    }
  }
  @Test public void testCompletingSnapshot() throws Exception {
    setupRocksKeyedStateBackend();
    try {
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=keyedStateBackend.snapshot(0L,0L,testStreamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
      Thread asyncSnapshotThread=new Thread(snapshot);
      asyncSnapshotThread.start();
      waiter.await();
      waiter.reset();
      runStateUpdates();
      blocker.trigger();
      waiter.await();
      SnapshotResult<KeyedStateHandle> snapshotResult=snapshot.get();
      KeyedStateHandle keyedStateHandle=snapshotResult.getJobManagerOwnedSnapshot();
      assertNotNull(keyedStateHandle);
      assertTrue(keyedStateHandle.getStateSize() > 0);
      assertEquals(2,keyedStateHandle.getKeyGroupRange().getNumberOfKeyGroups());
      for (      BlockingCheckpointOutputStream stream : testStreamFactory.getAllCreatedStreams()) {
        assertTrue(stream.isClosed());
      }
      asyncSnapshotThread.join();
      verifyRocksObjectsReleased();
    }
  finally {
      this.keyedStateBackend.dispose();
      this.keyedStateBackend=null;
    }
  }
  @Test public void testCancelRunningSnapshot() throws Exception {
    setupRocksKeyedStateBackend();
    try {
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=keyedStateBackend.snapshot(0L,0L,testStreamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
      Thread asyncSnapshotThread=new Thread(snapshot);
      asyncSnapshotThread.start();
      waiter.await();
      waiter.reset();
      runStateUpdates();
      snapshot.cancel(true);
      blocker.trigger();
      for (      BlockingCheckpointOutputStream stream : testStreamFactory.getAllCreatedStreams()) {
        assertTrue(stream.isClosed());
      }
      waiter.await();
      try {
        snapshot.get();
        fail();
      }
 catch (      Exception ignored) {
      }
      asyncSnapshotThread.join();
      verifyRocksObjectsReleased();
    }
  finally {
      this.keyedStateBackend.dispose();
      this.keyedStateBackend=null;
    }
  }
  @Test public void testDisposeDeletesAllDirectories() throws Exception {
    AbstractKeyedStateBackend<Integer> backend=createKeyedBackend(IntSerializer.INSTANCE);
    Collection<File> allFilesInDbDir=FileUtils.listFilesAndDirs(new File(dbPath),new AcceptAllFilter(),new AcceptAllFilter());
    try {
      ValueStateDescriptor<String> kvId=new ValueStateDescriptor<>("id",String.class,null);
      kvId.initializeSerializerUnlessSet(new ExecutionConfig());
      ValueState<String> state=backend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,kvId);
      backend.setCurrentKey(1);
      state.update("Hello");
      assertTrue(allFilesInDbDir.size() > 1);
    }
  finally {
      IOUtils.closeQuietly(backend);
      backend.dispose();
    }
    allFilesInDbDir=FileUtils.listFilesAndDirs(new File(dbPath),new AcceptAllFilter(),new AcceptAllFilter());
    assertEquals(1,allFilesInDbDir.size());
  }
  @Test public void testSharedIncrementalStateDeRegistration() throws Exception {
    if (enableIncrementalCheckpointing) {
      AbstractKeyedStateBackend<Integer> backend=createKeyedBackend(IntSerializer.INSTANCE);
      try {
        ValueStateDescriptor<String> kvId=new ValueStateDescriptor<>("id",String.class,null);
        kvId.initializeSerializerUnlessSet(new ExecutionConfig());
        ValueState<String> state=backend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,kvId);
        Queue<IncrementalKeyedStateHandle> previousStateHandles=new LinkedList<>();
        SharedStateRegistry sharedStateRegistry=spy(new SharedStateRegistry());
        for (int checkpointId=0; checkpointId < 3; ++checkpointId) {
          reset(sharedStateRegistry);
          backend.setCurrentKey(checkpointId);
          state.update("Hello-" + checkpointId);
          RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=backend.snapshot(checkpointId,checkpointId,createStreamFactory(),CheckpointOptions.forCheckpointWithDefaultLocation());
          snapshot.run();
          SnapshotResult<KeyedStateHandle> snapshotResult=snapshot.get();
          IncrementalKeyedStateHandle stateHandle=(IncrementalKeyedStateHandle)snapshotResult.getJobManagerOwnedSnapshot();
          Map<StateHandleID,StreamStateHandle> sharedState=new HashMap<>(stateHandle.getSharedState());
          stateHandle.registerSharedStates(sharedStateRegistry);
          for (          Map.Entry<StateHandleID,StreamStateHandle> e : sharedState.entrySet()) {
            verify(sharedStateRegistry).registerReference(stateHandle.createSharedStateRegistryKeyFromFileName(e.getKey()),e.getValue());
          }
          previousStateHandles.add(stateHandle);
          backend.notifyCheckpointComplete(checkpointId);
          if (previousStateHandles.size() > 1) {
            checkRemove(previousStateHandles.remove(),sharedStateRegistry);
          }
        }
        while (!previousStateHandles.isEmpty()) {
          reset(sharedStateRegistry);
          checkRemove(previousStateHandles.remove(),sharedStateRegistry);
        }
      }
  finally {
        IOUtils.closeQuietly(backend);
        backend.dispose();
      }
    }
  }
  private void checkRemove(  IncrementalKeyedStateHandle remove,  SharedStateRegistry registry) throws Exception {
    for (    StateHandleID id : remove.getSharedState().keySet()) {
      verify(registry,times(0)).unregisterReference(remove.createSharedStateRegistryKeyFromFileName(id));
    }
    remove.discardState();
    for (    StateHandleID id : remove.getSharedState().keySet()) {
      verify(registry).unregisterReference(remove.createSharedStateRegistryKeyFromFileName(id));
    }
  }
  private void runStateUpdates() throws Exception {
    for (int i=50; i < 150; ++i) {
      if (i % 10 == 0) {
        Thread.sleep(1);
      }
      keyedStateBackend.setCurrentKey(i);
      testState1.update(4200 + i);
      testState2.update("S-" + (4200 + i));
    }
  }
  private void verifyRocksObjectsReleased(){
    for (    RocksObject rocksCloseable : allCreatedCloseables) {
      verify(rocksCloseable,times(1)).close();
    }
    assertNotNull(null,keyedStateBackend.db);
    RocksDB spyDB=keyedStateBackend.db;
    if (!enableIncrementalCheckpointing) {
      verify(spyDB,times(1)).getSnapshot();
      verify(spyDB,times(1)).releaseSnapshot(any(Snapshot.class));
    }
    keyedStateBackend.dispose();
    verify(spyDB,times(1)).close();
    assertEquals(null,keyedStateBackend.db);
  }
private static class AcceptAllFilter implements IOFileFilter {
    @Override public boolean accept(    File file){
      return true;
    }
    @Override public boolean accept(    File file,    String s){
      return true;
    }
  }
}
