/** 
 * Tests for  {@link SpillableSubpartition}.
 */
public class SpillableSubpartitionTest extends SubpartitionTestBase {
  private static final int BUFFER_DATA_SIZE=4096;
  @Rule public ExpectedException exception=ExpectedException.none();
  /** 
 * Executor service for concurrent produce/consume tests. 
 */
  private static final ExecutorService executorService=Executors.newCachedThreadPool();
  /** 
 * Asynchronous I/O manager. 
 */
  private static IOManager ioManager;
  @BeforeClass public static void setup(){
    ioManager=new IOManagerAsync();
  }
  @AfterClass public static void shutdown(){
    executorService.shutdownNow();
    ioManager.shutdown();
  }
  @Override SpillableSubpartition createSubpartition(){
    return createSubpartition(ioManager);
  }
  private static SpillableSubpartition createSubpartition(  IOManager ioManager){
    ResultPartition parent=mock(ResultPartition.class);
    BufferProvider bufferProvider=mock(BufferProvider.class);
    when(parent.getBufferProvider()).thenReturn(bufferProvider);
    when(bufferProvider.getMemorySegmentSize()).thenReturn(32 * 1024);
    return new SpillableSubpartition(0,parent,ioManager);
  }
  /** 
 * Tests a fix for FLINK-2384.
 * @see <a href="https://issues.apache.org/jira/browse/FLINK-2384">FLINK-2384</a>
 */
  @Test public void testConcurrentFinishAndReleaseMemory() throws Exception {
    final CountDownLatch doneLatch=new CountDownLatch(1);
    final CountDownLatch blockLatch=new CountDownLatch(1);
    AsynchronousBufferFileWriter spillWriter=mock(AsynchronousBufferFileWriter.class);
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        blockLatch.countDown();
        doneLatch.await();
        return null;
      }
    }
).when(spillWriter).close();
    IOManager ioManager=mock(IOManager.class);
    when(ioManager.createBufferFileWriter(any(FileIOChannel.ID.class))).thenReturn(spillWriter);
    final SpillableSubpartition partition=new SpillableSubpartition(0,mock(ResultPartition.class),ioManager);
    assertEquals(0,partition.releaseMemory());
    ExecutorService executor=Executors.newSingleThreadExecutor();
    Future<Void> blockingFinish=executor.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        partition.finish();
        return null;
      }
    }
);
    blockLatch.await();
    partition.releaseMemory();
    doneLatch.countDown();
    blockingFinish.get();
  }
  /** 
 * Tests a fix for FLINK-2412.
 * @see <a href="https://issues.apache.org/jira/browse/FLINK-2412">FLINK-2412</a>
 */
  @Test public void testReleasePartitionAndGetNext() throws Exception {
    SpillableSubpartition partition=createSubpartition();
    partition.finish();
    ResultSubpartitionView readView=spy(partition.createReadView(new NoOpBufferAvailablityListener()));
    doNothing().when(readView).releaseAllResources();
    partition.release();
    assertNull(readView.getNextBuffer());
  }
  /** 
 * Tests that a spilled partition is correctly read back in via a spilled read view.
 */
  @Test public void testConsumeSpilledPartition() throws Exception {
    SpillableSubpartition partition=createSubpartition();
    BufferConsumer bufferConsumer=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    BufferConsumer eventBufferConsumer=EventSerializer.toBufferConsumer(new CancelCheckpointMarker(1));
    final int eventSize=eventBufferConsumer.getWrittenBytes();
    partition.add(bufferConsumer.copy());
    partition.add(bufferConsumer.copy());
    partition.add(eventBufferConsumer);
    partition.add(bufferConsumer);
    assertEquals(4,partition.getTotalNumberOfBuffers());
    assertEquals(3,partition.getBuffersInBacklog());
    assertEquals(0,partition.getTotalNumberOfBytes());
    assertFalse(bufferConsumer.isRecycled());
    assertEquals(4,partition.releaseMemory());
    assertEquals(4,partition.getTotalNumberOfBuffers());
    assertEquals(3,partition.getBuffersInBacklog());
    assertEquals(BUFFER_DATA_SIZE * 3 + eventSize,partition.getTotalNumberOfBytes());
    partition.finish();
    assertEquals(5,partition.getTotalNumberOfBuffers());
    assertEquals(3,partition.getBuffersInBacklog());
    assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4,partition.getTotalNumberOfBytes());
    AwaitableBufferAvailablityListener listener=new AwaitableBufferAvailablityListener();
    SpilledSubpartitionView reader=(SpilledSubpartitionView)partition.createReadView(listener);
    assertEquals(1,listener.getNumNotifications());
    assertFalse(reader.nextBufferIsEvent());
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,2,false,true);
    assertEquals(2,partition.getBuffersInBacklog());
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,1,true,true);
    assertEquals(1,partition.getBuffersInBacklog());
    assertNextEvent(reader,eventSize,CancelCheckpointMarker.class,true,1,false,true);
    assertEquals(1,partition.getBuffersInBacklog());
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,0,true,true);
    assertEquals(0,partition.getBuffersInBacklog());
    assertNextEvent(reader,4,EndOfPartitionEvent.class,false,0,false,true);
    assertEquals(0,partition.getBuffersInBacklog());
    final long deadline=System.currentTimeMillis() + 30_000L;
    while (!bufferConsumer.isRecycled() && System.currentTimeMillis() < deadline) {
      Thread.sleep(1);
    }
    assertTrue(bufferConsumer.isRecycled());
  }
  /** 
 * Tests that a spilled partition is correctly read back in via a spilled read view. The partition went into spilled state before adding buffers and the access pattern resembles the actual use of  {@link org.apache.flink.runtime.io.network.api.writer.RecordWriter}.
 */
  @Test public void testConsumeSpilledPartitionSpilledBeforeAdd() throws Exception {
    SpillableSubpartition partition=createSubpartition();
    assertEquals(0,partition.releaseMemory());
    BufferBuilder[] bufferBuilders=new BufferBuilder[]{createBufferBuilder(BUFFER_DATA_SIZE),createBufferBuilder(BUFFER_DATA_SIZE),createBufferBuilder(BUFFER_DATA_SIZE),createBufferBuilder(BUFFER_DATA_SIZE)};
    BufferConsumer[] bufferConsumers=Arrays.stream(bufferBuilders).map(BufferBuilder::createBufferConsumer).toArray(BufferConsumer[]::new);
    BufferConsumer eventBufferConsumer=EventSerializer.toBufferConsumer(new CancelCheckpointMarker(1));
    final int eventSize=eventBufferConsumer.getWrittenBytes();
    partition.add(bufferConsumers[0]);
    fillBufferBuilder(bufferBuilders[0],BUFFER_DATA_SIZE).finish();
    partition.add(bufferConsumers[1]);
    fillBufferBuilder(bufferBuilders[1],BUFFER_DATA_SIZE).finish();
    partition.add(eventBufferConsumer);
    partition.add(bufferConsumers[2]);
    bufferBuilders[2].finish();
    partition.add(bufferConsumers[3]);
    fillBufferBuilder(bufferBuilders[3],BUFFER_DATA_SIZE / 2);
    int expectedSize=BUFFER_DATA_SIZE * 2 + eventSize;
    assertEquals(5,partition.getTotalNumberOfBuffers());
    assertEquals(3,partition.getBuffersInBacklog());
    assertEquals(expectedSize,partition.getTotalNumberOfBytes());
    partition.finish();
    expectedSize+=BUFFER_DATA_SIZE / 2;
    expectedSize+=4;
    assertEquals(6,partition.getTotalNumberOfBuffers());
    assertEquals(3,partition.getBuffersInBacklog());
    assertEquals(expectedSize,partition.getTotalNumberOfBytes());
    Arrays.stream(bufferConsumers).forEach(bufferConsumer -> assertTrue(bufferConsumer.isRecycled()));
    AwaitableBufferAvailablityListener listener=new AwaitableBufferAvailablityListener();
    SpilledSubpartitionView reader=(SpilledSubpartitionView)partition.createReadView(listener);
    assertEquals(1,listener.getNumNotifications());
    assertFalse(reader.nextBufferIsEvent());
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,2,false,true);
    assertEquals(2,partition.getBuffersInBacklog());
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,1,true,true);
    assertEquals(1,partition.getBuffersInBacklog());
    assertNextEvent(reader,eventSize,CancelCheckpointMarker.class,true,1,false,true);
    assertEquals(1,partition.getBuffersInBacklog());
    assertNextBuffer(reader,BUFFER_DATA_SIZE / 2,true,0,true,true);
    assertEquals(0,partition.getBuffersInBacklog());
    assertNextEvent(reader,4,EndOfPartitionEvent.class,false,0,false,true);
    assertEquals(0,partition.getBuffersInBacklog());
    Arrays.stream(bufferConsumers).forEach(bufferConsumer -> bufferConsumer.close());
  }
  /** 
 * Tests that a spilled partition is correctly read back in via a spilled read view.
 */
  @Test public void testConsumeSpillablePartitionSpilledDuringConsume() throws Exception {
    SpillableSubpartition partition=createSubpartition();
    BufferConsumer bufferConsumer=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    BufferConsumer eventBufferConsumer=EventSerializer.toBufferConsumer(new CancelCheckpointMarker(1));
    final int eventSize=eventBufferConsumer.getWrittenBytes();
    partition.add(bufferConsumer.copy());
    partition.add(bufferConsumer.copy());
    partition.add(eventBufferConsumer);
    partition.add(bufferConsumer);
    partition.finish();
    assertEquals(5,partition.getTotalNumberOfBuffers());
    assertEquals(3,partition.getBuffersInBacklog());
    assertEquals(0,partition.getTotalNumberOfBytes());
    AwaitableBufferAvailablityListener listener=new AwaitableBufferAvailablityListener();
    SpillableSubpartitionView reader=(SpillableSubpartitionView)partition.createReadView(listener);
    assertEquals(1,listener.getNumNotifications());
    assertFalse(bufferConsumer.isRecycled());
    assertFalse(reader.nextBufferIsEvent());
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,2,false,false);
    assertEquals(BUFFER_DATA_SIZE,partition.getTotalNumberOfBytes());
    assertEquals(2,partition.getBuffersInBacklog());
    assertEquals(1,listener.getNumNotifications());
    assertFalse(bufferConsumer.isRecycled());
    assertEquals(3,partition.releaseMemory());
    assertFalse(bufferConsumer.isRecycled());
    assertEquals(5,partition.getTotalNumberOfBuffers());
    assertEquals(2,partition.getBuffersInBacklog());
    assertEquals(BUFFER_DATA_SIZE * 2 + eventSize + 4,partition.getTotalNumberOfBytes());
    listener.awaitNotifications(2,30_000);
    assertEquals(2,listener.getNumNotifications());
    Buffer buffer=bufferConsumer.build();
    buffer.retainBuffer();
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,1,true,false);
    assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4,partition.getTotalNumberOfBytes());
    assertEquals(1,partition.getBuffersInBacklog());
    bufferConsumer.close();
    assertNextEvent(reader,eventSize,CancelCheckpointMarker.class,true,1,false,true);
    assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4,partition.getTotalNumberOfBytes());
    assertEquals(1,partition.getBuffersInBacklog());
    assertNextBuffer(reader,BUFFER_DATA_SIZE,true,0,true,true);
    assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4,partition.getTotalNumberOfBytes());
    assertEquals(0,partition.getBuffersInBacklog());
    buffer.recycleBuffer();
    assertTrue(buffer.isRecycled());
    assertNextEvent(reader,4,EndOfPartitionEvent.class,false,0,false,true);
    assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4,partition.getTotalNumberOfBytes());
    assertEquals(0,partition.getBuffersInBacklog());
    final long deadline=System.currentTimeMillis() + 30_000L;
    while (!bufferConsumer.isRecycled() && System.currentTimeMillis() < deadline) {
      Thread.sleep(1);
    }
    assertTrue(bufferConsumer.isRecycled());
  }
  /** 
 * Tests  {@link SpillableSubpartition#add(BufferConsumer)} with a spillable finished partition.
 */
  @Test public void testAddOnFinishedSpillablePartition() throws Exception {
    testAddOnFinishedPartition(false);
  }
  /** 
 * Tests  {@link SpillableSubpartition#add(BufferConsumer)} with a spilled finished partition.
 */
  @Test public void testAddOnFinishedSpilledPartition() throws Exception {
    testAddOnFinishedPartition(true);
  }
  /** 
 * Tests  {@link SpillableSubpartition#add(BufferConsumer)} with a finished partition.
 * @param spilled whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>, spillable).
 */
  private void testAddOnFinishedPartition(  boolean spilled) throws Exception {
    SpillableSubpartition partition=createSubpartition();
    if (spilled) {
      assertEquals(0,partition.releaseMemory());
    }
    partition.finish();
    assertEquals(1,partition.getTotalNumberOfBuffers());
    assertEquals(spilled ? 4 : 0,partition.getTotalNumberOfBytes());
    BufferConsumer buffer=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    try {
      partition.add(buffer);
    }
  finally {
      if (!buffer.isRecycled()) {
        buffer.close();
        Assert.fail("buffer not recycled");
      }
    }
    assertEquals(1,partition.getTotalNumberOfBuffers());
    assertEquals(spilled ? 4 : 0,partition.getTotalNumberOfBytes());
  }
  @Test public void testAddOnReleasedSpillablePartition() throws Exception {
    testAddOnReleasedPartition(false);
  }
  @Test public void testAddOnReleasedSpilledPartition() throws Exception {
    testAddOnReleasedPartition(true);
  }
  /** 
 * Tests  {@link SpillableSubpartition#add(BufferConsumer)} with a released partition.
 * @param spilled whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>, spillable).
 */
  private void testAddOnReleasedPartition(  boolean spilled) throws Exception {
    SpillableSubpartition partition=createSubpartition();
    partition.release();
    if (spilled) {
      assertEquals(0,partition.releaseMemory());
    }
    BufferConsumer buffer=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    boolean bufferRecycled;
    try {
      partition.add(buffer);
    }
  finally {
      bufferRecycled=buffer.isRecycled();
      if (!bufferRecycled) {
        buffer.close();
      }
    }
    if (!bufferRecycled) {
      Assert.fail("buffer not recycled");
    }
    assertEquals(0,partition.getTotalNumberOfBuffers());
    assertEquals(0,partition.getTotalNumberOfBytes());
  }
  /** 
 * Tests  {@link SpillableSubpartition#add(BufferConsumer)} with a spilled partition where adding thewrite request fails with an exception.
 */
  @Test public void testAddOnSpilledPartitionWithSlowWriter() throws Exception {
    IOManager ioManager=new IOManagerAsyncWithNoOpBufferFileWriter();
    SpillableSubpartition partition=createSubpartition(ioManager);
    assertEquals(0,partition.releaseMemory());
    BufferConsumer buffer=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    boolean bufferRecycled;
    try {
      partition.add(buffer);
    }
  finally {
      ioManager.shutdown();
      bufferRecycled=buffer.isRecycled();
      if (!bufferRecycled) {
        buffer.close();
      }
    }
    if (bufferRecycled) {
      Assert.fail("buffer recycled before the write operation completed");
    }
    assertEquals(1,partition.getTotalNumberOfBuffers());
    assertEquals(BUFFER_DATA_SIZE,partition.getTotalNumberOfBytes());
  }
  /** 
 * Tests  {@link SpillableSubpartition#releaseMemory()} with a spillable partition without a viewbut with a writer that does not do any write to check for correct buffer recycling.
 */
  @Test public void testReleaseOnSpillablePartitionWithoutViewWithSlowWriter() throws Exception {
    testReleaseOnSpillablePartitionWithSlowWriter(false);
  }
  /** 
 * Tests  {@link SpillableSubpartition#releaseMemory()} with a spillable partition which has aview associated with it and a writer that does not do any write to check for correct buffer recycling.
 */
  @Test public void testReleaseOnSpillablePartitionWithViewWithSlowWriter() throws Exception {
    testReleaseOnSpillablePartitionWithSlowWriter(true);
  }
  /** 
 * Tests  {@link SpillableSubpartition#releaseMemory()} with a spillable partition which has a awriter that does not do any write to check for correct buffer recycling.
 */
  private void testReleaseOnSpillablePartitionWithSlowWriter(  boolean createView) throws Exception {
    IOManager ioManager=new IOManagerAsyncWithNoOpBufferFileWriter();
    SpillableSubpartition partition=createSubpartition(ioManager);
    BufferConsumer buffer1=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    BufferConsumer buffer2=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    try {
      partition.add(buffer1);
      partition.add(buffer2);
      assertFalse("buffer1 should not be recycled (still in the queue)",buffer1.isRecycled());
      assertFalse("buffer2 should not be recycled (still in the queue)",buffer2.isRecycled());
      assertEquals(2,partition.getTotalNumberOfBuffers());
      assertEquals(0,partition.getTotalNumberOfBytes());
      if (createView) {
        partition.finish();
        partition.createReadView(new NoOpBufferAvailablityListener());
        assertEquals(0,partition.getTotalNumberOfBytes());
      }
      assertEquals(2,partition.releaseMemory());
      assertFalse("buffer1 should not be recycled (advertised as nextBuffer)",buffer1.isRecycled());
      assertFalse("buffer2 should not be recycled (not written yet)",buffer2.isRecycled());
    }
  finally {
      ioManager.shutdown();
      if (!buffer1.isRecycled()) {
        buffer1.close();
      }
      if (!buffer2.isRecycled()) {
        buffer2.close();
      }
    }
    assertEquals(2 + (createView ? 1 : 0),partition.getTotalNumberOfBuffers());
    assertEquals(BUFFER_DATA_SIZE + (createView ? 4 : BUFFER_DATA_SIZE),partition.getTotalNumberOfBytes());
  }
  /** 
 * Tests  {@link SpillableSubpartition#add(BufferConsumer)} with a spilled partition where adding thewrite request fails with an exception.
 */
  @Test public void testAddOnSpilledPartitionWithFailingWriter() throws Exception {
    IOManager ioManager=new IOManagerAsyncWithClosedBufferFileWriter();
    SpillableSubpartition partition=createSubpartition(ioManager);
    assertEquals(0,partition.releaseMemory());
    exception.expect(IOException.class);
    BufferConsumer buffer=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    boolean bufferRecycled;
    try {
      partition.add(buffer);
    }
  finally {
      ioManager.shutdown();
      bufferRecycled=buffer.isRecycled();
      if (!bufferRecycled) {
        buffer.close();
      }
    }
    if (!bufferRecycled) {
      Assert.fail("buffer not recycled");
    }
    assertEquals(0,partition.getTotalNumberOfBuffers());
    assertEquals(0,partition.getTotalNumberOfBytes());
  }
  /** 
 * Tests cleanup of  {@link SpillableSubpartition#release()} with a spillable partition and noread view attached.
 */
  @Test public void testCleanupReleasedSpillablePartitionNoView() throws Exception {
    testCleanupReleasedPartition(false,false);
  }
  /** 
 * Tests cleanup of  {@link SpillableSubpartition#release()} with a spillable partition and aread view attached - [FLINK-8371].
 */
  @Test public void testCleanupReleasedSpillablePartitionWithView() throws Exception {
    testCleanupReleasedPartition(false,true);
  }
  /** 
 * Tests cleanup of  {@link SpillableSubpartition#release()} with a spilled partition and noread view attached.
 */
  @Test public void testCleanupReleasedSpilledPartitionNoView() throws Exception {
    testCleanupReleasedPartition(true,false);
  }
  /** 
 * Tests cleanup of  {@link SpillableSubpartition#release()} with a spilled partition and aread view attached.
 */
  @Test public void testCleanupReleasedSpilledPartitionWithView() throws Exception {
    testCleanupReleasedPartition(true,true);
  }
  /** 
 * Tests cleanup of  {@link SpillableSubpartition#release()}.
 * @param spilled whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>, spillable)
 * @param createView whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)
 */
  private void testCleanupReleasedPartition(  boolean spilled,  boolean createView) throws Exception {
    SpillableSubpartition partition=createSubpartition();
    BufferConsumer buffer1=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    BufferConsumer buffer2=createFilledBufferConsumer(BUFFER_DATA_SIZE,BUFFER_DATA_SIZE);
    boolean buffer1Recycled;
    boolean buffer2Recycled;
    try {
      partition.add(buffer1);
      partition.add(buffer2);
      ResultSubpartitionView view=null;
      if (createView) {
        partition.finish();
        view=partition.createReadView(new NoOpBufferAvailablityListener());
      }
      if (spilled) {
        assertEquals(2,partition.releaseMemory());
      }
      partition.release();
      assertTrue(partition.isReleased());
      if (createView) {
        assertTrue(view.isReleased());
      }
      assertTrue(buffer1.isRecycled());
    }
  finally {
      buffer1Recycled=buffer1.isRecycled();
      if (!buffer1Recycled) {
        buffer1.close();
      }
      buffer2Recycled=buffer2.isRecycled();
      if (!buffer2Recycled) {
        buffer2.close();
      }
    }
    if (!buffer1Recycled) {
      Assert.fail("buffer 1 not recycled");
    }
    if (!buffer2Recycled) {
      Assert.fail("buffer 2 not recycled");
    }
    assertEquals(createView ? 3 : 2,partition.getTotalNumberOfBuffers());
    if (spilled) {
      assertEquals(BUFFER_DATA_SIZE + (createView ? 4 : BUFFER_DATA_SIZE),partition.getTotalNumberOfBytes());
    }
 else {
      assertEquals(0,partition.getTotalNumberOfBytes());
    }
  }
  /** 
 * Tests  {@link SpillableSubpartition#spillFinishedBufferConsumers} spilled bytes andbuffers counting.
 */
  @Test public void testSpillFinishedBufferConsumersFull() throws Exception {
    SpillableSubpartition partition=createSubpartition();
    BufferBuilder bufferBuilder=createBufferBuilder(BUFFER_DATA_SIZE);
    partition.add(bufferBuilder.createBufferConsumer());
    assertEquals(0,partition.releaseMemory());
    assertEquals(1,partition.getBuffersInBacklog());
    fillBufferBuilder(bufferBuilder,BUFFER_DATA_SIZE).finish();
    assertEquals(BUFFER_DATA_SIZE,partition.spillFinishedBufferConsumers(false));
    assertEquals(1,partition.getBuffersInBacklog());
  }
  /** 
 * Tests  {@link SpillableSubpartition#spillFinishedBufferConsumers} spilled bytes andbuffers counting with partially filled buffers.
 */
  @Test public void testSpillFinishedBufferConsumersPartial() throws Exception {
    SpillableSubpartition partition=createSubpartition();
    BufferBuilder bufferBuilder=createBufferBuilder(BUFFER_DATA_SIZE * 2);
    partition.add(bufferBuilder.createBufferConsumer());
    fillBufferBuilder(bufferBuilder,BUFFER_DATA_SIZE);
    assertEquals(0,partition.releaseMemory());
    assertEquals(2,partition.getBuffersInBacklog());
    fillBufferBuilder(bufferBuilder,BUFFER_DATA_SIZE).finish();
    assertEquals(BUFFER_DATA_SIZE,partition.spillFinishedBufferConsumers(false));
    assertEquals(2,partition.getBuffersInBacklog());
  }
  /** 
 * An  {@link IOManagerAsync} that creates closed {@link BufferFileWriter} instances in its{@link #createBufferFileWriter(FileIOChannel.ID)} method.<p>These  {@link BufferFileWriter} objects will thus throw an exception when trying to addwrite requests, e.g. by calling  {@link BufferFileWriter#writeBlock(Object)}.
 */
private static class IOManagerAsyncWithClosedBufferFileWriter extends IOManagerAsync {
    @Override public BufferFileWriter createBufferFileWriter(    FileIOChannel.ID channelID) throws IOException {
      BufferFileWriter bufferFileWriter=super.createBufferFileWriter(channelID);
      bufferFileWriter.close();
      return bufferFileWriter;
    }
  }
}
