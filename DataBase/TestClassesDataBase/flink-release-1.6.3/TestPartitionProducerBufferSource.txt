/** 
 * Returns the configured number of buffers for each channel in a random order.
 */
private static class TestPartitionProducerBufferSource implements TestProducerSource {
  private final BufferProvider bufferProvider;
  private final List<Byte> channelIndexes;
  public TestPartitionProducerBufferSource(  int parallelism,  BufferProvider bufferProvider,  int numberOfBuffersToProduce){
    this.bufferProvider=bufferProvider;
    this.channelIndexes=Lists.newArrayListWithCapacity(parallelism * numberOfBuffersToProduce);
    for (byte i=0; i < parallelism; i++) {
      for (int j=0; j < numberOfBuffersToProduce; j++) {
        channelIndexes.add(i);
      }
    }
    Collections.shuffle(channelIndexes);
  }
  @Override public BufferConsumerAndChannel getNextBufferConsumer() throws Exception {
    if (channelIndexes.size() > 0) {
      final int channelIndex=channelIndexes.remove(0);
      BufferBuilder bufferBuilder=bufferProvider.requestBufferBuilderBlocking();
      bufferBuilder.appendAndCommit(ByteBuffer.wrap(new byte[4]));
      bufferBuilder.finish();
      return new BufferConsumerAndChannel(bufferBuilder.createBufferConsumer(),channelIndex);
    }
    return null;
  }
}
