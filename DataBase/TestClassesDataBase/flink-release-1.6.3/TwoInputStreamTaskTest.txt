/** 
 * Tests for  {@link org.apache.flink.streaming.runtime.tasks.TwoInputStreamTask}. Theses tests implicitly also test the  {@link org.apache.flink.streaming.runtime.io.StreamTwoInputProcessor}. <p>Note:<br> We only use a  {@link CoStreamMap} operator here. We also test the individual operators but Map isused as a representative to test TwoInputStreamTask, since TwoInputStreamTask is used for all TwoInputStreamOperators.
 */
public class TwoInputStreamTaskTest {
  /** 
 * This test verifies that open() and close() are correctly called. This test also verifies that timestamps of emitted elements are correct.  {@link CoStreamMap} assigns the inputtimestamp to emitted elements.
 */
  @Test @SuppressWarnings("unchecked") public void testOpenCloseAndTimestamps() throws Exception {
    final TwoInputStreamTaskTestHarness<String,Integer,String> testHarness=new TwoInputStreamTaskTestHarness<>(TwoInputStreamTask::new,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.INT_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    StreamConfig streamConfig=testHarness.getStreamConfig();
    CoStreamMap<String,Integer,String> coMapOperator=new CoStreamMap<String,Integer,String>(new TestOpenCloseMapFunction());
    streamConfig.setStreamOperator(coMapOperator);
    streamConfig.setOperatorID(new OperatorID());
    long initialTime=0L;
    ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<Object>();
    testHarness.invoke();
    testHarness.waitForTaskRunning();
    testHarness.processElement(new StreamRecord<String>("Hello",initialTime + 1),0,0);
    expectedOutput.add(new StreamRecord<String>("Hello",initialTime + 1));
    testHarness.waitForInputProcessing();
    testHarness.processElement(new StreamRecord<Integer>(1337,initialTime + 2),1,0);
    expectedOutput.add(new StreamRecord<String>("1337",initialTime + 2));
    testHarness.endInput();
    testHarness.waitForTaskCompletion();
    Assert.assertTrue("RichFunction methods where not called.",TestOpenCloseMapFunction.closeCalled);
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
  }
  /** 
 * This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether watermarks are forwarded only when we have received watermarks from all inputs. The forwarded watermark must be the minimum of the watermarks of all active inputs.
 */
  @Test @SuppressWarnings("unchecked") public void testWatermarkAndStreamStatusForwarding() throws Exception {
    final TwoInputStreamTaskTestHarness<String,Integer,String> testHarness=new TwoInputStreamTaskTestHarness<String,Integer,String>(TwoInputStreamTask::new,2,2,new int[]{1,2},BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.INT_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    StreamConfig streamConfig=testHarness.getStreamConfig();
    CoStreamMap<String,Integer,String> coMapOperator=new CoStreamMap<String,Integer,String>(new IdentityMap());
    streamConfig.setStreamOperator(coMapOperator);
    streamConfig.setOperatorID(new OperatorID());
    ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<Object>();
    long initialTime=0L;
    testHarness.invoke();
    testHarness.waitForTaskRunning();
    testHarness.processElement(new Watermark(initialTime),0,0);
    testHarness.processElement(new Watermark(initialTime),0,1);
    testHarness.processElement(new Watermark(initialTime),1,0);
    testHarness.waitForInputProcessing();
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(new Watermark(initialTime),1,1);
    testHarness.waitForInputProcessing();
    expectedOutput.add(new Watermark(initialTime));
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(new StreamRecord<String>("Hello",initialTime),0,0);
    testHarness.processElement(new StreamRecord<Integer>(42,initialTime),1,1);
    expectedOutput.add(new StreamRecord<String>("Hello",initialTime));
    expectedOutput.add(new StreamRecord<String>("42",initialTime));
    testHarness.waitForInputProcessing();
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(new Watermark(initialTime + 4),0,0);
    testHarness.processElement(new Watermark(initialTime + 3),0,1);
    testHarness.processElement(new Watermark(initialTime + 3),1,0);
    testHarness.processElement(new Watermark(initialTime + 2),1,1);
    expectedOutput.add(new Watermark(initialTime + 2));
    testHarness.waitForInputProcessing();
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(new Watermark(initialTime + 4),1,1);
    testHarness.waitForInputProcessing();
    expectedOutput.add(new Watermark(initialTime + 3));
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(new Watermark(initialTime + 4),0,1);
    testHarness.processElement(new Watermark(initialTime + 4),1,0);
    testHarness.waitForInputProcessing();
    expectedOutput.add(new Watermark(initialTime + 4));
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(StreamStatus.IDLE,0,1);
    testHarness.processElement(StreamStatus.IDLE,1,0);
    testHarness.processElement(new Watermark(initialTime + 6),0,0);
    testHarness.processElement(new Watermark(initialTime + 5),1,1);
    testHarness.processElement(StreamStatus.IDLE,1,1);
    testHarness.waitForInputProcessing();
    expectedOutput.add(new Watermark(initialTime + 5));
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(StreamStatus.IDLE,0,0);
    testHarness.waitForInputProcessing();
    expectedOutput.add(StreamStatus.IDLE);
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processElement(StreamStatus.ACTIVE,1,0);
    testHarness.processElement(StreamStatus.ACTIVE,0,1);
    testHarness.waitForInputProcessing();
    expectedOutput.add(StreamStatus.ACTIVE);
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.endInput();
    testHarness.waitForTaskCompletion();
    List<String> resultElements=TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput());
    Assert.assertEquals(2,resultElements.size());
  }
  /** 
 * This test verifies that checkpoint barriers are correctly forwarded.
 */
  @Test @SuppressWarnings("unchecked") public void testCheckpointBarriers() throws Exception {
    final TwoInputStreamTaskTestHarness<String,Integer,String> testHarness=new TwoInputStreamTaskTestHarness<String,Integer,String>(TwoInputStreamTask::new,2,2,new int[]{1,2},BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.INT_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    StreamConfig streamConfig=testHarness.getStreamConfig();
    CoStreamMap<String,Integer,String> coMapOperator=new CoStreamMap<String,Integer,String>(new IdentityMap());
    streamConfig.setStreamOperator(coMapOperator);
    streamConfig.setOperatorID(new OperatorID());
    ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<Object>();
    long initialTime=0L;
    testHarness.invoke();
    testHarness.waitForTaskRunning();
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,0);
    testHarness.processElement(new StreamRecord<String>("Hello-0-0",initialTime),0,0);
    testHarness.processElement(new StreamRecord<String>("Ciao-0-0",initialTime),0,1);
    expectedOutput.add(new StreamRecord<String>("Ciao-0-0",initialTime));
    testHarness.waitForInputProcessing();
    testHarness.processElement(new StreamRecord<Integer>(11,initialTime),1,1);
    testHarness.processElement(new StreamRecord<Integer>(111,initialTime),1,1);
    expectedOutput.add(new StreamRecord<String>("11",initialTime));
    expectedOutput.add(new StreamRecord<String>("111",initialTime));
    testHarness.waitForInputProcessing();
    for (int i=0; i < 20; ++i) {
      if (testHarness.getOutput().size() >= expectedOutput.size()) {
        break;
      }
 else {
        Thread.sleep(100);
      }
    }
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,1);
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,0);
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,1);
    testHarness.waitForInputProcessing();
    testHarness.endInput();
    testHarness.waitForTaskCompletion();
    expectedOutput.add(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()));
    expectedOutput.add(new StreamRecord<String>("Hello-0-0",initialTime));
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    List<String> resultElements=TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput());
    Assert.assertEquals(4,resultElements.size());
  }
  /** 
 * This test verifies that checkpoint barriers and barrier buffers work correctly with concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e. some inputs receive barriers from an earlier checkpoint, thereby blocking, then all inputs receive barriers from a later checkpoint.
 */
  @Test @SuppressWarnings("unchecked") public void testOvertakingCheckpointBarriers() throws Exception {
    final TwoInputStreamTaskTestHarness<String,Integer,String> testHarness=new TwoInputStreamTaskTestHarness<>(TwoInputStreamTask::new,2,2,new int[]{1,2},BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.INT_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    StreamConfig streamConfig=testHarness.getStreamConfig();
    CoStreamMap<String,Integer,String> coMapOperator=new CoStreamMap<String,Integer,String>(new IdentityMap());
    streamConfig.setStreamOperator(coMapOperator);
    streamConfig.setOperatorID(new OperatorID());
    ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<Object>();
    long initialTime=0L;
    testHarness.invoke();
    testHarness.waitForTaskRunning();
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,0);
    testHarness.processElement(new StreamRecord<String>("Hello-0-0",initialTime),0,0);
    testHarness.processElement(new StreamRecord<String>("Ciao-0-0",initialTime),0,0);
    testHarness.processElement(new StreamRecord<Integer>(42,initialTime),1,1);
    testHarness.processElement(new StreamRecord<Integer>(1337,initialTime),1,1);
    expectedOutput.add(new StreamRecord<String>("42",initialTime));
    expectedOutput.add(new StreamRecord<String>("1337",initialTime));
    testHarness.waitForInputProcessing();
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),0,0);
    testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),0,1);
    testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),1,0);
    testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),1,1);
    expectedOutput.add(new CancelCheckpointMarker(0));
    expectedOutput.add(new StreamRecord<String>("Hello-0-0",initialTime));
    expectedOutput.add(new StreamRecord<String>("Ciao-0-0",initialTime));
    expectedOutput.add(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()));
    testHarness.waitForInputProcessing();
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,1);
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,0);
    testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,1);
    testHarness.waitForInputProcessing();
    testHarness.endInput();
    testHarness.waitForTaskCompletion();
    TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
  }
  @Test public void testOperatorMetricReuse() throws Exception {
    final TwoInputStreamTaskTestHarness<String,String,String> testHarness=new TwoInputStreamTaskTestHarness<>(TwoInputStreamTask::new,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOperatorChain(new OperatorID(),new DuplicatingOperator()).chain(new OperatorID(),new OneInputStreamTaskTest.DuplicatingOperator(),BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig())).chain(new OperatorID(),new OneInputStreamTaskTest.DuplicatingOperator(),BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig())).finish();
    final TaskMetricGroup taskMetricGroup=new UnregisteredMetricGroups.UnregisteredTaskMetricGroup(){
      @Override public OperatorMetricGroup addOperator(      OperatorID operatorID,      String name){
        return new OperatorMetricGroup(NoOpMetricRegistry.INSTANCE,this,operatorID,name);
      }
    }
;
    final StreamMockEnvironment env=new StreamMockEnvironment(testHarness.jobConfig,testHarness.taskConfig,testHarness.memorySize,new MockInputSplitProvider(),testHarness.bufferSize,new TestTaskStateManager()){
      @Override public TaskMetricGroup getMetricGroup(){
        return taskMetricGroup;
      }
    }
;
    final Counter numRecordsInCounter=taskMetricGroup.getIOMetricGroup().getNumRecordsInCounter();
    final Counter numRecordsOutCounter=taskMetricGroup.getIOMetricGroup().getNumRecordsOutCounter();
    testHarness.invoke(env);
    testHarness.waitForTaskRunning();
    final int numRecords1=5;
    final int numRecords2=3;
    for (int x=0; x < numRecords1; x++) {
      testHarness.processElement(new StreamRecord<>("hello"),0,0);
    }
    for (int x=0; x < numRecords2; x++) {
      testHarness.processElement(new StreamRecord<>("hello"),1,0);
    }
    testHarness.waitForInputProcessing();
    assertEquals(numRecords1 + numRecords2,numRecordsInCounter.getCount());
    assertEquals((numRecords1 + numRecords2) * 2 * 2* 2,numRecordsOutCounter.getCount());
  }
static class DuplicatingOperator extends AbstractStreamOperator<String> implements TwoInputStreamOperator<String,String,String> {
    @Override public void processElement1(    StreamRecord<String> element){
      output.collect(element);
      output.collect(element);
    }
    @Override public void processElement2(    StreamRecord<String> element){
      output.collect(element);
      output.collect(element);
    }
  }
  @Test public void testWatermarkMetrics() throws Exception {
    final TwoInputStreamTaskTestHarness<String,Integer,String> testHarness=new TwoInputStreamTaskTestHarness<>(TwoInputStreamTask::new,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.INT_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    CoStreamMap<String,Integer,String> headOperator=new CoStreamMap<>(new IdentityMap());
    final OperatorID headOperatorId=new OperatorID();
    OneInputStreamTaskTest.WatermarkMetricOperator chainedOperator=new OneInputStreamTaskTest.WatermarkMetricOperator();
    OperatorID chainedOperatorId=new OperatorID();
    testHarness.setupOperatorChain(headOperatorId,headOperator).chain(chainedOperatorId,chainedOperator,BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig())).finish();
    InterceptingOperatorMetricGroup headOperatorMetricGroup=new InterceptingOperatorMetricGroup();
    InterceptingOperatorMetricGroup chainedOperatorMetricGroup=new InterceptingOperatorMetricGroup();
    InterceptingTaskMetricGroup taskMetricGroup=new InterceptingTaskMetricGroup(){
      @Override public OperatorMetricGroup addOperator(      OperatorID id,      String name){
        if (id.equals(headOperatorId)) {
          return headOperatorMetricGroup;
        }
 else         if (id.equals(chainedOperatorId)) {
          return chainedOperatorMetricGroup;
        }
 else {
          return super.addOperator(id,name);
        }
      }
    }
;
    StreamMockEnvironment env=new StreamMockEnvironment(testHarness.jobConfig,testHarness.taskConfig,testHarness.memorySize,new MockInputSplitProvider(),testHarness.bufferSize,new TestTaskStateManager()){
      @Override public TaskMetricGroup getMetricGroup(){
        return taskMetricGroup;
      }
    }
;
    testHarness.invoke(env);
    testHarness.waitForTaskRunning();
    Gauge<Long> taskInputWatermarkGauge=(Gauge<Long>)taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);
    Gauge<Long> headInput1WatermarkGauge=(Gauge<Long>)headOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_1_WATERMARK);
    Gauge<Long> headInput2WatermarkGauge=(Gauge<Long>)headOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_2_WATERMARK);
    Gauge<Long> headInputWatermarkGauge=(Gauge<Long>)headOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);
    Gauge<Long> headOutputWatermarkGauge=(Gauge<Long>)headOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);
    Gauge<Long> chainedInputWatermarkGauge=(Gauge<Long>)chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);
    Gauge<Long> chainedOutputWatermarkGauge=(Gauge<Long>)chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);
    Assert.assertEquals("A metric was registered multiple times.",7,new HashSet<>(Arrays.asList(taskInputWatermarkGauge,headInput1WatermarkGauge,headInput2WatermarkGauge,headInputWatermarkGauge,headOutputWatermarkGauge,chainedInputWatermarkGauge,chainedOutputWatermarkGauge)).size());
    Assert.assertEquals(Long.MIN_VALUE,taskInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,headInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,headInput1WatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,headInput2WatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,headOutputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,chainedInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,chainedOutputWatermarkGauge.getValue().longValue());
    testHarness.processElement(new Watermark(1L),0,0);
    testHarness.waitForInputProcessing();
    Assert.assertEquals(Long.MIN_VALUE,taskInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,headInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(1L,headInput1WatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,headInput2WatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,headOutputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,chainedInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(Long.MIN_VALUE,chainedOutputWatermarkGauge.getValue().longValue());
    testHarness.processElement(new Watermark(2L),1,0);
    testHarness.waitForInputProcessing();
    Assert.assertEquals(1L,taskInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(1L,headInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(1L,headInput1WatermarkGauge.getValue().longValue());
    Assert.assertEquals(2L,headInput2WatermarkGauge.getValue().longValue());
    Assert.assertEquals(1L,headOutputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(1L,chainedInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(2L,chainedOutputWatermarkGauge.getValue().longValue());
    testHarness.processElement(new Watermark(3L),0,0);
    testHarness.waitForInputProcessing();
    Assert.assertEquals(2L,taskInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(2L,headInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(3L,headInput1WatermarkGauge.getValue().longValue());
    Assert.assertEquals(2L,headInput2WatermarkGauge.getValue().longValue());
    Assert.assertEquals(2L,headOutputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(2L,chainedInputWatermarkGauge.getValue().longValue());
    Assert.assertEquals(4L,chainedOutputWatermarkGauge.getValue().longValue());
    testHarness.endInput();
    testHarness.waitForTaskCompletion();
  }
private static class TestOpenCloseMapFunction extends RichCoMapFunction<String,Integer,String> {
    private static final long serialVersionUID=1L;
    public static boolean openCalled=false;
    public static boolean closeCalled=false;
    @Override public void open(    Configuration parameters) throws Exception {
      super.open(parameters);
      if (closeCalled) {
        Assert.fail("Close called before open.");
      }
      openCalled=true;
    }
    @Override public void close() throws Exception {
      super.close();
      if (!openCalled) {
        Assert.fail("Open was not called before close.");
      }
      closeCalled=true;
    }
    @Override public String map1(    String value) throws Exception {
      if (!openCalled) {
        Assert.fail("Open was not called before run.");
      }
      return value;
    }
    @Override public String map2(    Integer value) throws Exception {
      if (!openCalled) {
        Assert.fail("Open was not called before run.");
      }
      return value.toString();
    }
  }
private static class IdentityMap implements CoMapFunction<String,Integer,String> {
    private static final long serialVersionUID=1L;
    @Override public String map1(    String value) throws Exception {
      return value;
    }
    @Override public String map2(    Integer value) throws Exception {
      return value.toString();
    }
  }
}
