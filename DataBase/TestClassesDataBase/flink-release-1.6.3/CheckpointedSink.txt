private static class CheckpointedSink extends RichSinkFunction<Long> implements ListCheckpointed<Long> {
  private long stepSize;
  private long congruence;
  private long toCollect;
  private Long collected=0L;
  private long end;
  public CheckpointedSink(  long end){
    this.end=end;
  }
  @Override public void open(  Configuration parameters) throws IOException {
    stepSize=getRuntimeContext().getNumberOfParallelSubtasks();
    congruence=getRuntimeContext().getIndexOfThisSubtask();
    toCollect=(end % stepSize > congruence) ? (end / stepSize + 1) : (end / stepSize);
  }
  @Override public void invoke(  Long value) throws Exception {
    long expected=collected * stepSize + congruence;
    Assert.assertTrue("Value did not match expected value. " + expected + " != "+ value,value.equals(expected));
    collected++;
    if (collected > toCollect) {
      Assert.fail("Collected <= toCollect: " + collected + " > "+ toCollect);
    }
  }
  @Override public List<Long> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(this.collected);
  }
  @Override public void restoreState(  List<Long> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.collected=state.get(0);
  }
}
