/** 
 * Tests for the barrier buffer's maximum limit of buffered/spilled bytes.
 */
public class BarrierBufferAlignmentLimitTest {
  private static final int PAGE_SIZE=512;
  private static final Random RND=new Random();
  private static IOManager ioManager;
  @BeforeClass public static void setup(){
    ioManager=new IOManagerAsync();
  }
  @AfterClass public static void shutdownIOManager(){
    ioManager.shutdown();
  }
  /** 
 * This tests that a single alignment that buffers too much data cancels.
 */
  @Test public void testBreakCheckpointAtAlignmentLimit() throws Exception {
    BufferOrEvent[] sequence={createBuffer(1,100),createBuffer(2,70),createBuffer(0,42),createBuffer(2,111),createBarrier(7,1),createBuffer(1,100),createBuffer(2,200),createBuffer(1,300),createBuffer(0,50),createBarrier(7,0),createBuffer(2,100),createBuffer(0,100),createBuffer(1,200),createBuffer(0,200),createBuffer(0,101),createBuffer(0,100),createBuffer(1,100),createBuffer(2,100),createBarrier(7,2),createBuffer(0,100),createBuffer(1,100),createBuffer(2,100)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=new BarrierBuffer(gate,new BufferSpiller(ioManager,gate.getPageSize()),1000);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    check(sequence[0],buffer.getNextNonBlocked());
    check(sequence[1],buffer.getNextNonBlocked());
    check(sequence[2],buffer.getNextNonBlocked());
    check(sequence[3],buffer.getNextNonBlocked());
    long startTs=System.nanoTime();
    check(sequence[6],buffer.getNextNonBlocked());
    check(sequence[8],buffer.getNextNonBlocked());
    check(sequence[10],buffer.getNextNonBlocked());
    check(sequence[5],buffer.getNextNonBlocked());
    validateAlignmentTime(startTs,buffer);
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(7L),any(AlignmentLimitExceededException.class));
    check(sequence[7],buffer.getNextNonBlocked());
    check(sequence[11],buffer.getNextNonBlocked());
    check(sequence[12],buffer.getNextNonBlocked());
    check(sequence[13],buffer.getNextNonBlocked());
    check(sequence[14],buffer.getNextNonBlocked());
    check(sequence[15],buffer.getNextNonBlocked());
    check(sequence[16],buffer.getNextNonBlocked());
    check(sequence[17],buffer.getNextNonBlocked());
    check(sequence[19],buffer.getNextNonBlocked());
    check(sequence[20],buffer.getNextNonBlocked());
    check(sequence[21],buffer.getNextNonBlocked());
    verify(toNotify,times(0)).triggerCheckpointOnBarrier(any(CheckpointMetaData.class),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
    checkNoTempFilesRemain();
  }
  /** 
 * This tests the following case: - an alignment starts - barriers from a second checkpoint queue before the first completes - together they are larger than the threshold - after the first checkpoint (with second checkpoint data queued) aborts, the second completes.
 */
  @Test public void testAlignmentLimitWithQueuedAlignments() throws Exception {
    BufferOrEvent[] sequence={createBuffer(1,100),createBuffer(2,70),createBarrier(3,2),createBuffer(1,100),createBuffer(2,100),createBarrier(3,0),createBuffer(0,100),createBuffer(1,100),createBarrier(4,0),createBuffer(0,100),createBuffer(0,120),createBuffer(1,100),createBuffer(2,100),createBarrier(3,1),createBarrier(4,1),createBuffer(0,100),createBuffer(1,100),createBuffer(2,100),createBarrier(4,2),createBuffer(0,100),createBuffer(1,100),createBuffer(2,100)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=new BarrierBuffer(gate,new BufferSpiller(ioManager,gate.getPageSize()),500);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    long startTs;
    check(sequence[0],buffer.getNextNonBlocked());
    check(sequence[1],buffer.getNextNonBlocked());
    startTs=System.nanoTime();
    check(sequence[3],buffer.getNextNonBlocked());
    check(sequence[7],buffer.getNextNonBlocked());
    check(sequence[11],buffer.getNextNonBlocked());
    check(sequence[4],buffer.getNextNonBlocked());
    validateAlignmentTime(startTs,buffer);
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(3L),any(AlignmentLimitExceededException.class));
    check(sequence[6],buffer.getNextNonBlocked());
    startTs=System.nanoTime();
    check(sequence[12],buffer.getNextNonBlocked());
    check(sequence[17],buffer.getNextNonBlocked());
    check(sequence[9],buffer.getNextNonBlocked());
    validateAlignmentTime(startTs,buffer);
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(4L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    check(sequence[10],buffer.getNextNonBlocked());
    check(sequence[15],buffer.getNextNonBlocked());
    check(sequence[16],buffer.getNextNonBlocked());
    check(sequence[19],buffer.getNextNonBlocked());
    check(sequence[20],buffer.getNextNonBlocked());
    check(sequence[21],buffer.getNextNonBlocked());
    verify(toNotify,times(0)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(3L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
    checkNoTempFilesRemain();
  }
  private static BufferOrEvent createBuffer(  int channel,  int size){
    byte[] bytes=new byte[size];
    RND.nextBytes(bytes);
    MemorySegment memory=MemorySegmentFactory.allocateUnpooledSegment(PAGE_SIZE);
    memory.put(0,bytes);
    Buffer buf=new NetworkBuffer(memory,FreeingBufferRecycler.INSTANCE);
    buf.setSize(size);
    buf.retainBuffer();
    return new BufferOrEvent(buf,channel);
  }
  private static BufferOrEvent createBarrier(  long id,  int channel){
    return new BufferOrEvent(new CheckpointBarrier(id,System.currentTimeMillis(),CheckpointOptions.forCheckpointWithDefaultLocation()),channel);
  }
  private static void check(  BufferOrEvent expected,  BufferOrEvent present){
    assertNotNull(expected);
    assertNotNull(present);
    assertEquals(expected.isBuffer(),present.isBuffer());
    if (expected.isBuffer()) {
      assertEquals(expected.getBuffer().getMaxCapacity(),present.getBuffer().getMaxCapacity());
      assertEquals(expected.getBuffer().getSize(),present.getBuffer().getSize());
      MemorySegment expectedMem=expected.getBuffer().getMemorySegment();
      MemorySegment presentMem=present.getBuffer().getMemorySegment();
      assertTrue("memory contents differs",expectedMem.compare(presentMem,0,0,PAGE_SIZE) == 0);
    }
 else {
      assertEquals(expected.getEvent(),present.getEvent());
    }
  }
  private static void validateAlignmentTime(  long startTimestamp,  BarrierBuffer buffer){
    final long elapsed=System.nanoTime() - startTimestamp;
    assertTrue("wrong alignment time",buffer.getAlignmentDurationNanos() <= elapsed);
  }
  private static void checkNoTempFilesRemain(){
    for (    File dir : ioManager.getSpillingDirectories()) {
      for (      String file : dir.list()) {
        if (file != null && !(file.equals(".") || file.equals(".."))) {
          fail("barrier buffer did not clean up temp files. remaining file: " + file);
        }
      }
    }
  }
  /** 
 * A validation matcher for checkpoint metadata against checkpoint IDs.
 */
private static class CheckpointMatcher extends BaseMatcher<CheckpointMetaData> {
    private final long checkpointId;
    CheckpointMatcher(    long checkpointId){
      this.checkpointId=checkpointId;
    }
    @Override public boolean matches(    Object o){
      return o != null && o.getClass() == CheckpointMetaData.class && ((CheckpointMetaData)o).getCheckpointId() == checkpointId;
    }
    @Override public void describeTo(    Description description){
      description.appendText("CheckpointMetaData - id = " + checkpointId);
    }
  }
}
