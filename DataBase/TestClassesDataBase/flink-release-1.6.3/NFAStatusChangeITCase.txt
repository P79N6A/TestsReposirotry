/** 
 * Tests if the  {@link NFAState} status is changed after processing events.
 */
public class NFAStatusChangeITCase {
  private SharedBuffer<Event> sharedBuffer;
  @Before public void init(){
    this.sharedBuffer=TestSharedBuffer.createTestBuffer(Event.createTypeSerializer());
  }
  @Test public void testNFAChange() throws Exception {
    Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
      private static final long serialVersionUID=1858562682635302605L;
      @Override public boolean filter(      Event value) throws Exception {
        return value.getName().equals("a");
      }
    }
).followedByAny("middle").where(new IterativeCondition<Event>(){
      private static final long serialVersionUID=8061969839441121955L;
      @Override public boolean filter(      Event value,      Context<Event> ctx) throws Exception {
        return value.getName().equals("b");
      }
    }
).oneOrMore().optional().allowCombinations().followedBy("middle2").where(new IterativeCondition<Event>(){
      private static final long serialVersionUID=8061969839441121955L;
      @Override public boolean filter(      Event value,      Context<Event> ctx) throws Exception {
        return value.getName().equals("d");
      }
    }
).followedBy("end").where(new IterativeCondition<Event>(){
      private static final long serialVersionUID=8061969839441121955L;
      @Override public boolean filter(      Event value,      Context<Event> ctx) throws Exception {
        return value.getName().equals("e");
      }
    }
).within(Time.milliseconds(10));
    NFA<Event> nfa=compile(pattern,true);
    NFAState nfaState=nfa.createInitialNFAState();
    nfa.process(sharedBuffer,nfaState,new Event(1,"b",1.0),1L);
    assertFalse("NFA status should not change as the event does not match the take condition of the 'start' state",nfaState.isStateChanged());
    nfaState.resetStateChanged();
    nfa.process(sharedBuffer,nfaState,new Event(2,"a",1.0),2L);
    assertTrue("NFA status should change as the event matches the take condition of the 'start' state",nfaState.isStateChanged());
    nfaState.resetStateChanged();
    nfa.process(sharedBuffer,nfaState,new Event(3,"f",1.0),3L);
    assertTrue("NFA status should change as the event matches the ignore condition and proceed condition of the 'middle:1' state",nfaState.isStateChanged());
    nfaState.resetStateChanged();
    nfa.process(sharedBuffer,nfaState,new Event(4,"f",1.0),4L);
    assertFalse("NFA status should not change as the event only matches the ignore condition of the 'middle:2' state and the target state is still 'middle:2'",nfaState.isStateChanged());
    nfaState.resetStateChanged();
    nfa.process(sharedBuffer,nfaState,new Event(5,"b",1.0),5L);
    assertTrue("NFA status should change as the event matches the take condition of 'middle:2' state",nfaState.isStateChanged());
    nfaState.resetStateChanged();
    nfa.process(sharedBuffer,nfaState,new Event(6,"d",1.0),6L);
    assertTrue("NFA status should change as the event matches the take condition of 'middle2' state",nfaState.isStateChanged());
    nfaState.resetStateChanged();
    nfa.advanceTime(sharedBuffer,nfaState,8L);
    assertFalse("NFA status should not change as the timestamp is within the window",nfaState.isStateChanged());
    nfaState.resetStateChanged();
    Collection<Tuple2<Map<String,List<Event>>,Long>> timeoutResults=nfa.advanceTime(sharedBuffer,nfaState,12L);
    assertTrue("NFA status should change as timeout happens",nfaState.isStateChanged() && !timeoutResults.isEmpty());
  }
  @Test public void testNFAChangedOnOneNewComputationState() throws Exception {
    Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
      @Override public boolean filter(      Event value) throws Exception {
        return value.getName().equals("start");
      }
    }
).followedBy("a*").where(new SimpleCondition<Event>(){
      private static final long serialVersionUID=1858562682635302605L;
      @Override public boolean filter(      Event value) throws Exception {
        return value.getName().equals("a");
      }
    }
).oneOrMore().optional().next("end").where(new IterativeCondition<Event>(){
      private static final long serialVersionUID=8061969839441121955L;
      @Override public boolean filter(      Event value,      Context<Event> ctx) throws Exception {
        return value.getName().equals("b");
      }
    }
).within(Time.milliseconds(10));
    NFA<Event> nfa=compile(pattern,true);
    NFAState nfaState=nfa.createInitialNFAState();
    nfaState.resetStateChanged();
    nfa.process(sharedBuffer,nfaState,new Event(6,"start",1.0),6L);
    nfaState.resetStateChanged();
    nfa.process(sharedBuffer,nfaState,new Event(6,"a",1.0),7L);
    assertTrue(nfaState.isStateChanged());
  }
  @Test public void testNFAChangedOnTimeoutWithoutPrune() throws Exception {
    Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new IterativeCondition<Event>(){
      @Override public boolean filter(      Event value,      Context<Event> ctx) throws Exception {
        return value.getName().equals("start");
      }
    }
).followedBy("end").where(new IterativeCondition<Event>(){
      private static final long serialVersionUID=8061969839441121955L;
      @Override public boolean filter(      Event value,      Context<Event> ctx) throws Exception {
        return value.getName().equals("end");
      }
    }
).within(Time.milliseconds(10));
    NFA<Event> nfa=compile(pattern,true);
    NFAState nfaState=nfa.createInitialNFAState();
    nfaState.resetStateChanged();
    nfa.advanceTime(sharedBuffer,nfaState,6L);
    nfa.process(sharedBuffer,nfaState,new Event(6,"start",1.0),6L);
    nfaState.resetStateChanged();
    nfa.advanceTime(sharedBuffer,nfaState,17L);
    assertTrue(nfaState.isStateChanged());
  }
}
