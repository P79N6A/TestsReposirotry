/** 
 * Tests for the  {@link Execution}.
 */
public class ExecutionTest extends TestLogger {
  /** 
 * Tests that slots are released if we cannot assign the allocated resource to the Execution.
 */
  @Test public void testSlotReleaseOnFailedResourceAssignment() throws Exception {
    final JobVertex jobVertex=createNoOpJobVertex();
    final JobVertexID jobVertexId=jobVertex.getID();
    final CompletableFuture<LogicalSlot> slotFuture=new CompletableFuture<>();
    final ProgrammedSlotProvider slotProvider=new ProgrammedSlotProvider(1);
    slotProvider.addSlot(jobVertexId,0,slotFuture);
    ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
    ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
    final Execution execution=executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt();
    final SingleSlotTestingSlotOwner slotOwner=new SingleSlotTestingSlotOwner();
    final SimpleSlot slot=new SimpleSlot(slotOwner,new LocalTaskManagerLocation(),0,new SimpleAckingTaskManagerGateway());
    final LogicalSlot otherSlot=new TestingLogicalSlot();
    CompletableFuture<Execution> allocationFuture=execution.allocateAndAssignSlotForExecution(slotProvider,false,LocationPreferenceConstraint.ALL,Collections.emptySet(),TestingUtils.infiniteTime());
    assertFalse(allocationFuture.isDone());
    assertEquals(ExecutionState.SCHEDULED,execution.getState());
    assertTrue(execution.tryAssignResource(otherSlot));
    slotFuture.complete(slot);
    assertEquals(slot,slotOwner.getReturnedSlotFuture().get());
  }
  /** 
 * Tests that the slot is released in case of a execution cancellation when having a slot assigned and being in state SCHEDULED.
 */
  @Test public void testSlotReleaseOnExecutionCancellationInScheduled() throws Exception {
    final JobVertex jobVertex=createNoOpJobVertex();
    final JobVertexID jobVertexId=jobVertex.getID();
    final SingleSlotTestingSlotOwner slotOwner=new SingleSlotTestingSlotOwner();
    final SimpleSlot slot=new SimpleSlot(slotOwner,new LocalTaskManagerLocation(),0,new SimpleAckingTaskManagerGateway());
    final ProgrammedSlotProvider slotProvider=new ProgrammedSlotProvider(1);
    slotProvider.addSlot(jobVertexId,0,CompletableFuture.completedFuture(slot));
    ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
    ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
    final Execution execution=executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt();
    CompletableFuture<Execution> allocationFuture=execution.allocateAndAssignSlotForExecution(slotProvider,false,LocationPreferenceConstraint.ALL,Collections.emptySet(),TestingUtils.infiniteTime());
    assertTrue(allocationFuture.isDone());
    assertEquals(ExecutionState.SCHEDULED,execution.getState());
    assertEquals(slot,execution.getAssignedResource());
    execution.cancel();
    assertEquals(ExecutionState.CANCELED,execution.getState());
    assertEquals(slot,slotOwner.getReturnedSlotFuture().get());
  }
  /** 
 * Tests that the slot is released in case of a execution cancellation when being in state RUNNING.
 */
  @Test public void testSlotReleaseOnExecutionCancellationInRunning() throws Exception {
    final JobVertex jobVertex=createNoOpJobVertex();
    final JobVertexID jobVertexId=jobVertex.getID();
    final SingleSlotTestingSlotOwner slotOwner=new SingleSlotTestingSlotOwner();
    final SimpleSlot slot=new SimpleSlot(slotOwner,new LocalTaskManagerLocation(),0,new SimpleAckingTaskManagerGateway());
    final ProgrammedSlotProvider slotProvider=new ProgrammedSlotProvider(1);
    slotProvider.addSlot(jobVertexId,0,CompletableFuture.completedFuture(slot));
    ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
    ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
    final Execution execution=executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt();
    CompletableFuture<Execution> allocationFuture=execution.allocateAndAssignSlotForExecution(slotProvider,false,LocationPreferenceConstraint.ALL,Collections.emptySet(),TestingUtils.infiniteTime());
    assertTrue(allocationFuture.isDone());
    assertEquals(ExecutionState.SCHEDULED,execution.getState());
    assertEquals(slot,execution.getAssignedResource());
    execution.deploy();
    execution.switchToRunning();
    execution.cancel();
    assertEquals(ExecutionState.CANCELING,execution.getState());
    execution.cancelingComplete();
    assertEquals(slot,slotOwner.getReturnedSlotFuture().get());
  }
  /** 
 * Tests that a slot allocation from a  {@link SlotProvider} is cancelled if the{@link Execution} is cancelled.
 */
  @Test public void testSlotAllocationCancellationWhenExecutionCancelled() throws Exception {
    final JobVertexID jobVertexId=new JobVertexID();
    final JobVertex jobVertex=new JobVertex("test vertex",jobVertexId);
    jobVertex.setInvokableClass(NoOpInvokable.class);
    final ProgrammedSlotProvider slotProvider=new ProgrammedSlotProvider(1);
    final CompletableFuture<LogicalSlot> slotFuture=new CompletableFuture<>();
    slotProvider.addSlot(jobVertexId,0,slotFuture);
    final ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
    final ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
    final Execution currentExecutionAttempt=executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt();
    final CompletableFuture<Execution> allocationFuture=currentExecutionAttempt.allocateAndAssignSlotForExecution(slotProvider,false,LocationPreferenceConstraint.ALL,Collections.emptySet(),TestingUtils.infiniteTime());
    assertThat(allocationFuture.isDone(),is(false));
    assertThat(slotProvider.getSlotRequestedFuture(jobVertexId,0).get(),is(true));
    final Set<SlotRequestId> slotRequests=slotProvider.getSlotRequests();
    assertThat(slotRequests,hasSize(1));
    assertThat(currentExecutionAttempt.getState(),is(ExecutionState.SCHEDULED));
    currentExecutionAttempt.cancel();
    assertThat(currentExecutionAttempt.getState(),is(ExecutionState.CANCELED));
    assertThat(allocationFuture.isCompletedExceptionally(),is(true));
    final Set<SlotRequestId> canceledSlotRequests=slotProvider.getCanceledSlotRequests();
    assertThat(canceledSlotRequests,equalTo(slotRequests));
  }
  /** 
 * Tests that all preferred locations are calculated.
 */
  @Test public void testAllPreferredLocationCalculation() throws ExecutionException, InterruptedException {
    final TaskManagerLocation taskManagerLocation1=new LocalTaskManagerLocation();
    final TaskManagerLocation taskManagerLocation2=new LocalTaskManagerLocation();
    final TaskManagerLocation taskManagerLocation3=new LocalTaskManagerLocation();
    final CompletableFuture<TaskManagerLocation> locationFuture1=CompletableFuture.completedFuture(taskManagerLocation1);
    final CompletableFuture<TaskManagerLocation> locationFuture2=new CompletableFuture<>();
    final CompletableFuture<TaskManagerLocation> locationFuture3=new CompletableFuture<>();
    final Execution execution=SchedulerTestUtils.getTestVertex(Arrays.asList(locationFuture1,locationFuture2,locationFuture3));
    CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture=execution.calculatePreferredLocations(LocationPreferenceConstraint.ALL);
    assertFalse(preferredLocationsFuture.isDone());
    locationFuture3.complete(taskManagerLocation3);
    assertFalse(preferredLocationsFuture.isDone());
    locationFuture2.complete(taskManagerLocation2);
    assertTrue(preferredLocationsFuture.isDone());
    final Collection<TaskManagerLocation> preferredLocations=preferredLocationsFuture.get();
    assertThat(preferredLocations,containsInAnyOrder(taskManagerLocation1,taskManagerLocation2,taskManagerLocation3));
  }
  /** 
 * Tests that any preferred locations are calculated.
 */
  @Test public void testAnyPreferredLocationCalculation() throws ExecutionException, InterruptedException {
    final TaskManagerLocation taskManagerLocation1=new LocalTaskManagerLocation();
    final TaskManagerLocation taskManagerLocation3=new LocalTaskManagerLocation();
    final CompletableFuture<TaskManagerLocation> locationFuture1=CompletableFuture.completedFuture(taskManagerLocation1);
    final CompletableFuture<TaskManagerLocation> locationFuture2=new CompletableFuture<>();
    final CompletableFuture<TaskManagerLocation> locationFuture3=CompletableFuture.completedFuture(taskManagerLocation3);
    final Execution execution=SchedulerTestUtils.getTestVertex(Arrays.asList(locationFuture1,locationFuture2,locationFuture3));
    CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture=execution.calculatePreferredLocations(LocationPreferenceConstraint.ANY);
    assertTrue(preferredLocationsFuture.isDone());
    final Collection<TaskManagerLocation> preferredLocations=preferredLocationsFuture.get();
    assertThat(preferredLocations,containsInAnyOrder(taskManagerLocation1,taskManagerLocation3));
  }
  /** 
 * Checks that the  {@link Execution} termination future is only completed after theassigned slot has been released. <p>NOTE: This test only fails spuriously without the fix of this commit. Thus, one has to execute this test multiple times to see the failure.
 */
  @Test public void testTerminationFutureIsCompletedAfterSlotRelease() throws Exception {
    final JobVertex jobVertex=createNoOpJobVertex();
    final JobVertexID jobVertexId=jobVertex.getID();
    final SingleSlotTestingSlotOwner slotOwner=new SingleSlotTestingSlotOwner();
    final ProgrammedSlotProvider slotProvider=createProgrammedSlotProvider(1,Collections.singleton(jobVertexId),slotOwner);
    ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
    ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
    ExecutionVertex executionVertex=executionJobVertex.getTaskVertices()[0];
    executionVertex.scheduleForExecution(slotProvider,false,LocationPreferenceConstraint.ANY,Collections.emptySet()).get();
    Execution currentExecutionAttempt=executionVertex.getCurrentExecutionAttempt();
    CompletableFuture<LogicalSlot> returnedSlotFuture=slotOwner.getReturnedSlotFuture();
    CompletableFuture<?> terminationFuture=executionVertex.cancel();
    CompletableFuture.runAsync(() -> currentExecutionAttempt.cancelingComplete(),TestingUtils.defaultExecutor());
    Thread.yield();
    CompletableFuture<Boolean> restartFuture=terminationFuture.thenApply(ignored -> {
      assertTrue(returnedSlotFuture.isDone());
      return true;
    }
);
    restartFuture.get();
  }
  /** 
 * Tests that the task restore state is nulled after the  {@link Execution} has beendeployed. See FLINK-9693.
 */
  @Test public void testTaskRestoreStateIsNulledAfterDeployment() throws Exception {
    final JobVertex jobVertex=createNoOpJobVertex();
    final JobVertexID jobVertexId=jobVertex.getID();
    final SingleSlotTestingSlotOwner slotOwner=new SingleSlotTestingSlotOwner();
    final ProgrammedSlotProvider slotProvider=createProgrammedSlotProvider(1,Collections.singleton(jobVertexId),slotOwner);
    ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
    ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
    ExecutionVertex executionVertex=executionJobVertex.getTaskVertices()[0];
    final Execution execution=executionVertex.getCurrentExecutionAttempt();
    final JobManagerTaskRestore taskRestoreState=new JobManagerTaskRestore(1L,new TaskStateSnapshot());
    execution.setInitialState(taskRestoreState);
    assertThat(execution.getTaskRestore(),is(notNullValue()));
    executionVertex.scheduleForExecution(slotProvider,false,LocationPreferenceConstraint.ANY,Collections.emptySet()).get();
    assertThat(execution.getTaskRestore(),is(nullValue()));
  }
  @Test public void testEagerSchedulingFailureReturnsSlot() throws Exception {
    final JobVertex jobVertex=createNoOpJobVertex();
    final JobVertexID jobVertexId=jobVertex.getID();
    final SimpleAckingTaskManagerGateway taskManagerGateway=new SimpleAckingTaskManagerGateway();
    final SingleSlotTestingSlotOwner slotOwner=new SingleSlotTestingSlotOwner();
    final CompletableFuture<SlotRequestId> slotRequestIdFuture=new CompletableFuture<>();
    final CompletableFuture<SlotRequestId> returnedSlotFuture=new CompletableFuture<>();
    final TestingSlotProvider slotProvider=new TestingSlotProvider((    SlotRequestId slotRequestId) -> {
      slotRequestIdFuture.complete(slotRequestId);
      return new CompletableFuture<>();
    }
);
    slotProvider.setSlotCanceller(returnedSlotFuture::complete);
    slotOwner.getReturnedSlotFuture().thenAccept((    LogicalSlot logicalSlot) -> returnedSlotFuture.complete(logicalSlot.getSlotRequestId()));
    ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
    ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
    ExecutionVertex executionVertex=executionJobVertex.getTaskVertices()[0];
    final Execution execution=executionVertex.getCurrentExecutionAttempt();
    taskManagerGateway.setCancelConsumer(executionAttemptID -> {
      if (execution.getAttemptId().equals(executionAttemptID)) {
        execution.cancelingComplete();
      }
    }
);
    final ExecutorService executorService=Executors.newFixedThreadPool(1);
    try {
      slotRequestIdFuture.thenAcceptAsync((      SlotRequestId slotRequestId) -> {
        final SingleLogicalSlot singleLogicalSlot=ExecutionGraphSchedulingTest.createSingleLogicalSlot(slotOwner,taskManagerGateway,slotRequestId);
        slotProvider.complete(slotRequestId,singleLogicalSlot);
      }
,executorService);
      final CompletableFuture<Void> schedulingFuture=execution.scheduleForExecution(slotProvider,false,LocationPreferenceConstraint.ANY,Collections.emptySet());
      try {
        schedulingFuture.get();
        execution.cancel();
      }
 catch (      ExecutionException ignored) {
      }
      assertThat(returnedSlotFuture.get(),is(equalTo(slotRequestIdFuture.get())));
    }
  finally {
      executorService.shutdownNow();
    }
  }
  @Nonnull private JobVertex createNoOpJobVertex(){
    final JobVertex jobVertex=new JobVertex("Test vertex",new JobVertexID());
    jobVertex.setInvokableClass(NoOpInvokable.class);
    return jobVertex;
  }
  @Nonnull private ProgrammedSlotProvider createProgrammedSlotProvider(  int parallelism,  Collection<JobVertexID> jobVertexIds,  SlotOwner slotOwner){
    final ProgrammedSlotProvider slotProvider=new ProgrammedSlotProvider(parallelism);
    for (    JobVertexID jobVertexId : jobVertexIds) {
      for (int i=0; i < parallelism; i++) {
        final SimpleSlot slot=new SimpleSlot(slotOwner,new LocalTaskManagerLocation(),0,new SimpleAckingTaskManagerGateway(),null,null);
        slotProvider.addSlot(jobVertexId,0,CompletableFuture.completedFuture(slot));
      }
    }
    return slotProvider;
  }
  /** 
 * Slot owner which records the first returned slot.
 */
private static final class SingleSlotTestingSlotOwner implements SlotOwner {
    final CompletableFuture<LogicalSlot> returnedSlot=new CompletableFuture<>();
    public CompletableFuture<LogicalSlot> getReturnedSlotFuture(){
      return returnedSlot;
    }
    @Override public CompletableFuture<Boolean> returnAllocatedSlot(    LogicalSlot logicalSlot){
      return CompletableFuture.completedFuture(returnedSlot.complete(logicalSlot));
    }
  }
}
