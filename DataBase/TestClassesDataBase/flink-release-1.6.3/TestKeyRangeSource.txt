/** 
 * Test source producing (key, 1) tuples with random key in key range (numKeys).
 */
private static class TestKeyRangeSource extends RichParallelSourceFunction<Tuple2<Integer,Long>> implements CheckpointListener {
  private static final long serialVersionUID=-5744725196953582710L;
  private static final AtomicLong LATEST_CHECKPOINT_ID=new AtomicLong();
  private final int numKeys;
  private final ThreadLocalRandom random=ThreadLocalRandom.current();
  private volatile boolean isRunning=true;
  private int counter=0;
  TestKeyRangeSource(  int numKeys){
    this.numKeys=numKeys;
  }
  @Override public void open(  Configuration parameters) throws Exception {
    super.open(parameters);
    if (getRuntimeContext().getIndexOfThisSubtask() == 0) {
      LATEST_CHECKPOINT_ID.set(0L);
    }
  }
  @Override public void run(  SourceContext<Tuple2<Integer,Long>> ctx) throws Exception {
    Tuple2<Integer,Long> record=new Tuple2<>(0,1L);
    while (isRunning) {
synchronized (ctx.getCheckpointLock()) {
        record.f0=random.nextInt(numKeys);
        ctx.collect(record);
        counter++;
      }
      if (counter % 50 == 0) {
        Thread.sleep(1L);
      }
    }
  }
  @Override public void cancel(){
    isRunning=false;
  }
  @Override public void notifyCheckpointComplete(  long checkpointId) throws Exception {
    if (getRuntimeContext().getIndexOfThisSubtask() == 0) {
      LATEST_CHECKPOINT_ID.set(checkpointId);
    }
  }
}
