/** 
 * Tests for the emission of latency markers by  {@link StreamSource} operators.
 */
public class StreamSourceOperatorLatencyMetricsTest extends TestLogger {
  private static final long maxProcessingTime=100L;
  private static final long latencyMarkInterval=10L;
  /** 
 * Verifies that latency metrics can be enabled via the  {@link ExecutionConfig}.
 */
  @Test public void testLatencyMarkEmissionEnabledViaExecutionConfig() throws Exception {
    testLatencyMarkEmission((int)(maxProcessingTime / latencyMarkInterval) + 1,(operator,timeProvider) -> {
      ExecutionConfig executionConfig=new ExecutionConfig();
      executionConfig.setLatencyTrackingInterval(latencyMarkInterval);
      setupSourceOperator(operator,executionConfig,MockEnvironment.builder().build(),timeProvider);
    }
);
  }
  /** 
 * Verifies that latency metrics can be enabled via the configuration.
 */
  @Test public void testLatencyMarkEmissionEnabledViaFlinkConfig() throws Exception {
    testLatencyMarkEmission((int)(maxProcessingTime / latencyMarkInterval) + 1,(operator,timeProvider) -> {
      Configuration tmConfig=new Configuration();
      tmConfig.setLong(MetricOptions.LATENCY_INTERVAL,latencyMarkInterval);
      Environment env=MockEnvironment.builder().setTaskManagerRuntimeInfo(new TestingTaskManagerRuntimeInfo(tmConfig)).build();
      setupSourceOperator(operator,new ExecutionConfig(),env,timeProvider);
    }
);
  }
  /** 
 * Verifies that latency metrics can be enabled via the  {@link ExecutionConfig} even if they are disabled viathe configuration.
 */
  @Test public void testLatencyMarkEmissionEnabledOverrideViaExecutionConfig() throws Exception {
    testLatencyMarkEmission((int)(maxProcessingTime / latencyMarkInterval) + 1,(operator,timeProvider) -> {
      ExecutionConfig executionConfig=new ExecutionConfig();
      executionConfig.setLatencyTrackingInterval(latencyMarkInterval);
      Configuration tmConfig=new Configuration();
      tmConfig.setLong(MetricOptions.LATENCY_INTERVAL,0L);
      Environment env=MockEnvironment.builder().setTaskManagerRuntimeInfo(new TestingTaskManagerRuntimeInfo(tmConfig)).build();
      setupSourceOperator(operator,executionConfig,env,timeProvider);
    }
);
  }
  /** 
 * Verifies that latency metrics can be disabled via the  {@link ExecutionConfig} even if they are enabled viathe configuration.
 */
  @Test public void testLatencyMarkEmissionDisabledOverrideViaExecutionConfig() throws Exception {
    testLatencyMarkEmission(0,(operator,timeProvider) -> {
      Configuration tmConfig=new Configuration();
      tmConfig.setLong(MetricOptions.LATENCY_INTERVAL,latencyMarkInterval);
      Environment env=MockEnvironment.builder().setTaskManagerRuntimeInfo(new TestingTaskManagerRuntimeInfo(tmConfig)).build();
      ExecutionConfig executionConfig=new ExecutionConfig();
      executionConfig.setLatencyTrackingInterval(0);
      setupSourceOperator(operator,executionConfig,env,timeProvider);
    }
);
  }
private interface OperatorSetupOperation {
    void setupSourceOperator(    StreamSource<Long,?> operator,    TestProcessingTimeService testProcessingTimeService);
  }
  private void testLatencyMarkEmission(  int numberLatencyMarkers,  OperatorSetupOperation operatorSetup) throws Exception {
    final List<StreamElement> output=new ArrayList<>();
    final TestProcessingTimeService testProcessingTimeService=new TestProcessingTimeService();
    testProcessingTimeService.setCurrentTime(0L);
    final List<Long> processingTimes=Arrays.asList(1L,10L,11L,21L,maxProcessingTime);
    final StreamSource<Long,ProcessingTimeServiceSource> operator=new StreamSource<>(new ProcessingTimeServiceSource(testProcessingTimeService,processingTimes));
    operatorSetup.setupSourceOperator(operator,testProcessingTimeService);
    operator.run(new Object(),mock(StreamStatusMaintainer.class),new CollectorOutput<Long>(output));
    assertEquals(numberLatencyMarkers + 1,output.size());
    long timestamp=0L;
    int i=0;
    for (; i < numberLatencyMarkers; i++) {
      StreamElement se=output.get(i);
      Assert.assertTrue(se.isLatencyMarker());
      Assert.assertEquals(operator.getOperatorID(),se.asLatencyMarker().getOperatorId());
      Assert.assertEquals(0,se.asLatencyMarker().getSubtaskIndex());
      Assert.assertTrue(se.asLatencyMarker().getMarkedTime() == timestamp);
      timestamp+=latencyMarkInterval;
    }
    Assert.assertTrue(output.get(i).isWatermark());
  }
  private static <T>void setupSourceOperator(  StreamSource<T,?> operator,  ExecutionConfig executionConfig,  Environment env,  ProcessingTimeService timeProvider){
    StreamConfig cfg=new StreamConfig(new Configuration());
    cfg.setStateBackend(new MemoryStateBackend());
    cfg.setTimeCharacteristic(TimeCharacteristic.EventTime);
    cfg.setOperatorID(new OperatorID());
    StreamStatusMaintainer streamStatusMaintainer=mock(StreamStatusMaintainer.class);
    when(streamStatusMaintainer.getStreamStatus()).thenReturn(StreamStatus.ACTIVE);
    StreamTask<?,?> mockTask=mock(StreamTask.class);
    when(mockTask.getName()).thenReturn("Mock Task");
    when(mockTask.getCheckpointLock()).thenReturn(new Object());
    when(mockTask.getConfiguration()).thenReturn(cfg);
    when(mockTask.getEnvironment()).thenReturn(env);
    when(mockTask.getExecutionConfig()).thenReturn(executionConfig);
    when(mockTask.getAccumulatorMap()).thenReturn(Collections.<String,Accumulator<?,?>>emptyMap());
    when(mockTask.getStreamStatusMaintainer()).thenReturn(streamStatusMaintainer);
    doAnswer(new Answer<ProcessingTimeService>(){
      @Override public ProcessingTimeService answer(      InvocationOnMock invocation) throws Throwable {
        if (timeProvider == null) {
          throw new RuntimeException("The time provider is null.");
        }
        return timeProvider;
      }
    }
).when(mockTask).getProcessingTimeService();
    operator.setup(mockTask,cfg,(Output<StreamRecord<T>>)mock(Output.class));
  }
private static final class ProcessingTimeServiceSource implements SourceFunction<Long> {
    private final TestProcessingTimeService processingTimeService;
    private final List<Long> processingTimes;
    private boolean cancelled=false;
    private ProcessingTimeServiceSource(    TestProcessingTimeService processingTimeService,    List<Long> processingTimes){
      this.processingTimeService=processingTimeService;
      this.processingTimes=processingTimes;
    }
    @Override public void run(    SourceContext<Long> ctx) throws Exception {
      for (      Long processingTime : processingTimes) {
        if (cancelled) {
          break;
        }
        processingTimeService.setCurrentTime(processingTime);
      }
    }
    @Override public void cancel(){
      cancelled=true;
    }
  }
}
