/** 
 * Tests for the  {@link EventSerializer}.
 */
public class EventSerializerTest {
  @Test public void testCheckpointBarrierSerialization() throws Exception {
    long id=Integer.MAX_VALUE + 123123L;
    long timestamp=Integer.MAX_VALUE + 1228L;
    CheckpointOptions checkpoint=CheckpointOptions.forCheckpointWithDefaultLocation();
    testCheckpointBarrierSerialization(id,timestamp,checkpoint);
    final byte[] reference=new byte[]{15,52,52,11,0,0,0,0,-1,-23,-19,35};
    CheckpointOptions savepoint=new CheckpointOptions(CheckpointType.SAVEPOINT,new CheckpointStorageLocationReference(reference));
    testCheckpointBarrierSerialization(id,timestamp,savepoint);
  }
  private void testCheckpointBarrierSerialization(  long id,  long timestamp,  CheckpointOptions options) throws IOException {
    ClassLoader cl=Thread.currentThread().getContextClassLoader();
    CheckpointBarrier barrier=new CheckpointBarrier(id,timestamp,options);
    ByteBuffer serialized=EventSerializer.toSerializedEvent(barrier);
    CheckpointBarrier deserialized=(CheckpointBarrier)EventSerializer.fromSerializedEvent(serialized,cl);
    assertFalse(serialized.hasRemaining());
    assertEquals(id,deserialized.getId());
    assertEquals(timestamp,deserialized.getTimestamp());
    assertEquals(options.getCheckpointType(),deserialized.getCheckpointOptions().getCheckpointType());
    assertEquals(options.getTargetLocation(),deserialized.getCheckpointOptions().getTargetLocation());
  }
  @Test public void testSerializeDeserializeEvent() throws Exception {
    AbstractEvent[] events={EndOfPartitionEvent.INSTANCE,EndOfSuperstepEvent.INSTANCE,new CheckpointBarrier(1678L,4623784L,CheckpointOptions.forCheckpointWithDefaultLocation()),new TestTaskEvent(Math.random(),12361231273L),new CancelCheckpointMarker(287087987329842L)};
    for (    AbstractEvent evt : events) {
      ByteBuffer serializedEvent=EventSerializer.toSerializedEvent(evt);
      assertTrue(serializedEvent.hasRemaining());
      AbstractEvent deserialized=EventSerializer.fromSerializedEvent(serializedEvent,getClass().getClassLoader());
      assertNotNull(deserialized);
      assertEquals(evt,deserialized);
    }
  }
  /** 
 * Tests  {@link EventSerializer#isEvent(Buffer,Class)}whether it peaks into the buffer only, i.e. after the call, the buffer is still de-serializable.
 */
  @Test public void testIsEventPeakOnly() throws Exception {
    final Buffer serializedEvent=EventSerializer.toBuffer(EndOfPartitionEvent.INSTANCE);
    try {
      final ClassLoader cl=getClass().getClassLoader();
      assertTrue(EventSerializer.isEvent(serializedEvent,EndOfPartitionEvent.class));
      EndOfPartitionEvent event=(EndOfPartitionEvent)EventSerializer.fromBuffer(serializedEvent,cl);
      assertEquals(EndOfPartitionEvent.INSTANCE,event);
    }
  finally {
      serializedEvent.recycleBuffer();
    }
  }
  /** 
 * Tests  {@link EventSerializer#isEvent(Buffer,Class)} returnsthe correct answer for various encoded event buffers.
 */
  @Test public void testIsEvent() throws Exception {
    AbstractEvent[] events={EndOfPartitionEvent.INSTANCE,EndOfSuperstepEvent.INSTANCE,new CheckpointBarrier(1678L,4623784L,CheckpointOptions.forCheckpointWithDefaultLocation()),new TestTaskEvent(Math.random(),12361231273L),new CancelCheckpointMarker(287087987329842L)};
    Class[] expectedClasses=Arrays.stream(events).map(AbstractEvent::getClass).toArray(Class[]::new);
    for (    AbstractEvent evt : events) {
      for (      Class<?> expectedClass : expectedClasses) {
        if (expectedClass.equals(TestTaskEvent.class)) {
          try {
            checkIsEvent(evt,expectedClass);
            fail("This should fail");
          }
 catch (          UnsupportedOperationException ex) {
          }
        }
 else         if (evt.getClass().equals(expectedClass)) {
          assertTrue(checkIsEvent(evt,expectedClass));
        }
 else {
          assertFalse(checkIsEvent(evt,expectedClass));
        }
      }
    }
  }
  /** 
 * Returns the result of {@link EventSerializer#isEvent(Buffer,Class)} on a bufferthat encodes the given <tt>event</tt>.
 * @param event the event to encode
 * @param eventClass the event class to check against
 * @return whether {@link EventSerializer#isEvent(ByteBuffer,Class)}thinks the encoded buffer matches the class
 */
  private boolean checkIsEvent(  AbstractEvent event,  Class<?> eventClass) throws IOException {
    final Buffer serializedEvent=EventSerializer.toBuffer(event);
    try {
      return EventSerializer.isEvent(serializedEvent,eventClass);
    }
  finally {
      serializedEvent.recycleBuffer();
    }
  }
}
