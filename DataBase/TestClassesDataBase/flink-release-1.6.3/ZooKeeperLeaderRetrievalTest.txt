public class ZooKeeperLeaderRetrievalTest extends TestLogger {
  private TestingServer testingServer;
  private Configuration config;
  private HighAvailabilityServices highAvailabilityServices;
  @Before public void before() throws Exception {
    testingServer=new TestingServer();
    config=new Configuration();
    config.setString(HighAvailabilityOptions.HA_MODE,"zookeeper");
    config.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM,testingServer.getConnectString());
    CuratorFramework client=ZooKeeperUtils.startCuratorFramework(config);
    highAvailabilityServices=new ZooKeeperHaServices(client,TestingUtils.defaultExecutor(),config,new VoidBlobStore());
  }
  @After public void after() throws Exception {
    if (testingServer != null) {
      testingServer.stop();
      testingServer=null;
    }
    if (highAvailabilityServices != null) {
      highAvailabilityServices.closeAndCleanupAllData();
      highAvailabilityServices=null;
    }
  }
  /** 
 * Tests that LeaderRetrievalUtils.findConnectingAddress finds the correct connecting address in case of an old leader address in ZooKeeper and a subsequent election of a new leader. The findConnectingAddress should block until the new leader has been elected and his address has been written to ZooKeeper.
 */
  @Test public void testConnectingAddressRetrievalWithDelayedLeaderElection() throws Exception {
    FiniteDuration timeout=new FiniteDuration(1,TimeUnit.MINUTES);
    long sleepingTime=1000;
    LeaderElectionService leaderElectionService=null;
    LeaderElectionService faultyLeaderElectionService;
    ServerSocket serverSocket;
    InetAddress localHost;
    Thread thread;
    try {
      String wrongAddress=AkkaRpcServiceUtils.getRpcUrl("1.1.1.1",1234,"foobar",HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION,config);
      try {
        localHost=InetAddress.getLocalHost();
        serverSocket=new ServerSocket(0,50,localHost);
      }
 catch (      UnknownHostException e) {
        System.err.println("Skipping 'testNetworkInterfaceSelection' test.");
        return;
      }
catch (      IOException e) {
        System.err.println("Skipping 'testNetworkInterfaceSelection' test.");
        return;
      }
      InetSocketAddress correctInetSocketAddress=new InetSocketAddress(localHost,serverSocket.getLocalPort());
      String correctAddress=AkkaRpcServiceUtils.getRpcUrl(localHost.getHostName(),correctInetSocketAddress.getPort(),JobMaster.JOB_MANAGER_NAME,HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION,config);
      faultyLeaderElectionService=highAvailabilityServices.getJobManagerLeaderElectionService(HighAvailabilityServices.DEFAULT_JOB_ID);
      TestingContender wrongLeaderAddressContender=new TestingContender(wrongAddress,faultyLeaderElectionService);
      faultyLeaderElectionService.start(wrongLeaderAddressContender);
      FindConnectingAddress findConnectingAddress=new FindConnectingAddress(timeout,highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID));
      thread=new Thread(findConnectingAddress);
      thread.start();
      leaderElectionService=highAvailabilityServices.getJobManagerLeaderElectionService(HighAvailabilityServices.DEFAULT_JOB_ID);
      TestingContender correctLeaderAddressContender=new TestingContender(correctAddress,leaderElectionService);
      Thread.sleep(sleepingTime);
      faultyLeaderElectionService.stop();
      leaderElectionService.start(correctLeaderAddressContender);
      thread.join();
      InetAddress result=findConnectingAddress.getInetAddress();
      Socket socket=new Socket();
      try {
        SocketAddress bindP=new InetSocketAddress(result,0);
        socket.bind(bindP);
        socket.connect(correctInetSocketAddress,1000);
      }
  finally {
        socket.close();
      }
    }
  finally {
      if (leaderElectionService != null) {
        leaderElectionService.stop();
      }
    }
  }
  /** 
 * Tests that the LeaderRetrievalUtils.findConnectingAddress stops trying to find the connecting address if no leader address has been specified. The call should return then InetAddress.getLocalHost().
 */
  @Test public void testTimeoutOfFindConnectingAddress() throws Exception {
    FiniteDuration timeout=new FiniteDuration(10L,TimeUnit.SECONDS);
    LeaderRetrievalService leaderRetrievalService=highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID);
    InetAddress result=LeaderRetrievalUtils.findConnectingAddress(leaderRetrievalService,timeout);
    assertEquals(InetAddress.getLocalHost(),result);
  }
static class FindConnectingAddress implements Runnable {
    private final FiniteDuration timeout;
    private final LeaderRetrievalService leaderRetrievalService;
    private InetAddress result;
    private Exception exception;
    public FindConnectingAddress(    FiniteDuration timeout,    LeaderRetrievalService leaderRetrievalService){
      this.timeout=timeout;
      this.leaderRetrievalService=leaderRetrievalService;
    }
    @Override public void run(){
      try {
        result=LeaderRetrievalUtils.findConnectingAddress(leaderRetrievalService,timeout);
      }
 catch (      Exception e) {
        exception=e;
      }
    }
    public InetAddress getInetAddress() throws Exception {
      if (exception != null) {
        throw exception;
      }
 else {
        return result;
      }
    }
  }
}
