/** 
 * Tests for the  {@link BucketStateSerializer}.
 */
public class BucketStateSerializerTest {
  private static final String IN_PROGRESS_CONTENT="writing";
  private static final String PENDING_CONTENT="wrote";
  @ClassRule public static TemporaryFolder tempFolder=new TemporaryFolder();
  @Test public void testSerializationEmpty() throws IOException {
    final File testFolder=tempFolder.newFolder();
    final FileSystem fs=FileSystem.get(testFolder.toURI());
    final RecoverableWriter writer=fs.createRecoverableWriter();
    final Path testBucket=new Path(testFolder.getPath(),"test");
    final BucketState<String> bucketState=new BucketState<>("test",testBucket,Long.MAX_VALUE,null,new HashMap<>());
    final SimpleVersionedSerializer<BucketState<String>> serializer=new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(),writer.getCommitRecoverableSerializer(),SimpleVersionedStringSerializer.INSTANCE);
    byte[] bytes=SimpleVersionedSerialization.writeVersionAndSerialize(serializer,bucketState);
    final BucketState<String> recoveredState=SimpleVersionedSerialization.readVersionAndDeSerialize(serializer,bytes);
    Assert.assertEquals(testBucket,recoveredState.getBucketPath());
    Assert.assertNull(recoveredState.getInProgressResumableFile());
    Assert.assertTrue(recoveredState.getCommittableFilesPerCheckpoint().isEmpty());
  }
  @Test public void testSerializationOnlyInProgress() throws IOException {
    final File testFolder=tempFolder.newFolder();
    final FileSystem fs=FileSystem.get(testFolder.toURI());
    final Path testBucket=new Path(testFolder.getPath(),"test");
    final RecoverableWriter writer=fs.createRecoverableWriter();
    final RecoverableFsDataOutputStream stream=writer.open(testBucket);
    stream.write(IN_PROGRESS_CONTENT.getBytes(Charset.forName("UTF-8")));
    final RecoverableWriter.ResumeRecoverable current=stream.persist();
    final BucketState<String> bucketState=new BucketState<>("test",testBucket,Long.MAX_VALUE,current,new HashMap<>());
    final SimpleVersionedSerializer<BucketState<String>> serializer=new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(),writer.getCommitRecoverableSerializer(),SimpleVersionedStringSerializer.INSTANCE);
    final byte[] bytes=SimpleVersionedSerialization.writeVersionAndSerialize(serializer,bucketState);
    stream.close();
    final BucketState<String> recoveredState=SimpleVersionedSerialization.readVersionAndDeSerialize(serializer,bytes);
    Assert.assertEquals(testBucket,recoveredState.getBucketPath());
    FileStatus[] statuses=fs.listStatus(testBucket.getParent());
    Assert.assertEquals(1L,statuses.length);
    Assert.assertTrue(statuses[0].getPath().getPath().startsWith((new Path(testBucket.getParent(),".test.inprogress")).toString()));
  }
  @Test public void testSerializationFull() throws IOException {
    final int noOfTasks=5;
    final File testFolder=tempFolder.newFolder();
    final FileSystem fs=FileSystem.get(testFolder.toURI());
    final RecoverableWriter writer=fs.createRecoverableWriter();
    final Path bucketPath=new Path(testFolder.getPath());
    final Map<Long,List<RecoverableWriter.CommitRecoverable>> commitRecoverables=new HashMap<>();
    for (int i=0; i < noOfTasks; i++) {
      final List<RecoverableWriter.CommitRecoverable> recoverables=new ArrayList<>();
      for (int j=0; j < 2 + i; j++) {
        final Path part=new Path(bucketPath,"part-" + i + '-'+ j);
        final RecoverableFsDataOutputStream stream=writer.open(part);
        stream.write((PENDING_CONTENT + '-' + j).getBytes(Charset.forName("UTF-8")));
        recoverables.add(stream.closeForCommit().getRecoverable());
      }
      commitRecoverables.put((long)i,recoverables);
    }
    final Path testBucket=new Path(bucketPath,"test-2");
    final RecoverableFsDataOutputStream stream=writer.open(testBucket);
    stream.write(IN_PROGRESS_CONTENT.getBytes(Charset.forName("UTF-8")));
    final RecoverableWriter.ResumeRecoverable current=stream.persist();
    final BucketState<String> bucketState=new BucketState<>("test-2",bucketPath,Long.MAX_VALUE,current,commitRecoverables);
    final SimpleVersionedSerializer<BucketState<String>> serializer=new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(),writer.getCommitRecoverableSerializer(),SimpleVersionedStringSerializer.INSTANCE);
    stream.close();
    byte[] bytes=SimpleVersionedSerialization.writeVersionAndSerialize(serializer,bucketState);
    final BucketState<String> recoveredState=SimpleVersionedSerialization.readVersionAndDeSerialize(serializer,bytes);
    Assert.assertEquals(bucketPath,recoveredState.getBucketPath());
    final Map<Long,List<RecoverableWriter.CommitRecoverable>> recoveredRecoverables=recoveredState.getCommittableFilesPerCheckpoint();
    Assert.assertEquals(5L,recoveredRecoverables.size());
    for (    Map.Entry<Long,List<RecoverableWriter.CommitRecoverable>> entry : recoveredRecoverables.entrySet()) {
      for (      RecoverableWriter.CommitRecoverable recoverable : entry.getValue()) {
        writer.recoverForCommit(recoverable).commit();
      }
    }
    FileStatus[] filestatuses=fs.listStatus(bucketPath);
    Set<String> paths=new HashSet<>(filestatuses.length);
    for (    FileStatus filestatus : filestatuses) {
      paths.add(filestatus.getPath().getPath());
    }
    for (int i=0; i < noOfTasks; i++) {
      for (int j=0; j < 2 + i; j++) {
        final String part=new Path(bucketPath,"part-" + i + '-'+ j).toString();
        Assert.assertTrue(paths.contains(part));
        paths.remove(part);
      }
    }
    Assert.assertEquals(1L,paths.size());
    Assert.assertTrue(paths.iterator().next().startsWith((new Path(testBucket.getParent(),".test-2.inprogress").toString())));
  }
  @Test public void testSerializationNullInProgress() throws IOException {
    final int noOfTasks=5;
    final File testFolder=tempFolder.newFolder();
    final FileSystem fs=FileSystem.get(testFolder.toURI());
    final RecoverableWriter writer=fs.createRecoverableWriter();
    final Path bucketPath=new Path(testFolder.getPath());
    final Map<Long,List<RecoverableWriter.CommitRecoverable>> commitRecoverables=new HashMap<>();
    for (int i=0; i < noOfTasks; i++) {
      final List<RecoverableWriter.CommitRecoverable> recoverables=new ArrayList<>();
      for (int j=0; j < 2 + i; j++) {
        final Path part=new Path(bucketPath,"test-" + i + '-'+ j);
        final RecoverableFsDataOutputStream stream=writer.open(part);
        stream.write((PENDING_CONTENT + '-' + j).getBytes(Charset.forName("UTF-8")));
        recoverables.add(stream.closeForCommit().getRecoverable());
      }
      commitRecoverables.put((long)i,recoverables);
    }
    final RecoverableWriter.ResumeRecoverable current=null;
    final BucketState<String> bucketState=new BucketState<>("",bucketPath,Long.MAX_VALUE,current,commitRecoverables);
    final SimpleVersionedSerializer<BucketState<String>> serializer=new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(),writer.getCommitRecoverableSerializer(),SimpleVersionedStringSerializer.INSTANCE);
    byte[] bytes=SimpleVersionedSerialization.writeVersionAndSerialize(serializer,bucketState);
    final BucketState<String> recoveredState=SimpleVersionedSerialization.readVersionAndDeSerialize(serializer,bytes);
    Assert.assertEquals(bucketPath,recoveredState.getBucketPath());
    Assert.assertNull(recoveredState.getInProgressResumableFile());
    final Map<Long,List<RecoverableWriter.CommitRecoverable>> recoveredRecoverables=recoveredState.getCommittableFilesPerCheckpoint();
    Assert.assertEquals(5L,recoveredRecoverables.size());
    for (    Map.Entry<Long,List<RecoverableWriter.CommitRecoverable>> entry : recoveredRecoverables.entrySet()) {
      for (      RecoverableWriter.CommitRecoverable recoverable : entry.getValue()) {
        writer.recoverForCommit(recoverable).commit();
      }
    }
    FileStatus[] filestatuses=fs.listStatus(bucketPath);
    Set<String> paths=new HashSet<>(filestatuses.length);
    for (    FileStatus filestatus : filestatuses) {
      paths.add(filestatus.getPath().getPath());
    }
    for (int i=0; i < noOfTasks; i++) {
      for (int j=0; j < 2 + i; j++) {
        final String part=new Path(bucketPath,"test-" + i + '-'+ j).toString();
        Assert.assertTrue(paths.contains(part));
        paths.remove(part);
      }
    }
    Assert.assertTrue(paths.isEmpty());
  }
}
