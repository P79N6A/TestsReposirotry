public class CancelPartitionRequestTest {
  /** 
 * Verifies that requests for non-existing (failed/cancelled) input channels are properly cancelled. The receiver receives data, but there is no input channel to receive the data. This should cancel the request.
 */
  @Test public void testCancelPartitionRequest() throws Exception {
    NettyServerAndClient serverAndClient=null;
    try {
      TestPooledBufferProvider outboundBuffers=new TestPooledBufferProvider(16);
      ResultPartitionManager partitions=mock(ResultPartitionManager.class);
      ResultPartitionID pid=new ResultPartitionID();
      CountDownLatch sync=new CountDownLatch(1);
      final ResultSubpartitionView view=spy(new InfiniteSubpartitionView(outboundBuffers,sync));
      when(partitions.createSubpartitionView(eq(pid),eq(0),any(BufferAvailabilityListener.class))).thenAnswer(new Answer<ResultSubpartitionView>(){
        @Override public ResultSubpartitionView answer(        InvocationOnMock invocationOnMock) throws Throwable {
          BufferAvailabilityListener listener=(BufferAvailabilityListener)invocationOnMock.getArguments()[2];
          listener.notifyDataAvailable();
          return view;
        }
      }
);
      NettyProtocol protocol=new NettyProtocol(partitions,mock(TaskEventDispatcher.class),true);
      serverAndClient=initServerAndClient(protocol);
      Channel ch=connect(serverAndClient);
      ch.writeAndFlush(new PartitionRequest(pid,0,new InputChannelID(),Integer.MAX_VALUE)).await();
      if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(),TimeUnit.MILLISECONDS)) {
        fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about cancelled partition.");
      }
      verify(view,times(1)).releaseAllResources();
      verify(view,times(0)).notifySubpartitionConsumed();
    }
  finally {
      shutdown(serverAndClient);
    }
  }
  @Test public void testDuplicateCancel() throws Exception {
    NettyServerAndClient serverAndClient=null;
    try {
      final TestPooledBufferProvider outboundBuffers=new TestPooledBufferProvider(16);
      ResultPartitionManager partitions=mock(ResultPartitionManager.class);
      ResultPartitionID pid=new ResultPartitionID();
      final CountDownLatch sync=new CountDownLatch(1);
      final ResultSubpartitionView view=spy(new InfiniteSubpartitionView(outboundBuffers,sync));
      when(partitions.createSubpartitionView(eq(pid),eq(0),any(BufferAvailabilityListener.class))).thenAnswer(new Answer<ResultSubpartitionView>(){
        @Override public ResultSubpartitionView answer(        InvocationOnMock invocationOnMock) throws Throwable {
          BufferAvailabilityListener listener=(BufferAvailabilityListener)invocationOnMock.getArguments()[2];
          listener.notifyDataAvailable();
          return view;
        }
      }
);
      NettyProtocol protocol=new NettyProtocol(partitions,mock(TaskEventDispatcher.class),true);
      serverAndClient=initServerAndClient(protocol);
      Channel ch=connect(serverAndClient);
      InputChannelID inputChannelId=new InputChannelID();
      ch.writeAndFlush(new PartitionRequest(pid,0,inputChannelId,Integer.MAX_VALUE)).await();
      if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(),TimeUnit.MILLISECONDS)) {
        fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about cancelled partition.");
      }
      ch.writeAndFlush(new CancelPartitionRequest(inputChannelId)).await();
      ch.close();
      NettyTestUtil.awaitClose(ch);
      verify(view,times(1)).releaseAllResources();
      verify(view,times(0)).notifySubpartitionConsumed();
    }
  finally {
      shutdown(serverAndClient);
    }
  }
static class InfiniteSubpartitionView implements ResultSubpartitionView {
    private final BufferProvider bufferProvider;
    private final CountDownLatch sync;
    public InfiniteSubpartitionView(    BufferProvider bufferProvider,    CountDownLatch sync){
      this.bufferProvider=checkNotNull(bufferProvider);
      this.sync=checkNotNull(sync);
    }
    @Nullable @Override public BufferAndBacklog getNextBuffer() throws IOException, InterruptedException {
      Buffer buffer=bufferProvider.requestBufferBlocking();
      buffer.setSize(buffer.getMaxCapacity());
      return new BufferAndBacklog(buffer,true,0,false);
    }
    @Override public void notifyDataAvailable(){
    }
    @Override public void releaseAllResources() throws IOException {
      sync.countDown();
    }
    @Override public void notifySubpartitionConsumed() throws IOException {
    }
    @Override public boolean isReleased(){
      return false;
    }
    @Override public boolean nextBufferIsEvent(){
      return false;
    }
    @Override public boolean isAvailable(){
      return true;
    }
    @Override public Throwable getFailureCause(){
      return null;
    }
  }
}
