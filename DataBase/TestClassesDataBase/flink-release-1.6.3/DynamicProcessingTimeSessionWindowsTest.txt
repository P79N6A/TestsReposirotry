/** 
 * Tests for  {@link DynamicProcessingTimeSessionWindows}.
 */
public class DynamicProcessingTimeSessionWindowsTest extends TestLogger {
  @Test public void testWindowAssignment(){
    WindowAssigner.WindowAssignerContext mockContext=mock(WindowAssigner.WindowAssignerContext.class);
    SessionWindowTimeGapExtractor<String> extractor=mock(SessionWindowTimeGapExtractor.class);
    when(extractor.extract(eq("gap5000"))).thenReturn(5000L);
    when(extractor.extract(eq("gap4000"))).thenReturn(4000L);
    when(extractor.extract(eq("gap9000"))).thenReturn(9000L);
    DynamicProcessingTimeSessionWindows<String> assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
    when(mockContext.getCurrentProcessingTime()).thenReturn(0L);
    assertThat(assigner.assignWindows("gap5000",Long.MIN_VALUE,mockContext),contains(timeWindow(0,5000)));
    when(mockContext.getCurrentProcessingTime()).thenReturn(4999L);
    assertThat(assigner.assignWindows("gap4000",Long.MIN_VALUE,mockContext),contains(timeWindow(4999,8999)));
    when(mockContext.getCurrentProcessingTime()).thenReturn(5000L);
    assertThat(assigner.assignWindows("gap9000",Long.MIN_VALUE,mockContext),contains(timeWindow(5000,14000)));
  }
  @Test public void testMergeSinglePointWindow(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
    when(extractor.extract(any())).thenReturn(5000L);
    DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(0,0)),callback);
    verify(callback,never()).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testMergeSingleWindow(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
    when(extractor.extract(any())).thenReturn(5000L);
    DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(0,1)),callback);
    verify(callback,never()).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testMergeConsecutiveWindows(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
    when(extractor.extract(any())).thenReturn(5000L);
    DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(0,1),new TimeWindow(1,2),new TimeWindow(2,3),new TimeWindow(4,5),new TimeWindow(5,6)),callback);
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(0,1),new TimeWindow(1,2),new TimeWindow(2,3))),eq(new TimeWindow(0,3)));
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(4,5),new TimeWindow(5,6))),eq(new TimeWindow(4,6)));
    verify(callback,times(2)).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testMergeCoveringWindow(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
    when(extractor.extract(any())).thenReturn(5000L);
    DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(1,1),new TimeWindow(0,2),new TimeWindow(4,7),new TimeWindow(5,6)),callback);
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(1,1),new TimeWindow(0,2))),eq(new TimeWindow(0,2)));
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(5,6),new TimeWindow(4,7))),eq(new TimeWindow(4,7)));
    verify(callback,times(2)).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testInvalidParameters(){
    WindowAssigner.WindowAssignerContext mockContext=mock(WindowAssigner.WindowAssignerContext.class);
    try {
      SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
      when(extractor.extract(any())).thenReturn(-1L);
      DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
      assigner.assignWindows(Lists.newArrayList(new Object()),1,mockContext);
      fail("should fail");
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.toString(),containsString("0 < gap"));
    }
    try {
      SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
      when(extractor.extract(any())).thenReturn(-1L);
      DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
      assigner.assignWindows(Lists.newArrayList(new Object()),1,mockContext);
      fail("should fail");
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.toString(),containsString("0 < gap"));
    }
  }
  @Test public void testProperties(){
    SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
    when(extractor.extract(any())).thenReturn(5000L);
    DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
    assertFalse(assigner.isEventTime());
    assertEquals(new TimeWindow.Serializer(),assigner.getWindowSerializer(new ExecutionConfig()));
    assertThat(assigner.getDefaultTrigger(mock(StreamExecutionEnvironment.class)),instanceOf(ProcessingTimeTrigger.class));
  }
}
