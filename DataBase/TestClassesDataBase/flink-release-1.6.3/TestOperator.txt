/** 
 * Testing operator that can respond to commands by either setting/deleting state, emitting state or setting timers.
 */
private static class TestOperator extends AbstractStreamOperator<String> implements OneInputStreamOperator<Tuple2<Integer,String>,String>, Triggerable<Integer,VoidNamespace> {
  private static final long serialVersionUID=1L;
  private transient InternalTimerService<VoidNamespace> timerService;
  private final ValueStateDescriptor<String> stateDescriptor=new ValueStateDescriptor<>("state",StringSerializer.INSTANCE);
  @Override public void open() throws Exception {
    super.open();
    this.timerService=getInternalTimerService("test-timers",VoidNamespaceSerializer.INSTANCE,this);
  }
  @Override public void processElement(  StreamRecord<Tuple2<Integer,String>> element) throws Exception {
    String[] command=element.getValue().f1.split(":");
switch (command[0]) {
case "SET_STATE":
      getPartitionedState(stateDescriptor).update(command[1]);
    break;
case "DELETE_STATE":
  getPartitionedState(stateDescriptor).clear();
break;
case "SET_EVENT_TIME_TIMER":
timerService.registerEventTimeTimer(VoidNamespace.INSTANCE,Long.parseLong(command[1]));
break;
case "SET_PROC_TIME_TIMER":
timerService.registerProcessingTimeTimer(VoidNamespace.INSTANCE,Long.parseLong(command[1]));
break;
case "EMIT_STATE":
String stateValue=getPartitionedState(stateDescriptor).value();
output.collect(new StreamRecord<>("ON_ELEMENT:" + element.getValue().f0 + ":"+ stateValue));
break;
default :
throw new IllegalArgumentException();
}
}
@Override public void onEventTime(InternalTimer<Integer,VoidNamespace> timer) throws Exception {
String stateValue=getPartitionedState(stateDescriptor).value();
output.collect(new StreamRecord<>("ON_EVENT_TIME:" + stateValue));
}
@Override public void onProcessingTime(InternalTimer<Integer,VoidNamespace> timer) throws Exception {
String stateValue=getPartitionedState(stateDescriptor).value();
output.collect(new StreamRecord<>("ON_PROC_TIME:" + stateValue));
}
}
