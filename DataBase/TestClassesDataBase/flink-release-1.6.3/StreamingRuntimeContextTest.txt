/** 
 * Tests for  {@link StreamingRuntimeContext}.
 */
public class StreamingRuntimeContextTest {
  @Test public void testValueStateInstantiation() throws Exception {
    final ExecutionConfig config=new ExecutionConfig();
    config.registerKryoType(Path.class);
    final AtomicReference<Object> descriptorCapture=new AtomicReference<>();
    StreamingRuntimeContext context=new StreamingRuntimeContext(createDescriptorCapturingMockOp(descriptorCapture,config),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    ValueStateDescriptor<TaskInfo> descr=new ValueStateDescriptor<>("name",TaskInfo.class);
    context.getState(descr);
    StateDescriptor<?,?> descrIntercepted=(StateDescriptor<?,?>)descriptorCapture.get();
    TypeSerializer<?> serializer=descrIntercepted.getSerializer();
    assertTrue(serializer instanceof KryoSerializer);
    assertTrue(((KryoSerializer<?>)serializer).getKryo().getRegistration(Path.class).getId() > 0);
  }
  @Test public void testReducingStateInstantiation() throws Exception {
    final ExecutionConfig config=new ExecutionConfig();
    config.registerKryoType(Path.class);
    final AtomicReference<Object> descriptorCapture=new AtomicReference<>();
    StreamingRuntimeContext context=new StreamingRuntimeContext(createDescriptorCapturingMockOp(descriptorCapture,config),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    @SuppressWarnings("unchecked") ReduceFunction<TaskInfo> reducer=(ReduceFunction<TaskInfo>)mock(ReduceFunction.class);
    ReducingStateDescriptor<TaskInfo> descr=new ReducingStateDescriptor<>("name",reducer,TaskInfo.class);
    context.getReducingState(descr);
    StateDescriptor<?,?> descrIntercepted=(StateDescriptor<?,?>)descriptorCapture.get();
    TypeSerializer<?> serializer=descrIntercepted.getSerializer();
    assertTrue(serializer instanceof KryoSerializer);
    assertTrue(((KryoSerializer<?>)serializer).getKryo().getRegistration(Path.class).getId() > 0);
  }
  @Test public void testAggregatingStateInstantiation() throws Exception {
    final ExecutionConfig config=new ExecutionConfig();
    config.registerKryoType(Path.class);
    final AtomicReference<Object> descriptorCapture=new AtomicReference<>();
    StreamingRuntimeContext context=new StreamingRuntimeContext(createDescriptorCapturingMockOp(descriptorCapture,config),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    @SuppressWarnings("unchecked") AggregateFunction<String,TaskInfo,String> aggregate=(AggregateFunction<String,TaskInfo,String>)mock(AggregateFunction.class);
    AggregatingStateDescriptor<String,TaskInfo,String> descr=new AggregatingStateDescriptor<>("name",aggregate,TaskInfo.class);
    context.getAggregatingState(descr);
    AggregatingStateDescriptor<?,?,?> descrIntercepted=(AggregatingStateDescriptor<?,?,?>)descriptorCapture.get();
    TypeSerializer<?> serializer=descrIntercepted.getSerializer();
    assertTrue(serializer instanceof KryoSerializer);
    assertTrue(((KryoSerializer<?>)serializer).getKryo().getRegistration(Path.class).getId() > 0);
  }
  @Test public void testFoldingStateInstantiation() throws Exception {
    final ExecutionConfig config=new ExecutionConfig();
    config.registerKryoType(Path.class);
    final AtomicReference<Object> descriptorCapture=new AtomicReference<>();
    StreamingRuntimeContext context=new StreamingRuntimeContext(createDescriptorCapturingMockOp(descriptorCapture,config),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    @SuppressWarnings("unchecked") FoldFunction<String,TaskInfo> folder=(FoldFunction<String,TaskInfo>)mock(FoldFunction.class);
    FoldingStateDescriptor<String,TaskInfo> descr=new FoldingStateDescriptor<>("name",null,folder,TaskInfo.class);
    context.getFoldingState(descr);
    FoldingStateDescriptor<?,?> descrIntercepted=(FoldingStateDescriptor<?,?>)descriptorCapture.get();
    TypeSerializer<?> serializer=descrIntercepted.getSerializer();
    assertTrue(serializer instanceof KryoSerializer);
    assertTrue(((KryoSerializer<?>)serializer).getKryo().getRegistration(Path.class).getId() > 0);
  }
  @Test public void testListStateInstantiation() throws Exception {
    final ExecutionConfig config=new ExecutionConfig();
    config.registerKryoType(Path.class);
    final AtomicReference<Object> descriptorCapture=new AtomicReference<>();
    StreamingRuntimeContext context=new StreamingRuntimeContext(createDescriptorCapturingMockOp(descriptorCapture,config),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    ListStateDescriptor<TaskInfo> descr=new ListStateDescriptor<>("name",TaskInfo.class);
    context.getListState(descr);
    ListStateDescriptor<?> descrIntercepted=(ListStateDescriptor<?>)descriptorCapture.get();
    TypeSerializer<?> serializer=descrIntercepted.getSerializer();
    assertTrue(serializer instanceof ListSerializer);
    TypeSerializer<?> elementSerializer=descrIntercepted.getElementSerializer();
    assertTrue(elementSerializer instanceof KryoSerializer);
    assertTrue(((KryoSerializer<?>)elementSerializer).getKryo().getRegistration(Path.class).getId() > 0);
  }
  @Test public void testListStateReturnsEmptyListByDefault() throws Exception {
    StreamingRuntimeContext context=new StreamingRuntimeContext(createListPlainMockOp(),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    ListStateDescriptor<String> descr=new ListStateDescriptor<>("name",String.class);
    ListState<String> state=context.getListState(descr);
    Iterable<String> value=state.get();
    assertNotNull(value);
    assertFalse(value.iterator().hasNext());
  }
  @Test public void testMapStateInstantiation() throws Exception {
    final ExecutionConfig config=new ExecutionConfig();
    config.registerKryoType(Path.class);
    final AtomicReference<Object> descriptorCapture=new AtomicReference<>();
    StreamingRuntimeContext context=new StreamingRuntimeContext(createDescriptorCapturingMockOp(descriptorCapture,config),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    MapStateDescriptor<String,TaskInfo> descr=new MapStateDescriptor<>("name",String.class,TaskInfo.class);
    context.getMapState(descr);
    MapStateDescriptor<?,?> descrIntercepted=(MapStateDescriptor<?,?>)descriptorCapture.get();
    TypeSerializer<?> valueSerializer=descrIntercepted.getValueSerializer();
    assertTrue(valueSerializer instanceof KryoSerializer);
    assertTrue(((KryoSerializer<?>)valueSerializer).getKryo().getRegistration(Path.class).getId() > 0);
  }
  @Test public void testMapStateReturnsEmptyMapByDefault() throws Exception {
    StreamingRuntimeContext context=new StreamingRuntimeContext(createMapPlainMockOp(),createMockEnvironment(),Collections.<String,Accumulator<?,?>>emptyMap());
    MapStateDescriptor<Integer,String> descr=new MapStateDescriptor<>("name",Integer.class,String.class);
    MapState<Integer,String> state=context.getMapState(descr);
    Iterable<Map.Entry<Integer,String>> value=state.entries();
    assertNotNull(value);
    assertFalse(value.iterator().hasNext());
  }
  @SuppressWarnings("unchecked") private static AbstractStreamOperator<?> createDescriptorCapturingMockOp(  final AtomicReference<Object> ref,  final ExecutionConfig config) throws Exception {
    AbstractStreamOperator<?> operatorMock=mock(AbstractStreamOperator.class);
    KeyedStateBackend keyedStateBackend=mock(KeyedStateBackend.class);
    DefaultKeyedStateStore keyedStateStore=new DefaultKeyedStateStore(keyedStateBackend,config);
    when(operatorMock.getExecutionConfig()).thenReturn(config);
    doAnswer(new Answer<Object>(){
      @Override public Object answer(      InvocationOnMock invocationOnMock) throws Throwable {
        ref.set(invocationOnMock.getArguments()[2]);
        return null;
      }
    }
).when(keyedStateBackend).getPartitionedState(Matchers.any(),any(TypeSerializer.class),any(StateDescriptor.class));
    when(operatorMock.getKeyedStateStore()).thenReturn(keyedStateStore);
    when(operatorMock.getOperatorID()).thenReturn(new OperatorID());
    return operatorMock;
  }
  @SuppressWarnings("unchecked") private static AbstractStreamOperator<?> createListPlainMockOp() throws Exception {
    AbstractStreamOperator<?> operatorMock=mock(AbstractStreamOperator.class);
    ExecutionConfig config=new ExecutionConfig();
    KeyedStateBackend keyedStateBackend=mock(KeyedStateBackend.class);
    DefaultKeyedStateStore keyedStateStore=new DefaultKeyedStateStore(keyedStateBackend,config);
    when(operatorMock.getExecutionConfig()).thenReturn(config);
    doAnswer(new Answer<ListState<String>>(){
      @Override public ListState<String> answer(      InvocationOnMock invocationOnMock) throws Throwable {
        ListStateDescriptor<String> descr=(ListStateDescriptor<String>)invocationOnMock.getArguments()[2];
        AbstractKeyedStateBackend<Integer> backend=new MemoryStateBackend().createKeyedStateBackend(new DummyEnvironment("test_task",1,0),new JobID(),"test_op",IntSerializer.INSTANCE,1,new KeyGroupRange(0,0),new KvStateRegistry().createTaskRegistry(new JobID(),new JobVertexID()));
        backend.setCurrentKey(0);
        return backend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,descr);
      }
    }
).when(keyedStateBackend).getPartitionedState(Matchers.any(),any(TypeSerializer.class),any(ListStateDescriptor.class));
    when(operatorMock.getKeyedStateStore()).thenReturn(keyedStateStore);
    when(operatorMock.getOperatorID()).thenReturn(new OperatorID());
    return operatorMock;
  }
  @SuppressWarnings("unchecked") private static AbstractStreamOperator<?> createMapPlainMockOp() throws Exception {
    AbstractStreamOperator<?> operatorMock=mock(AbstractStreamOperator.class);
    ExecutionConfig config=new ExecutionConfig();
    KeyedStateBackend keyedStateBackend=mock(KeyedStateBackend.class);
    DefaultKeyedStateStore keyedStateStore=new DefaultKeyedStateStore(keyedStateBackend,config);
    when(operatorMock.getExecutionConfig()).thenReturn(config);
    doAnswer(new Answer<MapState<Integer,String>>(){
      @Override public MapState<Integer,String> answer(      InvocationOnMock invocationOnMock) throws Throwable {
        MapStateDescriptor<Integer,String> descr=(MapStateDescriptor<Integer,String>)invocationOnMock.getArguments()[2];
        AbstractKeyedStateBackend<Integer> backend=new MemoryStateBackend().createKeyedStateBackend(new DummyEnvironment("test_task",1,0),new JobID(),"test_op",IntSerializer.INSTANCE,1,new KeyGroupRange(0,0),new KvStateRegistry().createTaskRegistry(new JobID(),new JobVertexID()));
        backend.setCurrentKey(0);
        return backend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,descr);
      }
    }
).when(keyedStateBackend).getPartitionedState(Matchers.any(),any(TypeSerializer.class),any(MapStateDescriptor.class));
    when(operatorMock.getKeyedStateStore()).thenReturn(keyedStateStore);
    when(operatorMock.getOperatorID()).thenReturn(new OperatorID());
    return operatorMock;
  }
  private static Environment createMockEnvironment(){
    return MockEnvironment.builder().setTaskName("test task").build();
  }
}
