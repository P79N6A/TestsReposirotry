/** 
 * Test source producing (key, 0)..(key, maxValue) with key being the sub task index. <p>After all tuples have been emitted, the source waits to be cancelled and does not immediately finish.
 */
private static class TestAscendingValueSource extends RichParallelSourceFunction<Tuple2<Integer,Long>> {
  private static final long serialVersionUID=1459935229498173245L;
  private final long maxValue;
  private volatile boolean isRunning=true;
  TestAscendingValueSource(  long maxValue){
    Preconditions.checkArgument(maxValue >= 0);
    this.maxValue=maxValue;
  }
  @Override public void open(  Configuration parameters) throws Exception {
    super.open(parameters);
  }
  @Override public void run(  SourceContext<Tuple2<Integer,Long>> ctx) throws Exception {
    int key=getRuntimeContext().getIndexOfThisSubtask();
    Tuple2<Integer,Long> record=new Tuple2<>(key,0L);
    long currentValue=0;
    while (isRunning && currentValue <= maxValue) {
synchronized (ctx.getCheckpointLock()) {
        record.f1=currentValue;
        ctx.collect(record);
      }
      currentValue++;
    }
    while (isRunning) {
synchronized (this) {
        wait();
      }
    }
  }
  @Override public void cancel(){
    isRunning=false;
synchronized (this) {
      notifyAll();
    }
  }
}
