/** 
 * Source for window checkpointing IT cases that can introduce artificial failures.
 */
public class FailingSource extends RichSourceFunction<Tuple2<Long,IntType>> implements ListCheckpointed<Integer>, CheckpointListener {
  /** 
 * Function to generate and emit the test events (and watermarks if required).
 */
@FunctionalInterface public interface EventEmittingGenerator extends Serializable {
    void emitEvent(    SourceContext<Tuple2<Long,IntType>> ctx,    int eventSequenceNo);
  }
  private static final long INITIAL=Long.MIN_VALUE;
  private static final long STATEFUL_CHECKPOINT_COMPLETED=Long.MIN_VALUE;
  @Nonnull private final EventEmittingGenerator eventEmittingGenerator;
  private final int expectedEmitCalls;
  private final int failureAfterNumElements;
  private final boolean usingProcessingTime;
  private final AtomicLong checkpointStatus;
  private int emitCallCount;
  private volatile boolean running;
  public FailingSource(  @Nonnull EventEmittingGenerator eventEmittingGenerator,  @Nonnegative int numberOfGeneratorInvocations){
    this(eventEmittingGenerator,numberOfGeneratorInvocations,TimeCharacteristic.EventTime);
  }
  public FailingSource(  @Nonnull EventEmittingGenerator eventEmittingGenerator,  @Nonnegative int numberOfGeneratorInvocations,  @Nonnull TimeCharacteristic timeCharacteristic){
    this.eventEmittingGenerator=eventEmittingGenerator;
    this.running=true;
    this.emitCallCount=0;
    this.expectedEmitCalls=numberOfGeneratorInvocations;
    this.failureAfterNumElements=numberOfGeneratorInvocations / 2;
    this.checkpointStatus=new AtomicLong(INITIAL);
    this.usingProcessingTime=timeCharacteristic == TimeCharacteristic.ProcessingTime;
  }
  @Override public void open(  Configuration parameters){
    assertEquals(1,getRuntimeContext().getNumberOfParallelSubtasks());
  }
  @Override public void run(  SourceContext<Tuple2<Long,IntType>> ctx) throws Exception {
    final RuntimeContext runtimeContext=getRuntimeContext();
    final boolean failThisTask=runtimeContext.getAttemptNumber() == 0 && runtimeContext.getIndexOfThisSubtask() == 0;
    while (running && emitCallCount < expectedEmitCalls) {
synchronized (ctx.getCheckpointLock()) {
        eventEmittingGenerator.emitEvent(ctx,emitCallCount++);
      }
      if (emitCallCount < failureAfterNumElements) {
        Thread.sleep(1);
      }
 else       if (failThisTask && emitCallCount == failureAfterNumElements) {
        while (checkpointStatus.get() != STATEFUL_CHECKPOINT_COMPLETED) {
          Thread.sleep(1);
        }
        throw new Exception("Artificial Failure");
      }
    }
    if (usingProcessingTime) {
      while (running) {
        Thread.sleep(10);
      }
    }
  }
  @Override public void cancel(){
    running=false;
  }
  @Override public void notifyCheckpointComplete(  long checkpointId){
    checkpointStatus.compareAndSet(checkpointId,STATEFUL_CHECKPOINT_COMPLETED);
  }
  @Override public List<Integer> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    if (emitCallCount > failureAfterNumElements / 2) {
      checkpointStatus.compareAndSet(INITIAL,checkpointId);
    }
    return Collections.singletonList(this.emitCallCount);
  }
  @Override public void restoreState(  List<Integer> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.emitCallCount=state.get(0);
  }
}
