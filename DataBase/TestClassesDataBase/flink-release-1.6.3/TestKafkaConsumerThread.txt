/** 
 * A testable  {@link KafkaConsumerThread} that injects multiple latches exactly before and afterpartition reassignment, so that tests are eligible to setup various conditions before the reassignment happens and inspect reassignment results after it is completed.
 */
private static class TestKafkaConsumerThread extends KafkaConsumerThread {
  private final KafkaConsumer<byte[],byte[]> mockConsumer;
  private final MultiShotLatch preReassignmentLatch=new MultiShotLatch();
  private final MultiShotLatch startReassignmentLatch=new MultiShotLatch();
  private final MultiShotLatch reassignmentCompleteLatch=new MultiShotLatch();
  private final MultiShotLatch postReassignmentLatch=new MultiShotLatch();
  public TestKafkaConsumerThread(  KafkaConsumer<byte[],byte[]> mockConsumer,  ClosableBlockingQueue<KafkaTopicPartitionState<TopicPartition>> unassignedPartitionsQueue,  Handover handover){
    super(mock(Logger.class),handover,new Properties(),unassignedPartitionsQueue,new KafkaConsumerCallBridge(),"test-kafka-consumer-thread",0,false,new UnregisteredMetricsGroup(),new UnregisteredMetricsGroup());
    this.mockConsumer=mockConsumer;
  }
  public void waitPartitionReassignmentInvoked() throws InterruptedException {
    preReassignmentLatch.await();
  }
  public void startPartitionReassignment(){
    startReassignmentLatch.trigger();
  }
  public void waitPartitionReassignmentComplete() throws InterruptedException {
    reassignmentCompleteLatch.await();
  }
  public void endPartitionReassignment(){
    postReassignmentLatch.trigger();
  }
  @Override KafkaConsumer<byte[],byte[]> getConsumer(  Properties kafkaProperties){
    return mockConsumer;
  }
  @Override void reassignPartitions(  List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {
    preReassignmentLatch.trigger();
    startReassignmentLatch.await();
    try {
      super.reassignPartitions(newPartitions);
    }
  finally {
      reassignmentCompleteLatch.trigger();
      postReassignmentLatch.await();
    }
  }
}
