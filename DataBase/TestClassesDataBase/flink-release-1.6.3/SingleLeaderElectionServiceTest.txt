/** 
 * Tests for the  {@link SingleLeaderElectionService}.
 */
public class SingleLeaderElectionServiceTest {
  private static final Random RND=new Random();
  private final Executor executor=Executors.directExecutor();
  @Test public void testStartStopAssignLeadership() throws Exception {
    final UUID uuid=UUID.randomUUID();
    final SingleLeaderElectionService service=new SingleLeaderElectionService(executor,uuid);
    final LeaderContender contender=mockContender(service);
    final LeaderContender otherContender=mockContender(service);
    service.start(contender);
    verify(contender,times(1)).grantLeadership(uuid);
    service.stop();
    verify(contender,times(1)).revokeLeadership();
    service.start(otherContender);
    verify(otherContender,times(1)).grantLeadership(uuid);
    verify(contender,times(1)).grantLeadership(uuid);
    verify(contender,times(1)).revokeLeadership();
  }
  @Test public void testStopBeforeConfirmingLeadership() throws Exception {
    final UUID uuid=UUID.randomUUID();
    final SingleLeaderElectionService service=new SingleLeaderElectionService(executor,uuid);
    final LeaderContender contender=mock(LeaderContender.class);
    service.start(contender);
    verify(contender,times(1)).grantLeadership(uuid);
    service.stop();
    verifyNoMoreInteractions(contender);
  }
  @Test public void testStartOnlyOnce() throws Exception {
    final UUID uuid=UUID.randomUUID();
    final SingleLeaderElectionService service=new SingleLeaderElectionService(executor,uuid);
    final LeaderContender contender=mock(LeaderContender.class);
    final LeaderContender otherContender=mock(LeaderContender.class);
    service.start(contender);
    verify(contender,times(1)).grantLeadership(uuid);
    try {
      service.start(otherContender);
      fail("should fail with an exception");
    }
 catch (    IllegalStateException e) {
    }
    try {
      service.start(contender);
      fail("should fail with an exception");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void testShutdown() throws Exception {
    final UUID uuid=UUID.randomUUID();
    final SingleLeaderElectionService service=new SingleLeaderElectionService(executor,uuid);
    final LeaderContender contender=mockContender(service);
    service.start(contender);
    verify(contender,times(1)).grantLeadership(uuid);
    final LeaderRetrievalListener listener1=mock(LeaderRetrievalListener.class);
    final LeaderRetrievalListener listener2=mock(LeaderRetrievalListener.class);
    LeaderRetrievalService listenerService1=service.createLeaderRetrievalService();
    LeaderRetrievalService listenerService2=service.createLeaderRetrievalService();
    listenerService1.start(listener1);
    listenerService2.start(listener2);
    listenerService1.stop();
    service.shutdown();
    verify(contender,times(1)).handleError(any(Exception.class));
    verify(listener2,times(1)).handleError(any(Exception.class));
    verify(listener1,times(0)).handleError(any(Exception.class));
    try {
      service.start(contender);
      fail("should fail with an exception");
    }
 catch (    IllegalStateException e) {
    }
    verify(contender,times(1)).grantLeadership(any(UUID.class));
  }
  @Test public void testImmediateShutdown() throws Exception {
    final UUID uuid=UUID.randomUUID();
    final SingleLeaderElectionService service=new SingleLeaderElectionService(executor,uuid);
    service.shutdown();
    final LeaderContender contender=mock(LeaderContender.class);
    try {
      service.start(contender);
      fail("should fail with an exception");
    }
 catch (    IllegalStateException e) {
    }
    verify(contender,times(0)).grantLeadership(any(UUID.class));
  }
  private static LeaderContender mockContender(  final LeaderElectionService service){
    String address=StringUtils.getRandomString(RND,5,10,'a','z');
    return mockContender(service,address);
  }
  private static LeaderContender mockContender(  final LeaderElectionService service,  final String address){
    LeaderContender mockContender=mock(LeaderContender.class);
    when(mockContender.getAddress()).thenReturn(address);
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        final UUID uuid=(UUID)invocation.getArguments()[0];
        service.confirmLeaderSessionID(uuid);
        return null;
      }
    }
).when(mockContender).grantLeadership(any(UUID.class));
    return mockContender;
  }
}
