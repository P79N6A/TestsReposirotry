public class TaskLocalStateStoreImplTest {
  private SortedMap<Long,TaskStateSnapshot> internalSnapshotMap;
  private Object internalLock;
  private TemporaryFolder temporaryFolder;
  private File[] allocationBaseDirs;
  private TaskLocalStateStoreImpl taskLocalStateStore;
  @Before public void before() throws Exception {
    JobID jobID=new JobID();
    AllocationID allocationID=new AllocationID();
    JobVertexID jobVertexID=new JobVertexID();
    int subtaskIdx=0;
    this.temporaryFolder=new TemporaryFolder();
    this.temporaryFolder.create();
    this.allocationBaseDirs=new File[]{temporaryFolder.newFolder(),temporaryFolder.newFolder()};
    this.internalSnapshotMap=new TreeMap<>();
    this.internalLock=new Object();
    LocalRecoveryDirectoryProviderImpl directoryProvider=new LocalRecoveryDirectoryProviderImpl(allocationBaseDirs,jobID,jobVertexID,subtaskIdx);
    LocalRecoveryConfig localRecoveryConfig=new LocalRecoveryConfig(false,directoryProvider);
    this.taskLocalStateStore=new TaskLocalStateStoreImpl(jobID,allocationID,jobVertexID,subtaskIdx,localRecoveryConfig,Executors.directExecutor(),internalSnapshotMap,internalLock);
  }
  @After public void after(){
    this.temporaryFolder.delete();
  }
  /** 
 * Test that the instance delivers a correctly configured LocalRecoveryDirectoryProvider.
 */
  @Test public void getLocalRecoveryRootDirectoryProvider(){
    LocalRecoveryConfig directoryProvider=taskLocalStateStore.getLocalRecoveryConfig();
    Assert.assertEquals(allocationBaseDirs.length,directoryProvider.getLocalStateDirectoryProvider().allocationBaseDirsCount());
    for (int i=0; i < allocationBaseDirs.length; ++i) {
      Assert.assertEquals(allocationBaseDirs[i],directoryProvider.getLocalStateDirectoryProvider().selectAllocationBaseDirectory(i));
    }
  }
  /** 
 * Tests basic store/retrieve of local state.
 */
  @Test public void storeAndRetrieve() throws Exception {
    final int chkCount=3;
    for (int i=0; i < chkCount; ++i) {
      Assert.assertNull(taskLocalStateStore.retrieveLocalState(i));
    }
    List<TaskStateSnapshot> taskStateSnapshots=storeStates(chkCount);
    checkStoredAsExpected(taskStateSnapshots,0,chkCount);
    Assert.assertNull(taskLocalStateStore.retrieveLocalState(chkCount + 1));
  }
  /** 
 * Test checkpoint pruning.
 */
  @Test public void pruneCheckpoints() throws Exception {
    final int chkCount=3;
    List<TaskStateSnapshot> taskStateSnapshots=storeStates(chkCount);
    taskLocalStateStore.pruneMatchingCheckpoints((    long chk) -> chk != chkCount - 1);
    for (int i=0; i < chkCount - 1; ++i) {
      Assert.assertNull(taskLocalStateStore.retrieveLocalState(i));
    }
    checkStoredAsExpected(taskStateSnapshots,chkCount - 1,chkCount);
  }
  /** 
 * Tests pruning of previous checkpoints if a new checkpoint is confirmed.
 */
  @Test public void confirmCheckpoint() throws Exception {
    final int chkCount=3;
    final int confirmed=chkCount - 1;
    List<TaskStateSnapshot> taskStateSnapshots=storeStates(chkCount);
    taskLocalStateStore.confirmCheckpoint(confirmed);
    checkPrunedAndDiscarded(taskStateSnapshots,0,confirmed);
    checkStoredAsExpected(taskStateSnapshots,confirmed,chkCount);
  }
  /** 
 * Tests that disposal of a  {@link TaskLocalStateStoreImpl} works and discards all local states.
 */
  @Test public void dispose() throws Exception {
    final int chkCount=3;
    final int confirmed=chkCount - 1;
    List<TaskStateSnapshot> taskStateSnapshots=storeStates(chkCount);
    taskLocalStateStore.confirmCheckpoint(confirmed);
    taskLocalStateStore.dispose();
    checkPrunedAndDiscarded(taskStateSnapshots,0,chkCount);
  }
  private void checkStoredAsExpected(  List<TaskStateSnapshot> history,  int off,  int len) throws Exception {
    for (int i=off; i < len; ++i) {
      TaskStateSnapshot expected=history.get(i);
      Assert.assertTrue(expected == taskLocalStateStore.retrieveLocalState(i));
      Mockito.verify(expected,Mockito.never()).discardState();
    }
  }
  private void checkPrunedAndDiscarded(  List<TaskStateSnapshot> history,  int off,  int len) throws Exception {
    for (int i=off; i < len; ++i) {
      Assert.assertNull(taskLocalStateStore.retrieveLocalState(i));
      Mockito.verify(history.get(i)).discardState();
    }
  }
  private List<TaskStateSnapshot> storeStates(  int count){
    List<TaskStateSnapshot> taskStateSnapshots=new ArrayList<>(count);
    for (int i=0; i < count; ++i) {
      OperatorID operatorID=new OperatorID();
      TaskStateSnapshot taskStateSnapshot=spy(new TaskStateSnapshot());
      OperatorSubtaskState operatorSubtaskState=new OperatorSubtaskState();
      taskStateSnapshot.putSubtaskStateByOperatorID(operatorID,operatorSubtaskState);
      taskLocalStateStore.storeLocalState(i,taskStateSnapshot);
      taskStateSnapshots.add(taskStateSnapshot);
    }
    return taskStateSnapshots;
  }
}
