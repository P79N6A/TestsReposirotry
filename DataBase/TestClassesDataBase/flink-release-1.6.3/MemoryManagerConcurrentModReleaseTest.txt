/** 
 * Validate memory release under concurrent modification exceptions.
 */
public class MemoryManagerConcurrentModReleaseTest {
  @Test public void testConcurrentModificationOnce(){
    try {
      final int numSegments=10000;
      final int segmentSize=4096;
      MemoryManager memMan=new MemoryManager(numSegments * segmentSize,1,segmentSize,MemoryType.HEAP,true);
      ArrayList<MemorySegment> segs=new ListWithConcModExceptionOnFirstAccess<>();
      memMan.allocatePages(this,segs,numSegments);
      memMan.release(segs);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testConcurrentModificationWhileReleasing(){
    try {
      final int numSegments=10000;
      final int segmentSize=4096;
      MemoryManager memMan=new MemoryManager(numSegments * segmentSize,1,segmentSize,MemoryType.HEAP,true);
      ArrayList<MemorySegment> segs=new ArrayList<>(numSegments);
      memMan.allocatePages(this,segs,numSegments);
      Modifier mod=new Modifier(segs);
      Thread modRunner=new Thread(mod);
      modRunner.start();
      Thread.sleep(500);
      try {
        memMan.release(segs);
      }
  finally {
        mod.cancel();
      }
      modRunner.join();
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
private class Modifier implements Runnable {
    private final ArrayList<MemorySegment> toModify;
    private volatile boolean running=true;
    private Modifier(    ArrayList<MemorySegment> toModify){
      this.toModify=toModify;
    }
    public void cancel(){
      running=false;
    }
    @Override public void run(){
      while (running) {
        try {
          MemorySegment seg=toModify.remove(0);
          toModify.add(seg);
        }
 catch (        IndexOutOfBoundsException e) {
        }
      }
    }
  }
private class ListWithConcModExceptionOnFirstAccess<E> extends ArrayList<E> {
    private static final long serialVersionUID=-1623249699823349781L;
    private boolean returnedIterator;
    @Override public Iterator<E> iterator(){
      if (returnedIterator) {
        return super.iterator();
      }
 else {
        returnedIterator=true;
        return new ConcFailingIterator<>();
      }
    }
  }
private class ConcFailingIterator<E> implements Iterator<E> {
    @Override public boolean hasNext(){
      return true;
    }
    @Override public E next(){
      throw new ConcurrentModificationException();
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
}
