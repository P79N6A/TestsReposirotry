@RunWith(PowerMockRunner.class) @PrepareForTest(PendingCheckpoint.class) public class CheckpointCoordinatorFailureTest extends TestLogger {
  /** 
 * Tests that a failure while storing a completed checkpoint in the completed checkpoint store will properly fail the originating pending checkpoint and clean upt the completed checkpoint.
 */
  @Test public void testFailingCompletedCheckpointStoreAdd() throws Exception {
    JobID jid=new JobID();
    final ExecutionAttemptID executionAttemptId=new ExecutionAttemptID();
    final ExecutionVertex vertex=CheckpointCoordinatorTest.mockExecutionVertex(executionAttemptId);
    final long triggerTimestamp=1L;
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex},new ExecutionVertex[]{vertex},new ExecutionVertex[]{vertex},new StandaloneCheckpointIDCounter(),new FailingCompletedCheckpointStore(),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    coord.triggerCheckpoint(triggerTimestamp,false);
    assertEquals(1,coord.getNumberOfPendingCheckpoints());
    PendingCheckpoint pendingCheckpoint=coord.getPendingCheckpoints().values().iterator().next();
    assertFalse(pendingCheckpoint.isDiscarded());
    final long checkpointId=coord.getPendingCheckpoints().keySet().iterator().next();
    KeyedStateHandle managedKeyedHandle=mock(KeyedStateHandle.class);
    KeyedStateHandle rawKeyedHandle=mock(KeyedStateHandle.class);
    OperatorStateHandle managedOpHandle=mock(OperatorStreamStateHandle.class);
    OperatorStateHandle rawOpHandle=mock(OperatorStreamStateHandle.class);
    final OperatorSubtaskState operatorSubtaskState=spy(new OperatorSubtaskState(managedOpHandle,rawOpHandle,managedKeyedHandle,rawKeyedHandle));
    TaskStateSnapshot subtaskState=spy(new TaskStateSnapshot());
    subtaskState.putSubtaskStateByOperatorID(new OperatorID(),operatorSubtaskState);
    when(subtaskState.getSubtaskStateByOperatorID(OperatorID.fromJobVertexID(vertex.getJobvertexId()))).thenReturn(operatorSubtaskState);
    AcknowledgeCheckpoint acknowledgeMessage=new AcknowledgeCheckpoint(jid,executionAttemptId,checkpointId,new CheckpointMetrics(),subtaskState);
    try {
      coord.receiveAcknowledgeMessage(acknowledgeMessage);
      fail("Expected a checkpoint exception because the completed checkpoint store could not " + "store the completed checkpoint.");
    }
 catch (    CheckpointException e) {
    }
    assertTrue(pendingCheckpoint.isDiscarded());
    verify(operatorSubtaskState).discardState();
    verify(operatorSubtaskState.getManagedOperatorState().iterator().next()).discardState();
    verify(operatorSubtaskState.getRawOperatorState().iterator().next()).discardState();
    verify(operatorSubtaskState.getManagedKeyedState().iterator().next()).discardState();
    verify(operatorSubtaskState.getRawKeyedState().iterator().next()).discardState();
  }
private static final class FailingCompletedCheckpointStore implements CompletedCheckpointStore {
    @Override public void recover() throws Exception {
      throw new UnsupportedOperationException("Not implemented.");
    }
    @Override public void addCheckpoint(    CompletedCheckpoint checkpoint) throws Exception {
      throw new Exception("The failing completed checkpoint store failed again... :-(");
    }
    @Override public CompletedCheckpoint getLatestCheckpoint() throws Exception {
      throw new UnsupportedOperationException("Not implemented.");
    }
    @Override public void shutdown(    JobStatus jobStatus) throws Exception {
      throw new UnsupportedOperationException("Not implemented.");
    }
    @Override public List<CompletedCheckpoint> getAllCheckpoints() throws Exception {
      throw new UnsupportedOperationException("Not implemented.");
    }
    @Override public int getNumberOfRetainedCheckpoints(){
      return -1;
    }
    @Override public int getMaxNumberOfRetainedCheckpoints(){
      return 1;
    }
    @Override public boolean requiresExternalizedCheckpoints(){
      return false;
    }
  }
}
