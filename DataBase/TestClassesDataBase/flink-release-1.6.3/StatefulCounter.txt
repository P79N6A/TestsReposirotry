private static class StatefulCounter extends RichMapFunction<Integer,Integer> implements ListCheckpointed<byte[]> {
  private static volatile CountDownLatch progressLatch=new CountDownLatch(0);
  private static volatile CountDownLatch restoreLatch=new CountDownLatch(0);
  private int numCollectedElements=0;
  private static final long serialVersionUID=7317800376639115920L;
  private byte[] data;
  @Override public void open(  Configuration parameters) throws Exception {
    if (data == null) {
      Random rand=new Random(getRuntimeContext().getIndexOfThisSubtask());
      data=new byte[CheckpointingOptions.FS_SMALL_FILE_THRESHOLD.defaultValue() + 1];
      rand.nextBytes(data);
    }
  }
  @Override public Integer map(  Integer value) throws Exception {
    for (int i=0; i < data.length; i++) {
      data[i]+=1;
    }
    if (numCollectedElements++ > 10) {
      progressLatch.countDown();
    }
    return value;
  }
  @Override public List<byte[]> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(data);
  }
  @Override public void restoreState(  List<byte[]> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.data=state.get(0);
    restoreLatch.countDown();
  }
  static CountDownLatch getProgressLatch(){
    return progressLatch;
  }
  static CountDownLatch getRestoreLatch(){
    return restoreLatch;
  }
  static void resetForTest(  int parallelism){
    progressLatch=new CountDownLatch(parallelism);
    restoreLatch=new CountDownLatch(parallelism);
  }
}
