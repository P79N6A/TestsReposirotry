public static class CheckpointsInOrderInvokable extends AbstractInvokable {
  private volatile long lastCheckpointId=0;
  private volatile Exception error;
  public CheckpointsInOrderInvokable(  Environment environment){
    super(environment);
  }
  @Override public void invoke() throws Exception {
    awaitLatch.trigger();
synchronized (this) {
      while (error == null) {
        wait();
      }
    }
    if (error != null) {
      triggerLatch.trigger();
      notifyCheckpointCompleteLatch.trigger();
      stopLatch.trigger();
      throw error;
    }
  }
  @Override public boolean triggerCheckpoint(  CheckpointMetaData checkpointMetaData,  CheckpointOptions checkpointOptions){
    lastCheckpointId++;
    if (checkpointMetaData.getCheckpointId() == lastCheckpointId) {
      if (lastCheckpointId == numCalls) {
        triggerLatch.trigger();
      }
    }
 else     if (this.error == null) {
      this.error=new Exception("calls out of order");
synchronized (this) {
        notifyAll();
      }
    }
    return true;
  }
  @Override public void triggerCheckpointOnBarrier(  CheckpointMetaData checkpointMetaData,  CheckpointOptions checkpointOptions,  CheckpointMetrics checkpointMetrics) throws Exception {
    throw new UnsupportedOperationException("Should not be called");
  }
  @Override public void abortCheckpointOnBarrier(  long checkpointId,  Throwable cause){
    throw new UnsupportedOperationException("Should not be called");
  }
  @Override public void notifyCheckpointComplete(  long checkpointId){
    if (checkpointId != lastCheckpointId && this.error == null) {
      this.error=new Exception("calls out of order");
synchronized (this) {
        notifyAll();
      }
    }
 else     if (lastCheckpointId == numCalls) {
      notifyCheckpointCompleteLatch.trigger();
    }
  }
}
