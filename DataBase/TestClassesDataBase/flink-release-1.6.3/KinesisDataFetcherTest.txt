/** 
 * Tests for the  {@link KinesisDataFetcher}.
 */
public class KinesisDataFetcherTest extends TestLogger {
  @Test(expected=RuntimeException.class) public void testIfNoShardsAreFoundShouldThrowException() throws Exception {
    List<String> fakeStreams=new LinkedList<>();
    fakeStreams.add("fakeStream1");
    fakeStreams.add("fakeStream2");
    HashMap<String,String> subscribedStreamsToLastSeenShardIdsUnderTest=KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams);
    TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(fakeStreams,new TestSourceContext<>(),TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),10,2,new AtomicReference<>(),new LinkedList<>(),subscribedStreamsToLastSeenShardIdsUnderTest,FakeKinesisBehavioursFactory.noShardsFoundForRequestedStreamsBehaviour());
    fetcher.runFetcher();
  }
  @Test public void testSkipCorruptedRecord() throws Exception {
    final String stream="fakeStream";
    final int numShards=3;
    final LinkedList<KinesisStreamShardState> testShardStates=new LinkedList<>();
    final TestSourceContext<String> sourceContext=new TestSourceContext<>();
    final TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(Collections.singletonList(stream),sourceContext,TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),1,0,new AtomicReference<>(),testShardStates,new HashMap<>(),FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(Collections.singletonMap(stream,numShards)));
    final DummyFlinkKinesisConsumer<String> consumer=new DummyFlinkKinesisConsumer<>(TestUtils.getStandardProperties(),fetcher,1,0);
    CheckedThread consumerThread=new CheckedThread(){
      @Override public void go() throws Exception {
        consumer.run(new TestSourceContext<>());
      }
    }
;
    consumerThread.start();
    fetcher.waitUntilRun();
    consumer.cancel();
    consumerThread.sync();
    assertEquals(numShards,testShardStates.size());
    for (int i=0; i < numShards; i++) {
      fetcher.emitRecordAndUpdateState("record-" + i,10L,i,new SequenceNumber("seq-num-1"));
      assertEquals(new SequenceNumber("seq-num-1"),testShardStates.get(i).getLastProcessedSequenceNum());
      assertEquals(new StreamRecord<>("record-" + i,10L),sourceContext.removeLatestOutput());
    }
    fetcher.emitRecordAndUpdateState(null,10L,1,new SequenceNumber("seq-num-2"));
    assertEquals(new SequenceNumber("seq-num-2"),testShardStates.get(1).getLastProcessedSequenceNum());
    assertEquals(null,sourceContext.removeLatestOutput());
  }
  @Test public void testStreamToLastSeenShardStateIsCorrectlySetWhenNotRestoringFromFailure() throws Exception {
    List<String> fakeStreams=new LinkedList<>();
    fakeStreams.add("fakeStream1");
    fakeStreams.add("fakeStream2");
    fakeStreams.add("fakeStream3");
    fakeStreams.add("fakeStream4");
    HashMap<String,String> subscribedStreamsToLastSeenShardIdsUnderTest=KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams);
    Map<String,Integer> streamToShardCount=new HashMap<>();
    Random rand=new Random();
    for (    String fakeStream : fakeStreams) {
      streamToShardCount.put(fakeStream,rand.nextInt(5) + 1);
    }
    final TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(fakeStreams,new TestSourceContext<>(),TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),10,2,new AtomicReference<>(),new LinkedList<>(),subscribedStreamsToLastSeenShardIdsUnderTest,FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(streamToShardCount));
    final DummyFlinkKinesisConsumer<String> consumer=new DummyFlinkKinesisConsumer<>(TestUtils.getStandardProperties(),fetcher,1,0);
    CheckedThread consumerThread=new CheckedThread(){
      @Override public void go() throws Exception {
        consumer.run(new TestSourceContext<>());
      }
    }
;
    consumerThread.start();
    fetcher.waitUntilRun();
    consumer.cancel();
    consumerThread.sync();
    Set<String> streamsInState=subscribedStreamsToLastSeenShardIdsUnderTest.keySet();
    assertEquals(fakeStreams.size(),streamsInState.size());
    assertTrue(streamsInState.containsAll(fakeStreams));
    for (    Map.Entry<String,String> streamToLastSeenShard : subscribedStreamsToLastSeenShardIdsUnderTest.entrySet()) {
      assertEquals(KinesisShardIdGenerator.generateFromShardOrder(streamToShardCount.get(streamToLastSeenShard.getKey()) - 1),streamToLastSeenShard.getValue());
    }
  }
  @Test public void testStreamToLastSeenShardStateIsCorrectlySetWhenNoNewShardsSinceRestoredCheckpoint() throws Exception {
    List<String> fakeStreams=new LinkedList<>();
    fakeStreams.add("fakeStream1");
    fakeStreams.add("fakeStream2");
    Map<StreamShardHandle,String> restoredStateUnderTest=new HashMap<>();
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    Map<String,Integer> streamToShardCount=new HashMap<>();
    streamToShardCount.put("fakeStream1",3);
    streamToShardCount.put("fakeStream2",2);
    HashMap<String,String> subscribedStreamsToLastSeenShardIdsUnderTest=KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams);
    final TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(fakeStreams,new TestSourceContext<>(),TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),10,2,new AtomicReference<>(),new LinkedList<>(),subscribedStreamsToLastSeenShardIdsUnderTest,FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(streamToShardCount));
    for (    Map.Entry<StreamShardHandle,String> restoredState : restoredStateUnderTest.entrySet()) {
      fetcher.advanceLastDiscoveredShardOfStream(restoredState.getKey().getStreamName(),restoredState.getKey().getShard().getShardId());
      fetcher.registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredState.getKey()),restoredState.getKey(),new SequenceNumber(restoredState.getValue())));
    }
    CheckedThread runFetcherThread=new CheckedThread(){
      @Override public void go() throws Exception {
        fetcher.runFetcher();
      }
    }
;
    runFetcherThread.start();
    fetcher.waitUntilInitialDiscovery();
    fetcher.shutdownFetcher();
    runFetcherThread.sync();
    Set<String> streamsInState=subscribedStreamsToLastSeenShardIdsUnderTest.keySet();
    assertEquals(fakeStreams.size(),streamsInState.size());
    assertTrue(streamsInState.containsAll(fakeStreams));
    for (    Map.Entry<String,String> streamToLastSeenShard : subscribedStreamsToLastSeenShardIdsUnderTest.entrySet()) {
      assertEquals(KinesisShardIdGenerator.generateFromShardOrder(streamToShardCount.get(streamToLastSeenShard.getKey()) - 1),streamToLastSeenShard.getValue());
    }
  }
  @Test public void testStreamToLastSeenShardStateIsCorrectlySetWhenNewShardsFoundSinceRestoredCheckpoint() throws Exception {
    List<String> fakeStreams=new LinkedList<>();
    fakeStreams.add("fakeStream1");
    fakeStreams.add("fakeStream2");
    Map<StreamShardHandle,String> restoredStateUnderTest=new HashMap<>();
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    Map<String,Integer> streamToShardCount=new HashMap<>();
    streamToShardCount.put("fakeStream1",3 + 1);
    streamToShardCount.put("fakeStream2",2 + 3);
    HashMap<String,String> subscribedStreamsToLastSeenShardIdsUnderTest=KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams);
    final TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(fakeStreams,new TestSourceContext<>(),TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),10,2,new AtomicReference<>(),new LinkedList<>(),subscribedStreamsToLastSeenShardIdsUnderTest,FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(streamToShardCount));
    for (    Map.Entry<StreamShardHandle,String> restoredState : restoredStateUnderTest.entrySet()) {
      fetcher.advanceLastDiscoveredShardOfStream(restoredState.getKey().getStreamName(),restoredState.getKey().getShard().getShardId());
      fetcher.registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredState.getKey()),restoredState.getKey(),new SequenceNumber(restoredState.getValue())));
    }
    CheckedThread runFetcherThread=new CheckedThread(){
      @Override public void go() throws Exception {
        fetcher.runFetcher();
      }
    }
;
    runFetcherThread.start();
    fetcher.waitUntilInitialDiscovery();
    fetcher.shutdownFetcher();
    runFetcherThread.sync();
    Set<String> streamsInState=subscribedStreamsToLastSeenShardIdsUnderTest.keySet();
    assertEquals(fakeStreams.size(),streamsInState.size());
    assertTrue(streamsInState.containsAll(fakeStreams));
    for (    Map.Entry<String,String> streamToLastSeenShard : subscribedStreamsToLastSeenShardIdsUnderTest.entrySet()) {
      assertEquals(KinesisShardIdGenerator.generateFromShardOrder(streamToShardCount.get(streamToLastSeenShard.getKey()) - 1),streamToLastSeenShard.getValue());
    }
  }
  @Test public void testStreamToLastSeenShardStateIsCorrectlySetWhenNoNewShardsSinceRestoredCheckpointAndSomeStreamsDoNotExist() throws Exception {
    List<String> fakeStreams=new LinkedList<>();
    fakeStreams.add("fakeStream1");
    fakeStreams.add("fakeStream2");
    fakeStreams.add("fakeStream3");
    fakeStreams.add("fakeStream4");
    Map<StreamShardHandle,String> restoredStateUnderTest=new HashMap<>();
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    Map<String,Integer> streamToShardCount=new HashMap<>();
    streamToShardCount.put("fakeStream1",3);
    streamToShardCount.put("fakeStream2",2);
    streamToShardCount.put("fakeStream3",0);
    streamToShardCount.put("fakeStream4",0);
    HashMap<String,String> subscribedStreamsToLastSeenShardIdsUnderTest=KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams);
    final TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(fakeStreams,new TestSourceContext<>(),TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),10,2,new AtomicReference<>(),new LinkedList<>(),subscribedStreamsToLastSeenShardIdsUnderTest,FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(streamToShardCount));
    for (    Map.Entry<StreamShardHandle,String> restoredState : restoredStateUnderTest.entrySet()) {
      fetcher.advanceLastDiscoveredShardOfStream(restoredState.getKey().getStreamName(),restoredState.getKey().getShard().getShardId());
      fetcher.registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredState.getKey()),restoredState.getKey(),new SequenceNumber(restoredState.getValue())));
    }
    CheckedThread runFetcherThread=new CheckedThread(){
      @Override public void go() throws Exception {
        fetcher.runFetcher();
      }
    }
;
    runFetcherThread.start();
    fetcher.waitUntilInitialDiscovery();
    fetcher.shutdownFetcher();
    runFetcherThread.sync();
    Set<String> streamsInState=subscribedStreamsToLastSeenShardIdsUnderTest.keySet();
    assertEquals(fakeStreams.size(),streamsInState.size());
    assertTrue(streamsInState.containsAll(fakeStreams));
    assertEquals(KinesisShardIdGenerator.generateFromShardOrder(2),subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream1"));
    assertEquals(KinesisShardIdGenerator.generateFromShardOrder(1),subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream2"));
    assertNull(subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream3"));
    assertNull(subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream4"));
  }
  @Test public void testStreamToLastSeenShardStateIsCorrectlySetWhenNewShardsFoundSinceRestoredCheckpointAndSomeStreamsDoNotExist() throws Exception {
    List<String> fakeStreams=new LinkedList<>();
    fakeStreams.add("fakeStream1");
    fakeStreams.add("fakeStream2");
    fakeStreams.add("fakeStream3");
    fakeStreams.add("fakeStream4");
    Map<StreamShardHandle,String> restoredStateUnderTest=new HashMap<>();
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),UUID.randomUUID().toString());
    restoredStateUnderTest.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),UUID.randomUUID().toString());
    Map<String,Integer> streamToShardCount=new HashMap<>();
    streamToShardCount.put("fakeStream1",3 + 1);
    streamToShardCount.put("fakeStream2",2 + 3);
    streamToShardCount.put("fakeStream3",0);
    streamToShardCount.put("fakeStream4",0);
    HashMap<String,String> subscribedStreamsToLastSeenShardIdsUnderTest=KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams);
    final TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(fakeStreams,new TestSourceContext<>(),TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),10,2,new AtomicReference<>(),new LinkedList<>(),subscribedStreamsToLastSeenShardIdsUnderTest,FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(streamToShardCount));
    for (    Map.Entry<StreamShardHandle,String> restoredState : restoredStateUnderTest.entrySet()) {
      fetcher.advanceLastDiscoveredShardOfStream(restoredState.getKey().getStreamName(),restoredState.getKey().getShard().getShardId());
      fetcher.registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredState.getKey()),restoredState.getKey(),new SequenceNumber(restoredState.getValue())));
    }
    CheckedThread runFetcherThread=new CheckedThread(){
      @Override public void go() throws Exception {
        fetcher.runFetcher();
      }
    }
;
    runFetcherThread.start();
    fetcher.waitUntilInitialDiscovery();
    fetcher.shutdownFetcher();
    runFetcherThread.sync();
    Set<String> streamsInState=subscribedStreamsToLastSeenShardIdsUnderTest.keySet();
    assertEquals(fakeStreams.size(),streamsInState.size());
    assertTrue(streamsInState.containsAll(fakeStreams));
    assertEquals(KinesisShardIdGenerator.generateFromShardOrder(3),subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream1"));
    assertEquals(KinesisShardIdGenerator.generateFromShardOrder(4),subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream2"));
    assertNull(subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream3"));
    assertNull(subscribedStreamsToLastSeenShardIdsUnderTest.get("fakeStream4"));
  }
  @Test public void testStreamShardMetadataAndHandleConversion(){
    String streamName="fakeStream1";
    String shardId="shard-000001";
    String parentShardId="shard-000002";
    String adjacentParentShardId="shard-000003";
    String startingHashKey="key-000001";
    String endingHashKey="key-000010";
    String startingSequenceNumber="seq-0000021";
    String endingSequenceNumber="seq-00000031";
    StreamShardMetadata kinesisStreamShard=new StreamShardMetadata();
    kinesisStreamShard.setStreamName(streamName);
    kinesisStreamShard.setShardId(shardId);
    kinesisStreamShard.setParentShardId(parentShardId);
    kinesisStreamShard.setAdjacentParentShardId(adjacentParentShardId);
    kinesisStreamShard.setStartingHashKey(startingHashKey);
    kinesisStreamShard.setEndingHashKey(endingHashKey);
    kinesisStreamShard.setStartingSequenceNumber(startingSequenceNumber);
    kinesisStreamShard.setEndingSequenceNumber(endingSequenceNumber);
    Shard shard=new Shard().withShardId(shardId).withParentShardId(parentShardId).withAdjacentParentShardId(adjacentParentShardId).withHashKeyRange(new HashKeyRange().withStartingHashKey(startingHashKey).withEndingHashKey(endingHashKey)).withSequenceNumberRange(new SequenceNumberRange().withStartingSequenceNumber(startingSequenceNumber).withEndingSequenceNumber(endingSequenceNumber));
    StreamShardHandle streamShardHandle=new StreamShardHandle(streamName,shard);
    assertEquals(kinesisStreamShard,KinesisDataFetcher.convertToStreamShardMetadata(streamShardHandle));
    assertEquals(streamShardHandle,KinesisDataFetcher.convertToStreamShardHandle(kinesisStreamShard));
  }
private static class DummyFlinkKinesisConsumer<T> extends FlinkKinesisConsumer<T> {
    private static final long serialVersionUID=1L;
    private final KinesisDataFetcher<T> fetcher;
    private final int numParallelSubtasks;
    private final int subtaskIndex;
    @SuppressWarnings("unchecked") DummyFlinkKinesisConsumer(    Properties properties,    KinesisDataFetcher<T> fetcher,    int numParallelSubtasks,    int subtaskIndex){
      super("test",mock(KinesisDeserializationSchema.class),properties);
      this.fetcher=fetcher;
      this.numParallelSubtasks=numParallelSubtasks;
      this.subtaskIndex=subtaskIndex;
    }
    @Override protected KinesisDataFetcher<T> createFetcher(    List<String> streams,    SourceFunction.SourceContext<T> sourceContext,    RuntimeContext runtimeContext,    Properties configProps,    KinesisDeserializationSchema<T> deserializationSchema){
      return fetcher;
    }
    @Override public RuntimeContext getRuntimeContext(){
      RuntimeContext context=mock(RuntimeContext.class);
      when(context.getIndexOfThisSubtask()).thenReturn(subtaskIndex);
      when(context.getNumberOfParallelSubtasks()).thenReturn(numParallelSubtasks);
      return context;
    }
  }
  @Test public void testShardToSubtaskMappingWithCustomHashFunction() throws Exception {
    int totalCountOfSubtasks=10;
    int shardCount=3;
    for (int i=0; i < 2; i++) {
      final int hash=i;
      final KinesisShardAssigner allShardsSingleSubtaskFn=(shard,subtasks) -> hash;
      Map<String,Integer> streamToShardCount=new HashMap<>();
      List<String> fakeStreams=new LinkedList<>();
      fakeStreams.add("fakeStream");
      streamToShardCount.put("fakeStream",shardCount);
      for (int j=0; j < totalCountOfSubtasks; j++) {
        int subtaskIndex=j;
        final TestableKinesisDataFetcher fetcher=new TestableKinesisDataFetcher(fakeStreams,new TestSourceContext<>(),new Properties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),totalCountOfSubtasks,subtaskIndex,new AtomicReference<>(),new LinkedList<>(),KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams),FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(streamToShardCount));
        Whitebox.setInternalState(fetcher,"shardAssigner",allShardsSingleSubtaskFn);
        List<StreamShardHandle> shards=fetcher.discoverNewShardsToSubscribe();
        fetcher.shutdownFetcher();
        String msg=String.format("for hash=%d, subtask=%d",hash,subtaskIndex);
        if (j == i) {
          assertEquals(msg,shardCount,shards.size());
        }
 else {
          assertEquals(msg,0,shards.size());
        }
      }
    }
  }
  @Test public void testIsThisSubtaskShouldSubscribeTo(){
    assertTrue(KinesisDataFetcher.isThisSubtaskShouldSubscribeTo(0,2,0));
    assertFalse(KinesisDataFetcher.isThisSubtaskShouldSubscribeTo(1,2,0));
    assertTrue(KinesisDataFetcher.isThisSubtaskShouldSubscribeTo(2,2,0));
    assertFalse(KinesisDataFetcher.isThisSubtaskShouldSubscribeTo(0,2,1));
    assertTrue(KinesisDataFetcher.isThisSubtaskShouldSubscribeTo(1,2,1));
    assertFalse(KinesisDataFetcher.isThisSubtaskShouldSubscribeTo(2,2,1));
  }
}
