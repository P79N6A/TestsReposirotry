/** 
 * A blocking stateful source task that declines savepoints.
 */
public static class FailOnSavepointSourceTask extends AbstractInvokable {
  private static final CountDownLatch CHECKPOINT_AFTER_SAVEPOINT_LATCH=new CountDownLatch(1);
  private boolean receivedSavepoint;
  /** 
 * Create an Invokable task and set its environment.
 * @param environment The environment assigned to this invokable.
 */
  public FailOnSavepointSourceTask(  Environment environment){
    super(environment);
  }
  @Override public void invoke() throws Exception {
    new CountDownLatch(1).await();
  }
  @Override public boolean triggerCheckpoint(  CheckpointMetaData checkpointMetaData,  CheckpointOptions checkpointOptions) throws Exception {
    if (checkpointOptions.getCheckpointType() == CheckpointType.SAVEPOINT) {
      receivedSavepoint=true;
      return false;
    }
 else     if (receivedSavepoint) {
      CHECKPOINT_AFTER_SAVEPOINT_LATCH.countDown();
      return true;
    }
    return true;
  }
  @Override public void triggerCheckpointOnBarrier(  CheckpointMetaData checkpointMetaData,  CheckpointOptions checkpointOptions,  CheckpointMetrics checkpointMetrics) throws Exception {
    throw new UnsupportedOperationException("This is meant to be used as a source");
  }
  @Override public void abortCheckpointOnBarrier(  long checkpointId,  Throwable cause) throws Exception {
  }
  @Override public void notifyCheckpointComplete(  long checkpointId) throws Exception {
  }
}
