/** 
 * Tests for  {@link StreamExecutionEnvironment}.
 */
public class StreamExecutionEnvironmentTest {
  @Test public void fromElementsWithBaseTypeTest1(){
    StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    env.fromElements(ParentClass.class,new SubClass(1,"Java"),new ParentClass(1,"hello"));
  }
  @Test(expected=IllegalArgumentException.class) public void fromElementsWithBaseTypeTest2(){
    StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    env.fromElements(SubClass.class,new SubClass(1,"Java"),new ParentClass(1,"hello"));
  }
  @Test @SuppressWarnings("unchecked") public void testFromCollectionParallelism(){
    try {
      TypeInformation<Integer> typeInfo=BasicTypeInfo.INT_TYPE_INFO;
      StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
      DataStreamSource<Integer> dataStream1=env.fromCollection(new DummySplittableIterator<Integer>(),typeInfo);
      try {
        dataStream1.setParallelism(4);
        fail("should throw an exception");
      }
 catch (      IllegalArgumentException e) {
      }
      dataStream1.addSink(new DiscardingSink<Integer>());
      DataStreamSource<Integer> dataStream2=env.fromParallelCollection(new DummySplittableIterator<Integer>(),typeInfo).setParallelism(4);
      dataStream2.addSink(new DiscardingSink<Integer>());
      env.getExecutionPlan();
      assertEquals("Parallelism of collection source must be 1.",1,env.getStreamGraph().getStreamNode(dataStream1.getId()).getParallelism());
      assertEquals("Parallelism of parallel collection source must be 4.",4,env.getStreamGraph().getStreamNode(dataStream2.getId()).getParallelism());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testSources(){
    StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    SourceFunction<Integer> srcFun=new SourceFunction<Integer>(){
      private static final long serialVersionUID=1L;
      @Override public void run(      SourceContext<Integer> ctx) throws Exception {
      }
      @Override public void cancel(){
      }
    }
;
    DataStreamSource<Integer> src1=env.addSource(srcFun);
    src1.addSink(new DiscardingSink<Integer>());
    assertEquals(srcFun,getFunctionFromDataSource(src1));
    List<Long> list=Arrays.asList(0L,1L,2L);
    DataStreamSource<Long> src2=env.generateSequence(0,2);
    assertTrue(getFunctionFromDataSource(src2) instanceof StatefulSequenceSource);
    DataStreamSource<Long> src3=env.fromElements(0L,1L,2L);
    assertTrue(getFunctionFromDataSource(src3) instanceof FromElementsFunction);
    DataStreamSource<Long> src4=env.fromCollection(list);
    assertTrue(getFunctionFromDataSource(src4) instanceof FromElementsFunction);
  }
  @Test public void testParallelismBounds(){
    StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    SourceFunction<Integer> srcFun=new SourceFunction<Integer>(){
      private static final long serialVersionUID=1L;
      @Override public void run(      SourceContext<Integer> ctx) throws Exception {
      }
      @Override public void cancel(){
      }
    }
;
    SingleOutputStreamOperator<Object> operator=env.addSource(srcFun).flatMap(new FlatMapFunction<Integer,Object>(){
      private static final long serialVersionUID=1L;
      @Override public void flatMap(      Integer value,      Collector<Object> out) throws Exception {
      }
    }
);
    Assert.assertEquals(-1,operator.getTransformation().getMaxParallelism());
    try {
      operator.setParallelism(0);
      Assert.fail();
    }
 catch (    IllegalArgumentException expected) {
    }
    operator.setParallelism(1);
    Assert.assertEquals(1,operator.getParallelism());
    operator.setParallelism(1 << 15);
    Assert.assertEquals(1 << 15,operator.getParallelism());
    env.getStreamGraph().getJobGraph();
    Assert.assertEquals(-1,operator.getTransformation().getMaxParallelism());
    env.setMaxParallelism(42);
    env.getStreamGraph().getJobGraph();
    Assert.assertEquals(42,operator.getTransformation().getMaxParallelism());
    try {
      env.setMaxParallelism(0);
      Assert.fail();
    }
 catch (    IllegalArgumentException expected) {
    }
    try {
      env.setMaxParallelism(1 + (1 << 15));
      Assert.fail();
    }
 catch (    IllegalArgumentException expected) {
    }
    try {
      operator.setMaxParallelism(0);
      Assert.fail();
    }
 catch (    IllegalArgumentException expected) {
    }
    try {
      operator.setMaxParallelism(1 + (1 << 15));
      Assert.fail();
    }
 catch (    IllegalArgumentException expected) {
    }
    operator.setMaxParallelism(1);
    Assert.assertEquals(1,operator.getTransformation().getMaxParallelism());
    operator.setMaxParallelism(1 << 15);
    Assert.assertEquals(1 << 15,operator.getTransformation().getMaxParallelism());
    env.getStreamGraph().getJobGraph();
    Assert.assertEquals(1 << 15,operator.getTransformation().getMaxParallelism());
  }
  private static StreamOperator<?> getOperatorFromDataStream(  DataStream<?> dataStream){
    StreamExecutionEnvironment env=dataStream.getExecutionEnvironment();
    StreamGraph streamGraph=env.getStreamGraph();
    return streamGraph.getStreamNode(dataStream.getId()).getOperator();
  }
  @SuppressWarnings("unchecked") private static <T>SourceFunction<T> getFunctionFromDataSource(  DataStreamSource<T> dataStreamSource){
    dataStreamSource.addSink(new DiscardingSink<T>());
    AbstractUdfStreamOperator<?,?> operator=(AbstractUdfStreamOperator<?,?>)getOperatorFromDataStream(dataStreamSource);
    return (SourceFunction<T>)operator.getUserFunction();
  }
private static class DummySplittableIterator<T> extends SplittableIterator<T> {
    private static final long serialVersionUID=1312752876092210499L;
    @SuppressWarnings("unchecked") @Override public Iterator<T>[] split(    int numPartitions){
      return (Iterator<T>[])new Iterator<?>[0];
    }
    @Override public int getMaximumNumberOfSplits(){
      return 0;
    }
    @Override public boolean hasNext(){
      return false;
    }
    @Override public T next(){
      throw new NoSuchElementException();
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
private static class ParentClass {
    int num;
    String string;
    public ParentClass(    int num,    String string){
      this.num=num;
      this.string=string;
    }
  }
private static class SubClass extends ParentClass {
    public SubClass(    int num,    String string){
      super(num,string);
    }
  }
}
