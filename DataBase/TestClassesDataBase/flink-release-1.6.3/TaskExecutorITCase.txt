public class TaskExecutorITCase extends TestLogger {
  private final Time timeout=Time.seconds(10L);
  @Test public void testSlotAllocation() throws Exception {
    TestingFatalErrorHandler testingFatalErrorHandler=new TestingFatalErrorHandler();
    TestingHighAvailabilityServices testingHAServices=new TestingHighAvailabilityServices();
    final Configuration configuration=new Configuration();
    final ScheduledExecutorService scheduledExecutorService=new ScheduledThreadPoolExecutor(1);
    final ResourceID taskManagerResourceId=new ResourceID("foobar");
    final UUID rmLeaderId=UUID.randomUUID();
    final TestingLeaderElectionService rmLeaderElectionService=new TestingLeaderElectionService();
    final SettableLeaderRetrievalService rmLeaderRetrievalService=new SettableLeaderRetrievalService(null,null);
    final String rmAddress="rm";
    final String jmAddress="jm";
    final JobMasterId jobMasterId=JobMasterId.generate();
    final ResourceID rmResourceId=new ResourceID(rmAddress);
    final ResourceID jmResourceId=new ResourceID(jmAddress);
    final JobID jobId=new JobID();
    final ResourceProfile resourceProfile=new ResourceProfile(1.0,1);
    testingHAServices.setResourceManagerLeaderElectionService(rmLeaderElectionService);
    testingHAServices.setResourceManagerLeaderRetriever(rmLeaderRetrievalService);
    testingHAServices.setJobMasterLeaderRetriever(jobId,new SettableLeaderRetrievalService(jmAddress,jobMasterId.toUUID()));
    TestingRpcService rpcService=new TestingRpcService();
    ResourceManagerConfiguration resourceManagerConfiguration=new ResourceManagerConfiguration(Time.milliseconds(500L),Time.milliseconds(500L));
    JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(testingHAServices,rpcService.getScheduledExecutor(),Time.minutes(5L));
    MetricRegistry metricRegistry=NoOpMetricRegistry.INSTANCE;
    HeartbeatServices heartbeatServices=new HeartbeatServices(1000L,1000L);
    final TaskManagerConfiguration taskManagerConfiguration=TaskManagerConfiguration.fromConfiguration(configuration);
    final TaskManagerLocation taskManagerLocation=new TaskManagerLocation(taskManagerResourceId,InetAddress.getLocalHost(),1234);
    final List<ResourceProfile> resourceProfiles=Arrays.asList(resourceProfile);
    final TaskSlotTable taskSlotTable=new TaskSlotTable(resourceProfiles,new TimerService<AllocationID>(scheduledExecutorService,100L));
    final SlotManager slotManager=new SlotManager(rpcService.getScheduledExecutor(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime());
    final File[] taskExecutorLocalStateRootDirs=new File[]{new File(System.getProperty("java.io.tmpdir"),"localRecovery")};
    final TaskExecutorLocalStateStoresManager taskStateManager=new TaskExecutorLocalStateStoresManager(false,taskExecutorLocalStateRootDirs,rpcService.getExecutor());
    ResourceManager<ResourceID> resourceManager=new StandaloneResourceManager(rpcService,FlinkResourceManager.RESOURCE_MANAGER_NAME,rmResourceId,resourceManagerConfiguration,testingHAServices,heartbeatServices,slotManager,metricRegistry,jobLeaderIdService,new ClusterInformation("localhost",1234),testingFatalErrorHandler,UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup());
    final TaskManagerServices taskManagerServices=new TaskManagerServicesBuilder().setTaskManagerLocation(taskManagerLocation).setTaskSlotTable(taskSlotTable).setTaskStateManager(taskStateManager).build();
    TaskExecutor taskExecutor=new TaskExecutor(rpcService,taskManagerConfiguration,testingHAServices,taskManagerServices,heartbeatServices,UnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),new BlobCacheService(configuration,new VoidBlobStore(),null),testingFatalErrorHandler);
    JobMasterGateway jmGateway=mock(JobMasterGateway.class);
    when(jmGateway.registerTaskManager(any(String.class),any(TaskManagerLocation.class),any(Time.class))).thenReturn(CompletableFuture.completedFuture(new JMTMRegistrationSuccess(taskManagerResourceId)));
    when(jmGateway.getHostname()).thenReturn(jmAddress);
    when(jmGateway.offerSlots(eq(taskManagerResourceId),any(Collection.class),any(Time.class))).thenReturn(mock(CompletableFuture.class,RETURNS_MOCKS));
    when(jmGateway.getFencingToken()).thenReturn(jobMasterId);
    rpcService.registerGateway(rmAddress,resourceManager.getSelfGateway(ResourceManagerGateway.class));
    rpcService.registerGateway(jmAddress,jmGateway);
    rpcService.registerGateway(taskExecutor.getAddress(),taskExecutor.getSelfGateway(TaskExecutorGateway.class));
    final AllocationID allocationId=new AllocationID();
    final SlotRequest slotRequest=new SlotRequest(jobId,allocationId,resourceProfile,jmAddress);
    final SlotOffer slotOffer=new SlotOffer(allocationId,0,resourceProfile);
    try {
      resourceManager.start();
      taskExecutor.start();
      final ResourceManagerGateway rmGateway=resourceManager.getSelfGateway(ResourceManagerGateway.class);
      CompletableFuture<UUID> isLeaderFuture=rmLeaderElectionService.isLeader(rmLeaderId);
      assertEquals(rmLeaderId,isLeaderFuture.get());
      rmLeaderRetrievalService.notifyListener(rmAddress,rmLeaderId);
      CompletableFuture<RegistrationResponse> registrationResponseFuture=rmGateway.registerJobManager(jobMasterId,jmResourceId,jmAddress,jobId,timeout);
      RegistrationResponse registrationResponse=registrationResponseFuture.get();
      assertTrue(registrationResponse instanceof JobMasterRegistrationSuccess);
      CompletableFuture<Acknowledge> slotAck=rmGateway.requestSlot(jobMasterId,slotRequest,timeout);
      slotAck.get();
      verify(jmGateway,Mockito.timeout(timeout.toMilliseconds())).offerSlots(eq(taskManagerResourceId),(Collection<SlotOffer>)argThat(Matchers.contains(slotOffer)),any(Time.class));
    }
  finally {
      if (testingFatalErrorHandler.hasExceptionOccurred()) {
        testingFatalErrorHandler.rethrowError();
      }
      RpcUtils.terminateRpcService(rpcService,timeout);
    }
  }
}
