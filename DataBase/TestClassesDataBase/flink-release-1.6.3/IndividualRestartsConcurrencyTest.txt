/** 
 * These tests make sure that global failover (restart all) always takes precedence over local recovery strategies. <p>This test must be in the package it resides in, because it uses package-private methods from the ExecutionGraph classes.
 */
public class IndividualRestartsConcurrencyTest extends TestLogger {
  /** 
 * Tests that a cancellation concurrent to a local failover leads to a properly cancelled state.
 */
  @Test public void testCancelWhileInLocalFailover() throws Exception {
    final JobID jid=new JobID();
    final int parallelism=2;
    final ManuallyTriggeredDirectExecutor executor=new ManuallyTriggeredDirectExecutor();
    final SimpleSlotProvider slotProvider=new SimpleSlotProvider(jid,parallelism);
    final ExecutionGraph graph=createSampleGraph(jid,new IndividualFailoverWithCustomExecutor(executor),slotProvider,2);
    final ExecutionJobVertex ejv=graph.getVerticesTopologically().iterator().next();
    final ExecutionVertex vertex1=ejv.getTaskVertices()[0];
    final ExecutionVertex vertex2=ejv.getTaskVertices()[1];
    graph.scheduleForExecution();
    assertEquals(JobStatus.RUNNING,graph.getState());
    vertex1.getCurrentExecutionAttempt().fail(new Exception("test failure"));
    assertEquals(ExecutionState.FAILED,vertex1.getCurrentExecutionAttempt().getState());
    assertEquals(JobStatus.RUNNING,graph.getState());
    assertEquals(1,executor.numQueuedRunnables());
    graph.cancel();
    assertEquals(JobStatus.CANCELLING,graph.getState());
    assertEquals(ExecutionState.FAILED,vertex1.getCurrentExecutionAttempt().getState());
    assertEquals(ExecutionState.CANCELING,vertex2.getCurrentExecutionAttempt().getState());
    executor.trigger();
    vertex2.getCurrentExecutionAttempt().cancelingComplete();
    assertEquals(JobStatus.CANCELED,graph.getTerminationFuture().get());
    assertTrue(vertex1.getCurrentExecutionAttempt().getState().isTerminal());
    assertTrue(vertex2.getCurrentExecutionAttempt().getState().isTerminal());
    assertEquals(parallelism,slotProvider.getNumberOfAvailableSlots());
  }
  /** 
 * Tests that a terminal global failure concurrent to a local failover leads to a properly failed state.
 */
  @Test public void testGlobalFailureConcurrentToLocalFailover() throws Exception {
    final JobID jid=new JobID();
    final int parallelism=2;
    final ManuallyTriggeredDirectExecutor executor=new ManuallyTriggeredDirectExecutor();
    final SimpleSlotProvider slotProvider=new SimpleSlotProvider(jid,parallelism);
    final ExecutionGraph graph=createSampleGraph(jid,new IndividualFailoverWithCustomExecutor(executor),slotProvider,2);
    final ExecutionJobVertex ejv=graph.getVerticesTopologically().iterator().next();
    final ExecutionVertex vertex1=ejv.getTaskVertices()[0];
    final ExecutionVertex vertex2=ejv.getTaskVertices()[1];
    graph.scheduleForExecution();
    assertEquals(JobStatus.RUNNING,graph.getState());
    vertex1.getCurrentExecutionAttempt().fail(new Exception("test failure"));
    assertEquals(ExecutionState.FAILED,vertex1.getCurrentExecutionAttempt().getState());
    assertEquals(JobStatus.RUNNING,graph.getState());
    assertEquals(1,executor.numQueuedRunnables());
    graph.failGlobal(new Exception("test exception"));
    assertEquals(JobStatus.FAILING,graph.getState());
    assertEquals(ExecutionState.FAILED,vertex1.getCurrentExecutionAttempt().getState());
    assertEquals(ExecutionState.CANCELING,vertex2.getCurrentExecutionAttempt().getState());
    executor.trigger();
    vertex2.getCurrentExecutionAttempt().cancelingComplete();
    assertEquals(JobStatus.FAILED,graph.getState());
    assertTrue(vertex1.getCurrentExecutionAttempt().getState().isTerminal());
    assertTrue(vertex2.getCurrentExecutionAttempt().getState().isTerminal());
    assertEquals(parallelism,slotProvider.getNumberOfAvailableSlots());
  }
  /** 
 * Tests that a local failover does not try to trump a global failover.
 */
  @Test public void testGlobalRecoveryConcurrentToLocalRecovery() throws Exception {
    final JobID jid=new JobID();
    final int parallelism=2;
    final ManuallyTriggeredDirectExecutor executor=new ManuallyTriggeredDirectExecutor();
    final SimpleSlotProvider slotProvider=new SimpleSlotProvider(jid,parallelism);
    final ExecutionGraph graph=createSampleGraph(jid,new IndividualFailoverWithCustomExecutor(executor),new FixedDelayRestartStrategy(1,0),slotProvider,2);
    final ExecutionJobVertex ejv=graph.getVerticesTopologically().iterator().next();
    final ExecutionVertex vertex1=ejv.getTaskVertices()[0];
    final ExecutionVertex vertex2=ejv.getTaskVertices()[1];
    graph.scheduleForExecution();
    assertEquals(JobStatus.RUNNING,graph.getState());
    vertex2.getCurrentExecutionAttempt().fail(new Exception("test failure"));
    assertEquals(ExecutionState.FAILED,vertex2.getCurrentExecutionAttempt().getState());
    assertEquals(JobStatus.RUNNING,graph.getState());
    assertEquals(1,executor.numQueuedRunnables());
    graph.failGlobal(new Exception("test exception"));
    assertEquals(JobStatus.FAILING,graph.getState());
    assertEquals(ExecutionState.FAILED,vertex2.getCurrentExecutionAttempt().getState());
    assertEquals(ExecutionState.CANCELING,vertex1.getCurrentExecutionAttempt().getState());
    vertex1.getCurrentExecutionAttempt().cancelingComplete();
    waitUntilJobStatus(graph,JobStatus.RUNNING,1000);
    assertEquals(JobStatus.RUNNING,graph.getState());
    waitUntilExecutionState(vertex1.getCurrentExecutionAttempt(),ExecutionState.DEPLOYING,1000);
    waitUntilExecutionState(vertex2.getCurrentExecutionAttempt(),ExecutionState.DEPLOYING,1000);
    vertex1.getCurrentExecutionAttempt().switchToRunning();
    vertex2.getCurrentExecutionAttempt().switchToRunning();
    assertEquals(ExecutionState.RUNNING,vertex1.getCurrentExecutionAttempt().getState());
    assertEquals(ExecutionState.RUNNING,vertex2.getCurrentExecutionAttempt().getState());
    executor.trigger();
    assertEquals(JobStatus.RUNNING,graph.getState());
    assertEquals(ExecutionState.RUNNING,vertex1.getCurrentExecutionAttempt().getState());
    assertEquals(ExecutionState.RUNNING,vertex2.getCurrentExecutionAttempt().getState());
    assertEquals(1,vertex1.getCurrentExecutionAttempt().getAttemptNumber());
    assertEquals(1,vertex2.getCurrentExecutionAttempt().getAttemptNumber());
    assertEquals(1,vertex1.getCopyOfPriorExecutionsList().size());
    assertEquals(1,vertex2.getCopyOfPriorExecutionsList().size());
    assertEquals(0,slotProvider.getNumberOfAvailableSlots());
  }
  /** 
 * Tests that a local failure fails all pending checkpoints which have not been acknowledged by the failing task.
 */
  @Test public void testLocalFailureFailsPendingCheckpoints() throws Exception {
    final JobID jid=new JobID();
    final int parallelism=2;
    final long verifyTimeout=5000L;
    final TaskManagerGateway taskManagerGateway=mock(TaskManagerGateway.class);
    when(taskManagerGateway.submitTask(any(TaskDeploymentDescriptor.class),any(Time.class))).thenReturn(CompletableFuture.completedFuture(Acknowledge.get()));
    when(taskManagerGateway.cancelTask(any(ExecutionAttemptID.class),any(Time.class))).thenReturn(CompletableFuture.completedFuture(Acknowledge.get()));
    final SimpleSlotProvider slotProvider=new SimpleSlotProvider(jid,parallelism,taskManagerGateway);
    final ManuallyTriggeredDirectExecutor executor=new ManuallyTriggeredDirectExecutor();
    final CheckpointCoordinatorConfiguration checkpointCoordinatorConfiguration=new CheckpointCoordinatorConfiguration(10L,100000L,1L,3,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,true);
    final ExecutionGraph graph=createSampleGraph(jid,new IndividualFailoverWithCustomExecutor(executor),slotProvider,parallelism);
    final List<ExecutionJobVertex> allVertices=new ArrayList<>(graph.getAllVertices().values());
    final StandaloneCheckpointIDCounter standaloneCheckpointIDCounter=new StandaloneCheckpointIDCounter();
    graph.enableCheckpointing(checkpointCoordinatorConfiguration.getCheckpointInterval(),checkpointCoordinatorConfiguration.getCheckpointTimeout(),checkpointCoordinatorConfiguration.getMinPauseBetweenCheckpoints(),checkpointCoordinatorConfiguration.getMaxConcurrentCheckpoints(),checkpointCoordinatorConfiguration.getCheckpointRetentionPolicy(),allVertices,allVertices,allVertices,Collections.emptyList(),standaloneCheckpointIDCounter,new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),new CheckpointStatsTracker(1,allVertices,checkpointCoordinatorConfiguration,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup()));
    final CheckpointCoordinator checkpointCoordinator=graph.getCheckpointCoordinator();
    final ExecutionJobVertex ejv=graph.getVerticesTopologically().iterator().next();
    final ExecutionVertex vertex1=ejv.getTaskVertices()[0];
    final ExecutionVertex vertex2=ejv.getTaskVertices()[1];
    graph.scheduleForExecution();
    assertEquals(JobStatus.RUNNING,graph.getState());
    verify(taskManagerGateway,timeout(verifyTimeout).times(parallelism)).submitTask(any(TaskDeploymentDescriptor.class),any(Time.class));
    for (    ExecutionVertex executionVertex : graph.getAllExecutionVertices()) {
      executionVertex.getCurrentExecutionAttempt().switchToRunning();
    }
    verify(taskManagerGateway,timeout(verifyTimeout).times(3)).triggerCheckpoint(eq(vertex1.getCurrentExecutionAttempt().getAttemptId()),any(JobID.class),anyLong(),anyLong(),any(CheckpointOptions.class));
    verify(taskManagerGateway,timeout(verifyTimeout).times(3)).triggerCheckpoint(eq(vertex2.getCurrentExecutionAttempt().getAttemptId()),any(JobID.class),anyLong(),anyLong(),any(CheckpointOptions.class));
    assertEquals(3,checkpointCoordinator.getNumberOfPendingCheckpoints());
    long checkpointToAcknowledge=standaloneCheckpointIDCounter.getLast();
    checkpointCoordinator.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(graph.getJobID(),vertex1.getCurrentExecutionAttempt().getAttemptId(),checkpointToAcknowledge));
    Map<Long,PendingCheckpoint> oldPendingCheckpoints=new HashMap<>(3);
    for (    PendingCheckpoint pendingCheckpoint : checkpointCoordinator.getPendingCheckpoints().values()) {
      assertFalse(pendingCheckpoint.isDiscarded());
      oldPendingCheckpoints.put(pendingCheckpoint.getCheckpointId(),pendingCheckpoint);
    }
    vertex1.getCurrentExecutionAttempt().fail(new Exception("test failure"));
    for (    PendingCheckpoint pendingCheckpoint : oldPendingCheckpoints.values()) {
      if (pendingCheckpoint.getCheckpointId() == checkpointToAcknowledge) {
        assertFalse(pendingCheckpoint.isDiscarded());
      }
 else {
        assertTrue(pendingCheckpoint.isDiscarded());
      }
    }
  }
  private ExecutionGraph createSampleGraph(  JobID jid,  Factory failoverStrategy,  SlotProvider slotProvider,  int parallelism) throws Exception {
    return createSampleGraph(jid,failoverStrategy,new NoRestartStrategy(),slotProvider,parallelism);
  }
  private ExecutionGraph createSampleGraph(  JobID jid,  Factory failoverStrategy,  RestartStrategy restartStrategy,  SlotProvider slotProvider,  int parallelism) throws Exception {
    final ExecutionGraph graph=new ExecutionGraph(new DummyJobInformation(jid,"test job"),TestingUtils.defaultExecutor(),TestingUtils.defaultExecutor(),Time.seconds(10),restartStrategy,failoverStrategy,slotProvider);
    JobVertex jv=new JobVertex("test vertex");
    jv.setInvokableClass(NoOpInvokable.class);
    jv.setParallelism(parallelism);
    JobGraph jg=new JobGraph(jid,"testjob",jv);
    graph.attachJobGraph(jg.getVerticesSortedTopologicallyFromSources());
    return graph;
  }
private static class IndividualFailoverWithCustomExecutor implements Factory {
    private final Executor executor;
    IndividualFailoverWithCustomExecutor(    Executor executor){
      this.executor=executor;
    }
    @Override public FailoverStrategy create(    ExecutionGraph executionGraph){
      return new RestartIndividualStrategy(executionGraph,executor);
    }
  }
}
