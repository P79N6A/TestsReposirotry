/** 
 * Starts a Flink mini cluster as a resource and registers the respective ExecutionEnvironment and StreamExecutionEnvironment.
 */
public class MiniClusterResource extends ExternalResource {
  private static final Logger LOG=LoggerFactory.getLogger(MiniClusterResource.class);
  private final TemporaryFolder temporaryFolder=new TemporaryFolder();
  private final MiniClusterResourceConfiguration miniClusterResourceConfiguration;
  private final TestBaseUtils.CodebaseType codebaseType;
  private JobExecutorService jobExecutorService;
  private ClusterClient<?> clusterClient;
  private Configuration restClusterClientConfig;
  private int numberSlots=-1;
  private TestEnvironment executionEnvironment;
  private int webUIPort=-1;
  public MiniClusterResource(  final MiniClusterResourceConfiguration miniClusterResourceConfiguration){
    this.miniClusterResourceConfiguration=Preconditions.checkNotNull(miniClusterResourceConfiguration);
    this.codebaseType=miniClusterResourceConfiguration.getCodebaseType();
  }
  public TestBaseUtils.CodebaseType getCodebaseType(){
    return codebaseType;
  }
  public int getNumberSlots(){
    return numberSlots;
  }
  public ClusterClient<?> getClusterClient(){
    return clusterClient;
  }
  public Configuration getClientConfiguration(){
    return restClusterClientConfig;
  }
  public TestEnvironment getTestEnvironment(){
    return executionEnvironment;
  }
  public int getWebUIPort(){
    return webUIPort;
  }
  @Override public void before() throws Exception {
    Assume.assumeThat(TestBaseUtils.getCodebaseType(),is(equalTo(codebaseType)));
    temporaryFolder.create();
    startJobExecutorService(codebaseType);
    numberSlots=miniClusterResourceConfiguration.getNumberSlotsPerTaskManager() * miniClusterResourceConfiguration.getNumberTaskManagers();
    executionEnvironment=new TestEnvironment(jobExecutorService,numberSlots,false);
    executionEnvironment.setAsContext();
    TestStreamEnvironment.setAsContext(jobExecutorService,numberSlots);
  }
  @Override public void after(){
    temporaryFolder.delete();
    TestStreamEnvironment.unsetAsContext();
    TestEnvironment.unsetAsContext();
    Exception exception=null;
    if (clusterClient != null) {
      try {
        clusterClient.shutdown();
      }
 catch (      Exception e) {
        exception=e;
      }
    }
    clusterClient=null;
    if (jobExecutorService != null) {
      final CompletableFuture<?> terminationFuture=jobExecutorService.closeAsync();
      try {
        terminationFuture.get(miniClusterResourceConfiguration.getShutdownTimeout().toMilliseconds(),TimeUnit.MILLISECONDS);
      }
 catch (      Exception e) {
        exception=ExceptionUtils.firstOrSuppressed(e,exception);
      }
      jobExecutorService=null;
    }
    if (exception != null) {
      LOG.warn("Could not properly shut down the MiniClusterResource.",exception);
    }
  }
  private void startJobExecutorService(  TestBaseUtils.CodebaseType miniClusterType) throws Exception {
switch (miniClusterType) {
case LEGACY:
      startLegacyMiniCluster();
    break;
case NEW:
  startMiniCluster();
break;
default :
throw new FlinkRuntimeException("Unknown MiniClusterType " + miniClusterType + '.');
}
}
private void startLegacyMiniCluster() throws Exception {
final Configuration configuration=new Configuration(miniClusterResourceConfiguration.getConfiguration());
configuration.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER,miniClusterResourceConfiguration.getNumberTaskManagers());
configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS,miniClusterResourceConfiguration.getNumberSlotsPerTaskManager());
configuration.setString(CoreOptions.TMP_DIRS,temporaryFolder.newFolder().getAbsolutePath());
final LocalFlinkMiniCluster flinkMiniCluster=TestBaseUtils.startCluster(configuration,miniClusterResourceConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED);
jobExecutorService=flinkMiniCluster;
switch (miniClusterResourceConfiguration.getRpcServiceSharing()) {
case SHARED:
Option<ActorSystem> actorSystemOption=flinkMiniCluster.firstActorSystem();
Preconditions.checkState(actorSystemOption.isDefined());
final ActorSystem actorSystem=actorSystemOption.get();
clusterClient=new StandaloneClusterClient(configuration,flinkMiniCluster.highAvailabilityServices(),true,new DefaultActorSystemLoader(actorSystem));
break;
case DEDICATED:
clusterClient=new StandaloneClusterClient(configuration,flinkMiniCluster.highAvailabilityServices(),true);
break;
}
Configuration restClientConfig=new Configuration();
restClientConfig.setInteger(JobManagerOptions.PORT,flinkMiniCluster.getLeaderRPCPort());
this.restClusterClientConfig=new UnmodifiableConfiguration(restClientConfig);
if (flinkMiniCluster.webMonitor().isDefined()) {
webUIPort=flinkMiniCluster.webMonitor().get().getServerPort();
}
}
private void startMiniCluster() throws Exception {
final Configuration configuration=miniClusterResourceConfiguration.getConfiguration();
configuration.setString(CoreOptions.TMP_DIRS,temporaryFolder.newFolder().getAbsolutePath());
if (!configuration.contains(CoreOptions.FILESYTEM_DEFAULT_OVERRIDE)) {
configuration.setBoolean(CoreOptions.FILESYTEM_DEFAULT_OVERRIDE,true);
}
if (!configuration.contains(TaskManagerOptions.MANAGED_MEMORY_SIZE)) {
configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE,TestBaseUtils.TASK_MANAGER_MEMORY_SIZE);
}
configuration.setInteger(RestOptions.PORT,0);
final MiniClusterConfiguration miniClusterConfiguration=new MiniClusterConfiguration.Builder().setConfiguration(configuration).setNumTaskManagers(miniClusterResourceConfiguration.getNumberTaskManagers()).setNumSlotsPerTaskManager(miniClusterResourceConfiguration.getNumberSlotsPerTaskManager()).build();
final MiniCluster miniCluster=new MiniCluster(miniClusterConfiguration);
miniCluster.start();
configuration.setInteger(RestOptions.PORT,miniCluster.getRestAddress().getPort());
jobExecutorService=miniCluster;
clusterClient=new MiniClusterClient(configuration,miniCluster);
Configuration restClientConfig=new Configuration();
restClientConfig.setString(JobManagerOptions.ADDRESS,miniCluster.getRestAddress().getHost());
restClientConfig.setInteger(RestOptions.PORT,miniCluster.getRestAddress().getPort());
this.restClusterClientConfig=new UnmodifiableConfiguration(restClientConfig);
webUIPort=miniCluster.getRestAddress().getPort();
}
}
