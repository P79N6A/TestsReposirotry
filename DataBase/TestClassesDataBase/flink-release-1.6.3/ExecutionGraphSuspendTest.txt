/** 
 * Validates that suspending out of various states works correctly.
 */
public class ExecutionGraphSuspendTest extends TestLogger {
  /** 
 * Going into SUSPENDING out of CREATED should immediately cancel everything and not send out RPC calls.
 */
  @Test public void testSuspendedOutOfCreated() throws Exception {
    final TaskManagerGateway gateway=spy(new SimpleAckingTaskManagerGateway());
    final int parallelism=10;
    final ExecutionGraph eg=createExecutionGraph(gateway,parallelism);
    assertEquals(JobStatus.CREATED,eg.getState());
    eg.suspend(new Exception("suspend"));
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    validateAllVerticesInState(eg,ExecutionState.CANCELED);
    validateCancelRpcCalls(gateway,0);
    ensureCannotLeaveSuspendedState(eg,gateway);
  }
  /** 
 * Going into SUSPENDING out of DEPLOYING vertices should cancel all vertices once with RPC calls.
 */
  @Test public void testSuspendedOutOfDeploying() throws Exception {
    final TaskManagerGateway gateway=spy(new SimpleAckingTaskManagerGateway());
    final int parallelism=10;
    final ExecutionGraph eg=createExecutionGraph(gateway,parallelism);
    eg.scheduleForExecution();
    assertEquals(JobStatus.RUNNING,eg.getState());
    validateAllVerticesInState(eg,ExecutionState.DEPLOYING);
    eg.suspend(new Exception("suspend"));
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    validateAllVerticesInState(eg,ExecutionState.CANCELING);
    validateCancelRpcCalls(gateway,parallelism);
    ExecutionGraphTestUtils.completeCancellingForAllVertices(eg);
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    ensureCannotLeaveSuspendedState(eg,gateway);
  }
  /** 
 * Going into SUSPENDING out of RUNNING vertices should cancel all vertices once with RPC calls.
 */
  @Test public void testSuspendedOutOfRunning() throws Exception {
    final TaskManagerGateway gateway=spy(new SimpleAckingTaskManagerGateway());
    final int parallelism=10;
    final ExecutionGraph eg=createExecutionGraph(gateway,parallelism);
    eg.scheduleForExecution();
    ExecutionGraphTestUtils.switchAllVerticesToRunning(eg);
    assertEquals(JobStatus.RUNNING,eg.getState());
    validateAllVerticesInState(eg,ExecutionState.RUNNING);
    eg.suspend(new Exception("suspend"));
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    validateAllVerticesInState(eg,ExecutionState.CANCELING);
    validateCancelRpcCalls(gateway,parallelism);
    ExecutionGraphTestUtils.completeCancellingForAllVertices(eg);
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    ensureCannotLeaveSuspendedState(eg,gateway);
  }
  /** 
 * Suspending from FAILING goes to SUSPENDING and sends no additional RPC calls
 */
  @Test public void testSuspendedOutOfFailing() throws Exception {
    final TaskManagerGateway gateway=spy(new SimpleAckingTaskManagerGateway());
    final int parallelism=10;
    final ExecutionGraph eg=createExecutionGraph(gateway,parallelism);
    eg.scheduleForExecution();
    ExecutionGraphTestUtils.switchAllVerticesToRunning(eg);
    eg.failGlobal(new Exception("fail global"));
    assertEquals(JobStatus.FAILING,eg.getState());
    validateCancelRpcCalls(gateway,parallelism);
    eg.suspend(new Exception("suspend"));
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    ensureCannotLeaveSuspendingState(eg,gateway);
    ExecutionGraphTestUtils.completeCancellingForAllVertices(eg);
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    ensureCannotLeaveSuspendedState(eg,gateway);
  }
  /** 
 * Suspending from FAILED should do nothing.
 */
  @Test public void testSuspendedOutOfFailed() throws Exception {
    final TaskManagerGateway gateway=spy(new SimpleAckingTaskManagerGateway());
    final int parallelism=10;
    final ExecutionGraph eg=createExecutionGraph(gateway,parallelism);
    eg.scheduleForExecution();
    ExecutionGraphTestUtils.switchAllVerticesToRunning(eg);
    eg.failGlobal(new Exception("fail global"));
    assertEquals(JobStatus.FAILING,eg.getState());
    validateCancelRpcCalls(gateway,parallelism);
    ExecutionGraphTestUtils.completeCancellingForAllVertices(eg);
    assertEquals(JobStatus.FAILED,eg.getState());
    eg.suspend(new Exception("suspend"));
    assertEquals(JobStatus.FAILED,eg.getState());
    validateCancelRpcCalls(gateway,parallelism);
  }
  /** 
 * Suspending from CANCELING goes to SUSPENDING and sends no additional RPC calls.
 */
  @Test public void testSuspendedOutOfCanceling() throws Exception {
    final TaskManagerGateway gateway=spy(new SimpleAckingTaskManagerGateway());
    final int parallelism=10;
    final ExecutionGraph eg=createExecutionGraph(gateway,parallelism);
    eg.scheduleForExecution();
    ExecutionGraphTestUtils.switchAllVerticesToRunning(eg);
    eg.cancel();
    assertEquals(JobStatus.CANCELLING,eg.getState());
    validateCancelRpcCalls(gateway,parallelism);
    eg.suspend(new Exception("suspend"));
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    ensureCannotLeaveSuspendingState(eg,gateway);
    ExecutionGraphTestUtils.completeCancellingForAllVertices(eg);
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    ensureCannotLeaveSuspendedState(eg,gateway);
  }
  /** 
 * Suspending from CANCELLED should do nothing.
 */
  @Test public void testSuspendedOutOfCanceled() throws Exception {
    final TaskManagerGateway gateway=spy(new SimpleAckingTaskManagerGateway());
    final int parallelism=10;
    final ExecutionGraph eg=createExecutionGraph(gateway,parallelism);
    eg.scheduleForExecution();
    ExecutionGraphTestUtils.switchAllVerticesToRunning(eg);
    eg.cancel();
    assertEquals(JobStatus.CANCELLING,eg.getState());
    validateCancelRpcCalls(gateway,parallelism);
    ExecutionGraphTestUtils.completeCancellingForAllVertices(eg);
    assertEquals(JobStatus.CANCELED,eg.getTerminationFuture().get());
    eg.suspend(new Exception("suspend"));
    assertEquals(JobStatus.CANCELED,eg.getState());
    validateCancelRpcCalls(gateway,parallelism);
  }
  /** 
 * Tests that we can suspend a job when in state RESTARTING.
 */
  @Test public void testSuspendWhileRestarting() throws Exception {
    final ExecutionGraph eg=ExecutionGraphTestUtils.createSimpleTestGraph(new InfiniteDelayRestartStrategy(10));
    eg.scheduleForExecution();
    assertEquals(JobStatus.RUNNING,eg.getState());
    ExecutionGraphTestUtils.switchAllVerticesToRunning(eg);
    eg.failGlobal(new Exception("test"));
    assertEquals(JobStatus.FAILING,eg.getState());
    ExecutionGraphTestUtils.completeCancellingForAllVertices(eg);
    assertEquals(JobStatus.RESTARTING,eg.getState());
    final Exception exception=new Exception("Suspended");
    eg.suspend(exception);
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    assertEquals(exception,eg.getFailureCause());
  }
  private static void ensureCannotLeaveSuspendedState(  ExecutionGraph eg,  TaskManagerGateway gateway){
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    reset(gateway);
    eg.failGlobal(new Exception("fail"));
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    verifyNoMoreInteractions(gateway);
    eg.cancel();
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    verifyNoMoreInteractions(gateway);
    eg.suspend(new Exception("suspend again"));
    assertEquals(JobStatus.SUSPENDED,eg.getState());
    verifyNoMoreInteractions(gateway);
    for (    ExecutionVertex ev : eg.getAllExecutionVertices()) {
      assertEquals(0,ev.getCurrentExecutionAttempt().getAttemptNumber());
    }
  }
  private static void ensureCannotLeaveSuspendingState(  ExecutionGraph eg,  TaskManagerGateway gateway){
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    reset(gateway);
    eg.failGlobal(new Exception("fail"));
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    verifyNoMoreInteractions(gateway);
    eg.cancel();
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    verifyNoMoreInteractions(gateway);
    eg.suspend(new Exception("suspend again"));
    assertEquals(JobStatus.SUSPENDING,eg.getState());
    verifyNoMoreInteractions(gateway);
    for (    ExecutionVertex ev : eg.getAllExecutionVertices()) {
      assertEquals(0,ev.getCurrentExecutionAttempt().getAttemptNumber());
    }
  }
  private static void validateAllVerticesInState(  ExecutionGraph eg,  ExecutionState expected){
    for (    ExecutionVertex ev : eg.getAllExecutionVertices()) {
      assertEquals(expected,ev.getCurrentExecutionAttempt().getState());
    }
  }
  private static void validateCancelRpcCalls(  TaskManagerGateway gateway,  int num){
    verify(gateway,times(num)).cancelTask(any(ExecutionAttemptID.class),any(Time.class));
  }
  private static ExecutionGraph createExecutionGraph(  TaskManagerGateway gateway,  int parallelism) throws Exception {
    final JobID jobId=new JobID();
    final JobVertex vertex=new JobVertex("vertex");
    vertex.setInvokableClass(NoOpInvokable.class);
    vertex.setParallelism(parallelism);
    final SlotProvider slotProvider=new SimpleSlotProvider(jobId,parallelism,gateway);
    return ExecutionGraphTestUtils.createSimpleTestGraph(jobId,slotProvider,new FixedDelayRestartStrategy(0,0),vertex);
  }
}
