/** 
 * Invokable which calls  {@link CountDownLatch#countDown()} on{@link JobMasterTriggerSavepointIT#invokeLatch}, and then blocks afterwards.
 */
public static class NoOpBlockingInvokable extends AbstractInvokable {
  public NoOpBlockingInvokable(  final Environment environment){
    super(environment);
  }
  @Override public void invoke(){
    invokeLatch.countDown();
    try {
      Thread.sleep(Long.MAX_VALUE);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  @Override public boolean triggerCheckpoint(  final CheckpointMetaData checkpointMetaData,  final CheckpointOptions checkpointOptions) throws Exception {
    final TaskStateSnapshot checkpointStateHandles=new TaskStateSnapshot();
    checkpointStateHandles.putSubtaskStateByOperatorID(OperatorID.fromJobVertexID(getEnvironment().getJobVertexId()),new OperatorSubtaskState());
    getEnvironment().acknowledgeCheckpoint(checkpointMetaData.getCheckpointId(),new CheckpointMetrics(),checkpointStateHandles);
    triggerCheckpointLatch.countDown();
    return true;
  }
  @Override public void notifyCheckpointComplete(  final long checkpointId) throws Exception {
  }
}
