/** 
 * Tests to guard rescaling from checkpoint.
 */
public class RocksIncrementalCheckpointRescalingTest extends TestLogger {
  @Rule public TemporaryFolder rootFolder=new TemporaryFolder();
  private final int maxParallelism=10;
  private KeySelector<String,String> keySelector=new TestKeySelector();
  private String[] records;
  @Before public void initRecords() throws Exception {
    records=new String[10];
    records[0]="8";
    Assert.assertEquals(0,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[0]),maxParallelism));
    records[1]="5";
    Assert.assertEquals(1,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[1]),maxParallelism));
    records[2]="25";
    Assert.assertEquals(2,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[2]),maxParallelism));
    records[3]="13";
    Assert.assertEquals(3,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[3]),maxParallelism));
    records[4]="4";
    Assert.assertEquals(4,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[4]),maxParallelism));
    records[5]="7";
    Assert.assertEquals(5,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[5]),maxParallelism));
    records[6]="1";
    Assert.assertEquals(6,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[6]),maxParallelism));
    records[7]="6";
    Assert.assertEquals(7,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[7]),maxParallelism));
    records[8]="9";
    Assert.assertEquals(8,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[8]),maxParallelism));
    records[9]="3";
    Assert.assertEquals(9,KeyGroupRangeAssignment.assignToKeyGroup(keySelector.getKey(records[9]),maxParallelism));
  }
  @Test @SuppressWarnings("unchecked") public void testScalingUp() throws Exception {
    OperatorSubtaskState snapshot;
    try (KeyedOneInputStreamOperatorTestHarness<String,String,Integer> harness=getHarnessTest(keySelector,maxParallelism,1,0)){
      harness.setStateBackend(getStateBackend());
      harness.open();
      validHarnessResult(harness,1,records);
      snapshot=harness.snapshot(0,0);
    }
     KeyedOneInputStreamOperatorTestHarness<String,String,Integer>[] harness2=new KeyedOneInputStreamOperatorTestHarness[3];
    OperatorSubtaskState snapshot2;
    try {
      List<KeyGroupRange> keyGroupPartitions=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism,2);
      KeyGroupRange localKeyGroupRange20=keyGroupPartitions.get(0);
      Assert.assertEquals(new KeyGroupRange(0,4),localKeyGroupRange20);
      harness2[0]=getHarnessTest(keySelector,maxParallelism,2,0);
      harness2[0].setStateBackend(getStateBackend());
      harness2[0].setup();
      harness2[0].initializeState(snapshot);
      harness2[0].open();
      KeyGroupRange localKeyGroupRange21=keyGroupPartitions.get(1);
      Assert.assertEquals(new KeyGroupRange(5,9),localKeyGroupRange21);
      harness2[1]=getHarnessTest(keySelector,maxParallelism,2,1);
      harness2[1].setStateBackend(getStateBackend());
      harness2[1].setup();
      harness2[1].initializeState(snapshot);
      harness2[1].open();
      validHarnessResult(harness2[0],2,records[0],records[1],records[2],records[3],records[4]);
      validHarnessResult(harness2[1],2,records[5],records[6],records[7],records[8],records[9]);
      snapshot2=AbstractStreamOperatorTestHarness.repackageState(harness2[0].snapshot(0,0),harness2[1].snapshot(0,0));
      validHarnessResult(harness2[0],1,records[5],records[6],records[7],records[8],records[9]);
      validHarnessResult(harness2[1],1,records[0],records[1],records[2],records[3],records[4]);
    }
  finally {
      closeHarness(harness2);
    }
    KeyedOneInputStreamOperatorTestHarness<String,String,Integer>[] harness3=new KeyedOneInputStreamOperatorTestHarness[3];
    try {
      List<KeyGroupRange> keyGroupPartitions=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism,3);
      KeyGroupRange localKeyGroupRange30=keyGroupPartitions.get(0);
      Assert.assertEquals(new KeyGroupRange(0,3),localKeyGroupRange30);
      harness3[0]=getHarnessTest(keySelector,maxParallelism,3,0);
      harness3[0].setStateBackend(getStateBackend());
      harness3[0].setup();
      harness3[0].initializeState(snapshot2);
      harness3[0].open();
      KeyGroupRange localKeyGroupRange31=keyGroupPartitions.get(1);
      Assert.assertEquals(new KeyGroupRange(4,6),localKeyGroupRange31);
      harness3[1]=getHarnessTest(keySelector,maxParallelism,3,1);
      harness3[1].setStateBackend(getStateBackend());
      harness3[1].setup();
      harness3[1].initializeState(snapshot2);
      harness3[1].open();
      KeyGroupRange localKeyGroupRange32=keyGroupPartitions.get(2);
      Assert.assertEquals(new KeyGroupRange(7,9),localKeyGroupRange32);
      harness3[2]=getHarnessTest(keySelector,maxParallelism,3,2);
      harness3[2].setStateBackend(getStateBackend());
      harness3[2].setup();
      harness3[2].initializeState(snapshot2);
      harness3[2].open();
      validHarnessResult(harness3[0],3,records[0],records[1],records[2],records[3]);
      validHarnessResult(harness3[1],3,records[4],records[5],records[6]);
      validHarnessResult(harness3[2],3,records[7],records[8],records[9]);
      validHarnessResult(harness3[0],1,records[4],records[5],records[6],records[7],records[8],records[9]);
      validHarnessResult(harness3[1],1,records[0],records[1],records[2],records[3],records[7],records[8],records[9]);
      validHarnessResult(harness3[2],1,records[0],records[1],records[2],records[3],records[4],records[5],records[6]);
    }
  finally {
      closeHarness(harness3);
    }
  }
  @Test @SuppressWarnings("unchecked") public void testScalingDown() throws Exception {
    KeyedOneInputStreamOperatorTestHarness<String,String,Integer>[] harness3=new KeyedOneInputStreamOperatorTestHarness[3];
    OperatorSubtaskState snapshot3;
    try {
      List<KeyGroupRange> keyGroupPartitions=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism,3);
      KeyGroupRange localKeyGroupRange30=keyGroupPartitions.get(0);
      Assert.assertEquals(new KeyGroupRange(0,3),localKeyGroupRange30);
      harness3[0]=getHarnessTest(keySelector,maxParallelism,3,0);
      harness3[0].setStateBackend(getStateBackend());
      harness3[0].open();
      KeyGroupRange localKeyGroupRange31=keyGroupPartitions.get(1);
      Assert.assertEquals(new KeyGroupRange(4,6),localKeyGroupRange31);
      harness3[1]=getHarnessTest(keySelector,maxParallelism,3,1);
      harness3[1].setStateBackend(getStateBackend());
      harness3[1].open();
      KeyGroupRange localKeyGroupRange32=keyGroupPartitions.get(2);
      Assert.assertEquals(new KeyGroupRange(7,9),localKeyGroupRange32);
      harness3[2]=getHarnessTest(keySelector,maxParallelism,3,2);
      harness3[2].setStateBackend(getStateBackend());
      harness3[2].open();
      validHarnessResult(harness3[0],1,records[0],records[1],records[2],records[3]);
      validHarnessResult(harness3[1],1,records[4],records[5],records[6]);
      validHarnessResult(harness3[2],1,records[7],records[8],records[9]);
      snapshot3=AbstractStreamOperatorTestHarness.repackageState(harness3[0].snapshot(0,0),harness3[1].snapshot(0,0),harness3[2].snapshot(0,0));
    }
  finally {
      closeHarness(harness3);
    }
    KeyedOneInputStreamOperatorTestHarness<String,String,Integer>[] harness2=new KeyedOneInputStreamOperatorTestHarness[3];
    OperatorSubtaskState snapshot2;
    try {
      List<KeyGroupRange> keyGroupPartitions=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism,2);
      KeyGroupRange localKeyGroupRange20=keyGroupPartitions.get(0);
      Assert.assertEquals(new KeyGroupRange(0,4),localKeyGroupRange20);
      harness2[0]=getHarnessTest(keySelector,maxParallelism,2,0);
      harness2[0].setStateBackend(getStateBackend());
      harness2[0].setup();
      harness2[0].initializeState(snapshot3);
      harness2[0].open();
      KeyGroupRange localKeyGroupRange21=keyGroupPartitions.get(1);
      Assert.assertEquals(new KeyGroupRange(5,9),localKeyGroupRange21);
      harness2[1]=getHarnessTest(keySelector,maxParallelism,2,1);
      harness2[1].setStateBackend(getStateBackend());
      harness2[1].setup();
      harness2[1].initializeState(snapshot3);
      harness2[1].open();
      validHarnessResult(harness2[0],2,records[0],records[1],records[2],records[3],records[4]);
      validHarnessResult(harness2[1],2,records[5],records[6],records[7],records[8],records[9]);
      snapshot2=AbstractStreamOperatorTestHarness.repackageState(harness2[0].snapshot(0,0),harness2[1].snapshot(0,0));
      validHarnessResult(harness2[0],1,records[5],records[6],records[7],records[8],records[9]);
      validHarnessResult(harness2[1],1,records[0],records[1],records[2],records[3],records[4]);
    }
  finally {
      closeHarness(harness2);
    }
    try (KeyedOneInputStreamOperatorTestHarness<String,String,Integer> harness=getHarnessTest(keySelector,maxParallelism,1,0)){
      harness.setStateBackend(getStateBackend());
      harness.setup();
      harness.initializeState(snapshot2);
      harness.open();
      validHarnessResult(harness,3,records);
    }
   }
  private void closeHarness(  KeyedOneInputStreamOperatorTestHarness<?,?,?>[] harnessArr) throws Exception {
    for (    KeyedOneInputStreamOperatorTestHarness<?,?,?> harness : harnessArr) {
      if (harness != null) {
        harness.close();
      }
    }
  }
  @SuppressWarnings("unchecked") private void validHarnessResult(  KeyedOneInputStreamOperatorTestHarness<?,String,?> harness,  Integer expectedValue,  String... records) throws Exception {
    for (    String record : records) {
      harness.processElement(new StreamRecord<>(record,1));
      StreamRecord<Integer> outputRecord=(StreamRecord<Integer>)harness.getOutput().poll();
      Assert.assertNotNull(outputRecord);
      Assert.assertEquals(expectedValue,outputRecord.getValue());
    }
  }
  private KeyedOneInputStreamOperatorTestHarness<String,String,Integer> getHarnessTest(  KeySelector<String,String> keySelector,  int maxParallelism,  int taskParallelism,  int subtaskIdx) throws Exception {
    return new KeyedOneInputStreamOperatorTestHarness<>(new KeyedProcessOperator<>(new TestKeyedFunction()),keySelector,BasicTypeInfo.STRING_TYPE_INFO,maxParallelism,taskParallelism,subtaskIdx);
  }
  private StateBackend getStateBackend() throws Exception {
    return new RocksDBStateBackend("file://" + rootFolder.newFolder().getAbsolutePath(),true);
  }
  /** 
 * A simple keyed function for tests.
 */
private class TestKeyedFunction extends KeyedProcessFunction<String,String,Integer> {
    private ValueState<Integer> counterState;
    @Override public void open(    Configuration parameters) throws Exception {
      super.open(parameters);
      counterState=this.getRuntimeContext().getState(new ValueStateDescriptor<>("counter",Integer.class));
    }
    @Override public void processElement(    String value,    Context ctx,    Collector<Integer> out) throws Exception {
      Integer oldCount=counterState.value();
      Integer newCount=oldCount != null ? oldCount + 1 : 1;
      counterState.update(newCount);
      out.collect(newCount);
    }
  }
  /** 
 * A simple key selector for tests.
 */
private class TestKeySelector implements KeySelector<String,String> {
    @Override public String getKey(    String value) throws Exception {
      return value;
    }
  }
}
