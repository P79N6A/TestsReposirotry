/** 
 * Tests for the  {@link ConjunctFuture} and {@link FutureUtils.WaitingConjunctFuture}.
 */
@RunWith(Parameterized.class) public class ConjunctFutureTest extends TestLogger {
  @Parameterized.Parameters public static Collection<FutureFactory> parameters(){
    return Arrays.asList(new ConjunctFutureFactory(),new WaitingFutureFactory());
  }
  @Parameterized.Parameter public FutureFactory futureFactory;
  @Test public void testConjunctFutureFailsOnEmptyAndNull() throws Exception {
    try {
      futureFactory.createFuture(null);
      fail();
    }
 catch (    NullPointerException ignored) {
    }
    try {
      futureFactory.createFuture(Arrays.asList(new CompletableFuture<>(),null,new CompletableFuture<>()));
      fail();
    }
 catch (    NullPointerException ignored) {
    }
  }
  @Test public void testConjunctFutureCompletion() throws Exception {
    java.util.concurrent.CompletableFuture<Object> future1=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future2=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future3=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future4=new java.util.concurrent.CompletableFuture<>();
    future2.complete(new Object());
    ConjunctFuture<?> result=futureFactory.createFuture(Arrays.asList(future1,future2,future3,future4));
    CompletableFuture<?> resultMapped=result.thenAccept(value -> {
    }
);
    assertEquals(4,result.getNumFuturesTotal());
    assertEquals(1,result.getNumFuturesCompleted());
    assertFalse(result.isDone());
    assertFalse(resultMapped.isDone());
    future4.complete(new Object());
    assertEquals(2,result.getNumFuturesCompleted());
    assertFalse(result.isDone());
    assertFalse(resultMapped.isDone());
    future1.complete(new Object());
    assertEquals(3,result.getNumFuturesCompleted());
    assertFalse(result.isDone());
    assertFalse(resultMapped.isDone());
    future1.complete(new Object());
    assertEquals(3,result.getNumFuturesCompleted());
    assertFalse(result.isDone());
    assertFalse(resultMapped.isDone());
    future3.complete(new Object());
    assertEquals(4,result.getNumFuturesCompleted());
    assertTrue(result.isDone());
    assertTrue(resultMapped.isDone());
  }
  @Test public void testConjunctFutureFailureOnFirst() throws Exception {
    java.util.concurrent.CompletableFuture<Object> future1=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future2=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future3=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future4=new java.util.concurrent.CompletableFuture<>();
    ConjunctFuture<?> result=futureFactory.createFuture(Arrays.asList(future1,future2,future3,future4));
    CompletableFuture<?> resultMapped=result.thenAccept(value -> {
    }
);
    assertEquals(4,result.getNumFuturesTotal());
    assertEquals(0,result.getNumFuturesCompleted());
    assertFalse(result.isDone());
    assertFalse(resultMapped.isDone());
    future2.completeExceptionally(new IOException());
    assertEquals(0,result.getNumFuturesCompleted());
    assertTrue(result.isDone());
    assertTrue(resultMapped.isDone());
    try {
      result.get();
      fail();
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof IOException);
    }
    try {
      resultMapped.get();
      fail();
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof IOException);
    }
  }
  @Test public void testConjunctFutureFailureOnSuccessive() throws Exception {
    java.util.concurrent.CompletableFuture<Object> future1=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future2=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future3=new java.util.concurrent.CompletableFuture<>();
    java.util.concurrent.CompletableFuture<Object> future4=new java.util.concurrent.CompletableFuture<>();
    ConjunctFuture<?> result=futureFactory.createFuture(Arrays.asList(future1,future2,future3,future4));
    assertEquals(4,result.getNumFuturesTotal());
    java.util.concurrent.CompletableFuture<?> resultMapped=result.thenAccept(value -> {
    }
);
    future1.complete(new Object());
    future3.complete(new Object());
    future4.complete(new Object());
    future2.completeExceptionally(new IOException());
    assertEquals(3,result.getNumFuturesCompleted());
    assertTrue(result.isDone());
    assertTrue(resultMapped.isDone());
    try {
      result.get();
      fail();
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof IOException);
    }
    try {
      resultMapped.get();
      fail();
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof IOException);
    }
  }
  /** 
 * Tests that the conjunct future returns upon completion the collection of all future values
 */
  @Test public void testConjunctFutureValue() throws ExecutionException, InterruptedException {
    java.util.concurrent.CompletableFuture<Integer> future1=java.util.concurrent.CompletableFuture.completedFuture(1);
    java.util.concurrent.CompletableFuture<Long> future2=java.util.concurrent.CompletableFuture.completedFuture(2L);
    java.util.concurrent.CompletableFuture<Double> future3=new java.util.concurrent.CompletableFuture<>();
    ConjunctFuture<Collection<Number>> result=FutureUtils.combineAll(Arrays.asList(future1,future2,future3));
    assertFalse(result.isDone());
    future3.complete(.1);
    assertTrue(result.isDone());
    assertThat(result.get(),IsIterableContainingInAnyOrder.<Number>containsInAnyOrder(1,2L,.1));
  }
  @Test public void testConjunctOfNone() throws Exception {
    final ConjunctFuture<?> result=futureFactory.createFuture(Collections.<java.util.concurrent.CompletableFuture<Object>>emptyList());
    assertEquals(0,result.getNumFuturesTotal());
    assertEquals(0,result.getNumFuturesCompleted());
    assertTrue(result.isDone());
  }
  /** 
 * Factory to create  {@link ConjunctFuture} for testing.
 */
private interface FutureFactory {
    ConjunctFuture<?> createFuture(    Collection<? extends java.util.concurrent.CompletableFuture<?>> futures);
  }
private static class ConjunctFutureFactory implements FutureFactory {
    @Override public ConjunctFuture<?> createFuture(    Collection<? extends java.util.concurrent.CompletableFuture<?>> futures){
      return FutureUtils.combineAll(futures);
    }
  }
private static class WaitingFutureFactory implements FutureFactory {
    @Override public ConjunctFuture<?> createFuture(    Collection<? extends java.util.concurrent.CompletableFuture<?>> futures){
      return FutureUtils.waitForAll(futures);
    }
  }
}
