/** 
 */
public class ChannelViewsTest {
  private static final long SEED=649180756312423613L;
  private static final int KEY_MAX=Integer.MAX_VALUE;
  private static final int VALUE_SHORT_LENGTH=114;
  private static final int VALUE_LONG_LENGTH=112 * 1024;
  private static final int NUM_PAIRS_SHORT=1000000;
  private static final int NUM_PAIRS_LONG=3000;
  private static final int MEMORY_SIZE=1024 * 1024;
  private static final int MEMORY_PAGE_SIZE=64 * 1024;
  private static final int NUM_MEMORY_SEGMENTS=3;
  private final AbstractInvokable parentTask=new DummyInvokable();
  private IOManager ioManager;
  private MemoryManager memoryManager;
  @Before public void beforeTest(){
    this.memoryManager=new MemoryManager(MEMORY_SIZE,1,MEMORY_PAGE_SIZE,MemoryType.HEAP,true);
    this.ioManager=new IOManagerAsync();
  }
  @After public void afterTest(){
    this.ioManager.shutdown();
    if (!this.ioManager.isProperlyShutDown()) {
      Assert.fail("I/O Manager was not properly shut down.");
    }
    if (memoryManager != null) {
      Assert.assertTrue("Memory leak: not all segments have been returned to the memory manager.",this.memoryManager.verifyEmpty());
      this.memoryManager.shutdown();
      this.memoryManager=null;
    }
  }
  @Test public void testWriteReadSmallRecords() throws Exception {
    final TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    final FileIOChannel.ID channel=this.ioManager.createChannel();
    final TypeSerializer<Tuple2<Integer,String>> serializer=TestData.getIntStringTupleSerializer();
    List<MemorySegment> memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
    final ChannelWriterOutputView outView=new ChannelWriterOutputView(writer,memory,MEMORY_PAGE_SIZE);
    final Tuple2<Integer,String> rec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.serialize(rec,outView);
    }
    this.memoryManager.release(outView.close());
    memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelReader<MemorySegment> reader=this.ioManager.createBlockChannelReader(channel);
    final ChannelReaderInputView inView=new ChannelReaderInputView(reader,memory,outView.getBlockCount(),true);
    generator.reset();
    final Tuple2<Integer,String> readRec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.deserialize(readRec,inView);
      int k1=rec.f0;
      String v1=rec.f1;
      int k2=readRec.f0;
      String v2=readRec.f1;
      Assert.assertTrue("The re-generated and the read record do not match.",k1 == k2 && v1.equals(v2));
    }
    this.memoryManager.release(inView.close());
    reader.deleteChannel();
  }
  @Test public void testWriteAndReadLongRecords() throws Exception {
    final TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LONG_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    final FileIOChannel.ID channel=this.ioManager.createChannel();
    final TypeSerializer<Tuple2<Integer,String>> serializer=TestData.getIntStringTupleSerializer();
    List<MemorySegment> memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
    final ChannelWriterOutputView outView=new ChannelWriterOutputView(writer,memory,MEMORY_PAGE_SIZE);
    final Tuple2<Integer,String> rec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_LONG; i++) {
      generator.next(rec);
      serializer.serialize(rec,outView);
    }
    this.memoryManager.release(outView.close());
    memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelReader<MemorySegment> reader=this.ioManager.createBlockChannelReader(channel);
    final ChannelReaderInputView inView=new ChannelReaderInputView(reader,memory,outView.getBlockCount(),true);
    generator.reset();
    final Tuple2<Integer,String> readRec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_LONG; i++) {
      generator.next(rec);
      serializer.deserialize(readRec,inView);
      final int k1=rec.f0;
      final String v1=rec.f1;
      final int k2=readRec.f0;
      final String v2=readRec.f1;
      Assert.assertTrue("The re-generated and the read record do not match.",k1 == k2 && v1.equals(v2));
    }
    this.memoryManager.release(inView.close());
    reader.deleteChannel();
  }
  @Test public void testReadTooMany() throws Exception {
    final TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    final FileIOChannel.ID channel=this.ioManager.createChannel();
    final TypeSerializer<Tuple2<Integer,String>> serializer=TestData.getIntStringTupleSerializer();
    List<MemorySegment> memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
    final ChannelWriterOutputView outView=new ChannelWriterOutputView(writer,memory,MEMORY_PAGE_SIZE);
    final Tuple2<Integer,String> rec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.serialize(rec,outView);
    }
    this.memoryManager.release(outView.close());
    memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelReader<MemorySegment> reader=this.ioManager.createBlockChannelReader(channel);
    final ChannelReaderInputView inView=new ChannelReaderInputView(reader,memory,outView.getBlockCount(),true);
    generator.reset();
    try {
      final Tuple2<Integer,String> readRec=new Tuple2<>();
      for (int i=0; i < NUM_PAIRS_SHORT + 1; i++) {
        generator.next(rec);
        serializer.deserialize(readRec,inView);
        final int k1=rec.f0;
        final String v1=rec.f1;
        final int k2=readRec.f0;
        final String v2=readRec.f1;
        Assert.assertTrue("The re-generated and the read record do not match.",k1 == k2 && v1.equals(v2));
      }
      Assert.fail("Expected an EOFException which did not occur.");
    }
 catch (    EOFException eofex) {
    }
catch (    Throwable t) {
      Assert.fail("Unexpected Exception: " + t.getMessage());
    }
    this.memoryManager.release(inView.close());
    reader.deleteChannel();
  }
  @Test public void testReadWithoutKnownBlockCount() throws Exception {
    final TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    final FileIOChannel.ID channel=this.ioManager.createChannel();
    final TypeSerializer<Tuple2<Integer,String>> serializer=TestData.getIntStringTupleSerializer();
    List<MemorySegment> memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
    final ChannelWriterOutputView outView=new ChannelWriterOutputView(writer,memory,MEMORY_PAGE_SIZE);
    final Tuple2<Integer,String> rec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.serialize(rec,outView);
    }
    this.memoryManager.release(outView.close());
    memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelReader<MemorySegment> reader=this.ioManager.createBlockChannelReader(channel);
    final ChannelReaderInputView inView=new ChannelReaderInputView(reader,memory,true);
    generator.reset();
    final Tuple2<Integer,String> readRec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.deserialize(readRec,inView);
      int k1=rec.f0;
      String v1=rec.f1;
      int k2=readRec.f0;
      String v2=readRec.f1;
      Assert.assertTrue("The re-generated and the read record do not match.",k1 == k2 && v1.equals(v2));
    }
    this.memoryManager.release(inView.close());
    reader.deleteChannel();
  }
  @Test public void testWriteReadOneBufferOnly() throws Exception {
    final TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    final FileIOChannel.ID channel=this.ioManager.createChannel();
    final TypeSerializer<Tuple2<Integer,String>> serializer=TestData.getIntStringTupleSerializer();
    List<MemorySegment> memory=this.memoryManager.allocatePages(this.parentTask,1);
    final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
    final ChannelWriterOutputView outView=new ChannelWriterOutputView(writer,memory,MEMORY_PAGE_SIZE);
    final Tuple2<Integer,String> rec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.serialize(rec,outView);
    }
    this.memoryManager.release(outView.close());
    memory=this.memoryManager.allocatePages(this.parentTask,1);
    final BlockChannelReader<MemorySegment> reader=this.ioManager.createBlockChannelReader(channel);
    final ChannelReaderInputView inView=new ChannelReaderInputView(reader,memory,outView.getBlockCount(),true);
    generator.reset();
    final Tuple2<Integer,String> readRec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.deserialize(readRec,inView);
      int k1=rec.f0;
      String v1=rec.f1;
      int k2=readRec.f0;
      String v2=readRec.f1;
      Assert.assertTrue("The re-generated and the read record do not match.",k1 == k2 && v1.equals(v2));
    }
    this.memoryManager.release(inView.close());
    reader.deleteChannel();
  }
  @Test public void testWriteReadNotAll() throws Exception {
    final TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    final FileIOChannel.ID channel=this.ioManager.createChannel();
    final TypeSerializer<Tuple2<Integer,String>> serializer=TestData.getIntStringTupleSerializer();
    List<MemorySegment> memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
    final ChannelWriterOutputView outView=new ChannelWriterOutputView(writer,memory,MEMORY_PAGE_SIZE);
    final Tuple2<Integer,String> rec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT; i++) {
      generator.next(rec);
      serializer.serialize(rec,outView);
    }
    this.memoryManager.release(outView.close());
    memory=this.memoryManager.allocatePages(this.parentTask,NUM_MEMORY_SEGMENTS);
    final BlockChannelReader<MemorySegment> reader=this.ioManager.createBlockChannelReader(channel);
    final ChannelReaderInputView inView=new ChannelReaderInputView(reader,memory,outView.getBlockCount(),true);
    generator.reset();
    final Tuple2<Integer,String> readRec=new Tuple2<>();
    for (int i=0; i < NUM_PAIRS_SHORT / 2; i++) {
      generator.next(rec);
      serializer.deserialize(readRec,inView);
      int k1=rec.f0;
      String v1=rec.f1;
      int k2=readRec.f0;
      String v2=readRec.f1;
      Assert.assertTrue("The re-generated and the read record do not match.",k1 == k2 && v1.equals(v2));
    }
    this.memoryManager.release(inView.close());
    reader.deleteChannel();
  }
}
