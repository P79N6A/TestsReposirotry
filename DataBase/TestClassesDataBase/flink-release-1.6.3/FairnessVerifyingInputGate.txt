private static class FairnessVerifyingInputGate extends SingleInputGate {
  private final ArrayDeque<InputChannel> channelsWithData;
  private final HashSet<InputChannel> uniquenessChecker;
  @SuppressWarnings("unchecked") public FairnessVerifyingInputGate(  String owningTaskName,  JobID jobId,  IntermediateDataSetID consumedResultId,  int consumedSubpartitionIndex,  int numberOfInputChannels,  TaskActions taskActions,  TaskIOMetricGroup metrics,  boolean isCreditBased){
    super(owningTaskName,jobId,consumedResultId,ResultPartitionType.PIPELINED,consumedSubpartitionIndex,numberOfInputChannels,taskActions,metrics,isCreditBased);
    try {
      Field f=SingleInputGate.class.getDeclaredField("inputChannelsWithData");
      f.setAccessible(true);
      channelsWithData=(ArrayDeque<InputChannel>)f.get(this);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    this.uniquenessChecker=new HashSet<>();
  }
  @Override public Optional<BufferOrEvent> getNextBufferOrEvent() throws IOException, InterruptedException {
synchronized (channelsWithData) {
      assertTrue("too many input channels",channelsWithData.size() <= getNumberOfInputChannels());
      ensureUnique(channelsWithData);
    }
    return super.getNextBufferOrEvent();
  }
  private void ensureUnique(  Collection<InputChannel> channels){
    HashSet<InputChannel> uniquenessChecker=this.uniquenessChecker;
    for (    InputChannel channel : channels) {
      if (!uniquenessChecker.add(channel)) {
        fail("Duplicate channel in input gate: " + channel);
      }
    }
    assertTrue("found duplicate input channels",uniquenessChecker.size() == channels.size());
    uniquenessChecker.clear();
  }
}
