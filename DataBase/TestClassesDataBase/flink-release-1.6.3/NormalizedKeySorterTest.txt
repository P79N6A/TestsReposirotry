public class NormalizedKeySorterTest {
  private static final long SEED=649180756312423613L;
  private static final long SEED2=97652436586326573L;
  private static final int KEY_MAX=Integer.MAX_VALUE;
  private static final int VALUE_LENGTH=118;
  private static final int MEMORY_SIZE=1024 * 1024 * 64;
  private static final int MEMORY_PAGE_SIZE=32 * 1024;
  private MemoryManager memoryManager;
  @Before public void beforeTest(){
    this.memoryManager=new MemoryManager(MEMORY_SIZE,1,MEMORY_PAGE_SIZE,MemoryType.HEAP,true);
  }
  @After public void afterTest(){
    if (!this.memoryManager.verifyEmpty()) {
      Assert.fail("Memory Leak: Some memory has not been returned to the memory manager.");
    }
    if (this.memoryManager != null) {
      this.memoryManager.shutdown();
      this.memoryManager=null;
    }
  }
  private NormalizedKeySorter<Tuple2<Integer,String>> newSortBuffer(  List<MemorySegment> memory) throws Exception {
    return new NormalizedKeySorter<>(TestData.getIntStringTupleSerializer(),TestData.getIntStringTupleComparator(),memory);
  }
  @Test public void testWriteAndRead() throws Exception {
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=newSortBuffer(memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    int num=-1;
    do {
      generator.next(record);
      num++;
    }
 while (sorter.write(record));
    generator.reset();
    Tuple2<Integer,String> readTarget=new Tuple2<>();
    int i=0;
    while (i < num) {
      generator.next(record);
      readTarget=sorter.getRecord(readTarget,i++);
      int rk=readTarget.f0;
      int gk=record.f0;
      String rv=readTarget.f1;
      String gv=record.f1;
      Assert.assertEquals("The re-read key is wrong",gk,rk);
      Assert.assertEquals("The re-read value is wrong",gv,rv);
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
  @Test public void testWriteAndIterator() throws Exception {
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=newSortBuffer(memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    do {
      generator.next(record);
    }
 while (sorter.write(record));
    generator.reset();
    MutableObjectIterator<Tuple2<Integer,String>> iter=sorter.getIterator();
    Tuple2<Integer,String> readTarget=new Tuple2<>();
    while ((readTarget=iter.next(readTarget)) != null) {
      generator.next(record);
      int rk=readTarget.f0;
      int gk=record.f0;
      String rv=readTarget.f1;
      String gv=record.f1;
      Assert.assertEquals("The re-read key is wrong",gk,rk);
      Assert.assertEquals("The re-read value is wrong",gv,rv);
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
  @Test public void testReset() throws Exception {
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=newSortBuffer(memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    int num=-1;
    do {
      generator.next(record);
      num++;
    }
 while (sorter.write(record));
    sorter.reset();
    generator=new TestData.TupleGenerator(SEED2,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
    int num2=-1;
    do {
      generator.next(record);
      num2++;
    }
 while (sorter.write(record));
    Assert.assertEquals("The number of records written after the reset was not the same as before.",num,num2);
    generator.reset();
    Tuple2<Integer,String> readTarget=new Tuple2<>();
    int i=0;
    while (i < num) {
      generator.next(record);
      readTarget=sorter.getRecord(readTarget,i++);
      int rk=readTarget.f0;
      int gk=record.f0;
      String rv=readTarget.f1;
      String gv=record.f1;
      Assert.assertEquals("The re-read key is wrong",gk,rk);
      Assert.assertEquals("The re-read value is wrong",gv,rv);
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
  /** 
 * The swap test fills the sort buffer and swaps all elements such that they are backwards. It then resets the generator, goes backwards through the buffer and compares for equality.
 */
  @Test public void testSwap() throws Exception {
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=newSortBuffer(memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    int num=-1;
    do {
      generator.next(record);
      num++;
    }
 while (sorter.write(record));
    int start=0, end=num - 1;
    while (start < end) {
      sorter.swap(start++,end--);
    }
    generator.reset();
    Tuple2<Integer,String> readTarget=new Tuple2<>();
    int i=num - 1;
    while (i >= 0) {
      generator.next(record);
      readTarget=sorter.getRecord(readTarget,i--);
      int rk=readTarget.f0;
      int gk=record.f0;
      String rv=readTarget.f1;
      String gv=record.f1;
      Assert.assertEquals("The re-read key is wrong",gk,rk);
      Assert.assertEquals("The re-read value is wrong",gv,rv);
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
  /** 
 * The compare test creates a sorted stream, writes it to the buffer and compares random elements. It expects that earlier elements are lower than later ones.
 */
  @Test public void testCompare() throws Exception {
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=newSortBuffer(memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.SORTED,ValueMode.RANDOM_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    int num=-1;
    do {
      generator.next(record);
      num++;
    }
 while (sorter.write(record));
    Random rnd=new Random(SEED << 1);
    for (int i=0; i < 2 * num; i++) {
      int pos1=rnd.nextInt(num);
      int pos2=rnd.nextInt(num);
      int cmp=sorter.compare(pos1,pos2);
      if (pos1 < pos2) {
        Assert.assertTrue(cmp <= 0);
      }
 else {
        Assert.assertTrue(cmp >= 0);
      }
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
  @Test public void testSort() throws Exception {
    final int NUM_RECORDS=559273;
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=newSortBuffer(memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    int num=0;
    do {
      generator.next(record);
      num++;
    }
 while (sorter.write(record) && num < NUM_RECORDS);
    QuickSort qs=new QuickSort();
    qs.sort(sorter);
    MutableObjectIterator<Tuple2<Integer,String>> iter=sorter.getIterator();
    Tuple2<Integer,String> readTarget=new Tuple2<>();
    iter.next(readTarget);
    int last=readTarget.f0;
    while ((readTarget=iter.next(readTarget)) != null) {
      int current=readTarget.f0;
      final int cmp=last - current;
      if (cmp > 0) {
        Assert.fail("Next key is not larger or equal to previous key.");
      }
      last=current;
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
  @Test public void testSortShortStringKeys() throws Exception {
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    @SuppressWarnings("unchecked") TypeComparator<Tuple2<Integer,String>> accessors=TestData.getIntStringTupleTypeInfo().createComparator(new int[]{1},new boolean[]{true},0,null);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=new NormalizedKeySorter<>(TestData.getIntStringTupleSerializer(),accessors,memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,5,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    do {
      generator.next(record);
    }
 while (sorter.write(record));
    QuickSort qs=new QuickSort();
    qs.sort(sorter);
    MutableObjectIterator<Tuple2<Integer,String>> iter=sorter.getIterator();
    Tuple2<Integer,String> readTarget=new Tuple2<>();
    iter.next(readTarget);
    String last=readTarget.f1;
    while ((readTarget=iter.next(readTarget)) != null) {
      String current=readTarget.f1;
      final int cmp=last.compareTo(current);
      if (cmp > 0) {
        Assert.fail("Next value is not larger or equal to previous value.");
      }
      last=current;
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
  @Test public void testSortLongStringKeys() throws Exception {
    final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
    final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
    @SuppressWarnings("unchecked") TypeComparator<Tuple2<Integer,String>> accessors=TestData.getIntStringTupleTypeInfo().createComparator(new int[]{1},new boolean[]{true},0,null);
    NormalizedKeySorter<Tuple2<Integer,String>> sorter=new NormalizedKeySorter<>(TestData.getIntStringTupleSerializer(),accessors,memory);
    TestData.TupleGenerator generator=new TestData.TupleGenerator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
    Tuple2<Integer,String> record=new Tuple2<>();
    do {
      generator.next(record);
    }
 while (sorter.write(record));
    QuickSort qs=new QuickSort();
    qs.sort(sorter);
    MutableObjectIterator<Tuple2<Integer,String>> iter=sorter.getIterator();
    Tuple2<Integer,String> readTarget=new Tuple2<>();
    iter.next(readTarget);
    String last=readTarget.f1;
    while ((readTarget=iter.next(readTarget)) != null) {
      String current=readTarget.f1;
      final int cmp=last.compareTo(current);
      if (cmp > 0) {
        Assert.fail("Next value is not larger or equal to previous value.");
      }
      last=current;
    }
    sorter.dispose();
    this.memoryManager.release(memory);
  }
}
