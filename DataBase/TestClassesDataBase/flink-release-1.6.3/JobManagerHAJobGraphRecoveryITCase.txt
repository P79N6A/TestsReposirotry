/** 
 * Tests recovery of  {@link SubmittedJobGraph} instances.
 */
public class JobManagerHAJobGraphRecoveryITCase extends TestLogger {
  private static final ZooKeeperTestEnvironment ZooKeeper=new ZooKeeperTestEnvironment(1);
  private static final FiniteDuration TestTimeOut=new FiniteDuration(5,TimeUnit.MINUTES);
  @Rule public TemporaryFolder tempFolder=new TemporaryFolder();
  @AfterClass public static void tearDown() throws Exception {
    ZooKeeper.shutdown();
  }
  @Before public void cleanUp() throws Exception {
    ZooKeeper.deleteAll();
  }
  /** 
 * Tests that the HA job is not cleaned up when the jobmanager is stopped.
 */
  @Test public void testJobPersistencyWhenJobManagerShutdown() throws Exception {
    Configuration config=ZooKeeperTestUtils.createZooKeeperHAConfig(ZooKeeper.getConnectString(),tempFolder.getRoot().getPath());
    config.setInteger(ConfigConstants.LOCAL_NUMBER_JOB_MANAGER,1);
    config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER,1);
    TestingCluster flink=new TestingCluster(config,false,false);
    try {
      final Deadline deadline=TestTimeOut.fromNow();
      flink.start(true);
      JobGraph jobGraph=createBlockingJobGraph();
      ExecutionConfig ec=new ExecutionConfig();
      ec.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE,100));
      jobGraph.setExecutionConfig(ec);
      ActorGateway jobManager=flink.getLeaderGateway(deadline.timeLeft());
      jobManager.tell(new SubmitJob(jobGraph,ListeningBehaviour.DETACHED));
      JobManagerActorTestUtils.waitForJobStatus(jobGraph.getJobID(),JobStatus.RUNNING,jobManager,deadline.timeLeft());
    }
  finally {
      flink.stop();
    }
    verifyRecoveryState(config);
  }
  /** 
 * Tests that clients receive updates after recovery by a new leader.
 */
  @Test public void testClientNonDetachedListeningBehaviour() throws Exception {
    Configuration config=ZooKeeperTestUtils.createZooKeeperHAConfig(ZooKeeper.getConnectString(),tempFolder.getRoot().getPath());
    ActorSystem testSystem=null;
    JobManagerProcess[] jobManagerProcess=new JobManagerProcess[2];
    LeaderRetrievalService leaderRetrievalService=null;
    ActorSystem taskManagerSystem=null;
    final HighAvailabilityServices highAvailabilityServices=HighAvailabilityServicesUtils.createHighAvailabilityServices(config,TestingUtils.defaultExecutor(),HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION);
    try {
      final Deadline deadline=TestTimeOut.fromNow();
      testSystem=AkkaUtils.createActorSystem(new Configuration(),new Some<>(new Tuple2<String,Object>("localhost",0)));
      jobManagerProcess[0]=new JobManagerProcess(0,config);
      jobManagerProcess[1]=new JobManagerProcess(1,config);
      jobManagerProcess[0].startProcess();
      jobManagerProcess[1].startProcess();
      TestingListener leaderListener=new TestingListener();
      leaderRetrievalService=highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID);
      leaderRetrievalService.start(leaderListener);
      taskManagerSystem=AkkaUtils.createActorSystem(AkkaUtils.getDefaultAkkaConfig());
      TaskManager.startTaskManagerComponentsAndActor(config,ResourceID.generate(),taskManagerSystem,highAvailabilityServices,NoOpMetricRegistry.INSTANCE,"localhost",Option.<String>empty(),false,TaskManager.class);
      TestActorRef<RecordingTestClient> clientRef=TestActorRef.create(testSystem,Props.create(RecordingTestClient.class));
      JobGraph jobGraph=createBlockingJobGraph();
{
        leaderListener.waitForNewLeader(deadline.timeLeft().toMillis());
        String leaderAddress=leaderListener.getAddress();
        UUID leaderId=leaderListener.getLeaderSessionID();
        AkkaActorGateway client=new AkkaActorGateway(clientRef,leaderId);
        ActorRef leaderRef=AkkaUtils.getActorRef(leaderAddress,testSystem,deadline.timeLeft());
        ActorGateway leader=new AkkaActorGateway(leaderRef,leaderId);
        int numSlots=0;
        while (numSlots == 0) {
          Future<?> slotsFuture=leader.ask(JobManagerMessages.getRequestTotalNumberOfSlots(),deadline.timeLeft());
          numSlots=(Integer)Await.result(slotsFuture,deadline.timeLeft());
        }
        leader.tell(new SubmitJob(jobGraph,ListeningBehaviour.EXECUTION_RESULT_AND_STATE_CHANGES),client);
        JobManagerActorTestUtils.waitForJobStatus(jobGraph.getJobID(),JobStatus.RUNNING,leader,deadline.timeLeft());
      }
      JobManagerProcess leadingJobManagerProcess;
      if (jobManagerProcess[0].getJobManagerAkkaURL(deadline.timeLeft()).equals(leaderListener.getAddress())) {
        leadingJobManagerProcess=jobManagerProcess[0];
      }
 else {
        leadingJobManagerProcess=jobManagerProcess[1];
      }
      leadingJobManagerProcess.destroy();
{
        leaderListener.waitForNewLeader(deadline.timeLeft().toMillis());
        String leaderAddress=leaderListener.getAddress();
        UUID leaderId=leaderListener.getLeaderSessionID();
        ActorRef leaderRef=AkkaUtils.getActorRef(leaderAddress,testSystem,deadline.timeLeft());
        ActorGateway leader=new AkkaActorGateway(leaderRef,leaderId);
        JobManagerActorTestUtils.waitForJobStatus(jobGraph.getJobID(),JobStatus.RUNNING,leader,deadline.timeLeft());
        leader.tell(new JobManagerMessages.CancelJob(jobGraph.getJobID()));
      }
      clientRef.underlyingActor().awaitJobResult(deadline.timeLeft().toMillis());
      int jobSubmitSuccessMessages=0;
      for (      Object msg : clientRef.underlyingActor().getMessages()) {
        if (msg instanceof JobManagerMessages.JobSubmitSuccess) {
          jobSubmitSuccessMessages++;
        }
      }
      assertEquals(2,jobSubmitSuccessMessages);
    }
 catch (    Throwable t) {
      t.printStackTrace();
      if (jobManagerProcess[0] != null) {
        jobManagerProcess[0].printProcessLog();
      }
      if (jobManagerProcess[1] != null) {
        jobManagerProcess[1].printProcessLog();
      }
      throw t;
    }
 finally {
      if (jobManagerProcess[0] != null) {
        jobManagerProcess[0].destroy();
      }
      if (jobManagerProcess[1] != null) {
        jobManagerProcess[1].destroy();
      }
      if (leaderRetrievalService != null) {
        leaderRetrievalService.stop();
      }
      if (taskManagerSystem != null) {
        taskManagerSystem.shutdown();
      }
      if (testSystem != null) {
        testSystem.shutdown();
      }
      highAvailabilityServices.closeAndCleanupAllData();
    }
  }
  /** 
 * Simple recording client.
 */
private static class RecordingTestClient extends UntypedActor {
    private final Queue<Object> messages=new ConcurrentLinkedQueue<>();
    private CountDownLatch jobResultLatch=new CountDownLatch(1);
    @Override public void onReceive(    Object message) throws Exception {
      if (message instanceof LeaderSessionMessage) {
        message=((LeaderSessionMessage)message).message();
      }
      messages.add(message);
      if (message instanceof JobManagerMessages.JobResultFailure || message instanceof JobManagerMessages.JobResultSuccess) {
        jobResultLatch.countDown();
      }
    }
    public Queue<Object> getMessages(){
      return messages;
    }
    public void awaitJobResult(    long timeout) throws InterruptedException {
      jobResultLatch.await(timeout,TimeUnit.MILLISECONDS);
    }
  }
  /** 
 * Creates a simple blocking JobGraph.
 */
  private static JobGraph createBlockingJobGraph(){
    JobGraph jobGraph=new JobGraph("Blocking program");
    JobVertex jobVertex=new JobVertex("Blocking Vertex");
    jobVertex.setInvokableClass(BlockingNoOpInvokable.class);
    jobGraph.addVertex(jobVertex);
    return jobGraph;
  }
  /** 
 * Fails the test if the recovery state (file state backend and ZooKeeper) is not clean.
 */
  private void verifyCleanRecoveryState(  Configuration config) throws Exception {
    Collection<File> stateHandles=FileUtils.listFiles(tempFolder.getRoot(),TrueFileFilter.INSTANCE,TrueFileFilter.INSTANCE);
    if (!stateHandles.isEmpty()) {
      fail("File state backend is not clean: " + stateHandles);
    }
    String currentJobsPath=config.getString(HighAvailabilityOptions.HA_ZOOKEEPER_JOBGRAPHS_PATH);
    Stat stat=ZooKeeper.getClient().checkExists().forPath(currentJobsPath);
    if (stat.getCversion() == 0) {
      fail("ZooKeeper state for '" + currentJobsPath + "' has not been modified during "+ "this test. What are you testing?");
    }
    if (stat.getNumChildren() != 0) {
      fail("ZooKeeper path '" + currentJobsPath + "' is not clean: "+ ZooKeeper.getClient().getChildren().forPath(currentJobsPath));
    }
  }
  /** 
 * Fails the test if the recovery state (file state backend and ZooKeeper) has been cleaned.
 */
  private void verifyRecoveryState(  Configuration config) throws Exception {
    Collection<File> stateHandles=FileUtils.listFiles(tempFolder.getRoot(),TrueFileFilter.INSTANCE,TrueFileFilter.INSTANCE);
    if (stateHandles.isEmpty()) {
      fail("File state backend has been cleaned: " + stateHandles);
    }
    String currentJobsPath=config.getString(HighAvailabilityOptions.HA_ZOOKEEPER_JOBGRAPHS_PATH);
    Stat stat=ZooKeeper.getClient().checkExists().forPath(currentJobsPath);
    if (stat.getCversion() == 0) {
      fail("ZooKeeper state for '" + currentJobsPath + "' has not been modified during "+ "this test. What are you testing?");
    }
    if (stat.getNumChildren() == 0) {
      fail("ZooKeeper path '" + currentJobsPath + "' has been cleaned: "+ ZooKeeper.getClient().getChildren().forPath(currentJobsPath));
    }
  }
}
