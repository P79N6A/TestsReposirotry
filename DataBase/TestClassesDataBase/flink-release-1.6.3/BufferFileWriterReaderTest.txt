public class BufferFileWriterReaderTest {
  private static final int BUFFER_SIZE=32 * 1024;
  private static final BufferRecycler BUFFER_RECYCLER=FreeingBufferRecycler.INSTANCE;
  private static final Random random=new Random();
  private static final IOManager ioManager=new IOManagerAsync();
  private BufferFileWriter writer;
  private BufferFileReader reader;
  private LinkedBlockingQueue<Buffer> returnedBuffers=new LinkedBlockingQueue<>();
  @AfterClass public static void shutdown(){
    ioManager.shutdown();
  }
  @Before public void setUpWriterAndReader(){
    final FileIOChannel.ID channel=ioManager.createChannel();
    try {
      writer=ioManager.createBufferFileWriter(channel);
      reader=ioManager.createBufferFileReader(channel,new QueuingCallback<>(returnedBuffers));
    }
 catch (    IOException e) {
      if (writer != null) {
        writer.deleteChannel();
      }
      if (reader != null) {
        reader.deleteChannel();
      }
      fail("Failed to setup writer and reader.");
    }
  }
  @After public void tearDownWriterAndReader(){
    if (writer != null) {
      writer.deleteChannel();
    }
    if (reader != null) {
      reader.deleteChannel();
    }
    returnedBuffers.clear();
  }
  @Test public void testWriteRead() throws IOException {
    int numBuffers=1024;
    int currentNumber=0;
    final int minBufferSize=BUFFER_SIZE / 4;
    for (int i=0; i < numBuffers; i++) {
      final Buffer buffer=createBuffer();
      int size=getNextMultipleOf(getRandomNumberInRange(minBufferSize,BUFFER_SIZE),4);
      currentNumber=fillBufferWithAscendingNumbers(buffer,currentNumber,size);
      writer.writeBlock(buffer);
    }
    writer.close();
    for (int i=0; i < numBuffers; i++) {
      assertFalse(reader.hasReachedEndOfFile());
      reader.readInto(createBuffer());
    }
    reader.close();
    assertTrue(reader.hasReachedEndOfFile());
    assertEquals("Read less buffers than written.",numBuffers,returnedBuffers.size());
    currentNumber=0;
    Buffer buffer;
    while ((buffer=returnedBuffers.poll()) != null) {
      currentNumber=verifyBufferFilledWithAscendingNumbers(buffer,currentNumber);
    }
  }
  @Test public void testWriteSkipRead() throws IOException {
    int numBuffers=1024;
    int currentNumber=0;
    for (int i=0; i < numBuffers; i++) {
      final Buffer buffer=createBuffer();
      currentNumber=fillBufferWithAscendingNumbers(buffer,currentNumber,buffer.getMaxCapacity());
      writer.writeBlock(buffer);
    }
    writer.close();
    final int toSkip=32;
    reader.seekToPosition((8 + BUFFER_SIZE) * toSkip);
    numBuffers-=toSkip;
    for (int i=0; i < numBuffers; i++) {
      assertFalse(reader.hasReachedEndOfFile());
      reader.readInto(createBuffer());
    }
    reader.close();
    assertTrue(reader.hasReachedEndOfFile());
    assertEquals("Read less buffers than written.",numBuffers,returnedBuffers.size());
    currentNumber=(BUFFER_SIZE / 4) * toSkip;
    Buffer buffer;
    while ((buffer=returnedBuffers.poll()) != null) {
      currentNumber=verifyBufferFilledWithAscendingNumbers(buffer,currentNumber);
    }
  }
  private int getRandomNumberInRange(  int min,  int max){
    return random.nextInt((max - min) + 1) + min;
  }
  private int getNextMultipleOf(  int number,  int multiple){
    final int mod=number % multiple;
    if (mod == 0) {
      return number;
    }
    return number + multiple - mod;
  }
  private Buffer createBuffer(){
    return new NetworkBuffer(MemorySegmentFactory.allocateUnpooledSegment(BUFFER_SIZE),BUFFER_RECYCLER);
  }
  static int fillBufferWithAscendingNumbers(  Buffer buffer,  int currentNumber,  int size){
    checkArgument(size % 4 == 0);
    MemorySegment segment=buffer.getMemorySegment();
    for (int i=0; i < size; i+=4) {
      segment.putInt(i,currentNumber++);
    }
    buffer.setSize(size);
    return currentNumber;
  }
  static int verifyBufferFilledWithAscendingNumbers(  Buffer buffer,  int currentNumber){
    MemorySegment segment=buffer.getMemorySegment();
    int size=buffer.getSize();
    for (int i=0; i < size; i+=4) {
      if (segment.getInt(i) != currentNumber++) {
        throw new IllegalStateException("Read unexpected number from buffer.");
      }
    }
    return currentNumber;
  }
}
