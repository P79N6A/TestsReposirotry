/** 
 * Tests for the common/shared functionality of  {@link StateDescriptor}.
 */
public class StateDescriptorTest {
  @Test public void testInitializeWithSerializer() throws Exception {
    final TypeSerializer<String> serializer=StringSerializer.INSTANCE;
    final TestStateDescriptor<String> descr=new TestStateDescriptor<>("test",serializer);
    assertTrue(descr.isSerializerInitialized());
    assertNotNull(descr.getSerializer());
    assertTrue(descr.getSerializer() instanceof StringSerializer);
    descr.initializeSerializerUnlessSet(new ExecutionConfig());
    assertTrue(descr.isSerializerInitialized());
    assertNotNull(descr.getSerializer());
    assertTrue(descr.getSerializer() instanceof StringSerializer);
    TestStateDescriptor<String> clone=CommonTestUtils.createCopySerializable(descr);
    assertTrue(clone.isSerializerInitialized());
    assertNotNull(clone.getSerializer());
    assertTrue(clone.getSerializer() instanceof StringSerializer);
  }
  @Test public void testInitializeSerializerBeforeSerialization() throws Exception {
    final TestStateDescriptor<String> descr=new TestStateDescriptor<>("test",String.class);
    assertFalse(descr.isSerializerInitialized());
    try {
      descr.getSerializer();
      fail("should fail with an exception");
    }
 catch (    IllegalStateException ignored) {
    }
    descr.initializeSerializerUnlessSet(new ExecutionConfig());
    assertTrue(descr.isSerializerInitialized());
    assertNotNull(descr.getSerializer());
    assertTrue(descr.getSerializer() instanceof StringSerializer);
    TestStateDescriptor<String> clone=CommonTestUtils.createCopySerializable(descr);
    assertTrue(clone.isSerializerInitialized());
    assertNotNull(clone.getSerializer());
    assertTrue(clone.getSerializer() instanceof StringSerializer);
  }
  @Test public void testInitializeSerializerAfterSerialization() throws Exception {
    final TestStateDescriptor<String> descr=new TestStateDescriptor<>("test",String.class);
    assertFalse(descr.isSerializerInitialized());
    try {
      descr.getSerializer();
      fail("should fail with an exception");
    }
 catch (    IllegalStateException ignored) {
    }
    TestStateDescriptor<String> clone=CommonTestUtils.createCopySerializable(descr);
    assertFalse(clone.isSerializerInitialized());
    try {
      clone.getSerializer();
      fail("should fail with an exception");
    }
 catch (    IllegalStateException ignored) {
    }
    clone.initializeSerializerUnlessSet(new ExecutionConfig());
    assertTrue(clone.isSerializerInitialized());
    assertNotNull(clone.getSerializer());
    assertTrue(clone.getSerializer() instanceof StringSerializer);
  }
  @Test public void testInitializeSerializerAfterSerializationWithCustomConfig() throws Exception {
    assertEquals("broken test assumption",-1,new KryoSerializer<>(String.class,new ExecutionConfig()).getKryo().getRegistration(File.class).getId());
    final ExecutionConfig config=new ExecutionConfig();
    config.registerKryoType(File.class);
    final TestStateDescriptor<Path> original=new TestStateDescriptor<>("test",Path.class);
    TestStateDescriptor<Path> clone=CommonTestUtils.createCopySerializable(original);
    clone.initializeSerializerUnlessSet(config);
    assertTrue(((KryoSerializer<?>)clone.getSerializer()).getKryo().getRegistration(File.class).getId() > 0);
  }
  /** 
 * FLINK-6775, tests that the returned serializer is duplicated. This allows to share the state descriptor across threads.
 */
  @Test public void testSerializerDuplication() throws Exception {
    TypeSerializer<String> statefulSerializer=new KryoSerializer<>(String.class,new ExecutionConfig());
    TestStateDescriptor<String> descr=new TestStateDescriptor<>("foobar",statefulSerializer);
    TypeSerializer<String> serializerA=descr.getSerializer();
    TypeSerializer<String> serializerB=descr.getSerializer();
    assertNotSame(serializerA,serializerB);
  }
  @Test public void testHashCodeAndEquals() throws Exception {
    final String name="testName";
    TestStateDescriptor<String> original=new TestStateDescriptor<>(name,String.class);
    TestStateDescriptor<String> same=new TestStateDescriptor<>(name,String.class);
    TestStateDescriptor<String> sameBySerializer=new TestStateDescriptor<>(name,StringSerializer.INSTANCE);
    assertEquals(original.hashCode(),same.hashCode());
    assertEquals(original.hashCode(),sameBySerializer.hashCode());
    assertEquals(original,same);
    assertEquals(original,sameBySerializer);
    TestStateDescriptor<String> clone=CommonTestUtils.createCopySerializable(original);
    assertEquals(original,clone);
    clone.initializeSerializerUnlessSet(new ExecutionConfig());
    assertEquals(original,clone);
    original.initializeSerializerUnlessSet(new ExecutionConfig());
    assertEquals(original,same);
  }
  @Test public void testEqualsSameNameAndTypeDifferentClass() throws Exception {
    final String name="test name";
    final TestStateDescriptor<String> descr1=new TestStateDescriptor<>(name,String.class);
    final OtherTestStateDescriptor<String> descr2=new OtherTestStateDescriptor<>(name,String.class);
    assertNotEquals(descr1,descr2);
  }
private static class TestStateDescriptor<T> extends StateDescriptor<State,T> {
    private static final long serialVersionUID=1L;
    TestStateDescriptor(    String name,    TypeSerializer<T> serializer){
      super(name,serializer,null);
    }
    TestStateDescriptor(    String name,    TypeInformation<T> typeInfo){
      super(name,typeInfo,null);
    }
    TestStateDescriptor(    String name,    Class<T> type){
      super(name,type,null);
    }
    @Override public Type getType(){
      return Type.VALUE;
    }
  }
private static class OtherTestStateDescriptor<T> extends StateDescriptor<State,T> {
    private static final long serialVersionUID=1L;
    OtherTestStateDescriptor(    String name,    TypeSerializer<T> serializer){
      super(name,serializer,null);
    }
    OtherTestStateDescriptor(    String name,    TypeInformation<T> typeInfo){
      super(name,typeInfo,null);
    }
    OtherTestStateDescriptor(    String name,    Class<T> type){
      super(name,type,null);
    }
    @Override public Type getType(){
      return Type.VALUE;
    }
  }
}
