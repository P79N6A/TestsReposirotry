/** 
 * Metrics related tests for batch task chains.
 */
public class ChainedOperatorsMetricTest extends TaskTestBase {
  private static final int MEMORY_MANAGER_SIZE=1024 * 1024 * 3;
  private static final int NETWORK_BUFFER_SIZE=1024;
  private static final TypeSerializerFactory<Record> serFact=RecordSerializerFactory.get();
  private final List<Record> outList=new ArrayList<>();
  private static final String HEAD_OPERATOR_NAME="headoperator";
  private static final String CHAINED_OPERATOR_NAME="chainedoperator";
  @Test public void testOperatorIOMetricReuse() throws Exception {
    initEnvironment(MEMORY_MANAGER_SIZE,NETWORK_BUFFER_SIZE);
    this.mockEnv=new MockEnvironmentBuilder().setTaskName(HEAD_OPERATOR_NAME).setMemorySize(MEMORY_MANAGER_SIZE).setInputSplitProvider(this.inputSplitProvider).setBufferSize(NETWORK_BUFFER_SIZE).setMetricGroup(new TaskMetricGroup(NoOpMetricRegistry.INSTANCE,UnregisteredMetricGroups.createUnregisteredTaskManagerJobMetricGroup(),new JobVertexID(),new AbstractID(),"task",0,0)).build();
    final int keyCnt=100;
    final int valCnt=20;
    final int numRecords=keyCnt * valCnt;
    addInput(new UniformRecordGenerator(keyCnt,valCnt,false),0);
    addOutput(this.outList);
    addChainedOperator();
    registerTask(FlatMapDriver.class,DuplicatingFlatMapFunction.class);
    final BatchTask<FlatMapFunction<Record,Record>,Record> testTask=new BatchTask<>(this.mockEnv);
    testTask.invoke();
    Assert.assertEquals(numRecords * 2 * 2,this.outList.size());
    final TaskMetricGroup taskMetricGroup=mockEnv.getMetricGroup();
{
      final TaskIOMetricGroup ioMetricGroup=taskMetricGroup.getIOMetricGroup();
      final Counter numRecordsInCounter=ioMetricGroup.getNumRecordsInCounter();
      final Counter numRecordsOutCounter=ioMetricGroup.getNumRecordsOutCounter();
      Assert.assertEquals(numRecords,numRecordsInCounter.getCount());
      Assert.assertEquals(numRecords * 2 * 2,numRecordsOutCounter.getCount());
    }
{
      final OperatorMetricGroup operatorMetricGroup1=taskMetricGroup.addOperator(HEAD_OPERATOR_NAME);
      final OperatorIOMetricGroup ioMetricGroup=operatorMetricGroup1.getIOMetricGroup();
      final Counter numRecordsInCounter=ioMetricGroup.getNumRecordsInCounter();
      final Counter numRecordsOutCounter=ioMetricGroup.getNumRecordsOutCounter();
      Assert.assertEquals(numRecords,numRecordsInCounter.getCount());
      Assert.assertEquals(numRecords * 2,numRecordsOutCounter.getCount());
    }
{
      final OperatorMetricGroup operatorMetricGroup1=taskMetricGroup.addOperator(CHAINED_OPERATOR_NAME);
      final OperatorIOMetricGroup ioMetricGroup=operatorMetricGroup1.getIOMetricGroup();
      final Counter numRecordsInCounter=ioMetricGroup.getNumRecordsInCounter();
      final Counter numRecordsOutCounter=ioMetricGroup.getNumRecordsOutCounter();
      Assert.assertEquals(numRecords * 2,numRecordsInCounter.getCount());
      Assert.assertEquals(numRecords * 2 * 2,numRecordsOutCounter.getCount());
    }
  }
  private void addChainedOperator(){
    final TaskConfig chainedConfig=new TaskConfig(new Configuration());
    chainedConfig.addInputToGroup(0);
    chainedConfig.setInputSerializer(serFact,0);
    chainedConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
    chainedConfig.setOutputSerializer(serFact);
    chainedConfig.setDriverStrategy(DriverStrategy.FLAT_MAP);
    chainedConfig.setStubWrapper(new UserCodeClassWrapper<>(DuplicatingFlatMapFunction.class));
    getTaskConfig().addChainedTask(ChainedFlatMapDriver.class,chainedConfig,CHAINED_OPERATOR_NAME);
  }
  /** 
 * Simple  {@link FlatMapFunction} that duplicates the input.
 */
public static class DuplicatingFlatMapFunction extends RichFlatMapFunction<Record,Record> {
    private static final long serialVersionUID=-1152068682935346164L;
    @Override public void flatMap(    final Record value,    final Collector<Record> out) throws Exception {
      out.collect(value);
      out.collect(value);
    }
  }
}
