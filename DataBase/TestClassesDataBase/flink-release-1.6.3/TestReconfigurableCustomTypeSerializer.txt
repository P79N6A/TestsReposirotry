/** 
 * A reconfigurable serializer that simulates backwards compatible schema evolution for the  {@link TestCustomStateClass}. A flag is maintained to determine whether or not the serializer has be reconfigured. Whether or not it has been reconfigured affects which fields of  {@link TestCustomStateClass} instances arewritten and read on serialization.
 */
public static class TestReconfigurableCustomTypeSerializer extends TypeSerializer<TestCustomStateClass> {
  private boolean reconfigured=false;
  public TestReconfigurableCustomTypeSerializer(){
  }
  /** 
 * Copy constructor. 
 */
  private TestReconfigurableCustomTypeSerializer(  boolean reconfigured){
    this.reconfigured=reconfigured;
  }
  @Override public TypeSerializerConfigSnapshot snapshotConfiguration(){
    return new ParameterlessTypeSerializerConfig(getClass().getName());
  }
  @Override public CompatibilityResult<TestCustomStateClass> ensureCompatibility(  TypeSerializerConfigSnapshot configSnapshot){
    if (configSnapshot instanceof ParameterlessTypeSerializerConfig && ((ParameterlessTypeSerializerConfig)configSnapshot).getSerializationFormatIdentifier().equals(getClass().getName())) {
      this.reconfigured=true;
      return CompatibilityResult.compatible();
    }
 else {
      return CompatibilityResult.requiresMigration();
    }
  }
  @Override public TypeSerializer<TestCustomStateClass> duplicate(){
    return new TestReconfigurableCustomTypeSerializer(reconfigured);
  }
  @Override public TestCustomStateClass createInstance(){
    return new TestCustomStateClass(null,null);
  }
  @Override public void serialize(  TestCustomStateClass record,  DataOutputView target) throws IOException {
    target.writeBoolean(reconfigured);
    target.writeUTF(record.getMessage());
    if (reconfigured) {
      target.writeUTF(record.getExtraMessage());
    }
  }
  @Override public TestCustomStateClass deserialize(  DataInputView source) throws IOException {
    boolean isNewSchema=source.readBoolean();
    String message=source.readUTF();
    if (isNewSchema) {
      return new TestCustomStateClass(message,source.readUTF());
    }
 else {
      return new TestCustomStateClass(message,null);
    }
  }
  @Override public TestCustomStateClass deserialize(  TestCustomStateClass reuse,  DataInputView source) throws IOException {
    boolean isNewSchema=source.readBoolean();
    String message=source.readUTF();
    if (isNewSchema) {
      reuse.setMessage(message);
      reuse.setExtraMessage(source.readUTF());
      return reuse;
    }
 else {
      reuse.setMessage(message);
      reuse.setExtraMessage(null);
      return reuse;
    }
  }
  @Override public void copy(  DataInputView source,  DataOutputView target) throws IOException {
    boolean reconfigured=source.readBoolean();
    target.writeUTF(source.readUTF());
    if (reconfigured)     target.writeUTF(source.readUTF());
  }
  @Override public TestCustomStateClass copy(  TestCustomStateClass from){
    return new TestCustomStateClass(from.getMessage(),from.getExtraMessage());
  }
  @Override public TestCustomStateClass copy(  TestCustomStateClass from,  TestCustomStateClass reuse){
    reuse.setMessage(from.getMessage());
    reuse.setExtraMessage(from.getExtraMessage());
    return reuse;
  }
  @Override public int getLength(){
    return 0;
  }
  @Override public boolean isImmutableType(){
    return false;
  }
  @Override public boolean canEqual(  Object obj){
    return obj instanceof TestReconfigurableCustomTypeSerializer;
  }
  @Override public boolean equals(  Object obj){
    if (obj == null) {
      return false;
    }
    if (!(obj instanceof TestReconfigurableCustomTypeSerializer)) {
      return false;
    }
    if (obj == this) {
      return true;
    }
 else {
      TestReconfigurableCustomTypeSerializer other=(TestReconfigurableCustomTypeSerializer)obj;
      return other.reconfigured == this.reconfigured;
    }
  }
  @Override public int hashCode(){
    return Objects.hash(getClass().getName(),reconfigured);
  }
  public boolean isReconfigured(){
    return reconfigured;
  }
}
