/** 
 * Tests for the  {@link org.apache.flink.runtime.state.memory.MemoryStateBackend}.
 */
public class MemoryStateBackendTest extends StateBackendTestBase<MemoryStateBackend> {
  @Override protected MemoryStateBackend getStateBackend() throws Exception {
    return new MemoryStateBackend(useAsyncMode());
  }
  protected boolean useAsyncMode(){
    return false;
  }
  @Override protected boolean isSerializerPresenceRequiredOnRestore(){
    return true;
  }
  @Override @Test public void testValueStateRestoreWithWrongSerializers(){
  }
  @Override @Test public void testListStateRestoreWithWrongSerializers(){
  }
  @Override @Test public void testReducingStateRestoreWithWrongSerializers(){
  }
  @Override @Test public void testMapStateRestoreWithWrongSerializers(){
  }
  /** 
 * Verifies that the operator state backend fails with appropriate error and message if previous serializer can not be restored.
 */
  @Test public void testOperatorStateRestoreFailsIfSerializerDeserializationFails() throws Exception {
    DummyEnvironment env=new DummyEnvironment();
    AbstractStateBackend abstractStateBackend=new MemoryStateBackend(4096);
    OperatorStateBackend operatorStateBackend=abstractStateBackend.createOperatorStateBackend(env,"test-op-name");
    ListStateDescriptor<Serializable> stateDescriptor1=new ListStateDescriptor<>("test1",new JavaSerializer<>());
    ListStateDescriptor<Serializable> stateDescriptor2=new ListStateDescriptor<>("test2",new JavaSerializer<>());
    ListStateDescriptor<Serializable> stateDescriptor3=new ListStateDescriptor<>("test3",new JavaSerializer<>());
    ListState<Serializable> listState1=operatorStateBackend.getListState(stateDescriptor1);
    ListState<Serializable> listState2=operatorStateBackend.getListState(stateDescriptor2);
    ListState<Serializable> listState3=operatorStateBackend.getUnionListState(stateDescriptor3);
    listState1.add(42);
    listState1.add(4711);
    listState2.add(7);
    listState2.add(13);
    listState2.add(23);
    listState3.add(17);
    listState3.add(18);
    listState3.add(19);
    listState3.add(20);
    CheckpointStreamFactory streamFactory=new MemCheckpointStreamFactory(MemoryStateBackend.DEFAULT_MAX_STATE_SIZE);
    RunnableFuture<SnapshotResult<OperatorStateHandle>> runnableFuture=operatorStateBackend.snapshot(1,1,streamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
    SnapshotResult<OperatorStateHandle> snapshotResult=FutureUtil.runIfNotDoneAndGet(runnableFuture);
    OperatorStateHandle stateHandle=snapshotResult.getJobManagerOwnedSnapshot();
    try {
      operatorStateBackend.close();
      operatorStateBackend.dispose();
      env=new DummyEnvironment(new ArtificialCNFExceptionThrowingClassLoader(getClass().getClassLoader(),Collections.singleton(JavaSerializer.class.getName())));
      operatorStateBackend=abstractStateBackend.createOperatorStateBackend(env,"testOperator");
      operatorStateBackend.restore(StateObjectCollection.singleton(stateHandle));
      fail("The operator state restore should have failed if the previous state serializer could not be loaded.");
    }
 catch (    IOException expected) {
      Assert.assertTrue(expected.getMessage().contains("Unable to restore operator state"));
    }
 finally {
      stateHandle.discardState();
    }
  }
  /** 
 * Verifies that memory-backed keyed state backend fails with appropriate error and message if previous serializer can not be restored.
 */
  @Test public void testKeyedStateRestoreFailsIfSerializerDeserializationFails() throws Exception {
    CheckpointStreamFactory streamFactory=createStreamFactory();
    SharedStateRegistry sharedStateRegistry=new SharedStateRegistry();
    KeyedStateBackend<Integer> backend=createKeyedBackend(IntSerializer.INSTANCE);
    ValueStateDescriptor<String> kvId=new ValueStateDescriptor<>("id",String.class,null);
    kvId.initializeSerializerUnlessSet(new ExecutionConfig());
    HeapKeyedStateBackend<Integer> heapBackend=(HeapKeyedStateBackend<Integer>)backend;
    assertEquals(0,heapBackend.numKeyValueStateEntries());
    ValueState<String> state=backend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,kvId);
    backend.setCurrentKey(0);
    state.update("hello");
    state.update("ciao");
    KeyedStateHandle snapshot=runSnapshot(((HeapKeyedStateBackend<Integer>)backend).snapshot(682375462378L,2,streamFactory,CheckpointOptions.forCheckpointWithDefaultLocation()),sharedStateRegistry);
    backend.dispose();
    try {
      restoreKeyedBackend(IntSerializer.INSTANCE,snapshot,new DummyEnvironment(new ArtificialCNFExceptionThrowingClassLoader(getClass().getClassLoader(),Collections.singleton(StringSerializer.class.getName()))));
      fail("The keyed state restore should have failed if the previous state serializer could not be loaded.");
    }
 catch (    IOException expected) {
      Assert.assertTrue(expected.getMessage().contains("Unable to restore keyed state"));
    }
  }
  @Ignore @Test public void testConcurrentMapIfQueryable() throws Exception {
    super.testConcurrentMapIfQueryable();
  }
}
