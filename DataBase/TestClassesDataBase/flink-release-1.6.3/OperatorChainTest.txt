/** 
 * This class test the  {@link OperatorChain}. <p>It takes a different (simpler) approach at testing the operator chain than {@link StreamOperatorChainingTest}.
 */
public class OperatorChainTest {
  @Test public void testPrepareCheckpointPreBarrier() throws Exception {
    final AtomicInteger intRef=new AtomicInteger();
    final OneInputStreamOperator<String,String> one=new ValidatingOperator(intRef,0);
    final OneInputStreamOperator<String,String> two=new ValidatingOperator(intRef,1);
    final OneInputStreamOperator<String,String> three=new ValidatingOperator(intRef,2);
    final OperatorChain<?,?> chain=setupOperatorChain(one,two,three);
    chain.prepareSnapshotPreBarrier(ValidatingOperator.CHECKPOINT_ID);
    assertEquals(3,intRef.get());
  }
  @SafeVarargs private static <T,OP extends StreamOperator<T>>OperatorChain<T,OP> setupOperatorChain(  OneInputStreamOperator<T,T>... operators){
    checkNotNull(operators);
    checkArgument(operators.length > 0);
    try (MockEnvironment env=MockEnvironment.builder().build()){
      final StreamTask<?,?> containingTask=new OneInputStreamTask<T,OneInputStreamOperator<T,T>>(env);
      final StreamStatusProvider statusProvider=mock(StreamStatusProvider.class);
      final StreamConfig cfg=new StreamConfig(new Configuration());
      final StreamOperator<?>[] ops=new StreamOperator<?>[operators.length];
      @SuppressWarnings({"unchecked","rawtypes"}) WatermarkGaugeExposingOutput<StreamRecord<T>> lastWriter=new BroadcastingOutputCollector<>(new Output[0],statusProvider);
      for (int i=0; i < ops.length; i++) {
        OneInputStreamOperator<T,T> op=operators[ops.length - i - 1];
        op.setup(containingTask,cfg,lastWriter);
        lastWriter=new ChainingOutput<>(op,statusProvider,null);
        ops[i]=op;
      }
      @SuppressWarnings("unchecked") final OP head=(OP)operators[0];
      return new OperatorChain<>(ops,new RecordWriterOutput<?>[0],lastWriter,head);
    }
   }
private static class ValidatingOperator extends AbstractStreamOperator<String> implements OneInputStreamOperator<String,String> {
    private static final long serialVersionUID=1L;
    static final long CHECKPOINT_ID=5765167L;
    final AtomicInteger toUpdate;
    final int expected;
    public ValidatingOperator(    AtomicInteger toUpdate,    int expected){
      this.toUpdate=toUpdate;
      this.expected=expected;
    }
    @Override public void prepareSnapshotPreBarrier(    long checkpointId) throws Exception {
      assertEquals("wrong checkpointId",CHECKPOINT_ID,checkpointId);
      assertEquals("wrong order",expected,toUpdate.getAndIncrement());
    }
    @Override public void processElement(    StreamRecord<String> element) throws Exception {
      throw new UnsupportedOperationException();
    }
    @Override public OperatorID getOperatorID(){
      return new OperatorID();
    }
  }
}
