private static class TokenizeLine extends RichFlatMapFunction<String,Tuple2<String,Integer>> {
  private IntCounter cntNumLines;
  private Histogram wordsPerLineDistribution;
  private DoubleCounter openCloseCounter=new DoubleCounter();
  private SetAccumulator<StringValue> distinctWords;
  @Override public void open(  Configuration parameters){
    this.cntNumLines=getRuntimeContext().getIntCounter("num-lines");
    this.wordsPerLineDistribution=getRuntimeContext().getHistogram("words-per-line");
    getRuntimeContext().addAccumulator("open-close-counter",this.openCloseCounter);
    this.distinctWords=new SetAccumulator<>();
    this.getRuntimeContext().addAccumulator("distinct-words",distinctWords);
    IntCounter simpleCounter=getRuntimeContext().getIntCounter("simple-counter");
    simpleCounter.add(1);
    Assert.assertEquals(simpleCounter.getLocalValue().intValue(),1);
    IntCounter simpleCounter2=getRuntimeContext().getIntCounter("simple-counter");
    Assert.assertEquals(simpleCounter.getLocalValue(),simpleCounter2.getLocalValue());
    try {
      @SuppressWarnings("unused") DoubleCounter simpleCounter3=getRuntimeContext().getDoubleCounter("simple-counter");
      Assert.fail("Should not be able to obtain previously created counter with different type");
    }
 catch (    UnsupportedOperationException ex) {
    }
    this.openCloseCounter.add(0.5);
  }
  @Override public void flatMap(  String value,  Collector<Tuple2<String,Integer>> out){
    this.cntNumLines.add(1);
    int wordsPerLine=0;
    for (    String token : value.toLowerCase().split("\\W+")) {
      distinctWords.add(new StringValue(token));
      out.collect(new Tuple2<>(token,1));
      ++wordsPerLine;
    }
    wordsPerLineDistribution.add(wordsPerLine);
  }
  @Override public void close() throws Exception {
    this.openCloseCounter.add(0.5);
    Assert.assertEquals(1,this.openCloseCounter.getLocalValue().intValue());
  }
}
