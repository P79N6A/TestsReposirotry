/** 
 * A parallel source with union state used to verify the restored state of {@link CheckpointingParallelSourceWithUnionListState}.
 */
public static class CheckingParallelSourceWithUnionListState extends RichParallelSourceFunction<Tuple2<Long,Long>> implements CheckpointedFunction {
  private static final long serialVersionUID=1L;
  static final String SUCCESSFUL_RESTORE_CHECK_ACCUMULATOR=CheckingParallelSourceWithUnionListState.class + "_RESTORE_CHECK";
  private volatile boolean isRunning=true;
  private final int numElements;
  CheckingParallelSourceWithUnionListState(  int numElements){
    this.numElements=numElements;
  }
  @Override public void snapshotState(  FunctionSnapshotContext context) throws Exception {
  }
  @Override public void initializeState(  FunctionInitializationContext context) throws Exception {
    ListState<String> unionListState=context.getOperatorStateStore().getUnionListState(CheckpointingNonParallelSourceWithListState.STATE_DESCRIPTOR);
    if (context.isRestored()) {
      assertThat(unionListState.get(),containsInAnyOrder(CheckpointingParallelSourceWithUnionListState.CHECKPOINTED_STRINGS));
      getRuntimeContext().addAccumulator(SUCCESSFUL_RESTORE_CHECK_ACCUMULATOR,new IntCounter());
      getRuntimeContext().getAccumulator(SUCCESSFUL_RESTORE_CHECK_ACCUMULATOR).add(1);
    }
 else {
      throw new RuntimeException("This source should always be restored because it's only used when restoring from a savepoint.");
    }
  }
  @Override public void run(  SourceContext<Tuple2<Long,Long>> ctx) throws Exception {
    ctx.emitWatermark(new Watermark(1000));
synchronized (ctx.getCheckpointLock()) {
      for (long i=0; i < numElements; i++) {
        if (i % getRuntimeContext().getNumberOfParallelSubtasks() == getRuntimeContext().getIndexOfThisSubtask()) {
          ctx.collect(new Tuple2<>(i,i));
        }
      }
    }
    while (isRunning) {
      Thread.sleep(20);
    }
  }
  @Override public void cancel(){
    isRunning=false;
  }
}
