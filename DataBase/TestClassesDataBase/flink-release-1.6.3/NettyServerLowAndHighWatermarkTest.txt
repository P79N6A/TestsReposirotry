/** 
 * Verifies that high and low watermarks for  {@link NettyServer} may be set to any (valid) valuesgiven by the user.
 */
public class NettyServerLowAndHighWatermarkTest {
  /** 
 * Verify low and high watermarks being set correctly for larger memory segment sizes which trigger <a href="https://issues.apache.org/jira/browse/FLINK-7258">FLINK-7258</a>.
 */
  @Test public void testLargeLowAndHighWatermarks() throws Throwable {
    testLowAndHighWatermarks(65536);
  }
  /** 
 * Verify low and high watermarks being set correctly for smaller memory segment sizes than Netty's defaults.
 */
  @Test public void testSmallLowAndHighWatermarks() throws Throwable {
    testLowAndHighWatermarks(1024);
  }
  /** 
 * Verifies that the high and low watermark are set in relation to the page size. <p>The high and low water marks control the data flow to the wire. If the Netty write buffer has size greater or equal to the high water mark, the channel state becomes not-writable. Only when the size falls below the low water mark again, the state changes to writable again. <p>The Channel writability state needs to be checked by the handler when writing to the channel and is not enforced in the sense that you cannot write a channel, which is in not-writable state.
 * @param pageSize memory segment size to test with (influences high and low watermarks)
 */
  private void testLowAndHighWatermarks(  int pageSize) throws Throwable {
    final int expectedLowWatermark=pageSize + 1;
    final int expectedHighWatermark=2 * pageSize;
    final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    final NettyProtocol protocol=new NettyProtocol(null,null,true){
      @Override public ChannelHandler[] getServerChannelHandlers(){
        return new ChannelHandler[]{new TestLowAndHighWatermarkHandler(pageSize,expectedLowWatermark,expectedHighWatermark,error)};
      }
      @Override public ChannelHandler[] getClientChannelHandlers(){
        return new ChannelHandler[0];
      }
    }
;
    final NettyConfig conf=createConfig(pageSize);
    final NettyServerAndClient serverAndClient=initServerAndClient(protocol,conf);
    try {
      final Channel ch=connect(serverAndClient);
      awaitClose(ch);
      final Throwable t=error.get();
      if (t != null) {
        throw t;
      }
    }
  finally {
      shutdown(serverAndClient);
    }
  }
  /** 
 * This handler implements the test. <p>Verifies that the high and low watermark are set in relation to the page size.
 */
private static class TestLowAndHighWatermarkHandler extends ChannelInboundHandlerAdapter {
    private final int pageSize;
    private final int expectedLowWatermark;
    private final int expectedHighWatermark;
    private final AtomicReference<Throwable> error;
    private boolean hasFlushed;
    public TestLowAndHighWatermarkHandler(    int pageSize,    int expectedLowWatermark,    int expectedHighWatermark,    AtomicReference<Throwable> error){
      this.pageSize=pageSize;
      this.expectedLowWatermark=expectedLowWatermark;
      this.expectedHighWatermark=expectedHighWatermark;
      this.error=error;
    }
    @Override public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      final Channel ch=ctx.channel();
      assertEquals("Low watermark",expectedLowWatermark,ch.config().getWriteBufferLowWaterMark());
      assertEquals("High watermark",expectedHighWatermark,ch.config().getWriteBufferHighWaterMark());
      assertTrue(ch.isWritable());
      ch.write(buffer());
      assertTrue(ch.isWritable());
      ch.write(buffer());
      assertFalse(ch.isWritable());
      hasFlushed=true;
      ch.flush();
    }
    @Override public void channelWritabilityChanged(    ChannelHandlerContext ctx) throws Exception {
      if (hasFlushed) {
        assertTrue(ctx.channel().isWritable());
        ctx.close();
      }
      super.channelWritabilityChanged(ctx);
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      if (error.get() == null) {
        error.set(cause);
      }
      ctx.close();
      super.exceptionCaught(ctx,cause);
    }
    private ByteBuf buffer(){
      return NettyServerLowAndHighWatermarkTest.buffer(pageSize);
    }
  }
  /** 
 * Creates a new buffer of the given size.
 */
  private static ByteBuf buffer(  int size){
    return Unpooled.buffer(size).writerIndex(size);
  }
}
