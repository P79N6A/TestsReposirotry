public abstract class ReOpenableHashTableTestBase extends TestLogger {
  protected static final int PAGE_SIZE=8 * 1024;
  protected static final long MEMORY_SIZE=PAGE_SIZE * 1000;
  protected static final long SEED1=561349061987311L;
  protected static final long SEED2=231434613412342L;
  protected static final int NUM_PROBES=3;
  protected final AbstractInvokable parentTask=new DummyInvokable();
  protected IOManager ioManager;
  protected MemoryManager memoryManager;
  protected TypeSerializer<Tuple2<Integer,String>> recordSerializer;
  protected TypeComparator<Tuple2<Integer,String>> record1Comparator;
  protected TypeComparator<Tuple2<Integer,String>> record2Comparator;
  protected TypePairComparator<Tuple2<Integer,String>,Tuple2<Integer,String>> recordPairComparator;
  protected TypeSerializer<Tuple2<Integer,Integer>> recordBuildSideAccesssor;
  protected TypeSerializer<Tuple2<Integer,Integer>> recordProbeSideAccesssor;
  protected TypeComparator<Tuple2<Integer,Integer>> recordBuildSideComparator;
  protected TypeComparator<Tuple2<Integer,Integer>> recordProbeSideComparator;
  protected TypePairComparator<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> pactRecordComparator;
  @SuppressWarnings({"unchecked","rawtypes"}) @Before public void beforeTest(){
    this.recordSerializer=TestData.getIntStringTupleSerializer();
    this.record1Comparator=TestData.getIntStringTupleComparator();
    this.record2Comparator=TestData.getIntStringTupleComparator();
    this.recordPairComparator=new GenericPairComparator(this.record1Comparator,this.record2Comparator);
    this.recordBuildSideAccesssor=TestData.getIntIntTupleSerializer();
    this.recordProbeSideAccesssor=TestData.getIntIntTupleSerializer();
    this.recordBuildSideComparator=TestData.getIntIntTupleComparator();
    this.recordProbeSideComparator=TestData.getIntIntTupleComparator();
    this.pactRecordComparator=new GenericPairComparator(this.recordBuildSideComparator,this.recordProbeSideComparator);
    this.memoryManager=new MemoryManager(MEMORY_SIZE,1,PAGE_SIZE,MemoryType.HEAP,true);
    this.ioManager=new IOManagerAsync();
  }
  @After public void afterTest(){
    if (this.ioManager != null) {
      this.ioManager.shutdown();
      if (!this.ioManager.isProperlyShutDown()) {
        Assert.fail("I/O manager failed to properly shut down.");
      }
      this.ioManager=null;
    }
    if (this.memoryManager != null) {
      Assert.assertTrue("Memory Leak: Not all memory has been returned to the memory manager.",this.memoryManager.verifyEmpty());
      this.memoryManager.shutdown();
      this.memoryManager=null;
    }
  }
  /** 
 * Test behavior with overflow buckets (Overflow buckets must be initialized correctly if the input is reopened again)
 */
  @Test public void testOverflow(){
    int buildSize=1000;
    int probeSize=1000;
    try {
      TupleGenerator bgen=new TupleGenerator(SEED1,200,1024,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
      TupleGenerator pgen=new TupleGenerator(SEED2,0,1024,KeyMode.SORTED,ValueMode.FIX_LENGTH);
      final TupleGeneratorIterator buildInput=new TupleGeneratorIterator(bgen,buildSize);
      final TupleGeneratorIterator probeInput=new TupleGeneratorIterator(pgen,probeSize);
      doTest(buildInput,probeInput,bgen,pgen);
    }
 catch (    Exception e) {
      e.printStackTrace();
      Assert.fail("An exception occurred during the test: " + e.getMessage());
    }
  }
  /** 
 * Verify proper operation if the build side is spilled to disk.
 */
  @Test public void testDoubleProbeSpilling(){
    int buildSize=1000;
    int probeSize=1000;
    try {
      TupleGenerator bgen=new TupleGenerator(SEED1,0,1024,KeyMode.SORTED,ValueMode.FIX_LENGTH);
      TupleGenerator pgen=new TupleGenerator(SEED2,0,1024,KeyMode.SORTED,ValueMode.FIX_LENGTH);
      final TupleGeneratorIterator buildInput=new TupleGeneratorIterator(bgen,buildSize);
      final TupleGeneratorIterator probeInput=new TupleGeneratorIterator(pgen,probeSize);
      doTest(buildInput,probeInput,bgen,pgen);
    }
 catch (    Exception e) {
      e.printStackTrace();
      Assert.fail("An exception occurred during the test: " + e.getMessage());
    }
  }
  /** 
 * This test case verifies that hybrid hash join is able to handle multiple probe phases when the build side fits completely into memory.
 */
  @Test public void testDoubleProbeInMemory(){
    int buildSize=1000;
    int probeSize=1000;
    try {
      TupleGenerator bgen=new TupleGenerator(SEED1,0,28,KeyMode.SORTED,ValueMode.FIX_LENGTH);
      TupleGenerator pgen=new TupleGenerator(SEED2,0,28,KeyMode.SORTED,ValueMode.FIX_LENGTH);
      final TupleGeneratorIterator buildInput=new TupleGeneratorIterator(bgen,buildSize);
      final TupleGeneratorIterator probeInput=new TupleGeneratorIterator(pgen,probeSize);
      doTest(buildInput,probeInput,bgen,pgen);
    }
 catch (    Exception e) {
      e.printStackTrace();
      Assert.fail("An exception occurred during the test: " + e.getMessage());
    }
  }
  abstract protected void doTest(  TupleGeneratorIterator buildInput,  TupleGeneratorIterator probeInput,  TestData.TupleGenerator bgen,  TestData.TupleGenerator pgen) throws Exception ;
  static Map<Integer,Collection<TupleMatch>> deepCopy(  Map<Integer,Collection<TupleMatch>> expectedSecondMatchesMap){
    Map<Integer,Collection<TupleMatch>> copy=new HashMap<>(expectedSecondMatchesMap.size());
    for (    Map.Entry<Integer,Collection<TupleMatch>> entry : expectedSecondMatchesMap.entrySet()) {
      List<TupleMatch> matches=new ArrayList<TupleMatch>(entry.getValue().size());
      for (      TupleMatch m : entry.getValue()) {
        matches.add(m);
      }
      copy.put(entry.getKey(),matches);
    }
    return copy;
  }
}
