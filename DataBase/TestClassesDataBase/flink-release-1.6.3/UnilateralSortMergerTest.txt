/** 
 * Tests for the  {@link UnilateralSortMerger}.
 */
public class UnilateralSortMergerTest extends TestLogger {
  @Test public void testInMemorySorterDisposal() throws Exception {
    final TestingInMemorySorterFactory<Tuple2<Integer,Integer>> inMemorySorterFactory=new TestingInMemorySorterFactory<>();
    final int numPages=32;
    final MemoryManager memoryManager=new MemoryManager(MemoryManager.DEFAULT_PAGE_SIZE * numPages,1);
    final IOManagerAsync ioManager=new IOManagerAsync();
    final DummyInvokable parentTask=new DummyInvokable();
    try {
      final List<MemorySegment> memory=memoryManager.allocatePages(parentTask,numPages);
      final UnilateralSortMerger<Tuple2<Integer,Integer>> unilateralSortMerger=new UnilateralSortMerger<>(memoryManager,memory,ioManager,EmptyMutableObjectIterator.get(),parentTask,TestData.getIntIntTupleSerializerFactory(),TestData.getIntIntTupleComparator(),10,2,1.0f,true,false,false,inMemorySorterFactory);
      final Collection<TestingInMemorySorter<?>> inMemorySorters=inMemorySorterFactory.getInMemorySorters();
      assertThat(inMemorySorters,is(not(empty())));
      unilateralSortMerger.close();
      assertThat(unilateralSortMerger.closed,is(true));
      for (      TestingInMemorySorter<?> inMemorySorter : inMemorySorters) {
        assertThat(inMemorySorter.isDisposed(),is(true));
      }
    }
  finally {
      ioManager.shutdown();
      memoryManager.shutdown();
    }
  }
private static final class TestingInMemorySorterFactory<T> implements InMemorySorterFactory<T> {
    private final Collection<TestingInMemorySorter<?>> inMemorySorters=new ArrayList<>(10);
    Collection<TestingInMemorySorter<?>> getInMemorySorters(){
      return inMemorySorters;
    }
    @Override public InMemorySorter<T> create(    List<MemorySegment> sortSegments){
      final TestingInMemorySorter<T> testingInMemorySorter=new TestingInMemorySorter<>();
      inMemorySorters.add(testingInMemorySorter);
      return testingInMemorySorter;
    }
  }
private static final class TestingInMemorySorter<T> implements InMemorySorter<T> {
    private volatile boolean isDisposed;
    public boolean isDisposed(){
      return isDisposed;
    }
    @Override public void reset(){
    }
    @Override public boolean isEmpty(){
      return true;
    }
    @Override public void dispose(){
      isDisposed=true;
    }
    @Override public long getCapacity(){
      return 0;
    }
    @Override public long getOccupancy(){
      return 0;
    }
    @Override public T getRecord(    int logicalPosition) throws IOException {
      return null;
    }
    @Override public T getRecord(    T reuse,    int logicalPosition) throws IOException {
      return null;
    }
    @Override public boolean write(    T record) throws IOException {
      return false;
    }
    @Override public MutableObjectIterator<T> getIterator(){
      return null;
    }
    @Override public void writeToOutput(    ChannelWriterOutputView output) throws IOException {
    }
    @Override public void writeToOutput(    ChannelWriterOutputView output,    LargeRecordHandler<T> largeRecordsOutput) throws IOException {
    }
    @Override public void writeToOutput(    ChannelWriterOutputView output,    int start,    int num) throws IOException {
    }
    @Override public int compare(    int i,    int j){
      return 0;
    }
    @Override public int compare(    int segmentNumberI,    int segmentOffsetI,    int segmentNumberJ,    int segmentOffsetJ){
      return 0;
    }
    @Override public void swap(    int i,    int j){
    }
    @Override public void swap(    int segmentNumberI,    int segmentOffsetI,    int segmentNumberJ,    int segmentOffsetJ){
    }
    @Override public int size(){
      return 0;
    }
    @Override public int recordSize(){
      return 0;
    }
    @Override public int recordsPerSegment(){
      return 0;
    }
  }
}
