/** 
 * Test base for verifying that marshalling / unmarshalling REST  {@link ResponseBody}s work properly.
 */
public abstract class RestResponseMarshallingTestBase<R extends ResponseBody> extends TestLogger {
  /** 
 * Returns the class of the test response.
 * @return class of the test response type
 */
  protected abstract Class<R> getTestResponseClass();
  protected Collection<Class<?>> getTypeParameters(){
    return Collections.emptyList();
  }
  /** 
 * Returns an instance of a response to be tested.
 * @return instance of the expected test response
 */
  protected abstract R getTestResponseInstance() throws Exception ;
  /** 
 * Tests that we can marshal and unmarshal the response.
 */
  @Test public void testJsonMarshalling() throws Exception {
    final R expected=getTestResponseInstance();
    ObjectMapper objectMapper=RestMapperUtils.getStrictObjectMapper();
    final String marshalled=objectMapper.writeValueAsString(expected);
    final Collection<Class<?>> typeParameters=getTypeParameters();
    final JavaType type;
    if (typeParameters.isEmpty()) {
      type=objectMapper.getTypeFactory().constructType(getTestResponseClass());
    }
 else {
      type=objectMapper.getTypeFactory().constructParametricType(getTestResponseClass(),typeParameters.toArray(new Class<?>[typeParameters.size()]));
    }
    final R unmarshalled=objectMapper.readValue(marshalled,type);
    assertOriginalEqualsToUnmarshalled(expected,unmarshalled);
  }
  /** 
 * Asserts that two objects are equal. If they are not, an  {@link AssertionError} is thrown.
 * @param expected expected value
 * @param actual   the value to check against expected
 */
  protected void assertOriginalEqualsToUnmarshalled(  R expected,  R actual){
    Assert.assertEquals(expected,actual);
  }
}
