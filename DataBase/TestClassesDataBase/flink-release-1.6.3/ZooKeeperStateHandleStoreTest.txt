/** 
 * Tests for basic  {@link ZooKeeperStateHandleStore} behaviour.<p> Tests include: <ul> <li>Expected usage of operations</li> <li>Correct ordering of ZooKeeper and state handle operations</li> </ul>
 */
public class ZooKeeperStateHandleStoreTest extends TestLogger {
  private static final ZooKeeperTestEnvironment ZOOKEEPER=new ZooKeeperTestEnvironment(1);
  @AfterClass public static void tearDown() throws Exception {
    if (ZOOKEEPER != null) {
      ZOOKEEPER.shutdown();
    }
  }
  @Before public void cleanUp() throws Exception {
    ZOOKEEPER.deleteAll();
  }
  /** 
 * Tests add operation with lock.
 */
  @Test public void testAddAndLock() throws Exception {
    LongStateStorage longStateStorage=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),longStateStorage);
    final String pathInZooKeeper="/testAdd";
    final Long state=1239712317L;
    store.addAndLock(pathInZooKeeper,state);
    assertEquals(1,store.getAllAndLock().size());
    assertEquals(state,store.getAndLock(pathInZooKeeper).retrieveState());
    Stat stat=ZOOKEEPER.getClient().checkExists().forPath(pathInZooKeeper);
    assertNotNull(stat);
    assertEquals(0,stat.getEphemeralOwner());
    List<String> children=ZOOKEEPER.getClient().getChildren().forPath(pathInZooKeeper);
    assertEquals(1,children.size());
    stat=ZOOKEEPER.getClient().checkExists().forPath(pathInZooKeeper + '/' + children.get(0));
    assertNotNull(stat);
    assertNotEquals(0,stat.getEphemeralOwner());
    @SuppressWarnings("unchecked") Long actual=((RetrievableStateHandle<Long>)InstantiationUtil.deserializeObject(ZOOKEEPER.getClient().getData().forPath(pathInZooKeeper),ClassLoader.getSystemClassLoader())).retrieveState();
    assertEquals(state,actual);
  }
  /** 
 * Tests that an existing path throws an Exception.
 */
  @Test(expected=Exception.class) public void testAddAlreadyExistingPath() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    ZOOKEEPER.getClient().create().forPath("/testAddAlreadyExistingPath");
    store.addAndLock("/testAddAlreadyExistingPath",1L);
    assertEquals(1,stateHandleProvider.getStateHandles());
    assertEquals(1,stateHandleProvider.getStateHandles().get(0).getNumberOfDiscardCalls());
  }
  /** 
 * Tests that the created state handle is discarded if ZooKeeper create fails.
 */
  @Test public void testAddDiscardStateHandleAfterFailure() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    CuratorFramework client=spy(ZOOKEEPER.getClient());
    when(client.inTransaction().create()).thenThrow(new RuntimeException("Expected test Exception."));
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(client,stateHandleProvider);
    final String pathInZooKeeper="/testAddDiscardStateHandleAfterFailure";
    final Long state=81282227L;
    try {
      store.addAndLock(pathInZooKeeper,state);
      fail("Did not throw expected exception");
    }
 catch (    Exception ignored) {
    }
    assertEquals(1,stateHandleProvider.getStateHandles().size());
    assertEquals(state,stateHandleProvider.getStateHandles().get(0).retrieveState());
    assertEquals(1,stateHandleProvider.getStateHandles().get(0).getNumberOfDiscardCalls());
  }
  /** 
 * Tests that a state handle is replaced.
 */
  @Test public void testReplace() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    final String pathInZooKeeper="/testReplace";
    final Long initialState=30968470898L;
    final Long replaceState=88383776661L;
    store.addAndLock(pathInZooKeeper,initialState);
    store.replace(pathInZooKeeper,0,replaceState);
    assertEquals(2,stateHandleProvider.getStateHandles().size());
    assertEquals(initialState,stateHandleProvider.getStateHandles().get(0).retrieveState());
    assertEquals(replaceState,stateHandleProvider.getStateHandles().get(1).retrieveState());
    Stat stat=ZOOKEEPER.getClient().checkExists().forPath(pathInZooKeeper);
    assertNotNull(stat);
    assertEquals(0,stat.getEphemeralOwner());
    @SuppressWarnings("unchecked") Long actual=((RetrievableStateHandle<Long>)InstantiationUtil.deserializeObject(ZOOKEEPER.getClient().getData().forPath(pathInZooKeeper),ClassLoader.getSystemClassLoader())).retrieveState();
    assertEquals(replaceState,actual);
  }
  /** 
 * Tests that a non existing path throws an Exception.
 */
  @Test(expected=Exception.class) public void testReplaceNonExistingPath() throws Exception {
    RetrievableStateStorageHelper<Long> stateStorage=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateStorage);
    store.replace("/testReplaceNonExistingPath",0,1L);
  }
  /** 
 * Tests that the replace state handle is discarded if ZooKeeper setData fails.
 */
  @Test public void testReplaceDiscardStateHandleAfterFailure() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    CuratorFramework client=spy(ZOOKEEPER.getClient());
    when(client.setData()).thenThrow(new RuntimeException("Expected test Exception."));
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(client,stateHandleProvider);
    final String pathInZooKeeper="/testReplaceDiscardStateHandleAfterFailure";
    final Long initialState=30968470898L;
    final Long replaceState=88383776661L;
    store.addAndLock(pathInZooKeeper,initialState);
    try {
      store.replace(pathInZooKeeper,0,replaceState);
      fail("Did not throw expected exception");
    }
 catch (    Exception ignored) {
    }
    assertEquals(2,stateHandleProvider.getStateHandles().size());
    assertEquals(initialState,stateHandleProvider.getStateHandles().get(0).retrieveState());
    assertEquals(replaceState,stateHandleProvider.getStateHandles().get(1).retrieveState());
    assertEquals(1,stateHandleProvider.getStateHandles().get(1).getNumberOfDiscardCalls());
    @SuppressWarnings("unchecked") Long actual=((RetrievableStateHandle<Long>)InstantiationUtil.deserializeObject(ZOOKEEPER.getClient().getData().forPath(pathInZooKeeper),ClassLoader.getSystemClassLoader())).retrieveState();
    assertEquals(initialState,actual);
  }
  /** 
 * Tests get operation.
 */
  @Test public void testGetAndExists() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    final String pathInZooKeeper="/testGetAndExists";
    final Long state=311222268470898L;
    assertEquals(-1,store.exists(pathInZooKeeper));
    store.addAndLock(pathInZooKeeper,state);
    RetrievableStateHandle<Long> actual=store.getAndLock(pathInZooKeeper);
    assertEquals(state,actual.retrieveState());
    assertTrue(store.exists(pathInZooKeeper) >= 0);
  }
  /** 
 * Tests that a non existing path throws an Exception.
 */
  @Test(expected=Exception.class) public void testGetNonExistingPath() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    store.getAndLock("/testGetNonExistingPath");
  }
  /** 
 * Tests that all added state is returned.
 */
  @Test public void testGetAll() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    final String pathInZooKeeper="/testGetAll";
    final Set<Long> expected=new HashSet<>();
    expected.add(311222268470898L);
    expected.add(132812888L);
    expected.add(27255442L);
    expected.add(11122233124L);
    for (    long val : expected) {
      store.addAndLock(pathInZooKeeper + val,val);
    }
    for (    Tuple2<RetrievableStateHandle<Long>,String> val : store.getAllAndLock()) {
      assertTrue(expected.remove(val.f0.retrieveState()));
    }
    assertEquals(0,expected.size());
  }
  /** 
 * Tests that the state is returned sorted.
 */
  @Test public void testGetAllSortedByName() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    final String basePath="/testGetAllSortedByName";
    final Long[] expected=new Long[]{311222268470898L,132812888L,27255442L,11122233124L};
    for (    long val : expected) {
      final String pathInZooKeeper=String.format("%s%016d",basePath,val);
      store.addAndLock(pathInZooKeeper,val);
    }
    List<Tuple2<RetrievableStateHandle<Long>,String>> actual=store.getAllSortedByNameAndLock();
    assertEquals(expected.length,actual.size());
    Arrays.sort(expected);
    for (int i=0; i < expected.length; i++) {
      assertEquals(expected[i],actual.get(i).f0.retrieveState());
    }
  }
  /** 
 * Tests that state handles are correctly removed.
 */
  @Test public void testRemove() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    final String pathInZooKeeper="/testRemove";
    final Long state=27255442L;
    store.addAndLock(pathInZooKeeper,state);
    final int numberOfGlobalDiscardCalls=LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls();
    store.releaseAndTryRemove(pathInZooKeeper);
    assertEquals(0,ZOOKEEPER.getClient().getChildren().forPath("/").size());
    assertEquals(numberOfGlobalDiscardCalls + 1,LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls());
  }
  /** 
 * Tests that all state handles are correctly discarded. 
 */
  @Test public void testReleaseAndTryRemoveAll() throws Exception {
    LongStateStorage stateHandleProvider=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateHandleProvider);
    final String pathInZooKeeper="/testDiscardAll";
    final Set<Long> expected=new HashSet<>();
    expected.add(311222268470898L);
    expected.add(132812888L);
    expected.add(27255442L);
    expected.add(11122233124L);
    for (    long val : expected) {
      store.addAndLock(pathInZooKeeper + val,val);
    }
    store.releaseAndTryRemoveAll();
    assertEquals(0,ZOOKEEPER.getClient().getChildren().forPath("/").size());
  }
  /** 
 * Tests that the ZooKeeperStateHandleStore can handle corrupted data by releasing and trying to remove the respective ZooKeeper ZNodes.
 */
  @Test public void testCorruptedData() throws Exception {
    LongStateStorage stateStorage=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> store=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),stateStorage);
    final Collection<Long> input=new HashSet<>();
    input.add(1L);
    input.add(2L);
    input.add(3L);
    for (    Long aLong : input) {
      store.addAndLock("/" + aLong,aLong);
    }
    ZOOKEEPER.getClient().setData().forPath("/" + 2,new byte[2]);
    List<Tuple2<RetrievableStateHandle<Long>,String>> allEntries=store.getAllAndLock();
    Collection<Long> expected=new HashSet<>(input);
    expected.remove(2L);
    Collection<Long> actual=new HashSet<>(expected.size());
    for (    Tuple2<RetrievableStateHandle<Long>,String> entry : allEntries) {
      actual.add(entry.f0.retrieveState());
    }
    assertEquals(expected,actual);
    allEntries=store.getAllSortedByNameAndLock();
    actual.clear();
    for (    Tuple2<RetrievableStateHandle<Long>,String> entry : allEntries) {
      actual.add(entry.f0.retrieveState());
    }
    assertEquals(expected,actual);
    Stat stat=ZOOKEEPER.getClient().checkExists().forPath("/" + 2);
    assertNull("The corrupted node should no longer exist.",stat);
  }
  /** 
 * FLINK-6612 Tests that a concurrent delete operation cannot succeed if another instance holds a lock on the specified node.
 */
  @Test public void testConcurrentDeleteOperation() throws Exception {
    LongStateStorage longStateStorage=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> zkStore1=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),longStateStorage);
    ZooKeeperStateHandleStore<Long> zkStore2=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),longStateStorage);
    final String statePath="/state";
    zkStore1.addAndLock(statePath,42L);
    RetrievableStateHandle<Long> stateHandle=zkStore2.getAndLock(statePath);
    zkStore1.releaseAndTryRemove(statePath);
    assertEquals(42L,(long)stateHandle.retrieveState());
    Stat nodeStat=ZOOKEEPER.getClient().checkExists().forPath(statePath);
    assertNotNull("NodeStat should not be null, otherwise the referenced node does not exist.",nodeStat);
    zkStore2.releaseAndTryRemove(statePath);
    nodeStat=ZOOKEEPER.getClient().checkExists().forPath(statePath);
    assertNull("NodeState should be null, because the referenced node should no longer exist.",nodeStat);
  }
  /** 
 * FLINK-6612 Tests that getAndLock removes a created lock if the RetrievableStateHandle cannot be retrieved (e.g. deserialization problem).
 */
  @Test public void testLockCleanupWhenGetAndLockFails() throws Exception {
    LongStateStorage longStateStorage=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> zkStore1=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),longStateStorage);
    ZooKeeperStateHandleStore<Long> zkStore2=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),longStateStorage);
    final String path="/state";
    zkStore1.addAndLock(path,42L);
    final byte[] corruptedData={1,2};
    ZOOKEEPER.getClient().setData().forPath(path,corruptedData);
    try {
      zkStore2.getAndLock(path);
      fail("Should fail because we cannot deserialize the node's data");
    }
 catch (    IOException ignored) {
    }
    String lockNodePath=zkStore2.getLockPath(path);
    Stat stat=ZOOKEEPER.getClient().checkExists().forPath(lockNodePath);
    assertNull("zkStore2 should not have created a lock node.",stat);
    Collection<String> children=ZOOKEEPER.getClient().getChildren().forPath(path);
    assertEquals(1,children.size());
    zkStore1.releaseAndTryRemove(path);
    stat=ZOOKEEPER.getClient().checkExists().forPath(path);
    assertNull("The state node should have been removed.",stat);
  }
  /** 
 * FLINK-6612 Tests that lock nodes will be released if the client dies.
 */
  @Test public void testLockCleanupWhenClientTimesOut() throws Exception {
    LongStateStorage longStateStorage=new LongStateStorage();
    Configuration configuration=new Configuration();
    configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM,ZOOKEEPER.getConnectString());
    configuration.setInteger(HighAvailabilityOptions.ZOOKEEPER_SESSION_TIMEOUT,100);
    configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_ROOT,"timeout");
    try (CuratorFramework client=ZooKeeperUtils.startCuratorFramework(configuration);CuratorFramework client2=ZooKeeperUtils.startCuratorFramework(configuration)){
      ZooKeeperStateHandleStore<Long> zkStore=new ZooKeeperStateHandleStore<>(client,longStateStorage);
      final String path="/state";
      zkStore.addAndLock(path,42L);
      client.close();
      Stat stat=client2.checkExists().forPath(path);
      assertNotNull(stat);
      Collection<String> children=client2.getChildren().forPath(path);
      assertEquals(0,children.size());
    }
   }
  /** 
 * FLINK-6612 Tests that we can release a locked state handles in the ZooKeeperStateHandleStore.
 */
  @Test public void testRelease() throws Exception {
    LongStateStorage longStateStorage=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> zkStore=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),longStateStorage);
    final String path="/state";
    zkStore.addAndLock(path,42L);
    final String lockPath=zkStore.getLockPath(path);
    Stat stat=ZOOKEEPER.getClient().checkExists().forPath(lockPath);
    assertNotNull("Expected an existing lock",stat);
    zkStore.release(path);
    stat=ZOOKEEPER.getClient().checkExists().forPath(path);
    assertEquals("Expected no lock nodes as children",0,stat.getNumChildren());
    zkStore.releaseAndTryRemove(path);
    stat=ZOOKEEPER.getClient().checkExists().forPath(path);
    assertNull("State node should have been removed.",stat);
  }
  /** 
 * FLINK-6612 Tests that we can release all locked state handles in the ZooKeeperStateHandleStore
 */
  @Test public void testReleaseAll() throws Exception {
    LongStateStorage longStateStorage=new LongStateStorage();
    ZooKeeperStateHandleStore<Long> zkStore=new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(),longStateStorage);
    final Collection<String> paths=Arrays.asList("/state1","/state2","/state3");
    for (    String path : paths) {
      zkStore.addAndLock(path,42L);
    }
    for (    String path : paths) {
      Stat stat=ZOOKEEPER.getClient().checkExists().forPath(zkStore.getLockPath(path));
      assertNotNull("Expecte and existing lock.",stat);
    }
    zkStore.releaseAll();
    for (    String path : paths) {
      Stat stat=ZOOKEEPER.getClient().checkExists().forPath(path);
      assertEquals(0,stat.getNumChildren());
    }
    zkStore.releaseAndTryRemoveAll();
    Stat stat=ZOOKEEPER.getClient().checkExists().forPath("/");
    assertEquals(0,stat.getNumChildren());
  }
private static class LongStateStorage implements RetrievableStateStorageHelper<Long> {
    private final List<LongRetrievableStateHandle> stateHandles=new ArrayList<>();
    @Override public RetrievableStateHandle<Long> store(    Long state) throws Exception {
      LongRetrievableStateHandle stateHandle=new LongRetrievableStateHandle(state);
      stateHandles.add(stateHandle);
      return stateHandle;
    }
    List<LongRetrievableStateHandle> getStateHandles(){
      return stateHandles;
    }
  }
private static class LongRetrievableStateHandle implements RetrievableStateHandle<Long> {
    private static final long serialVersionUID=-3555329254423838912L;
    private static int numberOfGlobalDiscardCalls=0;
    private final Long state;
    private int numberOfDiscardCalls=0;
    public LongRetrievableStateHandle(    Long state){
      this.state=state;
    }
    @Override public Long retrieveState(){
      return state;
    }
    @Override public void discardState() throws Exception {
      numberOfGlobalDiscardCalls++;
      numberOfDiscardCalls++;
    }
    @Override public long getStateSize(){
      return 0;
    }
    int getNumberOfDiscardCalls(){
      return numberOfDiscardCalls;
    }
    public static int getNumberOfGlobalDiscardCalls(){
      return numberOfGlobalDiscardCalls;
    }
  }
}
