private static class PartitionedStateSource extends StateSourceBase implements CheckpointedFunction {
  private static final long serialVersionUID=-359715965103593462L;
  private static final int NUM_PARTITIONS=7;
  private transient ListState<Integer> counterPartitions;
  private boolean broadcast;
  private static int[] checkCorrectSnapshot;
  private static int[] checkCorrectRestore;
  public PartitionedStateSource(  boolean broadcast){
    this.broadcast=broadcast;
  }
  @Override public void snapshotState(  FunctionSnapshotContext context) throws Exception {
    counterPartitions.clear();
    checkCorrectSnapshot[getRuntimeContext().getIndexOfThisSubtask()]=counter;
    int div=counter / NUM_PARTITIONS;
    int mod=counter % NUM_PARTITIONS;
    for (int i=0; i < NUM_PARTITIONS; ++i) {
      int partitionValue=div;
      if (mod > 0) {
        --mod;
        ++partitionValue;
      }
      counterPartitions.add(partitionValue);
    }
  }
  @Override public void initializeState(  FunctionInitializationContext context) throws Exception {
    if (broadcast) {
      this.counterPartitions=context.getOperatorStateStore().getUnionListState(new ListStateDescriptor<>("counter_partitions",IntSerializer.INSTANCE));
    }
 else {
      this.counterPartitions=context.getOperatorStateStore().getListState(new ListStateDescriptor<>("counter_partitions",IntSerializer.INSTANCE));
    }
    if (context.isRestored()) {
      for (      int v : counterPartitions.get()) {
        counter+=v;
      }
      checkCorrectRestore[getRuntimeContext().getIndexOfThisSubtask()]=counter;
    }
  }
}
