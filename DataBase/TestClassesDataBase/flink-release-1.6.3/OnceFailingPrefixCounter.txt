/** 
 * This function uses simultaneously the key/value state and is checkpointed.
 */
private static class OnceFailingPrefixCounter extends RichMapFunction<PrefixCount,PrefixCount> implements ListCheckpointed<Long> {
  private static Map<String,Long> prefixCounts=new ConcurrentHashMap<String,Long>();
  static long[] counts=new long[PARALLELISM];
  private static volatile boolean hasFailed=false;
  private final long numElements;
  private long failurePos;
  private long count;
  private ValueState<Long> pCount;
  private long inputCount;
  OnceFailingPrefixCounter(  long numElements){
    this.numElements=numElements;
  }
  @Override public void open(  Configuration parameters) throws IOException {
    long failurePosMin=(long)(0.4 * numElements / getRuntimeContext().getNumberOfParallelSubtasks());
    long failurePosMax=(long)(0.7 * numElements / getRuntimeContext().getNumberOfParallelSubtasks());
    failurePos=(new Random().nextLong() % (failurePosMax - failurePosMin)) + failurePosMin;
    count=0;
    pCount=getRuntimeContext().getState(new ValueStateDescriptor<>("pCount",Long.class,0L));
  }
  @Override public void close() throws IOException {
    counts[getRuntimeContext().getIndexOfThisSubtask()]=inputCount;
  }
  @Override public PrefixCount map(  PrefixCount value) throws Exception {
    count++;
    if (!hasFailed && count >= failurePos) {
      hasFailed=true;
      throw new Exception("Test Failure");
    }
    inputCount++;
    long currentPrefixCount=pCount.value() + value.count;
    pCount.update(currentPrefixCount);
    prefixCounts.put(value.prefix,currentPrefixCount);
    value.count=currentPrefixCount;
    return value;
  }
  @Override public List<Long> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(this.inputCount);
  }
  @Override public void restoreState(  List<Long> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.inputCount=state.get(0);
  }
}
