/** 
 * Environment preparation and suite of tests for version-specific  {@link ElasticsearchSinkBase} implementations.
 * @param < C > Elasticsearch client type
 * @param < A > The address type to use
 */
public abstract class ElasticsearchSinkTestBase<C extends AutoCloseable,A> extends AbstractTestBase {
  private static final Logger LOG=LoggerFactory.getLogger(ElasticsearchSinkTestBase.class);
  protected static final String CLUSTER_NAME="test-cluster";
  protected static EmbeddedElasticsearchNodeEnvironment embeddedNodeEnv;
  @ClassRule public static TemporaryFolder tempFolder=new TemporaryFolder();
  @BeforeClass public static void prepare() throws Exception {
    LOG.info("-------------------------------------------------------------------------");
    LOG.info("    Starting embedded Elasticsearch node ");
    LOG.info("-------------------------------------------------------------------------");
    Class<?> clazz=Class.forName("org.apache.flink.streaming.connectors.elasticsearch.EmbeddedElasticsearchNodeEnvironmentImpl");
    embeddedNodeEnv=(EmbeddedElasticsearchNodeEnvironment)InstantiationUtil.instantiate(clazz);
    embeddedNodeEnv.start(tempFolder.newFolder(),CLUSTER_NAME);
  }
  @AfterClass public static void shutdown() throws Exception {
    LOG.info("-------------------------------------------------------------------------");
    LOG.info("    Shutting down embedded Elasticsearch node ");
    LOG.info("-------------------------------------------------------------------------");
    embeddedNodeEnv.close();
  }
  /** 
 * Tests that the Elasticsearch sink works properly.
 */
  public void runElasticsearchSinkTest() throws Exception {
    final String index="elasticsearch-sink-test-index";
    final StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    DataStreamSource<Tuple2<Integer,String>> source=env.addSource(new SourceSinkDataTestKit.TestDataSourceFunction());
    source.addSink(createElasticsearchSinkForEmbeddedNode(1,CLUSTER_NAME,new SourceSinkDataTestKit.TestElasticsearchSinkFunction(index)));
    env.execute("Elasticsearch Sink Test");
    Client client=embeddedNodeEnv.getClient();
    SourceSinkDataTestKit.verifyProducedSinkData(client,index);
    client.close();
  }
  /** 
 * Tests that the Elasticsearch sink fails eagerly if the provided list of addresses is  {@code null}.
 */
  public void runNullAddressesTest() throws Exception {
    Map<String,String> userConfig=new HashMap<>();
    userConfig.put(ElasticsearchSinkBase.CONFIG_KEY_BULK_FLUSH_MAX_ACTIONS,"1");
    userConfig.put("cluster.name",CLUSTER_NAME);
    try {
      createElasticsearchSink(1,CLUSTER_NAME,null,new SourceSinkDataTestKit.TestElasticsearchSinkFunction("test"));
    }
 catch (    IllegalArgumentException|NullPointerException expectedException) {
      return;
    }
    fail();
  }
  /** 
 * Tests that the Elasticsearch sink fails eagerly if the provided list of addresses is empty.
 */
  public void runEmptyAddressesTest() throws Exception {
    Map<String,String> userConfig=new HashMap<>();
    userConfig.put(ElasticsearchSinkBase.CONFIG_KEY_BULK_FLUSH_MAX_ACTIONS,"1");
    userConfig.put("cluster.name",CLUSTER_NAME);
    try {
      createElasticsearchSink(1,CLUSTER_NAME,Collections.emptyList(),new SourceSinkDataTestKit.TestElasticsearchSinkFunction("test"));
    }
 catch (    IllegalArgumentException expectedException) {
      return;
    }
    fail();
  }
  /** 
 * Tests whether the Elasticsearch sink fails when there is no cluster to connect to.
 */
  public void runInvalidElasticsearchClusterTest() throws Exception {
    final StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    DataStreamSource<Tuple2<Integer,String>> source=env.addSource(new SourceSinkDataTestKit.TestDataSourceFunction());
    Map<String,String> userConfig=new HashMap<>();
    userConfig.put(ElasticsearchSinkBase.CONFIG_KEY_BULK_FLUSH_MAX_ACTIONS,"1");
    userConfig.put("cluster.name","invalid-cluster-name");
    source.addSink(createElasticsearchSinkForNode(1,"invalid-cluster-name",new SourceSinkDataTestKit.TestElasticsearchSinkFunction("test"),"123.123.123.123"));
    try {
      env.execute("Elasticsearch Sink Test");
    }
 catch (    JobExecutionException expectedException) {
      return;
    }
    fail();
  }
  /** 
 * Utility method to create a user config map.
 */
  protected Map<String,String> createUserConfig(  int bulkFlushMaxActions,  String clusterName){
    Map<String,String> userConfig=new HashMap<>();
    userConfig.put("cluster.name",clusterName);
    userConfig.put(ElasticsearchSinkBase.CONFIG_KEY_BULK_FLUSH_MAX_ACTIONS,String.valueOf(bulkFlushMaxActions));
    return userConfig;
  }
  /** 
 * Creates a version-specific Elasticsearch sink, using arbitrary transport addresses. 
 */
  protected abstract ElasticsearchSinkBase<Tuple2<Integer,String>,C> createElasticsearchSink(  int bulkFlushMaxActions,  String clusterName,  List<A> addresses,  ElasticsearchSinkFunction<Tuple2<Integer,String>> elasticsearchSinkFunction);
  /** 
 * Creates a version-specific Elasticsearch sink to connect to a local embedded Elasticsearch node. <p>This case is singled out from  {@link ElasticsearchSinkTestBase#createElasticsearchSink(int,String,List,ElasticsearchSinkFunction)}because the Elasticsearch Java API to do so is incompatible across different versions.
 */
  protected abstract ElasticsearchSinkBase<Tuple2<Integer,String>,C> createElasticsearchSinkForEmbeddedNode(  int bulkFlushMaxActions,  String clusterName,  ElasticsearchSinkFunction<Tuple2<Integer,String>> elasticsearchSinkFunction) throws Exception ;
  /** 
 * Creates a version-specific Elasticsearch sink to connect to a specific Elasticsearch node.
 */
  protected abstract ElasticsearchSinkBase<Tuple2<Integer,String>,C> createElasticsearchSinkForNode(  int bulkFlushMaxActions,  String clusterName,  ElasticsearchSinkFunction<Tuple2<Integer,String>> elasticsearchSinkFunction,  String ipAddress) throws Exception ;
}
