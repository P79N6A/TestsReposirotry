/** 
 * Tests for  {@link StreamOperator} snapshot restoration.
 */
public class StreamOperatorSnapshotRestoreTest extends TestLogger {
  private static final int ONLY_JM_RECOVERY=0;
  private static final int TM_AND_JM_RECOVERY=1;
  private static final int TM_REMOVE_JM_RECOVERY=2;
  private static final int JM_REMOVE_TM_RECOVERY=3;
  private static final int MAX_PARALLELISM=10;
  protected static TemporaryFolder temporaryFolder;
  @BeforeClass public static void beforeClass() throws IOException {
    temporaryFolder=new TemporaryFolder();
    temporaryFolder.create();
  }
  @AfterClass public static void afterClass(){
    temporaryFolder.delete();
  }
  /** 
 * Test restoring an operator from a snapshot (local recovery deactivated).
 */
  @Test public void testOperatorStatesSnapshotRestore() throws Exception {
    testOperatorStatesSnapshotRestoreInternal(ONLY_JM_RECOVERY);
  }
  /** 
 * Test restoring an operator from a snapshot (local recovery activated).
 */
  @Test public void testOperatorStatesSnapshotRestoreWithLocalState() throws Exception {
    testOperatorStatesSnapshotRestoreInternal(TM_AND_JM_RECOVERY);
  }
  /** 
 * Test restoring an operator from a snapshot (local recovery activated, JM snapshot deleted). <p>This case does not really simulate a practical scenario, but we make sure that restore happens from the local state here because we discard the JM state.
 */
  @Test public void testOperatorStatesSnapshotRestoreWithLocalStateDeletedJM() throws Exception {
    testOperatorStatesSnapshotRestoreInternal(TM_REMOVE_JM_RECOVERY);
  }
  /** 
 * Test restoring an operator from a snapshot (local recovery activated, local TM snapshot deleted). <p>This tests discards the local state, to simulate corruption and checks that we still recover from the fallback JM state.
 */
  @Test public void testOperatorStatesSnapshotRestoreWithLocalStateDeletedTM() throws Exception {
    testOperatorStatesSnapshotRestoreInternal(JM_REMOVE_TM_RECOVERY);
  }
  private void testOperatorStatesSnapshotRestoreInternal(  final int mode) throws Exception {
    StateBackend stateBackend=createStateBackend();
    TestOneInputStreamOperator op=new TestOneInputStreamOperator(false);
    JobID jobID=new JobID();
    JobVertexID jobVertexID=new JobVertexID();
    int subtaskIdx=0;
    LocalRecoveryDirectoryProvider directoryProvider=new LocalRecoveryDirectoryProviderImpl(temporaryFolder.newFolder(),jobID,jobVertexID,subtaskIdx);
    LocalRecoveryConfig localRecoveryConfig=new LocalRecoveryConfig(mode != ONLY_JM_RECOVERY,directoryProvider);
    MockEnvironment mockEnvironment=new MockEnvironmentBuilder().setJobID(jobID).setJobVertexID(jobVertexID).setTaskName("test").setMemorySize(1024L * 1024L).setInputSplitProvider(new MockInputSplitProvider()).setBufferSize(1024 * 1024).setTaskStateManager(new TestTaskStateManager(localRecoveryConfig)).setMaxParallelism(MAX_PARALLELISM).setSubtaskIndex(subtaskIdx).setUserCodeClassLoader(getClass().getClassLoader()).build();
    KeyedOneInputStreamOperatorTestHarness<Integer,Integer,Integer> testHarness=new KeyedOneInputStreamOperatorTestHarness<>(op,(KeySelector<Integer,Integer>)value -> value,TypeInformation.of(Integer.class),mockEnvironment);
    testHarness.setStateBackend(stateBackend);
    testHarness.open();
    for (int i=0; i < 10; ++i) {
      testHarness.processElement(new StreamRecord<>(i));
    }
    OperatorSnapshotFinalizer snapshotWithLocalState=testHarness.snapshotWithLocalState(1L,1L);
    testHarness.close();
    op=new TestOneInputStreamOperator(true);
    testHarness=new KeyedOneInputStreamOperatorTestHarness<Integer,Integer,Integer>(op,(KeySelector<Integer,Integer>)value -> value,TypeInformation.of(Integer.class),MAX_PARALLELISM,1,0){
      @Override protected StreamTaskStateInitializer createStreamTaskStateManager(      Environment env,      StateBackend stateBackend,      ProcessingTimeService processingTimeService){
        return new StreamTaskStateInitializerImpl(env,stateBackend,processingTimeService){
          @Override protected <K>InternalTimeServiceManager<K> internalTimeServiceManager(          AbstractKeyedStateBackend<K> keyedStatedBackend,          KeyContext keyContext,          Iterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {
            return null;
          }
        }
;
      }
    }
;
    testHarness.setStateBackend(stateBackend);
    OperatorSubtaskState jobManagerOwnedState=snapshotWithLocalState.getJobManagerOwnedState();
    OperatorSubtaskState taskLocalState=snapshotWithLocalState.getTaskLocalState();
    Assert.assertTrue(mode > ONLY_JM_RECOVERY == (taskLocalState != null && taskLocalState.hasState()));
    if (mode == TM_REMOVE_JM_RECOVERY) {
      jobManagerOwnedState.getManagedKeyedState().discardState();
    }
 else     if (mode == JM_REMOVE_TM_RECOVERY) {
      taskLocalState.getManagedKeyedState().discardState();
    }
    testHarness.initializeState(jobManagerOwnedState,taskLocalState);
    testHarness.open();
    for (int i=0; i < 10; ++i) {
      testHarness.processElement(new StreamRecord<>(i));
    }
    testHarness.close();
  }
  protected StateBackend createStateBackend() throws IOException {
    return createStateBackendInternal();
  }
  protected final FsStateBackend createStateBackendInternal() throws IOException {
    File checkpointDir=temporaryFolder.newFolder();
    return new FsStateBackend(checkpointDir.toURI());
  }
static class TestOneInputStreamOperator extends AbstractStreamOperator<Integer> implements OneInputStreamOperator<Integer,Integer> {
    private static final long serialVersionUID=-8942866418598856475L;
    public TestOneInputStreamOperator(    boolean verifyRestore){
      this.verifyRestore=verifyRestore;
    }
    private boolean verifyRestore;
    private ValueState<Integer> keyedState;
    private ListState<Integer> opState;
    @Override public void processElement(    StreamRecord<Integer> element) throws Exception {
      if (verifyRestore) {
        long exp=element.getValue() + 1;
        long act=keyedState.value();
        Assert.assertEquals(exp,act);
      }
 else {
        keyedState.update(element.getValue() + 1);
        opState.add(element.getValue());
      }
    }
    @Override public void processWatermark(    Watermark mark) throws Exception {
    }
    @Override public void snapshotState(    StateSnapshotContext context) throws Exception {
      KeyedStateCheckpointOutputStream out=context.getRawKeyedOperatorStateOutput();
      DataOutputView dov=new DataOutputViewStreamWrapper(out);
      int count=0;
      for (      int kg : out.getKeyGroupList()) {
        out.startNewKeyGroup(kg);
        dov.writeInt(kg + 2);
        ++count;
      }
      Assert.assertEquals(MAX_PARALLELISM,count);
      OperatorStateCheckpointOutputStream outOp=context.getRawOperatorStateOutput();
      dov=new DataOutputViewStreamWrapper(outOp);
      for (int i=0; i < 13; ++i) {
        outOp.startNewPartition();
        dov.writeInt(42 + i);
      }
    }
    @Override public void initializeState(    StateInitializationContext context) throws Exception {
      Assert.assertEquals(verifyRestore,context.isRestored());
      keyedState=context.getKeyedStateStore().getState(new ValueStateDescriptor<>("managed-keyed",Integer.class,0));
      opState=context.getOperatorStateStore().getListState(new ListStateDescriptor<>("managed-op-state",IntSerializer.INSTANCE));
      if (context.isRestored()) {
        int count=0;
        for (        KeyGroupStatePartitionStreamProvider streamProvider : context.getRawKeyedStateInputs()) {
          try (InputStream in=streamProvider.getStream()){
            DataInputView div=new DataInputViewStreamWrapper(in);
            Assert.assertEquals(streamProvider.getKeyGroupId() + 2,div.readInt());
            ++count;
          }
         }
        Assert.assertEquals(MAX_PARALLELISM,count);
        BitSet check=new BitSet(10);
        for (        int v : opState.get()) {
          check.set(v);
        }
        Assert.assertEquals(10,check.cardinality());
        check=new BitSet(13);
        for (        StatePartitionStreamProvider streamProvider : context.getRawOperatorStateInputs()) {
          try (InputStream in=streamProvider.getStream()){
            DataInputView div=new DataInputViewStreamWrapper(in);
            check.set(div.readInt() - 42);
          }
         }
        Assert.assertEquals(13,check.cardinality());
      }
    }
  }
}
