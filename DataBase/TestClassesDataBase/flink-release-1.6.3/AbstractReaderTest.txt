/** 
 * Tests for the event handling behaviour.
 */
public class AbstractReaderTest {
  @Test @SuppressWarnings("unchecked") public void testTaskEvent() throws Exception {
    final AbstractReader reader=new MockReader(createInputGate(1));
    final EventListener<TaskEvent> listener1=mock(EventListener.class);
    final EventListener<TaskEvent> listener2=mock(EventListener.class);
    final EventListener<TaskEvent> listener3=mock(EventListener.class);
    reader.registerTaskEventListener(listener1,TestTaskEvent1.class);
    reader.registerTaskEventListener(listener2,TestTaskEvent2.class);
    reader.registerTaskEventListener(listener3,TaskEvent.class);
    reader.handleEvent(new TestTaskEvent1());
    reader.handleEvent(new TestTaskEvent2());
    verify(listener1,times(1)).onEvent(Matchers.any(TaskEvent.class));
    verify(listener2,times(1)).onEvent(Matchers.any(TaskEvent.class));
    verify(listener3,times(0)).onEvent(Matchers.any(TaskEvent.class));
  }
  @Test public void testEndOfPartitionEvent() throws Exception {
    final AbstractReader reader=new MockReader(createInputGate(1));
    assertTrue(reader.handleEvent(EndOfPartitionEvent.INSTANCE));
  }
  /** 
 * Ensure that all end of superstep event related methods throw an Exception when used with a non-iterative reader.
 */
  @Test public void testExceptionsNonIterativeReader() throws Exception {
    final AbstractReader reader=new MockReader(createInputGate(4));
    assertFalse(reader.hasReachedEndOfSuperstep());
    try {
      reader.startNextSuperstep();
      fail("Did not throw expected exception when starting next superstep with non-iterative reader.");
    }
 catch (    Throwable t) {
    }
    try {
      reader.handleEvent(EndOfSuperstepEvent.INSTANCE);
      fail("Did not throw expected exception when handling end of superstep event with non-iterative reader.");
    }
 catch (    Throwable t) {
    }
  }
  @Test public void testEndOfSuperstepEventLogic() throws IOException {
    final int numberOfInputChannels=4;
    final AbstractReader reader=new MockReader(createInputGate(numberOfInputChannels));
    reader.setIterativeReader();
    try {
      reader.startNextSuperstep();
      fail("Did not throw expected exception when starting next superstep before receiving all end of superstep events.");
    }
 catch (    Throwable t) {
    }
    EndOfSuperstepEvent eos=EndOfSuperstepEvent.INSTANCE;
    for (int i=0; i < numberOfInputChannels - 1; i++) {
      assertFalse(reader.handleEvent(eos));
      assertFalse(reader.hasReachedEndOfSuperstep());
    }
    assertTrue(reader.handleEvent(eos));
    assertTrue(reader.hasReachedEndOfSuperstep());
    try {
      reader.handleEvent(eos);
      fail("Did not throw expected exception when receiving too many end of superstep events.");
    }
 catch (    Throwable t) {
    }
    reader.startNextSuperstep();
    assertFalse(reader.hasReachedEndOfSuperstep());
  }
  private InputGate createInputGate(  int numberOfInputChannels){
    final InputGate inputGate=mock(InputGate.class);
    when(inputGate.getNumberOfInputChannels()).thenReturn(numberOfInputChannels);
    return inputGate;
  }
private static class TestTaskEvent1 extends TaskEvent {
    @Override public void write(    DataOutputView out) throws IOException {
    }
    @Override public void read(    DataInputView in) throws IOException {
    }
  }
private static class TestTaskEvent2 extends TaskEvent {
    @Override public void write(    DataOutputView out) throws IOException {
    }
    @Override public void read(    DataInputView in) throws IOException {
    }
  }
private static class MockReader extends AbstractReader {
    protected MockReader(    InputGate inputGate){
      super(inputGate);
    }
  }
}
