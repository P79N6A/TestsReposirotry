/** 
 * Integration test cases for the  {@link MiniCluster}.
 */
public class MiniClusterITCase extends TestLogger {
  private static Configuration configuration;
  @BeforeClass public static void setup(){
    configuration=new Configuration();
    configuration.setInteger(WebOptions.PORT,0);
  }
  @Test public void runJobWithSingleRpcService() throws Exception {
    MiniClusterConfiguration cfg=new MiniClusterConfiguration.Builder().setRpcServiceSharing(RpcServiceSharing.SHARED).setConfiguration(configuration).build();
    MiniCluster miniCluster=new MiniCluster(cfg);
    try {
      miniCluster.start();
      executeJob(miniCluster);
    }
  finally {
      miniCluster.close();
    }
  }
  @Test public void runJobWithMultipleRpcServices() throws Exception {
    MiniClusterConfiguration cfg=new MiniClusterConfiguration.Builder().setRpcServiceSharing(RpcServiceSharing.DEDICATED).setConfiguration(configuration).build();
    MiniCluster miniCluster=new MiniCluster(cfg);
    try {
      miniCluster.start();
      executeJob(miniCluster);
    }
  finally {
      miniCluster.close();
    }
  }
  private static void executeJob(  MiniCluster miniCluster) throws Exception {
    JobGraph job=getSimpleJob();
    miniCluster.executeJobBlocking(job);
  }
  private static JobGraph getSimpleJob() throws IOException {
    JobVertex task=new JobVertex("Test task");
    task.setParallelism(1);
    task.setMaxParallelism(1);
    task.setInvokableClass(NoOpInvokable.class);
    JobGraph jg=new JobGraph(new JobID(),"Test Job",task);
    jg.setAllowQueuedScheduling(true);
    jg.setScheduleMode(ScheduleMode.EAGER);
    ExecutionConfig executionConfig=new ExecutionConfig();
    executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE,1000));
    jg.setExecutionConfig(executionConfig);
    return jg;
  }
}
