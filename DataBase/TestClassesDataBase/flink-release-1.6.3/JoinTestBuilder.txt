private class JoinTestBuilder {
  private IntervalJoinOperator<String,TestElem,TestElem,Tuple2<TestElem,TestElem>> operator;
  private TestHarness testHarness;
  public JoinTestBuilder(  TestHarness t,  IntervalJoinOperator<String,TestElem,TestElem,Tuple2<TestElem,TestElem>> operator) throws Exception {
    this.testHarness=t;
    this.operator=operator;
    t.open();
    t.setup();
  }
  public TestHarness get(){
    return testHarness;
  }
  public JoinTestBuilder processElement1(  int ts) throws Exception {
    testHarness.processElement1(createStreamRecord(ts,"lhs"));
    return this;
  }
  public JoinTestBuilder processElement2(  int ts) throws Exception {
    testHarness.processElement2(createStreamRecord(ts,"rhs"));
    return this;
  }
  public JoinTestBuilder processWatermark1(  int ts) throws Exception {
    testHarness.processWatermark1(new Watermark(ts));
    return this;
  }
  public JoinTestBuilder processWatermark2(  int ts) throws Exception {
    testHarness.processWatermark2(new Watermark(ts));
    return this;
  }
  public JoinTestBuilder processElementsAndWatermarks(  int from,  int to) throws Exception {
    if (lhsFasterThanRhs) {
      for (int i=from; i <= to; i++) {
        testHarness.processElement1(createStreamRecord(i,"lhs"));
        testHarness.processWatermark1(new Watermark(i));
      }
      for (int i=from; i <= to; i++) {
        testHarness.processElement2(createStreamRecord(i,"rhs"));
        testHarness.processWatermark2(new Watermark(i));
      }
    }
 else {
      for (int i=from; i <= to; i++) {
        testHarness.processElement2(createStreamRecord(i,"rhs"));
        testHarness.processWatermark2(new Watermark(i));
      }
      for (int i=from; i <= to; i++) {
        testHarness.processElement1(createStreamRecord(i,"lhs"));
        testHarness.processWatermark1(new Watermark(i));
      }
    }
    return this;
  }
  @SafeVarargs public final JoinTestBuilder andExpect(  StreamRecord<Tuple2<TestElem,TestElem>>... elems){
    assertOutput(Lists.newArrayList(elems),testHarness.getOutput());
    return this;
  }
  public JoinTestBuilder assertLeftBufferContainsOnly(  long... timestamps){
    try {
      assertContainsOnly(operator.getLeftBuffer(),timestamps);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    return this;
  }
  public JoinTestBuilder assertRightBufferContainsOnly(  long... timestamps){
    try {
      assertContainsOnly(operator.getRightBuffer(),timestamps);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    return this;
  }
  public JoinTestBuilder assertLeftBufferEmpty(){
    try {
      assertEmpty(operator.getLeftBuffer());
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    return this;
  }
  public JoinTestBuilder assertRightBufferEmpty(){
    try {
      assertEmpty(operator.getRightBuffer());
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    return this;
  }
  public JoinTestBuilder noLateRecords(){
    TestHarnessUtil.assertNoLateRecords(this.testHarness.getOutput());
    return this;
  }
  public void close() throws Exception {
    testHarness.close();
  }
}
