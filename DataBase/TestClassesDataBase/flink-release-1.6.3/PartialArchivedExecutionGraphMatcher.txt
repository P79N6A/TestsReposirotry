private static final class PartialArchivedExecutionGraphMatcher extends BaseMatcher<ArchivedExecutionGraph> {
  private final ArchivedExecutionGraph archivedExecutionGraph;
  private PartialArchivedExecutionGraphMatcher(  ArchivedExecutionGraph expectedArchivedExecutionGraph){
    this.archivedExecutionGraph=Preconditions.checkNotNull(expectedArchivedExecutionGraph);
  }
  @Override public boolean matches(  Object o){
    if (archivedExecutionGraph == o) {
      return true;
    }
    if (o == null || archivedExecutionGraph.getClass() != o.getClass()) {
      return false;
    }
    ArchivedExecutionGraph that=(ArchivedExecutionGraph)o;
    return archivedExecutionGraph.isStoppable() == that.isStoppable() && Objects.equals(archivedExecutionGraph.getJobID(),that.getJobID()) && Objects.equals(archivedExecutionGraph.getJobName(),that.getJobName()) && archivedExecutionGraph.getState() == that.getState() && Objects.equals(archivedExecutionGraph.getJsonPlan(),that.getJsonPlan()) && Objects.equals(archivedExecutionGraph.getAccumulatorsSerialized(),that.getAccumulatorsSerialized()) && Objects.equals(archivedExecutionGraph.getCheckpointCoordinatorConfiguration(),that.getCheckpointCoordinatorConfiguration()) && archivedExecutionGraph.getAllVertices().size() == that.getAllVertices().size();
  }
  @Override public void describeTo(  Description description){
    description.appendText("Matches against " + ArchivedExecutionGraph.class.getSimpleName() + '.');
  }
}
