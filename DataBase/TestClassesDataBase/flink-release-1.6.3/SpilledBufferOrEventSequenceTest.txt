/** 
 * Tests that validate the behavior of the  {@link SpilledBufferOrEventSequence} in isolation,with respect to detecting corrupt sequences, trailing data, and interleaved buffers and events.
 */
public class SpilledBufferOrEventSequenceTest {
  private final ByteBuffer buffer=ByteBuffer.allocateDirect(128 * 1024).order(ByteOrder.LITTLE_ENDIAN);
  private final int pageSize=32 * 1024;
  private File tempFile;
  private FileChannel fileChannel;
  @Before public void initTempChannel(){
    try {
      tempFile=File.createTempFile("testdata","tmp");
      fileChannel=new RandomAccessFile(tempFile,"rw").getChannel();
    }
 catch (    Exception e) {
      cleanup();
    }
  }
  @After public void cleanup(){
    if (fileChannel != null) {
      try {
        fileChannel.close();
      }
 catch (      IOException e) {
      }
    }
    if (tempFile != null) {
      tempFile.delete();
    }
  }
  @Test public void testEmptyChannel(){
    try {
      SpilledBufferOrEventSequence seq=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      seq.open();
      assertNull(seq.getNext());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testIncompleteHeaderOnFirstElement(){
    try {
      ByteBuffer buf=ByteBuffer.allocate(7);
      buf.order(ByteOrder.LITTLE_ENDIAN);
      FileUtils.writeCompletely(fileChannel,buf);
      fileChannel.position(0);
      SpilledBufferOrEventSequence seq=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      seq.open();
      try {
        seq.getNext();
        fail("should fail with an exception");
      }
 catch (      IOException e) {
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testBufferSequence(){
    try {
      final Random rnd=new Random();
      final long seed=rnd.nextLong();
      final int numBuffers=325;
      final int numChannels=671;
      rnd.setSeed(seed);
      for (int i=0; i < numBuffers; i++) {
        writeBuffer(fileChannel,rnd.nextInt(pageSize) + 1,rnd.nextInt(numChannels));
      }
      fileChannel.position(0L);
      rnd.setSeed(seed);
      SpilledBufferOrEventSequence seq=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      seq.open();
      for (int i=0; i < numBuffers; i++) {
        validateBuffer(seq.getNext(),rnd.nextInt(pageSize) + 1,rnd.nextInt(numChannels));
      }
      assertNull(seq.getNext());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testBufferSequenceWithIncompleteBuffer(){
    try {
      writeBuffer(fileChannel,1672,7);
      ByteBuffer data=ByteBuffer.allocate(615);
      data.order(ByteOrder.LITTLE_ENDIAN);
      data.putInt(2);
      data.putInt(999);
      data.put((byte)0);
      data.position(0);
      data.limit(312);
      FileUtils.writeCompletely(fileChannel,data);
      fileChannel.position(0L);
      SpilledBufferOrEventSequence seq=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      seq.open();
      validateBuffer(seq.getNext(),1672,7);
      try {
        seq.getNext();
        fail("should fail with an exception");
      }
 catch (      IOException e) {
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testEventSequence(){
    try {
      final Random rnd=new Random();
      final int numEvents=3000;
      final int numChannels=1656;
      final ArrayList<BufferOrEvent> events=new ArrayList<BufferOrEvent>(numEvents);
      for (int i=0; i < numEvents; i++) {
        events.add(generateAndWriteEvent(fileChannel,rnd,numChannels));
      }
      fileChannel.position(0L);
      SpilledBufferOrEventSequence seq=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      seq.open();
      int i=0;
      BufferOrEvent boe;
      while ((boe=seq.getNext()) != null) {
        BufferOrEvent expected=events.get(i);
        assertTrue(boe.isEvent());
        assertEquals(expected.getEvent(),boe.getEvent());
        assertEquals(expected.getChannelIndex(),boe.getChannelIndex());
        i++;
      }
      assertEquals(numEvents,i);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testMixedSequence(){
    try {
      final Random rnd=new Random();
      final Random bufferRnd=new Random();
      final long bufferSeed=rnd.nextLong();
      bufferRnd.setSeed(bufferSeed);
      final int numEventsAndBuffers=3000;
      final int numChannels=1656;
      final ArrayList<BufferOrEvent> events=new ArrayList<BufferOrEvent>(128);
      for (int i=0; i < numEventsAndBuffers; i++) {
        boolean isEvent=rnd.nextDouble() < 0.05d;
        if (isEvent) {
          events.add(generateAndWriteEvent(fileChannel,rnd,numChannels));
        }
 else {
          writeBuffer(fileChannel,bufferRnd.nextInt(pageSize) + 1,bufferRnd.nextInt(numChannels));
        }
      }
      fileChannel.position(0L);
      bufferRnd.setSeed(bufferSeed);
      SpilledBufferOrEventSequence seq=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      seq.open();
      int numEvent=0;
      for (int i=0; i < numEventsAndBuffers; i++) {
        BufferOrEvent next=seq.getNext();
        if (next.isEvent()) {
          BufferOrEvent expected=events.get(numEvent++);
          assertEquals(expected.getEvent(),next.getEvent());
          assertEquals(expected.getChannelIndex(),next.getChannelIndex());
        }
 else {
          validateBuffer(next,bufferRnd.nextInt(pageSize) + 1,bufferRnd.nextInt(numChannels));
        }
      }
      assertNull(seq.getNext());
      assertEquals(events.size(),numEvent);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testMultipleSequences(){
    File secondFile=null;
    FileChannel secondChannel=null;
    try {
      secondFile=File.createTempFile("testdata","tmp");
      secondChannel=new RandomAccessFile(secondFile,"rw").getChannel();
      final Random rnd=new Random();
      final Random bufferRnd=new Random();
      final long bufferSeed=rnd.nextLong();
      bufferRnd.setSeed(bufferSeed);
      final int numEventsAndBuffers1=272;
      final int numEventsAndBuffers2=151;
      final int numChannels=1656;
      final ArrayList<BufferOrEvent> events1=new ArrayList<BufferOrEvent>(128);
      final ArrayList<BufferOrEvent> events2=new ArrayList<BufferOrEvent>(128);
      for (int i=0; i < numEventsAndBuffers1; i++) {
        boolean isEvent=rnd.nextDouble() < 0.05d;
        if (isEvent) {
          events1.add(generateAndWriteEvent(fileChannel,rnd,numChannels));
        }
 else {
          writeBuffer(fileChannel,bufferRnd.nextInt(pageSize) + 1,bufferRnd.nextInt(numChannels));
        }
      }
      for (int i=0; i < numEventsAndBuffers2; i++) {
        boolean isEvent=rnd.nextDouble() < 0.05d;
        if (isEvent) {
          events2.add(generateAndWriteEvent(secondChannel,rnd,numChannels));
        }
 else {
          writeBuffer(secondChannel,bufferRnd.nextInt(pageSize) + 1,bufferRnd.nextInt(numChannels));
        }
      }
      fileChannel.position(0L);
      secondChannel.position(0L);
      bufferRnd.setSeed(bufferSeed);
      SpilledBufferOrEventSequence seq1=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      SpilledBufferOrEventSequence seq2=new SpilledBufferOrEventSequence(secondFile,secondChannel,buffer,pageSize);
      seq1.open();
      int numEvent=0;
      for (int i=0; i < numEventsAndBuffers1; i++) {
        BufferOrEvent next=seq1.getNext();
        if (next.isEvent()) {
          BufferOrEvent expected=events1.get(numEvent++);
          assertEquals(expected.getEvent(),next.getEvent());
          assertEquals(expected.getChannelIndex(),next.getChannelIndex());
        }
 else {
          validateBuffer(next,bufferRnd.nextInt(pageSize) + 1,bufferRnd.nextInt(numChannels));
        }
      }
      assertNull(seq1.getNext());
      assertEquals(events1.size(),numEvent);
      seq2.open();
      numEvent=0;
      for (int i=0; i < numEventsAndBuffers2; i++) {
        BufferOrEvent next=seq2.getNext();
        if (next.isEvent()) {
          BufferOrEvent expected=events2.get(numEvent++);
          assertEquals(expected.getEvent(),next.getEvent());
          assertEquals(expected.getChannelIndex(),next.getChannelIndex());
        }
 else {
          validateBuffer(next,bufferRnd.nextInt(pageSize) + 1,bufferRnd.nextInt(numChannels));
        }
      }
      assertNull(seq2.getNext());
      assertEquals(events2.size(),numEvent);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
 finally {
      if (secondChannel != null) {
        try {
          secondChannel.close();
        }
 catch (        IOException e) {
        }
      }
      if (secondFile != null) {
        secondFile.delete();
      }
    }
  }
  @Test public void testCleanup(){
    try {
      ByteBuffer data=ByteBuffer.allocate(157);
      data.order(ByteOrder.LITTLE_ENDIAN);
      FileUtils.writeCompletely(fileChannel,data);
      fileChannel.position(54);
      SpilledBufferOrEventSequence seq=new SpilledBufferOrEventSequence(tempFile,fileChannel,buffer,pageSize);
      seq.open();
      seq.cleanup();
      assertFalse(fileChannel.isOpen());
      assertFalse(tempFile.exists());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  private static BufferOrEvent generateAndWriteEvent(  FileChannel fileChannel,  Random rnd,  int numChannels) throws IOException {
    long magicNumber=rnd.nextLong();
    byte[] data=new byte[rnd.nextInt(1000)];
    rnd.nextBytes(data);
    TestEvent evt=new TestEvent(magicNumber,data);
    int channelIndex=rnd.nextInt(numChannels);
    ByteBuffer serializedEvent=EventSerializer.toSerializedEvent(evt);
    ByteBuffer header=ByteBuffer.allocate(9);
    header.order(ByteOrder.LITTLE_ENDIAN);
    header.putInt(channelIndex);
    header.putInt(serializedEvent.remaining());
    header.put((byte)1);
    header.flip();
    FileUtils.writeCompletely(fileChannel,header);
    FileUtils.writeCompletely(fileChannel,serializedEvent);
    return new BufferOrEvent(evt,channelIndex);
  }
  private static void writeBuffer(  FileChannel fileChannel,  int size,  int channelIndex) throws IOException {
    ByteBuffer data=ByteBuffer.allocate(size + 9);
    data.order(ByteOrder.LITTLE_ENDIAN);
    data.putInt(channelIndex);
    data.putInt(size);
    data.put((byte)0);
    for (int i=0; i < size; i++) {
      data.put((byte)i);
    }
    data.flip();
    FileUtils.writeCompletely(fileChannel,data);
  }
  private static void validateBuffer(  BufferOrEvent boe,  int expectedSize,  int expectedChannelIndex){
    assertEquals("wrong channel index",expectedChannelIndex,boe.getChannelIndex());
    assertTrue("is not buffer",boe.isBuffer());
    Buffer buf=boe.getBuffer();
    assertEquals("wrong buffer size",expectedSize,buf.getSize());
    MemorySegment seg=buf.getMemorySegment();
    for (int i=0; i < expectedSize; i++) {
      assertEquals("wrong buffer contents",(byte)i,seg.get(i));
    }
  }
}
