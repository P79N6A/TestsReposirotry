public class TaskExecutorLocalStateStoresManagerTest extends TestLogger {
  @ClassRule public static TemporaryFolder temporaryFolder=new TemporaryFolder();
  private static final long MEM_SIZE_PARAM=128L * 1024 * 1024;
  /** 
 * This tests that the creation of  {@link TaskManagerServices} correctly creates the local state root directoryfor the  {@link TaskExecutorLocalStateStoresManager} with the configured root directory.
 */
  @Test public void testCreationFromConfig() throws Exception {
    final Configuration config=new Configuration();
    File newFolder=temporaryFolder.newFolder();
    String tmpDir=newFolder.getAbsolutePath() + File.separator;
    final String rootDirString="__localStateRoot1,__localStateRoot2,__localStateRoot3".replaceAll("__",tmpDir);
    config.setString(CheckpointingOptions.LOCAL_RECOVERY_TASK_MANAGER_STATE_ROOT_DIRS,rootDirString);
    config.setBoolean(CheckpointingOptions.LOCAL_RECOVERY,true);
    final ResourceID tmResourceID=ResourceID.generate();
    TaskManagerServicesConfiguration taskManagerServicesConfiguration=TaskManagerServicesConfiguration.fromConfiguration(config,InetAddress.getLocalHost(),true);
    TaskManagerServices taskManagerServices=TaskManagerServices.fromConfiguration(taskManagerServicesConfiguration,tmResourceID,Executors.directExecutor(),MEM_SIZE_PARAM,MEM_SIZE_PARAM);
    TaskExecutorLocalStateStoresManager taskStateManager=taskManagerServices.getTaskManagerStateStore();
    String[] split=rootDirString.split(",");
    File[] rootDirectories=taskStateManager.getLocalStateRootDirectories();
    for (int i=0; i < split.length; ++i) {
      Assert.assertEquals(new File(split[i],TaskManagerServices.LOCAL_STATE_SUB_DIRECTORY_ROOT),rootDirectories[i]);
    }
    Assert.assertTrue(taskStateManager.isLocalRecoveryEnabled());
    Assert.assertEquals("localState",TaskManagerServices.LOCAL_STATE_SUB_DIRECTORY_ROOT);
    for (    File rootDirectory : rootDirectories) {
      FileUtils.deleteFileOrDirectory(rootDirectory);
    }
  }
  /** 
 * This tests that the creation of  {@link TaskManagerServices} correctly falls back to the first tmp directory ofthe IOManager as default for the local state root directory.
 */
  @Test public void testCreationFromConfigDefault() throws Exception {
    final Configuration config=new Configuration();
    final ResourceID tmResourceID=ResourceID.generate();
    TaskManagerServicesConfiguration taskManagerServicesConfiguration=TaskManagerServicesConfiguration.fromConfiguration(config,InetAddress.getLocalHost(),true);
    TaskManagerServices taskManagerServices=TaskManagerServices.fromConfiguration(taskManagerServicesConfiguration,tmResourceID,Executors.directExecutor(),MEM_SIZE_PARAM,MEM_SIZE_PARAM);
    TaskExecutorLocalStateStoresManager taskStateManager=taskManagerServices.getTaskManagerStateStore();
    String[] tmpDirPaths=taskManagerServicesConfiguration.getTmpDirPaths();
    File[] localStateRootDirectories=taskStateManager.getLocalStateRootDirectories();
    for (int i=0; i < tmpDirPaths.length; ++i) {
      Assert.assertEquals(new File(tmpDirPaths[i],TaskManagerServices.LOCAL_STATE_SUB_DIRECTORY_ROOT),localStateRootDirectories[i]);
    }
    Assert.assertFalse(taskStateManager.isLocalRecoveryEnabled());
  }
  /** 
 * This tests that the  {@link TaskExecutorLocalStateStoresManager} creates {@link TaskLocalStateStoreImpl} that havea properly initialized local state base directory. It also checks that subdirectories are correctly deleted on shutdown.
 */
  @Test public void testSubtaskStateStoreDirectoryCreateAndDelete() throws Exception {
    JobID jobID=new JobID();
    JobVertexID jobVertexID=new JobVertexID();
    AllocationID allocationID=new AllocationID();
    int subtaskIdx=23;
    File[] rootDirs={temporaryFolder.newFolder(),temporaryFolder.newFolder(),temporaryFolder.newFolder()};
    TaskExecutorLocalStateStoresManager storesManager=new TaskExecutorLocalStateStoresManager(true,rootDirs,Executors.directExecutor());
    TaskLocalStateStore taskLocalStateStore=storesManager.localStateStoreForSubtask(jobID,allocationID,jobVertexID,subtaskIdx);
    LocalRecoveryDirectoryProvider directoryProvider=taskLocalStateStore.getLocalRecoveryConfig().getLocalStateDirectoryProvider();
    for (int i=0; i < 10; ++i) {
      Assert.assertEquals(new File(rootDirs[(i & Integer.MAX_VALUE) % rootDirs.length],storesManager.allocationSubDirString(allocationID)),directoryProvider.allocationBaseDirectory(i));
    }
    long chkId=42L;
    File allocBaseDirChk42=directoryProvider.allocationBaseDirectory(chkId);
    File subtaskSpecificCheckpointDirectory=directoryProvider.subtaskSpecificCheckpointDirectory(chkId);
    Assert.assertEquals(new File(allocBaseDirChk42,"jid_" + jobID + File.separator+ "vtx_"+ jobVertexID+ "_"+ "sti_"+ subtaskIdx+ File.separator+ "chk_"+ chkId),subtaskSpecificCheckpointDirectory);
    Assert.assertTrue(subtaskSpecificCheckpointDirectory.mkdirs());
    File testFile=new File(subtaskSpecificCheckpointDirectory,"test");
    Assert.assertTrue(testFile.createNewFile());
    Assert.assertEquals(storesManager.isLocalRecoveryEnabled(),taskLocalStateStore.getLocalRecoveryConfig().isLocalRecoveryEnabled());
    Assert.assertTrue(testFile.exists());
    storesManager.releaseLocalStateForAllocationId(allocationID);
    checkRootDirsClean(rootDirs);
    AllocationID otherAllocationID=new AllocationID();
    taskLocalStateStore=storesManager.localStateStoreForSubtask(jobID,otherAllocationID,jobVertexID,subtaskIdx);
    directoryProvider=taskLocalStateStore.getLocalRecoveryConfig().getLocalStateDirectoryProvider();
    File chkDir=directoryProvider.subtaskSpecificCheckpointDirectory(23L);
    Assert.assertTrue(chkDir.mkdirs());
    testFile=new File(chkDir,"test");
    Assert.assertTrue(testFile.createNewFile());
    storesManager.shutdown();
    checkRootDirsClean(rootDirs);
  }
  private void checkRootDirsClean(  File[] rootDirs){
    for (    File rootDir : rootDirs) {
      File[] files=rootDir.listFiles();
      if (files != null) {
        Assert.assertArrayEquals(new File[0],files);
      }
    }
  }
}
