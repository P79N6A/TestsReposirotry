/** 
 * This test verifies that the auto parallelism is properly forwarded to the runtime.
 */
@SuppressWarnings("serial") public class AutoParallelismITCase extends TestLogger {
  private static final int NUM_TM=2;
  private static final int SLOTS_PER_TM=7;
  private static final int PARALLELISM=NUM_TM * SLOTS_PER_TM;
  @ClassRule public static final MiniClusterResource MINI_CLUSTER_RESOURCE=new MiniClusterResource(new MiniClusterResourceConfiguration.Builder().setNumberTaskManagers(NUM_TM).setNumberSlotsPerTaskManager(SLOTS_PER_TM).build());
  @Test public void testProgramWithAutoParallelism() throws Exception {
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(ExecutionConfig.PARALLELISM_AUTO_MAX);
    env.getConfig().disableSysoutLogging();
    DataSet<Integer> result=env.createInput(new ParallelismDependentInputFormat()).rebalance().mapPartition(new ParallelismDependentMapPartition());
    List<Integer> resultCollection=new ArrayList<>();
    result.output(new LocalCollectionOutputFormat<>(resultCollection));
    try {
      env.execute();
      assertEquals(PARALLELISM,resultCollection.size());
    }
 catch (    Exception ex) {
      if (MINI_CLUSTER_RESOURCE.getCodebaseType() == TestBaseUtils.CodebaseType.LEGACY) {
        throw ex;
      }
      assertTrue(ExceptionUtils.findThrowableWithMessage(ex,ExecutionGraphBuilder.PARALLELISM_AUTO_MAX_ERROR_MESSAGE).isPresent());
    }
  }
private static class ParallelismDependentInputFormat extends GenericInputFormat<Integer> {
    private transient boolean emitted;
    @Override public GenericInputSplit[] createInputSplits(    int numSplits) throws IOException {
      assertEquals(PARALLELISM,numSplits);
      return super.createInputSplits(numSplits);
    }
    @Override public boolean reachedEnd(){
      return emitted;
    }
    @Override public Integer nextRecord(    Integer reuse){
      if (emitted) {
        return null;
      }
      emitted=true;
      return 1;
    }
  }
private static class ParallelismDependentMapPartition extends RichMapPartitionFunction<Integer,Integer> {
    @Override public void mapPartition(    Iterable<Integer> values,    Collector<Integer> out){
      out.collect(getRuntimeContext().getIndexOfThisSubtask());
    }
  }
}
