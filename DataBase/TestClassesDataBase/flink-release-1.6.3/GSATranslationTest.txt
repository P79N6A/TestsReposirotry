/** 
 * Test the creation of a  {@link GatherSumApplyIteration} program.
 */
public class GSATranslationTest {
  private static final String ITERATION_NAME="Test Name";
  private static final String AGGREGATOR_NAME="AggregatorName";
  private static final String BC_SET_GATHER_NAME="gather messages";
  private static final String BC_SET_SUM_NAME="sum updates";
  private static final String BC_SET_APLLY_NAME="apply updates";
  private static final int NUM_ITERATIONS=13;
  private static final int ITERATION_parallelism=77;
  @Test public void testTranslation(){
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<Long> bcGather=env.fromElements(1L);
    DataSet<Long> bcSum=env.fromElements(1L);
    DataSet<Long> bcApply=env.fromElements(1L);
    DataSet<Vertex<Long,Long>> result;
    DataSet<Edge<Long,NullValue>> edges=env.fromElements(new Tuple3<>(1L,2L,NullValue.getInstance())).map(new Tuple3ToEdgeMap<>());
    Graph<Long,Long,NullValue> graph=Graph.fromDataSet(edges,new InitVertices(),env);
    GSAConfiguration parameters=new GSAConfiguration();
    parameters.registerAggregator(AGGREGATOR_NAME,new LongSumAggregator());
    parameters.setName(ITERATION_NAME);
    parameters.setParallelism(ITERATION_parallelism);
    parameters.addBroadcastSetForGatherFunction(BC_SET_GATHER_NAME,bcGather);
    parameters.addBroadcastSetForSumFunction(BC_SET_SUM_NAME,bcSum);
    parameters.addBroadcastSetForApplyFunction(BC_SET_APLLY_NAME,bcApply);
    result=graph.runGatherSumApplyIteration(new GatherNeighborIds(),new SelectMinId(),new UpdateComponentId(),NUM_ITERATIONS,parameters).getVertices();
    result.output(new DiscardingOutputFormat<>());
    assertTrue(result instanceof DeltaIterationResultSet);
    DeltaIterationResultSet<?,?> resultSet=(DeltaIterationResultSet<?,?>)result;
    DeltaIteration<?,?> iteration=resultSet.getIterationHead();
    assertEquals(NUM_ITERATIONS,resultSet.getMaxIterations());
    assertArrayEquals(new int[]{0},resultSet.getKeyPositions());
    assertEquals(ITERATION_parallelism,iteration.getParallelism());
    assertEquals(ITERATION_NAME,iteration.getName());
    assertEquals(AGGREGATOR_NAME,iteration.getAggregators().getAllRegisteredAggregators().iterator().next().getName());
    TwoInputUdfOperator<?,?,?,?> solutionSetJoin=(TwoInputUdfOperator<?,?,?,?>)resultSet.getNextWorkset();
    assertTrue(solutionSetJoin.getSemanticProperties().getForwardingTargetFields(0,0).contains(0));
    assertTrue(solutionSetJoin.getSemanticProperties().getForwardingTargetFields(1,0).contains(0));
    SingleInputUdfOperator<?,?,?> sumReduce=(SingleInputUdfOperator<?,?,?>)solutionSetJoin.getInput1();
    SingleInputUdfOperator<?,?,?> gatherMap=(SingleInputUdfOperator<?,?,?>)sumReduce.getInput();
    assertEquals(bcGather,gatherMap.getBroadcastSets().get(BC_SET_GATHER_NAME));
    assertEquals(bcSum,sumReduce.getBroadcastSets().get(BC_SET_SUM_NAME));
    assertEquals(bcApply,solutionSetJoin.getBroadcastSets().get(BC_SET_APLLY_NAME));
  }
@SuppressWarnings("serial") private static final class InitVertices implements MapFunction<Long,Long> {
    public Long map(    Long vertexId){
      return vertexId;
    }
  }
@SuppressWarnings("serial") private static final class GatherNeighborIds extends GatherFunction<Long,NullValue,Long> {
    public Long gather(    Neighbor<Long,NullValue> neighbor){
      return neighbor.getNeighborValue();
    }
  }
@SuppressWarnings("serial") private static final class SelectMinId extends SumFunction<Long,NullValue,Long> {
    public Long sum(    Long newValue,    Long currentValue){
      return Math.min(newValue,currentValue);
    }
  }
@SuppressWarnings("serial") private static final class UpdateComponentId extends ApplyFunction<Long,Long,Long> {
    public void apply(    Long summedValue,    Long origValue){
      if (summedValue < origValue) {
        setResult(summedValue);
      }
    }
  }
}
