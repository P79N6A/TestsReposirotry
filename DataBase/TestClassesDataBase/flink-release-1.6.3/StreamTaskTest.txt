/** 
 * Tests for  {@link StreamTask}.
 */
@RunWith(PowerMockRunner.class) @PrepareForTest(StreamTask.class) @PowerMockIgnore("org.apache.log4j.*") @SuppressWarnings("deprecation") public class StreamTaskTest extends TestLogger {
  private static OneShotLatch syncLatch;
  /** 
 * This test checks that cancel calls that are issued before the operator is instantiated still lead to proper canceling.
 */
  @Test public void testEarlyCanceling() throws Exception {
    Deadline deadline=Deadline.fromNow(Duration.ofMinutes(2));
    StreamConfig cfg=new StreamConfig(new Configuration());
    cfg.setOperatorID(new OperatorID(4711L,42L));
    cfg.setStreamOperator(new SlowlyDeserializingOperator());
    cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);
    Task task=createTask(SourceStreamTask.class,cfg,new Configuration());
    TestingExecutionStateListener testingExecutionStateListener=new TestingExecutionStateListener();
    task.registerExecutionListener(testingExecutionStateListener);
    task.startTaskThread();
    Future<ExecutionState> running=testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING);
    ExecutionState executionState=running.get(deadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    if (executionState != ExecutionState.RUNNING) {
      fail("Task entered state " + task.getExecutionState() + " with error "+ ExceptionUtils.stringifyException(task.getFailureCause()));
    }
    task.cancelExecution();
    Future<ExecutionState> canceling=testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING);
    executionState=canceling.get(deadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    assertTrue(executionState == ExecutionState.CANCELING || executionState == ExecutionState.CANCELED);
    task.getExecutingThread().join(deadline.timeLeft().toMillis());
    assertFalse("Task did not cancel",task.getExecutingThread().isAlive());
    assertEquals(ExecutionState.CANCELED,task.getExecutionState());
  }
  @Test public void testStateBackendLoadingAndClosing() throws Exception {
    Configuration taskManagerConfig=new Configuration();
    taskManagerConfig.setString(CheckpointingOptions.STATE_BACKEND,TestMemoryStateBackendFactory.class.getName());
    StreamConfig cfg=new StreamConfig(new Configuration());
    cfg.setStateKeySerializer(mock(TypeSerializer.class));
    cfg.setOperatorID(new OperatorID(4711L,42L));
    TestStreamSource<Long,MockSourceFunction> streamSource=new TestStreamSource<>(new MockSourceFunction());
    cfg.setStreamOperator(streamSource);
    cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);
    Task task=createTask(StateBackendTestSource.class,cfg,taskManagerConfig);
    StateBackendTestSource.fail=false;
    task.startTaskThread();
    task.getExecutingThread().join();
    verify(TestStreamSource.operatorStateBackend).close();
    verify(TestStreamSource.keyedStateBackend).close();
    verify(TestStreamSource.rawOperatorStateInputs).close();
    verify(TestStreamSource.rawKeyedStateInputs).close();
    verify(TestStreamSource.operatorStateBackend).dispose();
    verify(TestStreamSource.keyedStateBackend).dispose();
    assertEquals(ExecutionState.FINISHED,task.getExecutionState());
  }
  @Test public void testStateBackendClosingOnFailure() throws Exception {
    Configuration taskManagerConfig=new Configuration();
    taskManagerConfig.setString(CheckpointingOptions.STATE_BACKEND,TestMemoryStateBackendFactory.class.getName());
    StreamConfig cfg=new StreamConfig(new Configuration());
    cfg.setStateKeySerializer(mock(TypeSerializer.class));
    cfg.setOperatorID(new OperatorID(4711L,42L));
    TestStreamSource<Long,MockSourceFunction> streamSource=new TestStreamSource<>(new MockSourceFunction());
    cfg.setStreamOperator(streamSource);
    cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);
    Task task=createTask(StateBackendTestSource.class,cfg,taskManagerConfig);
    StateBackendTestSource.fail=true;
    task.startTaskThread();
    task.getExecutingThread().join();
    verify(TestStreamSource.operatorStateBackend).close();
    verify(TestStreamSource.keyedStateBackend).close();
    verify(TestStreamSource.rawOperatorStateInputs).close();
    verify(TestStreamSource.rawKeyedStateInputs).close();
    verify(TestStreamSource.operatorStateBackend).dispose();
    verify(TestStreamSource.keyedStateBackend).dispose();
    assertEquals(ExecutionState.FAILED,task.getExecutionState());
  }
  @Test public void testCancellationNotBlockedOnLock() throws Exception {
    syncLatch=new OneShotLatch();
    StreamConfig cfg=new StreamConfig(new Configuration());
    Task task=createTask(CancelLockingTask.class,cfg,new Configuration());
    task.startTaskThread();
    syncLatch.await();
    task.cancelExecution();
    task.getExecutingThread().join();
    assertEquals(ExecutionState.CANCELED,task.getExecutionState());
  }
  @Test public void testCancellationFailsWithBlockingLock() throws Exception {
    syncLatch=new OneShotLatch();
    StreamConfig cfg=new StreamConfig(new Configuration());
    Task task=createTask(CancelFailingTask.class,cfg,new Configuration());
    task.startTaskThread();
    syncLatch.await();
    task.cancelExecution();
    task.getExecutingThread().join();
    assertEquals(ExecutionState.CANCELED,task.getExecutionState());
  }
  @Test public void testFailingCheckpointStreamOperator() throws Exception {
    final long checkpointId=42L;
    final long timestamp=1L;
    TaskInfo mockTaskInfo=mock(TaskInfo.class);
    when(mockTaskInfo.getTaskNameWithSubtasks()).thenReturn("foobar");
    when(mockTaskInfo.getIndexOfThisSubtask()).thenReturn(0);
    Environment mockEnvironment=new MockEnvironmentBuilder().build();
    StreamTask<?,?> streamTask=new EmptyStreamTask(mockEnvironment);
    CheckpointMetaData checkpointMetaData=new CheckpointMetaData(checkpointId,timestamp);
    StreamOperator<?> streamOperator1=mock(StreamOperator.class);
    StreamOperator<?> streamOperator2=mock(StreamOperator.class);
    StreamOperator<?> streamOperator3=mock(StreamOperator.class);
    OperatorSnapshotFutures operatorSnapshotResult1=mock(OperatorSnapshotFutures.class);
    OperatorSnapshotFutures operatorSnapshotResult2=mock(OperatorSnapshotFutures.class);
    final Exception testException=new Exception("Test exception");
    when(streamOperator1.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1);
    when(streamOperator2.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2);
    when(streamOperator3.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenThrow(testException);
    OperatorID operatorID1=new OperatorID();
    OperatorID operatorID2=new OperatorID();
    OperatorID operatorID3=new OperatorID();
    when(streamOperator1.getOperatorID()).thenReturn(operatorID1);
    when(streamOperator2.getOperatorID()).thenReturn(operatorID2);
    when(streamOperator3.getOperatorID()).thenReturn(operatorID3);
    StreamOperator<?>[] streamOperators={streamOperator1,streamOperator2,streamOperator3};
    OperatorChain<Void,AbstractStreamOperator<Void>> operatorChain=mock(OperatorChain.class);
    when(operatorChain.getAllOperators()).thenReturn(streamOperators);
    Whitebox.setInternalState(streamTask,"isRunning",true);
    Whitebox.setInternalState(streamTask,"lock",new Object());
    Whitebox.setInternalState(streamTask,"operatorChain",operatorChain);
    Whitebox.setInternalState(streamTask,"cancelables",new CloseableRegistry());
    Whitebox.setInternalState(streamTask,"configuration",new StreamConfig(new Configuration()));
    Whitebox.setInternalState(streamTask,"checkpointStorage",new MemoryBackendCheckpointStorage(new JobID(),null,null,Integer.MAX_VALUE));
    CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory=new CheckpointExceptionHandlerFactory();
    CheckpointExceptionHandler checkpointExceptionHandler=checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true,mockEnvironment);
    Whitebox.setInternalState(streamTask,"synchronousCheckpointExceptionHandler",checkpointExceptionHandler);
    StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler=new StreamTask.AsyncCheckpointExceptionHandler(streamTask);
    Whitebox.setInternalState(streamTask,"asynchronousCheckpointExceptionHandler",asyncCheckpointExceptionHandler);
    try {
      streamTask.triggerCheckpoint(checkpointMetaData,CheckpointOptions.forCheckpointWithDefaultLocation());
      fail("Expected test exception here.");
    }
 catch (    Exception e) {
      assertEquals(testException,e.getCause());
    }
    verify(operatorSnapshotResult1).cancel();
    verify(operatorSnapshotResult2).cancel();
  }
  /** 
 * Tests that in case of a failing AsyncCheckpointRunnable all operator snapshot results are cancelled and all non partitioned state handles are discarded.
 */
  @Test public void testFailingAsyncCheckpointRunnable() throws Exception {
    final long checkpointId=42L;
    final long timestamp=1L;
    MockEnvironment mockEnvironment=new MockEnvironmentBuilder().build();
    StreamTask<?,?> streamTask=spy(new EmptyStreamTask(mockEnvironment));
    CheckpointMetaData checkpointMetaData=new CheckpointMetaData(checkpointId,timestamp);
    StreamOperator<?> streamOperator1=mock(StreamOperator.class);
    StreamOperator<?> streamOperator2=mock(StreamOperator.class);
    StreamOperator<?> streamOperator3=mock(StreamOperator.class);
    OperatorSnapshotFutures operatorSnapshotResult1=mock(OperatorSnapshotFutures.class);
    OperatorSnapshotFutures operatorSnapshotResult2=mock(OperatorSnapshotFutures.class);
    OperatorSnapshotFutures operatorSnapshotResult3=mock(OperatorSnapshotFutures.class);
    RunnableFuture<SnapshotResult<OperatorStateHandle>> failingFuture=mock(RunnableFuture.class);
    when(failingFuture.get()).thenThrow(new ExecutionException(new Exception("Test exception")));
    when(operatorSnapshotResult3.getOperatorStateRawFuture()).thenReturn(failingFuture);
    when(streamOperator1.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult1);
    when(streamOperator2.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult2);
    when(streamOperator3.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult3);
    OperatorID operatorID1=new OperatorID();
    OperatorID operatorID2=new OperatorID();
    OperatorID operatorID3=new OperatorID();
    when(streamOperator1.getOperatorID()).thenReturn(operatorID1);
    when(streamOperator2.getOperatorID()).thenReturn(operatorID2);
    when(streamOperator3.getOperatorID()).thenReturn(operatorID3);
    StreamOperator<?>[] streamOperators={streamOperator1,streamOperator2,streamOperator3};
    OperatorChain<Void,AbstractStreamOperator<Void>> operatorChain=mock(OperatorChain.class);
    when(operatorChain.getAllOperators()).thenReturn(streamOperators);
    Whitebox.setInternalState(streamTask,"isRunning",true);
    Whitebox.setInternalState(streamTask,"lock",new Object());
    Whitebox.setInternalState(streamTask,"operatorChain",operatorChain);
    Whitebox.setInternalState(streamTask,"cancelables",new CloseableRegistry());
    Whitebox.setInternalState(streamTask,"asyncOperationsThreadPool",new DirectExecutorService());
    Whitebox.setInternalState(streamTask,"configuration",new StreamConfig(new Configuration()));
    Whitebox.setInternalState(streamTask,"checkpointStorage",new MemoryBackendCheckpointStorage(new JobID(),null,null,Integer.MAX_VALUE));
    CheckpointExceptionHandlerFactory checkpointExceptionHandlerFactory=new CheckpointExceptionHandlerFactory();
    CheckpointExceptionHandler checkpointExceptionHandler=checkpointExceptionHandlerFactory.createCheckpointExceptionHandler(true,mockEnvironment);
    Whitebox.setInternalState(streamTask,"synchronousCheckpointExceptionHandler",checkpointExceptionHandler);
    StreamTask.AsyncCheckpointExceptionHandler asyncCheckpointExceptionHandler=new StreamTask.AsyncCheckpointExceptionHandler(streamTask);
    Whitebox.setInternalState(streamTask,"asynchronousCheckpointExceptionHandler",asyncCheckpointExceptionHandler);
    mockEnvironment.setExpectedExternalFailureCause(Throwable.class);
    streamTask.triggerCheckpoint(checkpointMetaData,CheckpointOptions.forCheckpointWithDefaultLocation());
    verify(streamTask).handleAsyncException(anyString(),any(Throwable.class));
    verify(operatorSnapshotResult1).cancel();
    verify(operatorSnapshotResult2).cancel();
    verify(operatorSnapshotResult3).cancel();
  }
  /** 
 * FLINK-5667 <p>Tests that a concurrent cancel operation does not discard the state handles of an acknowledged checkpoint. The situation can only happen if the cancel call is executed after Environment.acknowledgeCheckpoint() and before the CloseableRegistry.unregisterClosable() call.
 */
  @Test public void testAsyncCheckpointingConcurrentCloseAfterAcknowledge() throws Exception {
    final long checkpointId=42L;
    final long timestamp=1L;
    final OneShotLatch acknowledgeCheckpointLatch=new OneShotLatch();
    final OneShotLatch completeAcknowledge=new OneShotLatch();
    CheckpointResponder checkpointResponder=mock(CheckpointResponder.class);
    doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocation) throws Throwable {
        acknowledgeCheckpointLatch.trigger();
        completeAcknowledge.await();
        return null;
      }
    }
).when(checkpointResponder).acknowledgeCheckpoint(any(JobID.class),any(ExecutionAttemptID.class),anyLong(),any(CheckpointMetrics.class),any(TaskStateSnapshot.class));
    TaskStateManager taskStateManager=new TaskStateManagerImpl(new JobID(1L,2L),new ExecutionAttemptID(1L,2L),mock(TaskLocalStateStoreImpl.class),null,checkpointResponder);
    MockEnvironment mockEnvironment=new MockEnvironmentBuilder().setTaskName("mock-task").setTaskStateManager(taskStateManager).build();
    StreamTask<?,?> streamTask=new EmptyStreamTask(mockEnvironment);
    CheckpointMetaData checkpointMetaData=new CheckpointMetaData(checkpointId,timestamp);
    StreamOperator<?> streamOperator=mock(StreamOperator.class);
    when(streamOperator.getOperatorID()).thenReturn(new OperatorID(42,42));
    KeyedStateHandle managedKeyedStateHandle=mock(KeyedStateHandle.class);
    KeyedStateHandle rawKeyedStateHandle=mock(KeyedStateHandle.class);
    OperatorStateHandle managedOperatorStateHandle=mock(OperatorStreamStateHandle.class);
    OperatorStateHandle rawOperatorStateHandle=mock(OperatorStreamStateHandle.class);
    OperatorSnapshotFutures operatorSnapshotResult=new OperatorSnapshotFutures(DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)));
    when(streamOperator.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult);
    StreamOperator<?>[] streamOperators={streamOperator};
    OperatorChain<Void,AbstractStreamOperator<Void>> operatorChain=mock(OperatorChain.class);
    when(operatorChain.getAllOperators()).thenReturn(streamOperators);
    CheckpointStorage checkpointStorage=new MemoryBackendCheckpointStorage(new JobID(),null,null,Integer.MAX_VALUE);
    Whitebox.setInternalState(streamTask,"isRunning",true);
    Whitebox.setInternalState(streamTask,"lock",new Object());
    Whitebox.setInternalState(streamTask,"operatorChain",operatorChain);
    Whitebox.setInternalState(streamTask,"cancelables",new CloseableRegistry());
    Whitebox.setInternalState(streamTask,"asyncOperationsThreadPool",Executors.newFixedThreadPool(1));
    Whitebox.setInternalState(streamTask,"configuration",new StreamConfig(new Configuration()));
    Whitebox.setInternalState(streamTask,"checkpointStorage",checkpointStorage);
    streamTask.triggerCheckpoint(checkpointMetaData,CheckpointOptions.forCheckpointWithDefaultLocation());
    acknowledgeCheckpointLatch.await();
    ArgumentCaptor<TaskStateSnapshot> subtaskStateCaptor=ArgumentCaptor.forClass(TaskStateSnapshot.class);
    verify(checkpointResponder).acknowledgeCheckpoint(any(JobID.class),any(ExecutionAttemptID.class),eq(checkpointId),any(CheckpointMetrics.class),subtaskStateCaptor.capture());
    TaskStateSnapshot subtaskStates=subtaskStateCaptor.getValue();
    OperatorSubtaskState subtaskState=subtaskStates.getSubtaskStateMappings().iterator().next().getValue();
    assertEquals(StateObjectCollection.singleton(managedKeyedStateHandle),subtaskState.getManagedKeyedState());
    assertEquals(StateObjectCollection.singleton(rawKeyedStateHandle),subtaskState.getRawKeyedState());
    assertEquals(StateObjectCollection.singleton(managedOperatorStateHandle),subtaskState.getManagedOperatorState());
    assertEquals(StateObjectCollection.singleton(rawOperatorStateHandle),subtaskState.getRawOperatorState());
    verify(managedKeyedStateHandle,never()).discardState();
    verify(rawKeyedStateHandle,never()).discardState();
    verify(managedOperatorStateHandle,never()).discardState();
    verify(rawOperatorStateHandle,never()).discardState();
    streamTask.cancel();
    completeAcknowledge.trigger();
    verify(managedKeyedStateHandle,never()).discardState();
    verify(rawKeyedStateHandle,never()).discardState();
    verify(managedOperatorStateHandle,never()).discardState();
    verify(rawOperatorStateHandle,never()).discardState();
  }
  /** 
 * FLINK-5667 <p>Tests that a concurrent cancel operation discards the state handles of a not yet acknowledged checkpoint and prevents sending an acknowledge message to the CheckpointCoordinator. The situation can only happen if the cancel call is executed before Environment.acknowledgeCheckpoint().
 */
  @Test public void testAsyncCheckpointingConcurrentCloseBeforeAcknowledge() throws Exception {
    final long checkpointId=42L;
    final long timestamp=1L;
    final OneShotLatch createSubtask=new OneShotLatch();
    final OneShotLatch completeSubtask=new OneShotLatch();
    Environment mockEnvironment=spy(new MockEnvironmentBuilder().build());
    whenNew(OperatorSnapshotFinalizer.class).withAnyArguments().thenAnswer((Answer<OperatorSnapshotFinalizer>)invocation -> {
      createSubtask.trigger();
      completeSubtask.await();
      Object[] arguments=invocation.getArguments();
      return new OperatorSnapshotFinalizer((OperatorSnapshotFutures)arguments[0]);
    }
);
    StreamTask<?,?> streamTask=new EmptyStreamTask(mockEnvironment);
    CheckpointMetaData checkpointMetaData=new CheckpointMetaData(checkpointId,timestamp);
    final StreamOperator<?> streamOperator=mock(StreamOperator.class);
    final OperatorID operatorID=new OperatorID();
    when(streamOperator.getOperatorID()).thenReturn(operatorID);
    KeyedStateHandle managedKeyedStateHandle=mock(KeyedStateHandle.class);
    KeyedStateHandle rawKeyedStateHandle=mock(KeyedStateHandle.class);
    OperatorStateHandle managedOperatorStateHandle=mock(OperatorStreamStateHandle.class);
    OperatorStateHandle rawOperatorStateHandle=mock(OperatorStreamStateHandle.class);
    OperatorSnapshotFutures operatorSnapshotResult=new OperatorSnapshotFutures(DoneFuture.of(SnapshotResult.of(managedKeyedStateHandle)),DoneFuture.of(SnapshotResult.of(rawKeyedStateHandle)),DoneFuture.of(SnapshotResult.of(managedOperatorStateHandle)),DoneFuture.of(SnapshotResult.of(rawOperatorStateHandle)));
    when(streamOperator.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(operatorSnapshotResult);
    StreamOperator<?>[] streamOperators={streamOperator};
    OperatorChain<Void,AbstractStreamOperator<Void>> operatorChain=mock(OperatorChain.class);
    when(operatorChain.getAllOperators()).thenReturn(streamOperators);
    CheckpointStorage checkpointStorage=new MemoryBackendCheckpointStorage(new JobID(),null,null,Integer.MAX_VALUE);
    ExecutorService executor=Executors.newFixedThreadPool(1);
    Whitebox.setInternalState(streamTask,"isRunning",true);
    Whitebox.setInternalState(streamTask,"lock",new Object());
    Whitebox.setInternalState(streamTask,"operatorChain",operatorChain);
    Whitebox.setInternalState(streamTask,"cancelables",new CloseableRegistry());
    Whitebox.setInternalState(streamTask,"asyncOperationsThreadPool",executor);
    Whitebox.setInternalState(streamTask,"configuration",new StreamConfig(new Configuration()));
    Whitebox.setInternalState(streamTask,"checkpointStorage",checkpointStorage);
    streamTask.triggerCheckpoint(checkpointMetaData,CheckpointOptions.forCheckpointWithDefaultLocation());
    createSubtask.await();
    streamTask.cancel();
    completeSubtask.trigger();
    executor.shutdown();
    if (!executor.awaitTermination(10000L,TimeUnit.MILLISECONDS)) {
      fail("Executor did not shut down within the given timeout. This indicates that the " + "checkpointing did not resume.");
    }
    verify(mockEnvironment,never()).acknowledgeCheckpoint(eq(checkpointId),any(CheckpointMetrics.class),any(TaskStateSnapshot.class));
    verify(managedKeyedStateHandle).discardState();
    verify(rawKeyedStateHandle).discardState();
    verify(managedOperatorStateHandle).discardState();
    verify(rawOperatorStateHandle).discardState();
  }
  /** 
 * FLINK-5985 <p>This test ensures that empty snapshots (no op/keyed stated whatsoever) will be reported as stateless tasks. This happens by translating an empty  {@link SubtaskState} into reporting 'null' to #acknowledgeCheckpoint.
 */
  @Test public void testEmptySubtaskStateLeadsToStatelessAcknowledgment() throws Exception {
    final long checkpointId=42L;
    final long timestamp=1L;
    Environment mockEnvironment=spy(new MockEnvironmentBuilder().build());
    final OneShotLatch checkpointCompletedLatch=new OneShotLatch();
    final List<SubtaskState> checkpointResult=new ArrayList<>(1);
    CheckpointResponder checkpointResponder=mock(CheckpointResponder.class);
    doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocation) throws Throwable {
        SubtaskState subtaskState=invocation.getArgumentAt(4,SubtaskState.class);
        checkpointResult.add(subtaskState);
        checkpointCompletedLatch.trigger();
        return null;
      }
    }
).when(checkpointResponder).acknowledgeCheckpoint(any(JobID.class),any(ExecutionAttemptID.class),anyLong(),any(CheckpointMetrics.class),any(TaskStateSnapshot.class));
    TaskStateManager taskStateManager=new TaskStateManagerImpl(new JobID(1L,2L),new ExecutionAttemptID(1L,2L),mock(TaskLocalStateStoreImpl.class),null,checkpointResponder);
    when(mockEnvironment.getTaskStateManager()).thenReturn(taskStateManager);
    StreamTask<?,?> streamTask=new EmptyStreamTask(mockEnvironment);
    CheckpointMetaData checkpointMetaData=new CheckpointMetaData(checkpointId,timestamp);
    StreamOperator<?> statelessOperator=mock(StreamOperator.class);
    final OperatorID operatorID=new OperatorID();
    when(statelessOperator.getOperatorID()).thenReturn(operatorID);
    OperatorSnapshotFutures statelessOperatorSnapshotResult=new OperatorSnapshotFutures();
    when(statelessOperator.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenReturn(statelessOperatorSnapshotResult);
    StreamOperator<?>[] streamOperators={statelessOperator};
    OperatorChain<Void,AbstractStreamOperator<Void>> operatorChain=mock(OperatorChain.class);
    when(operatorChain.getAllOperators()).thenReturn(streamOperators);
    Whitebox.setInternalState(streamTask,"isRunning",true);
    Whitebox.setInternalState(streamTask,"lock",new Object());
    Whitebox.setInternalState(streamTask,"operatorChain",operatorChain);
    Whitebox.setInternalState(streamTask,"cancelables",new CloseableRegistry());
    Whitebox.setInternalState(streamTask,"configuration",new StreamConfig(new Configuration()));
    Whitebox.setInternalState(streamTask,"asyncOperationsThreadPool",Executors.newCachedThreadPool());
    Whitebox.setInternalState(streamTask,"checkpointStorage",new MemoryBackendCheckpointStorage(new JobID(),null,null,Integer.MAX_VALUE));
    streamTask.triggerCheckpoint(checkpointMetaData,CheckpointOptions.forCheckpointWithDefaultLocation());
    checkpointCompletedLatch.await(30,TimeUnit.SECONDS);
    streamTask.cancel();
    Assert.assertNull(checkpointResult.get(0));
  }
  /** 
 * Tests that the StreamTask first closes all of its operators before setting its state to not running (isRunning == false) <p>See FLINK-7430.
 */
  @Test public void testOperatorClosingBeforeStopRunning() throws Throwable {
    Configuration taskConfiguration=new Configuration();
    StreamConfig streamConfig=new StreamConfig(taskConfiguration);
    streamConfig.setStreamOperator(new BlockingCloseStreamOperator());
    streamConfig.setOperatorID(new OperatorID());
    try (MockEnvironment mockEnvironment=new MockEnvironmentBuilder().setTaskName("Test Task").setMemorySize(32L * 1024L).setInputSplitProvider(new MockInputSplitProvider()).setBufferSize(1).setTaskConfiguration(taskConfiguration).build()){
      StreamTask<Void,BlockingCloseStreamOperator> streamTask=new NoOpStreamTask<>(mockEnvironment);
      final AtomicReference<Throwable> atomicThrowable=new AtomicReference<>(null);
      CompletableFuture<Void> invokeFuture=CompletableFuture.runAsync(() -> {
        try {
          streamTask.invoke();
        }
 catch (        Exception e) {
          atomicThrowable.set(e);
        }
      }
,TestingUtils.defaultExecutor());
      BlockingCloseStreamOperator.IN_CLOSE.await();
      assertTrue(streamTask.isRunning());
      BlockingCloseStreamOperator.FINISH_CLOSE.trigger();
      invokeFuture.get();
      assertFalse(streamTask.isRunning());
      if (atomicThrowable.get() != null) {
        throw atomicThrowable.get();
      }
    }
   }
  /** 
 * Test set user code ClassLoader before calling ProcessingTimeCallback.
 */
  @Test public void testSetsUserCodeClassLoaderForTimerThreadFactory() throws Throwable {
    syncLatch=new OneShotLatch();
    try (MockEnvironment mockEnvironment=new MockEnvironmentBuilder().setUserCodeClassLoader(new TestUserCodeClassLoader()).build()){
      TimeServiceTask timerServiceTask=new TimeServiceTask(mockEnvironment);
      CompletableFuture<Void> invokeFuture=CompletableFuture.runAsync(() -> {
        try {
          timerServiceTask.invoke();
        }
 catch (        Exception e) {
          throw new CompletionException(e);
        }
      }
,TestingUtils.defaultExecutor());
      invokeFuture.get();
      assertThat(timerServiceTask.getClassLoaders(),hasSize(greaterThanOrEqualTo(1)));
      assertThat(timerServiceTask.getClassLoaders(),everyItem(instanceOf(TestUserCodeClassLoader.class)));
    }
   }
  /** 
 * Operator that does nothing.
 * @param < T >
 * @param < OP >
 */
public static class NoOpStreamTask<T,OP extends StreamOperator<T>> extends StreamTask<T,OP> {
    public NoOpStreamTask(    Environment environment){
      super(environment,null);
    }
    @Override protected void init() throws Exception {
    }
    @Override protected void run() throws Exception {
    }
    @Override protected void cleanup() throws Exception {
    }
    @Override protected void cancelTask() throws Exception {
    }
  }
private static class BlockingCloseStreamOperator extends AbstractStreamOperator<Void> {
    private static final long serialVersionUID=-9042150529568008847L;
    public static final OneShotLatch IN_CLOSE=new OneShotLatch();
    public static final OneShotLatch FINISH_CLOSE=new OneShotLatch();
    @Override public void close() throws Exception {
      IN_CLOSE.trigger();
      FINISH_CLOSE.await();
      super.close();
    }
  }
private static class TestingExecutionStateListener implements TaskExecutionStateListener {
    private ExecutionState executionState=null;
    private final PriorityQueue<Tuple2<ExecutionState,CompletableFuture<ExecutionState>>> priorityQueue=new PriorityQueue<>(1,Comparator.comparingInt(o -> o.f0.ordinal()));
    Future<ExecutionState> notifyWhenExecutionState(    ExecutionState executionState){
synchronized (priorityQueue) {
        if (this.executionState != null && this.executionState.ordinal() >= executionState.ordinal()) {
          return CompletableFuture.completedFuture(executionState);
        }
 else {
          CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
          priorityQueue.offer(Tuple2.of(executionState,promise));
          return promise;
        }
      }
    }
    @Override public void notifyTaskExecutionStateChanged(    TaskExecutionState taskExecutionState){
synchronized (priorityQueue) {
        this.executionState=taskExecutionState.getExecutionState();
        while (!priorityQueue.isEmpty() && priorityQueue.peek().f0.ordinal() <= executionState.ordinal()) {
          CompletableFuture<ExecutionState> promise=priorityQueue.poll().f1;
          promise.complete(executionState);
        }
      }
    }
  }
  public static Task createTask(  Class<? extends AbstractInvokable> invokable,  StreamConfig taskConfig,  Configuration taskManagerConfig) throws Exception {
    return createTask(invokable,taskConfig,taskManagerConfig,new TestTaskStateManager());
  }
  public static Task createTask(  Class<? extends AbstractInvokable> invokable,  StreamConfig taskConfig,  Configuration taskManagerConfig,  TestTaskStateManager taskStateManager) throws Exception {
    BlobCacheService blobService=new BlobCacheService(mock(PermanentBlobCache.class),mock(TransientBlobCache.class));
    LibraryCacheManager libCache=mock(LibraryCacheManager.class);
    when(libCache.getClassLoader(any(JobID.class))).thenReturn(StreamTaskTest.class.getClassLoader());
    ResultPartitionManager partitionManager=mock(ResultPartitionManager.class);
    ResultPartitionConsumableNotifier consumableNotifier=new NoOpResultPartitionConsumableNotifier();
    PartitionProducerStateChecker partitionProducerStateChecker=mock(PartitionProducerStateChecker.class);
    Executor executor=mock(Executor.class);
    TaskEventDispatcher taskEventDispatcher=new TaskEventDispatcher();
    NetworkEnvironment network=mock(NetworkEnvironment.class);
    when(network.getResultPartitionManager()).thenReturn(partitionManager);
    when(network.getDefaultIOMode()).thenReturn(IOManager.IOMode.SYNC);
    when(network.createKvStateTaskRegistry(any(JobID.class),any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class));
    when(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
    JobInformation jobInformation=new JobInformation(new JobID(),"Job Name",new SerializedValue<>(new ExecutionConfig()),new Configuration(),Collections.emptyList(),Collections.emptyList());
    TaskInformation taskInformation=new TaskInformation(new JobVertexID(),"Test Task",1,1,invokable.getName(),taskConfig.getConfiguration());
    return new Task(jobInformation,taskInformation,new ExecutionAttemptID(),new AllocationID(),0,0,Collections.<ResultPartitionDeploymentDescriptor>emptyList(),Collections.<InputGateDeploymentDescriptor>emptyList(),0,mock(MemoryManager.class),mock(IOManager.class),network,mock(BroadcastVariableManager.class),taskStateManager,mock(TaskManagerActions.class),mock(InputSplitProvider.class),mock(CheckpointResponder.class),blobService,libCache,mock(FileCache.class),new TestingTaskManagerRuntimeInfo(taskManagerConfig,new String[]{System.getProperty("java.io.tmpdir")}),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),consumableNotifier,partitionProducerStateChecker,executor);
  }
private static class SlowlyDeserializingOperator extends StreamSource<Long,SourceFunction<Long>> {
    private static final long serialVersionUID=1L;
    private volatile boolean canceled=false;
    public SlowlyDeserializingOperator(){
      super(new MockSourceFunction());
    }
    @Override public void run(    Object lockingObject,    StreamStatusMaintainer streamStatusMaintainer,    Output<StreamRecord<Long>> collector) throws Exception {
      while (!canceled) {
        try {
          Thread.sleep(500);
        }
 catch (        InterruptedException ignored) {
        }
      }
    }
    @Override public void cancel(){
      canceled=true;
    }
    private void readObject(    ObjectInputStream in) throws IOException, ClassNotFoundException {
      in.defaultReadObject();
      long delay=500;
      long deadline=System.currentTimeMillis() + delay;
      do {
        try {
          Thread.sleep(delay);
        }
 catch (        InterruptedException ignored) {
        }
      }
 while ((delay=deadline - System.currentTimeMillis()) > 0);
    }
  }
private static class MockSourceFunction implements SourceFunction<Long> {
    private static final long serialVersionUID=1L;
    @Override public void run(    SourceContext<Long> ctx){
    }
    @Override public void cancel(){
    }
  }
  /** 
 * Mocked state backend factory which returns mocks for the operator and keyed state backends.
 */
public static final class TestMemoryStateBackendFactory implements StateBackendFactory<AbstractStateBackend> {
    private static final long serialVersionUID=1L;
    @Override public AbstractStateBackend createFromConfig(    Configuration config){
      return new TestSpyWrapperStateBackend(createInnerBackend(config));
    }
    protected AbstractStateBackend createInnerBackend(    Configuration config){
      return new MemoryStateBackend();
    }
  }
private static class EmptyStreamTask extends StreamTask<String,AbstractStreamOperator<String>> {
    public EmptyStreamTask(    Environment env){
      super(env,null);
    }
    @Override protected void init() throws Exception {
    }
    @Override protected void run() throws Exception {
    }
    @Override protected void cleanup() throws Exception {
    }
    @Override protected void cancelTask() throws Exception {
    }
  }
  /** 
 * Source that instantiates the operator state backend and the keyed state backend. The created state backends can be retrieved from the static fields to check if the CloseableRegistry closed them correctly.
 */
public static class StateBackendTestSource extends StreamTask<Long,StreamSource<Long,SourceFunction<Long>>> {
    private static volatile boolean fail;
    public StateBackendTestSource(    Environment env){
      super(env);
    }
    @Override protected void init() throws Exception {
    }
    @Override protected void run() throws Exception {
      if (fail) {
        throw new RuntimeException();
      }
    }
    @Override protected void cleanup() throws Exception {
    }
    @Override protected void cancelTask() throws Exception {
    }
    @Override public StreamTaskStateInitializer createStreamTaskStateInitializer(){
      final StreamTaskStateInitializer streamTaskStateManager=super.createStreamTaskStateInitializer();
      return (operatorID,operatorClassName,keyContext,keySerializer,closeableRegistry) -> {
        final StreamOperatorStateContext context=streamTaskStateManager.streamOperatorStateContext(operatorID,operatorClassName,keyContext,keySerializer,closeableRegistry);
        return new StreamOperatorStateContext(){
          @Override public boolean isRestored(){
            return context.isRestored();
          }
          @Override public OperatorStateBackend operatorStateBackend(){
            return context.operatorStateBackend();
          }
          @Override public AbstractKeyedStateBackend<?> keyedStateBackend(){
            return context.keyedStateBackend();
          }
          @Override public InternalTimeServiceManager<?> internalTimerServiceManager(){
            InternalTimeServiceManager<?> timeServiceManager=context.internalTimerServiceManager();
            return timeServiceManager != null ? spy(timeServiceManager) : null;
          }
          @Override public CloseableIterable<StatePartitionStreamProvider> rawOperatorStateInputs(){
            return replaceWithSpy(context.rawOperatorStateInputs());
          }
          @Override public CloseableIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStateInputs(){
            return replaceWithSpy(context.rawKeyedStateInputs());
          }
          public <T extends Closeable>T replaceWithSpy(          T closeable){
            T spyCloseable=spy(closeable);
            if (closeableRegistry.unregisterCloseable(closeable)) {
              try {
                closeableRegistry.registerCloseable(spyCloseable);
              }
 catch (              IOException e) {
                throw new RuntimeException(e);
              }
            }
            return spyCloseable;
          }
        }
;
      }
;
    }
  }
  /** 
 * A task that locks if cancellation attempts to cleanly shut down.
 */
public static class CancelLockingTask extends StreamTask<String,AbstractStreamOperator<String>> {
    private final OneShotLatch latch=new OneShotLatch();
    private LockHolder holder;
    public CancelLockingTask(    Environment env){
      super(env);
    }
    @Override protected void init(){
    }
    @Override protected void run() throws Exception {
      holder=new LockHolder(getCheckpointLock(),latch);
      holder.start();
      latch.await();
      syncLatch.trigger();
      try {
        Thread.sleep(100000000);
      }
 catch (      InterruptedException ignored) {
        Thread.currentThread().interrupt();
      }
    }
    @Override protected void cleanup(){
      holder.close();
    }
    @Override protected void cancelTask(){
      holder.cancel();
    }
  }
  /** 
 * A task that locks if cancellation attempts to cleanly shut down.
 */
public static class CancelFailingTask extends StreamTask<String,AbstractStreamOperator<String>> {
    public CancelFailingTask(    Environment env){
      super(env);
    }
    @Override protected void init(){
    }
    @Override protected void run() throws Exception {
      final OneShotLatch latch=new OneShotLatch();
      final Object lock=new Object();
      LockHolder holder=new LockHolder(lock,latch);
      holder.start();
      try {
        getCancelables().registerCloseable(holder);
        latch.await();
        syncLatch.trigger();
synchronized (lock) {
        }
      }
  finally {
        holder.close();
      }
    }
    @Override protected void cleanup(){
    }
    @Override protected void cancelTask() throws Exception {
      throw new Exception("test exception");
    }
  }
  /** 
 * A task that register a processing time service callback.
 */
public static class TimeServiceTask extends StreamTask<String,AbstractStreamOperator<String>> {
    private final List<ClassLoader> classLoaders=Collections.synchronizedList(new ArrayList<>());
    public TimeServiceTask(    Environment env){
      super(env,null);
    }
    public List<ClassLoader> getClassLoaders(){
      return classLoaders;
    }
    @Override protected void init() throws Exception {
      getProcessingTimeService().registerTimer(0,new ProcessingTimeCallback(){
        @Override public void onProcessingTime(        long timestamp) throws Exception {
          classLoaders.add(Thread.currentThread().getContextClassLoader());
          syncLatch.trigger();
        }
      }
);
    }
    @Override protected void run() throws Exception {
      syncLatch.await();
    }
    @Override protected void cleanup() throws Exception {
    }
    @Override protected void cancelTask() throws Exception {
    }
  }
  /** 
 * A  {@link ClassLoader} that delegates everything to {@link ClassLoader#getSystemClassLoader()}.
 */
private static class TestUserCodeClassLoader extends ClassLoader {
    public TestUserCodeClassLoader(){
      super(ClassLoader.getSystemClassLoader());
    }
  }
  /** 
 * A thread that holds a lock as long as it lives.
 */
private static final class LockHolder extends Thread implements Closeable {
    private final OneShotLatch trigger;
    private final Object lock;
    private volatile boolean canceled;
    private LockHolder(    Object lock,    OneShotLatch trigger){
      this.lock=lock;
      this.trigger=trigger;
    }
    @Override public void run(){
synchronized (lock) {
        while (!canceled) {
          trigger.trigger();
          try {
            Thread.sleep(1000000000);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
    public void cancel(){
      canceled=true;
    }
    @Override public void close(){
      canceled=true;
      interrupt();
    }
  }
static class TestStreamSource<OUT,SRC extends SourceFunction<OUT>> extends StreamSource<OUT,SRC> {
    static AbstractKeyedStateBackend<?> keyedStateBackend;
    static OperatorStateBackend operatorStateBackend;
    static CloseableIterable<StatePartitionStreamProvider> rawOperatorStateInputs;
    static CloseableIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStateInputs;
    public TestStreamSource(    SRC sourceFunction){
      super(sourceFunction);
    }
    @Override public void initializeState(    StateInitializationContext context) throws Exception {
      keyedStateBackend=(AbstractKeyedStateBackend<?>)getKeyedStateBackend();
      operatorStateBackend=getOperatorStateBackend();
      rawOperatorStateInputs=(CloseableIterable<StatePartitionStreamProvider>)context.getRawOperatorStateInputs();
      rawKeyedStateInputs=(CloseableIterable<KeyGroupStatePartitionStreamProvider>)context.getRawKeyedStateInputs();
      super.initializeState(context);
    }
  }
}
