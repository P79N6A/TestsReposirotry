public class ResourceManagerTaskExecutorTest extends TestLogger {
  private final Time timeout=Time.seconds(10L);
  private TestingRpcService rpcService;
  private int dataPort=1234;
  private HardwareDescription hardwareDescription=new HardwareDescription(1,2L,3L,4L);
  private static String taskExecutorAddress="/taskExecutor1";
  private ResourceID taskExecutorResourceID;
  private ResourceID resourceManagerResourceID;
  private StandaloneResourceManager resourceManager;
  private ResourceManagerGateway rmGateway;
  private ResourceManagerGateway wronglyFencedGateway;
  private TestingFatalErrorHandler testingFatalErrorHandler;
  @Before public void setup() throws Exception {
    rpcService=new TestingRpcService();
    taskExecutorResourceID=mockTaskExecutor(taskExecutorAddress);
    resourceManagerResourceID=ResourceID.generate();
    testingFatalErrorHandler=new TestingFatalErrorHandler();
    TestingLeaderElectionService rmLeaderElectionService=new TestingLeaderElectionService();
    resourceManager=createAndStartResourceManager(rmLeaderElectionService,testingFatalErrorHandler);
    rmGateway=resourceManager.getSelfGateway(ResourceManagerGateway.class);
    wronglyFencedGateway=rpcService.connect(resourceManager.getAddress(),ResourceManagerId.generate(),ResourceManagerGateway.class).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    grantLeadership(rmLeaderElectionService).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
  }
  @After public void teardown() throws Exception {
    RpcUtils.terminateRpcService(rpcService,timeout);
  }
  /** 
 * Test receive normal registration from task executor and receive duplicate registration from task executor.
 */
  @Test public void testRegisterTaskExecutor() throws Exception {
    try {
      CompletableFuture<RegistrationResponse> successfulFuture=rmGateway.registerTaskExecutor(taskExecutorAddress,taskExecutorResourceID,dataPort,hardwareDescription,timeout);
      RegistrationResponse response=successfulFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
      assertTrue(response instanceof TaskExecutorRegistrationSuccess);
      final TaskManagerInfo taskManagerInfo=rmGateway.requestTaskManagerInfo(taskExecutorResourceID,timeout).get();
      assertThat(taskManagerInfo.getResourceId(),equalTo(taskExecutorResourceID));
      CompletableFuture<RegistrationResponse> duplicateFuture=rmGateway.registerTaskExecutor(taskExecutorAddress,taskExecutorResourceID,dataPort,hardwareDescription,timeout);
      RegistrationResponse duplicateResponse=duplicateFuture.get();
      assertTrue(duplicateResponse instanceof TaskExecutorRegistrationSuccess);
      assertNotEquals(((TaskExecutorRegistrationSuccess)response).getRegistrationId(),((TaskExecutorRegistrationSuccess)duplicateResponse).getRegistrationId());
    }
  finally {
      if (testingFatalErrorHandler.hasExceptionOccurred()) {
        testingFatalErrorHandler.rethrowError();
      }
    }
  }
  /** 
 * Test receive registration with unmatched leadershipId from task executor
 */
  @Test public void testRegisterTaskExecutorWithUnmatchedLeaderSessionId() throws Exception {
    try {
      CompletableFuture<RegistrationResponse> unMatchedLeaderFuture=wronglyFencedGateway.registerTaskExecutor(taskExecutorAddress,taskExecutorResourceID,dataPort,hardwareDescription,timeout);
      try {
        unMatchedLeaderFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
        fail("Should have failed because we are using a wrongly fenced ResourceManagerGateway.");
      }
 catch (      ExecutionException e) {
        assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException);
      }
    }
  finally {
      if (testingFatalErrorHandler.hasExceptionOccurred()) {
        testingFatalErrorHandler.rethrowError();
      }
    }
  }
  /** 
 * Test receive registration with invalid address from task executor
 */
  @Test public void testRegisterTaskExecutorFromInvalidAddress() throws Exception {
    try {
      String invalidAddress="/taskExecutor2";
      CompletableFuture<RegistrationResponse> invalidAddressFuture=rmGateway.registerTaskExecutor(invalidAddress,taskExecutorResourceID,dataPort,hardwareDescription,timeout);
      assertTrue(invalidAddressFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS) instanceof RegistrationResponse.Decline);
    }
  finally {
      if (testingFatalErrorHandler.hasExceptionOccurred()) {
        testingFatalErrorHandler.rethrowError();
      }
    }
  }
  private ResourceID mockTaskExecutor(  String taskExecutorAddress){
    TaskExecutorGateway taskExecutorGateway=mock(TaskExecutorGateway.class);
    when(taskExecutorGateway.getAddress()).thenReturn(taskExecutorAddress);
    ResourceID taskExecutorResourceID=ResourceID.generate();
    rpcService.registerGateway(taskExecutorAddress,taskExecutorGateway);
    return taskExecutorResourceID;
  }
  private StandaloneResourceManager createAndStartResourceManager(  LeaderElectionService rmLeaderElectionService,  FatalErrorHandler fatalErrorHandler) throws Exception {
    TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    HeartbeatServices heartbeatServices=new HeartbeatServices(1000L,1000L);
    highAvailabilityServices.setResourceManagerLeaderElectionService(rmLeaderElectionService);
    ResourceManagerConfiguration resourceManagerConfiguration=new ResourceManagerConfiguration(Time.seconds(5L),Time.seconds(5L));
    SlotManager slotManager=new SlotManager(rpcService.getScheduledExecutor(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime());
    MetricRegistryImpl metricRegistry=mock(MetricRegistryImpl.class);
    JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,rpcService.getScheduledExecutor(),Time.minutes(5L));
    StandaloneResourceManager resourceManager=new StandaloneResourceManager(rpcService,FlinkResourceManager.RESOURCE_MANAGER_NAME,resourceManagerResourceID,resourceManagerConfiguration,highAvailabilityServices,heartbeatServices,slotManager,metricRegistry,jobLeaderIdService,new ClusterInformation("localhost",1234),fatalErrorHandler,UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup());
    resourceManager.start();
    return resourceManager;
  }
  private CompletableFuture<UUID> grantLeadership(  TestingLeaderElectionService leaderElectionService){
    UUID leaderSessionId=UUID.randomUUID();
    return leaderElectionService.isLeader(leaderSessionId);
  }
}
