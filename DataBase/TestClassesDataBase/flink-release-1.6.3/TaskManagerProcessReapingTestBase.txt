/** 
 * Tests that the TaskManager process properly exits when the TaskManager actor dies.
 */
public abstract class TaskManagerProcessReapingTestBase extends TestLogger {
  /** 
 * Called after the task manager has been started up. After calling this method, the test base checks that the process exits.
 */
  abstract void onTaskManagerProcessRunning(  ActorRef taskManager);
  /** 
 * Called after the task manager has successfully terminated.
 */
  void onTaskManagerProcessTerminated(  String processOutput){
  }
  @Test public void testReapProcessOnFailure() throws Exception {
    Process taskManagerProcess=null;
    ActorSystem jmActorSystem=null;
    final StringWriter processOutput=new StringWriter();
    final Configuration config=new Configuration();
    final String jobManagerHostname="localhost";
    final int jobManagerPort=NetUtils.getAvailablePort();
    config.setString(JobManagerOptions.ADDRESS,jobManagerHostname);
    config.setInteger(JobManagerOptions.PORT,jobManagerPort);
    final HighAvailabilityServices highAvailabilityServices=HighAvailabilityServicesUtils.createHighAvailabilityServices(config,TestingUtils.defaultExecutor(),HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION);
    try {
      String javaCommand=getJavaCommandPath();
      if (javaCommand == null) {
        System.out.println("---- Skipping TaskManagerProcessReapingTest : Could not find java executable ----");
        return;
      }
      File tempLogFile=File.createTempFile("testlogconfig","properties");
      tempLogFile.deleteOnExit();
      CommonTestUtils.printLog4jDebugConfig(tempLogFile);
      Tuple2<String,Object> localAddress=new Tuple2<String,Object>(jobManagerHostname,jobManagerPort);
      jmActorSystem=AkkaUtils.createActorSystem(config,new Some<>(localAddress));
      ActorRef jmActor=JobManager.startJobManagerActors(config,jmActorSystem,TestingUtils.defaultExecutor(),TestingUtils.defaultExecutor(),highAvailabilityServices,NoOpMetricRegistry.INSTANCE,Option.empty(),JobManager.class,MemoryArchivist.class)._1;
      FlinkResourceManager.startResourceManagerActors(new Configuration(),jmActorSystem,highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID),StandaloneResourceManager.class);
      final int taskManagerPort=NetUtils.getAvailablePort();
      String[] command=new String[]{javaCommand,"-Dlog.level=DEBUG","-Dlog4j.configuration=file:" + tempLogFile.getAbsolutePath(),"-Xms256m","-Xmx256m","-classpath",getCurrentClasspath(),TaskManagerTestEntryPoint.class.getName(),String.valueOf(jobManagerPort),String.valueOf(taskManagerPort)};
      ProcessBuilder bld=new ProcessBuilder(command);
      taskManagerProcess=bld.start();
      new PipeForwarder(taskManagerProcess.getErrorStream(),processOutput);
      String taskManagerActorName=String.format("akka.tcp://flink@%s/user/%s","localhost:" + taskManagerPort,TaskExecutor.TASK_MANAGER_NAME);
      ActorRef taskManagerRef=null;
      Throwable lastError=null;
      for (int i=0; i < 40; i++) {
        try {
          taskManagerRef=TaskManager.getTaskManagerRemoteReference(taskManagerActorName,jmActorSystem,new FiniteDuration(25,TimeUnit.SECONDS));
          break;
        }
 catch (        Throwable t) {
          lastError=t;
        }
        Thread.sleep(500);
      }
      assertTrue("TaskManager process died",isProcessAlive(taskManagerProcess));
      if (taskManagerRef == null) {
        if (lastError != null) {
          lastError.printStackTrace();
        }
        fail("TaskManager process did not launch the TaskManager properly. Failed to look up " + taskManagerActorName);
      }
      onTaskManagerProcessRunning(taskManagerRef);
{
        long now=System.currentTimeMillis();
        long deadline=now + 10000;
        while (now < deadline && isProcessAlive(taskManagerProcess)) {
          Thread.sleep(100);
          now=System.currentTimeMillis();
        }
      }
      assertFalse("TaskManager process did not terminate upon actor death",isProcessAlive(taskManagerProcess));
      int returnCode=taskManagerProcess.exitValue();
      assertEquals("TaskManager died, but not because of the process reaper",TaskManager.RUNTIME_FAILURE_RETURN_CODE(),returnCode);
      onTaskManagerProcessTerminated(processOutput.toString());
    }
 catch (    Exception e) {
      e.printStackTrace();
      printProcessLog(processOutput.toString());
      fail(e.getMessage());
    }
catch (    Error e) {
      e.printStackTrace();
      printProcessLog(processOutput.toString());
      throw e;
    }
 finally {
      if (taskManagerProcess != null) {
        taskManagerProcess.destroy();
      }
      if (jmActorSystem != null) {
        jmActorSystem.shutdown();
      }
      if (highAvailabilityServices != null) {
        highAvailabilityServices.closeAndCleanupAllData();
      }
    }
  }
  private static void printProcessLog(  String log){
    System.out.println("-----------------------------------------");
    System.out.println("       BEGIN SPAWNED PROCESS LOG");
    System.out.println("-----------------------------------------");
    System.out.println(log);
    System.out.println("-----------------------------------------");
    System.out.println("        END SPAWNED PROCESS LOG");
    System.out.println("-----------------------------------------");
  }
public static class TaskManagerTestEntryPoint {
    public static void main(    String[] args) throws Exception {
      int jobManagerPort=Integer.parseInt(args[0]);
      int taskManagerPort=Integer.parseInt(args[1]);
      Configuration cfg=new Configuration();
      cfg.setString(JobManagerOptions.ADDRESS,"localhost");
      cfg.setInteger(JobManagerOptions.PORT,jobManagerPort);
      cfg.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE,"4m");
      cfg.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS,256);
      final HighAvailabilityServices highAvailabilityServices=HighAvailabilityServicesUtils.createHighAvailabilityServices(cfg,TestingUtils.defaultExecutor(),HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION);
      try {
        TaskManager.runTaskManager("localhost",ResourceID.generate(),taskManagerPort,cfg,highAvailabilityServices);
        Object lock=new Object();
synchronized (lock) {
          lock.wait();
        }
      }
 catch (      Throwable t) {
        System.exit(1);
      }
 finally {
        highAvailabilityServices.closeAndCleanupAllData();
      }
    }
  }
private static class PipeForwarder extends Thread {
    private final StringWriter target;
    private final InputStream source;
    public PipeForwarder(    InputStream source,    StringWriter target){
      super("Pipe Forwarder");
      setDaemon(true);
      this.source=source;
      this.target=target;
      start();
    }
    @Override public void run(){
      try {
        int next;
        while ((next=source.read()) != -1) {
          target.write(next);
        }
      }
 catch (      IOException e) {
      }
    }
  }
}
