/** 
 * Tests that check how the TaskManager behaves when encountering startup problems.
 */
public class TaskManagerStartupTest extends TestLogger {
  @Rule public TemporaryFolder tempFolder=new TemporaryFolder();
  private HighAvailabilityServices highAvailabilityServices;
  @Before public void setupTest(){
    highAvailabilityServices=new EmbeddedHaServices(TestingUtils.defaultExecutor());
  }
  @After public void tearDownTest() throws Exception {
    if (highAvailabilityServices != null) {
      highAvailabilityServices.closeAndCleanupAllData();
      highAvailabilityServices=null;
    }
  }
  /** 
 * Tests that the TaskManager fails synchronously when the actor system port is in use.
 * @throws Throwable
 */
  @Test(expected=BindException.class) public void testStartupWhenTaskmanagerActorPortIsUsed() throws Exception {
    ServerSocket blocker=null;
    try {
      final String localHostName="localhost";
      final InetAddress localBindAddress=InetAddress.getByName(NetUtils.getWildcardIPAddress());
      blocker=new ServerSocket(0,50,localBindAddress);
      final int port=blocker.getLocalPort();
      TaskManager.runTaskManager(localHostName,ResourceID.generate(),port,new Configuration(),highAvailabilityServices,TaskManager.class);
      fail("This should fail with an IOException");
    }
 catch (    Exception e) {
      List<Throwable> causes=StartupUtils.getExceptionCauses(e,new ArrayList<Throwable>());
      for (      Throwable cause : causes) {
        if (cause instanceof BindException) {
          throw (BindException)cause;
        }
      }
      fail("This should fail with an exception caused by BindException");
    }
 finally {
      if (blocker != null) {
        try {
          blocker.close();
        }
 catch (        IOException e) {
        }
      }
      highAvailabilityServices.closeAndCleanupAllData();
    }
  }
  /** 
 * Tests that the TaskManager startup fails synchronously when the I/O directories are not writable.
 */
  @Test public void testIODirectoryNotWritable() throws Exception {
    File nonWritable=tempFolder.newFolder();
    Assume.assumeTrue("Cannot create non-writable temporary file directory. Skipping test.",nonWritable.setWritable(false,false));
    try {
      Configuration cfg=new Configuration();
      cfg.setString(CoreOptions.TMP_DIRS,nonWritable.getAbsolutePath());
      cfg.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE,"4m");
      cfg.setString(JobManagerOptions.ADDRESS,"localhost");
      cfg.setInteger(JobManagerOptions.PORT,21656);
      try {
        TaskManager.runTaskManager("localhost",ResourceID.generate(),0,cfg,highAvailabilityServices);
        fail("Should fail synchronously with an exception");
      }
 catch (      IOException e) {
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
 finally {
      nonWritable.setWritable(true,false);
      try {
        FileUtils.deleteDirectory(nonWritable);
      }
 catch (      IOException e) {
      }
      highAvailabilityServices.closeAndCleanupAllData();
    }
  }
  /** 
 * Tests that the TaskManager startup fails synchronously when the I/O directories are not writable.
 */
  @Test public void testMemoryConfigWrong(){
    try {
      Configuration cfg=new Configuration();
      cfg.setString(JobManagerOptions.ADDRESS,"localhost");
      cfg.setInteger(JobManagerOptions.PORT,21656);
      cfg.setBoolean(TaskManagerOptions.MANAGED_MEMORY_PRE_ALLOCATE,true);
      cfg.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE,"-42m");
      try {
        TaskManager.runTaskManager("localhost",ResourceID.generate(),0,cfg,highAvailabilityServices);
        fail("Should fail synchronously with an exception");
      }
 catch (      IllegalConfigurationException e) {
      }
      final long memSize=(((long)Integer.MAX_VALUE - 1) * MemorySize.parse(TaskManagerOptions.MEMORY_SEGMENT_SIZE.defaultValue()).getBytes()) >> 20;
      cfg.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE,memSize + "m");
      try {
        TaskManager.runTaskManager("localhost",ResourceID.generate(),0,cfg,highAvailabilityServices);
        fail("Should fail synchronously with an exception");
      }
 catch (      Exception e) {
        assertTrue(e.getCause() instanceof OutOfMemoryError);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  /** 
 * Tests that the task manager start-up fails if the network stack cannot be initialized.
 * @throws Exception
 */
  @Test(expected=IOException.class) public void testStartupWhenNetworkStackFailsToInitialize() throws Exception {
    ServerSocket blocker=null;
    try {
      blocker=new ServerSocket(0,50,InetAddress.getByName("localhost"));
      final Configuration cfg=new Configuration();
      cfg.setString(TaskManagerOptions.HOST,"localhost");
      cfg.setInteger(TaskManagerOptions.DATA_PORT,blocker.getLocalPort());
      cfg.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE,"1m");
      ActorSystem actorSystem=AkkaUtils.createLocalActorSystem(cfg);
      TaskManager.startTaskManagerComponentsAndActor(cfg,ResourceID.generate(),actorSystem,highAvailabilityServices,NoOpMetricRegistry.INSTANCE,"localhost",Option.<String>empty(),false,TaskManager.class);
    }
  finally {
      if (blocker != null) {
        try {
          blocker.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
}
