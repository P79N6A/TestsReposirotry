@Ignore public class PartitionRequestClientFactoryTest {
  private final static int SERVER_PORT=NetUtils.getAvailablePort();
  @Test public void testResourceReleaseAfterInterruptedConnect() throws Exception {
    final CountDownLatch syncOnConnect=new CountDownLatch(1);
    final Tuple2<NettyServer,NettyClient> netty=createNettyServerAndClient(new NettyProtocol(null,null,true){
      @Override public ChannelHandler[] getServerChannelHandlers(){
        return new ChannelHandler[0];
      }
      @Override public ChannelHandler[] getClientChannelHandlers(){
        return new ChannelHandler[]{new CountDownLatchOnConnectHandler(syncOnConnect)};
      }
    }
);
    final NettyServer server=netty.f0;
    final NettyClient client=netty.f1;
    final UncaughtTestExceptionHandler exceptionHandler=new UncaughtTestExceptionHandler();
    try {
      final PartitionRequestClientFactory factory=new PartitionRequestClientFactory(client);
      final Thread connect=new Thread(new Runnable(){
        @Override public void run(){
          ConnectionID serverAddress=null;
          try {
            serverAddress=createServerConnectionID(0);
            factory.createPartitionRequestClient(serverAddress);
          }
 catch (          Throwable t) {
            if (serverAddress != null) {
              factory.closeOpenChannelConnections(serverAddress);
              Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(),t);
            }
 else {
              t.printStackTrace();
              fail("Could not create RemoteAddress for server.");
            }
          }
        }
      }
);
      connect.setUncaughtExceptionHandler(exceptionHandler);
      connect.start();
      syncOnConnect.await();
      connect.interrupt();
      connect.join();
      assertEquals(0,factory.getNumberOfActiveClients());
      assertTrue(exceptionHandler.getErrors().size() > 0);
    }
  finally {
      if (server != null) {
        server.shutdown();
      }
      if (client != null) {
        client.shutdown();
      }
    }
  }
private static class CountDownLatchOnConnectHandler extends ChannelOutboundHandlerAdapter {
    private final CountDownLatch syncOnConnect;
    public CountDownLatchOnConnectHandler(    CountDownLatch syncOnConnect){
      this.syncOnConnect=syncOnConnect;
    }
    @Override public void connect(    ChannelHandlerContext ctx,    SocketAddress remoteAddress,    SocketAddress localAddress,    ChannelPromise promise) throws Exception {
      syncOnConnect.countDown();
    }
  }
private static class UncaughtTestExceptionHandler implements UncaughtExceptionHandler {
    private final List<Throwable> errors=new ArrayList<Throwable>(1);
    @Override public void uncaughtException(    Thread t,    Throwable e){
      errors.add(e);
    }
    private List<Throwable> getErrors(){
      return errors;
    }
  }
  private static Tuple2<NettyServer,NettyClient> createNettyServerAndClient(  NettyProtocol protocol) throws IOException {
    final NettyConfig config=new NettyConfig(InetAddress.getLocalHost(),SERVER_PORT,32 * 1024,1,new Configuration());
    final NettyServer server=new NettyServer(config);
    final NettyClient client=new NettyClient(config);
    boolean success=false;
    try {
      NettyBufferPool bufferPool=new NettyBufferPool(1);
      server.init(protocol,bufferPool);
      client.init(protocol,bufferPool);
      success=true;
    }
  finally {
      if (!success) {
        server.shutdown();
        client.shutdown();
      }
    }
    return new Tuple2<NettyServer,NettyClient>(server,client);
  }
  private static ConnectionID createServerConnectionID(  int connectionIndex) throws UnknownHostException {
    return new ConnectionID(new InetSocketAddress(InetAddress.getLocalHost(),SERVER_PORT),connectionIndex);
  }
}
