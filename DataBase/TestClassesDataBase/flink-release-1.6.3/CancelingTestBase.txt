/** 
 * Base class for testing job cancellation.
 */
public abstract class CancelingTestBase extends TestLogger {
  private static final int MINIMUM_HEAP_SIZE_MB=192;
  protected static final int PARALLELISM=4;
  @ClassRule public static final MiniClusterResource CLUSTER=new MiniClusterResource(new MiniClusterResourceConfiguration.Builder().setConfiguration(getConfiguration()).setNumberTaskManagers(2).setNumberSlotsPerTaskManager(4).build());
  private static void verifyJvmOptions(){
    final long heap=Runtime.getRuntime().maxMemory() >> 20;
    Assert.assertTrue("Insufficient java heap space " + heap + "mb - set JVM option: -Xmx"+ MINIMUM_HEAP_SIZE_MB+ "m",heap > MINIMUM_HEAP_SIZE_MB - 50);
  }
  private static Configuration getConfiguration(){
    verifyJvmOptions();
    Configuration config=new Configuration();
    config.setBoolean(CoreOptions.FILESYTEM_DEFAULT_OVERRIDE,true);
    config.setString(AkkaOptions.ASK_TIMEOUT,TestingUtils.DEFAULT_AKKA_ASK_TIMEOUT());
    config.setString(TaskManagerOptions.MEMORY_SEGMENT_SIZE,"4096");
    config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS,2048);
    return config;
  }
  protected void runAndCancelJob(  Plan plan,  final int msecsTillCanceling,  int maxTimeTillCanceled) throws Exception {
    final JobGraph jobGraph=getJobGraph(plan);
    ClusterClient<?> client=CLUSTER.getClusterClient();
    client.setDetached(true);
    JobSubmissionResult jobSubmissionResult=client.submitJob(jobGraph,CancelingTestBase.class.getClassLoader());
    Deadline submissionDeadLine=new FiniteDuration(2,TimeUnit.MINUTES).fromNow();
    JobStatus jobStatus=client.getJobStatus(jobSubmissionResult.getJobID()).get(submissionDeadLine.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    while (jobStatus != JobStatus.RUNNING && submissionDeadLine.hasTimeLeft()) {
      Thread.sleep(50);
      jobStatus=client.getJobStatus(jobSubmissionResult.getJobID()).get(submissionDeadLine.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    }
    if (jobStatus != JobStatus.RUNNING) {
      Assert.fail("Job not in state RUNNING.");
    }
    Thread.sleep(msecsTillCanceling);
    client.cancel(jobSubmissionResult.getJobID());
    Deadline cancelDeadline=new FiniteDuration(maxTimeTillCanceled,TimeUnit.MILLISECONDS).fromNow();
    JobStatus jobStatusAfterCancel=client.getJobStatus(jobSubmissionResult.getJobID()).get(cancelDeadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    while (jobStatusAfterCancel != JobStatus.CANCELED && cancelDeadline.hasTimeLeft()) {
      Thread.sleep(50);
      jobStatusAfterCancel=client.getJobStatus(jobSubmissionResult.getJobID()).get(cancelDeadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    }
    if (jobStatusAfterCancel != JobStatus.CANCELED) {
      Assert.fail("Failed to cancel job with ID " + jobSubmissionResult.getJobID() + '.');
    }
  }
  private JobGraph getJobGraph(  final Plan plan){
    final Optimizer pc=new Optimizer(new DataStatistics(),getConfiguration());
    final OptimizedPlan op=pc.compile(plan);
    final JobGraphGenerator jgg=new JobGraphGenerator();
    return jgg.compileJobGraph(op);
  }
}
