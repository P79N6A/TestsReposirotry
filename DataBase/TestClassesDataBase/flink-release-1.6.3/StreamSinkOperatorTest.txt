/** 
 * Tests for  {@link StreamSink}.
 */
public class StreamSinkOperatorTest extends TestLogger {
  @Rule public ExpectedException expectedException=ExpectedException.none();
  /** 
 * Verify that we can correctly query watermark, processing time and the timestamp from the context.
 */
  @Test public void testTimeQuerying() throws Exception {
    BufferingQueryingSink<String> bufferingSink=new BufferingQueryingSink<>();
    StreamSink<String> operator=new StreamSink<>(bufferingSink);
    OneInputStreamOperatorTestHarness<String,Object> testHarness=new OneInputStreamOperatorTestHarness<>(operator);
    testHarness.setup();
    testHarness.open();
    testHarness.processWatermark(new Watermark(17));
    testHarness.setProcessingTime(12);
    testHarness.processElement(new StreamRecord<>("Hello",12L));
    testHarness.processWatermark(new Watermark(42));
    testHarness.setProcessingTime(15);
    testHarness.processElement(new StreamRecord<>("Ciao",13L));
    testHarness.processWatermark(new Watermark(42));
    testHarness.setProcessingTime(15);
    testHarness.processElement(new StreamRecord<>("Ciao"));
    assertThat(bufferingSink.data.size(),is(3));
    assertThat(bufferingSink.data,contains(new Tuple4<>(17L,12L,12L,"Hello"),new Tuple4<>(42L,15L,13L,"Ciao"),new Tuple4<>(42L,15L,null,"Ciao")));
    testHarness.close();
  }
private static class BufferingQueryingSink<T> implements SinkFunction<T> {
    private final List<Tuple4<Long,Long,Long,T>> data;
    public BufferingQueryingSink(){
      data=new ArrayList<>();
    }
    @Override public void invoke(    T value,    Context context) throws Exception {
      Long timestamp=context.timestamp();
      if (timestamp != null) {
        data.add(new Tuple4<>(context.currentWatermark(),context.currentProcessingTime(),context.timestamp(),value));
      }
 else {
        data.add(new Tuple4<>(context.currentWatermark(),context.currentProcessingTime(),null,value));
      }
    }
  }
}
