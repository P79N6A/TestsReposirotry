/** 
 * Mock  {@link Environment}.
 */
public class StreamMockEnvironment implements Environment {
  private final TaskInfo taskInfo;
  private final MemoryManager memManager;
  private final IOManager ioManager;
  private final InputSplitProvider inputSplitProvider;
  private final Configuration jobConfiguration;
  private final Configuration taskConfiguration;
  private final List<InputGate> inputs;
  private final List<ResultPartitionWriter> outputs;
  private final JobID jobID;
  private final ExecutionAttemptID executionAttemptID;
  private final BroadcastVariableManager bcVarManager=new BroadcastVariableManager();
  private final AccumulatorRegistry accumulatorRegistry;
  private final TaskKvStateRegistry kvStateRegistry;
  private final int bufferSize;
  private final ExecutionConfig executionConfig;
  private final TaskStateManager taskStateManager;
  private volatile boolean wasFailedExternally=false;
  private TaskEventDispatcher taskEventDispatcher=mock(TaskEventDispatcher.class);
  public StreamMockEnvironment(  Configuration jobConfig,  Configuration taskConfig,  ExecutionConfig executionConfig,  long memorySize,  MockInputSplitProvider inputSplitProvider,  int bufferSize,  TaskStateManager taskStateManager){
    this(new JobID(),new ExecutionAttemptID(0L,0L),jobConfig,taskConfig,executionConfig,memorySize,inputSplitProvider,bufferSize,taskStateManager);
  }
  public StreamMockEnvironment(  JobID jobID,  ExecutionAttemptID executionAttemptID,  Configuration jobConfig,  Configuration taskConfig,  ExecutionConfig executionConfig,  long memorySize,  MockInputSplitProvider inputSplitProvider,  int bufferSize,  TaskStateManager taskStateManager){
    this.jobID=jobID;
    this.executionAttemptID=executionAttemptID;
    int subtaskIndex=0;
    this.taskInfo=new TaskInfo("",1,subtaskIndex,1,0);
    this.jobConfiguration=jobConfig;
    this.taskConfiguration=taskConfig;
    this.inputs=new LinkedList<InputGate>();
    this.outputs=new LinkedList<ResultPartitionWriter>();
    this.memManager=new MemoryManager(memorySize,1);
    this.ioManager=new IOManagerAsync();
    this.taskStateManager=Preconditions.checkNotNull(taskStateManager);
    this.inputSplitProvider=inputSplitProvider;
    this.bufferSize=bufferSize;
    this.executionConfig=executionConfig;
    this.accumulatorRegistry=new AccumulatorRegistry(jobID,getExecutionId());
    KvStateRegistry registry=new KvStateRegistry();
    this.kvStateRegistry=registry.createTaskRegistry(jobID,getJobVertexId());
  }
  public StreamMockEnvironment(  Configuration jobConfig,  Configuration taskConfig,  long memorySize,  MockInputSplitProvider inputSplitProvider,  int bufferSize,  TaskStateManager taskStateManager){
    this(jobConfig,taskConfig,new ExecutionConfig(),memorySize,inputSplitProvider,bufferSize,taskStateManager);
  }
  public void addInputGate(  InputGate gate){
    inputs.add(gate);
  }
  public <T>void addOutput(  final Collection<Object> outputList,  final TypeSerializer<T> serializer){
    try {
      outputs.add(new RecordOrEventCollectingResultPartitionWriter<T>(outputList,new TestPooledBufferProvider(Integer.MAX_VALUE),serializer));
    }
 catch (    Throwable t) {
      t.printStackTrace();
      fail(t.getMessage());
    }
  }
  @Override public Configuration getTaskConfiguration(){
    return this.taskConfiguration;
  }
  @Override public MemoryManager getMemoryManager(){
    return this.memManager;
  }
  @Override public IOManager getIOManager(){
    return this.ioManager;
  }
  @Override public ExecutionConfig getExecutionConfig(){
    return this.executionConfig;
  }
  @Override public JobID getJobID(){
    return this.jobID;
  }
  @Override public Configuration getJobConfiguration(){
    return this.jobConfiguration;
  }
  @Override public InputSplitProvider getInputSplitProvider(){
    return this.inputSplitProvider;
  }
  @Override public TaskInfo getTaskInfo(){
    return this.taskInfo;
  }
  @Override public ClassLoader getUserClassLoader(){
    return getClass().getClassLoader();
  }
  @Override public Map<String,Future<Path>> getDistributedCacheEntries(){
    return Collections.emptyMap();
  }
  @Override public ResultPartitionWriter getWriter(  int index){
    return outputs.get(index);
  }
  @Override public ResultPartitionWriter[] getAllWriters(){
    return outputs.toArray(new ResultPartitionWriter[outputs.size()]);
  }
  @Override public InputGate getInputGate(  int index){
    return inputs.get(index);
  }
  @Override public InputGate[] getAllInputGates(){
    InputGate[] gates=new InputGate[inputs.size()];
    inputs.toArray(gates);
    return gates;
  }
  @Override public TaskEventDispatcher getTaskEventDispatcher(){
    return taskEventDispatcher;
  }
  @Override public JobVertexID getJobVertexId(){
    return new JobVertexID(new byte[16]);
  }
  @Override public ExecutionAttemptID getExecutionId(){
    return executionAttemptID;
  }
  @Override public BroadcastVariableManager getBroadcastVariableManager(){
    return this.bcVarManager;
  }
  @Override public TaskStateManager getTaskStateManager(){
    return taskStateManager;
  }
  @Override public AccumulatorRegistry getAccumulatorRegistry(){
    return accumulatorRegistry;
  }
  @Override public TaskKvStateRegistry getTaskKvStateRegistry(){
    return kvStateRegistry;
  }
  @Override public void acknowledgeCheckpoint(  long checkpointId,  CheckpointMetrics checkpointMetrics){
  }
  @Override public void acknowledgeCheckpoint(  long checkpointId,  CheckpointMetrics checkpointMetrics,  TaskStateSnapshot subtaskState){
    taskStateManager.reportTaskStateSnapshots(new CheckpointMetaData(checkpointId,0L),checkpointMetrics,subtaskState,null);
  }
  @Override public void declineCheckpoint(  long checkpointId,  Throwable cause){
  }
  @Override public void failExternally(  Throwable cause){
    this.wasFailedExternally=true;
  }
  public boolean wasFailedExternally(){
    return wasFailedExternally;
  }
  @Override public TaskManagerRuntimeInfo getTaskManagerInfo(){
    return new TestingTaskManagerRuntimeInfo();
  }
  @Override public TaskMetricGroup getMetricGroup(){
    return UnregisteredMetricGroups.createUnregisteredTaskMetricGroup();
  }
}
