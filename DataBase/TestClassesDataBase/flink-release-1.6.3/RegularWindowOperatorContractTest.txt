/** 
 * These tests verify that  {@link WindowOperator} correctly interacts with the other windowingcomponents:  {@link WindowAssigner}, {@link Trigger}. {@link org.apache.flink.streaming.api.functions.windowing.WindowFunction} and window state.<p>These tests document the implicit contract that exists between the windowing components.
 */
public class RegularWindowOperatorContractTest extends WindowOperatorContractTest {
  @Test public void testReducingWindow() throws Exception {
    WindowAssigner<Integer,TimeWindow> mockAssigner=mockTimeWindowAssigner();
    Trigger<Integer,TimeWindow> mockTrigger=mockTrigger();
    InternalWindowFunction<Integer,Void,Integer,TimeWindow> mockWindowFunction=mockWindowFunction();
    ReducingStateDescriptor<Integer> intReduceSumDescriptor=new ReducingStateDescriptor<>("int-reduce",new ReduceFunction<Integer>(){
      private static final long serialVersionUID=1L;
      @Override public Integer reduce(      Integer a,      Integer b) throws Exception {
        return a + b;
      }
    }
,IntSerializer.INSTANCE);
    final ValueStateDescriptor<String> valueStateDescriptor=new ValueStateDescriptor<>("string-state",StringSerializer.INSTANCE);
    KeyedOneInputStreamOperatorTestHarness<Integer,Integer,Void> testHarness=createWindowOperator(mockAssigner,mockTrigger,0L,intReduceSumDescriptor,mockWindowFunction);
    testHarness.open();
    when(mockAssigner.assignWindows(anyInt(),anyLong(),anyAssignerContext())).thenReturn(Arrays.asList(new TimeWindow(2,4),new TimeWindow(0,2)));
    assertEquals(0,testHarness.getOutput().size());
    assertEquals(0,testHarness.numKeyedStateEntries());
    testHarness.processElement(new StreamRecord<>(1,0L));
    testHarness.processElement(new StreamRecord<>(1,0L));
    doAnswer(new Answer<TriggerResult>(){
      @Override public TriggerResult answer(      InvocationOnMock invocation) throws Exception {
        TimeWindow window=(TimeWindow)invocation.getArguments()[2];
        Trigger.TriggerContext context=(Trigger.TriggerContext)invocation.getArguments()[3];
        context.registerEventTimeTimer(window.getEnd());
        context.getPartitionedState(valueStateDescriptor).update("hello");
        return TriggerResult.FIRE;
      }
    }
).when(mockTrigger).onElement(Matchers.<Integer>anyObject(),anyLong(),anyTimeWindow(),anyTriggerContext());
    testHarness.processElement(new StreamRecord<>(1,0L));
    verify(mockWindowFunction,times(2)).process(eq(1),anyTimeWindow(),anyInternalWindowContext(),anyInt(),WindowOperatorContractTest.<Void>anyCollector());
    verify(mockWindowFunction,times(1)).process(eq(1),eq(new TimeWindow(0,2)),anyInternalWindowContext(),eq(3),WindowOperatorContractTest.<Void>anyCollector());
    verify(mockWindowFunction,times(1)).process(eq(1),eq(new TimeWindow(2,4)),anyInternalWindowContext(),eq(3),WindowOperatorContractTest.<Void>anyCollector());
    verify(mockTrigger,never()).clear(anyTimeWindow(),anyTriggerContext());
    assertEquals(4,testHarness.numKeyedStateEntries());
    assertEquals(4,testHarness.numEventTimeTimers());
  }
  @Test public void testFoldingWindow() throws Exception {
    WindowAssigner<Integer,TimeWindow> mockAssigner=mockTimeWindowAssigner();
    Trigger<Integer,TimeWindow> mockTrigger=mockTrigger();
    InternalWindowFunction<Integer,Void,Integer,TimeWindow> mockWindowFunction=mockWindowFunction();
    FoldingStateDescriptor<Integer,Integer> intFoldSumDescriptor=new FoldingStateDescriptor<>("int-fold",0,new FoldFunction<Integer,Integer>(){
      private static final long serialVersionUID=1L;
      @Override public Integer fold(      Integer accumulator,      Integer value) throws Exception {
        return accumulator + value;
      }
    }
,IntSerializer.INSTANCE);
    final ValueStateDescriptor<String> valueStateDescriptor=new ValueStateDescriptor<>("string-state",StringSerializer.INSTANCE);
    KeyedOneInputStreamOperatorTestHarness<Integer,Integer,Void> testHarness=createWindowOperator(mockAssigner,mockTrigger,0L,intFoldSumDescriptor,mockWindowFunction);
    testHarness.open();
    when(mockAssigner.assignWindows(anyInt(),anyLong(),anyAssignerContext())).thenReturn(Arrays.asList(new TimeWindow(2,4),new TimeWindow(0,2)));
    assertEquals(0,testHarness.getOutput().size());
    assertEquals(0,testHarness.numKeyedStateEntries());
    testHarness.processElement(new StreamRecord<>(1,0L));
    testHarness.processElement(new StreamRecord<>(1,0L));
    doAnswer(new Answer<TriggerResult>(){
      @Override public TriggerResult answer(      InvocationOnMock invocation) throws Exception {
        TimeWindow window=(TimeWindow)invocation.getArguments()[2];
        Trigger.TriggerContext context=(Trigger.TriggerContext)invocation.getArguments()[3];
        context.registerEventTimeTimer(window.getEnd());
        context.getPartitionedState(valueStateDescriptor).update("hello");
        return TriggerResult.FIRE;
      }
    }
).when(mockTrigger).onElement(Matchers.<Integer>anyObject(),anyLong(),anyTimeWindow(),anyTriggerContext());
    testHarness.processElement(new StreamRecord<>(1,0L));
    verify(mockWindowFunction,times(2)).process(eq(1),anyTimeWindow(),anyInternalWindowContext(),anyInt(),WindowOperatorContractTest.<Void>anyCollector());
    verify(mockWindowFunction,times(1)).process(eq(1),eq(new TimeWindow(0,2)),anyInternalWindowContext(),eq(3),WindowOperatorContractTest.<Void>anyCollector());
    verify(mockWindowFunction,times(1)).process(eq(1),eq(new TimeWindow(2,4)),anyInternalWindowContext(),eq(3),WindowOperatorContractTest.<Void>anyCollector());
    verify(mockTrigger,never()).clear(anyTimeWindow(),anyTriggerContext());
    assertEquals(4,testHarness.numKeyedStateEntries());
    assertEquals(4,testHarness.numEventTimeTimers());
  }
  /** 
 * Special method for creating a  {@link WindowOperator} with a custom {@link StateDescriptor}for the window contents state.
 */
  private <W extends Window,ACC,OUT>KeyedOneInputStreamOperatorTestHarness<Integer,Integer,OUT> createWindowOperator(  WindowAssigner<Integer,W> assigner,  Trigger<Integer,W> trigger,  long allowedLatenss,  StateDescriptor<? extends AppendingState<Integer,ACC>,?> stateDescriptor,  InternalWindowFunction<ACC,OUT,Integer,W> windowFunction) throws Exception {
    KeySelector<Integer,Integer> keySelector=new KeySelector<Integer,Integer>(){
      private static final long serialVersionUID=1L;
      @Override public Integer getKey(      Integer value) throws Exception {
        return value;
      }
    }
;
    @SuppressWarnings("unchecked") WindowOperator<Integer,Integer,ACC,OUT,W> operator=new WindowOperator<>(assigner,assigner.getWindowSerializer(new ExecutionConfig()),keySelector,IntSerializer.INSTANCE,stateDescriptor,windowFunction,trigger,allowedLatenss,null);
    return new KeyedOneInputStreamOperatorTestHarness<>(operator,keySelector,BasicTypeInfo.INT_TYPE_INFO);
  }
  @Override protected <W extends Window,OUT>KeyedOneInputStreamOperatorTestHarness<Integer,Integer,OUT> createWindowOperator(  WindowAssigner<Integer,W> assigner,  Trigger<Integer,W> trigger,  long allowedLatenss,  InternalWindowFunction<Iterable<Integer>,OUT,Integer,W> windowFunction,  OutputTag<Integer> lateOutputTag) throws Exception {
    KeySelector<Integer,Integer> keySelector=new KeySelector<Integer,Integer>(){
      private static final long serialVersionUID=1L;
      @Override public Integer getKey(      Integer value) throws Exception {
        return value;
      }
    }
;
    ListStateDescriptor<Integer> intListDescriptor=new ListStateDescriptor<>("int-list",IntSerializer.INSTANCE);
    @SuppressWarnings("unchecked") WindowOperator<Integer,Integer,Iterable<Integer>,OUT,W> operator=new WindowOperator<>(assigner,assigner.getWindowSerializer(new ExecutionConfig()),keySelector,IntSerializer.INSTANCE,intListDescriptor,windowFunction,trigger,allowedLatenss,lateOutputTag);
    return new KeyedOneInputStreamOperatorTestHarness<>(operator,keySelector,BasicTypeInfo.INT_TYPE_INFO);
  }
  @Override protected <W extends Window,OUT>KeyedOneInputStreamOperatorTestHarness<Integer,Integer,OUT> createWindowOperator(  WindowAssigner<Integer,W> assigner,  Trigger<Integer,W> trigger,  long allowedLatenss,  InternalWindowFunction<Iterable<Integer>,OUT,Integer,W> windowFunction) throws Exception {
    return createWindowOperator(assigner,trigger,allowedLatenss,windowFunction,null);
  }
}
