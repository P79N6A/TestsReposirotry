/** 
 * Test checkpoint cancellation barrier.
 */
public class StreamTaskCancellationBarrierTest {
  /** 
 * This test checks that tasks emit a proper cancel checkpoint barrier, if a "trigger checkpoint" message comes before they are ready.
 */
  @Test public void testEmitCancellationBarrierWhenNotReady() throws Exception {
    StreamTaskTestHarness<String> testHarness=new StreamTaskTestHarness<>(InitBlockingTask::new,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    testHarness.invoke();
    StreamTask<String,?> task=testHarness.getTask();
    boolean result=task.triggerCheckpoint(new CheckpointMetaData(41L,System.currentTimeMillis()),CheckpointOptions.forCheckpointWithDefaultLocation());
    assertFalse("task triggered checkpoint though not ready",result);
    Object emitted=testHarness.getOutput().poll();
    assertNotNull("nothing emitted",emitted);
    assertTrue("wrong type emitted",emitted instanceof CancelCheckpointMarker);
    assertEquals("wrong checkpoint id",41L,((CancelCheckpointMarker)emitted).getCheckpointId());
  }
  /** 
 * This test verifies (for onw input tasks) that the Stream tasks react the following way to receiving a checkpoint cancellation barrier: - send a "decline checkpoint" notification out (to the JobManager) - emit a cancellation barrier downstream.
 */
  @Test public void testDeclineCallOnCancelBarrierOneInput() throws Exception {
    OneInputStreamTaskTestHarness<String,String> testHarness=new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new,1,2,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    StreamConfig streamConfig=testHarness.getStreamConfig();
    StreamMap<String,String> mapOperator=new StreamMap<>(new IdentityMap());
    streamConfig.setStreamOperator(mapOperator);
    streamConfig.setOperatorID(new OperatorID());
    StreamMockEnvironment environment=spy(testHarness.createEnvironment());
    testHarness.invoke(environment);
    testHarness.waitForTaskRunning();
    testHarness.processEvent(new CancelCheckpointMarker(2L),0,1);
    testHarness.processEvent(new CancelCheckpointMarker(2L),0,0);
    testHarness.waitForInputProcessing();
    verify(environment,times(1)).declineCheckpoint(eq(2L),any(CheckpointDeclineOnCancellationBarrierException.class));
    Object result=testHarness.getOutput().poll();
    assertNotNull("nothing emitted",result);
    assertTrue("wrong type emitted",result instanceof CancelCheckpointMarker);
    assertEquals("wrong checkpoint id",2L,((CancelCheckpointMarker)result).getCheckpointId());
    testHarness.endInput();
    testHarness.waitForTaskCompletion();
  }
  /** 
 * This test verifies (for two input tasks) that the Stream tasks react the following way to receiving a checkpoint cancellation barrier: - send a "decline checkpoint" notification out (to the JobManager) - emit a cancellation barrier downstream.
 */
  @Test public void testDeclineCallOnCancelBarrierTwoInputs() throws Exception {
    TwoInputStreamTaskTestHarness<String,String,String> testHarness=new TwoInputStreamTaskTestHarness<>(TwoInputStreamTask::new,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    StreamConfig streamConfig=testHarness.getStreamConfig();
    CoStreamMap<String,String,String> op=new CoStreamMap<>(new UnionCoMap());
    streamConfig.setStreamOperator(op);
    streamConfig.setOperatorID(new OperatorID());
    StreamMockEnvironment environment=spy(testHarness.createEnvironment());
    testHarness.invoke(environment);
    testHarness.waitForTaskRunning();
    testHarness.processEvent(new CancelCheckpointMarker(2L),0,0);
    testHarness.processEvent(new CancelCheckpointMarker(2L),1,0);
    testHarness.waitForInputProcessing();
    verify(environment,times(1)).declineCheckpoint(eq(2L),any(CheckpointDeclineOnCancellationBarrierException.class));
    Object result=testHarness.getOutput().poll();
    assertNotNull("nothing emitted",result);
    assertTrue("wrong type emitted",result instanceof CancelCheckpointMarker);
    assertEquals("wrong checkpoint id",2L,((CancelCheckpointMarker)result).getCheckpointId());
    testHarness.endInput();
    testHarness.waitForTaskCompletion();
  }
private static class InitBlockingTask extends StreamTask<String,AbstractStreamOperator<String>> {
    private final Object lock=new Object();
    private volatile boolean running=true;
    protected InitBlockingTask(    Environment env){
      super(env);
    }
    @Override protected void init() throws Exception {
synchronized (lock) {
        while (running) {
          lock.wait();
        }
      }
    }
    @Override protected void run() throws Exception {
    }
    @Override protected void cleanup() throws Exception {
    }
    @Override protected void cancelTask() throws Exception {
      running=false;
synchronized (lock) {
        lock.notifyAll();
      }
    }
  }
private static class IdentityMap implements MapFunction<String,String> {
    private static final long serialVersionUID=1L;
    @Override public String map(    String value) throws Exception {
      return value;
    }
  }
private static class UnionCoMap implements CoMapFunction<String,String,String> {
    private static final long serialVersionUID=1L;
    @Override public String map1(    String value) throws Exception {
      return value;
    }
    @Override public String map2(    String value) throws Exception {
      return value;
    }
  }
}
