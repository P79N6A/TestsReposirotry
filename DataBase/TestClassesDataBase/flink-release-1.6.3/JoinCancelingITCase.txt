/** 
 * Test job cancellation from within a JoinFunction.
 */
@Ignore("Takes too long.") public class JoinCancelingITCase extends CancelingTestBase {
  private void executeTask(  JoinFunction<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> joiner,  boolean slow) throws Exception {
    executeTask(joiner,slow,PARALLELISM);
  }
  private void executeTask(  JoinFunction<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> joiner,  boolean slow,  int parallelism) throws Exception {
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<Tuple2<Integer,Integer>> input1=env.createInput(new InfiniteIntegerTupleInputFormat(slow));
    DataSet<Tuple2<Integer,Integer>> input2=env.createInput(new InfiniteIntegerTupleInputFormat(slow));
    input1.join(input2,JoinOperatorBase.JoinHint.REPARTITION_SORT_MERGE).where(0).equalTo(0).with(joiner).output(new DiscardingOutputFormat<Tuple2<Integer,Integer>>());
    env.setParallelism(parallelism);
    runAndCancelJob(env.createProgramPlan(),5 * 1000,10 * 1000);
  }
  @Test public void testCancelSortMatchWhileReadingSlowInputs() throws Exception {
    executeTask(new SimpleMatcher<Integer>(),true);
  }
  @Test public void testCancelSortMatchWhileReadingFastInputs() throws Exception {
    executeTask(new SimpleMatcher<Integer>(),false);
  }
  @Test public void testCancelSortMatchPriorToFirstRecordReading() throws Exception {
    executeTask(new StuckInOpenMatcher<Integer>(),false);
  }
  private void executeTaskWithGenerator(  JoinFunction<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> joiner,  int keys,  int vals,  int msecsTillCanceling,  int maxTimeTillCanceled) throws Exception {
    UniformIntTupleGenerator g=new UniformIntTupleGenerator(keys,vals,false);
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<Tuple2<Integer,Integer>> input1=env.createInput(new UniformIntTupleGeneratorInputFormat(keys,vals));
    DataSet<Tuple2<Integer,Integer>> input2=env.createInput(new UniformIntTupleGeneratorInputFormat(keys,vals));
    input1.join(input2,JoinOperatorBase.JoinHint.REPARTITION_SORT_MERGE).where(0).equalTo(0).with(joiner).output(new DiscardingOutputFormat<Tuple2<Integer,Integer>>());
    env.setParallelism(PARALLELISM);
    runAndCancelJob(env.createProgramPlan(),msecsTillCanceling,maxTimeTillCanceled);
  }
  @Test public void testCancelSortMatchWhileDoingHeavySorting() throws Exception {
    executeTaskWithGenerator(new SimpleMatcher<Integer>(),50000,100,30 * 1000,30 * 1000);
  }
  @Test public void testCancelSortMatchWhileJoining() throws Exception {
    executeTaskWithGenerator(new DelayingMatcher<Integer>(),500,3,10 * 1000,20 * 1000);
  }
  @Test public void testCancelSortMatchWithLongCancellingResponse() throws Exception {
    executeTaskWithGenerator(new LongCancelTimeMatcher<Integer>(),500,3,10 * 1000,10 * 1000);
  }
  @Test public void testCancelSortMatchWithHighparallelism() throws Exception {
    executeTask(new SimpleMatcher<Integer>(),false,64);
  }
private static final class SimpleMatcher<IN> implements JoinFunction<Tuple2<IN,IN>,Tuple2<IN,IN>,Tuple2<IN,IN>> {
    private static final long serialVersionUID=1L;
    @Override public Tuple2<IN,IN> join(    Tuple2<IN,IN> first,    Tuple2<IN,IN> second) throws Exception {
      return new Tuple2<>(first.f0,second.f0);
    }
  }
private static final class DelayingMatcher<IN> implements JoinFunction<Tuple2<IN,IN>,Tuple2<IN,IN>,Tuple2<IN,IN>> {
    private static final long serialVersionUID=1L;
    private static final int WAIT_TIME_PER_RECORD=10 * 1000;
    @Override public Tuple2<IN,IN> join(    Tuple2<IN,IN> first,    Tuple2<IN,IN> second) throws Exception {
      Thread.sleep(WAIT_TIME_PER_RECORD);
      return new Tuple2<>(first.f0,second.f0);
    }
  }
private static final class LongCancelTimeMatcher<IN> implements JoinFunction<Tuple2<IN,IN>,Tuple2<IN,IN>,Tuple2<IN,IN>> {
    private static final long serialVersionUID=1L;
    private static final int WAIT_TIME_PER_RECORD=5 * 1000;
    @Override public Tuple2<IN,IN> join(    Tuple2<IN,IN> first,    Tuple2<IN,IN> second) throws Exception {
      final long start=System.currentTimeMillis();
      long remaining=WAIT_TIME_PER_RECORD;
      do {
        try {
          Thread.sleep(remaining);
        }
 catch (        InterruptedException iex) {
        }
      }
 while ((remaining=WAIT_TIME_PER_RECORD - System.currentTimeMillis() + start) > 0);
      return new Tuple2<>(first.f0,second.f0);
    }
  }
private static final class StuckInOpenMatcher<IN> extends RichJoinFunction<Tuple2<IN,IN>,Tuple2<IN,IN>,Tuple2<IN,IN>> {
    private static final long serialVersionUID=1L;
    @Override public void open(    Configuration parameters) throws Exception {
synchronized (this) {
        wait();
      }
    }
    @Override public Tuple2<IN,IN> join(    Tuple2<IN,IN> first,    Tuple2<IN,IN> second) throws Exception {
      return new Tuple2<>(first.f0,second.f0);
    }
  }
}
