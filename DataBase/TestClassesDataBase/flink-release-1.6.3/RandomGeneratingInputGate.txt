private static class RandomGeneratingInputGate implements InputGate {
  private final int numChannels;
  private final BufferPool[] bufferPools;
  private final int[] currentBarriers;
  private final BarrierGenerator[] barrierGens;
  private int currentChannel=0;
  private long c=0;
  private final String owningTaskName;
  public RandomGeneratingInputGate(  BufferPool[] bufferPools,  BarrierGenerator[] barrierGens){
    this(bufferPools,barrierGens,"TestTask");
  }
  public RandomGeneratingInputGate(  BufferPool[] bufferPools,  BarrierGenerator[] barrierGens,  String owningTaskName){
    this.numChannels=bufferPools.length;
    this.currentBarriers=new int[numChannels];
    this.bufferPools=bufferPools;
    this.barrierGens=barrierGens;
    this.owningTaskName=owningTaskName;
  }
  @Override public int getNumberOfInputChannels(){
    return numChannels;
  }
  @Override public String getOwningTaskName(){
    return owningTaskName;
  }
  @Override public boolean isFinished(){
    return false;
  }
  @Override public void requestPartitions(){
  }
  @Override public Optional<BufferOrEvent> getNextBufferOrEvent() throws IOException, InterruptedException {
    currentChannel=(currentChannel + 1) % numChannels;
    if (barrierGens[currentChannel].isNextBarrier()) {
      return Optional.of(new BufferOrEvent(new CheckpointBarrier(++currentBarriers[currentChannel],System.currentTimeMillis(),CheckpointOptions.forCheckpointWithDefaultLocation()),currentChannel));
    }
 else {
      Buffer buffer=bufferPools[currentChannel].requestBuffer();
      buffer.getMemorySegment().putLong(0,c++);
      return Optional.of(new BufferOrEvent(buffer,currentChannel));
    }
  }
  @Override public Optional<BufferOrEvent> pollNextBufferOrEvent() throws IOException, InterruptedException {
    return getNextBufferOrEvent();
  }
  @Override public void sendTaskEvent(  TaskEvent event){
  }
  @Override public void registerListener(  InputGateListener listener){
  }
  @Override public int getPageSize(){
    return PAGE_SIZE;
  }
}
