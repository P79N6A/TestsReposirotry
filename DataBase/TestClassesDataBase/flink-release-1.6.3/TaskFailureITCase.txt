/** 
 * Tests that both jobs, the failing and the working one, are handled correctly. The first (failing) job must be canceled and the client must report the failure. The second (working) job must finish successfully and compute the correct result.
 */
public class TaskFailureITCase extends JavaProgramTestBase {
  private static final String EXCEPTION_STRING="This is an expected Test Exception";
  @Override protected void testProgram() throws Exception {
    try {
      executeTask(new FailingTestMapper(),1);
    }
 catch (    RuntimeException e) {
      if (!isCollectionExecution()) {
        Assert.fail();
      }
      Assert.assertEquals(EXCEPTION_STRING + ":0",e.getMessage());
    }
catch (    JobExecutionException e) {
      if (isCollectionExecution()) {
        Assert.fail();
      }
      Assert.assertEquals(EXCEPTION_STRING + ":1",e.getCause().getMessage());
    }
    executeTask(new TestMapper(),0);
  }
  private void executeTask(  MapFunction<Long,Long> mapper,  int retries) throws Exception {
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setRestartStrategy(RestartStrategies.fixedDelayRestart(retries,0));
    List<Long> result=env.generateSequence(1,9).map(mapper).collect();
    MultipleProgramsTestBase.compareResultAsText(result,"1\n2\n3\n4\n5\n6\n7\n8\n9");
  }
  /** 
 * Working map function.
 */
public static class TestMapper implements MapFunction<Long,Long> {
    private static final long serialVersionUID=1L;
    @Override public Long map(    Long value) throws Exception {
      return value;
    }
  }
  /** 
 * Failing map function.
 */
public static class FailingTestMapper extends RichMapFunction<Long,Long> {
    private static final long serialVersionUID=1L;
    @Override public Long map(    Long value) throws Exception {
      throw new RuntimeException(EXCEPTION_STRING + ":" + getRuntimeContext().getAttemptNumber());
    }
  }
}
