public class ResourceManagerJobMasterTest extends TestLogger {
  private TestingRpcService rpcService;
  private final Time timeout=Time.seconds(10L);
  @Before public void setup() throws Exception {
    rpcService=new TestingRpcService();
  }
  @After public void teardown() throws Exception {
    RpcUtils.terminateRpcService(rpcService,timeout);
  }
  /** 
 * Test receive normal registration from job master and receive duplicate registration from job master
 */
  @Test public void testRegisterJobMaster() throws Exception {
    String jobMasterAddress="/jobMasterAddress1";
    JobID jobID=mockJobMaster(jobMasterAddress);
    JobMasterId jobMasterId=JobMasterId.generate();
    final ResourceID jmResourceId=new ResourceID(jobMasterAddress);
    SettableLeaderRetrievalService jobMasterLeaderRetrievalService=new SettableLeaderRetrievalService(jobMasterAddress,jobMasterId.toUUID());
    TestingLeaderElectionService resourceManagerLeaderElectionService=new TestingLeaderElectionService();
    TestingFatalErrorHandler testingFatalErrorHandler=new TestingFatalErrorHandler();
    final ResourceManager<?> resourceManager=createAndStartResourceManager(resourceManagerLeaderElectionService,jobID,jobMasterLeaderRetrievalService,testingFatalErrorHandler);
    final ResourceManagerGateway rmGateway=resourceManager.getSelfGateway(ResourceManagerGateway.class);
    resourceManagerLeaderElectionService.isLeader(UUID.randomUUID()).get();
    CompletableFuture<RegistrationResponse> successfulFuture=rmGateway.registerJobManager(jobMasterId,jmResourceId,jobMasterAddress,jobID,timeout);
    RegistrationResponse response=successfulFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    assertTrue(response instanceof JobMasterRegistrationSuccess);
    if (testingFatalErrorHandler.hasExceptionOccurred()) {
      testingFatalErrorHandler.rethrowError();
    }
  }
  /** 
 * Test receive registration with unmatched leadershipId from job master
 */
  @Test public void testRegisterJobMasterWithUnmatchedLeaderSessionId1() throws Exception {
    String jobMasterAddress="/jobMasterAddress1";
    JobID jobID=mockJobMaster(jobMasterAddress);
    JobMasterId jobMasterId=JobMasterId.generate();
    final ResourceID jmResourceId=new ResourceID(jobMasterAddress);
    SettableLeaderRetrievalService jobMasterLeaderRetrievalService=new SettableLeaderRetrievalService(jobMasterAddress,jobMasterId.toUUID());
    TestingFatalErrorHandler testingFatalErrorHandler=new TestingFatalErrorHandler();
    final ResourceManager<?> resourceManager=createAndStartResourceManager(mock(LeaderElectionService.class),jobID,jobMasterLeaderRetrievalService,testingFatalErrorHandler);
    final ResourceManagerGateway wronglyFencedGateway=rpcService.connect(resourceManager.getAddress(),ResourceManagerId.generate(),ResourceManagerGateway.class).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    CompletableFuture<RegistrationResponse> unMatchedLeaderFuture=wronglyFencedGateway.registerJobManager(jobMasterId,jmResourceId,jobMasterAddress,jobID,timeout);
    try {
      unMatchedLeaderFuture.get(5L,TimeUnit.SECONDS);
      fail("Should fail because we are using the wrong fencing token.");
    }
 catch (    ExecutionException e) {
      assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException);
    }
    if (testingFatalErrorHandler.hasExceptionOccurred()) {
      testingFatalErrorHandler.rethrowError();
    }
  }
  /** 
 * Test receive registration with unmatched leadershipId from job master
 */
  @Test public void testRegisterJobMasterWithUnmatchedLeaderSessionId2() throws Exception {
    String jobMasterAddress="/jobMasterAddress1";
    JobID jobID=mockJobMaster(jobMasterAddress);
    TestingLeaderElectionService resourceManagerLeaderElectionService=new TestingLeaderElectionService();
    SettableLeaderRetrievalService jobMasterLeaderRetrievalService=new SettableLeaderRetrievalService("localhost",HighAvailabilityServices.DEFAULT_LEADER_ID);
    TestingFatalErrorHandler testingFatalErrorHandler=new TestingFatalErrorHandler();
    final ResourceManager<?> resourceManager=createAndStartResourceManager(resourceManagerLeaderElectionService,jobID,jobMasterLeaderRetrievalService,testingFatalErrorHandler);
    final ResourceManagerGateway rmGateway=resourceManager.getSelfGateway(ResourceManagerGateway.class);
    final ResourceID jmResourceId=new ResourceID(jobMasterAddress);
    resourceManagerLeaderElectionService.isLeader(UUID.randomUUID()).get();
    JobMasterId differentJobMasterId=JobMasterId.generate();
    CompletableFuture<RegistrationResponse> unMatchedLeaderFuture=rmGateway.registerJobManager(differentJobMasterId,jmResourceId,jobMasterAddress,jobID,timeout);
    assertTrue(unMatchedLeaderFuture.get(5,TimeUnit.SECONDS) instanceof RegistrationResponse.Decline);
    if (testingFatalErrorHandler.hasExceptionOccurred()) {
      testingFatalErrorHandler.rethrowError();
    }
  }
  /** 
 * Test receive registration with invalid address from job master
 */
  @Test public void testRegisterJobMasterFromInvalidAddress() throws Exception {
    String jobMasterAddress="/jobMasterAddress1";
    JobID jobID=mockJobMaster(jobMasterAddress);
    TestingLeaderElectionService resourceManagerLeaderElectionService=new TestingLeaderElectionService();
    SettableLeaderRetrievalService jobMasterLeaderRetrievalService=new SettableLeaderRetrievalService("localhost",HighAvailabilityServices.DEFAULT_LEADER_ID);
    TestingFatalErrorHandler testingFatalErrorHandler=new TestingFatalErrorHandler();
    final ResourceManager<?> resourceManager=createAndStartResourceManager(resourceManagerLeaderElectionService,jobID,jobMasterLeaderRetrievalService,testingFatalErrorHandler);
    final ResourceManagerGateway rmGateway=resourceManager.getSelfGateway(ResourceManagerGateway.class);
    final ResourceID jmResourceId=new ResourceID(jobMasterAddress);
    resourceManagerLeaderElectionService.isLeader(UUID.randomUUID()).get();
    String invalidAddress="/jobMasterAddress2";
    CompletableFuture<RegistrationResponse> invalidAddressFuture=rmGateway.registerJobManager(new JobMasterId(HighAvailabilityServices.DEFAULT_LEADER_ID),jmResourceId,invalidAddress,jobID,timeout);
    assertTrue(invalidAddressFuture.get(5,TimeUnit.SECONDS) instanceof RegistrationResponse.Decline);
    if (testingFatalErrorHandler.hasExceptionOccurred()) {
      testingFatalErrorHandler.rethrowError();
    }
  }
  /** 
 * Check and verify return RegistrationResponse.Decline when failed to start a job master Leader retrieval listener
 */
  @Test public void testRegisterJobMasterWithFailureLeaderListener() throws Exception {
    String jobMasterAddress="/jobMasterAddress1";
    JobID jobID=mockJobMaster(jobMasterAddress);
    TestingLeaderElectionService resourceManagerLeaderElectionService=new TestingLeaderElectionService();
    SettableLeaderRetrievalService jobMasterLeaderRetrievalService=new SettableLeaderRetrievalService("localhost",HighAvailabilityServices.DEFAULT_LEADER_ID);
    TestingFatalErrorHandler testingFatalErrorHandler=new TestingFatalErrorHandler();
    final ResourceManager<?> resourceManager=createAndStartResourceManager(resourceManagerLeaderElectionService,jobID,jobMasterLeaderRetrievalService,testingFatalErrorHandler);
    final ResourceManagerGateway rmGateway=resourceManager.getSelfGateway(ResourceManagerGateway.class);
    final ResourceID jmResourceId=new ResourceID(jobMasterAddress);
    JobID unknownJobIDToHAServices=new JobID();
    resourceManagerLeaderElectionService.isLeader(UUID.randomUUID()).get();
    CompletableFuture<RegistrationResponse> registrationFuture=rmGateway.registerJobManager(new JobMasterId(HighAvailabilityServices.DEFAULT_LEADER_ID),jmResourceId,jobMasterAddress,unknownJobIDToHAServices,timeout);
    try {
      registrationFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    }
 catch (    ExecutionException e) {
      assertTrue(ExceptionUtils.stripExecutionException(e) instanceof ResourceManagerException);
    }
  }
  private JobID mockJobMaster(  String jobMasterAddress){
    JobID jobID=new JobID();
    JobMasterGateway jobMasterGateway=mock(JobMasterGateway.class);
    rpcService.registerGateway(jobMasterAddress,jobMasterGateway);
    return jobID;
  }
  private ResourceManager createAndStartResourceManager(  LeaderElectionService resourceManagerLeaderElectionService,  JobID jobID,  LeaderRetrievalService jobMasterLeaderRetrievalService,  FatalErrorHandler fatalErrorHandler) throws Exception {
    ResourceID rmResourceId=ResourceID.generate();
    TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    highAvailabilityServices.setResourceManagerLeaderElectionService(resourceManagerLeaderElectionService);
    highAvailabilityServices.setJobMasterLeaderRetriever(jobID,jobMasterLeaderRetrievalService);
    HeartbeatServices heartbeatServices=new HeartbeatServices(1000L,1000L);
    ResourceManagerConfiguration resourceManagerConfiguration=new ResourceManagerConfiguration(Time.seconds(5L),Time.seconds(5L));
    MetricRegistryImpl metricRegistry=mock(MetricRegistryImpl.class);
    JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,rpcService.getScheduledExecutor(),Time.minutes(5L));
    final SlotManager slotManager=new SlotManager(rpcService.getScheduledExecutor(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime());
    ResourceManager resourceManager=new StandaloneResourceManager(rpcService,FlinkResourceManager.RESOURCE_MANAGER_NAME,rmResourceId,resourceManagerConfiguration,highAvailabilityServices,heartbeatServices,slotManager,metricRegistry,jobLeaderIdService,new ClusterInformation("localhost",1234),fatalErrorHandler,UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup());
    resourceManager.start();
    return resourceManager;
  }
}
