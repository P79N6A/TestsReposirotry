/** 
 * This test verifies that the optimizer assigns the correct data exchange mode to a simple forward / shuffle plan. <pre> (source) -> (map) -> (filter) -> (groupBy / reduce) </pre>
 */
@SuppressWarnings("serial") public class DataExchangeModeForwardTest extends CompilerTestBase {
  @Test public void testPipelinedForced(){
    verifySimpleForwardPlan(ExecutionMode.PIPELINED_FORCED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED);
  }
  @Test public void testPipelined(){
    verifySimpleForwardPlan(ExecutionMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED);
  }
  @Test public void testBatch(){
    verifySimpleForwardPlan(ExecutionMode.BATCH,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.PIPELINED,DataExchangeMode.BATCH,DataExchangeMode.PIPELINED);
  }
  @Test public void testBatchForced(){
    verifySimpleForwardPlan(ExecutionMode.BATCH_FORCED,DataExchangeMode.BATCH,DataExchangeMode.BATCH,DataExchangeMode.BATCH,DataExchangeMode.PIPELINED,DataExchangeMode.BATCH,DataExchangeMode.BATCH);
  }
  private void verifySimpleForwardPlan(  ExecutionMode execMode,  DataExchangeMode toMap,  DataExchangeMode toFilter,  DataExchangeMode toKeyExtractor,  DataExchangeMode toCombiner,  DataExchangeMode toReduce,  DataExchangeMode toSink){
    try {
      ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      env.getConfig().setExecutionMode(execMode);
      DataSet<String> dataSet=env.readTextFile("/never/accessed");
      dataSet.map(new MapFunction<String,Integer>(){
        @Override public Integer map(        String value){
          return 0;
        }
      }
).filter(new FilterFunction<Integer>(){
        @Override public boolean filter(        Integer value){
          return false;
        }
      }
).groupBy(new IdentityKeyExtractor<Integer>()).reduceGroup(new Top1GroupReducer<Integer>()).output(new DiscardingOutputFormat<Integer>());
      OptimizedPlan optPlan=compileNoStats(env.createProgramPlan());
      SinkPlanNode sinkNode=optPlan.getDataSinks().iterator().next();
      SingleInputPlanNode reduceNode=(SingleInputPlanNode)sinkNode.getPredecessor();
      SingleInputPlanNode combineNode=(SingleInputPlanNode)reduceNode.getPredecessor();
      SingleInputPlanNode keyExtractorNode=(SingleInputPlanNode)combineNode.getPredecessor();
      SingleInputPlanNode filterNode=(SingleInputPlanNode)keyExtractorNode.getPredecessor();
      SingleInputPlanNode mapNode=(SingleInputPlanNode)filterNode.getPredecessor();
      assertEquals(toMap,mapNode.getInput().getDataExchangeMode());
      assertEquals(toFilter,filterNode.getInput().getDataExchangeMode());
      assertEquals(toKeyExtractor,keyExtractorNode.getInput().getDataExchangeMode());
      assertEquals(toCombiner,combineNode.getInput().getDataExchangeMode());
      assertEquals(toReduce,reduceNode.getInput().getDataExchangeMode());
      assertEquals(toSink,sinkNode.getInput().getDataExchangeMode());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
}
