/** 
 * Test cases for the deployment of Yarn Flink clusters.
 */
public class YARNITCase extends YarnTestBase {
  @BeforeClass public static void setup(){
    YARN_CONFIGURATION.set(YarnTestBase.TEST_CLUSTER_NAME_KEY,"flink-yarn-tests-ha");
    startYARNWithConfig(YARN_CONFIGURATION);
  }
  @Ignore("The cluster cannot be stopped yet.") @Test public void testPerJobMode() throws Exception {
    Configuration configuration=new Configuration();
    configuration.setString(AkkaOptions.ASK_TIMEOUT,"30 s");
    final YarnClient yarnClient=getYarnClient();
    try (final YarnClusterDescriptor yarnClusterDescriptor=new YarnClusterDescriptor(configuration,getYarnConfiguration(),System.getenv(ConfigConstants.ENV_FLINK_CONF_DIR),yarnClient,true)){
      yarnClusterDescriptor.setLocalJarPath(new Path(flinkUberjar.getAbsolutePath()));
      yarnClusterDescriptor.addShipFiles(Arrays.asList(flinkLibFolder.listFiles()));
      final ClusterSpecification clusterSpecification=new ClusterSpecification.ClusterSpecificationBuilder().setMasterMemoryMB(768).setTaskManagerMemoryMB(1024).setSlotsPerTaskManager(1).setNumberTaskManagers(1).createClusterSpecification();
      StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
      env.setParallelism(2);
      env.addSource(new InfiniteSource()).shuffle().addSink(new DiscardingSink<Integer>());
      final JobGraph jobGraph=env.getStreamGraph().getJobGraph();
      File testingJar=YarnTestBase.findFile("..",new TestingYarnClusterDescriptor.TestJarFinder("flink-yarn-tests"));
      jobGraph.addJar(new org.apache.flink.core.fs.Path(testingJar.toURI()));
      ClusterClient<ApplicationId> clusterClient=yarnClusterDescriptor.deployJobCluster(clusterSpecification,jobGraph,true);
      clusterClient.shutdown();
    }
   }
private static class InfiniteSource implements ParallelSourceFunction<Integer> {
    private static final long serialVersionUID=1642561062000662861L;
    private volatile boolean running;
    private final Random random;
    InfiniteSource(){
      running=true;
      random=new Random();
    }
    @Override public void run(    SourceContext<Integer> ctx) throws Exception {
      while (running) {
synchronized (ctx.getCheckpointLock()) {
          ctx.collect(random.nextInt());
        }
        Thread.sleep(5L);
      }
    }
    @Override public void cancel(){
      running=false;
    }
  }
}
