/** 
 * Test that verifies the behavior of blocking shutdown hooks and of the {@link JvmShutdownSafeguard} that guards against it.
 */
public class JvmExitOnFatalErrorTest {
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  @Test public void testExitJvmOnOutOfMemory() throws Exception {
    assumeTrue(OperatingSystem.isLinux());
    final KillOnFatalErrorProcess testProcess=new KillOnFatalErrorProcess();
    try {
      testProcess.startProcess();
      testProcess.waitFor();
    }
  finally {
      testProcess.destroy();
    }
  }
private static final class KillOnFatalErrorProcess extends TestJvmProcess {
    public KillOnFatalErrorProcess() throws Exception {
    }
    @Override public String getName(){
      return "KillOnFatalErrorProcess";
    }
    @Override public String[] getJvmArgs(){
      return new String[0];
    }
    @Override public String getEntryPointClassName(){
      return ProcessEntryPoint.class.getName();
    }
  }
public static final class ProcessEntryPoint {
    public static void main(    String[] args) throws Exception {
      System.err.println("creating task");
      try {
        final Configuration taskManagerConfig=new Configuration();
        taskManagerConfig.setBoolean(TaskManagerOptions.KILL_ON_OUT_OF_MEMORY,true);
        final JobID jid=new JobID();
        final AllocationID allocationID=new AllocationID();
        final JobVertexID jobVertexId=new JobVertexID();
        final ExecutionAttemptID executionAttemptID=new ExecutionAttemptID();
        final AllocationID slotAllocationId=new AllocationID();
        final SerializedValue<ExecutionConfig> execConfig=new SerializedValue<>(new ExecutionConfig());
        final JobInformation jobInformation=new JobInformation(jid,"Test Job",execConfig,new Configuration(),Collections.emptyList(),Collections.emptyList());
        final TaskInformation taskInformation=new TaskInformation(jobVertexId,"Test Task",1,1,OomInvokable.class.getName(),new Configuration());
        final MemoryManager memoryManager=new MemoryManager(1024 * 1024,1);
        final IOManager ioManager=new IOManagerAsync();
        final NetworkEnvironment networkEnvironment=mock(NetworkEnvironment.class);
        when(networkEnvironment.createKvStateTaskRegistry(jid,jobVertexId)).thenReturn(mock(TaskKvStateRegistry.class));
        TaskEventDispatcher taskEventDispatcher=mock(TaskEventDispatcher.class);
        when(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
        final TaskManagerRuntimeInfo tmInfo=TaskManagerConfiguration.fromConfiguration(taskManagerConfig);
        final Executor executor=Executors.newCachedThreadPool();
        BlobCacheService blobService=new BlobCacheService(mock(PermanentBlobCache.class),mock(TransientBlobCache.class));
        final TaskLocalStateStore localStateStore=new TaskLocalStateStoreImpl(jid,allocationID,jobVertexId,0,TestLocalRecoveryConfig.disabled(),executor);
        final TaskStateManager slotStateManager=new TaskStateManagerImpl(jid,executionAttemptID,localStateStore,null,mock(CheckpointResponder.class));
        Task task=new Task(jobInformation,taskInformation,executionAttemptID,slotAllocationId,0,0,Collections.<ResultPartitionDeploymentDescriptor>emptyList(),Collections.<InputGateDeploymentDescriptor>emptyList(),0,memoryManager,ioManager,networkEnvironment,new BroadcastVariableManager(),slotStateManager,new NoOpTaskManagerActions(),new NoOpInputSplitProvider(),new NoOpCheckpointResponder(),blobService,new BlobLibraryCacheManager(blobService.getPermanentBlobService(),FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,new String[0]),new FileCache(tmInfo.getTmpDirectories(),blobService.getPermanentBlobService()),tmInfo,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),new NoOpResultPartitionConsumableNotifier(),new NoOpPartitionProducerStateChecker(),executor);
        System.err.println("starting task thread");
        task.startTaskThread();
      }
 catch (      Throwable t) {
        System.err.println("ERROR STARTING TASK");
        t.printStackTrace();
      }
      System.err.println("parking the main thread");
      CommonTestUtils.blockForeverNonInterruptibly();
    }
public static final class OomInvokable extends AbstractInvokable {
      public OomInvokable(      Environment environment){
        super(environment);
      }
      @Override public void invoke() throws Exception {
        throw new OutOfMemoryError();
      }
    }
private static final class NoOpTaskManagerActions implements TaskManagerActions {
      @Override public void notifyFinalState(      ExecutionAttemptID executionAttemptID){
      }
      @Override public void notifyFatalError(      String message,      Throwable cause){
      }
      @Override public void failTask(      ExecutionAttemptID executionAttemptID,      Throwable cause){
      }
      @Override public void updateTaskExecutionState(      TaskExecutionState taskExecutionState){
      }
    }
private static final class NoOpInputSplitProvider implements InputSplitProvider {
      @Override public InputSplit getNextInputSplit(      ClassLoader userCodeClassLoader){
        return null;
      }
    }
private static final class NoOpCheckpointResponder implements CheckpointResponder {
      @Override public void acknowledgeCheckpoint(      JobID j,      ExecutionAttemptID e,      long i,      CheckpointMetrics c,      TaskStateSnapshot s){
      }
      @Override public void declineCheckpoint(      JobID j,      ExecutionAttemptID e,      long l,      Throwable t){
      }
    }
private static final class NoOpPartitionProducerStateChecker implements PartitionProducerStateChecker {
      @Override public CompletableFuture<ExecutionState> requestPartitionProducerState(      JobID jobId,      IntermediateDataSetID intermediateDataSetId,      ResultPartitionID r){
        return null;
      }
    }
  }
}
