private static class BrokerKillingMapper<T> extends RichMapFunction<T,T> implements ListCheckpointed<Integer>, CheckpointListener {
  private static final long serialVersionUID=6334389850158707313L;
  public static volatile boolean killedLeaderBefore;
  public static volatile boolean hasBeenCheckpointedBeforeFailure;
  private final int shutdownBrokerId;
  private final int failCount;
  private int numElementsTotal;
  private boolean failer;
  private boolean hasBeenCheckpointed;
  public BrokerKillingMapper(  int shutdownBrokerId,  int failCount){
    this.shutdownBrokerId=shutdownBrokerId;
    this.failCount=failCount;
  }
  @Override public void open(  Configuration parameters){
    failer=getRuntimeContext().getIndexOfThisSubtask() == 0;
  }
  @Override public T map(  T value) throws Exception {
    numElementsTotal++;
    if (!killedLeaderBefore) {
      Thread.sleep(10);
      if (failer && numElementsTotal >= failCount) {
        KafkaServer toShutDown=null;
        for (        KafkaServer server : kafkaServer.getBrokers()) {
          if (kafkaServer.getBrokerId(server) == shutdownBrokerId) {
            toShutDown=server;
            break;
          }
        }
        if (toShutDown == null) {
          StringBuilder listOfBrokers=new StringBuilder();
          for (          KafkaServer server : kafkaServer.getBrokers()) {
            listOfBrokers.append(kafkaServer.getBrokerId(server));
            listOfBrokers.append(" ; ");
          }
          throw new Exception("Cannot find broker to shut down: " + shutdownBrokerId + " ; available brokers: "+ listOfBrokers.toString());
        }
 else {
          hasBeenCheckpointedBeforeFailure=hasBeenCheckpointed;
          killedLeaderBefore=true;
          toShutDown.shutdown();
        }
      }
    }
    return value;
  }
  @Override public void notifyCheckpointComplete(  long checkpointId){
    hasBeenCheckpointed=true;
  }
  @Override public List<Integer> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(this.numElementsTotal);
  }
  @Override public void restoreState(  List<Integer> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.numElementsTotal=state.get(0);
  }
}
