/** 
 * A few tests for the cleanup of transient BLOBs at the  {@link BlobServer}.
 */
public class BlobServerCleanupTest extends TestLogger {
  private final Random rnd=new Random();
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  @Test public void testTransientBlobNoJobCleanup() throws IOException, InterruptedException, ExecutionException {
    testTransientBlobCleanup(null);
  }
  @Test public void testTransientBlobForJobCleanup() throws IOException, InterruptedException, ExecutionException {
    testTransientBlobCleanup(new JobID());
  }
  /** 
 * Tests that  {@link TransientBlobCache} cleans up after a default TTL and keeps files which areconstantly accessed.
 */
  private void testTransientBlobCleanup(  @Nullable final JobID jobId) throws IOException, InterruptedException, ExecutionException {
    long cleanupInterval=1L;
    final int numberConcurrentGetOperations=3;
    final List<CompletableFuture<Void>> getOperations=new ArrayList<>(numberConcurrentGetOperations);
    byte[] data=new byte[2000000];
    rnd.nextBytes(data);
    byte[] data2=Arrays.copyOfRange(data,10,54);
    Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    config.setLong(BlobServerOptions.CLEANUP_INTERVAL,cleanupInterval);
    long cleanupLowerBound;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore())){
      ConcurrentMap<Tuple2<JobID,TransientBlobKey>,Long> transientBlobExpiryTimes=server.getBlobExpiryTimes();
      server.start();
      cleanupLowerBound=System.currentTimeMillis() + cleanupInterval;
      final TransientBlobKey key1=(TransientBlobKey)put(server,jobId,data,TRANSIENT_BLOB);
      final Long key1ExpiryAfterPut=transientBlobExpiryTimes.get(Tuple2.of(jobId,key1));
      assertThat(key1ExpiryAfterPut,greaterThanOrEqualTo(cleanupLowerBound));
      cleanupLowerBound=System.currentTimeMillis() + cleanupInterval;
      final TransientBlobKey key2=(TransientBlobKey)put(server,jobId,data2,TRANSIENT_BLOB);
      final Long key2ExpiryAfterPut=transientBlobExpiryTimes.get(Tuple2.of(jobId,key2));
      assertThat(key2ExpiryAfterPut,greaterThanOrEqualTo(cleanupLowerBound));
      final JobID jobIdHA=(jobId == null) ? new JobID() : jobId;
      final BlobKey keyHA=put(server,jobIdHA,data,PERMANENT_BLOB);
      Thread.sleep(1);
      cleanupLowerBound=System.currentTimeMillis() + cleanupInterval;
      verifyContents(server,jobId,key1,data);
      final Long key1ExpiryAfterGet=transientBlobExpiryTimes.get(Tuple2.of(jobId,key1));
      assertThat(key1ExpiryAfterGet,greaterThan(key1ExpiryAfterPut));
      assertThat(key1ExpiryAfterGet,greaterThanOrEqualTo(cleanupLowerBound));
      assertEquals(key2ExpiryAfterPut,transientBlobExpiryTimes.get(Tuple2.of(jobId,key2)));
      Thread.sleep(1);
      cleanupLowerBound=System.currentTimeMillis() + cleanupInterval;
      verifyContents(server,jobId,key2,data2);
      assertEquals(key1ExpiryAfterGet,transientBlobExpiryTimes.get(Tuple2.of(jobId,key1)));
      assertThat(transientBlobExpiryTimes.get(Tuple2.of(jobId,key2)),greaterThan(key2ExpiryAfterPut));
      assertThat(transientBlobExpiryTimes.get(Tuple2.of(jobId,key2)),greaterThanOrEqualTo(cleanupLowerBound));
      final long finishTime=System.currentTimeMillis() + 3 * cleanupInterval;
      final ExecutorService executor=Executors.newFixedThreadPool(numberConcurrentGetOperations);
      for (int i=0; i < numberConcurrentGetOperations; i++) {
        CompletableFuture<Void> getOperation=CompletableFuture.supplyAsync(() -> {
          try {
            while (System.currentTimeMillis() < finishTime) {
              get(server,jobId,key1);
            }
            return null;
          }
 catch (          IOException e) {
            throw new CompletionException(new FlinkException("Could not retrieve blob.",e));
          }
        }
,executor);
        getOperations.add(getOperation);
      }
      FutureUtils.ConjunctFuture<Collection<Void>> filesFuture=FutureUtils.combineAll(getOperations);
      filesFuture.get();
      verifyDeletedEventually(server,jobId,key1,key2);
      verifyContents(server,jobIdHA,keyHA,data);
    }
   }
  /** 
 * Checks how many of the files given by blob keys are accessible.
 * @param jobId ID of a job
 * @param keys blob keys to check
 * @param blobService BLOB store to use
 * @param doThrow whether exceptions should be ignored (<tt>false</tt>), or thrown (<tt>true</tt>)
 * @return number of files existing at {@link BlobServer#getStorageLocation(JobID,BlobKey)} and{@link PermanentBlobCache#getStorageLocation(JobID,BlobKey)}, respectively
 */
  public static <T>int checkFilesExist(  JobID jobId,  Collection<? extends BlobKey> keys,  T blobService,  boolean doThrow) throws IOException {
    int numFiles=0;
    for (    BlobKey key : keys) {
      final File blobFile;
      if (blobService instanceof BlobServer) {
        BlobServer server=(BlobServer)blobService;
        blobFile=server.getStorageLocation(jobId,key);
      }
 else       if (blobService instanceof PermanentBlobCache) {
        PermanentBlobCache cache=(PermanentBlobCache)blobService;
        blobFile=cache.getStorageLocation(jobId,key);
      }
 else       if (blobService instanceof TransientBlobCache) {
        TransientBlobCache cache=(TransientBlobCache)blobService;
        blobFile=cache.getStorageLocation(jobId,key);
      }
 else {
        throw new UnsupportedOperationException("unsupported BLOB service class: " + blobService.getClass().getCanonicalName());
      }
      if (blobFile.exists()) {
        ++numFiles;
      }
 else       if (doThrow) {
        throw new IOException("File " + blobFile + " does not exist.");
      }
    }
    return numFiles;
  }
  /** 
 * Checks how many of the files given by blob keys are accessible.
 * @param expectedCount number of expected files in the blob service for the given job
 * @param jobId ID of a job
 * @param blobService BLOB store to use
 */
  public static void checkFileCountForJob(  int expectedCount,  JobID jobId,  PermanentBlobService blobService) throws IOException {
    final File jobDir;
    if (blobService instanceof BlobServer) {
      BlobServer server=(BlobServer)blobService;
      jobDir=server.getStorageLocation(jobId,new PermanentBlobKey()).getParentFile();
    }
 else {
      PermanentBlobCache cache=(PermanentBlobCache)blobService;
      jobDir=cache.getStorageLocation(jobId,new PermanentBlobKey()).getParentFile();
    }
    File[] blobsForJob=jobDir.listFiles();
    if (blobsForJob == null) {
      if (expectedCount != 0) {
        throw new IOException("File " + jobDir + " does not exist.");
      }
    }
 else {
      assertEquals("Too many/few files in job dir: " + Arrays.asList(blobsForJob).toString(),expectedCount,blobsForJob.length);
    }
  }
}
