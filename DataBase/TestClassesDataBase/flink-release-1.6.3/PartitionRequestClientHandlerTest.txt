public class PartitionRequestClientHandlerTest {
  /** 
 * Tests a fix for FLINK-1627. <p> FLINK-1627 discovered a race condition, which could lead to an infinite loop when a receiver was cancelled during a certain time of decoding a message. The test reproduces the input, which lead to the infinite loop: when the handler gets a reference to the buffer provider of the receiving input channel, but the respective input channel is released (and the corresponding buffer provider destroyed), the handler did not notice this.
 * @see <a href="https://issues.apache.org/jira/browse/FLINK-1627">FLINK-1627</a>
 */
  @Test(timeout=60000) @SuppressWarnings("unchecked") public void testReleaseInputChannelDuringDecode() throws Exception {
    final BufferProvider bufferProvider=mock(BufferProvider.class);
    when(bufferProvider.requestBuffer()).thenReturn(null);
    when(bufferProvider.isDestroyed()).thenReturn(true);
    when(bufferProvider.addBufferListener(any(BufferListener.class))).thenReturn(false);
    final RemoteInputChannel inputChannel=mock(RemoteInputChannel.class);
    when(inputChannel.getInputChannelId()).thenReturn(new InputChannelID());
    when(inputChannel.getBufferProvider()).thenReturn(bufferProvider);
    final BufferResponse receivedBuffer=createBufferResponse(TestBufferFactory.createBuffer(TestBufferFactory.BUFFER_SIZE),0,inputChannel.getInputChannelId(),2);
    final PartitionRequestClientHandler client=new PartitionRequestClientHandler();
    client.addInputChannel(inputChannel);
    client.channelRead(mock(ChannelHandlerContext.class),receivedBuffer);
  }
  /** 
 * Tests a fix for FLINK-1761. <p>FLINK-1761 discovered an IndexOutOfBoundsException, when receiving buffers of size 0.
 */
  @Test public void testReceiveEmptyBuffer() throws Exception {
    final BufferProvider bufferProvider=mock(BufferProvider.class);
    when(bufferProvider.requestBuffer()).thenReturn(TestBufferFactory.createBuffer(0));
    final RemoteInputChannel inputChannel=mock(RemoteInputChannel.class);
    when(inputChannel.getInputChannelId()).thenReturn(new InputChannelID());
    when(inputChannel.getBufferProvider()).thenReturn(bufferProvider);
    final Buffer emptyBuffer=TestBufferFactory.createBuffer(0);
    final int backlog=-1;
    final BufferResponse receivedBuffer=createBufferResponse(emptyBuffer,0,inputChannel.getInputChannelId(),backlog);
    final PartitionRequestClientHandler client=new PartitionRequestClientHandler();
    client.addInputChannel(inputChannel);
    client.channelRead(mock(ChannelHandlerContext.class),receivedBuffer);
    verify(inputChannel,never()).onError(any(Throwable.class));
    verify(inputChannel,times(1)).onEmptyBuffer(0,backlog);
  }
  /** 
 * Verifies that  {@link RemoteInputChannel#onBuffer(Buffer,int,int)} is called when a{@link BufferResponse} is received.
 */
  @Test public void testReceiveBuffer() throws Exception {
    final NetworkBufferPool networkBufferPool=new NetworkBufferPool(10,32);
    final SingleInputGate inputGate=createSingleInputGate();
    final RemoteInputChannel inputChannel=createRemoteInputChannel(inputGate);
    try {
      final BufferPool bufferPool=networkBufferPool.createBufferPool(8,8);
      inputGate.setBufferPool(bufferPool);
      final int numExclusiveBuffers=2;
      inputGate.assignExclusiveSegments(networkBufferPool,numExclusiveBuffers);
      final PartitionRequestClientHandler handler=new PartitionRequestClientHandler();
      handler.addInputChannel(inputChannel);
      final int backlog=2;
      final BufferResponse bufferResponse=createBufferResponse(TestBufferFactory.createBuffer(32),0,inputChannel.getInputChannelId(),backlog);
      handler.channelRead(mock(ChannelHandlerContext.class),bufferResponse);
      assertEquals(1,inputChannel.getNumberOfQueuedBuffers());
    }
  finally {
      inputGate.releaseAllResources();
      networkBufferPool.destroyAllBufferPools();
      networkBufferPool.destroy();
    }
  }
  /** 
 * Verifies that  {@link RemoteInputChannel#onFailedPartitionRequest()} is called when a{@link PartitionNotFoundException} is received.
 */
  @Test public void testReceivePartitionNotFoundException() throws Exception {
    final BufferProvider bufferProvider=mock(BufferProvider.class);
    when(bufferProvider.requestBuffer()).thenReturn(TestBufferFactory.createBuffer(0));
    final RemoteInputChannel inputChannel=mock(RemoteInputChannel.class);
    when(inputChannel.getInputChannelId()).thenReturn(new InputChannelID());
    when(inputChannel.getBufferProvider()).thenReturn(bufferProvider);
    final ErrorResponse partitionNotFound=new ErrorResponse(new PartitionNotFoundException(new ResultPartitionID()),inputChannel.getInputChannelId());
    final PartitionRequestClientHandler client=new PartitionRequestClientHandler();
    client.addInputChannel(inputChannel);
    ChannelHandlerContext ctx=mock(ChannelHandlerContext.class);
    when(ctx.channel()).thenReturn(mock(Channel.class));
    client.channelActive(ctx);
    client.channelRead(ctx,partitionNotFound);
    verify(inputChannel,times(1)).onFailedPartitionRequest();
  }
  @Test public void testCancelBeforeActive() throws Exception {
    final RemoteInputChannel inputChannel=mock(RemoteInputChannel.class);
    when(inputChannel.getInputChannelId()).thenReturn(new InputChannelID());
    final PartitionRequestClientHandler client=new PartitionRequestClientHandler();
    client.addInputChannel(inputChannel);
    client.cancelRequestFor(null);
    client.cancelRequestFor(inputChannel.getInputChannelId());
  }
  /** 
 * Creates and returns the single input gate for credit-based testing.
 * @return The new created single input gate.
 */
  static SingleInputGate createSingleInputGate(){
    return new SingleInputGate("InputGate",new JobID(),new IntermediateDataSetID(),ResultPartitionType.PIPELINED,0,1,mock(TaskActions.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(),true);
  }
  /** 
 * Creates and returns a remote input channel for the specific input gate.
 * @param inputGate The input gate owns the created input channel.
 * @return The new created remote input channel.
 */
  static RemoteInputChannel createRemoteInputChannel(  SingleInputGate inputGate) throws Exception {
    return createRemoteInputChannel(inputGate,mock(PartitionRequestClient.class));
  }
  /** 
 * Creates and returns a remote input channel for the specific input gate with specific partition request client.
 * @param inputGate The input gate owns the created input channel.
 * @param client The client is used to send partition request.
 * @return The new created remote input channel.
 */
  static RemoteInputChannel createRemoteInputChannel(  SingleInputGate inputGate,  PartitionRequestClient client) throws Exception {
    return createRemoteInputChannel(inputGate,client,0,0);
  }
  /** 
 * Creates and returns a remote input channel for the specific input gate with specific partition request client.
 * @param inputGate The input gate owns the created input channel.
 * @param client The client is used to send partition request.
 * @param initialBackoff initial back off (in ms) for retriggering subpartition requests (must be <tt>&gt; 0</tt> to activate)
 * @param maxBackoff after which delay (in ms) to stop retriggering subpartition requests
 * @return The new created remote input channel.
 */
  static RemoteInputChannel createRemoteInputChannel(  SingleInputGate inputGate,  PartitionRequestClient client,  int initialBackoff,  int maxBackoff) throws Exception {
    final ConnectionManager connectionManager=mock(ConnectionManager.class);
    when(connectionManager.createPartitionRequestClient(any(ConnectionID.class))).thenReturn(client);
    ResultPartitionID partitionId=new ResultPartitionID();
    RemoteInputChannel inputChannel=new RemoteInputChannel(inputGate,0,partitionId,mock(ConnectionID.class),connectionManager,initialBackoff,maxBackoff,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup());
    inputGate.setInputChannel(partitionId.getPartitionId(),inputChannel);
    return inputChannel;
  }
  /** 
 * Returns a deserialized buffer message as it would be received during runtime.
 */
  static BufferResponse createBufferResponse(  Buffer buffer,  int sequenceNumber,  InputChannelID receivingChannelId,  int backlog) throws IOException {
    BufferResponse resp=new BufferResponse(buffer,sequenceNumber,receivingChannelId,backlog);
    ByteBuf serialized=resp.write(UnpooledByteBufAllocator.DEFAULT);
    serialized.readBytes(NettyMessage.FRAME_HEADER_LENGTH);
    BufferResponse deserialized=BufferResponse.readFrom(serialized);
    return deserialized;
  }
}
