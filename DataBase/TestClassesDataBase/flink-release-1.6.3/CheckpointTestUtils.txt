/** 
 * A collection of utility methods for testing the (de)serialization of checkpoint metadata for persistence.
 */
public class CheckpointTestUtils {
  /** 
 * Creates a random collection of OperatorState objects containing various types of state handles.
 */
  public static Collection<OperatorState> createOperatorStates(  int numTaskStates,  int numSubtasksPerTask){
    return createOperatorStates(new Random(),numTaskStates,numSubtasksPerTask);
  }
  /** 
 * Creates a random collection of OperatorState objects containing various types of state handles.
 */
  public static Collection<OperatorState> createOperatorStates(  Random random,  int numTaskStates,  int numSubtasksPerTask){
    List<OperatorState> taskStates=new ArrayList<>(numTaskStates);
    for (int stateIdx=0; stateIdx < numTaskStates; ++stateIdx) {
      OperatorState taskState=new OperatorState(new OperatorID(),numSubtasksPerTask,128);
      boolean hasOperatorStateBackend=random.nextBoolean();
      boolean hasOperatorStateStream=random.nextBoolean();
      boolean hasKeyedBackend=random.nextInt(4) != 0;
      boolean hasKeyedStream=random.nextInt(4) != 0;
      boolean isIncremental=random.nextInt(3) == 0;
      for (int subtaskIdx=0; subtaskIdx < numSubtasksPerTask; subtaskIdx++) {
        StreamStateHandle operatorStateBackend=new ByteStreamStateHandle("b",("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET));
        StreamStateHandle operatorStateStream=new ByteStreamStateHandle("b",("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET));
        OperatorStateHandle operatorStateHandleBackend=null;
        OperatorStateHandle operatorStateHandleStream=null;
        Map<String,OperatorStateHandle.StateMetaInfo> offsetsMap=new HashMap<>();
        offsetsMap.put("A",new OperatorStateHandle.StateMetaInfo(new long[]{0,10,20},OperatorStateHandle.Mode.SPLIT_DISTRIBUTE));
        offsetsMap.put("B",new OperatorStateHandle.StateMetaInfo(new long[]{30,40,50},OperatorStateHandle.Mode.SPLIT_DISTRIBUTE));
        offsetsMap.put("C",new OperatorStateHandle.StateMetaInfo(new long[]{60,70,80},OperatorStateHandle.Mode.UNION));
        if (hasOperatorStateBackend) {
          operatorStateHandleBackend=new OperatorStreamStateHandle(offsetsMap,operatorStateBackend);
        }
        if (hasOperatorStateStream) {
          operatorStateHandleStream=new OperatorStreamStateHandle(offsetsMap,operatorStateStream);
        }
        KeyedStateHandle keyedStateBackend=null;
        KeyedStateHandle keyedStateStream=null;
        if (hasKeyedBackend) {
          if (isIncremental) {
            keyedStateBackend=createDummyIncrementalKeyedStateHandle(random);
          }
 else {
            keyedStateBackend=createDummyKeyGroupStateHandle(random);
          }
        }
        if (hasKeyedStream) {
          keyedStateStream=createDummyKeyGroupStateHandle(random);
        }
        taskState.putState(subtaskIdx,new OperatorSubtaskState(operatorStateHandleBackend,operatorStateHandleStream,keyedStateStream,keyedStateBackend));
      }
      taskStates.add(taskState);
    }
    return taskStates;
  }
  /** 
 * Creates a random collection of TaskState objects containing various types of state handles.
 */
  public static Collection<TaskState> createTaskStates(  int numTaskStates,  int numSubtasksPerTask){
    return createTaskStates(new Random(),numTaskStates,numSubtasksPerTask);
  }
  /** 
 * Creates a random collection of TaskState objects containing various types of state handles.
 */
  public static Collection<TaskState> createTaskStates(  Random random,  int numTaskStates,  int numSubtasksPerTask){
    List<TaskState> taskStates=new ArrayList<>(numTaskStates);
    for (int stateIdx=0; stateIdx < numTaskStates; ++stateIdx) {
      int chainLength=1 + random.nextInt(8);
      TaskState taskState=new TaskState(new JobVertexID(),numSubtasksPerTask,128,chainLength);
      int noNonPartitionableStateAtIndex=random.nextInt(chainLength);
      int noOperatorStateBackendAtIndex=random.nextInt(chainLength);
      int noOperatorStateStreamAtIndex=random.nextInt(chainLength);
      boolean hasKeyedBackend=random.nextInt(4) != 0;
      boolean hasKeyedStream=random.nextInt(4) != 0;
      for (int subtaskIdx=0; subtaskIdx < numSubtasksPerTask; subtaskIdx++) {
        List<OperatorStateHandle> operatorStatesBackend=new ArrayList<>(chainLength);
        List<OperatorStateHandle> operatorStatesStream=new ArrayList<>(chainLength);
        for (int chainIdx=0; chainIdx < chainLength; ++chainIdx) {
          StreamStateHandle operatorStateBackend=new ByteStreamStateHandle("b-" + chainIdx,("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET));
          StreamStateHandle operatorStateStream=new ByteStreamStateHandle("b-" + chainIdx,("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET));
          Map<String,OperatorStateHandle.StateMetaInfo> offsetsMap=new HashMap<>();
          offsetsMap.put("A",new OperatorStateHandle.StateMetaInfo(new long[]{0,10,20},OperatorStateHandle.Mode.SPLIT_DISTRIBUTE));
          offsetsMap.put("B",new OperatorStateHandle.StateMetaInfo(new long[]{30,40,50},OperatorStateHandle.Mode.SPLIT_DISTRIBUTE));
          offsetsMap.put("C",new OperatorStateHandle.StateMetaInfo(new long[]{60,70,80},OperatorStateHandle.Mode.UNION));
          if (chainIdx != noOperatorStateBackendAtIndex) {
            OperatorStateHandle operatorStateHandleBackend=new OperatorStreamStateHandle(offsetsMap,operatorStateBackend);
            operatorStatesBackend.add(operatorStateHandleBackend);
          }
          if (chainIdx != noOperatorStateStreamAtIndex) {
            OperatorStateHandle operatorStateHandleStream=new OperatorStreamStateHandle(offsetsMap,operatorStateStream);
            operatorStatesStream.add(operatorStateHandleStream);
          }
        }
        KeyGroupsStateHandle keyedStateBackend=null;
        KeyGroupsStateHandle keyedStateStream=null;
        if (hasKeyedBackend) {
          keyedStateBackend=createDummyKeyGroupStateHandle(random);
        }
        if (hasKeyedStream) {
          keyedStateStream=createDummyKeyGroupStateHandle(random);
        }
        taskState.putState(subtaskIdx,new SubtaskState(new ChainedStateHandle<>(operatorStatesBackend),new ChainedStateHandle<>(operatorStatesStream),keyedStateStream,keyedStateBackend));
      }
      taskStates.add(taskState);
    }
    return taskStates;
  }
  /** 
 * Creates a bunch of random master states.
 */
  public static Collection<MasterState> createRandomMasterStates(  Random random,  int num){
    final ArrayList<MasterState> states=new ArrayList<>(num);
    for (int i=0; i < num; i++) {
      int version=random.nextInt(10);
      String name=StringUtils.getRandomString(random,5,500);
      byte[] bytes=new byte[random.nextInt(5000) + 1];
      random.nextBytes(bytes);
      states.add(new MasterState(name,bytes,version));
    }
    return states;
  }
  /** 
 * Asserts that two MasterStates are equal. <p>The MasterState avoids overriding  {@code equals()} on purpose, because equality is not welldefined in the raw contents.
 */
  public static void assertMasterStateEquality(  MasterState a,  MasterState b){
    assertEquals(a.version(),b.version());
    assertEquals(a.name(),b.name());
    assertArrayEquals(a.bytes(),b.bytes());
  }
  /** 
 * utility class, not meant to be instantiated 
 */
  private CheckpointTestUtils(){
  }
  public static IncrementalKeyedStateHandle createDummyIncrementalKeyedStateHandle(  Random rnd){
    return new IncrementalKeyedStateHandle(createRandomUUID(rnd),new KeyGroupRange(1,1),42L,createRandomStateHandleMap(rnd),createRandomStateHandleMap(rnd),createDummyStreamStateHandle(rnd));
  }
  public static Map<StateHandleID,StreamStateHandle> createRandomStateHandleMap(  Random rnd){
    final int size=rnd.nextInt(4);
    Map<StateHandleID,StreamStateHandle> result=new HashMap<>(size);
    for (int i=0; i < size; ++i) {
      StateHandleID randomId=new StateHandleID(createRandomUUID(rnd).toString());
      StreamStateHandle stateHandle=createDummyStreamStateHandle(rnd);
      result.put(randomId,stateHandle);
    }
    return result;
  }
  public static KeyGroupsStateHandle createDummyKeyGroupStateHandle(  Random rnd){
    return new KeyGroupsStateHandle(new KeyGroupRangeOffsets(1,1,new long[]{rnd.nextInt(1024)}),createDummyStreamStateHandle(rnd));
  }
  public static StreamStateHandle createDummyStreamStateHandle(  Random rnd){
    return new ByteStreamStateHandle(String.valueOf(createRandomUUID(rnd)),String.valueOf(createRandomUUID(rnd)).getBytes(ConfigConstants.DEFAULT_CHARSET));
  }
  private static UUID createRandomUUID(  Random rnd){
    return new UUID(rnd.nextLong(),rnd.nextLong());
  }
}
