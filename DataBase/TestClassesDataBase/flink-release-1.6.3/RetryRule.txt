/** 
 * A rule to retry failed tests for a fixed number of times. <p>Add the  {@link RetryRule} to your test and annotate tests with {@link RetryOnFailure}. <pre> public class YourTest { {@literal @}Rule public RetryRule retryRule = new RetryRule(); {@literal @}Test {@literal @}RetryOnFailure(times=1) public void yourTest() { // This will be retried 1 time (total runs 2) before failing the test. throw new Exception("Failing test"); } } </pre>
 */
public class RetryRule implements TestRule {
  public static final Logger LOG=LoggerFactory.getLogger(RetryRule.class);
  @Override public Statement apply(  Statement statement,  Description description){
    RetryOnFailure retryOnFailure=description.getAnnotation(RetryOnFailure.class);
    RetryOnException retryOnException=description.getAnnotation(RetryOnException.class);
    if (retryOnFailure != null || retryOnException != null) {
      Test test=description.getAnnotation(Test.class);
      if (test.expected() != Test.None.class) {
        throw new IllegalArgumentException("You cannot combine the RetryOnFailure " + "annotation with the Test(expected) annotation.");
      }
    }
    if (retryOnFailure != null && retryOnException != null) {
      throw new IllegalArgumentException("You cannot combine the RetryOnFailure and RetryOnException annotations.");
    }
    if (retryOnFailure != null) {
      return new RetryOnFailureStatement(retryOnFailure.times(),statement);
    }
 else     if (retryOnException != null) {
      return new RetryOnExceptionStatement(retryOnException.times(),retryOnException.exception(),statement);
    }
 else {
      return statement;
    }
  }
  /** 
 * Retries a test in case of a failure.
 */
private static class RetryOnFailureStatement extends Statement {
    private final int timesOnFailure;
    private int currentRun;
    private final Statement statement;
    private RetryOnFailureStatement(    int timesOnFailure,    Statement statement){
      if (timesOnFailure < 0) {
        throw new IllegalArgumentException("Negatives number of retries on failure");
      }
      this.timesOnFailure=timesOnFailure;
      this.statement=statement;
    }
    /** 
 * Retry a test in case of a failure.
 * @throws Throwable
 */
    @Override public void evaluate() throws Throwable {
      for (currentRun=0; currentRun <= timesOnFailure; currentRun++) {
        try {
          statement.evaluate();
          break;
        }
 catch (        Throwable t) {
          LOG.warn(String.format("Test run failed (%d/%d).",currentRun,timesOnFailure + 1),t);
          if (currentRun == timesOnFailure) {
            throw t;
          }
        }
      }
    }
  }
  /** 
 * Retries a test in case of a failure.
 */
private static class RetryOnExceptionStatement extends Statement {
    private final Class<? extends Throwable> exceptionClass;
    private final int timesOnFailure;
    private final Statement statement;
    private int currentRun;
    private RetryOnExceptionStatement(    int timesOnFailure,    Class<? extends Throwable> exceptionClass,    Statement statement){
      if (timesOnFailure < 0) {
        throw new IllegalArgumentException("Negatives number of retries on failure");
      }
      if (exceptionClass == null) {
        throw new NullPointerException("exceptionClass");
      }
      this.exceptionClass=(exceptionClass);
      this.timesOnFailure=timesOnFailure;
      this.statement=statement;
    }
    /** 
 * Retry a test in case of a failure with a specific exception.
 * @throws Throwable
 */
    @Override public void evaluate() throws Throwable {
      for (currentRun=0; currentRun <= timesOnFailure; currentRun++) {
        try {
          statement.evaluate();
          break;
        }
 catch (        Throwable t) {
          LOG.warn(String.format("Test run failed (%d/%d).",currentRun,timesOnFailure + 1),t);
          if (!exceptionClass.isAssignableFrom(t.getClass()) || currentRun >= timesOnFailure) {
            throw t;
          }
        }
      }
    }
  }
}
