/** 
 * A simple  {@link KeyedBroadcastProcessFunction} that verifies the contents of the broadcast state after recovery.
 */
private static class CheckingKeyedBroadcastFunction extends KeyedBroadcastProcessFunction<Long,Tuple2<Long,Long>,Tuple2<Long,Long>,Tuple2<Long,Long>> {
  private static final long serialVersionUID=1333992081671604521L;
  private final Map<Long,Long> expectedFirstState;
  private final Map<String,Long> expectedSecondState;
  private MapStateDescriptor<Long,Long> firstStateDesc;
  private MapStateDescriptor<String,Long> secondStateDesc;
  CheckingKeyedBroadcastFunction(  Map<Long,Long> firstState,  Map<String,Long> secondState){
    this.expectedFirstState=firstState;
    this.expectedSecondState=secondState;
  }
  @Override public void open(  Configuration parameters) throws Exception {
    super.open(parameters);
    firstStateDesc=new MapStateDescriptor<>("broadcast-state-1",BasicTypeInfo.LONG_TYPE_INFO,BasicTypeInfo.LONG_TYPE_INFO);
    secondStateDesc=new MapStateDescriptor<>("broadcast-state-2",BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.LONG_TYPE_INFO);
  }
  @Override public void processElement(  Tuple2<Long,Long> value,  ReadOnlyContext ctx,  Collector<Tuple2<Long,Long>> out) throws Exception {
    final Map<Long,Long> actualFirstState=new HashMap<>();
    for (    Map.Entry<Long,Long> entry : ctx.getBroadcastState(firstStateDesc).immutableEntries()) {
      actualFirstState.put(entry.getKey(),entry.getValue());
    }
    Assert.assertEquals(expectedFirstState,actualFirstState);
    final Map<String,Long> actualSecondState=new HashMap<>();
    for (    Map.Entry<String,Long> entry : ctx.getBroadcastState(secondStateDesc).immutableEntries()) {
      actualSecondState.put(entry.getKey(),entry.getValue());
    }
    Assert.assertEquals(expectedSecondState,actualSecondState);
    out.collect(value);
  }
  @Override public void processBroadcastElement(  Tuple2<Long,Long> value,  Context ctx,  Collector<Tuple2<Long,Long>> out) throws Exception {
  }
}
