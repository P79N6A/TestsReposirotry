/** 
 * Test cases for the interaction between ZooKeeper HA and the  {@link Dispatcher}.
 */
public class ZooKeeperHADispatcherTest extends TestLogger {
  private static final Time TIMEOUT=Time.seconds(10L);
  @Rule public final ZooKeeperResource zooKeeperResource=new ZooKeeperResource();
  @ClassRule public static final TemporaryFolder TEMPORARY_FOLDER=new TemporaryFolder();
  private static Configuration configuration;
  private static TestingRpcService rpcService;
  private static BlobServer blobServer;
  @Rule public TestName name=new TestName();
  private TestingFatalErrorHandler testingFatalErrorHandler;
  @BeforeClass public static void setupClass() throws IOException {
    configuration=new Configuration();
    configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH,TEMPORARY_FOLDER.newFolder().getAbsolutePath());
    rpcService=new TestingRpcService();
    blobServer=new BlobServer(configuration,new VoidBlobStore());
  }
  @Before public void setup() throws Exception {
    configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM,zooKeeperResource.getConnectString());
    testingFatalErrorHandler=new TestingFatalErrorHandler();
  }
  @After public void teardown() throws Exception {
    if (testingFatalErrorHandler != null) {
      testingFatalErrorHandler.rethrowError();
    }
  }
  @AfterClass public static void teardownClass() throws Exception {
    if (rpcService != null) {
      RpcUtils.terminateRpcService(rpcService,TIMEOUT);
      rpcService=null;
    }
    if (blobServer != null) {
      blobServer.close();
      blobServer=null;
    }
  }
  /** 
 * Tests that the  {@link Dispatcher} releases a locked {@link SubmittedJobGraph} if itlost the leadership.
 */
  @Test public void testSubmittedJobGraphRelease() throws Exception {
    final CuratorFramework client=ZooKeeperUtils.startCuratorFramework(configuration);
    final CuratorFramework otherClient=ZooKeeperUtils.startCuratorFramework(configuration);
    try (final TestingHighAvailabilityServices testingHighAvailabilityServices=new TestingHighAvailabilityServices()){
      testingHighAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client,configuration));
      final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore=ZooKeeperUtils.createSubmittedJobGraphs(otherClient,configuration);
      otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);
      final TestingLeaderElectionService leaderElectionService=new TestingLeaderElectionService();
      testingHighAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);
      final TestingDispatcher dispatcher=createDispatcher(testingHighAvailabilityServices,new TestingJobManagerRunnerFactory(new CompletableFuture<>(),new CompletableFuture<>(),CompletableFuture.completedFuture(null)));
      dispatcher.start();
      try {
        final DispatcherId expectedLeaderId=DispatcherId.generate();
        leaderElectionService.isLeader(expectedLeaderId.toUUID()).get();
        final DispatcherGateway dispatcherGateway=dispatcher.getSelfGateway(DispatcherGateway.class);
        final JobGraph nonEmptyJobGraph=DispatcherHATest.createNonEmptyJobGraph();
        final CompletableFuture<Acknowledge> submissionFuture=dispatcherGateway.submitJob(nonEmptyJobGraph,TIMEOUT);
        submissionFuture.get();
        Collection<JobID> jobIds=otherSubmittedJobGraphStore.getJobIds();
        final JobID jobId=nonEmptyJobGraph.getJobID();
        assertThat(jobIds,Matchers.contains(jobId));
        leaderElectionService.notLeader();
        final CompletableFuture<Void> jobTerminationFuture=dispatcher.getJobTerminationFuture(jobId,TIMEOUT);
        jobTerminationFuture.get();
        final SubmittedJobGraph submittedJobGraph=otherSubmittedJobGraphStore.recoverJobGraph(jobId);
        assertThat(submittedJobGraph,is(notNullValue()));
        otherSubmittedJobGraphStore.removeJobGraph(jobId);
        jobIds=otherSubmittedJobGraphStore.getJobIds();
        assertThat(jobIds,Matchers.not(Matchers.contains(jobId)));
      }
  finally {
        RpcUtils.terminateRpcEndpoint(dispatcher,TIMEOUT);
        client.close();
        otherClient.close();
      }
    }
   }
  /** 
 * Tests that a standby Dispatcher does not interfere with the clean up of a completed job.
 */
  @Test public void testStandbyDispatcherJobExecution() throws Exception {
    try (final TestingHighAvailabilityServices haServices1=new TestingHighAvailabilityServices();final TestingHighAvailabilityServices haServices2=new TestingHighAvailabilityServices();final CuratorFramework curatorFramework=ZooKeeperUtils.startCuratorFramework(configuration)){
      final ZooKeeperSubmittedJobGraphStore submittedJobGraphStore1=ZooKeeperUtils.createSubmittedJobGraphs(curatorFramework,configuration);
      haServices1.setSubmittedJobGraphStore(submittedJobGraphStore1);
      final TestingLeaderElectionService leaderElectionService1=new TestingLeaderElectionService();
      haServices1.setDispatcherLeaderElectionService(leaderElectionService1);
      final ZooKeeperSubmittedJobGraphStore submittedJobGraphStore2=ZooKeeperUtils.createSubmittedJobGraphs(curatorFramework,configuration);
      haServices2.setSubmittedJobGraphStore(submittedJobGraphStore2);
      final TestingLeaderElectionService leaderElectionService2=new TestingLeaderElectionService();
      haServices2.setDispatcherLeaderElectionService(leaderElectionService2);
      final CompletableFuture<JobGraph> jobGraphFuture=new CompletableFuture<>();
      final CompletableFuture<ArchivedExecutionGraph> resultFuture=new CompletableFuture<>();
      final TestingDispatcher dispatcher1=createDispatcher(haServices1,new TestingJobManagerRunnerFactory(jobGraphFuture,resultFuture,CompletableFuture.completedFuture(null)));
      final TestingDispatcher dispatcher2=createDispatcher(haServices2,new TestingJobManagerRunnerFactory(new CompletableFuture<>(),new CompletableFuture<>(),CompletableFuture.completedFuture(null)));
      try {
        dispatcher1.start();
        dispatcher2.start();
        leaderElectionService1.isLeader(UUID.randomUUID()).get();
        final DispatcherGateway dispatcherGateway1=dispatcher1.getSelfGateway(DispatcherGateway.class);
        final JobGraph jobGraph=DispatcherHATest.createNonEmptyJobGraph();
        dispatcherGateway1.submitJob(jobGraph,TIMEOUT).get();
        final CompletableFuture<JobResult> jobResultFuture=dispatcherGateway1.requestJobResult(jobGraph.getJobID(),TIMEOUT);
        jobGraphFuture.get();
        resultFuture.complete(new ArchivedExecutionGraphBuilder().setJobID(jobGraph.getJobID()).setState(JobStatus.FINISHED).build());
        final JobResult jobResult=jobResultFuture.get();
        assertThat(jobResult.isSuccess(),is(true));
        dispatcher1.getJobTerminationFuture(jobGraph.getJobID(),TIMEOUT).get();
        leaderElectionService1.notLeader();
        leaderElectionService2.isLeader(UUID.randomUUID()).get();
        final DispatcherGateway dispatcherGateway2=dispatcher2.getSelfGateway(DispatcherGateway.class);
        assertThat(dispatcherGateway2.listJobs(TIMEOUT).get(),is(empty()));
      }
  finally {
        RpcUtils.terminateRpcEndpoint(dispatcher1,TIMEOUT);
        RpcUtils.terminateRpcEndpoint(dispatcher2,TIMEOUT);
      }
    }
   }
  /** 
 * Tests that a standby  {@link Dispatcher} can recover all submitted jobs.
 */
  @Test public void testStandbyDispatcherJobRecovery() throws Exception {
    try (CuratorFramework curatorFramework=ZooKeeperUtils.startCuratorFramework(configuration)){
      HighAvailabilityServices haServices=null;
      Dispatcher dispatcher1=null;
      Dispatcher dispatcher2=null;
      try {
        haServices=new ZooKeeperHaServices(curatorFramework,rpcService.getExecutor(),configuration,new VoidBlobStore());
        final CompletableFuture<JobGraph> jobGraphFuture1=new CompletableFuture<>();
        dispatcher1=createDispatcher(haServices,new TestingJobManagerRunnerFactory(jobGraphFuture1,new CompletableFuture<>(),CompletableFuture.completedFuture(null)));
        final CompletableFuture<JobGraph> jobGraphFuture2=new CompletableFuture<>();
        dispatcher2=createDispatcher(haServices,new TestingJobManagerRunnerFactory(jobGraphFuture2,new CompletableFuture<>(),CompletableFuture.completedFuture(null)));
        dispatcher1.start();
        dispatcher2.start();
        final LeaderConnectionInfo leaderConnectionInfo=LeaderRetrievalUtils.retrieveLeaderConnectionInfo(haServices.getDispatcherLeaderRetriever(),TIMEOUT);
        final DispatcherGateway dispatcherGateway=rpcService.connect(leaderConnectionInfo.getAddress(),DispatcherId.fromUuid(leaderConnectionInfo.getLeaderSessionID()),DispatcherGateway.class).get();
        final JobGraph nonEmptyJobGraph=DispatcherHATest.createNonEmptyJobGraph();
        dispatcherGateway.submitJob(nonEmptyJobGraph,TIMEOUT).get();
        if (dispatcher1.getAddress().equals(leaderConnectionInfo.getAddress())) {
          dispatcher1.shutDown();
          assertThat(jobGraphFuture2.get().getJobID(),is(equalTo(nonEmptyJobGraph.getJobID())));
        }
 else {
          dispatcher2.shutDown();
          assertThat(jobGraphFuture1.get().getJobID(),is(equalTo(nonEmptyJobGraph.getJobID())));
        }
      }
  finally {
        if (dispatcher1 != null) {
          RpcUtils.terminateRpcEndpoint(dispatcher1,TIMEOUT);
        }
        if (dispatcher2 != null) {
          RpcUtils.terminateRpcEndpoint(dispatcher2,TIMEOUT);
        }
        if (haServices != null) {
          haServices.close();
        }
      }
    }
   }
  @Nonnull private TestingDispatcher createDispatcher(  HighAvailabilityServices highAvailabilityServices,  Dispatcher.JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {
    return new TestingDispatcher(rpcService,Dispatcher.DISPATCHER_NAME + '_' + name.getMethodName()+ UUID.randomUUID(),configuration,highAvailabilityServices,new TestingResourceManagerGateway(),blobServer,new HeartbeatServices(1000L,1000L),UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),null,new MemoryArchivedExecutionGraphStore(),jobManagerRunnerFactory,testingFatalErrorHandler);
  }
}
