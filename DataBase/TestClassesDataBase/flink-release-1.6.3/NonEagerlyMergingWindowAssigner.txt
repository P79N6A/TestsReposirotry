/** 
 * A special  {@link MergingWindowAssigner} that let's windows get larger which leads to windowsbeing merged lazily.
 */
static class NonEagerlyMergingWindowAssigner extends MergingWindowAssigner<Object,TimeWindow> {
  private static final long serialVersionUID=1L;
  protected long sessionTimeout;
  public NonEagerlyMergingWindowAssigner(  long sessionTimeout){
    this.sessionTimeout=sessionTimeout;
  }
  @Override public Collection<TimeWindow> assignWindows(  Object element,  long timestamp,  WindowAssignerContext context){
    return Collections.singletonList(new TimeWindow(timestamp,timestamp + sessionTimeout));
  }
  @Override public Trigger<Object,TimeWindow> getDefaultTrigger(  StreamExecutionEnvironment env){
    return EventTimeTrigger.create();
  }
  @Override public TypeSerializer<TimeWindow> getWindowSerializer(  ExecutionConfig executionConfig){
    return new TimeWindow.Serializer();
  }
  @Override public boolean isEventTime(){
    return true;
  }
  /** 
 * Merge overlapping  {@link TimeWindow}s.
 */
  public void mergeWindows(  Collection<TimeWindow> windows,  MergingWindowAssigner.MergeCallback<TimeWindow> c){
    TimeWindow earliestStart=null;
    for (    TimeWindow win : windows) {
      if (earliestStart == null) {
        earliestStart=win;
      }
 else       if (win.getStart() < earliestStart.getStart()) {
        earliestStart=win;
      }
    }
    List<TimeWindow> associatedWindows=new ArrayList<>();
    for (    TimeWindow win : windows) {
      if (win.getStart() < earliestStart.getEnd() && win.getStart() >= earliestStart.getStart()) {
        associatedWindows.add(win);
      }
    }
    TimeWindow target=new TimeWindow(earliestStart.getStart(),earliestStart.getEnd() + 1);
    if (associatedWindows.size() > 1) {
      c.merge(associatedWindows,target);
    }
  }
}
