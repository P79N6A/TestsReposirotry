/** 
 * This test delegates to instances of  {@link EventTimeWindowCheckpointingITCase} that have been reconfiguredto use local recovery. <p>TODO: This class must be refactored to properly extend  {@link EventTimeWindowCheckpointingITCase}.
 */
@RunWith(Parameterized.class) public class LocalRecoveryITCase extends TestLogger {
  private final boolean localRecoveryEnabled=true;
  @Rule public TestName testName=new TestName();
  @Parameterized.Parameter public StateBackendEnum backendEnum;
  @Parameterized.Parameters(name="statebackend type ={0}") public static Collection<StateBackendEnum> parameter(){
    return Arrays.asList(ROCKSDB_FULLY_ASYNC,ROCKSDB_INCREMENTAL_ZK,FILE_ASYNC);
  }
  @Test public final void executeTest() throws Exception {
    EventTimeWindowCheckpointingITCase.tempFolder.create();
    EventTimeWindowCheckpointingITCase windowChkITCase=new EventTimeWindowCheckpointingITCase(){
      @Override protected StateBackendEnum getStateBackend(){
        return backendEnum;
      }
      @Override protected Configuration createClusterConfig() throws IOException {
        Configuration config=super.createClusterConfig();
        config.setBoolean(CheckpointingOptions.LOCAL_RECOVERY,localRecoveryEnabled);
        return config;
      }
    }
;
    executeTest(windowChkITCase);
  }
  private void executeTest(  EventTimeWindowCheckpointingITCase delegate) throws Exception {
    delegate.name=testName;
    try {
      delegate.setupTestCluster();
      try {
        delegate.testTumblingTimeWindow();
        delegate.stopTestCluster();
      }
 catch (      Exception e) {
        delegate.stopTestCluster();
      }
      delegate.setupTestCluster();
      try {
        delegate.testSlidingTimeWindow();
        delegate.stopTestCluster();
      }
 catch (      Exception e) {
        delegate.stopTestCluster();
      }
    }
  finally {
      delegate.tempFolder.delete();
    }
  }
}
