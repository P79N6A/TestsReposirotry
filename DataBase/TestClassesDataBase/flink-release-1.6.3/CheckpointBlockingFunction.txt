private static class CheckpointBlockingFunction extends RichMapFunction<String,String> implements CheckpointedFunction {
  static AtomicInteger allowedInitializeCallsWithoutRestore=new AtomicInteger(1);
  static AtomicInteger illegalRestores=new AtomicInteger(0);
  static AtomicInteger successfulRestores=new AtomicInteger(0);
  static AtomicBoolean afterMessWithZooKeeper=new AtomicBoolean(false);
  static AtomicBoolean failedAlready=new AtomicBoolean(false);
  private final ValueStateDescriptor<String> stateDescriptor=new ValueStateDescriptor<>("state",StringSerializer.INSTANCE);
  @Override public String map(  String value) throws Exception {
    getRuntimeContext().getState(stateDescriptor).update("42");
    return value;
  }
  @Override public void snapshotState(  FunctionSnapshotContext context) throws Exception {
    if (context.getCheckpointId() > 5) {
      waitForCheckpointLatch.trigger();
      failInCheckpointLatch.await();
      if (!failedAlready.getAndSet(true)) {
        throw new RuntimeException("Failing on purpose.");
      }
    }
  }
  @Override public void initializeState(  FunctionInitializationContext context){
    if (!context.isRestored()) {
      int updatedValue=allowedInitializeCallsWithoutRestore.decrementAndGet();
      if (updatedValue < 0) {
        illegalRestores.getAndIncrement();
        throw new RuntimeException("We are not allowed any more restores.");
      }
    }
 else {
      if (!afterMessWithZooKeeper.get()) {
        illegalRestores.getAndIncrement();
      }
 else       if (successfulRestores.getAndIncrement() > 0) {
        illegalRestores.getAndIncrement();
      }
    }
  }
}
