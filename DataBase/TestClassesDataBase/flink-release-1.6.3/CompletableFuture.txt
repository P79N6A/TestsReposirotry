static class CompletableFuture<T> implements Future<T> {
  private Exception exception=null;
  private T value=null;
  private Object lock=new Object();
  @Override public boolean cancel(  boolean mayInterruptIfRunning){
synchronized (lock) {
      if (isDone()) {
        return false;
      }
 else {
        exception=new CancellationException("Future was cancelled.");
        lock.notifyAll();
        return true;
      }
    }
  }
  @Override public boolean isCancelled(){
    return exception instanceof CancellationException;
  }
  @Override public boolean isDone(){
    return value != null || exception != null;
  }
  @Override public T get() throws InterruptedException, ExecutionException {
    while (!isDone() && !isCancelled()) {
synchronized (lock) {
        lock.wait();
      }
    }
    if (exception != null) {
      throw new ExecutionException(exception);
    }
 else     if (value != null) {
      return value;
    }
 else {
      throw new ExecutionException(new Exception("Future did not complete correctly."));
    }
  }
  @Override public T get(  long timeout,  TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    long timeoutMs=unit.toMillis(timeout);
    long timeoutEnd=timeoutMs + System.currentTimeMillis();
    while (!isDone() && !isCancelled() && timeoutMs > 0) {
synchronized (lock) {
        lock.wait(unit.toMillis(timeoutMs));
      }
      timeoutMs=timeoutEnd - System.currentTimeMillis();
    }
    if (exception != null) {
      throw new ExecutionException(exception);
    }
 else     if (value != null) {
      return value;
    }
 else {
      throw new ExecutionException(new Exception("Future did not complete correctly."));
    }
  }
  public boolean complete(  T value){
synchronized (lock) {
      if (!isDone()) {
        this.value=value;
        lock.notifyAll();
        return true;
      }
 else {
        return false;
      }
    }
  }
  public boolean fail(  Exception exception){
synchronized (lock) {
      if (!isDone()) {
        this.exception=exception;
        lock.notifyAll();
        return true;
      }
 else {
        return false;
      }
    }
  }
}
