private static final class TestingSlotPoolSlotProvider implements TestingSlotProvider {
  private final TestingSlotPool slotPool;
  private final SlotProvider slotProvider;
  private final AtomicInteger numberOfLocalizedAssignments;
  private final AtomicInteger numberOfNonLocalizedAssignments;
  private final AtomicInteger numberOfUnconstrainedAssignments;
  private final AtomicInteger numberOfHostLocalizedAssignments;
  private TestingSlotPoolSlotProvider(  TestingSlotPool slotPool){
    this.slotPool=Preconditions.checkNotNull(slotPool);
    this.slotProvider=slotPool.getSlotProvider();
    this.numberOfLocalizedAssignments=new AtomicInteger();
    this.numberOfNonLocalizedAssignments=new AtomicInteger();
    this.numberOfUnconstrainedAssignments=new AtomicInteger();
    this.numberOfHostLocalizedAssignments=new AtomicInteger();
  }
  @Override public TaskManagerLocation addTaskManager(  int numberSlots){
    final TaskManagerLocation taskManagerLocation=new LocalTaskManagerLocation();
    final ResourceID resourceId=taskManagerLocation.getResourceID();
    final SlotPoolGateway slotPoolGateway=slotPool.getSelfGateway(SlotPoolGateway.class);
    try {
      slotPoolGateway.registerTaskManager(resourceId).get();
    }
 catch (    Exception e) {
      throw new RuntimeException("Unexpected exception occurred. This indicates a programming bug.",e);
    }
    final TaskManagerGateway taskManagerGateway=new SimpleAckingTaskManagerGateway();
    final Collection<SlotOffer> slotOffers=new ArrayList<>(numberSlots);
    for (int i=0; i < numberSlots; i++) {
      final SlotOffer slotOffer=new SlotOffer(new AllocationID(),i,ResourceProfile.UNKNOWN);
      slotOffers.add(slotOffer);
    }
    final Collection<SlotOffer> acceptedSlotOffers;
    try {
      acceptedSlotOffers=slotPoolGateway.offerSlots(taskManagerLocation,taskManagerGateway,slotOffers).get();
    }
 catch (    Exception e) {
      throw new RuntimeException("Unexpected exception occurred. This indicates a programming bug.",e);
    }
    Preconditions.checkState(acceptedSlotOffers.size() == numberSlots);
    return taskManagerLocation;
  }
  @Override public void releaseTaskManager(  ResourceID resourceId){
    try {
      slotPool.releaseTaskManager(resourceId,null).get();
    }
 catch (    Exception e) {
      throw new RuntimeException("Should not have happened.",e);
    }
  }
  @Override public int getNumberOfAvailableSlots(){
    try {
      return slotPool.getNumberOfAvailableSlots().get();
    }
 catch (    Exception e) {
      throw new RuntimeException("Should not have happened.",e);
    }
  }
  @Override public int getNumberOfLocalizedAssignments(){
    return numberOfLocalizedAssignments.get();
  }
  @Override public int getNumberOfNonLocalizedAssignments(){
    return numberOfNonLocalizedAssignments.get();
  }
  @Override public int getNumberOfUnconstrainedAssignments(){
    return numberOfUnconstrainedAssignments.get();
  }
  @Override public int getNumberOfHostLocalizedAssignments(){
    return numberOfHostLocalizedAssignments.get();
  }
  @Override public int getNumberOfSlots(  SlotSharingGroup slotSharingGroup){
    try {
      return slotPool.getNumberOfSharedSlots(slotSharingGroup.getSlotSharingGroupId()).get();
    }
 catch (    Exception e) {
      throw new RuntimeException("Should not have happened.",e);
    }
  }
  @Override public int getNumberOfAvailableSlotsForGroup(  SlotSharingGroup slotSharingGroup,  JobVertexID jobVertexId){
    try {
      return slotPool.getNumberOfAvailableSlotsForGroup(slotSharingGroup.getSlotSharingGroupId(),jobVertexId).get();
    }
 catch (    Exception e) {
      throw new RuntimeException("Should not have happened.",e);
    }
  }
  @Override public void shutdown() throws Exception {
    RpcUtils.terminateRpcEndpoint(slotPool,TestingUtils.TIMEOUT());
  }
  @Override public CompletableFuture<LogicalSlot> allocateSlot(  SlotRequestId slotRequestId,  ScheduledUnit task,  boolean allowQueued,  SlotProfile slotProfile,  Time allocationTimeout){
    return slotProvider.allocateSlot(task,allowQueued,slotProfile,allocationTimeout).thenApply((    LogicalSlot logicalSlot) -> {
switch (logicalSlot.getLocality()) {
case LOCAL:
        numberOfLocalizedAssignments.incrementAndGet();
      break;
case UNCONSTRAINED:
    numberOfUnconstrainedAssignments.incrementAndGet();
  break;
case NON_LOCAL:
numberOfNonLocalizedAssignments.incrementAndGet();
break;
case HOST_LOCAL:
numberOfHostLocalizedAssignments.incrementAndGet();
break;
default :
}
return logicalSlot;
}
);
}
@Override public CompletableFuture<Acknowledge> cancelSlotRequest(SlotRequestId slotRequestId,@Nullable SlotSharingGroupId slotSharingGroupId,Throwable cause){
return CompletableFuture.completedFuture(Acknowledge.get());
}
}
