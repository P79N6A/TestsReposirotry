/** 
 * Tests for the encoding / decoding of storage location references.
 */
public class FsStorageLocationReferenceTest extends TestLogger {
  @Test public void testEncodeAndDecode() throws Exception {
    final Path path=randomPath(new Random());
    try {
      CheckpointStorageLocationReference ref=encodePathAsReference(path);
      Path decoded=decodePathFromReference(ref);
      assertEquals(path,decoded);
    }
 catch (    Exception|Error e) {
      log.error("ERROR FOR PATH " + path);
      throw e;
    }
  }
  @Test(expected=IllegalArgumentException.class) public void testDecodingTooShortReference(){
    decodePathFromReference(new CheckpointStorageLocationReference(new byte[2]));
  }
  @Test(expected=IllegalArgumentException.class) public void testDecodingGarbage(){
    final byte[] bytes=new byte[]{0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C};
    decodePathFromReference(new CheckpointStorageLocationReference(bytes));
  }
  @Test(expected=IllegalArgumentException.class) public void testDecodingDefaultReference(){
    decodePathFromReference(CheckpointStorageLocationReference.getDefault());
  }
  private static Path randomPath(  Random rnd){
    final StringBuilder path=new StringBuilder();
    path.append(StringUtils.getRandomString(rnd,1,5,'a','z'));
    path.append("://");
    path.append(StringUtils.getRandomString(rnd,10,20));
    path.append(rnd.nextInt(50000) + 1);
    for (int i=rnd.nextInt(5) + 1; i > 0; i--) {
      path.append('/');
      path.append(StringUtils.getRandomString(rnd,3,15));
    }
    return new Path(path.toString());
  }
}
