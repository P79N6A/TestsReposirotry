public class ClientTransportErrorHandlingTest {
  /** 
 * Verifies that failed client requests via  {@link PartitionRequestClient} are correctlyattributed to the respective  {@link RemoteInputChannel}.
 */
  @Test public void testExceptionOnWrite() throws Exception {
    NettyProtocol protocol=new NettyProtocol(mock(ResultPartitionProvider.class),mock(TaskEventDispatcher.class),true){
      @Override public ChannelHandler[] getServerChannelHandlers(){
        return new ChannelHandler[0];
      }
    }
;
    NettyServerAndClient serverAndClient=initServerAndClient(protocol,createConfig());
    Channel ch=connect(serverAndClient);
    NetworkClientHandler handler=getClientHandler(ch);
    ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter(){
      int writeNum=0;
      @Override public void write(      ChannelHandlerContext ctx,      Object msg,      ChannelPromise promise) throws Exception {
        if (writeNum >= 1) {
          throw new RuntimeException("Expected test exception.");
        }
        writeNum++;
        ctx.write(msg,promise);
      }
    }
);
    PartitionRequestClient requestClient=new PartitionRequestClient(ch,handler,mock(ConnectionID.class),mock(PartitionRequestClientFactory.class));
    RemoteInputChannel[] rich=new RemoteInputChannel[]{createRemoteInputChannel(),createRemoteInputChannel()};
    final CountDownLatch sync=new CountDownLatch(1);
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        sync.countDown();
        return null;
      }
    }
).when(rich[1]).onError(isA(LocalTransportException.class));
    ChannelFuture f=requestClient.requestSubpartition(new ResultPartitionID(),0,rich[0],0);
    assertTrue(f.await().isSuccess());
    f=requestClient.requestSubpartition(new ResultPartitionID(),0,rich[1],0);
    assertFalse(f.await().isSuccess());
    verify(rich[0],times(0)).onError(any(LocalTransportException.class));
    if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(),TimeUnit.MILLISECONDS)) {
      fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about the channel error.");
    }
    shutdown(serverAndClient);
  }
  /** 
 * Verifies that  {@link NettyMessage.ErrorResponse} messages are correctly wrapped in{@link RemoteTransportException} instances.
 */
  @Test public void testWrappingOfRemoteErrorMessage() throws Exception {
    EmbeddedChannel ch=createEmbeddedChannel();
    NetworkClientHandler handler=getClientHandler(ch);
    RemoteInputChannel[] rich=new RemoteInputChannel[]{createRemoteInputChannel(),createRemoteInputChannel()};
    for (    RemoteInputChannel r : rich) {
      when(r.getInputChannelId()).thenReturn(new InputChannelID());
      handler.addInputChannel(r);
    }
    ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(new RuntimeException("Expected test exception"),rich[0].getInputChannelId()));
    try {
      ch.checkException();
    }
 catch (    Exception e) {
      fail("The exception reached the end of the pipeline and " + "was not handled correctly by the last handler.");
    }
    verify(rich[0],times(1)).onError(isA(RemoteTransportException.class));
    verify(rich[1],never()).onError(any(Throwable.class));
    ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(new RuntimeException("Expected test exception")));
    try {
      ch.checkException();
    }
 catch (    Exception e) {
      fail("The exception reached the end of the pipeline and " + "was not handled correctly by the last handler.");
    }
    verify(rich[0],times(2)).onError(isA(RemoteTransportException.class));
    verify(rich[1],times(1)).onError(isA(RemoteTransportException.class));
  }
  /** 
 * Verifies that unexpected remote closes are reported as an instance of {@link RemoteTransportException}.
 */
  @Test public void testExceptionOnRemoteClose() throws Exception {
    NettyProtocol protocol=new NettyProtocol(mock(ResultPartitionProvider.class),mock(TaskEventDispatcher.class),true){
      @Override public ChannelHandler[] getServerChannelHandlers(){
        return new ChannelHandler[]{new ChannelInboundHandlerAdapter(){
          @Override public void channelRead(          ChannelHandlerContext ctx,          Object msg) throws Exception {
            ctx.channel().close();
          }
        }
};
      }
    }
;
    NettyServerAndClient serverAndClient=initServerAndClient(protocol,createConfig());
    Channel ch=connect(serverAndClient);
    NetworkClientHandler handler=getClientHandler(ch);
    RemoteInputChannel[] rich=new RemoteInputChannel[]{createRemoteInputChannel(),createRemoteInputChannel()};
    final CountDownLatch sync=new CountDownLatch(rich.length);
    Answer<Void> countDownLatch=new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        sync.countDown();
        return null;
      }
    }
;
    for (    RemoteInputChannel r : rich) {
      doAnswer(countDownLatch).when(r).onError(any(Throwable.class));
      handler.addInputChannel(r);
    }
    ch.writeAndFlush(Unpooled.buffer().writerIndex(16));
    if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(),TimeUnit.MILLISECONDS)) {
      fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about remote connection close.");
    }
    for (    RemoteInputChannel r : rich) {
      verify(r).onError(isA(RemoteTransportException.class));
    }
    shutdown(serverAndClient);
  }
  /** 
 * Verifies that fired Exceptions are handled correctly by the pipeline.
 */
  @Test public void testExceptionCaught() throws Exception {
    EmbeddedChannel ch=createEmbeddedChannel();
    NetworkClientHandler handler=getClientHandler(ch);
    RemoteInputChannel[] rich=new RemoteInputChannel[]{createRemoteInputChannel(),createRemoteInputChannel()};
    for (    RemoteInputChannel r : rich) {
      when(r.getInputChannelId()).thenReturn(new InputChannelID());
      handler.addInputChannel(r);
    }
    ch.pipeline().fireExceptionCaught(new Exception());
    try {
      ch.checkException();
    }
 catch (    Exception e) {
      fail("The exception reached the end of the pipeline and " + "was not handled correctly by the last handler.");
    }
    for (    RemoteInputChannel r : rich) {
      verify(r).onError(isA(LocalTransportException.class));
    }
  }
  /** 
 * Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as an instance of  {@link RemoteTransportException}.
 */
  @Test public void testConnectionResetByPeer() throws Throwable {
    EmbeddedChannel ch=createEmbeddedChannel();
    NetworkClientHandler handler=getClientHandler(ch);
    RemoteInputChannel rich=addInputChannel(handler);
    final Throwable[] error=new Throwable[1];
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        Throwable cause=(Throwable)invocation.getArguments()[0];
        try {
          assertEquals(RemoteTransportException.class,cause.getClass());
          assertNotEquals("Connection reset by peer",cause.getMessage());
          assertEquals(IOException.class,cause.getCause().getClass());
          assertEquals("Connection reset by peer",cause.getCause().getMessage());
        }
 catch (        Throwable t) {
          error[0]=t;
        }
        return null;
      }
    }
).when(rich).onError(any(Throwable.class));
    ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer"));
    assertNull(error[0]);
  }
  /** 
 * Verifies that the channel is closed if there is an error *during* error notification.
 */
  @Test public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {
    EmbeddedChannel ch=createEmbeddedChannel();
    NetworkClientHandler handler=getClientHandler(ch);
    RemoteInputChannel rich=addInputChannel(handler);
    doThrow(new RuntimeException("Expected test exception")).when(rich).onError(any(Throwable.class));
    ch.pipeline().fireExceptionCaught(new Exception());
    assertFalse(ch.isActive());
  }
  private EmbeddedChannel createEmbeddedChannel(){
    NettyProtocol protocol=new NettyProtocol(mock(ResultPartitionProvider.class),mock(TaskEventDispatcher.class),true);
    return new EmbeddedChannel(protocol.getClientChannelHandlers());
  }
  private RemoteInputChannel addInputChannel(  NetworkClientHandler clientHandler) throws IOException {
    RemoteInputChannel rich=createRemoteInputChannel();
    clientHandler.addInputChannel(rich);
    return rich;
  }
  private NetworkClientHandler getClientHandler(  Channel ch){
    return ch.pipeline().get(NetworkClientHandler.class);
  }
  private RemoteInputChannel createRemoteInputChannel(){
    return when(mock(RemoteInputChannel.class).getInputChannelId()).thenReturn(new InputChannelID()).getMock();
  }
}
