@SuppressWarnings("serial") public class ExecutionVertexCancelTest extends TestLogger {
  @Test public void testCancelFromCreated(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid);
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      assertEquals(ExecutionState.CREATED,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      assertNull(vertex.getFailureCause());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelFromScheduled(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid);
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      setVertexState(vertex,ExecutionState.SCHEDULED);
      assertEquals(ExecutionState.SCHEDULED,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      assertNull(vertex.getFailureCause());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelConcurrentlyToDeploying_CallsNotOvertaking(){
    try {
      final JobVertexID jid=new JobVertexID();
      final TestingUtils.QueuedActionExecutionContext executionContext=TestingUtils.queuedActionExecutionContext();
      final TestingUtils.ActionQueue actions=executionContext.actionQueue();
      final ExecutionJobVertex ejv=getExecutionVertex(jid,executionContext);
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      setVertexState(vertex,ExecutionState.SCHEDULED);
      assertEquals(ExecutionState.SCHEDULED,vertex.getExecutionState());
      ActorGateway actorGateway=new CancelSequenceActorGateway(executionContext,2);
      Instance instance=getInstance(new ActorTaskManagerGateway(actorGateway));
      SimpleSlot slot=instance.allocateSimpleSlot();
      vertex.deployToSlot(slot);
      assertEquals(ExecutionState.DEPLOYING,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      actions.triggerNextAction();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      actions.triggerNextAction();
      vertex.getCurrentExecutionAttempt().cancelingComplete();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      actions.triggerNextAction();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      assertTrue(slot.isReleased());
      assertNull(vertex.getFailureCause());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelConcurrentlyToDeploying_CallsOvertaking(){
    try {
      final JobVertexID jid=new JobVertexID();
      final TestingUtils.QueuedActionExecutionContext executionContext=TestingUtils.queuedActionExecutionContext();
      final TestingUtils.ActionQueue actions=executionContext.actionQueue();
      final ExecutionJobVertex ejv=getExecutionVertex(jid,executionContext);
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      setVertexState(vertex,ExecutionState.SCHEDULED);
      assertEquals(ExecutionState.SCHEDULED,vertex.getExecutionState());
      ActorGateway actorGateway=new CancelSequenceActorGateway(executionContext,2);
      Instance instance=getInstance(new ActorTaskManagerGateway(actorGateway));
      SimpleSlot slot=instance.allocateSimpleSlot();
      vertex.deployToSlot(slot);
      assertEquals(ExecutionState.DEPLOYING,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      Runnable deployAction=actions.popNextAction();
      Runnable cancelAction=actions.popNextAction();
      cancelAction.run();
      actions.triggerNextAction();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      deployAction.run();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      vertex.getCurrentExecutionAttempt().cancelingComplete();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      assertTrue(slot.isReleased());
      assertNull(vertex.getFailureCause());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelFromRunning(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid,new DirectScheduledExecutorService());
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      ActorGateway actorGateway=new CancelSequenceActorGateway(TestingUtils.directExecutionContext(),1);
      Instance instance=getInstance(new ActorTaskManagerGateway(actorGateway));
      SimpleSlot slot=instance.allocateSimpleSlot();
      setVertexResource(vertex,slot);
      setVertexState(vertex,ExecutionState.RUNNING);
      assertEquals(ExecutionState.RUNNING,vertex.getExecutionState());
      vertex.cancel();
      vertex.getCurrentExecutionAttempt().cancelingComplete();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      assertTrue(slot.isReleased());
      assertNull(vertex.getFailureCause());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testRepeatedCancelFromRunning(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid,new DirectScheduledExecutorService());
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      final ActorGateway actorGateway=new CancelSequenceActorGateway(TestingUtils.directExecutionContext(),1);
      Instance instance=getInstance(new ActorTaskManagerGateway(actorGateway));
      SimpleSlot slot=instance.allocateSimpleSlot();
      setVertexResource(vertex,slot);
      setVertexState(vertex,ExecutionState.RUNNING);
      assertEquals(ExecutionState.RUNNING,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      vertex.getCurrentExecutionAttempt().cancelingComplete();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      assertTrue(slot.isReleased());
      assertNull(vertex.getFailureCause());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelFromRunningDidNotFindTask(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid,new DirectScheduledExecutorService());
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      final ActorGateway actorGateway=new CancelSequenceActorGateway(TestingUtils.directExecutionContext(),1);
      Instance instance=getInstance(new ActorTaskManagerGateway(actorGateway));
      SimpleSlot slot=instance.allocateSimpleSlot();
      setVertexResource(vertex,slot);
      setVertexState(vertex,ExecutionState.RUNNING);
      assertEquals(ExecutionState.RUNNING,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELING,vertex.getExecutionState());
      assertNull(vertex.getFailureCause());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelCallFails(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid,new DirectScheduledExecutorService());
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      final ActorGateway gateway=new CancelSequenceActorGateway(TestingUtils.directExecutionContext(),0);
      Instance instance=getInstance(new ActorTaskManagerGateway(gateway));
      SimpleSlot slot=instance.allocateSimpleSlot();
      setVertexResource(vertex,slot);
      setVertexState(vertex,ExecutionState.RUNNING);
      assertEquals(ExecutionState.RUNNING,vertex.getExecutionState());
      vertex.cancel();
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      assertTrue(slot.isReleased());
      assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0);
      assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testSendCancelAndReceiveFail() throws Exception {
    final ExecutionGraph graph=ExecutionGraphTestUtils.createSimpleTestGraph();
    graph.scheduleForExecution();
    ExecutionGraphTestUtils.switchAllVerticesToRunning(graph);
    assertEquals(JobStatus.RUNNING,graph.getState());
    final ExecutionVertex[] vertices=graph.getVerticesTopologically().iterator().next().getTaskVertices();
    assertEquals(vertices.length,graph.getRegisteredExecutions().size());
    final Execution exec=vertices[3].getCurrentExecutionAttempt();
    exec.cancel();
    assertEquals(ExecutionState.CANCELING,exec.getState());
    exec.markFailed(new Exception("test"));
    assertTrue(exec.getState() == ExecutionState.FAILED || exec.getState() == ExecutionState.CANCELED);
    assertFalse(exec.getAssignedResource().isAlive());
    assertEquals(vertices.length - 1,exec.getVertex().getExecutionGraph().getRegisteredExecutions().size());
  }
  @Test public void testScheduleOrDeployAfterCancel(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid);
      final ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
      setVertexState(vertex,ExecutionState.CANCELED);
      assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
{
        Scheduler scheduler=mock(Scheduler.class);
        vertex.scheduleForExecution(scheduler,false,LocationPreferenceConstraint.ALL,Collections.emptySet());
        assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      }
      try {
        Instance instance=getInstance(new ActorTaskManagerGateway(DummyActorGateway.INSTANCE));
        SimpleSlot slot=instance.allocateSimpleSlot();
        vertex.deployToSlot(slot);
        fail("Method should throw an exception");
      }
 catch (      IllegalStateException e) {
        assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testActionsWhileCancelling(){
    try {
      final JobVertexID jid=new JobVertexID();
      final ExecutionJobVertex ejv=getExecutionVertex(jid);
      try {
        ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
        setVertexState(vertex,ExecutionState.CANCELING);
        Scheduler scheduler=mock(Scheduler.class);
        vertex.scheduleForExecution(scheduler,false,LocationPreferenceConstraint.ALL,Collections.emptySet());
      }
 catch (      Exception e) {
        fail("should not throw an exception");
      }
      try {
        ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
        setVertexState(vertex,ExecutionState.CANCELING);
        Instance instance=getInstance(new ActorTaskManagerGateway(DummyActorGateway.INSTANCE));
        SimpleSlot slot=instance.allocateSimpleSlot();
        vertex.deployToSlot(slot);
        fail("Method should throw an exception");
      }
 catch (      IllegalStateException e) {
      }
{
        ExecutionVertex vertex=new ExecutionVertex(ejv,0,new IntermediateResult[0],AkkaUtils.getDefaultTimeout());
        Instance instance=getInstance(new ActorTaskManagerGateway(DummyActorGateway.INSTANCE));
        SimpleSlot slot=instance.allocateSimpleSlot();
        setVertexResource(vertex,slot);
        setVertexState(vertex,ExecutionState.CANCELING);
        Exception failureCause=new Exception("test exception");
        vertex.fail(failureCause);
        assertEquals(ExecutionState.CANCELED,vertex.getExecutionState());
        assertTrue(slot.isReleased());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
public static class CancelSequenceActorGateway extends BaseTestingActorGateway {
    private final int successfulOperations;
    private int index=-1;
    public CancelSequenceActorGateway(    ExecutionContext executionContext,    int successfulOperations){
      super(executionContext);
      this.successfulOperations=successfulOperations;
    }
    @Override public Object handleMessage(    Object message) throws Exception {
      Object result;
      if (message instanceof SubmitTask) {
        result=Acknowledge.get();
      }
 else       if (message instanceof CancelTask) {
        index++;
        if (index >= successfulOperations) {
          throw new IOException("RPC call failed.");
        }
 else {
          result=Acknowledge.get();
        }
      }
 else {
        result=null;
      }
      return result;
    }
  }
}
