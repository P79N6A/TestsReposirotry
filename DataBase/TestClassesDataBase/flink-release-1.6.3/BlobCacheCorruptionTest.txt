/** 
 * Tests how GET requests react to corrupt files when downloaded via a  {@link BlobCacheService}. <p>Successful GET requests are tested in conjunction wit the PUT requests.
 */
public class BlobCacheCorruptionTest extends TestLogger {
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  @Rule public final ExpectedException exception=ExpectedException.none();
  @Test public void testGetFailsFromCorruptFile1() throws IOException {
    testGetFailsFromCorruptFile(null,TRANSIENT_BLOB,false);
  }
  @Test public void testGetFailsFromCorruptFile2() throws IOException {
    testGetFailsFromCorruptFile(new JobID(),TRANSIENT_BLOB,false);
  }
  @Test public void testGetFailsFromCorruptFile3() throws IOException {
    testGetFailsFromCorruptFile(new JobID(),PERMANENT_BLOB,false);
  }
  @Test public void testGetFailsFromCorruptFile4() throws IOException {
    testGetFailsFromCorruptFile(new JobID(),PERMANENT_BLOB,true);
  }
  /** 
 * Checks the GET operation fails when the downloaded file (from  {@link BlobServer} or HA store)is corrupt, i.e. its content's hash does not match the  {@link BlobKey}'s hash.
 * @param jobId job ID or <tt>null</tt> if job-unrelated
 * @param blobType whether the BLOB should become permanent or transient
 * @param corruptOnHAStore whether the file should be corrupt in the HA store (<tt>true</tt>, required <tt>highAvailability</tt> to be set) or on the  {@link BlobServer}'s local store (<tt>false</tt>)
 */
  private void testGetFailsFromCorruptFile(  final JobID jobId,  BlobKey.BlobType blobType,  boolean corruptOnHAStore) throws IOException {
    final Configuration config=new Configuration();
    config.setString(HighAvailabilityOptions.HA_MODE,"ZOOKEEPER");
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,temporaryFolder.newFolder().getPath());
    BlobStoreService blobStoreService=null;
    try {
      blobStoreService=BlobUtils.createBlobStoreFromConfig(config);
      testGetFailsFromCorruptFile(jobId,blobType,corruptOnHAStore,config,blobStoreService,exception);
    }
  finally {
      if (blobStoreService != null) {
        blobStoreService.closeAndCleanupAllData();
      }
    }
  }
  /** 
 * Checks the GET operation fails when the downloaded file (from HA store) is corrupt, i.e. its content's hash does not match the  {@link BlobKey}'s hash, using a permanent BLOB.
 * @param jobId job ID
 * @param config blob server configuration (including HA settings like  {@link HighAvailabilityOptions#HA_STORAGE_PATH}and  {@link HighAvailabilityOptions#HA_CLUSTER_ID}) used to set up <tt>blobStore</tt>
 * @param blobStore shared HA blob store to use
 * @param expectedException expected exception rule to use
 */
  public static void testGetFailsFromCorruptFile(  JobID jobId,  Configuration config,  BlobStore blobStore,  ExpectedException expectedException) throws IOException {
    testGetFailsFromCorruptFile(jobId,PERMANENT_BLOB,true,config,blobStore,expectedException);
  }
  /** 
 * Checks the GET operation fails when the downloaded file (from  {@link BlobServer} or HA store)is corrupt, i.e. its content's hash does not match the  {@link BlobKey}'s hash.
 * @param jobId job ID or <tt>null</tt> if job-unrelated
 * @param blobType whether the BLOB should become permanent or transient
 * @param corruptOnHAStore whether the file should be corrupt in the HA store (<tt>true</tt>, required <tt>highAvailability</tt> to be set) or on the  {@link BlobServer}'s local store (<tt>false</tt>)
 * @param config blob server configuration (including HA settings like  {@link HighAvailabilityOptions#HA_STORAGE_PATH}and  {@link HighAvailabilityOptions#HA_CLUSTER_ID}) used to set up <tt>blobStore</tt>
 * @param blobStore shared HA blob store to use
 * @param expectedException expected exception rule to use
 */
  private static void testGetFailsFromCorruptFile(  @Nullable JobID jobId,  BlobKey.BlobType blobType,  boolean corruptOnHAStore,  Configuration config,  BlobStore blobStore,  ExpectedException expectedException) throws IOException {
    assertTrue("corrupt HA file requires a HA setup",!corruptOnHAStore || blobType == PERMANENT_BLOB);
    Random rnd=new Random();
    try (BlobServer server=new BlobServer(config,blobStore);BlobCacheService cache=new BlobCacheService(config,corruptOnHAStore ? blobStore : new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      BlobKey key=put(server,jobId,data,blobType);
      assertNotNull(key);
      byte[] data2=Arrays.copyOf(data,data.length);
      data2[0]^=1;
      if (corruptOnHAStore) {
        File tmpFile=Files.createTempFile("blob",".jar").toFile();
        try {
          FileUtils.writeByteArrayToFile(tmpFile,data2);
          blobStore.put(tmpFile,jobId,key);
        }
  finally {
          tmpFile.delete();
        }
        File blobFile=server.getStorageLocation(jobId,key);
        assertTrue(blobFile.delete());
      }
 else {
        File blobFile=server.getStorageLocation(jobId,key);
        assertTrue(blobFile.exists());
        FileUtils.writeByteArrayToFile(blobFile,data2);
      }
      expectedException.expect(IOException.class);
      expectedException.expectCause(CoreMatchers.allOf(instanceOf(IOException.class),hasProperty("message",containsString("data corruption"))));
      get(cache,jobId,key);
    }
   }
}
