public class StateSnapshotCompressionTest extends TestLogger {
  @Test public void testCompressionConfiguration(){
    ExecutionConfig executionConfig=new ExecutionConfig();
    executionConfig.setUseSnapshotCompression(true);
    AbstractKeyedStateBackend<String> stateBackend=new HeapKeyedStateBackend<>(mock(TaskKvStateRegistry.class),StringSerializer.INSTANCE,StateSnapshotCompressionTest.class.getClassLoader(),16,new KeyGroupRange(0,15),true,executionConfig,TestLocalRecoveryConfig.disabled(),mock(HeapPriorityQueueSetFactory.class),TtlTimeProvider.DEFAULT);
    try {
      Assert.assertTrue(SnappyStreamCompressionDecorator.INSTANCE.equals(stateBackend.getKeyGroupCompressionDecorator()));
    }
  finally {
      IOUtils.closeQuietly(stateBackend);
      stateBackend.dispose();
    }
    executionConfig=new ExecutionConfig();
    executionConfig.setUseSnapshotCompression(false);
    stateBackend=new HeapKeyedStateBackend<>(mock(TaskKvStateRegistry.class),StringSerializer.INSTANCE,StateSnapshotCompressionTest.class.getClassLoader(),16,new KeyGroupRange(0,15),true,executionConfig,TestLocalRecoveryConfig.disabled(),mock(HeapPriorityQueueSetFactory.class),TtlTimeProvider.DEFAULT);
    try {
      Assert.assertTrue(UncompressedStreamCompressionDecorator.INSTANCE.equals(stateBackend.getKeyGroupCompressionDecorator()));
    }
  finally {
      IOUtils.closeQuietly(stateBackend);
      stateBackend.dispose();
    }
  }
  @Test public void snapshotRestoreRoundtripWithCompression() throws Exception {
    snapshotRestoreRoundtrip(true);
  }
  @Test public void snapshotRestoreRoundtripUncompressed() throws Exception {
    snapshotRestoreRoundtrip(false);
  }
  private void snapshotRestoreRoundtrip(  boolean useCompression) throws Exception {
    ExecutionConfig executionConfig=new ExecutionConfig();
    executionConfig.setUseSnapshotCompression(useCompression);
    KeyedStateHandle stateHandle=null;
    ValueStateDescriptor<String> stateDescriptor=new ValueStateDescriptor<>("test",String.class);
    stateDescriptor.initializeSerializerUnlessSet(executionConfig);
    AbstractKeyedStateBackend<String> stateBackend=new HeapKeyedStateBackend<>(mock(TaskKvStateRegistry.class),StringSerializer.INSTANCE,StateSnapshotCompressionTest.class.getClassLoader(),16,new KeyGroupRange(0,15),true,executionConfig,TestLocalRecoveryConfig.disabled(),mock(HeapPriorityQueueSetFactory.class),TtlTimeProvider.DEFAULT);
    try {
      InternalValueState<String,VoidNamespace,String> state=stateBackend.createInternalState(new VoidNamespaceSerializer(),stateDescriptor);
      stateBackend.setCurrentKey("A");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      state.update("42");
      stateBackend.setCurrentKey("B");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      state.update("43");
      stateBackend.setCurrentKey("C");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      state.update("44");
      stateBackend.setCurrentKey("D");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      state.update("45");
      CheckpointStreamFactory streamFactory=new MemCheckpointStreamFactory(4 * 1024 * 1024);
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=stateBackend.snapshot(0L,0L,streamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
      snapshot.run();
      SnapshotResult<KeyedStateHandle> snapshotResult=snapshot.get();
      stateHandle=snapshotResult.getJobManagerOwnedSnapshot();
    }
  finally {
      IOUtils.closeQuietly(stateBackend);
      stateBackend.dispose();
    }
    executionConfig=new ExecutionConfig();
    stateBackend=new HeapKeyedStateBackend<>(mock(TaskKvStateRegistry.class),StringSerializer.INSTANCE,StateSnapshotCompressionTest.class.getClassLoader(),16,new KeyGroupRange(0,15),true,executionConfig,TestLocalRecoveryConfig.disabled(),mock(HeapPriorityQueueSetFactory.class),TtlTimeProvider.DEFAULT);
    try {
      stateBackend.restore(StateObjectCollection.singleton(stateHandle));
      InternalValueState<String,VoidNamespace,String> state=stateBackend.createInternalState(new VoidNamespaceSerializer(),stateDescriptor);
      stateBackend.setCurrentKey("A");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      Assert.assertEquals("42",state.value());
      stateBackend.setCurrentKey("B");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      Assert.assertEquals("43",state.value());
      stateBackend.setCurrentKey("C");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      Assert.assertEquals("44",state.value());
      stateBackend.setCurrentKey("D");
      state.setCurrentNamespace(VoidNamespace.INSTANCE);
      Assert.assertEquals("45",state.value());
    }
  finally {
      IOUtils.closeQuietly(stateBackend);
      stateBackend.dispose();
    }
  }
}
