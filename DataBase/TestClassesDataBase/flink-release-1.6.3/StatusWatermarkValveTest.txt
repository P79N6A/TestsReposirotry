/** 
 * Tests for  {@link StatusWatermarkValve}. While tests in  {@link org.apache.flink.streaming.runtime.tasks.OneInputStreamTaskTest}and  {@link org.apache.flink.streaming.runtime.tasks.TwoInputStreamTaskTest} may also implicitly test {@link StatusWatermarkValve}and that valves are correctly used in the tasks' input processors, the unit tests here additionally makes sure that the watermarks and stream statuses to forward are generated from the valve at the exact correct times and in a deterministic behaviour. The unit tests here also test more complex stream status / watermark input cases. <p>The tests are performed by a series of watermark and stream status inputs to the valve. On every input method call, the output is checked to contain only the expected watermark or stream status, and nothing else. This ensures that no redundant outputs are generated by the output logic of  {@link StatusWatermarkValve}. The behaviours that a series of input calls to the valve is trying to test is explained as inline comments within the tests.
 */
public class StatusWatermarkValveTest {
  /** 
 * Tests that watermarks correctly advance with increasing watermarks for a single input valve.
 */
  @Test public void testSingleInputIncreasingWatermarks(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(1,valveOutput);
    valve.inputWatermark(new Watermark(0),0);
    assertEquals(new Watermark(0),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(25),0);
    assertEquals(new Watermark(25),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that watermarks do not advance with decreasing watermark inputs for a single input valve.
 */
  @Test public void testSingleInputDecreasingWatermarksYieldsNoOutput(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(1,valveOutput);
    valve.inputWatermark(new Watermark(25),0);
    assertEquals(new Watermark(25),valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(18),0);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(42),0);
    assertEquals(new Watermark(42),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that stream status toggling works correctly, as well as that non-toggling status inputs do not yield output for a single input valve.
 */
  @Test public void testSingleInputStreamStatusToggling(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(1,valveOutput);
    valve.inputStreamStatus(StreamStatus.ACTIVE,0);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,0);
    assertEquals(StreamStatus.IDLE,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,0);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.ACTIVE,0);
    assertEquals(StreamStatus.ACTIVE,valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that the watermark of an input channel remains intact while in the IDLE status.
 */
  @Test public void testSingleInputWatermarksIntactDuringIdleness(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(1,valveOutput);
    valve.inputWatermark(new Watermark(25),0);
    assertEquals(new Watermark(25),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,0);
    assertEquals(StreamStatus.IDLE,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(50),0);
    assertEquals(null,valveOutput.popLastSeenOutput());
    assertEquals(25,valve.getInputChannelStatus(0).watermark);
    valve.inputStreamStatus(StreamStatus.ACTIVE,0);
    assertEquals(StreamStatus.ACTIVE,valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(50),0);
    assertEquals(new Watermark(50),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that the valve yields a watermark only when all inputs have received a watermark.
 */
  @Test public void testMultipleInputYieldsWatermarkOnlyWhenAllChannelsReceivesWatermarks(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(0),0);
    valve.inputWatermark(new Watermark(0),1);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(0),2);
    assertEquals(new Watermark(0),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that new min watermark is emitted from the valve as soon as the overall new min watermark across inputs advances.
 */
  @Test public void testMultipleInputIncreasingWatermarks(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(0),0);
    valve.inputWatermark(new Watermark(0),1);
    valve.inputWatermark(new Watermark(0),2);
    assertEquals(new Watermark(0),valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(12),0);
    valve.inputWatermark(new Watermark(8),2);
    valve.inputWatermark(new Watermark(10),2);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(15),1);
    assertEquals(new Watermark(10),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(17),2);
    assertEquals(new Watermark(12),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(20),0);
    assertEquals(new Watermark(15),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that for a multiple input valve, decreasing watermarks will yield no output.
 */
  @Test public void testMultipleInputDecreasingWatermarksYieldsNoOutput(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(25),0);
    valve.inputWatermark(new Watermark(10),1);
    valve.inputWatermark(new Watermark(17),2);
    assertEquals(new Watermark(10),valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(12),0);
    valve.inputWatermark(new Watermark(8),1);
    valve.inputWatermark(new Watermark(15),2);
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that stream status toggling works correctly, as well as that non-toggling status inputs do not yield output for a multiple input valve.
 */
  @Test public void testMultipleInputStreamStatusToggling(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(2,valveOutput);
    valve.inputStreamStatus(StreamStatus.ACTIVE,0);
    valve.inputStreamStatus(StreamStatus.ACTIVE,1);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,1);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,0);
    assertEquals(StreamStatus.IDLE,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,0);
    valve.inputStreamStatus(StreamStatus.IDLE,1);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.ACTIVE,1);
    assertEquals(StreamStatus.ACTIVE,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.ACTIVE,0);
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that for multiple inputs, when some inputs are idle, the min watermark is correctly computed and advanced from the remaining active inputs.
 */
  @Test public void testMultipleInputWatermarkAdvancingWithPartiallyIdleChannels(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(15),0);
    valve.inputWatermark(new Watermark(10),1);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,2);
    assertEquals(new Watermark(10),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(18),1);
    assertEquals(new Watermark(15),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(20),0);
    assertEquals(new Watermark(18),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that as input channels individually and gradually become idle, watermarks are output as soon remaining active channels can yield a new min watermark.
 */
  @Test public void testMultipleInputWatermarkAdvancingAsChannelsIndividuallyBecomeIdle(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(25),0);
    valve.inputWatermark(new Watermark(10),1);
    valve.inputWatermark(new Watermark(17),2);
    assertEquals(new Watermark(10),valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,1);
    assertEquals(new Watermark(17),valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,2);
    assertEquals(new Watermark(25),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that when all inputs become idle, the max watermark across all channels is correctly "flushed" from the valve, as well as the stream status IDLE marker. <p>This test along with  {@link #testMultipleInputWatermarkAdvancingAsChannelsIndividuallyBecomeIdle}should completely verify that the eventual watermark advancement result when all inputs become idle is independent of the order that the inputs become idle.
 */
  @Test public void testMultipleInputFlushMaxWatermarkAndStreamStatusOnceAllInputsBecomeIdle(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(10),0);
    valve.inputWatermark(new Watermark(5),1);
    valve.inputWatermark(new Watermark(3),2);
    assertEquals(new Watermark(3),valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,0);
    valve.inputStreamStatus(StreamStatus.IDLE,1);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,2);
    assertEquals(new Watermark(10),valveOutput.popLastSeenOutput());
    assertEquals(StreamStatus.IDLE,valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Tests that when idle channels become active again, they need to "catch up" with the latest watermark before they are considered for min watermark computation again.
 */
  @Test public void testMultipleInputWatermarkRealignmentAfterResumeActive(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(10),0);
    valve.inputWatermark(new Watermark(7),1);
    valve.inputWatermark(new Watermark(3),2);
    assertEquals(new Watermark(3),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,2);
    assertEquals(new Watermark(7),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.ACTIVE,2);
    assertFalse(valve.getInputChannelStatus(2).isWatermarkAligned);
    valve.inputWatermark(new Watermark(5),2);
    assertEquals(5,valve.getInputChannelStatus(2).watermark);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(9),2);
    assertTrue(valve.getInputChannelStatus(2).isWatermarkAligned);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputWatermark(new Watermark(12),1);
    assertEquals(new Watermark(9),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
  /** 
 * Verify that we don't see any state changes/watermarks when all ACTIVE channels are unaligned. Earlier versions of the valve had a bug that would cause it to emit a  {@code Long.MAX_VALUE}watermark in that case.
 */
  @Test public void testNoOutputWhenAllActiveChannelsAreUnaligned(){
    BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
    StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
    valve.inputWatermark(new Watermark(10),0);
    valve.inputWatermark(new Watermark(7),1);
    valve.inputStreamStatus(StreamStatus.IDLE,2);
    assertEquals(new Watermark(7),valveOutput.popLastSeenOutput());
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.ACTIVE,2);
    assertEquals(null,valveOutput.popLastSeenOutput());
    valve.inputStreamStatus(StreamStatus.IDLE,0);
    valve.inputStreamStatus(StreamStatus.IDLE,1);
    assertEquals(null,valveOutput.popLastSeenOutput());
  }
private class BufferedValveOutputHandler implements StatusWatermarkValve.ValveOutputHandler {
    private BlockingQueue<StreamElement> allOutputs=new LinkedBlockingQueue<>();
    @Override public void handleWatermark(    Watermark watermark){
      allOutputs.add(watermark);
    }
    @Override public void handleStreamStatus(    StreamStatus streamStatus){
      allOutputs.add(streamStatus);
    }
    public StreamElement popLastSeenOutput(){
      return allOutputs.poll();
    }
  }
}
