/** 
 * Tests for translation of distinct operation.
 */
@SuppressWarnings("serial") public class DistinctTranslationTest {
  @Test public void translateDistinctPlain(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> initialData=getSourceDataSet(env);
      initialData.distinct().output(new DiscardingOutputFormat<Tuple3<Double,StringValue,LongValue>>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      ReduceOperatorBase<?,?> reducer=(ReduceOperatorBase<?,?>)sink.getInput();
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getOutputType());
      assertArrayEquals(new int[]{0,1,2},reducer.getKeyColumns(0));
      assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1);
      assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @Test public void translateDistinctPlain2(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<CustomType> initialData=getSourcePojoDataSet(env);
      initialData.distinct().output(new DiscardingOutputFormat<CustomType>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      ReduceOperatorBase<?,?> reducer=(ReduceOperatorBase<?,?>)sink.getInput();
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getOutputType());
      assertArrayEquals(new int[]{0},reducer.getKeyColumns(0));
      assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1);
      assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @Test public void translateDistinctPosition(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> initialData=getSourceDataSet(env);
      initialData.distinct(1,2).output(new DiscardingOutputFormat<Tuple3<Double,StringValue,LongValue>>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      ReduceOperatorBase<?,?> reducer=(ReduceOperatorBase<?,?>)sink.getInput();
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getOutputType());
      assertArrayEquals(new int[]{1,2},reducer.getKeyColumns(0));
      assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1);
      assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @Test public void translateDistinctKeySelector(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> initialData=getSourceDataSet(env);
      initialData.distinct(new KeySelector<Tuple3<Double,StringValue,LongValue>,StringValue>(){
        public StringValue getKey(        Tuple3<Double,StringValue,LongValue> value){
          return value.f1;
        }
      }
).setParallelism(4).output(new DiscardingOutputFormat<Tuple3<Double,StringValue,LongValue>>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      MapOperatorBase<?,?,?> keyRemover=(MapOperatorBase<?,?,?>)sink.getInput();
      PlanUnwrappingReduceOperator<?,?> reducer=(PlanUnwrappingReduceOperator<?,?>)keyRemover.getInput();
      MapOperatorBase<?,?,?> keyExtractor=(MapOperatorBase<?,?,?>)reducer.getInput();
      assertEquals(1,keyExtractor.getParallelism());
      assertEquals(4,reducer.getParallelism());
      TypeInformation<?> keyValueInfo=new TupleTypeInfo<Tuple2<StringValue,Tuple3<Double,StringValue,LongValue>>>(new ValueTypeInfo<StringValue>(StringValue.class),initialData.getType());
      assertEquals(initialData.getType(),keyExtractor.getOperatorInfo().getInputType());
      assertEquals(keyValueInfo,keyExtractor.getOperatorInfo().getOutputType());
      assertEquals(keyValueInfo,reducer.getOperatorInfo().getInputType());
      assertEquals(keyValueInfo,reducer.getOperatorInfo().getOutputType());
      assertEquals(keyValueInfo,keyRemover.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),keyRemover.getOperatorInfo().getOutputType());
      assertEquals(KeyExtractingMapper.class,keyExtractor.getUserCodeWrapper().getUserCodeClass());
      assertTrue(keyExtractor.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @Test public void translateDistinctExpressionKey(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<CustomType> initialData=getSourcePojoDataSet(env);
      initialData.distinct("myInt").output(new DiscardingOutputFormat<CustomType>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      ReduceOperatorBase<?,?> reducer=(ReduceOperatorBase<?,?>)sink.getInput();
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getOutputType());
      assertArrayEquals(new int[]{0},reducer.getKeyColumns(0));
      assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1);
      assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @SuppressWarnings("unchecked") private static DataSet<Tuple3<Double,StringValue,LongValue>> getSourceDataSet(  ExecutionEnvironment env){
    return env.fromElements(new Tuple3<Double,StringValue,LongValue>(3.141592,new StringValue("foobar"),new LongValue(77))).setParallelism(1);
  }
  private static DataSet<CustomType> getSourcePojoDataSet(  ExecutionEnvironment env){
    List<CustomType> data=new ArrayList<CustomType>();
    data.add(new CustomType(1));
    return env.fromCollection(data);
  }
  /** 
 * Custom data type, for testing purposes.
 */
public static class CustomType implements Serializable {
    private static final long serialVersionUID=1L;
    public int myInt;
    public CustomType(){
    }
    public CustomType(    int i){
      myInt=i;
    }
    @Override public String toString(){
      return "" + myInt;
    }
  }
}
