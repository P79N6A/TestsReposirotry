/** 
 * IT cases for the  {@link AvroOutputFormat}.
 */
@SuppressWarnings("serial") public class AvroOutputFormatITCase extends JavaProgramTestBase {
  public static String outputPath1;
  public static String outputPath2;
  public static String inputPath;
  public static String userData="alice|1|blue\n" + "bob|2|red\n" + "john|3|yellow\n"+ "walt|4|black\n";
  @Override protected void preSubmit() throws Exception {
    inputPath=createTempFile("user",userData);
    outputPath1=getTempDirPath("avro_output1");
    outputPath2=getTempDirPath("avro_output2");
  }
  @Override protected void testProgram() throws Exception {
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<Tuple3<String,Integer,String>> input=env.readCsvFile(inputPath).fieldDelimiter("|").types(String.class,Integer.class,String.class);
    DataSet<User> specificUser=input.map(new ConvertToUser());
    AvroOutputFormat<User> avroOutputFormat=new AvroOutputFormat<>(User.class);
    avroOutputFormat.setCodec(Codec.SNAPPY);
    avroOutputFormat.setSchema(User.SCHEMA$);
    specificUser.write(avroOutputFormat,outputPath1);
    DataSet<ReflectiveUser> reflectiveUser=specificUser.map(new ConvertToReflective());
    reflectiveUser.write(new AvroOutputFormat<>(ReflectiveUser.class),outputPath2);
    env.execute();
  }
  @Override protected void postSubmit() throws Exception {
    File[] output1;
    File file1=asFile(outputPath1);
    if (file1.isDirectory()) {
      output1=file1.listFiles();
      for (      File avroOutput : Objects.requireNonNull(output1)) {
        Assert.assertTrue("Expect extension '.avro'",avroOutput.toString().endsWith(".avro"));
      }
    }
 else {
      output1=new File[]{file1};
    }
    List<String> result1=new ArrayList<>();
    DatumReader<User> userDatumReader1=new SpecificDatumReader<>(User.class);
    for (    File avroOutput : output1) {
      DataFileReader<User> dataFileReader1=new DataFileReader<>(avroOutput,userDatumReader1);
      while (dataFileReader1.hasNext()) {
        User user=dataFileReader1.next();
        result1.add(user.getName() + "|" + user.getFavoriteNumber()+ "|"+ user.getFavoriteColor());
      }
    }
    for (    String expectedResult : userData.split("\n")) {
      Assert.assertTrue("expected user " + expectedResult + " not found.",result1.contains(expectedResult));
    }
    File[] output2;
    File file2=asFile(outputPath2);
    if (file2.isDirectory()) {
      output2=file2.listFiles();
    }
 else {
      output2=new File[]{file2};
    }
    List<String> result2=new ArrayList<>();
    DatumReader<ReflectiveUser> userDatumReader2=new ReflectDatumReader<>(ReflectiveUser.class);
    for (    File avroOutput : Objects.requireNonNull(output2)) {
      DataFileReader<ReflectiveUser> dataFileReader2=new DataFileReader<>(avroOutput,userDatumReader2);
      while (dataFileReader2.hasNext()) {
        ReflectiveUser user=dataFileReader2.next();
        result2.add(user.getName() + "|" + user.getFavoriteNumber()+ "|"+ user.getFavoriteColor());
      }
    }
    for (    String expectedResult : userData.split("\n")) {
      Assert.assertTrue("expected user " + expectedResult + " not found.",result2.contains(expectedResult));
    }
  }
private static final class ConvertToUser extends RichMapFunction<Tuple3<String,Integer,String>,User> {
    @Override public User map(    Tuple3<String,Integer,String> value){
      User user=new User();
      user.setName(value.f0);
      user.setFavoriteNumber(value.f1);
      user.setFavoriteColor(value.f2);
      user.setTypeBoolTest(true);
      user.setTypeArrayString(Collections.emptyList());
      user.setTypeArrayBoolean(Collections.emptyList());
      user.setTypeEnum(Colors.BLUE);
      user.setTypeMap(Collections.emptyMap());
      user.setTypeBytes(ByteBuffer.allocate(10));
      user.setTypeDate(LocalDate.parse("2014-03-01"));
      user.setTypeTimeMillis(LocalTime.parse("12:12:12"));
      user.setTypeTimeMicros(123456);
      user.setTypeTimestampMillis(DateTime.parse("2014-03-01T12:12:12.321Z"));
      user.setTypeTimestampMicros(123456L);
      user.setTypeDecimalBytes(ByteBuffer.wrap(BigDecimal.valueOf(2000,2).unscaledValue().toByteArray()));
      user.setTypeDecimalFixed(new Fixed2(BigDecimal.valueOf(2000,2).unscaledValue().toByteArray()));
      return user;
    }
  }
private static final class ConvertToReflective extends RichMapFunction<User,ReflectiveUser> {
    @Override public ReflectiveUser map(    User value){
      return new ReflectiveUser(value.getName().toString(),value.getFavoriteNumber(),value.getFavoriteColor().toString());
    }
  }
private static class ReflectiveUser {
    private String name;
    private int favoriteNumber;
    private String favoriteColor;
    public ReflectiveUser(){
    }
    public ReflectiveUser(    String name,    int favoriteNumber,    String favoriteColor){
      this.name=name;
      this.favoriteNumber=favoriteNumber;
      this.favoriteColor=favoriteColor;
    }
    public String getName(){
      return this.name;
    }
    public String getFavoriteColor(){
      return this.favoriteColor;
    }
    public int getFavoriteNumber(){
      return this.favoriteNumber;
    }
  }
}
