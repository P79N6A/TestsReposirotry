/** 
 * These tests verify the behavior of a source function that triggers checkpoints in response to received events.
 */
@SuppressWarnings("serial") public class SourceExternalCheckpointTriggerTest {
  private static final OneShotLatch ready=new OneShotLatch();
  private static final MultiShotLatch sync=new MultiShotLatch();
  @Test @SuppressWarnings("unchecked") public void testCheckpointsTriggeredBySource() throws Exception {
    final StreamTaskTestHarness<Long> testHarness=new StreamTaskTestHarness<>(SourceStreamTask::new,BasicTypeInfo.LONG_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    testHarness.getExecutionConfig().setLatencyTrackingInterval(-1);
    final long numElements=10;
    final long checkpointEvery=3;
    ExternalCheckpointsSource source=new ExternalCheckpointsSource(numElements,checkpointEvery);
    StreamConfig streamConfig=testHarness.getStreamConfig();
    StreamSource<Long,?> sourceOperator=new StreamSource<>(source);
    streamConfig.setStreamOperator(sourceOperator);
    streamConfig.setOperatorID(new OperatorID());
    testHarness.invoke();
    final StreamTask<Long,?> sourceTask=testHarness.getTask();
    ready.await();
    assertTrue(sourceTask.triggerCheckpoint(new CheckpointMetaData(32,829),CheckpointOptions.forCheckpointWithDefaultLocation()));
    sync.trigger();
    verifyNextElement(testHarness.getOutput(),1L);
    sync.trigger();
    verifyNextElement(testHarness.getOutput(),2L);
    sync.trigger();
    verifyNextElement(testHarness.getOutput(),3L);
    verifyCheckpointBarrier(testHarness.getOutput(),1L);
    sync.trigger();
    verifyNextElement(testHarness.getOutput(),4L);
    assertTrue(sourceTask.triggerCheckpoint(new CheckpointMetaData(34,900),CheckpointOptions.forCheckpointWithDefaultLocation()));
    sync.trigger();
    verifyNextElement(testHarness.getOutput(),5L);
    sync.trigger();
    verifyNextElement(testHarness.getOutput(),6L);
    verifyCheckpointBarrier(testHarness.getOutput(),2L);
    for (long l=7L, checkpoint=3L; l <= numElements; l++) {
      sync.trigger();
      verifyNextElement(testHarness.getOutput(),l);
      if (l % checkpointEvery == 0) {
        verifyCheckpointBarrier(testHarness.getOutput(),checkpoint++);
      }
    }
  }
  @SuppressWarnings("unchecked") private void verifyNextElement(  BlockingQueue<Object> output,  long expectedElement) throws InterruptedException {
    Object next=output.take();
    assertTrue("next element is not an event",next instanceof StreamRecord);
    assertEquals("wrong event",expectedElement,((StreamRecord<Long>)next).getValue().longValue());
  }
  private void verifyCheckpointBarrier(  BlockingQueue<Object> output,  long checkpointId) throws InterruptedException {
    Object next=output.take();
    assertTrue("next element is not a checkpoint barrier",next instanceof CheckpointBarrier);
    assertEquals("wrong checkpoint id",checkpointId,((CheckpointBarrier)next).getId());
  }
private static class ExternalCheckpointsSource implements ParallelSourceFunction<Long>, ExternallyInducedSource<Long,Object> {
    private final long numEvents;
    private final long checkpointFrequency;
    private CheckpointTrigger trigger;
    ExternalCheckpointsSource(    long numEvents,    long checkpointFrequency){
      this.numEvents=numEvents;
      this.checkpointFrequency=checkpointFrequency;
    }
    @Override public void run(    SourceContext<Long> ctx) throws Exception {
      ready.trigger();
      long checkpoint=1;
      for (long num=1; num <= numEvents; num++) {
        sync.await();
        ctx.collect(num);
        if (num % checkpointFrequency == 0) {
          trigger.triggerCheckpoint(checkpoint++);
        }
      }
    }
    @Override public void cancel(){
    }
    @Override public void setCheckpointTrigger(    CheckpointTrigger checkpointTrigger){
      this.trigger=checkpointTrigger;
    }
    @Override public MasterTriggerRestoreHook<Object> createMasterTriggerRestoreHook(){
      throw new UnsupportedOperationException("not implemented");
    }
  }
}
