/** 
 * Tests for the  {@link MiniDispatcher}.
 */
public class MiniDispatcherTest extends TestLogger {
  private static final Time timeout=Time.seconds(10L);
  @ClassRule public static TemporaryFolder temporaryFolder=new TemporaryFolder();
  private static JobGraph jobGraph;
  private static ArchivedExecutionGraph archivedExecutionGraph;
  private static TestingRpcService rpcService;
  private static Configuration configuration;
  private static BlobServer blobServer;
  private final TestingResourceManagerGateway resourceManagerGateway=new TestingResourceManagerGateway();
  private final HeartbeatServices heartbeatServices=new HeartbeatServices(1000L,1000L);
  private final ArchivedExecutionGraphStore archivedExecutionGraphStore=new MemoryArchivedExecutionGraphStore();
  private CompletableFuture<JobGraph> jobGraphFuture;
  private CompletableFuture<ArchivedExecutionGraph> resultFuture;
  private TestingLeaderElectionService dispatcherLeaderElectionService;
  private TestingHighAvailabilityServices highAvailabilityServices;
  private TestingFatalErrorHandler testingFatalErrorHandler;
  private TestingJobManagerRunnerFactory testingJobManagerRunnerFactory;
  @BeforeClass public static void setupClass() throws IOException {
    jobGraph=new JobGraph();
    archivedExecutionGraph=new ArchivedExecutionGraphBuilder().setJobID(jobGraph.getJobID()).setState(JobStatus.FINISHED).build();
    rpcService=new TestingRpcService();
    configuration=new Configuration();
    configuration.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    blobServer=new BlobServer(configuration,new VoidBlobStore());
  }
  @Before public void setup() throws Exception {
    dispatcherLeaderElectionService=new TestingLeaderElectionService();
    highAvailabilityServices=new TestingHighAvailabilityServices();
    testingFatalErrorHandler=new TestingFatalErrorHandler();
    highAvailabilityServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService);
    jobGraphFuture=new CompletableFuture<>();
    resultFuture=new CompletableFuture<>();
    testingJobManagerRunnerFactory=new TestingJobManagerRunnerFactory(jobGraphFuture,resultFuture,CompletableFuture.completedFuture(null));
  }
  @After public void teardown() throws Exception {
    testingFatalErrorHandler.rethrowError();
  }
  @AfterClass public static void teardownClass() throws IOException, InterruptedException, ExecutionException, TimeoutException {
    if (blobServer != null) {
      blobServer.close();
    }
    if (rpcService != null) {
      RpcUtils.terminateRpcService(rpcService,timeout);
    }
  }
  /** 
 * Tests that the  {@link MiniDispatcher} recovers the single job with which itwas started.
 */
  @Test public void testSingleJobRecovery() throws Exception {
    final MiniDispatcher miniDispatcher=createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED);
    miniDispatcher.start();
    try {
      dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
      final JobGraph actualJobGraph=jobGraphFuture.get();
      assertThat(actualJobGraph.getJobID(),is(jobGraph.getJobID()));
    }
  finally {
      RpcUtils.terminateRpcEndpoint(miniDispatcher,timeout);
    }
  }
  /** 
 * Tests that in detached mode, the  {@link MiniDispatcher} will complete the future thatsignals job termination.
 */
  @Test public void testTerminationAfterJobCompletion() throws Exception {
    final MiniDispatcher miniDispatcher=createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED);
    miniDispatcher.start();
    try {
      dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
      jobGraphFuture.get();
      resultFuture.complete(archivedExecutionGraph);
      miniDispatcher.getJobTerminationFuture().get();
    }
  finally {
      RpcUtils.terminateRpcEndpoint(miniDispatcher,timeout);
    }
  }
  /** 
 * Tests that the  {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}after it has served the  {@link org.apache.flink.runtime.jobmaster.JobResult} once.
 */
  @Test public void testJobResultRetrieval() throws Exception {
    final MiniDispatcher miniDispatcher=createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL);
    miniDispatcher.start();
    try {
      dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
      jobGraphFuture.get();
      resultFuture.complete(archivedExecutionGraph);
      assertFalse(miniDispatcher.getTerminationFuture().isDone());
      final DispatcherGateway dispatcherGateway=miniDispatcher.getSelfGateway(DispatcherGateway.class);
      final CompletableFuture<JobResult> jobResultFuture=dispatcherGateway.requestJobResult(jobGraph.getJobID(),timeout);
      final JobResult jobResult=jobResultFuture.get();
      assertThat(jobResult.getJobId(),is(jobGraph.getJobID()));
    }
  finally {
      RpcUtils.terminateRpcEndpoint(miniDispatcher,timeout);
    }
  }
  @Nonnull private MiniDispatcher createMiniDispatcher(  ClusterEntrypoint.ExecutionMode executionMode) throws Exception {
    return new MiniDispatcher(rpcService,UUID.randomUUID().toString(),configuration,highAvailabilityServices,resourceManagerGateway,blobServer,heartbeatServices,UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),null,archivedExecutionGraphStore,testingJobManagerRunnerFactory,testingFatalErrorHandler,null,VoidHistoryServerArchivist.INSTANCE,jobGraph,executionMode);
  }
}
