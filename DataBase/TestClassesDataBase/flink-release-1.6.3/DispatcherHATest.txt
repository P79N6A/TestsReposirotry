/** 
 * Tests the HA behaviour of the  {@link Dispatcher}.
 */
public class DispatcherHATest extends TestLogger {
  private static final DispatcherId NULL_FENCING_TOKEN=DispatcherId.fromUuid(new UUID(0L,0L));
  private static final Time timeout=Time.seconds(10L);
  private static TestingRpcService rpcService;
  private TestingFatalErrorHandler testingFatalErrorHandler;
  @BeforeClass public static void setupClass(){
    rpcService=new TestingRpcService();
  }
  @Before public void setup(){
    testingFatalErrorHandler=new TestingFatalErrorHandler();
  }
  @After public void teardown() throws Exception {
    if (testingFatalErrorHandler != null) {
      testingFatalErrorHandler.rethrowError();
    }
  }
  @AfterClass public static void teardownClass() throws ExecutionException, InterruptedException {
    if (rpcService != null) {
      rpcService.stopService().get();
      rpcService=null;
    }
  }
  /** 
 * Tests that interleaved granting and revoking of the leadership won't interfere with the job recovery and the resulting internal state of the Dispatcher.
 */
  @Test public void testGrantingRevokingLeadership() throws Exception {
    final TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    final JobGraph nonEmptyJobGraph=createNonEmptyJobGraph();
    final SubmittedJobGraph submittedJobGraph=new SubmittedJobGraph(nonEmptyJobGraph,null);
    final OneShotLatch enterGetJobIdsLatch=new OneShotLatch();
    final OneShotLatch proceedGetJobIdsLatch=new OneShotLatch();
    highAvailabilityServices.setSubmittedJobGraphStore(new BlockingSubmittedJobGraphStore(submittedJobGraph,enterGetJobIdsLatch,proceedGetJobIdsLatch));
    final TestingLeaderElectionService dispatcherLeaderElectionService=new TestingLeaderElectionService();
    highAvailabilityServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService);
    final BlockingQueue<DispatcherId> fencingTokens=new ArrayBlockingQueue<>(2);
    final HATestingDispatcher dispatcher=createHADispatcher(highAvailabilityServices,fencingTokens);
    dispatcher.start();
    try {
      final UUID leaderId=UUID.randomUUID();
      dispatcherLeaderElectionService.isLeader(leaderId);
      dispatcherLeaderElectionService.notLeader();
      final DispatcherId firstFencingToken=fencingTokens.take();
      assertThat(firstFencingToken,equalTo(NULL_FENCING_TOKEN));
      enterGetJobIdsLatch.await();
      proceedGetJobIdsLatch.trigger();
      assertThat(dispatcher.getNumberJobs(timeout).get(),is(0));
    }
  finally {
      RpcUtils.terminateRpcEndpoint(dispatcher,timeout);
    }
  }
  @Nonnull private HATestingDispatcher createHADispatcher(  TestingHighAvailabilityServices highAvailabilityServices,  BlockingQueue<DispatcherId> fencingTokens) throws Exception {
    final Configuration configuration=new Configuration();
    return new HATestingDispatcher(rpcService,UUID.randomUUID().toString(),configuration,highAvailabilityServices,new TestingResourceManagerGateway(),new BlobServer(configuration,new VoidBlobStore()),new HeartbeatServices(1000L,1000L),UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),null,new MemoryArchivedExecutionGraphStore(),new TestingJobManagerRunnerFactory(new CompletableFuture<>(),new CompletableFuture<>(),CompletableFuture.completedFuture(null)),testingFatalErrorHandler,fencingTokens);
  }
  /** 
 * Tests that all JobManagerRunner are terminated if the leadership of the Dispatcher is revoked.
 */
  @Test public void testRevokeLeadershipTerminatesJobManagerRunners() throws Exception {
    final TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    highAvailabilityServices.setSubmittedJobGraphStore(new StandaloneSubmittedJobGraphStore());
    final TestingLeaderElectionService leaderElectionService=new TestingLeaderElectionService();
    highAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);
    final ArrayBlockingQueue<DispatcherId> fencingTokens=new ArrayBlockingQueue<>(2);
    final HATestingDispatcher dispatcher=createHADispatcher(highAvailabilityServices,fencingTokens);
    dispatcher.start();
    try {
      final DispatcherId expectedDispatcherId=DispatcherId.generate();
      leaderElectionService.isLeader(expectedDispatcherId.toUUID()).get();
      assertThat(fencingTokens.take(),is(equalTo(expectedDispatcherId)));
      final DispatcherGateway dispatcherGateway=dispatcher.getSelfGateway(DispatcherGateway.class);
      final CompletableFuture<Acknowledge> submissionFuture=dispatcherGateway.submitJob(createNonEmptyJobGraph(),timeout);
      submissionFuture.get();
      assertThat(dispatcher.getNumberJobs(timeout).get(),is(1));
      leaderElectionService.notLeader();
      assertThat(fencingTokens.take(),is(equalTo(NULL_FENCING_TOKEN)));
      assertThat(dispatcher.getNumberJobs(timeout).get(),is(0));
    }
  finally {
      RpcUtils.terminateRpcEndpoint(dispatcher,timeout);
    }
  }
  @Nonnull public static JobGraph createNonEmptyJobGraph(){
    final JobVertex noOpVertex=new JobVertex("NoOp vertex");
    noOpVertex.setInvokableClass(NoOpInvokable.class);
    final JobGraph jobGraph=new JobGraph(noOpVertex);
    jobGraph.setAllowQueuedScheduling(true);
    return jobGraph;
  }
private static class HATestingDispatcher extends TestingDispatcher {
    @Nonnull private final BlockingQueue<DispatcherId> fencingTokens;
    HATestingDispatcher(    RpcService rpcService,    String endpointId,    Configuration configuration,    HighAvailabilityServices highAvailabilityServices,    ResourceManagerGateway resourceManagerGateway,    BlobServer blobServer,    HeartbeatServices heartbeatServices,    JobManagerMetricGroup jobManagerMetricGroup,    @Nullable String metricQueryServicePath,    ArchivedExecutionGraphStore archivedExecutionGraphStore,    JobManagerRunnerFactory jobManagerRunnerFactory,    FatalErrorHandler fatalErrorHandler,    @Nonnull BlockingQueue<DispatcherId> fencingTokens) throws Exception {
      super(rpcService,endpointId,configuration,highAvailabilityServices,resourceManagerGateway,blobServer,heartbeatServices,jobManagerMetricGroup,metricQueryServicePath,archivedExecutionGraphStore,jobManagerRunnerFactory,fatalErrorHandler);
      this.fencingTokens=fencingTokens;
    }
    @VisibleForTesting CompletableFuture<Integer> getNumberJobs(    Time timeout){
      return callAsyncWithoutFencing(() -> listJobs(timeout).get().size(),timeout);
    }
    @Override protected void setFencingToken(    @Nullable DispatcherId newFencingToken){
      super.setFencingToken(newFencingToken);
      if (newFencingToken == null) {
        fencingTokens.offer(NULL_FENCING_TOKEN);
      }
 else {
        fencingTokens.offer(newFencingToken);
      }
    }
  }
private static class BlockingSubmittedJobGraphStore implements SubmittedJobGraphStore {
    @Nonnull private final SubmittedJobGraph submittedJobGraph;
    @Nonnull private final OneShotLatch enterGetJobIdsLatch;
    @Nonnull private final OneShotLatch proceedGetJobIdsLatch;
    private boolean isStarted=false;
    private BlockingSubmittedJobGraphStore(    @Nonnull SubmittedJobGraph submittedJobGraph,    @Nonnull OneShotLatch enterGetJobIdsLatch,    @Nonnull OneShotLatch proceedGetJobIdsLatch){
      this.submittedJobGraph=submittedJobGraph;
      this.enterGetJobIdsLatch=enterGetJobIdsLatch;
      this.proceedGetJobIdsLatch=proceedGetJobIdsLatch;
    }
    @Override public void start(    SubmittedJobGraphListener jobGraphListener) throws Exception {
      isStarted=true;
    }
    @Override public void stop() throws Exception {
      isStarted=false;
    }
    @Nullable @Override public SubmittedJobGraph recoverJobGraph(    JobID jobId) throws Exception {
      Preconditions.checkArgument(jobId.equals(submittedJobGraph.getJobId()));
      return submittedJobGraph;
    }
    @Override public void putJobGraph(    SubmittedJobGraph jobGraph) throws Exception {
      throw new UnsupportedOperationException("Should not be called.");
    }
    @Override public void removeJobGraph(    JobID jobId) throws Exception {
      throw new UnsupportedOperationException("Should not be called.");
    }
    @Override public void releaseJobGraph(    JobID jobId) throws Exception {
    }
    @Override public Collection<JobID> getJobIds() throws Exception {
      enterGetJobIdsLatch.trigger();
      proceedGetJobIdsLatch.await();
      return Collections.singleton(submittedJobGraph.getJobId());
    }
  }
}
