/** 
 * Test for  {@link StreamTaskStateInitializerImpl}.
 */
public class StreamTaskStateInitializerImplTest {
  @Test public void testNoRestore() throws Exception {
    MemoryStateBackend stateBackend=spy(new MemoryStateBackend(1024));
    StreamTaskStateInitializer streamTaskStateManager=streamTaskStateManager(stateBackend,null,true);
    OperatorID operatorID=new OperatorID(47L,11L);
    AbstractStreamOperator<?> streamOperator=mock(AbstractStreamOperator.class);
    when(streamOperator.getOperatorID()).thenReturn(operatorID);
    TypeSerializer<?> typeSerializer=new IntSerializer();
    CloseableRegistry closeableRegistry=new CloseableRegistry();
    StreamOperatorStateContext stateContext=streamTaskStateManager.streamOperatorStateContext(streamOperator.getOperatorID(),streamOperator.getClass().getSimpleName(),streamOperator,typeSerializer,closeableRegistry);
    OperatorStateBackend operatorStateBackend=stateContext.operatorStateBackend();
    AbstractKeyedStateBackend<?> keyedStateBackend=stateContext.keyedStateBackend();
    InternalTimeServiceManager<?> timeServiceManager=stateContext.internalTimerServiceManager();
    CloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs=stateContext.rawKeyedStateInputs();
    CloseableIterable<StatePartitionStreamProvider> operatorStateInputs=stateContext.rawOperatorStateInputs();
    Assert.assertEquals(false,stateContext.isRestored());
    Assert.assertNotNull(operatorStateBackend);
    Assert.assertNotNull(keyedStateBackend);
    Assert.assertNotNull(timeServiceManager);
    Assert.assertNotNull(keyedStateInputs);
    Assert.assertNotNull(operatorStateInputs);
    checkCloseablesRegistered(closeableRegistry,operatorStateBackend,keyedStateBackend,keyedStateInputs,operatorStateInputs);
    Assert.assertFalse(keyedStateInputs.iterator().hasNext());
    Assert.assertFalse(operatorStateInputs.iterator().hasNext());
  }
  @SuppressWarnings("unchecked") @Test public void testWithRestore() throws Exception {
    StateBackend mockingBackend=spy(new StateBackend(){
      @Override public CompletedCheckpointStorageLocation resolveCheckpoint(      String pointer) throws IOException {
        throw new UnsupportedOperationException();
      }
      @Override public CheckpointStorage createCheckpointStorage(      JobID jobId) throws IOException {
        throw new UnsupportedOperationException();
      }
      @Override public <K>AbstractKeyedStateBackend<K> createKeyedStateBackend(      Environment env,      JobID jobID,      String operatorIdentifier,      TypeSerializer<K> keySerializer,      int numberOfKeyGroups,      KeyGroupRange keyGroupRange,      TaskKvStateRegistry kvStateRegistry,      TtlTimeProvider ttlTimeProvider) throws Exception {
        return mock(AbstractKeyedStateBackend.class);
      }
      @Override public OperatorStateBackend createOperatorStateBackend(      Environment env,      String operatorIdentifier) throws Exception {
        return mock(OperatorStateBackend.class);
      }
    }
);
    OperatorID operatorID=new OperatorID(47L,11L);
    TaskStateSnapshot taskStateSnapshot=new TaskStateSnapshot();
    Random random=new Random(0x42);
    OperatorSubtaskState operatorSubtaskState=new OperatorSubtaskState(new OperatorStreamStateHandle(Collections.singletonMap("a",new OperatorStateHandle.StateMetaInfo(new long[]{0,10},OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),CheckpointTestUtils.createDummyStreamStateHandle(random)),new OperatorStreamStateHandle(Collections.singletonMap("_default_",new OperatorStateHandle.StateMetaInfo(new long[]{0,20,30},OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),CheckpointTestUtils.createDummyStreamStateHandle(random)),CheckpointTestUtils.createDummyKeyGroupStateHandle(random),CheckpointTestUtils.createDummyKeyGroupStateHandle(random));
    taskStateSnapshot.putSubtaskStateByOperatorID(operatorID,operatorSubtaskState);
    JobManagerTaskRestore jobManagerTaskRestore=new JobManagerTaskRestore(0L,taskStateSnapshot);
    StreamTaskStateInitializer streamTaskStateManager=streamTaskStateManager(mockingBackend,jobManagerTaskRestore,false);
    AbstractStreamOperator<?> streamOperator=mock(AbstractStreamOperator.class);
    when(streamOperator.getOperatorID()).thenReturn(operatorID);
    TypeSerializer<?> typeSerializer=new IntSerializer();
    CloseableRegistry closeableRegistry=new CloseableRegistry();
    StreamOperatorStateContext stateContext=streamTaskStateManager.streamOperatorStateContext(streamOperator.getOperatorID(),streamOperator.getClass().getSimpleName(),streamOperator,typeSerializer,closeableRegistry);
    OperatorStateBackend operatorStateBackend=stateContext.operatorStateBackend();
    AbstractKeyedStateBackend<?> keyedStateBackend=stateContext.keyedStateBackend();
    InternalTimeServiceManager<?> timeServiceManager=stateContext.internalTimerServiceManager();
    CloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs=stateContext.rawKeyedStateInputs();
    CloseableIterable<StatePartitionStreamProvider> operatorStateInputs=stateContext.rawOperatorStateInputs();
    Assert.assertEquals(true,stateContext.isRestored());
    Assert.assertNotNull(operatorStateBackend);
    Assert.assertNotNull(keyedStateBackend);
    Assert.assertNull(timeServiceManager);
    Assert.assertNotNull(keyedStateInputs);
    Assert.assertNotNull(operatorStateInputs);
    verify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));
    verify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));
    int count=0;
    for (    KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {
      ++count;
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {
      ++count;
    }
    Assert.assertEquals(3,count);
    checkCloseablesRegistered(closeableRegistry,operatorStateBackend,keyedStateBackend,keyedStateInputs,operatorStateInputs);
  }
  private static void checkCloseablesRegistered(  CloseableRegistry closeableRegistry,  Closeable... closeables){
    for (    Closeable closeable : closeables) {
      Assert.assertTrue(closeableRegistry.unregisterCloseable(closeable));
    }
  }
  private StreamTaskStateInitializer streamTaskStateManager(  StateBackend stateBackend,  JobManagerTaskRestore jobManagerTaskRestore,  boolean createTimerServiceManager){
    JobID jobID=new JobID(42L,43L);
    ExecutionAttemptID executionAttemptID=new ExecutionAttemptID(23L,24L);
    TestCheckpointResponder checkpointResponderMock=new TestCheckpointResponder();
    TaskLocalStateStore taskLocalStateStore=new TestTaskLocalStateStore();
    TaskStateManager taskStateManager=TaskStateManagerImplTest.taskStateManager(jobID,executionAttemptID,checkpointResponderMock,jobManagerTaskRestore,taskLocalStateStore);
    DummyEnvironment dummyEnvironment=new DummyEnvironment("test-task",1,0);
    dummyEnvironment.setTaskStateManager(taskStateManager);
    ProcessingTimeService processingTimeService=new TestProcessingTimeService();
    if (createTimerServiceManager) {
      return new StreamTaskStateInitializerImpl(dummyEnvironment,stateBackend,processingTimeService);
    }
 else {
      return new StreamTaskStateInitializerImpl(dummyEnvironment,stateBackend,processingTimeService){
        @Override protected <K>InternalTimeServiceManager<K> internalTimeServiceManager(        AbstractKeyedStateBackend<K> keyedStatedBackend,        KeyContext keyContext,        Iterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {
          return null;
        }
      }
;
    }
  }
}
