private static class SleepyDurableGenerateSequence extends RichParallelSourceFunction<Long> implements ListCheckpointed<Long> {
  private static final long SLEEP_TIME=50;
  private final File coordinateDir;
  private final long end;
  private volatile boolean isRunning=true;
  private long collected;
  public SleepyDurableGenerateSequence(  File coordinateDir,  long end){
    this.coordinateDir=coordinateDir;
    this.end=end;
  }
  @Override public void run(  SourceContext<Long> sourceCtx) throws Exception {
    final Object checkpointLock=sourceCtx.getCheckpointLock();
    RuntimeContext runtimeCtx=getRuntimeContext();
    final long stepSize=runtimeCtx.getNumberOfParallelSubtasks();
    final long congruence=runtimeCtx.getIndexOfThisSubtask();
    final long toCollect=(end % stepSize > congruence) ? (end / stepSize + 1) : (end / stepSize);
    final File proceedFile=new File(coordinateDir,PROCEED_MARKER_FILE);
    boolean checkForProceedFile=true;
    while (isRunning && collected < toCollect) {
      if (checkForProceedFile) {
        if (proceedFile.exists()) {
          checkForProceedFile=false;
        }
 else {
          Thread.sleep(SLEEP_TIME);
        }
      }
synchronized (checkpointLock) {
        sourceCtx.collect(collected * stepSize + congruence);
        collected++;
      }
    }
  }
  @Override public void cancel(){
    isRunning=false;
  }
  @Override public List<Long> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(this.collected);
  }
  @Override public void restoreState(  List<Long> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.collected=state.get(0);
  }
}
