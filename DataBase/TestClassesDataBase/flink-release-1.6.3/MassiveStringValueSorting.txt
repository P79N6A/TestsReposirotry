/** 
 * Test  {@link UnilateralSortMerger} on a large set of {@link StringValue}.
 */
public class MassiveStringValueSorting {
  private static final long SEED=347569784659278346L;
  public void testStringValueSorting(){
    File input=null;
    File sorted=null;
    try {
      input=generateFileWithStrings(300000,"http://some-uri.com/that/is/a/common/prefix/to/all");
      sorted=File.createTempFile("sorted_strings","txt");
      String[] command={"/bin/bash","-c","export LC_ALL=\"C\" && cat \"" + input.getAbsolutePath() + "\" | sort > \""+ sorted.getAbsolutePath()+ "\""};
      Process p=null;
      try {
        p=Runtime.getRuntime().exec(command);
        int retCode=p.waitFor();
        if (retCode != 0) {
          throw new Exception("Command failed with return code " + retCode);
        }
        p=null;
      }
  finally {
        if (p != null) {
          p.destroy();
        }
      }
      UnilateralSortMerger<StringValue> sorter=null;
      BufferedReader reader=null;
      BufferedReader verifyReader=null;
      MemoryManager mm=null;
      IOManager ioMan=null;
      try {
        mm=new MemoryManager(1024 * 1024,1);
        ioMan=new IOManagerAsync();
        TypeSerializer<StringValue> serializer=new CopyableValueSerializer<StringValue>(StringValue.class);
        TypeComparator<StringValue> comparator=new CopyableValueComparator<StringValue>(true,StringValue.class);
        reader=new BufferedReader(new FileReader(input));
        MutableObjectIterator<StringValue> inputIterator=new StringValueReaderMutableObjectIterator(reader);
        sorter=new UnilateralSortMerger<StringValue>(mm,ioMan,inputIterator,new DummyInvokable(),new RuntimeSerializerFactory<StringValue>(serializer,StringValue.class),comparator,1.0,4,0.8f,true,true);
        MutableObjectIterator<StringValue> sortedData=sorter.getIterator();
        reader.close();
        verifyReader=new BufferedReader(new FileReader(sorted));
        String nextVerify;
        StringValue nextFromFlinkSort=new StringValue();
        while ((nextVerify=verifyReader.readLine()) != null) {
          nextFromFlinkSort=sortedData.next(nextFromFlinkSort);
          Assert.assertNotNull(nextFromFlinkSort);
          Assert.assertEquals(nextVerify,nextFromFlinkSort.getValue());
        }
      }
  finally {
        if (reader != null) {
          reader.close();
        }
        if (verifyReader != null) {
          verifyReader.close();
        }
        if (sorter != null) {
          sorter.close();
        }
        if (mm != null) {
          mm.shutdown();
        }
        if (ioMan != null) {
          ioMan.shutdown();
        }
      }
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      Assert.fail(e.getMessage());
    }
 finally {
      if (input != null) {
        input.delete();
      }
      if (sorted != null) {
        sorted.delete();
      }
    }
  }
  @SuppressWarnings("unchecked") public void testStringValueTuplesSorting(){
    final int numStrings=300000;
    File input=null;
    File sorted=null;
    try {
      input=generateFileWithStringTuples(numStrings,"http://some-uri.com/that/is/a/common/prefix/to/all");
      sorted=File.createTempFile("sorted_strings","txt");
      String[] command={"/bin/bash","-c","export LC_ALL=\"C\" && cat \"" + input.getAbsolutePath() + "\" | sort > \""+ sorted.getAbsolutePath()+ "\""};
      Process p=null;
      try {
        p=Runtime.getRuntime().exec(command);
        int retCode=p.waitFor();
        if (retCode != 0) {
          throw new Exception("Command failed with return code " + retCode);
        }
        p=null;
      }
  finally {
        if (p != null) {
          p.destroy();
        }
      }
      UnilateralSortMerger<Tuple2<StringValue,StringValue[]>> sorter=null;
      BufferedReader reader=null;
      BufferedReader verifyReader=null;
      MemoryManager mm=null;
      IOManager ioMan=null;
      try {
        mm=new MemoryManager(1024 * 1024,1);
        ioMan=new IOManagerAsync();
        TupleTypeInfo<Tuple2<StringValue,StringValue[]>> typeInfo=(TupleTypeInfo<Tuple2<StringValue,StringValue[]>>)new TypeHint<Tuple2<StringValue,StringValue[]>>(){
        }
.getTypeInfo();
        TypeSerializer<Tuple2<StringValue,StringValue[]>> serializer=typeInfo.createSerializer(new ExecutionConfig());
        TypeComparator<Tuple2<StringValue,StringValue[]>> comparator=typeInfo.createComparator(new int[]{0},new boolean[]{true},0,new ExecutionConfig());
        reader=new BufferedReader(new FileReader(input));
        MutableObjectIterator<Tuple2<StringValue,StringValue[]>> inputIterator=new StringValueTupleReaderMutableObjectIterator(reader);
        sorter=new UnilateralSortMerger<Tuple2<StringValue,StringValue[]>>(mm,ioMan,inputIterator,new DummyInvokable(),new RuntimeSerializerFactory<Tuple2<StringValue,StringValue[]>>(serializer,(Class<Tuple2<StringValue,StringValue[]>>)(Class<?>)Tuple2.class),comparator,1.0,4,0.8f,true,false);
        MutableObjectIterator<Tuple2<StringValue,StringValue[]>> sortedData=sorter.getIterator();
        reader.close();
        verifyReader=new BufferedReader(new FileReader(sorted));
        MutableObjectIterator<Tuple2<StringValue,StringValue[]>> verifyIterator=new StringValueTupleReaderMutableObjectIterator(verifyReader);
        Tuple2<StringValue,StringValue[]> nextVerify=new Tuple2<StringValue,StringValue[]>(new StringValue(),new StringValue[0]);
        Tuple2<StringValue,StringValue[]> nextFromFlinkSort=new Tuple2<StringValue,StringValue[]>(new StringValue(),new StringValue[0]);
        int num=0;
        while ((nextVerify=verifyIterator.next(nextVerify)) != null) {
          num++;
          nextFromFlinkSort=sortedData.next(nextFromFlinkSort);
          Assert.assertNotNull(nextFromFlinkSort);
          Assert.assertEquals(nextVerify.f0,nextFromFlinkSort.f0);
          Assert.assertArrayEquals(nextVerify.f1,nextFromFlinkSort.f1);
        }
        Assert.assertNull(sortedData.next(nextFromFlinkSort));
        Assert.assertEquals(numStrings,num);
      }
  finally {
        if (reader != null) {
          reader.close();
        }
        if (verifyReader != null) {
          verifyReader.close();
        }
        if (sorter != null) {
          sorter.close();
        }
        if (mm != null) {
          mm.shutdown();
        }
        if (ioMan != null) {
          ioMan.shutdown();
        }
      }
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      Assert.fail(e.getMessage());
    }
 finally {
      if (input != null) {
        input.delete();
      }
      if (sorted != null) {
        sorted.delete();
      }
    }
  }
private static final class StringValueReaderMutableObjectIterator implements MutableObjectIterator<StringValue> {
    private final BufferedReader reader;
    public StringValueReaderMutableObjectIterator(    BufferedReader reader){
      this.reader=reader;
    }
    @Override public StringValue next(    StringValue reuse) throws IOException {
      String line=reader.readLine();
      if (line == null) {
        return null;
      }
      reuse.setValue(line);
      return reuse;
    }
    @Override public StringValue next() throws IOException {
      return next(new StringValue());
    }
  }
private static final class StringValueTupleReaderMutableObjectIterator implements MutableObjectIterator<Tuple2<StringValue,StringValue[]>> {
    private final BufferedReader reader;
    public StringValueTupleReaderMutableObjectIterator(    BufferedReader reader){
      this.reader=reader;
    }
    @Override public Tuple2<StringValue,StringValue[]> next(    Tuple2<StringValue,StringValue[]> reuse) throws IOException {
      String line=reader.readLine();
      if (line == null) {
        return null;
      }
      String[] parts=line.split(" ");
      reuse.f0.setValue(parts[0]);
      reuse.f1=new StringValue[parts.length];
      for (int i=0; i < parts.length; i++) {
        reuse.f1[i]=new StringValue(parts[i]);
      }
      return reuse;
    }
    @Override public Tuple2<StringValue,StringValue[]> next() throws IOException {
      return next(new Tuple2<StringValue,StringValue[]>(new StringValue(),new StringValue[0]));
    }
  }
  private File generateFileWithStrings(  int numStrings,  String prefix) throws IOException {
    final Random rnd=new Random(SEED);
    final StringBuilder bld=new StringBuilder();
    final int resetValue=prefix.length();
    bld.append(prefix);
    File f=File.createTempFile("strings","txt");
    BufferedWriter wrt=null;
    try {
      wrt=new BufferedWriter(new FileWriter(f));
      for (int i=0; i < numStrings; i++) {
        bld.setLength(resetValue);
        int len=rnd.nextInt(20) + 300;
        for (int k=0; k < len; k++) {
          char c=(char)(rnd.nextInt(80) + 40);
          bld.append(c);
        }
        String str=bld.toString();
        wrt.write(str);
        wrt.newLine();
      }
    }
  finally {
      if (wrt != null) {
        wrt.close();
      }
    }
    return f;
  }
  private File generateFileWithStringTuples(  int numStrings,  String prefix) throws IOException {
    final Random rnd=new Random(SEED);
    final StringBuilder bld=new StringBuilder();
    File f=File.createTempFile("strings","txt");
    BufferedWriter wrt=null;
    try {
      wrt=new BufferedWriter(new FileWriter(f));
      for (int i=0; i < numStrings; i++) {
        bld.setLength(0);
        int numComps=rnd.nextInt(5) + 1;
        for (int z=0; z < numComps; z++) {
          if (z > 0) {
            bld.append(' ');
          }
          bld.append(prefix);
          int len=rnd.nextInt(20) + 10;
          for (int k=0; k < len; k++) {
            char c=(char)(rnd.nextInt(80) + 40);
            bld.append(c);
          }
        }
        String str=bld.toString();
        wrt.write(str);
        wrt.newLine();
      }
    }
  finally {
      if (wrt != null) {
        wrt.close();
      }
    }
    return f;
  }
  public static void main(  String[] args){
    new MassiveStringValueSorting().testStringValueSorting();
    new MassiveStringValueSorting().testStringValueTuplesSorting();
  }
}
