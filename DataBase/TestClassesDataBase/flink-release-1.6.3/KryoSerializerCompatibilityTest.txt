/** 
 * Tests related to configuration snapshotting and reconfiguring for the  {@link KryoSerializer}.
 */
public class KryoSerializerCompatibilityTest {
  @Rule public ExpectedException thrown=ExpectedException.none();
  @Test public void testMigrationStrategyForRemovedAvroDependency() throws Exception {
    KryoSerializer<TestClass> kryoSerializerForA=new KryoSerializer<>(TestClass.class,new ExecutionConfig());
    TypeSerializerConfigSnapshot kryoSerializerConfigSnapshot;
    try (InputStream in=getClass().getResourceAsStream("/kryo-serializer-flink1.3-snapshot")){
      kryoSerializerConfigSnapshot=TypeSerializerSerializationUtil.readSerializerConfigSnapshot(new DataInputViewStreamWrapper(in),Thread.currentThread().getContextClassLoader());
    }
     CompatibilityResult<TestClass> compatResult=kryoSerializerForA.ensureCompatibility(kryoSerializerConfigSnapshot);
    assertFalse(compatResult.isRequiresMigration());
  }
  @Test public void testDeserializingKryoSerializerWithoutAvro() throws Exception {
    final String resource="serialized-kryo-serializer-1.3";
    TypeSerializer<?> serializer;
    try (InputStream in=getClass().getClassLoader().getResourceAsStream(resource)){
      DataInputViewStreamWrapper inView=new DataInputViewStreamWrapper(in);
      serializer=TypeSerializerSerializationUtil.tryReadSerializer(inView,getClass().getClassLoader());
    }
     assertNotNull(serializer);
    assertTrue(serializer instanceof KryoSerializer);
  }
  /** 
 * Verifies that reconfiguration result is INCOMPATIBLE if data type has changed.
 */
  @Test public void testMigrationStrategyWithDifferentKryoType() throws Exception {
    KryoSerializer<TestClassA> kryoSerializerForA=new KryoSerializer<>(TestClassA.class,new ExecutionConfig());
    TypeSerializerConfigSnapshot kryoSerializerConfigSnapshot=kryoSerializerForA.snapshotConfiguration();
    byte[] serializedConfig;
    try (ByteArrayOutputStream out=new ByteArrayOutputStream()){
      TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out),kryoSerializerConfigSnapshot);
      serializedConfig=out.toByteArray();
    }
     KryoSerializer<TestClassB> kryoSerializerForB=new KryoSerializer<>(TestClassB.class,new ExecutionConfig());
    try (ByteArrayInputStream in=new ByteArrayInputStream(serializedConfig)){
      kryoSerializerConfigSnapshot=TypeSerializerSerializationUtil.readSerializerConfigSnapshot(new DataInputViewStreamWrapper(in),Thread.currentThread().getContextClassLoader());
    }
     CompatibilityResult<TestClassB> compatResult=kryoSerializerForB.ensureCompatibility(kryoSerializerConfigSnapshot);
    assertTrue(compatResult.isRequiresMigration());
  }
  @Test public void testMigrationOfTypeWithAvroType() throws Exception {
class FakeAvroClass {
      public List<Integer> array;
      FakeAvroClass(      List<Integer> array){
        this.array=array;
      }
    }
{
      ExecutionConfig executionConfig=new ExecutionConfig();
      KryoSerializer<FakeAvroClass> kryoSerializer=new KryoSerializer<>(FakeAvroClass.class,executionConfig);
      try (FileInputStream f=new FileInputStream("src/test/resources/type-with-avro-serialized-using-kryo");DataInputViewStreamWrapper inputView=new DataInputViewStreamWrapper(f)){
        thrown.expectMessage("Could not find required Avro dependency");
        kryoSerializer.deserialize(inputView);
      }
     }
  }
  @Test public void testMigrationWithTypeDevoidOfAvroTypes() throws Exception {
class FakeClass {
      public List<Integer> array;
      FakeClass(      List<Integer> array){
        this.array=array;
      }
    }
{
      ExecutionConfig executionConfig=new ExecutionConfig();
      KryoSerializer<FakeClass> kryoSerializer=new KryoSerializer<>(FakeClass.class,executionConfig);
      try (FileInputStream f=new FileInputStream("src/test/resources/type-without-avro-serialized-using-kryo");DataInputViewStreamWrapper inputView=new DataInputViewStreamWrapper(f)){
        FakeClass myTestClass=kryoSerializer.deserialize(inputView);
        assertThat(myTestClass.array.get(0),is(10));
        assertThat(myTestClass.array.get(1),is(20));
        assertThat(myTestClass.array.get(2),is(30));
      }
     }
  }
  /** 
 * Tests that after reconfiguration, registration ids are reconfigured to remain the same as the preceding KryoSerializer.
 */
  @Test public void testMigrationStrategyForDifferentRegistrationOrder() throws Exception {
    ExecutionConfig executionConfig=new ExecutionConfig();
    executionConfig.registerKryoType(TestClassA.class);
    executionConfig.registerKryoType(TestClassB.class);
    KryoSerializer<TestClass> kryoSerializer=new KryoSerializer<>(TestClass.class,executionConfig);
    int testClassId=kryoSerializer.getKryo().getRegistration(TestClass.class).getId();
    int testClassAId=kryoSerializer.getKryo().getRegistration(TestClassA.class).getId();
    int testClassBId=kryoSerializer.getKryo().getRegistration(TestClassB.class).getId();
    TypeSerializerConfigSnapshot kryoSerializerConfigSnapshot=kryoSerializer.snapshotConfiguration();
    byte[] serializedConfig;
    try (ByteArrayOutputStream out=new ByteArrayOutputStream()){
      TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out),kryoSerializerConfigSnapshot);
      serializedConfig=out.toByteArray();
    }
     executionConfig=new ExecutionConfig();
    executionConfig.registerKryoType(TestClassB.class);
    executionConfig.registerKryoType(TestClassA.class);
    kryoSerializer=new KryoSerializer<>(TestClass.class,executionConfig);
    try (ByteArrayInputStream in=new ByteArrayInputStream(serializedConfig)){
      kryoSerializerConfigSnapshot=TypeSerializerSerializationUtil.readSerializerConfigSnapshot(new DataInputViewStreamWrapper(in),Thread.currentThread().getContextClassLoader());
    }
     CompatibilityResult<TestClass> compatResult=kryoSerializer.ensureCompatibility(kryoSerializerConfigSnapshot);
    assertFalse(compatResult.isRequiresMigration());
    assertEquals(testClassId,kryoSerializer.getKryo().getRegistration(TestClass.class).getId());
    assertEquals(testClassAId,kryoSerializer.getKryo().getRegistration(TestClassA.class).getId());
    assertEquals(testClassBId,kryoSerializer.getKryo().getRegistration(TestClassB.class).getId());
  }
private static class TestClass {
  }
private static class TestClassA {
  }
private static class TestClassB {
  }
private static class TestClassBSerializer extends Serializer {
    @Override public void write(    Kryo kryo,    Output output,    Object o){
      throw new UnsupportedOperationException();
    }
    @Override public Object read(    Kryo kryo,    Input input,    Class aClass){
      throw new UnsupportedOperationException();
    }
  }
}
