/** 
 * Tests for  {@link ProcessingTimeSessionWindows}.
 */
public class ProcessingTimeSessionWindowsTest extends TestLogger {
  @Test public void testWindowAssignment(){
    WindowAssigner.WindowAssignerContext mockContext=mock(WindowAssigner.WindowAssignerContext.class);
    ProcessingTimeSessionWindows assigner=ProcessingTimeSessionWindows.withGap(Time.milliseconds(5000));
    when(mockContext.getCurrentProcessingTime()).thenReturn(0L);
    assertThat(assigner.assignWindows("String",Long.MIN_VALUE,mockContext),contains(timeWindow(0,5000)));
    when(mockContext.getCurrentProcessingTime()).thenReturn(4999L);
    assertThat(assigner.assignWindows("String",Long.MIN_VALUE,mockContext),contains(timeWindow(4999,9999)));
    when(mockContext.getCurrentProcessingTime()).thenReturn(5000L);
    assertThat(assigner.assignWindows("String",Long.MIN_VALUE,mockContext),contains(timeWindow(5000,10000)));
  }
  @Test public void testMergeSinglePointWindow(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    ProcessingTimeSessionWindows assigner=ProcessingTimeSessionWindows.withGap(Time.milliseconds(5000));
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(0,0)),callback);
    verify(callback,never()).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testMergeSingleWindow(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    ProcessingTimeSessionWindows assigner=ProcessingTimeSessionWindows.withGap(Time.milliseconds(5000));
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(0,1)),callback);
    verify(callback,never()).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testMergeConsecutiveWindows(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    ProcessingTimeSessionWindows assigner=ProcessingTimeSessionWindows.withGap(Time.milliseconds(5000));
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(0,1),new TimeWindow(1,2),new TimeWindow(2,3),new TimeWindow(4,5),new TimeWindow(5,6)),callback);
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(0,1),new TimeWindow(1,2),new TimeWindow(2,3))),eq(new TimeWindow(0,3)));
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(4,5),new TimeWindow(5,6))),eq(new TimeWindow(4,6)));
    verify(callback,times(2)).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testMergeCoveringWindow(){
    MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
    ProcessingTimeSessionWindows assigner=ProcessingTimeSessionWindows.withGap(Time.milliseconds(5000));
    assigner.mergeWindows(Lists.newArrayList(new TimeWindow(1,1),new TimeWindow(0,2),new TimeWindow(4,7),new TimeWindow(5,6)),callback);
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(1,1),new TimeWindow(0,2))),eq(new TimeWindow(0,2)));
    verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(5,6),new TimeWindow(4,7))),eq(new TimeWindow(4,7)));
    verify(callback,times(2)).merge(anyCollection(),Matchers.anyObject());
  }
  @Test public void testTimeUnits(){
    WindowAssigner.WindowAssignerContext mockContext=mock(WindowAssigner.WindowAssignerContext.class);
    ProcessingTimeSessionWindows assigner=ProcessingTimeSessionWindows.withGap(Time.seconds(5));
    when(mockContext.getCurrentProcessingTime()).thenReturn(0L);
    assertThat(assigner.assignWindows("String",Long.MIN_VALUE,mockContext),contains(timeWindow(0,5000)));
    when(mockContext.getCurrentProcessingTime()).thenReturn(4999L);
    assertThat(assigner.assignWindows("String",Long.MIN_VALUE,mockContext),contains(timeWindow(4999,9999)));
    when(mockContext.getCurrentProcessingTime()).thenReturn(5000L);
    assertThat(assigner.assignWindows("String",Long.MIN_VALUE,mockContext),contains(timeWindow(5000,10000)));
  }
  @Test public void testInvalidParameters(){
    try {
      ProcessingTimeSessionWindows.withGap(Time.seconds(-1));
      fail("should fail");
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.toString(),containsString("0 < size"));
    }
    try {
      ProcessingTimeSessionWindows.withGap(Time.seconds(0));
      fail("should fail");
    }
 catch (    IllegalArgumentException e) {
      assertThat(e.toString(),containsString("0 < size"));
    }
  }
  @Test public void testProperties(){
    ProcessingTimeSessionWindows assigner=ProcessingTimeSessionWindows.withGap(Time.seconds(5));
    assertFalse(assigner.isEventTime());
    assertEquals(new TimeWindow.Serializer(),assigner.getWindowSerializer(new ExecutionConfig()));
    assertThat(assigner.getDefaultTrigger(mock(StreamExecutionEnvironment.class)),instanceOf(ProcessingTimeTrigger.class));
  }
  @Test public void testDynamicGapProperties(){
    SessionWindowTimeGapExtractor<String> extractor=mock(SessionWindowTimeGapExtractor.class);
    DynamicProcessingTimeSessionWindows<String> assigner=ProcessingTimeSessionWindows.withDynamicGap(extractor);
    assertNotNull(assigner);
    assertFalse(assigner.isEventTime());
  }
}
