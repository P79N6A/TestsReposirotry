/** 
 * Tests for  {@link PipelinedSubpartition}.
 * @see PipelinedSubpartitionWithReadViewTest
 */
public class PipelinedSubpartitionTest extends SubpartitionTestBase {
  /** 
 * Executor service for concurrent produce/consume tests. 
 */
  private static final ExecutorService executorService=Executors.newCachedThreadPool();
  @AfterClass public static void shutdownExecutorService() throws Exception {
    executorService.shutdownNow();
  }
  @Override PipelinedSubpartition createSubpartition(){
    final ResultPartition parent=mock(ResultPartition.class);
    return new PipelinedSubpartition(0,parent);
  }
  @Test public void testIllegalReadViewRequest() throws Exception {
    final PipelinedSubpartition subpartition=createSubpartition();
    assertNotNull(subpartition.createReadView(new NoOpBufferAvailablityListener()));
    try {
      subpartition.createReadView(new NoOpBufferAvailablityListener());
      fail("Did not throw expected exception after duplicate notifyNonEmpty view request.");
    }
 catch (    IllegalStateException expected) {
    }
  }
  /** 
 * Verifies that the isReleased() check of the view checks the parent subpartition.
 */
  @Test public void testIsReleasedChecksParent(){
    PipelinedSubpartition subpartition=mock(PipelinedSubpartition.class);
    PipelinedSubpartitionView reader=new PipelinedSubpartitionView(subpartition,mock(BufferAvailabilityListener.class));
    assertFalse(reader.isReleased());
    verify(subpartition,times(1)).isReleased();
    when(subpartition.isReleased()).thenReturn(true);
    assertTrue(reader.isReleased());
    verify(subpartition,times(2)).isReleased();
  }
  @Test public void testConcurrentFastProduceAndFastConsume() throws Exception {
    testProduceConsume(false,false);
  }
  @Test public void testConcurrentFastProduceAndSlowConsume() throws Exception {
    testProduceConsume(false,true);
  }
  @Test public void testConcurrentSlowProduceAndFastConsume() throws Exception {
    testProduceConsume(true,false);
  }
  @Test public void testConcurrentSlowProduceAndSlowConsume() throws Exception {
    testProduceConsume(true,true);
  }
  private void testProduceConsume(  boolean isSlowProducer,  boolean isSlowConsumer) throws Exception {
    final int producerBufferPoolSize=8;
    final int producerNumberOfBuffersToProduce=128;
    final TestProducerSource producerSource=new TestProducerSource(){
      private BufferProvider bufferProvider=new TestPooledBufferProvider(producerBufferPoolSize);
      private int numberOfBuffers;
      @Override public BufferConsumerAndChannel getNextBufferConsumer() throws Exception {
        if (numberOfBuffers == producerNumberOfBuffersToProduce) {
          return null;
        }
        final BufferBuilder bufferBuilder=bufferProvider.requestBufferBuilderBlocking();
        int segmentSize=bufferBuilder.getMaxCapacity();
        MemorySegment segment=MemorySegmentFactory.allocateUnpooledSegment(segmentSize);
        int next=numberOfBuffers * (segmentSize / Integer.BYTES);
        for (int i=0; i < segmentSize; i+=4) {
          segment.putInt(i,next);
          next++;
        }
        checkState(bufferBuilder.appendAndCommit(ByteBuffer.wrap(segment.getArray())) == segmentSize);
        bufferBuilder.finish();
        numberOfBuffers++;
        return new BufferConsumerAndChannel(bufferBuilder.createBufferConsumer(),0);
      }
    }
;
    final TestConsumerCallback consumerCallback=new TestConsumerCallback(){
      private int numberOfBuffers;
      @Override public void onBuffer(      Buffer buffer){
        final MemorySegment segment=buffer.getMemorySegment();
        assertEquals(segment.size(),buffer.getSize());
        int expected=numberOfBuffers * (segment.size() / 4);
        for (int i=0; i < segment.size(); i+=4) {
          assertEquals(expected,segment.getInt(i));
          expected++;
        }
        numberOfBuffers++;
        buffer.recycleBuffer();
      }
      @Override public void onEvent(      AbstractEvent event){
      }
    }
;
    final PipelinedSubpartition subpartition=createSubpartition();
    TestSubpartitionConsumer consumer=new TestSubpartitionConsumer(isSlowConsumer,consumerCallback);
    final PipelinedSubpartitionView view=subpartition.createReadView(consumer);
    consumer.setSubpartitionView(view);
    Future<Boolean> producerResult=executorService.submit(new TestSubpartitionProducer(subpartition,isSlowProducer,producerSource));
    Future<Boolean> consumerResult=executorService.submit(consumer);
    waitForAll(60_000L,producerResult,consumerResult);
  }
  /** 
 * Tests cleanup of  {@link PipelinedSubpartition#release()} with no read view attached.
 */
  @Test public void testCleanupReleasedPartitionNoView() throws Exception {
    testCleanupReleasedPartition(false);
  }
  /** 
 * Tests cleanup of  {@link PipelinedSubpartition#release()} with a read view attached.
 */
  @Test public void testCleanupReleasedPartitionWithView() throws Exception {
    testCleanupReleasedPartition(true);
  }
  /** 
 * Tests cleanup of  {@link PipelinedSubpartition#release()}.
 * @param createView whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)
 */
  private void testCleanupReleasedPartition(  boolean createView) throws Exception {
    PipelinedSubpartition partition=createSubpartition();
    BufferConsumer buffer1=createFilledBufferConsumer(4096);
    BufferConsumer buffer2=createFilledBufferConsumer(4096);
    boolean buffer1Recycled;
    boolean buffer2Recycled;
    try {
      partition.add(buffer1);
      partition.add(buffer2);
      ResultSubpartitionView view=null;
      if (createView) {
        view=partition.createReadView(new NoOpBufferAvailablityListener());
      }
      partition.release();
      assertTrue(partition.isReleased());
      if (createView) {
        assertTrue(view.isReleased());
      }
      assertTrue(buffer1.isRecycled());
    }
  finally {
      buffer1Recycled=buffer1.isRecycled();
      if (!buffer1Recycled) {
        buffer1.close();
      }
      buffer2Recycled=buffer2.isRecycled();
      if (!buffer2Recycled) {
        buffer2.close();
      }
    }
    if (!buffer1Recycled) {
      Assert.fail("buffer 1 not recycled");
    }
    if (!buffer2Recycled) {
      Assert.fail("buffer 2 not recycled");
    }
    assertEquals(2,partition.getTotalNumberOfBuffers());
    assertEquals(0,partition.getTotalNumberOfBytes());
  }
}
