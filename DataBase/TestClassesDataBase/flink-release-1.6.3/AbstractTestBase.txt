/** 
 * Base class for unit tests that run multiple tests and want to reuse the same Flink cluster. This saves a significant amount of time, since the startup and shutdown of the Flink clusters (including actor systems, etc) usually dominates the execution of the actual tests. <p>To write a unit test against this test base, simply extend it and add one or more regular test methods and retrieve the StreamExecutionEnvironment from the context: <pre> {@literal @}Test public void someTest() { ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment(); // test code env.execute(); } {@literal @}Test public void anotherTest() { StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // test code env.execute(); } </pre>
 */
public abstract class AbstractTestBase extends TestBaseUtils {
  private static final int DEFAULT_PARALLELISM=4;
  @ClassRule public static MiniClusterResource miniClusterResource=new MiniClusterResource(new MiniClusterResourceConfiguration.Builder().setNumberTaskManagers(1).setNumberSlotsPerTaskManager(DEFAULT_PARALLELISM).build());
  @ClassRule public static final TemporaryFolder TEMPORARY_FOLDER=new TemporaryFolder();
  public String getTempDirPath(  String dirName) throws IOException {
    File f=createAndRegisterTempFile(dirName);
    return f.toURI().toString();
  }
  public String getTempFilePath(  String fileName) throws IOException {
    File f=createAndRegisterTempFile(fileName);
    return f.toURI().toString();
  }
  public String createTempFile(  String fileName,  String contents) throws IOException {
    File f=createAndRegisterTempFile(fileName);
    if (!f.getParentFile().exists()) {
      f.getParentFile().mkdirs();
    }
    f.createNewFile();
    FileUtils.writeFileUtf8(f,contents);
    return f.toURI().toString();
  }
  public File createAndRegisterTempFile(  String fileName) throws IOException {
    return new File(TEMPORARY_FOLDER.newFolder(),fileName);
  }
}
