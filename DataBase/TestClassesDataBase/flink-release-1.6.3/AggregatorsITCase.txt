/** 
 * Test the functionality of aggregators in bulk and delta iterative cases.
 */
@RunWith(Parameterized.class) public class AggregatorsITCase extends MultipleProgramsTestBase {
  private static final int MAX_ITERATIONS=20;
  private static final int parallelism=2;
  private static final String NEGATIVE_ELEMENTS_AGGR="count.negative.elements";
  public AggregatorsITCase(  TestExecutionMode mode){
    super(mode);
  }
  @ClassRule public static TemporaryFolder tempFolder=new TemporaryFolder();
  @Test public void testDistributedCacheWithIterations() throws Exception {
    final String testString="Et tu, Brute?";
    final String testName="testing_caesar";
    final File folder=tempFolder.newFolder();
    final File resultFile=new File(folder,UUID.randomUUID().toString());
    String testPath=resultFile.toString();
    String resultPath=resultFile.toURI().toString();
    File tempFile=new File(testPath);
    try (FileWriter writer=new FileWriter(tempFile)){
      writer.write(testString);
    }
     final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.registerCachedFile(resultPath,testName);
    IterativeDataSet<Long> solution=env.fromElements(1L).iterate(2);
    solution.closeWith(env.generateSequence(1,2).filter(new RichFilterFunction<Long>(){
      @Override public void open(      Configuration parameters) throws Exception {
        File file=getRuntimeContext().getDistributedCache().getFile(testName);
        BufferedReader reader=new BufferedReader(new FileReader(file));
        String output=reader.readLine();
        reader.close();
        assertEquals(output,testString);
      }
      @Override public boolean filter(      Long value) throws Exception {
        return false;
      }
    }
).withBroadcastSet(solution,"SOLUTION")).output(new DiscardingOutputFormat<Long>());
    env.execute();
  }
  @Test public void testAggregatorWithoutParameterForIterate() throws Exception {
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(parallelism);
    DataSet<Integer> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env);
    IterativeDataSet<Integer> iteration=initialSolutionSet.iterate(MAX_ITERATIONS);
    LongSumAggregator aggr=new LongSumAggregator();
    iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
    iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR,aggr,new NegativeElementsConvergenceCriterion());
    DataSet<Integer> updatedDs=iteration.map(new SubtractOneMap());
    List<Integer> result=iteration.closeWith(updatedDs).collect();
    Collections.sort(result);
    List<Integer> expected=Arrays.asList(-3,-2,-2,-1,-1,-1,0,0,0,0,1,1,1,1,1);
    assertEquals(expected,result);
  }
  @Test public void testAggregatorWithParameterForIterate() throws Exception {
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(parallelism);
    DataSet<Integer> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env);
    IterativeDataSet<Integer> iteration=initialSolutionSet.iterate(MAX_ITERATIONS);
    LongSumAggregatorWithParameter aggr=new LongSumAggregatorWithParameter(0);
    iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
    iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR,aggr,new NegativeElementsConvergenceCriterion());
    DataSet<Integer> updatedDs=iteration.map(new SubtractOneMapWithParam());
    List<Integer> result=iteration.closeWith(updatedDs).collect();
    Collections.sort(result);
    List<Integer> expected=Arrays.asList(-3,-2,-2,-1,-1,-1,0,0,0,0,1,1,1,1,1);
    assertEquals(expected,result);
  }
  @Test public void testConvergenceCriterionWithParameterForIterate() throws Exception {
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(parallelism);
    DataSet<Integer> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env);
    IterativeDataSet<Integer> iteration=initialSolutionSet.iterate(MAX_ITERATIONS);
    LongSumAggregator aggr=new LongSumAggregator();
    iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
    iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR,aggr,new NegativeElementsConvergenceCriterionWithParam(3));
    DataSet<Integer> updatedDs=iteration.map(new SubtractOneMap());
    List<Integer> result=iteration.closeWith(updatedDs).collect();
    Collections.sort(result);
    List<Integer> expected=Arrays.asList(-3,-2,-2,-1,-1,-1,0,0,0,0,1,1,1,1,1);
    assertEquals(expected,result);
  }
  @Test public void testAggregatorWithoutParameterForIterateDelta() throws Exception {
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(parallelism);
    DataSet<Tuple2<Integer,Integer>> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap());
    DeltaIteration<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> iteration=initialSolutionSet.iterateDelta(initialSolutionSet,MAX_ITERATIONS,0);
    LongSumAggregator aggr=new LongSumAggregator();
    iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
    DataSet<Tuple2<Integer,Integer>> updatedDs=iteration.getWorkset().map(new AggregateMapDelta());
    DataSet<Tuple2<Integer,Integer>> newElements=updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new UpdateFilter());
    DataSet<Tuple2<Integer,Integer>> iterationRes=iteration.closeWith(newElements,newElements);
    List<Integer> result=iterationRes.map(new ProjectSecondMapper()).collect();
    Collections.sort(result);
    List<Integer> expected=Arrays.asList(1,2,2,3,3,3,4,4,4,4,5,5,5,5,5);
    assertEquals(expected,result);
  }
  @Test public void testAggregatorWithParameterForIterateDelta() throws Exception {
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(parallelism);
    DataSet<Tuple2<Integer,Integer>> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap());
    DeltaIteration<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> iteration=initialSolutionSet.iterateDelta(initialSolutionSet,MAX_ITERATIONS,0);
    LongSumAggregator aggr=new LongSumAggregatorWithParameter(4);
    iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
    DataSet<Tuple2<Integer,Integer>> updatedDs=iteration.getWorkset().map(new AggregateMapDelta());
    DataSet<Tuple2<Integer,Integer>> newElements=updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new UpdateFilter());
    DataSet<Tuple2<Integer,Integer>> iterationRes=iteration.closeWith(newElements,newElements);
    List<Integer> result=iterationRes.map(new ProjectSecondMapper()).collect();
    Collections.sort(result);
    List<Integer> expected=Arrays.asList(1,2,2,3,3,3,4,4,4,4,5,5,5,5,5);
    assertEquals(result,expected);
  }
  @Test public void testConvergenceCriterionWithParameterForIterateDelta() throws Exception {
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(parallelism);
    DataSet<Tuple2<Integer,Integer>> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap());
    DeltaIteration<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> iteration=initialSolutionSet.iterateDelta(initialSolutionSet,MAX_ITERATIONS,0);
    LongSumAggregator aggr=new LongSumAggregator();
    iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
    iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR,aggr,new NegativeElementsConvergenceCriterionWithParam(3));
    DataSet<Tuple2<Integer,Integer>> updatedDs=iteration.getWorkset().map(new AggregateAndSubtractOneDelta());
    DataSet<Tuple2<Integer,Integer>> newElements=updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).projectFirst(0,1);
    DataSet<Tuple2<Integer,Integer>> iterationRes=iteration.closeWith(newElements,newElements);
    List<Integer> result=iterationRes.map(new ProjectSecondMapper()).collect();
    Collections.sort(result);
    List<Integer> expected=Arrays.asList(-3,-2,-2,-1,-1,-1,0,0,0,0,1,1,1,1,1);
    assertEquals(expected,result);
  }
@SuppressWarnings("serial") private static final class NegativeElementsConvergenceCriterion implements ConvergenceCriterion<LongValue> {
    @Override public boolean isConverged(    int iteration,    LongValue value){
      return value.getValue() > 3;
    }
  }
@SuppressWarnings("serial") private static final class NegativeElementsConvergenceCriterionWithParam implements ConvergenceCriterion<LongValue> {
    private int value;
    public NegativeElementsConvergenceCriterionWithParam(    int val){
      this.value=val;
    }
    public int getValue(){
      return this.value;
    }
    @Override public boolean isConverged(    int iteration,    LongValue value){
      return value.getValue() > this.value;
    }
  }
@SuppressWarnings("serial") private static final class SubtractOneMap extends RichMapFunction<Integer,Integer> {
    private LongSumAggregator aggr;
    @Override public void open(    Configuration conf){
      aggr=getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR);
    }
    @Override public Integer map(    Integer value){
      Integer newValue=value - 1;
      if (newValue < 0) {
        aggr.aggregate(1L);
      }
      return newValue;
    }
  }
@SuppressWarnings("serial") private static final class SubtractOneMapWithParam extends RichMapFunction<Integer,Integer> {
    private LongSumAggregatorWithParameter aggr;
    @Override public void open(    Configuration conf){
      aggr=getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR);
    }
    @Override public Integer map(    Integer value){
      Integer newValue=value - 1;
      if (newValue < aggr.getValue()) {
        aggr.aggregate(1L);
      }
      return newValue;
    }
  }
@SuppressWarnings("serial") private static class LongSumAggregatorWithParameter extends LongSumAggregator {
    private int value;
    public LongSumAggregatorWithParameter(    int val){
      this.value=val;
    }
    public int getValue(){
      return this.value;
    }
  }
@SuppressWarnings("serial") private static final class TupleMakerMap extends RichMapFunction<Integer,Tuple2<Integer,Integer>> {
    private Random rnd;
    @Override public void open(    Configuration parameters){
      rnd=new Random(0xC0FFEBADBEEFDEADL + getRuntimeContext().getIndexOfThisSubtask());
    }
    @Override public Tuple2<Integer,Integer> map(    Integer value){
      Integer nodeId=rnd.nextInt(100000);
      return new Tuple2<>(nodeId,value);
    }
  }
@SuppressWarnings("serial") private static final class AggregateMapDelta extends RichMapFunction<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> {
    private LongSumAggregator aggr;
    private LongValue previousAggr;
    private int superstep;
    @Override public void open(    Configuration conf){
      aggr=getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR);
      superstep=getIterationRuntimeContext().getSuperstepNumber();
      if (superstep > 1) {
        previousAggr=getIterationRuntimeContext().getPreviousIterationAggregate(NEGATIVE_ELEMENTS_AGGR);
        Assert.assertEquals(superstep - 1,previousAggr.getValue());
      }
    }
    @Override public Tuple2<Integer,Integer> map(    Tuple2<Integer,Integer> value){
      if (value.f1 == superstep) {
        aggr.aggregate(1L);
      }
      return value;
    }
  }
@SuppressWarnings("serial") private static final class UpdateFilter extends RichFlatMapFunction<Tuple2<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>>,Tuple2<Integer,Integer>> {
    private int superstep;
    @Override public void open(    Configuration conf){
      superstep=getIterationRuntimeContext().getSuperstepNumber();
    }
    @Override public void flatMap(    Tuple2<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> value,    Collector<Tuple2<Integer,Integer>> out){
      if (value.f0.f1 > superstep) {
        out.collect(value.f0);
      }
    }
  }
@SuppressWarnings("serial") private static final class ProjectSecondMapper extends RichMapFunction<Tuple2<Integer,Integer>,Integer> {
    @Override public Integer map(    Tuple2<Integer,Integer> value){
      return value.f1;
    }
  }
@SuppressWarnings("serial") private static final class AggregateAndSubtractOneDelta extends RichMapFunction<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> {
    private LongSumAggregator aggr;
    private LongValue previousAggr;
    private int superstep;
    @Override public void open(    Configuration conf){
      aggr=getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR);
      superstep=getIterationRuntimeContext().getSuperstepNumber();
      if (superstep > 1) {
        previousAggr=getIterationRuntimeContext().getPreviousIterationAggregate(NEGATIVE_ELEMENTS_AGGR);
        Assert.assertEquals(superstep - 1,previousAggr.getValue());
      }
    }
    @Override public Tuple2<Integer,Integer> map(    Tuple2<Integer,Integer> value){
      if (value.f1 == 1) {
        aggr.aggregate(1L);
      }
      value.f1--;
      return value;
    }
  }
}
