private static class TwoInputTimerOperator extends AbstractStreamOperator<String> implements TwoInputStreamOperator<String,String,String>, ProcessingTimeCallback {
  private static final long serialVersionUID=1L;
  int numTimers=0;
  int numElements=0;
  private boolean first=true;
  private Semaphore semaphore=new Semaphore(1);
  public TwoInputTimerOperator(  ChainingStrategy chainingStrategy){
    setChainingStrategy(chainingStrategy);
  }
  @Override public void processElement1(  StreamRecord<String> element) throws Exception {
    if (!semaphore.tryAcquire()) {
      Assert.fail("Concurrent invocation of operator functions.");
    }
    if (first) {
      getProcessingTimeService().registerTimer(System.currentTimeMillis() + 100,this);
      first=false;
    }
    numElements++;
    semaphore.release();
  }
  @Override public void processElement2(  StreamRecord<String> element) throws Exception {
    if (!semaphore.tryAcquire()) {
      Assert.fail("Concurrent invocation of operator functions.");
    }
    if (first) {
      getProcessingTimeService().registerTimer(System.currentTimeMillis() + 100,this);
      first=false;
    }
    numElements++;
    semaphore.release();
  }
  @Override public void onProcessingTime(  long time) throws Exception {
    if (!semaphore.tryAcquire()) {
      Assert.fail("Concurrent invocation of operator functions.");
    }
    try {
      numTimers++;
      throwIfDone();
      getProcessingTimeService().registerTimer(System.currentTimeMillis() + 1,this);
    }
  finally {
      semaphore.release();
    }
  }
  private void throwIfDone(){
    if (numTimers > 1000 && numElements > 10_000) {
      throw new RuntimeException("TEST SUCCESS");
    }
  }
  @Override public void processWatermark1(  Watermark mark) throws Exception {
  }
  @Override public void processWatermark2(  Watermark mark) throws Exception {
  }
}
