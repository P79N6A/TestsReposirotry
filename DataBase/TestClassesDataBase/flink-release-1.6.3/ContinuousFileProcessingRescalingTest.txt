/** 
 * Test processing files during rescaling.
 */
public class ContinuousFileProcessingRescalingTest {
  @Test public void testReaderScalingDown() throws Exception {
    final OneShotLatch waitingLatch=new OneShotLatch();
    final OneShotLatch triggerLatch1=new OneShotLatch();
    BlockingFileInputFormat format1=new BlockingFileInputFormat(triggerLatch1,waitingLatch,new Path("test"),20,5);
    FileInputSplit[] splits=format1.createInputSplits(2);
    OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> testHarness1=getTestHarness(format1,2,0);
    testHarness1.open();
    testHarness1.processElement(new StreamRecord<>(getTimestampedSplit(0,splits[0])));
    if (!triggerLatch1.isTriggered()) {
      triggerLatch1.await();
    }
    final OneShotLatch triggerLatch2=new OneShotLatch();
    BlockingFileInputFormat format2=new BlockingFileInputFormat(triggerLatch2,waitingLatch,new Path("test"),20,15);
    OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> testHarness2=getTestHarness(format2,2,1);
    testHarness2.open();
    testHarness2.processElement(new StreamRecord<>(getTimestampedSplit(0,splits[1])));
    if (!triggerLatch2.isTriggered()) {
      triggerLatch2.await();
    }
    testHarness1.getOutput().clear();
    testHarness2.getOutput().clear();
    OperatorSubtaskState mergedState=AbstractStreamOperatorTestHarness.repackageState(testHarness2.snapshot(0,0),testHarness1.snapshot(0,0));
    final OneShotLatch wLatch=new OneShotLatch();
    final OneShotLatch tLatch=new OneShotLatch();
    BlockingFileInputFormat format=new BlockingFileInputFormat(wLatch,tLatch,new Path("test"),20,5);
    OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> testHarness=getTestHarness(format,1,0);
    testHarness.initializeState(mergedState);
    testHarness.open();
    wLatch.trigger();
    tLatch.trigger();
    waitingLatch.trigger();
synchronized (testHarness1.getCheckpointLock()) {
      testHarness1.close();
    }
synchronized (testHarness2.getCheckpointLock()) {
      testHarness2.close();
    }
synchronized (testHarness.getCheckpointLock()) {
      testHarness.close();
    }
    Queue<Object> expectedResult=new ArrayDeque<>();
    putElementsInQ(expectedResult,testHarness1.getOutput());
    putElementsInQ(expectedResult,testHarness2.getOutput());
    Queue<Object> actualResult=new ArrayDeque<>();
    putElementsInQ(actualResult,testHarness.getOutput());
    Assert.assertEquals(20,actualResult.size());
    Assert.assertArrayEquals(expectedResult.toArray(),actualResult.toArray());
  }
  @Test public void testReaderScalingUp() throws Exception {
    final OneShotLatch waitingLatch1=new OneShotLatch();
    final OneShotLatch triggerLatch1=new OneShotLatch();
    BlockingFileInputFormat format1=new BlockingFileInputFormat(triggerLatch1,waitingLatch1,new Path("test"),20,5);
    FileInputSplit[] splits=format1.createInputSplits(2);
    OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> testHarness1=getTestHarness(format1,1,0);
    testHarness1.open();
    testHarness1.processElement(new StreamRecord<>(getTimestampedSplit(0,splits[0])));
    testHarness1.processElement(new StreamRecord<>(getTimestampedSplit(1,splits[1])));
    if (!triggerLatch1.isTriggered()) {
      triggerLatch1.await();
    }
    OperatorSubtaskState snapshot=testHarness1.snapshot(0,0);
    testHarness1.getOutput().clear();
    waitingLatch1.trigger();
    final OneShotLatch triggerLatch2=new OneShotLatch();
    final OneShotLatch waitingLatch2=new OneShotLatch();
    BlockingFileInputFormat format2=new BlockingFileInputFormat(triggerLatch2,waitingLatch2,new Path("test"),20,15);
    OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> testHarness2=getTestHarness(format2,2,0);
    testHarness2.setup();
    testHarness2.initializeState(snapshot);
    testHarness2.open();
    BlockingFileInputFormat format3=new BlockingFileInputFormat(triggerLatch2,waitingLatch2,new Path("test"),20,15);
    OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> testHarness3=getTestHarness(format3,2,1);
    testHarness3.setup();
    testHarness3.initializeState(snapshot);
    testHarness3.open();
    triggerLatch2.trigger();
    waitingLatch2.trigger();
synchronized (testHarness1.getCheckpointLock()) {
      testHarness1.close();
    }
synchronized (testHarness2.getCheckpointLock()) {
      testHarness2.close();
    }
synchronized (testHarness3.getCheckpointLock()) {
      testHarness3.close();
    }
    Queue<Object> expectedResult=new ArrayDeque<>();
    putElementsInQ(expectedResult,testHarness1.getOutput());
    Queue<Object> actualResult=new ArrayDeque<>();
    putElementsInQ(actualResult,testHarness2.getOutput());
    putElementsInQ(actualResult,testHarness3.getOutput());
    Assert.assertEquals(35,actualResult.size());
    Assert.assertArrayEquals(expectedResult.toArray(),actualResult.toArray());
  }
  private void putElementsInQ(  Queue<Object> res,  Queue<Object> partial){
    for (    Object o : partial) {
      if (o instanceof Watermark) {
        continue;
      }
      res.add(o);
    }
  }
  private OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> getTestHarness(  BlockingFileInputFormat format,  int noOfTasks,  int taksIdx) throws Exception {
    ContinuousFileReaderOperator<String> reader=new ContinuousFileReaderOperator<>(format);
    reader.setOutputType(TypeExtractor.getInputFormatTypes(format),new ExecutionConfig());
    OneInputStreamOperatorTestHarness<TimestampedFileInputSplit,String> testHarness=new OneInputStreamOperatorTestHarness<>(reader,10,noOfTasks,taksIdx);
    testHarness.setTimeCharacteristic(TimeCharacteristic.EventTime);
    return testHarness;
  }
  private TimestampedFileInputSplit getTimestampedSplit(  long modTime,  FileInputSplit split){
    Preconditions.checkNotNull(split);
    return new TimestampedFileInputSplit(modTime,split.getSplitNumber(),split.getPath(),split.getStart(),split.getLength(),split.getHostnames());
  }
private static class BlockingFileInputFormat extends FileInputFormat<String> implements CheckpointableInputFormat<FileInputSplit,Integer> {
    private final OneShotLatch triggerLatch;
    private final OneShotLatch waitingLatch;
    private final int elementsBeforeCheckpoint;
    private final int linesPerSplit;
    private FileInputSplit split;
    private int state;
    BlockingFileInputFormat(    OneShotLatch triggerLatch,    OneShotLatch waitingLatch,    Path filePath,    int sizeOfSplit,    int elementsBeforeCheckpoint){
      super(filePath);
      this.triggerLatch=triggerLatch;
      this.waitingLatch=waitingLatch;
      this.elementsBeforeCheckpoint=elementsBeforeCheckpoint;
      this.linesPerSplit=sizeOfSplit;
      this.state=0;
    }
    @Override public FileInputSplit[] createInputSplits(    int minNumSplits) throws IOException {
      FileInputSplit[] splits=new FileInputSplit[minNumSplits];
      for (int i=0; i < minNumSplits; i++) {
        splits[i]=new FileInputSplit(i,getFilePaths()[0],i * linesPerSplit + 1,linesPerSplit,null);
      }
      return splits;
    }
    @Override public void open(    FileInputSplit fileSplit) throws IOException {
      this.split=fileSplit;
      this.state=0;
    }
    @Override public void reopen(    FileInputSplit split,    Integer state) throws IOException {
      this.split=split;
      this.state=state;
    }
    @Override public Integer getCurrentState() throws IOException {
      return state;
    }
    @Override public boolean reachedEnd() throws IOException {
      if (state == elementsBeforeCheckpoint) {
        triggerLatch.trigger();
        if (!waitingLatch.isTriggered()) {
          try {
            waitingLatch.await();
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
      return state == linesPerSplit;
    }
    @Override public String nextRecord(    String reuse) throws IOException {
      return reachedEnd() ? null : split.getSplitNumber() + ": test line " + state++;
    }
  }
}
