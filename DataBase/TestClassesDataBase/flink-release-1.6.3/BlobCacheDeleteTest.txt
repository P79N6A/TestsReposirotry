/** 
 * Tests how DELETE requests behave.
 */
public class BlobCacheDeleteTest extends TestLogger {
  private final Random rnd=new Random();
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  @Test public void testDeleteTransient1() throws IOException {
    testDelete(null,new JobID());
  }
  @Test public void testDeleteTransient2() throws IOException {
    testDelete(new JobID(),null);
  }
  @Test public void testDeleteTransient3() throws IOException {
    testDelete(null,null);
  }
  @Test public void testDeleteTransient4() throws IOException {
    testDelete(new JobID(),new JobID());
  }
  @Test public void testDeleteTransient5() throws IOException {
    JobID jobId=new JobID();
    testDelete(jobId,jobId);
  }
  /** 
 * Uploads a (different) byte array for each of the given jobs and verifies that deleting one of them (via the  {@link BlobCacheService}) does not influence the other.
 * @param jobId1 first job id
 * @param jobId2 second job id
 */
  private void testDelete(  @Nullable JobID jobId1,  @Nullable JobID jobId2) throws IOException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      byte[] data2=Arrays.copyOf(data,data.length);
      data2[0]^=1;
      TransientBlobKey key1=(TransientBlobKey)put(server,jobId1,data,TRANSIENT_BLOB);
      assertNotNull(key1);
      TransientBlobKey key2a=(TransientBlobKey)put(server,jobId2,data,TRANSIENT_BLOB);
      assertNotNull(key2a);
      BlobKeyTest.verifyKeyDifferentHashEquals(key1,key2a);
      TransientBlobKey key2b=(TransientBlobKey)put(server,jobId2,data2,TRANSIENT_BLOB);
      assertNotNull(key2b);
      BlobKeyTest.verifyKeyDifferentHashDifferent(key1,key2b);
      assertTrue(delete(cache,jobId1,key1));
      assertTrue(server.getStorageLocation(jobId1,key1).exists());
      assertTrue(server.deleteInternal(jobId1,key1));
      verifyDeleted(cache,jobId1,key1);
      verifyContents(server,jobId2,key2a,data);
      verifyContents(server,jobId2,key2b,data2);
      assertTrue(delete(cache,jobId2,key2a));
      assertTrue(server.getStorageLocation(jobId2,key2a).exists());
      assertTrue(server.deleteInternal(jobId2,key2a));
      verifyDeleted(cache,jobId2,key2a);
      verifyContents(server,jobId2,key2b,data2);
      assertTrue(delete(cache,jobId2,key2b));
      assertTrue(server.getStorageLocation(jobId2,key2b).exists());
      assertTrue(server.deleteInternal(jobId2,key2b));
      verifyDeleted(cache,jobId2,key2b);
    }
   }
  @Test public void testDeleteTransientAlreadyDeletedNoJob() throws IOException {
    testDeleteTransientAlreadyDeleted(null);
  }
  @Test public void testDeleteTransientAlreadyDeletedForJob() throws IOException {
    testDeleteTransientAlreadyDeleted(new JobID());
  }
  /** 
 * Uploads a byte array for the given job and verifies that deleting it (via the  {@link BlobCacheService}) does not fail independent of whether the file exists.
 * @param jobId job id
 */
  private void testDeleteTransientAlreadyDeleted(  @Nullable final JobID jobId) throws IOException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      TransientBlobKey key=(TransientBlobKey)put(server,jobId,data,TRANSIENT_BLOB);
      assertNotNull(key);
      File blobFile=server.getStorageLocation(jobId,key);
      assertTrue(blobFile.delete());
      assertTrue(delete(cache,jobId,key));
      verifyDeleted(cache,jobId,key);
      assertTrue(delete(cache,jobId,key));
      verifyDeleted(cache,jobId,key);
    }
   }
  @Test public void testDeleteTransientLocalFailsNoJob() throws IOException, InterruptedException {
    testDeleteTransientLocalFails(null);
  }
  @Test public void testDeleteTransientLocalFailsForJob() throws IOException, InterruptedException {
    testDeleteTransientLocalFails(new JobID());
  }
  /** 
 * Uploads a byte array for the given job and verifies that a delete operation (via the  {@link BlobCacheService}) does not fail even if the file is not deletable locally, e.g. via restricting the permissions.
 * @param jobId job id
 */
  private void testDeleteTransientLocalFails(  @Nullable final JobID jobId) throws IOException, InterruptedException {
    assumeTrue(!OperatingSystem.isWindows());
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    File blobFile=null;
    File directory=null;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      try {
        byte[] data=new byte[2000000];
        rnd.nextBytes(data);
        TransientBlobKey key=(TransientBlobKey)put(server,jobId,data,TRANSIENT_BLOB);
        assertNotNull(key);
        verifyContents(cache,jobId,key,data);
        blobFile=cache.getTransientBlobService().getStorageLocation(jobId,key);
        directory=blobFile.getParentFile();
        assertTrue(blobFile.setWritable(false,false));
        assertTrue(directory.setWritable(false,false));
        assertFalse(delete(cache,jobId,key));
        verifyContents(cache,jobId,key,data);
        verifyDeletedEventually(server,jobId,key);
      }
  finally {
        if (blobFile != null && directory != null) {
          blobFile.setWritable(true,false);
          directory.setWritable(true,false);
        }
      }
    }
   }
  @Test public void testConcurrentDeleteOperationsNoJobTransient() throws IOException, ExecutionException, InterruptedException {
    testConcurrentDeleteOperations(null);
  }
  @Test public void testConcurrentDeleteOperationsForJobTransient() throws IOException, ExecutionException, InterruptedException {
    testConcurrentDeleteOperations(new JobID());
  }
  /** 
 * [FLINK-6020] Tests that concurrent delete operations don't interfere with each other. <p>Note: This test checks that there cannot be two threads which have checked whether a given blob file exist and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely broken.
 * @param jobId job ID to use (or <tt>null</tt> if job-unrelated)
 */
  private void testConcurrentDeleteOperations(  @Nullable final JobID jobId) throws IOException, InterruptedException, ExecutionException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    final int concurrentDeleteOperations=3;
    final ExecutorService executor=Executors.newFixedThreadPool(concurrentDeleteOperations);
    final List<CompletableFuture<Void>> deleteFutures=new ArrayList<>(concurrentDeleteOperations);
    final byte[] data={1,2,3};
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      final TransientBlobKey blobKey=(TransientBlobKey)put(server,jobId,data,TRANSIENT_BLOB);
      assertTrue(server.getStorageLocation(jobId,blobKey).exists());
      for (int i=0; i < concurrentDeleteOperations; i++) {
        CompletableFuture<Void> deleteFuture=CompletableFuture.supplyAsync(() -> {
          try {
            assertTrue(delete(cache,jobId,blobKey));
            assertFalse(cache.getTransientBlobService().getStorageLocation(jobId,blobKey).exists());
            assertTrue(server.getStorageLocation(jobId,blobKey).exists());
            return null;
          }
 catch (          IOException e) {
            throw new CompletionException(new FlinkException("Could not upload blob.",e));
          }
        }
,executor);
        deleteFutures.add(deleteFuture);
      }
      CompletableFuture<Void> waitFuture=FutureUtils.waitForAll(deleteFutures);
      waitFuture.get();
      assertTrue(server.getStorageLocation(jobId,blobKey).exists());
    }
  finally {
      executor.shutdownNow();
    }
  }
}
