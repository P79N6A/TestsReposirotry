/** 
 * Tests for the behavior of the  {@link BarrierBuffer} with different {@link BufferBlocker} implements.
 */
public abstract class BarrierBufferTestBase {
  protected static final int PAGE_SIZE=512;
  private static final Random RND=new Random();
  private static int sizeCounter=1;
  abstract BarrierBuffer createBarrierHandler(  InputGate gate) throws IOException ;
  abstract void validateAlignmentBuffered(  long actualBytesBuffered,  BufferOrEvent... sequence);
  /** 
 * Validates that the buffer behaves correctly if no checkpoint barriers come, for a single input channel.
 */
  @Test public void testSingleChannelNoBarriers() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,1,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    for (    BufferOrEvent boe : sequence) {
      assertEquals(boe,buffer.getNextNonBlocked());
    }
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * Validates that the buffer behaves correctly if no checkpoint barriers come, for an input with multiple input channels.
 */
  @Test public void testMultiChannelNoBarriers() throws Exception {
    BufferOrEvent[] sequence={createBuffer(2,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createEndOfPartition(0),createBuffer(3,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createEndOfPartition(3),createBuffer(1,PAGE_SIZE),createEndOfPartition(1),createBuffer(2,PAGE_SIZE),createEndOfPartition(2)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,4,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    for (    BufferOrEvent boe : sequence) {
      assertEquals(boe,buffer.getNextNonBlocked());
    }
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * Validates that the buffer preserved the order of elements for a input with a single input channel, and checkpoint events.
 */
  @Test public void testSingleChannelWithBarriers() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,0),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,0),createBarrier(3,0),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(4,0),createBarrier(5,0),createBarrier(6,0),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,1,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    ValidatingCheckpointHandler handler=new ValidatingCheckpointHandler();
    buffer.registerCheckpointEventHandler(handler);
    handler.setNextExpectedCheckpointId(1L);
    for (    BufferOrEvent boe : sequence) {
      if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
        assertEquals(boe,buffer.getNextNonBlocked());
      }
    }
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * Validates that the buffer correctly aligns the streams for inputs with multiple input channels, by buffering and blocking certain inputs.
 */
  @Test public void testMultiChannelWithBarriers() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,0),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBarrier(2,1),createBarrier(2,2),createBuffer(2,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(3,2),createBuffer(2,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(3,0),createBarrier(3,1),createBarrier(4,1),createBarrier(4,2),createBarrier(4,0),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(5,1),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBarrier(5,2),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBarrier(5,0),createBuffer(0,PAGE_SIZE),createEndOfPartition(0),createEndOfPartition(1),createEndOfPartition(2)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    ValidatingCheckpointHandler handler=new ValidatingCheckpointHandler();
    buffer.registerCheckpointEventHandler(handler);
    handler.setNextExpectedCheckpointId(1L);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,handler.getNextExpectedCheckpointId());
    long startTs=System.nanoTime();
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,handler.getNextExpectedCheckpointId());
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,handler.getNextExpectedCheckpointId());
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    validateAlignmentBuffered(handler.getLastReportedBytesBufferedInAlignment(),sequence[5],sequence[6]);
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[11],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,handler.getNextExpectedCheckpointId());
    startTs=System.nanoTime();
    check(sequence[17],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(3L,handler.getNextExpectedCheckpointId());
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    validateAlignmentBuffered(handler.getLastReportedBytesBufferedInAlignment());
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[20],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentBuffered(handler.getLastReportedBytesBufferedInAlignment(),sequence[20],sequence[21]);
    assertEquals(4L,handler.getNextExpectedCheckpointId());
    check(sequence[21],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[27],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentBuffered(handler.getLastReportedBytesBufferedInAlignment());
    assertEquals(5L,handler.getNextExpectedCheckpointId());
    check(sequence[28],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[29],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[31],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[32],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[33],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[37],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[34],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[36],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[38],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[39],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[41],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[42],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[43],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[44],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    validateAlignmentBuffered(handler.getLastReportedBytesBufferedInAlignment(),sequence[34],sequence[36],sequence[38],sequence[39]);
    buffer.cleanup();
  }
  @Test public void testMultiChannelTrailingBlockedData() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBarrier(1,0),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,1),createBuffer(1,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createEndOfPartition(1),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,2),createBuffer(2,PAGE_SIZE),createEndOfPartition(2),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    ValidatingCheckpointHandler handler=new ValidatingCheckpointHandler();
    buffer.registerCheckpointEventHandler(handler);
    handler.setNextExpectedCheckpointId(1L);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,handler.getNextExpectedCheckpointId());
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,handler.getNextExpectedCheckpointId());
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    long startTs=System.nanoTime();
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[14],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[11],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[17],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * Validates that the buffer correctly aligns the streams in cases where some channels receive barriers from multiple successive checkpoints before the pending checkpoint is complete.
 */
  @Test public void testMultiChannelWithQueuedFutureBarriers() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,0),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,1),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBarrier(3,0),createBuffer(0,PAGE_SIZE),createBarrier(3,1),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(4,1),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(4,0),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(5,1),createBarrier(3,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(6,1),createBarrier(4,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createEndOfPartition(1),createBuffer(2,PAGE_SIZE),createEndOfPartition(2),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    ValidatingCheckpointHandler handler=new ValidatingCheckpointHandler();
    buffer.registerCheckpointEventHandler(handler);
    handler.setNextExpectedCheckpointId(1L);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,handler.getNextExpectedCheckpointId());
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    long startTs=System.nanoTime();
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[20],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[23],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[25],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[27],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[30],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[32],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[28],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[36],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[38],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[22],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[26],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[31],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[33],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[39],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[42],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[45],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[46],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[37],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[47],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[48],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[43],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[44],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * Validates that the buffer skips over the current checkpoint if it receives a barrier from a later checkpoint on a non-blocked input.
 */
  @Test public void testMultiChannelSkippingCheckpoints() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,0),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,1),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(3,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createEndOfPartition(1),createBuffer(2,PAGE_SIZE),createEndOfPartition(2),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    long startTs;
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,buffer.getCurrentCheckpointId());
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    verify(toNotify).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[15],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(3L,buffer.getCurrentCheckpointId());
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    verify(toNotify).abortCheckpointOnBarrier(eq(2L),any(CheckpointDeclineSubsumedException.class));
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[20],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify).abortCheckpointOnBarrier(eq(3L),any(CheckpointDeclineSubsumedException.class));
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[21],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[22],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[23],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[24],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * Validates that the buffer skips over the current checkpoint if it receives a barrier from a later checkpoint on a non-blocked input.
 */
  @Test public void testMultiChannelJumpingOverCheckpoint() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,0),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,1),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(3,1),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(3,0),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(4,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createEndOfPartition(1),createBuffer(2,PAGE_SIZE),createEndOfPartition(2),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    ValidatingCheckpointHandler handler=new ValidatingCheckpointHandler();
    buffer.registerCheckpointEventHandler(handler);
    handler.setNextExpectedCheckpointId(1L);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,buffer.getCurrentCheckpointId());
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,buffer.getCurrentCheckpointId());
    check(sequence[15],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[21],buffer.getNextNonBlocked(),PAGE_SIZE);
    long startTs=System.nanoTime();
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(4L,buffer.getCurrentCheckpointId());
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[22],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[25],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[26],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[24],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[27],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[28],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[29],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[30],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * Validates that the buffer skips over a later checkpoint if it receives a barrier from an even later checkpoint on a blocked input.
 */
  @Test public void testMultiChannelSkippingCheckpointsViaBlockedInputs() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,0),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,1),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(3,0),createBuffer(0,PAGE_SIZE),createBarrier(4,1),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,2),createBuffer(0,PAGE_SIZE),createBarrier(3,2),createBuffer(2,PAGE_SIZE),createBarrier(4,0),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(4,2),createBuffer(1,PAGE_SIZE),createEndOfPartition(1),createBuffer(2,PAGE_SIZE),createEndOfPartition(2),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,buffer.getCurrentCheckpointId());
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[22],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,buffer.getCurrentCheckpointId());
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[15],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(4L,buffer.getCurrentCheckpointId());
    check(sequence[21],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[24],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[26],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[30],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[20],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[28],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[29],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[32],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[33],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[34],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[35],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[36],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[37],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  @Test public void testEarlyCleanup() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBarrier(1,0),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,1),createBuffer(1,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createEndOfPartition(1),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,2),createBuffer(2,PAGE_SIZE),createEndOfPartition(2),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    ValidatingCheckpointHandler handler=new ValidatingCheckpointHandler();
    buffer.registerCheckpointEventHandler(handler);
    handler.setNextExpectedCheckpointId(1L);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,handler.getNextExpectedCheckpointId());
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,handler.getNextExpectedCheckpointId());
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[14],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
    buffer.getNextNonBlocked();
    buffer.cleanup();
  }
  @Test public void testStartAlignmentWithClosedChannels() throws Exception {
    BufferOrEvent[] sequence={createEndOfPartition(2),createEndOfPartition(1),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(3,PAGE_SIZE),createBarrier(2,3),createBarrier(2,0),createBuffer(3,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(3,3),createBuffer(3,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(3,0),createBarrier(4,0),createBarrier(4,3),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(3,PAGE_SIZE),createEndOfPartition(0),createBuffer(3,PAGE_SIZE),createBarrier(5,3),createBuffer(3,PAGE_SIZE),createEndOfPartition(3)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,4,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[3],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[4],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,buffer.getCurrentCheckpointId());
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[11],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(3L,buffer.getCurrentCheckpointId());
    check(sequence[15],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(4L,buffer.getCurrentCheckpointId());
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[17],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[21],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(5L,buffer.getCurrentCheckpointId());
    check(sequence[22],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  @Test public void testEndOfStreamWhileCheckpoint() throws Exception {
    BufferOrEvent[] sequence={createBarrier(1,0),createBarrier(1,1),createBarrier(1,2),createBuffer(0,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,2),createBarrier(2,0),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createEndOfPartition(2),createEndOfPartition(1),createBuffer(0,PAGE_SIZE),createEndOfPartition(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    check(sequence[3],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[4],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(1L,buffer.getCurrentCheckpointId());
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(2L,buffer.getCurrentCheckpointId());
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[11],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[14],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  @Test public void testSingleChannelAbortCheckpoint() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBarrier(1,0),createBuffer(0,PAGE_SIZE),createBarrier(2,0),createCancellationBarrier(4,0),createBarrier(5,0),createBuffer(0,PAGE_SIZE),createCancellationBarrier(6,0),createBuffer(0,PAGE_SIZE)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,1,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(5L,buffer.getCurrentCheckpointId());
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(2L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(4L),any(CheckpointDeclineOnCancellationBarrierException.class));
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(5L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(6L,buffer.getCurrentCheckpointId());
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(6L),any(CheckpointDeclineOnCancellationBarrierException.class));
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    buffer.cleanup();
  }
  @Test public void testMultiChannelAbortCheckpoint() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBarrier(1,0),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBarrier(2,2),createBuffer(0,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createCancellationBarrier(2,1),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBarrier(3,1),createBarrier(3,2),createBarrier(3,0),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createCancellationBarrier(4,1),createBarrier(4,2),createBuffer(0,PAGE_SIZE),createBarrier(4,0),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(5,2),createBarrier(5,1),createBarrier(5,0),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createCancellationBarrier(6,1),createCancellationBarrier(6,2),createBarrier(6,0),createBuffer(0,PAGE_SIZE)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    long startTs;
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[1],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(2L),any(CheckpointDeclineOnCancellationBarrierException.class));
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[15],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[20],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(3L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[21],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[24],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(4L),any(CheckpointDeclineOnCancellationBarrierException.class));
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    check(sequence[26],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[27],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[28],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[32],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(5L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[33],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[37],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(6L),any(CheckpointDeclineOnCancellationBarrierException.class));
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  @Test public void testAbortViaQueuedBarriers() throws Exception {
    BufferOrEvent[] sequence={createBuffer(1,PAGE_SIZE),createBarrier(1,1),createBarrier(1,2),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createCancellationBarrier(2,2),createBarrier(2,1),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(1,0),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(2,0),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    long startTs;
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[4],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[3],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(2L),any(CheckpointDeclineOnCancellationBarrierException.class));
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[14],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[17],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertEquals(0L,buffer.getAlignmentDurationNanos());
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(any(CheckpointMetaData.class),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    verify(toNotify,times(1)).abortCheckpointOnBarrier(anyLong(),any(CheckpointDeclineOnCancellationBarrierException.class));
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
  }
  /** 
 * This tests the where a replay of queued checkpoint barriers meets a canceled checkpoint. <p>The replayed newer checkpoint barrier must not try to cancel the already canceled checkpoint.
 */
  @Test public void testAbortWhileHavingQueuedBarriers() throws Exception {
    BufferOrEvent[] sequence={createBuffer(1,PAGE_SIZE),createBarrier(1,1),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBarrier(2,1),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createCancellationBarrier(1,0),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,2),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBarrier(2,2),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    long startTs;
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[3],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[4],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    verify(toNotify).abortCheckpointOnBarrier(eq(1L),any(CheckpointDeclineOnCancellationBarrierException.class));
    startTs=System.nanoTime();
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[11],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[15],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    verify(toNotify).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(2L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[14],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[20],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(any(CheckpointMetaData.class),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    verify(toNotify,times(1)).abortCheckpointOnBarrier(anyLong(),any(Throwable.class));
  }
  /** 
 * This tests the where a cancellation barrier is received for a checkpoint already canceled due to receiving a newer checkpoint barrier.
 */
  @Test public void testIgnoreCancelBarrierIfCheckpointSubsumed() throws Exception {
    BufferOrEvent[] sequence={createBuffer(2,PAGE_SIZE),createBarrier(3,1),createBarrier(3,0),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(5,2),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createCancellationBarrier(3,2),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBarrier(5,0),createBarrier(5,1),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierBuffer buffer=createBarrierHandler(gate);
    AbstractInvokable toNotify=mock(AbstractInvokable.class);
    buffer.registerCheckpointEventHandler(toNotify);
    long startTs;
    check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[5],buffer.getNextNonBlocked(),PAGE_SIZE);
    startTs=System.nanoTime();
    check(sequence[3],buffer.getNextNonBlocked(),PAGE_SIZE);
    verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(3L),any(CheckpointDeclineSubsumedException.class));
    check(sequence[4],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[8],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[12],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
    validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(5L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    check(sequence[11],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[16],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[17],buffer.getNextNonBlocked(),PAGE_SIZE);
    check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
    assertNull(buffer.getNextNonBlocked());
    assertNull(buffer.getNextNonBlocked());
    buffer.cleanup();
    verify(toNotify,times(1)).triggerCheckpointOnBarrier(any(CheckpointMetaData.class),any(CheckpointOptions.class),any(CheckpointMetrics.class));
    verify(toNotify,times(1)).abortCheckpointOnBarrier(anyLong(),any(Throwable.class));
  }
  private static BufferOrEvent createBarrier(  long checkpointId,  int channel){
    return new BufferOrEvent(new CheckpointBarrier(checkpointId,System.currentTimeMillis(),CheckpointOptions.forCheckpointWithDefaultLocation()),channel);
  }
  private static BufferOrEvent createCancellationBarrier(  long checkpointId,  int channel){
    return new BufferOrEvent(new CancelCheckpointMarker(checkpointId),channel);
  }
  private static BufferOrEvent createBuffer(  int channel,  int pageSize){
    final int size=sizeCounter++;
    byte[] bytes=new byte[size];
    RND.nextBytes(bytes);
    MemorySegment memory=MemorySegmentFactory.allocateUnpooledSegment(pageSize);
    memory.put(0,bytes);
    Buffer buf=new NetworkBuffer(memory,FreeingBufferRecycler.INSTANCE);
    buf.setSize(size);
    buf.retainBuffer();
    return new BufferOrEvent(buf,channel);
  }
  private static BufferOrEvent createEndOfPartition(  int channel){
    return new BufferOrEvent(EndOfPartitionEvent.INSTANCE,channel);
  }
  private static void check(  BufferOrEvent expected,  BufferOrEvent present,  int pageSize){
    assertNotNull(expected);
    assertNotNull(present);
    assertEquals(expected.isBuffer(),present.isBuffer());
    if (expected.isBuffer()) {
      assertEquals(expected.getBuffer().getMaxCapacity(),present.getBuffer().getMaxCapacity());
      assertEquals(expected.getBuffer().getSize(),present.getBuffer().getSize());
      MemorySegment expectedMem=expected.getBuffer().getMemorySegment();
      MemorySegment presentMem=present.getBuffer().getMemorySegment();
      assertTrue("memory contents differs",expectedMem.compare(presentMem,0,0,pageSize) == 0);
    }
 else {
      assertEquals(expected.getEvent(),present.getEvent());
    }
  }
  private static void validateAlignmentTime(  long startTimestamp,  long alignmentDuration){
    final long elapsed=System.nanoTime() - startTimestamp;
    assertTrue("wrong alignment time",alignmentDuration <= elapsed);
  }
  /** 
 * The invokable handler used for triggering checkpoint and validation.
 */
private static class ValidatingCheckpointHandler extends AbstractInvokable {
    private long nextExpectedCheckpointId=-1L;
    private long lastReportedBytesBufferedInAlignment=-1;
    public ValidatingCheckpointHandler(){
      super(new DummyEnvironment("test",1,0));
    }
    public void setNextExpectedCheckpointId(    long nextExpectedCheckpointId){
      this.nextExpectedCheckpointId=nextExpectedCheckpointId;
    }
    public long getNextExpectedCheckpointId(){
      return nextExpectedCheckpointId;
    }
    long getLastReportedBytesBufferedInAlignment(){
      return lastReportedBytesBufferedInAlignment;
    }
    @Override public void invoke(){
      throw new UnsupportedOperationException();
    }
    @Override public boolean triggerCheckpoint(    CheckpointMetaData checkpointMetaData,    CheckpointOptions checkpointOptions) throws Exception {
      throw new UnsupportedOperationException("should never be called");
    }
    @Override public void triggerCheckpointOnBarrier(    CheckpointMetaData checkpointMetaData,    CheckpointOptions checkpointOptions,    CheckpointMetrics checkpointMetrics) throws Exception {
      assertTrue("wrong checkpoint id",nextExpectedCheckpointId == -1L || nextExpectedCheckpointId == checkpointMetaData.getCheckpointId());
      assertTrue(checkpointMetaData.getTimestamp() > 0);
      assertTrue(checkpointMetrics.getBytesBufferedInAlignment() >= 0);
      assertTrue(checkpointMetrics.getAlignmentDurationNanos() >= 0);
      nextExpectedCheckpointId++;
      lastReportedBytesBufferedInAlignment=checkpointMetrics.getBytesBufferedInAlignment();
    }
    @Override public void abortCheckpointOnBarrier(    long checkpointId,    Throwable cause){
    }
    @Override public void notifyCheckpointComplete(    long checkpointId) throws Exception {
      throw new UnsupportedOperationException("should never be called");
    }
  }
  /** 
 * The matcher used for verifying checkpoint equality.
 */
private static class CheckpointMatcher extends BaseMatcher<CheckpointMetaData> {
    private final long checkpointId;
    CheckpointMatcher(    long checkpointId){
      this.checkpointId=checkpointId;
    }
    @Override public boolean matches(    Object o){
      return o != null && o.getClass() == CheckpointMetaData.class && ((CheckpointMetaData)o).getCheckpointId() == checkpointId;
    }
    @Override public void describeTo(    Description description){
      description.appendText("CheckpointMetaData - id = " + checkpointId);
    }
  }
}
