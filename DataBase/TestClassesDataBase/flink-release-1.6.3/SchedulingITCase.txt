/** 
 * IT case for testing Flink's scheduling strategies.
 */
public class SchedulingITCase extends TestLogger {
  /** 
 * Tests that if local recovery is disabled we won't spread out tasks when recovering.
 */
  @Test public void testDisablingLocalRecovery() throws Exception {
    final Configuration configuration=new Configuration();
    configuration.setBoolean(CheckpointingOptions.LOCAL_RECOVERY,false);
    executeSchedulingTest(configuration);
  }
  /** 
 * Tests that if local recovery is enabled we won't spread out tasks when recovering for global failover.
 */
  @Test public void testLocalRecoveryFull() throws Exception {
    testLocalRecoveryInternal("full");
  }
  /** 
 * Tests that if local recovery is enabled we won't spread out tasks when recovering for regional failover.
 */
  @Test public void testLocalRecoveryRegion() throws Exception {
    testLocalRecoveryInternal("region");
  }
  private void testLocalRecoveryInternal(  String failoverStrategyValue) throws Exception {
    final Configuration configuration=new Configuration();
    configuration.setBoolean(CheckpointingOptions.LOCAL_RECOVERY,true);
    configuration.setString(EXECUTION_FAILOVER_STRATEGY.key(),failoverStrategyValue);
    executeSchedulingTest(configuration);
  }
  private void executeSchedulingTest(  Configuration configuration) throws Exception {
    configuration.setInteger(RestOptions.PORT,0);
    final long slotIdleTimeout=50L;
    configuration.setLong(JobManagerOptions.SLOT_IDLE_TIMEOUT,slotIdleTimeout);
    final int parallelism=4;
    final MiniClusterConfiguration miniClusterConfiguration=new MiniClusterConfiguration.Builder().setConfiguration(configuration).setNumTaskManagers(parallelism).setNumSlotsPerTaskManager(1).build();
    try (MiniCluster miniCluster=new MiniCluster(miniClusterConfiguration)){
      miniCluster.start();
      MiniClusterClient miniClusterClient=new MiniClusterClient(configuration,miniCluster);
      JobGraph jobGraph=createJobGraph(slotIdleTimeout << 1,parallelism);
      CompletableFuture<JobSubmissionResult> submissionFuture=miniClusterClient.submitJob(jobGraph);
      JobSubmissionResult jobSubmissionResult=submissionFuture.get();
      CompletableFuture<JobResult> resultFuture=miniClusterClient.requestJobResult(jobSubmissionResult.getJobID());
      JobResult jobResult=resultFuture.get();
      assertThat(jobResult.getSerializedThrowable().isPresent(),is(false));
    }
   }
  @Nonnull private JobGraph createJobGraph(  long delay,  int parallelism) throws IOException {
    SlotSharingGroup slotSharingGroup=new SlotSharingGroup();
    final JobVertex source=new JobVertex("source");
    source.setInvokableClass(OneTimeFailingInvokable.class);
    source.setParallelism(parallelism);
    source.setSlotSharingGroup(slotSharingGroup);
    final JobVertex sink=new JobVertex("sink");
    sink.setInvokableClass(NoOpInvokable.class);
    sink.setParallelism(parallelism);
    sink.setSlotSharingGroup(slotSharingGroup);
    sink.connectNewDataSetAsInput(source,DistributionPattern.POINTWISE,ResultPartitionType.PIPELINED);
    JobGraph jobGraph=new JobGraph(source,sink);
    jobGraph.setScheduleMode(ScheduleMode.EAGER);
    ExecutionConfig executionConfig=new ExecutionConfig();
    executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(1,delay));
    jobGraph.setExecutionConfig(executionConfig);
    return jobGraph;
  }
  /** 
 * Invokable which fails exactly once (one sub task of it).
 */
public static final class OneTimeFailingInvokable extends AbstractInvokable {
    private static final AtomicBoolean hasFailed=new AtomicBoolean(false);
    /** 
 * Create an Invokable task and set its environment.
 * @param environment The environment assigned to this invokable.
 */
    public OneTimeFailingInvokable(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      if (hasFailed.compareAndSet(false,true)) {
        throw new FlinkException("One time failure.");
      }
    }
  }
}
