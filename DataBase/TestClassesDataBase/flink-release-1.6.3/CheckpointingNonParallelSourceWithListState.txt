/** 
 * A non-parallel source with list state used for testing.
 */
public static class CheckpointingNonParallelSourceWithListState implements SourceFunction<Tuple2<Long,Long>>, CheckpointedFunction {
  static final ListStateDescriptor<String> STATE_DESCRIPTOR=new ListStateDescriptor<>("source-state",StringSerializer.INSTANCE);
  static final String CHECKPOINTED_STRING="Here be dragons!";
  static final String CHECKPOINTED_STRING_1="Here be more dragons!";
  static final String CHECKPOINTED_STRING_2="Here be yet more dragons!";
  static final String CHECKPOINTED_STRING_3="Here be the mostest dragons!";
  private static final long serialVersionUID=1L;
  private volatile boolean isRunning=true;
  private final int numElements;
  private transient ListState<String> unionListState;
  CheckpointingNonParallelSourceWithListState(  int numElements){
    this.numElements=numElements;
  }
  @Override public void snapshotState(  FunctionSnapshotContext context) throws Exception {
    unionListState.clear();
    unionListState.add(CHECKPOINTED_STRING);
    unionListState.add(CHECKPOINTED_STRING_1);
    unionListState.add(CHECKPOINTED_STRING_2);
    unionListState.add(CHECKPOINTED_STRING_3);
  }
  @Override public void initializeState(  FunctionInitializationContext context) throws Exception {
    unionListState=context.getOperatorStateStore().getListState(STATE_DESCRIPTOR);
  }
  @Override public void run(  SourceContext<Tuple2<Long,Long>> ctx) throws Exception {
    ctx.emitWatermark(new Watermark(0));
synchronized (ctx.getCheckpointLock()) {
      for (long i=0; i < numElements; i++) {
        ctx.collect(new Tuple2<>(i,i));
      }
    }
    while (isRunning) {
      Thread.sleep(20);
    }
  }
  @Override public void cancel(){
    isRunning=false;
  }
}
