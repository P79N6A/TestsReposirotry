/** 
 * Tests for the checkpoint coordinator.
 */
public class CheckpointCoordinatorTest extends TestLogger {
  @Rule public TemporaryFolder tmpFolder=new TemporaryFolder();
  @Test public void testCheckpointAbortsIfTriggerTasksAreNotExecuted(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      ExecutionVertex triggerVertex1=mock(ExecutionVertex.class);
      ExecutionVertex triggerVertex2=mock(ExecutionVertex.class);
      final ExecutionAttemptID ackAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID2=new ExecutionAttemptID();
      ExecutionVertex ackVertex1=mockExecutionVertex(ackAttemptID1);
      ExecutionVertex ackVertex2=mockExecutionVertex(ackAttemptID2);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex1,triggerVertex2},new ExecutionVertex[]{ackVertex1,ackVertex2},new ExecutionVertex[]{},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertFalse(coord.triggerCheckpoint(timestamp,false));
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCheckpointAbortsIfTriggerTasksAreFinished(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID triggerAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID triggerAttemptID2=new ExecutionAttemptID();
      ExecutionVertex triggerVertex1=mockExecutionVertex(triggerAttemptID1);
      JobVertexID jobVertexID2=new JobVertexID();
      ExecutionVertex triggerVertex2=mockExecutionVertex(triggerAttemptID2,jobVertexID2,Collections.singletonList(OperatorID.fromJobVertexID(jobVertexID2)),1,1,ExecutionState.FINISHED);
      final ExecutionAttemptID ackAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID2=new ExecutionAttemptID();
      ExecutionVertex ackVertex1=mockExecutionVertex(ackAttemptID1);
      ExecutionVertex ackVertex2=mockExecutionVertex(ackAttemptID2);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex1,triggerVertex2},new ExecutionVertex[]{ackVertex1,ackVertex2},new ExecutionVertex[]{},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertFalse(coord.triggerCheckpoint(timestamp,false));
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCheckpointAbortsIfAckTasksAreNotExecuted(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID triggerAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID triggerAttemptID2=new ExecutionAttemptID();
      ExecutionVertex triggerVertex1=mockExecutionVertex(triggerAttemptID1);
      ExecutionVertex triggerVertex2=mockExecutionVertex(triggerAttemptID2);
      ExecutionVertex ackVertex1=mock(ExecutionVertex.class);
      ExecutionVertex ackVertex2=mock(ExecutionVertex.class);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex1,triggerVertex2},new ExecutionVertex[]{ackVertex1,ackVertex2},new ExecutionVertex[]{},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertFalse(coord.triggerCheckpoint(timestamp,false));
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  /** 
 * This test triggers a checkpoint and then sends a decline checkpoint message from one of the tasks. The expected behaviour is that said checkpoint is discarded and a new checkpoint is triggered.
 */
  @Test public void testTriggerAndDeclineCheckpointSimple(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID attemptID2=new ExecutionAttemptID();
      ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
      ExecutionVertex vertex2=mockExecutionVertex(attemptID2);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertTrue(coord.triggerCheckpoint(timestamp,false));
      assertEquals(1,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(1,coord.getNumScheduledTasks());
      long checkpointId=coord.getPendingCheckpoints().entrySet().iterator().next().getKey();
      PendingCheckpoint checkpoint=coord.getPendingCheckpoints().get(checkpointId);
      assertNotNull(checkpoint);
      assertEquals(checkpointId,checkpoint.getCheckpointId());
      assertEquals(timestamp,checkpoint.getCheckpointTimestamp());
      assertEquals(jid,checkpoint.getJobId());
      assertEquals(2,checkpoint.getNumberOfNonAcknowledgedTasks());
      assertEquals(0,checkpoint.getNumberOfAcknowledgedTasks());
      assertEquals(0,checkpoint.getOperatorStates().size());
      assertFalse(checkpoint.isDiscarded());
      assertFalse(checkpoint.isFullyAcknowledged());
      verify(vertex1.getCurrentExecutionAttempt()).triggerCheckpoint(checkpointId,timestamp,CheckpointOptions.forCheckpointWithDefaultLocation());
      verify(vertex2.getCurrentExecutionAttempt()).triggerCheckpoint(checkpointId,timestamp,CheckpointOptions.forCheckpointWithDefaultLocation());
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID2,checkpointId));
      assertEquals(1,checkpoint.getNumberOfAcknowledgedTasks());
      assertEquals(1,checkpoint.getNumberOfNonAcknowledgedTasks());
      assertFalse(checkpoint.isDiscarded());
      assertFalse(checkpoint.isFullyAcknowledged());
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID2,checkpointId));
      assertFalse(checkpoint.isDiscarded());
      assertFalse(checkpoint.isFullyAcknowledged());
      coord.receiveDeclineMessage(new DeclineCheckpoint(jid,attemptID1,checkpointId));
      assertTrue(checkpoint.isDiscarded());
      assertEquals(0,coord.getNumScheduledTasks());
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      coord.receiveDeclineMessage(new DeclineCheckpoint(jid,attemptID1,checkpointId));
      coord.receiveDeclineMessage(new DeclineCheckpoint(jid,attemptID2,checkpointId));
      assertTrue(checkpoint.isDiscarded());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  /** 
 * This test triggers two checkpoints and then sends a decline message from one of the tasks for the first checkpoint. This should discard the first checkpoint while not triggering a new checkpoint because a later checkpoint is already in progress.
 */
  @Test public void testTriggerAndDeclineCheckpointComplex(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID attemptID2=new ExecutionAttemptID();
      ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
      ExecutionVertex vertex2=mockExecutionVertex(attemptID2);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(0,coord.getNumScheduledTasks());
      assertTrue(coord.triggerCheckpoint(timestamp,false));
      assertTrue(coord.triggerCheckpoint(timestamp + 2,false));
      assertEquals(2,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(2,coord.getNumScheduledTasks());
      Iterator<Map.Entry<Long,PendingCheckpoint>> it=coord.getPendingCheckpoints().entrySet().iterator();
      long checkpoint1Id=it.next().getKey();
      long checkpoint2Id=it.next().getKey();
      PendingCheckpoint checkpoint1=coord.getPendingCheckpoints().get(checkpoint1Id);
      PendingCheckpoint checkpoint2=coord.getPendingCheckpoints().get(checkpoint2Id);
      assertNotNull(checkpoint1);
      assertEquals(checkpoint1Id,checkpoint1.getCheckpointId());
      assertEquals(timestamp,checkpoint1.getCheckpointTimestamp());
      assertEquals(jid,checkpoint1.getJobId());
      assertEquals(2,checkpoint1.getNumberOfNonAcknowledgedTasks());
      assertEquals(0,checkpoint1.getNumberOfAcknowledgedTasks());
      assertEquals(0,checkpoint1.getOperatorStates().size());
      assertFalse(checkpoint1.isDiscarded());
      assertFalse(checkpoint1.isFullyAcknowledged());
      assertNotNull(checkpoint2);
      assertEquals(checkpoint2Id,checkpoint2.getCheckpointId());
      assertEquals(timestamp + 2,checkpoint2.getCheckpointTimestamp());
      assertEquals(jid,checkpoint2.getJobId());
      assertEquals(2,checkpoint2.getNumberOfNonAcknowledgedTasks());
      assertEquals(0,checkpoint2.getNumberOfAcknowledgedTasks());
      assertEquals(0,checkpoint2.getOperatorStates().size());
      assertFalse(checkpoint2.isDiscarded());
      assertFalse(checkpoint2.isFullyAcknowledged());
{
        verify(vertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpoint1Id),eq(timestamp),any(CheckpointOptions.class));
        verify(vertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpoint1Id),eq(timestamp),any(CheckpointOptions.class));
      }
{
        verify(vertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpoint2Id),eq(timestamp + 2),any(CheckpointOptions.class));
        verify(vertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpoint2Id),eq(timestamp + 2),any(CheckpointOptions.class));
      }
      coord.receiveDeclineMessage(new DeclineCheckpoint(jid,attemptID1,checkpoint1Id));
      assertTrue(checkpoint1.isDiscarded());
      assertEquals(1,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(1,coord.getNumScheduledTasks());
      long checkpointIdNew=coord.getPendingCheckpoints().entrySet().iterator().next().getKey();
      PendingCheckpoint checkpointNew=coord.getPendingCheckpoints().get(checkpointIdNew);
      assertEquals(checkpoint2Id,checkpointIdNew);
      assertNotNull(checkpointNew);
      assertEquals(checkpointIdNew,checkpointNew.getCheckpointId());
      assertEquals(jid,checkpointNew.getJobId());
      assertEquals(2,checkpointNew.getNumberOfNonAcknowledgedTasks());
      assertEquals(0,checkpointNew.getNumberOfAcknowledgedTasks());
      assertEquals(0,checkpointNew.getOperatorStates().size());
      assertFalse(checkpointNew.isDiscarded());
      assertFalse(checkpointNew.isFullyAcknowledged());
      assertNotEquals(checkpoint1.getCheckpointId(),checkpointNew.getCheckpointId());
      coord.receiveDeclineMessage(new DeclineCheckpoint(jid,attemptID1,checkpoint1Id));
      coord.receiveDeclineMessage(new DeclineCheckpoint(jid,attemptID2,checkpoint1Id));
      assertTrue(checkpoint1.isDiscarded());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testTriggerAndConfirmSimpleCheckpoint(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID attemptID2=new ExecutionAttemptID();
      ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
      ExecutionVertex vertex2=mockExecutionVertex(attemptID2);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(0,coord.getNumScheduledTasks());
      assertTrue(coord.triggerCheckpoint(timestamp,false));
      assertEquals(1,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(1,coord.getNumScheduledTasks());
      long checkpointId=coord.getPendingCheckpoints().entrySet().iterator().next().getKey();
      PendingCheckpoint checkpoint=coord.getPendingCheckpoints().get(checkpointId);
      assertNotNull(checkpoint);
      assertEquals(checkpointId,checkpoint.getCheckpointId());
      assertEquals(timestamp,checkpoint.getCheckpointTimestamp());
      assertEquals(jid,checkpoint.getJobId());
      assertEquals(2,checkpoint.getNumberOfNonAcknowledgedTasks());
      assertEquals(0,checkpoint.getNumberOfAcknowledgedTasks());
      assertEquals(0,checkpoint.getOperatorStates().size());
      assertFalse(checkpoint.isDiscarded());
      assertFalse(checkpoint.isFullyAcknowledged());
{
        verify(vertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId),eq(timestamp),any(CheckpointOptions.class));
        verify(vertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId),eq(timestamp),any(CheckpointOptions.class));
      }
      OperatorID opID1=OperatorID.fromJobVertexID(vertex1.getJobvertexId());
      OperatorID opID2=OperatorID.fromJobVertexID(vertex2.getJobvertexId());
      TaskStateSnapshot taskOperatorSubtaskStates1=mock(TaskStateSnapshot.class);
      TaskStateSnapshot taskOperatorSubtaskStates2=mock(TaskStateSnapshot.class);
      OperatorSubtaskState subtaskState1=mock(OperatorSubtaskState.class);
      OperatorSubtaskState subtaskState2=mock(OperatorSubtaskState.class);
      when(taskOperatorSubtaskStates1.getSubtaskStateByOperatorID(opID1)).thenReturn(subtaskState1);
      when(taskOperatorSubtaskStates2.getSubtaskStateByOperatorID(opID2)).thenReturn(subtaskState2);
      AcknowledgeCheckpoint acknowledgeCheckpoint1=new AcknowledgeCheckpoint(jid,attemptID2,checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates2);
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint1);
      assertEquals(1,checkpoint.getNumberOfAcknowledgedTasks());
      assertEquals(1,checkpoint.getNumberOfNonAcknowledgedTasks());
      assertFalse(checkpoint.isDiscarded());
      assertFalse(checkpoint.isFullyAcknowledged());
      verify(taskOperatorSubtaskStates2,never()).registerSharedStates(any(SharedStateRegistry.class));
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint1);
      assertFalse(checkpoint.isDiscarded());
      assertFalse(checkpoint.isFullyAcknowledged());
      verify(subtaskState2,never()).registerSharedStates(any(SharedStateRegistry.class));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID1,checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates1));
      assertTrue(checkpoint.isDiscarded());
      assertEquals(1,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumScheduledTasks());
{
        verify(subtaskState1,times(1)).registerSharedStates(any(SharedStateRegistry.class));
        verify(subtaskState2,times(1)).registerSharedStates(any(SharedStateRegistry.class));
      }
{
        verify(vertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId),eq(timestamp),any(CheckpointOptions.class));
        verify(vertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId),eq(timestamp),any(CheckpointOptions.class));
      }
      CompletedCheckpoint success=coord.getSuccessfulCheckpoints().get(0);
      assertEquals(jid,success.getJobId());
      assertEquals(timestamp,success.getTimestamp());
      assertEquals(checkpoint.getCheckpointId(),success.getCheckpointID());
      assertEquals(2,success.getOperatorStates().size());
      final long timestampNew=timestamp + 7;
      coord.triggerCheckpoint(timestampNew,false);
      long checkpointIdNew=coord.getPendingCheckpoints().entrySet().iterator().next().getKey();
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID1,checkpointIdNew));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID2,checkpointIdNew));
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(1,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertEquals(0,coord.getNumScheduledTasks());
      CompletedCheckpoint successNew=coord.getSuccessfulCheckpoints().get(0);
      assertEquals(jid,successNew.getJobId());
      assertEquals(timestampNew,successNew.getTimestamp());
      assertEquals(checkpointIdNew,successNew.getCheckpointID());
      assertTrue(successNew.getOperatorStates().isEmpty());
{
        verify(vertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointIdNew),eq(timestampNew),any(CheckpointOptions.class));
        verify(vertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointIdNew),eq(timestampNew),any(CheckpointOptions.class));
        verify(vertex1.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointIdNew),eq(timestampNew));
        verify(vertex2.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointIdNew),eq(timestampNew));
      }
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testMultipleConcurrentCheckpoints(){
    try {
      final JobID jid=new JobID();
      final long timestamp1=System.currentTimeMillis();
      final long timestamp2=timestamp1 + 8617;
      final ExecutionAttemptID triggerAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID triggerAttemptID2=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID2=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID3=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex1=mockExecutionVertex(triggerAttemptID1);
      ExecutionVertex triggerVertex2=mockExecutionVertex(triggerAttemptID2);
      ExecutionVertex ackVertex1=mockExecutionVertex(ackAttemptID1);
      ExecutionVertex ackVertex2=mockExecutionVertex(ackAttemptID2);
      ExecutionVertex ackVertex3=mockExecutionVertex(ackAttemptID3);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex1,triggerVertex2},new ExecutionVertex[]{ackVertex1,ackVertex2,ackVertex3},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertTrue(coord.triggerCheckpoint(timestamp1,false));
      assertEquals(1,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      PendingCheckpoint pending1=coord.getPendingCheckpoints().values().iterator().next();
      long checkpointId1=pending1.getCheckpointId();
      verify(triggerVertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId1),eq(timestamp1),any(CheckpointOptions.class));
      verify(triggerVertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId1),eq(timestamp1),any(CheckpointOptions.class));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID2,checkpointId1));
      assertTrue(coord.triggerCheckpoint(timestamp2,false));
      assertEquals(2,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      PendingCheckpoint pending2;
{
        Iterator<PendingCheckpoint> all=coord.getPendingCheckpoints().values().iterator();
        PendingCheckpoint cc1=all.next();
        PendingCheckpoint cc2=all.next();
        pending2=pending1 == cc1 ? cc2 : cc1;
      }
      long checkpointId2=pending2.getCheckpointId();
      verify(triggerVertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId2),eq(timestamp2),any(CheckpointOptions.class));
      verify(triggerVertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId2),eq(timestamp2),any(CheckpointOptions.class));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID3,checkpointId1));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID1,checkpointId2));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID1,checkpointId1));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID2,checkpointId2));
      assertEquals(1,coord.getNumberOfPendingCheckpoints());
      assertEquals(1,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertTrue(pending1.isDiscarded());
      verify(commitVertex.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointId1),eq(timestamp1));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID3,checkpointId2));
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(2,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertTrue(pending2.isDiscarded());
      verify(commitVertex.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointId2),eq(timestamp2));
      List<CompletedCheckpoint> scs=coord.getSuccessfulCheckpoints();
      CompletedCheckpoint sc1=scs.get(0);
      assertEquals(checkpointId1,sc1.getCheckpointID());
      assertEquals(timestamp1,sc1.getTimestamp());
      assertEquals(jid,sc1.getJobId());
      assertTrue(sc1.getOperatorStates().isEmpty());
      CompletedCheckpoint sc2=scs.get(1);
      assertEquals(checkpointId2,sc2.getCheckpointID());
      assertEquals(timestamp2,sc2.getTimestamp());
      assertEquals(jid,sc2.getJobId());
      assertTrue(sc2.getOperatorStates().isEmpty());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testSuccessfulCheckpointSubsumesUnsuccessful(){
    try {
      final JobID jid=new JobID();
      final long timestamp1=System.currentTimeMillis();
      final long timestamp2=timestamp1 + 1552;
      final ExecutionAttemptID triggerAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID triggerAttemptID2=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID2=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID3=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex1=mockExecutionVertex(triggerAttemptID1);
      ExecutionVertex triggerVertex2=mockExecutionVertex(triggerAttemptID2);
      ExecutionVertex ackVertex1=mockExecutionVertex(ackAttemptID1);
      ExecutionVertex ackVertex2=mockExecutionVertex(ackAttemptID2);
      ExecutionVertex ackVertex3=mockExecutionVertex(ackAttemptID3);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex1,triggerVertex2},new ExecutionVertex[]{ackVertex1,ackVertex2,ackVertex3},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(10),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      assertTrue(coord.triggerCheckpoint(timestamp1,false));
      assertEquals(1,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      PendingCheckpoint pending1=coord.getPendingCheckpoints().values().iterator().next();
      long checkpointId1=pending1.getCheckpointId();
      verify(triggerVertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId1),eq(timestamp1),any(CheckpointOptions.class));
      verify(triggerVertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId1),eq(timestamp1),any(CheckpointOptions.class));
      OperatorID opID1=OperatorID.fromJobVertexID(ackVertex1.getJobvertexId());
      OperatorID opID2=OperatorID.fromJobVertexID(ackVertex2.getJobvertexId());
      OperatorID opID3=OperatorID.fromJobVertexID(ackVertex3.getJobvertexId());
      TaskStateSnapshot taskOperatorSubtaskStates1_1=spy(new TaskStateSnapshot());
      TaskStateSnapshot taskOperatorSubtaskStates1_2=spy(new TaskStateSnapshot());
      TaskStateSnapshot taskOperatorSubtaskStates1_3=spy(new TaskStateSnapshot());
      OperatorSubtaskState subtaskState1_1=mock(OperatorSubtaskState.class);
      OperatorSubtaskState subtaskState1_2=mock(OperatorSubtaskState.class);
      OperatorSubtaskState subtaskState1_3=mock(OperatorSubtaskState.class);
      taskOperatorSubtaskStates1_1.putSubtaskStateByOperatorID(opID1,subtaskState1_1);
      taskOperatorSubtaskStates1_2.putSubtaskStateByOperatorID(opID2,subtaskState1_2);
      taskOperatorSubtaskStates1_3.putSubtaskStateByOperatorID(opID3,subtaskState1_3);
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID2,checkpointId1,new CheckpointMetrics(),taskOperatorSubtaskStates1_2));
      assertTrue(coord.triggerCheckpoint(timestamp2,false));
      assertEquals(2,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      PendingCheckpoint pending2;
{
        Iterator<PendingCheckpoint> all=coord.getPendingCheckpoints().values().iterator();
        PendingCheckpoint cc1=all.next();
        PendingCheckpoint cc2=all.next();
        pending2=pending1 == cc1 ? cc2 : cc1;
      }
      long checkpointId2=pending2.getCheckpointId();
      TaskStateSnapshot taskOperatorSubtaskStates2_1=spy(new TaskStateSnapshot());
      TaskStateSnapshot taskOperatorSubtaskStates2_2=spy(new TaskStateSnapshot());
      TaskStateSnapshot taskOperatorSubtaskStates2_3=spy(new TaskStateSnapshot());
      OperatorSubtaskState subtaskState2_1=mock(OperatorSubtaskState.class);
      OperatorSubtaskState subtaskState2_2=mock(OperatorSubtaskState.class);
      OperatorSubtaskState subtaskState2_3=mock(OperatorSubtaskState.class);
      taskOperatorSubtaskStates2_1.putSubtaskStateByOperatorID(opID1,subtaskState2_1);
      taskOperatorSubtaskStates2_2.putSubtaskStateByOperatorID(opID2,subtaskState2_2);
      taskOperatorSubtaskStates2_3.putSubtaskStateByOperatorID(opID3,subtaskState2_3);
      verify(triggerVertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId2),eq(timestamp2),any(CheckpointOptions.class));
      verify(triggerVertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointId2),eq(timestamp2),any(CheckpointOptions.class));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID3,checkpointId2,new CheckpointMetrics(),taskOperatorSubtaskStates2_3));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID1,checkpointId2,new CheckpointMetrics(),taskOperatorSubtaskStates2_1));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID1,checkpointId1,new CheckpointMetrics(),taskOperatorSubtaskStates1_1));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID2,checkpointId2,new CheckpointMetrics(),taskOperatorSubtaskStates2_2));
      assertTrue(pending1.isDiscarded());
      assertTrue(pending2.isDiscarded());
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(1,coord.getNumberOfRetainedSuccessfulCheckpoints());
      verify(subtaskState1_1,times(1)).discardState();
      verify(subtaskState1_2,times(1)).discardState();
      verify(subtaskState2_1,never()).discardState();
      verify(subtaskState2_2,never()).discardState();
      verify(subtaskState2_3,never()).discardState();
      List<CompletedCheckpoint> scs=coord.getSuccessfulCheckpoints();
      CompletedCheckpoint success=scs.get(0);
      assertEquals(checkpointId2,success.getCheckpointID());
      assertEquals(timestamp2,success.getTimestamp());
      assertEquals(jid,success.getJobId());
      assertEquals(3,success.getOperatorStates().size());
      verify(commitVertex.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointId2),eq(timestamp2));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID3,checkpointId1,new CheckpointMetrics(),taskOperatorSubtaskStates1_3));
      verify(subtaskState1_3,times(1)).discardState();
      coord.shutdown(JobStatus.FINISHED);
      verify(subtaskState2_1,times(1)).discardState();
      verify(subtaskState2_2,times(1)).discardState();
      verify(subtaskState2_3,times(1)).discardState();
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCheckpointTimeoutIsolated(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID triggerAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID2=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptID);
      ExecutionVertex ackVertex1=mockExecutionVertex(ackAttemptID1);
      ExecutionVertex ackVertex2=mockExecutionVertex(ackAttemptID2);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,200,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{ackVertex1,ackVertex2},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertTrue(coord.triggerCheckpoint(timestamp,false));
      assertEquals(1,coord.getNumberOfPendingCheckpoints());
      PendingCheckpoint checkpoint=coord.getPendingCheckpoints().values().iterator().next();
      assertFalse(checkpoint.isDiscarded());
      OperatorID opID1=OperatorID.fromJobVertexID(ackVertex1.getJobvertexId());
      TaskStateSnapshot taskOperatorSubtaskStates1=spy(new TaskStateSnapshot());
      OperatorSubtaskState subtaskState1=mock(OperatorSubtaskState.class);
      taskOperatorSubtaskStates1.putSubtaskStateByOperatorID(opID1,subtaskState1);
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID1,checkpoint.getCheckpointId(),new CheckpointMetrics(),taskOperatorSubtaskStates1));
      long deadline=System.currentTimeMillis() + 5000;
      do {
        Thread.sleep(250);
      }
 while (!checkpoint.isDiscarded() && coord.getNumberOfPendingCheckpoints() > 0 && System.currentTimeMillis() < deadline);
      assertTrue("Checkpoint was not canceled by the timeout",checkpoint.isDiscarded());
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
      verify(subtaskState1,times(1)).discardState();
      verify(commitVertex.getCurrentExecutionAttempt(),times(0)).notifyCheckpointComplete(anyLong(),anyLong());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testHandleMessagesForNonExistingCheckpoints(){
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID triggerAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID1=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID2=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptID);
      ExecutionVertex ackVertex1=mockExecutionVertex(ackAttemptID1);
      ExecutionVertex ackVertex2=mockExecutionVertex(ackAttemptID2);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,200000,200000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{ackVertex1,ackVertex2},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertTrue(coord.triggerCheckpoint(timestamp,false));
      long checkpointId=coord.getPendingCheckpoints().keySet().iterator().next();
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(new JobID(),ackAttemptID1,checkpointId));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID1,1L));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,new ExecutionAttemptID(),checkpointId));
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  /** 
 * Tests that late acknowledge checkpoint messages are properly cleaned up. Furthermore it tests that unknown checkpoint messages for the same job a are cleaned up as well. In contrast checkpointing messages from other jobs should not be touched. A late acknowledge message is an acknowledge message which arrives after the checkpoint has been declined.
 * @throws Exception
 */
  @Test public void testStateCleanupForLateOrUnknownMessages() throws Exception {
    final JobID jobId=new JobID();
    final ExecutionAttemptID triggerAttemptId=new ExecutionAttemptID();
    final ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptId);
    final ExecutionAttemptID ackAttemptId1=new ExecutionAttemptID();
    final ExecutionVertex ackVertex1=mockExecutionVertex(ackAttemptId1);
    final ExecutionAttemptID ackAttemptId2=new ExecutionAttemptID();
    final ExecutionVertex ackVertex2=mockExecutionVertex(ackAttemptId2);
    final long timestamp=1L;
    CheckpointCoordinator coord=new CheckpointCoordinator(jobId,20000L,20000L,0L,1,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{triggerVertex,ackVertex1,ackVertex2},new ExecutionVertex[0],new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    assertTrue(coord.triggerCheckpoint(timestamp,false));
    assertEquals(1,coord.getNumberOfPendingCheckpoints());
    PendingCheckpoint pendingCheckpoint=coord.getPendingCheckpoints().values().iterator().next();
    long checkpointId=pendingCheckpoint.getCheckpointId();
    OperatorID opIDtrigger=OperatorID.fromJobVertexID(triggerVertex.getJobvertexId());
    TaskStateSnapshot taskOperatorSubtaskStatesTrigger=spy(new TaskStateSnapshot());
    OperatorSubtaskState subtaskStateTrigger=mock(OperatorSubtaskState.class);
    taskOperatorSubtaskStatesTrigger.putSubtaskStateByOperatorID(opIDtrigger,subtaskStateTrigger);
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId,triggerAttemptId,checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStatesTrigger));
    verify(subtaskStateTrigger,never()).discardState();
    TaskStateSnapshot unknownSubtaskState=mock(TaskStateSnapshot.class);
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId,new ExecutionAttemptID(),checkpointId,new CheckpointMetrics(),unknownSubtaskState));
    verify(unknownSubtaskState,times(1)).discardState();
    TaskStateSnapshot differentJobSubtaskState=mock(TaskStateSnapshot.class);
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(new JobID(),new ExecutionAttemptID(),checkpointId,new CheckpointMetrics(),differentJobSubtaskState));
    verify(differentJobSubtaskState,never()).discardState();
    TaskStateSnapshot triggerSubtaskState=mock(TaskStateSnapshot.class);
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId,triggerAttemptId,checkpointId,new CheckpointMetrics(),triggerSubtaskState));
    verify(triggerSubtaskState,never()).discardState();
    reset(subtaskStateTrigger);
    coord.receiveDeclineMessage(new DeclineCheckpoint(jobId,ackAttemptId1,checkpointId));
    assertTrue(pendingCheckpoint.isDiscarded());
    verify(subtaskStateTrigger,times(1)).discardState();
    TaskStateSnapshot ackSubtaskState=mock(TaskStateSnapshot.class);
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId,ackAttemptId2,checkpointId,new CheckpointMetrics(),ackSubtaskState));
    verify(ackSubtaskState,times(1)).discardState();
    reset(differentJobSubtaskState);
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(new JobID(),new ExecutionAttemptID(),checkpointId,new CheckpointMetrics(),differentJobSubtaskState));
    verify(differentJobSubtaskState,never()).discardState();
    TaskStateSnapshot unknownSubtaskState2=mock(TaskStateSnapshot.class);
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId,new ExecutionAttemptID(),checkpointId,new CheckpointMetrics(),unknownSubtaskState2));
    verify(unknownSubtaskState2,times(1)).discardState();
  }
  @Test public void testPeriodicTriggering(){
    try {
      final JobID jid=new JobID();
      final long start=System.currentTimeMillis();
      final ExecutionAttemptID triggerAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptID);
      ExecutionVertex ackVertex=mockExecutionVertex(ackAttemptID);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      final AtomicInteger numCalls=new AtomicInteger();
      final Execution execution=triggerVertex.getCurrentExecutionAttempt();
      doAnswer(new Answer<Void>(){
        private long lastId=-1;
        private long lastTs=-1;
        @Override public Void answer(        InvocationOnMock invocation) throws Throwable {
          long id=(Long)invocation.getArguments()[0];
          long ts=(Long)invocation.getArguments()[1];
          assertTrue(id > lastId);
          assertTrue(ts >= lastTs);
          assertTrue(ts >= start);
          lastId=id;
          lastTs=ts;
          numCalls.incrementAndGet();
          return null;
        }
      }
).when(execution).triggerCheckpoint(anyLong(),anyLong(),any(CheckpointOptions.class));
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,10,200000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{ackVertex},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      coord.startCheckpointScheduler();
      long timeout=System.currentTimeMillis() + 60000;
      do {
        Thread.sleep(20);
      }
 while (timeout > System.currentTimeMillis() && numCalls.get() < 5);
      assertTrue(numCalls.get() >= 5);
      coord.stopCheckpointScheduler();
      int numCallsSoFar=numCalls.get();
      Thread.sleep(400);
      assertTrue(numCallsSoFar == numCalls.get() || numCallsSoFar + 1 == numCalls.get());
      numCalls.set(0);
      coord.startCheckpointScheduler();
      timeout=System.currentTimeMillis() + 60000;
      do {
        Thread.sleep(20);
      }
 while (timeout > System.currentTimeMillis() && numCalls.get() < 5);
      assertTrue(numCalls.get() >= 5);
      coord.stopCheckpointScheduler();
      numCallsSoFar=numCalls.get();
      Thread.sleep(400);
      assertTrue(numCallsSoFar == numCalls.get() || numCallsSoFar + 1 == numCalls.get());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  /** 
 * This test verified that after a completed checkpoint a certain time has passed before another is triggered.
 */
  @Test public void testMinTimeBetweenCheckpointsInterval() throws Exception {
    final JobID jid=new JobID();
    final ExecutionAttemptID attemptID=new ExecutionAttemptID();
    final ExecutionVertex vertex=mockExecutionVertex(attemptID);
    final Execution executionAttempt=vertex.getCurrentExecutionAttempt();
    final BlockingQueue<Long> triggerCalls=new LinkedBlockingQueue<>();
    doAnswer(invocation -> {
      triggerCalls.add((Long)invocation.getArguments()[0]);
      return null;
    }
).when(executionAttempt).triggerCheckpoint(anyLong(),anyLong(),any(CheckpointOptions.class));
    final long delay=50;
    final CheckpointCoordinator coord=new CheckpointCoordinator(jid,2,200_000,delay,1,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex},new ExecutionVertex[]{vertex},new ExecutionVertex[]{vertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    try {
      coord.startCheckpointScheduler();
      Long firstCallId=triggerCalls.take();
      assertEquals(1L,firstCallId.longValue());
      AcknowledgeCheckpoint ackMsg=new AcknowledgeCheckpoint(jid,attemptID,1L);
      final long ackTime=System.nanoTime();
      coord.receiveAcknowledgeMessage(ackMsg);
      Long nextCallId=triggerCalls.take();
      final long nextCheckpointTime=System.nanoTime();
      assertEquals(2L,nextCallId.longValue());
      final long delayMillis=(nextCheckpointTime - ackTime) / 1_000_000;
      if (delayMillis + 1 < delay) {
        fail("checkpoint came too early: delay was " + delayMillis + " but should have been at least "+ delay);
      }
    }
  finally {
      coord.stopCheckpointScheduler();
      coord.shutdown(JobStatus.FINISHED);
    }
  }
  @Test public void testMaxConcurrentAttempts1(){
    testMaxConcurrentAttempts(1);
  }
  @Test public void testMaxConcurrentAttempts2(){
    testMaxConcurrentAttempts(2);
  }
  @Test public void testMaxConcurrentAttempts5(){
    testMaxConcurrentAttempts(5);
  }
  @Test public void testTriggerAndConfirmSimpleSavepoint() throws Exception {
    final JobID jid=new JobID();
    final long timestamp=System.currentTimeMillis();
    final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
    final ExecutionAttemptID attemptID2=new ExecutionAttemptID();
    ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
    ExecutionVertex vertex2=mockExecutionVertex(attemptID2);
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    assertEquals(0,coord.getNumberOfPendingCheckpoints());
    assertEquals(0,coord.getNumberOfRetainedSuccessfulCheckpoints());
    String savepointDir=tmpFolder.newFolder().getAbsolutePath();
    CompletableFuture<CompletedCheckpoint> savepointFuture=coord.triggerSavepoint(timestamp,savepointDir);
    assertFalse(savepointFuture.isDone());
    assertEquals(1,coord.getNumberOfPendingCheckpoints());
    long checkpointId=coord.getPendingCheckpoints().entrySet().iterator().next().getKey();
    PendingCheckpoint pending=coord.getPendingCheckpoints().get(checkpointId);
    assertNotNull(pending);
    assertEquals(checkpointId,pending.getCheckpointId());
    assertEquals(timestamp,pending.getCheckpointTimestamp());
    assertEquals(jid,pending.getJobId());
    assertEquals(2,pending.getNumberOfNonAcknowledgedTasks());
    assertEquals(0,pending.getNumberOfAcknowledgedTasks());
    assertEquals(0,pending.getOperatorStates().size());
    assertFalse(pending.isDiscarded());
    assertFalse(pending.isFullyAcknowledged());
    assertFalse(pending.canBeSubsumed());
    OperatorID opID1=OperatorID.fromJobVertexID(vertex1.getJobvertexId());
    OperatorID opID2=OperatorID.fromJobVertexID(vertex2.getJobvertexId());
    TaskStateSnapshot taskOperatorSubtaskStates1=mock(TaskStateSnapshot.class);
    TaskStateSnapshot taskOperatorSubtaskStates2=mock(TaskStateSnapshot.class);
    OperatorSubtaskState subtaskState1=mock(OperatorSubtaskState.class);
    OperatorSubtaskState subtaskState2=mock(OperatorSubtaskState.class);
    when(taskOperatorSubtaskStates1.getSubtaskStateByOperatorID(opID1)).thenReturn(subtaskState1);
    when(taskOperatorSubtaskStates2.getSubtaskStateByOperatorID(opID2)).thenReturn(subtaskState2);
    AcknowledgeCheckpoint acknowledgeCheckpoint2=new AcknowledgeCheckpoint(jid,attemptID2,checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates2);
    coord.receiveAcknowledgeMessage(acknowledgeCheckpoint2);
    assertEquals(1,pending.getNumberOfAcknowledgedTasks());
    assertEquals(1,pending.getNumberOfNonAcknowledgedTasks());
    assertFalse(pending.isDiscarded());
    assertFalse(pending.isFullyAcknowledged());
    assertFalse(savepointFuture.isDone());
    coord.receiveAcknowledgeMessage(acknowledgeCheckpoint2);
    assertFalse(pending.isDiscarded());
    assertFalse(pending.isFullyAcknowledged());
    assertFalse(savepointFuture.isDone());
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID1,checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates1));
    assertTrue(pending.isDiscarded());
    assertTrue(savepointFuture.isDone());
    assertEquals(1,coord.getNumberOfRetainedSuccessfulCheckpoints());
    assertEquals(0,coord.getNumberOfPendingCheckpoints());
{
      verify(vertex1.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointId),eq(timestamp));
      verify(vertex2.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointId),eq(timestamp));
    }
{
      verify(subtaskState1,times(1)).registerSharedStates(any(SharedStateRegistry.class));
      verify(subtaskState2,times(1)).registerSharedStates(any(SharedStateRegistry.class));
    }
    CompletedCheckpoint success=coord.getSuccessfulCheckpoints().get(0);
    assertEquals(jid,success.getJobId());
    assertEquals(timestamp,success.getTimestamp());
    assertEquals(pending.getCheckpointId(),success.getCheckpointID());
    assertEquals(2,success.getOperatorStates().size());
    final long timestampNew=timestamp + 7;
    savepointFuture=coord.triggerSavepoint(timestampNew,savepointDir);
    assertFalse(savepointFuture.isDone());
    long checkpointIdNew=coord.getPendingCheckpoints().entrySet().iterator().next().getKey();
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID1,checkpointIdNew));
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID2,checkpointIdNew));
    assertEquals(0,coord.getNumberOfPendingCheckpoints());
    assertEquals(1,coord.getNumberOfRetainedSuccessfulCheckpoints());
    CompletedCheckpoint successNew=coord.getSuccessfulCheckpoints().get(0);
    assertEquals(jid,successNew.getJobId());
    assertEquals(timestampNew,successNew.getTimestamp());
    assertEquals(checkpointIdNew,successNew.getCheckpointID());
    assertTrue(successNew.getOperatorStates().isEmpty());
    assertTrue(savepointFuture.isDone());
    verify(subtaskState1,never()).discardState();
    verify(subtaskState2,never()).discardState();
{
      verify(vertex1.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointIdNew),eq(timestampNew),any(CheckpointOptions.class));
      verify(vertex2.getCurrentExecutionAttempt(),times(1)).triggerCheckpoint(eq(checkpointIdNew),eq(timestampNew),any(CheckpointOptions.class));
      verify(vertex1.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointIdNew),eq(timestampNew));
      verify(vertex2.getCurrentExecutionAttempt(),times(1)).notifyCheckpointComplete(eq(checkpointIdNew),eq(timestampNew));
    }
    coord.shutdown(JobStatus.FINISHED);
  }
  /** 
 * Triggers a savepoint and two checkpoints. The second checkpoint completes and subsumes the first checkpoint, but not the first savepoint. Then we trigger another checkpoint and savepoint. The 2nd savepoint completes and subsumes the last checkpoint, but not the first savepoint.
 */
  @Test public void testSavepointsAreNotSubsumed() throws Exception {
    final JobID jid=new JobID();
    final long timestamp=System.currentTimeMillis();
    final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
    final ExecutionAttemptID attemptID2=new ExecutionAttemptID();
    ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
    ExecutionVertex vertex2=mockExecutionVertex(attemptID2);
    StandaloneCheckpointIDCounter counter=new StandaloneCheckpointIDCounter();
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},new ExecutionVertex[]{vertex1,vertex2},counter,new StandaloneCompletedCheckpointStore(10),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    String savepointDir=tmpFolder.newFolder().getAbsolutePath();
    CompletableFuture<CompletedCheckpoint> savepointFuture1=coord.triggerSavepoint(timestamp,savepointDir);
    long savepointId1=counter.getLast();
    assertEquals(1,coord.getNumberOfPendingCheckpoints());
    assertTrue(coord.triggerCheckpoint(timestamp + 1,false));
    assertEquals(2,coord.getNumberOfPendingCheckpoints());
    assertTrue(coord.triggerCheckpoint(timestamp + 2,false));
    long checkpointId2=counter.getLast();
    assertEquals(3,coord.getNumberOfPendingCheckpoints());
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID1,checkpointId2));
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID2,checkpointId2));
    assertEquals(1,coord.getNumberOfPendingCheckpoints());
    assertEquals(1,coord.getNumberOfRetainedSuccessfulCheckpoints());
    assertFalse(coord.getPendingCheckpoints().get(savepointId1).isDiscarded());
    assertFalse(savepointFuture1.isDone());
    assertTrue(coord.triggerCheckpoint(timestamp + 3,false));
    assertEquals(2,coord.getNumberOfPendingCheckpoints());
    CompletableFuture<CompletedCheckpoint> savepointFuture2=coord.triggerSavepoint(timestamp + 4,savepointDir);
    long savepointId2=counter.getLast();
    assertEquals(3,coord.getNumberOfPendingCheckpoints());
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID1,savepointId2));
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID2,savepointId2));
    assertEquals(1,coord.getNumberOfPendingCheckpoints());
    assertEquals(2,coord.getNumberOfRetainedSuccessfulCheckpoints());
    assertFalse(coord.getPendingCheckpoints().get(savepointId1).isDiscarded());
    assertFalse(savepointFuture1.isDone());
    assertTrue(savepointFuture2.isDone());
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID1,savepointId1));
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,attemptID2,savepointId1));
    assertEquals(0,coord.getNumberOfPendingCheckpoints());
    assertEquals(3,coord.getNumberOfRetainedSuccessfulCheckpoints());
    assertTrue(savepointFuture1.isDone());
  }
  private void testMaxConcurrentAttempts(  int maxConcurrentAttempts){
    try {
      final JobID jid=new JobID();
      final ExecutionAttemptID triggerAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptID);
      ExecutionVertex ackVertex=mockExecutionVertex(ackAttemptID);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      final AtomicInteger numCalls=new AtomicInteger();
      final Execution execution=triggerVertex.getCurrentExecutionAttempt();
      doAnswer(invocation -> {
        numCalls.incrementAndGet();
        return null;
      }
).when(execution).triggerCheckpoint(anyLong(),anyLong(),any(CheckpointOptions.class));
      doAnswer(invocation -> {
        numCalls.incrementAndGet();
        return null;
      }
).when(execution).notifyCheckpointComplete(anyLong(),anyLong());
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,10,200000,0L,maxConcurrentAttempts,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{ackVertex},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      coord.startCheckpointScheduler();
      long now=System.currentTimeMillis();
      long timeout=now + 60000;
      long minDuration=now + 100;
      do {
        Thread.sleep(20);
      }
 while ((now=System.currentTimeMillis()) < minDuration || (numCalls.get() < maxConcurrentAttempts && now < timeout));
      assertEquals(maxConcurrentAttempts,numCalls.get());
      verify(triggerVertex.getCurrentExecutionAttempt(),times(maxConcurrentAttempts)).triggerCheckpoint(anyLong(),anyLong(),any(CheckpointOptions.class));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID,1L));
      now=System.currentTimeMillis();
      timeout=now + 60000;
      do {
        Thread.sleep(20);
      }
 while (numCalls.get() < maxConcurrentAttempts + 1 && now < timeout);
      assertEquals(maxConcurrentAttempts + 1,numCalls.get());
      Thread.sleep(200);
      assertEquals(maxConcurrentAttempts + 1,numCalls.get());
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testMaxConcurrentAttempsWithSubsumption(){
    try {
      final int maxConcurrentAttempts=2;
      final JobID jid=new JobID();
      final ExecutionAttemptID triggerAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptID);
      ExecutionVertex ackVertex=mockExecutionVertex(ackAttemptID);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,10,200000,0L,maxConcurrentAttempts,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{ackVertex},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      coord.startCheckpointScheduler();
      long now=System.currentTimeMillis();
      long timeout=now + 60000;
      long minDuration=now + 100;
      do {
        Thread.sleep(20);
      }
 while ((now=System.currentTimeMillis()) < minDuration || (coord.getNumberOfPendingCheckpoints() < maxConcurrentAttempts && now < timeout));
      assertEquals(maxConcurrentAttempts,coord.getNumberOfPendingCheckpoints());
      assertNotNull(coord.getPendingCheckpoints().get(1L));
      assertNotNull(coord.getPendingCheckpoints().get(2L));
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jid,ackAttemptID,2L));
      final long newTimeout=System.currentTimeMillis() + 60000;
      do {
        Thread.sleep(20);
      }
 while (coord.getPendingCheckpoints().get(4L) == null && System.currentTimeMillis() < newTimeout);
      assertEquals(maxConcurrentAttempts,coord.getNumberOfPendingCheckpoints());
      assertNotNull(coord.getPendingCheckpoints().get(3L));
      assertNotNull(coord.getPendingCheckpoints().get(4L));
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testPeriodicSchedulingWithInactiveTasks(){
    try {
      final JobID jid=new JobID();
      final ExecutionAttemptID triggerAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID ackAttemptID=new ExecutionAttemptID();
      final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
      ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptID);
      ExecutionVertex ackVertex=mockExecutionVertex(ackAttemptID);
      ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
      final AtomicReference<ExecutionState> currentState=new AtomicReference<>(ExecutionState.CREATED);
      when(triggerVertex.getCurrentExecutionAttempt().getState()).thenAnswer(invocation -> currentState.get());
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,10,200000,0L,2,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{ackVertex},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      coord.startCheckpointScheduler();
      Thread.sleep(200);
      assertEquals(0,coord.getNumberOfPendingCheckpoints());
      currentState.set(ExecutionState.RUNNING);
      final long timeout=System.currentTimeMillis() + 10000;
      do {
        Thread.sleep(20);
      }
 while (System.currentTimeMillis() < timeout && coord.getNumberOfPendingCheckpoints() == 0);
      assertTrue(coord.getNumberOfPendingCheckpoints() > 0);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  /** 
 * Tests that the savepoints can be triggered concurrently.
 */
  @Test public void testConcurrentSavepoints() throws Exception {
    JobID jobId=new JobID();
    final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
    ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
    StandaloneCheckpointIDCounter checkpointIDCounter=new StandaloneCheckpointIDCounter();
    CheckpointCoordinator coord=new CheckpointCoordinator(jobId,100000,200000,0L,1,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},checkpointIDCounter,new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    List<CompletableFuture<CompletedCheckpoint>> savepointFutures=new ArrayList<>();
    int numSavepoints=5;
    String savepointDir=tmpFolder.newFolder().getAbsolutePath();
    for (int i=0; i < numSavepoints; i++) {
      savepointFutures.add(coord.triggerSavepoint(i,savepointDir));
    }
    for (    CompletableFuture<CompletedCheckpoint> savepointFuture : savepointFutures) {
      assertFalse(savepointFuture.isDone());
    }
    long checkpointId=checkpointIDCounter.getLast();
    for (int i=0; i < numSavepoints; i++, checkpointId--) {
      coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId,attemptID1,checkpointId));
    }
    for (    CompletableFuture<CompletedCheckpoint> savepointFuture : savepointFutures) {
      assertTrue(savepointFuture.isDone());
    }
  }
  /** 
 * Tests that no minimum delay between savepoints is enforced.
 */
  @Test public void testMinDelayBetweenSavepoints() throws Exception {
    JobID jobId=new JobID();
    final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
    ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
    CheckpointCoordinator coord=new CheckpointCoordinator(jobId,100000,200000,100000000L,1,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    String savepointDir=tmpFolder.newFolder().getAbsolutePath();
    CompletableFuture<CompletedCheckpoint> savepoint0=coord.triggerSavepoint(0,savepointDir);
    assertFalse("Did not trigger savepoint",savepoint0.isDone());
    CompletableFuture<CompletedCheckpoint> savepoint1=coord.triggerSavepoint(1,savepointDir);
    assertFalse("Did not trigger savepoint",savepoint1.isDone());
  }
  /** 
 * Tests that the checkpointed partitioned and non-partitioned state is assigned properly to the  {@link Execution} upon recovery.
 * @throws Exception
 */
  @Test public void testRestoreLatestCheckpointedState() throws Exception {
    final JobID jid=new JobID();
    final long timestamp=System.currentTimeMillis();
    final JobVertexID jobVertexID1=new JobVertexID();
    final JobVertexID jobVertexID2=new JobVertexID();
    int parallelism1=3;
    int parallelism2=2;
    int maxParallelism1=42;
    int maxParallelism2=13;
    final ExecutionJobVertex jobVertex1=mockExecutionJobVertex(jobVertexID1,parallelism1,maxParallelism1);
    final ExecutionJobVertex jobVertex2=mockExecutionJobVertex(jobVertexID2,parallelism2,maxParallelism2);
    List<ExecutionVertex> allExecutionVertices=new ArrayList<>(parallelism1 + parallelism2);
    allExecutionVertices.addAll(Arrays.asList(jobVertex1.getTaskVertices()));
    allExecutionVertices.addAll(Arrays.asList(jobVertex2.getTaskVertices()));
    ExecutionVertex[] arrayExecutionVertices=allExecutionVertices.toArray(new ExecutionVertex[allExecutionVertices.size()]);
    CompletedCheckpointStore store=new RecoverableCompletedCheckpointStore();
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,arrayExecutionVertices,arrayExecutionVertices,arrayExecutionVertices,new StandaloneCheckpointIDCounter(),store,new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    coord.triggerCheckpoint(timestamp,false);
    assertTrue(coord.getPendingCheckpoints().keySet().size() == 1);
    long checkpointId=Iterables.getOnlyElement(coord.getPendingCheckpoints().keySet());
    List<KeyGroupRange> keyGroupPartitions1=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism1,parallelism1);
    List<KeyGroupRange> keyGroupPartitions2=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism2,parallelism2);
    for (int index=0; index < jobVertex1.getParallelism(); index++) {
      TaskStateSnapshot subtaskState=mockSubtaskState(jobVertexID1,index,keyGroupPartitions1.get(index));
      AcknowledgeCheckpoint acknowledgeCheckpoint=new AcknowledgeCheckpoint(jid,jobVertex1.getTaskVertices()[index].getCurrentExecutionAttempt().getAttemptId(),checkpointId,new CheckpointMetrics(),subtaskState);
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint);
    }
    for (int index=0; index < jobVertex2.getParallelism(); index++) {
      TaskStateSnapshot subtaskState=mockSubtaskState(jobVertexID2,index,keyGroupPartitions2.get(index));
      AcknowledgeCheckpoint acknowledgeCheckpoint=new AcknowledgeCheckpoint(jid,jobVertex2.getTaskVertices()[index].getCurrentExecutionAttempt().getAttemptId(),checkpointId,new CheckpointMetrics(),subtaskState);
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint);
    }
    List<CompletedCheckpoint> completedCheckpoints=coord.getSuccessfulCheckpoints();
    assertEquals(1,completedCheckpoints.size());
    store.shutdown(JobStatus.SUSPENDED);
    Map<JobVertexID,ExecutionJobVertex> tasks=new HashMap<>();
    tasks.put(jobVertexID1,jobVertex1);
    tasks.put(jobVertexID2,jobVertex2);
    coord.restoreLatestCheckpointedState(tasks,true,false);
    for (    CompletedCheckpoint completedCheckpoint : completedCheckpoints) {
      for (      OperatorState taskState : completedCheckpoint.getOperatorStates().values()) {
        for (        OperatorSubtaskState subtaskState : taskState.getStates()) {
          verify(subtaskState,times(2)).registerSharedStates(any(SharedStateRegistry.class));
        }
      }
    }
    verifyStateRestore(jobVertexID1,jobVertex1,keyGroupPartitions1);
    verifyStateRestore(jobVertexID2,jobVertex2,keyGroupPartitions2);
  }
  /** 
 * Tests that the checkpoint restoration fails if the max parallelism of the job vertices has changed.
 * @throws Exception
 */
  @Test(expected=IllegalStateException.class) public void testRestoreLatestCheckpointFailureWhenMaxParallelismChanges() throws Exception {
    final JobID jid=new JobID();
    final long timestamp=System.currentTimeMillis();
    final JobVertexID jobVertexID1=new JobVertexID();
    final JobVertexID jobVertexID2=new JobVertexID();
    int parallelism1=3;
    int parallelism2=2;
    int maxParallelism1=42;
    int maxParallelism2=13;
    final ExecutionJobVertex jobVertex1=mockExecutionJobVertex(jobVertexID1,parallelism1,maxParallelism1);
    final ExecutionJobVertex jobVertex2=mockExecutionJobVertex(jobVertexID2,parallelism2,maxParallelism2);
    List<ExecutionVertex> allExecutionVertices=new ArrayList<>(parallelism1 + parallelism2);
    allExecutionVertices.addAll(Arrays.asList(jobVertex1.getTaskVertices()));
    allExecutionVertices.addAll(Arrays.asList(jobVertex2.getTaskVertices()));
    ExecutionVertex[] arrayExecutionVertices=allExecutionVertices.toArray(new ExecutionVertex[allExecutionVertices.size()]);
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,arrayExecutionVertices,arrayExecutionVertices,arrayExecutionVertices,new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    coord.triggerCheckpoint(timestamp,false);
    assertTrue(coord.getPendingCheckpoints().keySet().size() == 1);
    long checkpointId=Iterables.getOnlyElement(coord.getPendingCheckpoints().keySet());
    List<KeyGroupRange> keyGroupPartitions1=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism1,parallelism1);
    List<KeyGroupRange> keyGroupPartitions2=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism2,parallelism2);
    for (int index=0; index < jobVertex1.getParallelism(); index++) {
      KeyGroupsStateHandle keyGroupState=generateKeyGroupState(jobVertexID1,keyGroupPartitions1.get(index),false);
      OperatorSubtaskState operatorSubtaskState=new OperatorSubtaskState(null,null,keyGroupState,null);
      TaskStateSnapshot taskOperatorSubtaskStates=new TaskStateSnapshot();
      taskOperatorSubtaskStates.putSubtaskStateByOperatorID(OperatorID.fromJobVertexID(jobVertexID1),operatorSubtaskState);
      AcknowledgeCheckpoint acknowledgeCheckpoint=new AcknowledgeCheckpoint(jid,jobVertex1.getTaskVertices()[index].getCurrentExecutionAttempt().getAttemptId(),checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates);
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint);
    }
    for (int index=0; index < jobVertex2.getParallelism(); index++) {
      KeyGroupsStateHandle keyGroupState=generateKeyGroupState(jobVertexID2,keyGroupPartitions2.get(index),false);
      OperatorSubtaskState operatorSubtaskState=new OperatorSubtaskState(null,null,keyGroupState,null);
      TaskStateSnapshot taskOperatorSubtaskStates=new TaskStateSnapshot();
      taskOperatorSubtaskStates.putSubtaskStateByOperatorID(OperatorID.fromJobVertexID(jobVertexID2),operatorSubtaskState);
      AcknowledgeCheckpoint acknowledgeCheckpoint=new AcknowledgeCheckpoint(jid,jobVertex2.getTaskVertices()[index].getCurrentExecutionAttempt().getAttemptId(),checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates);
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint);
    }
    List<CompletedCheckpoint> completedCheckpoints=coord.getSuccessfulCheckpoints();
    assertEquals(1,completedCheckpoints.size());
    Map<JobVertexID,ExecutionJobVertex> tasks=new HashMap<>();
    int newMaxParallelism1=20;
    int newMaxParallelism2=42;
    final ExecutionJobVertex newJobVertex1=mockExecutionJobVertex(jobVertexID1,parallelism1,newMaxParallelism1);
    final ExecutionJobVertex newJobVertex2=mockExecutionJobVertex(jobVertexID2,parallelism2,newMaxParallelism2);
    tasks.put(jobVertexID1,newJobVertex1);
    tasks.put(jobVertexID2,newJobVertex2);
    coord.restoreLatestCheckpointedState(tasks,true,false);
    fail("The restoration should have failed because the max parallelism changed.");
  }
  @Test public void testRestoreLatestCheckpointedStateScaleIn() throws Exception {
    testRestoreLatestCheckpointedStateWithChangingParallelism(false);
  }
  @Test public void testRestoreLatestCheckpointedStateScaleOut() throws Exception {
    testRestoreLatestCheckpointedStateWithChangingParallelism(true);
  }
  @Test public void testStateRecoveryWhenTopologyChangeOut() throws Exception {
    testStateRecoveryWithTopologyChange(0);
  }
  @Test public void testStateRecoveryWhenTopologyChangeIn() throws Exception {
    testStateRecoveryWithTopologyChange(1);
  }
  @Test public void testStateRecoveryWhenTopologyChange() throws Exception {
    testStateRecoveryWithTopologyChange(2);
  }
  /** 
 * Tests the checkpoint restoration with changing parallelism of job vertex with partitioned state.
 * @throws Exception
 */
  private void testRestoreLatestCheckpointedStateWithChangingParallelism(  boolean scaleOut) throws Exception {
    final JobID jid=new JobID();
    final long timestamp=System.currentTimeMillis();
    final JobVertexID jobVertexID1=new JobVertexID();
    final JobVertexID jobVertexID2=new JobVertexID();
    int parallelism1=3;
    int parallelism2=scaleOut ? 2 : 13;
    int maxParallelism1=42;
    int maxParallelism2=13;
    int newParallelism2=scaleOut ? 13 : 2;
    final ExecutionJobVertex jobVertex1=mockExecutionJobVertex(jobVertexID1,parallelism1,maxParallelism1);
    final ExecutionJobVertex jobVertex2=mockExecutionJobVertex(jobVertexID2,parallelism2,maxParallelism2);
    List<ExecutionVertex> allExecutionVertices=new ArrayList<>(parallelism1 + parallelism2);
    allExecutionVertices.addAll(Arrays.asList(jobVertex1.getTaskVertices()));
    allExecutionVertices.addAll(Arrays.asList(jobVertex2.getTaskVertices()));
    ExecutionVertex[] arrayExecutionVertices=allExecutionVertices.toArray(new ExecutionVertex[allExecutionVertices.size()]);
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,arrayExecutionVertices,arrayExecutionVertices,arrayExecutionVertices,new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    coord.triggerCheckpoint(timestamp,false);
    assertTrue(coord.getPendingCheckpoints().keySet().size() == 1);
    long checkpointId=Iterables.getOnlyElement(coord.getPendingCheckpoints().keySet());
    List<KeyGroupRange> keyGroupPartitions1=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism1,parallelism1);
    List<KeyGroupRange> keyGroupPartitions2=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism2,parallelism2);
    for (int index=0; index < jobVertex1.getParallelism(); index++) {
      OperatorStateHandle opStateBackend=generatePartitionableStateHandle(jobVertexID1,index,2,8,false);
      KeyGroupsStateHandle keyedStateBackend=generateKeyGroupState(jobVertexID1,keyGroupPartitions1.get(index),false);
      KeyGroupsStateHandle keyedStateRaw=generateKeyGroupState(jobVertexID1,keyGroupPartitions1.get(index),true);
      OperatorSubtaskState operatorSubtaskState=new OperatorSubtaskState(opStateBackend,null,keyedStateBackend,keyedStateRaw);
      TaskStateSnapshot taskOperatorSubtaskStates=new TaskStateSnapshot();
      taskOperatorSubtaskStates.putSubtaskStateByOperatorID(OperatorID.fromJobVertexID(jobVertexID1),operatorSubtaskState);
      AcknowledgeCheckpoint acknowledgeCheckpoint=new AcknowledgeCheckpoint(jid,jobVertex1.getTaskVertices()[index].getCurrentExecutionAttempt().getAttemptId(),checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates);
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint);
    }
    final List<ChainedStateHandle<OperatorStateHandle>> expectedOpStatesBackend=new ArrayList<>(jobVertex2.getParallelism());
    final List<ChainedStateHandle<OperatorStateHandle>> expectedOpStatesRaw=new ArrayList<>(jobVertex2.getParallelism());
    for (int index=0; index < jobVertex2.getParallelism(); index++) {
      KeyGroupsStateHandle keyedStateBackend=generateKeyGroupState(jobVertexID2,keyGroupPartitions2.get(index),false);
      KeyGroupsStateHandle keyedStateRaw=generateKeyGroupState(jobVertexID2,keyGroupPartitions2.get(index),true);
      OperatorStateHandle opStateBackend=generatePartitionableStateHandle(jobVertexID2,index,2,8,false);
      OperatorStateHandle opStateRaw=generatePartitionableStateHandle(jobVertexID2,index,2,8,true);
      expectedOpStatesBackend.add(new ChainedStateHandle<>(Collections.singletonList(opStateBackend)));
      expectedOpStatesRaw.add(new ChainedStateHandle<>(Collections.singletonList(opStateRaw)));
      OperatorSubtaskState operatorSubtaskState=new OperatorSubtaskState(opStateBackend,opStateRaw,keyedStateBackend,keyedStateRaw);
      TaskStateSnapshot taskOperatorSubtaskStates=new TaskStateSnapshot();
      taskOperatorSubtaskStates.putSubtaskStateByOperatorID(OperatorID.fromJobVertexID(jobVertexID2),operatorSubtaskState);
      AcknowledgeCheckpoint acknowledgeCheckpoint=new AcknowledgeCheckpoint(jid,jobVertex2.getTaskVertices()[index].getCurrentExecutionAttempt().getAttemptId(),checkpointId,new CheckpointMetrics(),taskOperatorSubtaskStates);
      coord.receiveAcknowledgeMessage(acknowledgeCheckpoint);
    }
    List<CompletedCheckpoint> completedCheckpoints=coord.getSuccessfulCheckpoints();
    assertEquals(1,completedCheckpoints.size());
    Map<JobVertexID,ExecutionJobVertex> tasks=new HashMap<>();
    List<KeyGroupRange> newKeyGroupPartitions2=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism2,newParallelism2);
    final ExecutionJobVertex newJobVertex1=mockExecutionJobVertex(jobVertexID1,parallelism1,maxParallelism1);
    final ExecutionJobVertex newJobVertex2=mockExecutionJobVertex(jobVertexID2,newParallelism2,maxParallelism2);
    tasks.put(jobVertexID1,newJobVertex1);
    tasks.put(jobVertexID2,newJobVertex2);
    coord.restoreLatestCheckpointedState(tasks,true,false);
    verifyStateRestore(jobVertexID1,newJobVertex1,keyGroupPartitions1);
    List<List<Collection<OperatorStateHandle>>> actualOpStatesBackend=new ArrayList<>(newJobVertex2.getParallelism());
    List<List<Collection<OperatorStateHandle>>> actualOpStatesRaw=new ArrayList<>(newJobVertex2.getParallelism());
    for (int i=0; i < newJobVertex2.getParallelism(); i++) {
      List<OperatorID> operatorIDs=newJobVertex2.getOperatorIDs();
      KeyGroupsStateHandle originalKeyedStateBackend=generateKeyGroupState(jobVertexID2,newKeyGroupPartitions2.get(i),false);
      KeyGroupsStateHandle originalKeyedStateRaw=generateKeyGroupState(jobVertexID2,newKeyGroupPartitions2.get(i),true);
      JobManagerTaskRestore taskRestore=newJobVertex2.getTaskVertices()[i].getCurrentExecutionAttempt().getTaskRestore();
      Assert.assertEquals(1L,taskRestore.getRestoreCheckpointId());
      TaskStateSnapshot taskStateHandles=taskRestore.getTaskStateSnapshot();
      final int headOpIndex=operatorIDs.size() - 1;
      List<Collection<OperatorStateHandle>> allParallelManagedOpStates=new ArrayList<>(operatorIDs.size());
      List<Collection<OperatorStateHandle>> allParallelRawOpStates=new ArrayList<>(operatorIDs.size());
      for (int idx=0; idx < operatorIDs.size(); ++idx) {
        OperatorID operatorID=operatorIDs.get(idx);
        OperatorSubtaskState opState=taskStateHandles.getSubtaskStateByOperatorID(operatorID);
        Collection<OperatorStateHandle> opStateBackend=opState.getManagedOperatorState();
        Collection<OperatorStateHandle> opStateRaw=opState.getRawOperatorState();
        allParallelManagedOpStates.add(opStateBackend);
        allParallelRawOpStates.add(opStateRaw);
        if (idx == headOpIndex) {
          Collection<KeyedStateHandle> keyedStateBackend=opState.getManagedKeyedState();
          Collection<KeyedStateHandle> keyGroupStateRaw=opState.getRawKeyedState();
          compareKeyedState(Collections.singletonList(originalKeyedStateBackend),keyedStateBackend);
          compareKeyedState(Collections.singletonList(originalKeyedStateRaw),keyGroupStateRaw);
        }
      }
      actualOpStatesBackend.add(allParallelManagedOpStates);
      actualOpStatesRaw.add(allParallelRawOpStates);
    }
    comparePartitionableState(expectedOpStatesBackend,actualOpStatesBackend);
    comparePartitionableState(expectedOpStatesRaw,actualOpStatesRaw);
  }
  private static Tuple2<JobVertexID,OperatorID> generateIDPair(){
    JobVertexID jobVertexID=new JobVertexID();
    OperatorID operatorID=OperatorID.fromJobVertexID(jobVertexID);
    return new Tuple2<>(jobVertexID,operatorID);
  }
  /** 
 * old topology [operator1,operator2] * parallelism1 -> [operator3,operator4] * parallelism2 new topology [operator5,operator1,operator3] * newParallelism1 -> [operator3, operator6] * newParallelism2 scaleType: 0  increase parallelism 1  decrease parallelism 2  same parallelism
 */
  public void testStateRecoveryWithTopologyChange(  int scaleType) throws Exception {
    Tuple2<JobVertexID,OperatorID> id1=generateIDPair();
    Tuple2<JobVertexID,OperatorID> id2=generateIDPair();
    int parallelism1=10;
    int maxParallelism1=64;
    Tuple2<JobVertexID,OperatorID> id3=generateIDPair();
    Tuple2<JobVertexID,OperatorID> id4=generateIDPair();
    int parallelism2=10;
    int maxParallelism2=64;
    List<KeyGroupRange> keyGroupPartitions2=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism2,parallelism2);
    Map<OperatorID,OperatorState> operatorStates=new HashMap<>();
    for (    Tuple2<JobVertexID,OperatorID> id : Arrays.asList(id1,id2)) {
      OperatorState taskState=new OperatorState(id.f1,parallelism1,maxParallelism1);
      operatorStates.put(id.f1,taskState);
      for (int index=0; index < taskState.getParallelism(); index++) {
        OperatorStateHandle subManagedOperatorState=generatePartitionableStateHandle(id.f0,index,2,8,false);
        OperatorStateHandle subRawOperatorState=generatePartitionableStateHandle(id.f0,index,2,8,true);
        OperatorSubtaskState subtaskState=new OperatorSubtaskState(subManagedOperatorState,subRawOperatorState,null,null);
        taskState.putState(index,subtaskState);
      }
    }
    List<List<ChainedStateHandle<OperatorStateHandle>>> expectedManagedOperatorStates=new ArrayList<>();
    List<List<ChainedStateHandle<OperatorStateHandle>>> expectedRawOperatorStates=new ArrayList<>();
    for (    Tuple2<JobVertexID,OperatorID> id : Arrays.asList(id3,id4)) {
      OperatorState operatorState=new OperatorState(id.f1,parallelism2,maxParallelism2);
      operatorStates.put(id.f1,operatorState);
      List<ChainedStateHandle<OperatorStateHandle>> expectedManagedOperatorState=new ArrayList<>();
      List<ChainedStateHandle<OperatorStateHandle>> expectedRawOperatorState=new ArrayList<>();
      expectedManagedOperatorStates.add(expectedManagedOperatorState);
      expectedRawOperatorStates.add(expectedRawOperatorState);
      for (int index=0; index < operatorState.getParallelism(); index++) {
        OperatorStateHandle subManagedOperatorState=generateChainedPartitionableStateHandle(id.f0,index,2,8,false).get(0);
        OperatorStateHandle subRawOperatorState=generateChainedPartitionableStateHandle(id.f0,index,2,8,true).get(0);
        KeyGroupsStateHandle subManagedKeyedState=id.f0.equals(id3.f0) ? generateKeyGroupState(id.f0,keyGroupPartitions2.get(index),false) : null;
        KeyGroupsStateHandle subRawKeyedState=id.f0.equals(id3.f0) ? generateKeyGroupState(id.f0,keyGroupPartitions2.get(index),true) : null;
        expectedManagedOperatorState.add(ChainedStateHandle.wrapSingleHandle(subManagedOperatorState));
        expectedRawOperatorState.add(ChainedStateHandle.wrapSingleHandle(subRawOperatorState));
        OperatorSubtaskState subtaskState=new OperatorSubtaskState(subManagedOperatorState,subRawOperatorState,subManagedKeyedState,subRawKeyedState);
        operatorState.putState(index,subtaskState);
      }
    }
    Tuple2<JobVertexID,OperatorID> id5=generateIDPair();
    int newParallelism1=10;
    Tuple2<JobVertexID,OperatorID> id6=generateIDPair();
    int newParallelism2=parallelism2;
    if (scaleType == 0) {
      newParallelism2=20;
    }
 else     if (scaleType == 1) {
      newParallelism2=8;
    }
    List<KeyGroupRange> newKeyGroupPartitions2=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism2,newParallelism2);
    final ExecutionJobVertex newJobVertex1=mockExecutionJobVertex(id5.f0,Arrays.asList(id2.f1,id1.f1,id5.f1),newParallelism1,maxParallelism1);
    final ExecutionJobVertex newJobVertex2=mockExecutionJobVertex(id3.f0,Arrays.asList(id6.f1,id3.f1),newParallelism2,maxParallelism2);
    Map<JobVertexID,ExecutionJobVertex> tasks=new HashMap<>();
    tasks.put(id5.f0,newJobVertex1);
    tasks.put(id3.f0,newJobVertex2);
    JobID jobID=new JobID();
    StandaloneCompletedCheckpointStore standaloneCompletedCheckpointStore=spy(new StandaloneCompletedCheckpointStore(1));
    CompletedCheckpoint completedCheckpoint=new CompletedCheckpoint(jobID,2,System.currentTimeMillis(),System.currentTimeMillis() + 3000,operatorStates,Collections.<MasterState>emptyList(),CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),new TestCompletedCheckpointStorageLocation());
    when(standaloneCompletedCheckpointStore.getLatestCheckpoint()).thenReturn(completedCheckpoint);
    CheckpointCoordinator coord=new CheckpointCoordinator(new JobID(),600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,newJobVertex1.getTaskVertices(),newJobVertex1.getTaskVertices(),newJobVertex1.getTaskVertices(),new StandaloneCheckpointIDCounter(),standaloneCompletedCheckpointStore,new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    coord.restoreLatestCheckpointedState(tasks,false,true);
    for (int i=0; i < newJobVertex1.getParallelism(); i++) {
      final List<OperatorID> operatorIds=newJobVertex1.getOperatorIDs();
      JobManagerTaskRestore taskRestore=newJobVertex1.getTaskVertices()[i].getCurrentExecutionAttempt().getTaskRestore();
      Assert.assertEquals(2L,taskRestore.getRestoreCheckpointId());
      TaskStateSnapshot stateSnapshot=taskRestore.getTaskStateSnapshot();
      OperatorSubtaskState headOpState=stateSnapshot.getSubtaskStateByOperatorID(operatorIds.get(operatorIds.size() - 1));
      assertTrue(headOpState.getManagedKeyedState().isEmpty());
      assertTrue(headOpState.getRawKeyedState().isEmpty());
{
        int operatorIndexInChain=2;
        OperatorSubtaskState opState=stateSnapshot.getSubtaskStateByOperatorID(operatorIds.get(operatorIndexInChain));
        assertTrue(opState.getManagedOperatorState().isEmpty());
        assertTrue(opState.getRawOperatorState().isEmpty());
      }
{
        int operatorIndexInChain=1;
        OperatorSubtaskState opState=stateSnapshot.getSubtaskStateByOperatorID(operatorIds.get(operatorIndexInChain));
        OperatorStateHandle expectedManagedOpState=generatePartitionableStateHandle(id1.f0,i,2,8,false);
        OperatorStateHandle expectedRawOpState=generatePartitionableStateHandle(id1.f0,i,2,8,true);
        Collection<OperatorStateHandle> managedOperatorState=opState.getManagedOperatorState();
        assertEquals(1,managedOperatorState.size());
        assertTrue(CommonTestUtils.isSteamContentEqual(expectedManagedOpState.openInputStream(),managedOperatorState.iterator().next().openInputStream()));
        Collection<OperatorStateHandle> rawOperatorState=opState.getRawOperatorState();
        assertEquals(1,rawOperatorState.size());
        assertTrue(CommonTestUtils.isSteamContentEqual(expectedRawOpState.openInputStream(),rawOperatorState.iterator().next().openInputStream()));
      }
{
        int operatorIndexInChain=0;
        OperatorSubtaskState opState=stateSnapshot.getSubtaskStateByOperatorID(operatorIds.get(operatorIndexInChain));
        OperatorStateHandle expectedManagedOpState=generatePartitionableStateHandle(id2.f0,i,2,8,false);
        OperatorStateHandle expectedRawOpState=generatePartitionableStateHandle(id2.f0,i,2,8,true);
        Collection<OperatorStateHandle> managedOperatorState=opState.getManagedOperatorState();
        assertEquals(1,managedOperatorState.size());
        assertTrue(CommonTestUtils.isSteamContentEqual(expectedManagedOpState.openInputStream(),managedOperatorState.iterator().next().openInputStream()));
        Collection<OperatorStateHandle> rawOperatorState=opState.getRawOperatorState();
        assertEquals(1,rawOperatorState.size());
        assertTrue(CommonTestUtils.isSteamContentEqual(expectedRawOpState.openInputStream(),rawOperatorState.iterator().next().openInputStream()));
      }
    }
    List<List<Collection<OperatorStateHandle>>> actualManagedOperatorStates=new ArrayList<>(newJobVertex2.getParallelism());
    List<List<Collection<OperatorStateHandle>>> actualRawOperatorStates=new ArrayList<>(newJobVertex2.getParallelism());
    for (int i=0; i < newJobVertex2.getParallelism(); i++) {
      final List<OperatorID> operatorIds=newJobVertex2.getOperatorIDs();
      JobManagerTaskRestore taskRestore=newJobVertex2.getTaskVertices()[i].getCurrentExecutionAttempt().getTaskRestore();
      Assert.assertEquals(2L,taskRestore.getRestoreCheckpointId());
      TaskStateSnapshot stateSnapshot=taskRestore.getTaskStateSnapshot();
{
        int operatorIndexInChain=1;
        OperatorSubtaskState opState=stateSnapshot.getSubtaskStateByOperatorID(operatorIds.get(operatorIndexInChain));
        List<Collection<OperatorStateHandle>> actualSubManagedOperatorState=new ArrayList<>(1);
        actualSubManagedOperatorState.add(opState.getManagedOperatorState());
        List<Collection<OperatorStateHandle>> actualSubRawOperatorState=new ArrayList<>(1);
        actualSubRawOperatorState.add(opState.getRawOperatorState());
        actualManagedOperatorStates.add(actualSubManagedOperatorState);
        actualRawOperatorStates.add(actualSubRawOperatorState);
      }
{
        int operatorIndexInChain=0;
        OperatorSubtaskState opState=stateSnapshot.getSubtaskStateByOperatorID(operatorIds.get(operatorIndexInChain));
        assertTrue(opState.getManagedOperatorState().isEmpty());
        assertTrue(opState.getRawOperatorState().isEmpty());
      }
      KeyGroupsStateHandle originalKeyedStateBackend=generateKeyGroupState(id3.f0,newKeyGroupPartitions2.get(i),false);
      KeyGroupsStateHandle originalKeyedStateRaw=generateKeyGroupState(id3.f0,newKeyGroupPartitions2.get(i),true);
      OperatorSubtaskState headOpState=stateSnapshot.getSubtaskStateByOperatorID(operatorIds.get(operatorIds.size() - 1));
      Collection<KeyedStateHandle> keyedStateBackend=headOpState.getManagedKeyedState();
      Collection<KeyedStateHandle> keyGroupStateRaw=headOpState.getRawKeyedState();
      compareKeyedState(Collections.singletonList(originalKeyedStateBackend),keyedStateBackend);
      compareKeyedState(Collections.singletonList(originalKeyedStateRaw),keyGroupStateRaw);
    }
    comparePartitionableState(expectedManagedOperatorStates.get(0),actualManagedOperatorStates);
    comparePartitionableState(expectedRawOperatorStates.get(0),actualRawOperatorStates);
  }
  /** 
 * Tests that the externalized checkpoint configuration is respected.
 */
  @Test public void testExternalizedCheckpoints() throws Exception {
    try {
      final JobID jid=new JobID();
      final long timestamp=System.currentTimeMillis();
      final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
      ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
      CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.RETAIN_ON_FAILURE,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
      assertTrue(coord.triggerCheckpoint(timestamp,false));
      for (      PendingCheckpoint checkpoint : coord.getPendingCheckpoints().values()) {
        CheckpointProperties props=checkpoint.getProps();
        CheckpointProperties expected=CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE);
        assertEquals(expected,props);
      }
      coord.shutdown(JobStatus.FINISHED);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testReplicateModeStateHandle(){
    Map<String,OperatorStateHandle.StateMetaInfo> metaInfoMap=new HashMap<>(1);
    metaInfoMap.put("t-1",new OperatorStateHandle.StateMetaInfo(new long[]{0,23},OperatorStateHandle.Mode.UNION));
    metaInfoMap.put("t-2",new OperatorStateHandle.StateMetaInfo(new long[]{42,64},OperatorStateHandle.Mode.UNION));
    metaInfoMap.put("t-3",new OperatorStateHandle.StateMetaInfo(new long[]{72,83},OperatorStateHandle.Mode.SPLIT_DISTRIBUTE));
    metaInfoMap.put("t-4",new OperatorStateHandle.StateMetaInfo(new long[]{87,94,95},OperatorStateHandle.Mode.BROADCAST));
    metaInfoMap.put("t-5",new OperatorStateHandle.StateMetaInfo(new long[]{97,108,112},OperatorStateHandle.Mode.BROADCAST));
    metaInfoMap.put("t-6",new OperatorStateHandle.StateMetaInfo(new long[]{121,143,147},OperatorStateHandle.Mode.BROADCAST));
    OperatorStateHandle osh=new OperatorStreamStateHandle(metaInfoMap,new ByteStreamStateHandle("test",new byte[150]));
    OperatorStateRepartitioner repartitioner=RoundRobinOperatorStateRepartitioner.INSTANCE;
    List<List<OperatorStateHandle>> repartitionedStates=repartitioner.repartitionState(Collections.singletonList(osh),3);
    Map<String,Integer> checkCounts=new HashMap<>(3);
    for (    Collection<OperatorStateHandle> operatorStateHandles : repartitionedStates) {
      for (      OperatorStateHandle operatorStateHandle : operatorStateHandles) {
        for (        Map.Entry<String,OperatorStateHandle.StateMetaInfo> stateNameToMetaInfo : operatorStateHandle.getStateNameToPartitionOffsets().entrySet()) {
          String stateName=stateNameToMetaInfo.getKey();
          Integer count=checkCounts.get(stateName);
          if (null == count) {
            checkCounts.put(stateName,1);
          }
 else {
            checkCounts.put(stateName,1 + count);
          }
          OperatorStateHandle.StateMetaInfo stateMetaInfo=stateNameToMetaInfo.getValue();
          if (OperatorStateHandle.Mode.SPLIT_DISTRIBUTE.equals(stateMetaInfo.getDistributionMode())) {
            Assert.assertEquals(1,stateNameToMetaInfo.getValue().getOffsets().length);
          }
 else           if (OperatorStateHandle.Mode.UNION.equals(stateMetaInfo.getDistributionMode())) {
            Assert.assertEquals(2,stateNameToMetaInfo.getValue().getOffsets().length);
          }
 else {
            Assert.assertEquals(3,stateNameToMetaInfo.getValue().getOffsets().length);
          }
        }
      }
    }
    Assert.assertEquals(6,checkCounts.size());
    Assert.assertEquals(3,checkCounts.get("t-1").intValue());
    Assert.assertEquals(3,checkCounts.get("t-2").intValue());
    Assert.assertEquals(2,checkCounts.get("t-3").intValue());
    Assert.assertEquals(3,checkCounts.get("t-4").intValue());
    Assert.assertEquals(3,checkCounts.get("t-5").intValue());
    Assert.assertEquals(3,checkCounts.get("t-6").intValue());
  }
  public static KeyGroupsStateHandle generateKeyGroupState(  JobVertexID jobVertexID,  KeyGroupRange keyGroupPartition,  boolean rawState) throws IOException {
    List<Integer> testStatesLists=new ArrayList<>(keyGroupPartition.getNumberOfKeyGroups());
    for (    int keyGroupIndex : keyGroupPartition) {
      int vertexHash=jobVertexID.hashCode();
      int seed=rawState ? (vertexHash * (31 + keyGroupIndex)) : (vertexHash + keyGroupIndex);
      Random random=new Random(seed);
      int simulatedStateValue=random.nextInt();
      testStatesLists.add(simulatedStateValue);
    }
    return generateKeyGroupState(keyGroupPartition,testStatesLists);
  }
  public static KeyGroupsStateHandle generateKeyGroupState(  KeyGroupRange keyGroupRange,  List<? extends Serializable> states) throws IOException {
    Preconditions.checkArgument(keyGroupRange.getNumberOfKeyGroups() == states.size());
    Tuple2<byte[],List<long[]>> serializedDataWithOffsets=serializeTogetherAndTrackOffsets(Collections.<List<? extends Serializable>>singletonList(states));
    KeyGroupRangeOffsets keyGroupRangeOffsets=new KeyGroupRangeOffsets(keyGroupRange,serializedDataWithOffsets.f1.get(0));
    ByteStreamStateHandle allSerializedStatesHandle=new ByteStreamStateHandle(String.valueOf(UUID.randomUUID()),serializedDataWithOffsets.f0);
    return new KeyGroupsStateHandle(keyGroupRangeOffsets,allSerializedStatesHandle);
  }
  public static Tuple2<byte[],List<long[]>> serializeTogetherAndTrackOffsets(  List<List<? extends Serializable>> serializables) throws IOException {
    List<long[]> offsets=new ArrayList<>(serializables.size());
    List<byte[]> serializedGroupValues=new ArrayList<>();
    int runningGroupsOffset=0;
    for (    List<? extends Serializable> list : serializables) {
      long[] currentOffsets=new long[list.size()];
      offsets.add(currentOffsets);
      for (int i=0; i < list.size(); ++i) {
        currentOffsets[i]=runningGroupsOffset;
        byte[] serializedValue=InstantiationUtil.serializeObject(list.get(i));
        serializedGroupValues.add(serializedValue);
        runningGroupsOffset+=serializedValue.length;
      }
    }
    byte[] allSerializedValuesConcatenated=new byte[runningGroupsOffset];
    runningGroupsOffset=0;
    for (    byte[] serializedGroupValue : serializedGroupValues) {
      System.arraycopy(serializedGroupValue,0,allSerializedValuesConcatenated,runningGroupsOffset,serializedGroupValue.length);
      runningGroupsOffset+=serializedGroupValue.length;
    }
    return new Tuple2<>(allSerializedValuesConcatenated,offsets);
  }
  public static OperatorStateHandle generatePartitionableStateHandle(  JobVertexID jobVertexID,  int index,  int namedStates,  int partitionsPerState,  boolean rawState) throws IOException {
    Map<String,List<? extends Serializable>> statesListsMap=new HashMap<>(namedStates);
    for (int i=0; i < namedStates; ++i) {
      List<Integer> testStatesLists=new ArrayList<>(partitionsPerState);
      int seed=jobVertexID.hashCode() * index + i * namedStates;
      if (rawState) {
        seed=(seed + 1) * 31;
      }
      Random random=new Random(seed);
      for (int j=0; j < partitionsPerState; ++j) {
        int simulatedStateValue=random.nextInt();
        testStatesLists.add(simulatedStateValue);
      }
      statesListsMap.put("state-" + i,testStatesLists);
    }
    return generatePartitionableStateHandle(statesListsMap);
  }
  public static ChainedStateHandle<OperatorStateHandle> generateChainedPartitionableStateHandle(  JobVertexID jobVertexID,  int index,  int namedStates,  int partitionsPerState,  boolean rawState) throws IOException {
    Map<String,List<? extends Serializable>> statesListsMap=new HashMap<>(namedStates);
    for (int i=0; i < namedStates; ++i) {
      List<Integer> testStatesLists=new ArrayList<>(partitionsPerState);
      int seed=jobVertexID.hashCode() * index + i * namedStates;
      if (rawState) {
        seed=(seed + 1) * 31;
      }
      Random random=new Random(seed);
      for (int j=0; j < partitionsPerState; ++j) {
        int simulatedStateValue=random.nextInt();
        testStatesLists.add(simulatedStateValue);
      }
      statesListsMap.put("state-" + i,testStatesLists);
    }
    return ChainedStateHandle.wrapSingleHandle(generatePartitionableStateHandle(statesListsMap));
  }
  private static OperatorStateHandle generatePartitionableStateHandle(  Map<String,List<? extends Serializable>> states) throws IOException {
    List<List<? extends Serializable>> namedStateSerializables=new ArrayList<>(states.size());
    for (    Map.Entry<String,List<? extends Serializable>> entry : states.entrySet()) {
      namedStateSerializables.add(entry.getValue());
    }
    Tuple2<byte[],List<long[]>> serializationWithOffsets=serializeTogetherAndTrackOffsets(namedStateSerializables);
    Map<String,OperatorStateHandle.StateMetaInfo> offsetsMap=new HashMap<>(states.size());
    int idx=0;
    for (    Map.Entry<String,List<? extends Serializable>> entry : states.entrySet()) {
      offsetsMap.put(entry.getKey(),new OperatorStateHandle.StateMetaInfo(serializationWithOffsets.f1.get(idx),OperatorStateHandle.Mode.SPLIT_DISTRIBUTE));
      ++idx;
    }
    ByteStreamStateHandle streamStateHandle=new ByteStreamStateHandle(String.valueOf(UUID.randomUUID()),serializationWithOffsets.f0);
    return new OperatorStreamStateHandle(offsetsMap,streamStateHandle);
  }
  static ExecutionJobVertex mockExecutionJobVertex(  JobVertexID jobVertexID,  int parallelism,  int maxParallelism){
    return mockExecutionJobVertex(jobVertexID,Collections.singletonList(OperatorID.fromJobVertexID(jobVertexID)),parallelism,maxParallelism);
  }
  static ExecutionJobVertex mockExecutionJobVertex(  JobVertexID jobVertexID,  List<OperatorID> jobVertexIDs,  int parallelism,  int maxParallelism){
    final ExecutionJobVertex executionJobVertex=mock(ExecutionJobVertex.class);
    ExecutionVertex[] executionVertices=new ExecutionVertex[parallelism];
    for (int i=0; i < parallelism; i++) {
      executionVertices[i]=mockExecutionVertex(new ExecutionAttemptID(),jobVertexID,jobVertexIDs,parallelism,maxParallelism,ExecutionState.RUNNING);
      when(executionVertices[i].getParallelSubtaskIndex()).thenReturn(i);
    }
    when(executionJobVertex.getJobVertexId()).thenReturn(jobVertexID);
    when(executionJobVertex.getTaskVertices()).thenReturn(executionVertices);
    when(executionJobVertex.getParallelism()).thenReturn(parallelism);
    when(executionJobVertex.getMaxParallelism()).thenReturn(maxParallelism);
    when(executionJobVertex.isMaxParallelismConfigured()).thenReturn(true);
    when(executionJobVertex.getOperatorIDs()).thenReturn(jobVertexIDs);
    when(executionJobVertex.getUserDefinedOperatorIDs()).thenReturn(Arrays.asList(new OperatorID[jobVertexIDs.size()]));
    return executionJobVertex;
  }
  static ExecutionVertex mockExecutionVertex(  ExecutionAttemptID attemptID){
    JobVertexID jobVertexID=new JobVertexID();
    return mockExecutionVertex(attemptID,jobVertexID,Collections.singletonList(OperatorID.fromJobVertexID(jobVertexID)),1,1,ExecutionState.RUNNING);
  }
  private static ExecutionVertex mockExecutionVertex(  ExecutionAttemptID attemptID,  JobVertexID jobVertexID,  List<OperatorID> jobVertexIDs,  int parallelism,  int maxParallelism,  ExecutionState state,  ExecutionState... successiveStates){
    ExecutionVertex vertex=mock(ExecutionVertex.class);
    final Execution exec=spy(new Execution(mock(Executor.class),vertex,1,1L,1L,Time.milliseconds(500L)));
    when(exec.getAttemptId()).thenReturn(attemptID);
    when(exec.getState()).thenReturn(state,successiveStates);
    when(vertex.getJobvertexId()).thenReturn(jobVertexID);
    when(vertex.getCurrentExecutionAttempt()).thenReturn(exec);
    when(vertex.getTotalNumberOfParallelSubtasks()).thenReturn(parallelism);
    when(vertex.getMaxParallelism()).thenReturn(maxParallelism);
    ExecutionJobVertex jobVertex=mock(ExecutionJobVertex.class);
    when(jobVertex.getOperatorIDs()).thenReturn(jobVertexIDs);
    when(vertex.getJobVertex()).thenReturn(jobVertex);
    return vertex;
  }
  static TaskStateSnapshot mockSubtaskState(  JobVertexID jobVertexID,  int index,  KeyGroupRange keyGroupRange) throws IOException {
    OperatorStateHandle partitionableState=generatePartitionableStateHandle(jobVertexID,index,2,8,false);
    KeyGroupsStateHandle partitionedKeyGroupState=generateKeyGroupState(jobVertexID,keyGroupRange,false);
    TaskStateSnapshot subtaskStates=spy(new TaskStateSnapshot());
    OperatorSubtaskState subtaskState=spy(new OperatorSubtaskState(partitionableState,null,partitionedKeyGroupState,null));
    subtaskStates.putSubtaskStateByOperatorID(OperatorID.fromJobVertexID(jobVertexID),subtaskState);
    return subtaskStates;
  }
  public static void verifyStateRestore(  JobVertexID jobVertexID,  ExecutionJobVertex executionJobVertex,  List<KeyGroupRange> keyGroupPartitions) throws Exception {
    for (int i=0; i < executionJobVertex.getParallelism(); i++) {
      JobManagerTaskRestore taskRestore=executionJobVertex.getTaskVertices()[i].getCurrentExecutionAttempt().getTaskRestore();
      Assert.assertEquals(1L,taskRestore.getRestoreCheckpointId());
      TaskStateSnapshot stateSnapshot=taskRestore.getTaskStateSnapshot();
      OperatorSubtaskState operatorState=stateSnapshot.getSubtaskStateByOperatorID(OperatorID.fromJobVertexID(jobVertexID));
      ChainedStateHandle<OperatorStateHandle> expectedOpStateBackend=generateChainedPartitionableStateHandle(jobVertexID,i,2,8,false);
      assertTrue(CommonTestUtils.isSteamContentEqual(expectedOpStateBackend.get(0).openInputStream(),operatorState.getManagedOperatorState().iterator().next().openInputStream()));
      KeyGroupsStateHandle expectPartitionedKeyGroupState=generateKeyGroupState(jobVertexID,keyGroupPartitions.get(i),false);
      compareKeyedState(Collections.singletonList(expectPartitionedKeyGroupState),operatorState.getManagedKeyedState());
    }
  }
  public static void compareKeyedState(  Collection<KeyGroupsStateHandle> expectPartitionedKeyGroupState,  Collection<? extends KeyedStateHandle> actualPartitionedKeyGroupState) throws Exception {
    KeyGroupsStateHandle expectedHeadOpKeyGroupStateHandle=expectPartitionedKeyGroupState.iterator().next();
    int expectedTotalKeyGroups=expectedHeadOpKeyGroupStateHandle.getKeyGroupRange().getNumberOfKeyGroups();
    int actualTotalKeyGroups=0;
    for (    KeyedStateHandle keyedStateHandle : actualPartitionedKeyGroupState) {
      assertTrue(keyedStateHandle instanceof KeyGroupsStateHandle);
      actualTotalKeyGroups+=keyedStateHandle.getKeyGroupRange().getNumberOfKeyGroups();
    }
    assertEquals(expectedTotalKeyGroups,actualTotalKeyGroups);
    try (FSDataInputStream inputStream=expectedHeadOpKeyGroupStateHandle.openInputStream()){
      for (      int groupId : expectedHeadOpKeyGroupStateHandle.getKeyGroupRange()) {
        long offset=expectedHeadOpKeyGroupStateHandle.getOffsetForKeyGroup(groupId);
        inputStream.seek(offset);
        int expectedKeyGroupState=InstantiationUtil.deserializeObject(inputStream,Thread.currentThread().getContextClassLoader());
        for (        KeyedStateHandle oneActualKeyedStateHandle : actualPartitionedKeyGroupState) {
          assertTrue(oneActualKeyedStateHandle instanceof KeyGroupsStateHandle);
          KeyGroupsStateHandle oneActualKeyGroupStateHandle=(KeyGroupsStateHandle)oneActualKeyedStateHandle;
          if (oneActualKeyGroupStateHandle.getKeyGroupRange().contains(groupId)) {
            long actualOffset=oneActualKeyGroupStateHandle.getOffsetForKeyGroup(groupId);
            try (FSDataInputStream actualInputStream=oneActualKeyGroupStateHandle.openInputStream()){
              actualInputStream.seek(actualOffset);
              int actualGroupState=InstantiationUtil.deserializeObject(actualInputStream,Thread.currentThread().getContextClassLoader());
              assertEquals(expectedKeyGroupState,actualGroupState);
            }
           }
        }
      }
    }
   }
  public static void comparePartitionableState(  List<ChainedStateHandle<OperatorStateHandle>> expected,  List<List<Collection<OperatorStateHandle>>> actual) throws Exception {
    List<String> expectedResult=new ArrayList<>();
    for (    ChainedStateHandle<OperatorStateHandle> chainedStateHandle : expected) {
      for (int i=0; i < chainedStateHandle.getLength(); ++i) {
        OperatorStateHandle operatorStateHandle=chainedStateHandle.get(i);
        collectResult(i,operatorStateHandle,expectedResult);
      }
    }
    Collections.sort(expectedResult);
    List<String> actualResult=new ArrayList<>();
    for (    List<Collection<OperatorStateHandle>> collectionList : actual) {
      if (collectionList != null) {
        for (int i=0; i < collectionList.size(); ++i) {
          Collection<OperatorStateHandle> stateHandles=collectionList.get(i);
          Assert.assertNotNull(stateHandles);
          for (          OperatorStateHandle operatorStateHandle : stateHandles) {
            collectResult(i,operatorStateHandle,actualResult);
          }
        }
      }
    }
    Collections.sort(actualResult);
    Assert.assertEquals(expectedResult,actualResult);
  }
  private static void collectResult(  int opIdx,  OperatorStateHandle operatorStateHandle,  List<String> resultCollector) throws Exception {
    try (FSDataInputStream in=operatorStateHandle.openInputStream()){
      for (      Map.Entry<String,OperatorStateHandle.StateMetaInfo> entry : operatorStateHandle.getStateNameToPartitionOffsets().entrySet()) {
        for (        long offset : entry.getValue().getOffsets()) {
          in.seek(offset);
          Integer state=InstantiationUtil.deserializeObject(in,Thread.currentThread().getContextClassLoader());
          resultCollector.add(opIdx + " : " + entry.getKey()+ " : "+ state);
        }
      }
    }
   }
  @Test public void testCreateKeyGroupPartitions(){
    testCreateKeyGroupPartitions(1,1);
    testCreateKeyGroupPartitions(13,1);
    testCreateKeyGroupPartitions(13,2);
    testCreateKeyGroupPartitions(Short.MAX_VALUE,1);
    testCreateKeyGroupPartitions(Short.MAX_VALUE,13);
    testCreateKeyGroupPartitions(Short.MAX_VALUE,Short.MAX_VALUE);
    Random r=new Random(1234);
    for (int k=0; k < 1000; ++k) {
      int maxParallelism=1 + r.nextInt(Short.MAX_VALUE - 1);
      int parallelism=1 + r.nextInt(maxParallelism);
      testCreateKeyGroupPartitions(maxParallelism,parallelism);
    }
  }
  @Test public void testStopPeriodicScheduler() throws Exception {
    final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
    ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
    CheckpointCoordinator coord=new CheckpointCoordinator(new JobID(),600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    CheckpointTriggerResult triggerResult=coord.triggerCheckpoint(System.currentTimeMillis(),CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),null,true);
    assertTrue(triggerResult.isFailure());
    assertEquals(CheckpointDeclineReason.PERIODIC_SCHEDULER_SHUTDOWN,triggerResult.getFailureReason());
    triggerResult=coord.triggerCheckpoint(System.currentTimeMillis(),CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),null,false);
    assertFalse(triggerResult.isFailure());
  }
  private void testCreateKeyGroupPartitions(  int maxParallelism,  int parallelism){
    List<KeyGroupRange> ranges=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism,parallelism);
    for (int i=0; i < maxParallelism; ++i) {
      KeyGroupRange range=ranges.get(KeyGroupRangeAssignment.computeOperatorIndexForKeyGroup(maxParallelism,parallelism,i));
      if (!range.contains(i)) {
        Assert.fail("Could not find expected key-group " + i + " in range "+ range);
      }
    }
  }
  @Test public void testPartitionableStateRepartitioning(){
    Random r=new Random(42);
    for (int run=0; run < 10000; ++run) {
      int oldParallelism=1 + r.nextInt(9);
      int newParallelism=1 + r.nextInt(9);
      int numNamedStates=1 + r.nextInt(9);
      int maxPartitionsPerState=1 + r.nextInt(9);
      doTestPartitionableStateRepartitioning(r,oldParallelism,newParallelism,numNamedStates,maxPartitionsPerState);
    }
  }
  private void doTestPartitionableStateRepartitioning(  Random r,  int oldParallelism,  int newParallelism,  int numNamedStates,  int maxPartitionsPerState){
    List<OperatorStateHandle> previousParallelOpInstanceStates=new ArrayList<>(oldParallelism);
    for (int i=0; i < oldParallelism; ++i) {
      Path fakePath=new Path("/fake-" + i);
      Map<String,OperatorStateHandle.StateMetaInfo> namedStatesToOffsets=new HashMap<>();
      int off=0;
      for (int s=0; s < numNamedStates - 1; ++s) {
        long[] offs=new long[1 + r.nextInt(maxPartitionsPerState)];
        for (int o=0; o < offs.length; ++o) {
          offs[o]=off;
          ++off;
        }
        OperatorStateHandle.Mode mode=r.nextInt(10) == 0 ? OperatorStateHandle.Mode.UNION : OperatorStateHandle.Mode.SPLIT_DISTRIBUTE;
        namedStatesToOffsets.put("State-" + s,new OperatorStateHandle.StateMetaInfo(offs,mode));
      }
      if (numNamedStates % 2 == 0) {
        long[] offs={off + 1,off + 2,off + 3,off + 4};
        namedStatesToOffsets.put("State-" + (numNamedStates - 1),new OperatorStateHandle.StateMetaInfo(offs,OperatorStateHandle.Mode.BROADCAST));
      }
      previousParallelOpInstanceStates.add(new OperatorStreamStateHandle(namedStatesToOffsets,new FileStateHandle(fakePath,-1)));
    }
    Map<StreamStateHandle,Map<String,List<Long>>> expected=new HashMap<>();
    int taskIndex=0;
    int expectedTotalPartitions=0;
    for (    OperatorStateHandle psh : previousParallelOpInstanceStates) {
      Map<String,OperatorStateHandle.StateMetaInfo> offsMap=psh.getStateNameToPartitionOffsets();
      Map<String,List<Long>> offsMapWithList=new HashMap<>(offsMap.size());
      for (      Map.Entry<String,OperatorStateHandle.StateMetaInfo> e : offsMap.entrySet()) {
        long[] offs=e.getValue().getOffsets();
        int replication;
switch (e.getValue().getDistributionMode()) {
case UNION:
          replication=newParallelism;
        break;
case BROADCAST:
      int extra=taskIndex < (newParallelism % oldParallelism) ? 1 : 0;
    replication=newParallelism / oldParallelism + extra;
  break;
case SPLIT_DISTRIBUTE:
replication=1;
break;
default :
throw new RuntimeException("Unknown distribution mode " + e.getValue().getDistributionMode());
}
if (replication > 0) {
expectedTotalPartitions+=replication * offs.length;
List<Long> offsList=new ArrayList<>(offs.length);
for (long off : offs) {
for (int p=0; p < replication; ++p) {
offsList.add(off);
}
}
offsMapWithList.put(e.getKey(),offsList);
}
}
if (!offsMapWithList.isEmpty()) {
expected.put(psh.getDelegateStateHandle(),offsMapWithList);
}
taskIndex++;
}
OperatorStateRepartitioner repartitioner=RoundRobinOperatorStateRepartitioner.INSTANCE;
List<List<OperatorStateHandle>> pshs=repartitioner.repartitionState(previousParallelOpInstanceStates,newParallelism);
Map<StreamStateHandle,Map<String,List<Long>>> actual=new HashMap<>();
int minCount=Integer.MAX_VALUE;
int maxCount=0;
int actualTotalPartitions=0;
for (int p=0; p < newParallelism; ++p) {
int partitionCount=0;
Collection<OperatorStateHandle> pshc=pshs.get(p);
for (OperatorStateHandle sh : pshc) {
for (Map.Entry<String,OperatorStateHandle.StateMetaInfo> namedState : sh.getStateNameToPartitionOffsets().entrySet()) {
Map<String,List<Long>> stateToOffsets=actual.get(sh.getDelegateStateHandle());
if (stateToOffsets == null) {
stateToOffsets=new HashMap<>();
actual.put(sh.getDelegateStateHandle(),stateToOffsets);
}
List<Long> actualOffs=stateToOffsets.get(namedState.getKey());
if (actualOffs == null) {
actualOffs=new ArrayList<>();
stateToOffsets.put(namedState.getKey(),actualOffs);
}
long[] add=namedState.getValue().getOffsets();
for (long l : add) {
actualOffs.add(l);
}
partitionCount+=namedState.getValue().getOffsets().length;
}
}
minCount=Math.min(minCount,partitionCount);
maxCount=Math.max(maxCount,partitionCount);
actualTotalPartitions+=partitionCount;
}
for (Map<String,List<Long>> v : actual.values()) {
for (List<Long> l : v.values()) {
Collections.sort(l);
}
}
int maxLoadDiff=maxCount - minCount;
Assert.assertTrue("Difference in partition load is > 1 : " + maxLoadDiff,maxLoadDiff <= 1);
Assert.assertEquals(expectedTotalPartitions,actualTotalPartitions);
Assert.assertEquals(expected,actual);
}
/** 
 * Tests that the pending checkpoint stats callbacks are created.
 */
@Test public void testCheckpointStatsTrackerPendingCheckpointCallback(){
final long timestamp=System.currentTimeMillis();
ExecutionVertex vertex1=mockExecutionVertex(new ExecutionAttemptID());
CheckpointCoordinator coord=new CheckpointCoordinator(new JobID(),600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
CheckpointStatsTracker tracker=mock(CheckpointStatsTracker.class);
coord.setCheckpointStatsTracker(tracker);
when(tracker.reportPendingCheckpoint(anyLong(),anyLong(),any(CheckpointProperties.class))).thenReturn(mock(PendingCheckpointStats.class));
assertTrue(coord.triggerCheckpoint(timestamp,false));
verify(tracker,times(1)).reportPendingCheckpoint(eq(1L),eq(timestamp),eq(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)));
}
/** 
 * Tests that the restore callbacks are called if registered.
 */
@Test public void testCheckpointStatsTrackerRestoreCallback() throws Exception {
ExecutionVertex vertex1=mockExecutionVertex(new ExecutionAttemptID());
StandaloneCompletedCheckpointStore store=new StandaloneCompletedCheckpointStore(1);
CheckpointCoordinator coord=new CheckpointCoordinator(new JobID(),600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new StandaloneCheckpointIDCounter(),store,new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
store.addCheckpoint(new CompletedCheckpoint(new JobID(),0,0,0,Collections.<OperatorID,OperatorState>emptyMap(),Collections.<MasterState>emptyList(),CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),new TestCompletedCheckpointStorageLocation()));
CheckpointStatsTracker tracker=mock(CheckpointStatsTracker.class);
coord.setCheckpointStatsTracker(tracker);
assertTrue(coord.restoreLatestCheckpointedState(Collections.<JobVertexID,ExecutionJobVertex>emptyMap(),false,true));
verify(tracker,times(1)).reportRestoredCheckpoint(any(RestoredCheckpointStats.class));
}
@Test public void testSharedStateRegistrationOnRestore() throws Exception {
final JobID jid=new JobID();
final long timestamp=System.currentTimeMillis();
final JobVertexID jobVertexID1=new JobVertexID();
int parallelism1=2;
int maxParallelism1=4;
final ExecutionJobVertex jobVertex1=mockExecutionJobVertex(jobVertexID1,parallelism1,maxParallelism1);
List<ExecutionVertex> allExecutionVertices=new ArrayList<>(parallelism1);
allExecutionVertices.addAll(Arrays.asList(jobVertex1.getTaskVertices()));
ExecutionVertex[] arrayExecutionVertices=allExecutionVertices.toArray(new ExecutionVertex[allExecutionVertices.size()]);
RecoverableCompletedCheckpointStore store=new RecoverableCompletedCheckpointStore(10);
final List<SharedStateRegistry> createdSharedStateRegistries=new ArrayList<>(2);
CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,arrayExecutionVertices,arrayExecutionVertices,arrayExecutionVertices,new StandaloneCheckpointIDCounter(),store,new MemoryStateBackend(),Executors.directExecutor(),deleteExecutor -> {
SharedStateRegistry instance=new SharedStateRegistry(deleteExecutor);
createdSharedStateRegistries.add(instance);
return instance;
}
);
final int numCheckpoints=3;
List<KeyGroupRange> keyGroupPartitions1=StateAssignmentOperation.createKeyGroupPartitions(maxParallelism1,parallelism1);
for (int i=0; i < numCheckpoints; ++i) {
performIncrementalCheckpoint(jid,coord,jobVertex1,keyGroupPartitions1,timestamp + i,i);
}
List<CompletedCheckpoint> completedCheckpoints=coord.getSuccessfulCheckpoints();
assertEquals(numCheckpoints,completedCheckpoints.size());
int sharedHandleCount=0;
List<Map<StateHandleID,StreamStateHandle>> sharedHandlesByCheckpoint=new ArrayList<>(numCheckpoints);
for (int i=0; i < numCheckpoints; ++i) {
sharedHandlesByCheckpoint.add(new HashMap<>(2));
}
int cp=0;
for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {
for (OperatorState taskState : completedCheckpoint.getOperatorStates().values()) {
for (OperatorSubtaskState subtaskState : taskState.getStates()) {
for (KeyedStateHandle keyedStateHandle : subtaskState.getManagedKeyedState()) {
verify(keyedStateHandle,times(1)).registerSharedStates(createdSharedStateRegistries.get(0));
IncrementalKeyedStateHandle incrementalKeyedStateHandle=(IncrementalKeyedStateHandle)keyedStateHandle;
sharedHandlesByCheckpoint.get(cp).putAll(incrementalKeyedStateHandle.getSharedState());
for (StreamStateHandle streamStateHandle : incrementalKeyedStateHandle.getSharedState().values()) {
assertTrue(!(streamStateHandle instanceof PlaceholderStreamStateHandle));
verify(streamStateHandle,never()).discardState();
++sharedHandleCount;
}
for (StreamStateHandle streamStateHandle : incrementalKeyedStateHandle.getPrivateState().values()) {
verify(streamStateHandle,never()).discardState();
}
verify(incrementalKeyedStateHandle.getMetaStateHandle(),never()).discardState();
}
verify(subtaskState,never()).discardState();
}
}
++cp;
}
assertEquals(10,sharedHandleCount);
store.removeOldestCheckpoint();
for (Map<StateHandleID,StreamStateHandle> cpList : sharedHandlesByCheckpoint) {
for (StreamStateHandle streamStateHandle : cpList.values()) {
verify(streamStateHandle,never()).discardState();
}
}
store.shutdown(JobStatus.SUSPENDED);
Map<JobVertexID,ExecutionJobVertex> tasks=new HashMap<>();
tasks.put(jobVertexID1,jobVertex1);
coord.restoreLatestCheckpointedState(tasks,true,false);
cp=0;
for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {
for (OperatorState taskState : completedCheckpoint.getOperatorStates().values()) {
for (OperatorSubtaskState subtaskState : taskState.getStates()) {
for (KeyedStateHandle keyedStateHandle : subtaskState.getManagedKeyedState()) {
VerificationMode verificationMode;
if (cp > 0) {
verificationMode=times(1);
}
 else {
verificationMode=never();
}
verify(keyedStateHandle,verificationMode).registerSharedStates(createdSharedStateRegistries.get(1));
}
}
}
++cp;
}
store.removeOldestCheckpoint();
for (Map<StateHandleID,StreamStateHandle> cpList : sharedHandlesByCheckpoint) {
for (Map.Entry<StateHandleID,StreamStateHandle> entry : cpList.entrySet()) {
String key=entry.getKey().getKeyString();
int belongToCP=Integer.parseInt(String.valueOf(key.charAt(key.length() - 1)));
if (belongToCP == 0) {
verify(entry.getValue(),times(1)).discardState();
}
 else {
verify(entry.getValue(),never()).discardState();
}
}
}
store.removeOldestCheckpoint();
for (Map<StateHandleID,StreamStateHandle> cpList : sharedHandlesByCheckpoint) {
for (StreamStateHandle streamStateHandle : cpList.values()) {
verify(streamStateHandle,times(1)).discardState();
}
}
}
private void performIncrementalCheckpoint(JobID jid,CheckpointCoordinator coord,ExecutionJobVertex jobVertex1,List<KeyGroupRange> keyGroupPartitions1,long timestamp,int cpSequenceNumber) throws Exception {
coord.triggerCheckpoint(timestamp,false);
assertTrue(coord.getPendingCheckpoints().keySet().size() == 1);
long checkpointId=Iterables.getOnlyElement(coord.getPendingCheckpoints().keySet());
for (int index=0; index < jobVertex1.getParallelism(); index++) {
KeyGroupRange keyGroupRange=keyGroupPartitions1.get(index);
Map<StateHandleID,StreamStateHandle> privateState=new HashMap<>();
privateState.put(new StateHandleID("private-1"),spy(new ByteStreamStateHandle("private-1",new byte[]{'p'})));
Map<StateHandleID,StreamStateHandle> sharedState=new HashMap<>();
if (cpSequenceNumber > 0) {
sharedState.put(new StateHandleID("shared-" + (cpSequenceNumber - 1)),spy(new PlaceholderStreamStateHandle()));
}
sharedState.put(new StateHandleID("shared-" + cpSequenceNumber),spy(new ByteStreamStateHandle("shared-" + cpSequenceNumber + "-"+ keyGroupRange,new byte[]{'s'})));
IncrementalKeyedStateHandle managedState=spy(new IncrementalKeyedStateHandle(new UUID(42L,42L),keyGroupRange,checkpointId,sharedState,privateState,spy(new ByteStreamStateHandle("meta",new byte[]{'m'}))));
OperatorSubtaskState operatorSubtaskState=spy(new OperatorSubtaskState(StateObjectCollection.empty(),StateObjectCollection.empty(),StateObjectCollection.singleton(managedState),StateObjectCollection.empty()));
Map<OperatorID,OperatorSubtaskState> opStates=new HashMap<>();
opStates.put(jobVertex1.getOperatorIDs().get(0),operatorSubtaskState);
TaskStateSnapshot taskStateSnapshot=new TaskStateSnapshot(opStates);
AcknowledgeCheckpoint acknowledgeCheckpoint=new AcknowledgeCheckpoint(jid,jobVertex1.getTaskVertices()[index].getCurrentExecutionAttempt().getAttemptId(),checkpointId,new CheckpointMetrics(),taskStateSnapshot);
coord.receiveAcknowledgeMessage(acknowledgeCheckpoint);
}
}
}
