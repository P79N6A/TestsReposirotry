/** 
 * The invokable handler used for triggering checkpoint and validation.
 */
private static class ValidatingCheckpointHandler extends AbstractInvokable {
  private long nextExpectedCheckpointId=-1L;
  private long lastReportedBytesBufferedInAlignment=-1;
  public ValidatingCheckpointHandler(){
    super(new DummyEnvironment("test",1,0));
  }
  public void setNextExpectedCheckpointId(  long nextExpectedCheckpointId){
    this.nextExpectedCheckpointId=nextExpectedCheckpointId;
  }
  public long getNextExpectedCheckpointId(){
    return nextExpectedCheckpointId;
  }
  long getLastReportedBytesBufferedInAlignment(){
    return lastReportedBytesBufferedInAlignment;
  }
  @Override public void invoke(){
    throw new UnsupportedOperationException();
  }
  @Override public boolean triggerCheckpoint(  CheckpointMetaData checkpointMetaData,  CheckpointOptions checkpointOptions) throws Exception {
    throw new UnsupportedOperationException("should never be called");
  }
  @Override public void triggerCheckpointOnBarrier(  CheckpointMetaData checkpointMetaData,  CheckpointOptions checkpointOptions,  CheckpointMetrics checkpointMetrics) throws Exception {
    assertTrue("wrong checkpoint id",nextExpectedCheckpointId == -1L || nextExpectedCheckpointId == checkpointMetaData.getCheckpointId());
    assertTrue(checkpointMetaData.getTimestamp() > 0);
    assertTrue(checkpointMetrics.getBytesBufferedInAlignment() >= 0);
    assertTrue(checkpointMetrics.getAlignmentDurationNanos() >= 0);
    nextExpectedCheckpointId++;
    lastReportedBytesBufferedInAlignment=checkpointMetrics.getBytesBufferedInAlignment();
  }
  @Override public void abortCheckpointOnBarrier(  long checkpointId,  Throwable cause){
  }
  @Override public void notifyCheckpointComplete(  long checkpointId) throws Exception {
    throw new UnsupportedOperationException("should never be called");
  }
}
