public class EnumSerializerTest extends TestLogger {
  @Test public void testPublicEnum(){
    testEnumSerializer(PrivateEnum.ONE,PrivateEnum.TWO,PrivateEnum.THREE);
  }
  @Test public void testPrivateEnum(){
    testEnumSerializer(PublicEnum.FOO,PublicEnum.BAR,PublicEnum.PETER,PublicEnum.NATHANIEL,PublicEnum.EMMA,PublicEnum.PAULA);
  }
  @Test(expected=IllegalArgumentException.class) public void testEmptyEnum(){
    new EnumSerializer<>(EmptyEnum.class);
  }
  @Test public void testReconfiguration(){
    PublicEnum[] mockPreviousOrder={PublicEnum.BAR,PublicEnum.PAULA,PublicEnum.NATHANIEL};
    EnumSerializer<PublicEnum> serializer=new EnumSerializer<>(PublicEnum.class);
    assertEquals(PublicEnum.FOO.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.FOO).intValue());
    assertEquals(PublicEnum.BAR.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.BAR).intValue());
    assertEquals(PublicEnum.PETER.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PETER).intValue());
    assertEquals(PublicEnum.NATHANIEL.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.NATHANIEL).intValue());
    assertEquals(PublicEnum.EMMA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.EMMA).intValue());
    assertEquals(PublicEnum.PAULA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PAULA).intValue());
    CompatibilityResult<PublicEnum> compatResult=serializer.ensureCompatibility(new EnumSerializer.EnumSerializerConfigSnapshot<>(PublicEnum.class,mockPreviousOrder));
    assertFalse(compatResult.isRequiresMigration());
    PublicEnum[] expectedOrder={PublicEnum.BAR,PublicEnum.PAULA,PublicEnum.NATHANIEL,PublicEnum.FOO,PublicEnum.PETER,PublicEnum.EMMA};
    int i=0;
    for (    PublicEnum constant : expectedOrder) {
      assertEquals(i,serializer.getValueToOrdinal().get(constant).intValue());
      i++;
    }
    assertTrue(Arrays.equals(expectedOrder,serializer.getValues()));
  }
  @Test public void testConfigurationSnapshotSerialization() throws Exception {
    EnumSerializer<PublicEnum> serializer=new EnumSerializer<>(PublicEnum.class);
    byte[] serializedConfig;
    try (ByteArrayOutputStream out=new ByteArrayOutputStream()){
      TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out),serializer.snapshotConfiguration());
      serializedConfig=out.toByteArray();
    }
     TypeSerializerConfigSnapshot restoredConfig;
    try (ByteArrayInputStream in=new ByteArrayInputStream(serializedConfig)){
      restoredConfig=TypeSerializerSerializationUtil.readSerializerConfigSnapshot(new DataInputViewStreamWrapper(in),Thread.currentThread().getContextClassLoader());
    }
     CompatibilityResult<PublicEnum> compatResult=serializer.ensureCompatibility(restoredConfig);
    assertFalse(compatResult.isRequiresMigration());
    assertEquals(PublicEnum.FOO.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.FOO).intValue());
    assertEquals(PublicEnum.BAR.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.BAR).intValue());
    assertEquals(PublicEnum.PETER.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PETER).intValue());
    assertEquals(PublicEnum.NATHANIEL.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.NATHANIEL).intValue());
    assertEquals(PublicEnum.EMMA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.EMMA).intValue());
    assertEquals(PublicEnum.PAULA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PAULA).intValue());
    assertTrue(Arrays.equals(PublicEnum.values(),serializer.getValues()));
  }
  @Test public void testSerializeEnumSerializer() throws Exception {
    EnumSerializer<PublicEnum> serializer=new EnumSerializer<>(PublicEnum.class);
    assertEquals(PublicEnum.FOO.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.FOO).intValue());
    assertEquals(PublicEnum.BAR.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.BAR).intValue());
    assertEquals(PublicEnum.PETER.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PETER).intValue());
    assertEquals(PublicEnum.NATHANIEL.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.NATHANIEL).intValue());
    assertEquals(PublicEnum.EMMA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.EMMA).intValue());
    assertEquals(PublicEnum.PAULA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PAULA).intValue());
    assertTrue(Arrays.equals(PublicEnum.values(),serializer.getValues()));
    byte[] serializedSerializer=InstantiationUtil.serializeObject(serializer);
    serializer=InstantiationUtil.deserializeObject(serializedSerializer,Thread.currentThread().getContextClassLoader());
    assertEquals(PublicEnum.FOO.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.FOO).intValue());
    assertEquals(PublicEnum.BAR.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.BAR).intValue());
    assertEquals(PublicEnum.PETER.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PETER).intValue());
    assertEquals(PublicEnum.NATHANIEL.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.NATHANIEL).intValue());
    assertEquals(PublicEnum.EMMA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.EMMA).intValue());
    assertEquals(PublicEnum.PAULA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PAULA).intValue());
    assertTrue(Arrays.equals(PublicEnum.values(),serializer.getValues()));
  }
  @Test public void testSerializeReconfiguredEnumSerializer() throws Exception {
    PublicEnum[] mockPreviousOrder={PublicEnum.BAR,PublicEnum.PAULA,PublicEnum.NATHANIEL};
    EnumSerializer<PublicEnum> serializer=new EnumSerializer<>(PublicEnum.class);
    assertEquals(PublicEnum.FOO.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.FOO).intValue());
    assertEquals(PublicEnum.BAR.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.BAR).intValue());
    assertEquals(PublicEnum.PETER.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PETER).intValue());
    assertEquals(PublicEnum.NATHANIEL.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.NATHANIEL).intValue());
    assertEquals(PublicEnum.EMMA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.EMMA).intValue());
    assertEquals(PublicEnum.PAULA.ordinal(),serializer.getValueToOrdinal().get(PublicEnum.PAULA).intValue());
    CompatibilityResult<PublicEnum> compatResult=serializer.ensureCompatibility(new EnumSerializer.EnumSerializerConfigSnapshot<>(PublicEnum.class,mockPreviousOrder));
    assertFalse(compatResult.isRequiresMigration());
    byte[] serializedSerializer=InstantiationUtil.serializeObject(serializer);
    serializer=InstantiationUtil.deserializeObject(serializedSerializer,Thread.currentThread().getContextClassLoader());
    PublicEnum[] expectedOrder={PublicEnum.BAR,PublicEnum.PAULA,PublicEnum.NATHANIEL,PublicEnum.FOO,PublicEnum.PETER,PublicEnum.EMMA};
    int i=0;
    for (    PublicEnum constant : expectedOrder) {
      assertEquals(i,serializer.getValueToOrdinal().get(constant).intValue());
      i++;
    }
    assertTrue(Arrays.equals(expectedOrder,serializer.getValues()));
  }
  @SafeVarargs public final <T extends Enum<T>>void testEnumSerializer(  T... data){
    @SuppressWarnings("unchecked") final Class<T> clazz=(Class<T>)data.getClass().getComponentType();
    SerializerTestInstance<T> tester=new SerializerTestInstance<>(new EnumSerializer<T>(clazz),clazz,4,data);
    tester.testAll();
  }
  public enum PublicEnum {  FOO,   BAR,   PETER,   NATHANIEL,   EMMA,   PAULA}
  public enum EmptyEnum {}
  private enum PrivateEnum {  ONE,   TWO,   THREE}
}
