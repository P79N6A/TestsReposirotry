/** 
 * Tests for  {@link KvStateSerializer}.
 */
@RunWith(Parameterized.class) public class KvStateRequestSerializerTest {
  @Parameterized.Parameters public static Collection<Boolean> parameters(){
    return Arrays.asList(false,true);
  }
  @Parameterized.Parameter public boolean async;
  /** 
 * Tests key and namespace serialization utils.
 */
  @Test public void testKeyAndNamespaceSerialization() throws Exception {
    TypeSerializer<Long> keySerializer=LongSerializer.INSTANCE;
    TypeSerializer<String> namespaceSerializer=StringSerializer.INSTANCE;
    long expectedKey=Integer.MAX_VALUE + 12323L;
    String expectedNamespace="knilf";
    byte[] serializedKeyAndNamespace=KvStateSerializer.serializeKeyAndNamespace(expectedKey,keySerializer,expectedNamespace,namespaceSerializer);
    Tuple2<Long,String> actual=KvStateSerializer.deserializeKeyAndNamespace(serializedKeyAndNamespace,keySerializer,namespaceSerializer);
    assertEquals(expectedKey,actual.f0.longValue());
    assertEquals(expectedNamespace,actual.f1);
  }
  /** 
 * Tests key and namespace deserialization utils with too few bytes.
 */
  @Test(expected=IOException.class) public void testKeyAndNamespaceDeserializationEmpty() throws Exception {
    KvStateSerializer.deserializeKeyAndNamespace(new byte[]{},LongSerializer.INSTANCE,StringSerializer.INSTANCE);
  }
  /** 
 * Tests key and namespace deserialization utils with too few bytes.
 */
  @Test(expected=IOException.class) public void testKeyAndNamespaceDeserializationTooShort() throws Exception {
    KvStateSerializer.deserializeKeyAndNamespace(new byte[]{1},LongSerializer.INSTANCE,StringSerializer.INSTANCE);
  }
  /** 
 * Tests key and namespace deserialization utils with too many bytes.
 */
  @Test(expected=IOException.class) public void testKeyAndNamespaceDeserializationTooMany1() throws Exception {
    KvStateSerializer.deserializeKeyAndNamespace(new byte[]{1,1,1,1,1,1,1,1,42,0,2},LongSerializer.INSTANCE,StringSerializer.INSTANCE);
  }
  /** 
 * Tests key and namespace deserialization utils with too many bytes.
 */
  @Test(expected=IOException.class) public void testKeyAndNamespaceDeserializationTooMany2() throws Exception {
    KvStateSerializer.deserializeKeyAndNamespace(new byte[]{1,1,1,1,1,1,1,1,42,0,2,2},LongSerializer.INSTANCE,StringSerializer.INSTANCE);
  }
  /** 
 * Tests value serialization utils.
 */
  @Test public void testValueSerialization() throws Exception {
    TypeSerializer<Long> valueSerializer=LongSerializer.INSTANCE;
    long expectedValue=Long.MAX_VALUE - 1292929292L;
    byte[] serializedValue=KvStateSerializer.serializeValue(expectedValue,valueSerializer);
    long actualValue=KvStateSerializer.deserializeValue(serializedValue,valueSerializer);
    assertEquals(expectedValue,actualValue);
  }
  /** 
 * Tests value deserialization with too few bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeValueEmpty() throws Exception {
    KvStateSerializer.deserializeValue(new byte[]{},LongSerializer.INSTANCE);
  }
  /** 
 * Tests value deserialization with too few bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeValueTooShort() throws Exception {
    KvStateSerializer.deserializeValue(new byte[]{1},LongSerializer.INSTANCE);
  }
  /** 
 * Tests value deserialization with too many bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeValueTooMany1() throws Exception {
    KvStateSerializer.deserializeValue(new byte[]{1,1,1,1,1,1,1,1,2},LongSerializer.INSTANCE);
  }
  /** 
 * Tests value deserialization with too many bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeValueTooMany2() throws Exception {
    KvStateSerializer.deserializeValue(new byte[]{1,1,1,1,1,1,1,1,2,2},LongSerializer.INSTANCE);
  }
  /** 
 * Tests list serialization utils.
 */
  @Test public void testListSerialization() throws Exception {
    final long key=0L;
    final KeyGroupRange keyGroupRange=new KeyGroupRange(0,0);
    final HeapKeyedStateBackend<Long> longHeapKeyedStateBackend=new HeapKeyedStateBackend<>(mock(TaskKvStateRegistry.class),LongSerializer.INSTANCE,ClassLoader.getSystemClassLoader(),keyGroupRange.getNumberOfKeyGroups(),keyGroupRange,async,new ExecutionConfig(),TestLocalRecoveryConfig.disabled(),new HeapPriorityQueueSetFactory(keyGroupRange,keyGroupRange.getNumberOfKeyGroups(),128),TtlTimeProvider.DEFAULT);
    longHeapKeyedStateBackend.setCurrentKey(key);
    final InternalListState<Long,VoidNamespace,Long> listState=longHeapKeyedStateBackend.createInternalState(VoidNamespaceSerializer.INSTANCE,new ListStateDescriptor<>("test",LongSerializer.INSTANCE));
    testListSerialization(key,listState);
  }
  /** 
 * Verifies that the serialization of a list using the given list state matches the deserialization with  {@link KvStateSerializer#deserializeList}.
 * @param key key of the list state
 * @param listState list state using the  {@link VoidNamespace}, must also be a  {@link InternalKvState} instance
 * @throws Exception
 */
  public static void testListSerialization(  final long key,  final InternalListState<Long,VoidNamespace,Long> listState) throws Exception {
    TypeSerializer<Long> valueSerializer=LongSerializer.INSTANCE;
    listState.setCurrentNamespace(VoidNamespace.INSTANCE);
    final int numElements=10;
    final List<Long> expectedValues=new ArrayList<>();
    for (int i=0; i < numElements; i++) {
      final long value=ThreadLocalRandom.current().nextLong();
      expectedValues.add(value);
      listState.add(value);
    }
    final byte[] serializedKey=KvStateSerializer.serializeKeyAndNamespace(key,LongSerializer.INSTANCE,VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE);
    final byte[] serializedValues=listState.getSerializedValue(serializedKey,listState.getKeySerializer(),listState.getNamespaceSerializer(),listState.getValueSerializer());
    List<Long> actualValues=KvStateSerializer.deserializeList(serializedValues,valueSerializer);
    assertEquals(expectedValues,actualValues);
    long expectedValue=ThreadLocalRandom.current().nextLong();
    byte[] serializedValue=KvStateSerializer.serializeValue(expectedValue,valueSerializer);
    List<Long> actualValue=KvStateSerializer.deserializeList(serializedValue,valueSerializer);
    assertEquals(1,actualValue.size());
    assertEquals(expectedValue,actualValue.get(0).longValue());
  }
  /** 
 * Tests list deserialization with too few bytes.
 */
  @Test public void testDeserializeListEmpty() throws Exception {
    List<Long> actualValue=KvStateSerializer.deserializeList(new byte[]{},LongSerializer.INSTANCE);
    assertEquals(0,actualValue.size());
  }
  /** 
 * Tests list deserialization with too few bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeListTooShort1() throws Exception {
    KvStateSerializer.deserializeList(new byte[]{1},LongSerializer.INSTANCE);
  }
  /** 
 * Tests list deserialization with too few bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeListTooShort2() throws Exception {
    KvStateSerializer.deserializeList(new byte[]{1,1,1,1,1,1,1,1,2,3},LongSerializer.INSTANCE);
  }
  /** 
 * Tests map serialization utils.
 */
  @Test public void testMapSerialization() throws Exception {
    final long key=0L;
    final KeyGroupRange keyGroupRange=new KeyGroupRange(0,0);
    final HeapKeyedStateBackend<Long> longHeapKeyedStateBackend=new HeapKeyedStateBackend<>(mock(TaskKvStateRegistry.class),LongSerializer.INSTANCE,ClassLoader.getSystemClassLoader(),keyGroupRange.getNumberOfKeyGroups(),keyGroupRange,async,new ExecutionConfig(),TestLocalRecoveryConfig.disabled(),new HeapPriorityQueueSetFactory(keyGroupRange,keyGroupRange.getNumberOfKeyGroups(),128),TtlTimeProvider.DEFAULT);
    longHeapKeyedStateBackend.setCurrentKey(key);
    final InternalMapState<Long,VoidNamespace,Long,String> mapState=(InternalMapState<Long,VoidNamespace,Long,String>)longHeapKeyedStateBackend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,new MapStateDescriptor<>("test",LongSerializer.INSTANCE,StringSerializer.INSTANCE));
    testMapSerialization(key,mapState);
  }
  /** 
 * Verifies that the serialization of a map using the given map state matches the deserialization with  {@link KvStateSerializer#deserializeList}.
 * @param key key of the map state
 * @param mapState map state using the  {@link VoidNamespace}, must also be a  {@link InternalKvState} instance
 * @throws Exception
 */
  public static void testMapSerialization(  final long key,  final InternalMapState<Long,VoidNamespace,Long,String> mapState) throws Exception {
    TypeSerializer<Long> userKeySerializer=LongSerializer.INSTANCE;
    TypeSerializer<String> userValueSerializer=StringSerializer.INSTANCE;
    mapState.setCurrentNamespace(VoidNamespace.INSTANCE);
    final int numElements=10;
    final Map<Long,String> expectedValues=new HashMap<>();
    for (int i=1; i <= numElements; i++) {
      final long value=ThreadLocalRandom.current().nextLong();
      expectedValues.put(value,Long.toString(value));
      mapState.put(value,Long.toString(value));
    }
    expectedValues.put(0L,null);
    mapState.put(0L,null);
    final byte[] serializedKey=KvStateSerializer.serializeKeyAndNamespace(key,LongSerializer.INSTANCE,VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE);
    final byte[] serializedValues=mapState.getSerializedValue(serializedKey,mapState.getKeySerializer(),mapState.getNamespaceSerializer(),mapState.getValueSerializer());
    Map<Long,String> actualValues=KvStateSerializer.deserializeMap(serializedValues,userKeySerializer,userValueSerializer);
    assertEquals(expectedValues.size(),actualValues.size());
    for (    Map.Entry<Long,String> actualEntry : actualValues.entrySet()) {
      assertEquals(expectedValues.get(actualEntry.getKey()),actualEntry.getValue());
    }
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    long expectedKey=ThreadLocalRandom.current().nextLong();
    String expectedValue=Long.toString(expectedKey);
    byte[] isNull={0};
    baos.write(KvStateSerializer.serializeValue(expectedKey,userKeySerializer));
    baos.write(isNull);
    baos.write(KvStateSerializer.serializeValue(expectedValue,userValueSerializer));
    byte[] serializedValue=baos.toByteArray();
    Map<Long,String> actualValue=KvStateSerializer.deserializeMap(serializedValue,userKeySerializer,userValueSerializer);
    assertEquals(1,actualValue.size());
    assertEquals(expectedValue,actualValue.get(expectedKey));
  }
  /** 
 * Tests map deserialization with too few bytes.
 */
  @Test public void testDeserializeMapEmpty() throws Exception {
    Map<Long,String> actualValue=KvStateSerializer.deserializeMap(new byte[]{},LongSerializer.INSTANCE,StringSerializer.INSTANCE);
    assertEquals(0,actualValue.size());
  }
  /** 
 * Tests map deserialization with too few bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeMapTooShort1() throws Exception {
    KvStateSerializer.deserializeMap(new byte[]{1},LongSerializer.INSTANCE,StringSerializer.INSTANCE);
  }
  /** 
 * Tests map deserialization with too few bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeMapTooShort2() throws Exception {
    KvStateSerializer.deserializeMap(new byte[]{1,1,1,1,1,1,1,1,0},LongSerializer.INSTANCE,LongSerializer.INSTANCE);
  }
  /** 
 * Tests map deserialization with too few bytes.
 */
  @Test(expected=IOException.class) public void testDeserializeMapTooShort3() throws Exception {
    KvStateSerializer.deserializeMap(new byte[]{1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,3},LongSerializer.INSTANCE,LongSerializer.INSTANCE);
  }
  private byte[] randomByteArray(  int capacity){
    byte[] bytes=new byte[capacity];
    ThreadLocalRandom.current().nextBytes(bytes);
    return bytes;
  }
}
