/** 
 * Tests for the Task, which make sure that correct state transitions happen, and failures are correctly handled. <p>All tests here have a set of mock actors for TaskManager, JobManager, and execution listener, which simply put the messages in a queue to be picked up by the test and validated.
 */
public class TaskTest extends TestLogger {
  private static OneShotLatch awaitLatch;
  private static OneShotLatch triggerLatch;
  private static OneShotLatch cancelLatch;
  private ActorGateway taskManagerGateway;
  private ActorGateway jobManagerGateway;
  private ActorGateway listenerGateway;
  private ActorGatewayTaskExecutionStateListener listener;
  private ActorGatewayTaskManagerActions taskManagerConnection;
  private BlockingQueue<Object> taskManagerMessages;
  private BlockingQueue<Object> jobManagerMessages;
  private BlockingQueue<Object> listenerMessages;
  @Before public void createQueuesAndActors(){
    taskManagerMessages=new LinkedBlockingQueue<>();
    jobManagerMessages=new LinkedBlockingQueue<>();
    listenerMessages=new LinkedBlockingQueue<>();
    taskManagerGateway=new ForwardingActorGateway(taskManagerMessages);
    jobManagerGateway=new ForwardingActorGateway(jobManagerMessages);
    listenerGateway=new ForwardingActorGateway(listenerMessages);
    listener=new ActorGatewayTaskExecutionStateListener(listenerGateway);
    taskManagerConnection=new ActorGatewayTaskManagerActions(taskManagerGateway);
    awaitLatch=new OneShotLatch();
    triggerLatch=new OneShotLatch();
    cancelLatch=new OneShotLatch();
  }
  @After public void clearActorsAndMessages(){
    jobManagerMessages=null;
    taskManagerMessages=null;
    listenerMessages=null;
    taskManagerGateway=null;
    jobManagerGateway=null;
    listenerGateway=null;
  }
  @Test public void testRegularExecution(){
    try {
      Task task=createTask(TestInvokableCorrect.class);
      assertEquals(ExecutionState.CREATED,task.getExecutionState());
      assertFalse(task.isCanceledOrFailed());
      assertNull(task.getFailureCause());
      task.registerExecutionListener(listener);
      task.run();
      assertEquals(ExecutionState.FINISHED,task.getExecutionState());
      assertFalse(task.isCanceledOrFailed());
      assertNull(task.getFailureCause());
      assertNull(task.getInvokable());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateListenerMessage(ExecutionState.FINISHED,task,false);
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelRightAway(){
    try {
      Task task=createTask(TestInvokableCorrect.class);
      task.cancelExecution();
      assertEquals(ExecutionState.CANCELING,task.getExecutionState());
      task.run();
      assertEquals(ExecutionState.CANCELED,task.getExecutionState());
      validateUnregisterTask(task.getExecutionId());
      assertNull(task.getInvokable());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testFailExternallyRightAway(){
    try {
      Task task=createTask(TestInvokableCorrect.class);
      task.failExternally(new Exception("fail externally"));
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      task.run();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      validateUnregisterTask(task.getExecutionId());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testLibraryCacheRegistrationFailed(){
    try {
      BlobCacheService blobService=createBlobCache();
      Task task=createTask(TestInvokableCorrect.class,blobService,mock(LibraryCacheManager.class));
      assertEquals(ExecutionState.CREATED,task.getExecutionState());
      assertFalse(task.isCanceledOrFailed());
      assertNull(task.getFailureCause());
      task.registerExecutionListener(listener);
      task.run();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertNotNull(task.getFailureCause());
      assertNotNull(task.getFailureCause().getMessage());
      assertTrue(task.getFailureCause().getMessage().contains("classloader"));
      validateListenerMessage(ExecutionState.FAILED,task,true);
      validateUnregisterTask(task.getExecutionId());
      assertNull(task.getInvokable());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testExecutionFailsInNetworkRegistration(){
    try {
      BlobCacheService blobService=createBlobCache();
      LibraryCacheManager libCache=mock(LibraryCacheManager.class);
      when(libCache.getClassLoader(any(JobID.class))).thenReturn(getClass().getClassLoader());
      ResultPartitionManager partitionManager=mock(ResultPartitionManager.class);
      ResultPartitionConsumableNotifier consumableNotifier=new NoOpResultPartitionConsumableNotifier();
      PartitionProducerStateChecker partitionProducerStateChecker=mock(PartitionProducerStateChecker.class);
      TaskEventDispatcher taskEventDispatcher=mock(TaskEventDispatcher.class);
      Executor executor=mock(Executor.class);
      NetworkEnvironment network=mock(NetworkEnvironment.class);
      when(network.getResultPartitionManager()).thenReturn(partitionManager);
      when(network.getDefaultIOMode()).thenReturn(IOManager.IOMode.SYNC);
      when(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
      doThrow(new RuntimeException("buffers")).when(network).registerTask(any(Task.class));
      Task task=createTask(TestInvokableCorrect.class,blobService,libCache,network,consumableNotifier,partitionProducerStateChecker,executor);
      task.registerExecutionListener(listener);
      task.run();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertTrue(task.getFailureCause().getMessage().contains("buffers"));
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.FAILED,task,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testInvokableInstantiationFailed(){
    try {
      Task task=createTask(InvokableNonInstantiable.class);
      task.registerExecutionListener(listener);
      task.run();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertTrue(task.getFailureCause().getMessage().contains("instantiate"));
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.FAILED,task,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testExecutionFailsInInvoke(){
    try {
      Task task=createTask(InvokableWithExceptionInInvoke.class);
      task.registerExecutionListener(listener);
      task.run();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertNotNull(task.getFailureCause());
      assertNotNull(task.getFailureCause().getMessage());
      assertTrue(task.getFailureCause().getMessage().contains("test"));
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateListenerMessage(ExecutionState.FAILED,task,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testFailWithWrappedException(){
    try {
      Task task=createTask(FailingInvokableWithChainedException.class);
      task.registerExecutionListener(listener);
      task.run();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      Throwable cause=task.getFailureCause();
      assertTrue(cause instanceof IOException);
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateListenerMessage(ExecutionState.FAILED,task,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelDuringInvoke(){
    try {
      Task task=createTask(InvokableBlockingInInvoke.class);
      task.registerExecutionListener(listener);
      task.startTaskThread();
      awaitLatch.await();
      task.cancelExecution();
      assertTrue(task.getExecutionState() == ExecutionState.CANCELING || task.getExecutionState() == ExecutionState.CANCELED);
      task.getExecutingThread().join();
      assertEquals(ExecutionState.CANCELED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertNull(task.getFailureCause());
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateCancelingAndCanceledListenerMessage(task);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testFailExternallyDuringInvoke(){
    try {
      Task task=createTask(InvokableBlockingInInvoke.class);
      task.registerExecutionListener(listener);
      task.startTaskThread();
      awaitLatch.await();
      task.failExternally(new Exception("test"));
      assertTrue(task.getExecutionState() == ExecutionState.FAILED);
      task.getExecutingThread().join();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertTrue(task.getFailureCause().getMessage().contains("test"));
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateListenerMessage(ExecutionState.FAILED,task,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCanceledAfterExecutionFailedInInvoke(){
    try {
      Task task=createTask(InvokableWithExceptionInInvoke.class);
      task.registerExecutionListener(listener);
      task.run();
      task.cancelExecution();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertTrue(task.getFailureCause().getMessage().contains("test"));
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateListenerMessage(ExecutionState.FAILED,task,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testExecutionFailesAfterCanceling(){
    try {
      Task task=createTask(InvokableWithExceptionOnTrigger.class);
      task.registerExecutionListener(listener);
      task.startTaskThread();
      awaitLatch.await();
      task.cancelExecution();
      assertEquals(ExecutionState.CANCELING,task.getExecutionState());
      triggerLatch.trigger();
      task.getExecutingThread().join();
      assertEquals(ExecutionState.CANCELED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertNull(task.getFailureCause());
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateCancelingAndCanceledListenerMessage(task);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testExecutionFailsAfterTaskMarkedFailed(){
    try {
      Task task=createTask(InvokableWithExceptionOnTrigger.class);
      task.registerExecutionListener(listener);
      task.startTaskThread();
      awaitLatch.await();
      task.failExternally(new Exception("external"));
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      triggerLatch.trigger();
      task.getExecutingThread().join();
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
      assertTrue(task.isCanceledOrFailed());
      assertTrue(task.getFailureCause().getMessage().contains("external"));
      validateTaskManagerStateChange(ExecutionState.RUNNING,task,false);
      validateUnregisterTask(task.getExecutionId());
      validateListenerMessage(ExecutionState.RUNNING,task,false);
      validateListenerMessage(ExecutionState.FAILED,task,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCancelTaskException() throws Exception {
    final Task task=createTask(InvokableWithCancelTaskExceptionInInvoke.class);
    triggerLatch.trigger();
    task.run();
    assertEquals(ExecutionState.CANCELED,task.getExecutionState());
  }
  @Test public void testCancelTaskExceptionAfterTaskMarkedFailed() throws Exception {
    final Task task=createTask(InvokableWithCancelTaskExceptionInInvoke.class);
    task.startTaskThread();
    awaitLatch.await();
    task.failExternally(new Exception("external"));
    assertEquals(ExecutionState.FAILED,task.getExecutionState());
    triggerLatch.trigger();
    task.getExecutingThread().join();
    assertEquals(ExecutionState.FAILED,task.getExecutionState());
    assertTrue(task.isCanceledOrFailed());
    assertTrue(task.getFailureCause().getMessage().contains("external"));
  }
  @Test public void testOnPartitionStateUpdate() throws Exception {
    IntermediateDataSetID resultId=new IntermediateDataSetID();
    ResultPartitionID partitionId=new ResultPartitionID();
    SingleInputGate inputGate=mock(SingleInputGate.class);
    when(inputGate.getConsumedResultId()).thenReturn(resultId);
    final Task task=createTask(InvokableBlockingInInvoke.class);
    setInputGate(task,inputGate);
    final Map<ExecutionState,ExecutionState> expected=new HashMap<>(ExecutionState.values().length);
    for (    ExecutionState state : ExecutionState.values()) {
      expected.put(state,ExecutionState.FAILED);
    }
    expected.put(ExecutionState.RUNNING,ExecutionState.RUNNING);
    expected.put(ExecutionState.SCHEDULED,ExecutionState.RUNNING);
    expected.put(ExecutionState.DEPLOYING,ExecutionState.RUNNING);
    expected.put(ExecutionState.FINISHED,ExecutionState.RUNNING);
    expected.put(ExecutionState.CANCELED,ExecutionState.CANCELING);
    expected.put(ExecutionState.CANCELING,ExecutionState.CANCELING);
    expected.put(ExecutionState.FAILED,ExecutionState.CANCELING);
    for (    ExecutionState state : ExecutionState.values()) {
      setState(task,ExecutionState.RUNNING);
      task.onPartitionStateUpdate(resultId,partitionId,state);
      ExecutionState newTaskState=task.getExecutionState();
      assertEquals(expected.get(state),newTaskState);
    }
    verify(inputGate,times(4)).retriggerPartitionRequest(eq(partitionId.getPartitionId()));
  }
  /** 
 * Tests the trigger partition state update future completions.
 */
  @Test public void testTriggerPartitionStateUpdate() throws Exception {
    IntermediateDataSetID resultId=new IntermediateDataSetID();
    ResultPartitionID partitionId=new ResultPartitionID();
    BlobCacheService blobService=createBlobCache();
    LibraryCacheManager libCache=mock(LibraryCacheManager.class);
    when(libCache.getClassLoader(any(JobID.class))).thenReturn(getClass().getClassLoader());
    PartitionProducerStateChecker partitionChecker=mock(PartitionProducerStateChecker.class);
    TaskEventDispatcher taskEventDispatcher=mock(TaskEventDispatcher.class);
    ResultPartitionConsumableNotifier consumableNotifier=new NoOpResultPartitionConsumableNotifier();
    NetworkEnvironment network=mock(NetworkEnvironment.class);
    when(network.getResultPartitionManager()).thenReturn(mock(ResultPartitionManager.class));
    when(network.getDefaultIOMode()).thenReturn(IOManager.IOMode.SYNC);
    when(network.createKvStateTaskRegistry(any(JobID.class),any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class));
    when(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
    createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
{
      createQueuesAndActors();
      Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
      CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
      when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
      task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
      promise.completeExceptionally(new PartitionProducerDisposedException(partitionId));
      assertEquals(ExecutionState.CANCELING,task.getExecutionState());
    }
{
      createQueuesAndActors();
      Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
      CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
      when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
      task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
      promise.completeExceptionally(new RuntimeException("Any other exception"));
      assertEquals(ExecutionState.FAILED,task.getExecutionState());
    }
{
      createQueuesAndActors();
      Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
      SingleInputGate inputGate=mock(SingleInputGate.class);
      when(inputGate.getConsumedResultId()).thenReturn(resultId);
      try {
        task.startTaskThread();
        awaitLatch.await();
        setInputGate(task,inputGate);
        CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
        when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
        task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
        promise.completeExceptionally(new TimeoutException());
        assertEquals(ExecutionState.RUNNING,task.getExecutionState());
        verify(inputGate,times(1)).retriggerPartitionRequest(eq(partitionId.getPartitionId()));
      }
  finally {
        task.getExecutingThread().interrupt();
        task.getExecutingThread().join();
      }
    }
{
      createQueuesAndActors();
      Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
      SingleInputGate inputGate=mock(SingleInputGate.class);
      when(inputGate.getConsumedResultId()).thenReturn(resultId);
      try {
        task.startTaskThread();
        awaitLatch.await();
        setInputGate(task,inputGate);
        CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
        when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
        task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
        promise.complete(ExecutionState.RUNNING);
        assertEquals(ExecutionState.RUNNING,task.getExecutionState());
        verify(inputGate,times(1)).retriggerPartitionRequest(eq(partitionId.getPartitionId()));
      }
  finally {
        task.getExecutingThread().interrupt();
        task.getExecutingThread().join();
      }
    }
  }
  /** 
 * Tests that interrupt happens via watch dog if canceller is stuck in cancel. Task cancellation blocks the task canceller. Interrupt after cancel via cancellation watch dog.
 */
  @Test public void testWatchDogInterruptsTask() throws Exception {
    Configuration config=new Configuration();
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_INTERVAL.key(),5);
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_TIMEOUT.key(),60 * 1000);
    Task task=createTask(InvokableBlockingInCancel.class,config);
    task.startTaskThread();
    awaitLatch.await();
    task.cancelExecution();
    task.getExecutingThread().join();
    for (    Object msg : taskManagerMessages) {
      assertFalse("Unexpected FatalError message",msg instanceof TaskManagerMessages.FatalError);
    }
  }
  /** 
 * The invoke() method holds a lock (trigger awaitLatch after acquisition) and cancel cannot complete because it also tries to acquire the same lock. This is resolved by the watch dog, no fatal error.
 */
  @Test public void testInterruptableSharedLockInInvokeAndCancel() throws Exception {
    Configuration config=new Configuration();
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_INTERVAL,5);
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_TIMEOUT,50);
    Task task=createTask(InvokableInterruptableSharedLockInInvokeAndCancel.class,config);
    task.startTaskThread();
    awaitLatch.await();
    task.cancelExecution();
    task.getExecutingThread().join();
    for (    Object msg : taskManagerMessages) {
      assertFalse("Unexpected FatalError message",msg instanceof TaskManagerMessages.FatalError);
    }
  }
  /** 
 * The invoke() method blocks infinitely, but cancel() does not block. Only resolved by a fatal error.
 */
  @Test public void testFatalErrorAfterUninterruptibleInvoke() throws Exception {
    Configuration config=new Configuration();
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_INTERVAL,5);
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_TIMEOUT,50);
    Task task=createTask(InvokableUninterruptibleBlockingInvoke.class,config);
    try {
      task.startTaskThread();
      awaitLatch.await();
      task.cancelExecution();
      for (int i=0; i < 10; i++) {
        Object msg=taskManagerMessages.poll(1,TimeUnit.SECONDS);
        if (msg instanceof TaskManagerMessages.FatalError) {
          return;
        }
      }
      fail("Did not receive expected task manager message");
    }
  finally {
      cancelLatch.trigger();
      task.getExecutingThread().interrupt();
      task.getExecutingThread().join();
    }
  }
  /** 
 * Tests that the task configuration is respected and overwritten by the execution config.
 */
  @Test public void testTaskConfig() throws Exception {
    long interval=28218123;
    long timeout=interval + 19292;
    Configuration config=new Configuration();
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_INTERVAL,interval);
    config.setLong(TaskManagerOptions.TASK_CANCELLATION_TIMEOUT,timeout);
    ExecutionConfig executionConfig=new ExecutionConfig();
    executionConfig.setTaskCancellationInterval(interval + 1337);
    executionConfig.setTaskCancellationTimeout(timeout - 1337);
    Task task=createTask(InvokableBlockingInInvoke.class,config,executionConfig);
    assertEquals(interval,task.getTaskCancellationInterval());
    assertEquals(timeout,task.getTaskCancellationTimeout());
    task.startTaskThread();
    awaitLatch.await();
    assertEquals(executionConfig.getTaskCancellationInterval(),task.getTaskCancellationInterval());
    assertEquals(executionConfig.getTaskCancellationTimeout(),task.getTaskCancellationTimeout());
    task.getExecutingThread().interrupt();
    task.getExecutingThread().join();
  }
  private void setInputGate(  Task task,  SingleInputGate inputGate){
    try {
      Field f=Task.class.getDeclaredField("inputGates");
      f.setAccessible(true);
      f.set(task,new SingleInputGate[]{inputGate});
      Map<IntermediateDataSetID,SingleInputGate> byId=new HashMap<>(1);
      byId.put(inputGate.getConsumedResultId(),inputGate);
      f=Task.class.getDeclaredField("inputGatesById");
      f.setAccessible(true);
      f.set(task,byId);
    }
 catch (    Exception e) {
      throw new RuntimeException("Modifying the task state failed",e);
    }
  }
  private void setState(  Task task,  ExecutionState state){
    try {
      Field f=Task.class.getDeclaredField("executionState");
      f.setAccessible(true);
      f.set(task,state);
    }
 catch (    Exception e) {
      throw new RuntimeException("Modifying the task state failed",e);
    }
  }
  /** 
 * Creates a  {@link BlobCacheService} mock that is suitable to be used in the tests above.
 * @return BlobCache mock with the bare minimum of implemented functions that work
 */
  private BlobCacheService createBlobCache(){
    return new BlobCacheService(mock(PermanentBlobCache.class),mock(TransientBlobCache.class));
  }
  private Task createTask(  Class<? extends AbstractInvokable> invokable) throws IOException {
    return createTask(invokable,new Configuration(),new ExecutionConfig());
  }
  private Task createTask(  Class<? extends AbstractInvokable> invokable,  Configuration config) throws IOException {
    BlobCacheService blobService=createBlobCache();
    LibraryCacheManager libCache=mock(LibraryCacheManager.class);
    when(libCache.getClassLoader(any(JobID.class))).thenReturn(getClass().getClassLoader());
    return createTask(invokable,blobService,libCache,config,new ExecutionConfig());
  }
  private Task createTask(  Class<? extends AbstractInvokable> invokable,  Configuration config,  ExecutionConfig execConfig) throws IOException {
    BlobCacheService blobService=createBlobCache();
    LibraryCacheManager libCache=mock(LibraryCacheManager.class);
    when(libCache.getClassLoader(any(JobID.class))).thenReturn(getClass().getClassLoader());
    return createTask(invokable,blobService,libCache,config,execConfig);
  }
  private Task createTask(  Class<? extends AbstractInvokable> invokable,  BlobCacheService blobService,  LibraryCacheManager libCache) throws IOException {
    return createTask(invokable,blobService,libCache,new Configuration(),new ExecutionConfig());
  }
  private Task createTask(  Class<? extends AbstractInvokable> invokable,  BlobCacheService blobService,  LibraryCacheManager libCache,  Configuration config,  ExecutionConfig execConfig) throws IOException {
    ResultPartitionManager partitionManager=mock(ResultPartitionManager.class);
    ResultPartitionConsumableNotifier consumableNotifier=new NoOpResultPartitionConsumableNotifier();
    PartitionProducerStateChecker partitionProducerStateChecker=mock(PartitionProducerStateChecker.class);
    TaskEventDispatcher taskEventDispatcher=mock(TaskEventDispatcher.class);
    Executor executor=mock(Executor.class);
    NetworkEnvironment network=mock(NetworkEnvironment.class);
    when(network.getResultPartitionManager()).thenReturn(partitionManager);
    when(network.getDefaultIOMode()).thenReturn(IOManager.IOMode.SYNC);
    when(network.createKvStateTaskRegistry(any(JobID.class),any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class));
    when(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
    return createTask(invokable,blobService,libCache,network,consumableNotifier,partitionProducerStateChecker,executor,config,execConfig);
  }
  private Task createTask(  Class<? extends AbstractInvokable> invokable,  BlobCacheService blobService,  LibraryCacheManager libCache,  NetworkEnvironment networkEnvironment,  ResultPartitionConsumableNotifier consumableNotifier,  PartitionProducerStateChecker partitionProducerStateChecker,  Executor executor) throws IOException {
    return createTask(invokable,blobService,libCache,networkEnvironment,consumableNotifier,partitionProducerStateChecker,executor,new Configuration(),new ExecutionConfig());
  }
  private Task createTask(  Class<? extends AbstractInvokable> invokable,  BlobCacheService blobService,  LibraryCacheManager libCache,  NetworkEnvironment networkEnvironment,  ResultPartitionConsumableNotifier consumableNotifier,  PartitionProducerStateChecker partitionProducerStateChecker,  Executor executor,  Configuration taskManagerConfig,  ExecutionConfig execConfig) throws IOException {
    JobID jobId=new JobID();
    JobVertexID jobVertexId=new JobVertexID();
    ExecutionAttemptID executionAttemptId=new ExecutionAttemptID();
    InputSplitProvider inputSplitProvider=new TaskInputSplitProvider(jobManagerGateway,jobId,jobVertexId,executionAttemptId,new FiniteDuration(60,TimeUnit.SECONDS));
    CheckpointResponder checkpointResponder=new ActorGatewayCheckpointResponder(jobManagerGateway);
    SerializedValue<ExecutionConfig> serializedExecutionConfig=new SerializedValue<>(execConfig);
    JobInformation jobInformation=new JobInformation(jobId,"Test Job",serializedExecutionConfig,new Configuration(),Collections.emptyList(),Collections.emptyList());
    TaskInformation taskInformation=new TaskInformation(jobVertexId,"Test Task",1,1,invokable.getName(),new Configuration());
    TaskMetricGroup taskMetricGroup=mock(TaskMetricGroup.class);
    when(taskMetricGroup.getIOMetricGroup()).thenReturn(mock(TaskIOMetricGroup.class));
    return new Task(jobInformation,taskInformation,executionAttemptId,new AllocationID(),0,0,Collections.emptyList(),Collections.emptyList(),0,mock(MemoryManager.class),mock(IOManager.class),networkEnvironment,mock(BroadcastVariableManager.class),new TestTaskStateManager(),taskManagerConnection,inputSplitProvider,checkpointResponder,blobService,libCache,mock(FileCache.class),new TestingTaskManagerRuntimeInfo(taskManagerConfig),taskMetricGroup,consumableNotifier,partitionProducerStateChecker,executor);
  }
  private void validateUnregisterTask(  ExecutionAttemptID id){
    try {
      Object rawMessage=taskManagerMessages.take();
      assertNotNull("There is no additional TaskManager message",rawMessage);
      if (!(rawMessage instanceof TaskMessages.TaskInFinalState)) {
        fail("TaskManager message is not 'UnregisterTask', but " + rawMessage.getClass());
      }
      TaskMessages.TaskInFinalState message=(TaskMessages.TaskInFinalState)rawMessage;
      assertEquals(id,message.executionID());
    }
 catch (    InterruptedException e) {
      fail("interrupted");
    }
  }
  private void validateTaskManagerStateChange(  ExecutionState state,  Task task,  boolean hasError){
    try {
      Object rawMessage=taskManagerMessages.take();
      assertNotNull("There is no additional TaskManager message",rawMessage);
      if (!(rawMessage instanceof TaskMessages.UpdateTaskExecutionState)) {
        fail("TaskManager message is not 'UpdateTaskExecutionState', but " + rawMessage.getClass());
      }
      TaskMessages.UpdateTaskExecutionState message=(TaskMessages.UpdateTaskExecutionState)rawMessage;
      TaskExecutionState taskState=message.taskExecutionState();
      assertEquals(task.getJobID(),taskState.getJobID());
      assertEquals(task.getExecutionId(),taskState.getID());
      assertEquals(state,taskState.getExecutionState());
      if (hasError) {
        assertNotNull(taskState.getError(getClass().getClassLoader()));
      }
 else {
        assertNull(taskState.getError(getClass().getClassLoader()));
      }
    }
 catch (    InterruptedException e) {
      fail("interrupted");
    }
  }
  private void validateListenerMessage(  ExecutionState state,  Task task,  boolean hasError){
    try {
      TaskMessages.UpdateTaskExecutionState message=(TaskMessages.UpdateTaskExecutionState)listenerMessages.take();
      assertNotNull("There is no additional listener message",message);
      TaskExecutionState taskState=message.taskExecutionState();
      assertEquals(task.getJobID(),taskState.getJobID());
      assertEquals(task.getExecutionId(),taskState.getID());
      assertEquals(state,taskState.getExecutionState());
      if (hasError) {
        assertNotNull(taskState.getError(getClass().getClassLoader()));
      }
 else {
        assertNull(taskState.getError(getClass().getClassLoader()));
      }
    }
 catch (    InterruptedException e) {
      fail("interrupted");
    }
  }
  private void validateCancelingAndCanceledListenerMessage(  Task task){
    try {
      TaskMessages.UpdateTaskExecutionState message1=(TaskMessages.UpdateTaskExecutionState)listenerMessages.take();
      TaskMessages.UpdateTaskExecutionState message2=(TaskMessages.UpdateTaskExecutionState)listenerMessages.take();
      assertNotNull("There is no additional listener message",message1);
      assertNotNull("There is no additional listener message",message2);
      TaskExecutionState taskState1=message1.taskExecutionState();
      TaskExecutionState taskState2=message2.taskExecutionState();
      assertEquals(task.getJobID(),taskState1.getJobID());
      assertEquals(task.getJobID(),taskState2.getJobID());
      assertEquals(task.getExecutionId(),taskState1.getID());
      assertEquals(task.getExecutionId(),taskState2.getID());
      ExecutionState state1=taskState1.getExecutionState();
      ExecutionState state2=taskState2.getExecutionState();
      assertTrue((state1 == ExecutionState.CANCELING && state2 == ExecutionState.CANCELED) || (state2 == ExecutionState.CANCELING && state1 == ExecutionState.CANCELED));
    }
 catch (    InterruptedException e) {
      fail("interrupted");
    }
  }
  /** 
 * Test task class. 
 */
public static final class TestInvokableCorrect extends AbstractInvokable {
    public TestInvokableCorrect(    Environment environment){
      super(environment);
    }
    @Override public void invoke(){
    }
    @Override public void cancel() throws Exception {
      fail("This should not be called");
    }
  }
  /** 
 * Test task class. 
 */
public static final class InvokableWithExceptionInInvoke extends AbstractInvokable {
    public InvokableWithExceptionInInvoke(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      throw new Exception("test");
    }
  }
  /** 
 * Test task class. 
 */
public static final class InvokableWithExceptionOnTrigger extends AbstractInvokable {
    public InvokableWithExceptionOnTrigger(    Environment environment){
      super(environment);
    }
    @Override public void invoke(){
      awaitLatch.trigger();
      while (true) {
        try {
          triggerLatch.await();
          break;
        }
 catch (        InterruptedException e) {
        }
      }
      throw new RuntimeException("test");
    }
  }
  /** 
 * Test task class. 
 */
public abstract static class InvokableNonInstantiable extends AbstractInvokable {
    public InvokableNonInstantiable(    Environment environment){
      super(environment);
    }
  }
  /** 
 * Test task class. 
 */
public static final class InvokableBlockingInInvoke extends AbstractInvokable {
    public InvokableBlockingInInvoke(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      awaitLatch.trigger();
synchronized (this) {
        wait();
      }
    }
  }
  /** 
 * Test task class. 
 */
public static final class InvokableWithCancelTaskExceptionInInvoke extends AbstractInvokable {
    public InvokableWithCancelTaskExceptionInInvoke(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      awaitLatch.trigger();
      try {
        triggerLatch.await();
      }
 catch (      Throwable ignored) {
      }
      throw new CancelTaskException();
    }
  }
  /** 
 * Test task class. 
 */
public static final class InvokableInterruptableSharedLockInInvokeAndCancel extends AbstractInvokable {
    private final Object lock=new Object();
    public InvokableInterruptableSharedLockInInvokeAndCancel(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
synchronized (lock) {
        awaitLatch.trigger();
        wait();
      }
    }
    @Override public void cancel() throws Exception {
synchronized (lock) {
        cancelLatch.trigger();
      }
    }
  }
  /** 
 * Test task class. 
 */
public static final class InvokableBlockingInCancel extends AbstractInvokable {
    public InvokableBlockingInCancel(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      awaitLatch.trigger();
      try {
        cancelLatch.await();
synchronized (this) {
          wait();
        }
      }
 catch (      InterruptedException ignored) {
synchronized (this) {
          notifyAll();
        }
      }
    }
    @Override public void cancel() throws Exception {
synchronized (this) {
        cancelLatch.trigger();
        wait();
      }
    }
  }
  /** 
 * Test task class. 
 */
public static final class InvokableUninterruptibleBlockingInvoke extends AbstractInvokable {
    public InvokableUninterruptibleBlockingInvoke(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      while (!cancelLatch.isTriggered()) {
        try {
synchronized (this) {
            awaitLatch.trigger();
            wait();
          }
        }
 catch (        InterruptedException ignored) {
        }
      }
    }
    @Override public void cancel() throws Exception {
    }
  }
  /** 
 * Test task class. 
 */
public static final class FailingInvokableWithChainedException extends AbstractInvokable {
    public FailingInvokableWithChainedException(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      throw new TestWrappedException(new IOException("test"));
    }
    @Override public void cancel(){
    }
  }
private static class TestWrappedException extends WrappingRuntimeException {
    private static final long serialVersionUID=1L;
    public TestWrappedException(    @Nonnull Throwable cause){
      super(cause);
    }
  }
}
