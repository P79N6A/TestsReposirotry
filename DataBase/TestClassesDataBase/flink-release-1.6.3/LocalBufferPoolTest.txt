public class LocalBufferPoolTest extends TestLogger {
  private final static int numBuffers=1024;
  private final static int memorySegmentSize=128;
  private NetworkBufferPool networkBufferPool;
  private BufferPool localBufferPool;
  private final static ExecutorService executor=Executors.newCachedThreadPool();
  @Before public void setupLocalBufferPool(){
    networkBufferPool=new NetworkBufferPool(numBuffers,memorySegmentSize);
    localBufferPool=new LocalBufferPool(networkBufferPool,1);
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
  }
  @After public void destroyAndVerifyAllBuffersReturned() throws IOException {
    if (!localBufferPool.isDestroyed()) {
      localBufferPool.lazyDestroy();
    }
    String msg="Did not return all buffers to memory segment pool after test.";
    assertEquals(msg,numBuffers,networkBufferPool.getNumberOfAvailableMemorySegments());
    networkBufferPool.destroyAllBufferPools();
    networkBufferPool.destroy();
  }
  @AfterClass public static void shutdownExecutor(){
    executor.shutdownNow();
  }
  @Test public void testRequestMoreThanAvailable() throws IOException {
    localBufferPool.setNumBuffers(numBuffers);
    List<Buffer> requests=new ArrayList<Buffer>(numBuffers);
    for (int i=1; i <= numBuffers; i++) {
      Buffer buffer=localBufferPool.requestBuffer();
      assertEquals(i,getNumRequestedFromMemorySegmentPool());
      assertNotNull(buffer);
      requests.add(buffer);
    }
{
      Buffer buffer=localBufferPool.requestBuffer();
      assertEquals(numBuffers,getNumRequestedFromMemorySegmentPool());
      assertNull(buffer);
    }
    for (    Buffer buffer : requests) {
      buffer.recycleBuffer();
    }
  }
  @Test public void testRequestAfterDestroy() throws IOException {
    localBufferPool.lazyDestroy();
    try {
      localBufferPool.requestBuffer();
      fail("Call should have failed with an IllegalStateException");
    }
 catch (    IllegalStateException e) {
    }
  }
  @Test public void testRecycleAfterDestroy() throws IOException {
    localBufferPool.setNumBuffers(numBuffers);
    List<Buffer> requests=new ArrayList<Buffer>(numBuffers);
    for (int i=0; i < numBuffers; i++) {
      requests.add(localBufferPool.requestBuffer());
    }
    localBufferPool.lazyDestroy();
    assertEquals(numBuffers,getNumRequestedFromMemorySegmentPool());
    for (    Buffer buffer : requests) {
      buffer.recycleBuffer();
    }
  }
  @Test public void testRecycleExcessBuffersAfterRecycling() throws Exception {
    localBufferPool.setNumBuffers(numBuffers);
    List<Buffer> requests=new ArrayList<Buffer>(numBuffers);
    for (int i=1; i <= numBuffers; i++) {
      requests.add(localBufferPool.requestBuffer());
    }
    assertEquals(numBuffers,getNumRequestedFromMemorySegmentPool());
    localBufferPool.setNumBuffers(numBuffers / 2);
    assertEquals(numBuffers,getNumRequestedFromMemorySegmentPool());
    for (int i=1; i < numBuffers / 2; i++) {
      requests.remove(0).recycleBuffer();
      assertEquals(numBuffers - i,getNumRequestedFromMemorySegmentPool());
    }
    for (    Buffer buffer : requests) {
      buffer.recycleBuffer();
    }
  }
  @Test public void testRecycleExcessBuffersAfterChangingNumBuffers() throws Exception {
    localBufferPool.setNumBuffers(numBuffers);
    List<Buffer> requests=new ArrayList<Buffer>(numBuffers);
    for (int i=1; i <= numBuffers; i++) {
      requests.add(localBufferPool.requestBuffer());
    }
    for (    Buffer buffer : requests) {
      buffer.recycleBuffer();
    }
    assertEquals(numBuffers,localBufferPool.getNumberOfAvailableMemorySegments());
    localBufferPool.setNumBuffers(numBuffers / 2);
    assertEquals(numBuffers / 2,localBufferPool.getNumberOfAvailableMemorySegments());
  }
  @Test(expected=IllegalArgumentException.class) public void testSetLessThanRequiredNumBuffers() throws IOException {
    localBufferPool.setNumBuffers(1);
    localBufferPool.setNumBuffers(0);
  }
  @Test public void testPendingRequestWithListenersAfterRecycle() throws Exception {
    BufferListener twoTimesListener=createBufferListener(2);
    BufferListener oneTimeListener=createBufferListener(1);
    localBufferPool.setNumBuffers(2);
    Buffer available1=localBufferPool.requestBuffer();
    Buffer available2=localBufferPool.requestBuffer();
    assertNull(localBufferPool.requestBuffer());
    assertTrue(localBufferPool.addBufferListener(twoTimesListener));
    assertTrue(localBufferPool.addBufferListener(oneTimeListener));
    available1.recycleBuffer();
    verify(oneTimeListener,times(1)).notifyBufferAvailable(any(Buffer.class));
    verify(twoTimesListener,times(1)).notifyBufferAvailable(any(Buffer.class));
    available2.recycleBuffer();
    verify(oneTimeListener,times(1)).notifyBufferAvailable(any(Buffer.class));
    verify(twoTimesListener,times(2)).notifyBufferAvailable(any(Buffer.class));
  }
  @Test @SuppressWarnings("unchecked") public void testCancelPendingRequestsAfterDestroy() throws IOException {
    BufferListener listener=Mockito.mock(BufferListener.class);
    localBufferPool.setNumBuffers(1);
    Buffer available=localBufferPool.requestBuffer();
    Buffer unavailable=localBufferPool.requestBuffer();
    assertNull(unavailable);
    localBufferPool.addBufferListener(listener);
    localBufferPool.lazyDestroy();
    available.recycleBuffer();
    verify(listener,times(1)).notifyBufferDestroyed();
  }
  @Test @SuppressWarnings("unchecked") public void testConcurrentRequestRecycle() throws ExecutionException, InterruptedException, IOException {
    int numConcurrentTasks=128;
    int numBuffersToRequestPerTask=1024;
    localBufferPool.setNumBuffers(numConcurrentTasks);
    Future<Boolean>[] taskResults=new Future[numConcurrentTasks];
    for (int i=0; i < numConcurrentTasks; i++) {
      taskResults[i]=executor.submit(new BufferRequesterTask(localBufferPool,numBuffersToRequestPerTask));
    }
    for (int i=0; i < numConcurrentTasks; i++) {
      assertTrue(taskResults[i].get());
    }
  }
  @Test public void testDestroyDuringBlockingRequest() throws Exception {
    final int numberOfBuffers=1;
    localBufferPool.setNumBuffers(numberOfBuffers);
    final CountDownLatch sync=new CountDownLatch(1);
    final Callable<List<Buffer>> requester=new Callable<List<Buffer>>(){
      @Override public List<Buffer> call() throws Exception {
        final List<Buffer> requested=Lists.newArrayList();
        for (int i=0; i < numberOfBuffers; i++) {
          requested.add(localBufferPool.requestBufferBlocking());
        }
        sync.countDown();
        try {
          localBufferPool.requestBufferBlocking();
          fail("Call should have failed with an IllegalStateException");
        }
 catch (        IllegalStateException e) {
        }
        return requested;
      }
    }
;
    Future<List<Buffer>> f=executor.submit(requester);
    sync.await();
    localBufferPool.lazyDestroy();
    Thread.sleep(50);
    List<Buffer> requestedBuffers=f.get(60,TimeUnit.SECONDS);
    for (    Buffer buffer : requestedBuffers) {
      buffer.recycleBuffer();
    }
  }
  @Test public void testBoundedBuffer() throws Exception {
    localBufferPool.lazyDestroy();
    localBufferPool=new LocalBufferPool(networkBufferPool,1,2);
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    assertEquals(2,localBufferPool.getMaxNumberOfMemorySegments());
    Buffer buffer1, buffer2;
    localBufferPool.setNumBuffers(1);
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNotNull(buffer1=localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNull(localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    buffer1.recycleBuffer();
    assertEquals(1,localBufferPool.getNumberOfAvailableMemorySegments());
    localBufferPool.setNumBuffers(2);
    assertEquals(1,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNotNull(buffer1=localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNotNull(buffer2=localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNull(localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    buffer1.recycleBuffer();
    assertEquals(1,localBufferPool.getNumberOfAvailableMemorySegments());
    buffer2.recycleBuffer();
    assertEquals(2,localBufferPool.getNumberOfAvailableMemorySegments());
    localBufferPool.setNumBuffers(3);
    assertEquals(2,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNotNull(buffer1=localBufferPool.requestBuffer());
    assertEquals(1,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNotNull(buffer2=localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNull(localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    buffer1.recycleBuffer();
    assertEquals(1,localBufferPool.getNumberOfAvailableMemorySegments());
    buffer2.recycleBuffer();
    assertEquals(2,localBufferPool.getNumberOfAvailableMemorySegments());
    localBufferPool.setNumBuffers(1);
    assertEquals(1,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNotNull(buffer1=localBufferPool.requestBuffer());
    assertEquals(0,localBufferPool.getNumberOfAvailableMemorySegments());
    assertNull(localBufferPool.requestBuffer());
    buffer1.recycleBuffer();
    assertEquals(1,localBufferPool.getNumberOfAvailableMemorySegments());
  }
  private int getNumRequestedFromMemorySegmentPool(){
    return networkBufferPool.getTotalNumberOfMemorySegments() - networkBufferPool.getNumberOfAvailableMemorySegments();
  }
  private BufferListener createBufferListener(  int notificationTimes){
    return spy(new BufferListener(){
      AtomicInteger times=new AtomicInteger(0);
      @Override public NotificationResult notifyBufferAvailable(      Buffer buffer){
        int newCount=times.incrementAndGet();
        buffer.recycleBuffer();
        if (newCount < notificationTimes) {
          return NotificationResult.BUFFER_USED_NEED_MORE;
        }
 else {
          return NotificationResult.BUFFER_USED_NO_NEED_MORE;
        }
      }
      @Override public void notifyBufferDestroyed(){
      }
    }
);
  }
private static class BufferRequesterTask implements Callable<Boolean> {
    private final BufferProvider bufferProvider;
    private final int numBuffersToRequest;
    private BufferRequesterTask(    BufferProvider bufferProvider,    int numBuffersToRequest){
      this.bufferProvider=bufferProvider;
      this.numBuffersToRequest=numBuffersToRequest;
    }
    @Override public Boolean call() throws Exception {
      try {
        for (int i=0; i < numBuffersToRequest; i++) {
          Buffer buffer=bufferProvider.requestBufferBlocking();
          buffer.recycleBuffer();
        }
      }
 catch (      Throwable t) {
        return false;
      }
      return true;
    }
  }
}
