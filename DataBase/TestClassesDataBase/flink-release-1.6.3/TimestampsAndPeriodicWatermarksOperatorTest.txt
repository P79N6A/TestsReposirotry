/** 
 * Tests for  {@link TimestampsAndPeriodicWatermarksOperator}.
 */
public class TimestampsAndPeriodicWatermarksOperatorTest {
  @Test public void testTimestampsAndPeriodicWatermarksOperator() throws Exception {
    final TimestampsAndPeriodicWatermarksOperator<Long> operator=new TimestampsAndPeriodicWatermarksOperator<Long>(new LongExtractor());
    OneInputStreamOperatorTestHarness<Long,Long> testHarness=new OneInputStreamOperatorTestHarness<>(operator);
    testHarness.getExecutionConfig().setAutoWatermarkInterval(50);
    long currentTime=0;
    testHarness.open();
    testHarness.processElement(new StreamRecord<>(1L,1));
    testHarness.processElement(new StreamRecord<>(2L,1));
    testHarness.processWatermark(new Watermark(2));
    testHarness.processElement(new StreamRecord<>(3L,3));
    testHarness.processElement(new StreamRecord<>(4L,3));
{
      ConcurrentLinkedQueue<Object> output=testHarness.getOutput();
      long nextElementValue=1L;
      long lastWatermark=-1L;
      while (lastWatermark < 3) {
        if (output.size() > 0) {
          Object next=output.poll();
          assertNotNull(next);
          Tuple2<Long,Long> update=validateElement(next,nextElementValue,lastWatermark);
          nextElementValue=update.f0;
          lastWatermark=update.f1;
          assertTrue(lastWatermark < nextElementValue);
        }
 else {
          currentTime=currentTime + 10;
          testHarness.setProcessingTime(currentTime);
        }
      }
      output.clear();
    }
    testHarness.processElement(new StreamRecord<>(4L,4));
    testHarness.processElement(new StreamRecord<>(5L,4));
    testHarness.processElement(new StreamRecord<>(6L,4));
    testHarness.processElement(new StreamRecord<>(7L,4));
    testHarness.processElement(new StreamRecord<>(8L,4));
{
      ConcurrentLinkedQueue<Object> output=testHarness.getOutput();
      long nextElementValue=4L;
      long lastWatermark=2L;
      while (lastWatermark < 7) {
        if (output.size() > 0) {
          Object next=output.poll();
          assertNotNull(next);
          Tuple2<Long,Long> update=validateElement(next,nextElementValue,lastWatermark);
          nextElementValue=update.f0;
          lastWatermark=update.f1;
          assertTrue(lastWatermark < nextElementValue);
        }
 else {
          currentTime=currentTime + 10;
          testHarness.setProcessingTime(currentTime);
        }
      }
      output.clear();
    }
    testHarness.processWatermark(new Watermark(Long.MAX_VALUE));
    assertEquals(Long.MAX_VALUE,((Watermark)testHarness.getOutput().poll()).getTimestamp());
  }
  @Test public void testNegativeTimestamps() throws Exception {
    final AssignerWithPeriodicWatermarks<Long> assigner=new NeverWatermarkExtractor();
    final TimestampsAndPeriodicWatermarksOperator<Long> operator=new TimestampsAndPeriodicWatermarksOperator<Long>(assigner);
    OneInputStreamOperatorTestHarness<Long,Long> testHarness=new OneInputStreamOperatorTestHarness<Long,Long>(operator);
    testHarness.getExecutionConfig().setAutoWatermarkInterval(50);
    testHarness.open();
    long[] values={Long.MIN_VALUE,-1L,0L,1L,2L,3L,Long.MAX_VALUE};
    for (    long value : values) {
      testHarness.processElement(new StreamRecord<>(value));
    }
    ConcurrentLinkedQueue<Object> output=testHarness.getOutput();
    for (    long value : values) {
      assertEquals(value,((StreamRecord<?>)output.poll()).getTimestamp());
    }
  }
  private Tuple2<Long,Long> validateElement(  Object element,  long nextElementValue,  long currentWatermark){
    if (element instanceof StreamRecord) {
      @SuppressWarnings("unchecked") StreamRecord<Long> record=(StreamRecord<Long>)element;
      assertEquals(nextElementValue,record.getValue().longValue());
      assertEquals(nextElementValue,record.getTimestamp());
      return new Tuple2<>(nextElementValue + 1,currentWatermark);
    }
 else     if (element instanceof Watermark) {
      long wt=((Watermark)element).getTimestamp();
      assertTrue(wt > currentWatermark);
      return new Tuple2<>(nextElementValue,wt);
    }
 else {
      throw new IllegalArgumentException("unrecognized element: " + element);
    }
  }
private static class LongExtractor implements AssignerWithPeriodicWatermarks<Long> {
    private static final long serialVersionUID=1L;
    private long currentTimestamp=Long.MIN_VALUE;
    @Override public long extractTimestamp(    Long element,    long previousElementTimestamp){
      currentTimestamp=element;
      return element;
    }
    @Override public Watermark getCurrentWatermark(){
      return new Watermark(currentTimestamp == Long.MIN_VALUE ? Long.MIN_VALUE : currentTimestamp - 1);
    }
  }
private static class NeverWatermarkExtractor implements AssignerWithPeriodicWatermarks<Long> {
    private static final long serialVersionUID=1L;
    @Override public long extractTimestamp(    Long element,    long previousElementTimestamp){
      return element;
    }
    @Override public Watermark getCurrentWatermark(){
      return null;
    }
  }
}
