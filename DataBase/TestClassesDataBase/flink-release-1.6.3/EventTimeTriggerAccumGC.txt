/** 
 * A trigger that fires at the end of the window but does not purge the state of the fired window. This is to test the state garbage collection mechanism.
 */
private static class EventTimeTriggerAccumGC extends Trigger<Object,TimeWindow> {
  private static final long serialVersionUID=1L;
  private long cleanupTime;
  public EventTimeTriggerAccumGC(  long cleanupTime){
    this.cleanupTime=cleanupTime;
  }
  @Override public TriggerResult onElement(  Object element,  long timestamp,  TimeWindow window,  TriggerContext ctx) throws Exception {
    if (window.maxTimestamp() <= ctx.getCurrentWatermark()) {
      return TriggerResult.FIRE;
    }
 else {
      ctx.registerEventTimeTimer(window.maxTimestamp());
      return TriggerResult.CONTINUE;
    }
  }
  @Override public TriggerResult onEventTime(  long time,  TimeWindow window,  TriggerContext ctx){
    return time == window.maxTimestamp() || time == window.maxTimestamp() + cleanupTime ? TriggerResult.FIRE_AND_PURGE : TriggerResult.CONTINUE;
  }
  @Override public TriggerResult onProcessingTime(  long time,  TimeWindow window,  TriggerContext ctx) throws Exception {
    return TriggerResult.CONTINUE;
  }
  @Override public void clear(  TimeWindow window,  TriggerContext ctx) throws Exception {
    ctx.deleteEventTimeTimer(window.maxTimestamp());
  }
  @Override public boolean canMerge(){
    return true;
  }
  @Override public void onMerge(  TimeWindow window,  OnMergeContext ctx){
    ctx.registerEventTimeTimer(window.maxTimestamp());
  }
  @Override public String toString(){
    return "EventTimeTrigger()";
  }
}
