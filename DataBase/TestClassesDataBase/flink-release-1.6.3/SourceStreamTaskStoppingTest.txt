/** 
 * These tests verify that the RichFunction methods are called (in correct order). And that checkpointing/element emission don't occur concurrently.
 */
public class SourceStreamTaskStoppingTest {
  static boolean stopped=false;
  @Test public void testStop(){
    final StoppableSourceStreamTask<Object,StoppableSource> sourceTask=new StoppableSourceStreamTask<>(new DummyEnvironment("test",1,0));
    sourceTask.headOperator=new StoppableStreamSource<>(new StoppableSource());
    sourceTask.stop();
    assertTrue(stopped);
  }
  @Test public void testStopBeforeInitialization() throws Exception {
    final StoppableSourceStreamTask<Object,StoppableFailingSource> sourceTask=new StoppableSourceStreamTask<>(new DummyEnvironment("test",1,0));
    sourceTask.stop();
    sourceTask.headOperator=new StoppableStreamSource<>(new StoppableFailingSource());
    sourceTask.run();
  }
private static class StoppableSource extends RichSourceFunction<Object> implements StoppableFunction {
    private static final long serialVersionUID=728864804042338806L;
    @Override public void run(    org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext<Object> ctx) throws Exception {
    }
    @Override public void cancel(){
    }
    @Override public void stop(){
      stopped=true;
    }
  }
private static class StoppableFailingSource extends RichSourceFunction<Object> implements StoppableFunction {
    private static final long serialVersionUID=728864804042338806L;
    @Override public void run(    SourceContext<Object> ctx) throws Exception {
      fail("should not be called");
    }
    @Override public void cancel(){
    }
    @Override public void stop(){
    }
  }
}
