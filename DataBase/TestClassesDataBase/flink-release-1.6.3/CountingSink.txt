/** 
 * A checkpointed sink, which sums up its input and notifies the main thread after all inputs are exhausted.
 */
public static class CountingSink implements SinkFunction<Long>, ListCheckpointed<CountingSink>, CheckpointListener {
  private static final Logger LOG=LoggerFactory.getLogger(CountingSink.class);
  private static final long serialVersionUID=1436484290453629091L;
  private long current=0;
  private int numberOfReceivedLastElements;
  @Override public void invoke(  Long value) throws Exception {
    if (value == lastElement) {
      numberOfReceivedLastElements++;
      if (numberOfReceivedLastElements == Parallelism) {
        finalCount.set(current);
        finalCountLatch.countDown();
      }
 else       if (numberOfReceivedLastElements > Parallelism) {
        throw new IllegalStateException("Received more elements than parallelism.");
      }
    }
 else {
      current+=value;
    }
  }
  @Override public List<CountingSink> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    LOG.debug("Snapshotting state {}:{} @ ID {}.",current,numberOfReceivedLastElements,checkpointId);
    return Collections.singletonList(this);
  }
  @Override public void restoreState(  List<CountingSink> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    CountingSink s=state.get(0);
    LOG.debug("Restoring state {}:{}",s.current,s.numberOfReceivedLastElements);
    this.current=s.current;
    this.numberOfReceivedLastElements=s.numberOfReceivedLastElements;
  }
  @Override public void notifyCheckpointComplete(  long checkpointId) throws Exception {
    LOG.debug("Checkpoint {} completed.",checkpointId);
    completedCheckpointsLatch.countDown();
    completedCheckpointsLatch2.countDown();
  }
}
