/** 
 * Tests for rich DataSource and DataSink input output formats accessing RuntimeContext by checking accumulator values.
 */
public class RichInputOutputITCase extends JavaProgramTestBase {
  private String inputPath;
  private static ConcurrentLinkedQueue<Integer> readCalls;
  private static ConcurrentLinkedQueue<Integer> writeCalls;
  @Override protected void preSubmit() throws Exception {
    inputPath=createTempFile("input","ab\n" + "cd\n" + "ef\n");
  }
  @Override protected void testProgram() throws Exception {
    readCalls=new ConcurrentLinkedQueue<Integer>();
    writeCalls=new ConcurrentLinkedQueue<Integer>();
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.createInput(new TestInputFormat(new Path(inputPath))).output(new TestOutputFormat());
    JobExecutionResult result=env.execute();
    Object a=result.getAllAccumulatorResults().get("DATA_SOURCE_ACCUMULATOR");
    Object b=result.getAllAccumulatorResults().get("DATA_SINK_ACCUMULATOR");
    long recordsRead=(Long)a;
    long recordsWritten=(Long)b;
    assertEquals(recordsRead,readCalls.size());
    assertEquals(recordsWritten,writeCalls.size());
  }
private static final class TestInputFormat extends TextInputFormat {
    private static final long serialVersionUID=1L;
    private LongCounter counter=new LongCounter();
    public TestInputFormat(    Path filePath){
      super(filePath);
    }
    @Override public void open(    FileInputSplit split) throws IOException {
      try {
        getRuntimeContext().addAccumulator("DATA_SOURCE_ACCUMULATOR",counter);
      }
 catch (      UnsupportedOperationException e) {
      }
      super.open(split);
    }
    @Override public String nextRecord(    String reuse) throws IOException {
      readCalls.add(1);
      counter.add(1);
      return super.nextRecord(reuse);
    }
  }
private static final class TestOutputFormat extends RichOutputFormat<String> {
    private LongCounter counter=new LongCounter();
    @Override public void configure(    Configuration parameters){
    }
    @Override public void open(    int a,    int b){
      try {
        getRuntimeContext().addAccumulator("DATA_SINK_ACCUMULATOR",counter);
      }
 catch (      UnsupportedOperationException e) {
      }
    }
    @Override public void close() throws IOException {
    }
    @Override public void writeRecord(    String record){
      writeCalls.add(1);
      counter.add(1);
    }
  }
}
