/** 
 * Tests retrieval of a job from a running Flink cluster.
 */
public class JobRetrievalITCase extends TestLogger {
  private static final Semaphore lock=new Semaphore(1);
  @ClassRule public static final MiniClusterResource CLUSTER=new MiniClusterResource(new MiniClusterResourceConfiguration.Builder().setNumberTaskManagers(1).setNumberSlotsPerTaskManager(4).setCodebaseType(TestBaseUtils.CodebaseType.NEW).build());
  private RestClusterClient<StandaloneClusterId> client;
  @Before public void setUp() throws Exception {
    final Configuration clientConfig=new Configuration();
    clientConfig.setInteger(RestOptions.RETRY_MAX_ATTEMPTS,0);
    clientConfig.setLong(RestOptions.RETRY_DELAY,0);
    clientConfig.addAll(CLUSTER.getClientConfiguration());
    client=new RestClusterClient<>(clientConfig,StandaloneClusterId.getInstance());
  }
  @After public void tearDown(){
    if (client != null) {
      client.shutdown();
    }
  }
  @Test public void testJobRetrieval() throws Exception {
    final JobID jobID=new JobID();
    final JobVertex imalock=new JobVertex("imalock");
    imalock.setInvokableClass(SemaphoreInvokable.class);
    final JobGraph jobGraph=new JobGraph(jobID,"testjob",imalock);
    lock.acquire();
    client.setDetached(true);
    client.submitJob(jobGraph,JobRetrievalITCase.class.getClassLoader());
    final CheckedThread resumingThread=new CheckedThread("Flink-Job-Retriever"){
      @Override public void go() throws Exception {
        assertNotNull(client.requestJobResult(jobID).get());
      }
    }
;
    while (client.listJobs().get().isEmpty()) {
      Thread.sleep(50);
    }
    resumingThread.start();
    while (resumingThread.getState() != Thread.State.WAITING) {
      Thread.sleep(10);
    }
    lock.release();
    resumingThread.sync();
  }
  @Test public void testNonExistingJobRetrieval() throws Exception {
    final JobID jobID=new JobID();
    try {
      client.requestJobResult(jobID).get();
      fail();
    }
 catch (    Exception exception) {
      Optional<Throwable> expectedCause=ExceptionUtils.findThrowable(exception,candidate -> candidate.getMessage() != null && candidate.getMessage().contains("Could not find Flink job"));
      if (!expectedCause.isPresent()) {
        throw exception;
      }
    }
  }
  /** 
 * Invokable that waits on  {@link #lock} to be released and finishes afterwards.<p>NOTE: needs to be <tt>public</tt> so that a task can be run with this!
 */
public static class SemaphoreInvokable extends AbstractInvokable {
    public SemaphoreInvokable(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      lock.acquire();
      lock.release();
    }
  }
}
