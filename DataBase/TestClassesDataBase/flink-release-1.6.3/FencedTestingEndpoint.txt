private static class FencedTestingEndpoint extends FencedRpcEndpoint<UUID> implements FencedTestingGateway {
  private final OneShotLatch computationLatch;
  private final String value;
  protected FencedTestingEndpoint(  RpcService rpcService,  String value){
    this(rpcService,value,null);
  }
  @Override public CompletableFuture<Void> postStop(){
    return CompletableFuture.completedFuture(null);
  }
  protected FencedTestingEndpoint(  RpcService rpcService,  String value,  UUID initialFencingToken){
    super(rpcService);
    computationLatch=new OneShotLatch();
    this.value=value;
    currentMainThread.set(Thread.currentThread());
    try {
      setFencingToken(initialFencingToken);
    }
  finally {
      currentMainThread.set(null);
    }
  }
  @Override public CompletableFuture<String> foobar(  Time timeout){
    return CompletableFuture.completedFuture(value);
  }
  @Override public CompletableFuture<Acknowledge> triggerMainThreadExecutorComputation(  Time timeout){
    return CompletableFuture.supplyAsync(() -> {
      try {
        computationLatch.await();
      }
 catch (      InterruptedException e) {
        throw new CompletionException(new FlinkException("Waiting on latch failed.",e));
      }
      return value;
    }
,getRpcService().getExecutor()).thenApplyAsync((    String v) -> Acknowledge.get(),getMainThreadExecutor());
  }
  @Override public CompletableFuture<Acknowledge> triggerComputationLatch(  Time timeout){
    computationLatch.trigger();
    return CompletableFuture.completedFuture(Acknowledge.get());
  }
  public CompletableFuture<Acknowledge> setFencingTokenInMainThread(  UUID fencingToken,  Time timeout){
    return callAsyncWithoutFencing(() -> {
      setFencingToken(fencingToken);
      return Acknowledge.get();
    }
,timeout);
  }
}
