/** 
 * Tests for  {@link RegisterApplicationMasterResponseReflector}.
 */
public class RegisterApplicationMasterResponseReflectorTest extends TestLogger {
  private static final Logger LOG=LoggerFactory.getLogger(RegisterApplicationMasterResponseReflectorTest.class);
  @Mock private Container mockContainer;
  @Before public void setUp(){
    MockitoAnnotations.initMocks(this);
  }
  @Test public void testCallsMethodIfPresent(){
    final RegisterApplicationMasterResponseReflector registerApplicationMasterResponseReflector=new RegisterApplicationMasterResponseReflector(LOG,HasMethod.class);
    final List<Container> containersFromPreviousAttemptsUnsafe=registerApplicationMasterResponseReflector.getContainersFromPreviousAttemptsUnsafe(new HasMethod());
    assertThat(containersFromPreviousAttemptsUnsafe,hasSize(1));
  }
  @Test public void testDoesntCallMethodIfAbsent(){
    final RegisterApplicationMasterResponseReflector registerApplicationMasterResponseReflector=new RegisterApplicationMasterResponseReflector(LOG,HasMethod.class);
    final List<Container> containersFromPreviousAttemptsUnsafe=registerApplicationMasterResponseReflector.getContainersFromPreviousAttemptsUnsafe(new Object());
    assertThat(containersFromPreviousAttemptsUnsafe,empty());
  }
  @Test public void testGetMethodReflectiveHadoop22(){
    assumeTrue("Method getContainersFromPreviousAttempts is not supported by Hadoop: " + VersionInfo.getVersion(),isHadoopVersionGreaterThanOrEquals(2,2));
    final RegisterApplicationMasterResponseReflector registerApplicationMasterResponseReflector=new RegisterApplicationMasterResponseReflector(LOG);
    final Method method=registerApplicationMasterResponseReflector.getMethod();
    assertThat(method,notNullValue());
  }
  private static boolean isHadoopVersionGreaterThanOrEquals(  final int major,  final int minor){
    final String[] splitVersion=VersionInfo.getVersion().split("\\.");
    final int[] versions=Arrays.stream(splitVersion).mapToInt(Integer::parseInt).toArray();
    return versions[0] >= major && versions[1] >= minor;
  }
  /** 
 * Class which has a method with the same signature as {@link RegisterApplicationMasterResponse#getContainersFromPreviousAttempts()}.
 */
private class HasMethod {
    /** 
 * Called from  {@link #testCallsMethodIfPresent()}.
 */
    @SuppressWarnings("unused") public List<Container> getContainersFromPreviousAttempts(){
      return Collections.singletonList(mockContainer);
    }
  }
}
