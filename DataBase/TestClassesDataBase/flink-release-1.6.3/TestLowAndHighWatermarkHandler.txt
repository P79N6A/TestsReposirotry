/** 
 * This handler implements the test. <p>Verifies that the high and low watermark are set in relation to the page size.
 */
private static class TestLowAndHighWatermarkHandler extends ChannelInboundHandlerAdapter {
  private final int pageSize;
  private final int expectedLowWatermark;
  private final int expectedHighWatermark;
  private final AtomicReference<Throwable> error;
  private boolean hasFlushed;
  public TestLowAndHighWatermarkHandler(  int pageSize,  int expectedLowWatermark,  int expectedHighWatermark,  AtomicReference<Throwable> error){
    this.pageSize=pageSize;
    this.expectedLowWatermark=expectedLowWatermark;
    this.expectedHighWatermark=expectedHighWatermark;
    this.error=error;
  }
  @Override public void channelActive(  ChannelHandlerContext ctx) throws Exception {
    final Channel ch=ctx.channel();
    assertEquals("Low watermark",expectedLowWatermark,ch.config().getWriteBufferLowWaterMark());
    assertEquals("High watermark",expectedHighWatermark,ch.config().getWriteBufferHighWaterMark());
    assertTrue(ch.isWritable());
    ch.write(buffer());
    assertTrue(ch.isWritable());
    ch.write(buffer());
    assertFalse(ch.isWritable());
    hasFlushed=true;
    ch.flush();
  }
  @Override public void channelWritabilityChanged(  ChannelHandlerContext ctx) throws Exception {
    if (hasFlushed) {
      assertTrue(ctx.channel().isWritable());
      ctx.close();
    }
    super.channelWritabilityChanged(ctx);
  }
  @Override public void exceptionCaught(  ChannelHandlerContext ctx,  Throwable cause) throws Exception {
    if (error.get() == null) {
      error.set(cause);
    }
    ctx.close();
    super.exceptionCaught(ctx,cause);
  }
  private ByteBuf buffer(){
    return NettyServerLowAndHighWatermarkTest.buffer(pageSize);
  }
}
