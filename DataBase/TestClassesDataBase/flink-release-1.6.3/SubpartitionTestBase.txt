/** 
 * Basic subpartition behaviour tests.
 */
public abstract class SubpartitionTestBase extends TestLogger {
  /** 
 * Return the subpartition to be tested.
 */
  abstract ResultSubpartition createSubpartition();
  @Test public void testAddAfterFinish() throws Exception {
    final ResultSubpartition subpartition=createSubpartition();
    try {
      subpartition.finish();
      assertEquals(1,subpartition.getTotalNumberOfBuffers());
      assertEquals(0,subpartition.getTotalNumberOfBytes());
      assertEquals(1,subpartition.getTotalNumberOfBuffers());
      assertEquals(0,subpartition.getBuffersInBacklog());
      assertEquals(0,subpartition.getTotalNumberOfBytes());
      BufferConsumer bufferConsumer=createFilledBufferConsumer(4096,4096);
      assertFalse(subpartition.add(bufferConsumer));
      assertEquals(1,subpartition.getTotalNumberOfBuffers());
      assertEquals(0,subpartition.getBuffersInBacklog());
      assertEquals(0,subpartition.getTotalNumberOfBytes());
    }
  finally {
      if (subpartition != null) {
        subpartition.release();
      }
    }
  }
  @Test public void testAddAfterRelease() throws Exception {
    final ResultSubpartition subpartition=createSubpartition();
    try {
      subpartition.release();
      assertEquals(0,subpartition.getTotalNumberOfBuffers());
      assertEquals(0,subpartition.getTotalNumberOfBytes());
      assertEquals(0,subpartition.getTotalNumberOfBuffers());
      assertEquals(0,subpartition.getBuffersInBacklog());
      assertEquals(0,subpartition.getTotalNumberOfBytes());
      BufferConsumer bufferConsumer=createFilledBufferConsumer(4096,4096);
      assertFalse(subpartition.add(bufferConsumer));
      assertEquals(0,subpartition.getTotalNumberOfBuffers());
      assertEquals(0,subpartition.getBuffersInBacklog());
      assertEquals(0,subpartition.getTotalNumberOfBytes());
    }
  finally {
      if (subpartition != null) {
        subpartition.release();
      }
    }
  }
  @Test public void testReleaseParent() throws Exception {
    final ResultSubpartition partition=createSubpartition();
    verifyViewReleasedAfterParentRelease(partition);
  }
  @Test public void testReleaseParentAfterSpilled() throws Exception {
    final ResultSubpartition partition=createSubpartition();
    partition.releaseMemory();
    verifyViewReleasedAfterParentRelease(partition);
  }
  private void verifyViewReleasedAfterParentRelease(  ResultSubpartition partition) throws Exception {
    BufferConsumer bufferConsumer=createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE);
    partition.add(bufferConsumer);
    partition.finish();
    BufferAvailabilityListener listener=mock(BufferAvailabilityListener.class);
    ResultSubpartitionView view=partition.createReadView(listener);
    assertNotNull(view.getNextBuffer());
    assertNotNull(view.getNextBuffer());
    assertFalse(view.isReleased());
    partition.release();
    assertTrue(view.isReleased());
  }
  static void assertNextBuffer(  ResultSubpartitionView readView,  int expectedReadableBufferSize,  boolean expectedIsMoreAvailable,  int expectedBuffersInBacklog,  boolean expectedNextBufferIsEvent,  boolean expectedRecycledAfterRecycle) throws IOException, InterruptedException {
    assertNextBufferOrEvent(readView,expectedReadableBufferSize,true,null,expectedIsMoreAvailable,expectedBuffersInBacklog,expectedNextBufferIsEvent,expectedRecycledAfterRecycle);
  }
  static void assertNextEvent(  ResultSubpartitionView readView,  int expectedReadableBufferSize,  Class<? extends AbstractEvent> expectedEventClass,  boolean expectedIsMoreAvailable,  int expectedBuffersInBacklog,  boolean expectedNextBufferIsEvent,  boolean expectedRecycledAfterRecycle) throws IOException, InterruptedException {
    assertNextBufferOrEvent(readView,expectedReadableBufferSize,false,expectedEventClass,expectedIsMoreAvailable,expectedBuffersInBacklog,expectedNextBufferIsEvent,expectedRecycledAfterRecycle);
  }
  private static void assertNextBufferOrEvent(  ResultSubpartitionView readView,  int expectedReadableBufferSize,  boolean expectedIsBuffer,  @Nullable Class<? extends AbstractEvent> expectedEventClass,  boolean expectedIsMoreAvailable,  int expectedBuffersInBacklog,  boolean expectedNextBufferIsEvent,  boolean expectedRecycledAfterRecycle) throws IOException, InterruptedException {
    checkArgument(expectedEventClass == null || !expectedIsBuffer);
    ResultSubpartition.BufferAndBacklog bufferAndBacklog=readView.getNextBuffer();
    assertNotNull(bufferAndBacklog);
    try {
      assertEquals("buffer size",expectedReadableBufferSize,bufferAndBacklog.buffer().readableBytes());
      assertEquals("buffer or event",expectedIsBuffer,bufferAndBacklog.buffer().isBuffer());
      if (expectedEventClass != null) {
        assertThat(EventSerializer.fromBuffer(bufferAndBacklog.buffer(),ClassLoader.getSystemClassLoader()),instanceOf(expectedEventClass));
      }
      assertEquals("more available",expectedIsMoreAvailable,bufferAndBacklog.isMoreAvailable());
      assertEquals("more available",expectedIsMoreAvailable,readView.isAvailable());
      assertEquals("backlog",expectedBuffersInBacklog,bufferAndBacklog.buffersInBacklog());
      assertEquals("next is event",expectedNextBufferIsEvent,bufferAndBacklog.nextBufferIsEvent());
      assertEquals("next is event",expectedNextBufferIsEvent,readView.nextBufferIsEvent());
      assertFalse("not recycled",bufferAndBacklog.buffer().isRecycled());
    }
  finally {
      bufferAndBacklog.buffer().recycleBuffer();
    }
    assertEquals("recycled",expectedRecycledAfterRecycle,bufferAndBacklog.buffer().isRecycled());
  }
  static void assertNoNextBuffer(  ResultSubpartitionView readView) throws IOException, InterruptedException {
    assertNull(readView.getNextBuffer());
  }
}
