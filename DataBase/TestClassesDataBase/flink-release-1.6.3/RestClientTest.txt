/** 
 * Tests for  {@link RestClient}.
 */
public class RestClientTest extends TestLogger {
  private static final String unroutableIp="10.255.255.1";
  private static final long TIMEOUT=10L;
  @Test public void testConnectionTimeout() throws Exception {
    final Configuration config=new Configuration();
    config.setLong(RestOptions.CONNECTION_TIMEOUT,1);
    try (final RestClient restClient=new RestClient(RestClientConfiguration.fromConfiguration(config),Executors.directExecutor())){
      restClient.sendRequest(unroutableIp,80,new TestMessageHeaders(),EmptyMessageParameters.getInstance(),EmptyRequestBody.getInstance()).get(60,TimeUnit.SECONDS);
    }
 catch (    final ExecutionException e) {
      final Throwable throwable=ExceptionUtils.stripExecutionException(e);
      assertThat(throwable,instanceOf(ConnectTimeoutException.class));
      assertThat(throwable.getMessage(),containsString(unroutableIp));
    }
  }
  /** 
 * Tests that we fail the operation if the remote connection closes.
 */
  @Test public void testConnectionClosedHandling() throws Exception {
    final Configuration config=new Configuration();
    config.setLong(RestOptions.IDLENESS_TIMEOUT,5000L);
    try (final ServerSocket serverSocket=new ServerSocket(0);final RestClient restClient=new RestClient(RestClientConfiguration.fromConfiguration(config),TestingUtils.defaultExecutor())){
      final String targetAddress="localhost";
      final int targetPort=serverSocket.getLocalPort();
      final CompletableFuture<Socket> socketCompletableFuture=CompletableFuture.supplyAsync(CheckedSupplier.unchecked(serverSocket::accept));
      final CompletableFuture<EmptyResponseBody> responseFuture=restClient.sendRequest(targetAddress,targetPort,new TestMessageHeaders(),EmptyMessageParameters.getInstance(),EmptyRequestBody.getInstance(),Collections.emptyList());
      Socket connectionSocket=null;
      try {
        connectionSocket=socketCompletableFuture.get(TIMEOUT,TimeUnit.SECONDS);
      }
 catch (      TimeoutException ignored) {
        socketCompletableFuture.cancel(true);
      }
      if (connectionSocket != null) {
        connectionSocket.close();
      }
      try {
        responseFuture.get();
      }
 catch (      ExecutionException ee) {
        if (!ExceptionUtils.findThrowable(ee,IOException.class).isPresent()) {
          throw ee;
        }
      }
    }
   }
  /** 
 * Tests that we fail the operation if the client closes.
 */
  @Test public void testRestClientClosedHandling() throws Exception {
    final Configuration config=new Configuration();
    config.setLong(RestOptions.IDLENESS_TIMEOUT,5000L);
    Socket connectionSocket=null;
    try (final ServerSocket serverSocket=new ServerSocket(0);final RestClient restClient=new RestClient(RestClientConfiguration.fromConfiguration(config),TestingUtils.defaultExecutor())){
      final String targetAddress="localhost";
      final int targetPort=serverSocket.getLocalPort();
      final CompletableFuture<Socket> socketCompletableFuture=CompletableFuture.supplyAsync(CheckedSupplier.unchecked(serverSocket::accept));
      final CompletableFuture<EmptyResponseBody> responseFuture=restClient.sendRequest(targetAddress,targetPort,new TestMessageHeaders(),EmptyMessageParameters.getInstance(),EmptyRequestBody.getInstance(),Collections.emptyList());
      try {
        connectionSocket=socketCompletableFuture.get(TIMEOUT,TimeUnit.SECONDS);
      }
 catch (      TimeoutException ignored) {
        socketCompletableFuture.cancel(true);
      }
      restClient.close();
      try {
        responseFuture.get();
      }
 catch (      ExecutionException ee) {
        if (!ExceptionUtils.findThrowable(ee,IOException.class).isPresent()) {
          throw ee;
        }
      }
    }
  finally {
      if (connectionSocket != null) {
        connectionSocket.close();
      }
    }
  }
private static class TestMessageHeaders implements MessageHeaders<EmptyRequestBody,EmptyResponseBody,EmptyMessageParameters> {
    @Override public Class<EmptyRequestBody> getRequestClass(){
      return EmptyRequestBody.class;
    }
    @Override public Class<EmptyResponseBody> getResponseClass(){
      return EmptyResponseBody.class;
    }
    @Override public HttpResponseStatus getResponseStatusCode(){
      return HttpResponseStatus.OK;
    }
    @Override public String getDescription(){
      return "";
    }
    @Override public EmptyMessageParameters getUnresolvedMessageParameters(){
      return EmptyMessageParameters.getInstance();
    }
    @Override public HttpMethodWrapper getHttpMethod(){
      return HttpMethodWrapper.GET;
    }
    @Override public String getTargetRestEndpointURL(){
      return "/";
    }
  }
}
