private static class TimestampValidatingOperator extends StreamSink<Long> {
  private static final long serialVersionUID=1353168781235526806L;
  public TimestampValidatingOperator(){
    super(new SinkFunction<Long>(){
      private static final long serialVersionUID=-6676565693361786524L;
      @Override public void invoke(      Long value) throws Exception {
        throw new RuntimeException("Unexpected");
      }
    }
);
  }
  long elCount=0;
  long wmCount=0;
  long lastWM=Long.MIN_VALUE;
  @Override public void processElement(  StreamRecord<Long> element) throws Exception {
    elCount++;
    if (element.getValue() * 2 != element.getTimestamp()) {
      throw new RuntimeException("Invalid timestamp: " + element);
    }
  }
  @Override public void processWatermark(  Watermark mark) throws Exception {
    wmCount++;
    if (lastWM <= mark.getTimestamp()) {
      lastWM=mark.getTimestamp();
    }
 else {
      throw new RuntimeException("Received watermark higher than the last one");
    }
    if (mark.getTimestamp() % 10 != 0 && mark.getTimestamp() != Long.MAX_VALUE) {
      throw new RuntimeException("Invalid watermark: " + mark.getTimestamp());
    }
  }
  @Override public void close() throws Exception {
    super.close();
    if (elCount != 1000L) {
      throw new RuntimeException("Wrong final element count " + elCount);
    }
    if (wmCount <= 2) {
      throw new RuntimeException("Almost no watermarks have been sent " + wmCount);
    }
  }
}
