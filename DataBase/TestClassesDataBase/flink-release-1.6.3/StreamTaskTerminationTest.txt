/** 
 * Tests for the StreamTask termination.
 */
public class StreamTaskTerminationTest extends TestLogger {
  public static final OneShotLatch RUN_LATCH=new OneShotLatch();
  public static final OneShotLatch CHECKPOINTING_LATCH=new OneShotLatch();
  private static final OneShotLatch CLEANUP_LATCH=new OneShotLatch();
  /** 
 * FLINK-6833 <p>Tests that a finished stream task cannot be failed by an asynchronous checkpointing operation after the stream task has stopped running.
 */
  @Test public void testConcurrentAsyncCheckpointCannotFailFinishedStreamTask() throws Exception {
    final Configuration taskConfiguration=new Configuration();
    final StreamConfig streamConfig=new StreamConfig(taskConfiguration);
    final NoOpStreamOperator<Long> noOpStreamOperator=new NoOpStreamOperator<>();
    final StateBackend blockingStateBackend=new BlockingStateBackend();
    streamConfig.setStreamOperator(noOpStreamOperator);
    streamConfig.setOperatorID(new OperatorID());
    streamConfig.setStateBackend(blockingStateBackend);
    final long checkpointId=0L;
    final long checkpointTimestamp=0L;
    final JobInformation jobInformation=new JobInformation(new JobID(),"Test Job",new SerializedValue<>(new ExecutionConfig()),new Configuration(),Collections.emptyList(),Collections.emptyList());
    final TaskInformation taskInformation=new TaskInformation(new JobVertexID(),"Test Task",1,1,BlockingStreamTask.class.getName(),taskConfiguration);
    final TaskManagerRuntimeInfo taskManagerRuntimeInfo=new TestingTaskManagerRuntimeInfo();
    TaskEventDispatcher taskEventDispatcher=new TaskEventDispatcher();
    final NetworkEnvironment networkEnv=mock(NetworkEnvironment.class);
    when(networkEnv.createKvStateTaskRegistry(any(JobID.class),any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class));
    when(networkEnv.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
    BlobCacheService blobService=new BlobCacheService(mock(PermanentBlobCache.class),mock(TransientBlobCache.class));
    final Task task=new Task(jobInformation,taskInformation,new ExecutionAttemptID(),new AllocationID(),0,0,Collections.<ResultPartitionDeploymentDescriptor>emptyList(),Collections.<InputGateDeploymentDescriptor>emptyList(),0,new MemoryManager(32L * 1024L,1),new IOManagerAsync(),networkEnv,mock(BroadcastVariableManager.class),new TestTaskStateManager(),mock(TaskManagerActions.class),mock(InputSplitProvider.class),mock(CheckpointResponder.class),blobService,new BlobLibraryCacheManager(blobService.getPermanentBlobService(),FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,new String[0]),mock(FileCache.class),taskManagerRuntimeInfo,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),new NoOpResultPartitionConsumableNotifier(),mock(PartitionProducerStateChecker.class),Executors.directExecutor());
    CompletableFuture<Void> taskRun=CompletableFuture.runAsync(() -> task.run(),TestingUtils.defaultExecutor());
    RUN_LATCH.await();
    task.triggerCheckpointBarrier(checkpointId,checkpointTimestamp,CheckpointOptions.forCheckpointWithDefaultLocation());
    taskRun.get();
    if (task.getFailureCause() != null) {
      throw new Exception("Task failed",task.getFailureCause());
    }
    assertEquals(ExecutionState.FINISHED,task.getExecutionState());
  }
  /** 
 * Blocking stream task which waits on and triggers a set of one shot latches to establish a certain interleaving with a concurrently running checkpoint operation.
 */
public static class BlockingStreamTask<T,OP extends StreamOperator<T>> extends StreamTask<T,OP> {
    public BlockingStreamTask(    Environment env){
      super(env);
    }
    @Override protected void init(){
    }
    @Override protected void run() throws Exception {
      RUN_LATCH.trigger();
      CHECKPOINTING_LATCH.await();
    }
    @Override protected void cleanup() throws Exception {
      CLEANUP_LATCH.trigger();
      Assert.assertTrue(getAsyncOperationsThreadPool().awaitTermination(30L,TimeUnit.SECONDS));
    }
    @Override protected void cancelTask(){
    }
  }
private static class NoOpStreamOperator<T> extends AbstractStreamOperator<T> {
    private static final long serialVersionUID=4517845269225218312L;
  }
static class BlockingStateBackend implements StateBackend {
    private static final long serialVersionUID=-5053068148933314100L;
    @Override public CompletedCheckpointStorageLocation resolveCheckpoint(    String pointer){
      throw new UnsupportedOperationException();
    }
    @Override public CheckpointStorage createCheckpointStorage(    JobID jobId) throws IOException {
      return new MemoryBackendCheckpointStorage(jobId,null,null,Integer.MAX_VALUE);
    }
    @Override public <K>AbstractKeyedStateBackend<K> createKeyedStateBackend(    Environment env,    JobID jobID,    String operatorIdentifier,    TypeSerializer<K> keySerializer,    int numberOfKeyGroups,    KeyGroupRange keyGroupRange,    TaskKvStateRegistry kvStateRegistry,    TtlTimeProvider ttlTimeProvider){
      return null;
    }
    @Override public OperatorStateBackend createOperatorStateBackend(    Environment env,    String operatorIdentifier) throws Exception {
      OperatorStateBackend operatorStateBackend=mock(OperatorStateBackend.class);
      when(operatorStateBackend.snapshot(anyLong(),anyLong(),any(CheckpointStreamFactory.class),any(CheckpointOptions.class))).thenReturn(new FutureTask<>(new BlockingCallable()));
      return operatorStateBackend;
    }
  }
static class BlockingCallable implements Callable<SnapshotResult<OperatorStateHandle>> {
    @Override public SnapshotResult<OperatorStateHandle> call() throws Exception {
      CHECKPOINTING_LATCH.trigger();
      CLEANUP_LATCH.await();
      throw new FlinkException("Checkpointing operation failed");
    }
  }
}
