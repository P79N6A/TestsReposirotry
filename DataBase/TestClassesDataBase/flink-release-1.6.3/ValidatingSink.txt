/** 
 * Generalized sink for validation of window checkpointing IT cases.
 */
public class ValidatingSink<T> extends RichSinkFunction<T> implements ListCheckpointed<HashMap<Long,Integer>> {
  /** 
 * Function to check if the window counts are as expected.
 */
@FunctionalInterface public interface ResultChecker extends Serializable {
    boolean checkResult(    Map<Long,Integer> windowCounts);
  }
  /** 
 * Function that updates the window counts from an update event.
 * @param < T > type of the update event.
 */
public interface CountUpdater<T> extends Serializable {
    void updateCount(    T update,    Map<Long,Integer> windowCounts);
  }
  @Nonnull private final ResultChecker resultChecker;
  @Nonnull private final CountUpdater<T> countUpdater;
  @Nonnull private final HashMap<Long,Integer> windowCounts;
  private final boolean usingProcessingTime;
  public ValidatingSink(  @Nonnull CountUpdater<T> countUpdater,  @Nonnull ResultChecker resultChecker){
    this(countUpdater,resultChecker,TimeCharacteristic.EventTime);
  }
  public ValidatingSink(  @Nonnull CountUpdater<T> countUpdater,  @Nonnull ResultChecker resultChecker,  @Nonnull TimeCharacteristic timeCharacteristic){
    this.resultChecker=resultChecker;
    this.countUpdater=countUpdater;
    this.usingProcessingTime=TimeCharacteristic.ProcessingTime == timeCharacteristic;
    this.windowCounts=new HashMap<>();
  }
  @Override public void open(  Configuration parameters) throws Exception {
    assertEquals(1,getRuntimeContext().getNumberOfParallelSubtasks());
    if (usingProcessingTime && resultChecker.checkResult(windowCounts)) {
      throw new SuccessException();
    }
  }
  @Override public void close(){
    if (resultChecker.checkResult(windowCounts)) {
      if (usingProcessingTime) {
        throw new SuccessException();
      }
    }
 else {
      throw new AssertionError("Test failed check.");
    }
  }
  @Override public void invoke(  T value,  Context context) throws Exception {
    countUpdater.updateCount(value,windowCounts);
    if (usingProcessingTime && resultChecker.checkResult(windowCounts)) {
      throw new SuccessException();
    }
  }
  @Override public List<HashMap<Long,Integer>> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(this.windowCounts);
  }
  @Override public void restoreState(  List<HashMap<Long,Integer>> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    windowCounts.putAll(state.get(0));
  }
}
