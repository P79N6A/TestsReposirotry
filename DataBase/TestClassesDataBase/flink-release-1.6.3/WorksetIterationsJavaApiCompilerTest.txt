/** 
 * Tests that validate optimizer choices when using operators that are requesting certain specific execution strategies.
 */
@SuppressWarnings("serial") public class WorksetIterationsJavaApiCompilerTest extends CompilerTestBase {
  private static final String JOIN_WITH_INVARIANT_NAME="Test Join Invariant";
  private static final String JOIN_WITH_SOLUTION_SET="Test Join SolutionSet";
  private static final String NEXT_WORKSET_REDUCER_NAME="Test Reduce Workset";
  private static final String SOLUTION_DELTA_MAPPER_NAME="Test Map Delta";
  @Test public void testJavaApiWithDeferredSoltionSetUpdateWithMapper(){
    try {
      Plan plan=getJavaTestPlan(false,true);
      OptimizedPlan oPlan=compileNoStats(plan);
      OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(oPlan);
      DualInputPlanNode joinWithInvariantNode=resolver.getNode(JOIN_WITH_INVARIANT_NAME);
      DualInputPlanNode joinWithSolutionSetNode=resolver.getNode(JOIN_WITH_SOLUTION_SET);
      SingleInputPlanNode worksetReducer=resolver.getNode(NEXT_WORKSET_REDUCER_NAME);
      SingleInputPlanNode deltaMapper=resolver.getNode(SOLUTION_DELTA_MAPPER_NAME);
      assertEquals(ShipStrategyType.FORWARD,joinWithInvariantNode.getInput1().getShipStrategy());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithInvariantNode.getInput2().getShipStrategy());
      assertEquals(new FieldList(1,2),joinWithInvariantNode.getKeysForInput1());
      assertEquals(new FieldList(1,2),joinWithInvariantNode.getKeysForInput2());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithSolutionSetNode.getInput1().getShipStrategy());
      assertEquals(ShipStrategyType.FORWARD,joinWithSolutionSetNode.getInput2().getShipStrategy());
      assertEquals(new FieldList(1,0),joinWithSolutionSetNode.getKeysForInput1());
      assertEquals(ShipStrategyType.PARTITION_HASH,worksetReducer.getInput().getShipStrategy());
      assertEquals(new FieldList(1,2),worksetReducer.getKeys(0));
      ShipStrategyType ss1=deltaMapper.getInput().getShipStrategy();
      ShipStrategyType ss2=deltaMapper.getOutgoingChannels().get(0).getShipStrategy();
      assertTrue((ss1 == ShipStrategyType.FORWARD && ss2 == ShipStrategyType.PARTITION_HASH) || (ss2 == ShipStrategyType.FORWARD && ss1 == ShipStrategyType.PARTITION_HASH));
      new JobGraphGenerator().compileJobGraph(oPlan);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test errored: " + e.getMessage());
    }
  }
  @Test public void testJavaApiWithDeferredSoltionSetUpdateWithNonPreservingJoin(){
    try {
      Plan plan=getJavaTestPlan(false,false);
      OptimizedPlan oPlan=compileNoStats(plan);
      OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(oPlan);
      DualInputPlanNode joinWithInvariantNode=resolver.getNode(JOIN_WITH_INVARIANT_NAME);
      DualInputPlanNode joinWithSolutionSetNode=resolver.getNode(JOIN_WITH_SOLUTION_SET);
      SingleInputPlanNode worksetReducer=resolver.getNode(NEXT_WORKSET_REDUCER_NAME);
      assertEquals(ShipStrategyType.FORWARD,joinWithInvariantNode.getInput1().getShipStrategy());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithInvariantNode.getInput2().getShipStrategy());
      assertEquals(new FieldList(1,2),joinWithInvariantNode.getKeysForInput1());
      assertEquals(new FieldList(1,2),joinWithInvariantNode.getKeysForInput2());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithSolutionSetNode.getInput1().getShipStrategy());
      assertEquals(ShipStrategyType.FORWARD,joinWithSolutionSetNode.getInput2().getShipStrategy());
      assertEquals(new FieldList(1,0),joinWithSolutionSetNode.getKeysForInput1());
      assertEquals(ShipStrategyType.PARTITION_HASH,worksetReducer.getInput().getShipStrategy());
      assertEquals(new FieldList(1,2),worksetReducer.getKeys(0));
      assertEquals(2,joinWithSolutionSetNode.getOutgoingChannels().size());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithSolutionSetNode.getOutgoingChannels().get(0).getShipStrategy());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithSolutionSetNode.getOutgoingChannels().get(1).getShipStrategy());
      new JobGraphGenerator().compileJobGraph(oPlan);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test errored: " + e.getMessage());
    }
  }
  @Test public void testJavaApiWithDirectSoltionSetUpdate(){
    try {
      Plan plan=getJavaTestPlan(true,false);
      OptimizedPlan oPlan=compileNoStats(plan);
      OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(oPlan);
      DualInputPlanNode joinWithInvariantNode=resolver.getNode(JOIN_WITH_INVARIANT_NAME);
      DualInputPlanNode joinWithSolutionSetNode=resolver.getNode(JOIN_WITH_SOLUTION_SET);
      SingleInputPlanNode worksetReducer=resolver.getNode(NEXT_WORKSET_REDUCER_NAME);
      assertEquals(ShipStrategyType.FORWARD,joinWithInvariantNode.getInput1().getShipStrategy());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithInvariantNode.getInput2().getShipStrategy());
      assertEquals(new FieldList(1,2),joinWithInvariantNode.getKeysForInput1());
      assertEquals(new FieldList(1,2),joinWithInvariantNode.getKeysForInput2());
      assertEquals(ShipStrategyType.PARTITION_HASH,joinWithSolutionSetNode.getInput1().getShipStrategy());
      assertEquals(ShipStrategyType.FORWARD,joinWithSolutionSetNode.getInput2().getShipStrategy());
      assertEquals(new FieldList(1,0),joinWithSolutionSetNode.getKeysForInput1());
      assertEquals(ShipStrategyType.FORWARD,worksetReducer.getInput().getShipStrategy());
      assertEquals(new FieldList(1,2),worksetReducer.getKeys(0));
      assertEquals(1,joinWithSolutionSetNode.getOutgoingChannels().size());
      assertEquals(ShipStrategyType.FORWARD,joinWithSolutionSetNode.getOutgoingChannels().get(0).getShipStrategy());
      new JobGraphGenerator().compileJobGraph(oPlan);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test errored: " + e.getMessage());
    }
  }
  @Test public void testRejectPlanIfSolutionSetKeysAndJoinKeysDontMatch(){
    try {
      ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      env.setParallelism(DEFAULT_PARALLELISM);
      @SuppressWarnings("unchecked") DataSet<Tuple3<Long,Long,Long>> solutionSetInput=env.fromElements(new Tuple3<Long,Long,Long>(1L,2L,3L)).name("Solution Set");
      @SuppressWarnings("unchecked") DataSet<Tuple3<Long,Long,Long>> worksetInput=env.fromElements(new Tuple3<Long,Long,Long>(1L,2L,3L)).name("Workset");
      @SuppressWarnings("unchecked") DataSet<Tuple3<Long,Long,Long>> invariantInput=env.fromElements(new Tuple3<Long,Long,Long>(1L,2L,3L)).name("Invariant Input");
      DeltaIteration<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>> iter=solutionSetInput.iterateDelta(worksetInput,100,1,2);
      DataSet<Tuple3<Long,Long,Long>> result=iter.getWorkset().join(invariantInput).where(1,2).equalTo(1,2).with(new JoinFunction<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>>(){
        public Tuple3<Long,Long,Long> join(        Tuple3<Long,Long,Long> first,        Tuple3<Long,Long,Long> second){
          return first;
        }
      }
);
      try {
        result.join(iter.getSolutionSet()).where(1,0).equalTo(0,2).with(new JoinFunction<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>>(){
          public Tuple3<Long,Long,Long> join(          Tuple3<Long,Long,Long> first,          Tuple3<Long,Long,Long> second){
            return second;
          }
        }
);
        fail("The join should be rejected with key type mismatches.");
      }
 catch (      InvalidProgramException e) {
      }
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test errored: " + e.getMessage());
    }
  }
  private Plan getJavaTestPlan(  boolean joinPreservesSolutionSet,  boolean mapBeforeSolutionDelta){
    ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(DEFAULT_PARALLELISM);
    @SuppressWarnings("unchecked") DataSet<Tuple3<Long,Long,Long>> solutionSetInput=env.fromElements(new Tuple3<Long,Long,Long>(1L,2L,3L)).name("Solution Set");
    @SuppressWarnings("unchecked") DataSet<Tuple3<Long,Long,Long>> worksetInput=env.fromElements(new Tuple3<Long,Long,Long>(1L,2L,3L)).name("Workset");
    @SuppressWarnings("unchecked") DataSet<Tuple3<Long,Long,Long>> invariantInput=env.fromElements(new Tuple3<Long,Long,Long>(1L,2L,3L)).name("Invariant Input");
    DeltaIteration<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>> iter=solutionSetInput.iterateDelta(worksetInput,100,1,2);
    DataSet<Tuple3<Long,Long,Long>> joinedWithSolutionSet=iter.getWorkset().join(invariantInput).where(1,2).equalTo(1,2).with(new RichJoinFunction<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>>(){
      public Tuple3<Long,Long,Long> join(      Tuple3<Long,Long,Long> first,      Tuple3<Long,Long,Long> second){
        return first;
      }
    }
).name(JOIN_WITH_INVARIANT_NAME).join(iter.getSolutionSet()).where(1,0).equalTo(1,2).with(new RichJoinFunction<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>>(){
      public Tuple3<Long,Long,Long> join(      Tuple3<Long,Long,Long> first,      Tuple3<Long,Long,Long> second){
        return second;
      }
    }
).name(JOIN_WITH_SOLUTION_SET).withForwardedFieldsSecond(joinPreservesSolutionSet ? new String[]{"0->0","1->1","2->2"} : null);
    DataSet<Tuple3<Long,Long,Long>> nextWorkset=joinedWithSolutionSet.groupBy(1,2).reduceGroup(new RichGroupReduceFunction<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>>(){
      public void reduce(      Iterable<Tuple3<Long,Long,Long>> values,      Collector<Tuple3<Long,Long,Long>> out){
      }
    }
).name(NEXT_WORKSET_REDUCER_NAME).withForwardedFields("1->1","2->2","0->0");
    DataSet<Tuple3<Long,Long,Long>> nextSolutionSet=mapBeforeSolutionDelta ? joinedWithSolutionSet.map(new RichMapFunction<Tuple3<Long,Long,Long>,Tuple3<Long,Long,Long>>(){
      public Tuple3<Long,Long,Long> map(      Tuple3<Long,Long,Long> value){
        return value;
      }
    }
).name(SOLUTION_DELTA_MAPPER_NAME).withForwardedFields("0->0","1->1","2->2") : joinedWithSolutionSet;
    iter.closeWith(nextSolutionSet,nextWorkset).output(new DiscardingOutputFormat<Tuple3<Long,Long,Long>>());
    return env.createProgramPlan();
  }
}
