/** 
 * Tests for the behavior of the barrier tracker.
 */
public class BarrierTrackerTest {
  private static final int PAGE_SIZE=512;
  @Test public void testSingleChannelNoBarriers(){
    try {
      BufferOrEvent[] sequence={createBuffer(0),createBuffer(0),createBuffer(0)};
      MockInputGate gate=new MockInputGate(PAGE_SIZE,1,Arrays.asList(sequence));
      BarrierTracker tracker=new BarrierTracker(gate);
      for (      BufferOrEvent boe : sequence) {
        assertEquals(boe,tracker.getNextNonBlocked());
      }
      assertNull(tracker.getNextNonBlocked());
      assertNull(tracker.getNextNonBlocked());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testMultiChannelNoBarriers(){
    try {
      BufferOrEvent[] sequence={createBuffer(2),createBuffer(2),createBuffer(0),createBuffer(1),createBuffer(0),createBuffer(3),createBuffer(1),createBuffer(1),createBuffer(2)};
      MockInputGate gate=new MockInputGate(PAGE_SIZE,4,Arrays.asList(sequence));
      BarrierTracker tracker=new BarrierTracker(gate);
      for (      BufferOrEvent boe : sequence) {
        assertEquals(boe,tracker.getNextNonBlocked());
      }
      assertNull(tracker.getNextNonBlocked());
      assertNull(tracker.getNextNonBlocked());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testSingleChannelWithBarriers(){
    try {
      BufferOrEvent[] sequence={createBuffer(0),createBuffer(0),createBuffer(0),createBarrier(1,0),createBuffer(0),createBuffer(0),createBuffer(0),createBuffer(0),createBarrier(2,0),createBarrier(3,0),createBuffer(0),createBuffer(0),createBarrier(4,0),createBarrier(5,0),createBarrier(6,0),createBuffer(0)};
      MockInputGate gate=new MockInputGate(PAGE_SIZE,1,Arrays.asList(sequence));
      BarrierTracker tracker=new BarrierTracker(gate);
      CheckpointSequenceValidator validator=new CheckpointSequenceValidator(1,2,3,4,5,6);
      tracker.registerCheckpointEventHandler(validator);
      for (      BufferOrEvent boe : sequence) {
        if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
          assertEquals(boe,tracker.getNextNonBlocked());
        }
      }
      assertNull(tracker.getNextNonBlocked());
      assertNull(tracker.getNextNonBlocked());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testSingleChannelWithSkippedBarriers(){
    try {
      BufferOrEvent[] sequence={createBuffer(0),createBarrier(1,0),createBuffer(0),createBuffer(0),createBarrier(3,0),createBuffer(0),createBarrier(4,0),createBarrier(6,0),createBuffer(0),createBarrier(7,0),createBuffer(0),createBarrier(10,0),createBuffer(0)};
      MockInputGate gate=new MockInputGate(PAGE_SIZE,1,Arrays.asList(sequence));
      BarrierTracker tracker=new BarrierTracker(gate);
      CheckpointSequenceValidator validator=new CheckpointSequenceValidator(1,3,4,6,7,10);
      tracker.registerCheckpointEventHandler(validator);
      for (      BufferOrEvent boe : sequence) {
        if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
          assertEquals(boe,tracker.getNextNonBlocked());
        }
      }
      assertNull(tracker.getNextNonBlocked());
      assertNull(tracker.getNextNonBlocked());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testMultiChannelWithBarriers(){
    try {
      BufferOrEvent[] sequence={createBuffer(0),createBuffer(2),createBuffer(0),createBarrier(1,1),createBarrier(1,2),createBuffer(2),createBuffer(1),createBarrier(1,0),createBuffer(0),createBuffer(0),createBuffer(1),createBuffer(1),createBuffer(2),createBarrier(2,0),createBarrier(2,1),createBarrier(2,2),createBuffer(2),createBuffer(2),createBarrier(3,2),createBuffer(2),createBuffer(2),createBarrier(3,0),createBarrier(3,1),createBarrier(4,1),createBarrier(4,2),createBarrier(4,0),createBuffer(0)};
      MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
      BarrierTracker tracker=new BarrierTracker(gate);
      CheckpointSequenceValidator validator=new CheckpointSequenceValidator(1,2,3,4);
      tracker.registerCheckpointEventHandler(validator);
      for (      BufferOrEvent boe : sequence) {
        if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
          assertEquals(boe,tracker.getNextNonBlocked());
        }
      }
      assertNull(tracker.getNextNonBlocked());
      assertNull(tracker.getNextNonBlocked());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testMultiChannelSkippingCheckpoints(){
    try {
      BufferOrEvent[] sequence={createBuffer(0),createBuffer(2),createBuffer(0),createBarrier(1,1),createBarrier(1,2),createBuffer(2),createBuffer(1),createBarrier(1,0),createBuffer(0),createBuffer(0),createBuffer(1),createBuffer(1),createBuffer(2),createBarrier(2,0),createBarrier(2,1),createBarrier(2,2),createBuffer(2),createBuffer(2),createBarrier(3,2),createBuffer(2),createBuffer(2),createBarrier(4,0),createBuffer(0),createBuffer(1),createBuffer(2),createBarrier(4,1),createBuffer(1),createBarrier(4,2),createBuffer(0)};
      MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
      BarrierTracker tracker=new BarrierTracker(gate);
      CheckpointSequenceValidator validator=new CheckpointSequenceValidator(1,2,4);
      tracker.registerCheckpointEventHandler(validator);
      for (      BufferOrEvent boe : sequence) {
        if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
          assertEquals(boe,tracker.getNextNonBlocked());
        }
      }
      assertNull(tracker.getNextNonBlocked());
      assertNull(tracker.getNextNonBlocked());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  /** 
 * This test validates that the barrier tracker does not immediately discard a pending checkpoint as soon as it sees a barrier from a later checkpoint from some channel. <p>This behavior is crucial, otherwise topologies where different inputs have different latency (and that latency is close to or higher than the checkpoint interval) may skip many checkpoints, or fail to complete a checkpoint all together.
 */
  @Test public void testCompleteCheckpointsOnLateBarriers(){
    try {
      BufferOrEvent[] sequence={createBuffer(1),createBuffer(1),createBuffer(0),createBuffer(2),createBarrier(2,1),createBarrier(2,0),createBarrier(2,2),createBuffer(1),createBuffer(0),createBarrier(3,1),createBarrier(3,2),createBuffer(1),createBuffer(0),createBarrier(4,2),createBarrier(4,1),createBuffer(1),createBuffer(2),createBarrier(3,0),createBuffer(0),createBarrier(4,0),createBuffer(1),createBuffer(2),createBarrier(5,1),createBuffer(0),createBarrier(5,0),createBuffer(1),createBarrier(5,2),createBuffer(1),createBarrier(6,1),createBuffer(0),createBarrier(6,0),createBuffer(1),createBarrier(7,1),createBuffer(0),createBarrier(7,2),createBuffer(2),createBarrier(8,2),createBuffer(0),createBarrier(8,1),createBuffer(1),createBarrier(9,1),createBarrier(7,0),createBuffer(0),createBarrier(9,2),createBuffer(2),createBarrier(10,2),createBarrier(8,0),createBuffer(1),createBuffer(2),createBarrier(9,0),createBuffer(1),createBuffer(0),createBuffer(2)};
      MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
      BarrierTracker tracker=new BarrierTracker(gate);
      CheckpointSequenceValidator validator=new CheckpointSequenceValidator(2,3,4,5,7,8,9);
      tracker.registerCheckpointEventHandler(validator);
      for (      BufferOrEvent boe : sequence) {
        if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
          assertEquals(boe,tracker.getNextNonBlocked());
        }
      }
      assertNull(tracker.getNextNonBlocked());
      assertNull(tracker.getNextNonBlocked());
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testSingleChannelAbortCheckpoint() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0),createBarrier(1,0),createBuffer(0),createBarrier(2,0),createCancellationBarrier(4,0),createBarrier(5,0),createBuffer(0),createCancellationBarrier(6,0),createBuffer(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,1,Arrays.asList(sequence));
    BarrierTracker tracker=new BarrierTracker(gate);
    CheckpointSequenceValidator validator=new CheckpointSequenceValidator(1,2,-4,5,-6);
    tracker.registerCheckpointEventHandler(validator);
    for (    BufferOrEvent boe : sequence) {
      if (boe.isBuffer()) {
        assertEquals(boe,tracker.getNextNonBlocked());
      }
      assertTrue(tracker.isEmpty());
    }
    assertNull(tracker.getNextNonBlocked());
    assertNull(tracker.getNextNonBlocked());
  }
  @Test public void testMultiChannelAbortCheckpoint() throws Exception {
    BufferOrEvent[] sequence={createBuffer(0),createBuffer(2),createBuffer(0),createBarrier(1,1),createBarrier(1,2),createBuffer(2),createBuffer(1),createBarrier(1,0),createBuffer(0),createBuffer(2),createBarrier(2,0),createBarrier(2,2),createBuffer(0),createBuffer(2),createCancellationBarrier(2,1),createBuffer(2),createBuffer(1),createBarrier(3,1),createBarrier(3,2),createBarrier(3,0),createBuffer(0),createBuffer(1),createCancellationBarrier(4,1),createBarrier(4,2),createBuffer(0),createBarrier(4,0),createBuffer(0),createBuffer(1),createBuffer(2),createBarrier(5,2),createBarrier(5,1),createBarrier(5,0),createBuffer(0),createBuffer(1),createCancellationBarrier(6,1),createCancellationBarrier(6,2),createBarrier(6,0),createBuffer(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierTracker tracker=new BarrierTracker(gate);
    CheckpointSequenceValidator validator=new CheckpointSequenceValidator(1,-2,3,-4,5,-6);
    tracker.registerCheckpointEventHandler(validator);
    for (    BufferOrEvent boe : sequence) {
      if (boe.isBuffer()) {
        assertEquals(boe,tracker.getNextNonBlocked());
      }
    }
    assertTrue(tracker.isEmpty());
    assertNull(tracker.getNextNonBlocked());
    assertNull(tracker.getNextNonBlocked());
    assertTrue(tracker.isEmpty());
  }
  /** 
 * Tests that each checkpoint is only aborted once in case of an interleaved cancellation barrier arrival of two consecutive checkpoints.
 */
  @Test public void testInterleavedCancellationBarriers() throws Exception {
    BufferOrEvent[] sequence={createBarrier(1L,0),createCancellationBarrier(2L,0),createCancellationBarrier(1L,1),createCancellationBarrier(2L,1),createCancellationBarrier(1L,2),createCancellationBarrier(2L,2),createBuffer(0)};
    MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
    BarrierTracker tracker=new BarrierTracker(gate);
    AbstractInvokable statefulTask=mock(AbstractInvokable.class);
    tracker.registerCheckpointEventHandler(statefulTask);
    for (    BufferOrEvent boe : sequence) {
      if (boe.isBuffer() || (boe.getEvent().getClass() != CheckpointBarrier.class && boe.getEvent().getClass() != CancelCheckpointMarker.class)) {
        assertEquals(boe,tracker.getNextNonBlocked());
      }
    }
    verify(statefulTask,times(1)).abortCheckpointOnBarrier(eq(1L),any(Throwable.class));
    verify(statefulTask,times(1)).abortCheckpointOnBarrier(eq(2L),any(Throwable.class));
  }
  private static BufferOrEvent createBarrier(  long id,  int channel){
    return new BufferOrEvent(new CheckpointBarrier(id,System.currentTimeMillis(),CheckpointOptions.forCheckpointWithDefaultLocation()),channel);
  }
  private static BufferOrEvent createCancellationBarrier(  long id,  int channel){
    return new BufferOrEvent(new CancelCheckpointMarker(id),channel);
  }
  private static BufferOrEvent createBuffer(  int channel){
    return new BufferOrEvent(new NetworkBuffer(MemorySegmentFactory.wrap(new byte[]{1,2}),FreeingBufferRecycler.INSTANCE),channel);
  }
private static class CheckpointSequenceValidator extends AbstractInvokable {
    private final long[] checkpointIDs;
    private int i=0;
    private CheckpointSequenceValidator(    long... checkpointIDs){
      super(new DummyEnvironment("test",1,0));
      this.checkpointIDs=checkpointIDs;
    }
    @Override public void invoke(){
      throw new UnsupportedOperationException("should never be called");
    }
    @Override public boolean triggerCheckpoint(    CheckpointMetaData checkpointMetaData,    CheckpointOptions checkpointOptions) throws Exception {
      throw new UnsupportedOperationException("should never be called");
    }
    @Override public void triggerCheckpointOnBarrier(    CheckpointMetaData checkpointMetaData,    CheckpointOptions checkpointOptions,    CheckpointMetrics checkpointMetrics) throws Exception {
      assertTrue("More checkpoints than expected",i < checkpointIDs.length);
      final long expectedId=checkpointIDs[i++];
      if (expectedId >= 0) {
        assertEquals("wrong checkpoint id",expectedId,checkpointMetaData.getCheckpointId());
        assertTrue(checkpointMetaData.getTimestamp() > 0);
      }
 else {
        fail("got 'triggerCheckpointOnBarrier()' when expecting an 'abortCheckpointOnBarrier()'");
      }
    }
    @Override public void abortCheckpointOnBarrier(    long checkpointId,    Throwable cause){
      assertTrue("More checkpoints than expected",i < checkpointIDs.length);
      final long expectedId=checkpointIDs[i++];
      if (expectedId < 0) {
        assertEquals("wrong checkpoint id for checkpoint abort",-expectedId,checkpointId);
      }
 else {
        fail("got 'abortCheckpointOnBarrier()' when expecting an 'triggerCheckpointOnBarrier()'");
      }
    }
    @Override public void notifyCheckpointComplete(    long checkpointId) throws Exception {
      throw new UnsupportedOperationException("should never be called");
    }
  }
}
