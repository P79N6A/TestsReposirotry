/** 
 * Tests for the  {@link InstantiationUtil}.
 */
public class InstantiationUtilTest extends TestLogger {
  @Test public void testInstantiationOfStringValue(){
    StringValue stringValue=InstantiationUtil.instantiate(StringValue.class,null);
    assertNotNull(stringValue);
  }
  @Test public void testInstantiationOfStringValueAndCastToValue(){
    StringValue stringValue=InstantiationUtil.instantiate(StringValue.class,Value.class);
    assertNotNull(stringValue);
  }
  @Test public void testHasNullaryConstructor(){
    assertTrue(InstantiationUtil.hasPublicNullaryConstructor(StringValue.class));
  }
  @Test public void testClassIsProper(){
    assertTrue(InstantiationUtil.isProperClass(StringValue.class));
  }
  @Test public void testClassIsNotProper(){
    assertFalse(InstantiationUtil.isProperClass(Value.class));
  }
  @Test(expected=RuntimeException.class) public void testCheckForInstantiationOfPrivateClass(){
    InstantiationUtil.checkForInstantiation(TestClass.class);
  }
  @Test public void testSerializationToByteArray() throws IOException {
    final DoubleValue toSerialize=new DoubleValue(Math.random());
    final DoubleValueSerializer serializer=new DoubleValueSerializer();
    byte[] serialized=InstantiationUtil.serializeToByteArray(serializer,toSerialize);
    DoubleValue deserialized=InstantiationUtil.deserializeFromByteArray(serializer,serialized);
    assertEquals("Serialized record is not equal after serialization.",toSerialize,deserialized);
  }
  @Test public void testWriteToConfigFailingSerialization(){
    try {
      final String key1="testkey1";
      final String key2="testkey2";
      final Configuration config=new Configuration();
      try {
        InstantiationUtil.writeObjectToConfig(new TestClassWriteFails(),config,"irgnored");
        fail("should throw an exception");
      }
 catch (      TestException e) {
      }
catch (      Exception e) {
        fail("Wrong exception type - exception not properly forwarded");
      }
      InstantiationUtil.writeObjectToConfig(new TestClassReadFails(),config,key1);
      InstantiationUtil.writeObjectToConfig(new TestClassReadFailsCNF(),config,key2);
      try {
        InstantiationUtil.readObjectFromConfig(config,key1,getClass().getClassLoader());
        fail("should throw an exception");
      }
 catch (      TestException e) {
      }
catch (      Exception e) {
        fail("Wrong exception type - exception not properly forwarded");
      }
      try {
        InstantiationUtil.readObjectFromConfig(config,key2,getClass().getClassLoader());
        fail("should throw an exception");
      }
 catch (      ClassNotFoundException e) {
      }
catch (      Exception e) {
        fail("Wrong exception type - exception not properly forwarded");
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testCopyWritable() throws Exception {
    WritableType original=new WritableType();
    WritableType copy=InstantiationUtil.createCopyWritable(original);
    assertTrue(original != copy);
    assertTrue(original.equals(copy));
  }
private class TestClass {
  }
private static class TestException extends IOException {
    private static final long serialVersionUID=1L;
  }
private static class TestClassWriteFails implements java.io.Serializable {
    private static final long serialVersionUID=1L;
    private void writeObject(    ObjectOutputStream out) throws IOException {
      throw new TestException();
    }
  }
private static class TestClassReadFails implements java.io.Serializable {
    private static final long serialVersionUID=1L;
    private void readObject(    ObjectInputStream in) throws IOException, ClassNotFoundException {
      throw new TestException();
    }
  }
private static class TestClassReadFailsCNF implements java.io.Serializable {
    private static final long serialVersionUID=1L;
    private void readObject(    ObjectInputStream in) throws IOException, ClassNotFoundException {
      throw new ClassNotFoundException("test exception");
    }
  }
  /** 
 * A simple test type. 
 */
public static final class WritableType implements IOReadableWritable {
    private int aInt;
    private long aLong;
    public WritableType(){
      Random rnd=new Random();
      this.aInt=rnd.nextInt();
      this.aLong=rnd.nextLong();
    }
    @Override public int hashCode(){
      return Objects.hash(aInt,aLong);
    }
    @Override public boolean equals(    Object obj){
      if (obj == this) {
        return true;
      }
 else       if (obj != null && obj.getClass() == WritableType.class) {
        WritableType that=(WritableType)obj;
        return this.aLong == that.aLong && this.aInt == that.aInt;
      }
 else {
        return false;
      }
    }
    @Override public void write(    DataOutputView out) throws IOException {
      out.writeInt(aInt);
      out.writeLong(aLong);
    }
    @Override public void read(    DataInputView in) throws IOException {
      this.aInt=in.readInt();
      this.aLong=in.readLong();
    }
  }
}
