/** 
 * Tests for  {@link GenericWriteAheadSink}.
 */
public class GenericWriteAheadSinkTest extends WriteAheadSinkTestBase<Tuple1<Integer>,GenericWriteAheadSinkTest.ListSink> {
  @Override protected ListSink createSink() throws Exception {
    return new ListSink();
  }
  @Override protected TupleTypeInfo<Tuple1<Integer>> createTypeInfo(){
    return TupleTypeInfo.getBasicTupleTypeInfo(Integer.class);
  }
  @Override protected Tuple1<Integer> generateValue(  int counter,  int checkpointID){
    return new Tuple1<>(counter);
  }
  @Override protected void verifyResultsIdealCircumstances(  ListSink sink){
    ArrayList<Integer> list=new ArrayList<>();
    for (int x=1; x <= 60; x++) {
      list.add(x);
    }
    for (    Integer i : sink.values) {
      list.remove(i);
    }
    Assert.assertTrue("The following ID's where not found in the result list: " + list.toString(),list.isEmpty());
    Assert.assertTrue("The sink emitted to many values: " + (sink.values.size() - 60),sink.values.size() == 60);
  }
  @Override protected void verifyResultsDataPersistenceUponMissedNotify(  ListSink sink){
    ArrayList<Integer> list=new ArrayList<>();
    for (int x=1; x <= 60; x++) {
      list.add(x);
    }
    for (    Integer i : sink.values) {
      list.remove(i);
    }
    Assert.assertTrue("The following ID's where not found in the result list: " + list.toString(),list.isEmpty());
    Assert.assertTrue("The sink emitted to many values: " + (sink.values.size() - 60),sink.values.size() == 60);
  }
  @Override protected void verifyResultsDataDiscardingUponRestore(  ListSink sink){
    ArrayList<Integer> list=new ArrayList<>();
    for (int x=1; x <= 20; x++) {
      list.add(x);
    }
    for (int x=41; x <= 60; x++) {
      list.add(x);
    }
    for (    Integer i : sink.values) {
      list.remove(i);
    }
    Assert.assertTrue("The following ID's where not found in the result list: " + list.toString(),list.isEmpty());
    Assert.assertTrue("The sink emitted to many values: " + (sink.values.size() - 40),sink.values.size() == 40);
  }
  @Override protected void verifyResultsWhenReScaling(  ListSink sink,  int startElementCounter,  int endElementCounter) throws Exception {
    ArrayList<Integer> list=new ArrayList<>();
    for (int i=startElementCounter; i <= endElementCounter; i++) {
      list.add(i);
    }
    Collections.sort(sink.values);
    Assert.assertArrayEquals(list.toArray(),sink.values.toArray());
  }
  @Test public void testCommitterException() throws Exception {
    ListSink2 sink=new ListSink2();
    OneInputStreamOperatorTestHarness<Tuple1<Integer>,Tuple1<Integer>> testHarness=new OneInputStreamOperatorTestHarness<>(sink);
    testHarness.open();
    int elementCounter=1;
    for (int x=0; x < 10; x++) {
      testHarness.processElement(new StreamRecord<>(generateValue(elementCounter,0)));
      elementCounter++;
    }
    testHarness.snapshot(0,0);
    testHarness.notifyOfCompletedCheckpoint(0);
    Assert.assertEquals(0,sink.values.size());
    for (int x=0; x < 11; x++) {
      testHarness.processElement(new StreamRecord<>(generateValue(elementCounter,1)));
      elementCounter++;
    }
    testHarness.snapshot(1,0);
    testHarness.notifyOfCompletedCheckpoint(1);
    Assert.assertEquals(10,sink.values.size());
    for (int x=0; x < 12; x++) {
      testHarness.processElement(new StreamRecord<>(generateValue(elementCounter,2)));
      elementCounter++;
    }
    testHarness.snapshot(2,0);
    testHarness.notifyOfCompletedCheckpoint(2);
    Assert.assertEquals(43,sink.values.size());
  }
  /** 
 * Simple sink that stores all records in a public list.
 */
public static class ListSink extends GenericWriteAheadSink<Tuple1<Integer>> {
    private static final long serialVersionUID=1L;
    public List<Integer> values=new ArrayList<>();
    public ListSink() throws Exception {
      super(new SimpleCommitter(),TypeExtractor.getForObject(new Tuple1<>(1)).createSerializer(new ExecutionConfig()),"job");
    }
    @Override protected boolean sendValues(    Iterable<Tuple1<Integer>> values,    long checkpointId,    long timestamp) throws Exception {
      for (      Tuple1<Integer> value : values) {
        this.values.add(value.f0);
      }
      return true;
    }
  }
private static class SimpleCommitter extends CheckpointCommitter {
    private static final long serialVersionUID=1L;
    private List<Tuple2<Long,Integer>> checkpoints;
    @Override public void open() throws Exception {
    }
    @Override public void close() throws Exception {
    }
    @Override public void createResource() throws Exception {
      checkpoints=new ArrayList<>();
    }
    @Override public void commitCheckpoint(    int subtaskIdx,    long checkpointID){
      checkpoints.add(new Tuple2<>(checkpointID,subtaskIdx));
    }
    @Override public boolean isCheckpointCommitted(    int subtaskIdx,    long checkpointID){
      return checkpoints.contains(new Tuple2<>(checkpointID,subtaskIdx));
    }
  }
  /** 
 * Simple sink that stores all records in a public list.
 */
public static class ListSink2 extends GenericWriteAheadSink<Tuple1<Integer>> {
    private static final long serialVersionUID=1L;
    public List<Integer> values=new ArrayList<>();
    public ListSink2() throws Exception {
      super(new FailingCommitter(),TypeExtractor.getForObject(new Tuple1<>(1)).createSerializer(new ExecutionConfig()),"job");
    }
    @Override protected boolean sendValues(    Iterable<Tuple1<Integer>> values,    long checkpointId,    long timestamp) throws Exception {
      for (      Tuple1<Integer> value : values) {
        this.values.add(value.f0);
      }
      return true;
    }
  }
private static class FailingCommitter extends CheckpointCommitter {
    private static final long serialVersionUID=1L;
    private List<Tuple2<Long,Integer>> checkpoints;
    private boolean failIsCommitted=true;
    private boolean failCommit=true;
    @Override public void open() throws Exception {
    }
    @Override public void close() throws Exception {
    }
    @Override public void createResource() throws Exception {
      checkpoints=new ArrayList<>();
    }
    @Override public void commitCheckpoint(    int subtaskIdx,    long checkpointID){
      if (failCommit) {
        failCommit=false;
        throw new RuntimeException("Expected exception");
      }
 else {
        checkpoints.add(new Tuple2<>(checkpointID,subtaskIdx));
      }
    }
    @Override public boolean isCheckpointCommitted(    int subtaskIdx,    long checkpointID){
      if (failIsCommitted) {
        failIsCommitted=false;
        throw new RuntimeException("Expected exception");
      }
 else {
        return false;
      }
    }
  }
}
