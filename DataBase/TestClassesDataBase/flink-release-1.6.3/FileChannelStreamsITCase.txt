public class FileChannelStreamsITCase extends TestLogger {
  private static final long SEED=649180756312423613L;
  private static final int KEY_MAX=Integer.MAX_VALUE;
  private static final int VALUE_SHORT_LENGTH=114;
  private static final int VALUE_LONG_LENGTH=112 * 1024;
  private static final int NUM_PAIRS_SHORT=1000000;
  private static final int NUM_PAIRS_LONG=3000;
  private static final int MEMORY_PAGE_SIZE=32 * 1024;
  private static final int NUM_MEMORY_SEGMENTS=3;
  private IOManager ioManager;
  private MemoryManager memManager;
  @Before public void beforeTest(){
    memManager=new MemoryManager(NUM_MEMORY_SEGMENTS * MEMORY_PAGE_SIZE,1,MEMORY_PAGE_SIZE,MemoryType.HEAP,true);
    ioManager=new IOManagerAsync();
  }
  @After public void afterTest(){
    ioManager.shutdown();
    assertTrue("I/O Manager was not properly shut down.",ioManager.isProperlyShutDown());
    assertTrue("The memory has not been properly released",memManager.verifyEmpty());
  }
  @Test public void testWriteReadSmallRecords(){
    try {
      List<MemorySegment> memory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final PairGenerator generator=new PairGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
      final FileIOChannel.ID channel=ioManager.createChannel();
      final BlockChannelWriter<MemorySegment> writer=ioManager.createBlockChannelWriter(channel);
      final FileChannelOutputView outView=new FileChannelOutputView(writer,memManager,memory,MEMORY_PAGE_SIZE);
      Pair pair=new Pair();
      for (int i=0; i < NUM_PAIRS_SHORT; i++) {
        generator.next(pair);
        pair.write(outView);
      }
      outView.close();
      List<MemorySegment> readMemory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final BlockChannelReader<MemorySegment> reader=ioManager.createBlockChannelReader(channel);
      final FileChannelInputView inView=new FileChannelInputView(reader,memManager,readMemory,outView.getBytesInLatestSegment());
      generator.reset();
      Pair readPair=new Pair();
      for (int i=0; i < NUM_PAIRS_SHORT; i++) {
        generator.next(pair);
        readPair.read(inView);
        assertEquals("The re-generated and the read record do not match.",pair,readPair);
      }
      inView.close();
      reader.deleteChannel();
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testWriteAndReadLongRecords(){
    try {
      final List<MemorySegment> memory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final PairGenerator generator=new PairGenerator(SEED,KEY_MAX,VALUE_LONG_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
      final FileIOChannel.ID channel=this.ioManager.createChannel();
      final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
      final FileChannelOutputView outView=new FileChannelOutputView(writer,memManager,memory,MEMORY_PAGE_SIZE);
      Pair pair=new Pair();
      for (int i=0; i < NUM_PAIRS_LONG; i++) {
        generator.next(pair);
        pair.write(outView);
      }
      outView.close();
      List<MemorySegment> readMemory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final BlockChannelReader<MemorySegment> reader=ioManager.createBlockChannelReader(channel);
      final FileChannelInputView inView=new FileChannelInputView(reader,memManager,readMemory,outView.getBytesInLatestSegment());
      generator.reset();
      Pair readPair=new Pair();
      for (int i=0; i < NUM_PAIRS_LONG; i++) {
        generator.next(pair);
        readPair.read(inView);
        assertEquals("The re-generated and the read record do not match.",pair,readPair);
      }
      inView.close();
      reader.deleteChannel();
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testReadTooMany(){
    try {
      final List<MemorySegment> memory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final PairGenerator generator=new PairGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
      final FileIOChannel.ID channel=this.ioManager.createChannel();
      final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
      final FileChannelOutputView outView=new FileChannelOutputView(writer,memManager,memory,MEMORY_PAGE_SIZE);
      Pair pair=new Pair();
      for (int i=0; i < NUM_PAIRS_SHORT; i++) {
        generator.next(pair);
        pair.write(outView);
      }
      outView.close();
      List<MemorySegment> readMemory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final BlockChannelReader<MemorySegment> reader=ioManager.createBlockChannelReader(channel);
      final FileChannelInputView inView=new FileChannelInputView(reader,memManager,readMemory,outView.getBytesInLatestSegment());
      generator.reset();
      try {
        Pair readPair=new Pair();
        for (int i=0; i < NUM_PAIRS_SHORT + 1; i++) {
          generator.next(pair);
          readPair.read(inView);
          assertEquals("The re-generated and the read record do not match.",pair,readPair);
        }
        fail("Expected an EOFException which did not occur.");
      }
 catch (      EOFException eofex) {
      }
      inView.close();
      reader.deleteChannel();
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testWriteReadOneBufferOnly(){
    try {
      final List<MemorySegment> memory=memManager.allocatePages(new DummyInvokable(),1);
      final PairGenerator generator=new PairGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
      final FileIOChannel.ID channel=this.ioManager.createChannel();
      final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
      final FileChannelOutputView outView=new FileChannelOutputView(writer,memManager,memory,MEMORY_PAGE_SIZE);
      Pair pair=new Pair();
      for (int i=0; i < NUM_PAIRS_SHORT; i++) {
        generator.next(pair);
        pair.write(outView);
      }
      outView.close();
      List<MemorySegment> readMemory=memManager.allocatePages(new DummyInvokable(),1);
      final BlockChannelReader<MemorySegment> reader=ioManager.createBlockChannelReader(channel);
      final FileChannelInputView inView=new FileChannelInputView(reader,memManager,readMemory,outView.getBytesInLatestSegment());
      generator.reset();
      Pair readPair=new Pair();
      for (int i=0; i < NUM_PAIRS_SHORT; i++) {
        generator.next(pair);
        readPair.read(inView);
        assertEquals("The re-generated and the read record do not match.",pair,readPair);
      }
      inView.close();
      reader.deleteChannel();
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  @Test public void testWriteReadNotAll(){
    try {
      final List<MemorySegment> memory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final PairGenerator generator=new PairGenerator(SEED,KEY_MAX,VALUE_SHORT_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
      final FileIOChannel.ID channel=this.ioManager.createChannel();
      final BlockChannelWriter<MemorySegment> writer=this.ioManager.createBlockChannelWriter(channel);
      final FileChannelOutputView outView=new FileChannelOutputView(writer,memManager,memory,MEMORY_PAGE_SIZE);
      Pair pair=new Pair();
      for (int i=0; i < NUM_PAIRS_SHORT; i++) {
        generator.next(pair);
        pair.write(outView);
      }
      outView.close();
      List<MemorySegment> readMemory=memManager.allocatePages(new DummyInvokable(),NUM_MEMORY_SEGMENTS);
      final BlockChannelReader<MemorySegment> reader=ioManager.createBlockChannelReader(channel);
      final FileChannelInputView inView=new FileChannelInputView(reader,memManager,readMemory,outView.getBytesInLatestSegment());
      generator.reset();
      Pair readPair=new Pair();
      for (int i=0; i < NUM_PAIRS_SHORT / 2; i++) {
        generator.next(pair);
        readPair.read(inView);
        assertEquals("The re-generated and the read record do not match.",pair,readPair);
      }
      inView.close();
      reader.deleteChannel();
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
}
