/** 
 * Test savepoint migration.
 */
public abstract class SavepointMigrationTestBase extends TestBaseUtils {
  @BeforeClass public static void before(){
    SavepointSerializers.setFailWhenLegacyStateDetected(false);
  }
  @ClassRule public static final TemporaryFolder TEMP_FOLDER=new TemporaryFolder();
  @Rule public final MiniClusterResource miniClusterResource;
  private static final Logger LOG=LoggerFactory.getLogger(SavepointMigrationTestBase.class);
  private static final Deadline DEADLINE=new FiniteDuration(5,TimeUnit.MINUTES).fromNow();
  protected static final int DEFAULT_PARALLELISM=4;
  protected static String getResourceFilename(  String filename){
    ClassLoader cl=SavepointMigrationTestBase.class.getClassLoader();
    URL resource=cl.getResource(filename);
    if (resource == null) {
      throw new NullPointerException("Missing snapshot resource.");
    }
    return resource.getFile();
  }
  protected SavepointMigrationTestBase() throws Exception {
    miniClusterResource=new MiniClusterResource(new MiniClusterResourceConfiguration.Builder().setConfiguration(getConfiguration()).setNumberTaskManagers(1).setNumberSlotsPerTaskManager(DEFAULT_PARALLELISM).build());
  }
  private Configuration getConfiguration() throws Exception {
    final Configuration config=new Configuration();
    config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER,1);
    config.setInteger(TaskManagerOptions.NUM_TASK_SLOTS,DEFAULT_PARALLELISM);
    UUID id=UUID.randomUUID();
    final File checkpointDir=TEMP_FOLDER.newFolder("checkpoints_" + id).getAbsoluteFile();
    final File savepointDir=TEMP_FOLDER.newFolder("savepoints_" + id).getAbsoluteFile();
    if (!checkpointDir.exists() || !savepointDir.exists()) {
      throw new Exception("Test setup failed: failed to create (temporary) directories.");
    }
    LOG.info("Created temporary checkpoint directory: " + checkpointDir + ".");
    LOG.info("Created savepoint directory: " + savepointDir + ".");
    config.setString(CheckpointingOptions.STATE_BACKEND,"memory");
    config.setString(CheckpointingOptions.CHECKPOINTS_DIRECTORY,checkpointDir.toURI().toString());
    config.setInteger(CheckpointingOptions.FS_SMALL_FILE_THRESHOLD,0);
    config.setString(CheckpointingOptions.SAVEPOINT_DIRECTORY,savepointDir.toURI().toString());
    return config;
  }
  @SafeVarargs protected final void executeAndSavepoint(  StreamExecutionEnvironment env,  String savepointPath,  Tuple2<String,Integer>... expectedAccumulators) throws Exception {
    ClusterClient<?> client=miniClusterResource.getClusterClient();
    client.setDetached(true);
    JobGraph jobGraph=env.getStreamGraph().getJobGraph();
    JobSubmissionResult jobSubmissionResult=client.submitJob(jobGraph,SavepointMigrationTestBase.class.getClassLoader());
    LOG.info("Submitted job {} and waiting...",jobSubmissionResult.getJobID());
    boolean done=false;
    while (DEADLINE.hasTimeLeft()) {
      Thread.sleep(100);
      Map<String,OptionalFailure<Object>> accumulators=client.getAccumulators(jobSubmissionResult.getJobID());
      boolean allDone=true;
      for (      Tuple2<String,Integer> acc : expectedAccumulators) {
        OptionalFailure<Object> accumOpt=accumulators.get(acc.f0);
        if (accumOpt == null) {
          allDone=false;
          break;
        }
        Integer numFinished=(Integer)accumOpt.get();
        if (numFinished == null) {
          allDone=false;
          break;
        }
        if (!numFinished.equals(acc.f1)) {
          allDone=false;
          break;
        }
      }
      if (allDone) {
        done=true;
        break;
      }
    }
    if (!done) {
      fail("Did not see the expected accumulator results within time limit.");
    }
    LOG.info("Triggering savepoint.");
    CompletableFuture<String> savepointPathFuture=client.triggerSavepoint(jobSubmissionResult.getJobID(),null);
    String jobmanagerSavepointPath=savepointPathFuture.get(DEADLINE.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    File jobManagerSavepoint=new File(new URI(jobmanagerSavepointPath).getPath());
    if (jobManagerSavepoint.isDirectory()) {
      FileUtils.moveDirectory(jobManagerSavepoint,new File(savepointPath));
    }
 else {
      FileUtils.moveFile(jobManagerSavepoint,new File(savepointPath));
    }
  }
  @SafeVarargs protected final void restoreAndExecute(  StreamExecutionEnvironment env,  String savepointPath,  Tuple2<String,Integer>... expectedAccumulators) throws Exception {
    ClusterClient<?> client=miniClusterResource.getClusterClient();
    client.setDetached(true);
    JobGraph jobGraph=env.getStreamGraph().getJobGraph();
    jobGraph.setSavepointRestoreSettings(SavepointRestoreSettings.forPath(savepointPath));
    JobSubmissionResult jobSubmissionResult=client.submitJob(jobGraph,SavepointMigrationTestBase.class.getClassLoader());
    boolean done=false;
    while (DEADLINE.hasTimeLeft()) {
      JobID jobId=jobSubmissionResult.getJobID();
      try {
        CompletableFuture<JobStatus> jobStatusFuture=client.getJobStatus(jobSubmissionResult.getJobID());
        JobStatus jobStatus=jobStatusFuture.get(5,TimeUnit.SECONDS);
        assertNotEquals(JobStatus.FAILED,jobStatus);
      }
 catch (      Exception e) {
        fail("Could not connect to job: " + e);
      }
      Thread.sleep(100);
      Map<String,OptionalFailure<Object>> accumulators=client.getAccumulators(jobId);
      boolean allDone=true;
      for (      Tuple2<String,Integer> acc : expectedAccumulators) {
        OptionalFailure<Object> numFinished=accumulators.get(acc.f0);
        if (numFinished == null) {
          allDone=false;
          break;
        }
        if (!numFinished.get().equals(acc.f1)) {
          allDone=false;
          break;
        }
      }
      if (allDone) {
        done=true;
        break;
      }
    }
    if (!done) {
      fail("Did not see the expected accumulator results within time limit.");
    }
  }
}
