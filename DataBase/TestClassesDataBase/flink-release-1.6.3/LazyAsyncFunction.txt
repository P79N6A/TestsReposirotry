/** 
 * A special  {@link AsyncFunction} without issuing{@link ResultFuture#complete} until the latch counts to zero.This function is used in the testStateSnapshotAndRestore, ensuring that  {@link StreamElementQueueEntry} can stayin the  {@link StreamElementQueue} to besnapshotted while checkpointing.
 */
private static class LazyAsyncFunction extends MyAsyncFunction {
  private static final long serialVersionUID=3537791752703154670L;
  private static CountDownLatch latch;
  public LazyAsyncFunction(){
    latch=new CountDownLatch(1);
  }
  @Override public void asyncInvoke(  final Integer input,  final ResultFuture<Integer> resultFuture) throws Exception {
    this.executorService.submit(new Runnable(){
      @Override public void run(){
        try {
          latch.await();
        }
 catch (        InterruptedException e) {
        }
        resultFuture.complete(Collections.singletonList(input));
      }
    }
);
  }
  public static void countDown(){
    latch.countDown();
  }
}
