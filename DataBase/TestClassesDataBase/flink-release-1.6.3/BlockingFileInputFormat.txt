private static class BlockingFileInputFormat extends FileInputFormat<String> implements CheckpointableInputFormat<FileInputSplit,Integer> {
  private final OneShotLatch triggerLatch;
  private final OneShotLatch waitingLatch;
  private final int elementsBeforeCheckpoint;
  private final int linesPerSplit;
  private FileInputSplit split;
  private int state;
  BlockingFileInputFormat(  OneShotLatch triggerLatch,  OneShotLatch waitingLatch,  Path filePath,  int sizeOfSplit,  int elementsBeforeCheckpoint){
    super(filePath);
    this.triggerLatch=triggerLatch;
    this.waitingLatch=waitingLatch;
    this.elementsBeforeCheckpoint=elementsBeforeCheckpoint;
    this.linesPerSplit=sizeOfSplit;
    this.state=0;
  }
  @Override public FileInputSplit[] createInputSplits(  int minNumSplits) throws IOException {
    FileInputSplit[] splits=new FileInputSplit[minNumSplits];
    for (int i=0; i < minNumSplits; i++) {
      splits[i]=new FileInputSplit(i,getFilePaths()[0],i * linesPerSplit + 1,linesPerSplit,null);
    }
    return splits;
  }
  @Override public void open(  FileInputSplit fileSplit) throws IOException {
    this.split=fileSplit;
    this.state=0;
  }
  @Override public void reopen(  FileInputSplit split,  Integer state) throws IOException {
    this.split=split;
    this.state=state;
  }
  @Override public Integer getCurrentState() throws IOException {
    return state;
  }
  @Override public boolean reachedEnd() throws IOException {
    if (state == elementsBeforeCheckpoint) {
      triggerLatch.trigger();
      if (!waitingLatch.isTriggered()) {
        try {
          waitingLatch.await();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
    return state == linesPerSplit;
  }
  @Override public String nextRecord(  String reuse) throws IOException {
    return reachedEnd() ? null : split.getSplitNumber() + ": test line " + state++;
  }
}
