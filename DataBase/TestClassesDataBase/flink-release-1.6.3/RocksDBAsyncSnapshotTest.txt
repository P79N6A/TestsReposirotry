/** 
 * Tests for asynchronous RocksDB Key/Value state checkpoints.
 */
@RunWith(PowerMockRunner.class) @PowerMockIgnore({"javax.management.*","com.sun.jndi.*","org.apache.log4j.*"}) @SuppressWarnings("serial") public class RocksDBAsyncSnapshotTest extends TestLogger {
  /** 
 * Temporary fold for test.
 */
  @Rule public final TemporaryFolder temporaryFolder=new TemporaryFolder();
  /** 
 * This ensures that asynchronous state handles are actually materialized asynchronously. <p>We use latches to block at various stages and see if the code still continues through the parts that are not asynchronous. If the checkpoint is not done asynchronously the test will simply lock forever.
 */
  @Test public void testFullyAsyncSnapshot() throws Exception {
    final OneInputStreamTaskTestHarness<String,String> testHarness=new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    testHarness.configureForKeyedStream(new KeySelector<String,String>(){
      @Override public String getKey(      String value) throws Exception {
        return value;
      }
    }
,BasicTypeInfo.STRING_TYPE_INFO);
    StreamConfig streamConfig=testHarness.getStreamConfig();
    File dbDir=temporaryFolder.newFolder();
    RocksDBStateBackend backend=new RocksDBStateBackend(new MemoryStateBackend());
    backend.setDbStoragePath(dbDir.getAbsolutePath());
    streamConfig.setStateBackend(backend);
    streamConfig.setStreamOperator(new AsyncCheckpointOperator());
    streamConfig.setOperatorID(new OperatorID());
    final OneShotLatch delayCheckpointLatch=new OneShotLatch();
    final OneShotLatch ensureCheckpointLatch=new OneShotLatch();
    CheckpointResponder checkpointResponderMock=new CheckpointResponder(){
      @Override public void acknowledgeCheckpoint(      JobID jobID,      ExecutionAttemptID executionAttemptID,      long checkpointId,      CheckpointMetrics checkpointMetrics,      TaskStateSnapshot subtaskState){
        try {
          delayCheckpointLatch.await();
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
        boolean hasManagedKeyedState=false;
        for (        Map.Entry<OperatorID,OperatorSubtaskState> entry : subtaskState.getSubtaskStateMappings()) {
          OperatorSubtaskState state=entry.getValue();
          if (state != null) {
            hasManagedKeyedState|=state.getManagedKeyedState() != null;
          }
        }
        assertTrue(hasManagedKeyedState);
        ensureCheckpointLatch.trigger();
      }
      @Override public void declineCheckpoint(      JobID jobID,      ExecutionAttemptID executionAttemptID,      long checkpointId,      Throwable cause){
      }
    }
;
    JobID jobID=new JobID();
    ExecutionAttemptID executionAttemptID=new ExecutionAttemptID(0L,0L);
    TestTaskStateManager taskStateManagerTestMock=new TestTaskStateManager(jobID,executionAttemptID,checkpointResponderMock,TestLocalRecoveryConfig.disabled());
    StreamMockEnvironment mockEnv=new StreamMockEnvironment(testHarness.jobConfig,testHarness.taskConfig,testHarness.memorySize,new MockInputSplitProvider(),testHarness.bufferSize,taskStateManagerTestMock);
    testHarness.invoke(mockEnv);
    final OneInputStreamTask<String,String> task=testHarness.getTask();
    for (    Field field : StreamTask.class.getDeclaredFields()) {
      if (field.getName().equals("isRunning")) {
        field.setAccessible(true);
        while (!field.getBoolean(task)) {
          Thread.sleep(10);
        }
      }
    }
    task.triggerCheckpoint(new CheckpointMetaData(42,17),CheckpointOptions.forCheckpointWithDefaultLocation());
    testHarness.processElement(new StreamRecord<>("Wohoo",0));
    delayCheckpointLatch.trigger();
    ensureCheckpointLatch.await();
    testHarness.endInput();
    ExecutorService threadPool=task.getAsyncOperationsThreadPool();
    threadPool.shutdown();
    Assert.assertTrue(threadPool.awaitTermination(60_000,TimeUnit.MILLISECONDS));
    testHarness.waitForTaskCompletion();
    if (mockEnv.wasFailedExternally()) {
      fail("Unexpected exception during execution.");
    }
  }
  /** 
 * This tests ensures that canceling of asynchronous snapshots works as expected and does not block.
 */
  @Test public void testCancelFullyAsyncCheckpoints() throws Exception {
    final OneInputStreamTaskTestHarness<String,String> testHarness=new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    testHarness.configureForKeyedStream(value -> value,BasicTypeInfo.STRING_TYPE_INFO);
    StreamConfig streamConfig=testHarness.getStreamConfig();
    File dbDir=temporaryFolder.newFolder();
    final RocksDBStateBackend.PriorityQueueStateType timerServicePriorityQueueType=RocksDBStateBackend.PriorityQueueStateType.valueOf(RocksDBOptions.TIMER_SERVICE_FACTORY.defaultValue());
    final int skipStreams;
    if (timerServicePriorityQueueType == RocksDBStateBackend.PriorityQueueStateType.HEAP) {
      skipStreams=1;
    }
 else     if (timerServicePriorityQueueType == RocksDBStateBackend.PriorityQueueStateType.ROCKSDB) {
      skipStreams=0;
    }
 else {
      throw new AssertionError(String.format("Unknown timer service priority queue type %s.",timerServicePriorityQueueType));
    }
    BlockerCheckpointStreamFactory blockerCheckpointStreamFactory=new BlockerCheckpointStreamFactory(4 * 1024 * 1024){
      int count=skipStreams;
      @Override public CheckpointStateOutputStream createCheckpointStateOutputStream(      CheckpointedStateScope scope) throws IOException {
        if (count > 0) {
          --count;
          return new BlockingCheckpointOutputStream(new MemCheckpointStreamFactory.MemoryCheckpointOutputStream(maxSize),null,null,Integer.MAX_VALUE);
        }
 else {
          return super.createCheckpointStateOutputStream(scope);
        }
      }
    }
;
    StateBackend stateBackend=new BackendForTestStream(new StaticForwardFactory(blockerCheckpointStreamFactory));
    RocksDBStateBackend backend=new RocksDBStateBackend(stateBackend);
    backend.setDbStoragePath(dbDir.getAbsolutePath());
    streamConfig.setStateBackend(backend);
    streamConfig.setStreamOperator(new AsyncCheckpointOperator());
    streamConfig.setOperatorID(new OperatorID());
    TestTaskStateManager taskStateManagerTestMock=new TestTaskStateManager();
    StreamMockEnvironment mockEnv=new StreamMockEnvironment(testHarness.jobConfig,testHarness.taskConfig,testHarness.memorySize,new MockInputSplitProvider(),testHarness.bufferSize,taskStateManagerTestMock);
    blockerCheckpointStreamFactory.setBlockerLatch(new OneShotLatch());
    blockerCheckpointStreamFactory.setWaiterLatch(new OneShotLatch());
    testHarness.invoke(mockEnv);
    final OneInputStreamTask<String,String> task=testHarness.getTask();
    for (    Field field : StreamTask.class.getDeclaredFields()) {
      if (field.getName().equals("isRunning")) {
        field.setAccessible(true);
        while (!field.getBoolean(task)) {
          Thread.sleep(10);
        }
      }
    }
    task.triggerCheckpoint(new CheckpointMetaData(42,17),CheckpointOptions.forCheckpointWithDefaultLocation());
    testHarness.processElement(new StreamRecord<>("Wohoo",0));
    blockerCheckpointStreamFactory.getWaiterLatch().await();
    task.cancel();
    blockerCheckpointStreamFactory.getBlockerLatch().trigger();
    testHarness.endInput();
    ExecutorService threadPool=task.getAsyncOperationsThreadPool();
    threadPool.shutdown();
    Assert.assertTrue(threadPool.awaitTermination(60_000,TimeUnit.MILLISECONDS));
    Set<BlockingCheckpointOutputStream> createdStreams=blockerCheckpointStreamFactory.getAllCreatedStreams();
    for (    BlockingCheckpointOutputStream stream : createdStreams) {
      Assert.assertTrue("Not all of the " + createdStreams.size() + " created streams have been closed.",stream.isClosed());
    }
    try {
      testHarness.waitForTaskCompletion();
      fail("Operation completed. Cancel failed.");
    }
 catch (    Exception expected) {
      Throwable cause=expected.getCause();
      if (!(cause instanceof CancelTaskException)) {
        fail("Unexpected exception: " + expected);
      }
    }
  }
  /** 
 * Test that the snapshot files are cleaned up in case of a failure during the snapshot procedure.
 */
  @Test public void testCleanupOfSnapshotsInFailureCase() throws Exception {
    long checkpointId=1L;
    long timestamp=42L;
    Environment env=new DummyEnvironment("test task",1,0);
    final IOException testException=new IOException("Test exception");
    CheckpointStateOutputStream outputStream=spy(new FailingStream(testException));
    RocksDBStateBackend backend=new RocksDBStateBackend((StateBackend)new MemoryStateBackend());
    backend.setDbStoragePath(temporaryFolder.newFolder().toURI().toString());
    AbstractKeyedStateBackend<Void> keyedStateBackend=backend.createKeyedStateBackend(env,new JobID(),"test operator",VoidSerializer.INSTANCE,1,new KeyGroupRange(0,0),null);
    try {
      keyedStateBackend.restore(null);
      keyedStateBackend.getPartitionedState("namespace",StringSerializer.INSTANCE,new ValueStateDescriptor<>("foobar",String.class));
      RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotFuture=keyedStateBackend.snapshot(checkpointId,timestamp,new TestCheckpointStreamFactory(() -> outputStream),CheckpointOptions.forCheckpointWithDefaultLocation());
      try {
        FutureUtil.runIfNotDoneAndGet(snapshotFuture);
        fail("Expected an exception to be thrown here.");
      }
 catch (      ExecutionException e) {
        Assert.assertEquals(testException,e.getCause());
      }
      verify(outputStream).close();
    }
  finally {
      IOUtils.closeQuietly(keyedStateBackend);
      keyedStateBackend.dispose();
    }
  }
  @Test public void testConsistentSnapshotSerializationFlagsAndMasks(){
    Assert.assertEquals(0xFFFF,RocksDBKeyedStateBackend.RocksDBFullSnapshotOperation.END_OF_KEY_GROUP_MARK);
    Assert.assertEquals(0x80,RocksDBKeyedStateBackend.RocksDBFullSnapshotOperation.FIRST_BIT_IN_BYTE_MASK);
    byte[] expectedKey=new byte[]{42,42};
    byte[] modKey=expectedKey.clone();
    Assert.assertFalse(RocksDBKeyedStateBackend.RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(modKey));
    RocksDBKeyedStateBackend.RocksDBFullSnapshotOperation.setMetaDataFollowsFlagInKey(modKey);
    Assert.assertTrue(RocksDBKeyedStateBackend.RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(modKey));
    RocksDBKeyedStateBackend.RocksDBFullSnapshotOperation.clearMetaDataFollowsFlag(modKey);
    Assert.assertFalse(RocksDBKeyedStateBackend.RocksDBFullSnapshotOperation.hasMetaDataFollowsFlag(modKey));
    Assert.assertTrue(Arrays.equals(expectedKey,modKey));
  }
private static class AsyncCheckpointOperator extends AbstractStreamOperator<String> implements OneInputStreamOperator<String,String> {
    @Override public void open() throws Exception {
      super.open();
      ValueState<String> state=getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,new ValueStateDescriptor<>("count",StringSerializer.INSTANCE));
    }
    @Override public void processElement(    StreamRecord<String> element) throws Exception {
      ValueState<String> state=getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,new ValueStateDescriptor<>("count",StringSerializer.INSTANCE));
      state.update(element.getValue());
    }
  }
private static class StaticForwardFactory implements StreamFactory {
    static CheckpointStreamFactory factory;
    StaticForwardFactory(    CheckpointStreamFactory factory){
      StaticForwardFactory.factory=factory;
    }
    @Override public CheckpointStateOutputStream get() throws IOException {
      return factory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE);
    }
  }
private static class FailingStream extends CheckpointStateOutputStream {
    private final IOException testException;
    FailingStream(    IOException testException){
      this.testException=testException;
    }
    @Nullable @Override public StreamStateHandle closeAndGetHandle() throws IOException {
      throw new UnsupportedOperationException();
    }
    @Override public long getPos() throws IOException {
      throw new UnsupportedOperationException();
    }
    @Override public void write(    int b) throws IOException {
      throw testException;
    }
    @Override public void flush() throws IOException {
      throw testException;
    }
    @Override public void sync() throws IOException {
      throw testException;
    }
    @Override public void close() throws IOException {
      throw new UnsupportedOperationException();
    }
  }
}
