private static class OnceFailingPartitionedSum extends RichMapFunction<Integer,Tuple2<Integer,Long>> implements ListCheckpointed<Integer> {
  private static final Map<Integer,Long> ALL_SUMS=new ConcurrentHashMap<>();
  private final int failurePos;
  private int count;
  private boolean shouldFail=true;
  private transient ValueState<Long> sum;
  OnceFailingPartitionedSum(  int failurePos){
    this.failurePos=failurePos;
  }
  @Override public void open(  Configuration parameters) throws IOException {
    sum=getRuntimeContext().getState(new ValueStateDescriptor<>("my_state",Long.class));
  }
  @Override public Tuple2<Integer,Long> map(  Integer value) throws Exception {
    if (shouldFail && count++ >= failurePos) {
      shouldFail=false;
      throw new Exception("Test Failure");
    }
    Long oldSum=sum.value();
    long currentSum=(oldSum == null ? 0L : oldSum) + value;
    sum.update(currentSum);
    ALL_SUMS.put(value,currentSum);
    return new Tuple2<>(value,currentSum);
  }
  @Override public List<Integer> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(count);
  }
  @Override public void restoreState(  List<Integer> state) throws Exception {
    assertEquals("Test failed due to unexpected recovered state size",1,state.size());
    count=state.get(0);
    shouldFail=false;
  }
  @Override public void close() throws Exception {
    if (shouldFail) {
      fail("Test ineffective: Function cleanly finished without ever failing.");
    }
  }
}
