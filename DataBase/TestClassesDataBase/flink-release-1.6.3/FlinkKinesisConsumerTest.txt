/** 
 * Suite of FlinkKinesisConsumer tests for the methods called throughout the source life cycle.
 */
@RunWith(PowerMockRunner.class) @PrepareForTest({FlinkKinesisConsumer.class,KinesisConfigUtil.class}) public class FlinkKinesisConsumerTest {
  @Rule private ExpectedException exception=ExpectedException.none();
  @Test public void testUseRestoredStateForSnapshotIfFetcherNotInitialized() throws Exception {
    Properties config=TestUtils.getStandardProperties();
    List<Tuple2<StreamShardMetadata,SequenceNumber>> globalUnionState=new ArrayList<>(4);
    globalUnionState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0)))),new SequenceNumber("1")));
    globalUnionState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1)))),new SequenceNumber("1")));
    globalUnionState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2)))),new SequenceNumber("1")));
    globalUnionState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(3)))),new SequenceNumber("1")));
    TestingListState<Tuple2<StreamShardMetadata,SequenceNumber>> listState=new TestingListState<>();
    for (    Tuple2<StreamShardMetadata,SequenceNumber> state : globalUnionState) {
      listState.add(state);
    }
    FlinkKinesisConsumer<String> consumer=new FlinkKinesisConsumer<>("fakeStream",new SimpleStringSchema(),config);
    RuntimeContext context=mock(RuntimeContext.class);
    when(context.getIndexOfThisSubtask()).thenReturn(0);
    when(context.getNumberOfParallelSubtasks()).thenReturn(2);
    consumer.setRuntimeContext(context);
    OperatorStateStore operatorStateStore=mock(OperatorStateStore.class);
    when(operatorStateStore.getUnionListState(Matchers.any(ListStateDescriptor.class))).thenReturn(listState);
    StateInitializationContext initializationContext=mock(StateInitializationContext.class);
    when(initializationContext.getOperatorStateStore()).thenReturn(operatorStateStore);
    when(initializationContext.isRestored()).thenReturn(true);
    consumer.initializeState(initializationContext);
    consumer.open(new Configuration());
    consumer.snapshotState(new StateSnapshotContextSynchronousImpl(123,123));
    assertTrue(listState.isClearCalled());
    assertEquals(globalUnionState.size() / 2,listState.getList().size());
    assertTrue(listState.getList().contains(globalUnionState.get(0)));
    assertTrue(listState.getList().contains(globalUnionState.get(2)));
  }
  @Test public void testListStateChangedAfterSnapshotState() throws Exception {
    Properties config=TestUtils.getStandardProperties();
    ArrayList<Tuple2<StreamShardMetadata,SequenceNumber>> initialState=new ArrayList<>(1);
    initialState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0)))),new SequenceNumber("1")));
    ArrayList<Tuple2<StreamShardMetadata,SequenceNumber>> expectedStateSnapshot=new ArrayList<>(3);
    expectedStateSnapshot.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0)))),new SequenceNumber("12")));
    expectedStateSnapshot.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1)))),new SequenceNumber("11")));
    expectedStateSnapshot.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2)))),new SequenceNumber("31")));
    TestingListState<Tuple2<StreamShardMetadata,SequenceNumber>> listState=new TestingListState<>();
    for (    Tuple2<StreamShardMetadata,SequenceNumber> state : initialState) {
      listState.add(state);
    }
    OperatorStateStore operatorStateStore=mock(OperatorStateStore.class);
    when(operatorStateStore.getUnionListState(Matchers.any(ListStateDescriptor.class))).thenReturn(listState);
    StateInitializationContext initializationContext=mock(StateInitializationContext.class);
    when(initializationContext.getOperatorStateStore()).thenReturn(operatorStateStore);
    when(initializationContext.isRestored()).thenReturn(true);
    HashMap<StreamShardMetadata,SequenceNumber> stateSnapshot=new HashMap<>();
    for (    Tuple2<StreamShardMetadata,SequenceNumber> tuple : expectedStateSnapshot) {
      stateSnapshot.put(tuple.f0,tuple.f1);
    }
    KinesisDataFetcher mockedFetcher=mock(KinesisDataFetcher.class);
    when(mockedFetcher.snapshotState()).thenReturn(stateSnapshot);
    FlinkKinesisConsumer<String> consumer=new FlinkKinesisConsumer<>("fakeStream",new SimpleStringSchema(),config);
    FlinkKinesisConsumer<?> mockedConsumer=spy(consumer);
    RuntimeContext context=mock(RuntimeContext.class);
    when(context.getIndexOfThisSubtask()).thenReturn(1);
    mockedConsumer.setRuntimeContext(context);
    mockedConsumer.initializeState(initializationContext);
    mockedConsumer.open(new Configuration());
    Whitebox.setInternalState(mockedConsumer,"fetcher",mockedFetcher);
    mockedConsumer.snapshotState(mock(FunctionSnapshotContext.class));
    assertEquals(true,listState.clearCalled);
    assertEquals(3,listState.getList().size());
    for (    Tuple2<StreamShardMetadata,SequenceNumber> state : initialState) {
      for (      Tuple2<StreamShardMetadata,SequenceNumber> currentState : listState.getList()) {
        assertNotEquals(state,currentState);
      }
    }
    for (    Tuple2<StreamShardMetadata,SequenceNumber> state : expectedStateSnapshot) {
      boolean hasOneIsSame=false;
      for (      Tuple2<StreamShardMetadata,SequenceNumber> currentState : listState.getList()) {
        hasOneIsSame=hasOneIsSame || state.equals(currentState);
      }
      assertEquals(true,hasOneIsSame);
    }
  }
  @Test @SuppressWarnings("unchecked") public void testFetcherShouldNotBeRestoringFromFailureIfNotRestoringFromCheckpoint() throws Exception {
    KinesisDataFetcher mockedFetcher=Mockito.mock(KinesisDataFetcher.class);
    PowerMockito.whenNew(KinesisDataFetcher.class).withAnyArguments().thenReturn(mockedFetcher);
    PowerMockito.mockStatic(KinesisConfigUtil.class);
    PowerMockito.doNothing().when(KinesisConfigUtil.class);
    TestableFlinkKinesisConsumer consumer=new TestableFlinkKinesisConsumer("fakeStream",new Properties(),10,2);
    consumer.open(new Configuration());
    consumer.run(Mockito.mock(SourceFunction.SourceContext.class));
  }
  @Test @SuppressWarnings("unchecked") public void testFetcherShouldBeCorrectlySeededIfRestoringFromCheckpoint() throws Exception {
    HashMap<StreamShardHandle,SequenceNumber> fakeRestoredState=getFakeRestoredStore("all");
    TestingListState<Tuple2<StreamShardMetadata,SequenceNumber>> listState=new TestingListState<>();
    for (    Map.Entry<StreamShardHandle,SequenceNumber> state : fakeRestoredState.entrySet()) {
      listState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(state.getKey()),state.getValue()));
    }
    OperatorStateStore operatorStateStore=mock(OperatorStateStore.class);
    when(operatorStateStore.getUnionListState(Matchers.any(ListStateDescriptor.class))).thenReturn(listState);
    StateInitializationContext initializationContext=mock(StateInitializationContext.class);
    when(initializationContext.getOperatorStateStore()).thenReturn(operatorStateStore);
    when(initializationContext.isRestored()).thenReturn(true);
    KinesisDataFetcher mockedFetcher=Mockito.mock(KinesisDataFetcher.class);
    List<StreamShardHandle> shards=new ArrayList<>();
    shards.addAll(fakeRestoredState.keySet());
    when(mockedFetcher.discoverNewShardsToSubscribe()).thenReturn(shards);
    PowerMockito.whenNew(KinesisDataFetcher.class).withAnyArguments().thenReturn(mockedFetcher);
    PowerMockito.mockStatic(KinesisConfigUtil.class);
    PowerMockito.doNothing().when(KinesisConfigUtil.class);
    TestableFlinkKinesisConsumer consumer=new TestableFlinkKinesisConsumer("fakeStream",new Properties(),10,2);
    consumer.initializeState(initializationContext);
    consumer.open(new Configuration());
    consumer.run(Mockito.mock(SourceFunction.SourceContext.class));
    for (    Map.Entry<StreamShardHandle,SequenceNumber> restoredShard : fakeRestoredState.entrySet()) {
      Mockito.verify(mockedFetcher).registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredShard.getKey()),restoredShard.getKey(),restoredShard.getValue()));
    }
  }
  @Test @SuppressWarnings("unchecked") public void testFetcherShouldBeCorrectlySeededOnlyItsOwnStates() throws Exception {
    HashMap<StreamShardHandle,SequenceNumber> fakeRestoredState=getFakeRestoredStore("fakeStream1");
    HashMap<StreamShardHandle,SequenceNumber> fakeRestoredStateForOthers=getFakeRestoredStore("fakeStream2");
    TestingListState<Tuple2<StreamShardMetadata,SequenceNumber>> listState=new TestingListState<>();
    for (    Map.Entry<StreamShardHandle,SequenceNumber> state : fakeRestoredState.entrySet()) {
      listState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(state.getKey()),state.getValue()));
    }
    for (    Map.Entry<StreamShardHandle,SequenceNumber> state : fakeRestoredStateForOthers.entrySet()) {
      listState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(state.getKey()),state.getValue()));
    }
    OperatorStateStore operatorStateStore=mock(OperatorStateStore.class);
    when(operatorStateStore.getUnionListState(Matchers.any(ListStateDescriptor.class))).thenReturn(listState);
    StateInitializationContext initializationContext=mock(StateInitializationContext.class);
    when(initializationContext.getOperatorStateStore()).thenReturn(operatorStateStore);
    when(initializationContext.isRestored()).thenReturn(true);
    KinesisDataFetcher mockedFetcher=Mockito.mock(KinesisDataFetcher.class);
    List<StreamShardHandle> shards=new ArrayList<>();
    shards.addAll(fakeRestoredState.keySet());
    when(mockedFetcher.discoverNewShardsToSubscribe()).thenReturn(shards);
    PowerMockito.whenNew(KinesisDataFetcher.class).withAnyArguments().thenReturn(mockedFetcher);
    PowerMockito.mockStatic(KinesisConfigUtil.class);
    PowerMockito.doNothing().when(KinesisConfigUtil.class);
    TestableFlinkKinesisConsumer consumer=new TestableFlinkKinesisConsumer("fakeStream",new Properties(),10,2);
    consumer.initializeState(initializationContext);
    consumer.open(new Configuration());
    consumer.run(Mockito.mock(SourceFunction.SourceContext.class));
    for (    Map.Entry<StreamShardHandle,SequenceNumber> restoredShard : fakeRestoredStateForOthers.entrySet()) {
      Mockito.verify(mockedFetcher,never()).registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredShard.getKey()),restoredShard.getKey(),restoredShard.getValue()));
    }
    for (    Map.Entry<StreamShardHandle,SequenceNumber> restoredShard : fakeRestoredState.entrySet()) {
      Mockito.verify(mockedFetcher).registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredShard.getKey()),restoredShard.getKey(),restoredShard.getValue()));
    }
  }
  @Test @SuppressWarnings("unchecked") public void testFetcherShouldBeCorrectlySeededWithNewDiscoveredKinesisStreamShard() throws Exception {
    HashMap<StreamShardHandle,SequenceNumber> fakeRestoredState=getFakeRestoredStore("all");
    TestingListState<Tuple2<StreamShardMetadata,SequenceNumber>> listState=new TestingListState<>();
    for (    Map.Entry<StreamShardHandle,SequenceNumber> state : fakeRestoredState.entrySet()) {
      listState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(state.getKey()),state.getValue()));
    }
    OperatorStateStore operatorStateStore=mock(OperatorStateStore.class);
    when(operatorStateStore.getUnionListState(Matchers.any(ListStateDescriptor.class))).thenReturn(listState);
    StateInitializationContext initializationContext=mock(StateInitializationContext.class);
    when(initializationContext.getOperatorStateStore()).thenReturn(operatorStateStore);
    when(initializationContext.isRestored()).thenReturn(true);
    KinesisDataFetcher mockedFetcher=Mockito.mock(KinesisDataFetcher.class);
    List<StreamShardHandle> shards=new ArrayList<>();
    shards.addAll(fakeRestoredState.keySet());
    shards.add(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2))));
    when(mockedFetcher.discoverNewShardsToSubscribe()).thenReturn(shards);
    PowerMockito.whenNew(KinesisDataFetcher.class).withAnyArguments().thenReturn(mockedFetcher);
    PowerMockito.mockStatic(KinesisConfigUtil.class);
    PowerMockito.doNothing().when(KinesisConfigUtil.class);
    TestableFlinkKinesisConsumer consumer=new TestableFlinkKinesisConsumer("fakeStream",new Properties(),10,2);
    consumer.initializeState(initializationContext);
    consumer.open(new Configuration());
    consumer.run(Mockito.mock(SourceFunction.SourceContext.class));
    fakeRestoredState.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2))),SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get());
    for (    Map.Entry<StreamShardHandle,SequenceNumber> restoredShard : fakeRestoredState.entrySet()) {
      Mockito.verify(mockedFetcher).registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(restoredShard.getKey()),restoredShard.getKey(),restoredShard.getValue()));
    }
  }
  @Test public void testLegacyKinesisStreamShardToStreamShardMetadataConversion(){
    String streamName="fakeStream1";
    String shardId="shard-000001";
    String parentShardId="shard-000002";
    String adjacentParentShardId="shard-000003";
    String startingHashKey="key-000001";
    String endingHashKey="key-000010";
    String startingSequenceNumber="seq-0000021";
    String endingSequenceNumber="seq-00000031";
    StreamShardMetadata streamShardMetadata=new StreamShardMetadata();
    streamShardMetadata.setStreamName(streamName);
    streamShardMetadata.setShardId(shardId);
    streamShardMetadata.setParentShardId(parentShardId);
    streamShardMetadata.setAdjacentParentShardId(adjacentParentShardId);
    streamShardMetadata.setStartingHashKey(startingHashKey);
    streamShardMetadata.setEndingHashKey(endingHashKey);
    streamShardMetadata.setStartingSequenceNumber(startingSequenceNumber);
    streamShardMetadata.setEndingSequenceNumber(endingSequenceNumber);
    Shard shard=new Shard().withShardId(shardId).withParentShardId(parentShardId).withAdjacentParentShardId(adjacentParentShardId).withHashKeyRange(new HashKeyRange().withStartingHashKey(startingHashKey).withEndingHashKey(endingHashKey)).withSequenceNumberRange(new SequenceNumberRange().withStartingSequenceNumber(startingSequenceNumber).withEndingSequenceNumber(endingSequenceNumber));
    KinesisStreamShard kinesisStreamShard=new KinesisStreamShard(streamName,shard);
    assertEquals(streamShardMetadata,KinesisStreamShard.convertToStreamShardMetadata(kinesisStreamShard));
  }
  @Test public void testStreamShardMetadataSerializedUsingPojoSerializer(){
    TypeInformation<StreamShardMetadata> typeInformation=TypeInformation.of(StreamShardMetadata.class);
    assertTrue(typeInformation.createSerializer(new ExecutionConfig()) instanceof PojoSerializer);
  }
  /** 
 * FLINK-8484: ensure that a state change in the StreamShardMetadata other than  {@link StreamShardMetadata#shardId} or{@link StreamShardMetadata#streamName} does not result in the shard not being able to be restored.This handles the corner case where the stored shard metadata is open (no ending sequence number), but after the job restore, the shard has been closed (ending number set) due to re-sharding, and we can no longer rely on {@link StreamShardMetadata#equals(Object)} to find back the sequence number in the collection of restored shard metadata.<p></p> Therefore, we will rely on synchronizing the snapshot's state with the Kinesis shard before attempting to find back the sequence number to restore.
 */
  @Test public void testFindSequenceNumberToRestoreFromIfTheShardHasBeenClosedSinceTheStateWasStored() throws Exception {
    HashMap<StreamShardHandle,SequenceNumber> fakeRestoredState=getFakeRestoredStore("all");
    TestingListState<Tuple2<StreamShardMetadata,SequenceNumber>> listState=new TestingListState<>();
    for (    Map.Entry<StreamShardHandle,SequenceNumber> state : fakeRestoredState.entrySet()) {
      listState.add(Tuple2.of(KinesisDataFetcher.convertToStreamShardMetadata(state.getKey()),state.getValue()));
    }
    OperatorStateStore operatorStateStore=mock(OperatorStateStore.class);
    when(operatorStateStore.getUnionListState(Matchers.any(ListStateDescriptor.class))).thenReturn(listState);
    StateInitializationContext initializationContext=mock(StateInitializationContext.class);
    when(initializationContext.getOperatorStateStore()).thenReturn(operatorStateStore);
    when(initializationContext.isRestored()).thenReturn(true);
    KinesisDataFetcher mockedFetcher=Mockito.mock(KinesisDataFetcher.class);
    List<StreamShardHandle> shards=new ArrayList<>();
    final StreamShardHandle originalStreamShardHandle=fakeRestoredState.keySet().iterator().next();
    final StreamShardHandle closedStreamShardHandle=new StreamShardHandle(originalStreamShardHandle.getStreamName(),originalStreamShardHandle.getShard());
    final SequenceNumberRange sequenceNumberRange=new SequenceNumberRange();
    sequenceNumberRange.setEndingSequenceNumber("1293844");
    closedStreamShardHandle.getShard().setSequenceNumberRange(sequenceNumberRange);
    shards.add(closedStreamShardHandle);
    when(mockedFetcher.discoverNewShardsToSubscribe()).thenReturn(shards);
    PowerMockito.whenNew(KinesisDataFetcher.class).withAnyArguments().thenReturn(mockedFetcher);
    PowerMockito.mockStatic(KinesisConfigUtil.class);
    PowerMockito.doNothing().when(KinesisConfigUtil.class);
    TestableFlinkKinesisConsumer consumer=new TestableFlinkKinesisConsumer("fakeStream",new Properties(),10,2);
    consumer.initializeState(initializationContext);
    consumer.open(new Configuration());
    consumer.run(Mockito.mock(SourceFunction.SourceContext.class));
    Mockito.verify(mockedFetcher).registerNewSubscribedShardState(new KinesisStreamShardState(KinesisDataFetcher.convertToStreamShardMetadata(closedStreamShardHandle),closedStreamShardHandle,fakeRestoredState.get(closedStreamShardHandle)));
  }
private static final class TestingListState<T> implements ListState<T> {
    private final List<T> list=new ArrayList<>();
    private boolean clearCalled=false;
    @Override public void clear(){
      list.clear();
      clearCalled=true;
    }
    @Override public Iterable<T> get() throws Exception {
      return list;
    }
    @Override public void add(    T value) throws Exception {
      list.add(value);
    }
    public List<T> getList(){
      return list;
    }
    public boolean isClearCalled(){
      return clearCalled;
    }
    @Override public void update(    List<T> values) throws Exception {
      list.clear();
      addAll(values);
    }
    @Override public void addAll(    List<T> values) throws Exception {
      if (values != null) {
        list.addAll(values);
      }
    }
  }
  private HashMap<StreamShardHandle,SequenceNumber> getFakeRestoredStore(  String streamName){
    HashMap<StreamShardHandle,SequenceNumber> fakeRestoredState=new HashMap<>();
    if (streamName.equals("fakeStream1") || streamName.equals("all")) {
      fakeRestoredState.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),new SequenceNumber(UUID.randomUUID().toString()));
      fakeRestoredState.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),new SequenceNumber(UUID.randomUUID().toString()));
      fakeRestoredState.put(new StreamShardHandle("fakeStream1",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(2))),new SequenceNumber(UUID.randomUUID().toString()));
    }
    if (streamName.equals("fakeStream2") || streamName.equals("all")) {
      fakeRestoredState.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(0))),new SequenceNumber(UUID.randomUUID().toString()));
      fakeRestoredState.put(new StreamShardHandle("fakeStream2",new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(1))),new SequenceNumber(UUID.randomUUID().toString()));
    }
    return fakeRestoredState;
  }
  /** 
 * A non-serializable  {@link KinesisDeserializationSchema} (because it is a nested class with referenceto the enclosing class, which is not serializable) used for testing.
 */
private final class NonSerializableDeserializationSchema implements KinesisDeserializationSchema<String> {
    @Override public String deserialize(    byte[] recordValue,    String partitionKey,    String seqNum,    long approxArrivalTimestamp,    String stream,    String shardId) throws IOException {
      return new String(recordValue);
    }
    @Override public TypeInformation<String> getProducedType(){
      return BasicTypeInfo.STRING_TYPE_INFO;
    }
  }
  /** 
 * A static, serializable  {@link KinesisDeserializationSchema}.
 */
private static final class SerializableDeserializationSchema implements KinesisDeserializationSchema<String> {
    @Override public String deserialize(    byte[] recordValue,    String partitionKey,    String seqNum,    long approxArrivalTimestamp,    String stream,    String shardId) throws IOException {
      return new String(recordValue);
    }
    @Override public TypeInformation<String> getProducedType(){
      return BasicTypeInfo.STRING_TYPE_INFO;
    }
  }
}
