/** 
 * Test ExecutionEnvironment from user perspective.
 */
@SuppressWarnings("serial") public class ExecutionEnvironmentITCase extends TestLogger {
  private static final int PARALLELISM=5;
  /** 
 * Ensure that the user can pass a custom configuration object to the LocalEnvironment.
 */
  @Test public void testLocalEnvironmentWithConfig() throws Exception {
    Configuration conf=new Configuration();
    conf.setInteger(TaskManagerOptions.NUM_TASK_SLOTS,PARALLELISM);
    final ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(conf);
    env.setParallelism(ExecutionConfig.PARALLELISM_AUTO_MAX);
    env.getConfig().disableSysoutLogging();
    DataSet<Integer> result=env.createInput(new ParallelismDependentInputFormat()).rebalance().mapPartition(new RichMapPartitionFunction<Integer,Integer>(){
      @Override public void mapPartition(      Iterable<Integer> values,      Collector<Integer> out) throws Exception {
        out.collect(getRuntimeContext().getIndexOfThisSubtask());
      }
    }
);
    List<Integer> resultCollection=result.collect();
    assertEquals(PARALLELISM,resultCollection.size());
  }
private static class ParallelismDependentInputFormat extends GenericInputFormat<Integer> {
    private transient boolean emitted;
    @Override public GenericInputSplit[] createInputSplits(    int numSplits) throws IOException {
      assertEquals(PARALLELISM,numSplits);
      return super.createInputSplits(numSplits);
    }
    @Override public boolean reachedEnd(){
      return emitted;
    }
    @Override public Integer nextRecord(    Integer reuse){
      if (emitted) {
        return null;
      }
      emitted=true;
      return 1;
    }
  }
}
