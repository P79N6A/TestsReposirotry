/** 
 * Tests for verifying file staging during submission to YARN works.
 */
public class YarnFileStageTest extends TestLogger {
  @ClassRule public static final TemporaryFolder CLASS_TEMP_DIR=new TemporaryFolder();
  @Rule public TemporaryFolder tempFolder=new TemporaryFolder();
  private static MiniDFSCluster hdfsCluster;
  private static Path hdfsRootPath;
  private org.apache.hadoop.conf.Configuration hadoopConfig;
  @BeforeClass public static void createHDFS() throws Exception {
    Assume.assumeTrue(!OperatingSystem.isWindows());
    final File tempDir=CLASS_TEMP_DIR.newFolder();
    org.apache.hadoop.conf.Configuration hdConf=new org.apache.hadoop.conf.Configuration();
    hdConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR,tempDir.getAbsolutePath());
    MiniDFSCluster.Builder builder=new MiniDFSCluster.Builder(hdConf);
    hdfsCluster=builder.build();
    hdfsRootPath=new Path(hdfsCluster.getURI());
  }
  @AfterClass public static void destroyHDFS(){
    if (hdfsCluster != null) {
      hdfsCluster.shutdown();
    }
    hdfsCluster=null;
    hdfsRootPath=null;
  }
  @Before public void initConfig(){
    hadoopConfig=new org.apache.hadoop.conf.Configuration();
    hadoopConfig.set(org.apache.hadoop.fs.FileSystem.FS_DEFAULT_NAME_KEY,hdfsRootPath.toString());
  }
  /** 
 * Verifies that nested directories are properly copied with a <tt>hdfs://</tt> file system (from a <tt>file:///absolute/path</tt> source path).
 */
  @Test public void testCopyFromLocalRecursiveWithScheme() throws Exception {
    final FileSystem targetFileSystem=hdfsRootPath.getFileSystem(hadoopConfig);
    final Path targetDir=targetFileSystem.getWorkingDirectory();
    testCopyFromLocalRecursive(targetFileSystem,targetDir,tempFolder,true);
  }
  /** 
 * Verifies that nested directories are properly copied with a <tt>hdfs://</tt> file system (from a <tt>/absolute/path</tt> source path).
 */
  @Test public void testCopyFromLocalRecursiveWithoutScheme() throws Exception {
    final FileSystem targetFileSystem=hdfsRootPath.getFileSystem(hadoopConfig);
    final Path targetDir=targetFileSystem.getWorkingDirectory();
    testCopyFromLocalRecursive(targetFileSystem,targetDir,tempFolder,false);
  }
  /** 
 * Verifies that nested directories are properly copied with the given filesystem and paths.
 * @param targetFileSystem file system of the target path
 * @param targetDir target path (URI like <tt>hdfs://...</tt>)
 * @param tempFolder JUnit temporary folder rule to create the source directory with
 * @param addSchemeToLocalPath whether add the <tt>file://</tt> scheme to the local path to copy from
 */
  static void testCopyFromLocalRecursive(  FileSystem targetFileSystem,  Path targetDir,  TemporaryFolder tempFolder,  boolean addSchemeToLocalPath) throws Exception {
    assertFalse(targetFileSystem.exists(targetDir));
    final File srcDir=tempFolder.newFolder();
    final Path srcPath;
    if (addSchemeToLocalPath) {
      srcPath=new Path("file://" + srcDir.getAbsolutePath());
    }
 else {
      srcPath=new Path(srcDir.getAbsolutePath());
    }
    HashMap<String,String> srcFiles=new HashMap<>(4);
    srcFiles.put("1","Hello 1");
    srcFiles.put("2","Hello 2");
    srcFiles.put("nested/3","Hello nested/3");
    srcFiles.put("nested/4/5","Hello nested/4/5");
    for (    Map.Entry<String,String> src : srcFiles.entrySet()) {
      File file=new File(srcDir,src.getKey());
      file.getParentFile().mkdirs();
      try (DataOutputStream out=new DataOutputStream(new FileOutputStream(file))){
        out.writeUTF(src.getValue());
      }
     }
    try {
      List<Path> remotePaths=new ArrayList<>();
      HashMap<String,LocalResource> localResources=new HashMap<>();
      AbstractYarnClusterDescriptor.uploadAndRegisterFiles(Collections.singletonList(new File(srcPath.toUri().getPath())),targetFileSystem,targetDir,ApplicationId.newInstance(0,0),remotePaths,localResources,new StringBuilder());
      assertEquals(srcFiles.size(),localResources.size());
      Path workDir=ConverterUtils.getPathFromYarnURL(localResources.get(srcPath.getName() + "/1").getResource()).getParent();
      RemoteIterator<LocatedFileStatus> targetFilesIterator=targetFileSystem.listFiles(workDir,true);
      HashMap<String,String> targetFiles=new HashMap<>(4);
      final int workDirPrefixLength=workDir.toString().length() + 1;
      while (targetFilesIterator.hasNext()) {
        LocatedFileStatus targetFile=targetFilesIterator.next();
        int retries=5;
        do {
          try (FSDataInputStream in=targetFileSystem.open(targetFile.getPath())){
            String absolutePathString=targetFile.getPath().toString();
            String relativePath=absolutePathString.substring(workDirPrefixLength);
            targetFiles.put(relativePath,in.readUTF());
            assertEquals("extraneous data in file " + relativePath,-1,in.read());
            break;
          }
 catch (          FileNotFoundException e) {
            Thread.sleep(50);
          }
        }
 while ((retries--) > 0);
      }
      assertThat(targetFiles,equalTo(srcFiles));
    }
  finally {
      targetFileSystem.delete(targetDir,true);
    }
  }
}
