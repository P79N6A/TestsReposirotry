/** 
 * Tests for GET-specific parts of the  {@link BlobCacheService}. <p>This includes access of transient BLOBs from the  {@link PermanentBlobCache}, permanent BLOBS from the  {@link TransientBlobCache}, and how failing GET requests behave in the presence of failures when used with a  {@link BlobCacheService}. <p>Most successful GET requests are tested in conjunction wit the PUT requests by  {@link BlobCachePutTest}.
 */
public class BlobCacheGetTest extends TestLogger {
  private final Random rnd=new Random();
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  @Rule public final ExpectedException exception=ExpectedException.none();
  @Test public void testGetTransientFailsDuringLookup1() throws IOException, InterruptedException {
    testGetFailsDuringLookup(null,new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testGetTransientFailsDuringLookup2() throws IOException, InterruptedException {
    testGetFailsDuringLookup(new JobID(),new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testGetTransientFailsDuringLookup3() throws IOException, InterruptedException {
    testGetFailsDuringLookup(new JobID(),null,TRANSIENT_BLOB);
  }
  @Test public void testGetFailsDuringLookupHa() throws IOException, InterruptedException {
    testGetFailsDuringLookup(new JobID(),new JobID(),PERMANENT_BLOB);
  }
  /** 
 * Checks the correct result if a GET operation fails during the lookup of the file.
 * @param jobId1 first job ID or <tt>null</tt> if job-unrelated
 * @param jobId2 second job ID different to <tt>jobId1</tt>
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testGetFailsDuringLookup(  final JobID jobId1,  final JobID jobId2,  BlobKey.BlobType blobType) throws IOException, InterruptedException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      BlobKey key=put(server,jobId1,data,blobType);
      assertNotNull(key);
      verifyType(blobType,key);
      File blobFile=server.getStorageLocation(jobId1,key);
      assertTrue(blobFile.delete());
      verifyDeleted(cache,jobId1,key);
      BlobKey key2=put(server,jobId2,data,blobType);
      assertNotNull(key2);
      verifyKeyDifferentHashEquals(key,key2);
      get(cache,jobId2,key2);
      verifyDeleted(cache,jobId1,key);
      if (blobType == PERMANENT_BLOB) {
        assertTrue(server.getStorageLocation(jobId2,key2).exists());
        blobFile=cache.getPermanentBlobService().getStorageLocation(jobId2,key2);
        assertTrue(blobFile.delete());
        get(cache,jobId2,key2);
        blobFile=cache.getPermanentBlobService().getStorageLocation(jobId2,key2);
        assertTrue(blobFile.delete());
        blobFile=server.getStorageLocation(jobId2,key2);
        assertTrue(blobFile.delete());
        verifyDeleted(cache,jobId2,key2);
      }
 else {
        verifyDeletedEventually(server,jobId2,key2);
        blobFile=cache.getTransientBlobService().getStorageLocation(jobId2,key2);
        assertTrue(blobFile.delete());
        verifyDeleted(cache,jobId2,key2);
      }
    }
   }
  @Test public void testGetFailsIncomingNoJob() throws IOException {
    testGetFailsIncoming(null,TRANSIENT_BLOB);
  }
  @Test public void testGetFailsIncomingForJob() throws IOException {
    testGetFailsIncoming(new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testGetFailsIncomingForJobHa() throws IOException {
    testGetFailsIncoming(new JobID(),PERMANENT_BLOB);
  }
  /** 
 * Retrieves a BLOB via a  {@link BlobCacheService} which cannot create incoming files. Filetransfers should fail.
 * @param jobId job id
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testGetFailsIncoming(  @Nullable final JobID jobId,  BlobKey.BlobType blobType) throws IOException {
    assumeTrue(!OperatingSystem.isWindows());
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    File tempFileDir=null;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      BlobKey blobKey=put(server,jobId,data,blobType);
      verifyType(blobType,blobKey);
      if (blobType == PERMANENT_BLOB) {
        tempFileDir=cache.getPermanentBlobService().createTemporaryFilename().getParentFile();
      }
 else {
        tempFileDir=cache.getTransientBlobService().createTemporaryFilename().getParentFile();
      }
      assertTrue(tempFileDir.setExecutable(true,false));
      assertTrue(tempFileDir.setReadable(true,false));
      assertTrue(tempFileDir.setWritable(false,false));
      exception.expect(IOException.class);
      exception.expectMessage("Failed to fetch BLOB ");
      try {
        get(cache,jobId,blobKey);
      }
  finally {
        HashSet<String> expectedDirs=new HashSet<>();
        expectedDirs.add("incoming");
        if (jobId != null) {
          expectedDirs.add(JOB_DIR_PREFIX + jobId);
          File storageDir=tempFileDir.getParentFile();
          String[] actualDirs=storageDir.list();
          assertNotNull(actualDirs);
          assertEquals(expectedDirs,new HashSet<>(Arrays.asList(actualDirs)));
          File jobDir=new File(tempFileDir.getParentFile(),JOB_DIR_PREFIX + jobId);
          assertArrayEquals(new String[]{},jobDir.list());
        }
 else {
          expectedDirs.add(NO_JOB_DIR_PREFIX);
          File storageDir=tempFileDir.getParentFile();
          String[] actualDirs=storageDir.list();
          assertNotNull(actualDirs);
          assertEquals(expectedDirs,new HashSet<>(Arrays.asList(actualDirs)));
          File noJobDir=new File(tempFileDir.getParentFile(),NO_JOB_DIR_PREFIX);
          assertArrayEquals(new String[]{},noJobDir.list());
        }
        assertTrue(server.getStorageLocation(jobId,blobKey).exists());
      }
    }
  finally {
      if (tempFileDir != null) {
        tempFileDir.setWritable(true,false);
      }
    }
  }
  @Test public void testGetTransientFailsStoreNoJob() throws IOException, InterruptedException {
    testGetFailsStore(null,TRANSIENT_BLOB);
  }
  @Test public void testGetTransientFailsStoreForJob() throws IOException, InterruptedException {
    testGetFailsStore(new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testGetPermanentFailsStoreForJob() throws IOException, InterruptedException {
    testGetFailsStore(new JobID(),PERMANENT_BLOB);
  }
  /** 
 * Retrieves a BLOB via a  {@link BlobCacheService} which cannot create the final storage file.File transfers should fail.
 * @param jobId job id
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testGetFailsStore(  @Nullable final JobID jobId,  BlobKey.BlobType blobType) throws IOException, InterruptedException {
    assumeTrue(!OperatingSystem.isWindows());
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    File jobStoreDir=null;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      BlobKey blobKey=put(server,jobId,data,blobType);
      verifyType(blobType,blobKey);
      if (blobType == PERMANENT_BLOB) {
        jobStoreDir=cache.getPermanentBlobService().getStorageLocation(jobId,new PermanentBlobKey()).getParentFile();
      }
 else {
        jobStoreDir=cache.getTransientBlobService().getStorageLocation(jobId,new TransientBlobKey()).getParentFile();
      }
      assertTrue(jobStoreDir.setExecutable(true,false));
      assertTrue(jobStoreDir.setReadable(true,false));
      assertTrue(jobStoreDir.setWritable(false,false));
      exception.expect(AccessDeniedException.class);
      try {
        get(cache,jobId,blobKey);
      }
  finally {
        File incomingFileDir=new File(jobStoreDir.getParent(),"incoming");
        assertArrayEquals(new String[]{},incomingFileDir.list());
        assertArrayEquals(new String[]{},jobStoreDir.list());
        if (blobType == TRANSIENT_BLOB) {
          verifyDeletedEventually(server,jobId,blobKey);
        }
 else {
          assertTrue(server.getStorageLocation(jobId,blobKey).exists());
        }
      }
    }
  finally {
      if (jobStoreDir != null) {
        jobStoreDir.setWritable(true,false);
      }
    }
  }
  /** 
 * Retrieves a BLOB from the HA store to a  {@link BlobServer} whose HA store does not containthe file. File transfers should fail.
 */
  @Test public void testGetFailsHaStoreForJobHa() throws IOException {
    final JobID jobId=new JobID();
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      PermanentBlobKey blobKey=(PermanentBlobKey)put(server,jobId,data,PERMANENT_BLOB);
      assertTrue(server.getStorageLocation(jobId,blobKey).delete());
      File tempFileDir=server.createTemporaryFilename().getParentFile();
      exception.expect(IOException.class);
      exception.expectMessage("Failed to fetch BLOB ");
      try {
        get(cache,jobId,blobKey);
      }
  finally {
        HashSet<String> expectedDirs=new HashSet<>();
        expectedDirs.add("incoming");
        expectedDirs.add(JOB_DIR_PREFIX + jobId);
        File storageDir=tempFileDir.getParentFile();
        String[] actualDirs=storageDir.list();
        assertNotNull(actualDirs);
        assertEquals(expectedDirs,new HashSet<>(Arrays.asList(actualDirs)));
        File jobDir=new File(tempFileDir.getParentFile(),JOB_DIR_PREFIX + jobId);
        assertArrayEquals(new String[]{},jobDir.list());
      }
    }
   }
  @Test public void testGetTransientRemoteDeleteFailsNoJob() throws IOException {
    testGetTransientRemoteDeleteFails(null);
  }
  @Test public void testGetTransientRemoteDeleteFailsForJob() throws IOException {
    testGetTransientRemoteDeleteFails(new JobID());
  }
  /** 
 * Uploads a byte array for the given job and verifies that a get operation of a transient BLOB (via the  {@link BlobCacheService}; also deletes the file on the  {@link BlobServer}) does not fail even if the file is not deletable on the  {@link BlobServer}, e.g. via restricting the permissions.
 * @param jobId job id
 */
  private void testGetTransientRemoteDeleteFails(  @Nullable final JobID jobId) throws IOException {
    assumeTrue(!OperatingSystem.isWindows());
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    File blobFile=null;
    File directory=null;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      try {
        byte[] data=new byte[2000000];
        rnd.nextBytes(data);
        TransientBlobKey key=(TransientBlobKey)put(server,jobId,data,TRANSIENT_BLOB);
        assertNotNull(key);
        blobFile=server.getStorageLocation(jobId,key);
        directory=blobFile.getParentFile();
        assertTrue(blobFile.setWritable(false,false));
        assertTrue(directory.setWritable(false,false));
        verifyContents(cache,jobId,key,data);
        assertTrue(delete(cache,jobId,key));
        File blobFileAtCache=cache.getTransientBlobService().getStorageLocation(jobId,key);
        assertFalse(blobFileAtCache.exists());
        verifyContents(server,jobId,key,data);
        verifyContents(cache,jobId,key,data);
      }
  finally {
        if (blobFile != null && directory != null) {
          blobFile.setWritable(true,false);
          directory.setWritable(true,false);
        }
      }
    }
   }
  /** 
 * FLINK-6020 <p>Tests that concurrent get operations don't concurrently access the BlobStore to download a blob.
 */
  @Test public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException {
    testConcurrentGetOperations(null,TRANSIENT_BLOB,false);
  }
  @Test public void testConcurrentGetOperationsForJob() throws IOException, ExecutionException, InterruptedException {
    testConcurrentGetOperations(new JobID(),TRANSIENT_BLOB,false);
  }
  @Test public void testConcurrentGetOperationsForJobHa() throws IOException, ExecutionException, InterruptedException {
    testConcurrentGetOperations(new JobID(),PERMANENT_BLOB,false);
  }
  @Test public void testConcurrentGetOperationsForJobHa2() throws IOException, ExecutionException, InterruptedException {
    testConcurrentGetOperations(new JobID(),PERMANENT_BLOB,true);
  }
  /** 
 * [FLINK-6020] Tests that concurrent get operations don't concurrently access the BlobStore to download a blob.
 * @param jobId job ID to use (or <tt>null</tt> if job-unrelated)
 * @param blobType whether the BLOB should become permanent or transient
 * @param cacheAccessesHAStore whether the cache has access to the  {@link BlobServer}'s HA store or not
 */
  private void testConcurrentGetOperations(  final JobID jobId,  final BlobKey.BlobType blobType,  final boolean cacheAccessesHAStore) throws IOException, InterruptedException, ExecutionException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    final BlobStore blobStoreServer=mock(BlobStore.class);
    final BlobStore blobStoreCache=mock(BlobStore.class);
    final int numberConcurrentGetOperations=3;
    final List<CompletableFuture<File>> getOperations=new ArrayList<>(numberConcurrentGetOperations);
    final byte[] data={1,2,3,4,99,42};
    final ExecutorService executor=Executors.newFixedThreadPool(numberConcurrentGetOperations);
    try (final BlobServer server=new BlobServer(config,blobStoreServer);final BlobCacheService cache=new BlobCacheService(config,cacheAccessesHAStore ? blobStoreServer : blobStoreCache,new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      final BlobKey blobKey=put(server,jobId,data,blobType);
      for (int i=0; i < numberConcurrentGetOperations; i++) {
        CompletableFuture<File> getOperation=CompletableFuture.supplyAsync(() -> {
          try {
            File file=get(cache,jobId,blobKey);
            validateGetAndClose(new FileInputStream(file),data);
            return file;
          }
 catch (          IOException e) {
            throw new CompletionException(new FlinkException("Could not read blob for key " + blobKey + '.',e));
          }
        }
,executor);
        getOperations.add(getOperation);
      }
      FutureUtils.ConjunctFuture<Collection<File>> filesFuture=FutureUtils.combineAll(getOperations);
      if (blobType == PERMANENT_BLOB) {
        filesFuture.get();
      }
 else {
        int completedSuccessfully=0;
        for (        CompletableFuture<File> op : getOperations) {
          try {
            op.get();
            ++completedSuccessfully;
          }
 catch (          Throwable t) {
            if (!(ExceptionUtils.getRootCause(t) instanceof FileNotFoundException)) {
              org.apache.flink.util.ExceptionUtils.rethrowIOException(t);
            }
          }
        }
        assertThat(completedSuccessfully,greaterThanOrEqualTo(1));
      }
    }
  finally {
      executor.shutdownNow();
    }
  }
}
