/** 
 * A few tests for the cleanup of  {@link PermanentBlobCache} and {@link TransientBlobCache}.
 */
public class BlobCacheCleanupTest extends TestLogger {
  private final Random rnd=new Random();
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  /** 
 * Tests that  {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}.
 */
  @Test public void testPermanentBlobCleanup() throws IOException, InterruptedException {
    JobID jobId=new JobID();
    List<PermanentBlobKey> keys=new ArrayList<>();
    BlobServer server=null;
    PermanentBlobCache cache=null;
    final byte[] buf=new byte[128];
    try {
      Configuration config=new Configuration();
      config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
      config.setLong(BlobServerOptions.CLEANUP_INTERVAL,1L);
      server=new BlobServer(config,new VoidBlobStore());
      server.start();
      InetSocketAddress serverAddress=new InetSocketAddress("localhost",server.getPort());
      cache=new PermanentBlobCache(config,new VoidBlobStore(),serverAddress);
      keys.add(server.putPermanent(jobId,buf));
      buf[0]+=1;
      keys.add(server.putPermanent(jobId,buf));
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(0,jobId,cache);
      cache.registerJob(jobId);
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(0,jobId,cache);
      for (      PermanentBlobKey key : keys) {
        cache.getFile(jobId,key);
      }
      cache.registerJob(jobId);
      for (      PermanentBlobKey key : keys) {
        cache.getFile(jobId,key);
      }
      assertEquals(2,checkFilesExist(jobId,keys,cache,true));
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(2,jobId,cache);
      cache.releaseJob(jobId);
      assertEquals(2,checkFilesExist(jobId,keys,cache,true));
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(2,jobId,cache);
      cache.releaseJob(jobId);
      verifyJobCleanup(cache,jobId,keys);
      checkFileCountForJob(2,jobId,server);
    }
  finally {
      if (cache != null) {
        cache.close();
      }
      if (server != null) {
        server.close();
      }
      checkFileCountForJob(0,jobId,server);
    }
  }
  /** 
 * Tests that  {@link PermanentBlobCache} sets the expected reference counts and cleanup timeoutswhen registering, releasing, and re-registering jobs.
 */
  @Test public void testPermanentJobReferences() throws IOException, InterruptedException {
    JobID jobId=new JobID();
    Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    config.setLong(BlobServerOptions.CLEANUP_INTERVAL,3_600_000L);
    InetSocketAddress serverAddress=new InetSocketAddress("localhost",12345);
    try (PermanentBlobCache cache=new PermanentBlobCache(config,new VoidBlobStore(),serverAddress)){
      cache.registerJob(jobId);
      assertEquals(1,cache.getJobRefCounters().get(jobId).references);
      assertEquals(-1,cache.getJobRefCounters().get(jobId).keepUntil);
      cache.registerJob(jobId);
      assertEquals(2,cache.getJobRefCounters().get(jobId).references);
      assertEquals(-1,cache.getJobRefCounters().get(jobId).keepUntil);
      cache.releaseJob(jobId);
      assertEquals(1,cache.getJobRefCounters().get(jobId).references);
      assertEquals(-1,cache.getJobRefCounters().get(jobId).keepUntil);
      long cleanupLowerBound=System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL);
      cache.releaseJob(jobId);
      assertEquals(0,cache.getJobRefCounters().get(jobId).references);
      assertThat(cache.getJobRefCounters().get(jobId).keepUntil,greaterThanOrEqualTo(cleanupLowerBound));
      cache.registerJob(jobId);
      assertEquals(1,cache.getJobRefCounters().get(jobId).references);
      assertEquals(-1,cache.getJobRefCounters().get(jobId).keepUntil);
      cleanupLowerBound=System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL);
      cache.releaseJob(jobId);
      assertEquals(0,cache.getJobRefCounters().get(jobId).references);
      assertThat(cache.getJobRefCounters().get(jobId).keepUntil,greaterThanOrEqualTo(cleanupLowerBound));
    }
   }
  /** 
 * Tests the deferred cleanup of  {@link PermanentBlobCache}, i.e. after calling  {@link PermanentBlobCache#releaseJob(JobID)} the file should be preserved a bit longer and thencleaned up.
 */
  @Test @Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") public void testPermanentBlobDeferredCleanup() throws IOException, InterruptedException {
    long cleanupInterval=5L;
    JobID jobId=new JobID();
    List<PermanentBlobKey> keys=new ArrayList<>();
    BlobServer server=null;
    PermanentBlobCache cache=null;
    final byte[] buf=new byte[128];
    try {
      Configuration config=new Configuration();
      config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
      config.setLong(BlobServerOptions.CLEANUP_INTERVAL,cleanupInterval);
      server=new BlobServer(config,new VoidBlobStore());
      server.start();
      InetSocketAddress serverAddress=new InetSocketAddress("localhost",server.getPort());
      cache=new PermanentBlobCache(config,new VoidBlobStore(),serverAddress);
      keys.add(server.putPermanent(jobId,buf));
      buf[0]+=1;
      keys.add(server.putPermanent(jobId,buf));
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(0,jobId,cache);
      cache.registerJob(jobId);
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(0,jobId,cache);
      for (      PermanentBlobKey key : keys) {
        cache.getFile(jobId,key);
      }
      cache.registerJob(jobId);
      for (      PermanentBlobKey key : keys) {
        cache.getFile(jobId,key);
      }
      assertEquals(2,checkFilesExist(jobId,keys,cache,true));
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(2,jobId,cache);
      cache.releaseJob(jobId);
      assertEquals(2,checkFilesExist(jobId,keys,cache,true));
      checkFileCountForJob(2,jobId,server);
      checkFileCountForJob(2,jobId,cache);
      cache.releaseJob(jobId);
      assertEquals(2,checkFilesExist(jobId,keys,cache,true));
      checkFileCountForJob(2,jobId,cache);
      Thread.sleep(cleanupInterval / 5);
      assertEquals(2,checkFilesExist(jobId,keys,cache,true));
      checkFileCountForJob(2,jobId,cache);
      Thread.sleep((cleanupInterval * 4) / 5);
      verifyJobCleanup(cache,jobId,keys);
      checkFileCountForJob(2,jobId,server);
    }
  finally {
      if (cache != null) {
        cache.close();
      }
      if (server != null) {
        server.close();
      }
      checkFileCountForJob(0,jobId,server);
    }
  }
  @Test public void testTransientBlobNoJobCleanup() throws IOException, InterruptedException, ExecutionException {
    testTransientBlobCleanup(null);
  }
  @Test public void testTransientBlobForJobCleanup() throws IOException, InterruptedException, ExecutionException {
    testTransientBlobCleanup(new JobID());
  }
  /** 
 * Tests that  {@link TransientBlobCache} cleans up after a default TTL and keeps files which areconstantly accessed.
 */
  private void testTransientBlobCleanup(  @Nullable final JobID jobId) throws IOException, InterruptedException, ExecutionException {
    long cleanupInterval=1L;
    final int numberConcurrentGetOperations=3;
    final List<CompletableFuture<Void>> getOperations=new ArrayList<>(numberConcurrentGetOperations);
    byte[] data=new byte[2000000];
    rnd.nextBytes(data);
    byte[] data2=Arrays.copyOfRange(data,10,54);
    Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    config.setLong(BlobServerOptions.CLEANUP_INTERVAL,cleanupInterval);
    long cleanupLowerBound;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());final BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      ConcurrentMap<Tuple2<JobID,TransientBlobKey>,Long> transientBlobExpiryTimes=cache.getTransientBlobService().getBlobExpiryTimes();
      server.start();
      final TransientBlobKey key1=(TransientBlobKey)put(server,jobId,data,TRANSIENT_BLOB);
      final TransientBlobKey key2=(TransientBlobKey)put(server,jobId,data2,TRANSIENT_BLOB);
      cleanupLowerBound=System.currentTimeMillis() + cleanupInterval;
      verifyContents(cache,jobId,key1,data);
      final Long key1ExpiryFirstAccess=transientBlobExpiryTimes.get(Tuple2.of(jobId,key1));
      assertThat(key1ExpiryFirstAccess,greaterThanOrEqualTo(cleanupLowerBound));
      assertNull(transientBlobExpiryTimes.get(Tuple2.of(jobId,key2)));
      Thread.sleep(1);
      cleanupLowerBound=System.currentTimeMillis() + cleanupInterval;
      verifyContents(cache,jobId,key2,data2);
      assertEquals(key1ExpiryFirstAccess,transientBlobExpiryTimes.get(Tuple2.of(jobId,key1)));
      assertThat(transientBlobExpiryTimes.get(Tuple2.of(jobId,key2)),greaterThanOrEqualTo(cleanupLowerBound));
      if (jobId != null) {
        server.cleanupJob(jobId,true);
      }
 else {
        server.deleteFromCache(key1);
        server.deleteFromCache(key2);
      }
      checkFileCountForJob(0,jobId,server);
      final long finishTime=System.currentTimeMillis() + 3 * cleanupInterval;
      final ExecutorService executor=Executors.newFixedThreadPool(numberConcurrentGetOperations);
      for (int i=0; i < numberConcurrentGetOperations; i++) {
        CompletableFuture<Void> getOperation=CompletableFuture.supplyAsync(() -> {
          try {
            while (System.currentTimeMillis() < finishTime) {
              get(cache,jobId,key1);
            }
            return null;
          }
 catch (          IOException e) {
            throw new CompletionException(new FlinkException("Could not retrieve blob.",e));
          }
        }
,executor);
        getOperations.add(getOperation);
      }
      FutureUtils.ConjunctFuture<Collection<Void>> filesFuture=FutureUtils.combineAll(getOperations);
      filesFuture.get();
      verifyDeletedEventually(server,jobId,key1,key2);
    }
   }
  /** 
 * Checks that BLOBs for the given <tt>jobId</tt> are cleaned up eventually (after calling {@link PermanentBlobCache#releaseJob(JobID)}, which is not done by this method!) (waits at most 30s).
 * @param cache BLOB server
 * @param jobId job ID or <tt>null</tt> if job-unrelated
 * @param keys keys identifying BLOBs which were previously registered for the <tt>jobId</tt>
 */
  static void verifyJobCleanup(  PermanentBlobCache cache,  JobID jobId,  List<? extends BlobKey> keys) throws InterruptedException, IOException {
{
      long deadline=System.currentTimeMillis() + 30_000L;
      do {
        Thread.sleep(100);
      }
 while (checkFilesExist(jobId,keys,cache,false) != 0 && System.currentTimeMillis() < deadline);
    }
    checkFileCountForJob(0,jobId,cache);
  }
}
