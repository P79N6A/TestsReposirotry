public abstract class TaskTestBase extends TestLogger {
  protected long memorySize=0;
  protected MockInputSplitProvider inputSplitProvider;
  protected MockEnvironment mockEnv;
  public void initEnvironment(  long memorySize,  int bufferSize){
    this.memorySize=memorySize;
    this.inputSplitProvider=new MockInputSplitProvider();
    this.mockEnv=new MockEnvironmentBuilder().setTaskName("mock task").setMemorySize(this.memorySize).setInputSplitProvider(this.inputSplitProvider).setBufferSize(bufferSize).build();
  }
  public IteratorWrappingTestSingleInputGate<Record> addInput(  MutableObjectIterator<Record> input,  int groupId){
    return addInput(input,groupId,true);
  }
  public IteratorWrappingTestSingleInputGate<Record> addInput(  MutableObjectIterator<Record> input,  int groupId,  boolean read){
    final IteratorWrappingTestSingleInputGate<Record> reader=this.mockEnv.addInput(input);
    TaskConfig conf=new TaskConfig(this.mockEnv.getTaskConfiguration());
    conf.addInputToGroup(groupId);
    conf.setInputSerializer(RecordSerializerFactory.get(),groupId);
    if (read) {
      reader.notifyNonEmpty();
    }
    return reader;
  }
  public void addOutput(  List<Record> output){
    this.mockEnv.addOutput(output);
    TaskConfig conf=new TaskConfig(this.mockEnv.getTaskConfiguration());
    conf.addOutputShipStrategy(ShipStrategyType.FORWARD);
    conf.setOutputSerializer(RecordSerializerFactory.get());
  }
  public TaskConfig getTaskConfig(){
    return new TaskConfig(this.mockEnv.getTaskConfiguration());
  }
  public Configuration getConfiguration(){
    return this.mockEnv.getTaskConfiguration();
  }
  public void registerTask(  @SuppressWarnings("rawtypes") Class<? extends Driver> driver,  Class<? extends RichFunction> stubClass){
    final TaskConfig config=new TaskConfig(this.mockEnv.getTaskConfiguration());
    config.setDriver(driver);
    config.setStubWrapper(new UserCodeClassWrapper<>(stubClass));
  }
  public void registerFileOutputTask(  Class<? extends FileOutputFormat<Record>> stubClass,  String outPath){
    registerFileOutputTask(InstantiationUtil.instantiate(stubClass,FileOutputFormat.class),outPath);
  }
  public void registerFileOutputTask(  FileOutputFormat<Record> outputFormat,  String outPath){
    TaskConfig dsConfig=new TaskConfig(this.mockEnv.getTaskConfiguration());
    outputFormat.setOutputFilePath(new Path(outPath));
    outputFormat.setWriteMode(WriteMode.OVERWRITE);
    dsConfig.setStubWrapper(new UserCodeObjectWrapper<>(outputFormat));
  }
  public void registerFileInputTask(  AbstractInvokable inTask,  Class<? extends DelimitedInputFormat<Record>> stubClass,  String inPath,  String delimiter){
    DelimitedInputFormat<Record> format;
    try {
      format=stubClass.newInstance();
    }
 catch (    Throwable t) {
      throw new RuntimeException("Could not instantiate test input format.",t);
    }
    format.setFilePath(inPath);
    format.setDelimiter(delimiter);
    TaskConfig dsConfig=new TaskConfig(this.mockEnv.getTaskConfiguration());
    dsConfig.setStubWrapper(new UserCodeObjectWrapper<>(format));
    this.inputSplitProvider.addInputSplits(inPath,5);
  }
  public MemoryManager getMemoryManager(){
    return this.mockEnv.getMemoryManager();
  }
  @After public void shutdown(){
    mockEnv.close();
  }
}
