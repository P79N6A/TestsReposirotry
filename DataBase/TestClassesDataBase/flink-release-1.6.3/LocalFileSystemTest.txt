/** 
 * This class tests the functionality of the  {@link LocalFileSystem} class in its components. In particular,file/directory access, creation, deletion, read, write is tested.
 */
public class LocalFileSystemTest extends TestLogger {
  @Rule public final TemporaryFolder temporaryFolder=new TemporaryFolder();
  /** 
 * This test checks the functionality of the  {@link LocalFileSystem} class.
 */
  @Test public void testLocalFilesystem() throws Exception {
    final File tempdir=new File(temporaryFolder.getRoot(),UUID.randomUUID().toString());
    final File testfile1=new File(tempdir,UUID.randomUUID().toString());
    final File testfile2=new File(tempdir,UUID.randomUUID().toString());
    final Path pathtotestfile1=new Path(testfile1.toURI().getPath());
    final Path pathtotestfile2=new Path(testfile2.toURI().getPath());
    final LocalFileSystem lfs=new LocalFileSystem();
    final Path pathtotmpdir=new Path(tempdir.toURI().getPath());
    assertFalse(lfs.exists(pathtotmpdir));
    assertTrue(tempdir.mkdirs());
    assertTrue(lfs.exists(pathtotmpdir));
    final FileStatus localstatus1=lfs.getFileStatus(pathtotmpdir);
    assertTrue(localstatus1.isDir());
    final FileStatus[] statusforfiles=lfs.listStatus(pathtotmpdir);
    assertTrue(statusforfiles.length == 0);
    lfs.delete(pathtotmpdir,true);
    assertFalse(lfs.exists(pathtotmpdir));
    assertFalse(tempdir.exists());
    lfs.mkdirs(pathtotmpdir);
    assertTrue(tempdir.exists());
    final FSDataOutputStream lfsoutput1=lfs.create(pathtotestfile1,WriteMode.NO_OVERWRITE);
    assertTrue(testfile2.createNewFile());
    assertTrue(testfile1.exists());
    assertTrue(lfs.exists(pathtotestfile2));
    final byte[] testbytes={1,2,3,4,5};
    lfsoutput1.write(testbytes);
    lfsoutput1.close();
    assertEquals(testfile1.length(),5L);
    byte[] testbytestest=new byte[5];
    try (FileInputStream fisfile1=new FileInputStream(testfile1)){
      assertEquals(testbytestest.length,fisfile1.read(testbytestest));
    }
     assertArrayEquals(testbytes,testbytestest);
    assertEquals(lfs.getFileStatus(pathtotestfile1).getLen(),testfile1.length());
    assertEquals(lfs.listStatus(pathtotestfile1)[0].getLen(),testfile1.length());
    final FileOutputStream fosfile2=new FileOutputStream(testfile2);
    fosfile2.write(testbytes);
    fosfile2.close();
    testbytestest=new byte[5];
    final FSDataInputStream lfsinput2=lfs.open(pathtotestfile2);
    assertEquals(lfsinput2.read(testbytestest),5);
    lfsinput2.close();
    assertTrue(Arrays.equals(testbytes,testbytestest));
    assertEquals(lfs.listStatus(pathtotmpdir).length,2);
    assertEquals(lfs.getFileBlockLocations(lfs.getFileStatus(pathtotestfile1),0,0).length,1);
    assertTrue(lfs.delete(pathtotestfile1,false));
    assertTrue(lfs.delete(pathtotmpdir,true));
    assertTrue(!tempdir.exists());
  }
  /** 
 * Test that  {@link FileUtils#deletePathIfEmpty(FileSystem,Path)} deletes the path if it isempty. A path can only be empty if it is a directory which does not contain any files/directories.
 */
  @Test public void testDeletePathIfEmpty() throws IOException {
    File file=temporaryFolder.newFile();
    File directory=temporaryFolder.newFolder();
    File directoryFile=new File(directory,UUID.randomUUID().toString());
    assertTrue(directoryFile.createNewFile());
    Path filePath=new Path(file.toURI());
    Path directoryPath=new Path(directory.toURI());
    Path directoryFilePath=new Path(directoryFile.toURI());
    FileSystem fs=FileSystem.getLocalFileSystem();
    assertTrue(fs.exists(filePath));
    assertTrue(fs.exists(directoryFilePath));
    assertFalse(FileUtils.deletePathIfEmpty(fs,filePath));
    assertTrue(fs.exists(filePath));
    assertFalse(FileUtils.deletePathIfEmpty(fs,directoryPath));
    assertTrue(fs.exists(directoryPath));
    assertTrue(fs.delete(directoryFilePath,false));
    assertTrue(FileUtils.deletePathIfEmpty(fs,directoryPath));
    assertFalse(fs.exists(directoryPath));
  }
  @Test public void testRenamePath() throws IOException {
    final File rootDirectory=temporaryFolder.newFolder();
    final File srcDirectory=new File(new File(rootDirectory,"src"),"B");
    assertTrue(srcDirectory.mkdirs());
    final File srcFile=new File(srcDirectory,"test.csv");
    assertTrue(srcFile.createNewFile());
    final File destDirectory=new File(new File(rootDirectory,"dst"),"B");
    final File destFile=new File(destDirectory,"test.csv");
    final Path srcDirPath=new Path(srcDirectory.toURI());
    final Path srcFilePath=new Path(srcFile.toURI());
    final Path destDirPath=new Path(destDirectory.toURI());
    final Path destFilePath=new Path(destFile.toURI());
    FileSystem fs=FileSystem.getLocalFileSystem();
    assertTrue(fs.exists(srcDirPath));
    assertFalse(fs.exists(destDirPath));
    assertTrue(fs.rename(srcDirPath,destDirPath));
    assertTrue(fs.exists(destFilePath));
    assertFalse(fs.exists(srcDirPath));
    assertTrue(srcDirectory.mkdirs());
    assertTrue(srcFile.createNewFile());
    assertTrue(fs.rename(srcFilePath,destFilePath));
    assertFalse(fs.exists(srcFilePath));
    assertTrue(fs.exists(srcDirPath));
    assertTrue(fs.exists(destFilePath));
  }
  @Test public void testRenameNonExistingFile() throws IOException {
    final FileSystem fs=FileSystem.getLocalFileSystem();
    final File srcFile=new File(temporaryFolder.newFolder(),"someFile.txt");
    final File destFile=new File(temporaryFolder.newFolder(),"target");
    final Path srcFilePath=new Path(srcFile.toURI());
    final Path destFilePath=new Path(destFile.toURI());
    assertFalse(fs.rename(srcFilePath,destFilePath));
  }
  @Test public void testRenameFileWithNoAccess() throws IOException {
    final FileSystem fs=FileSystem.getLocalFileSystem();
    final File srcFile=temporaryFolder.newFile("someFile.txt");
    final File destFile=new File(temporaryFolder.newFolder(),"target");
    Assume.assumeTrue(srcFile.getParentFile().setWritable(false,false));
    Assume.assumeTrue(srcFile.setWritable(false,false));
    try {
      final Path srcFilePath=new Path(srcFile.toURI());
      final Path destFilePath=new Path(destFile.toURI());
      assertFalse(fs.rename(srcFilePath,destFilePath));
    }
  finally {
      srcFile.getParentFile().setWritable(true,false);
      srcFile.setWritable(true,false);
    }
  }
  @Test public void testRenameToNonEmptyTargetDir() throws IOException {
    final FileSystem fs=FileSystem.getLocalFileSystem();
    final File srcFolder=temporaryFolder.newFolder();
    final File srcFile=new File(srcFolder,"someFile.txt");
    assertTrue(srcFile.createNewFile());
    final File dstFolder=temporaryFolder.newFolder();
    final File dstFile=new File(dstFolder,"target");
    assertTrue(dstFile.createNewFile());
    assertFalse(fs.rename(new Path(srcFolder.toURI()),new Path(dstFolder.toURI())));
    assertTrue(dstFile.delete());
    assertTrue(fs.rename(new Path(srcFolder.toURI()),new Path(dstFolder.toURI())));
    assertTrue(new File(dstFolder,srcFile.getName()).exists());
  }
  @Test public void testKind(){
    final FileSystem fs=FileSystem.getLocalFileSystem();
    assertEquals(FileSystemKind.FILE_SYSTEM,fs.getKind());
  }
  @Test public void testConcurrentMkdirs() throws Exception {
    final FileSystem fs=FileSystem.getLocalFileSystem();
    final File root=temporaryFolder.getRoot();
    final int directoryDepth=10;
    final int concurrentOperations=10;
    final Collection<File> targetDirectories=createTargetDirectories(root,directoryDepth,concurrentOperations);
    final ExecutorService executor=Executors.newFixedThreadPool(concurrentOperations);
    final CyclicBarrier cyclicBarrier=new CyclicBarrier(concurrentOperations);
    try {
      final Collection<CompletableFuture<Void>> mkdirsFutures=new ArrayList<>(concurrentOperations);
      for (      File targetDirectory : targetDirectories) {
        final CompletableFuture<Void> mkdirsFuture=CompletableFuture.runAsync(() -> {
          try {
            cyclicBarrier.await();
            assertThat(fs.mkdirs(Path.fromLocalFile(targetDirectory)),is(true));
          }
 catch (          Exception e) {
            throw new CompletionException(e);
          }
        }
,executor);
        mkdirsFutures.add(mkdirsFuture);
      }
      final CompletableFuture<Void> allFutures=CompletableFuture.allOf(mkdirsFutures.toArray(new CompletableFuture[concurrentOperations]));
      allFutures.get();
    }
  finally {
      final long timeout=10000L;
      ExecutorUtils.gracefulShutdown(timeout,TimeUnit.MILLISECONDS,executor);
    }
  }
  private Collection<File> createTargetDirectories(  File root,  int directoryDepth,  int numberDirectories){
    final StringBuilder stringBuilder=new StringBuilder();
    for (int i=0; i < directoryDepth; i++) {
      stringBuilder.append('/').append(i);
    }
    final Collection<File> targetDirectories=new ArrayList<>(numberDirectories);
    for (int i=0; i < numberDirectories; i++) {
      targetDirectories.add(new File(root,stringBuilder.toString() + '/' + i));
    }
    return targetDirectories;
  }
}
