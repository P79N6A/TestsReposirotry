/** 
 * Tests for  {@link TestProcessingTimeService}.
 */
public class TestProcessingTimeServiceTest {
  @Test public void testCustomTimeServiceProvider() throws Throwable {
    final TestProcessingTimeService tp=new TestProcessingTimeService();
    final OneInputStreamTaskTestHarness<String,String> testHarness=new OneInputStreamTaskTestHarness<>((env) -> new OneInputStreamTask<>(env,tp),BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
    testHarness.setupOutputForSingletonOperatorChain();
    StreamConfig streamConfig=testHarness.getStreamConfig();
    StreamMap<String,String> mapOperator=new StreamMap<>(new StreamTaskTimerTest.DummyMapFunction<String>());
    streamConfig.setStreamOperator(mapOperator);
    streamConfig.setOperatorID(new OperatorID());
    testHarness.invoke();
    final OneInputStreamTask<String,String> mapTask=testHarness.getTask();
    assertEquals(Long.MIN_VALUE,testHarness.getProcessingTimeService().getCurrentProcessingTime());
    tp.setCurrentTime(11);
    assertEquals(testHarness.getProcessingTimeService().getCurrentProcessingTime(),11);
    tp.setCurrentTime(15);
    tp.setCurrentTime(16);
    assertEquals(testHarness.getProcessingTimeService().getCurrentProcessingTime(),16);
    mapTask.getProcessingTimeService().registerTimer(30,new ProcessingTimeCallback(){
      @Override public void onProcessingTime(      long timestamp){
      }
    }
);
    mapTask.getProcessingTimeService().registerTimer(40,new ProcessingTimeCallback(){
      @Override public void onProcessingTime(      long timestamp){
      }
    }
);
    assertEquals(2,tp.getNumActiveTimers());
    tp.setCurrentTime(35);
    assertEquals(1,tp.getNumActiveTimers());
    tp.setCurrentTime(40);
    assertEquals(0,tp.getNumActiveTimers());
    tp.shutdownService();
  }
  /** 
 * An  {@link AsyncExceptionHandler} storing the handled exception.
 */
public static class ReferenceSettingExceptionHandler implements AsyncExceptionHandler {
    private final AtomicReference<Throwable> errorReference;
    public ReferenceSettingExceptionHandler(    AtomicReference<Throwable> errorReference){
      this.errorReference=errorReference;
    }
    @Override public void handleAsyncException(    String message,    Throwable exception){
      errorReference.compareAndSet(null,exception);
    }
  }
}
