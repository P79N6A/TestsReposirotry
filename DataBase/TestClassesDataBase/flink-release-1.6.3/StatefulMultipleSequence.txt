/** 
 * Produces a sequence multiple times for each parallelism instance of downstream operators, augmented by the designated parallel subtaskId. The source is not parallel to ensure order.
 */
private static class StatefulMultipleSequence extends RichSourceFunction<Tuple2<Integer,Long>> implements ListCheckpointed<Long> {
  private long count;
  @Override public void run(  SourceContext<Tuple2<Integer,Long>> ctx) throws Exception {
    Object lock=ctx.getCheckpointLock();
    while (count < NUM_INPUT) {
synchronized (lock) {
        for (int i=0; i < PARALLELISM; i++) {
          ctx.collect(Tuple2.of(i,count + 1));
        }
        count++;
      }
    }
  }
  @Override public void cancel(){
  }
  @Override public List<Long> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(this.count);
  }
  @Override public void restoreState(  List<Long> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.count=state.get(0);
  }
}
