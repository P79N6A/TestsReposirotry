/** 
 * Tests for successful and failing PUT operations against the BLOB server, and successful GET operations.
 */
public class BlobCachePutTest extends TestLogger {
  private final Random rnd=new Random();
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  @Rule public final ExpectedException exception=ExpectedException.none();
  /** 
 * Checked thread that calls  {@link TransientBlobCache#getStorageLocation(JobID,BlobKey)}.
 */
public static class TransientBlobCacheGetStorageLocation extends CheckedThread {
    private final TransientBlobCache cache;
    private final JobID jobId;
    private final BlobKey key;
    TransientBlobCacheGetStorageLocation(    TransientBlobCache cache,    @Nullable JobID jobId,    BlobKey key){
      this.cache=cache;
      this.jobId=jobId;
      this.key=key;
    }
    @Override public void go() throws Exception {
      cache.getStorageLocation(jobId,key);
    }
  }
  /** 
 * Checked thread that calls  {@link PermanentBlobCache#getStorageLocation(JobID,BlobKey)}.
 */
public static class PermanentBlobCacheGetStorageLocation extends CheckedThread {
    private final PermanentBlobCache cache;
    private final JobID jobId;
    private final BlobKey key;
    PermanentBlobCacheGetStorageLocation(    PermanentBlobCache cache,    JobID jobId,    BlobKey key){
      this.cache=cache;
      this.jobId=jobId;
      this.key=key;
    }
    @Override public void go() throws Exception {
      cache.getStorageLocation(jobId,key);
    }
  }
  /** 
 * Tests concurrent calls to  {@link TransientBlobCache#getStorageLocation(JobID,BlobKey)}.
 */
  @Test public void testTransientBlobCacheGetStorageLocationConcurrentNoJob() throws Exception {
    testTransientBlobCacheGetStorageLocationConcurrent(null);
  }
  /** 
 * Tests concurrent calls to  {@link TransientBlobCache#getStorageLocation(JobID,BlobKey)}.
 */
  @Test public void testTransientBlobCacheGetStorageLocationConcurrentForJob() throws Exception {
    testTransientBlobCacheGetStorageLocationConcurrent(new JobID());
  }
  private void testTransientBlobCacheGetStorageLocationConcurrent(  @Nullable final JobID jobId) throws Exception {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());final TransientBlobCache cache=new TransientBlobCache(config,new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      BlobKey key=new TransientBlobKey();
      CheckedThread[] threads=new CheckedThread[]{new TransientBlobCacheGetStorageLocation(cache,jobId,key),new TransientBlobCacheGetStorageLocation(cache,jobId,key),new TransientBlobCacheGetStorageLocation(cache,jobId,key)};
      checkedThreadSimpleTest(threads);
    }
   }
  /** 
 * Tests concurrent calls to  {@link PermanentBlobCache#getStorageLocation(JobID,BlobKey)}.
 */
  @Test public void testPermanentBlobCacheGetStorageLocationConcurrentForJob() throws Exception {
    final JobID jobId=new JobID();
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());final PermanentBlobCache cache=new PermanentBlobCache(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      BlobKey key=new PermanentBlobKey();
      CheckedThread[] threads=new CheckedThread[]{new PermanentBlobCacheGetStorageLocation(cache,jobId,key),new PermanentBlobCacheGetStorageLocation(cache,jobId,key),new PermanentBlobCacheGetStorageLocation(cache,jobId,key)};
      checkedThreadSimpleTest(threads);
    }
   }
  /** 
 * Helper method to first start all threads and then wait for their completion.
 * @param threads threads to use
 * @throws Exception exceptions that are thrown from the threads
 */
  private void checkedThreadSimpleTest(  CheckedThread[] threads) throws Exception {
    for (    CheckedThread t : threads) {
      t.start();
    }
    for (    CheckedThread t : threads) {
      t.sync();
    }
  }
  @Test public void testPutBufferTransientSuccessfulGet1() throws IOException, InterruptedException {
    testPutBufferSuccessfulGet(null,null,TRANSIENT_BLOB);
  }
  @Test public void testPutBufferTransientSuccessfulGet2() throws IOException, InterruptedException {
    testPutBufferSuccessfulGet(null,new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testPutBufferTransientSuccessfulGet3() throws IOException, InterruptedException {
    testPutBufferSuccessfulGet(new JobID(),new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testPutBufferTransientSuccessfulGet4() throws IOException, InterruptedException {
    testPutBufferSuccessfulGet(new JobID(),null,TRANSIENT_BLOB);
  }
  @Test public void testPutBufferPermanentSuccessfulGet() throws IOException, InterruptedException {
    testPutBufferSuccessfulGet(new JobID(),new JobID(),PERMANENT_BLOB);
  }
  /** 
 * Uploads two byte arrays for different jobs into the server via the  {@link BlobCacheService}. File transfers should be successful.
 * @param jobId1 first job id
 * @param jobId2 second job id
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testPutBufferSuccessfulGet(  @Nullable JobID jobId1,  @Nullable JobID jobId2,  BlobKey.BlobType blobType) throws IOException, InterruptedException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      byte[] data2=Arrays.copyOfRange(data,10,54);
      BlobKey key1a=put(cache,jobId1,data,blobType);
      assertNotNull(key1a);
      verifyType(blobType,key1a);
      BlobKey key1a2=put(cache,jobId1,data,blobType);
      assertNotNull(key1a2);
      verifyType(blobType,key1a2);
      verifyKeyDifferentHashEquals(key1a,key1a2);
      BlobKey key1b=put(cache,jobId1,data2,blobType);
      assertNotNull(key1b);
      verifyType(blobType,key1b);
      verifyContents(server,jobId1,key1a,data);
      verifyContents(server,jobId1,key1a2,data);
      verifyContents(server,jobId1,key1b,data2);
      BlobKey key2a=put(cache,jobId2,data,blobType);
      assertNotNull(key2a);
      verifyType(blobType,key2a);
      verifyKeyDifferentHashEquals(key1a,key2a);
      BlobKey key2b=put(cache,jobId2,data2,blobType);
      assertNotNull(key2b);
      verifyType(blobType,key2b);
      verifyKeyDifferentHashEquals(key1b,key2b);
      verifyContents(server,jobId1,key1a,data);
      verifyContents(server,jobId1,key1a2,data);
      verifyContents(server,jobId1,key1b,data2);
      verifyContents(server,jobId2,key2a,data);
      verifyContents(server,jobId2,key2b,data2);
      verifyContents(cache,jobId1,key1a,data);
      verifyContents(cache,jobId1,key1b,data2);
      verifyContents(cache,jobId2,key2a,data);
      verifyContents(cache,jobId2,key2b,data2);
      if (blobType == TRANSIENT_BLOB) {
        verifyDeletedEventually(server,jobId1,key1a);
        verifyDeletedEventually(server,jobId1,key1b);
        verifyDeletedEventually(server,jobId2,key2a);
        verifyDeletedEventually(server,jobId2,key2b);
        verifyContents(cache,jobId1,key1a,data);
        verifyContents(cache,jobId1,key1b,data2);
        verifyContents(cache,jobId2,key2a,data);
        verifyContents(cache,jobId2,key2b,data2);
      }
 else {
        verifyContents(server,jobId1,key1a,data);
        verifyContents(server,jobId1,key1b,data2);
        verifyContents(server,jobId2,key2a,data);
        verifyContents(server,jobId2,key2b,data2);
      }
    }
   }
  @Test public void testPutStreamTransientSuccessfulGet1() throws IOException, InterruptedException {
    testPutStreamTransientSuccessfulGet(null,null);
  }
  @Test public void testPutStreamTransientSuccessfulGet2() throws IOException, InterruptedException {
    testPutStreamTransientSuccessfulGet(null,new JobID());
  }
  @Test public void testPutStreamTransientSuccessfulGet3() throws IOException, InterruptedException {
    testPutStreamTransientSuccessfulGet(new JobID(),new JobID());
  }
  @Test public void testPutStreamTransientSuccessfulGet4() throws IOException, InterruptedException {
    testPutStreamTransientSuccessfulGet(new JobID(),null);
  }
  /** 
 * Uploads two file streams for different jobs into the server via the  {@link BlobCacheService}. File transfers should be successful. <p>Note that high-availability uploads of streams is currently only possible at the  {@link BlobServer}.
 * @param jobId1 first job id
 * @param jobId2 second job id
 */
  private void testPutStreamTransientSuccessfulGet(  @Nullable JobID jobId1,  @Nullable JobID jobId2) throws IOException, InterruptedException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      byte[] data2=Arrays.copyOfRange(data,10,54);
      TransientBlobKey key1a=(TransientBlobKey)put(cache,jobId1,new ByteArrayInputStream(data),TRANSIENT_BLOB);
      assertNotNull(key1a);
      BlobKey key1a2=put(cache,jobId1,new ByteArrayInputStream(data),TRANSIENT_BLOB);
      assertNotNull(key1a2);
      verifyKeyDifferentHashEquals(key1a,key1a2);
      TransientBlobKey key1b=(TransientBlobKey)put(cache,jobId1,new ByteArrayInputStream(data2),TRANSIENT_BLOB);
      assertNotNull(key1b);
      verifyContents(server,jobId1,key1a,data);
      verifyContents(server,jobId1,key1a2,data);
      verifyContents(server,jobId1,key1b,data2);
      TransientBlobKey key2a=(TransientBlobKey)put(cache,jobId2,new ByteArrayInputStream(data),TRANSIENT_BLOB);
      assertNotNull(key2a);
      verifyKeyDifferentHashEquals(key1a,key2a);
      TransientBlobKey key2b=(TransientBlobKey)put(cache,jobId2,new ByteArrayInputStream(data2),TRANSIENT_BLOB);
      assertNotNull(key2b);
      verifyKeyDifferentHashEquals(key1b,key2b);
      verifyContents(server,jobId1,key1a,data);
      verifyContents(server,jobId1,key1a2,data);
      verifyContents(server,jobId1,key1b,data2);
      verifyContents(server,jobId2,key2a,data);
      verifyContents(server,jobId2,key2b,data2);
      verifyContents(cache,jobId1,key1a,data);
      verifyContents(cache,jobId1,key1b,data2);
      verifyContents(cache,jobId2,key2a,data);
      verifyContents(cache,jobId2,key2b,data2);
      verifyDeletedEventually(server,jobId1,key1a);
      verifyDeletedEventually(server,jobId1,key1b);
      verifyDeletedEventually(server,jobId2,key2a);
      verifyDeletedEventually(server,jobId2,key2b);
      verifyContents(cache,jobId1,key1a,data);
      verifyContents(cache,jobId1,key1b,data2);
      verifyContents(cache,jobId2,key2a,data);
      verifyContents(cache,jobId2,key2b,data2);
    }
   }
  @Test public void testPutChunkedStreamTransientSuccessfulGet1() throws IOException, InterruptedException {
    testPutChunkedStreamTransientSuccessfulGet(null,null);
  }
  @Test public void testPutChunkedStreamTransientSuccessfulGet2() throws IOException, InterruptedException {
    testPutChunkedStreamTransientSuccessfulGet(null,new JobID());
  }
  @Test public void testPutChunkedStreamTransientSuccessfulGet3() throws IOException, InterruptedException {
    testPutChunkedStreamTransientSuccessfulGet(new JobID(),new JobID());
  }
  @Test public void testPutChunkedStreamTransientSuccessfulGet4() throws IOException, InterruptedException {
    testPutChunkedStreamTransientSuccessfulGet(new JobID(),null);
  }
  /** 
 * Uploads two chunked file streams for different jobs into the server via the  {@link BlobCacheService}. File transfers should be successful. <p>Note that high-availability uploads of streams is currently only possible at the  {@link BlobServer}.
 * @param jobId1 first job id
 * @param jobId2 second job id
 */
  private void testPutChunkedStreamTransientSuccessfulGet(  @Nullable JobID jobId1,  @Nullable JobID jobId2) throws IOException, InterruptedException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      byte[] data2=Arrays.copyOfRange(data,10,54);
      TransientBlobKey key1a=(TransientBlobKey)put(cache,jobId1,new ChunkedInputStream(data,19),TRANSIENT_BLOB);
      assertNotNull(key1a);
      BlobKey key1a2=put(cache,jobId1,new ChunkedInputStream(data,19),TRANSIENT_BLOB);
      assertNotNull(key1a2);
      verifyKeyDifferentHashEquals(key1a,key1a2);
      TransientBlobKey key1b=(TransientBlobKey)put(cache,jobId1,new ChunkedInputStream(data2,19),TRANSIENT_BLOB);
      assertNotNull(key1b);
      verifyContents(server,jobId1,key1a,data);
      verifyContents(server,jobId1,key1a2,data);
      verifyContents(server,jobId1,key1b,data2);
      TransientBlobKey key2a=(TransientBlobKey)put(cache,jobId2,new ChunkedInputStream(data,19),TRANSIENT_BLOB);
      assertNotNull(key2a);
      verifyKeyDifferentHashEquals(key1a,key2a);
      TransientBlobKey key2b=(TransientBlobKey)put(cache,jobId2,new ChunkedInputStream(data2,19),TRANSIENT_BLOB);
      assertNotNull(key2b);
      verifyKeyDifferentHashEquals(key1b,key2b);
      verifyContents(server,jobId1,key1a,data);
      verifyContents(server,jobId1,key1a2,data);
      verifyContents(server,jobId1,key1b,data2);
      verifyContents(server,jobId2,key2a,data);
      verifyContents(server,jobId2,key2b,data2);
      verifyContents(cache,jobId1,key1a,data);
      verifyContents(cache,jobId1,key1b,data2);
      verifyContents(cache,jobId2,key2a,data);
      verifyContents(cache,jobId2,key2b,data2);
      verifyDeletedEventually(server,jobId1,key1a);
      verifyDeletedEventually(server,jobId1,key1b);
      verifyDeletedEventually(server,jobId2,key2a);
      verifyDeletedEventually(server,jobId2,key2b);
      verifyContents(cache,jobId1,key1a,data);
      verifyContents(cache,jobId1,key1b,data2);
      verifyContents(cache,jobId2,key2a,data);
      verifyContents(cache,jobId2,key2b,data2);
    }
   }
  @Test public void testPutBufferFailsNoJob() throws IOException {
    testPutBufferFails(null,TRANSIENT_BLOB);
  }
  @Test public void testPutBufferFailsForJob() throws IOException {
    testPutBufferFails(new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testPutBufferFailsForJobHa() throws IOException {
    testPutBufferFails(new JobID(),PERMANENT_BLOB);
  }
  /** 
 * Uploads a byte array to a server which cannot create any files via the  {@link BlobCacheService}. File transfers should fail.
 * @param jobId job id
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testPutBufferFails(  @Nullable final JobID jobId,  BlobKey.BlobType blobType) throws IOException {
    assumeTrue(!OperatingSystem.isWindows());
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    File tempFileDir=null;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      tempFileDir=server.createTemporaryFilename().getParentFile().getParentFile();
      assertTrue(tempFileDir.setExecutable(true,false));
      assertTrue(tempFileDir.setReadable(true,false));
      assertTrue(tempFileDir.setWritable(false,false));
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      exception.expect(IOException.class);
      exception.expectMessage("PUT operation failed: ");
      put(cache,jobId,data,blobType);
    }
  finally {
      if (tempFileDir != null) {
        tempFileDir.setWritable(true,false);
      }
    }
  }
  @Test public void testPutBufferFailsIncomingNoJob() throws IOException {
    testPutBufferFailsIncoming(null,TRANSIENT_BLOB);
  }
  @Test public void testPutBufferFailsIncomingForJob() throws IOException {
    testPutBufferFailsIncoming(new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testPutBufferFailsIncomingForJobHa() throws IOException {
    testPutBufferFailsIncoming(new JobID(),PERMANENT_BLOB);
  }
  /** 
 * Uploads a byte array to a server which cannot create incoming files via the  {@link BlobCacheService}. File transfers should fail.
 * @param jobId job id
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testPutBufferFailsIncoming(  @Nullable final JobID jobId,  BlobKey.BlobType blobType) throws IOException {
    assumeTrue(!OperatingSystem.isWindows());
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    File tempFileDir=null;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      tempFileDir=server.createTemporaryFilename().getParentFile();
      assertTrue(tempFileDir.setExecutable(true,false));
      assertTrue(tempFileDir.setReadable(true,false));
      assertTrue(tempFileDir.setWritable(false,false));
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      exception.expect(IOException.class);
      exception.expectMessage("PUT operation failed: ");
      try {
        put(cache,jobId,data,blobType);
      }
  finally {
        File storageDir=tempFileDir.getParentFile();
        assertArrayEquals(new String[]{"incoming"},storageDir.list());
      }
    }
  finally {
      if (tempFileDir != null) {
        tempFileDir.setWritable(true,false);
      }
    }
  }
  @Test public void testPutBufferFailsStoreNoJob() throws IOException {
    testPutBufferFailsStore(null,TRANSIENT_BLOB);
  }
  @Test public void testPutBufferFailsStoreForJob() throws IOException {
    testPutBufferFailsStore(new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testPutBufferFailsStoreForJobHa() throws IOException {
    testPutBufferFailsStore(new JobID(),PERMANENT_BLOB);
  }
  /** 
 * Uploads a byte array to a server which cannot create files via the  {@link BlobCacheService}. File transfers should fail.
 * @param jobId job id
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testPutBufferFailsStore(  @Nullable final JobID jobId,  BlobKey.BlobType blobType) throws IOException {
    assumeTrue(!OperatingSystem.isWindows());
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    File jobStoreDir=null;
    try (BlobServer server=new BlobServer(config,new VoidBlobStore());BlobCacheService cache=new BlobCacheService(config,new VoidBlobStore(),new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      jobStoreDir=server.getStorageLocation(jobId,BlobKey.createKey(blobType)).getParentFile();
      assertTrue(jobStoreDir.setExecutable(true,false));
      assertTrue(jobStoreDir.setReadable(true,false));
      assertTrue(jobStoreDir.setWritable(false,false));
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      exception.expect(IOException.class);
      exception.expectMessage("PUT operation failed: ");
      try {
        put(cache,jobId,data,blobType);
      }
  finally {
        File incomingFileDir=new File(jobStoreDir.getParent(),"incoming");
        assertArrayEquals(new String[]{},incomingFileDir.list());
        assertArrayEquals(new String[]{},jobStoreDir.list());
      }
    }
  finally {
      if (jobStoreDir != null) {
        jobStoreDir.setWritable(true,false);
      }
    }
  }
  @Test public void testConcurrentPutOperationsNoJob() throws IOException, ExecutionException, InterruptedException {
    testConcurrentPutOperations(null,TRANSIENT_BLOB);
  }
  @Test public void testConcurrentPutOperationsForJob() throws IOException, ExecutionException, InterruptedException {
    testConcurrentPutOperations(new JobID(),TRANSIENT_BLOB);
  }
  @Test public void testConcurrentPutOperationsForJobHa() throws IOException, ExecutionException, InterruptedException {
    testConcurrentPutOperations(new JobID(),PERMANENT_BLOB);
  }
  /** 
 * [FLINK-6020] Tests that concurrent put operations will only upload the file once to the  {@link BlobStore}and that the files are not corrupt at any time.
 * @param jobId job ID to use (or <tt>null</tt> if job-unrelated)
 * @param blobType whether the BLOB should become permanent or transient
 */
  private void testConcurrentPutOperations(  @Nullable final JobID jobId,  final BlobKey.BlobType blobType) throws IOException, InterruptedException, ExecutionException {
    final Configuration config=new Configuration();
    config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
    final BlobStore blobStoreServer=mock(BlobStore.class);
    final BlobStore blobStoreCache=mock(BlobStore.class);
    int concurrentPutOperations=2;
    int dataSize=1024;
    final CountDownLatch countDownLatch=new CountDownLatch(concurrentPutOperations);
    final byte[] data=new byte[dataSize];
    final List<Path> jars;
    if (blobType == PERMANENT_BLOB) {
      File tmpFile=temporaryFolder.newFile();
      FileUtils.writeByteArrayToFile(tmpFile,data);
      jars=Collections.singletonList(new Path(tmpFile.getAbsolutePath()));
    }
 else {
      jars=null;
    }
    Collection<CompletableFuture<BlobKey>> allFutures=new ArrayList<>(concurrentPutOperations);
    ExecutorService executor=Executors.newFixedThreadPool(concurrentPutOperations);
    try (final BlobServer server=new BlobServer(config,blobStoreServer);final BlobCacheService cache=new BlobCacheService(config,blobStoreCache,new InetSocketAddress("localhost",server.getPort()))){
      server.start();
      final InetSocketAddress serverAddress=new InetSocketAddress("localhost",server.getPort());
      for (int i=0; i < concurrentPutOperations; i++) {
        final Supplier<BlobKey> callable;
        if (blobType == PERMANENT_BLOB) {
          callable=() -> {
            try {
              List<PermanentBlobKey> keys=BlobClient.uploadFiles(serverAddress,config,jobId,jars);
              assertEquals(1,keys.size());
              BlobKey uploadedKey=keys.get(0);
              verifyContents(server,jobId,uploadedKey,data);
              return uploadedKey;
            }
 catch (            IOException e) {
              throw new CompletionException(new FlinkException("Could not upload blob.",e));
            }
          }
;
        }
 else {
          callable=() -> {
            try {
              BlockingInputStream inputStream=new BlockingInputStream(countDownLatch,data);
              BlobKey uploadedKey=put(cache,jobId,inputStream,blobType);
              verifyContents(server,jobId,uploadedKey,data);
              return uploadedKey;
            }
 catch (            IOException e) {
              throw new CompletionException(new FlinkException("Could not upload blob.",e));
            }
          }
;
        }
        CompletableFuture<BlobKey> putFuture=CompletableFuture.supplyAsync(callable,executor);
        allFutures.add(putFuture);
      }
      FutureUtils.ConjunctFuture<Collection<BlobKey>> conjunctFuture=FutureUtils.combineAll(allFutures);
      Collection<BlobKey> blobKeys=conjunctFuture.get();
      Iterator<BlobKey> blobKeyIterator=blobKeys.iterator();
      assertTrue(blobKeyIterator.hasNext());
      BlobKey blobKey=blobKeyIterator.next();
      while (blobKeyIterator.hasNext()) {
        verifyKeyDifferentHashEquals(blobKey,blobKeyIterator.next());
      }
      verifyContents(server,jobId,blobKey,data);
      if (blobType == PERMANENT_BLOB) {
        verify(blobStoreServer,times(1)).put(any(File.class),eq(jobId),eq(blobKey));
      }
 else {
        verify(blobStoreServer,times(0)).put(any(File.class),eq(jobId),eq(blobKey));
      }
      verify(blobStoreCache,times(0)).put(any(File.class),eq(jobId),eq(blobKey));
    }
  finally {
      executor.shutdownNow();
    }
  }
  /** 
 * Checks that the given blob will be deleted at the  {@link BlobServer} eventually (waits at most 30s).
 * @param server BLOB server
 * @param jobId job ID or <tt>null</tt> if job-unrelated
 * @param keys key(s) identifying the BLOB to request
 */
  static void verifyDeletedEventually(  BlobServer server,  @Nullable JobID jobId,  BlobKey... keys) throws IOException, InterruptedException {
    long deadline=System.currentTimeMillis() + 30_000L;
    do {
      Thread.sleep(10);
    }
 while (checkFilesExist(jobId,Arrays.asList(keys),server,false) != 0 && System.currentTimeMillis() < deadline);
    for (    BlobKey key : keys) {
      verifyDeleted(server,jobId,key);
    }
  }
}
