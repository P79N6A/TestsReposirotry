/** 
 * Test that the configuration mechanism for how tasks react on checkpoint errors works correctly.
 */
public class CheckpointExceptionHandlerConfigurationTest extends TestLogger {
  @Test public void testConfigurationFailOnException() throws Exception {
    testConfigForwarding(true);
  }
  @Test public void testConfigurationDeclineOnException() throws Exception {
    testConfigForwarding(false);
  }
  @Test public void testFailIsDefaultConfig(){
    ExecutionConfig newExecutionConfig=new ExecutionConfig();
    Assert.assertTrue(newExecutionConfig.isFailTaskOnCheckpointError());
  }
  private void testConfigForwarding(  boolean failOnException) throws Exception {
    final boolean expectedHandlerFlag=failOnException;
    final DummyEnvironment environment=new DummyEnvironment("test",1,0);
    environment.setTaskStateManager(new TestTaskStateManager());
    environment.getExecutionConfig().setFailTaskOnCheckpointError(expectedHandlerFlag);
    final CheckpointExceptionHandlerFactory inspectingFactory=new CheckpointExceptionHandlerFactory(){
      @Override public CheckpointExceptionHandler createCheckpointExceptionHandler(      boolean failTaskOnCheckpointException,      Environment environment){
        Assert.assertEquals(expectedHandlerFlag,failTaskOnCheckpointException);
        return super.createCheckpointExceptionHandler(failTaskOnCheckpointException,environment);
      }
    }
;
    StreamTask streamTask=new StreamTask(environment,null){
      @Override protected void init() throws Exception {
      }
      @Override protected void run() throws Exception {
      }
      @Override protected void cleanup() throws Exception {
      }
      @Override protected void cancelTask() throws Exception {
      }
      @Override protected CheckpointExceptionHandlerFactory createCheckpointExceptionHandlerFactory(){
        return inspectingFactory;
      }
    }
;
    streamTask.invoke();
  }
  @Test public void testCheckpointConfigDefault() throws Exception {
    StreamExecutionEnvironment streamExecutionEnvironment=StreamExecutionEnvironment.getExecutionEnvironment();
    Assert.assertTrue(streamExecutionEnvironment.getCheckpointConfig().isFailOnCheckpointingErrors());
  }
  @Test public void testPropagationFailFromCheckpointConfig() throws Exception {
    doTestPropagationFromCheckpointConfig(true);
  }
  @Test public void testPropagationDeclineFromCheckpointConfig() throws Exception {
    doTestPropagationFromCheckpointConfig(false);
  }
  public void doTestPropagationFromCheckpointConfig(  boolean failTaskOnCheckpointErrors) throws Exception {
    StreamExecutionEnvironment streamExecutionEnvironment=StreamExecutionEnvironment.getExecutionEnvironment();
    streamExecutionEnvironment.setParallelism(1);
    streamExecutionEnvironment.getCheckpointConfig().setCheckpointInterval(1000);
    streamExecutionEnvironment.getCheckpointConfig().setFailOnCheckpointingErrors(failTaskOnCheckpointErrors);
    streamExecutionEnvironment.addSource(new SourceFunction<Integer>(){
      @Override public void run(      SourceContext<Integer> ctx) throws Exception {
      }
      @Override public void cancel(){
      }
    }
).addSink(new DiscardingSink<>());
    StreamGraph streamGraph=streamExecutionEnvironment.getStreamGraph();
    JobGraph jobGraph=StreamingJobGraphGenerator.createJobGraph(streamGraph);
    SerializedValue<ExecutionConfig> serializedExecutionConfig=jobGraph.getSerializedExecutionConfig();
    ExecutionConfig executionConfig=serializedExecutionConfig.deserializeValue(Thread.currentThread().getContextClassLoader());
    Assert.assertEquals(failTaskOnCheckpointErrors,executionConfig.isFailTaskOnCheckpointError());
  }
}
