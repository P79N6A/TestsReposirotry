/** 
 * Test the recovery of a simple batch program in the case of TaskManager process failure.
 */
@SuppressWarnings("serial") @RunWith(Parameterized.class) public class TaskManagerProcessFailureBatchRecoveryITCase extends AbstractTaskManagerProcessFailureRecoveryTest {
  private final ExecutionMode executionMode;
  public TaskManagerProcessFailureBatchRecoveryITCase(  ExecutionMode executionMode){
    this.executionMode=executionMode;
  }
  @Parameterized.Parameters public static Collection<Object[]> executionMode(){
    return Arrays.asList(new Object[][]{{ExecutionMode.PIPELINED},{ExecutionMode.BATCH}});
  }
  @Override public void testTaskManagerFailure(  int jobManagerPort,  final File coordinateDir) throws Exception {
    final Configuration configuration=new Configuration();
    configuration.setString(CoreOptions.MODE,CoreOptions.LEGACY_MODE);
    ExecutionEnvironment env=ExecutionEnvironment.createRemoteEnvironment("localhost",jobManagerPort,configuration);
    env.setParallelism(PARALLELISM);
    env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1,10000));
    env.getConfig().setExecutionMode(executionMode);
    env.getConfig().disableSysoutLogging();
    final long numElements=100000L;
    final DataSet<Long> result=env.generateSequence(1,numElements).rebalance().map(new RichMapFunction<Long,Long>(){
      private final File proceedFile=new File(coordinateDir,PROCEED_MARKER_FILE);
      private boolean markerCreated=false;
      private boolean checkForProceedFile=true;
      @Override public Long map(      Long value) throws Exception {
        if (!markerCreated) {
          int taskIndex=getRuntimeContext().getIndexOfThisSubtask();
          touchFile(new File(coordinateDir,READY_MARKER_FILE_PREFIX + taskIndex));
          markerCreated=true;
        }
        if (checkForProceedFile) {
          if (proceedFile.exists()) {
            checkForProceedFile=false;
          }
 else {
            Thread.sleep(100);
          }
        }
        return value;
      }
    }
).reduce(new ReduceFunction<Long>(){
      @Override public Long reduce(      Long value1,      Long value2){
        return value1 + value2;
      }
    }
);
    long sum=result.collect().get(0);
    assertEquals(numElements * (numElements + 1L) / 2L,sum);
  }
}
