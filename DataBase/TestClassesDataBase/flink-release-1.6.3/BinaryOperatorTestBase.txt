@RunWith(Parameterized.class) public abstract class BinaryOperatorTestBase<S extends Function,IN,OUT> extends TestLogger implements TaskContext<S,OUT> {
  protected static final int PAGE_SIZE=32 * 1024;
  private final IOManager ioManager;
  private final MemoryManager memManager;
  private final List<MutableObjectIterator<IN>> inputs;
  private final List<TypeComparator<IN>> comparators;
  private final List<UnilateralSortMerger<IN>> sorters;
  private final AbstractInvokable owner;
  private final TaskConfig taskConfig;
  private final TaskManagerRuntimeInfo taskManageInfo;
  protected final long perSortMem;
  protected final double perSortFractionMem;
  private Collector<OUT> output;
  protected int numFileHandles;
  private S stub;
  private Driver<S,IN> driver;
  private volatile boolean running=true;
  private ExecutionConfig executionConfig;
  private List<TypeSerializer<IN>> inputSerializers=new ArrayList<>();
  protected BinaryOperatorTestBase(  ExecutionConfig executionConfig,  long memory,  int maxNumSorters,  long perSortMemory){
    if (memory < 0 || maxNumSorters < 0 || perSortMemory < 0) {
      throw new IllegalArgumentException();
    }
    final long totalMem=Math.max(memory,0) + (Math.max(maxNumSorters,0) * perSortMemory);
    this.perSortMem=perSortMemory;
    this.perSortFractionMem=(double)perSortMemory / totalMem;
    this.ioManager=new IOManagerAsync();
    this.memManager=totalMem > 0 ? new MemoryManager(totalMem,1) : null;
    this.inputs=new ArrayList<>();
    this.comparators=new ArrayList<>();
    this.sorters=new ArrayList<>();
    this.owner=new DummyInvokable();
    this.taskConfig=new TaskConfig(new Configuration());
    this.executionConfig=executionConfig;
    this.taskManageInfo=new TestingTaskManagerRuntimeInfo();
  }
  @Parameterized.Parameters public static Collection<Object[]> getConfigurations() throws IOException {
    LinkedList<Object[]> configs=new LinkedList<>();
    ExecutionConfig withReuse=new ExecutionConfig();
    withReuse.enableObjectReuse();
    ExecutionConfig withoutReuse=new ExecutionConfig();
    withoutReuse.disableObjectReuse();
    Object[] a={withoutReuse};
    configs.add(a);
    Object[] b={withReuse};
    configs.add(b);
    return configs;
  }
  public void addInput(  MutableObjectIterator<IN> input,  TypeSerializer<IN> serializer){
    this.inputs.add(input);
    this.sorters.add(null);
    this.inputSerializers.add(serializer);
  }
  @SuppressWarnings("unchecked") public void addInputSorted(  MutableObjectIterator<IN> input,  TypeSerializer<IN> serializer,  TypeComparator<IN> comp) throws Exception {
    this.inputSerializers.add(serializer);
    UnilateralSortMerger<IN> sorter=new UnilateralSortMerger<>(this.memManager,this.ioManager,input,this.owner,new RuntimeSerializerFactory<>(serializer,(Class<IN>)serializer.createInstance().getClass()),comp,this.perSortFractionMem,32,0.8f,true,false);
    this.sorters.add(sorter);
    this.inputs.add(null);
  }
  public void addDriverComparator(  TypeComparator<IN> comparator){
    this.comparators.add(comparator);
  }
  public void setOutput(  Collector<OUT> output){
    this.output=output;
  }
  public void setOutput(  List<OUT> output,  TypeSerializer<OUT> outSerializer){
    this.output=new ListOutputCollector<>(output,outSerializer);
  }
  public int getNumFileHandlesForSort(){
    return numFileHandles;
  }
  public void setNumFileHandlesForSort(  int numFileHandles){
    this.numFileHandles=numFileHandles;
  }
  @SuppressWarnings("rawtypes") public void testDriver(  Driver driver,  Class stubClass) throws Exception {
    testDriverInternal(driver,stubClass);
  }
  @SuppressWarnings({"unchecked","rawtypes"}) public void testDriverInternal(  Driver driver,  Class stubClass) throws Exception {
    this.driver=driver;
    driver.setup(this);
    this.stub=(S)stubClass.newInstance();
    this.running=true;
    boolean stubOpen=false;
    try {
      try {
        driver.prepare();
      }
 catch (      Throwable t) {
        throw new Exception("The data preparation caused an error: " + t.getMessage(),t);
      }
      try {
        FunctionUtils.openFunction(this.stub,getTaskConfig().getStubParameters());
        stubOpen=true;
      }
 catch (      Throwable t) {
        throw new Exception("The user defined 'open()' method caused an exception: " + t.getMessage(),t);
      }
      if (!running) {
        return;
      }
      driver.run();
      if (this.running) {
        FunctionUtils.closeFunction(this.stub);
        stubOpen=false;
      }
      this.output.close();
    }
 catch (    Exception ex) {
      if (stubOpen) {
        try {
          FunctionUtils.closeFunction(this.stub);
        }
 catch (        Throwable ignored) {
        }
      }
      if (this.driver instanceof ResettableDriver) {
        final ResettableDriver<?,?> resDriver=(ResettableDriver<?,?>)this.driver;
        try {
          resDriver.teardown();
        }
 catch (        Throwable t) {
          throw new Exception("Error while shutting down an iterative operator: " + t.getMessage(),t);
        }
      }
      if (this.running) {
        throw ex;
      }
    }
 finally {
      driver.cleanup();
    }
  }
  @SuppressWarnings({"unchecked","rawtypes"}) public void testResettableDriver(  ResettableDriver driver,  Class stubClass,  int iterations) throws Exception {
    driver.setup(this);
    for (int i=0; i < iterations; i++) {
      if (i == 0) {
        driver.initialize();
      }
 else {
        driver.reset();
      }
      testDriver(driver,stubClass);
    }
    driver.teardown();
  }
  public void cancel() throws Exception {
    this.running=false;
    while (this.driver == null) {
      Thread.sleep(200);
    }
    this.driver.cancel();
  }
  @Override public TaskConfig getTaskConfig(){
    return this.taskConfig;
  }
  @Override public TaskManagerRuntimeInfo getTaskManagerInfo(){
    return this.taskManageInfo;
  }
  @Override public ExecutionConfig getExecutionConfig(){
    return executionConfig;
  }
  @Override public ClassLoader getUserCodeClassLoader(){
    return getClass().getClassLoader();
  }
  @Override public IOManager getIOManager(){
    return this.ioManager;
  }
  @Override public MemoryManager getMemoryManager(){
    return this.memManager;
  }
  @Override public <X>MutableObjectIterator<X> getInput(  int index){
    MutableObjectIterator<IN> in=this.inputs.get(index);
    if (in == null) {
      try {
        in=this.sorters.get(index).getIterator();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Interrupted");
      }
      this.inputs.set(index,in);
    }
    @SuppressWarnings("unchecked") MutableObjectIterator<X> input=(MutableObjectIterator<X>)this.inputs.get(index);
    return input;
  }
  @Override @SuppressWarnings("unchecked") public <X>TypeSerializerFactory<X> getInputSerializer(  int index){
    TypeSerializer<X> ser=(TypeSerializer<X>)this.inputSerializers.get(index);
    return new RuntimeSerializerFactory<>(ser,(Class<X>)ser.createInstance().getClass());
  }
  @Override public <X>TypeComparator<X> getDriverComparator(  int index){
    @SuppressWarnings("unchecked") TypeComparator<X> comparator=(TypeComparator<X>)this.comparators.get(index);
    return comparator;
  }
  @Override public S getStub(){
    return this.stub;
  }
  @Override public Collector<OUT> getOutputCollector(){
    return this.output;
  }
  @Override public AbstractInvokable getContainingTask(){
    return this.owner;
  }
  @Override public String formatLogString(  String message){
    return "Driver Tester: " + message;
  }
  @Override public OperatorMetricGroup getMetricGroup(){
    return UnregisteredMetricGroups.createUnregisteredOperatorMetricGroup();
  }
  @After public void shutdownAll() throws Exception {
    for (    UnilateralSortMerger<?> sorter : this.sorters) {
      if (sorter != null) {
        sorter.close();
      }
    }
    this.sorters.clear();
    this.ioManager.shutdown();
    Assert.assertTrue("I/O Manager has not properly shut down.",this.ioManager.isProperlyShutDown());
    MemoryManager memMan=getMemoryManager();
    if (memMan != null) {
      Assert.assertTrue("Memory Manager managed memory was not completely freed.",memMan.verifyEmpty());
      memMan.shutdown();
    }
  }
private static final class ListOutputCollector<OUT> implements Collector<OUT> {
    private final List<OUT> output;
    private final TypeSerializer<OUT> serializer;
    public ListOutputCollector(    List<OUT> outputList,    TypeSerializer<OUT> serializer){
      this.output=outputList;
      this.serializer=serializer;
    }
    @Override public void collect(    OUT record){
      this.output.add(serializer.copy(record));
    }
    @Override public void close(){
    }
  }
public static final class CountingOutputCollector<OUT> implements Collector<OUT> {
    private int num;
    @Override public void collect(    OUT record){
      this.num++;
    }
    @Override public void close(){
    }
    public int getNumberOfRecords(){
      return this.num;
    }
  }
}
