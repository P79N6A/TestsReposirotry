/** 
 * Tests for  {@link Broker}.
 */
public class BrokerTest {
  @Test public void mediation() throws Exception {
    Random random=new Random();
    for (int n=0; n < 20; n++) {
      mediate(random.nextInt(10) + 1);
    }
  }
  void mediate(  int subtasks) throws InterruptedException, ExecutionException {
    final ExecutorService executorService=Executors.newFixedThreadPool(subtasks * 2);
    try {
      List<Callable<StringPair>> tasks=new ArrayList<>();
      Broker<String> broker=new Broker<String>();
      for (int subtask=0; subtask < subtasks; subtask++) {
        tasks.add(new IterationHead(broker,subtask,"value" + subtask));
        tasks.add(new IterationTail(broker,subtask));
      }
      Collections.shuffle(tasks);
      int numSuccessfulHandovers=0;
      for (      Future<StringPair> future : executorService.invokeAll(tasks)) {
        StringPair stringPair=future.get();
        if (stringPair != null) {
          assertEquals("value" + stringPair.getFirst(),stringPair.getSecond());
          numSuccessfulHandovers++;
        }
      }
      assertEquals(subtasks,numSuccessfulHandovers);
    }
  finally {
      executorService.shutdownNow();
    }
  }
class IterationHead implements Callable<StringPair> {
    private final Random random;
    private final Broker<String> broker;
    private final String key;
    private final String value;
    IterationHead(    Broker<String> broker,    Integer key,    String value){
      this.broker=broker;
      this.key=String.valueOf(key);
      this.value=value;
      random=new Random();
    }
    @Override public StringPair call() throws Exception {
      Thread.sleep(random.nextInt(10));
      broker.handIn(key,value);
      Thread.sleep(random.nextInt(10));
      return null;
    }
  }
class IterationTail implements Callable<StringPair> {
    private final Random random;
    private final Broker<String> broker;
    private final String key;
    IterationTail(    Broker<String> broker,    Integer key){
      this.broker=broker;
      this.key=String.valueOf(key);
      random=new Random();
    }
    @Override public StringPair call() throws Exception {
      Thread.sleep(random.nextInt(10));
      String value=broker.getAndRemove(key);
      Preconditions.checkNotNull(value);
      return new StringPair(key,value);
    }
  }
}
