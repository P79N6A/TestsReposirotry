/** 
 * This test validates that the Kryo-based serializer handles classes with custom class loaders correctly.
 */
public class KryoSerializerClassLoadingTest extends SerializerTestBase<Object> {
  /** 
 * Class loader for the object that is not in the test class path 
 */
  private static final ClassLoader CLASS_LOADER=new URLClassLoader(new URL[0],KryoSerializerClassLoadingTest.class.getClassLoader());
  /** 
 * An object that is not in the test class path 
 */
  private static final Serializable OBJECT_OUT_OF_CLASSPATH=CommonTestUtils.createObjectForClassNotInClassPath(CLASS_LOADER);
  private ClassLoader originalClassLoader;
  @Before public void setupClassLoader(){
    originalClassLoader=Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(CLASS_LOADER);
  }
  @After public void restoreOriginalClassLoader(){
    Thread.currentThread().setContextClassLoader(originalClassLoader);
  }
  @Test public void guardTestAssumptions(){
    try {
      Class.forName(OBJECT_OUT_OF_CLASSPATH.getClass().getName());
      fail("This test's assumptions are broken");
    }
 catch (    ClassNotFoundException ignored) {
    }
  }
  @Override protected TypeSerializer<Object> createSerializer(){
    return new KryoSerializer<>(Object.class,new ExecutionConfig());
  }
  @Override protected int getLength(){
    return -1;
  }
  @Override protected Class<Object> getTypeClass(){
    return Object.class;
  }
  @Override protected Object[] getTestData(){
    return new Object[]{new Integer(7),OBJECT_OUT_OF_CLASSPATH,new Tuple1<>(OBJECT_OUT_OF_CLASSPATH)};
  }
  @Override public void testInstantiate(){
  }
}
