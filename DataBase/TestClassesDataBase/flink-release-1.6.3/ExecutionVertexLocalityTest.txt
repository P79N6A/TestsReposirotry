/** 
 * Tests that the execution vertex handles locality preferences well.
 */
public class ExecutionVertexLocalityTest extends TestLogger {
  private final JobID jobId=new JobID();
  private final JobVertexID sourceVertexId=new JobVertexID();
  private final JobVertexID targetVertexId=new JobVertexID();
  /** 
 * This test validates that vertices that have only one input stream try to co-locate their tasks with the producer.
 */
  @Test public void testLocalityInputBasedForward() throws Exception {
    final int parallelism=10;
    final TaskManagerLocation[] locations=new TaskManagerLocation[parallelism];
    final ExecutionGraph graph=createTestGraph(parallelism,false);
    for (int i=0; i < parallelism; i++) {
      ExecutionVertex source=graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i];
      TaskManagerLocation location=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),10000 + i);
      locations[i]=location;
      initializeLocation(source,location);
    }
    for (int i=0; i < parallelism; i++) {
      ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
      Iterator<CompletableFuture<TaskManagerLocation>> preference=target.getPreferredLocations().iterator();
      assertTrue(preference.hasNext());
      assertEquals(locations[i],preference.next().get());
      assertFalse(preference.hasNext());
    }
  }
  /** 
 * This test validates that vertices with too many input streams do not have a location preference any more.
 */
  @Test public void testNoLocalityInputLargeAllToAll() throws Exception {
    final int parallelism=100;
    final ExecutionGraph graph=createTestGraph(parallelism,true);
    for (int i=0; i < parallelism; i++) {
      ExecutionVertex source=graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i];
      TaskManagerLocation location=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),10000 + i);
      initializeLocation(source,location);
    }
    for (int i=0; i < parallelism; i++) {
      ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
      Iterator<CompletableFuture<TaskManagerLocation>> preference=target.getPreferredLocations().iterator();
      assertFalse(preference.hasNext());
    }
  }
  /** 
 * This test validates that stateful vertices schedule based in the state's location (which is the prior execution's location).
 */
  @Test public void testLocalityBasedOnState() throws Exception {
    final int parallelism=10;
    final TaskManagerLocation[] locations=new TaskManagerLocation[parallelism];
    final ExecutionGraph graph=createTestGraph(parallelism,false);
    for (int i=0; i < parallelism; i++) {
      ExecutionVertex source=graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i];
      ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
      TaskManagerLocation randomLocation=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),10000 + i);
      TaskManagerLocation location=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),20000 + i);
      locations[i]=location;
      initializeLocation(source,randomLocation);
      initializeLocation(target,location);
      setState(source.getCurrentExecutionAttempt(),ExecutionState.CANCELED);
      setState(target.getCurrentExecutionAttempt(),ExecutionState.CANCELED);
    }
    for (    ExecutionJobVertex ejv : graph.getVerticesTopologically()) {
      ejv.resetForNewExecution(System.currentTimeMillis(),graph.getGlobalModVersion());
    }
    for (int i=0; i < parallelism; i++) {
      ExecutionVertex source=graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i];
      TaskManagerLocation randomLocation=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),30000 + i);
      initializeLocation(source,randomLocation);
      ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
      target.getCurrentExecutionAttempt().setInitialState(mock(JobManagerTaskRestore.class));
    }
    for (int i=0; i < parallelism; i++) {
      ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
      Iterator<CompletableFuture<TaskManagerLocation>> preference=target.getPreferredLocations().iterator();
      assertTrue(preference.hasNext());
      assertEquals(locations[i],preference.next().get());
      assertFalse(preference.hasNext());
    }
  }
  /** 
 * Creates a simple 2 vertex graph with a parallel source and a parallel target.
 */
  private ExecutionGraph createTestGraph(  int parallelism,  boolean allToAll) throws Exception {
    JobVertex source=new JobVertex("source",sourceVertexId);
    source.setParallelism(parallelism);
    source.setInvokableClass(NoOpInvokable.class);
    JobVertex target=new JobVertex("source",targetVertexId);
    target.setParallelism(parallelism);
    target.setInvokableClass(NoOpInvokable.class);
    DistributionPattern connectionPattern=allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE;
    target.connectNewDataSetAsInput(source,connectionPattern,ResultPartitionType.PIPELINED);
    JobGraph testJob=new JobGraph(jobId,"test job",source,target);
    final Time timeout=Time.seconds(10L);
    return ExecutionGraphBuilder.buildGraph(null,testJob,new Configuration(),TestingUtils.defaultExecutor(),TestingUtils.defaultExecutor(),mock(SlotProvider.class),getClass().getClassLoader(),new StandaloneCheckpointRecoveryFactory(),timeout,new FixedDelayRestartStrategy(10,0L),new UnregisteredMetricsGroup(),1,VoidBlobWriter.getInstance(),timeout,log);
  }
  private void initializeLocation(  ExecutionVertex vertex,  TaskManagerLocation location) throws Exception {
    SlotContext slot=new SimpleSlotContext(new AllocationID(),location,0,mock(TaskManagerGateway.class));
    SimpleSlot simpleSlot=new SimpleSlot(slot,mock(SlotOwner.class),0);
    if (!vertex.getCurrentExecutionAttempt().tryAssignResource(simpleSlot)) {
      throw new FlinkException("Could not assign resource.");
    }
  }
  private void setState(  Execution execution,  ExecutionState state) throws Exception {
    final Field stateField=Execution.class.getDeclaredField("state");
    stateField.setAccessible(true);
    stateField.set(execution,state);
  }
}
