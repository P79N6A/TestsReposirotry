public class JobLeaderIdServiceTest extends TestLogger {
  /** 
 * Tests adding a job and finding out its leader id
 */
  @Test(timeout=10000) public void testAddingJob() throws Exception {
    final JobID jobId=new JobID();
    final String address="foobar";
    final JobMasterId leaderId=JobMasterId.generate();
    TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    SettableLeaderRetrievalService leaderRetrievalService=new SettableLeaderRetrievalService(null,null);
    highAvailabilityServices.setJobMasterLeaderRetriever(jobId,leaderRetrievalService);
    ScheduledExecutor scheduledExecutor=mock(ScheduledExecutor.class);
    Time timeout=Time.milliseconds(5000L);
    JobLeaderIdActions jobLeaderIdActions=mock(JobLeaderIdActions.class);
    JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,scheduledExecutor,timeout);
    jobLeaderIdService.start(jobLeaderIdActions);
    jobLeaderIdService.addJob(jobId);
    CompletableFuture<JobMasterId> leaderIdFuture=jobLeaderIdService.getLeaderId(jobId);
    leaderRetrievalService.notifyListener(address,leaderId.toUUID());
    assertEquals(leaderId,leaderIdFuture.get());
    assertTrue(jobLeaderIdService.containsJob(jobId));
  }
  /** 
 * Tests that removing a job completes the job leader id future exceptionally
 */
  @Test(timeout=10000) public void testRemovingJob() throws Exception {
    final JobID jobId=new JobID();
    TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    SettableLeaderRetrievalService leaderRetrievalService=new SettableLeaderRetrievalService(null,null);
    highAvailabilityServices.setJobMasterLeaderRetriever(jobId,leaderRetrievalService);
    ScheduledExecutor scheduledExecutor=mock(ScheduledExecutor.class);
    Time timeout=Time.milliseconds(5000L);
    JobLeaderIdActions jobLeaderIdActions=mock(JobLeaderIdActions.class);
    JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,scheduledExecutor,timeout);
    jobLeaderIdService.start(jobLeaderIdActions);
    jobLeaderIdService.addJob(jobId);
    CompletableFuture<JobMasterId> leaderIdFuture=jobLeaderIdService.getLeaderId(jobId);
    jobLeaderIdService.removeJob(jobId);
    assertFalse(jobLeaderIdService.containsJob(jobId));
    try {
      leaderIdFuture.get();
      fail("The leader id future should be completed exceptionally.");
    }
 catch (    ExecutionException ignored) {
    }
  }
  /** 
 * Tests that the initial job registration registers a timeout which will call {@link JobLeaderIdActions#notifyJobTimeout(JobID,UUID)} when executed.
 */
  @Test public void testInitialJobTimeout() throws Exception {
    final JobID jobId=new JobID();
    TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    SettableLeaderRetrievalService leaderRetrievalService=new SettableLeaderRetrievalService(null,null);
    highAvailabilityServices.setJobMasterLeaderRetriever(jobId,leaderRetrievalService);
    ScheduledExecutor scheduledExecutor=mock(ScheduledExecutor.class);
    Time timeout=Time.milliseconds(5000L);
    JobLeaderIdActions jobLeaderIdActions=mock(JobLeaderIdActions.class);
    JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,scheduledExecutor,timeout);
    jobLeaderIdService.start(jobLeaderIdActions);
    jobLeaderIdService.addJob(jobId);
    assertTrue(jobLeaderIdService.containsJob(jobId));
    ArgumentCaptor<Runnable> runnableArgumentCaptor=ArgumentCaptor.forClass(Runnable.class);
    verify(scheduledExecutor).schedule(runnableArgumentCaptor.capture(),anyLong(),any(TimeUnit.class));
    Runnable timeoutRunnable=runnableArgumentCaptor.getValue();
    timeoutRunnable.run();
    ArgumentCaptor<UUID> timeoutIdArgumentCaptor=ArgumentCaptor.forClass(UUID.class);
    verify(jobLeaderIdActions,times(1)).notifyJobTimeout(eq(jobId),timeoutIdArgumentCaptor.capture());
    assertTrue(jobLeaderIdService.isValidTimeout(jobId,timeoutIdArgumentCaptor.getValue()));
  }
  /** 
 * Tests that a timeout get cancelled once a job leader has been found. Furthermore, it tests that a new timeout is registered after the jobmanager has lost leadership.
 */
  @Test(timeout=10000) public void jobTimeoutAfterLostLeadership() throws Exception {
    final JobID jobId=new JobID();
    final String address="foobar";
    final JobMasterId leaderId=JobMasterId.generate();
    TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
    SettableLeaderRetrievalService leaderRetrievalService=new SettableLeaderRetrievalService(null,null);
    highAvailabilityServices.setJobMasterLeaderRetriever(jobId,leaderRetrievalService);
    ScheduledFuture<?> timeout1=mock(ScheduledFuture.class);
    ScheduledFuture<?> timeout2=mock(ScheduledFuture.class);
    final Queue<ScheduledFuture<?>> timeoutQueue=new ArrayDeque<>(Arrays.asList(timeout1,timeout2));
    ScheduledExecutor scheduledExecutor=mock(ScheduledExecutor.class);
    final AtomicReference<Runnable> lastRunnable=new AtomicReference<>();
    doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocation) throws Throwable {
        lastRunnable.set((Runnable)invocation.getArguments()[0]);
        return timeoutQueue.poll();
      }
    }
).when(scheduledExecutor).schedule(any(Runnable.class),anyLong(),any(TimeUnit.class));
    Time timeout=Time.milliseconds(5000L);
    JobLeaderIdActions jobLeaderIdActions=mock(JobLeaderIdActions.class);
    final AtomicReference<UUID> lastTimeoutId=new AtomicReference<>();
    doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocation) throws Throwable {
        lastTimeoutId.set((UUID)invocation.getArguments()[1]);
        return null;
      }
    }
).when(jobLeaderIdActions).notifyJobTimeout(eq(jobId),any(UUID.class));
    JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,scheduledExecutor,timeout);
    jobLeaderIdService.start(jobLeaderIdActions);
    jobLeaderIdService.addJob(jobId);
    CompletableFuture<JobMasterId> leaderIdFuture=jobLeaderIdService.getLeaderId(jobId);
    leaderRetrievalService.notifyListener(address,leaderId.toUUID());
    assertEquals(leaderId,leaderIdFuture.get());
    assertTrue(jobLeaderIdService.containsJob(jobId));
    verify(timeout1,times(1)).cancel(anyBoolean());
    verify(scheduledExecutor,times(1)).schedule(any(Runnable.class),anyLong(),any(TimeUnit.class));
    Runnable runnable=lastRunnable.get();
    assertNotNull(runnable);
    runnable.run();
    verify(jobLeaderIdActions,times(1)).notifyJobTimeout(eq(jobId),any(UUID.class));
    assertFalse(jobLeaderIdService.isValidTimeout(jobId,lastTimeoutId.get()));
    leaderRetrievalService.notifyListener("",null);
    verify(scheduledExecutor,times(2)).schedule(any(Runnable.class),anyLong(),any(TimeUnit.class));
    runnable=lastRunnable.get();
    assertNotNull(runnable);
    runnable.run();
    verify(jobLeaderIdActions,times(2)).notifyJobTimeout(eq(jobId),any(UUID.class));
    assertTrue(jobLeaderIdService.isValidTimeout(jobId,lastTimeoutId.get()));
  }
}
