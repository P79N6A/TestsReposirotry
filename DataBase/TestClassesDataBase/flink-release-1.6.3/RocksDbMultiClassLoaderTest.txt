/** 
 * This test validates that the RocksDB JNI library loading works properly in the presence of the RocksDB code being loaded dynamically via reflection. That can happen when RocksDB is in the user code JAR, or in certain test setups.
 */
public class RocksDbMultiClassLoaderTest {
  @Rule public final TemporaryFolder tmp=new TemporaryFolder();
  @Test public void testTwoSeparateClassLoaders() throws Exception {
    final URL codePath1=RocksDBStateBackend.class.getProtectionDomain().getCodeSource().getLocation();
    final URL codePath2=RocksDB.class.getProtectionDomain().getCodeSource().getLocation();
    final ClassLoader parent=getClass().getClassLoader();
    final ClassLoader loader1=FlinkUserCodeClassLoaders.childFirst(new URL[]{codePath1,codePath2},parent,new String[0]);
    final ClassLoader loader2=FlinkUserCodeClassLoaders.childFirst(new URL[]{codePath1,codePath2},parent,new String[0]);
    final String className=RocksDBStateBackend.class.getName();
    final Class<?> clazz1=Class.forName(className,false,loader1);
    final Class<?> clazz2=Class.forName(className,false,loader2);
    assertNotEquals("Test broken - the two reflectively loaded classes are equal",clazz1,clazz2);
    final Object instance1=clazz1.getConstructor(String.class).newInstance(tmp.newFolder().toURI().toString());
    final Object instance2=clazz2.getConstructor(String.class).newInstance(tmp.newFolder().toURI().toString());
    final String tempDir=tmp.newFolder().getAbsolutePath();
    final Method meth1=clazz1.getDeclaredMethod("ensureRocksDBIsLoaded",String.class);
    final Method meth2=clazz2.getDeclaredMethod("ensureRocksDBIsLoaded",String.class);
    meth1.setAccessible(true);
    meth2.setAccessible(true);
    meth1.invoke(instance1,tempDir);
    meth2.invoke(instance2,tempDir);
  }
}
