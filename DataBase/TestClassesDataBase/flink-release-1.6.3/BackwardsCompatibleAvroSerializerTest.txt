/** 
 * This test ensures that state and state configuration created by Flink 1.3 Avro types that used the PojoSerializer still works (in most cases, see notice below). <p><b>Important:</b> Since Avro itself broke class compatibility between 1.7.7 (used in Flink 1.3) and 1.8.2 (used in Flink 1.4), the Avro by Pojo compatibility is broken through Avro already. This test only tests that the Avro serializer change (switching from Pojo to Avro for Avro types) works properly. <p>This test can be dropped once we drop backwards compatibility with Flink 1.3 snapshots. <p>The  {@link BackwardsCompatibleAvroSerializer} does not support custom Kryo registrations (whichlogical types require for Avro 1.8 because Kryo does not support Joda-Time). We introduced a simpler user record for pre-Avro 1.8 test cases.
 */
public class BackwardsCompatibleAvroSerializerTest {
  private static final String SNAPSHOT_RESOURCE="flink-1.6-avro-type-serializer-snapshot";
  private static final String DATA_RESOURCE="flink-1.6-avro-type-serialized-data";
  @SuppressWarnings("unused") private static final String SNAPSHOT_RESOURCE_WRITER="/data/repositories/flink/flink-formats/flink-avro/src/test/resources/" + SNAPSHOT_RESOURCE;
  @SuppressWarnings("unused") private static final String DATA_RESOURCE_WRITER="/data/repositories/flink/flink-formats/flink-avro/src/test/resources/" + DATA_RESOURCE;
  private static final long RANDOM_SEED=143065108437678L;
  private static final int NUM_DATA_ENTRIES=20;
  @Test public void testCompatibilityWithPojoSerializer() throws Exception {
    final TypeSerializer<SimpleUser> serializer;
    final TypeSerializerConfigSnapshot configSnapshot;
    try (InputStream in=getClass().getClassLoader().getResourceAsStream(SNAPSHOT_RESOURCE)){
      DataInputViewStreamWrapper inView=new DataInputViewStreamWrapper(in);
      List<Tuple2<TypeSerializer<?>,TypeSerializerConfigSnapshot>> deserialized=TypeSerializerSerializationUtil.readSerializersAndConfigsWithResilience(inView,getClass().getClassLoader());
      assertEquals(1,deserialized.size());
      @SuppressWarnings("unchecked") final TypeSerializer<SimpleUser> typedSerializer=(TypeSerializer<SimpleUser>)deserialized.get(0).f0;
      serializer=typedSerializer;
      configSnapshot=deserialized.get(0).f1;
    }
     assertNotNull(serializer);
    assertNotNull(configSnapshot);
    assertTrue(serializer instanceof PojoSerializer);
    assertTrue(configSnapshot instanceof PojoSerializerConfigSnapshot);
    validateDeserialization(serializer);
    assertFalse(serializer.ensureCompatibility(configSnapshot).isRequiresMigration());
    final TypeSerializer<SimpleUser> newSerializer=new AvroTypeInfo<>(SimpleUser.class,true).createSerializer(new ExecutionConfig());
    assertFalse(newSerializer.ensureCompatibility(configSnapshot).isRequiresMigration());
    validateDeserialization(newSerializer);
    TypeSerializerConfigSnapshot nextSnapshot=newSerializer.snapshotConfiguration();
    final TypeSerializer<SimpleUser> nextSerializer=new AvroTypeInfo<>(SimpleUser.class,true).createSerializer(new ExecutionConfig());
    assertFalse(nextSerializer.ensureCompatibility(nextSnapshot).isRequiresMigration());
    validateDeserialization(nextSerializer);
  }
  private static void validateDeserialization(  TypeSerializer<SimpleUser> serializer) throws IOException {
    final Random rnd=new Random(RANDOM_SEED);
    try (InputStream in=BackwardsCompatibleAvroSerializerTest.class.getClassLoader().getResourceAsStream(DATA_RESOURCE)){
      final DataInputViewStreamWrapper inView=new DataInputViewStreamWrapper(in);
      for (int i=0; i < NUM_DATA_ENTRIES; i++) {
        final SimpleUser deserialized=serializer.deserialize(inView);
        final SimpleUser reference=TestDataGenerator.generateRandomSimpleUser(rnd);
        assertEquals(reference,deserialized);
      }
    }
   }
}
