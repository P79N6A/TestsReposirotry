/** 
 * Tests for  {@link TimestampsAndPunctuatedWatermarksOperator}.
 */
public class TimestampsAndPunctuatedWatermarksOperatorTest {
  @Test @SuppressWarnings("unchecked") public void testTimestampsAndPeriodicWatermarksOperator() throws Exception {
    final TimestampsAndPunctuatedWatermarksOperator<Tuple2<Long,Boolean>> operator=new TimestampsAndPunctuatedWatermarksOperator<>(new PunctuatedExtractor());
    OneInputStreamOperatorTestHarness<Tuple2<Long,Boolean>,Tuple2<Long,Boolean>> testHarness=new OneInputStreamOperatorTestHarness<>(operator);
    testHarness.open();
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(3L,true),0L));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(5L,false),0L));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(4L,false),0L));
    testHarness.processWatermark(new Watermark(10));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(4L,false),0L));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(4L,true),0L));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(9L,false),0L));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(5L,false),0L));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(7L,true),0L));
    testHarness.processElement(new StreamRecord<>(new Tuple2<>(10L,false),0L));
    testHarness.processWatermark(new Watermark(Long.MAX_VALUE));
    ConcurrentLinkedQueue<Object> output=testHarness.getOutput();
    assertEquals(3L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(3L,((Watermark)output.poll()).getTimestamp());
    assertEquals(5L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(4L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(4L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(4L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(4L,((Watermark)output.poll()).getTimestamp());
    assertEquals(9L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(5L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(7L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(7L,((Watermark)output.poll()).getTimestamp());
    assertEquals(10L,((StreamRecord<Tuple2<Long,Boolean>>)output.poll()).getTimestamp());
    assertEquals(Long.MAX_VALUE,((Watermark)output.poll()).getTimestamp());
  }
  @Test public void testZeroOnNegativeTimestamps() throws Exception {
    final AssignerWithPunctuatedWatermarks<Long> assigner=new NeverWatermarkExtractor();
    final TimestampsAndPunctuatedWatermarksOperator<Long> operator=new TimestampsAndPunctuatedWatermarksOperator<Long>(assigner);
    OneInputStreamOperatorTestHarness<Long,Long> testHarness=new OneInputStreamOperatorTestHarness<Long,Long>(operator);
    testHarness.open();
    long[] values={Long.MIN_VALUE,-1L,0L,1L,2L,3L,Long.MAX_VALUE};
    for (    long value : values) {
      testHarness.processElement(new StreamRecord<>(value));
    }
    ConcurrentLinkedQueue<Object> output=testHarness.getOutput();
    for (    long value : values) {
      assertEquals(value,((StreamRecord<?>)output.poll()).getTimestamp());
    }
  }
private static class PunctuatedExtractor implements AssignerWithPunctuatedWatermarks<Tuple2<Long,Boolean>> {
    private static final long serialVersionUID=1L;
    @Override public long extractTimestamp(    Tuple2<Long,Boolean> element,    long previousTimestamp){
      return element.f0;
    }
    @Override public Watermark checkAndGetNextWatermark(    Tuple2<Long,Boolean> lastElement,    long extractedTimestamp){
      return lastElement.f1 ? new Watermark(extractedTimestamp) : null;
    }
  }
private static class NeverWatermarkExtractor implements AssignerWithPunctuatedWatermarks<Long> {
    private static final long serialVersionUID=1L;
    @Override public long extractTimestamp(    Long element,    long previousElementTimestamp){
      return element;
    }
    @Override public Watermark checkAndGetNextWatermark(    Long lastElement,    long extractedTimestamp){
      return null;
    }
  }
}
