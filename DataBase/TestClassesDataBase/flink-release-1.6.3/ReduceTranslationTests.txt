/** 
 * Tests for translation of reduce operation.
 */
@SuppressWarnings("serial") public class ReduceTranslationTests implements java.io.Serializable {
  @Test public void translateNonGroupedReduce(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> initialData=getSourceDataSet(env);
      initialData.reduce(new RichReduceFunction<Tuple3<Double,StringValue,LongValue>>(){
        public Tuple3<Double,StringValue,LongValue> reduce(        Tuple3<Double,StringValue,LongValue> value1,        Tuple3<Double,StringValue,LongValue> value2){
          return value1;
        }
      }
).output(new DiscardingOutputFormat<Tuple3<Double,StringValue,LongValue>>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      ReduceOperatorBase<?,?> reducer=(ReduceOperatorBase<?,?>)sink.getInput();
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getOutputType());
      assertTrue(reducer.getKeyColumns(0) == null || reducer.getKeyColumns(0).length == 0);
      assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == ExecutionConfig.PARALLELISM_DEFAULT);
      assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @Test public void translateGroupedReduceNoMapper(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> initialData=getSourceDataSet(env);
      initialData.groupBy(2).reduce(new RichReduceFunction<Tuple3<Double,StringValue,LongValue>>(){
        public Tuple3<Double,StringValue,LongValue> reduce(        Tuple3<Double,StringValue,LongValue> value1,        Tuple3<Double,StringValue,LongValue> value2){
          return value1;
        }
      }
).output(new DiscardingOutputFormat<Tuple3<Double,StringValue,LongValue>>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      ReduceOperatorBase<?,?> reducer=(ReduceOperatorBase<?,?>)sink.getInput();
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),reducer.getOperatorInfo().getOutputType());
      assertTrue(reducer.getParallelism() == parallelism || reducer.getParallelism() == ExecutionConfig.PARALLELISM_DEFAULT);
      assertArrayEquals(new int[]{2},reducer.getKeyColumns(0));
      assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @Test public void translateGroupedReduceWithkeyExtractor(){
    try {
      final int parallelism=8;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> initialData=getSourceDataSet(env);
      initialData.groupBy(new KeySelector<Tuple3<Double,StringValue,LongValue>,StringValue>(){
        public StringValue getKey(        Tuple3<Double,StringValue,LongValue> value){
          return value.f1;
        }
      }
).reduce(new RichReduceFunction<Tuple3<Double,StringValue,LongValue>>(){
        public Tuple3<Double,StringValue,LongValue> reduce(        Tuple3<Double,StringValue,LongValue> value1,        Tuple3<Double,StringValue,LongValue> value2){
          return value1;
        }
      }
).setParallelism(4).output(new DiscardingOutputFormat<Tuple3<Double,StringValue,LongValue>>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      MapOperatorBase<?,?,?> keyProjector=(MapOperatorBase<?,?,?>)sink.getInput();
      PlanUnwrappingReduceOperator<?,?> reducer=(PlanUnwrappingReduceOperator<?,?>)keyProjector.getInput();
      MapOperatorBase<?,?,?> keyExtractor=(MapOperatorBase<?,?,?>)reducer.getInput();
      assertEquals(1,keyExtractor.getParallelism());
      assertEquals(4,reducer.getParallelism());
      assertEquals(4,keyProjector.getParallelism());
      TypeInformation<?> keyValueInfo=new TupleTypeInfo<Tuple2<StringValue,Tuple3<Double,StringValue,LongValue>>>(new ValueTypeInfo<StringValue>(StringValue.class),initialData.getType());
      assertEquals(initialData.getType(),keyExtractor.getOperatorInfo().getInputType());
      assertEquals(keyValueInfo,keyExtractor.getOperatorInfo().getOutputType());
      assertEquals(keyValueInfo,reducer.getOperatorInfo().getInputType());
      assertEquals(keyValueInfo,reducer.getOperatorInfo().getOutputType());
      assertEquals(keyValueInfo,keyProjector.getOperatorInfo().getInputType());
      assertEquals(initialData.getType(),keyProjector.getOperatorInfo().getOutputType());
      assertEquals(KeyExtractingMapper.class,keyExtractor.getUserCodeWrapper().getUserCodeClass());
      assertTrue(keyExtractor.getInput() instanceof GenericDataSourceBase<?,?>);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @SuppressWarnings("unchecked") private static DataSet<Tuple3<Double,StringValue,LongValue>> getSourceDataSet(  ExecutionEnvironment env){
    return env.fromElements(new Tuple3<Double,StringValue,LongValue>(3.141592,new StringValue("foobar"),new LongValue(77))).setParallelism(1);
  }
}
