/** 
 * Tests for the  {@link AbstractYarnClusterDescriptor}.
 */
public class AbstractYarnClusterTest extends TestLogger {
  @Rule public TemporaryFolder temporaryFolder=new TemporaryFolder();
  /** 
 * Tests that the cluster retrieval of a finished YARN application fails.
 */
  @Test(expected=ClusterRetrieveException.class) public void testClusterClientRetrievalOfFinishedYarnApplication() throws Exception {
    final ApplicationId applicationId=ApplicationId.newInstance(System.currentTimeMillis(),42);
    final ApplicationReport applicationReport=createApplicationReport(applicationId,YarnApplicationState.FINISHED,FinalApplicationStatus.SUCCEEDED);
    final YarnClient yarnClient=new TestingYarnClient(Collections.singletonMap(applicationId,applicationReport));
    final YarnConfiguration yarnConfiguration=new YarnConfiguration();
    yarnClient.init(yarnConfiguration);
    yarnClient.start();
    final TestingAbstractYarnClusterDescriptor clusterDescriptor=new TestingAbstractYarnClusterDescriptor(new Configuration(),yarnConfiguration,temporaryFolder.newFolder().getAbsolutePath(),yarnClient,false);
    try {
      clusterDescriptor.retrieve(applicationId);
    }
  finally {
      clusterDescriptor.close();
    }
  }
  private ApplicationReport createApplicationReport(  ApplicationId applicationId,  YarnApplicationState yarnApplicationState,  FinalApplicationStatus finalApplicationStatus){
    return ApplicationReport.newInstance(applicationId,ApplicationAttemptId.newInstance(applicationId,0),"user","queue","name","localhost",42,null,yarnApplicationState,null,null,1L,2L,finalApplicationStatus,null,null,1.0f,null,null);
  }
private static final class TestingYarnClient extends YarnClientImpl {
    private final Map<ApplicationId,ApplicationReport> applicationReports;
    private TestingYarnClient(    Map<ApplicationId,ApplicationReport> applicationReports){
      this.applicationReports=Preconditions.checkNotNull(applicationReports);
    }
    @Override public ApplicationReport getApplicationReport(    ApplicationId appId) throws YarnException, IOException {
      final ApplicationReport applicationReport=applicationReports.get(appId);
      if (applicationReport != null) {
        return applicationReport;
      }
 else {
        return super.getApplicationReport(appId);
      }
    }
  }
private static final class TestingAbstractYarnClusterDescriptor extends AbstractYarnClusterDescriptor {
    private TestingAbstractYarnClusterDescriptor(    Configuration flinkConfiguration,    YarnConfiguration yarnConfiguration,    String configurationDirectory,    YarnClient yarnClient,    boolean sharedYarnClient){
      super(flinkConfiguration,yarnConfiguration,configurationDirectory,yarnClient,sharedYarnClient);
    }
    @Override protected String getYarnSessionClusterEntrypoint(){
      throw new UnsupportedOperationException("Not needed for testing");
    }
    @Override protected String getYarnJobClusterEntrypoint(){
      throw new UnsupportedOperationException("Not needed for testing");
    }
    @Override protected ClusterClient<ApplicationId> createYarnClusterClient(    AbstractYarnClusterDescriptor descriptor,    int numberTaskManagers,    int slotsPerTaskManager,    ApplicationReport report,    Configuration flinkConfiguration,    boolean perJobCluster) throws Exception {
      throw new UnsupportedOperationException("Not needed for testing");
    }
    @Override public ClusterClient<ApplicationId> deployJobCluster(    ClusterSpecification clusterSpecification,    JobGraph jobGraph,    boolean detached) throws ClusterDeploymentException {
      throw new UnsupportedOperationException("Not needed for testing");
    }
  }
}
