@SuppressWarnings("serial") public class DistinctCompilationTest extends CompilerTestBase implements java.io.Serializable {
  @Test public void testDistinctPlain(){
    try {
      ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      env.setParallelism(8);
      DataSet<Tuple2<String,Double>> data=env.readCsvFile("file:///will/never/be/read").types(String.class,Double.class).name("source").setParallelism(6);
      data.distinct().name("reducer").output(new DiscardingOutputFormat<Tuple2<String,Double>>()).name("sink");
      Plan p=env.createProgramPlan();
      OptimizedPlan op=compileNoStats(p);
      OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(op);
      SourcePlanNode sourceNode=resolver.getNode("source");
      SingleInputPlanNode reduceNode=resolver.getNode("reducer");
      SinkPlanNode sinkNode=resolver.getNode("sink");
      SingleInputPlanNode combineNode=(SingleInputPlanNode)reduceNode.getInput().getSource();
      assertEquals(sourceNode,combineNode.getInput().getSource());
      assertEquals(reduceNode,sinkNode.getInput().getSource());
      assertEquals(DriverStrategy.SORTED_REDUCE,reduceNode.getDriverStrategy());
      assertEquals(DriverStrategy.SORTED_PARTIAL_REDUCE,combineNode.getDriverStrategy());
      assertEquals(new FieldList(0,1),reduceNode.getKeys(0));
      assertEquals(new FieldList(0,1),combineNode.getKeys(0));
      assertEquals(new FieldList(0,1),reduceNode.getInput().getLocalStrategyKeys());
      assertEquals(6,sourceNode.getParallelism());
      assertEquals(6,combineNode.getParallelism());
      assertEquals(8,reduceNode.getParallelism());
      assertEquals(8,sinkNode.getParallelism());
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail(e.getClass().getSimpleName() + " in test: " + e.getMessage());
    }
  }
  @Test public void testDistinctWithCombineHint(){
    try {
      ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      env.setParallelism(8);
      DataSet<Tuple2<String,Double>> data=env.readCsvFile("file:///will/never/be/read").types(String.class,Double.class).name("source").setParallelism(6);
      data.distinct().setCombineHint(CombineHint.HASH).name("reducer").output(new DiscardingOutputFormat<Tuple2<String,Double>>()).name("sink");
      Plan p=env.createProgramPlan();
      OptimizedPlan op=compileNoStats(p);
      OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(op);
      SourcePlanNode sourceNode=resolver.getNode("source");
      SingleInputPlanNode reduceNode=resolver.getNode("reducer");
      SinkPlanNode sinkNode=resolver.getNode("sink");
      SingleInputPlanNode combineNode=(SingleInputPlanNode)reduceNode.getInput().getSource();
      assertEquals(sourceNode,combineNode.getInput().getSource());
      assertEquals(reduceNode,sinkNode.getInput().getSource());
      assertEquals(DriverStrategy.SORTED_REDUCE,reduceNode.getDriverStrategy());
      assertEquals(DriverStrategy.HASHED_PARTIAL_REDUCE,combineNode.getDriverStrategy());
      assertEquals(new FieldList(0,1),reduceNode.getKeys(0));
      assertEquals(new FieldList(0,1),combineNode.getKeys(0));
      assertEquals(new FieldList(0,1),reduceNode.getInput().getLocalStrategyKeys());
      assertEquals(6,sourceNode.getParallelism());
      assertEquals(6,combineNode.getParallelism());
      assertEquals(8,reduceNode.getParallelism());
      assertEquals(8,sinkNode.getParallelism());
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail(e.getClass().getSimpleName() + " in test: " + e.getMessage());
    }
  }
  @Test public void testDistinctWithSelectorFunctionKey(){
    try {
      ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      env.setParallelism(8);
      DataSet<Tuple2<String,Double>> data=env.readCsvFile("file:///will/never/be/read").types(String.class,Double.class).name("source").setParallelism(6);
      data.distinct(new KeySelector<Tuple2<String,Double>,String>(){
        public String getKey(        Tuple2<String,Double> value){
          return value.f0;
        }
      }
).name("reducer").output(new DiscardingOutputFormat<Tuple2<String,Double>>()).name("sink");
      Plan p=env.createProgramPlan();
      OptimizedPlan op=compileNoStats(p);
      OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(op);
      SourcePlanNode sourceNode=resolver.getNode("source");
      SingleInputPlanNode reduceNode=resolver.getNode("reducer");
      SinkPlanNode sinkNode=resolver.getNode("sink");
      SingleInputPlanNode combineNode=(SingleInputPlanNode)reduceNode.getInput().getSource();
      SingleInputPlanNode keyExtractor=(SingleInputPlanNode)combineNode.getInput().getSource();
      SingleInputPlanNode keyProjector=(SingleInputPlanNode)sinkNode.getInput().getSource();
      assertEquals(sourceNode,keyExtractor.getInput().getSource());
      assertEquals(keyProjector,sinkNode.getInput().getSource());
      assertEquals(DriverStrategy.SORTED_REDUCE,reduceNode.getDriverStrategy());
      assertEquals(DriverStrategy.SORTED_PARTIAL_REDUCE,combineNode.getDriverStrategy());
      assertEquals(new FieldList(0),reduceNode.getKeys(0));
      assertEquals(new FieldList(0),combineNode.getKeys(0));
      assertEquals(new FieldList(0),reduceNode.getInput().getLocalStrategyKeys());
      assertEquals(6,sourceNode.getParallelism());
      assertEquals(6,keyExtractor.getParallelism());
      assertEquals(6,combineNode.getParallelism());
      assertEquals(8,reduceNode.getParallelism());
      assertEquals(8,keyProjector.getParallelism());
      assertEquals(8,sinkNode.getParallelism());
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail(e.getClass().getSimpleName() + " in test: " + e.getMessage());
    }
  }
  @Test public void testDistinctWithFieldPositionKeyCombinable(){
    try {
      ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      env.setParallelism(8);
      DataSet<Tuple2<String,Double>> data=env.readCsvFile("file:///will/never/be/read").types(String.class,Double.class).name("source").setParallelism(6);
      DistinctOperator<Tuple2<String,Double>> reduced=data.distinct(1).name("reducer");
      reduced.output(new DiscardingOutputFormat<Tuple2<String,Double>>()).name("sink");
      Plan p=env.createProgramPlan();
      OptimizedPlan op=compileNoStats(p);
      OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(op);
      SourcePlanNode sourceNode=resolver.getNode("source");
      SingleInputPlanNode reduceNode=resolver.getNode("reducer");
      SinkPlanNode sinkNode=resolver.getNode("sink");
      SingleInputPlanNode combineNode=(SingleInputPlanNode)reduceNode.getInput().getSource();
      assertEquals(sourceNode,combineNode.getInput().getSource());
      assertEquals(reduceNode,sinkNode.getInput().getSource());
      assertEquals(DriverStrategy.SORTED_REDUCE,reduceNode.getDriverStrategy());
      assertEquals(DriverStrategy.SORTED_PARTIAL_REDUCE,combineNode.getDriverStrategy());
      assertEquals(new FieldList(1),reduceNode.getKeys(0));
      assertEquals(new FieldList(1),combineNode.getKeys(0));
      assertEquals(new FieldList(1),reduceNode.getInput().getLocalStrategyKeys());
      assertEquals(6,sourceNode.getParallelism());
      assertEquals(6,combineNode.getParallelism());
      assertEquals(8,reduceNode.getParallelism());
      assertEquals(8,sinkNode.getParallelism());
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail(e.getClass().getSimpleName() + " in test: " + e.getMessage());
    }
  }
}
