private static class OnceFailingAggregator extends RichFlatMapFunction<PrefixCount,PrefixCount> implements ListCheckpointed<HashMap<String,PrefixCount>>, CheckpointListener {
  static boolean wasCheckpointedBeforeFailure=false;
  private static volatile boolean hasFailed=false;
  private final HashMap<String,PrefixCount> aggregationMap=new HashMap<String,PrefixCount>();
  private long failurePos;
  private long count;
  private boolean wasCheckpointed;
  OnceFailingAggregator(  long failurePos){
    this.failurePos=failurePos;
  }
  @Override public void open(  Configuration parameters){
    count=0;
  }
  @Override public void flatMap(  PrefixCount value,  Collector<PrefixCount> out) throws Exception {
    count++;
    if (!hasFailed && count >= failurePos && getRuntimeContext().getIndexOfThisSubtask() == 1) {
      wasCheckpointedBeforeFailure=wasCheckpointed;
      hasFailed=true;
      throw new Exception("Test Failure");
    }
    PrefixCount curr=aggregationMap.get(value.prefix);
    if (curr == null) {
      aggregationMap.put(value.prefix,value);
      out.collect(value);
    }
 else {
      curr.count+=value.count;
      out.collect(curr);
    }
  }
  @Override public List<HashMap<String,PrefixCount>> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(this.aggregationMap);
  }
  @Override public void restoreState(  List<HashMap<String,PrefixCount>> state) throws Exception {
    if (state.isEmpty() || state.size() > 1) {
      throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size());
    }
    this.aggregationMap.putAll(state.get(0));
  }
  @Override public void notifyCheckpointComplete(  long checkpointId){
    this.wasCheckpointed=true;
  }
}
