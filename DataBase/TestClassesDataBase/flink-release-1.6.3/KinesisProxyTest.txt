/** 
 * Test for methods in the  {@link KinesisProxy} class.
 */
public class KinesisProxyTest {
  @Test public void testIsRecoverableExceptionWithProvisionedThroughputExceeded(){
    final ProvisionedThroughputExceededException ex=new ProvisionedThroughputExceededException("asdf");
    ex.setErrorType(ErrorType.Client);
    assertTrue(KinesisProxy.isRecoverableException(ex));
  }
  @Test public void testIsRecoverableExceptionWithServiceException(){
    final AmazonServiceException ex=new AmazonServiceException("asdf");
    ex.setErrorType(ErrorType.Service);
    assertTrue(KinesisProxy.isRecoverableException(ex));
  }
  @Test public void testIsRecoverableExceptionWithExpiredIteratorException(){
    final ExpiredIteratorException ex=new ExpiredIteratorException("asdf");
    ex.setErrorType(ErrorType.Client);
    assertFalse(KinesisProxy.isRecoverableException(ex));
  }
  @Test public void testIsRecoverableExceptionWithNullErrorType(){
    final AmazonServiceException ex=new AmazonServiceException("asdf");
    ex.setErrorType(null);
    assertFalse(KinesisProxy.isRecoverableException(ex));
  }
  @Test public void testGetRecordsRetry() throws Exception {
    Properties kinesisConsumerConfig=new Properties();
    kinesisConsumerConfig.setProperty(ConsumerConfigConstants.AWS_REGION,"us-east-1");
    final GetRecordsResult expectedResult=new GetRecordsResult();
    MutableInt retries=new MutableInt();
    final Throwable[] retriableExceptions=new Throwable[]{new AmazonKinesisException("mock")};
    AmazonKinesisClient mockClient=mock(AmazonKinesisClient.class);
    Mockito.when(mockClient.getRecords(any())).thenAnswer(new Answer<GetRecordsResult>(){
      @Override public GetRecordsResult answer(      InvocationOnMock invocation) throws Throwable {
        if (retries.intValue() < retriableExceptions.length) {
          retries.increment();
          throw retriableExceptions[retries.intValue() - 1];
        }
        return expectedResult;
      }
    }
);
    KinesisProxy kinesisProxy=new KinesisProxy(kinesisConsumerConfig);
    Whitebox.getField(KinesisProxy.class,"kinesisClient").set(kinesisProxy,mockClient);
    GetRecordsResult result=kinesisProxy.getRecords("fakeShardIterator",1);
    assertEquals(retriableExceptions.length,retries.intValue());
    assertEquals(expectedResult,result);
  }
  @Test public void testGetShardList() throws Exception {
    List<String> shardIds=Arrays.asList("shardId-000000000000","shardId-000000000001","shardId-000000000002","shardId-000000000003");
    String nextToken="NextToken";
    String fakeStreamName="fake-stream";
    List<Shard> shards=shardIds.stream().map(shardId -> new Shard().withShardId(shardId)).collect(Collectors.toList());
    Properties kinesisConsumerConfig=new Properties();
    kinesisConsumerConfig.setProperty(ConsumerConfigConstants.AWS_REGION,"us-east-1");
    kinesisConsumerConfig.setProperty(ConsumerConfigConstants.AWS_ACCESS_KEY_ID,"fake_accesskey");
    kinesisConsumerConfig.setProperty(ConsumerConfigConstants.AWS_SECRET_ACCESS_KEY,"fake_secretkey");
    KinesisProxy kinesisProxy=new KinesisProxy(kinesisConsumerConfig);
    AmazonKinesis mockClient=mock(AmazonKinesis.class);
    Whitebox.setInternalState(kinesisProxy,"kinesisClient",mockClient);
    ListShardsResult responseWithMoreData=new ListShardsResult().withShards(shards.subList(0,2)).withNextToken(nextToken);
    ListShardsResult responseFinal=new ListShardsResult().withShards(shards.subList(2,shards.size())).withNextToken(null);
    doReturn(responseWithMoreData).when(mockClient).listShards(argThat(initialListShardsRequestMatcher()));
    doReturn(responseFinal).when(mockClient).listShards(argThat(listShardsNextToken(nextToken)));
    HashMap<String,String> streamHashMap=createInitialSubscribedStreamsToLastDiscoveredShardsState(Arrays.asList(fakeStreamName));
    GetShardListResult shardListResult=kinesisProxy.getShardList(streamHashMap);
    Assert.assertEquals(shardListResult.hasRetrievedShards(),true);
    Set<String> expectedStreams=new HashSet<>();
    expectedStreams.add(fakeStreamName);
    Assert.assertEquals(shardListResult.getStreamsWithRetrievedShards(),expectedStreams);
    List<StreamShardHandle> actualShardList=shardListResult.getRetrievedShardListOfStream(fakeStreamName);
    List<StreamShardHandle> expectedStreamShard=new ArrayList<>();
    assertThat(actualShardList,hasSize(4));
    for (int i=0; i < 4; i++) {
      StreamShardHandle shardHandle=new StreamShardHandle(fakeStreamName,new Shard().withShardId(KinesisShardIdGenerator.generateFromShardOrder(i)));
      expectedStreamShard.add(shardHandle);
    }
    Assert.assertThat(actualShardList,containsInAnyOrder(expectedStreamShard.toArray(new StreamShardHandle[actualShardList.size()])));
  }
  @Test public void testGetShardListRetry() throws Exception {
    Properties kinesisConsumerConfig=new Properties();
    kinesisConsumerConfig.setProperty(ConsumerConfigConstants.AWS_REGION,"us-east-1");
    Shard shard=new Shard();
    shard.setShardId("fake-shard-000000000000");
    final ListShardsResult expectedResult=new ListShardsResult();
    expectedResult.withShards(shard);
    MutableInt exceptionCount=new MutableInt();
    final Throwable[] retriableExceptions=new Throwable[]{new AmazonKinesisException("attempt1"),new AmazonKinesisException("attempt2")};
    AmazonKinesisClient mockClient=mock(AmazonKinesisClient.class);
    Mockito.when(mockClient.listShards(any())).thenAnswer(new Answer<ListShardsResult>(){
      @Override public ListShardsResult answer(      InvocationOnMock invocation) throws Throwable {
        if (exceptionCount.intValue() < retriableExceptions.length) {
          exceptionCount.increment();
          throw retriableExceptions[exceptionCount.intValue() - 1];
        }
        return expectedResult;
      }
    }
);
    KinesisProxy kinesisProxy=new KinesisProxy(kinesisConsumerConfig);
    Whitebox.getField(KinesisProxy.class,"kinesisClient").set(kinesisProxy,mockClient);
    HashMap<String,String> streamNames=new HashMap();
    streamNames.put("fake-stream",null);
    GetShardListResult result=kinesisProxy.getShardList(streamNames);
    assertEquals(retriableExceptions.length,exceptionCount.intValue());
    assertEquals(true,result.hasRetrievedShards());
    assertEquals(shard.getShardId(),result.getLastSeenShardOfStream("fake-stream").getShard().getShardId());
    int maxRetries=1;
    exceptionCount.setValue(0);
    kinesisConsumerConfig.setProperty(ConsumerConfigConstants.LIST_SHARDS_RETRIES,String.valueOf(maxRetries));
    kinesisProxy=new KinesisProxy(kinesisConsumerConfig);
    Whitebox.getField(KinesisProxy.class,"kinesisClient").set(kinesisProxy,mockClient);
    try {
      kinesisProxy.getShardList(streamNames);
      Assert.fail("exception expected");
    }
 catch (    SdkClientException ex) {
      assertEquals(retriableExceptions[maxRetries],ex);
    }
    assertEquals(maxRetries + 1,exceptionCount.intValue());
  }
  @Test public void testCustomConfigurationOverride(){
    Properties configProps=new Properties();
    configProps.setProperty(AWSConfigConstants.AWS_REGION,"us-east-1");
    KinesisProxy proxy=new KinesisProxy(configProps){
      @Override protected AmazonKinesis createKinesisClient(      Properties configProps){
        ClientConfiguration clientConfig=new ClientConfigurationFactory().getConfig();
        clientConfig.setSocketTimeout(10000);
        return AWSUtil.createKinesisClient(configProps,clientConfig);
      }
    }
;
    AmazonKinesis kinesisClient=Whitebox.getInternalState(proxy,"kinesisClient");
    ClientConfiguration clientConfiguration=Whitebox.getInternalState(kinesisClient,"clientConfiguration");
    assertEquals(10000,clientConfiguration.getSocketTimeout());
  }
  @Test public void testClientConfigOverride(){
    Properties configProps=new Properties();
    configProps.setProperty(AWSConfigConstants.AWS_REGION,"us-east-1");
    configProps.setProperty(AWSUtil.AWS_CLIENT_CONFIG_PREFIX + "socketTimeout","9999");
    KinesisProxyInterface proxy=KinesisProxy.create(configProps);
    AmazonKinesis kinesisClient=Whitebox.getInternalState(proxy,"kinesisClient");
    ClientConfiguration clientConfiguration=Whitebox.getInternalState(kinesisClient,"clientConfiguration");
    assertEquals(9999,clientConfiguration.getSocketTimeout());
  }
  protected static HashMap<String,String> createInitialSubscribedStreamsToLastDiscoveredShardsState(  List<String> streams){
    HashMap<String,String> initial=new HashMap<>();
    for (    String stream : streams) {
      initial.put(stream,null);
    }
    return initial;
  }
  private static ListShardsRequestMatcher initialListShardsRequestMatcher(){
    return new ListShardsRequestMatcher(null,null);
  }
  private static ListShardsRequestMatcher listShardsNextToken(  final String nextToken){
    return new ListShardsRequestMatcher(null,nextToken);
  }
private static class ListShardsRequestMatcher extends TypeSafeDiagnosingMatcher<ListShardsRequest> {
    private final String shardId;
    private final String nextToken;
    ListShardsRequestMatcher(    String shardIdArg,    String nextTokenArg){
      shardId=shardIdArg;
      nextToken=nextTokenArg;
    }
    @Override protected boolean matchesSafely(    final ListShardsRequest listShardsRequest,    final Description description){
      if (shardId == null) {
        if (listShardsRequest.getExclusiveStartShardId() != null) {
          return false;
        }
      }
 else {
        if (!shardId.equals(listShardsRequest.getExclusiveStartShardId())) {
          return false;
        }
      }
      if (listShardsRequest.getNextToken() != null) {
        if (!(listShardsRequest.getStreamName() == null && listShardsRequest.getExclusiveStartShardId() == null)) {
          return false;
        }
        if (!listShardsRequest.getNextToken().equals(nextToken)) {
          return false;
        }
      }
 else {
        return nextToken == null;
      }
      return true;
    }
    @Override public void describeTo(    final Description description){
      description.appendText("A ListShardsRequest with a shardId: ").appendValue(shardId).appendText(" and empty nextToken");
    }
  }
}
