/** 
 * Mapper that causes one failure between seeing 40% to 70% of the records.
 */
private static class OnceFailingIdentityMapFunction extends RichMapFunction<Tuple2<Integer,Long>,Tuple2<Integer,Long>> implements ListCheckpointed<Long> {
  private static volatile boolean hasFailed=false;
  private final long numElements;
  private long failurePos;
  private long count;
  public OnceFailingIdentityMapFunction(  long numElements){
    this.numElements=numElements;
  }
  @Override public void open(  Configuration parameters) throws Exception {
    long failurePosMin=(long)(0.4 * numElements / getRuntimeContext().getNumberOfParallelSubtasks());
    long failurePosMax=(long)(0.7 * numElements / getRuntimeContext().getNumberOfParallelSubtasks());
    failurePos=(new Random().nextLong() % (failurePosMax - failurePosMin)) + failurePosMin;
  }
  @Override public Tuple2<Integer,Long> map(  Tuple2<Integer,Long> value) throws Exception {
    if (!hasFailed && count >= failurePos) {
      hasFailed=true;
      throw new Exception("Test Failure");
    }
    count++;
    return value;
  }
  @Override public List<Long> snapshotState(  long checkpointId,  long timestamp) throws Exception {
    return Collections.singletonList(count);
  }
  @Override public void restoreState(  List<Long> state) throws Exception {
    if (!state.isEmpty()) {
      count=state.get(0);
    }
  }
}
