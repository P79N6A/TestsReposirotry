/** 
 * Test job classloader.
 */
public class LegacyClassLoaderITCase extends TestLogger {
  private static final Logger LOG=LoggerFactory.getLogger(LegacyClassLoaderITCase.class);
  private static final String INPUT_SPLITS_PROG_JAR_FILE="customsplit-test-jar.jar";
  private static final String STREAMING_INPUT_SPLITS_PROG_JAR_FILE="streaming-customsplit-test-jar.jar";
  private static final String STREAMING_PROG_JAR_FILE="streamingclassloader-test-jar.jar";
  private static final String STREAMING_CHECKPOINTED_PROG_JAR_FILE="streaming-checkpointed-classloader-test-jar.jar";
  private static final String KMEANS_JAR_PATH="kmeans-test-jar.jar";
  private static final String USERCODETYPE_JAR_PATH="usercodetype-test-jar.jar";
  private static final String CUSTOM_KV_STATE_JAR_PATH="custom_kv_state-test-jar.jar";
  private static final String CHECKPOINTING_CUSTOM_KV_STATE_JAR_PATH="checkpointing_custom_kv_state-test-jar.jar";
  @ClassRule public static final TemporaryFolder FOLDER=new TemporaryFolder();
  @Rule public ExpectedException expectedException=ExpectedException.none();
  private static TestingCluster testCluster;
  private static int parallelism;
  @BeforeClass public static void setUp() throws Exception {
    Configuration config=new Configuration();
    config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER,2);
    config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS,2);
    parallelism=4;
    config.setString(CheckpointingOptions.STATE_BACKEND,"filesystem");
    config.setString(CheckpointingOptions.CHECKPOINTS_DIRECTORY,FOLDER.newFolder().getAbsoluteFile().toURI().toString());
    config.setString(CheckpointingOptions.SAVEPOINT_DIRECTORY,FOLDER.newFolder().getAbsoluteFile().toURI().toString());
    testCluster=new TestingCluster(config,false);
    testCluster.start();
  }
  @AfterClass public static void tearDown() throws Exception {
    if (testCluster != null) {
      testCluster.stop();
    }
    TestStreamEnvironment.unsetAsContext();
    TestEnvironment.unsetAsContext();
  }
  @Test public void testCustomSplitJobWithCustomClassLoaderJar() throws IOException, ProgramInvocationException {
    PackagedProgram inputSplitTestProg=new PackagedProgram(new File(INPUT_SPLITS_PROG_JAR_FILE));
    TestEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(INPUT_SPLITS_PROG_JAR_FILE)),Collections.<URL>emptyList());
    inputSplitTestProg.invokeInteractiveModeForExecution();
  }
  @Test public void testStreamingCustomSplitJobWithCustomClassLoader() throws IOException, ProgramInvocationException {
    PackagedProgram streamingInputSplitTestProg=new PackagedProgram(new File(STREAMING_INPUT_SPLITS_PROG_JAR_FILE));
    TestStreamEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(STREAMING_INPUT_SPLITS_PROG_JAR_FILE)),Collections.<URL>emptyList());
    streamingInputSplitTestProg.invokeInteractiveModeForExecution();
  }
  @Test public void testCustomSplitJobWithCustomClassLoaderPath() throws IOException, ProgramInvocationException {
    URL classpath=new File(INPUT_SPLITS_PROG_JAR_FILE).toURI().toURL();
    PackagedProgram inputSplitTestProg2=new PackagedProgram(new File(INPUT_SPLITS_PROG_JAR_FILE));
    TestEnvironment.setAsContext(testCluster,parallelism,Collections.<Path>emptyList(),Collections.singleton(classpath));
    inputSplitTestProg2.invokeInteractiveModeForExecution();
  }
  @Test public void testStreamingClassloaderJobWithCustomClassLoader() throws IOException, ProgramInvocationException {
    PackagedProgram streamingProg=new PackagedProgram(new File(STREAMING_PROG_JAR_FILE));
    TestStreamEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(STREAMING_PROG_JAR_FILE)),Collections.<URL>emptyList());
    streamingProg.invokeInteractiveModeForExecution();
  }
  @Test public void testCheckpointedStreamingClassloaderJobWithCustomClassLoader() throws IOException, ProgramInvocationException {
    PackagedProgram streamingCheckpointedProg=new PackagedProgram(new File(STREAMING_CHECKPOINTED_PROG_JAR_FILE));
    TestStreamEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(STREAMING_CHECKPOINTED_PROG_JAR_FILE)),Collections.<URL>emptyList());
    expectedException.expectCause(Matchers.<Throwable>hasProperty("cause",hasProperty("class",hasProperty("canonicalName",equalTo("org.apache.flink.test.classloading.jar.CheckpointedStreamingProgram.SuccessException")))));
    streamingCheckpointedProg.invokeInteractiveModeForExecution();
  }
  @Test public void testKMeansJobWithCustomClassLoader() throws IOException, ProgramInvocationException {
    PackagedProgram kMeansProg=new PackagedProgram(new File(KMEANS_JAR_PATH),new String[]{KMeansData.DATAPOINTS,KMeansData.INITIAL_CENTERS,"25"});
    TestEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(KMEANS_JAR_PATH)),Collections.<URL>emptyList());
    kMeansProg.invokeInteractiveModeForExecution();
  }
  @Test public void testUserCodeTypeJobWithCustomClassLoader() throws IOException, ProgramInvocationException {
    int port=testCluster.getLeaderRPCPort();
    final PackagedProgram userCodeTypeProg=new PackagedProgram(new File(USERCODETYPE_JAR_PATH),new String[]{USERCODETYPE_JAR_PATH,"localhost",String.valueOf(port)});
    TestEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(USERCODETYPE_JAR_PATH)),Collections.<URL>emptyList());
    userCodeTypeProg.invokeInteractiveModeForExecution();
  }
  @Test public void testCheckpointingCustomKvStateJobWithCustomClassLoader() throws IOException, ProgramInvocationException {
    File checkpointDir=FOLDER.newFolder();
    File outputDir=FOLDER.newFolder();
    final PackagedProgram program=new PackagedProgram(new File(CHECKPOINTING_CUSTOM_KV_STATE_JAR_PATH),new String[]{checkpointDir.toURI().toString(),outputDir.toURI().toString()});
    TestStreamEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(CHECKPOINTING_CUSTOM_KV_STATE_JAR_PATH)),Collections.<URL>emptyList());
    expectedException.expectCause(Matchers.<Throwable>hasProperty("cause",isA(SuccessException.class)));
    program.invokeInteractiveModeForExecution();
  }
  /** 
 * Tests disposal of a savepoint, which contains custom user code KvState.
 */
  @Test public void testDisposeSavepointWithCustomKvState() throws Exception {
    Deadline deadline=new FiniteDuration(100,TimeUnit.SECONDS).fromNow();
    File checkpointDir=FOLDER.newFolder();
    File outputDir=FOLDER.newFolder();
    final PackagedProgram program=new PackagedProgram(new File(CUSTOM_KV_STATE_JAR_PATH),new String[]{String.valueOf(parallelism),checkpointDir.toURI().toString(),"5000",outputDir.toURI().toString()});
    TestStreamEnvironment.setAsContext(testCluster,parallelism,Collections.singleton(new Path(CUSTOM_KV_STATE_JAR_PATH)),Collections.<URL>emptyList());
    Thread invokeThread=new Thread(new Runnable(){
      @Override public void run(){
        try {
          program.invokeInteractiveModeForExecution();
        }
 catch (        ProgramInvocationException ignored) {
          if (ignored.getCause() == null || !(ignored.getCause() instanceof JobCancellationException)) {
            ignored.printStackTrace();
          }
        }
      }
    }
);
    LOG.info("Starting program invoke thread");
    invokeThread.start();
    JobID jobId=null;
    ActorGateway jm=testCluster.getLeaderGateway(deadline.timeLeft());
    LOG.info("Waiting for job status running.");
    while (jobId == null && deadline.hasTimeLeft()) {
      Future<Object> jobsFuture=jm.ask(JobManagerMessages.getRequestRunningJobsStatus(),deadline.timeLeft());
      RunningJobsStatus runningJobs=(RunningJobsStatus)Await.result(jobsFuture,deadline.timeLeft());
      for (      JobStatusMessage runningJob : runningJobs.getStatusMessages()) {
        jobId=runningJob.getJobId();
        LOG.info("Job running. ID: " + jobId);
        break;
      }
      if (jobId == null) {
        Thread.sleep(100L);
      }
    }
    LOG.info("Wait for all tasks to be running.");
    Future<Object> allRunning=jm.ask(new WaitForAllVerticesToBeRunning(jobId),deadline.timeLeft());
    Await.ready(allRunning,deadline.timeLeft());
    LOG.info("All tasks are running.");
    String savepointPath=null;
    for (int i=0; i < 20; i++) {
      LOG.info("Triggering savepoint (" + (i + 1) + "/20).");
      Future<Object> savepointFuture=jm.ask(new TriggerSavepoint(jobId,Option.<String>empty()),deadline.timeLeft());
      Object savepointResponse=Await.result(savepointFuture,deadline.timeLeft());
      if (savepointResponse.getClass() == TriggerSavepointSuccess.class) {
        savepointPath=((TriggerSavepointSuccess)savepointResponse).savepointPath();
        LOG.info("Triggered savepoint. Path: " + savepointPath);
      }
 else       if (savepointResponse.getClass() == JobManagerMessages.TriggerSavepointFailure.class) {
        Throwable cause=((JobManagerMessages.TriggerSavepointFailure)savepointResponse).cause();
        LOG.info("Failed to trigger savepoint. Retrying...",cause);
        Thread.sleep(500);
      }
 else {
        throw new IllegalStateException("Unexpected response to TriggerSavepoint");
      }
    }
    assertNotNull("Failed to trigger savepoint",savepointPath);
    LOG.info("Disposing savepoint at " + savepointPath);
    Future<Object> disposeFuture=jm.ask(new DisposeSavepoint(savepointPath),deadline.timeLeft());
    Object disposeResponse=Await.result(disposeFuture,deadline.timeLeft());
    if (disposeResponse.getClass() == JobManagerMessages.getDisposeSavepointSuccess().getClass()) {
      LOG.info("Disposed savepoint at " + savepointPath);
    }
 else     if (disposeResponse instanceof DisposeSavepointFailure) {
      throw new IllegalStateException("Failed to dispose savepoint " + disposeResponse);
    }
 else {
      throw new IllegalStateException("Unexpected response to DisposeSavepoint");
    }
    Future<?> cancelFuture=jm.ask(new JobManagerMessages.CancelJob(jobId),deadline.timeLeft());
    Object response=Await.result(cancelFuture,deadline.timeLeft());
    assertTrue("Unexpected response: " + response,response instanceof JobManagerMessages.CancellationSuccess);
    invokeThread.join(deadline.timeLeft().toMillis());
    assertFalse("Program invoke thread still running",invokeThread.isAlive());
  }
}
