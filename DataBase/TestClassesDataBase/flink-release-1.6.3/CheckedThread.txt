private abstract static class CheckedThread extends Thread {
  private volatile Throwable error;
  public abstract void go() throws Exception ;
  @Override public void run(){
    try {
      go();
    }
 catch (    Throwable t) {
      error=t;
    }
  }
  public void sync() throws Exception {
    join();
    if (error != null) {
      ExceptionUtils.rethrowException(error,error.getMessage());
    }
  }
  public void waitUntilThreadHoldsLock(  long timeoutMillis) throws InterruptedException, TimeoutException {
    final long deadline=System.nanoTime() + timeoutMillis * 1_000_000;
    while (!isBlockedOrWaiting() && (System.nanoTime() < deadline)) {
      Thread.sleep(1);
    }
    if (!isBlockedOrWaiting()) {
      throw new TimeoutException();
    }
  }
  private boolean isBlockedOrWaiting(){
    State state=getState();
    return state == State.BLOCKED || state == State.WAITING || state == State.TIMED_WAITING;
  }
}
