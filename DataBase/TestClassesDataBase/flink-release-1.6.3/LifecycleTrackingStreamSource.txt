private static class LifecycleTrackingStreamSource<OUT,SRC extends SourceFunction<OUT>> extends StreamSource<OUT,SRC> implements Serializable {
  private static final long serialVersionUID=2431488948886850562L;
  private transient Thread testCheckpointer;
  private final boolean simulateCheckpointing;
  static OneShotLatch runStarted;
  static OneShotLatch runFinish;
  public LifecycleTrackingStreamSource(  SRC sourceFunction,  boolean simulateCheckpointing){
    super(sourceFunction);
    this.simulateCheckpointing=simulateCheckpointing;
    runStarted=new OneShotLatch();
    runFinish=new OneShotLatch();
  }
  @Override public void run(  Object lockingObject,  StreamStatusMaintainer streamStatusMaintainer,  Output<StreamRecord<OUT>> collector) throws Exception {
    ACTUAL_ORDER_TRACKING.add("OPERATOR::run");
    super.run(lockingObject,streamStatusMaintainer,collector);
    runStarted.trigger();
    runFinish.await();
  }
  @Override public void setup(  StreamTask<?,?> containingTask,  StreamConfig config,  Output<StreamRecord<OUT>> output){
    ACTUAL_ORDER_TRACKING.add("OPERATOR::setup");
    super.setup(containingTask,config,output);
    if (simulateCheckpointing) {
      testCheckpointer=new Thread(){
        @Override public void run(){
          try {
            runStarted.await();
            if (getContainingTask().isCanceled() || getContainingTask().triggerCheckpoint(new CheckpointMetaData(0,System.currentTimeMillis()),CheckpointOptions.forCheckpointWithDefaultLocation())) {
              LifecycleTrackingStreamSource.runFinish.trigger();
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
            Assert.fail();
          }
        }
      }
;
      testCheckpointer.start();
    }
  }
  @Override public void snapshotState(  StateSnapshotContext context) throws Exception {
    ACTUAL_ORDER_TRACKING.add("OPERATOR::snapshotState");
    super.snapshotState(context);
  }
  @Override public void initializeState(  StateInitializationContext context) throws Exception {
    ACTUAL_ORDER_TRACKING.add("OPERATOR::initializeState");
    super.initializeState(context);
  }
  @Override public void prepareSnapshotPreBarrier(  long checkpointId) throws Exception {
    ACTUAL_ORDER_TRACKING.add("OPERATOR::prepareSnapshotPreBarrier");
    super.prepareSnapshotPreBarrier(checkpointId);
  }
  @Override public void open() throws Exception {
    ACTUAL_ORDER_TRACKING.add("OPERATOR::open");
    super.open();
  }
  @Override public void close() throws Exception {
    ACTUAL_ORDER_TRACKING.add("OPERATOR::close");
    super.close();
  }
  @Override public void cancel(){
    ACTUAL_ORDER_TRACKING.add("OPERATOR::cancel");
    super.cancel();
  }
  @Override public void dispose() throws Exception {
    ACTUAL_ORDER_TRACKING.add("OPERATOR::dispose");
    super.dispose();
    if (simulateCheckpointing) {
      testCheckpointer.join();
    }
  }
}
