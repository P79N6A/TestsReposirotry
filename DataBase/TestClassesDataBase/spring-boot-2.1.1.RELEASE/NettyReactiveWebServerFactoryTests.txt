/** 
 * Tests for  {@link NettyReactiveWebServerFactory}.
 * @author Brian Clozel
 */
public class NettyReactiveWebServerFactoryTests extends AbstractReactiveWebServerFactoryTests {
  @Override protected NettyReactiveWebServerFactory getFactory(){
    return new NettyReactiveWebServerFactory(0);
  }
  @Test public void exceptionIsThrownWhenPortIsAlreadyInUse(){
    AbstractReactiveWebServerFactory factory=getFactory();
    factory.setPort(0);
    this.webServer=factory.getWebServer(new EchoHandler());
    this.webServer.start();
    factory.setPort(this.webServer.getPort());
    assertThatExceptionOfType(PortInUseException.class).isThrownBy(factory.getWebServer(new EchoHandler())::start).satisfies(this::portMatchesRequirement);
  }
  private void portMatchesRequirement(  PortInUseException exception){
    assertThat(exception.getPort()).isEqualTo(this.webServer.getPort());
  }
  @Test public void nettyCustomizers(){
    NettyReactiveWebServerFactory factory=getFactory();
    NettyServerCustomizer[] customizers=new NettyServerCustomizer[2];
    for (int i=0; i < customizers.length; i++) {
      customizers[i]=mock(NettyServerCustomizer.class);
      given(customizers[i].apply(any(HttpServer.class))).will((invocation) -> invocation.getArgument(0));
    }
    factory.setServerCustomizers(Arrays.asList(customizers[0],customizers[1]));
    this.webServer=factory.getWebServer(new EchoHandler());
    InOrder ordered=inOrder((Object[])customizers);
    for (    NettyServerCustomizer customizer : customizers) {
      ordered.verify(customizer).apply(any(HttpServer.class));
    }
  }
  @Test public void useForwardedHeaders(){
    NettyReactiveWebServerFactory factory=getFactory();
    factory.setUseForwardHeaders(true);
    assertForwardHeaderIsUsed(factory);
  }
}
