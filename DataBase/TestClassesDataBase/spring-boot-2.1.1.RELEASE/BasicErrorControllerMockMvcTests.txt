/** 
 * Tests for  {@link BasicErrorController} using {@link MockMvc} and {@link SpringRunner}.
 * @author Dave Syer
 */
@RunWith(SpringRunner.class) @SpringBootTest @DirtiesContext public class BasicErrorControllerMockMvcTests {
  @Autowired private WebApplicationContext wac;
  private MockMvc mockMvc;
  @Before public void setup(){
    this.mockMvc=MockMvcBuilders.webAppContextSetup(this.wac).build();
  }
  @Test public void testDirectAccessForMachineClient() throws Exception {
    MvcResult response=this.mockMvc.perform(get("/error")).andExpect(status().is5xxServerError()).andReturn();
    String content=response.getResponse().getContentAsString();
    assertThat(content).contains("999");
  }
  @Test public void testErrorWithResponseStatus() throws Exception {
    MvcResult result=this.mockMvc.perform(get("/bang")).andExpect(status().isNotFound()).andReturn();
    MvcResult response=this.mockMvc.perform(new ErrorDispatcher(result,"/error")).andReturn();
    String content=response.getResponse().getContentAsString();
    assertThat(content).contains("Expected!");
  }
  @Test public void testBindingExceptionForMachineClient() throws Exception {
    MvcResult result=this.mockMvc.perform(get("/bind")).andExpect(status().is4xxClientError()).andReturn();
    MvcResult response=this.mockMvc.perform(new ErrorDispatcher(result,"/error")).andReturn();
    String content=response.getResponse().getContentAsString();
    assertThat(content).contains("Error count: 1");
  }
  @Test public void testDirectAccessForBrowserClient() throws Exception {
    MvcResult response=this.mockMvc.perform(get("/error").accept(MediaType.TEXT_HTML)).andExpect(status().is5xxServerError()).andReturn();
    String content=response.getResponse().getContentAsString();
    assertThat(content).contains("ERROR_BEAN");
  }
  @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @ImportAutoConfiguration({ServletWebServerFactoryAutoConfiguration.class,DispatcherServletAutoConfiguration.class,WebMvcAutoConfiguration.class,HttpMessageConvertersAutoConfiguration.class,ErrorMvcAutoConfiguration.class,PropertyPlaceholderAutoConfiguration.class}) private @interface MinimalWebConfiguration {}
@Configuration @MinimalWebConfiguration public static class TestConfiguration {
    public static void main(    String[] args){
      SpringApplication.run(TestConfiguration.class,args);
    }
    @Bean public View error(){
      return new AbstractView(){
        @Override protected void renderMergedOutputModel(        Map<String,Object> model,        HttpServletRequest request,        HttpServletResponse response) throws Exception {
          response.getWriter().write("ERROR_BEAN");
        }
      }
;
    }
@RestController protected static class Errors {
      public String getFoo(){
        return "foo";
      }
      @RequestMapping("/") public String home(){
        throw new IllegalStateException("Expected!");
      }
      @RequestMapping("/bang") public String bang(){
        throw new NotFoundException("Expected!");
      }
      @RequestMapping("/bind") public String bind() throws Exception {
        BindException error=new BindException(this,"test");
        error.rejectValue("foo","bar.error");
        throw error;
      }
    }
  }
@ResponseStatus(HttpStatus.NOT_FOUND) private static class NotFoundException extends RuntimeException {
    NotFoundException(    String string){
      super(string);
    }
  }
private class ErrorDispatcher implements RequestBuilder {
    private MvcResult result;
    private String path;
    ErrorDispatcher(    MvcResult result,    String path){
      this.result=result;
      this.path=path;
    }
    @Override public MockHttpServletRequest buildRequest(    ServletContext servletContext){
      MockHttpServletRequest request=this.result.getRequest();
      request.setDispatcherType(DispatcherType.ERROR);
      request.setRequestURI(this.path);
      return request;
    }
  }
}
