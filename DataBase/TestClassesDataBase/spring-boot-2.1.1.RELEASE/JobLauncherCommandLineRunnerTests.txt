/** 
 * Tests for  {@link JobLauncherCommandLineRunner}.
 * @author Dave Syer
 * @author Jean-Pierre Bergamin
 * @author Mahmoud Ben Hassine
 */
public class JobLauncherCommandLineRunnerTests {
  private AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext();
  private JobLauncherCommandLineRunner runner;
  private JobExplorer jobExplorer;
  private JobBuilderFactory jobs;
  private StepBuilderFactory steps;
  private Job job;
  private Step step;
  @Before public void init(){
    this.context.register(BatchConfiguration.class);
    this.context.refresh();
    JobRepository jobRepository=this.context.getBean(JobRepository.class);
    JobLauncher jobLauncher=this.context.getBean(JobLauncher.class);
    this.jobs=new JobBuilderFactory(jobRepository);
    PlatformTransactionManager transactionManager=this.context.getBean(PlatformTransactionManager.class);
    this.steps=new StepBuilderFactory(jobRepository,transactionManager);
    Tasklet tasklet=(contribution,chunkContext) -> null;
    this.step=this.steps.get("step").tasklet(tasklet).build();
    this.job=this.jobs.get("job").start(this.step).build();
    this.jobExplorer=this.context.getBean(JobExplorer.class);
    this.runner=new JobLauncherCommandLineRunner(jobLauncher,this.jobExplorer,jobRepository);
    this.context.getBean(BatchConfiguration.class).clear();
  }
  @After public void closeContext(){
    this.context.close();
  }
  @Test public void basicExecution() throws Exception {
    this.runner.execute(this.job,new JobParameters());
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(1);
    this.runner.execute(this.job,new JobParametersBuilder().addLong("id",1L).toJobParameters());
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(2);
  }
  @Test public void incrementExistingExecution() throws Exception {
    this.job=this.jobs.get("job").start(this.step).incrementer(new RunIdIncrementer()).build();
    this.runner.execute(this.job,new JobParameters());
    this.runner.execute(this.job,new JobParameters());
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(2);
  }
  @Test public void retryFailedExecution() throws Exception {
    this.job=this.jobs.get("job").start(this.steps.get("step").tasklet(throwingTasklet()).build()).incrementer(new RunIdIncrementer()).build();
    this.runner.execute(this.job,new JobParameters());
    this.runner.execute(this.job,new JobParametersBuilder().addLong("run.id",1L).toJobParameters());
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(1);
  }
  @Test public void runDifferentInstances() throws Exception {
    this.job=this.jobs.get("job").start(this.steps.get("step").tasklet(throwingTasklet()).build()).build();
    JobParameters jobParameters=new JobParametersBuilder().addString("name","foo").toJobParameters();
    this.runner.execute(this.job,jobParameters);
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(1);
    JobParameters otherJobParameters=new JobParametersBuilder().addString("name","bar").toJobParameters();
    this.runner.execute(this.job,otherJobParameters);
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(2);
  }
  @Test public void retryFailedExecutionOnNonRestartableJob() throws Exception {
    this.job=this.jobs.get("job").preventRestart().start(this.steps.get("step").tasklet(throwingTasklet()).build()).incrementer(new RunIdIncrementer()).build();
    this.runner.execute(this.job,new JobParameters());
    this.runner.execute(this.job,new JobParameters());
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(2);
    assertThatExceptionOfType(JobRestartException.class).isThrownBy(() -> {
      this.runner.execute(this.job,new JobParametersBuilder().addLong("run.id",1L).toJobParameters());
      fail("expected JobRestartException");
    }
).withMessageContaining("JobInstance already exists and is not restartable");
  }
  @Test public void retryFailedExecutionWithNonIdentifyingParameters() throws Exception {
    this.job=this.jobs.get("job").start(this.steps.get("step").tasklet(throwingTasklet()).build()).incrementer(new RunIdIncrementer()).build();
    JobParameters jobParameters=new JobParametersBuilder().addLong("id",1L,false).addLong("foo",2L,false).toJobParameters();
    this.runner.execute(this.job,jobParameters);
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(1);
    this.runner.execute(this.job,new JobParametersBuilder(jobParameters).addLong("run.id",1L).toJobParameters());
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(1);
  }
  @Test public void retryFailedExecutionWithDifferentNonIdentifyingParametersFromPreviousExecution() throws Exception {
    this.job=this.jobs.get("job").start(this.steps.get("step").tasklet(throwingTasklet()).build()).incrementer(new RunIdIncrementer()).build();
    JobParameters jobParameters=new JobParametersBuilder().addLong("id",1L,false).addLong("foo",2L,false).toJobParameters();
    this.runner.execute(this.job,jobParameters);
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(1);
    this.runner.execute(this.job,new JobParametersBuilder().addLong("run.id",1L).addLong("id",2L,false).addLong("foo",3L,false).toJobParameters());
    assertThat(this.jobExplorer.getJobInstances("job",0,100)).hasSize(1);
    JobInstance jobInstance=this.jobExplorer.getJobInstance(0L);
    assertThat(this.jobExplorer.getJobExecutions(jobInstance)).hasSize(2);
    JobExecution firstJobExecution=this.jobExplorer.getJobExecution(0L);
    JobParameters parameters=firstJobExecution.getJobParameters();
    assertThat(parameters.getLong("run.id")).isEqualTo(1L);
    assertThat(parameters.getLong("id")).isEqualTo(1L);
    assertThat(parameters.getLong("foo")).isEqualTo(2L);
    JobExecution secondJobExecution=this.jobExplorer.getJobExecution(1L);
    parameters=secondJobExecution.getJobParameters();
    assertThat(parameters.getLong("run.id")).isEqualTo(1L);
    assertThat(parameters.getLong("id")).isEqualTo(2L);
    assertThat(parameters.getLong("foo")).isEqualTo(3L);
  }
  private Tasklet throwingTasklet(){
    return (contribution,chunkContext) -> {
      throw new RuntimeException("Planned");
    }
;
  }
@Configuration @EnableBatchProcessing protected static class BatchConfiguration implements BatchConfigurer {
    private ResourcelessTransactionManager transactionManager=new ResourcelessTransactionManager();
    private JobRepository jobRepository;
    private MapJobRepositoryFactoryBean jobRepositoryFactory=new MapJobRepositoryFactoryBean(this.transactionManager);
    public BatchConfiguration() throws Exception {
      this.jobRepository=this.jobRepositoryFactory.getObject();
    }
    public void clear(){
      this.jobRepositoryFactory.clear();
    }
    @Override public JobRepository getJobRepository(){
      return this.jobRepository;
    }
    @Override public PlatformTransactionManager getTransactionManager(){
      return this.transactionManager;
    }
    @Override public JobLauncher getJobLauncher(){
      SimpleJobLauncher launcher=new SimpleJobLauncher();
      launcher.setJobRepository(this.jobRepository);
      launcher.setTaskExecutor(new SyncTaskExecutor());
      return launcher;
    }
    @Override public JobExplorer getJobExplorer() throws Exception {
      return new MapJobExplorerFactoryBean(this.jobRepositoryFactory).getObject();
    }
  }
}
