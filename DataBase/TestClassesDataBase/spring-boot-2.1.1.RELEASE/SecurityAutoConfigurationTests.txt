/** 
 * Tests for  {@link SecurityAutoConfiguration}.
 * @author Dave Syer
 * @author Rob Winch
 * @author Andy Wilkinson
 * @author Madhura Bhave
 */
public class SecurityAutoConfigurationTests {
  private WebApplicationContextRunner contextRunner=new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(SecurityAutoConfiguration.class,PropertyPlaceholderAutoConfiguration.class));
  @Rule public OutputCapture outputCapture=new OutputCapture();
  @Test public void testWebConfiguration(){
    this.contextRunner.run((context) -> {
      assertThat(context.getBean(AuthenticationManagerBuilder.class)).isNotNull();
      assertThat(context.getBean(FilterChainProxy.class).getFilterChains()).hasSize(1);
    }
);
  }
  @Test public void testDefaultFilterOrderWithSecurityAdapter(){
    this.contextRunner.withConfiguration(AutoConfigurations.of(WebSecurity.class,SecurityFilterAutoConfiguration.class)).run((context) -> assertThat(context.getBean("securityFilterChainRegistration",DelegatingFilterProxyRegistrationBean.class).getOrder()).isEqualTo(OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER - 100));
  }
  @Test public void testFilterIsNotRegisteredInNonWeb(){
    try (AnnotationConfigApplicationContext customContext=new AnnotationConfigApplicationContext()){
      customContext.register(SecurityAutoConfiguration.class,SecurityFilterAutoConfiguration.class,PropertyPlaceholderAutoConfiguration.class);
      customContext.refresh();
      assertThat(customContext.containsBean("securityFilterChainRegistration")).isFalse();
    }
   }
  @Test public void defaultAuthenticationEventPublisherRegistered(){
    this.contextRunner.run((context) -> assertThat(context.getBean(AuthenticationEventPublisher.class)).isInstanceOf(DefaultAuthenticationEventPublisher.class));
  }
  @Test public void defaultAuthenticationEventPublisherIsConditionalOnMissingBean(){
    this.contextRunner.withUserConfiguration(AuthenticationEventPublisherConfiguration.class).run((context) -> assertThat(context.getBean(AuthenticationEventPublisher.class)).isInstanceOf(AuthenticationEventPublisherConfiguration.TestAuthenticationEventPublisher.class));
  }
  @Test public void testDefaultFilterOrder(){
    this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class)).run((context) -> assertThat(context.getBean("securityFilterChainRegistration",DelegatingFilterProxyRegistrationBean.class).getOrder()).isEqualTo(OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER - 100));
  }
  @Test public void testCustomFilterOrder(){
    this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class)).withPropertyValues("spring.security.filter.order:12345").run((context) -> assertThat(context.getBean("securityFilterChainRegistration",DelegatingFilterProxyRegistrationBean.class).getOrder()).isEqualTo(12345));
  }
  @Test public void testJpaCoexistsHappily(){
    this.contextRunner.withPropertyValues("spring.datasource.url:jdbc:hsqldb:mem:testsecdb","spring.datasource.initialization-mode:never").withUserConfiguration(EntityConfiguration.class).withConfiguration(AutoConfigurations.of(HibernateJpaAutoConfiguration.class,DataSourceAutoConfiguration.class)).run((context) -> assertThat(context.getBean(JpaTransactionManager.class)).isNotNull());
  }
  @Test public void testSecurityEvaluationContextExtensionSupport(){
    this.contextRunner.run((context) -> assertThat(context).getBean(SecurityEvaluationContextExtension.class).isNotNull());
  }
  @Test public void defaultFilterDispatcherTypes(){
    this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class)).run((context) -> {
      DelegatingFilterProxyRegistrationBean bean=context.getBean("securityFilterChainRegistration",DelegatingFilterProxyRegistrationBean.class);
      @SuppressWarnings("unchecked") EnumSet<DispatcherType> dispatcherTypes=(EnumSet<DispatcherType>)ReflectionTestUtils.getField(bean,"dispatcherTypes");
      assertThat(dispatcherTypes).containsOnly(DispatcherType.ASYNC,DispatcherType.ERROR,DispatcherType.REQUEST);
    }
);
  }
  @Test public void customFilterDispatcherTypes(){
    this.contextRunner.withPropertyValues("spring.security.filter.dispatcher-types:INCLUDE,ERROR").withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class)).run((context) -> {
      DelegatingFilterProxyRegistrationBean bean=context.getBean("securityFilterChainRegistration",DelegatingFilterProxyRegistrationBean.class);
      @SuppressWarnings("unchecked") EnumSet<DispatcherType> dispatcherTypes=(EnumSet<DispatcherType>)ReflectionTestUtils.getField(bean,"dispatcherTypes");
      assertThat(dispatcherTypes).containsOnly(DispatcherType.INCLUDE,DispatcherType.ERROR);
    }
);
  }
@Configuration @TestAutoConfigurationPackage(City.class) protected static class EntityConfiguration {
  }
@Configuration static class AuthenticationEventPublisherConfiguration {
    @Bean public AuthenticationEventPublisher authenticationEventPublisher(){
      return new TestAuthenticationEventPublisher();
    }
class TestAuthenticationEventPublisher implements AuthenticationEventPublisher {
      @Override public void publishAuthenticationSuccess(      Authentication authentication){
      }
      @Override public void publishAuthenticationFailure(      AuthenticationException exception,      Authentication authentication){
      }
    }
  }
@Configuration @EnableWebSecurity static class WebSecurity extends WebSecurityConfigurerAdapter {
  }
}
