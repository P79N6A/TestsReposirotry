/** 
 * Tests for the  {@link AutoConfigurationImportFilter} part of {@link OnClassCondition}.
 * @author Phillip Webb
 */
public class OnClassConditionAutoConfigurationImportFilterTests {
  private OnClassCondition filter=new OnClassCondition();
  private DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();
  @Before public void setup(){
    this.filter.setBeanClassLoader(getClass().getClassLoader());
    this.filter.setBeanFactory(this.beanFactory);
  }
  @Test public void shouldBeRegistered(){
    assertThat(SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class,null)).hasAtLeastOneElementOfType(OnClassCondition.class);
  }
  @Test public void matchShouldMatchClasses(){
    String[] autoConfigurationClasses=new String[]{"test.match","test.nomatch"};
    boolean[] result=this.filter.match(autoConfigurationClasses,getAutoConfigurationMetadata());
    assertThat(result).containsExactly(true,false);
  }
  @Test public void matchShouldRecordOutcome(){
    String[] autoConfigurationClasses=new String[]{"test.match","test.nomatch"};
    this.filter.match(autoConfigurationClasses,getAutoConfigurationMetadata());
    ConditionEvaluationReport report=ConditionEvaluationReport.get(this.beanFactory);
    assertThat(report.getConditionAndOutcomesBySource()).hasSize(1).containsKey("test.nomatch");
  }
  private AutoConfigurationMetadata getAutoConfigurationMetadata(){
    AutoConfigurationMetadata metadata=mock(AutoConfigurationMetadata.class);
    given(metadata.wasProcessed("test.match")).willReturn(true);
    given(metadata.get("test.match","ConditionalOnClass")).willReturn("java.io.InputStream");
    given(metadata.wasProcessed("test.nomatch")).willReturn(true);
    given(metadata.get("test.nomatch","ConditionalOnClass")).willReturn("java.io.DoesNotExist");
    return metadata;
  }
}
