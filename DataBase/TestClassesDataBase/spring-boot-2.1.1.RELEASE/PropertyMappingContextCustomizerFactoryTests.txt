/** 
 * Tests for  {@link PropertyMappingContextCustomizerFactory}.
 * @author Phillip Webb
 */
public class PropertyMappingContextCustomizerFactoryTests {
  private PropertyMappingContextCustomizerFactory factory=new PropertyMappingContextCustomizerFactory();
  @Test public void getContextCustomizerWhenHasNoMappingShouldNotAddPropertySource(){
    ContextCustomizer customizer=this.factory.createContextCustomizer(NoMapping.class,null);
    ConfigurableApplicationContext context=mock(ConfigurableApplicationContext.class);
    ConfigurableEnvironment environment=mock(ConfigurableEnvironment.class);
    ConfigurableListableBeanFactory beanFactory=mock(ConfigurableListableBeanFactory.class);
    given(context.getEnvironment()).willReturn(environment);
    given(context.getBeanFactory()).willReturn(beanFactory);
    customizer.customizeContext(context,null);
    verifyZeroInteractions(environment);
  }
  @Test public void getContextCustomizerWhenHasTypeMappingShouldReturnCustomizer(){
    ContextCustomizer customizer=this.factory.createContextCustomizer(TypeMapping.class,null);
    assertThat(customizer).isNotNull();
  }
  @Test public void getContextCustomizerWhenHasAttributeMappingShouldReturnCustomizer(){
    ContextCustomizer customizer=this.factory.createContextCustomizer(AttributeMapping.class,null);
    assertThat(customizer).isNotNull();
  }
  @Test public void hashCodeAndEqualsShouldBeBasedOnPropertyValues(){
    ContextCustomizer customizer1=this.factory.createContextCustomizer(TypeMapping.class,null);
    ContextCustomizer customizer2=this.factory.createContextCustomizer(AttributeMapping.class,null);
    ContextCustomizer customizer3=this.factory.createContextCustomizer(OtherMapping.class,null);
    assertThat(customizer1.hashCode()).isEqualTo(customizer2.hashCode());
    assertThat(customizer1).isEqualTo(customizer1).isEqualTo(customizer2).isNotEqualTo(customizer3);
  }
  @Test public void prepareContextShouldAddPropertySource(){
    ContextCustomizer customizer=this.factory.createContextCustomizer(AttributeMapping.class,null);
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext();
    customizer.customizeContext(context,null);
    assertThat(context.getEnvironment().getProperty("mapped")).isEqualTo("Mapped");
  }
  @Test public void propertyMappingShouldNotBeUsedWithComponent(){
    ContextCustomizer customizer=this.factory.createContextCustomizer(AttributeMapping.class,null);
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext();
    context.register(ConfigMapping.class);
    customizer.customizeContext(context,null);
    assertThatExceptionOfType(BeanCreationException.class).isThrownBy(context::refresh).withMessageContaining("The @PropertyMapping annotation " + "@PropertyMappingContextCustomizerFactoryTests.TypeMappingAnnotation " + "cannot be used in combination with the @Component annotation @Configuration");
  }
@NoMappingAnnotation static class NoMapping {
  }
  @Retention(RetentionPolicy.RUNTIME) static @interface NoMappingAnnotation {}
@TypeMappingAnnotation static class TypeMapping {
  }
@Configuration @TypeMappingAnnotation static class ConfigMapping {
  }
  @Retention(RetentionPolicy.RUNTIME) @PropertyMapping static @interface TypeMappingAnnotation {  String mapped() default "Mapped";
}
@AttributeMappingAnnotation static class AttributeMapping {
  }
@AttributeMappingAnnotation("Other") static class OtherMapping {
  }
  @Retention(RetentionPolicy.RUNTIME) static @interface AttributeMappingAnnotation {  @PropertyMapping("mapped") String value() default "Mapped";
}
}
