/** 
 * Tests for  {@link MetricsWebClientFilterFunction}
 * @author Brian Clozel
 */
public class MetricsWebClientFilterFunctionTests {
  private static final String URI_TEMPLATE_ATTRIBUTE=WebClient.class.getName() + ".uriTemplate";
  private MeterRegistry registry;
  private MetricsWebClientFilterFunction filterFunction;
  private ClientResponse response;
  private ExchangeFunction exchange;
  @Before public void setup(){
    this.registry=new SimpleMeterRegistry(SimpleConfig.DEFAULT,new MockClock());
    this.filterFunction=new MetricsWebClientFilterFunction(this.registry,new DefaultWebClientExchangeTagsProvider(),"http.client.requests");
    this.response=mock(ClientResponse.class);
    this.exchange=(r) -> Mono.just(this.response);
  }
  @Test public void filterShouldRecordTimer(){
    ClientRequest request=ClientRequest.create(HttpMethod.GET,URI.create("http://example.com/projects/spring-boot")).build();
    given(this.response.statusCode()).willReturn(HttpStatus.OK);
    this.filterFunction.filter(request,this.exchange).block();
    assertThat(this.registry.get("http.client.requests").tags("method","GET","uri","/projects/spring-boot","status","200").timer().count()).isEqualTo(1);
  }
  @Test public void filterWhenUriTemplatePresentShouldRecordTimer(){
    ClientRequest request=ClientRequest.create(HttpMethod.GET,URI.create("http://example.com/projects/spring-boot")).attribute(URI_TEMPLATE_ATTRIBUTE,"/projects/{project}").build();
    given(this.response.statusCode()).willReturn(HttpStatus.OK);
    this.filterFunction.filter(request,this.exchange).block();
    assertThat(this.registry.get("http.client.requests").tags("method","GET","uri","/projects/{project}","status","200").timer().count()).isEqualTo(1);
  }
  @Test public void filterWhenIoExceptionThrownShouldRecordTimer(){
    ClientRequest request=ClientRequest.create(HttpMethod.GET,URI.create("http://example.com/projects/spring-boot")).build();
    ExchangeFunction errorExchange=(r) -> Mono.error(new IOException());
    this.filterFunction.filter(request,errorExchange).onErrorResume(IOException.class,(t) -> Mono.empty()).block();
    assertThat(this.registry.get("http.client.requests").tags("method","GET","uri","/projects/spring-boot","status","IO_ERROR").timer().count()).isEqualTo(1);
  }
  @Test public void filterWhenExceptionThrownShouldRecordTimer(){
    ClientRequest request=ClientRequest.create(HttpMethod.GET,URI.create("http://example.com/projects/spring-boot")).build();
    ExchangeFunction exchange=(r) -> Mono.error(new IllegalArgumentException());
    this.filterFunction.filter(request,exchange).onErrorResume(IllegalArgumentException.class,(t) -> Mono.empty()).block();
    assertThat(this.registry.get("http.client.requests").tags("method","GET","uri","/projects/spring-boot","status","CLIENT_ERROR").timer().count()).isEqualTo(1);
  }
  @Test public void filterWhenExceptionAndRetryShouldNotCumulateRecordTime(){
    ClientRequest request=ClientRequest.create(HttpMethod.GET,URI.create("http://example.com/projects/spring-boot")).build();
    ExchangeFunction exchange=(r) -> Mono.error(new IllegalArgumentException()).delaySubscription(Duration.ofMillis(300)).cast(ClientResponse.class);
    this.filterFunction.filter(request,exchange).retry(1).onErrorResume(IllegalArgumentException.class,(t) -> Mono.empty()).block();
    Timer timer=this.registry.get("http.client.requests").tags("method","GET","uri","/projects/spring-boot","status","CLIENT_ERROR").timer();
    assertThat(timer.count()).isEqualTo(2);
    assertThat(timer.max(TimeUnit.MILLISECONDS)).isLessThan(600);
  }
}
