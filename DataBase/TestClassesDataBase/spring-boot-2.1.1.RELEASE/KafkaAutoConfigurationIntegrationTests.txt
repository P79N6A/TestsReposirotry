/** 
 * Integration tests for  {@link KafkaAutoConfiguration}.
 * @author Gary Russell
 * @author Stephane Nicoll
 */
public class KafkaAutoConfigurationIntegrationTests {
  private static final String TEST_TOPIC="testTopic";
  private static final String ADMIN_CREATED_TOPIC="adminCreatedTopic";
  @ClassRule public static final EmbeddedKafkaRule embeddedKafka=new EmbeddedKafkaRule(1,true,TEST_TOPIC);
  private AnnotationConfigApplicationContext context;
  @After public void close(){
    if (this.context != null) {
      this.context.close();
    }
  }
  @SuppressWarnings({"unchecked","rawtypes"}) @Test public void testEndToEnd() throws Exception {
    load(KafkaConfig.class,"spring.kafka.bootstrap-servers:" + getEmbeddedKafkaBrokersAsString(),"spring.kafka.consumer.group-id=testGroup","spring.kafka.consumer.auto-offset-reset=earliest");
    KafkaTemplate<String,String> template=this.context.getBean(KafkaTemplate.class);
    template.send(TEST_TOPIC,"foo","bar");
    Listener listener=this.context.getBean(Listener.class);
    assertThat(listener.latch.await(30,TimeUnit.SECONDS)).isTrue();
    assertThat(listener.key).isEqualTo("foo");
    assertThat(listener.received).isEqualTo("bar");
    DefaultKafkaProducerFactory producerFactory=this.context.getBean(DefaultKafkaProducerFactory.class);
    Producer producer=producerFactory.createProducer();
    assertThat(producer.partitionsFor(ADMIN_CREATED_TOPIC).size()).isEqualTo(10);
    producer.close();
  }
  @Test public void testStreams(){
    load(KafkaStreamsConfig.class,"spring.application.name:my-app","spring.kafka.bootstrap-servers:" + getEmbeddedKafkaBrokersAsString());
    assertThat(this.context.getBean(StreamsBuilderFactoryBean.class).isAutoStartup()).isTrue();
  }
  private void load(  Class<?> config,  String... environment){
    this.context=doLoad(new Class<?>[]{config},environment);
  }
  private AnnotationConfigApplicationContext doLoad(  Class<?>[] configs,  String... environment){
    AnnotationConfigApplicationContext applicationContext=new AnnotationConfigApplicationContext();
    applicationContext.register(configs);
    applicationContext.register(KafkaAutoConfiguration.class);
    TestPropertyValues.of(environment).applyTo(applicationContext);
    applicationContext.refresh();
    return applicationContext;
  }
  private String getEmbeddedKafkaBrokersAsString(){
    return embeddedKafka.getEmbeddedKafka().getBrokersAsString();
  }
@Configuration static class KafkaConfig {
    @Bean public Listener listener(){
      return new Listener();
    }
    @Bean public NewTopic adminCreated(){
      return new NewTopic(ADMIN_CREATED_TOPIC,10,(short)1);
    }
  }
@Configuration @EnableKafkaStreams static class KafkaStreamsConfig {
  }
public static class Listener {
    private final CountDownLatch latch=new CountDownLatch(1);
    private volatile String received;
    private volatile String key;
    @KafkaListener(topics=TEST_TOPIC) public void listen(    String foo,    @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) String key){
      this.received=foo;
      this.key=key;
      this.latch.countDown();
    }
  }
}
