/** 
 * Tests for  {@link ReactiveManagementWebSecurityAutoConfiguration}.
 * @author Madhura Bhave
 */
public class ReactiveManagementWebSecurityAutoConfigurationTests {
  private ReactiveWebApplicationContextRunner contextRunner=new ReactiveWebApplicationContextRunner().withConfiguration(AutoConfigurations.of(HealthIndicatorAutoConfiguration.class,HealthEndpointAutoConfiguration.class,InfoEndpointAutoConfiguration.class,EnvironmentEndpointAutoConfiguration.class,EndpointAutoConfiguration.class,WebEndpointAutoConfiguration.class,ReactiveSecurityAutoConfiguration.class,ReactiveUserDetailsServiceAutoConfiguration.class,ReactiveManagementWebSecurityAutoConfiguration.class));
  @Test public void permitAllForHealth(){
    this.contextRunner.run((context) -> assertThat(getAuthenticateHeader(context,"/actuator/health")).isNull());
  }
  @Test public void permitAllForInfo(){
    this.contextRunner.run((context) -> assertThat(getAuthenticateHeader(context,"/actuator/info")).isNull());
  }
  @Test public void securesEverythingElse(){
    this.contextRunner.run((context) -> {
      assertThat(getAuthenticateHeader(context,"/actuator").get(0)).contains("Basic realm=");
      assertThat(getAuthenticateHeader(context,"/foo").toString()).contains("Basic realm=");
    }
);
  }
  @Test public void usesMatchersBasedOffConfiguredActuatorBasePath(){
    this.contextRunner.withPropertyValues("management.endpoints.web.base-path=/").run((context) -> {
      assertThat(getAuthenticateHeader(context,"/health")).isNull();
      assertThat(getAuthenticateHeader(context,"/foo").get(0)).contains("Basic realm=");
    }
);
  }
  @Test public void backsOffIfCustomSecurityIsAdded(){
    this.contextRunner.withUserConfiguration(CustomSecurityConfiguration.class).run((context) -> {
      assertThat(getLocationHeader(context,"/actuator/health").toString()).contains("/login");
      assertThat(getLocationHeader(context,"/foo")).isNull();
    }
);
  }
  @Test public void backsOffWhenWebFilterChainProxyBeanPresent(){
    this.contextRunner.withUserConfiguration(WebFilterChainProxyConfiguration.class).run((context) -> {
      assertThat(getLocationHeader(context,"/actuator/health").toString()).contains("/login");
      assertThat(getLocationHeader(context,"/foo").toString()).contains("/login");
    }
);
  }
  private List<String> getAuthenticateHeader(  AssertableReactiveWebApplicationContext context,  String path){
    ServerWebExchange exchange=performFilter(context,path);
    return exchange.getResponse().getHeaders().get(HttpHeaders.WWW_AUTHENTICATE);
  }
  private ServerWebExchange performFilter(  AssertableReactiveWebApplicationContext context,  String path){
    ServerWebExchange exchange=webHandler(context).createExchange(MockServerHttpRequest.get(path).build(),new MockServerHttpResponse());
    WebFilterChainProxy proxy=context.getBean(WebFilterChainProxy.class);
    proxy.filter(exchange,(serverWebExchange) -> Mono.empty()).block();
    return exchange;
  }
  private URI getLocationHeader(  AssertableReactiveWebApplicationContext context,  String path){
    ServerWebExchange exchange=performFilter(context,path);
    return exchange.getResponse().getHeaders().getLocation();
  }
  private TestHttpWebHandlerAdapter webHandler(  AssertableReactiveWebApplicationContext context){
    TestHttpWebHandlerAdapter adapter=new TestHttpWebHandlerAdapter(mock(WebHandler.class));
    adapter.setApplicationContext(context);
    return adapter;
  }
private static class TestHttpWebHandlerAdapter extends HttpWebHandlerAdapter {
    TestHttpWebHandlerAdapter(    WebHandler delegate){
      super(delegate);
    }
    @Override protected ServerWebExchange createExchange(    ServerHttpRequest request,    ServerHttpResponse response){
      return super.createExchange(request,response);
    }
  }
@Configuration static class CustomSecurityConfiguration {
    @Bean public SecurityWebFilterChain springSecurityFilterChain(    ServerHttpSecurity http){
      return http.authorizeExchange().pathMatchers("/foo").permitAll().anyExchange().authenticated().and().formLogin().and().build();
    }
  }
@Configuration static class WebFilterChainProxyConfiguration {
    @Bean public ReactiveAuthenticationManager authenticationManager(){
      return mock(ReactiveAuthenticationManager.class);
    }
    @Bean public WebFilterChainProxy webFilterChainProxy(    ServerHttpSecurity http){
      return new WebFilterChainProxy(getFilterChains(http));
    }
    @Bean public TestServerHttpSecurity http(    ReactiveAuthenticationManager authenticationManager){
      TestServerHttpSecurity httpSecurity=new TestServerHttpSecurity();
      httpSecurity.authenticationManager(authenticationManager);
      return httpSecurity;
    }
    private List<SecurityWebFilterChain> getFilterChains(    ServerHttpSecurity http){
      return Collections.singletonList(http.authorizeExchange().anyExchange().authenticated().and().formLogin().and().build());
    }
private static class TestServerHttpSecurity extends ServerHttpSecurity implements ApplicationContextAware {
      @Override public void setApplicationContext(      ApplicationContext applicationContext) throws BeansException {
        super.setApplicationContext(applicationContext);
      }
    }
  }
}
