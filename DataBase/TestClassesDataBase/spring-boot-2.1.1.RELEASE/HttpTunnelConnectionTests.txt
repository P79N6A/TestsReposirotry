/** 
 * Tests for  {@link HttpTunnelConnection}.
 * @author Phillip Webb
 * @author Rob Winch
 * @author Andy Wilkinson
 */
public class HttpTunnelConnectionTests {
  @Rule public OutputCapture outputCapture=new OutputCapture();
  private String url;
  private ByteArrayOutputStream incomingData;
  private WritableByteChannel incomingChannel;
  @Mock private Closeable closeable;
  private MockClientHttpRequestFactory requestFactory=new MockClientHttpRequestFactory();
  @Before public void setup(){
    MockitoAnnotations.initMocks(this);
    this.url="http://localhost:12345";
    this.incomingData=new ByteArrayOutputStream();
    this.incomingChannel=Channels.newChannel(this.incomingData);
  }
  @Test public void urlMustNotBeNull(){
    assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection(null,this.requestFactory)).withMessageContaining("URL must not be empty");
  }
  @Test public void urlMustNotBeEmpty(){
    assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection("",this.requestFactory)).withMessageContaining("URL must not be empty");
  }
  @Test public void urlMustNotBeMalformed(){
    assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection("htttttp:///ttest",this.requestFactory)).withMessageContaining("Malformed URL 'htttttp:///ttest'");
  }
  @Test public void requestFactoryMustNotBeNull(){
    assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection(this.url,null)).withMessageContaining("RequestFactory must not be null");
  }
  @Test public void closeTunnelChangesIsOpen() throws Exception {
    this.requestFactory.willRespondAfterDelay(1000,HttpStatus.GONE);
    WritableByteChannel channel=openTunnel(false);
    assertThat(channel.isOpen()).isTrue();
    channel.close();
    assertThat(channel.isOpen()).isFalse();
  }
  @Test public void closeTunnelCallsCloseableOnce() throws Exception {
    this.requestFactory.willRespondAfterDelay(1000,HttpStatus.GONE);
    WritableByteChannel channel=openTunnel(false);
    verify(this.closeable,never()).close();
    channel.close();
    channel.close();
    verify(this.closeable,times(1)).close();
  }
  @Test public void typicalTraffic() throws Exception {
    this.requestFactory.willRespond("hi","=2","=3");
    TunnelChannel channel=openTunnel(true);
    write(channel,"hello");
    write(channel,"1+1");
    write(channel,"1+2");
    assertThat(this.incomingData.toString()).isEqualTo("hi=2=3");
  }
  @Test public void trafficWithLongPollTimeouts() throws Exception {
    for (int i=0; i < 10; i++) {
      this.requestFactory.willRespond(HttpStatus.NO_CONTENT);
    }
    this.requestFactory.willRespond("hi");
    TunnelChannel channel=openTunnel(true);
    write(channel,"hello");
    assertThat(this.incomingData.toString()).isEqualTo("hi");
    assertThat(this.requestFactory.getExecutedRequests().size()).isGreaterThan(10);
  }
  @Test public void connectFailureLogsWarning() throws Exception {
    this.requestFactory.willRespond(new ConnectException());
    TunnelChannel tunnel=openTunnel(true);
    assertThat(tunnel.isOpen()).isFalse();
    this.outputCapture.expect(containsString("Failed to connect to remote application at http://localhost:12345"));
  }
  private void write(  TunnelChannel channel,  String string) throws IOException {
    channel.write(ByteBuffer.wrap(string.getBytes()));
  }
  private TunnelChannel openTunnel(  boolean singleThreaded) throws Exception {
    HttpTunnelConnection connection=new HttpTunnelConnection(this.url,this.requestFactory,singleThreaded ? new CurrentThreadExecutor() : null);
    return connection.open(this.incomingChannel,this.closeable);
  }
private static class CurrentThreadExecutor implements Executor {
    @Override public void execute(    Runnable command){
      command.run();
    }
  }
}
