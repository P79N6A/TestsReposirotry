/** 
 * Test for  {@link FilteredIterableConfigurationPropertiesSource}.
 * @author Phillip Webb
 * @author Madhura Bhave
 */
public class FilteredConfigurationPropertiesSourceTests {
  @Test public void createWhenSourceIsNullShouldThrowException(){
    assertThatIllegalArgumentException().isThrownBy(() -> new FilteredConfigurationPropertiesSource(null,Objects::nonNull)).withMessageContaining("Source must not be null");
  }
  @Test public void createWhenFilterIsNullShouldThrowException(){
    assertThatIllegalArgumentException().isThrownBy(() -> new FilteredConfigurationPropertiesSource(new MockConfigurationPropertySource(),null)).withMessageContaining("Filter must not be null");
  }
  @Test public void getValueShouldFilterNames(){
    ConfigurationPropertySource source=createTestSource();
    ConfigurationPropertySource filtered=source.filter(this::noBrackets);
    ConfigurationPropertyName name=ConfigurationPropertyName.of("a");
    assertThat(source.getConfigurationProperty(name).getValue()).isEqualTo("1");
    assertThat(filtered.getConfigurationProperty(name).getValue()).isEqualTo("1");
    ConfigurationPropertyName bracketName=ConfigurationPropertyName.of("a[1]");
    assertThat(source.getConfigurationProperty(bracketName).getValue()).isEqualTo("2");
    assertThat(filtered.getConfigurationProperty(bracketName)).isNull();
  }
  @Test public void containsDescendantOfWhenSourceReturnsEmptyShouldReturnEmpty(){
    ConfigurationPropertyName name=ConfigurationPropertyName.of("foo");
    ConfigurationPropertySource source=mock(ConfigurationPropertySource.class,Answers.CALLS_REAL_METHODS);
    given(source.containsDescendantOf(name)).willReturn(ConfigurationPropertyState.UNKNOWN);
    ConfigurationPropertySource filtered=source.filter((n) -> true);
    assertThat(filtered.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.UNKNOWN);
  }
  @Test public void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse(){
    ConfigurationPropertyName name=ConfigurationPropertyName.of("foo");
    ConfigurationPropertySource source=mock(ConfigurationPropertySource.class,Answers.CALLS_REAL_METHODS);
    given(source.containsDescendantOf(name)).willReturn(ConfigurationPropertyState.ABSENT);
    ConfigurationPropertySource filtered=source.filter((n) -> true);
    assertThat(filtered.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
  }
  @Test public void containsDescendantOfWhenSourceReturnsTrueShouldReturnEmpty(){
    ConfigurationPropertyName name=ConfigurationPropertyName.of("foo");
    ConfigurationPropertySource source=mock(ConfigurationPropertySource.class,Answers.CALLS_REAL_METHODS);
    given(source.containsDescendantOf(name)).willReturn(ConfigurationPropertyState.PRESENT);
    ConfigurationPropertySource filtered=source.filter((n) -> true);
    assertThat(filtered.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.UNKNOWN);
  }
  protected final ConfigurationPropertySource createTestSource(){
    MockConfigurationPropertySource source=new MockConfigurationPropertySource();
    source.put("a","1");
    source.put("a[1]","2");
    source.put("b","3");
    source.put("b[1]","4");
    source.put("c","5");
    return convertSource(source);
  }
  protected ConfigurationPropertySource convertSource(  MockConfigurationPropertySource source){
    return source.nonIterable();
  }
  private boolean noBrackets(  ConfigurationPropertyName name){
    return name.toString().indexOf("[") == -1;
  }
}
