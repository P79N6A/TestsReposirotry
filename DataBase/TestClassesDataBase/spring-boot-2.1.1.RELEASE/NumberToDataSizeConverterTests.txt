/** 
 * Tests for  {@link NumberToDataSizeConverter}.
 * @author Stephane Nicoll
 */
@RunWith(Parameterized.class) public class NumberToDataSizeConverterTests {
  private final ConversionService conversionService;
  public NumberToDataSizeConverterTests(  String name,  ConversionService conversionService){
    this.conversionService=conversionService;
  }
  @Test public void convertWhenSimpleWithoutSuffixShouldReturnDataSize(){
    assertThat(convert(10)).isEqualTo(DataSize.ofBytes(10));
    assertThat(convert(+10)).isEqualTo(DataSize.ofBytes(10));
    assertThat(convert(-10)).isEqualTo(DataSize.ofBytes(-10));
  }
  @Test public void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnDataSize(){
    assertThat(convert(10,DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(10));
    assertThat(convert(+10,DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(10));
    assertThat(convert(-10,DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(-10));
  }
  private DataSize convert(  Integer source){
    return this.conversionService.convert(source,DataSize.class);
  }
  @SuppressWarnings({"rawtypes","unchecked"}) private DataSize convert(  Integer source,  DataUnit defaultUnit){
    TypeDescriptor targetType=mock(TypeDescriptor.class);
    if (defaultUnit != null) {
      DataSizeUnit unitAnnotation=AnnotationUtils.synthesizeAnnotation(Collections.singletonMap("value",defaultUnit),DataSizeUnit.class,null);
      given(targetType.getAnnotation(DataSizeUnit.class)).willReturn(unitAnnotation);
    }
    given(targetType.getType()).willReturn((Class)DataSize.class);
    return (DataSize)this.conversionService.convert(source,TypeDescriptor.forObject(source),targetType);
  }
  @Parameterized.Parameters(name="{0}") public static Iterable<Object[]> conversionServices(){
    return new ConversionServiceParameters(new NumberToDataSizeConverter());
  }
}
