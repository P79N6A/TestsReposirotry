/** 
 * Tests for  {@link CachingOperationInvoker}.
 * @author Stephane Nicoll
 */
public class CachingOperationInvokerTests {
  @Test public void createInstanceWithTtlSetToZero(){
    assertThatIllegalArgumentException().isThrownBy(() -> new CachingOperationInvoker(mock(OperationInvoker.class),0)).withMessageContaining("TimeToLive");
  }
  @Test public void cacheInTtlRangeWithNoParameter(){
    assertCacheIsUsed(Collections.emptyMap());
  }
  @Test public void cacheInTtlWithNullParameters(){
    Map<String,Object> parameters=new HashMap<>();
    parameters.put("first",null);
    parameters.put("second",null);
    assertCacheIsUsed(parameters);
  }
  private void assertCacheIsUsed(  Map<String,Object> parameters){
    OperationInvoker target=mock(OperationInvoker.class);
    Object expected=new Object();
    InvocationContext context=new InvocationContext(mock(SecurityContext.class),parameters);
    given(target.invoke(context)).willReturn(expected);
    CachingOperationInvoker invoker=new CachingOperationInvoker(target,500L);
    Object response=invoker.invoke(context);
    assertThat(response).isSameAs(expected);
    verify(target,times(1)).invoke(context);
    Object cachedResponse=invoker.invoke(context);
    assertThat(cachedResponse).isSameAs(response);
    verifyNoMoreInteractions(target);
  }
  @Test public void targetAlwaysInvokedWithParameters(){
    OperationInvoker target=mock(OperationInvoker.class);
    Map<String,Object> parameters=new HashMap<>();
    parameters.put("test","value");
    parameters.put("something",null);
    InvocationContext context=new InvocationContext(mock(SecurityContext.class),parameters);
    given(target.invoke(context)).willReturn(new Object());
    CachingOperationInvoker invoker=new CachingOperationInvoker(target,500L);
    invoker.invoke(context);
    invoker.invoke(context);
    invoker.invoke(context);
    verify(target,times(3)).invoke(context);
  }
  @Test public void targetAlwaysInvokedWithPrincipal(){
    OperationInvoker target=mock(OperationInvoker.class);
    Map<String,Object> parameters=new HashMap<>();
    SecurityContext securityContext=mock(SecurityContext.class);
    given(securityContext.getPrincipal()).willReturn(mock(Principal.class));
    InvocationContext context=new InvocationContext(securityContext,parameters);
    given(target.invoke(context)).willReturn(new Object());
    CachingOperationInvoker invoker=new CachingOperationInvoker(target,500L);
    invoker.invoke(context);
    invoker.invoke(context);
    invoker.invoke(context);
    verify(target,times(3)).invoke(context);
  }
  @Test public void targetInvokedWhenCacheExpires() throws InterruptedException {
    OperationInvoker target=mock(OperationInvoker.class);
    Map<String,Object> parameters=new HashMap<>();
    InvocationContext context=new InvocationContext(mock(SecurityContext.class),parameters);
    given(target.invoke(context)).willReturn(new Object());
    CachingOperationInvoker invoker=new CachingOperationInvoker(target,50L);
    invoker.invoke(context);
    Thread.sleep(55);
    invoker.invoke(context);
    verify(target,times(2)).invoke(context);
  }
}
