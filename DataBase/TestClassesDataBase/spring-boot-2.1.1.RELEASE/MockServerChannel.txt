/** 
 * Mock  {@link ByteChannel} used to simulate the server connection.
 */
private static class MockServerChannel implements ByteChannel {
  private static final ByteBuffer DISCONNECT=ByteBuffer.wrap(NO_DATA);
  private int timeout;
  private BlockingDeque<ByteBuffer> outgoing=new LinkedBlockingDeque<>();
  private ByteArrayOutputStream written=new ByteArrayOutputStream();
  private AtomicBoolean open=new AtomicBoolean(true);
  public void setTimeout(  int timeout){
    this.timeout=timeout;
  }
  public void send(  String content){
    send(content.getBytes());
  }
  public void send(  byte[] bytes){
    this.outgoing.addLast(ByteBuffer.wrap(bytes));
  }
  public void disconnect(){
    this.outgoing.addLast(DISCONNECT);
  }
  public void verifyReceived(  String expected){
    verifyReceived(expected.getBytes());
  }
  public void verifyReceived(  byte[] expected){
synchronized (this.written) {
      assertThat(this.written.toByteArray()).isEqualTo(expected);
      this.written.reset();
    }
  }
  @Override public int read(  ByteBuffer dst) throws IOException {
    try {
      ByteBuffer bytes=this.outgoing.pollFirst(this.timeout,TimeUnit.MILLISECONDS);
      if (bytes == null) {
        throw new SocketTimeoutException();
      }
      if (bytes == DISCONNECT) {
        this.open.set(false);
        return -1;
      }
      int initialRemaining=dst.remaining();
      bytes.limit(Math.min(bytes.limit(),initialRemaining));
      dst.put(bytes);
      bytes.limit(bytes.capacity());
      return initialRemaining - dst.remaining();
    }
 catch (    InterruptedException ex) {
      throw new IllegalStateException(ex);
    }
  }
  @Override public int write(  ByteBuffer src) throws IOException {
    int remaining=src.remaining();
synchronized (this.written) {
      Channels.newChannel(this.written).write(src);
    }
    return remaining;
  }
  @Override public boolean isOpen(){
    return this.open.get();
  }
  @Override public void close(){
    this.open.set(false);
  }
}
