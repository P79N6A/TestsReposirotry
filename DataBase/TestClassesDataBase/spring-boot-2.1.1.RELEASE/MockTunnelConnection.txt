private static class MockTunnelConnection implements TunnelConnection {
  private final ByteArrayOutputStream written=new ByteArrayOutputStream();
  private boolean open;
  private int openedTimes;
  @Override public WritableByteChannel open(  WritableByteChannel incomingChannel,  Closeable closeable){
    this.openedTimes++;
    this.open=true;
    return new TunnelChannel(incomingChannel,closeable);
  }
  public void verifyWritten(  String expected){
    verifyWritten(expected.getBytes());
  }
  public void verifyWritten(  byte[] expected){
synchronized (this.written) {
      assertThat(this.written.toByteArray()).isEqualTo(expected);
      this.written.reset();
    }
  }
  public boolean isOpen(){
    return this.open;
  }
  public int getOpenedTimes(){
    return this.openedTimes;
  }
private class TunnelChannel implements WritableByteChannel {
    private final WritableByteChannel incomingChannel;
    private final Closeable closeable;
    TunnelChannel(    WritableByteChannel incomingChannel,    Closeable closeable){
      this.incomingChannel=incomingChannel;
      this.closeable=closeable;
    }
    @Override public boolean isOpen(){
      return MockTunnelConnection.this.open;
    }
    @Override public void close() throws IOException {
      MockTunnelConnection.this.open=false;
      this.closeable.close();
    }
    @Override public int write(    ByteBuffer src) throws IOException {
      int remaining=src.remaining();
      ByteArrayOutputStream stream=new ByteArrayOutputStream();
      Channels.newChannel(stream).write(src);
      byte[] bytes=stream.toByteArray();
synchronized (MockTunnelConnection.this.written) {
        MockTunnelConnection.this.written.write(bytes);
      }
      byte[] reversed=new byte[bytes.length];
      for (int i=0; i < reversed.length; i++) {
        reversed[i]=bytes[bytes.length - 1 - i];
      }
      this.incomingChannel.write(ByteBuffer.wrap(reversed));
      return remaining;
    }
  }
}
