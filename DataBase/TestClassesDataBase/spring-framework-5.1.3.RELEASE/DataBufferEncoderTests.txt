/** 
 * @author Sebastien Deleuze
 */
public class DataBufferEncoderTests extends AbstractEncoderTestCase<DataBufferEncoder> {
  private final byte[] fooBytes="foo".getBytes(StandardCharsets.UTF_8);
  private final byte[] barBytes="bar".getBytes(StandardCharsets.UTF_8);
  public DataBufferEncoderTests(){
    super(new DataBufferEncoder());
  }
  @Override @Test public void canEncode(){
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(DataBuffer.class),MimeTypeUtils.TEXT_PLAIN));
    assertFalse(this.encoder.canEncode(ResolvableType.forClass(Integer.class),MimeTypeUtils.TEXT_PLAIN));
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(DataBuffer.class),MimeTypeUtils.APPLICATION_JSON));
    assertFalse(this.encoder.canEncode(ResolvableType.NONE,null));
  }
  @Override public void encode() throws Exception {
    Flux<DataBuffer> input=Flux.just(this.fooBytes,this.barBytes).flatMap(bytes -> Mono.defer(() -> {
      DataBuffer dataBuffer=this.bufferFactory.allocateBuffer(bytes.length);
      dataBuffer.write(bytes);
      return Mono.just(dataBuffer);
    }
));
    testEncodeAll(input,DataBuffer.class,step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());
  }
}
