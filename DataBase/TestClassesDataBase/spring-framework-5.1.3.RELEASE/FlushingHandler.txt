private static class FlushingHandler implements HttpHandler {
  @Override public Mono<Void> handle(  ServerHttpRequest request,  ServerHttpResponse response){
    String path=request.getURI().getPath();
switch (path) {
case "/write-and-flush":
      return response.writeAndFlushWith(testInterval(Duration.ofMillis(50),2).map(longValue -> wrap("data" + longValue + "\n",response)).map(Flux::just).mergeWith(Flux.never()));
case "/write-and-complete":
    return response.writeWith(chunks1K().take(64).map(s -> wrap(s,response)));
case "/write-and-never-complete":
  return response.writeWith(chunks1K().take(64).map(s -> wrap(s,response)).mergeWith(Flux.never()));
default :
return response.writeWith(Flux.empty());
}
}
private Flux<String> chunks1K(){
return Flux.generate(sink -> {
StringBuilder sb=new StringBuilder();
do {
for (char c : "0123456789".toCharArray()) {
  sb.append(c);
  if (sb.length() + 1 == 1024) {
    sink.next(sb.append("\n").toString());
    return;
  }
}
}
 while (true);
}
);
}
private DataBuffer wrap(String value,ServerHttpResponse response){
byte[] bytes=value.getBytes(StandardCharsets.UTF_8);
return response.bufferFactory().wrap(bytes);
}
}
