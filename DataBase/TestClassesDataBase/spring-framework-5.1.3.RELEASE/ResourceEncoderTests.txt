/** 
 * @author Arjen Poutsma
 */
public class ResourceEncoderTests extends AbstractEncoderTestCase<ResourceEncoder> {
  private final byte[] bytes="foo".getBytes(UTF_8);
  public ResourceEncoderTests(){
    super(new ResourceEncoder());
  }
  @Override @Test public void canEncode(){
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(InputStreamResource.class),MimeTypeUtils.TEXT_PLAIN));
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(ByteArrayResource.class),MimeTypeUtils.TEXT_PLAIN));
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(Resource.class),MimeTypeUtils.TEXT_PLAIN));
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(InputStreamResource.class),MimeTypeUtils.APPLICATION_JSON));
    assertFalse(this.encoder.canEncode(ResolvableType.NONE,null));
  }
  @Override public void encode(){
    Flux<Resource> input=Flux.just(new ByteArrayResource(this.bytes));
    testEncodeAll(input,Resource.class,step -> step.consumeNextWith(expectBytes(this.bytes)).verifyComplete());
  }
  @Override protected void testEncodeError(  Publisher<?> input,  ResolvableType outputType,  @Nullable MimeType mimeType,  @Nullable Map<String,Object> hints){
    Flux<Resource> i=Flux.error(new InputException());
    Flux<DataBuffer> result=((Encoder<Resource>)this.encoder).encode(i,this.bufferFactory,outputType,mimeType,hints);
    StepVerifier.create(result).expectError(InputException.class).verify();
  }
}
