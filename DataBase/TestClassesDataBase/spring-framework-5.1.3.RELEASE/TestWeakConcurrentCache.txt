private static class TestWeakConcurrentCache<K,V> extends ConcurrentReferenceHashMap<K,V> {
  private int supplementalHash;
  private final LinkedList<MockReference<K,V>> queue=new LinkedList<>();
  private boolean disableTestHooks;
  public TestWeakConcurrentCache(){
    super();
  }
  public void setDisableTestHooks(  boolean disableTestHooks){
    this.disableTestHooks=disableTestHooks;
  }
  public TestWeakConcurrentCache(  int initialCapacity,  float loadFactor,  int concurrencyLevel){
    super(initialCapacity,loadFactor,concurrencyLevel);
  }
  public TestWeakConcurrentCache(  int initialCapacity,  int concurrencyLevel){
    super(initialCapacity,concurrencyLevel);
  }
  @Override protected int getHash(  @Nullable Object o){
    if (this.disableTestHooks) {
      return super.getHash(o);
    }
    this.supplementalHash=super.getHash(o);
    return o == null ? 0 : o.hashCode();
  }
  public int getSupplementalHash(){
    return this.supplementalHash;
  }
  @Override protected ReferenceManager createReferenceManager(){
    return new ReferenceManager(){
      @Override public Reference<K,V> createReference(      Entry<K,V> entry,      int hash,      @Nullable Reference<K,V> next){
        if (TestWeakConcurrentCache.this.disableTestHooks) {
          return super.createReference(entry,hash,next);
        }
        return new MockReference<>(entry,hash,next,TestWeakConcurrentCache.this.queue);
      }
      @Override public Reference<K,V> pollForPurge(){
        if (TestWeakConcurrentCache.this.disableTestHooks) {
          return super.pollForPurge();
        }
        return TestWeakConcurrentCache.this.queue.isEmpty() ? null : TestWeakConcurrentCache.this.queue.removeFirst();
      }
    }
;
  }
  public MockReference<K,V> getMockReference(  K key,  Restructure restructure){
    return (MockReference<K,V>)super.getReference(key,restructure);
  }
}
