/** 
 * @author Sebastien Deleuze
 */
public class CharSequenceEncoderTests extends AbstractEncoderTestCase<CharSequenceEncoder> {
  private final String foo="foo";
  private final String bar="bar";
  public CharSequenceEncoderTests(){
    super(CharSequenceEncoder.textPlainOnly());
  }
  @Override public void canEncode() throws Exception {
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(String.class),MimeTypeUtils.TEXT_PLAIN));
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(StringBuilder.class),MimeTypeUtils.TEXT_PLAIN));
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(StringBuffer.class),MimeTypeUtils.TEXT_PLAIN));
    assertFalse(this.encoder.canEncode(ResolvableType.forClass(Integer.class),MimeTypeUtils.TEXT_PLAIN));
    assertFalse(this.encoder.canEncode(ResolvableType.forClass(String.class),MimeTypeUtils.APPLICATION_JSON));
    assertFalse(this.encoder.canEncode(ResolvableType.NONE,null));
  }
  @Override public void encode(){
    Flux<CharSequence> input=Flux.just(this.foo,this.bar);
    testEncodeAll(input,CharSequence.class,step -> step.consumeNextWith(expectString(this.foo)).consumeNextWith(expectString(this.bar)).verifyComplete());
  }
}
