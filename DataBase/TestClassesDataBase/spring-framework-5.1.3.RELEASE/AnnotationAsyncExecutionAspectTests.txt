/** 
 * Unit tests for  {@link AnnotationAsyncExecutionAspect}.
 * @author Ramnivas Laddad
 * @author Stephane Nicoll
 */
public class AnnotationAsyncExecutionAspectTests {
  private static final long WAIT_TIME=1000;
  private final AsyncUncaughtExceptionHandler defaultExceptionHandler=new SimpleAsyncUncaughtExceptionHandler();
  private CountingExecutor executor;
  @Before public void setUp(){
    Assume.group(TestGroup.PERFORMANCE);
    executor=new CountingExecutor();
    AnnotationAsyncExecutionAspect.aspectOf().setExecutor(executor);
  }
  @Test public void asyncMethodGetsRoutedAsynchronously(){
    ClassWithoutAsyncAnnotation obj=new ClassWithoutAsyncAnnotation();
    obj.incrementAsync();
    executor.waitForCompletion();
    assertEquals(1,obj.counter);
    assertEquals(1,executor.submitStartCounter);
    assertEquals(1,executor.submitCompleteCounter);
  }
  @Test public void asyncMethodReturningFutureGetsRoutedAsynchronouslyAndReturnsAFuture() throws InterruptedException, ExecutionException {
    ClassWithoutAsyncAnnotation obj=new ClassWithoutAsyncAnnotation();
    Future<Integer> future=obj.incrementReturningAFuture();
    assertEquals(5,future.get().intValue());
    assertEquals(1,obj.counter);
    assertEquals(1,executor.submitStartCounter);
    assertEquals(1,executor.submitCompleteCounter);
  }
  @Test public void syncMethodGetsRoutedSynchronously(){
    ClassWithoutAsyncAnnotation obj=new ClassWithoutAsyncAnnotation();
    obj.increment();
    assertEquals(1,obj.counter);
    assertEquals(0,executor.submitStartCounter);
    assertEquals(0,executor.submitCompleteCounter);
  }
  @Test public void voidMethodInAsyncClassGetsRoutedAsynchronously(){
    Assume.group(TestGroup.PERFORMANCE);
    ClassWithAsyncAnnotation obj=new ClassWithAsyncAnnotation();
    obj.increment();
    executor.waitForCompletion();
    assertEquals(1,obj.counter);
    assertEquals(1,executor.submitStartCounter);
    assertEquals(1,executor.submitCompleteCounter);
  }
  @Test public void methodReturningFutureInAsyncClassGetsRoutedAsynchronouslyAndReturnsAFuture() throws InterruptedException, ExecutionException {
    ClassWithAsyncAnnotation obj=new ClassWithAsyncAnnotation();
    Future<Integer> future=obj.incrementReturningAFuture();
    assertEquals(5,future.get().intValue());
    assertEquals(1,obj.counter);
    assertEquals(1,executor.submitStartCounter);
    assertEquals(1,executor.submitCompleteCounter);
  }
  @Test public void qualifiedAsyncMethodsAreRoutedToCorrectExecutor() throws InterruptedException, ExecutionException {
    DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();
    beanFactory.registerBeanDefinition("e1",new RootBeanDefinition(ThreadPoolTaskExecutor.class));
    AnnotationAsyncExecutionAspect.aspectOf().setBeanFactory(beanFactory);
    ClassWithQualifiedAsyncMethods obj=new ClassWithQualifiedAsyncMethods();
    Future<Thread> defaultThread=obj.defaultWork();
    assertThat(defaultThread.get(),not(Thread.currentThread()));
    assertThat(defaultThread.get().getName(),not(startsWith("e1-")));
    ListenableFuture<Thread> e1Thread=obj.e1Work();
    assertThat(e1Thread.get().getName(),startsWith("e1-"));
    CompletableFuture<Thread> e1OtherThread=obj.e1OtherWork();
    assertThat(e1OtherThread.get().getName(),startsWith("e1-"));
  }
  @Test public void exceptionHandlerCalled(){
    Method m=ReflectionUtils.findMethod(ClassWithException.class,"failWithVoid");
    TestableAsyncUncaughtExceptionHandler exceptionHandler=new TestableAsyncUncaughtExceptionHandler();
    AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(exceptionHandler);
    try {
      assertFalse("Handler should not have been called",exceptionHandler.isCalled());
      ClassWithException obj=new ClassWithException();
      obj.failWithVoid();
      exceptionHandler.await(3000);
      exceptionHandler.assertCalledWith(m,UnsupportedOperationException.class);
    }
  finally {
      AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(defaultExceptionHandler);
    }
  }
  @Test public void exceptionHandlerNeverThrowsUnexpectedException(){
    Method m=ReflectionUtils.findMethod(ClassWithException.class,"failWithVoid");
    TestableAsyncUncaughtExceptionHandler exceptionHandler=new TestableAsyncUncaughtExceptionHandler(true);
    AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(exceptionHandler);
    try {
      assertFalse("Handler should not have been called",exceptionHandler.isCalled());
      ClassWithException obj=new ClassWithException();
      try {
        obj.failWithVoid();
        exceptionHandler.await(3000);
        exceptionHandler.assertCalledWith(m,UnsupportedOperationException.class);
      }
 catch (      Exception ex) {
        fail("No unexpected exception should have been received but got " + ex.getMessage());
      }
    }
  finally {
      AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(defaultExceptionHandler);
    }
  }
@SuppressWarnings("serial") private static class CountingExecutor extends SimpleAsyncTaskExecutor {
    int submitStartCounter;
    int submitCompleteCounter;
    @Override public <T>Future<T> submit(    Callable<T> task){
      submitStartCounter++;
      Future<T> future=super.submit(task);
      submitCompleteCounter++;
synchronized (this) {
        notifyAll();
      }
      return future;
    }
    public synchronized void waitForCompletion(){
      try {
        wait(WAIT_TIME);
      }
 catch (      InterruptedException ex) {
        fail("Didn't finish the async job in " + WAIT_TIME + " milliseconds");
      }
    }
  }
static class ClassWithoutAsyncAnnotation {
    int counter;
    @Async public void incrementAsync(){
      counter++;
    }
    public void increment(){
      counter++;
    }
    @Async public Future<Integer> incrementReturningAFuture(){
      counter++;
      return new AsyncResult<Integer>(5);
    }
  }
@Async static class ClassWithAsyncAnnotation {
    int counter;
    public void increment(){
      counter++;
    }
    public Future<Integer> incrementReturningAFuture(){
      counter++;
      return new AsyncResult<Integer>(5);
    }
  }
static class ClassWithQualifiedAsyncMethods {
    @Async public Future<Thread> defaultWork(){
      return new AsyncResult<Thread>(Thread.currentThread());
    }
    @Async("e1") public ListenableFuture<Thread> e1Work(){
      return new AsyncResult<Thread>(Thread.currentThread());
    }
    @Async("e1") public CompletableFuture<Thread> e1OtherWork(){
      return CompletableFuture.completedFuture(Thread.currentThread());
    }
  }
static class ClassWithException {
    @Async public void failWithVoid(){
      throw new UnsupportedOperationException("failWithVoid");
    }
  }
}
