/** 
 * Integration tests using in-memory database for container-managed JPA
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @since 2.0
 */
public class ContainerManagedEntityManagerIntegrationTests extends AbstractEntityManagerFactoryIntegrationTests {
  @Autowired private AbstractEntityManagerFactoryBean entityManagerFactoryBean;
  @Test public void testExceptionTranslationWithDialectFoundOnIntroducedEntityManagerInfo() throws Exception {
    doTestExceptionTranslationWithDialectFound(((EntityManagerFactoryInfo)entityManagerFactory).getJpaDialect());
  }
  @Test public void testExceptionTranslationWithDialectFoundOnEntityManagerFactoryBean() throws Exception {
    assertNotNull("Dialect must have been set",entityManagerFactoryBean.getJpaDialect());
    doTestExceptionTranslationWithDialectFound(entityManagerFactoryBean);
  }
  protected void doTestExceptionTranslationWithDialectFound(  PersistenceExceptionTranslator pet) throws Exception {
    RuntimeException in1=new RuntimeException("in1");
    PersistenceException in2=new PersistenceException();
    assertNull("No translation here",pet.translateExceptionIfPossible(in1));
    DataAccessException dex=pet.translateExceptionIfPossible(in2);
    assertNotNull(dex);
    assertSame(in2,dex.getCause());
  }
  @Test @SuppressWarnings("unchecked") public void testEntityManagerProxyIsProxy(){
    EntityManager em=createContainerManagedEntityManager();
    assertTrue(Proxy.isProxyClass(em.getClass()));
    Query q=em.createQuery("select p from Person as p");
    List<Person> people=q.getResultList();
    assertTrue(people.isEmpty());
    assertTrue("Should be open to start with",em.isOpen());
    try {
      em.close();
      fail("Close should not work on container managed EM");
    }
 catch (    IllegalStateException ex) {
    }
    assertTrue(em.isOpen());
  }
  @Test public void testEntityManagerProxyRejectsProgrammaticTxManagement(){
    try {
      createContainerManagedEntityManager().getTransaction();
      fail("Should have thrown an IllegalStateException");
    }
 catch (    IllegalStateException ex) {
    }
  }
  @Test public void testContainerEntityManagerProxyAllowsJoinTransactionInTransaction(){
    createContainerManagedEntityManager().joinTransaction();
  }
  @Test public void testContainerEntityManagerProxyRejectsJoinTransactionWithoutTransaction(){
    endTransaction();
    try {
      createContainerManagedEntityManager().joinTransaction();
      fail("Should have thrown a TransactionRequiredException");
    }
 catch (    TransactionRequiredException ex) {
    }
  }
  @Test public void testInstantiateAndSave(){
    EntityManager em=createContainerManagedEntityManager();
    doInstantiateAndSave(em);
  }
  protected void doInstantiateAndSave(  EntityManager em){
    assertEquals("Should be no people from previous transactions",0,countRowsInTable(em,"person"));
    Person p=new Person();
    p.setFirstName("Tony");
    p.setLastName("Blair");
    em.persist(p);
    em.flush();
    assertEquals("1 row must have been inserted",1,countRowsInTable(em,"person"));
  }
  @Test public void testReuseInNewTransaction(){
    EntityManager em=createContainerManagedEntityManager();
    doInstantiateAndSave(em);
    endTransaction();
    startNewTransaction();
    assertFalse(em.contains(new Person()));
    doInstantiateAndSave(em);
    setComplete();
    endTransaction();
    assertEquals("Tx must have committed back",1,countRowsInTable(em,"person"));
    deleteFromTables("person");
  }
  @Test public void testRollbackOccurs(){
    EntityManager em=createContainerManagedEntityManager();
    doInstantiateAndSave(em);
    endTransaction();
    assertEquals("Tx must have been rolled back",0,countRowsInTable(em,"person"));
  }
  @Test public void testCommitOccurs(){
    EntityManager em=createContainerManagedEntityManager();
    doInstantiateAndSave(em);
    setComplete();
    endTransaction();
    assertEquals("Tx must have committed back",1,countRowsInTable(em,"person"));
    deleteFromTables("person");
  }
}
