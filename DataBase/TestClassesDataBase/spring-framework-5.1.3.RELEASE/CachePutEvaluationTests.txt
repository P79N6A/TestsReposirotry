/** 
 * Tests corner case of using  {@link Cacheable} and  {@link CachePut} on thesame operation.
 * @author Stephane Nicoll
 */
public class CachePutEvaluationTests {
  private ConfigurableApplicationContext context;
  private Cache cache;
  private SimpleService service;
  @Before public void setup(){
    this.context=new AnnotationConfigApplicationContext(Config.class);
    this.cache=this.context.getBean(CacheManager.class).getCache("test");
    this.service=this.context.getBean(SimpleService.class);
  }
  @After public void close(){
    if (this.context != null) {
      this.context.close();
    }
  }
  @Test public void mutualGetPutExclusion(){
    String key="1";
    Long first=this.service.getOrPut(key,true);
    Long second=this.service.getOrPut(key,true);
    assertSame(first,second);
    Long expected=first + 1;
    Long third=this.service.getOrPut(key,false);
    assertEquals(expected,third);
    Long fourth=this.service.getOrPut(key,true);
    assertSame(third,fourth);
  }
  @Test public void getAndPut(){
    this.cache.clear();
    long key=1;
    Long value=this.service.getAndPut(key);
    assertEquals("Wrong value for @Cacheable key",value,this.cache.get(key).get());
    assertEquals("Wrong value for @CachePut key",value,this.cache.get(value + 100).get());
    Long anotherValue=this.service.getAndPut(key);
    assertNotSame(value,anotherValue);
    assertEquals("Wrong value for @CachePut key",anotherValue,this.cache.get(anotherValue + 100).get());
  }
@Configuration @EnableCaching static class Config extends CachingConfigurerSupport {
    @Bean @Override public CacheManager cacheManager(){
      return new ConcurrentMapCacheManager();
    }
    @Bean public SimpleService simpleService(){
      return new SimpleService();
    }
  }
@CacheConfig(cacheNames="test") public static class SimpleService {
    private AtomicLong counter=new AtomicLong();
    /** 
 * Represent a mutual exclusion use case. The boolean flag exclude one of the two operation.
 */
    @Cacheable(condition="#p1",key="#p0") @CachePut(condition="!#p1",key="#p0") public Long getOrPut(    Object id,    boolean flag){
      return this.counter.getAndIncrement();
    }
    /** 
 * Represent an invalid use case. If the result of the operation is non null, then we put the value with a different key. This forces the method to be executed every time.
 */
    @Cacheable @CachePut(key="#result + 100",condition="#result != null") public Long getAndPut(    long id){
      return this.counter.getAndIncrement();
    }
  }
}
