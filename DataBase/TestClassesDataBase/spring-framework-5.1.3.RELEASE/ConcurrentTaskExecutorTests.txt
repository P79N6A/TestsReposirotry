/** 
 * @author Rick Evans
 * @author Juergen Hoeller
 */
public class ConcurrentTaskExecutorTests extends AbstractSchedulingTaskExecutorTests {
  private final ThreadPoolExecutor concurrentExecutor=new ThreadPoolExecutor(1,1,60,TimeUnit.SECONDS,new LinkedBlockingQueue<>());
  @Override protected AsyncListenableTaskExecutor buildExecutor(){
    concurrentExecutor.setThreadFactory(new CustomizableThreadFactory(THREAD_NAME_PREFIX));
    return new ConcurrentTaskExecutor(concurrentExecutor);
  }
  @Override public void shutdownExecutor(){
    List<Runnable> remainingTasks=concurrentExecutor.shutdownNow();
    for (    Runnable task : remainingTasks) {
      if (task instanceof RunnableFuture) {
        ((RunnableFuture<?>)task).cancel(true);
      }
    }
  }
  @Test public void zeroArgCtorResultsInDefaultTaskExecutorBeingUsed(){
    ConcurrentTaskExecutor executor=new ConcurrentTaskExecutor();
    executor.execute(new NoOpRunnable());
  }
  @Test public void passingNullExecutorToCtorResultsInDefaultTaskExecutorBeingUsed(){
    ConcurrentTaskExecutor executor=new ConcurrentTaskExecutor(null);
    executor.execute(new NoOpRunnable());
  }
  @Test public void passingNullExecutorToSetterResultsInDefaultTaskExecutorBeingUsed(){
    ConcurrentTaskExecutor executor=new ConcurrentTaskExecutor();
    executor.setConcurrentExecutor(null);
    executor.execute(new NoOpRunnable());
  }
}
