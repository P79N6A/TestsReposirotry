private static class ConsumingHandler extends LoggingSessionHandler {
  private final List<String> topics;
  private final CountDownLatch subscriptionLatch;
  private final List<String> received=new ArrayList<>();
  public ConsumingHandler(  String... topics){
    Assert.notEmpty(topics,"Topics must not be empty");
    this.topics=Arrays.asList(topics);
    this.subscriptionLatch=new CountDownLatch(this.topics.size());
  }
  public List<String> getReceived(){
    return this.received;
  }
  @Override public void afterConnected(  StompSession session,  StompHeaders connectedHeaders){
    for (    String topic : this.topics) {
      session.setAutoReceipt(true);
      Subscription subscription=session.subscribe(topic,new StompFrameHandler(){
        @Override public Type getPayloadType(        StompHeaders headers){
          return String.class;
        }
        @Override public void handleFrame(        StompHeaders headers,        @Nullable Object payload){
          received.add((String)payload);
        }
      }
);
      subscription.addReceiptTask(subscriptionLatch::countDown);
    }
  }
  public boolean awaitForSubscriptions(  long millisToWait) throws InterruptedException {
    if (logger.isDebugEnabled()) {
      logger.debug("Awaiting for subscription receipts");
    }
    return this.subscriptionLatch.await(millisToWait,TimeUnit.MILLISECONDS);
  }
  public boolean awaitForMessageCount(  int expected,  long millisToWait) throws InterruptedException {
    if (logger.isDebugEnabled()) {
      logger.debug("Awaiting for message count: " + expected);
    }
    long startTime=System.currentTimeMillis();
    while (this.received.size() < expected) {
      Thread.sleep(500);
      if ((System.currentTimeMillis() - startTime) > millisToWait) {
        return false;
      }
    }
    return true;
  }
}
