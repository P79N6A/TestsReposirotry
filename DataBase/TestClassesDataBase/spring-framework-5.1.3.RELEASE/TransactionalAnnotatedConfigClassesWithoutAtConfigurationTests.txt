/** 
 * Concrete implementation of  {@link AbstractTransactionalAnnotatedConfigClassTests}that does <b>not</b> use a true  {@link Configuration @Configuration class} butrather a <em>lite mode</em> configuration class (see the Javadoc for  {@link Bean @Bean}for details).
 * @author Sam Brannen
 * @since 3.2
 * @see Bean
 * @see TransactionalAnnotatedConfigClassWithAtConfigurationTests
 */
@ContextConfiguration(classes=TransactionalAnnotatedConfigClassesWithoutAtConfigurationTests.AnnotatedFactoryBeans.class) public class TransactionalAnnotatedConfigClassesWithoutAtConfigurationTests extends AbstractTransactionalAnnotatedConfigClassTests {
  /** 
 * This is intentionally <b>not</b> annotated with  {@code @Configuration}. <p>Consequently, this class contains <i>annotated factory bean methods</i> instead of standard singleton bean methods.
 */
static class AnnotatedFactoryBeans {
    @Bean public Employee employee(){
      Employee employee=new Employee();
      employee.setName("John Smith");
      employee.setAge(42);
      employee.setCompany("Acme Widgets, Inc.");
      return employee;
    }
    @Bean public PlatformTransactionManager transactionManager(){
      return new DataSourceTransactionManager(dataSource());
    }
    /** 
 * Since this method does not reside in a true  {@code @Configuration class}, it acts as a factory method when invoked directly (e.g., from {@link #transactionManager()}) and as a singleton bean when retrieved through the application context (e.g., when injected into the test instance). The result is that this method will be called twice: <ol> <li>once <em>indirectly</em> by the  {@link TransactionalTestExecutionListener}when it retrieves the  {@link PlatformTransactionManager} from theapplication context</li> <li>and again when the  {@link DataSource} is injected into the testinstance in  {@link AbstractTransactionalAnnotatedConfigClassTests#setDataSource(DataSource)}.</li> </ol> Consequently, the  {@link JdbcTemplate} used by this test instance andthe  {@link PlatformTransactionManager} used by the Spring TestContextFramework will operate on two different  {@code DataSource} instances,which is almost certainly not the desired or intended behavior.
 */
    @Bean public DataSource dataSource(){
      return new EmbeddedDatabaseBuilder().addScript("classpath:/org/springframework/test/jdbc/schema.sql").setName(getClass().getName()).build();
    }
  }
  @Before public void compareDataSources() throws Exception {
    assertNotSame(dataSourceFromTxManager,dataSourceViaInjection);
  }
  /** 
 * Overrides  {@code afterTransaction()} in order to assert a different result.<p>See in-line comments for details.
 * @see AbstractTransactionalAnnotatedConfigClassTests#afterTransaction()
 * @see AbstractTransactionalAnnotatedConfigClassTests#modifyTestDataWithinTransaction()
 */
  @AfterTransaction @Override public void afterTransaction(){
    assertEquals("Deleting yoda",1,deletePerson(YODA));
    assertNumRowsInPersonTable(2,"after a transactional test method");
  }
}
