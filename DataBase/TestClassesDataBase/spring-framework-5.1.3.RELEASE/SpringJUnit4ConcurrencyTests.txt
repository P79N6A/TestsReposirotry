/** 
 * Concurrency tests for the  {@link SpringRunner},  {@link SpringClassRule}, and {@link SpringMethodRule} that use JUnit 4's experimental {@link ParallelComputer}to execute tests in parallel. <p>The tests executed by this test class come from a hand-picked collection of test classes within the test suite that is intended to cover most categories of tests that are currently supported by the TestContext Framework on JUnit 4. <p>The chosen test classes intentionally do <em>not</em> include any classes that fall under the following categories. <ul> <li>tests that make use of Spring's  {@code @DirtiesContext} support<li>tests that make use of JUnit 4's  {@code @FixMethodOrder} support<li>tests that commit changes to the state of a shared in-memory database </ul> <p><strong>NOTE</strong>: these tests only run if the  {@link TestGroup#LONG_RUNNING LONG_RUNNING} test group is enabled.
 * @author Sam Brannen
 * @since 5.0
 * @see org.springframework.test.context.TestContextConcurrencyTests
 */
public class SpringJUnit4ConcurrencyTests {
  private final Class<?>[] testClasses=new Class<?>[]{SpringJUnit4ClassRunnerAppCtxTests.class,InheritedConfigSpringJUnit4ClassRunnerAppCtxTests.class,SpringJUnit47ClassRunnerRuleTests.class,BaseAppCtxRuleTests.class,MethodLevelTransactionalSpringRunnerTests.class,TimedTransactionalSpringRunnerTests.class,DispatcherWacRootWacEarTests.class,BasicAnnotationConfigWacSpringRuleTests.class,RequestAndSessionScopedBeansWacTests.class,WebSocketServletServerContainerFactoryBeanTests.class,JavaConfigTests.class,WebAppResourceTests.class,SampleTests.class};
  @BeforeClass public static void abortIfLongRunningTestGroupIsNotEnabled(){
    Assume.group(TestGroup.LONG_RUNNING);
  }
  @Test public void runAllTestsConcurrently() throws Exception {
    final int FAILED=0;
    final int ABORTED=0;
    final int IGNORED=countAnnotatedMethods(Ignore.class);
    final int TESTS=countAnnotatedMethods(Test.class) - IGNORED;
    runTestsAndAssertCounters(new ParallelComputer(true,true),TESTS,FAILED,TESTS,IGNORED,ABORTED,this.testClasses);
  }
  private int countAnnotatedMethods(  Class<? extends Annotation> annotationType){
    return (int)Arrays.stream(this.testClasses).map(ReflectionUtils::getUniqueDeclaredMethods).flatMap(Arrays::stream).filter(method -> hasAnnotation(method,annotationType)).count();
  }
}
