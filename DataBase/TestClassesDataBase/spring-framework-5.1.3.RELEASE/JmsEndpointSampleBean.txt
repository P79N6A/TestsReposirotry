@SendTo("defaultReply") @SuppressWarnings("unused") static class JmsEndpointSampleBean {
  private final Map<String,Boolean> invocations=new HashMap<>();
  public void resolveMessageAndSession(  javax.jms.Message message,  Session session){
    this.invocations.put("resolveMessageAndSession",true);
    assertNotNull("Message not injected",message);
    assertNotNull("Session not injected",session);
  }
  public void resolveGenericMessage(  Message<String> message){
    this.invocations.put("resolveGenericMessage",true);
    assertNotNull("Generic message not injected",message);
    assertEquals("Wrong message payload","test",message.getPayload());
  }
  public void resolveHeaderAndPayload(  @Payload String content,  @Header int myCounter){
    this.invocations.put("resolveHeaderAndPayload",true);
    assertEquals("Wrong @Payload resolution","my payload",content);
    assertEquals("Wrong @Header resolution",55,myCounter);
  }
  public void resolveCustomHeaderNameAndPayload(  @Payload String content,  @Header("myCounter") int counter){
    this.invocations.put("resolveCustomHeaderNameAndPayload",true);
    assertEquals("Wrong @Payload resolution","my payload",content);
    assertEquals("Wrong @Header resolution",24,counter);
  }
  public void resolveCustomHeaderNameAndPayloadWithHeaderNameSet(  @Payload String content,  @Header(name="myCounter") int counter){
    this.invocations.put("resolveCustomHeaderNameAndPayloadWithHeaderNameSet",true);
    assertEquals("Wrong @Payload resolution","my payload",content);
    assertEquals("Wrong @Header resolution",24,counter);
  }
  public void resolveHeaders(  String content,  @Headers Map<String,Object> headers){
    this.invocations.put("resolveHeaders",true);
    assertEquals("Wrong payload resolution","my payload",content);
    assertNotNull("headers not injected",headers);
    assertEquals("Missing JMS message id header","abcd-1234",headers.get(JmsHeaders.MESSAGE_ID));
    assertEquals("Missing custom header",1234,headers.get("customInt"));
  }
  public void resolveMessageHeaders(  MessageHeaders headers){
    this.invocations.put("resolveMessageHeaders",true);
    assertNotNull("MessageHeaders not injected",headers);
    assertEquals("Missing JMS message type header","myMessageType",headers.get(JmsHeaders.TYPE));
    assertEquals("Missing custom header",4567L,(long)headers.get("customLong"),0.0);
  }
  public void resolveJmsMessageHeaderAccessor(  JmsMessageHeaderAccessor headers){
    this.invocations.put("resolveJmsMessageHeaderAccessor",true);
    assertNotNull("MessageHeaders not injected",headers);
    assertEquals("Missing JMS message priority header",Integer.valueOf(9),headers.getPriority());
    assertEquals("Missing custom header",true,headers.getHeader("customBoolean"));
  }
  public void resolveObjectPayload(  MyBean bean){
    this.invocations.put("resolveObjectPayload",true);
    assertNotNull("Object payload not injected",bean);
    assertEquals("Wrong content for payload","myBean name",bean.name);
  }
  public void resolveConvertedPayload(  Integer counter){
    this.invocations.put("resolveConvertedPayload",true);
    assertNotNull("Payload not injected",counter);
    assertEquals("Wrong content for payload",Integer.valueOf(33),counter);
  }
  public String processAndReply(  @Payload String content){
    this.invocations.put("processAndReply",true);
    return content;
  }
  @SendTo("replyDestination") public String processAndReplyWithSendTo(  String content){
    this.invocations.put("processAndReplyWithSendTo",true);
    return content;
  }
  public String processAndReplyWithDefaultSendTo(  String content){
    this.invocations.put("processAndReplyWithDefaultSendTo",true);
    return content;
  }
  @SendTo("") public String emptySendTo(  String content){
    this.invocations.put("emptySendTo",true);
    return content;
  }
  @SendTo({"firstDestination","secondDestination"}) public String invalidSendTo(  String content){
    this.invocations.put("invalidSendTo",true);
    return content;
  }
  public void validatePayload(  @Validated String payload){
    this.invocations.put("validatePayload",true);
  }
  public void invalidPayloadType(  @Payload Integer payload){
    throw new IllegalStateException("Should never be called.");
  }
  public void invalidMessagePayloadType(  Message<Integer> message){
    throw new IllegalStateException("Should never be called.");
  }
}
