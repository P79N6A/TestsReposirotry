/** 
 * @author Sebastien Deleuze
 */
public class ByteBufferEncoderTests extends AbstractEncoderTestCase<ByteBufferEncoder> {
  private final byte[] fooBytes="foo".getBytes(StandardCharsets.UTF_8);
  private final byte[] barBytes="bar".getBytes(StandardCharsets.UTF_8);
  public ByteBufferEncoderTests(){
    super(new ByteBufferEncoder());
  }
  @Override @Test public void canEncode(){
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(ByteBuffer.class),MimeTypeUtils.TEXT_PLAIN));
    assertFalse(this.encoder.canEncode(ResolvableType.forClass(Integer.class),MimeTypeUtils.TEXT_PLAIN));
    assertTrue(this.encoder.canEncode(ResolvableType.forClass(ByteBuffer.class),MimeTypeUtils.APPLICATION_JSON));
    assertFalse(this.encoder.canEncode(ResolvableType.NONE,null));
  }
  @Override @Test public void encode(){
    Flux<ByteBuffer> input=Flux.just(this.fooBytes,this.barBytes).map(ByteBuffer::wrap);
    testEncodeAll(input,ByteBuffer.class,step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());
  }
}
