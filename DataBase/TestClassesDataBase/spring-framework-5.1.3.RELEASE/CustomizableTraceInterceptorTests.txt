/** 
 * @author Rob Harrop
 * @author Rick Evans
 * @author Juergen Hoeller
 * @author Chris Beams
 */
public class CustomizableTraceInterceptorTests {
  @Test(expected=IllegalArgumentException.class) public void testSetEmptyEnterMessage(){
    new CustomizableTraceInterceptor().setEnterMessage("");
  }
  @Test(expected=IllegalArgumentException.class) public void testSetEnterMessageWithReturnValuePlaceholder(){
    new CustomizableTraceInterceptor().setEnterMessage(CustomizableTraceInterceptor.PLACEHOLDER_RETURN_VALUE);
  }
  @Test(expected=IllegalArgumentException.class) public void testSetEnterMessageWithExceptionPlaceholder(){
    new CustomizableTraceInterceptor().setEnterMessage(CustomizableTraceInterceptor.PLACEHOLDER_EXCEPTION);
  }
  @Test(expected=IllegalArgumentException.class) public void testSetEnterMessageWithInvocationTimePlaceholder(){
    new CustomizableTraceInterceptor().setEnterMessage(CustomizableTraceInterceptor.PLACEHOLDER_INVOCATION_TIME);
  }
  @Test(expected=IllegalArgumentException.class) public void testSetEmptyExitMessage(){
    new CustomizableTraceInterceptor().setExitMessage("");
  }
  @Test(expected=IllegalArgumentException.class) public void testSetExitMessageWithExceptionPlaceholder(){
    new CustomizableTraceInterceptor().setExitMessage(CustomizableTraceInterceptor.PLACEHOLDER_EXCEPTION);
  }
  @Test(expected=IllegalArgumentException.class) public void testSetEmptyExceptionMessage(){
    new CustomizableTraceInterceptor().setExceptionMessage("");
  }
  @Test(expected=IllegalArgumentException.class) public void testSetExceptionMethodWithReturnValuePlaceholder(){
    new CustomizableTraceInterceptor().setExceptionMessage(CustomizableTraceInterceptor.PLACEHOLDER_RETURN_VALUE);
  }
  @Test public void testSunnyDayPathLogsCorrectly() throws Throwable {
    MethodInvocation methodInvocation=mock(MethodInvocation.class);
    given(methodInvocation.getMethod()).willReturn(String.class.getMethod("toString"));
    given(methodInvocation.getThis()).willReturn(this);
    Log log=mock(Log.class);
    given(log.isTraceEnabled()).willReturn(true);
    CustomizableTraceInterceptor interceptor=new StubCustomizableTraceInterceptor(log);
    interceptor.invoke(methodInvocation);
    verify(log,times(2)).trace(anyString());
  }
  @Test public void testExceptionPathLogsCorrectly() throws Throwable {
    MethodInvocation methodInvocation=mock(MethodInvocation.class);
    IllegalArgumentException exception=new IllegalArgumentException();
    given(methodInvocation.getMethod()).willReturn(String.class.getMethod("toString"));
    given(methodInvocation.getThis()).willReturn(this);
    given(methodInvocation.proceed()).willThrow(exception);
    Log log=mock(Log.class);
    given(log.isTraceEnabled()).willReturn(true);
    CustomizableTraceInterceptor interceptor=new StubCustomizableTraceInterceptor(log);
    try {
      interceptor.invoke(methodInvocation);
      fail("Must have propagated the IllegalArgumentException.");
    }
 catch (    IllegalArgumentException expected) {
    }
    verify(log).trace(anyString());
    verify(log).trace(anyString(),eq(exception));
  }
  @Test public void testSunnyDayPathLogsCorrectlyWithPrettyMuchAllPlaceholdersMatching() throws Throwable {
    MethodInvocation methodInvocation=mock(MethodInvocation.class);
    given(methodInvocation.getMethod()).willReturn(String.class.getMethod("toString",new Class[0]));
    given(methodInvocation.getThis()).willReturn(this);
    given(methodInvocation.getArguments()).willReturn(new Object[]{"$ One \\$",new Long(2)});
    given(methodInvocation.proceed()).willReturn("Hello!");
    Log log=mock(Log.class);
    given(log.isTraceEnabled()).willReturn(true);
    CustomizableTraceInterceptor interceptor=new StubCustomizableTraceInterceptor(log);
    interceptor.setEnterMessage(new StringBuffer().append("Entering the '").append(CustomizableTraceInterceptor.PLACEHOLDER_METHOD_NAME).append("' method of the [").append(CustomizableTraceInterceptor.PLACEHOLDER_TARGET_CLASS_NAME).append("] class with the following args (").append(CustomizableTraceInterceptor.PLACEHOLDER_ARGUMENTS).append(") and arg types (").append(CustomizableTraceInterceptor.PLACEHOLDER_ARGUMENT_TYPES).append(").").toString());
    interceptor.setExitMessage(new StringBuffer().append("Exiting the '").append(CustomizableTraceInterceptor.PLACEHOLDER_METHOD_NAME).append("' method of the [").append(CustomizableTraceInterceptor.PLACEHOLDER_TARGET_CLASS_SHORT_NAME).append("] class with the following args (").append(CustomizableTraceInterceptor.PLACEHOLDER_ARGUMENTS).append(") and arg types (").append(CustomizableTraceInterceptor.PLACEHOLDER_ARGUMENT_TYPES).append("), returning '").append(CustomizableTraceInterceptor.PLACEHOLDER_RETURN_VALUE).append("' and taking '").append(CustomizableTraceInterceptor.PLACEHOLDER_INVOCATION_TIME).append("' this long.").toString());
    interceptor.invoke(methodInvocation);
    verify(log,times(2)).trace(anyString());
  }
@SuppressWarnings("serial") private static class StubCustomizableTraceInterceptor extends CustomizableTraceInterceptor {
    private final Log log;
    public StubCustomizableTraceInterceptor(    Log log){
      super.setUseDynamicLogger(false);
      this.log=log;
    }
    @Override protected Log getLoggerForInvocation(    MethodInvocation invocation){
      return this.log;
    }
  }
}
