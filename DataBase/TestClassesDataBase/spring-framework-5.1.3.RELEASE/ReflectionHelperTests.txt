/** 
 * Tests for reflection helper code.
 * @author Andy Clement
 */
public class ReflectionHelperTests extends AbstractExpressionTests {
  @Test public void testUtilities() throws ParseException {
    SpelExpression expr=(SpelExpression)parser.parseExpression("3+4+5+6+7-2");
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    PrintStream ps=new PrintStream(baos);
    SpelUtilities.printAbstractSyntaxTree(ps,expr);
    ps.flush();
    String s=baos.toString();
    assertTrue(s.contains("===> Expression '3+4+5+6+7-2' - AST start"));
    assertTrue(s.contains(" OpPlus  value:((((3 + 4) + 5) + 6) + 7)  #children:2"));
  }
  @Test public void testTypedValue(){
    TypedValue tv1=new TypedValue("hello");
    TypedValue tv2=new TypedValue("hello");
    TypedValue tv3=new TypedValue("bye");
    assertEquals(String.class,tv1.getTypeDescriptor().getType());
    assertEquals("TypedValue: 'hello' of [java.lang.String]",tv1.toString());
    assertEquals(tv1,tv2);
    assertEquals(tv2,tv1);
    assertNotEquals(tv1,tv3);
    assertNotEquals(tv2,tv3);
    assertNotEquals(tv3,tv1);
    assertNotEquals(tv3,tv2);
    assertEquals(tv1.hashCode(),tv2.hashCode());
    assertNotEquals(tv1.hashCode(),tv3.hashCode());
    assertNotEquals(tv2.hashCode(),tv3.hashCode());
  }
  @Test public void testReflectionHelperCompareArguments_ExactMatching(){
    StandardTypeConverter tc=new StandardTypeConverter();
    checkMatch(new Class<?>[]{String.class},new Class<?>[]{String.class},tc,ReflectionHelper.ArgumentsMatchKind.EXACT);
    checkMatch(new Class<?>[]{String.class,Integer.class},new Class<?>[]{String.class,Integer.class},tc,ArgumentsMatchKind.EXACT);
  }
  @Test public void testReflectionHelperCompareArguments_CloseMatching(){
    StandardTypeConverter tc=new StandardTypeConverter();
    checkMatch(new Class<?>[]{ArrayList.class},new Class<?>[]{List.class},tc,ArgumentsMatchKind.CLOSE);
    checkMatch(new Class<?>[]{Sub.class,String.class},new Class<?>[]{Super.class,String.class},tc,ArgumentsMatchKind.CLOSE);
    checkMatch(new Class<?>[]{String.class,Sub.class},new Class<?>[]{String.class,Super.class},tc,ArgumentsMatchKind.CLOSE);
  }
  @Test public void testReflectionHelperCompareArguments_RequiresConversionMatching(){
    StandardTypeConverter tc=new StandardTypeConverter();
    checkMatch(new Class<?>[]{String.class,Integer.TYPE},new Class<?>[]{String.class,Integer.class},tc,ArgumentsMatchKind.CLOSE);
    checkMatch(new Class<?>[]{Integer.TYPE,String.class},new Class<?>[]{Integer.class,String.class},tc,ArgumentsMatchKind.CLOSE);
    checkMatch(new Class<?>[]{Integer.TYPE,Sub.class},new Class<?>[]{Integer.class,Super.class},tc,ArgumentsMatchKind.CLOSE);
  }
  @Test public void testReflectionHelperCompareArguments_NotAMatch(){
    StandardTypeConverter typeConverter=new StandardTypeConverter();
    checkMatch(new Class<?>[]{Super.class,String.class},new Class<?>[]{Sub.class,String.class},typeConverter,null);
  }
  @Test public void testReflectionHelperCompareArguments_Varargs_ExactMatching(){
    StandardTypeConverter tc=new StandardTypeConverter();
    checkMatch2(new Class<?>[]{String[].class},new Class<?>[]{String[].class},tc,ArgumentsMatchKind.EXACT);
    checkMatch2(new Class<?>[]{Integer.class,String[].class},new Class<?>[]{Integer.class,String[].class},tc,ArgumentsMatchKind.EXACT);
    checkMatch2(new Class<?>[]{String.class,Integer.class,String[].class},new Class<?>[]{String.class,Integer.class,String[].class},tc,ArgumentsMatchKind.EXACT);
    checkMatch2(new Class<?>[]{Sub.class,String[].class},new Class<?>[]{Super.class,String[].class},tc,ArgumentsMatchKind.CLOSE);
    checkMatch2(new Class<?>[]{Integer.class,String[].class},new Class<?>[]{String.class,String[].class},tc,ArgumentsMatchKind.REQUIRES_CONVERSION);
    checkMatch2(new Class<?>[]{Integer.class,Sub.class,String[].class},new Class<?>[]{String.class,Super.class,String[].class},tc,ArgumentsMatchKind.REQUIRES_CONVERSION);
    checkMatch2(new Class<?>[]{String.class},new Class<?>[]{String[].class},tc,ArgumentsMatchKind.EXACT);
    checkMatch2(new Class<?>[]{Integer.class,String.class},new Class<?>[]{Integer.class,String[].class},tc,ArgumentsMatchKind.EXACT);
    checkMatch2(new Class<?>[]{String.class},new Class<?>[]{Integer[].class},tc,ArgumentsMatchKind.REQUIRES_CONVERSION);
    checkMatch2(new Class<?>[]{Sub.class},new Class<?>[]{Super[].class},tc,ArgumentsMatchKind.CLOSE);
    checkMatch2(new Class<?>[]{Super.class},new Class<?>[]{Sub[].class},tc,null);
    checkMatch2(new Class<?>[]{Unconvertable.class,String.class},new Class<?>[]{Sub.class,Super[].class},tc,null);
    checkMatch2(new Class<?>[]{Integer.class,Integer.class,String.class},new Class<?>[]{String.class,String.class,Super[].class},tc,null);
    checkMatch2(new Class<?>[]{Unconvertable.class,String.class},new Class<?>[]{Sub.class,Super[].class},tc,null);
    checkMatch2(new Class<?>[]{Integer.class,Integer.class,String.class},new Class<?>[]{String.class,String.class,Super[].class},tc,null);
    checkMatch2(new Class<?>[]{Integer.class,Integer.class,Sub.class},new Class<?>[]{String.class,String.class,Super[].class},tc,ArgumentsMatchKind.REQUIRES_CONVERSION);
    checkMatch2(new Class<?>[]{Integer.class,Integer.class,Integer.class},new Class<?>[]{Integer.class,String[].class},tc,ArgumentsMatchKind.REQUIRES_CONVERSION);
  }
  @Test public void testConvertArguments() throws Exception {
    StandardTypeConverter tc=new StandardTypeConverter();
    Method oneArg=TestInterface.class.getMethod("oneArg",String.class);
    Method twoArg=TestInterface.class.getMethod("twoArg",String.class,String[].class);
    Object[] args=new Object[]{3};
    ReflectionHelper.convertArguments(tc,args,oneArg,null);
    checkArguments(args,"3");
    args=new Object[]{3};
    ReflectionHelper.convertArguments(tc,args,twoArg,1);
    checkArguments(args,"3");
    args=new Object[]{3,"abc","abc"};
    ReflectionHelper.convertArguments(tc,args,twoArg,1);
    checkArguments(args,"3","abc","abc");
    args=new Object[]{3,false,3.0d};
    ReflectionHelper.convertArguments(tc,args,twoArg,1);
    checkArguments(args,"3","false","3.0");
  }
  @Test public void testConvertArguments2() throws Exception {
    StandardTypeConverter tc=new StandardTypeConverter();
    Method oneArg=TestInterface.class.getMethod("oneArg",String.class);
    Method twoArg=TestInterface.class.getMethod("twoArg",String.class,String[].class);
    Object[] args=new Object[]{3};
    ReflectionHelper.convertAllArguments(tc,args,oneArg);
    checkArguments(args,"3");
    args=new Object[]{3,false,3.0f};
    ReflectionHelper.convertAllArguments(tc,args,twoArg);
    checkArguments(args,"3","false","3.0");
    args=new Object[]{3};
    ReflectionHelper.convertAllArguments(tc,args,twoArg);
    checkArguments(args,"3");
    args=new Object[]{3,null,3.0f};
    ReflectionHelper.convertAllArguments(tc,args,twoArg);
    checkArguments(args,"3",null,"3.0");
  }
  @Test public void testSetupArguments(){
    Object[] newArray=ReflectionHelper.setupArgumentsForVarargsInvocation(new Class<?>[]{String[].class},"a","b","c");
    assertEquals(1,newArray.length);
    Object firstParam=newArray[0];
    assertEquals(String.class,firstParam.getClass().getComponentType());
    Object[] firstParamArray=(Object[])firstParam;
    assertEquals(3,firstParamArray.length);
    assertEquals("a",firstParamArray[0]);
    assertEquals("b",firstParamArray[1]);
    assertEquals("c",firstParamArray[2]);
  }
  @Test public void testReflectivePropertyAccessor() throws Exception {
    ReflectivePropertyAccessor rpa=new ReflectivePropertyAccessor();
    Tester t=new Tester();
    t.setProperty("hello");
    EvaluationContext ctx=new StandardEvaluationContext(t);
    assertTrue(rpa.canRead(ctx,t,"property"));
    assertEquals("hello",rpa.read(ctx,t,"property").getValue());
    assertEquals("hello",rpa.read(ctx,t,"property").getValue());
    assertTrue(rpa.canRead(ctx,t,"field"));
    assertEquals(3,rpa.read(ctx,t,"field").getValue());
    assertEquals(3,rpa.read(ctx,t,"field").getValue());
    assertTrue(rpa.canWrite(ctx,t,"property"));
    rpa.write(ctx,t,"property","goodbye");
    rpa.write(ctx,t,"property","goodbye");
    assertTrue(rpa.canWrite(ctx,t,"field"));
    rpa.write(ctx,t,"field",12);
    rpa.write(ctx,t,"field",12);
    rpa.write(ctx,t,"field2",3);
    rpa.write(ctx,t,"property2","doodoo");
    assertEquals(3,rpa.read(ctx,t,"field2").getValue());
    assertEquals(0,rpa.read(ctx,t,"field3").getValue());
    assertEquals("doodoo",rpa.read(ctx,t,"property3").getValue());
    assertEquals(0,rpa.read(ctx,t,"field3").getValue());
    assertEquals(false,rpa.read(ctx,t,"property4").getValue());
    assertTrue(rpa.canRead(ctx,t,"property4"));
    assertEquals("iD",rpa.read(ctx,t,"iD").getValue());
    assertTrue(rpa.canRead(ctx,t,"iD"));
    assertEquals("id",rpa.read(ctx,t,"id").getValue());
    assertTrue(rpa.canRead(ctx,t,"id"));
    assertEquals("ID",rpa.read(ctx,t,"ID").getValue());
    assertTrue(rpa.canRead(ctx,t,"ID"));
    assertEquals("id",rpa.read(ctx,t,"Id").getValue());
    assertTrue(rpa.canRead(ctx,t,"Id"));
    assertEquals("xyZ",rpa.read(ctx,t,"xyZ").getValue());
    assertTrue(rpa.canRead(ctx,t,"xyZ"));
    assertEquals("xY",rpa.read(ctx,t,"xY").getValue());
    assertTrue(rpa.canRead(ctx,t,"xY"));
    rpa.write(ctx,t,"pEBS","Test String");
    assertEquals("Test String",rpa.read(ctx,t,"pEBS").getValue());
  }
  @Test public void testOptimalReflectivePropertyAccessor() throws Exception {
    ReflectivePropertyAccessor rpa=new ReflectivePropertyAccessor();
    Tester t=new Tester();
    t.setProperty("hello");
    EvaluationContext ctx=new StandardEvaluationContext(t);
    assertTrue(rpa.canRead(ctx,t,"property"));
    assertEquals("hello",rpa.read(ctx,t,"property").getValue());
    assertEquals("hello",rpa.read(ctx,t,"property").getValue());
    PropertyAccessor optA=rpa.createOptimalAccessor(ctx,t,"property");
    assertTrue(optA.canRead(ctx,t,"property"));
    assertFalse(optA.canRead(ctx,t,"property2"));
    try {
      optA.canWrite(ctx,t,"property");
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
    try {
      optA.canWrite(ctx,t,"property2");
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
    assertEquals("hello",optA.read(ctx,t,"property").getValue());
    assertEquals("hello",optA.read(ctx,t,"property").getValue());
    try {
      optA.getSpecificTargetClasses();
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
    try {
      optA.write(ctx,t,"property",null);
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
    optA=rpa.createOptimalAccessor(ctx,t,"field");
    assertTrue(optA.canRead(ctx,t,"field"));
    assertFalse(optA.canRead(ctx,t,"field2"));
    try {
      optA.canWrite(ctx,t,"field");
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
    try {
      optA.canWrite(ctx,t,"field2");
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
    assertEquals(3,optA.read(ctx,t,"field").getValue());
    assertEquals(3,optA.read(ctx,t,"field").getValue());
    try {
      optA.getSpecificTargetClasses();
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
    try {
      optA.write(ctx,t,"field",null);
      fail();
    }
 catch (    UnsupportedOperationException uoe) {
    }
  }
  /** 
 * Used to validate the match returned from a compareArguments call.
 */
  private void checkMatch(  Class<?>[] inputTypes,  Class<?>[] expectedTypes,  StandardTypeConverter typeConverter,  ArgumentsMatchKind expectedMatchKind){
    ReflectionHelper.ArgumentsMatchInfo matchInfo=ReflectionHelper.compareArguments(getTypeDescriptors(expectedTypes),getTypeDescriptors(inputTypes),typeConverter);
    if (expectedMatchKind == null) {
      assertNull("Did not expect them to match in any way",matchInfo);
    }
 else {
      assertNotNull("Should not be a null match",matchInfo);
    }
    if (expectedMatchKind == ArgumentsMatchKind.EXACT) {
      assertTrue(matchInfo.isExactMatch());
    }
 else     if (expectedMatchKind == ArgumentsMatchKind.CLOSE) {
      assertTrue(matchInfo.isCloseMatch());
    }
 else     if (expectedMatchKind == ArgumentsMatchKind.REQUIRES_CONVERSION) {
      assertTrue("expected to be a match requiring conversion, but was " + matchInfo,matchInfo.isMatchRequiringConversion());
    }
  }
  /** 
 * Used to validate the match returned from a compareArguments call.
 */
  private void checkMatch2(  Class<?>[] inputTypes,  Class<?>[] expectedTypes,  StandardTypeConverter typeConverter,  ArgumentsMatchKind expectedMatchKind){
    ReflectionHelper.ArgumentsMatchInfo matchInfo=ReflectionHelper.compareArgumentsVarargs(getTypeDescriptors(expectedTypes),getTypeDescriptors(inputTypes),typeConverter);
    if (expectedMatchKind == null) {
      assertNull("Did not expect them to match in any way: " + matchInfo,matchInfo);
    }
 else {
      assertNotNull("Should not be a null match",matchInfo);
    }
    if (expectedMatchKind == ArgumentsMatchKind.EXACT) {
      assertTrue(matchInfo.isExactMatch());
    }
 else     if (expectedMatchKind == ArgumentsMatchKind.CLOSE) {
      assertTrue(matchInfo.isCloseMatch());
    }
 else     if (expectedMatchKind == ArgumentsMatchKind.REQUIRES_CONVERSION) {
      assertTrue("expected to be a match requiring conversion, but was " + matchInfo,matchInfo.isMatchRequiringConversion());
    }
  }
  private void checkArguments(  Object[] args,  Object... expected){
    assertEquals(expected.length,args.length);
    for (int i=0; i < expected.length; i++) {
      checkArgument(expected[i],args[i]);
    }
  }
  private void checkArgument(  Object expected,  Object actual){
    assertEquals(expected,actual);
  }
  private List<TypeDescriptor> getTypeDescriptors(  Class<?>... types){
    List<TypeDescriptor> typeDescriptors=new ArrayList<>(types.length);
    for (    Class<?> type : types) {
      typeDescriptors.add(TypeDescriptor.valueOf(type));
    }
    return typeDescriptors;
  }
public interface TestInterface {
    void oneArg(    String arg1);
    void twoArg(    String arg1,    String... arg2);
  }
static class Super {
  }
static class Sub extends Super {
  }
static class Unconvertable {
  }
static class Tester {
    String property;
    public int field=3;
    public int field2;
    public int field3=0;
    String property2;
    String property3="doodoo";
    boolean property4=false;
    String iD="iD";
    String id="id";
    String ID="ID";
    String pEBS="pEBS";
    String xY="xY";
    String xyZ="xyZ";
    public String getProperty(){
      return property;
    }
    public void setProperty(    String value){
      property=value;
    }
    public void setProperty2(    String value){
      property2=value;
    }
    public String getProperty3(){
      return property3;
    }
    public boolean isProperty4(){
      return property4;
    }
    public String getiD(){
      return iD;
    }
    public String getId(){
      return id;
    }
    public String getID(){
      return ID;
    }
    public String getXY(){
      return xY;
    }
    public String getXyZ(){
      return xyZ;
    }
    public String getpEBS(){
      return pEBS;
    }
    public void setpEBS(    String pEBS){
      this.pEBS=pEBS;
    }
  }
}
