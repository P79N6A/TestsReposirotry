/** 
 * Integration test that demonstrates how to register one or more  {@code @Configuration}classes via an  {@link ApplicationContextInitializer} in a composed annotation sothat certain  {@code @Configuration} classes are always registered whenever the composedannotation is used, even if the composed annotation is used to declare additional {@code @Configuration} classes.<p>This class has been implemented in response to the following Stack Overflow question: <a href="http://stackoverflow.com/questions/35733344/can-contextconfiguration-in-a-custom-annotation-be-merged"> Can  {@code @ContextConfiguration} in a custom annotation be merged?</a>
 * @author Sam Brannen
 * @since 4.3
 */
@RunWith(SpringRunner.class) @ComposedContextConfiguration(BarConfig.class) public class InitializerConfiguredViaMetaAnnotationTests {
  @Autowired String foo;
  @Autowired String bar;
  @Autowired List<String> strings;
  @Test public void beansFromInitializerAndComposedAnnotation(){
    assertEquals(2,strings.size());
    assertEquals("foo",foo);
    assertEquals("bar",bar);
  }
static class FooConfigInitializer implements ApplicationContextInitializer<GenericApplicationContext> {
    @Override public void initialize(    GenericApplicationContext applicationContext){
      new AnnotatedBeanDefinitionReader(applicationContext).register(FooConfig.class);
    }
  }
  @ContextConfiguration(loader=AnnotationConfigContextLoader.class,initializers=FooConfigInitializer.class) @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @interface ComposedContextConfiguration {  @AliasFor(annotation=ContextConfiguration.class,attribute="classes") Class<?>[] value() default {};
}
}
