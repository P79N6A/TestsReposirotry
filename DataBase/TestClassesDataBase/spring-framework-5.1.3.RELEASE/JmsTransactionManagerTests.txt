/** 
 * @author Juergen Hoeller
 * @since 26.07.2004
 */
public class JmsTransactionManagerTests {
  @After public void verifyTransactionSynchronizationManagerState(){
    assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());
    assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
  }
  @Test public void testTransactionCommit() throws JMSException {
    ConnectionFactory cf=mock(ConnectionFactory.class);
    Connection con=mock(Connection.class);
    final Session session=mock(Session.class);
    given(cf.createConnection()).willReturn(con);
    given(con.createSession(true,Session.AUTO_ACKNOWLEDGE)).willReturn(session);
    JmsTransactionManager tm=new JmsTransactionManager(cf);
    TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
    JmsTemplate jt=new JmsTemplate(cf);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    tm.commit(ts);
    verify(session).commit();
    verify(session).close();
    verify(con).close();
  }
  @Test public void testTransactionRollback() throws JMSException {
    ConnectionFactory cf=mock(ConnectionFactory.class);
    Connection con=mock(Connection.class);
    final Session session=mock(Session.class);
    given(cf.createConnection()).willReturn(con);
    given(con.createSession(true,Session.AUTO_ACKNOWLEDGE)).willReturn(session);
    JmsTransactionManager tm=new JmsTransactionManager(cf);
    TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
    JmsTemplate jt=new JmsTemplate(cf);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    tm.rollback(ts);
    verify(session).rollback();
    verify(session).close();
    verify(con).close();
  }
  @Test public void testParticipatingTransactionWithCommit() throws JMSException {
    ConnectionFactory cf=mock(ConnectionFactory.class);
    Connection con=mock(Connection.class);
    final Session session=mock(Session.class);
    given(cf.createConnection()).willReturn(con);
    given(con.createSession(true,Session.AUTO_ACKNOWLEDGE)).willReturn(session);
    JmsTransactionManager tm=new JmsTransactionManager(cf);
    TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
    final JmsTemplate jt=new JmsTemplate(cf);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    TransactionTemplate tt=new TransactionTemplate(tm);
    tt.execute(new TransactionCallbackWithoutResult(){
      @Override protected void doInTransactionWithoutResult(      TransactionStatus status){
        jt.execute(new SessionCallback<Void>(){
          @Override public Void doInJms(          Session sess){
            assertTrue(sess == session);
            return null;
          }
        }
);
      }
    }
);
    tm.commit(ts);
    verify(session).commit();
    verify(session).close();
    verify(con).close();
  }
  @Test public void testParticipatingTransactionWithRollbackOnly() throws JMSException {
    ConnectionFactory cf=mock(ConnectionFactory.class);
    Connection con=mock(Connection.class);
    final Session session=mock(Session.class);
    given(cf.createConnection()).willReturn(con);
    given(con.createSession(true,Session.AUTO_ACKNOWLEDGE)).willReturn(session);
    JmsTransactionManager tm=new JmsTransactionManager(cf);
    TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
    final JmsTemplate jt=new JmsTemplate(cf);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    TransactionTemplate tt=new TransactionTemplate(tm);
    tt.execute(new TransactionCallbackWithoutResult(){
      @Override protected void doInTransactionWithoutResult(      TransactionStatus status){
        jt.execute(new SessionCallback<Void>(){
          @Override public Void doInJms(          Session sess){
            assertTrue(sess == session);
            return null;
          }
        }
);
        status.setRollbackOnly();
      }
    }
);
    try {
      tm.commit(ts);
      fail("Should have thrown UnexpectedRollbackException");
    }
 catch (    UnexpectedRollbackException ex) {
    }
    verify(session).rollback();
    verify(session).close();
    verify(con).close();
  }
  @Test public void testSuspendedTransaction() throws JMSException {
    final ConnectionFactory cf=mock(ConnectionFactory.class);
    Connection con=mock(Connection.class);
    final Session session=mock(Session.class);
    final Session session2=mock(Session.class);
    given(cf.createConnection()).willReturn(con);
    given(con.createSession(true,Session.AUTO_ACKNOWLEDGE)).willReturn(session);
    given(con.createSession(false,Session.AUTO_ACKNOWLEDGE)).willReturn(session2);
    JmsTransactionManager tm=new JmsTransactionManager(cf);
    TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
    final JmsTemplate jt=new JmsTemplate(cf);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    TransactionTemplate tt=new TransactionTemplate(tm);
    tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED);
    tt.execute(new TransactionCallbackWithoutResult(){
      @Override protected void doInTransactionWithoutResult(      TransactionStatus status){
        jt.execute(new SessionCallback<Void>(){
          @Override public Void doInJms(          Session sess){
            assertTrue(sess != session);
            return null;
          }
        }
);
      }
    }
);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    tm.commit(ts);
    verify(session).commit();
    verify(session).close();
    verify(session2).close();
    verify(con,times(2)).close();
  }
  @Test public void testTransactionSuspension() throws JMSException {
    final ConnectionFactory cf=mock(ConnectionFactory.class);
    Connection con=mock(Connection.class);
    final Session session=mock(Session.class);
    final Session session2=mock(Session.class);
    given(cf.createConnection()).willReturn(con);
    given(con.createSession(true,Session.AUTO_ACKNOWLEDGE)).willReturn(session,session2);
    JmsTransactionManager tm=new JmsTransactionManager(cf);
    TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
    final JmsTemplate jt=new JmsTemplate(cf);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    TransactionTemplate tt=new TransactionTemplate(tm);
    tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
    tt.execute(new TransactionCallbackWithoutResult(){
      @Override protected void doInTransactionWithoutResult(      TransactionStatus status){
        jt.execute(new SessionCallback<Void>(){
          @Override public Void doInJms(          Session sess){
            assertTrue(sess != session);
            return null;
          }
        }
);
      }
    }
);
    jt.execute(new SessionCallback<Void>(){
      @Override public Void doInJms(      Session sess){
        assertTrue(sess == session);
        return null;
      }
    }
);
    tm.commit(ts);
    verify(session).commit();
    verify(session2).commit();
    verify(session).close();
    verify(session2).close();
    verify(con,times(2)).close();
  }
  @Test public void testTransactionCommitWithMessageProducer() throws JMSException {
    Destination dest=new StubQueue();
    ConnectionFactory cf=mock(ConnectionFactory.class);
    Connection con=mock(Connection.class);
    Session session=mock(Session.class);
    MessageProducer producer=mock(MessageProducer.class);
    final Message message=mock(Message.class);
    given(cf.createConnection()).willReturn(con);
    given(con.createSession(true,Session.AUTO_ACKNOWLEDGE)).willReturn(session);
    given(session.createProducer(dest)).willReturn(producer);
    given(session.getTransacted()).willReturn(true);
    JmsTransactionManager tm=new JmsTransactionManager(cf);
    TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
    JmsTemplate jt=new JmsTemplate(cf);
    jt.send(dest,new MessageCreator(){
      @Override public Message createMessage(      Session session) throws JMSException {
        return message;
      }
    }
);
    tm.commit(ts);
    verify(producer).send(message);
    verify(session).commit();
    verify(producer).close();
    verify(session).close();
    verify(con).close();
  }
}
