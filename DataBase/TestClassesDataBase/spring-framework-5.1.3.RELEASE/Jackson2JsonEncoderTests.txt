/** 
 * @author Sebastien Deleuze
 */
public class Jackson2JsonEncoderTests extends AbstractEncoderTestCase<Jackson2JsonEncoder> {
  public Jackson2JsonEncoderTests(){
    super(new Jackson2JsonEncoder());
  }
  @Override @Test public void canEncode(){
    ResolvableType pojoType=ResolvableType.forClass(Pojo.class);
    assertTrue(this.encoder.canEncode(pojoType,APPLICATION_JSON));
    assertTrue(this.encoder.canEncode(pojoType,APPLICATION_JSON_UTF8));
    assertTrue(this.encoder.canEncode(pojoType,APPLICATION_STREAM_JSON));
    assertTrue(this.encoder.canEncode(pojoType,null));
    assertTrue(this.encoder.canEncode(ResolvableType.NONE,null));
    assertFalse(this.encoder.canEncode(ResolvableType.forClass(Object.class),APPLICATION_OCTET_STREAM));
  }
  @Override public void encode() throws Exception {
    Flux<Object> input=Flux.just(new Pojo("foo","bar"),new Pojo("foofoo","barbar"),new Pojo("foofoofoo","barbarbar"));
    testEncodeAll(input,ResolvableType.forClass(Pojo.class),step -> step.consumeNextWith(expectString("{\"foo\":\"foo\",\"bar\":\"bar\"}\n")).consumeNextWith(expectString("{\"foo\":\"foofoo\",\"bar\":\"barbar\"}\n")).consumeNextWith(expectString("{\"foo\":\"foofoofoo\",\"bar\":\"barbarbar\"}\n")).verifyComplete(),APPLICATION_STREAM_JSON,null);
  }
  @Test public void canEncodeWithCustomMimeType(){
    MimeType textJavascript=new MimeType("text","javascript",StandardCharsets.UTF_8);
    Jackson2JsonEncoder encoder=new Jackson2JsonEncoder(new ObjectMapper(),textJavascript);
    assertEquals(Collections.singletonList(textJavascript),encoder.getEncodableMimeTypes());
  }
  @Test(expected=UnsupportedOperationException.class) public void encodableMimeTypesIsImmutable(){
    MimeType textJavascript=new MimeType("text","javascript",StandardCharsets.UTF_8);
    Jackson2JsonEncoder encoder=new Jackson2JsonEncoder(new ObjectMapper(),textJavascript);
    encoder.getMimeTypes().add(new MimeType("text","ecmascript"));
  }
  @Test public void canNotEncode(){
    assertFalse(this.encoder.canEncode(ResolvableType.forClass(String.class),null));
    assertFalse(this.encoder.canEncode(ResolvableType.forClass(Pojo.class),APPLICATION_XML));
    ResolvableType sseType=ResolvableType.forClass(ServerSentEvent.class);
    assertFalse(this.encoder.canEncode(sseType,APPLICATION_JSON));
  }
  @Test public void encodeNonStream(){
    Flux<Pojo> input=Flux.just(new Pojo("foo","bar"),new Pojo("foofoo","barbar"),new Pojo("foofoofoo","barbarbar"));
    testEncode(input,Pojo.class,step -> step.consumeNextWith(expectString("[" + "{\"foo\":\"foo\",\"bar\":\"bar\"}," + "{\"foo\":\"foofoo\",\"bar\":\"barbar\"},"+ "{\"foo\":\"foofoofoo\",\"bar\":\"barbarbar\"}]").andThen(DataBufferUtils::release)).verifyComplete());
  }
  @Test public void encodeWithType(){
    Flux<ParentClass> input=Flux.just(new Foo(),new Bar());
    testEncode(input,ParentClass.class,step -> step.consumeNextWith(expectString("[{\"type\":\"foo\"},{\"type\":\"bar\"}]").andThen(DataBufferUtils::release)).verifyComplete());
  }
  @Test public void encodeAsStreamWithCustomStreamingType(){
    MediaType fooMediaType=new MediaType("application","foo");
    MediaType barMediaType=new MediaType("application","bar");
    this.encoder.setStreamingMediaTypes(Arrays.asList(fooMediaType,barMediaType));
    Flux<Pojo> input=Flux.just(new Pojo("foo","bar"),new Pojo("foofoo","barbar"),new Pojo("foofoofoo","barbarbar"));
    testEncode(input,ResolvableType.forClass(Pojo.class),step -> step.consumeNextWith(expectString("{\"foo\":\"foo\",\"bar\":\"bar\"}\n").andThen(DataBufferUtils::release)).consumeNextWith(expectString("{\"foo\":\"foofoo\",\"bar\":\"barbar\"}\n").andThen(DataBufferUtils::release)).consumeNextWith(expectString("{\"foo\":\"foofoofoo\",\"bar\":\"barbarbar\"}\n").andThen(DataBufferUtils::release)).verifyComplete(),barMediaType,null);
  }
  @Test public void fieldLevelJsonView(){
    JacksonViewBean bean=new JacksonViewBean();
    bean.setWithView1("with");
    bean.setWithView2("with");
    bean.setWithoutView("without");
    Mono<JacksonViewBean> input=Mono.just(bean);
    ResolvableType type=ResolvableType.forClass(JacksonViewBean.class);
    Map<String,Object> hints=singletonMap(JSON_VIEW_HINT,MyJacksonView1.class);
    testEncode(input,type,step -> step.consumeNextWith(expectString("{\"withView1\":\"with\"}").andThen(DataBufferUtils::release)).verifyComplete(),null,hints);
  }
  @Test public void classLevelJsonView(){
    JacksonViewBean bean=new JacksonViewBean();
    bean.setWithView1("with");
    bean.setWithView2("with");
    bean.setWithoutView("without");
    Mono<JacksonViewBean> input=Mono.just(bean);
    ResolvableType type=ResolvableType.forClass(JacksonViewBean.class);
    Map<String,Object> hints=singletonMap(JSON_VIEW_HINT,MyJacksonView3.class);
    testEncode(input,type,step -> step.consumeNextWith(expectString("{\"withoutView\":\"without\"}").andThen(DataBufferUtils::release)).verifyComplete(),null,hints);
  }
@JsonTypeInfo(use=JsonTypeInfo.Id.NAME,property="type") private static class ParentClass {
  }
@JsonTypeName("foo") private static class Foo extends ParentClass {
  }
@JsonTypeName("bar") private static class Bar extends ParentClass {
  }
}
