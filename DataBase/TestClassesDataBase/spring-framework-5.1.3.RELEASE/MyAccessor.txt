static class MyAccessor implements CompilablePropertyAccessor {
  private Method method;
  public Class<?>[] getSpecificTargetClasses(){
    return new Class<?>[]{Payload2.class};
  }
  public boolean canRead(  EvaluationContext context,  Object target,  String name) throws AccessException {
    return true;
  }
  public TypedValue read(  EvaluationContext context,  Object target,  String name) throws AccessException {
    Payload2 payload2=(Payload2)target;
    return new TypedValue(payload2.getField(name));
  }
  public boolean canWrite(  EvaluationContext context,  Object target,  String name) throws AccessException {
    return false;
  }
  public void write(  EvaluationContext context,  Object target,  String name,  Object newValue) throws AccessException {
  }
  @Override public boolean isCompilable(){
    return true;
  }
  @Override public Class<?> getPropertyType(){
    return Object.class;
  }
  @Override public void generateCode(  String propertyName,  MethodVisitor mv,  CodeFlow cf){
    if (method == null) {
      try {
        method=Payload2.class.getDeclaredMethod("getField",String.class);
      }
 catch (      Exception ex) {
      }
    }
    String descriptor=cf.lastDescriptor();
    String memberDeclaringClassSlashedDescriptor=method.getDeclaringClass().getName().replace('.','/');
    if (descriptor == null) {
      cf.loadTarget(mv);
    }
    if (descriptor == null || !memberDeclaringClassSlashedDescriptor.equals(descriptor.substring(1))) {
      mv.visitTypeInsn(CHECKCAST,memberDeclaringClassSlashedDescriptor);
    }
    mv.visitLdcInsn(propertyName);
    mv.visitMethodInsn(INVOKEVIRTUAL,memberDeclaringClassSlashedDescriptor,method.getName(),CodeFlow.createSignatureDescriptor(method),false);
  }
}
