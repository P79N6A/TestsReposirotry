/** 
 * Test fixture for  {@link HttpMessageConverter}.
 * @author Arjen Poutsma
 * @author Brian Clozel
 */
public class HttpMessageConverterExtractorTests {
  private HttpMessageConverterExtractor<?> extractor;
  private final ClientHttpResponse response=mock(ClientHttpResponse.class);
  @Rule public final ExpectedException exception=ExpectedException.none();
  @Test public void noContent() throws IOException {
    HttpMessageConverter<?> converter=mock(HttpMessageConverter.class);
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.NO_CONTENT.value());
    Object result=extractor.extractData(response);
    assertNull(result);
  }
  @Test public void notModified() throws IOException {
    HttpMessageConverter<?> converter=mock(HttpMessageConverter.class);
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.NOT_MODIFIED.value());
    Object result=extractor.extractData(response);
    assertNull(result);
  }
  @Test public void informational() throws IOException {
    HttpMessageConverter<?> converter=mock(HttpMessageConverter.class);
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.CONTINUE.value());
    Object result=extractor.extractData(response);
    assertNull(result);
  }
  @Test public void zeroContentLength() throws IOException {
    HttpMessageConverter<?> converter=mock(HttpMessageConverter.class);
    HttpHeaders responseHeaders=new HttpHeaders();
    responseHeaders.setContentLength(0);
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.OK.value());
    given(response.getHeaders()).willReturn(responseHeaders);
    Object result=extractor.extractData(response);
    assertNull(result);
  }
  @Test @SuppressWarnings("unchecked") public void emptyMessageBody() throws IOException {
    HttpMessageConverter<String> converter=mock(HttpMessageConverter.class);
    HttpHeaders responseHeaders=new HttpHeaders();
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.OK.value());
    given(response.getHeaders()).willReturn(responseHeaders);
    given(response.getBody()).willReturn(new ByteArrayInputStream("".getBytes()));
    Object result=extractor.extractData(response);
    assertNull(result);
  }
  @Test @SuppressWarnings("unchecked") public void normal() throws IOException {
    HttpMessageConverter<String> converter=mock(HttpMessageConverter.class);
    HttpHeaders responseHeaders=new HttpHeaders();
    MediaType contentType=MediaType.TEXT_PLAIN;
    responseHeaders.setContentType(contentType);
    String expected="Foo";
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.OK.value());
    given(response.getHeaders()).willReturn(responseHeaders);
    given(response.getBody()).willReturn(new ByteArrayInputStream(expected.getBytes()));
    given(converter.canRead(String.class,contentType)).willReturn(true);
    given(converter.read(eq(String.class),any(HttpInputMessage.class))).willReturn(expected);
    Object result=extractor.extractData(response);
    assertEquals(expected,result);
  }
  @Test @SuppressWarnings("unchecked") public void cannotRead() throws IOException {
    HttpMessageConverter<String> converter=mock(HttpMessageConverter.class);
    HttpHeaders responseHeaders=new HttpHeaders();
    MediaType contentType=MediaType.TEXT_PLAIN;
    responseHeaders.setContentType(contentType);
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.OK.value());
    given(response.getHeaders()).willReturn(responseHeaders);
    given(response.getBody()).willReturn(new ByteArrayInputStream("Foobar".getBytes()));
    given(converter.canRead(String.class,contentType)).willReturn(false);
    exception.expect(RestClientException.class);
    extractor.extractData(response);
  }
  @Test @SuppressWarnings("unchecked") public void generics() throws IOException {
    GenericHttpMessageConverter<String> converter=mock(GenericHttpMessageConverter.class);
    HttpHeaders responseHeaders=new HttpHeaders();
    MediaType contentType=MediaType.TEXT_PLAIN;
    responseHeaders.setContentType(contentType);
    String expected="Foo";
    ParameterizedTypeReference<List<String>> reference=new ParameterizedTypeReference<List<String>>(){
    }
;
    Type type=reference.getType();
    extractor=new HttpMessageConverterExtractor<List<String>>(type,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.OK.value());
    given(response.getHeaders()).willReturn(responseHeaders);
    given(response.getBody()).willReturn(new ByteArrayInputStream(expected.getBytes()));
    given(converter.canRead(type,null,contentType)).willReturn(true);
    given(converter.read(eq(type),eq(null),any(HttpInputMessage.class))).willReturn(expected);
    Object result=extractor.extractData(response);
    assertEquals(expected,result);
  }
  @Test @SuppressWarnings("unchecked") public void converterThrowsIOException() throws IOException {
    HttpMessageConverter<String> converter=mock(HttpMessageConverter.class);
    HttpHeaders responseHeaders=new HttpHeaders();
    MediaType contentType=MediaType.TEXT_PLAIN;
    responseHeaders.setContentType(contentType);
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.OK.value());
    given(response.getHeaders()).willReturn(responseHeaders);
    given(response.getBody()).willReturn(new ByteArrayInputStream("Foobar".getBytes()));
    given(converter.canRead(String.class,contentType)).willReturn(true);
    given(converter.read(eq(String.class),any(HttpInputMessage.class))).willThrow(IOException.class);
    exception.expect(RestClientException.class);
    exception.expectMessage("Error while extracting response for type " + "[class java.lang.String] and content type [text/plain]");
    exception.expectCause(Matchers.instanceOf(IOException.class));
    extractor.extractData(response);
  }
  @Test @SuppressWarnings("unchecked") public void converterThrowsHttpMessageNotReadableException() throws IOException {
    HttpMessageConverter<String> converter=mock(HttpMessageConverter.class);
    HttpHeaders responseHeaders=new HttpHeaders();
    MediaType contentType=MediaType.TEXT_PLAIN;
    responseHeaders.setContentType(contentType);
    extractor=new HttpMessageConverterExtractor<>(String.class,createConverterList(converter));
    given(response.getRawStatusCode()).willReturn(HttpStatus.OK.value());
    given(response.getHeaders()).willReturn(responseHeaders);
    given(response.getBody()).willReturn(new ByteArrayInputStream("Foobar".getBytes()));
    given(converter.canRead(String.class,contentType)).willThrow(HttpMessageNotReadableException.class);
    exception.expect(RestClientException.class);
    exception.expectMessage("Error while extracting response for type " + "[class java.lang.String] and content type [text/plain]");
    exception.expectCause(Matchers.instanceOf(HttpMessageNotReadableException.class));
    extractor.extractData(response);
  }
  private List<HttpMessageConverter<?>> createConverterList(  HttpMessageConverter<?> converter){
    List<HttpMessageConverter<?>> converters=new ArrayList<>(1);
    converters.add(converter);
    return converters;
  }
}
