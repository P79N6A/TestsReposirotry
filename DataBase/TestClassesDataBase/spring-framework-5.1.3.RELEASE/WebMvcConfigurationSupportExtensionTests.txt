/** 
 * A test fixture with a sub-class of  {@link WebMvcConfigurationSupport} that alsoimplements the various  {@link WebMvcConfigurer} extension points.The former doesn't implement the latter but the two must have compatible callback method signatures to support moving from simple to advanced configuration -- i.e. dropping @EnableWebMvc + WebMvcConfigurer and extending directly from WebMvcConfigurationSupport.
 * @author Rossen Stoyanchev
 * @author Sebastien Deleuze
 */
public class WebMvcConfigurationSupportExtensionTests {
  private TestWebMvcConfigurationSupport config;
  private StaticWebApplicationContext context;
  @Before public void setUp(){
    this.context=new StaticWebApplicationContext();
    this.context.setServletContext(new MockServletContext(new FileSystemResourceLoader()));
    this.context.registerSingleton("controller",TestController.class);
    this.context.registerSingleton("userController",UserController.class);
    this.config=new TestWebMvcConfigurationSupport();
    this.config.setApplicationContext(this.context);
    this.config.setServletContext(this.context.getServletContext());
  }
  @Test public void handlerMappings() throws Exception {
    RequestMappingHandlerMapping rmHandlerMapping=this.config.requestMappingHandlerMapping();
    rmHandlerMapping.setApplicationContext(this.context);
    rmHandlerMapping.afterPropertiesSet();
    assertEquals(TestPathHelper.class,rmHandlerMapping.getUrlPathHelper().getClass());
    assertEquals(TestPathMatcher.class,rmHandlerMapping.getPathMatcher().getClass());
    HandlerExecutionChain chain=rmHandlerMapping.getHandler(new MockHttpServletRequest("GET","/"));
    assertNotNull(chain);
    assertNotNull(chain.getInterceptors());
    assertEquals(3,chain.getInterceptors().length);
    assertEquals(LocaleChangeInterceptor.class,chain.getInterceptors()[0].getClass());
    assertEquals(ConversionServiceExposingInterceptor.class,chain.getInterceptors()[1].getClass());
    assertEquals(ResourceUrlProviderExposingInterceptor.class,chain.getInterceptors()[2].getClass());
    Map<RequestMappingInfo,HandlerMethod> map=rmHandlerMapping.getHandlerMethods();
    assertEquals(2,map.size());
    RequestMappingInfo info=map.entrySet().stream().filter(entry -> entry.getValue().getBeanType().equals(UserController.class)).findFirst().orElseThrow(() -> new AssertionError("UserController bean not found")).getKey();
    assertEquals(Collections.singleton("/api/user/{id}"),info.getPatternsCondition().getPatterns());
    AbstractHandlerMapping handlerMapping=(AbstractHandlerMapping)this.config.viewControllerHandlerMapping();
    handlerMapping.setApplicationContext(this.context);
    assertNotNull(handlerMapping);
    assertEquals(1,handlerMapping.getOrder());
    assertEquals(TestPathHelper.class,handlerMapping.getUrlPathHelper().getClass());
    assertEquals(TestPathMatcher.class,handlerMapping.getPathMatcher().getClass());
    chain=handlerMapping.getHandler(new MockHttpServletRequest("GET","/path"));
    assertNotNull(chain);
    assertNotNull(chain.getHandler());
    chain=handlerMapping.getHandler(new MockHttpServletRequest("GET","/bad"));
    assertNotNull(chain);
    assertNotNull(chain.getHandler());
    chain=handlerMapping.getHandler(new MockHttpServletRequest("GET","/old"));
    assertNotNull(chain);
    assertNotNull(chain.getHandler());
    handlerMapping=(AbstractHandlerMapping)this.config.resourceHandlerMapping();
    handlerMapping.setApplicationContext(this.context);
    assertNotNull(handlerMapping);
    assertEquals(Integer.MAX_VALUE - 1,handlerMapping.getOrder());
    assertEquals(TestPathHelper.class,handlerMapping.getUrlPathHelper().getClass());
    assertEquals(TestPathMatcher.class,handlerMapping.getPathMatcher().getClass());
    chain=handlerMapping.getHandler(new MockHttpServletRequest("GET","/resources/foo.gif"));
    assertNotNull(chain);
    assertNotNull(chain.getHandler());
    assertEquals(Arrays.toString(chain.getInterceptors()),4,chain.getInterceptors().length);
    assertEquals(LocaleChangeInterceptor.class,chain.getInterceptors()[1].getClass());
    assertEquals(ConversionServiceExposingInterceptor.class,chain.getInterceptors()[2].getClass());
    assertEquals(ResourceUrlProviderExposingInterceptor.class,chain.getInterceptors()[3].getClass());
    handlerMapping=(AbstractHandlerMapping)this.config.defaultServletHandlerMapping();
    handlerMapping.setApplicationContext(this.context);
    assertNotNull(handlerMapping);
    assertEquals(Integer.MAX_VALUE,handlerMapping.getOrder());
    chain=handlerMapping.getHandler(new MockHttpServletRequest("GET","/anyPath"));
    assertNotNull(chain);
    assertNotNull(chain.getHandler());
  }
  @SuppressWarnings("unchecked") @Test public void requestMappingHandlerAdapter() throws Exception {
    RequestMappingHandlerAdapter adapter=this.config.requestMappingHandlerAdapter();
    String actual=this.config.mvcConversionService().convert(new TestBean(),String.class);
    assertEquals("converted",actual);
    List<HttpMessageConverter<?>> converters=adapter.getMessageConverters();
    assertEquals(2,converters.size());
    assertEquals(StringHttpMessageConverter.class,converters.get(0).getClass());
    assertEquals(MappingJackson2HttpMessageConverter.class,converters.get(1).getClass());
    ObjectMapper objectMapper=((MappingJackson2HttpMessageConverter)converters.get(1)).getObjectMapper();
    assertFalse(objectMapper.getDeserializationConfig().isEnabled(DEFAULT_VIEW_INCLUSION));
    assertFalse(objectMapper.getSerializationConfig().isEnabled(DEFAULT_VIEW_INCLUSION));
    assertFalse(objectMapper.getDeserializationConfig().isEnabled(FAIL_ON_UNKNOWN_PROPERTIES));
    DirectFieldAccessor fieldAccessor=new DirectFieldAccessor(adapter);
    List<HandlerMethodArgumentResolver> argResolvers=(List<HandlerMethodArgumentResolver>)fieldAccessor.getPropertyValue("customArgumentResolvers");
    assertEquals(1,argResolvers.size());
    List<HandlerMethodReturnValueHandler> handlers=(List<HandlerMethodReturnValueHandler>)fieldAccessor.getPropertyValue("customReturnValueHandlers");
    assertEquals(1,handlers.size());
    assertEquals(ConcurrentTaskExecutor.class,fieldAccessor.getPropertyValue("taskExecutor").getClass());
    assertEquals(2500L,fieldAccessor.getPropertyValue("asyncRequestTimeout"));
    CallableProcessingInterceptor[] callableInterceptors=(CallableProcessingInterceptor[])fieldAccessor.getPropertyValue("callableInterceptors");
    assertEquals(1,callableInterceptors.length);
    DeferredResultProcessingInterceptor[] deferredResultInterceptors=(DeferredResultProcessingInterceptor[])fieldAccessor.getPropertyValue("deferredResultInterceptors");
    assertEquals(1,deferredResultInterceptors.length);
    assertEquals(false,fieldAccessor.getPropertyValue("ignoreDefaultModelOnRedirect"));
  }
  @Test public void webBindingInitializer() throws Exception {
    RequestMappingHandlerAdapter adapter=this.config.requestMappingHandlerAdapter();
    ConfigurableWebBindingInitializer initializer=(ConfigurableWebBindingInitializer)adapter.getWebBindingInitializer();
    assertNotNull(initializer);
    BeanPropertyBindingResult bindingResult=new BeanPropertyBindingResult(null,"");
    initializer.getValidator().validate(null,bindingResult);
    assertEquals("invalid",bindingResult.getAllErrors().get(0).getCode());
    String[] codes=initializer.getMessageCodesResolver().resolveMessageCodes("invalid",null);
    assertEquals("custom.invalid",codes[0]);
  }
  @Test public void contentNegotiation() throws Exception {
    MockHttpServletRequest request=new MockHttpServletRequest("GET","/foo.json");
    NativeWebRequest webRequest=new ServletWebRequest(request);
    RequestMappingHandlerMapping mapping=this.config.requestMappingHandlerMapping();
    ContentNegotiationManager manager=mapping.getContentNegotiationManager();
    assertEquals(Collections.singletonList(APPLICATION_JSON),manager.resolveMediaTypes(webRequest));
    request.setRequestURI("/foo.xml");
    assertEquals(Collections.singletonList(APPLICATION_XML),manager.resolveMediaTypes(webRequest));
    request.setRequestURI("/foo.rss");
    assertEquals(Collections.singletonList(MediaType.valueOf("application/rss+xml")),manager.resolveMediaTypes(webRequest));
    request.setRequestURI("/foo.atom");
    assertEquals(Collections.singletonList(APPLICATION_ATOM_XML),manager.resolveMediaTypes(webRequest));
    request.setRequestURI("/foo");
    request.setParameter("f","json");
    assertEquals(Collections.singletonList(APPLICATION_JSON),manager.resolveMediaTypes(webRequest));
    request.setRequestURI("/resources/foo.gif");
    SimpleUrlHandlerMapping handlerMapping=(SimpleUrlHandlerMapping)this.config.resourceHandlerMapping();
    handlerMapping.setApplicationContext(this.context);
    HandlerExecutionChain chain=handlerMapping.getHandler(request);
    assertNotNull(chain);
    ResourceHttpRequestHandler handler=(ResourceHttpRequestHandler)chain.getHandler();
    assertNotNull(handler);
    assertSame(manager,handler.getContentNegotiationManager());
  }
  @Test public void exceptionResolvers() throws Exception {
    List<HandlerExceptionResolver> resolvers=((HandlerExceptionResolverComposite)this.config.handlerExceptionResolver()).getExceptionResolvers();
    assertEquals(2,resolvers.size());
    assertEquals(ResponseStatusExceptionResolver.class,resolvers.get(0).getClass());
    assertEquals(SimpleMappingExceptionResolver.class,resolvers.get(1).getClass());
  }
  @SuppressWarnings("unchecked") @Test public void viewResolvers() throws Exception {
    ViewResolverComposite viewResolver=(ViewResolverComposite)this.config.mvcViewResolver();
    assertEquals(Ordered.HIGHEST_PRECEDENCE,viewResolver.getOrder());
    List<ViewResolver> viewResolvers=viewResolver.getViewResolvers();
    DirectFieldAccessor accessor=new DirectFieldAccessor(viewResolvers.get(0));
    assertEquals(1,viewResolvers.size());
    assertEquals(ContentNegotiatingViewResolver.class,viewResolvers.get(0).getClass());
    assertFalse((Boolean)accessor.getPropertyValue("useNotAcceptableStatusCode"));
    assertNotNull(accessor.getPropertyValue("contentNegotiationManager"));
    List<View> defaultViews=(List<View>)accessor.getPropertyValue("defaultViews");
    assertNotNull(defaultViews);
    assertEquals(1,defaultViews.size());
    assertEquals(MappingJackson2JsonView.class,defaultViews.get(0).getClass());
    viewResolvers=(List<ViewResolver>)accessor.getPropertyValue("viewResolvers");
    assertNotNull(viewResolvers);
    assertEquals(1,viewResolvers.size());
    assertEquals(InternalResourceViewResolver.class,viewResolvers.get(0).getClass());
    accessor=new DirectFieldAccessor(viewResolvers.get(0));
    assertEquals("/",accessor.getPropertyValue("prefix"));
    assertEquals(".jsp",accessor.getPropertyValue("suffix"));
  }
  @Test public void crossOrigin(){
    Map<String,CorsConfiguration> configs=this.config.getCorsConfigurations();
    assertEquals(1,configs.size());
    assertEquals("*",configs.get("/resources/**").getAllowedOrigins().get(0));
  }
@Controller private static class TestController {
    @RequestMapping("/") public void handle(){
    }
  }
  /** 
 * Since WebMvcConfigurationSupport does not implement WebMvcConfigurer, the purpose of this test class is also to ensure the two are in sync with each other. Effectively that ensures that application config classes that use the combo  {@code @EnableWebMvc}plus WebMvcConfigurer can switch to extending WebMvcConfigurationSupport directly for more advanced configuration needs.
 */
private class TestWebMvcConfigurationSupport extends WebMvcConfigurationSupport implements WebMvcConfigurer {
    @Override public void addFormatters(    FormatterRegistry registry){
      registry.addConverter(new Converter<TestBean,String>(){
        @Override public String convert(        TestBean source){
          return "converted";
        }
      }
);
    }
    @Override public void configureMessageConverters(    List<HttpMessageConverter<?>> converters){
      converters.add(new MappingJackson2HttpMessageConverter());
    }
    @Override public void extendMessageConverters(    List<HttpMessageConverter<?>> converters){
      converters.add(0,new StringHttpMessageConverter());
    }
    @Override public Validator getValidator(){
      return new Validator(){
        @Override public void validate(        @Nullable Object target,        Errors errors){
          errors.reject("invalid");
        }
        @Override public boolean supports(        Class<?> clazz){
          return true;
        }
      }
;
    }
    @Override public void configureContentNegotiation(    ContentNegotiationConfigurer configurer){
      configurer.favorParameter(true).parameterName("f");
    }
    @Override public void configureAsyncSupport(    AsyncSupportConfigurer configurer){
      configurer.setDefaultTimeout(2500).setTaskExecutor(new ConcurrentTaskExecutor()).registerCallableInterceptors(new CallableProcessingInterceptor(){
      }
).registerDeferredResultInterceptors(new DeferredResultProcessingInterceptor(){
      }
);
    }
    @Override public void addArgumentResolvers(    List<HandlerMethodArgumentResolver> argumentResolvers){
      argumentResolvers.add(new ModelAttributeMethodProcessor(true));
    }
    @Override public void addReturnValueHandlers(    List<HandlerMethodReturnValueHandler> returnValueHandlers){
      returnValueHandlers.add(new ModelAttributeMethodProcessor(true));
    }
    @Override public void configureHandlerExceptionResolvers(    List<HandlerExceptionResolver> exceptionResolvers){
      exceptionResolvers.add(new SimpleMappingExceptionResolver());
    }
    @Override public void extendHandlerExceptionResolvers(    List<HandlerExceptionResolver> exceptionResolvers){
      exceptionResolvers.add(0,new ResponseStatusExceptionResolver());
    }
    @Override public void configurePathMatch(    PathMatchConfigurer configurer){
      configurer.setPathMatcher(new TestPathMatcher());
      configurer.setUrlPathHelper(new TestPathHelper());
      configurer.addPathPrefix("/api",HandlerTypePredicate.forAnnotation(RestController.class));
    }
    @Override public void addInterceptors(    InterceptorRegistry registry){
      registry.addInterceptor(new LocaleChangeInterceptor());
    }
    @SuppressWarnings("serial") @Override public MessageCodesResolver getMessageCodesResolver(){
      return new DefaultMessageCodesResolver(){
        @Override public String[] resolveMessageCodes(        String errorCode,        String objectName){
          return new String[]{"custom." + errorCode};
        }
      }
;
    }
    @Override public void addViewControllers(    ViewControllerRegistry registry){
      registry.addViewController("/path").setViewName("view");
      registry.addRedirectViewController("/old","/new").setStatusCode(HttpStatus.PERMANENT_REDIRECT);
      registry.addStatusController("/bad",HttpStatus.NOT_FOUND);
    }
    @Override public void configureViewResolvers(    ViewResolverRegistry registry){
      registry.enableContentNegotiation(new MappingJackson2JsonView());
      registry.jsp("/",".jsp");
    }
    @Override public void addResourceHandlers(    ResourceHandlerRegistry registry){
      registry.addResourceHandler("/resources/**").addResourceLocations("src/test/java");
    }
    @Override public void configureDefaultServletHandling(    DefaultServletHandlerConfigurer configurer){
      configurer.enable("default");
    }
    @Override public void addCorsMappings(    CorsRegistry registry){
      registry.addMapping("/resources/**");
    }
  }
private class TestPathHelper extends UrlPathHelper {
  }
private class TestPathMatcher extends AntPathMatcher {
  }
@RestController @RequestMapping("/user") static class UserController {
    @GetMapping("/{id}") public Principal getUser(){
      return mock(Principal.class);
    }
  }
}
