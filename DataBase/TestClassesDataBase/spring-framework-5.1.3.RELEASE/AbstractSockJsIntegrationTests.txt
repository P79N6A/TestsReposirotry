/** 
 * Abstract base class for integration tests using the {@link org.springframework.web.socket.sockjs.client.SockJsClient SockJsClient}against actual SockJS server endpoints.
 * @author Rossen Stoyanchev
 * @author Sam Brannen
 */
public abstract class AbstractSockJsIntegrationTests {
  @Rule public final TestName testName=new TestName();
  protected Log logger=LogFactory.getLog(getClass());
  private SockJsClient sockJsClient;
  private WebSocketTestServer server;
  private AnnotationConfigWebApplicationContext wac;
  private TestFilter testFilter;
  private String baseUrl;
  @BeforeClass public static void performanceTestGroupAssumption() throws Exception {
    Assume.group(TestGroup.PERFORMANCE);
  }
  @Before public void setup() throws Exception {
    logger.debug("Setting up '" + this.testName.getMethodName() + "'");
    this.testFilter=new TestFilter();
    this.wac=new AnnotationConfigWebApplicationContext();
    this.wac.register(TestConfig.class,upgradeStrategyConfigClass());
    this.server=createWebSocketTestServer();
    this.server.setup();
    this.server.deployConfig(this.wac,this.testFilter);
    this.server.start();
    this.wac.setServletContext(this.server.getServletContext());
    this.wac.refresh();
    this.baseUrl="http://localhost:" + this.server.getPort();
  }
  @After public void teardown() throws Exception {
    try {
      this.sockJsClient.stop();
    }
 catch (    Throwable ex) {
      logger.error("Failed to stop SockJsClient",ex);
    }
    try {
      this.server.undeployConfig();
    }
 catch (    Throwable t) {
      logger.error("Failed to undeploy application config",t);
    }
    try {
      this.server.stop();
    }
 catch (    Throwable t) {
      logger.error("Failed to stop server",t);
    }
    try {
      this.wac.close();
    }
 catch (    Throwable t) {
      logger.error("Failed to close WebApplicationContext",t);
    }
  }
  protected abstract Class<?> upgradeStrategyConfigClass();
  protected abstract WebSocketTestServer createWebSocketTestServer();
  protected abstract Transport createWebSocketTransport();
  protected abstract AbstractXhrTransport createXhrTransport();
  protected void initSockJsClient(  Transport... transports){
    this.sockJsClient=new SockJsClient(Arrays.asList(transports));
    this.sockJsClient.start();
  }
  @Test public void echoWebSocket() throws Exception {
    testEcho(100,createWebSocketTransport(),null);
  }
  @Test public void echoXhrStreaming() throws Exception {
    testEcho(100,createXhrTransport(),null);
  }
  @Test public void echoXhr() throws Exception {
    AbstractXhrTransport xhrTransport=createXhrTransport();
    xhrTransport.setXhrStreamingDisabled(true);
    testEcho(100,xhrTransport,null);
  }
  @Test public void echoXhrWithHeaders() throws Exception {
    AbstractXhrTransport xhrTransport=createXhrTransport();
    xhrTransport.setXhrStreamingDisabled(true);
    WebSocketHttpHeaders headers=new WebSocketHttpHeaders();
    headers.add("auth","123");
    testEcho(10,xhrTransport,headers);
    for (    Map.Entry<String,HttpHeaders> entry : this.testFilter.requests.entrySet()) {
      HttpHeaders httpHeaders=entry.getValue();
      assertEquals("No auth header for: " + entry.getKey(),"123",httpHeaders.getFirst("auth"));
    }
  }
  @Test public void receiveOneMessageWebSocket() throws Exception {
    testReceiveOneMessage(createWebSocketTransport(),null);
  }
  @Test public void receiveOneMessageXhrStreaming() throws Exception {
    testReceiveOneMessage(createXhrTransport(),null);
  }
  @Test public void receiveOneMessageXhr() throws Exception {
    AbstractXhrTransport xhrTransport=createXhrTransport();
    xhrTransport.setXhrStreamingDisabled(true);
    testReceiveOneMessage(xhrTransport,null);
  }
  @Test public void infoRequestFailure() throws Exception {
    TestClientHandler handler=new TestClientHandler();
    this.testFilter.sendErrorMap.put("/info",500);
    CountDownLatch latch=new CountDownLatch(1);
    initSockJsClient(createWebSocketTransport());
    this.sockJsClient.doHandshake(handler,this.baseUrl + "/echo").addCallback(new ListenableFutureCallback<WebSocketSession>(){
      @Override public void onSuccess(      WebSocketSession result){
      }
      @Override public void onFailure(      Throwable ex){
        latch.countDown();
      }
    }
);
    assertTrue(latch.await(5000,TimeUnit.MILLISECONDS));
  }
  @Test public void fallbackAfterTransportFailure() throws Exception {
    this.testFilter.sendErrorMap.put("/websocket",200);
    this.testFilter.sendErrorMap.put("/xhr_streaming",500);
    TestClientHandler handler=new TestClientHandler();
    initSockJsClient(createWebSocketTransport(),createXhrTransport());
    WebSocketSession session=this.sockJsClient.doHandshake(handler,this.baseUrl + "/echo").get();
    assertEquals("Fallback didn't occur",XhrClientSockJsSession.class,session.getClass());
    TextMessage message=new TextMessage("message1");
    session.sendMessage(message);
    handler.awaitMessage(message,5000);
  }
  @Test(timeout=5000) public void fallbackAfterConnectTimeout() throws Exception {
    TestClientHandler clientHandler=new TestClientHandler();
    this.testFilter.sleepDelayMap.put("/xhr_streaming",10000L);
    this.testFilter.sendErrorMap.put("/xhr_streaming",503);
    initSockJsClient(createXhrTransport());
    this.sockJsClient.setConnectTimeoutScheduler(this.wac.getBean(ThreadPoolTaskScheduler.class));
    WebSocketSession clientSession=sockJsClient.doHandshake(clientHandler,this.baseUrl + "/echo").get();
    assertEquals("Fallback didn't occur",XhrClientSockJsSession.class,clientSession.getClass());
    TextMessage message=new TextMessage("message1");
    clientSession.sendMessage(message);
    clientHandler.awaitMessage(message,5000);
    clientSession.close();
  }
  private void testEcho(  int messageCount,  Transport transport,  WebSocketHttpHeaders headers) throws Exception {
    List<TextMessage> messages=new ArrayList<>();
    for (int i=0; i < messageCount; i++) {
      messages.add(new TextMessage("m" + i));
    }
    TestClientHandler handler=new TestClientHandler();
    initSockJsClient(transport);
    URI url=new URI(this.baseUrl + "/echo");
    WebSocketSession session=this.sockJsClient.doHandshake(handler,headers,url).get();
    for (    TextMessage message : messages) {
      session.sendMessage(message);
    }
    handler.awaitMessageCount(messageCount,5000);
    for (    TextMessage message : messages) {
      assertTrue("Message not received: " + message,handler.receivedMessages.remove(message));
    }
    assertEquals("Remaining messages: " + handler.receivedMessages,0,handler.receivedMessages.size());
    session.close();
  }
  private void testReceiveOneMessage(  Transport transport,  WebSocketHttpHeaders headers) throws Exception {
    TestClientHandler clientHandler=new TestClientHandler();
    initSockJsClient(transport);
    this.sockJsClient.doHandshake(clientHandler,headers,new URI(this.baseUrl + "/test")).get();
    TestServerHandler serverHandler=this.wac.getBean(TestServerHandler.class);
    assertNotNull("afterConnectionEstablished should have been called",clientHandler.session);
    serverHandler.awaitSession(5000);
    TextMessage message=new TextMessage("message1");
    serverHandler.session.sendMessage(message);
    clientHandler.awaitMessage(message,5000);
  }
  private static void awaitEvent(  BooleanSupplier condition,  long timeToWait,  String description){
    long timeToSleep=200;
    for (int i=0; i < Math.floor(timeToWait / timeToSleep); i++) {
      if (condition.getAsBoolean()) {
        return;
      }
      try {
        Thread.sleep(timeToSleep);
      }
 catch (      InterruptedException e) {
        throw new IllegalStateException("Interrupted while waiting for " + description,e);
      }
    }
    throw new IllegalStateException("Timed out waiting for " + description);
  }
@Configuration @EnableWebSocket static class TestConfig implements WebSocketConfigurer {
    @Autowired private RequestUpgradeStrategy upgradeStrategy;
    @Override public void registerWebSocketHandlers(    WebSocketHandlerRegistry registry){
      HandshakeHandler handshakeHandler=new DefaultHandshakeHandler(this.upgradeStrategy);
      registry.addHandler(new EchoHandler(),"/echo").setHandshakeHandler(handshakeHandler).withSockJS();
      registry.addHandler(testServerHandler(),"/test").setHandshakeHandler(handshakeHandler).withSockJS();
    }
    @Bean public TestServerHandler testServerHandler(){
      return new TestServerHandler();
    }
  }
private static class TestClientHandler extends TextWebSocketHandler {
    private final BlockingQueue<TextMessage> receivedMessages=new LinkedBlockingQueue<>();
    private volatile WebSocketSession session;
    private volatile Throwable transportError;
    @Override public void afterConnectionEstablished(    WebSocketSession session) throws Exception {
      this.session=session;
    }
    @Override protected void handleTextMessage(    WebSocketSession session,    TextMessage message) throws Exception {
      this.receivedMessages.add(message);
    }
    @Override public void handleTransportError(    WebSocketSession session,    Throwable exception) throws Exception {
      this.transportError=exception;
    }
    public void awaitMessageCount(    final int count,    long timeToWait) throws Exception {
      awaitEvent(() -> receivedMessages.size() >= count,timeToWait,count + " number of messages. Received so far: " + this.receivedMessages);
    }
    public void awaitMessage(    TextMessage expected,    long timeToWait) throws InterruptedException {
      TextMessage actual=this.receivedMessages.poll(timeToWait,TimeUnit.MILLISECONDS);
      if (actual != null) {
        assertEquals(expected,actual);
      }
 else       if (this.transportError != null) {
        throw new AssertionError("Transport error",this.transportError);
      }
 else {
        fail("Timed out waiting for [" + expected + "]");
      }
    }
  }
private static class EchoHandler extends TextWebSocketHandler {
    @Override protected void handleTextMessage(    WebSocketSession session,    TextMessage message) throws Exception {
      session.sendMessage(message);
    }
  }
private static class TestServerHandler extends TextWebSocketHandler {
    private WebSocketSession session;
    @Override public void afterConnectionEstablished(    WebSocketSession session) throws Exception {
      this.session=session;
    }
    public WebSocketSession awaitSession(    long timeToWait) throws InterruptedException {
      awaitEvent(() -> this.session != null,timeToWait," session");
      return this.session;
    }
  }
private static class TestFilter implements Filter {
    private final Map<String,HttpHeaders> requests=new HashMap<>();
    private final Map<String,Long> sleepDelayMap=new HashMap<>();
    private final Map<String,Integer> sendErrorMap=new HashMap<>();
    @Override public void doFilter(    ServletRequest request,    ServletResponse response,    FilterChain chain) throws IOException, ServletException {
      HttpServletRequest httpRequest=(HttpServletRequest)request;
      String uri=httpRequest.getRequestURI();
      HttpHeaders headers=new ServletServerHttpRequest(httpRequest).getHeaders();
      this.requests.put(uri,headers);
      for (      String suffix : this.sleepDelayMap.keySet()) {
        if ((httpRequest).getRequestURI().endsWith(suffix)) {
          try {
            Thread.sleep(this.sleepDelayMap.get(suffix));
            break;
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
      for (      String suffix : this.sendErrorMap.keySet()) {
        if ((httpRequest).getRequestURI().endsWith(suffix)) {
          ((HttpServletResponse)response).sendError(this.sendErrorMap.get(suffix));
          return;
        }
      }
      chain.doFilter(request,response);
    }
    @Override public void init(    FilterConfig filterConfig){
    }
    @Override public void destroy(){
    }
  }
}
