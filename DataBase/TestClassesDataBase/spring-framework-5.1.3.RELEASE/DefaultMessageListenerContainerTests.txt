/** 
 * @author Stephane Nicoll
 */
public class DefaultMessageListenerContainerTests {
  @Test public void applyBackOff(){
    BackOff backOff=mock(BackOff.class);
    BackOffExecution execution=mock(BackOffExecution.class);
    given(execution.nextBackOff()).willReturn(BackOffExecution.STOP);
    given(backOff.start()).willReturn(execution);
    DefaultMessageListenerContainer container=createContainer(createFailingContainerFactory());
    container.setBackOff(backOff);
    container.start();
    assertEquals(true,container.isRunning());
    container.refreshConnectionUntilSuccessful();
    assertEquals(false,container.isRunning());
    verify(backOff).start();
    verify(execution).nextBackOff();
  }
  @Test public void applyBackOffRetry(){
    BackOff backOff=mock(BackOff.class);
    BackOffExecution execution=mock(BackOffExecution.class);
    given(execution.nextBackOff()).willReturn(50L,BackOffExecution.STOP);
    given(backOff.start()).willReturn(execution);
    DefaultMessageListenerContainer container=createContainer(createFailingContainerFactory());
    container.setBackOff(backOff);
    container.start();
    container.refreshConnectionUntilSuccessful();
    assertEquals(false,container.isRunning());
    verify(backOff).start();
    verify(execution,times(2)).nextBackOff();
  }
  @Test public void recoverResetBackOff(){
    BackOff backOff=mock(BackOff.class);
    BackOffExecution execution=mock(BackOffExecution.class);
    given(execution.nextBackOff()).willReturn(50L,50L,50L);
    given(backOff.start()).willReturn(execution);
    DefaultMessageListenerContainer container=createContainer(createRecoverableContainerFactory(1));
    container.setBackOff(backOff);
    container.start();
    container.refreshConnectionUntilSuccessful();
    assertEquals(true,container.isRunning());
    verify(backOff).start();
    verify(execution,times(1)).nextBackOff();
  }
  @Test public void runnableIsInvokedEvenIfContainerIsNotRunning() throws InterruptedException {
    DefaultMessageListenerContainer container=createRunningContainer();
    container.stop();
    TestRunnable runnable2=new TestRunnable();
    container.stop(runnable2);
    runnable2.waitForCompletion();
  }
  private DefaultMessageListenerContainer createRunningContainer(){
    DefaultMessageListenerContainer container=createContainer(createSuccessfulConnectionFactory());
    container.afterPropertiesSet();
    container.start();
    return container;
  }
  private DefaultMessageListenerContainer createContainer(  ConnectionFactory connectionFactory){
    Destination destination=new Destination(){
    }
;
    DefaultMessageListenerContainer container=new DefaultMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    container.setCacheLevel(DefaultMessageListenerContainer.CACHE_NONE);
    container.setDestination(destination);
    return container;
  }
  private ConnectionFactory createFailingContainerFactory(){
    try {
      ConnectionFactory connectionFactory=mock(ConnectionFactory.class);
      given(connectionFactory.createConnection()).will(invocation -> {
        throw new JMSException("Test exception");
      }
);
      return connectionFactory;
    }
 catch (    JMSException ex) {
      throw new IllegalStateException(ex);
    }
  }
  private ConnectionFactory createRecoverableContainerFactory(  final int failingAttempts){
    try {
      ConnectionFactory connectionFactory=mock(ConnectionFactory.class);
      given(connectionFactory.createConnection()).will(new Answer<Object>(){
        int currentAttempts=0;
        @Override public Object answer(        InvocationOnMock invocation) throws Throwable {
          currentAttempts++;
          if (currentAttempts <= failingAttempts) {
            throw new JMSException("Test exception (attempt " + currentAttempts + ")");
          }
 else {
            return mock(Connection.class);
          }
        }
      }
);
      return connectionFactory;
    }
 catch (    JMSException ex) {
      throw new IllegalStateException(ex);
    }
  }
  private ConnectionFactory createSuccessfulConnectionFactory(){
    try {
      ConnectionFactory connectionFactory=mock(ConnectionFactory.class);
      given(connectionFactory.createConnection()).willReturn(mock(Connection.class));
      return connectionFactory;
    }
 catch (    JMSException ex) {
      throw new IllegalStateException(ex);
    }
  }
private static class TestRunnable implements Runnable {
    private final CountDownLatch countDownLatch=new CountDownLatch(1);
    @Override public void run(){
      this.countDownLatch.countDown();
    }
    public void waitForCompletion() throws InterruptedException {
      this.countDownLatch.await(2,TimeUnit.SECONDS);
      assertEquals("callback was not invoked",0,this.countDownLatch.getCount());
    }
  }
}
