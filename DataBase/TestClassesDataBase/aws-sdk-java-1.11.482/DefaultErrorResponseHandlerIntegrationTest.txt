public class DefaultErrorResponseHandlerIntegrationTest extends WireMockTestBase {
  private static final String RESOURCE="/some-path";
  private LogCaptor logCaptor=new LogCaptor.DefaultLogCaptor(Level.DEBUG);
  private final AmazonHttpClient client=new AmazonHttpClient(new ClientConfiguration());
  private final DefaultErrorResponseHandler sut=new DefaultErrorResponseHandler(new ArrayList<Unmarshaller<AmazonServiceException,Node>>());
  @Before public void setUp(){
    logCaptor.clear();
  }
  @Test public void invocationIdIsCapturedInTheLog() throws Exception {
    stubFor(get(urlPathEqualTo(RESOURCE)).willReturn(aResponse().withStatus(418)));
    executeRequest();
    Matcher<Iterable<? super LoggingEvent>> matcher=hasItem(hasEventWithContent("Invocation Id"));
    assertThat(debugEvents(),matcher);
  }
  @Test public void invalidXmlLogsXmlContentToDebug() throws Exception {
    String content=RandomStringUtils.randomAlphanumeric(10);
    stubFor(get(urlPathEqualTo(RESOURCE)).willReturn(aResponse().withStatus(418).withBody(content)));
    executeRequest();
    Matcher<Iterable<? super LoggingEvent>> matcher=hasItem(hasEventWithContent(content));
    assertThat(debugEvents(),matcher);
  }
  @Test public void requestIdIsLoggedWithDebugIfInTheHeader() throws Exception {
    String requestId=RandomStringUtils.randomAlphanumeric(10);
    stubFor(get(urlPathEqualTo(RESOURCE)).willReturn(aResponse().withStatus(418).withHeader(X_AMZN_REQUEST_ID_HEADER,requestId)));
    executeRequest();
    Matcher<Iterable<? super LoggingEvent>> matcher=hasItem(hasEventWithContent(requestId));
    assertThat(debugEvents(),matcher);
  }
  private void executeRequest(){
    expectException(new Runnable(){
      @Override public void run(){
        client.requestExecutionBuilder().errorResponseHandler(sut).request(newGetRequest(RESOURCE)).execute();
      }
    }
);
  }
  @SuppressWarnings("EmptyCatchBlock") private void expectException(  Runnable r){
    try {
      r.run();
      throw new RuntimeException("Expected exception, got none");
    }
 catch (    Exception e) {
    }
  }
  private List<LoggingEvent> debugEvents(){
    List<LoggingEvent> events=new ArrayList<LoggingEvent>();
    List<LoggingEvent> loggingEvents=logCaptor.loggedEvents();
    for (    LoggingEvent le : loggingEvents) {
      if (le.getLevel().equals(Level.DEBUG)) {
        events.add(le);
      }
    }
    return events;
  }
  private org.hamcrest.Matcher<? super LoggingEvent> hasEventWithContent(  String content){
    return hasProperty("message",containsString(content));
  }
}
