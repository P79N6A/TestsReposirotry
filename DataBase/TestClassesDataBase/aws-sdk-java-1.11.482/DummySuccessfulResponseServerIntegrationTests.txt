public class DummySuccessfulResponseServerIntegrationTests extends MockServerTestBase {
  private static final int STATUS_CODE=200;
  private AmazonHttpClient httpClient;
  @BeforeClass public static void preConditions(){
    TestPreConditions.assumeNotJava6();
  }
  @Override protected MockServer buildMockServer(){
    return new MockServer(MockServer.DummyResponseServerBehavior.build(STATUS_CODE,"OK","Hi"));
  }
  @Test(timeout=TEST_TIMEOUT,expected=ClientExecutionTimeoutException.class) public void clientExecutionTimeoutEnabled_SlowResponseHandler_ThrowsClientExecutionTimeoutException() throws Exception {
    httpClient=new AmazonHttpClient(new ClientConfiguration().withClientExecutionTimeout(CLIENT_EXECUTION_TIMEOUT));
    requestBuilder().execute(new UnresponsiveResponseHandler());
  }
  @Test(timeout=TEST_TIMEOUT,expected=ClientExecutionTimeoutException.class) public void clientExecutionTimeoutEnabled_SlowAfterResponseRequestHandler_ThrowsClientExecutionTimeoutException() throws Exception {
    httpClient=new AmazonHttpClient(new ClientConfiguration().withClientExecutionTimeout(CLIENT_EXECUTION_TIMEOUT));
    List<RequestHandler2> requestHandlers=RequestHandlerTestUtils.buildRequestHandlerList(new SlowRequestHandler().withAfterResponseWaitInSeconds(SLOW_REQUEST_HANDLER_TIMEOUT));
    requestBuilder().executionContext(withHandlers(requestHandlers)).execute(new DummyResponseHandler());
  }
  @Test(timeout=TEST_TIMEOUT,expected=ClientExecutionTimeoutException.class) public void clientExecutionTimeoutEnabled_SlowBeforeRequestRequestHandler_ThrowsClientExecutionTimeoutException() throws Exception {
    httpClient=new AmazonHttpClient(new ClientConfiguration().withClientExecutionTimeout(CLIENT_EXECUTION_TIMEOUT));
    List<RequestHandler2> requestHandlers=RequestHandlerTestUtils.buildRequestHandlerList(new SlowRequestHandler().withBeforeRequestWaitInSeconds(SLOW_REQUEST_HANDLER_TIMEOUT));
    requestBuilder().executionContext(withHandlers(requestHandlers)).execute(new DummyResponseHandler());
  }
  /** 
 * Tests that a streaming operation has it's request properly cleaned up if the client is interrupted after the response is received.
 * @see TT0070103230
 */
  @Test public void clientInterruptedDuringResponseHandlers_DoesNotLeakConnection() throws IOException {
    ClientConfiguration config=new ClientConfiguration();
    ConnectionManagerAwareHttpClient rawHttpClient=new ApacheHttpClientFactory().create(HttpClientSettings.adapt(config));
    httpClient=new AmazonHttpClient(config,rawHttpClient,null);
    interruptCurrentThreadAfterDelay(1000);
    List<RequestHandler2> requestHandlers=RequestHandlerTestUtils.buildRequestHandlerList(new SlowRequestHandler().withAfterResponseWaitInSeconds(10));
    try {
      requestBuilder().executionContext(withHandlers(requestHandlers)).execute(new DummyResponseHandler().leaveConnectionOpen());
      fail("Expected exception");
    }
 catch (    AmazonClientException e) {
      assertThat(e.getCause(),instanceOf(InterruptedException.class));
    }
    @SuppressWarnings("deprecation") int leasedConnections=((ConnPoolControl<?>)((SdkHttpClient)rawHttpClient).getHttpClientConnectionManager()).getTotalStats().getLeased();
    assertEquals(0,leasedConnections);
  }
  private AmazonHttpClient.RequestExecutionBuilder requestBuilder(){
    return httpClient.requestExecutionBuilder().request(newGetRequest());
  }
  private ExecutionContext withHandlers(  List<RequestHandler2> requestHandlers){
    return ExecutionContext.builder().withRequestHandler2s(requestHandlers).build();
  }
}
