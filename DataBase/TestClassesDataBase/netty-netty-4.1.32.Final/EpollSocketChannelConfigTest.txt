public class EpollSocketChannelConfigTest {
  private static EventLoopGroup group;
  private static EpollSocketChannel ch;
  private static Random rand;
  @BeforeClass public static void beforeClass(){
    rand=new Random();
    group=new EpollEventLoopGroup(1);
  }
  @AfterClass public static void afterClass(){
    group.shutdownGracefully();
  }
  @Before public void setup(){
    Bootstrap bootstrap=new Bootstrap();
    ch=(EpollSocketChannel)bootstrap.group(group).channel(EpollSocketChannel.class).handler(new ChannelInboundHandlerAdapter()).bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
  }
  @After public void teardown(){
    ch.close().syncUninterruptibly();
  }
  private static long randLong(  long min,  long max){
    return min + nextLong(max - min + 1);
  }
  private static long nextLong(  long n){
    long bits, val;
    do {
      bits=(rand.nextLong() << 1) >>> 1;
      val=bits % n;
    }
 while (bits - val + (n - 1) < 0L);
    return val;
  }
  @Test public void testRandomTcpNotSentLowAt(){
    final long expected=randLong(0,0xFFFFFFFFL);
    final long actual;
    try {
      ch.config().setTcpNotSentLowAt(expected);
      actual=ch.config().getTcpNotSentLowAt();
    }
 catch (    RuntimeException e) {
      assumeNoException(e);
      return;
    }
    assertEquals(expected,actual);
  }
  @Test public void testInvalidHighTcpNotSentLowAt(){
    try {
      final long value=0xFFFFFFFFL + 1;
      ch.config().setTcpNotSentLowAt(value);
    }
 catch (    IllegalArgumentException e) {
      return;
    }
catch (    RuntimeException e) {
      assumeNoException(e);
    }
    fail();
  }
  @Test public void testInvalidLowTcpNotSentLowAt(){
    try {
      final long value=-1;
      ch.config().setTcpNotSentLowAt(value);
    }
 catch (    IllegalArgumentException e) {
      return;
    }
catch (    RuntimeException e) {
      assumeNoException(e);
    }
    fail();
  }
  @Test public void testTcpCork(){
    ch.config().setTcpCork(false);
    assertFalse(ch.config().isTcpCork());
    ch.config().setTcpCork(true);
    assertTrue(ch.config().isTcpCork());
  }
  @Test public void testTcpQickAck(){
    ch.config().setTcpQuickAck(false);
    assertFalse(ch.config().isTcpQuickAck());
    ch.config().setTcpQuickAck(true);
    assertTrue(ch.config().isTcpQuickAck());
  }
  @Test public void testSetOptionWhenClosed(){
    ch.close().syncUninterruptibly();
    try {
      ch.config().setSoLinger(0);
      fail();
    }
 catch (    ChannelException e) {
      assertTrue(e.getCause() instanceof ClosedChannelException);
    }
  }
  @Test public void testGetOptionWhenClosed(){
    ch.close().syncUninterruptibly();
    try {
      ch.config().getSoLinger();
      fail();
    }
 catch (    ChannelException e) {
      assertTrue(e.getCause() instanceof ClosedChannelException);
    }
  }
  @Test public void getGetOptions(){
    Map<ChannelOption<?>,Object> map=ch.config().getOptions();
    assertFalse(map.isEmpty());
  }
}
