public class ThreadPerChannelEventLoopGroupTest {
  private static final ChannelHandler NOOP_HANDLER=new ChannelHandlerAdapter(){
    @Override public boolean isSharable(){
      return true;
    }
  }
;
  @Test public void testTerminationFutureSuccessInLog() throws Exception {
    for (int i=0; i < 2; i++) {
      ThreadPerChannelEventLoopGroup loopGroup=new ThreadPerChannelEventLoopGroup(64);
      runTest(loopGroup);
    }
  }
  @Test public void testTerminationFutureSuccessReflectively() throws Exception {
    Field terminationFutureField=ThreadPerChannelEventLoopGroup.class.getDeclaredField("terminationFuture");
    terminationFutureField.setAccessible(true);
    final Exception[] exceptionHolder=new Exception[1];
    for (int i=0; i < 2; i++) {
      ThreadPerChannelEventLoopGroup loopGroup=new ThreadPerChannelEventLoopGroup(64);
      Promise<?> promise=new DefaultPromise<Void>(GlobalEventExecutor.INSTANCE){
        @Override public Promise<Void> setSuccess(        Void result){
          try {
            return super.setSuccess(result);
          }
 catch (          IllegalStateException e) {
            exceptionHolder[0]=e;
            throw e;
          }
        }
      }
;
      terminationFutureField.set(loopGroup,promise);
      runTest(loopGroup);
    }
    GlobalEventExecutor.INSTANCE.awaitTermination(100,TimeUnit.MILLISECONDS);
    assertNull(exceptionHolder[0]);
  }
  private static void runTest(  ThreadPerChannelEventLoopGroup loopGroup) throws InterruptedException {
    int taskCount=100;
    EventExecutor testExecutor=new TestEventExecutor();
    ChannelGroup channelGroup=new DefaultChannelGroup(testExecutor);
    while (taskCount-- > 0) {
      Channel channel=new EmbeddedChannel(NOOP_HANDLER);
      loopGroup.register(new DefaultChannelPromise(channel,testExecutor));
      channelGroup.add(channel);
    }
    channelGroup.close().sync();
    loopGroup.shutdownGracefully(100,200,TimeUnit.MILLISECONDS).sync();
    assertTrue(loopGroup.isTerminated());
  }
private static class TestEventExecutor extends SingleThreadEventExecutor {
    TestEventExecutor(){
      super(null,new DefaultThreadFactory("test"),false);
    }
    @Override protected void run(){
      for (; ; ) {
        Runnable task=takeTask();
        if (task != null) {
          task.run();
          updateLastExecutionTime();
        }
        if (confirmShutdown()) {
          break;
        }
      }
    }
  }
}
