public class IdleStateHandlerTest {
  @Test public void testReaderIdle() throws Exception {
    TestableIdleStateHandler idleStateHandler=new TestableIdleStateHandler(false,1L,0L,0L,TimeUnit.SECONDS);
    anyIdle(idleStateHandler,IdleStateEvent.FIRST_READER_IDLE_STATE_EVENT,IdleStateEvent.READER_IDLE_STATE_EVENT,IdleStateEvent.READER_IDLE_STATE_EVENT);
  }
  @Test public void testWriterIdle() throws Exception {
    TestableIdleStateHandler idleStateHandler=new TestableIdleStateHandler(false,0L,1L,0L,TimeUnit.SECONDS);
    anyIdle(idleStateHandler,IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT,IdleStateEvent.WRITER_IDLE_STATE_EVENT,IdleStateEvent.WRITER_IDLE_STATE_EVENT);
  }
  @Test public void testAllIdle() throws Exception {
    TestableIdleStateHandler idleStateHandler=new TestableIdleStateHandler(false,0L,0L,1L,TimeUnit.SECONDS);
    anyIdle(idleStateHandler,IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT,IdleStateEvent.ALL_IDLE_STATE_EVENT,IdleStateEvent.ALL_IDLE_STATE_EVENT);
  }
  private static void anyIdle(  TestableIdleStateHandler idleStateHandler,  Object... expected) throws Exception {
    assertTrue("The number of expected events must be >= 1",expected.length >= 1);
    final List<Object> events=new ArrayList<Object>();
    ChannelInboundHandlerAdapter handler=new ChannelInboundHandlerAdapter(){
      @Override public void userEventTriggered(      ChannelHandlerContext ctx,      Object evt) throws Exception {
        events.add(evt);
      }
    }
;
    EmbeddedChannel channel=new EmbeddedChannel(idleStateHandler,handler);
    try {
      for (int i=0; i < expected.length; i++) {
        idleStateHandler.tickRun();
      }
      assertEquals(expected.length,events.size());
      for (int i=0; i < expected.length; i++) {
        Object evt=events.get(i);
        assertSame("Element " + i + " is not matching",expected[i],evt);
      }
    }
  finally {
      channel.finishAndReleaseAll();
    }
  }
  @Test public void testReaderNotIdle() throws Exception {
    TestableIdleStateHandler idleStateHandler=new TestableIdleStateHandler(false,1L,0L,0L,TimeUnit.SECONDS);
    Action action=new Action(){
      @Override public void run(      EmbeddedChannel channel) throws Exception {
        channel.writeInbound("Hello, World!");
      }
    }
;
    anyNotIdle(idleStateHandler,action,IdleStateEvent.FIRST_READER_IDLE_STATE_EVENT);
  }
  @Test public void testWriterNotIdle() throws Exception {
    TestableIdleStateHandler idleStateHandler=new TestableIdleStateHandler(false,0L,1L,0L,TimeUnit.SECONDS);
    Action action=new Action(){
      @Override public void run(      EmbeddedChannel channel) throws Exception {
        channel.writeAndFlush("Hello, World!");
      }
    }
;
    anyNotIdle(idleStateHandler,action,IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT);
  }
  @Test public void testAllNotIdle() throws Exception {
    TestableIdleStateHandler idleStateHandler=new TestableIdleStateHandler(false,0L,0L,1L,TimeUnit.SECONDS);
    Action reader=new Action(){
      @Override public void run(      EmbeddedChannel channel) throws Exception {
        channel.writeInbound("Hello, World!");
      }
    }
;
    anyNotIdle(idleStateHandler,reader,IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);
    idleStateHandler=new TestableIdleStateHandler(false,0L,0L,1L,TimeUnit.SECONDS);
    Action writer=new Action(){
      @Override public void run(      EmbeddedChannel channel) throws Exception {
        channel.writeAndFlush("Hello, World!");
      }
    }
;
    anyNotIdle(idleStateHandler,writer,IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);
  }
  private static void anyNotIdle(  TestableIdleStateHandler idleStateHandler,  Action action,  Object expected) throws Exception {
    final List<Object> events=new ArrayList<Object>();
    ChannelInboundHandlerAdapter handler=new ChannelInboundHandlerAdapter(){
      @Override public void userEventTriggered(      ChannelHandlerContext ctx,      Object evt) throws Exception {
        events.add(evt);
      }
    }
;
    EmbeddedChannel channel=new EmbeddedChannel(idleStateHandler,handler);
    try {
      idleStateHandler.tick(1L,TimeUnit.NANOSECONDS);
      action.run(channel);
      long delayInNanos=idleStateHandler.delay(TimeUnit.NANOSECONDS);
      assertNotEquals(0L,delayInNanos);
      idleStateHandler.tickRun(delayInNanos / 2L,TimeUnit.NANOSECONDS);
      assertEquals(0,events.size());
      idleStateHandler.tickRun();
      assertEquals(1,events.size());
      assertSame(expected,events.get(0));
    }
  finally {
      channel.finishAndReleaseAll();
    }
  }
  @Test public void testObserveWriterIdle() throws Exception {
    observeOutputIdle(true);
  }
  @Test public void testObserveAllIdle() throws Exception {
    observeOutputIdle(false);
  }
  private static void observeOutputIdle(  boolean writer) throws Exception {
    long writerIdleTime=0L;
    long allIdleTime=0L;
    IdleStateEvent expected;
    if (writer) {
      writerIdleTime=5L;
      expected=IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT;
    }
 else {
      allIdleTime=5L;
      expected=IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;
    }
    TestableIdleStateHandler idleStateHandler=new TestableIdleStateHandler(true,0L,writerIdleTime,allIdleTime,TimeUnit.SECONDS);
    final List<Object> events=new ArrayList<Object>();
    ChannelInboundHandlerAdapter handler=new ChannelInboundHandlerAdapter(){
      @Override public void userEventTriggered(      ChannelHandlerContext ctx,      Object evt) throws Exception {
        events.add(evt);
      }
    }
;
    ObservableChannel channel=new ObservableChannel(idleStateHandler,handler);
    try {
      channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[]{1}));
      channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[]{2}));
      channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[]{3}));
      idleStateHandler.tickRun();
      assertEquals(1,events.size());
      assertSame(expected,events.get(0));
      events.clear();
      assertEquals(5L,idleStateHandler.tick(TimeUnit.SECONDS));
      idleStateHandler.tick(4L,TimeUnit.SECONDS);
      assertNotNullAndRelease(channel.consume());
      idleStateHandler.tickRun(2L,TimeUnit.SECONDS);
      assertEquals(0,events.size());
      assertEquals(11L,idleStateHandler.tick(TimeUnit.SECONDS));
      idleStateHandler.tick(3L,TimeUnit.SECONDS);
      assertNotNullAndRelease(channel.consume());
      idleStateHandler.tickRun(4L,TimeUnit.SECONDS);
      assertEquals(0,events.size());
      assertEquals(18L,idleStateHandler.tick(TimeUnit.SECONDS));
      idleStateHandler.tickRun(5L,TimeUnit.SECONDS);
      assertEquals(1,events.size());
      assertEquals(23L,idleStateHandler.tick(TimeUnit.SECONDS));
      events.clear();
      idleStateHandler.tick(2L,TimeUnit.SECONDS);
      assertNotNullAndRelease(channel.consume());
      idleStateHandler.tickRun(1L,TimeUnit.SECONDS);
      assertEquals(0,events.size());
      assertEquals(26L,idleStateHandler.tick(TimeUnit.SECONDS));
      idleStateHandler.tick(3L,TimeUnit.SECONDS);
      assertNull(channel.consume());
      idleStateHandler.tickRun(2L,TimeUnit.SECONDS);
      assertEquals(1,events.size());
      assertEquals(31L,idleStateHandler.tick(TimeUnit.SECONDS));
    }
  finally {
      channel.finishAndReleaseAll();
    }
  }
  private static void assertNotNullAndRelease(  Object msg){
    assertNotNull(msg);
    ReferenceCountUtil.release(msg);
  }
private interface Action {
    void run(    EmbeddedChannel channel) throws Exception ;
  }
private static class TestableIdleStateHandler extends IdleStateHandler {
    private Runnable task;
    private long delayInNanos;
    private long ticksInNanos;
    public TestableIdleStateHandler(    boolean observeOutput,    long readerIdleTime,    long writerIdleTime,    long allIdleTime,    TimeUnit unit){
      super(observeOutput,readerIdleTime,writerIdleTime,allIdleTime,unit);
    }
    public long delay(    TimeUnit unit){
      return unit.convert(delayInNanos,TimeUnit.NANOSECONDS);
    }
    public void run(){
      task.run();
    }
    public void tickRun(){
      tickRun(delayInNanos,TimeUnit.NANOSECONDS);
    }
    public void tickRun(    long delay,    TimeUnit unit){
      tick(delay,unit);
      run();
    }
    /** 
 * Advances the current ticker by the given amount.
 */
    public void tick(    long delay,    TimeUnit unit){
      ticksInNanos+=unit.toNanos(delay);
    }
    /** 
 * Returns  {@link #ticksInNanos()} in the given {@link TimeUnit}.
 */
    public long tick(    TimeUnit unit){
      return unit.convert(ticksInNanos(),TimeUnit.NANOSECONDS);
    }
    @Override long ticksInNanos(){
      return ticksInNanos;
    }
    @Override ScheduledFuture<?> schedule(    ChannelHandlerContext ctx,    Runnable task,    long delay,    TimeUnit unit){
      this.task=task;
      this.delayInNanos=unit.toNanos(delay);
      return null;
    }
  }
private static class ObservableChannel extends EmbeddedChannel {
    public ObservableChannel(    ChannelHandler... handlers){
      super(handlers);
    }
    @Override protected void doWrite(    ChannelOutboundBuffer in) throws Exception {
    }
    public Object consume(){
      ChannelOutboundBuffer buf=unsafe().outboundBuffer();
      if (buf != null) {
        Object msg=buf.current();
        if (msg != null) {
          ReferenceCountUtil.retain(msg);
          buf.remove();
          return msg;
        }
      }
      return null;
    }
  }
}
