public abstract class RenegotiateTest {
  @Test(timeout=30000) public void testRenegotiateServer() throws Throwable {
    final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    final CountDownLatch latch=new CountDownLatch(2);
    SelfSignedCertificate cert=new SelfSignedCertificate();
    EventLoopGroup group=new LocalEventLoopGroup();
    try {
      final SslContext context=SslContextBuilder.forServer(cert.key(),cert.cert()).sslProvider(serverSslProvider()).build();
      ServerBootstrap sb=new ServerBootstrap();
      sb.group(group).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(context.newHandler(ch.alloc()));
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            private boolean renegotiate;
            @Override public void channelRead(            ChannelHandlerContext ctx,            Object msg) throws Exception {
              ReferenceCountUtil.release(msg);
            }
            @Override public void userEventTriggered(            final ChannelHandlerContext ctx,            Object evt) throws Exception {
              if (!renegotiate && evt instanceof SslHandshakeCompletionEvent) {
                SslHandshakeCompletionEvent event=(SslHandshakeCompletionEvent)evt;
                if (event.isSuccess()) {
                  final SslHandler handler=ctx.pipeline().get(SslHandler.class);
                  renegotiate=true;
                  handler.renegotiate().addListener(new FutureListener<Channel>(){
                    @Override public void operationComplete(                    Future<Channel> future) throws Exception {
                      if (!future.isSuccess()) {
                        error.compareAndSet(null,future.cause());
                        latch.countDown();
                        ctx.close();
                      }
                    }
                  }
);
                }
 else {
                  error.compareAndSet(null,event.cause());
                  latch.countDown();
                  ctx.close();
                }
              }
            }
          }
);
        }
      }
);
      Channel channel=sb.bind(new LocalAddress("test")).syncUninterruptibly().channel();
      final SslContext clientContext=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).sslProvider(SslProvider.JDK).build();
      Bootstrap bootstrap=new Bootstrap();
      bootstrap.group(group).channel(LocalChannel.class).handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(clientContext.newHandler(ch.alloc()));
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void userEventTriggered(            ChannelHandlerContext ctx,            Object evt) throws Exception {
              if (evt instanceof SslHandshakeCompletionEvent) {
                SslHandshakeCompletionEvent event=(SslHandshakeCompletionEvent)evt;
                if (!event.isSuccess()) {
                  error.compareAndSet(null,event.cause());
                  ctx.close();
                }
                latch.countDown();
              }
            }
          }
);
        }
      }
);
      Channel clientChannel=bootstrap.connect(channel.localAddress()).syncUninterruptibly().channel();
      latch.await();
      clientChannel.close().syncUninterruptibly();
      channel.close().syncUninterruptibly();
      verifyResult(error);
    }
  finally {
      group.shutdownGracefully();
    }
  }
  protected abstract SslProvider serverSslProvider();
  protected void verifyResult(  AtomicReference<Throwable> error) throws Throwable {
    Throwable cause=error.get();
    if (cause != null) {
      throw cause;
    }
  }
}
