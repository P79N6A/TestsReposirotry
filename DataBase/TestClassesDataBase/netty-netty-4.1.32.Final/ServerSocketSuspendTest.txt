public class ServerSocketSuspendTest extends AbstractServerSocketTest {
  private static final int NUM_CHANNELS=10;
  private static final long TIMEOUT=3000000000L;
  @Test @Ignore("Need to investigate why it fails on osx") public void testSuspendAndResumeAccept() throws Throwable {
    run();
  }
  public void testSuspendAndResumeAccept(  ServerBootstrap sb) throws Throwable {
    AcceptedChannelCounter counter=new AcceptedChannelCounter(NUM_CHANNELS);
    sb.option(ChannelOption.SO_BACKLOG,1);
    sb.option(ChannelOption.AUTO_READ,false);
    sb.childHandler(counter);
    Channel sc=sb.bind().sync().channel();
    List<Socket> sockets=new ArrayList<Socket>();
    try {
      long startTime=System.nanoTime();
      for (int i=0; i < NUM_CHANNELS; i++) {
        Socket s=new Socket();
        SocketUtils.connect(s,sc.localAddress(),10000);
        sockets.add(s);
      }
      sc.config().setAutoRead(true);
      counter.latch.await();
      long endTime=System.nanoTime();
      assertTrue(endTime - startTime > TIMEOUT);
    }
  finally {
      for (      Socket s : sockets) {
        s.close();
      }
    }
    Thread.sleep(TIMEOUT / 1000000);
    try {
      long startTime=System.nanoTime();
      for (int i=0; i < NUM_CHANNELS; i++) {
        Socket s=new Socket();
        s.connect(sc.localAddress(),10000);
        sockets.add(s);
      }
      long endTime=System.nanoTime();
      assertTrue(endTime - startTime < TIMEOUT);
    }
  finally {
      for (      Socket s : sockets) {
        s.close();
      }
    }
  }
@ChannelHandler.Sharable private static final class AcceptedChannelCounter extends ChannelInboundHandlerAdapter {
    final CountDownLatch latch;
    AcceptedChannelCounter(    int nChannels){
      latch=new CountDownLatch(nChannels);
    }
    @Override public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      latch.countDown();
    }
  }
}
