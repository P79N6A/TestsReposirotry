public class DatagramMulticastTest extends AbstractDatagramTest {
  @Test public void testMulticast() throws Throwable {
    run();
  }
  public void testMulticast(  Bootstrap sb,  Bootstrap cb) throws Throwable {
    MulticastTestHandler mhandler=new MulticastTestHandler();
    sb.handler(new SimpleChannelInboundHandler<Object>(){
      @Override public void channelRead0(      ChannelHandlerContext ctx,      Object msg) throws Exception {
      }
    }
);
    cb.handler(mhandler);
    sb.option(ChannelOption.IP_MULTICAST_IF,NetUtil.LOOPBACK_IF);
    sb.option(ChannelOption.SO_REUSEADDR,true);
    cb.option(ChannelOption.IP_MULTICAST_IF,NetUtil.LOOPBACK_IF);
    cb.option(ChannelOption.SO_REUSEADDR,true);
    Channel sc=sb.bind(newSocketAddress()).sync().channel();
    InetSocketAddress addr=(InetSocketAddress)sc.localAddress();
    cb.localAddress(addr.getPort());
    if (sc instanceof OioDatagramChannel) {
      sc.close().awaitUninterruptibly();
      return;
    }
    DatagramChannel cc=(DatagramChannel)cb.bind().sync().channel();
    String group="230.0.0.1";
    InetSocketAddress groupAddress=SocketUtils.socketAddress(group,addr.getPort());
    cc.joinGroup(groupAddress,NetUtil.LOOPBACK_IF).sync();
    sc.writeAndFlush(new DatagramPacket(Unpooled.copyInt(1),groupAddress)).sync();
    assertTrue(mhandler.await());
    cc.leaveGroup(groupAddress,NetUtil.LOOPBACK_IF).sync();
    Thread.sleep(1000);
    sc.writeAndFlush(new DatagramPacket(Unpooled.copyInt(1),groupAddress)).sync();
    mhandler.await();
    sc.close().awaitUninterruptibly();
    cc.close().awaitUninterruptibly();
  }
private static final class MulticastTestHandler extends SimpleChannelInboundHandler<DatagramPacket> {
    private final CountDownLatch latch=new CountDownLatch(1);
    private boolean done;
    private volatile boolean fail;
    @Override protected void channelRead0(    ChannelHandlerContext ctx,    DatagramPacket msg) throws Exception {
      if (done) {
        fail=true;
      }
      assertEquals(1,msg.content().readInt());
      latch.countDown();
      done=true;
    }
    public boolean await() throws Exception {
      boolean success=latch.await(10,TimeUnit.SECONDS);
      if (fail) {
        fail();
      }
      return success;
    }
  }
}
