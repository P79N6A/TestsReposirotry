public class WebSocketServerProtocolHandlerTest {
  private final Queue<FullHttpResponse> responses=new ArrayDeque<FullHttpResponse>();
  @Before public void setUp(){
    responses.clear();
  }
  @Test public void testHttpUpgradeRequest() throws Exception {
    EmbeddedChannel ch=createChannel(new MockOutboundHandler());
    ChannelHandlerContext handshakerCtx=ch.pipeline().context(WebSocketServerProtocolHandshakeHandler.class);
    writeUpgradeRequest(ch);
    FullHttpResponse response=responses.remove();
    assertEquals(SWITCHING_PROTOCOLS,response.status());
    response.release();
    assertNotNull(WebSocketServerProtocolHandler.getHandshaker(handshakerCtx.channel()));
  }
  @Test public void testSubsequentHttpRequestsAfterUpgradeShouldReturn403() throws Exception {
    EmbeddedChannel ch=createChannel();
    writeUpgradeRequest(ch);
    FullHttpResponse response=responses.remove();
    assertEquals(SWITCHING_PROTOCOLS,response.status());
    response.release();
    ch.writeInbound(new DefaultFullHttpRequest(HTTP_1_1,HttpMethod.GET,"/test"));
    response=responses.remove();
    assertEquals(FORBIDDEN,response.status());
    response.release();
  }
  @Test public void testHttpUpgradeRequestInvalidUpgradeHeader(){
    EmbeddedChannel ch=createChannel();
    FullHttpRequest httpRequestWithEntity=new WebSocketRequestBuilder().httpVersion(HTTP_1_1).method(HttpMethod.GET).uri("/test").connection("Upgrade").version00().upgrade("BogusSocket").build();
    ch.writeInbound(httpRequestWithEntity);
    FullHttpResponse response=responses.remove();
    assertEquals(BAD_REQUEST,response.status());
    assertEquals("not a WebSocket handshake request: missing upgrade",getResponseMessage(response));
    response.release();
  }
  @Test public void testHttpUpgradeRequestMissingWSKeyHeader(){
    EmbeddedChannel ch=createChannel();
    HttpRequest httpRequest=new WebSocketRequestBuilder().httpVersion(HTTP_1_1).method(HttpMethod.GET).uri("/test").key(null).connection("Upgrade").upgrade(HttpHeaderValues.WEBSOCKET).version13().build();
    ch.writeInbound(httpRequest);
    FullHttpResponse response=responses.remove();
    assertEquals(BAD_REQUEST,response.status());
    assertEquals("not a WebSocket request: missing key",getResponseMessage(response));
    response.release();
  }
  @Test public void testHandleTextFrame(){
    CustomTextFrameHandler customTextFrameHandler=new CustomTextFrameHandler();
    EmbeddedChannel ch=createChannel(customTextFrameHandler);
    writeUpgradeRequest(ch);
    if (ch.pipeline().context(HttpRequestDecoder.class) != null) {
      ch.pipeline().remove(HttpRequestDecoder.class);
    }
    ch.writeInbound(new TextWebSocketFrame("payload"));
    assertEquals("processed: payload",customTextFrameHandler.getContent());
  }
  private EmbeddedChannel createChannel(){
    return createChannel(null);
  }
  private EmbeddedChannel createChannel(  ChannelHandler handler){
    return new EmbeddedChannel(new WebSocketServerProtocolHandler("/test",null,false),new HttpRequestDecoder(),new HttpResponseEncoder(),new MockOutboundHandler(),handler);
  }
  private static void writeUpgradeRequest(  EmbeddedChannel ch){
    ch.writeInbound(WebSocketRequestBuilder.successful());
  }
  private static String getResponseMessage(  FullHttpResponse response){
    return new String(response.content().array());
  }
private class MockOutboundHandler extends ChannelOutboundHandlerAdapter {
    @Override public void write(    ChannelHandlerContext ctx,    Object msg,    ChannelPromise promise) throws Exception {
      responses.add((FullHttpResponse)msg);
      promise.setSuccess();
    }
    @Override public void flush(    ChannelHandlerContext ctx) throws Exception {
    }
  }
private static class CustomTextFrameHandler extends ChannelInboundHandlerAdapter {
    private String content;
    @Override public void channelRead(    ChannelHandlerContext ctx,    Object msg) throws Exception {
      assertNull(content);
      content="processed: " + ((TextWebSocketFrame)msg).text();
      ReferenceCountUtil.release(msg);
    }
    String getContent(){
      return content;
    }
  }
}
