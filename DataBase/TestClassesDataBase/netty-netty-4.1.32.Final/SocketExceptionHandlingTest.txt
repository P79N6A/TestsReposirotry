public class SocketExceptionHandlingTest extends AbstractSocketTest {
  @Test public void testReadPendingIsResetAfterEachRead() throws Throwable {
    run();
  }
  public void testReadPendingIsResetAfterEachRead(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    Channel serverChannel=null;
    Channel clientChannel=null;
    try {
      MyInitializer serverInitializer=new MyInitializer();
      sb.option(ChannelOption.SO_BACKLOG,1024);
      sb.childHandler(serverInitializer);
      serverChannel=sb.bind().syncUninterruptibly().channel();
      cb.handler(new MyInitializer());
      clientChannel=cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      clientChannel.writeAndFlush(Unpooled.wrappedBuffer(new byte[1024]));
      assertTrue(serverInitializer.exceptionHandler.latch1.await(5,TimeUnit.SECONDS));
      assertFalse("Encountered " + serverInitializer.exceptionHandler.count.get() + " exceptions when 1 was expected",serverInitializer.exceptionHandler.latch2.await(1,TimeUnit.SECONDS));
    }
  finally {
      if (serverChannel != null) {
        serverChannel.close().syncUninterruptibly();
      }
      if (clientChannel != null) {
        clientChannel.close().syncUninterruptibly();
      }
    }
  }
private static class MyInitializer extends ChannelInitializer<Channel> {
    final ExceptionHandler exceptionHandler=new ExceptionHandler();
    @Override protected void initChannel(    Channel ch) throws Exception {
      ChannelPipeline pipeline=ch.pipeline();
      pipeline.addLast(new BuggyChannelHandler());
      pipeline.addLast(exceptionHandler);
    }
  }
private static class BuggyChannelHandler extends ChannelInboundHandlerAdapter {
    @Override public void channelRead(    ChannelHandlerContext ctx,    Object msg) throws Exception {
      ReferenceCountUtil.release(msg);
      throw new NullPointerException("I am a bug!");
    }
  }
private static class ExceptionHandler extends ChannelInboundHandlerAdapter {
    final AtomicLong count=new AtomicLong();
    /** 
 * We expect to get 1 call to  {@link #exceptionCaught(ChannelHandlerContext,Throwable)}.
 */
    final CountDownLatch latch1=new CountDownLatch(1);
    final CountDownLatch latch2=new CountDownLatch(1);
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      if (count.incrementAndGet() <= 2) {
        latch1.countDown();
      }
 else {
        latch2.countDown();
      }
      ctx.close();
    }
  }
}
