public class SocketShutdownOutputByPeerTest extends AbstractServerSocketTest {
  @Test(timeout=30000) public void testShutdownOutput() throws Throwable {
    run();
  }
  public void testShutdownOutput(  ServerBootstrap sb) throws Throwable {
    TestHandler h=new TestHandler();
    Socket s=new Socket();
    Channel sc=null;
    try {
      sc=sb.childHandler(h).childOption(ChannelOption.ALLOW_HALF_CLOSURE,true).bind().sync().channel();
      SocketUtils.connect(s,sc.localAddress(),10000);
      s.getOutputStream().write(1);
      assertEquals(1,(int)h.queue.take());
      assertTrue(h.ch.isOpen());
      assertTrue(h.ch.isActive());
      assertFalse(h.ch.isInputShutdown());
      assertFalse(h.ch.isOutputShutdown());
      s.shutdownOutput();
      h.halfClosure.await();
      assertTrue(h.ch.isOpen());
      assertTrue(h.ch.isActive());
      assertTrue(h.ch.isInputShutdown());
      assertFalse(h.ch.isOutputShutdown());
      assertEquals(1,h.closure.getCount());
      Thread.sleep(100);
      assertEquals(1,h.halfClosureCount.intValue());
    }
  finally {
      if (sc != null) {
        sc.close();
      }
      s.close();
    }
  }
  @Test(timeout=30000) public void testShutdownOutputWithoutOption() throws Throwable {
    run();
  }
  public void testShutdownOutputWithoutOption(  ServerBootstrap sb) throws Throwable {
    TestHandler h=new TestHandler();
    Socket s=new Socket();
    Channel sc=null;
    try {
      sc=sb.childHandler(h).bind().sync().channel();
      SocketUtils.connect(s,sc.localAddress(),10000);
      s.getOutputStream().write(1);
      assertEquals(1,(int)h.queue.take());
      assertTrue(h.ch.isOpen());
      assertTrue(h.ch.isActive());
      assertFalse(h.ch.isInputShutdown());
      assertFalse(h.ch.isOutputShutdown());
      s.shutdownOutput();
      h.closure.await();
      assertFalse(h.ch.isOpen());
      assertFalse(h.ch.isActive());
      assertTrue(h.ch.isInputShutdown());
      assertTrue(h.ch.isOutputShutdown());
      assertEquals(1,h.halfClosure.getCount());
      Thread.sleep(100);
      assertEquals(0,h.halfClosureCount.intValue());
    }
  finally {
      if (sc != null) {
        sc.close();
      }
      s.close();
    }
  }
private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
    volatile SocketChannel ch;
    final BlockingQueue<Byte> queue=new LinkedBlockingQueue<Byte>();
    final CountDownLatch halfClosure=new CountDownLatch(1);
    final CountDownLatch closure=new CountDownLatch(1);
    final AtomicInteger halfClosureCount=new AtomicInteger();
    @Override public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      ch=(SocketChannel)ctx.channel();
    }
    @Override public void channelInactive(    ChannelHandlerContext ctx) throws Exception {
      closure.countDown();
    }
    @Override public void channelRead0(    ChannelHandlerContext ctx,    ByteBuf msg) throws Exception {
      queue.offer(msg.readByte());
    }
    @Override public void userEventTriggered(    ChannelHandlerContext ctx,    Object evt) throws Exception {
      if (evt instanceof ChannelInputShutdownEvent) {
        halfClosureCount.incrementAndGet();
        halfClosure.countDown();
      }
    }
  }
}
