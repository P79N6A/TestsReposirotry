public class ByteToMessageDecoderTest {
  @Test public void testRemoveItself(){
    EmbeddedChannel channel=new EmbeddedChannel(new ByteToMessageDecoder(){
      private boolean removed;
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        assertFalse(removed);
        in.readByte();
        ctx.pipeline().remove(this);
        removed=true;
      }
    }
);
    ByteBuf buf=Unpooled.wrappedBuffer(new byte[]{'a','b','c'});
    channel.writeInbound(buf.copy());
    ByteBuf b=channel.readInbound();
    assertEquals(b,buf.skipBytes(1));
    b.release();
    buf.release();
  }
  @Test public void testRemoveItselfWriteBuffer(){
    final ByteBuf buf=Unpooled.buffer().writeBytes(new byte[]{'a','b','c'});
    EmbeddedChannel channel=new EmbeddedChannel(new ByteToMessageDecoder(){
      private boolean removed;
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        assertFalse(removed);
        in.readByte();
        ctx.pipeline().remove(this);
        buf.writeByte('d');
        removed=true;
      }
    }
);
    channel.writeInbound(buf.copy());
    ByteBuf expected=Unpooled.wrappedBuffer(new byte[]{'b','c'});
    ByteBuf b=channel.readInbound();
    assertEquals(expected,b);
    expected.release();
    buf.release();
    b.release();
  }
  /** 
 * Verifies that internal buffer of the ByteToMessageDecoder is released once decoder is removed from pipeline. In this case input is read fully.
 */
  @Test public void testInternalBufferClearReadAll(){
    final ByteBuf buf=Unpooled.buffer().writeBytes(new byte[]{'a'});
    EmbeddedChannel channel=newInternalBufferTestChannel();
    assertFalse(channel.writeInbound(buf));
    assertFalse(channel.finish());
  }
  /** 
 * Verifies that internal buffer of the ByteToMessageDecoder is released once decoder is removed from pipeline. In this case input was not fully read.
 */
  @Test public void testInternalBufferClearReadPartly(){
    final ByteBuf buf=Unpooled.buffer().writeBytes(new byte[]{'a','b'});
    EmbeddedChannel channel=newInternalBufferTestChannel();
    assertTrue(channel.writeInbound(buf));
    assertTrue(channel.finish());
    ByteBuf expected=Unpooled.wrappedBuffer(new byte[]{'b'});
    ByteBuf b=channel.readInbound();
    assertEquals(expected,b);
    assertNull(channel.readInbound());
    expected.release();
    b.release();
  }
  private EmbeddedChannel newInternalBufferTestChannel(){
    return new EmbeddedChannel(new ByteToMessageDecoder(){
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        ByteBuf byteBuf=internalBuffer();
        assertEquals(1,byteBuf.refCnt());
        in.readByte();
        ctx.pipeline().remove(this);
      }
      @Override protected void handlerRemoved0(      ChannelHandlerContext ctx) throws Exception {
        assertCumulationReleased(internalBuffer());
      }
    }
);
  }
  @Test public void handlerRemovedWillNotReleaseBufferIfDecodeInProgress(){
    EmbeddedChannel channel=new EmbeddedChannel(new ByteToMessageDecoder(){
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        ctx.pipeline().remove(this);
        assertTrue(in.refCnt() != 0);
      }
      @Override protected void handlerRemoved0(      ChannelHandlerContext ctx) throws Exception {
        assertCumulationReleased(internalBuffer());
      }
    }
);
    byte[] bytes=new byte[1024];
    PlatformDependent.threadLocalRandom().nextBytes(bytes);
    assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(bytes)));
    assertTrue(channel.finishAndReleaseAll());
  }
  private static void assertCumulationReleased(  ByteBuf byteBuf){
    assertTrue("unexpected value: " + byteBuf,byteBuf == null || byteBuf == Unpooled.EMPTY_BUFFER || byteBuf.refCnt() == 0);
  }
  @Test public void testFireChannelReadCompleteOnInactive() throws InterruptedException {
    final BlockingQueue<Integer> queue=new LinkedBlockingDeque<Integer>();
    final ByteBuf buf=Unpooled.buffer().writeBytes(new byte[]{'a','b'});
    EmbeddedChannel channel=new EmbeddedChannel(new ByteToMessageDecoder(){
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        int readable=in.readableBytes();
        assertTrue(readable > 0);
        in.skipBytes(readable);
      }
      @Override protected void decodeLast(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        assertFalse(in.isReadable());
        out.add("data");
      }
    }
,new ChannelInboundHandlerAdapter(){
      @Override public void channelInactive(      ChannelHandlerContext ctx) throws Exception {
        queue.add(3);
      }
      @Override public void channelRead(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        queue.add(1);
      }
      @Override public void channelReadComplete(      ChannelHandlerContext ctx) throws Exception {
        if (!ctx.channel().isActive()) {
          queue.add(2);
        }
      }
    }
);
    assertFalse(channel.writeInbound(buf));
    channel.finish();
    assertEquals(1,(int)queue.take());
    assertEquals(2,(int)queue.take());
    assertEquals(3,(int)queue.take());
    assertTrue(queue.isEmpty());
  }
  @Test public void testRemoveWhileInCallDecode(){
    final Object upgradeMessage=new Object();
    final ByteToMessageDecoder decoder=new ByteToMessageDecoder(){
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        assertEquals('a',in.readByte());
        out.add(upgradeMessage);
      }
    }
;
    EmbeddedChannel channel=new EmbeddedChannel(decoder,new ChannelInboundHandlerAdapter(){
      @Override public void channelRead(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        if (msg == upgradeMessage) {
          ctx.pipeline().remove(decoder);
          return;
        }
        ctx.fireChannelRead(msg);
      }
    }
);
    ByteBuf buf=Unpooled.wrappedBuffer(new byte[]{'a','b','c'});
    assertTrue(channel.writeInbound(buf.copy()));
    ByteBuf b=channel.readInbound();
    assertEquals(b,buf.skipBytes(1));
    assertFalse(channel.finish());
    buf.release();
    b.release();
  }
  @Test public void testDecodeLastEmptyBuffer(){
    EmbeddedChannel channel=new EmbeddedChannel(new ByteToMessageDecoder(){
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        int readable=in.readableBytes();
        assertTrue(readable > 0);
        out.add(in.readBytes(readable));
      }
    }
);
    byte[] bytes=new byte[1024];
    PlatformDependent.threadLocalRandom().nextBytes(bytes);
    assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(bytes)));
    assertBuffer(Unpooled.wrappedBuffer(bytes),(ByteBuf)channel.readInbound());
    assertNull(channel.readInbound());
    assertFalse(channel.finish());
    assertNull(channel.readInbound());
  }
  @Test public void testDecodeLastNonEmptyBuffer(){
    EmbeddedChannel channel=new EmbeddedChannel(new ByteToMessageDecoder(){
      private boolean decodeLast;
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        int readable=in.readableBytes();
        assertTrue(readable > 0);
        if (!decodeLast && readable == 1) {
          return;
        }
        out.add(in.readBytes(decodeLast ? readable : readable - 1));
      }
      @Override protected void decodeLast(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
        assertFalse(decodeLast);
        decodeLast=true;
        super.decodeLast(ctx,in,out);
      }
    }
);
    byte[] bytes=new byte[1024];
    PlatformDependent.threadLocalRandom().nextBytes(bytes);
    assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(bytes)));
    assertBuffer(Unpooled.wrappedBuffer(bytes,0,bytes.length - 1),(ByteBuf)channel.readInbound());
    assertNull(channel.readInbound());
    assertTrue(channel.finish());
    assertBuffer(Unpooled.wrappedBuffer(bytes,bytes.length - 1,1),(ByteBuf)channel.readInbound());
    assertNull(channel.readInbound());
  }
  private static void assertBuffer(  ByteBuf expected,  ByteBuf buffer){
    try {
      assertEquals(expected,buffer);
    }
  finally {
      buffer.release();
      expected.release();
    }
  }
  @Test public void testReadOnlyBuffer(){
    EmbeddedChannel channel=new EmbeddedChannel(new ByteToMessageDecoder(){
      @Override protected void decode(      ChannelHandlerContext ctx,      ByteBuf in,      List<Object> out) throws Exception {
      }
    }
);
    assertFalse(channel.writeInbound(Unpooled.buffer(8).writeByte(1).asReadOnly()));
    assertFalse(channel.writeInbound(Unpooled.wrappedBuffer(new byte[]{(byte)2})));
    assertFalse(channel.finish());
  }
  @Test public void releaseWhenMergeCumulateThrows(){
    final Error error=new Error();
    ByteBuf cumulation=new UnpooledHeapByteBuf(UnpooledByteBufAllocator.DEFAULT,0,64){
      @Override public ByteBuf writeBytes(      ByteBuf src){
        throw error;
      }
    }
;
    ByteBuf in=Unpooled.buffer().writeZero(12);
    try {
      ByteToMessageDecoder.MERGE_CUMULATOR.cumulate(UnpooledByteBufAllocator.DEFAULT,cumulation,in);
      fail();
    }
 catch (    Error expected) {
      assertSame(error,expected);
      assertEquals(0,in.refCnt());
    }
  }
  @Test public void releaseWhenCompositeCumulateThrows(){
    final Error error=new Error();
    ByteBuf cumulation=new CompositeByteBuf(UnpooledByteBufAllocator.DEFAULT,false,64){
      @Override public CompositeByteBuf addComponent(      boolean increaseWriterIndex,      ByteBuf buffer){
        throw error;
      }
    }
;
    ByteBuf in=Unpooled.buffer().writeZero(12);
    try {
      ByteToMessageDecoder.COMPOSITE_CUMULATOR.cumulate(UnpooledByteBufAllocator.DEFAULT,cumulation,in);
      fail();
    }
 catch (    Error expected) {
      assertSame(error,expected);
      assertEquals(0,in.refCnt());
    }
  }
}
