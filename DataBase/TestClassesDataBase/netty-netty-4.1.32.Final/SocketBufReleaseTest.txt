public class SocketBufReleaseTest extends AbstractSocketTest {
  private static final EventExecutor executor=new DefaultEventExecutorGroup(1,new DefaultThreadFactory(SocketBufReleaseTest.class,true)).next();
  @Test public void testBufRelease() throws Throwable {
    run();
  }
  public void testBufRelease(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    BufWriterHandler serverHandler=new BufWriterHandler();
    BufWriterHandler clientHandler=new BufWriterHandler();
    sb.childHandler(serverHandler);
    cb.handler(clientHandler);
    Channel sc=sb.bind().sync().channel();
    Channel cc=cb.connect(sc.localAddress()).sync().channel();
    serverHandler.channelFuture.sync();
    sc.close().sync();
    cc.close().sync();
    serverHandler.check();
    clientHandler.check();
    serverHandler.release();
    clientHandler.release();
  }
private static class BufWriterHandler extends SimpleChannelInboundHandler<Object> {
    private final Random random=new Random();
    private final CountDownLatch latch=new CountDownLatch(1);
    private ByteBuf buf;
    private final Promise<Channel> channelFuture=new DefaultPromise<Channel>(executor);
    @Override public void handlerAdded(    ChannelHandlerContext ctx) throws Exception {
      channelFuture.setSuccess(ctx.channel());
    }
    @Override public void channelActive(    final ChannelHandlerContext ctx) throws Exception {
      byte[] data=new byte[1024];
      random.nextBytes(data);
      buf=ctx.alloc().buffer();
      buf.writeBytes(data).retain();
      ctx.channel().writeAndFlush(buf).addListener(new ChannelFutureListener(){
        @Override public void operationComplete(        ChannelFuture future) throws Exception {
          latch.countDown();
        }
      }
);
    }
    @Override public void channelRead0(    ChannelHandlerContext ctx,    Object msg) throws Exception {
    }
    public void check() throws InterruptedException {
      latch.await();
      assertEquals(1,buf.refCnt());
    }
    void release(){
      buf.release();
    }
  }
}
