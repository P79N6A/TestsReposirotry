public class SocketFileRegionTest extends AbstractSocketTest {
  static final byte[] data=new byte[1048576 * 10];
static {
    PlatformDependent.threadLocalRandom().nextBytes(data);
  }
  @Test public void testFileRegion() throws Throwable {
    run();
  }
  @Test public void testCustomFileRegion() throws Throwable {
    run();
  }
  @Test public void testFileRegionNotAutoRead() throws Throwable {
    run();
  }
  @Test public void testFileRegionVoidPromise() throws Throwable {
    run();
  }
  @Test public void testFileRegionVoidPromiseNotAutoRead() throws Throwable {
    run();
  }
  public void testFileRegion(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testFileRegion0(sb,cb,false,true,true);
  }
  public void testCustomFileRegion(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testFileRegion0(sb,cb,false,true,false);
  }
  public void testFileRegionVoidPromise(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testFileRegion0(sb,cb,true,true,true);
  }
  public void testFileRegionNotAutoRead(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testFileRegion0(sb,cb,false,false,true);
  }
  public void testFileRegionVoidPromiseNotAutoRead(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testFileRegion0(sb,cb,true,false,true);
  }
  private static void testFileRegion0(  ServerBootstrap sb,  Bootstrap cb,  boolean voidPromise,  final boolean autoRead,  boolean defaultFileRegion) throws Throwable {
    sb.childOption(ChannelOption.AUTO_READ,autoRead);
    cb.option(ChannelOption.AUTO_READ,autoRead);
    final int bufferSize=1024;
    final File file=File.createTempFile("netty-",".tmp");
    file.deleteOnExit();
    final FileOutputStream out=new FileOutputStream(file);
    final Random random=PlatformDependent.threadLocalRandom();
    final int startOffset=random.nextInt(8192);
    for (int i=0; i < startOffset; i++) {
      out.write(random.nextInt());
    }
    out.write(data,bufferSize,data.length - bufferSize);
    for (int i=random.nextInt(8192); i > 0; i--) {
      out.write(random.nextInt());
    }
    out.close();
    ChannelInboundHandler ch=new SimpleChannelInboundHandler<Object>(){
      @Override public void channelRead0(      ChannelHandlerContext ctx,      Object msg) throws Exception {
      }
      @Override public void channelReadComplete(      ChannelHandlerContext ctx) throws Exception {
        if (!autoRead) {
          ctx.read();
        }
      }
      @Override public void exceptionCaught(      ChannelHandlerContext ctx,      Throwable cause) throws Exception {
        ctx.close();
      }
    }
;
    TestHandler sh=new TestHandler(autoRead);
    sb.childHandler(sh);
    cb.handler(ch);
    Channel sc=sb.bind().sync().channel();
    Channel cc=cb.connect(sc.localAddress()).sync().channel();
    FileRegion region=new DefaultFileRegion(new FileInputStream(file).getChannel(),startOffset,data.length - bufferSize);
    FileRegion emptyRegion=new DefaultFileRegion(new FileInputStream(file).getChannel(),0,0);
    if (!defaultFileRegion) {
      region=new FileRegionWrapper(region);
      emptyRegion=new FileRegionWrapper(emptyRegion);
    }
    if (voidPromise) {
      assertEquals(cc.voidPromise(),cc.write(Unpooled.wrappedBuffer(data,0,bufferSize),cc.voidPromise()));
      assertEquals(cc.voidPromise(),cc.write(emptyRegion,cc.voidPromise()));
      assertEquals(cc.voidPromise(),cc.writeAndFlush(region,cc.voidPromise()));
    }
 else {
      assertNotEquals(cc.voidPromise(),cc.write(Unpooled.wrappedBuffer(data,0,bufferSize)));
      assertNotEquals(cc.voidPromise(),cc.write(emptyRegion));
      assertNotEquals(cc.voidPromise(),cc.writeAndFlush(region));
    }
    while (sh.counter < data.length) {
      if (sh.exception.get() != null) {
        break;
      }
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
      }
    }
    sh.channel.close().sync();
    cc.close().sync();
    sc.close().sync();
    if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
      throw sh.exception.get();
    }
    if (sh.exception.get() != null) {
      throw sh.exception.get();
    }
    assertThat(sh.counter,is(data.length));
  }
private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
    private final boolean autoRead;
    volatile Channel channel;
    final AtomicReference<Throwable> exception=new AtomicReference<Throwable>();
    volatile int counter;
    TestHandler(    boolean autoRead){
      this.autoRead=autoRead;
    }
    @Override public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      channel=ctx.channel();
      if (!autoRead) {
        ctx.read();
      }
    }
    @Override public void channelRead0(    ChannelHandlerContext ctx,    ByteBuf in) throws Exception {
      byte[] actual=new byte[in.readableBytes()];
      in.readBytes(actual);
      int lastIdx=counter;
      for (int i=0; i < actual.length; i++) {
        assertEquals(data[i + lastIdx],actual[i]);
      }
      counter+=actual.length;
    }
    @Override public void channelReadComplete(    ChannelHandlerContext ctx) throws Exception {
      if (!autoRead) {
        ctx.read();
      }
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      if (exception.compareAndSet(null,cause)) {
        ctx.close();
      }
    }
  }
private static final class FileRegionWrapper implements FileRegion {
    private final FileRegion region;
    FileRegionWrapper(    FileRegion region){
      this.region=region;
    }
    @Override public int refCnt(){
      return region.refCnt();
    }
    @Override public long position(){
      return region.position();
    }
    @Override @Deprecated public long transfered(){
      return region.transferred();
    }
    @Override public boolean release(){
      return region.release();
    }
    @Override public long transferred(){
      return region.transferred();
    }
    @Override public long count(){
      return region.count();
    }
    @Override public boolean release(    int decrement){
      return region.release(decrement);
    }
    @Override public long transferTo(    WritableByteChannel target,    long position) throws IOException {
      return region.transferTo(target,position);
    }
    @Override public FileRegion retain(){
      region.retain();
      return this;
    }
    @Override public FileRegion retain(    int increment){
      region.retain(increment);
      return this;
    }
    @Override public FileRegion touch(){
      region.touch();
      return this;
    }
    @Override public FileRegion touch(    Object hint){
      region.touch(hint);
      return this;
    }
  }
}
