/** 
 * Verifies the correct functionality of the  {@link LoggingHandler}.
 */
public class LoggingHandlerTest {
  private static final String LOGGER_NAME=LoggingHandler.class.getName();
  private static final Logger rootLogger=(Logger)LoggerFactory.getLogger(ROOT_LOGGER_NAME);
  private static final Logger logger=(Logger)LoggerFactory.getLogger(LOGGER_NAME);
  private static final List<Appender<ILoggingEvent>> oldAppenders=new ArrayList<Appender<ILoggingEvent>>();
  /** 
 * Custom logback appender which gets used to match on log messages.
 */
  private Appender<ILoggingEvent> appender;
  @BeforeClass public static void beforeClass(){
    for (Iterator<Appender<ILoggingEvent>> i=rootLogger.iteratorForAppenders(); i.hasNext(); ) {
      Appender<ILoggingEvent> a=i.next();
      oldAppenders.add(a);
      rootLogger.detachAppender(a);
    }
    Unpooled.buffer();
  }
  @AfterClass public static void afterClass(){
    for (    Appender<ILoggingEvent> a : oldAppenders) {
      rootLogger.addAppender(a);
    }
  }
  @Before @SuppressWarnings("unchecked") public void setup(){
    appender=mock(Appender.class);
    logger.addAppender(appender);
  }
  @After public void teardown(){
    logger.detachAppender(appender);
  }
  @Test(expected=NullPointerException.class) public void shouldNotAcceptNullLogLevel(){
    LogLevel level=null;
    new LoggingHandler(level);
  }
  @Test public void shouldApplyCustomLogLevel(){
    LoggingHandler handler=new LoggingHandler(LogLevel.INFO);
    assertEquals(LogLevel.INFO,handler.level());
  }
  @Test public void shouldLogChannelActive(){
    new EmbeddedChannel(new LoggingHandler());
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+ACTIVE$")));
  }
  @Test public void shouldLogChannelWritabilityChanged() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.config().setWriteBufferLowWaterMark(5);
    channel.config().setWriteBufferHighWaterMark(10);
    channel.write("hello",channel.newPromise());
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+WRITABILITY CHANGED$")));
  }
  @Test public void shouldLogChannelRegistered(){
    new EmbeddedChannel(new LoggingHandler());
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+REGISTERED$")));
  }
  @Test public void shouldLogChannelClose() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.close().await();
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+CLOSE$")));
  }
  @Test public void shouldLogChannelConnect() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.connect(new InetSocketAddress(80)).await();
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+CONNECT: 0.0.0.0/0.0.0.0:80$")));
  }
  @Test public void shouldLogChannelConnectWithLocalAddress() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.connect(new InetSocketAddress(80),new InetSocketAddress(81)).await();
    verify(appender).doAppend(argThat(new RegexLogMatcher("^\\[id: 0xembedded, L:embedded - R:embedded\\] CONNECT: 0.0.0.0/0.0.0.0:80, 0.0.0.0/0.0.0.0:81$")));
  }
  @Test public void shouldLogChannelDisconnect() throws Exception {
    EmbeddedChannel channel=new DisconnectingEmbeddedChannel(new LoggingHandler());
    channel.connect(new InetSocketAddress(80)).await();
    channel.disconnect().await();
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+DISCONNECT$")));
  }
  @Test public void shouldLogChannelInactive() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.pipeline().fireChannelInactive();
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+INACTIVE$")));
  }
  @Test public void shouldLogChannelBind() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.bind(new InetSocketAddress(80));
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+BIND: 0.0.0.0/0.0.0.0:80$")));
  }
  @Test @SuppressWarnings("RedundantStringConstructorCall") public void shouldLogChannelUserEvent() throws Exception {
    String userTriggered="iAmCustom!";
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.pipeline().fireUserEventTriggered(new String(userTriggered));
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+USER_EVENT: " + userTriggered + '$')));
  }
  @Test public void shouldLogChannelException() throws Exception {
    String msg="illegalState";
    Throwable cause=new IllegalStateException(msg);
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.pipeline().fireExceptionCaught(cause);
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+EXCEPTION: " + cause.getClass().getCanonicalName() + ": "+ msg+ '$')));
  }
  @Test public void shouldLogDataWritten() throws Exception {
    String msg="hello";
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.writeOutbound(msg);
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+WRITE: " + msg + '$')));
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+FLUSH$")));
  }
  @Test public void shouldLogNonByteBufDataRead() throws Exception {
    String msg="hello";
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.writeInbound(msg);
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+READ: " + msg + '$')));
    String handledMsg=channel.readInbound();
    assertThat(msg,is(sameInstance(handledMsg)));
    assertThat(channel.readInbound(),is(nullValue()));
  }
  @Test public void shouldLogByteBufDataRead() throws Exception {
    ByteBuf msg=Unpooled.copiedBuffer("hello",CharsetUtil.UTF_8);
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.writeInbound(msg);
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+READ: " + msg.readableBytes() + "B$")));
    ByteBuf handledMsg=channel.readInbound();
    assertThat(msg,is(sameInstance(handledMsg)));
    handledMsg.release();
    assertThat(channel.readInbound(),is(nullValue()));
  }
  @Test public void shouldLogEmptyByteBufDataRead() throws Exception {
    ByteBuf msg=Unpooled.EMPTY_BUFFER;
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.writeInbound(msg);
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+READ: 0B$")));
    ByteBuf handledMsg=channel.readInbound();
    assertThat(msg,is(sameInstance(handledMsg)));
    assertThat(channel.readInbound(),is(nullValue()));
  }
  @Test public void shouldLogByteBufHolderDataRead() throws Exception {
    ByteBufHolder msg=new DefaultByteBufHolder(Unpooled.copiedBuffer("hello",CharsetUtil.UTF_8)){
      @Override public String toString(){
        return "foobar";
      }
    }
;
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.writeInbound(msg);
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+READ: foobar, 5B$")));
    ByteBufHolder handledMsg=channel.readInbound();
    assertThat(msg,is(sameInstance(handledMsg)));
    handledMsg.release();
    assertThat(channel.readInbound(),is(nullValue()));
  }
  @Test public void shouldLogChannelReadComplete() throws Exception {
    ByteBuf msg=Unpooled.EMPTY_BUFFER;
    EmbeddedChannel channel=new EmbeddedChannel(new LoggingHandler());
    channel.writeInbound(msg);
    verify(appender).doAppend(argThat(new RegexLogMatcher(".+READ COMPLETE$")));
  }
  /** 
 * A custom EasyMock matcher that matches on Logback messages.
 */
private static final class RegexLogMatcher implements ArgumentMatcher<ILoggingEvent> {
    private final String expected;
    private String actualMsg;
    RegexLogMatcher(    String expected){
      this.expected=expected;
    }
    @Override @SuppressWarnings("DynamicRegexReplaceableByCompiledPattern") public boolean matches(    ILoggingEvent actual){
      actualMsg=actual.getMessage().split("(?s)[\\r\\n]+")[0];
      return actualMsg.matches(expected);
    }
  }
private static final class DisconnectingEmbeddedChannel extends EmbeddedChannel {
    private DisconnectingEmbeddedChannel(    ChannelHandler... handlers){
      super(handlers);
    }
    @Override public ChannelMetadata metadata(){
      return new ChannelMetadata(true);
    }
  }
}
