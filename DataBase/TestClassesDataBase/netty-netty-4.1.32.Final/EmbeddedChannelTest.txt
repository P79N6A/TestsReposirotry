public class EmbeddedChannelTest {
  @Test public void testNotRegistered() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(false,false);
    assertFalse(channel.isRegistered());
    channel.register();
    assertTrue(channel.isRegistered());
    assertFalse(channel.finish());
  }
  @Test public void testRegistered() throws Exception {
    EmbeddedChannel channel=new EmbeddedChannel(true,false);
    assertTrue(channel.isRegistered());
    try {
      channel.register();
      fail();
    }
 catch (    IllegalStateException expected) {
    }
    assertFalse(channel.finish());
  }
  @Test(timeout=2000) public void promiseDoesNotInfiniteLoop() throws InterruptedException {
    EmbeddedChannel channel=new EmbeddedChannel();
    channel.closeFuture().addListener(new ChannelFutureListener(){
      @Override public void operationComplete(      ChannelFuture future) throws Exception {
        future.channel().close();
      }
    }
);
    channel.close().syncUninterruptibly();
  }
  @Test public void testConstructWithChannelInitializer(){
    final Integer first=1;
    final Integer second=2;
    final ChannelHandler handler=new ChannelInboundHandlerAdapter(){
      @Override public void channelRead(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        ctx.fireChannelRead(first);
        ctx.fireChannelRead(second);
      }
    }
;
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        ch.pipeline().addLast(handler);
      }
    }
);
    ChannelPipeline pipeline=channel.pipeline();
    assertSame(handler,pipeline.firstContext().handler());
    assertTrue(channel.writeInbound(3));
    assertTrue(channel.finish());
    assertSame(first,channel.readInbound());
    assertSame(second,channel.readInbound());
    assertNull(channel.readInbound());
  }
  @SuppressWarnings({"rawtypes","unchecked"}) @Test public void testScheduling() throws Exception {
    EmbeddedChannel ch=new EmbeddedChannel(new ChannelInboundHandlerAdapter());
    final CountDownLatch latch=new CountDownLatch(2);
    ScheduledFuture future=ch.eventLoop().schedule(new Runnable(){
      @Override public void run(){
        latch.countDown();
      }
    }
,1,TimeUnit.SECONDS);
    future.addListener(new FutureListener(){
      @Override public void operationComplete(      Future future) throws Exception {
        latch.countDown();
      }
    }
);
    long next=ch.runScheduledPendingTasks();
    assertTrue(next > 0);
    Thread.sleep(TimeUnit.NANOSECONDS.toMillis(next) + 50);
    assertEquals(-1,ch.runScheduledPendingTasks());
    latch.await();
  }
  @Test public void testScheduledCancelled() throws Exception {
    EmbeddedChannel ch=new EmbeddedChannel(new ChannelInboundHandlerAdapter());
    ScheduledFuture<?> future=ch.eventLoop().schedule(new Runnable(){
      @Override public void run(){
      }
    }
,1,TimeUnit.DAYS);
    ch.finish();
    assertTrue(future.isCancelled());
  }
  @Test(timeout=3000) public void testHandlerAddedExecutedInEventLoop() throws Throwable {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    final ChannelHandler handler=new ChannelHandlerAdapter(){
      @Override public void handlerAdded(      ChannelHandlerContext ctx) throws Exception {
        try {
          assertTrue(ctx.executor().inEventLoop());
        }
 catch (        Throwable cause) {
          error.set(cause);
        }
 finally {
          latch.countDown();
        }
      }
    }
;
    EmbeddedChannel channel=new EmbeddedChannel(handler);
    assertFalse(channel.finish());
    latch.await();
    Throwable cause=error.get();
    if (cause != null) {
      throw cause;
    }
  }
  @Test public void testConstructWithOutHandler(){
    EmbeddedChannel channel=new EmbeddedChannel();
    assertTrue(channel.writeInbound(1));
    assertTrue(channel.writeOutbound(2));
    assertTrue(channel.finish());
    assertSame(1,channel.readInbound());
    assertNull(channel.readInbound());
    assertSame(2,channel.readOutbound());
    assertNull(channel.readOutbound());
  }
  @Test public void testConstructWithChannelId(){
    ChannelId channelId=new CustomChannelId(1);
    EmbeddedChannel channel=new EmbeddedChannel(channelId);
    assertSame(channelId,channel.id());
  }
  @Test(timeout=2000) public void testFireChannelInactiveAndUnregisteredOnClose() throws InterruptedException {
    testFireChannelInactiveAndUnregistered(new Action(){
      @Override public ChannelFuture doRun(      Channel channel){
        return channel.close();
      }
    }
);
    testFireChannelInactiveAndUnregistered(new Action(){
      @Override public ChannelFuture doRun(      Channel channel){
        return channel.close(channel.newPromise());
      }
    }
);
  }
  @Test(timeout=2000) public void testFireChannelInactiveAndUnregisteredOnDisconnect() throws InterruptedException {
    testFireChannelInactiveAndUnregistered(new Action(){
      @Override public ChannelFuture doRun(      Channel channel){
        return channel.disconnect();
      }
    }
);
    testFireChannelInactiveAndUnregistered(new Action(){
      @Override public ChannelFuture doRun(      Channel channel){
        return channel.disconnect(channel.newPromise());
      }
    }
);
  }
  private static void testFireChannelInactiveAndUnregistered(  Action action) throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(3);
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelInboundHandlerAdapter(){
      @Override public void channelInactive(      ChannelHandlerContext ctx) throws Exception {
        latch.countDown();
        ctx.executor().execute(new Runnable(){
          @Override public void run(){
            latch.countDown();
          }
        }
);
      }
      @Override public void channelUnregistered(      ChannelHandlerContext ctx) throws Exception {
        latch.countDown();
      }
    }
);
    action.doRun(channel).syncUninterruptibly();
    latch.await();
  }
private interface Action {
    ChannelFuture doRun(    Channel channel);
  }
  @Test public void testHasDisconnect(){
    EventOutboundHandler handler=new EventOutboundHandler();
    EmbeddedChannel channel=new EmbeddedChannel(true,handler);
    assertTrue(channel.disconnect().isSuccess());
    assertTrue(channel.close().isSuccess());
    assertEquals(EventOutboundHandler.DISCONNECT,handler.pollEvent());
    assertEquals(EventOutboundHandler.CLOSE,handler.pollEvent());
    assertNull(handler.pollEvent());
  }
  @Test public void testHasNoDisconnect(){
    EventOutboundHandler handler=new EventOutboundHandler();
    EmbeddedChannel channel=new EmbeddedChannel(false,handler);
    assertTrue(channel.disconnect().isSuccess());
    assertTrue(channel.close().isSuccess());
    assertEquals(EventOutboundHandler.CLOSE,handler.pollEvent());
    assertEquals(EventOutboundHandler.CLOSE,handler.pollEvent());
    assertNull(handler.pollEvent());
  }
  @Test public void testFinishAndReleaseAll(){
    ByteBuf in=Unpooled.buffer();
    ByteBuf out=Unpooled.buffer();
    try {
      EmbeddedChannel channel=new EmbeddedChannel();
      assertTrue(channel.writeInbound(in));
      assertEquals(1,in.refCnt());
      assertTrue(channel.writeOutbound(out));
      assertEquals(1,out.refCnt());
      assertTrue(channel.finishAndReleaseAll());
      assertEquals(0,in.refCnt());
      assertEquals(0,out.refCnt());
      assertNull(channel.readInbound());
      assertNull(channel.readOutbound());
    }
  finally {
      release(in,out);
    }
  }
  @Test public void testReleaseInbound(){
    ByteBuf in=Unpooled.buffer();
    ByteBuf out=Unpooled.buffer();
    try {
      EmbeddedChannel channel=new EmbeddedChannel();
      assertTrue(channel.writeInbound(in));
      assertEquals(1,in.refCnt());
      assertTrue(channel.writeOutbound(out));
      assertEquals(1,out.refCnt());
      assertTrue(channel.releaseInbound());
      assertEquals(0,in.refCnt());
      assertEquals(1,out.refCnt());
      assertTrue(channel.finish());
      assertNull(channel.readInbound());
      ByteBuf buffer=channel.readOutbound();
      assertSame(out,buffer);
      buffer.release();
      assertNull(channel.readOutbound());
    }
  finally {
      release(in,out);
    }
  }
  @Test public void testReleaseOutbound(){
    ByteBuf in=Unpooled.buffer();
    ByteBuf out=Unpooled.buffer();
    try {
      EmbeddedChannel channel=new EmbeddedChannel();
      assertTrue(channel.writeInbound(in));
      assertEquals(1,in.refCnt());
      assertTrue(channel.writeOutbound(out));
      assertEquals(1,out.refCnt());
      assertTrue(channel.releaseOutbound());
      assertEquals(1,in.refCnt());
      assertEquals(0,out.refCnt());
      assertTrue(channel.finish());
      assertNull(channel.readOutbound());
      ByteBuf buffer=channel.readInbound();
      assertSame(in,buffer);
      buffer.release();
      assertNull(channel.readInbound());
    }
  finally {
      release(in,out);
    }
  }
  @Test public void testWriteLater(){
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelOutboundHandlerAdapter(){
      @Override public void write(      final ChannelHandlerContext ctx,      final Object msg,      final ChannelPromise promise) throws Exception {
        ctx.executor().execute(new Runnable(){
          @Override public void run(){
            ctx.write(msg,promise);
          }
        }
);
      }
    }
);
    Object msg=new Object();
    assertTrue(channel.writeOutbound(msg));
    assertTrue(channel.finish());
    assertSame(msg,channel.readOutbound());
    assertNull(channel.readOutbound());
  }
  @Test public void testWriteScheduled() throws InterruptedException {
    final int delay=500;
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelOutboundHandlerAdapter(){
      @Override public void write(      final ChannelHandlerContext ctx,      final Object msg,      final ChannelPromise promise) throws Exception {
        ctx.executor().schedule(new Runnable(){
          @Override public void run(){
            ctx.writeAndFlush(msg,promise);
          }
        }
,delay,TimeUnit.MILLISECONDS);
      }
    }
);
    Object msg=new Object();
    assertFalse(channel.writeOutbound(msg));
    Thread.sleep(delay * 2);
    assertTrue(channel.finish());
    assertSame(msg,channel.readOutbound());
    assertNull(channel.readOutbound());
  }
  @Test public void testFlushInbound() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelInboundHandlerAdapter(){
      @Override public void channelReadComplete(      ChannelHandlerContext ctx) throws Exception {
        latch.countDown();
      }
    }
);
    channel.flushInbound();
    if (!latch.await(1L,TimeUnit.SECONDS)) {
      fail("Nobody called #channelReadComplete() in time.");
    }
  }
  @Test public void testWriteOneInbound() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicInteger flushCount=new AtomicInteger(0);
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelInboundHandlerAdapter(){
      @Override public void channelRead(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        ReferenceCountUtil.release(msg);
        latch.countDown();
      }
      @Override public void channelReadComplete(      ChannelHandlerContext ctx) throws Exception {
        flushCount.incrementAndGet();
      }
    }
);
    channel.writeOneInbound("Hello, Netty!");
    if (!latch.await(1L,TimeUnit.SECONDS)) {
      fail("Nobody called #channelRead() in time.");
    }
    channel.close().syncUninterruptibly();
    assertEquals(0,flushCount.get());
  }
  @Test public void testFlushOutbound() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelOutboundHandlerAdapter(){
      @Override public void flush(      ChannelHandlerContext ctx) throws Exception {
        latch.countDown();
      }
    }
);
    channel.flushOutbound();
    if (!latch.await(1L,TimeUnit.SECONDS)) {
      fail("Nobody called #flush() in time.");
    }
  }
  @Test public void testWriteOneOutbound() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicInteger flushCount=new AtomicInteger(0);
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelOutboundHandlerAdapter(){
      @Override public void write(      ChannelHandlerContext ctx,      Object msg,      ChannelPromise promise) throws Exception {
        ctx.write(msg,promise);
        latch.countDown();
      }
      @Override public void flush(      ChannelHandlerContext ctx) throws Exception {
        flushCount.incrementAndGet();
      }
    }
);
    channel.writeOneOutbound("Hello, Netty!");
    if (!latch.await(1L,TimeUnit.SECONDS)) {
      fail("Nobody called #write() in time.");
    }
    channel.close().syncUninterruptibly();
    assertEquals(0,flushCount.get());
  }
  @Test public void testEnsureOpen() throws InterruptedException {
    EmbeddedChannel channel=new EmbeddedChannel();
    channel.close().syncUninterruptibly();
    try {
      channel.writeOutbound("Hello, Netty!");
      fail("This should have failed with a ClosedChannelException");
    }
 catch (    Exception expected) {
      assertTrue(expected instanceof ClosedChannelException);
    }
    try {
      channel.writeInbound("Hello, Netty!");
      fail("This should have failed with a ClosedChannelException");
    }
 catch (    Exception expected) {
      assertTrue(expected instanceof ClosedChannelException);
    }
  }
  @Test public void testHandleInboundMessage() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    EmbeddedChannel channel=new EmbeddedChannel(){
      @Override protected void handleInboundMessage(      Object msg){
        latch.countDown();
      }
    }
;
    channel.writeOneInbound("Hello, Netty!");
    if (!latch.await(1L,TimeUnit.SECONDS)) {
      fail("Nobody called #handleInboundMessage() in time.");
    }
  }
  @Test public void testHandleOutboundMessage() throws InterruptedException {
    final CountDownLatch latch=new CountDownLatch(1);
    EmbeddedChannel channel=new EmbeddedChannel(){
      @Override protected void handleOutboundMessage(      Object msg){
        latch.countDown();
      }
    }
;
    channel.writeOneOutbound("Hello, Netty!");
    if (latch.await(50L,TimeUnit.MILLISECONDS)) {
      fail("Somebody called unexpectedly #flush()");
    }
    channel.flushOutbound();
    if (!latch.await(1L,TimeUnit.SECONDS)) {
      fail("Nobody called #handleOutboundMessage() in time.");
    }
  }
  @Test(timeout=5000) public void testChannelInactiveFired() throws InterruptedException {
    final AtomicBoolean inactive=new AtomicBoolean();
    EmbeddedChannel channel=new EmbeddedChannel(new ChannelInboundHandlerAdapter(){
      @Override public void exceptionCaught(      ChannelHandlerContext ctx,      Throwable cause) throws Exception {
        ctx.close();
      }
      @Override public void channelInactive(      ChannelHandlerContext ctx) throws Exception {
        inactive.set(true);
      }
    }
);
    channel.pipeline().fireExceptionCaught(new IllegalStateException());
    assertTrue(inactive.get());
  }
  private static void release(  ByteBuf... buffers){
    for (    ByteBuf buffer : buffers) {
      if (buffer.refCnt() > 0) {
        buffer.release();
      }
    }
  }
private static final class EventOutboundHandler extends ChannelOutboundHandlerAdapter {
    static final Integer DISCONNECT=0;
    static final Integer CLOSE=1;
    private final Queue<Integer> queue=new ArrayDeque<Integer>();
    @Override public void disconnect(    ChannelHandlerContext ctx,    ChannelPromise promise) throws Exception {
      queue.add(DISCONNECT);
      promise.setSuccess();
    }
    @Override public void close(    ChannelHandlerContext ctx,    ChannelPromise promise) throws Exception {
      queue.add(CLOSE);
      promise.setSuccess();
    }
    Integer pollEvent(){
      return queue.poll();
    }
  }
}
