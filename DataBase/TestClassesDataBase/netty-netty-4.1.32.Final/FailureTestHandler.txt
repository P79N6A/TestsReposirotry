private static final class FailureTestHandler extends SimpleChannelInboundHandler<Object> {
  final Queue<Throwable> exceptions=new LinkedBlockingQueue<Throwable>();
  /** 
 * A latch that counts down when: - a pending write attempt in  {@link #channelActive(ChannelHandlerContext)} finishes, or- the channel is closed. By waiting until the latch goes down to 0, we can make sure all assertion failures related with all write attempts have been recorded.
 */
  final CountDownLatch latch=new CountDownLatch(2);
  @Override public void channelActive(  ChannelHandlerContext ctx) throws Exception {
    ctx.writeAndFlush(Unpooled.copiedBuffer("A\n",CharsetUtil.US_ASCII)).addListener(new ChannelFutureListener(){
      @Override public void operationComplete(      ChannelFuture future) throws Exception {
        latch.countDown();
        if (!(future.cause() instanceof ProxyConnectException)) {
          exceptions.add(new AssertionError("Unexpected failure cause for initial write: " + future.cause()));
        }
      }
    }
);
  }
  @Override public void channelInactive(  ChannelHandlerContext ctx) throws Exception {
    latch.countDown();
  }
  @Override public void userEventTriggered(  ChannelHandlerContext ctx,  Object evt) throws Exception {
    if (evt instanceof ProxyConnectionEvent) {
      fail("Unexpected event: " + evt);
    }
  }
  @Override protected void channelRead0(  ChannelHandlerContext ctx,  Object msg) throws Exception {
    fail("Unexpected message: " + msg);
  }
  @Override public void exceptionCaught(  ChannelHandlerContext ctx,  Throwable cause) throws Exception {
    exceptions.add(cause);
    ctx.close();
  }
}
