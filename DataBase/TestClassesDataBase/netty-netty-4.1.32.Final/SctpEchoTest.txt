public class SctpEchoTest extends AbstractSctpTest {
  private static final Random random=new Random();
  static final byte[] data=new byte[4096];
static {
    random.nextBytes(data);
  }
  @Test public void testSimpleEcho() throws Throwable {
    Assume.assumeTrue(TestUtils.isSctpSupported());
    run();
  }
  public void testSimpleEcho(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testSimpleEcho0(sb,cb,false);
  }
  @Test public void testSimpleEchoUnordered() throws Throwable {
    Assume.assumeTrue(TestUtils.isSctpSupported());
    run();
  }
  public void testSimpleEchoUnordered(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testSimpleEcho0(sb,cb,true);
  }
  private static void testSimpleEcho0(  ServerBootstrap sb,  Bootstrap cb,  final boolean unordered) throws Throwable {
    final EchoHandler sh=new EchoHandler();
    final EchoHandler ch=new EchoHandler();
    sb.childHandler(new ChannelInitializer<SctpChannel>(){
      @Override public void initChannel(      SctpChannel c) throws Exception {
        c.pipeline().addLast(new SctpMessageCompletionHandler(),new SctpInboundByteStreamHandler(0,0),new SctpOutboundByteStreamHandler(0,0,unordered),sh);
      }
    }
);
    cb.handler(new ChannelInitializer<SctpChannel>(){
      @Override public void initChannel(      SctpChannel c) throws Exception {
        c.pipeline().addLast(new SctpMessageCompletionHandler(),new SctpInboundByteStreamHandler(0,0),new SctpOutboundByteStreamHandler(0,0,unordered),ch);
      }
    }
);
    Channel sc=sb.bind().sync().channel();
    Channel cc=cb.connect(sc.localAddress()).sync().channel();
    for (int i=0; i < data.length; ) {
      int length=Math.min(random.nextInt(1024 * 64),data.length - i);
      cc.writeAndFlush(Unpooled.wrappedBuffer(data,i,length));
      i+=length;
    }
    while (ch.counter < data.length) {
      if (sh.exception.get() != null) {
        break;
      }
      if (ch.exception.get() != null) {
        break;
      }
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
      }
    }
    while (sh.counter < data.length) {
      if (sh.exception.get() != null) {
        break;
      }
      if (ch.exception.get() != null) {
        break;
      }
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
      }
    }
    sh.channel.close().sync();
    ch.channel.close().sync();
    sc.close().sync();
    if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
      throw sh.exception.get();
    }
    if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {
      throw ch.exception.get();
    }
    if (sh.exception.get() != null) {
      throw sh.exception.get();
    }
    if (ch.exception.get() != null) {
      throw ch.exception.get();
    }
  }
private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
    volatile Channel channel;
    final AtomicReference<Throwable> exception=new AtomicReference<Throwable>();
    volatile int counter;
    @Override public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      channel=ctx.channel();
    }
    @Override public void channelRead0(    ChannelHandlerContext ctx,    ByteBuf in) throws Exception {
      byte[] actual=new byte[in.readableBytes()];
      in.readBytes(actual);
      int lastIdx=counter;
      for (int i=0; i < actual.length; i++) {
        assertEquals(data[i + lastIdx],actual[i]);
      }
      if (channel.parent() != null) {
        channel.writeAndFlush(Unpooled.wrappedBuffer(actual));
      }
      counter+=actual.length;
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      if (exception.compareAndSet(null,cause)) {
        ctx.close();
      }
    }
  }
}
