public class AbstractChannelTest {
  @Test public void ensureInitialRegistrationFiresActive() throws Throwable {
    EventLoop eventLoop=mock(EventLoop.class);
    when(eventLoop.inEventLoop()).thenReturn(true);
    TestChannel channel=new TestChannel();
    ChannelInboundHandler handler=mock(ChannelInboundHandler.class);
    channel.pipeline().addLast(handler);
    registerChannel(eventLoop,channel);
    verify(handler).handlerAdded(any(ChannelHandlerContext.class));
    verify(handler).channelRegistered(any(ChannelHandlerContext.class));
    verify(handler).channelActive(any(ChannelHandlerContext.class));
  }
  @Test public void ensureSubsequentRegistrationDoesNotFireActive() throws Throwable {
    final EventLoop eventLoop=mock(EventLoop.class);
    when(eventLoop.inEventLoop()).thenReturn(true);
    doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocationOnMock) throws Throwable {
        ((Runnable)invocationOnMock.getArgument(0)).run();
        return null;
      }
    }
).when(eventLoop).execute(any(Runnable.class));
    final TestChannel channel=new TestChannel();
    ChannelInboundHandler handler=mock(ChannelInboundHandler.class);
    channel.pipeline().addLast(handler);
    registerChannel(eventLoop,channel);
    channel.unsafe().deregister(new DefaultChannelPromise(channel));
    registerChannel(eventLoop,channel);
    verify(handler).handlerAdded(any(ChannelHandlerContext.class));
    verify(handler,times(2)).channelRegistered(any(ChannelHandlerContext.class));
    verify(handler).channelActive(any(ChannelHandlerContext.class));
    verify(handler).channelUnregistered(any(ChannelHandlerContext.class));
  }
  @Test public void ensureDefaultChannelId(){
    TestChannel channel=new TestChannel();
    final ChannelId channelId=channel.id();
    assertTrue(channelId instanceof DefaultChannelId);
  }
  private static void registerChannel(  EventLoop eventLoop,  Channel channel) throws Exception {
    DefaultChannelPromise future=new DefaultChannelPromise(channel);
    channel.unsafe().register(eventLoop,future);
    future.sync();
  }
private static class TestChannel extends AbstractChannel {
    private static final ChannelMetadata TEST_METADATA=new ChannelMetadata(false);
private class TestUnsafe extends AbstractUnsafe {
      @Override public void connect(      SocketAddress remoteAddress,      SocketAddress localAddress,      ChannelPromise promise){
      }
    }
    public TestChannel(){
      super(null);
    }
    @Override public ChannelConfig config(){
      return new DefaultChannelConfig(this);
    }
    @Override public boolean isOpen(){
      return true;
    }
    @Override public boolean isActive(){
      return true;
    }
    @Override public ChannelMetadata metadata(){
      return TEST_METADATA;
    }
    @Override protected AbstractUnsafe newUnsafe(){
      return new TestUnsafe();
    }
    @Override protected boolean isCompatible(    EventLoop loop){
      return true;
    }
    @Override protected SocketAddress localAddress0(){
      return null;
    }
    @Override protected SocketAddress remoteAddress0(){
      return null;
    }
    @Override protected void doBind(    SocketAddress localAddress) throws Exception {
    }
    @Override protected void doDisconnect() throws Exception {
    }
    @Override protected void doClose() throws Exception {
    }
    @Override protected void doBeginRead() throws Exception {
    }
    @Override protected void doWrite(    ChannelOutboundBuffer in) throws Exception {
    }
  }
}
