public class SpdyHeaderBlockZlibDecoderTest {
  private static final byte[] zlibHeader={0x78,0x3f,(byte)0xe3,(byte)0xc6,(byte)0xa7,(byte)0xc2};
  private static final byte[] zlibSyncFlush={0x00,0x00,0x00,(byte)0xff,(byte)0xff};
  private static final int maxHeaderSize=8192;
  private static final String name="name";
  private static final String value="value";
  private static final byte[] nameBytes=name.getBytes();
  private static final byte[] valueBytes=value.getBytes();
  private SpdyHeaderBlockZlibDecoder decoder;
  private SpdyHeadersFrame frame;
  @Before public void setUp(){
    decoder=new SpdyHeaderBlockZlibDecoder(SpdyVersion.SPDY_3_1,maxHeaderSize);
    frame=new DefaultSpdyHeadersFrame(1);
  }
  @After public void tearDown(){
    decoder.end();
  }
  @Test public void testHeaderBlock() throws Exception {
    ByteBuf headerBlock=Unpooled.buffer(37);
    headerBlock.writeBytes(zlibHeader);
    headerBlock.writeByte(0);
    headerBlock.writeByte(0x15);
    headerBlock.writeByte(0x00);
    headerBlock.writeByte(0xea);
    headerBlock.writeByte(0xff);
    headerBlock.writeInt(1);
    headerBlock.writeInt(4);
    headerBlock.writeBytes(nameBytes);
    headerBlock.writeInt(5);
    headerBlock.writeBytes(valueBytes);
    headerBlock.writeBytes(zlibSyncFlush);
    decoder.decode(ByteBufAllocator.DEFAULT,headerBlock,frame);
    decoder.endHeaderBlock(frame);
    assertFalse(headerBlock.isReadable());
    assertFalse(frame.isInvalid());
    assertEquals(1,frame.headers().names().size());
    assertTrue(frame.headers().contains(name));
    assertEquals(1,frame.headers().getAll(name).size());
    assertEquals(value,frame.headers().get(name));
    headerBlock.release();
  }
  @Test public void testHeaderBlockMultipleDecodes() throws Exception {
    ByteBuf headerBlock=Unpooled.buffer(37);
    headerBlock.writeBytes(zlibHeader);
    headerBlock.writeByte(0);
    headerBlock.writeByte(0x15);
    headerBlock.writeByte(0x00);
    headerBlock.writeByte(0xea);
    headerBlock.writeByte(0xff);
    headerBlock.writeInt(1);
    headerBlock.writeInt(4);
    headerBlock.writeBytes(nameBytes);
    headerBlock.writeInt(5);
    headerBlock.writeBytes(valueBytes);
    headerBlock.writeBytes(zlibSyncFlush);
    int readableBytes=headerBlock.readableBytes();
    for (int i=0; i < readableBytes; i++) {
      ByteBuf headerBlockSegment=headerBlock.slice(i,1);
      decoder.decode(ByteBufAllocator.DEFAULT,headerBlockSegment,frame);
      assertFalse(headerBlockSegment.isReadable());
    }
    decoder.endHeaderBlock(frame);
    assertFalse(frame.isInvalid());
    assertEquals(1,frame.headers().names().size());
    assertTrue(frame.headers().contains(name));
    assertEquals(1,frame.headers().getAll(name).size());
    assertEquals(value,frame.headers().get(name));
    headerBlock.release();
  }
  @Test public void testLargeHeaderName() throws Exception {
    ByteBuf headerBlock=Unpooled.buffer(8220);
    headerBlock.writeBytes(zlibHeader);
    headerBlock.writeByte(0);
    headerBlock.writeByte(0x0c);
    headerBlock.writeByte(0x20);
    headerBlock.writeByte(0xf3);
    headerBlock.writeByte(0xdf);
    headerBlock.writeInt(1);
    headerBlock.writeInt(8192);
    for (int i=0; i < 8192; i++) {
      headerBlock.writeByte('n');
    }
    headerBlock.writeInt(0);
    headerBlock.writeBytes(zlibSyncFlush);
    decoder.decode(ByteBufAllocator.DEFAULT,headerBlock,frame);
    decoder.endHeaderBlock(frame);
    assertFalse(headerBlock.isReadable());
    assertFalse(frame.isInvalid());
    assertFalse(frame.isTruncated());
    assertEquals(1,frame.headers().names().size());
    headerBlock.release();
  }
  @Test public void testLargeHeaderValue() throws Exception {
    ByteBuf headerBlock=Unpooled.buffer(8220);
    headerBlock.writeBytes(zlibHeader);
    headerBlock.writeByte(0);
    headerBlock.writeByte(0x0c);
    headerBlock.writeByte(0x20);
    headerBlock.writeByte(0xf3);
    headerBlock.writeByte(0xdf);
    headerBlock.writeInt(1);
    headerBlock.writeInt(1);
    headerBlock.writeByte('n');
    headerBlock.writeInt(8191);
    for (int i=0; i < 8191; i++) {
      headerBlock.writeByte('v');
    }
    headerBlock.writeBytes(zlibSyncFlush);
    decoder.decode(ByteBufAllocator.DEFAULT,headerBlock,frame);
    decoder.endHeaderBlock(frame);
    assertFalse(headerBlock.isReadable());
    assertFalse(frame.isInvalid());
    assertFalse(frame.isTruncated());
    assertEquals(1,frame.headers().names().size());
    assertEquals(8191,frame.headers().get("n").length());
    headerBlock.release();
  }
  @Test(expected=SpdyProtocolException.class) public void testHeaderBlockExtraData() throws Exception {
    ByteBuf headerBlock=Unpooled.buffer(37);
    headerBlock.writeBytes(zlibHeader);
    headerBlock.writeByte(0);
    headerBlock.writeByte(0x15);
    headerBlock.writeByte(0x00);
    headerBlock.writeByte(0xea);
    headerBlock.writeByte(0xff);
    headerBlock.writeInt(1);
    headerBlock.writeInt(4);
    headerBlock.writeBytes(nameBytes);
    headerBlock.writeInt(5);
    headerBlock.writeBytes(valueBytes);
    headerBlock.writeByte(0x19);
    headerBlock.writeByte(0xa5);
    headerBlock.writeByte(0x03);
    headerBlock.writeByte(0xc9);
    headerBlock.writeByte(0);
    decoder.decode(ByteBufAllocator.DEFAULT,headerBlock,frame);
    headerBlock.release();
  }
  @Test(expected=SpdyProtocolException.class) public void testHeaderBlockInvalidDictionary() throws Exception {
    ByteBuf headerBlock=Unpooled.buffer(7);
    headerBlock.writeByte(0x78);
    headerBlock.writeByte(0x3f);
    headerBlock.writeByte(0x01);
    headerBlock.writeByte(0x02);
    headerBlock.writeByte(0x03);
    headerBlock.writeByte(0x04);
    headerBlock.writeByte(0);
    decoder.decode(ByteBufAllocator.DEFAULT,headerBlock,frame);
    headerBlock.release();
  }
  @Test(expected=SpdyProtocolException.class) public void testHeaderBlockInvalidDeflateBlock() throws Exception {
    ByteBuf headerBlock=Unpooled.buffer(11);
    headerBlock.writeBytes(zlibHeader);
    headerBlock.writeByte(0);
    headerBlock.writeByte(0x00);
    headerBlock.writeByte(0x00);
    headerBlock.writeByte(0x00);
    headerBlock.writeByte(0x00);
    decoder.decode(ByteBufAllocator.DEFAULT,headerBlock,frame);
    headerBlock.release();
  }
}
