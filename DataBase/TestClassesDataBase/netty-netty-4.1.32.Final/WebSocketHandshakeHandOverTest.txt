public class WebSocketHandshakeHandOverTest {
  private boolean serverReceivedHandshake;
  private WebSocketServerProtocolHandler.HandshakeComplete serverHandshakeComplete;
  private boolean clientReceivedHandshake;
  private boolean clientReceivedMessage;
  @Before public void setUp(){
    serverReceivedHandshake=false;
    serverHandshakeComplete=null;
    clientReceivedHandshake=false;
    clientReceivedMessage=false;
  }
  @Test public void testHandover() throws Exception {
    EmbeddedChannel serverChannel=createServerChannel(new SimpleChannelInboundHandler<Object>(){
      @Override public void userEventTriggered(      ChannelHandlerContext ctx,      Object evt){
        if (evt == ServerHandshakeStateEvent.HANDSHAKE_COMPLETE) {
          serverReceivedHandshake=true;
          ctx.writeAndFlush(new TextWebSocketFrame("abc"));
        }
 else         if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) {
          serverHandshakeComplete=(WebSocketServerProtocolHandler.HandshakeComplete)evt;
        }
      }
      @Override protected void channelRead0(      ChannelHandlerContext ctx,      Object msg) throws Exception {
      }
    }
);
    EmbeddedChannel clientChannel=createClientChannel(new SimpleChannelInboundHandler<Object>(){
      @Override public void userEventTriggered(      ChannelHandlerContext ctx,      Object evt){
        if (evt == ClientHandshakeStateEvent.HANDSHAKE_COMPLETE) {
          clientReceivedHandshake=true;
        }
      }
      @Override protected void channelRead0(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        if (msg instanceof TextWebSocketFrame) {
          clientReceivedMessage=true;
        }
      }
    }
);
    transferAllDataWithMerge(clientChannel,serverChannel);
    assertTrue(serverReceivedHandshake);
    assertNotNull(serverHandshakeComplete);
    assertEquals("/test",serverHandshakeComplete.requestUri());
    assertEquals(8,serverHandshakeComplete.requestHeaders().size());
    assertEquals("test-proto-2",serverHandshakeComplete.selectedSubprotocol());
    transferAllDataWithMerge(serverChannel,clientChannel);
    assertTrue(clientReceivedHandshake);
    assertTrue(clientReceivedMessage);
  }
  /** 
 * Transfers all pending data from the source channel into the destination channel.<br> Merges all data into a single buffer before transmission into the destination.
 * @param srcChannel The source channel
 * @param dstChannel The destination channel
 */
  private static void transferAllDataWithMerge(  EmbeddedChannel srcChannel,  EmbeddedChannel dstChannel){
    ByteBuf mergedBuffer=null;
    for (; ; ) {
      Object srcData=srcChannel.readOutbound();
      if (srcData != null) {
        assertTrue(srcData instanceof ByteBuf);
        ByteBuf srcBuf=(ByteBuf)srcData;
        try {
          if (mergedBuffer == null) {
            mergedBuffer=Unpooled.buffer();
          }
          mergedBuffer.writeBytes(srcBuf);
        }
  finally {
          srcBuf.release();
        }
      }
 else {
        break;
      }
    }
    if (mergedBuffer != null) {
      dstChannel.writeInbound(mergedBuffer);
    }
  }
  private static EmbeddedChannel createClientChannel(  ChannelHandler handler) throws Exception {
    return new EmbeddedChannel(new HttpClientCodec(),new HttpObjectAggregator(8192),new WebSocketClientProtocolHandler(new URI("ws://localhost:1234/test"),WebSocketVersion.V13,"test-proto-2",false,null,65536),handler);
  }
  private static EmbeddedChannel createServerChannel(  ChannelHandler handler){
    return new EmbeddedChannel(new HttpServerCodec(),new HttpObjectAggregator(8192),new WebSocketServerProtocolHandler("/test","test-proto-1, test-proto-2",false),handler);
  }
}
