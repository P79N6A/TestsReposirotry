public class RecyclerTest {
  private static Recycler<HandledObject> newRecycler(  int max){
    return new Recycler<HandledObject>(max){
      @Override protected HandledObject newObject(      Recycler.Handle<HandledObject> handle){
        return new HandledObject(handle);
      }
    }
;
  }
  @Test(timeout=5000L) public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced() throws Exception {
    final Recycler<HandledObject> recycler=newRecycler(1024);
    final AtomicBoolean collected=new AtomicBoolean();
    final AtomicReference<HandledObject> reference=new AtomicReference<HandledObject>();
    Thread thread=new Thread(new Runnable(){
      @Override public void run(){
        HandledObject object=recycler.get();
        reference.set(object);
      }
    }
){
      @Override protected void finalize() throws Throwable {
        super.finalize();
        collected.set(true);
      }
    }
;
    assertFalse(collected.get());
    thread.start();
    thread.join();
    thread=null;
    while (!collected.get()) {
      System.gc();
      System.runFinalization();
      Thread.sleep(50);
    }
    reference.getAndSet(null).recycle();
  }
  @Test(expected=IllegalStateException.class) public void testMultipleRecycle(){
    Recycler<HandledObject> recycler=newRecycler(1024);
    HandledObject object=recycler.get();
    object.recycle();
    object.recycle();
  }
  @Test(expected=IllegalStateException.class) public void testMultipleRecycleAtDifferentThread() throws InterruptedException {
    Recycler<HandledObject> recycler=newRecycler(1024);
    final HandledObject object=recycler.get();
    final AtomicReference<IllegalStateException> exceptionStore=new AtomicReference<IllegalStateException>();
    final Thread thread1=new Thread(new Runnable(){
      @Override public void run(){
        object.recycle();
      }
    }
);
    thread1.start();
    thread1.join();
    final Thread thread2=new Thread(new Runnable(){
      @Override public void run(){
        try {
          object.recycle();
        }
 catch (        IllegalStateException e) {
          exceptionStore.set(e);
        }
      }
    }
);
    thread2.start();
    thread2.join();
    IllegalStateException exception=exceptionStore.get();
    if (exception != null) {
      throw exception;
    }
  }
  @Test public void testRecycle(){
    Recycler<HandledObject> recycler=newRecycler(1024);
    HandledObject object=recycler.get();
    object.recycle();
    HandledObject object2=recycler.get();
    assertSame(object,object2);
    object2.recycle();
  }
  @Test public void testRecycleDisable(){
    Recycler<HandledObject> recycler=newRecycler(-1);
    HandledObject object=recycler.get();
    object.recycle();
    HandledObject object2=recycler.get();
    assertNotSame(object,object2);
    object2.recycle();
  }
  /** 
 * Test to make sure bug #2848 never happens again https://github.com/netty/netty/issues/2848
 */
  @Test public void testMaxCapacity(){
    testMaxCapacity(300);
    Random rand=new Random();
    for (int i=0; i < 50; i++) {
      testMaxCapacity(rand.nextInt(1000) + 256);
    }
  }
  private static void testMaxCapacity(  int maxCapacity){
    Recycler<HandledObject> recycler=newRecycler(maxCapacity);
    HandledObject[] objects=new HandledObject[maxCapacity * 3];
    for (int i=0; i < objects.length; i++) {
      objects[i]=recycler.get();
    }
    for (int i=0; i < objects.length; i++) {
      objects[i].recycle();
      objects[i]=null;
    }
    assertTrue("The threadLocalCapacity (" + recycler.threadLocalCapacity() + ") must be <= maxCapacity ("+ maxCapacity+ ") as we not pool all new handles internally",maxCapacity >= recycler.threadLocalCapacity());
  }
  @Test public void testRecycleAtDifferentThread() throws Exception {
    final Recycler<HandledObject> recycler=new Recycler<HandledObject>(256,10,2,10){
      @Override protected HandledObject newObject(      Recycler.Handle<HandledObject> handle){
        return new HandledObject(handle);
      }
    }
;
    final HandledObject o=recycler.get();
    final HandledObject o2=recycler.get();
    final Thread thread=new Thread(){
      @Override public void run(){
        o.recycle();
        o2.recycle();
      }
    }
;
    thread.start();
    thread.join();
    assertSame(recycler.get(),o);
    assertNotSame(recycler.get(),o2);
  }
  @Test public void testMaxCapacityWithRecycleAtDifferentThread() throws Exception {
    final int maxCapacity=4;
    final Recycler<HandledObject> recycler=newRecycler(maxCapacity);
    final HandledObject[] array=new HandledObject[maxCapacity * 3];
    for (int i=0; i < array.length; i++) {
      array[i]=recycler.get();
    }
    for (int i=0; i < maxCapacity; i++) {
      array[i].recycle();
    }
    final Thread thread=new Thread(){
      @Override public void run(){
        for (int i=maxCapacity; i < array.length; i++) {
          array[i].recycle();
        }
      }
    }
;
    thread.start();
    thread.join();
    assertEquals(maxCapacity,recycler.threadLocalCapacity());
    assertEquals(1,recycler.threadLocalSize());
    for (int i=0; i < array.length; i++) {
      recycler.get();
    }
    assertEquals(maxCapacity,recycler.threadLocalCapacity());
    assertEquals(0,recycler.threadLocalSize());
  }
  @Test public void testDiscardingExceedingElementsWithRecycleAtDifferentThread() throws Exception {
    final int maxCapacity=32;
    final AtomicInteger instancesCount=new AtomicInteger(0);
    final Recycler<HandledObject> recycler=new Recycler<HandledObject>(maxCapacity,2){
      @Override protected HandledObject newObject(      Recycler.Handle<HandledObject> handle){
        instancesCount.incrementAndGet();
        return new HandledObject(handle);
      }
    }
;
    final HandledObject[] array=new HandledObject[maxCapacity * 2];
    for (int i=0; i < array.length; i++) {
      array[i]=recycler.get();
    }
    assertEquals(array.length,instancesCount.get());
    instancesCount.set(0);
    final Thread thread=new Thread(){
      @Override public void run(){
        for (        HandledObject object : array) {
          object.recycle();
        }
      }
    }
;
    thread.start();
    thread.join();
    assertEquals(0,instancesCount.get());
    for (int i=0; i < array.length; i++) {
      recycler.get();
    }
    assertTrue("The instances count (" + instancesCount.get() + ") must be <= array.length ("+ array.length+ ") - maxCapacity ("+ maxCapacity+ ") / 2 as we not pool all new handles"+ " internally",array.length - maxCapacity / 2 <= instancesCount.get());
  }
static final class HandledObject {
    Recycler.Handle<HandledObject> handle;
    HandledObject(    Recycler.Handle<HandledObject> handle){
      this.handle=handle;
    }
    void recycle(){
      handle.recycle(this);
    }
  }
}
