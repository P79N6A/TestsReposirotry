public class AdaptiveRecvByteBufAllocatorTest {
  @Mock private ChannelConfig config;
  private ByteBufAllocator alloc=UnpooledByteBufAllocator.DEFAULT;
  private RecvByteBufAllocator.ExtendedHandle handle;
  @Before public void setup(){
    config=mock(ChannelConfig.class);
    when(config.isAutoRead()).thenReturn(true);
    AdaptiveRecvByteBufAllocator recvByteBufAllocator=new AdaptiveRecvByteBufAllocator(64,512,1024 * 1024 * 10);
    handle=(RecvByteBufAllocator.ExtendedHandle)recvByteBufAllocator.newHandle();
    handle.reset(config);
  }
  @Test public void rampUpBeforeReadCompleteWhenLargeDataPending(){
    allocReadExpected(handle,alloc,512);
    allocReadExpected(handle,alloc,8192);
    allocReadExpected(handle,alloc,131072);
    allocReadExpected(handle,alloc,2097152);
    handle.readComplete();
    handle.reset(config);
    allocReadExpected(handle,alloc,8388608);
  }
  @Test public void lastPartialReadDoesNotRampDown(){
    allocReadExpected(handle,alloc,512);
    allocRead(handle,alloc,8192,1);
    handle.readComplete();
    handle.reset(config);
    allocReadExpected(handle,alloc,8192);
  }
  @Test public void lastPartialReadCanRampUp(){
    allocReadExpected(handle,alloc,512);
    allocRead(handle,alloc,8192,8191);
    handle.readComplete();
    handle.reset(config);
    allocReadExpected(handle,alloc,131072);
  }
  private static void allocReadExpected(  RecvByteBufAllocator.ExtendedHandle handle,  ByteBufAllocator alloc,  int expectedSize){
    allocRead(handle,alloc,expectedSize,expectedSize);
  }
  private static void allocRead(  RecvByteBufAllocator.ExtendedHandle handle,  ByteBufAllocator alloc,  int expectedBufferSize,  int lastRead){
    ByteBuf buf=handle.allocate(alloc);
    assertEquals(expectedBufferSize,buf.capacity());
    handle.attemptedBytesRead(expectedBufferSize);
    handle.lastBytesRead(lastRead);
    handle.incMessagesRead(1);
    buf.release();
  }
}
