@RunWith(MockitoJUnitRunner.class) public class OptionalSslHandlerTest {
  private static final String SSL_HANDLER_NAME="sslhandler";
  private static final String HANDLER_NAME="handler";
  @Mock private ChannelHandlerContext context;
  @Mock private SslContext sslContext;
  @Mock private ChannelPipeline pipeline;
  @Before public void setUp() throws Exception {
    when(context.pipeline()).thenReturn(pipeline);
  }
  @Test public void handlerRemoved() throws Exception {
    OptionalSslHandler handler=new OptionalSslHandler(sslContext);
    final ByteBuf payload=Unpooled.copiedBuffer("plaintext".getBytes());
    try {
      handler.decode(context,payload,null);
      verify(pipeline).remove(handler);
    }
  finally {
      payload.release();
    }
  }
  @Test public void handlerReplaced() throws Exception {
    final ChannelHandler nonSslHandler=Mockito.mock(ChannelHandler.class);
    OptionalSslHandler handler=new OptionalSslHandler(sslContext){
      @Override protected ChannelHandler newNonSslHandler(      ChannelHandlerContext context){
        return nonSslHandler;
      }
      @Override protected String newNonSslHandlerName(){
        return HANDLER_NAME;
      }
    }
;
    final ByteBuf payload=Unpooled.copiedBuffer("plaintext".getBytes());
    try {
      handler.decode(context,payload,null);
      verify(pipeline).replace(handler,HANDLER_NAME,nonSslHandler);
    }
  finally {
      payload.release();
    }
  }
  @Test public void sslHandlerReplaced() throws Exception {
    final SslHandler sslHandler=Mockito.mock(SslHandler.class);
    OptionalSslHandler handler=new OptionalSslHandler(sslContext){
      @Override protected SslHandler newSslHandler(      ChannelHandlerContext context,      SslContext sslContext){
        return sslHandler;
      }
      @Override protected String newSslHandlerName(){
        return SSL_HANDLER_NAME;
      }
    }
;
    final ByteBuf payload=Unpooled.wrappedBuffer(new byte[]{22,3,1,0,5});
    try {
      handler.decode(context,payload,null);
      verify(pipeline).replace(handler,SSL_HANDLER_NAME,sslHandler);
    }
  finally {
      payload.release();
    }
  }
  @Test public void decodeBuffered() throws Exception {
    OptionalSslHandler handler=new OptionalSslHandler(sslContext);
    final ByteBuf payload=Unpooled.wrappedBuffer(new byte[]{22,3});
    try {
      handler.decode(context,payload,null);
      verifyZeroInteractions(pipeline);
    }
  finally {
      payload.release();
    }
  }
}
