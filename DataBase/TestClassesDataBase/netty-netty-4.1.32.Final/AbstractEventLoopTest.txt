public abstract class AbstractEventLoopTest {
  /** 
 * Test for https://github.com/netty/netty/issues/803
 */
  @Test public void testReregister(){
    EventLoopGroup group=newEventLoopGroup();
    EventLoopGroup group2=newEventLoopGroup();
    final EventExecutorGroup eventExecutorGroup=new DefaultEventExecutorGroup(2);
    ServerBootstrap bootstrap=new ServerBootstrap();
    ChannelFuture future=bootstrap.channel(newChannel()).group(group).childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
      }
    }
).handler(new ChannelInitializer<ServerSocketChannel>(){
      @Override public void initChannel(      ServerSocketChannel ch) throws Exception {
        ch.pipeline().addLast(new TestChannelHandler());
        ch.pipeline().addLast(eventExecutorGroup,new TestChannelHandler2());
      }
    }
).bind(0).awaitUninterruptibly();
    EventExecutor executor=future.channel().pipeline().context(TestChannelHandler2.class).executor();
    EventExecutor executor1=future.channel().pipeline().context(TestChannelHandler.class).executor();
    future.channel().deregister().awaitUninterruptibly();
    Channel channel=group2.register(future.channel()).awaitUninterruptibly().channel();
    EventExecutor executorNew=channel.pipeline().context(TestChannelHandler.class).executor();
    assertNotSame(executor1,executorNew);
    assertSame(executor,future.channel().pipeline().context(TestChannelHandler2.class).executor());
  }
  @Test(timeout=5000) public void testShutdownGracefullyNoQuietPeriod() throws Exception {
    EventLoopGroup loop=newEventLoopGroup();
    ServerBootstrap b=new ServerBootstrap();
    b.group(loop).channel(newChannel()).childHandler(new ChannelInboundHandlerAdapter());
    b.bind(0).sync().channel();
    Future<?> f=loop.shutdownGracefully(0,1,TimeUnit.MINUTES);
    assertTrue(loop.awaitTermination(2,TimeUnit.SECONDS));
    assertTrue(f.syncUninterruptibly().isSuccess());
    assertTrue(loop.isShutdown());
    assertTrue(loop.isTerminated());
  }
private static final class TestChannelHandler extends ChannelDuplexHandler {
  }
private static final class TestChannelHandler2 extends ChannelDuplexHandler {
    @Override public void channelRead(    ChannelHandlerContext ctx,    Object msg) throws Exception {
    }
  }
  protected abstract EventLoopGroup newEventLoopGroup();
  protected abstract Class<? extends ServerSocketChannel> newChannel();
}
