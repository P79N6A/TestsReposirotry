public class CompositeBufferGatheringWriteTest extends AbstractSocketTest {
  private static final int EXPECTED_BYTES=20;
  @Test(timeout=10000) public void testSingleCompositeBufferWrite() throws Throwable {
    run();
  }
  public void testSingleCompositeBufferWrite(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    Channel serverChannel=null;
    Channel clientChannel=null;
    try {
      final CountDownLatch latch=new CountDownLatch(1);
      final AtomicReference<Object> clientReceived=new AtomicReference<Object>();
      sb.childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void channelActive(            ChannelHandlerContext ctx) throws Exception {
              ctx.writeAndFlush(newCompositeBuffer(ctx.alloc())).addListener(ChannelFutureListener.CLOSE);
            }
          }
);
        }
      }
);
      cb.handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            private ByteBuf aggregator;
            @Override public void handlerAdded(            ChannelHandlerContext ctx){
              aggregator=ctx.alloc().buffer(EXPECTED_BYTES);
            }
            @Override public void channelRead(            ChannelHandlerContext ctx,            Object msg){
              try {
                if (msg instanceof ByteBuf) {
                  aggregator.writeBytes((ByteBuf)msg);
                }
              }
  finally {
                ReferenceCountUtil.release(msg);
              }
            }
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause) throws Exception {
              if (!(cause instanceof IOException)) {
                clientReceived.set(cause);
                latch.countDown();
              }
            }
            @Override public void channelInactive(            ChannelHandlerContext ctx) throws Exception {
              if (clientReceived.compareAndSet(null,aggregator)) {
                try {
                  assertEquals(EXPECTED_BYTES,aggregator.readableBytes());
                }
 catch (                Throwable cause) {
                  aggregator.release();
                  aggregator=null;
                  clientReceived.set(cause);
                }
 finally {
                  latch.countDown();
                }
              }
            }
          }
);
        }
      }
);
      serverChannel=sb.bind().syncUninterruptibly().channel();
      clientChannel=cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      ByteBuf expected=newCompositeBuffer(clientChannel.alloc());
      latch.await();
      Object received=clientReceived.get();
      if (received instanceof ByteBuf) {
        ByteBuf actual=(ByteBuf)received;
        assertEquals(expected,actual);
        expected.release();
        actual.release();
      }
 else {
        expected.release();
        throw (Throwable)received;
      }
    }
  finally {
      if (clientChannel != null) {
        clientChannel.close().sync();
      }
      if (serverChannel != null) {
        serverChannel.close().sync();
      }
    }
  }
  @Test(timeout=10000) public void testCompositeBufferPartialWriteDoesNotCorruptData() throws Throwable {
    run();
  }
  protected void compositeBufferPartialWriteDoesNotCorruptDataInitServerConfig(  ChannelConfig config,  int soSndBuf){
  }
  public void testCompositeBufferPartialWriteDoesNotCorruptData(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    Channel serverChannel=null;
    Channel clientChannel=null;
    try {
      Random r=new Random();
      final int soSndBuf=1024;
      ByteBufAllocator alloc=ByteBufAllocator.DEFAULT;
      final ByteBuf expectedContent=alloc.buffer(soSndBuf * 2);
      expectedContent.writeBytes(newRandomBytes(expectedContent.writableBytes(),r));
      final CountDownLatch latch=new CountDownLatch(1);
      final AtomicReference<Object> clientReceived=new AtomicReference<Object>();
      sb.childOption(ChannelOption.SO_SNDBUF,soSndBuf).childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void channelActive(            ChannelHandlerContext ctx) throws Exception {
              compositeBufferPartialWriteDoesNotCorruptDataInitServerConfig(ctx.channel().config(),soSndBuf);
              int offset=soSndBuf - 100;
              ctx.write(expectedContent.retainedSlice(expectedContent.readerIndex(),offset));
              CompositeByteBuf compositeByteBuf=ctx.alloc().compositeBuffer();
              compositeByteBuf.addComponent(true,expectedContent.retainedSlice(expectedContent.readerIndex() + offset,50));
              offset+=50;
              compositeByteBuf.addComponent(true,expectedContent.retainedSlice(expectedContent.readerIndex() + offset,200));
              offset+=200;
              ctx.write(compositeByteBuf);
              ctx.write(expectedContent.retainedSlice(expectedContent.readerIndex() + offset,50));
              offset+=50;
              ctx.writeAndFlush(expectedContent.retainedSlice(expectedContent.readerIndex() + offset,expectedContent.readableBytes() - expectedContent.readerIndex() - offset)).addListener(ChannelFutureListener.CLOSE);
            }
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause) throws Exception {
              if (!(cause instanceof IOException)) {
                clientReceived.set(cause);
                latch.countDown();
              }
            }
          }
);
        }
      }
);
      cb.handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            private ByteBuf aggregator;
            @Override public void handlerAdded(            ChannelHandlerContext ctx){
              aggregator=ctx.alloc().buffer(expectedContent.readableBytes());
            }
            @Override public void channelRead(            ChannelHandlerContext ctx,            Object msg){
              try {
                if (msg instanceof ByteBuf) {
                  aggregator.writeBytes((ByteBuf)msg);
                }
              }
  finally {
                ReferenceCountUtil.release(msg);
              }
            }
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause) throws Exception {
              if (!(cause instanceof IOException)) {
                clientReceived.set(cause);
                latch.countDown();
              }
            }
            @Override public void channelInactive(            ChannelHandlerContext ctx) throws Exception {
              if (clientReceived.compareAndSet(null,aggregator)) {
                try {
                  assertEquals(expectedContent.readableBytes(),aggregator.readableBytes());
                }
 catch (                Throwable cause) {
                  aggregator.release();
                  aggregator=null;
                  clientReceived.set(cause);
                }
 finally {
                  latch.countDown();
                }
              }
            }
          }
);
        }
      }
);
      serverChannel=sb.bind().syncUninterruptibly().channel();
      clientChannel=cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      latch.await();
      Object received=clientReceived.get();
      if (received instanceof ByteBuf) {
        ByteBuf actual=(ByteBuf)received;
        assertEquals(expectedContent,actual);
        expectedContent.release();
        actual.release();
      }
 else {
        expectedContent.release();
        throw (Throwable)received;
      }
    }
  finally {
      if (clientChannel != null) {
        clientChannel.close().sync();
      }
      if (serverChannel != null) {
        serverChannel.close().sync();
      }
    }
  }
  private static ByteBuf newCompositeBuffer(  ByteBufAllocator alloc){
    CompositeByteBuf compositeByteBuf=alloc.compositeBuffer();
    compositeByteBuf.addComponent(true,alloc.directBuffer(4).writeInt(100));
    compositeByteBuf.addComponent(true,alloc.directBuffer(8).writeLong(123));
    compositeByteBuf.addComponent(true,alloc.directBuffer(8).writeLong(456));
    assertEquals(EXPECTED_BYTES,compositeByteBuf.readableBytes());
    return compositeByteBuf;
  }
  private static byte[] newRandomBytes(  int size,  Random r){
    byte[] bytes=new byte[size];
    r.nextBytes(bytes);
    return bytes;
  }
}
