@RunWith(Parameterized.class) public class SslErrorTest {
  @Parameterized.Parameters(name="{index}: serverProvider = {0}, clientProvider = {1}, exception = {2}") public static Collection<Object[]> data(){
    List<SslProvider> serverProviders=new ArrayList<SslProvider>(2);
    List<SslProvider> clientProviders=new ArrayList<SslProvider>(3);
    if (OpenSsl.isAvailable()) {
      serverProviders.add(SslProvider.OPENSSL);
      serverProviders.add(SslProvider.OPENSSL_REFCNT);
      clientProviders.add(SslProvider.OPENSSL);
      clientProviders.add(SslProvider.OPENSSL_REFCNT);
    }
    clientProviders.add(SslProvider.JDK);
    List<CertificateException> exceptions=new ArrayList<CertificateException>(6);
    exceptions.add(new CertificateExpiredException());
    exceptions.add(new CertificateNotYetValidException());
    exceptions.add(new CertificateRevokedException(new Date(),CRLReason.AA_COMPROMISE,new X500Principal(""),Collections.<String,Extension>emptyMap()));
    exceptions.add(newCertificateException(CertPathValidatorException.BasicReason.EXPIRED));
    exceptions.add(newCertificateException(CertPathValidatorException.BasicReason.NOT_YET_VALID));
    exceptions.add(newCertificateException(CertPathValidatorException.BasicReason.REVOKED));
    List<Object[]> params=new ArrayList<Object[]>();
    for (    SslProvider serverProvider : serverProviders) {
      for (      SslProvider clientProvider : clientProviders) {
        for (        CertificateException exception : exceptions) {
          params.add(new Object[]{serverProvider,clientProvider,exception});
        }
      }
    }
    return params;
  }
  private static CertificateException newCertificateException(  CertPathValidatorException.Reason reason){
    return new TestCertificateException(new CertPathValidatorException("x",null,null,-1,reason));
  }
  private final SslProvider serverProvider;
  private final SslProvider clientProvider;
  private final CertificateException exception;
  public SslErrorTest(  SslProvider serverProvider,  SslProvider clientProvider,  CertificateException exception){
    this.serverProvider=serverProvider;
    this.clientProvider=clientProvider;
    this.exception=exception;
  }
  @Test(timeout=30000) public void testCorrectAlert() throws Exception {
    Assume.assumeTrue(OpenSsl.isAvailable());
    SelfSignedCertificate ssc=new SelfSignedCertificate();
    final SslContext sslServerCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(serverProvider).trustManager(new SimpleTrustManagerFactory(){
      @Override protected void engineInit(      KeyStore keyStore){
      }
      @Override protected void engineInit(      ManagerFactoryParameters managerFactoryParameters){
      }
      @Override protected TrustManager[] engineGetTrustManagers(){
        return new TrustManager[]{new X509TrustManager(){
          @Override public void checkClientTrusted(          X509Certificate[] x509Certificates,          String s) throws CertificateException {
            throw exception;
          }
          @Override public void checkServerTrusted(          X509Certificate[] x509Certificates,          String s) throws CertificateException {
          }
          @Override public X509Certificate[] getAcceptedIssuers(){
            return EmptyArrays.EMPTY_X509_CERTIFICATES;
          }
        }
};
      }
    }
).clientAuth(ClientAuth.REQUIRE).build();
    final SslContext sslClientCtx=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).keyManager(new File(getClass().getResource("test.crt").getFile()),new File(getClass().getResource("test_unencrypted.pem").getFile())).sslProvider(clientProvider).build();
    Channel serverChannel=null;
    Channel clientChannel=null;
    EventLoopGroup group=new NioEventLoopGroup();
    try {
      serverChannel=new ServerBootstrap().group(group).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(sslServerCtx.newHandler(ch.alloc()));
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause){
              ctx.close();
            }
          }
);
        }
      }
).bind(0).sync().channel();
      final Promise<Void> promise=group.next().newPromise();
      clientChannel=new Bootstrap().group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(sslClientCtx.newHandler(ch.alloc()));
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause){
              Throwable unwrappedCause=cause.getCause();
              if (unwrappedCause instanceof SSLException) {
                if (exception instanceof TestCertificateException) {
                  CertPathValidatorException.Reason reason=((CertPathValidatorException)exception.getCause()).getReason();
                  if (reason == CertPathValidatorException.BasicReason.EXPIRED) {
                    verifyException(unwrappedCause,"expired",promise);
                  }
 else                   if (reason == CertPathValidatorException.BasicReason.NOT_YET_VALID) {
                    if (OpenSsl.isBoringSSL()) {
                      verifyException(unwrappedCause,"expired",promise);
                    }
 else {
                      verifyException(unwrappedCause,"bad",promise);
                    }
                  }
 else                   if (reason == CertPathValidatorException.BasicReason.REVOKED) {
                    verifyException(unwrappedCause,"revoked",promise);
                  }
                }
 else                 if (exception instanceof CertificateExpiredException) {
                  verifyException(unwrappedCause,"expired",promise);
                }
 else                 if (exception instanceof CertificateNotYetValidException) {
                  if (OpenSsl.isBoringSSL()) {
                    verifyException(unwrappedCause,"expired",promise);
                  }
 else {
                    verifyException(unwrappedCause,"bad",promise);
                  }
                }
 else                 if (exception instanceof CertificateRevokedException) {
                  verifyException(unwrappedCause,"revoked",promise);
                }
              }
            }
          }
);
        }
      }
).connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      promise.syncUninterruptibly();
    }
  finally {
      if (clientChannel != null) {
        clientChannel.close().syncUninterruptibly();
      }
      if (serverChannel != null) {
        serverChannel.close().syncUninterruptibly();
      }
      group.shutdownGracefully();
      ReferenceCountUtil.release(sslServerCtx);
      ReferenceCountUtil.release(sslClientCtx);
    }
  }
  private static void verifyException(  Throwable cause,  String messagePart,  Promise<Void> promise){
    String message=cause.getMessage();
    if (message.toLowerCase(Locale.UK).contains(messagePart.toLowerCase(Locale.UK))) {
      promise.setSuccess(null);
    }
 else {
      Throwable error=new AssertionError("message not contains '" + messagePart + "': "+ message);
      error.initCause(cause);
      promise.setFailure(error);
    }
  }
private static final class TestCertificateException extends CertificateException {
    private static final long serialVersionUID=-5816338303868751410L;
    public TestCertificateException(    Throwable cause){
      super(cause);
    }
  }
}
