public class ResourceLeakDetectorTest {
  @Test(timeout=60000) public void testConcurrentUsage() throws Throwable {
    final AtomicBoolean finished=new AtomicBoolean();
    final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    Thread[] threads=new Thread[50];
    final CyclicBarrier barrier=new CyclicBarrier(threads.length);
    for (int i=0; i < threads.length; i++) {
      Thread t=new Thread(new Runnable(){
        Queue<LeakAwareResource> resources=new ArrayDeque<LeakAwareResource>(100);
        @Override public void run(){
          try {
            barrier.await();
            for (int b=0; b < 1000 && !finished.get(); b++) {
              for (int a=0; a < 100; a++) {
                DefaultResource resource=new DefaultResource();
                ResourceLeakTracker<Resource> leak=DefaultResource.detector.track(resource);
                LeakAwareResource leakAwareResource=new LeakAwareResource(resource,leak);
                resources.add(leakAwareResource);
              }
              if (closeResources(true)) {
                finished.set(true);
              }
            }
          }
 catch (          InterruptedException e) {
            Thread.currentThread().interrupt();
          }
catch (          Throwable e) {
            error.compareAndSet(null,e);
          }
 finally {
            closeResources(false);
          }
        }
        private boolean closeResources(        boolean checkClosed){
          for (; ; ) {
            LeakAwareResource r=resources.poll();
            if (r == null) {
              return false;
            }
            boolean closed=r.close();
            if (checkClosed && !closed) {
              error.compareAndSet(null,new AssertionError("ResourceLeak.close() returned 'false' but expected 'true'"));
              return true;
            }
          }
        }
      }
);
      threads[i]=t;
      t.start();
    }
    for (    Thread t : threads) {
      t.join();
    }
    DefaultResource.detector.assertNoErrors();
    assertNoErrors(error);
  }
private static final class LeakAwareResource implements Resource {
    private final Resource resource;
    private final ResourceLeakTracker<Resource> leak;
    LeakAwareResource(    Resource resource,    ResourceLeakTracker<Resource> leak){
      this.resource=resource;
      this.leak=leak;
    }
    @Override public boolean close(){
      return leak.close(resource);
    }
  }
private static final class DefaultResource implements Resource {
    static final TestResourceLeakDetector<Resource> detector=new TestResourceLeakDetector<Resource>(Resource.class,1,Integer.MAX_VALUE);
    @Override public boolean close(){
      return true;
    }
  }
private interface Resource {
    boolean close();
  }
  private static void assertNoErrors(  AtomicReference<Throwable> ref) throws Throwable {
    Throwable error=ref.get();
    if (error != null) {
      throw error;
    }
  }
private static final class TestResourceLeakDetector<T> extends ResourceLeakDetector<T> {
    private final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    TestResourceLeakDetector(    Class<?> resourceType,    int samplingInterval,    long maxActive){
      super(resourceType,samplingInterval,maxActive);
    }
    @Override protected void reportTracedLeak(    String resourceType,    String records){
      reportError(new AssertionError("Leak reported for '" + resourceType + "':\n"+ records));
    }
    @Override protected void reportUntracedLeak(    String resourceType){
      reportError(new AssertionError("Leak reported for '" + resourceType + '\''));
    }
    @Override protected void reportInstancesLeak(    String resourceType){
      reportError(new AssertionError("Leak reported for '" + resourceType + '\''));
    }
    private void reportError(    AssertionError cause){
      error.compareAndSet(null,cause);
    }
    void assertNoErrors() throws Throwable {
      ResourceLeakDetectorTest.assertNoErrors(error);
    }
  }
}
