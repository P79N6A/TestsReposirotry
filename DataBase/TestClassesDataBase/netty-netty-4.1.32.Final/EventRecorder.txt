private static final class EventRecorder extends ChannelDuplexHandler {
  private final Queue<EventType> events;
  private final boolean inbound;
  EventRecorder(  Queue<EventType> events,  boolean inbound){
    this.events=events;
    this.inbound=inbound;
  }
  @Override public void exceptionCaught(  ChannelHandlerContext ctx,  Throwable cause) throws Exception {
    events.add(EventType.EXCEPTION_CAUGHT);
  }
  @Override public void userEventTriggered(  ChannelHandlerContext ctx,  Object evt) throws Exception {
    if (inbound) {
      events.add(EventType.USER_EVENT);
    }
  }
  @Override public void channelReadComplete(  ChannelHandlerContext ctx) throws Exception {
    if (inbound) {
      events.add(EventType.MESSAGE_RECEIVED_LAST);
    }
  }
  @Override public void channelInactive(  ChannelHandlerContext ctx) throws Exception {
    events.add(EventType.INACTIVE);
  }
  @Override public void channelActive(  ChannelHandlerContext ctx) throws Exception {
    events.add(EventType.ACTIVE);
  }
  @Override public void channelUnregistered(  ChannelHandlerContext ctx) throws Exception {
    events.add(EventType.UNREGISTERED);
  }
  @Override public void channelRegistered(  ChannelHandlerContext ctx) throws Exception {
    events.add(EventType.REGISTERED);
  }
  @Override public void channelRead(  ChannelHandlerContext ctx,  Object msg) throws Exception {
    if (inbound) {
      events.add(EventType.MESSAGE_RECEIVED);
    }
  }
  @Override public void write(  ChannelHandlerContext ctx,  Object msg,  ChannelPromise promise) throws Exception {
    if (!inbound) {
      events.add(EventType.WRITE);
    }
    promise.setSuccess();
  }
  @Override public void read(  ChannelHandlerContext ctx){
    if (!inbound) {
      events.add(EventType.READ);
    }
  }
}
