public class KQueueSocketChannelConfigTest {
  private static EventLoopGroup group;
  private static KQueueSocketChannel ch;
  private static Random rand;
  @BeforeClass public static void beforeClass(){
    rand=new Random();
    group=new KQueueEventLoopGroup(1);
  }
  @AfterClass public static void afterClass(){
    group.shutdownGracefully();
  }
  @Before public void setup(){
    Bootstrap bootstrap=new Bootstrap();
    ch=(KQueueSocketChannel)bootstrap.group(group).channel(KQueueSocketChannel.class).handler(new ChannelInboundHandlerAdapter()).bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
  }
  @After public void teardown(){
    ch.close().syncUninterruptibly();
  }
  @Test public void testRandomSndLowAt(){
    final int expected=Math.min(BSD_SND_LOW_AT_MAX,Math.abs(rand.nextInt()));
    final int actual;
    try {
      ch.config().setSndLowAt(expected);
      actual=ch.config().getSndLowAt();
    }
 catch (    RuntimeException e) {
      assumeNoException(e);
      return;
    }
    assertEquals(expected,actual);
  }
  @Test public void testInvalidHighSndLowAt(){
    try {
      ch.config().setSndLowAt(Integer.MIN_VALUE);
    }
 catch (    ChannelException e) {
      return;
    }
catch (    RuntimeException e) {
      assumeNoException(e);
    }
    fail();
  }
  @Test public void testTcpNoPush(){
    ch.config().setTcpNoPush(false);
    assertFalse(ch.config().isTcpNoPush());
    ch.config().setTcpNoPush(true);
    assertTrue(ch.config().isTcpNoPush());
  }
  @Test public void testSetOptionWhenClosed(){
    ch.close().syncUninterruptibly();
    try {
      ch.config().setSoLinger(0);
      fail();
    }
 catch (    ChannelException e) {
      assertTrue(e.getCause() instanceof ClosedChannelException);
    }
  }
  @Test public void testGetOptionWhenClosed(){
    ch.close().syncUninterruptibly();
    try {
      ch.config().getSoLinger();
      fail();
    }
 catch (    ChannelException e) {
      assertTrue(e.getCause() instanceof ClosedChannelException);
    }
  }
}
