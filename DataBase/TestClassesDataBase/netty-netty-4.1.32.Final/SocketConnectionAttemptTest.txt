public class SocketConnectionAttemptTest extends AbstractClientSocketTest {
  private static final int UNASSIGNED_PORT=4;
  @Test(timeout=30000) public void testConnectTimeout() throws Throwable {
    run();
  }
  public void testConnectTimeout(  Bootstrap cb) throws Throwable {
    cb.handler(new TestHandler()).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,2000);
    ChannelFuture future=cb.connect(BAD_HOST,BAD_PORT);
    try {
      assertThat(future.await(3000),is(true));
    }
  finally {
      future.channel().close();
    }
  }
  @Test(timeout=30000) public void testConnectRefused() throws Throwable {
    run();
  }
  public void testConnectRefused(  Bootstrap cb) throws Throwable {
    testConnectRefused0(cb,false);
  }
  @Test(timeout=30000) public void testConnectRefusedHalfClosure() throws Throwable {
    run();
  }
  public void testConnectRefusedHalfClosure(  Bootstrap cb) throws Throwable {
    testConnectRefused0(cb,true);
  }
  private static void testConnectRefused0(  Bootstrap cb,  boolean halfClosure) throws Throwable {
    final Promise<Error> errorPromise=GlobalEventExecutor.INSTANCE.newPromise();
    ChannelHandler handler=new ChannelInboundHandlerAdapter(){
      @Override public void channelActive(      ChannelHandlerContext ctx) throws Exception {
        errorPromise.setFailure(new AssertionError("should have never been called"));
      }
    }
;
    cb.handler(handler);
    cb.option(ChannelOption.ALLOW_HALF_CLOSURE,halfClosure);
    ChannelFuture future=cb.connect(NetUtil.LOCALHOST,UNASSIGNED_PORT).awaitUninterruptibly();
    assertThat(future.cause(),is(instanceOf(ConnectException.class)));
    assertThat(errorPromise.cause(),is(nullValue()));
  }
  @Test public void testConnectCancellation() throws Throwable {
    boolean badHostTimedOut=true;
    Socket socket=new Socket();
    try {
      SocketUtils.connect(socket,SocketUtils.socketAddress(BAD_HOST,BAD_PORT),10);
    }
 catch (    ConnectException e) {
      badHostTimedOut=false;
    }
catch (    Exception e) {
    }
 finally {
      try {
        socket.close();
      }
 catch (      IOException e) {
      }
    }
    assumeThat("The connection attempt to " + BAD_HOST + " does not time out.",badHostTimedOut,is(true));
    run();
  }
  public void testConnectCancellation(  Bootstrap cb) throws Throwable {
    cb.handler(new TestHandler()).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,4000);
    ChannelFuture future=cb.connect(BAD_HOST,BAD_PORT);
    try {
      if (future.await(1000)) {
        if (future.isSuccess()) {
          fail("A connection attempt to " + BAD_HOST + " must not succeed.");
        }
 else {
          throw future.cause();
        }
      }
      if (future.cancel(true)) {
        assertThat(future.channel().closeFuture().await(500),is(true));
        assertThat(future.isCancelled(),is(true));
      }
 else {
      }
    }
  finally {
      future.channel().close();
    }
  }
private static class TestHandler extends ChannelInboundHandlerAdapter {
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      InternalLoggerFactory.getInstance(SocketConnectionAttemptTest.class).warn("Unexpected exception:",cause);
    }
  }
}
