public abstract class DetectPeerCloseWithoutReadTest {
  protected abstract EventLoopGroup newGroup();
  protected abstract Class<? extends ServerChannel> serverChannel();
  protected abstract Class<? extends Channel> clientChannel();
  @Test(timeout=10000) public void clientCloseWithoutServerReadIsDetectedNoExtraReadRequested() throws InterruptedException {
    clientCloseWithoutServerReadIsDetected0(false);
  }
  @Test(timeout=10000) public void clientCloseWithoutServerReadIsDetectedExtraReadRequested() throws InterruptedException {
    clientCloseWithoutServerReadIsDetected0(true);
  }
  private void clientCloseWithoutServerReadIsDetected0(  final boolean extraReadRequested) throws InterruptedException {
    EventLoopGroup serverGroup=null;
    EventLoopGroup clientGroup=null;
    Channel serverChannel=null;
    try {
      final CountDownLatch latch=new CountDownLatch(1);
      final AtomicInteger bytesRead=new AtomicInteger();
      final int expectedBytes=100;
      serverGroup=newGroup();
      clientGroup=newGroup();
      ServerBootstrap sb=new ServerBootstrap();
      sb.group(serverGroup);
      sb.channel(serverChannel());
      sb.childOption(ChannelOption.AUTO_READ,false);
      sb.childOption(ChannelOption.MAX_MESSAGES_PER_READ,1);
      sb.childOption(ChannelOption.RCVBUF_ALLOCATOR,new FixedRecvByteBufAllocator(expectedBytes / 10));
      sb.childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch){
          ch.pipeline().addLast(new TestHandler(bytesRead,extraReadRequested,latch));
        }
      }
);
      serverChannel=sb.bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
      Bootstrap cb=new Bootstrap();
      cb.group(serverGroup);
      cb.channel(clientChannel());
      cb.handler(new ChannelInboundHandlerAdapter());
      Channel clientChannel=cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      ByteBuf buf=clientChannel.alloc().buffer(expectedBytes);
      buf.writerIndex(buf.writerIndex() + expectedBytes);
      clientChannel.writeAndFlush(buf).addListener(ChannelFutureListener.CLOSE);
      latch.await();
      assertEquals(expectedBytes,bytesRead.get());
    }
  finally {
      if (serverChannel != null) {
        serverChannel.close().syncUninterruptibly();
      }
      if (serverGroup != null) {
        serverGroup.shutdownGracefully();
      }
      if (clientGroup != null) {
        clientGroup.shutdownGracefully();
      }
    }
  }
  @Test(timeout=10000) public void serverCloseWithoutClientReadIsDetectedNoExtraReadRequested() throws InterruptedException {
    serverCloseWithoutClientReadIsDetected0(false);
  }
  @Test(timeout=10000) public void serverCloseWithoutClientReadIsDetectedExtraReadRequested() throws InterruptedException {
    serverCloseWithoutClientReadIsDetected0(true);
  }
  private void serverCloseWithoutClientReadIsDetected0(  final boolean extraReadRequested) throws InterruptedException {
    EventLoopGroup serverGroup=null;
    EventLoopGroup clientGroup=null;
    Channel serverChannel=null;
    Channel clientChannel=null;
    try {
      final CountDownLatch latch=new CountDownLatch(1);
      final AtomicInteger bytesRead=new AtomicInteger();
      final int expectedBytes=100;
      serverGroup=newGroup();
      clientGroup=newGroup();
      ServerBootstrap sb=new ServerBootstrap();
      sb.group(serverGroup);
      sb.channel(serverChannel());
      sb.childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch){
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void channelActive(            ChannelHandlerContext ctx){
              ByteBuf buf=ctx.alloc().buffer(expectedBytes);
              buf.writerIndex(buf.writerIndex() + expectedBytes);
              ctx.writeAndFlush(buf).addListener(ChannelFutureListener.CLOSE);
              ctx.fireChannelActive();
            }
          }
);
        }
      }
);
      serverChannel=sb.bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
      Bootstrap cb=new Bootstrap();
      cb.group(serverGroup);
      cb.channel(clientChannel());
      cb.option(ChannelOption.AUTO_READ,false);
      cb.option(ChannelOption.MAX_MESSAGES_PER_READ,1);
      cb.option(ChannelOption.RCVBUF_ALLOCATOR,new FixedRecvByteBufAllocator(expectedBytes / 10));
      cb.handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(new TestHandler(bytesRead,extraReadRequested,latch));
        }
      }
);
      clientChannel=cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      latch.await();
      assertEquals(expectedBytes,bytesRead.get());
    }
  finally {
      if (serverChannel != null) {
        serverChannel.close().syncUninterruptibly();
      }
      if (clientChannel != null) {
        clientChannel.close().syncUninterruptibly();
      }
      if (serverGroup != null) {
        serverGroup.shutdownGracefully();
      }
      if (clientGroup != null) {
        clientGroup.shutdownGracefully();
      }
    }
  }
private static final class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
    private final AtomicInteger bytesRead;
    private final boolean extraReadRequested;
    private final CountDownLatch latch;
    TestHandler(    AtomicInteger bytesRead,    boolean extraReadRequested,    CountDownLatch latch){
      this.bytesRead=bytesRead;
      this.extraReadRequested=extraReadRequested;
      this.latch=latch;
    }
    @Override protected void channelRead0(    ChannelHandlerContext ctx,    ByteBuf msg){
      bytesRead.addAndGet(msg.readableBytes());
      if (extraReadRequested) {
        ctx.read();
      }
    }
    @Override public void channelInactive(    ChannelHandlerContext ctx){
      latch.countDown();
      ctx.fireChannelInactive();
    }
  }
}
