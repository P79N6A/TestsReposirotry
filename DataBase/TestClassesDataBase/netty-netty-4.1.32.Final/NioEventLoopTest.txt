public class NioEventLoopTest extends AbstractEventLoopTest {
  @Override protected EventLoopGroup newEventLoopGroup(){
    return new NioEventLoopGroup();
  }
  @Override protected Class<? extends ServerSocketChannel> newChannel(){
    return NioServerSocketChannel.class;
  }
  @Test public void testRebuildSelector(){
    EventLoopGroup group=new NioEventLoopGroup(1);
    final NioEventLoop loop=(NioEventLoop)group.next();
    try {
      Channel channel=new NioServerSocketChannel();
      loop.register(channel).syncUninterruptibly();
      Selector selector=loop.unwrappedSelector();
      assertSame(selector,((NioEventLoop)channel.eventLoop()).unwrappedSelector());
      assertTrue(selector.isOpen());
      loop.submit(new Runnable(){
        @Override public void run(){
          loop.rebuildSelector();
        }
      }
).syncUninterruptibly();
      Selector newSelector=((NioEventLoop)channel.eventLoop()).unwrappedSelector();
      assertTrue(newSelector.isOpen());
      assertNotSame(selector,newSelector);
      assertFalse(selector.isOpen());
      channel.close().syncUninterruptibly();
    }
  finally {
      group.shutdownGracefully();
    }
  }
  @Test public void testScheduleBigDelayNotOverflow(){
    EventLoopGroup group=new NioEventLoopGroup(1);
    final EventLoop el=group.next();
    Future<?> future=el.schedule(new Runnable(){
      @Override public void run(){
      }
    }
,Long.MAX_VALUE,TimeUnit.MILLISECONDS);
    assertFalse(future.awaitUninterruptibly(1000));
    assertTrue(future.cancel(true));
    group.shutdownGracefully();
  }
  @Test public void testInterruptEventLoopThread() throws Exception {
    EventLoopGroup group=new NioEventLoopGroup(1);
    final NioEventLoop loop=(NioEventLoop)group.next();
    try {
      Selector selector=loop.unwrappedSelector();
      assertTrue(selector.isOpen());
      loop.submit(new Runnable(){
        @Override public void run(){
          Thread.currentThread().interrupt();
        }
      }
).syncUninterruptibly();
      assertTrue(selector.isOpen());
      final CountDownLatch latch=new CountDownLatch(2);
      loop.submit(new Runnable(){
        @Override public void run(){
          latch.countDown();
        }
      }
).syncUninterruptibly();
      loop.schedule(new Runnable(){
        @Override public void run(){
          latch.countDown();
        }
      }
,2,TimeUnit.SECONDS).syncUninterruptibly();
      latch.await();
      assertSame(selector,loop.unwrappedSelector());
      assertTrue(selector.isOpen());
    }
  finally {
      group.shutdownGracefully();
    }
  }
  @Test(timeout=3000) public void testSelectableChannel() throws Exception {
    NioEventLoopGroup group=new NioEventLoopGroup(1);
    NioEventLoop loop=(NioEventLoop)group.next();
    try {
      Channel channel=new NioServerSocketChannel();
      loop.register(channel).syncUninterruptibly();
      channel.bind(new InetSocketAddress(0)).syncUninterruptibly();
      SocketChannel selectableChannel=SocketChannel.open();
      selectableChannel.configureBlocking(false);
      selectableChannel.connect(channel.localAddress());
      final CountDownLatch latch=new CountDownLatch(1);
      loop.register(selectableChannel,SelectionKey.OP_CONNECT,new NioTask<SocketChannel>(){
        @Override public void channelReady(        SocketChannel ch,        SelectionKey key){
          latch.countDown();
        }
        @Override public void channelUnregistered(        SocketChannel ch,        Throwable cause){
        }
      }
);
      latch.await();
      selectableChannel.close();
      channel.close().syncUninterruptibly();
    }
  finally {
      group.shutdownGracefully();
    }
  }
  @SuppressWarnings("deprecation") @Test public void testTaskRemovalOnShutdownThrowsNoUnsupportedOperationException() throws Exception {
    final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    final Runnable task=new Runnable(){
      @Override public void run(){
      }
    }
;
    for (int i=0; i < 1000; i++) {
      NioEventLoopGroup group=new NioEventLoopGroup(1);
      final NioEventLoop loop=(NioEventLoop)group.next();
      Thread t=new Thread(new Runnable(){
        @Override public void run(){
          try {
            for (; ; ) {
              loop.execute(task);
            }
          }
 catch (          Throwable cause) {
            error.set(cause);
          }
        }
      }
);
      t.start();
      group.shutdownNow();
      t.join();
      group.terminationFuture().syncUninterruptibly();
      assertThat(error.get(),IsInstanceOf.instanceOf(RejectedExecutionException.class));
      error.set(null);
    }
  }
  @Test public void testRebuildSelectorOnIOException(){
    SelectStrategyFactory selectStrategyFactory=new SelectStrategyFactory(){
      @Override public SelectStrategy newSelectStrategy(){
        return new SelectStrategy(){
          private boolean thrown;
          @Override public int calculateStrategy(          IntSupplier selectSupplier,          boolean hasTasks) throws Exception {
            if (!thrown) {
              thrown=true;
              throw new IOException();
            }
            return -1;
          }
        }
;
      }
    }
;
    EventLoopGroup group=new NioEventLoopGroup(1,new DefaultThreadFactory("ioPool"),SelectorProvider.provider(),selectStrategyFactory);
    final NioEventLoop loop=(NioEventLoop)group.next();
    try {
      Channel channel=new NioServerSocketChannel();
      Selector selector=loop.unwrappedSelector();
      loop.register(channel).syncUninterruptibly();
      Selector newSelector=((NioEventLoop)channel.eventLoop()).unwrappedSelector();
      assertTrue(newSelector.isOpen());
      assertNotSame(selector,newSelector);
      assertFalse(selector.isOpen());
      channel.close().syncUninterruptibly();
    }
  finally {
      group.shutdownGracefully();
    }
  }
}
