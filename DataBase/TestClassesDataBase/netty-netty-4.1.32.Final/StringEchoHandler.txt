static class StringEchoHandler extends SimpleChannelInboundHandler<String> {
  private final boolean autoRead;
  private final Promise<Void> donePromise;
  private int dataIndex;
  volatile Channel channel;
  final AtomicReference<Throwable> exception=new AtomicReference<Throwable>();
  StringEchoHandler(  boolean autoRead,  Promise<Void> donePromise){
    this.autoRead=autoRead;
    this.donePromise=donePromise;
  }
  @Override public void channelActive(  ChannelHandlerContext ctx) throws Exception {
    channel=ctx.channel();
    if (!autoRead) {
      ctx.read();
    }
  }
  @Override public void channelRead0(  ChannelHandlerContext ctx,  String msg) throws Exception {
    if (!data[dataIndex].equals(msg)) {
      donePromise.tryFailure(new IllegalStateException("index: " + dataIndex + " didn't match!"));
      ctx.close();
      return;
    }
    if (channel.parent() != null) {
      String delimiter=random.nextBoolean() ? "\r\n" : "\n";
      channel.write(msg + delimiter);
    }
    if (++dataIndex >= data.length) {
      donePromise.setSuccess(null);
    }
  }
  @Override public void channelReadComplete(  ChannelHandlerContext ctx) throws Exception {
    try {
      ctx.flush();
    }
  finally {
      if (!autoRead) {
        ctx.read();
      }
    }
  }
  @Override public void exceptionCaught(  ChannelHandlerContext ctx,  Throwable cause) throws Exception {
    if (exception.compareAndSet(null,cause)) {
      donePromise.tryFailure(new IllegalStateException("exceptionCaught: " + ctx.channel(),cause));
      ctx.close();
    }
  }
  @Override public void channelInactive(  ChannelHandlerContext ctx) throws Exception {
    donePromise.tryFailure(new IllegalStateException("channelInactive: " + ctx.channel()));
  }
}
