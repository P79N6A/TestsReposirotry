private class EchoServerHandler extends EchoHandler {
  volatile Future<Channel> renegoFuture;
  EchoServerHandler(  AtomicInteger recvCounter,  AtomicInteger negoCounter,  AtomicReference<Throwable> exception){
    super(recvCounter,negoCounter,exception);
  }
  @Override public final void channelRegistered(  ChannelHandlerContext ctx) throws Exception {
    renegoFuture=null;
  }
  @Override public void channelRead0(  ChannelHandlerContext ctx,  ByteBuf in) throws Exception {
    byte[] actual=new byte[in.readableBytes()];
    in.readBytes(actual);
    int lastIdx=recvCounter.get();
    for (int i=0; i < actual.length; i++) {
      assertEquals(data[i + lastIdx],actual[i]);
    }
    ByteBuf buf=Unpooled.wrappedBuffer(actual);
    if (useCompositeByteBuf) {
      buf=Unpooled.compositeBuffer().addComponent(true,buf);
    }
    ctx.write(buf);
    recvCounter.addAndGet(actual.length);
    if (renegotiation.type == RenegotiationType.SERVER_INITIATED && recvCounter.get() > data.length / 2 && renegoFuture == null) {
      SslHandler sslHandler=ctx.pipeline().get(SslHandler.class);
      Future<Channel> hf=sslHandler.handshakeFuture();
      assertThat(hf.isDone(),is(true));
      sslHandler.engine().setEnabledCipherSuites(new String[]{renegotiation.cipherSuite});
      logStats("SERVER RENEGOTIATES");
      renegoFuture=sslHandler.renegotiate();
      assertThat(renegoFuture,is(not(sameInstance(hf))));
      assertThat(renegoFuture,is(sameInstance(sslHandler.handshakeFuture())));
      assertThat(renegoFuture.isDone(),is(false));
    }
  }
}
