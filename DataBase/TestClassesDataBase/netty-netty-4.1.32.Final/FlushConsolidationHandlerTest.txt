public class FlushConsolidationHandlerTest {
  private static final int EXPLICIT_FLUSH_AFTER_FLUSHES=3;
  @Test public void testFlushViaScheduledTask(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,true);
    channel.flush();
    assertEquals(0,flushCount.get());
    channel.flush();
    assertEquals(0,flushCount.get());
    channel.runPendingTasks();
    assertEquals(1,flushCount.get());
    assertFalse(channel.finish());
  }
  @Test public void testFlushViaThresholdOutsideOfReadLoop(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,true);
    for (int i=0; i < EXPLICIT_FLUSH_AFTER_FLUSHES; i++) {
      channel.flush();
    }
    assertEquals(1,flushCount.get());
    assertFalse(channel.finish());
  }
  @Test public void testImmediateFlushOutsideOfReadLoop(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,false);
    channel.flush();
    assertEquals(1,flushCount.get());
    assertFalse(channel.finish());
  }
  @Test public void testFlushViaReadComplete(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,false);
    channel.flush();
    channel.runPendingTasks();
    assertEquals(1,flushCount.get());
    channel.pipeline().fireChannelRead(1L);
    assertEquals(1,flushCount.get());
    channel.pipeline().fireChannelRead(2L);
    assertEquals(1,flushCount.get());
    assertNull(channel.readOutbound());
    channel.pipeline().fireChannelReadComplete();
    assertEquals(2,flushCount.get());
    channel.flush();
    channel.runPendingTasks();
    assertEquals(3,flushCount.get());
    assertEquals(1L,channel.readOutbound());
    assertEquals(2L,channel.readOutbound());
    assertNull(channel.readOutbound());
    assertFalse(channel.finish());
  }
  @Test public void testFlushViaClose(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,false);
    channel.pipeline().fireChannelRead(1L);
    assertEquals(0,flushCount.get());
    assertNull(channel.readOutbound());
    channel.close();
    assertEquals(1,flushCount.get());
    assertEquals(1L,channel.readOutbound());
    assertNull(channel.readOutbound());
    assertFalse(channel.finish());
  }
  @Test public void testFlushViaDisconnect(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,false);
    channel.pipeline().fireChannelRead(1L);
    assertEquals(0,flushCount.get());
    assertNull(channel.readOutbound());
    channel.disconnect();
    assertEquals(1,flushCount.get());
    assertEquals(1L,channel.readOutbound());
    assertNull(channel.readOutbound());
    assertFalse(channel.finish());
  }
  @Test(expected=IllegalStateException.class) public void testFlushViaException(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,false);
    channel.pipeline().fireChannelRead(1L);
    assertEquals(0,flushCount.get());
    assertNull(channel.readOutbound());
    channel.pipeline().fireExceptionCaught(new IllegalStateException());
    assertEquals(1,flushCount.get());
    assertEquals(1L,channel.readOutbound());
    assertNull(channel.readOutbound());
    channel.finish();
  }
  @Test public void testFlushViaRemoval(){
    final AtomicInteger flushCount=new AtomicInteger();
    EmbeddedChannel channel=newChannel(flushCount,false);
    channel.pipeline().fireChannelRead(1L);
    assertEquals(0,flushCount.get());
    assertNull(channel.readOutbound());
    channel.pipeline().remove(FlushConsolidationHandler.class);
    assertEquals(1,flushCount.get());
    assertEquals(1L,channel.readOutbound());
    assertNull(channel.readOutbound());
    assertFalse(channel.finish());
  }
  private static EmbeddedChannel newChannel(  final AtomicInteger flushCount,  boolean consolidateWhenNoReadInProgress){
    return new EmbeddedChannel(new ChannelOutboundHandlerAdapter(){
      @Override public void flush(      ChannelHandlerContext ctx) throws Exception {
        flushCount.incrementAndGet();
        ctx.flush();
      }
    }
,new FlushConsolidationHandler(EXPLICIT_FLUSH_AFTER_FLUSHES,consolidateWhenNoReadInProgress),new ChannelInboundHandlerAdapter(){
      @Override public void channelRead(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        ctx.writeAndFlush(msg);
      }
    }
);
  }
}
