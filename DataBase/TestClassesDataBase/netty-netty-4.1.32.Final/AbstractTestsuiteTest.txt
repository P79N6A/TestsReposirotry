public abstract class AbstractTestsuiteTest<T extends AbstractBootstrap<?,?>> {
  private final Class<T> clazz;
  protected final InternalLogger logger=InternalLoggerFactory.getInstance(getClass());
  protected volatile T cb;
  protected AbstractTestsuiteTest(  Class<T> clazz){
    this.clazz=clazz;
  }
  protected abstract List<TestsuitePermutation.BootstrapFactory<T>> newFactories();
  protected List<ByteBufAllocator> newAllocators(){
    return TestsuitePermutation.allocator();
  }
  @Rule public final TestName testName=new TestName();
  protected void run() throws Throwable {
    List<TestsuitePermutation.BootstrapFactory<T>> combos=newFactories();
    for (    ByteBufAllocator allocator : newAllocators()) {
      int i=0;
      for (      TestsuitePermutation.BootstrapFactory<T> e : combos) {
        cb=e.newInstance();
        configure(cb,allocator);
        logger.info(String.format("Running: %s %d of %d with %s",testName.getMethodName(),++i,combos.size(),StringUtil.simpleClassName(allocator)));
        try {
          Method m=getClass().getMethod(TestUtils.testMethodName(testName),clazz);
          m.invoke(this,cb);
        }
 catch (        InvocationTargetException ex) {
          throw ex.getCause();
        }
      }
    }
  }
  protected abstract void configure(  T bootstrap,  ByteBufAllocator allocator);
}
