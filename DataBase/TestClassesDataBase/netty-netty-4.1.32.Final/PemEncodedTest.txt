public class PemEncodedTest {
  @Test public void testPemEncodedOpenSsl() throws Exception {
    testPemEncoded(SslProvider.OPENSSL);
  }
  @Test public void testPemEncodedOpenSslRef() throws Exception {
    testPemEncoded(SslProvider.OPENSSL_REFCNT);
  }
  private static void testPemEncoded(  SslProvider provider) throws Exception {
    assumeTrue(OpenSsl.isAvailable());
    assumeFalse(OpenSsl.useKeyManagerFactory());
    PemPrivateKey pemKey;
    PemX509Certificate pemCert;
    SelfSignedCertificate ssc=new SelfSignedCertificate();
    try {
      pemKey=PemPrivateKey.valueOf(toByteArray(ssc.privateKey()));
      pemCert=PemX509Certificate.valueOf(toByteArray(ssc.certificate()));
    }
  finally {
      ssc.delete();
    }
    SslContext context=SslContextBuilder.forServer(pemKey,pemCert).sslProvider(provider).build();
    assertEquals(1,pemKey.refCnt());
    assertEquals(1,pemCert.refCnt());
    try {
      assertTrue(context instanceof ReferenceCountedOpenSslContext);
    }
  finally {
      ReferenceCountUtil.release(context);
      assertRelease(pemKey);
      assertRelease(pemCert);
    }
  }
  @Test(expected=IllegalArgumentException.class) public void testEncodedReturnsNull() throws Exception {
    PemPrivateKey.toPEM(UnpooledByteBufAllocator.DEFAULT,true,new PrivateKey(){
      @Override public String getAlgorithm(){
        return null;
      }
      @Override public String getFormat(){
        return null;
      }
      @Override public byte[] getEncoded(){
        return null;
      }
    }
);
  }
  private static void assertRelease(  PemEncoded encoded){
    assertTrue(encoded.release());
  }
  private static byte[] toByteArray(  File file) throws Exception {
    FileInputStream in=new FileInputStream(file);
    try {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      try {
        byte[] buf=new byte[1024];
        int len;
        while ((len=in.read(buf)) != -1) {
          baos.write(buf,0,len);
        }
      }
  finally {
        baos.close();
      }
      return baos.toByteArray();
    }
  finally {
      in.close();
    }
  }
}
