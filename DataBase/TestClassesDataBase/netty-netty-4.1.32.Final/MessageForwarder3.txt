/** 
 * Simply forwards the received object to the next handler.
 */
private static class MessageForwarder3 extends ChannelDuplexHandler {
  private final AtomicReference<Throwable> exception=new AtomicReference<Throwable>();
  private volatile int inCnt;
  private volatile int outCnt;
  private volatile Thread t;
  @Override public void channelRead(  ChannelHandlerContext ctx,  Object msg) throws Exception {
    Thread t=this.t;
    if (t == null) {
      this.t=Thread.currentThread();
    }
 else {
      Assert.assertSame(t,Thread.currentThread());
    }
    int actual=(Integer)msg;
    int expected=inCnt++;
    Assert.assertEquals(expected,actual);
    ctx.fireChannelRead(msg);
  }
  @Override public void write(  ChannelHandlerContext ctx,  Object msg,  ChannelPromise promise) throws Exception {
    Assert.assertSame(t,Thread.currentThread());
    int actual=(Integer)msg;
    int expected=outCnt++;
    Assert.assertEquals(expected,actual);
    ctx.write(msg,promise);
  }
  @Override public void exceptionCaught(  ChannelHandlerContext ctx,  Throwable cause) throws Exception {
    exception.compareAndSet(null,cause);
    System.err.print('[' + Thread.currentThread().getName() + "] ");
    cause.printStackTrace();
    super.exceptionCaught(ctx,cause);
  }
}
