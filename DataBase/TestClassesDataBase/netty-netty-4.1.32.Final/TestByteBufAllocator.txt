private static final class TestByteBufAllocator implements ByteBufAllocator {
  private final ByteBufAllocator allocator;
  private final BufferType type;
  TestByteBufAllocator(  ByteBufAllocator allocator,  BufferType type){
    this.allocator=allocator;
    this.type=type;
  }
  @Override public ByteBuf buffer(){
switch (type) {
case Direct:
      return allocator.directBuffer();
case Heap:
    return allocator.heapBuffer();
case Mixed:
  return PlatformDependent.threadLocalRandom().nextBoolean() ? allocator.directBuffer() : allocator.heapBuffer();
default :
throw new Error();
}
}
@Override public ByteBuf buffer(int initialCapacity){
switch (type) {
case Direct:
return allocator.directBuffer(initialCapacity);
case Heap:
return allocator.heapBuffer(initialCapacity);
case Mixed:
return PlatformDependent.threadLocalRandom().nextBoolean() ? allocator.directBuffer(initialCapacity) : allocator.heapBuffer(initialCapacity);
default :
throw new Error();
}
}
@Override public ByteBuf buffer(int initialCapacity,int maxCapacity){
switch (type) {
case Direct:
return allocator.directBuffer(initialCapacity,maxCapacity);
case Heap:
return allocator.heapBuffer(initialCapacity,maxCapacity);
case Mixed:
return PlatformDependent.threadLocalRandom().nextBoolean() ? allocator.directBuffer(initialCapacity,maxCapacity) : allocator.heapBuffer(initialCapacity,maxCapacity);
default :
throw new Error();
}
}
@Override public ByteBuf ioBuffer(){
return allocator.ioBuffer();
}
@Override public ByteBuf ioBuffer(int initialCapacity){
return allocator.ioBuffer(initialCapacity);
}
@Override public ByteBuf ioBuffer(int initialCapacity,int maxCapacity){
return allocator.ioBuffer(initialCapacity,maxCapacity);
}
@Override public ByteBuf heapBuffer(){
return allocator.heapBuffer();
}
@Override public ByteBuf heapBuffer(int initialCapacity){
return allocator.heapBuffer(initialCapacity);
}
@Override public ByteBuf heapBuffer(int initialCapacity,int maxCapacity){
return allocator.heapBuffer(initialCapacity,maxCapacity);
}
@Override public ByteBuf directBuffer(){
return allocator.directBuffer();
}
@Override public ByteBuf directBuffer(int initialCapacity){
return allocator.directBuffer(initialCapacity);
}
@Override public ByteBuf directBuffer(int initialCapacity,int maxCapacity){
return allocator.directBuffer(initialCapacity,maxCapacity);
}
@Override public CompositeByteBuf compositeBuffer(){
switch (type) {
case Direct:
return allocator.compositeDirectBuffer();
case Heap:
return allocator.compositeHeapBuffer();
case Mixed:
return PlatformDependent.threadLocalRandom().nextBoolean() ? allocator.compositeDirectBuffer() : allocator.compositeHeapBuffer();
default :
throw new Error();
}
}
@Override public CompositeByteBuf compositeBuffer(int maxNumComponents){
switch (type) {
case Direct:
return allocator.compositeDirectBuffer(maxNumComponents);
case Heap:
return allocator.compositeHeapBuffer(maxNumComponents);
case Mixed:
return PlatformDependent.threadLocalRandom().nextBoolean() ? allocator.compositeDirectBuffer(maxNumComponents) : allocator.compositeHeapBuffer(maxNumComponents);
default :
throw new Error();
}
}
@Override public CompositeByteBuf compositeHeapBuffer(){
return allocator.compositeHeapBuffer();
}
@Override public CompositeByteBuf compositeHeapBuffer(int maxNumComponents){
return allocator.compositeHeapBuffer(maxNumComponents);
}
@Override public CompositeByteBuf compositeDirectBuffer(){
return allocator.compositeDirectBuffer();
}
@Override public CompositeByteBuf compositeDirectBuffer(int maxNumComponents){
return allocator.compositeDirectBuffer(maxNumComponents);
}
@Override public boolean isDirectBufferPooled(){
return allocator.isDirectBufferPooled();
}
@Override public int calculateNewCapacity(int minNewCapacity,int maxCapacity){
return allocator.calculateNewCapacity(minNewCapacity,maxCapacity);
}
}
