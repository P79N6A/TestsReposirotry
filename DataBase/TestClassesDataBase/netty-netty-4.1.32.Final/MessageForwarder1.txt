/** 
 * Converts integers into a binary stream.
 */
private static class MessageForwarder1 extends ChannelDuplexHandler {
  private final AtomicReference<Throwable> exception=new AtomicReference<Throwable>();
  private volatile int inCnt;
  private volatile int outCnt;
  private volatile Thread t;
  @Override public void channelRead(  ChannelHandlerContext ctx,  Object msg) throws Exception {
    Thread t=this.t;
    if (t == null) {
      this.t=Thread.currentThread();
    }
 else {
      Assert.assertSame(t,Thread.currentThread());
    }
    ByteBuf out=ctx.alloc().buffer(4);
    int m=((Integer)msg).intValue();
    int expected=inCnt++;
    Assert.assertEquals(expected,m);
    out.writeInt(m);
    ctx.fireChannelRead(out);
  }
  @Override public void write(  ChannelHandlerContext ctx,  Object msg,  ChannelPromise promise) throws Exception {
    Assert.assertSame(t,Thread.currentThread());
    boolean swallow=this == ctx.pipeline().first();
    ByteBuf m=(ByteBuf)msg;
    int count=m.readableBytes() / 4;
    for (int j=0; j < count; j++) {
      int actual=m.readInt();
      int expected=outCnt++;
      Assert.assertEquals(expected,actual);
      if (!swallow) {
        ctx.write(actual);
      }
    }
    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER,promise);
    m.release();
  }
  @Override public void exceptionCaught(  ChannelHandlerContext ctx,  Throwable cause) throws Exception {
    exception.compareAndSet(null,cause);
    super.exceptionCaught(ctx,cause);
  }
}
