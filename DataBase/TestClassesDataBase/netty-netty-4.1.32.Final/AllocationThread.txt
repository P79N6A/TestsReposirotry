private static final class AllocationThread extends Thread {
  private static final int[] ALLOCATION_SIZES=new int[16 * 1024];
static {
    for (int i=0; i < ALLOCATION_SIZES.length; i++) {
      ALLOCATION_SIZES[i]=i;
    }
  }
  private final Queue<ByteBuf> buffers=new ConcurrentLinkedQueue<ByteBuf>();
  private final ByteBufAllocator allocator;
  private final AtomicReference<Object> finish=new AtomicReference<Object>();
  public AllocationThread(  ByteBufAllocator allocator){
    this.allocator=allocator;
  }
  @Override public void run(){
    try {
      int idx=0;
      while (finish.get() == null) {
        for (int i=0; i < 10; i++) {
          buffers.add(allocator.directBuffer(ALLOCATION_SIZES[Math.abs(idx++ % ALLOCATION_SIZES.length)],Integer.MAX_VALUE));
        }
        releaseBuffers();
      }
    }
 catch (    Throwable cause) {
      finish.set(cause);
    }
 finally {
      releaseBuffers();
    }
  }
  private void releaseBuffers(){
    for (; ; ) {
      ByteBuf buf=buffers.poll();
      if (buf == null) {
        break;
      }
      buf.release();
    }
  }
  public boolean isFinished(){
    return finish.get() != null;
  }
  public void finish() throws Throwable {
    try {
      finish.compareAndSet(null,Boolean.TRUE);
      join();
    }
  finally {
      releaseBuffers();
    }
    checkForError();
  }
  public void checkForError() throws Throwable {
    Object obj=finish.get();
    if (obj instanceof Throwable) {
      throw (Throwable)obj;
    }
  }
}
