private static class ThreadNameAuditor extends ChannelDuplexHandler {
  private final AtomicReference<Throwable> exception=new AtomicReference<Throwable>();
  private final Queue<String> inboundThreadNames=new ConcurrentLinkedQueue<String>();
  private final Queue<String> outboundThreadNames=new ConcurrentLinkedQueue<String>();
  private final Queue<String> removalThreadNames=new ConcurrentLinkedQueue<String>();
  private final boolean discard;
  ThreadNameAuditor(){
    this(false);
  }
  ThreadNameAuditor(  boolean discard){
    this.discard=discard;
  }
  @Override public void handlerRemoved(  ChannelHandlerContext ctx) throws Exception {
    removalThreadNames.add(Thread.currentThread().getName());
  }
  @Override public void channelRead(  ChannelHandlerContext ctx,  Object msg) throws Exception {
    inboundThreadNames.add(Thread.currentThread().getName());
    if (!discard) {
      ctx.fireChannelRead(msg);
    }
  }
  @Override public void write(  ChannelHandlerContext ctx,  Object msg,  ChannelPromise promise) throws Exception {
    outboundThreadNames.add(Thread.currentThread().getName());
    ctx.write(msg,promise);
  }
  @Override public void exceptionCaught(  ChannelHandlerContext ctx,  Throwable cause) throws Exception {
    exception.compareAndSet(null,cause);
    System.err.print('[' + Thread.currentThread().getName() + "] ");
    cause.printStackTrace();
    super.exceptionCaught(ctx,cause);
  }
}
