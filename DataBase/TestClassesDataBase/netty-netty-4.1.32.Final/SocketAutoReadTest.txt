public class SocketAutoReadTest extends AbstractSocketTest {
  @Test public void testAutoReadOffDuringReadOnlyReadsOneTime() throws Throwable {
    run();
  }
  public void testAutoReadOffDuringReadOnlyReadsOneTime(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    testAutoReadOffDuringReadOnlyReadsOneTime(true,sb,cb);
    testAutoReadOffDuringReadOnlyReadsOneTime(false,sb,cb);
  }
  private static void testAutoReadOffDuringReadOnlyReadsOneTime(  boolean readOutsideEventLoopThread,  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    Channel serverChannel=null;
    Channel clientChannel=null;
    try {
      AutoReadInitializer serverInitializer=new AutoReadInitializer(!readOutsideEventLoopThread);
      AutoReadInitializer clientInitializer=new AutoReadInitializer(!readOutsideEventLoopThread);
      sb.option(ChannelOption.SO_BACKLOG,1024).option(ChannelOption.AUTO_READ,true).childOption(ChannelOption.AUTO_READ,true).childOption(ChannelOption.RCVBUF_ALLOCATOR,new TestRecvByteBufAllocator()).childHandler(serverInitializer);
      serverChannel=sb.bind().syncUninterruptibly().channel();
      cb.option(ChannelOption.AUTO_READ,true).option(ChannelOption.RCVBUF_ALLOCATOR,new TestRecvByteBufAllocator()).handler(clientInitializer);
      clientChannel=cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      clientChannel.writeAndFlush(Unpooled.wrappedBuffer(new byte[3]));
      serverInitializer.autoReadHandler.assertSingleRead();
      serverInitializer.channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[3]));
      clientInitializer.autoReadHandler.assertSingleRead();
      if (readOutsideEventLoopThread) {
        serverInitializer.channel.read();
      }
      serverInitializer.autoReadHandler.assertSingleReadSecondTry();
      if (readOutsideEventLoopThread) {
        clientChannel.read();
      }
      clientInitializer.autoReadHandler.assertSingleReadSecondTry();
    }
  finally {
      if (clientChannel != null) {
        clientChannel.close().sync();
      }
      if (serverChannel != null) {
        serverChannel.close().sync();
      }
    }
  }
private static class AutoReadInitializer extends ChannelInitializer<Channel> {
    final AutoReadHandler autoReadHandler;
    volatile Channel channel;
    AutoReadInitializer(    boolean readInEventLoop){
      autoReadHandler=new AutoReadHandler(readInEventLoop);
    }
    @Override protected void initChannel(    Channel ch) throws Exception {
      channel=ch;
      ch.pipeline().addLast(autoReadHandler);
    }
  }
private static final class AutoReadHandler extends ChannelInboundHandlerAdapter {
    private final AtomicInteger count=new AtomicInteger();
    private final CountDownLatch latch=new CountDownLatch(1);
    private final CountDownLatch latch2;
    private final boolean callRead;
    AutoReadHandler(    boolean callRead){
      this.callRead=callRead;
      latch2=new CountDownLatch(callRead ? 3 : 2);
    }
    @Override public void channelRead(    ChannelHandlerContext ctx,    Object msg) throws Exception {
      ReferenceCountUtil.release(msg);
      if (count.incrementAndGet() == 1) {
        ctx.channel().config().setAutoRead(false);
      }
      if (callRead) {
        ctx.read();
      }
    }
    @Override public void channelReadComplete(    ChannelHandlerContext ctx) throws Exception {
      latch.countDown();
      latch2.countDown();
    }
    void assertSingleRead() throws InterruptedException {
      assertTrue(latch.await(5,TimeUnit.SECONDS));
      assertTrue(count.get() > 0);
    }
    void assertSingleReadSecondTry() throws InterruptedException {
      assertTrue(latch2.await(5,TimeUnit.SECONDS));
      assertEquals(callRead ? 3 : 2,count.get());
    }
  }
  /** 
 * Designed to keep reading as long as autoread is enabled.
 */
private static final class TestRecvByteBufAllocator implements RecvByteBufAllocator {
    @Override public ExtendedHandle newHandle(){
      return new ExtendedHandle(){
        private ChannelConfig config;
        private int attemptedBytesRead;
        private int lastBytesRead;
        @Override public ByteBuf allocate(        ByteBufAllocator alloc){
          return alloc.ioBuffer(guess(),guess());
        }
        @Override public int guess(){
          return 1;
        }
        @Override public void reset(        ChannelConfig config){
          this.config=config;
        }
        @Override public void incMessagesRead(        int numMessages){
        }
        @Override public void lastBytesRead(        int bytes){
          lastBytesRead=bytes;
        }
        @Override public int lastBytesRead(){
          return lastBytesRead;
        }
        @Override public void attemptedBytesRead(        int bytes){
          attemptedBytesRead=bytes;
        }
        @Override public int attemptedBytesRead(){
          return attemptedBytesRead;
        }
        @Override public boolean continueReading(){
          return config.isAutoRead();
        }
        @Override public boolean continueReading(        UncheckedBooleanSupplier maybeMoreDataSupplier){
          return config.isAutoRead();
        }
        @Override public void readComplete(){
        }
      }
;
    }
  }
}
