public class SocketRstTest extends AbstractSocketTest {
  protected void assertRstOnCloseException(  IOException cause,  Channel clientChannel){
    if (Locale.getDefault() == Locale.US || Locale.getDefault() == Locale.UK) {
      assertTrue("actual message: " + cause.getMessage(),cause.getMessage().contains("reset") || cause.getMessage().contains("closed"));
    }
  }
  @Test(timeout=3000) public void testSoLingerZeroCausesOnlyRstOnClose() throws Throwable {
    run();
  }
  public void testSoLingerZeroCausesOnlyRstOnClose(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    final AtomicReference<Channel> serverChannelRef=new AtomicReference<Channel>();
    final AtomicReference<Throwable> throwableRef=new AtomicReference<Throwable>();
    final CountDownLatch latch=new CountDownLatch(1);
    final CountDownLatch latch2=new CountDownLatch(1);
    sb.childOption(ChannelOption.SO_LINGER,0);
    sb.childHandler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        serverChannelRef.compareAndSet(null,ch);
        latch.countDown();
      }
    }
);
    cb.handler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
          @Override public void exceptionCaught(          ChannelHandlerContext ctx,          Throwable cause){
            throwableRef.compareAndSet(null,cause);
          }
          @Override public void channelInactive(          ChannelHandlerContext ctx){
            latch2.countDown();
          }
        }
);
      }
    }
);
    Channel sc=sb.bind().sync().channel();
    Channel cc=cb.connect(sc.localAddress()).sync().channel();
    latch.await();
    serverChannelRef.get().close();
    latch2.await();
    Throwable cause=throwableRef.get();
    assertTrue("actual [type, message]: [" + cause.getClass() + ", "+ cause.getMessage()+ "]",cause instanceof IOException);
    assertRstOnCloseException((IOException)cause,cc);
  }
  @Test(timeout=3000) public void testNoRstIfSoLingerOnClose() throws Throwable {
    run();
  }
  public void testNoRstIfSoLingerOnClose(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    final AtomicReference<Channel> serverChannelRef=new AtomicReference<Channel>();
    final AtomicReference<Throwable> throwableRef=new AtomicReference<Throwable>();
    final CountDownLatch latch=new CountDownLatch(1);
    final CountDownLatch latch2=new CountDownLatch(1);
    sb.childHandler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        serverChannelRef.compareAndSet(null,ch);
        latch.countDown();
      }
    }
);
    cb.handler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
          @Override public void exceptionCaught(          ChannelHandlerContext ctx,          Throwable cause){
            throwableRef.compareAndSet(null,cause);
          }
          @Override public void channelInactive(          ChannelHandlerContext ctx){
            latch2.countDown();
          }
        }
);
      }
    }
);
    Channel sc=sb.bind().sync().channel();
    cb.connect(sc.localAddress()).syncUninterruptibly();
    latch.await();
    serverChannelRef.get().close();
    latch2.await();
    assertNull(throwableRef.get());
  }
}
