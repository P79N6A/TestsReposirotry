public class SocketReadPendingTest extends AbstractSocketTest {
  @Test(timeout=30000) public void testReadPendingIsResetAfterEachRead() throws Throwable {
    run();
  }
  public void testReadPendingIsResetAfterEachRead(  ServerBootstrap sb,  Bootstrap cb) throws Throwable {
    Channel serverChannel=null;
    Channel clientChannel=null;
    try {
      ReadPendingInitializer serverInitializer=new ReadPendingInitializer();
      ReadPendingInitializer clientInitializer=new ReadPendingInitializer();
      sb.option(ChannelOption.SO_BACKLOG,1024).option(ChannelOption.AUTO_READ,true).childOption(ChannelOption.AUTO_READ,false).childOption(ChannelOption.RCVBUF_ALLOCATOR,new TestNumReadsRecvByteBufAllocator(2)).childHandler(serverInitializer);
      serverChannel=sb.bind().syncUninterruptibly().channel();
      cb.option(ChannelOption.AUTO_READ,false).option(ChannelOption.RCVBUF_ALLOCATOR,new TestNumReadsRecvByteBufAllocator(2)).handler(clientInitializer);
      clientChannel=cb.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
      clientChannel.writeAndFlush(Unpooled.wrappedBuffer(new byte[4]));
      assertTrue(serverInitializer.channelInitLatch.await(5,TimeUnit.SECONDS));
      serverInitializer.channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[4]));
      serverInitializer.channel.read();
      serverInitializer.readPendingHandler.assertAllRead();
      clientChannel.read();
      clientInitializer.readPendingHandler.assertAllRead();
    }
  finally {
      if (serverChannel != null) {
        serverChannel.close().syncUninterruptibly();
      }
      if (clientChannel != null) {
        clientChannel.close().syncUninterruptibly();
      }
    }
  }
private static class ReadPendingInitializer extends ChannelInitializer<Channel> {
    final ReadPendingReadHandler readPendingHandler=new ReadPendingReadHandler();
    final CountDownLatch channelInitLatch=new CountDownLatch(1);
    volatile Channel channel;
    @Override protected void initChannel(    Channel ch) throws Exception {
      channel=ch;
      ch.pipeline().addLast(readPendingHandler);
      channelInitLatch.countDown();
    }
  }
private static final class ReadPendingReadHandler extends ChannelInboundHandlerAdapter {
    private final AtomicInteger count=new AtomicInteger();
    private final CountDownLatch latch=new CountDownLatch(1);
    private final CountDownLatch latch2=new CountDownLatch(2);
    @Override public void channelRead(    ChannelHandlerContext ctx,    Object msg) throws Exception {
      ReferenceCountUtil.release(msg);
      if (count.incrementAndGet() == 1) {
        ctx.read();
      }
    }
    @Override public void channelReadComplete(    ChannelHandlerContext ctx) throws Exception {
      latch.countDown();
      latch2.countDown();
    }
    void assertAllRead() throws InterruptedException {
      assertTrue(latch.await(5,TimeUnit.SECONDS));
      assertFalse(latch2.await(1,TimeUnit.SECONDS));
      assertEquals(2,count.get());
    }
  }
  /** 
 * Designed to read a single byte at a time to control the number of reads done at a fine granularity.
 */
private static final class TestNumReadsRecvByteBufAllocator implements RecvByteBufAllocator {
    private final int numReads;
    TestNumReadsRecvByteBufAllocator(    int numReads){
      this.numReads=numReads;
    }
    @Override public ExtendedHandle newHandle(){
      return new ExtendedHandle(){
        private int attemptedBytesRead;
        private int lastBytesRead;
        private int numMessagesRead;
        @Override public ByteBuf allocate(        ByteBufAllocator alloc){
          return alloc.ioBuffer(guess(),guess());
        }
        @Override public int guess(){
          return 1;
        }
        @Override public void reset(        ChannelConfig config){
          numMessagesRead=0;
        }
        @Override public void incMessagesRead(        int numMessages){
          numMessagesRead+=numMessages;
        }
        @Override public void lastBytesRead(        int bytes){
          lastBytesRead=bytes;
        }
        @Override public int lastBytesRead(){
          return lastBytesRead;
        }
        @Override public void attemptedBytesRead(        int bytes){
          attemptedBytesRead=bytes;
        }
        @Override public int attemptedBytesRead(){
          return attemptedBytesRead;
        }
        @Override public boolean continueReading(){
          return numMessagesRead < numReads;
        }
        @Override public boolean continueReading(        UncheckedBooleanSupplier maybeMoreDataSupplier){
          return continueReading();
        }
        @Override public void readComplete(){
        }
      }
;
    }
  }
}
