@RunWith(Parameterized.class) public class ParameterizedSslHandlerTest {
  @Parameterized.Parameters(name="{index}: clientProvider={0}, {index}: serverProvider={1}") public static Collection<Object[]> data(){
    List<SslProvider> providers=new ArrayList<SslProvider>(3);
    if (OpenSsl.isAvailable()) {
      providers.add(SslProvider.OPENSSL);
      providers.add(SslProvider.OPENSSL_REFCNT);
    }
    providers.add(SslProvider.JDK);
    List<Object[]> params=new ArrayList<Object[]>();
    for (    SslProvider cp : providers) {
      for (      SslProvider sp : providers) {
        params.add(new Object[]{cp,sp});
      }
    }
    return params;
  }
  private final SslProvider clientProvider;
  private final SslProvider serverProvider;
  public ParameterizedSslHandlerTest(  SslProvider clientProvider,  SslProvider serverProvider){
    this.clientProvider=clientProvider;
    this.serverProvider=serverProvider;
  }
  @Test(timeout=480000) public void testCompositeBufSizeEstimationGuaranteesSynchronousWrite() throws CertificateException, SSLException, ExecutionException, InterruptedException {
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,true,true,true);
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,true,true,false);
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,true,false,true);
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,true,false,false);
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,false,true,true);
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,false,true,false);
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,false,false,true);
    compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider,clientProvider,false,false,false);
  }
  private static void compositeBufSizeEstimationGuaranteesSynchronousWrite(  SslProvider serverProvider,  SslProvider clientProvider,  final boolean serverDisableWrapSize,  final boolean letHandlerCreateServerEngine,  final boolean letHandlerCreateClientEngine) throws CertificateException, SSLException, ExecutionException, InterruptedException {
    SelfSignedCertificate ssc=new SelfSignedCertificate();
    final SslContext sslServerCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(serverProvider).build();
    final SslContext sslClientCtx=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).sslProvider(clientProvider).build();
    EventLoopGroup group=new NioEventLoopGroup();
    Channel sc=null;
    Channel cc=null;
    try {
      final Promise<Void> donePromise=group.next().newPromise();
      final int numComponents=150;
      final int desiredBytes=16384;
      final int singleComponentSize=desiredBytes / numComponents;
      final int expectedBytes=numComponents * singleComponentSize;
      sc=new ServerBootstrap().group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          final SslHandler handler=letHandlerCreateServerEngine ? sslServerCtx.newHandler(ch.alloc()) : new SslHandler(sslServerCtx.newEngine(ch.alloc()));
          if (serverDisableWrapSize) {
            handler.setWrapDataSize(-1);
          }
          ch.pipeline().addLast(handler);
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            private boolean sentData;
            private Throwable writeCause;
            @Override public void userEventTriggered(            ChannelHandlerContext ctx,            Object evt){
              if (evt instanceof SslHandshakeCompletionEvent) {
                SslHandshakeCompletionEvent sslEvt=(SslHandshakeCompletionEvent)evt;
                if (sslEvt.isSuccess()) {
                  CompositeByteBuf content=ctx.alloc().compositeDirectBuffer(numComponents);
                  for (int i=0; i < numComponents; ++i) {
                    ByteBuf buf=ctx.alloc().directBuffer(singleComponentSize);
                    buf.writerIndex(buf.writerIndex() + singleComponentSize);
                    content.addComponent(true,buf);
                  }
                  ctx.writeAndFlush(content).addListener(new ChannelFutureListener(){
                    @Override public void operationComplete(                    ChannelFuture future) throws Exception {
                      writeCause=future.cause();
                      if (writeCause == null) {
                        sentData=true;
                      }
                    }
                  }
);
                }
 else {
                  donePromise.tryFailure(sslEvt.cause());
                }
              }
              ctx.fireUserEventTriggered(evt);
            }
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause){
              donePromise.tryFailure(new IllegalStateException("server exception sentData: " + sentData + " writeCause: "+ writeCause,cause));
            }
            @Override public void channelInactive(            ChannelHandlerContext ctx){
              donePromise.tryFailure(new IllegalStateException("server closed sentData: " + sentData + " writeCause: "+ writeCause));
            }
          }
);
        }
      }
).bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
      cc=new Bootstrap().group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          if (letHandlerCreateClientEngine) {
            ch.pipeline().addLast(sslClientCtx.newHandler(ch.alloc()));
          }
 else {
            ch.pipeline().addLast(new SslHandler(sslClientCtx.newEngine(ch.alloc())));
          }
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            private int bytesSeen;
            @Override public void channelRead(            ChannelHandlerContext ctx,            Object msg){
              if (msg instanceof ByteBuf) {
                bytesSeen+=((ByteBuf)msg).readableBytes();
                if (bytesSeen == expectedBytes) {
                  donePromise.trySuccess(null);
                }
              }
              ReferenceCountUtil.release(msg);
            }
            @Override public void userEventTriggered(            ChannelHandlerContext ctx,            Object evt){
              if (evt instanceof SslHandshakeCompletionEvent) {
                SslHandshakeCompletionEvent sslEvt=(SslHandshakeCompletionEvent)evt;
                if (!sslEvt.isSuccess()) {
                  donePromise.tryFailure(sslEvt.cause());
                }
              }
            }
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause){
              donePromise.tryFailure(new IllegalStateException("client exception. bytesSeen: " + bytesSeen,cause));
            }
            @Override public void channelInactive(            ChannelHandlerContext ctx){
              donePromise.tryFailure(new IllegalStateException("client closed. bytesSeen: " + bytesSeen));
            }
          }
);
        }
      }
).connect(sc.localAddress()).syncUninterruptibly().channel();
      donePromise.get();
    }
  finally {
      if (cc != null) {
        cc.close().syncUninterruptibly();
      }
      if (sc != null) {
        sc.close().syncUninterruptibly();
      }
      group.shutdownGracefully();
      ReferenceCountUtil.release(sslServerCtx);
      ReferenceCountUtil.release(sslClientCtx);
      ssc.delete();
    }
  }
  @Test(timeout=30000) public void testAlertProducedAndSend() throws Exception {
    SelfSignedCertificate ssc=new SelfSignedCertificate();
    final SslContext sslServerCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(serverProvider).trustManager(new SimpleTrustManagerFactory(){
      @Override protected void engineInit(      KeyStore keyStore){
      }
      @Override protected void engineInit(      ManagerFactoryParameters managerFactoryParameters){
      }
      @Override protected TrustManager[] engineGetTrustManagers(){
        return new TrustManager[]{new X509TrustManager(){
          @Override public void checkClientTrusted(          X509Certificate[] x509Certificates,          String s) throws CertificateException {
            throw new CertificateException();
          }
          @Override public void checkServerTrusted(          X509Certificate[] x509Certificates,          String s){
          }
          @Override public X509Certificate[] getAcceptedIssuers(){
            return EmptyArrays.EMPTY_X509_CERTIFICATES;
          }
        }
};
      }
    }
).clientAuth(ClientAuth.REQUIRE).build();
    final SslContext sslClientCtx=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).keyManager(new File(getClass().getResource("test.crt").getFile()),new File(getClass().getResource("test_unencrypted.pem").getFile())).sslProvider(clientProvider).build();
    NioEventLoopGroup group=new NioEventLoopGroup();
    Channel sc=null;
    Channel cc=null;
    try {
      final Promise<Void> promise=group.next().newPromise();
      sc=new ServerBootstrap().group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(sslServerCtx.newHandler(ch.alloc()));
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause){
              ctx.close();
            }
          }
);
        }
      }
).bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
      cc=new Bootstrap().group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ch.pipeline().addLast(sslClientCtx.newHandler(ch.alloc()));
          ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
            @Override public void exceptionCaught(            ChannelHandlerContext ctx,            Throwable cause){
              if (cause.getCause() instanceof SSLException) {
                promise.trySuccess(null);
              }
            }
          }
);
        }
      }
).connect(sc.localAddress()).syncUninterruptibly().channel();
      promise.syncUninterruptibly();
    }
  finally {
      if (cc != null) {
        cc.close().syncUninterruptibly();
      }
      if (sc != null) {
        sc.close().syncUninterruptibly();
      }
      group.shutdownGracefully();
      ReferenceCountUtil.release(sslServerCtx);
      ReferenceCountUtil.release(sslClientCtx);
    }
  }
  @Test(timeout=30000) public void testCloseNotify() throws Exception {
    testCloseNotify(5000,false);
  }
  @Test(timeout=30000) public void testCloseNotifyReceivedTimeout() throws Exception {
    testCloseNotify(100,true);
  }
  @Test(timeout=30000) public void testCloseNotifyNotWaitForResponse() throws Exception {
    testCloseNotify(0,false);
  }
  private void testCloseNotify(  final long closeNotifyReadTimeout,  final boolean timeout) throws Exception {
    SelfSignedCertificate ssc=new SelfSignedCertificate();
    final SslContext sslServerCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(serverProvider).protocols(SslUtils.PROTOCOL_TLS_V1_2).build();
    final SslContext sslClientCtx=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).sslProvider(clientProvider).protocols(SslUtils.PROTOCOL_TLS_V1_2).build();
    EventLoopGroup group=new NioEventLoopGroup();
    Channel sc=null;
    Channel cc=null;
    try {
      final Promise<Channel> clientPromise=group.next().newPromise();
      final Promise<Channel> serverPromise=group.next().newPromise();
      sc=new ServerBootstrap().group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          SslHandler handler=sslServerCtx.newHandler(ch.alloc());
          handler.setCloseNotifyReadTimeoutMillis(closeNotifyReadTimeout);
          handler.sslCloseFuture().addListener(new PromiseNotifier<Channel,Future<Channel>>(serverPromise));
          handler.handshakeFuture().addListener(new FutureListener<Channel>(){
            @Override public void operationComplete(            Future<Channel> future){
              if (!future.isSuccess()) {
                serverPromise.tryFailure(future.cause());
              }
            }
          }
);
          ch.pipeline().addLast(handler);
        }
      }
).bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
      cc=new Bootstrap().group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          final AtomicBoolean closeSent=new AtomicBoolean();
          if (timeout) {
            ch.pipeline().addFirst(new ChannelInboundHandlerAdapter(){
              @Override public void channelRead(              ChannelHandlerContext ctx,              Object msg) throws Exception {
                if (closeSent.get()) {
                  ReferenceCountUtil.release(msg);
                }
 else {
                  super.channelRead(ctx,msg);
                }
              }
            }
);
          }
          SslHandler handler=sslClientCtx.newHandler(ch.alloc());
          handler.setCloseNotifyReadTimeoutMillis(closeNotifyReadTimeout);
          handler.sslCloseFuture().addListener(new PromiseNotifier<Channel,Future<Channel>>(clientPromise));
          handler.handshakeFuture().addListener(new FutureListener<Channel>(){
            @Override public void operationComplete(            Future<Channel> future){
              if (future.isSuccess()) {
                closeSent.compareAndSet(false,true);
                future.getNow().close();
              }
 else {
                clientPromise.tryFailure(future.cause());
              }
            }
          }
);
          ch.pipeline().addLast(handler);
        }
      }
).connect(sc.localAddress()).syncUninterruptibly().channel();
      serverPromise.awaitUninterruptibly();
      clientPromise.awaitUninterruptibly();
      assertTrue(serverPromise.isSuccess());
      if (closeNotifyReadTimeout > 0 && !timeout) {
        assertTrue(clientPromise.isSuccess());
      }
 else {
        assertFalse(clientPromise.isSuccess());
      }
    }
  finally {
      if (cc != null) {
        cc.close().syncUninterruptibly();
      }
      if (sc != null) {
        sc.close().syncUninterruptibly();
      }
      group.shutdownGracefully();
      ReferenceCountUtil.release(sslServerCtx);
      ReferenceCountUtil.release(sslClientCtx);
    }
  }
}
