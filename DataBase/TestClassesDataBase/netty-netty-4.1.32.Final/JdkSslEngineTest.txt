@RunWith(Parameterized.class) public class JdkSslEngineTest extends SSLEngineTest {
  public enum ProviderType {  NPN_JETTY{
    @Override boolean isAvailable(){
      return JettyNpnSslEngine.isAvailable();
    }
    @Override Protocol protocol(){
      return Protocol.NPN;
    }
    @Override Provider provider(){
      return null;
    }
  }
,   ALPN_JETTY{
    @Override boolean isAvailable(){
      return JettyAlpnSslEngine.isAvailable();
    }
    @Override Protocol protocol(){
      return Protocol.ALPN;
    }
    @Override Provider provider(){
      return null;
    }
  }
,   ALPN_JAVA9{
    @Override boolean isAvailable(){
      return PlatformDependent.javaVersion() >= 9 && Java9SslUtils.supportsAlpn();
    }
    @Override Protocol protocol(){
      return Protocol.ALPN;
    }
    @Override Provider provider(){
      return null;
    }
  }
,   ALPN_CONSCRYPT{
    private Provider provider;
    @Override boolean isAvailable(){
      return Conscrypt.isAvailable();
    }
    @Override Protocol protocol(){
      return Protocol.ALPN;
    }
    @Override Provider provider(){
      try {
        if (provider == null) {
          provider=(Provider)Class.forName("org.conscrypt.OpenSSLProvider").getConstructor().newInstance();
        }
        return provider;
      }
 catch (      Exception e) {
        throw new IllegalStateException(e);
      }
    }
  }
;   abstract boolean isAvailable();
  abstract Protocol protocol();
  abstract Provider provider();
  final void activate(  JdkSslEngineTest instance){
    if (!isAvailable()) {
      throw tlsExtensionNotFound(protocol());
    }
    instance.provider=provider();
  }
}
  private static final String PREFERRED_APPLICATION_LEVEL_PROTOCOL="my-protocol-http2";
  private static final String FALLBACK_APPLICATION_LEVEL_PROTOCOL="my-protocol-http1_1";
  private static final String APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE="my-protocol-FOO";
  @Parameterized.Parameters(name="{index}: providerType = {0}, bufferType = {1}, combo = {2}") public static Collection<Object[]> data(){
    List<Object[]> params=new ArrayList<Object[]>();
    for (    ProviderType providerType : ProviderType.values()) {
      for (      BufferType bufferType : BufferType.values()) {
        params.add(new Object[]{providerType,bufferType,ProtocolCipherCombo.tlsv12()});
        if (PlatformDependent.javaVersion() >= 11) {
          params.add(new Object[]{providerType,bufferType,ProtocolCipherCombo.tlsv13()});
        }
      }
    }
    return params;
  }
  private final ProviderType providerType;
  private Provider provider;
  public JdkSslEngineTest(  ProviderType providerType,  BufferType bufferType,  ProtocolCipherCombo protocolCipherCombo){
    super(bufferType,protocolCipherCombo);
    this.providerType=providerType;
  }
  @Test public void testTlsExtension() throws Exception {
    try {
      providerType.activate(this);
      ApplicationProtocolConfig apn=failingNegotiator(providerType.protocol(),PREFERRED_APPLICATION_LEVEL_PROTOCOL);
      setupHandlers(apn);
      runTest();
    }
 catch (    SkipTestException e) {
      assumeNoException(e);
    }
  }
  @Test public void testTlsExtensionNoCompatibleProtocolsNoHandshakeFailure() throws Exception {
    try {
      providerType.activate(this);
      ApplicationProtocolConfig clientApn=acceptingNegotiator(providerType.protocol(),PREFERRED_APPLICATION_LEVEL_PROTOCOL);
      ApplicationProtocolConfig serverApn=acceptingNegotiator(providerType.protocol(),APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE);
      setupHandlers(serverApn,clientApn);
      runTest(null);
    }
 catch (    SkipTestException e) {
      assumeNoException(e);
    }
  }
  @Test public void testTlsExtensionNoCompatibleProtocolsClientHandshakeFailure() throws Exception {
    try {
      providerType.activate(this);
      if (providerType == ProviderType.NPN_JETTY) {
        ApplicationProtocolConfig clientApn=failingNegotiator(providerType.protocol(),PREFERRED_APPLICATION_LEVEL_PROTOCOL);
        ApplicationProtocolConfig serverApn=acceptingNegotiator(providerType.protocol(),APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE);
        setupHandlers(serverApn,clientApn);
        assertTrue(clientLatch.await(2,TimeUnit.SECONDS));
        assertTrue(clientException instanceof SSLHandshakeException);
      }
 else {
        SelfSignedCertificate ssc=new SelfSignedCertificate();
        JdkApplicationProtocolNegotiator clientApn=new JdkAlpnApplicationProtocolNegotiator(true,true,PREFERRED_APPLICATION_LEVEL_PROTOCOL);
        JdkApplicationProtocolNegotiator serverApn=new JdkAlpnApplicationProtocolNegotiator(new ProtocolSelectorFactory(){
          @Override public ProtocolSelector newSelector(          SSLEngine engine,          Set<String> supportedProtocols){
            return new ProtocolSelector(){
              @Override public void unsupported(){
              }
              @Override public String select(              List<String> protocols){
                return APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE;
              }
            }
;
          }
        }
,JdkBaseApplicationProtocolNegotiator.FAIL_SELECTION_LISTENER_FACTORY,APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE);
        SslContext serverSslCtx=new JdkSslServerContext(providerType.provider(),ssc.certificate(),ssc.privateKey(),null,null,IdentityCipherSuiteFilter.INSTANCE,serverApn,0,0);
        SslContext clientSslCtx=new JdkSslClientContext(providerType.provider(),null,InsecureTrustManagerFactory.INSTANCE,null,IdentityCipherSuiteFilter.INSTANCE,clientApn,0,0);
        setupHandlers(new TestDelegatingSslContext(serverSslCtx),new TestDelegatingSslContext(clientSslCtx));
        assertTrue(clientLatch.await(2,TimeUnit.SECONDS));
        assertTrue(clientException instanceof SSLHandshakeException || clientException == null);
      }
    }
 catch (    SkipTestException e) {
      assumeNoException(e);
    }
  }
  @Test public void testTlsExtensionNoCompatibleProtocolsServerHandshakeFailure() throws Exception {
    try {
      providerType.activate(this);
      ApplicationProtocolConfig clientApn=acceptingNegotiator(providerType.protocol(),PREFERRED_APPLICATION_LEVEL_PROTOCOL);
      ApplicationProtocolConfig serverApn=failingNegotiator(providerType.protocol(),APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE);
      setupHandlers(serverApn,clientApn);
      assertTrue(serverLatch.await(2,TimeUnit.SECONDS));
      assertTrue(serverException instanceof SSLHandshakeException);
    }
 catch (    SkipTestException e) {
      assumeNoException(e);
    }
  }
  @Test public void testAlpnCompatibleProtocolsDifferentClientOrder() throws Exception {
    try {
      providerType.activate(this);
      if (providerType == ProviderType.NPN_JETTY) {
        throw tlsExtensionNotFound(providerType.protocol());
      }
      ApplicationProtocolConfig clientApn=acceptingNegotiator(Protocol.ALPN,FALLBACK_APPLICATION_LEVEL_PROTOCOL,PREFERRED_APPLICATION_LEVEL_PROTOCOL);
      ApplicationProtocolConfig serverApn=failingNegotiator(Protocol.ALPN,PREFERRED_APPLICATION_LEVEL_PROTOCOL,FALLBACK_APPLICATION_LEVEL_PROTOCOL);
      setupHandlers(serverApn,clientApn);
      assertNull(serverException);
      runTest(PREFERRED_APPLICATION_LEVEL_PROTOCOL);
    }
 catch (    SkipTestException e) {
      assumeNoException(e);
    }
  }
  @Test public void testEnablingAnAlreadyDisabledSslProtocol() throws Exception {
    testEnablingAnAlreadyDisabledSslProtocol(new String[]{},new String[]{SslUtils.PROTOCOL_TLS_V1_2});
  }
  @Ignore @Override public void testMutualAuthValidClientCertChainTooLongFailOptionalClientAuth() throws Exception {
  }
  @Ignore @Override public void testMutualAuthValidClientCertChainTooLongFailRequireClientAuth() throws Exception {
  }
  @Override protected boolean mySetupMutualAuthServerIsValidException(  Throwable cause){
    return super.mySetupMutualAuthServerIsValidException(cause) || causedBySSLException(cause);
  }
  private void runTest() throws Exception {
    runTest(PREFERRED_APPLICATION_LEVEL_PROTOCOL);
  }
  @Override protected SslProvider sslClientProvider(){
    return SslProvider.JDK;
  }
  @Override protected SslProvider sslServerProvider(){
    return SslProvider.JDK;
  }
  @Override protected Provider clientSslContextProvider(){
    return provider;
  }
  @Override protected Provider serverSslContextProvider(){
    return provider;
  }
  private static ApplicationProtocolConfig failingNegotiator(  Protocol protocol,  String... supportedProtocols){
    return new ApplicationProtocolConfig(protocol,SelectorFailureBehavior.FATAL_ALERT,SelectedListenerFailureBehavior.FATAL_ALERT,supportedProtocols);
  }
  private static ApplicationProtocolConfig acceptingNegotiator(  Protocol protocol,  String... supportedProtocols){
    return new ApplicationProtocolConfig(protocol,SelectorFailureBehavior.NO_ADVERTISE,SelectedListenerFailureBehavior.ACCEPT,supportedProtocols);
  }
  private static SkipTestException tlsExtensionNotFound(  Protocol protocol){
    throw new SkipTestException(protocol + " not on classpath");
  }
private static final class SkipTestException extends RuntimeException {
    private static final long serialVersionUID=9214869217774035223L;
    SkipTestException(    String message){
      super(message);
    }
  }
private final class TestDelegatingSslContext extends DelegatingSslContext {
    TestDelegatingSslContext(    SslContext ctx){
      super(ctx);
    }
    @Override protected void initEngine(    SSLEngine engine){
      engine.setEnabledProtocols(protocols());
      engine.setEnabledCipherSuites(ciphers().toArray(EmptyArrays.EMPTY_STRINGS));
    }
  }
}
