private abstract static class MyChannel extends AbstractChannel {
  private static final ChannelMetadata METADATA=new ChannelMetadata(false);
  private final ChannelConfig config=new DefaultChannelConfig(this);
  private boolean active;
  private boolean closed;
  protected MyChannel(){
    super(null);
  }
  @Override protected DefaultChannelPipeline newChannelPipeline(){
    return new MyChannelPipeline(this);
  }
  @Override public ChannelConfig config(){
    return config;
  }
  @Override public boolean isOpen(){
    return !closed;
  }
  @Override public boolean isActive(){
    return isOpen() && active;
  }
  @Override public ChannelMetadata metadata(){
    return METADATA;
  }
  @Override protected AbstractUnsafe newUnsafe(){
    return new MyUnsafe();
  }
  @Override protected boolean isCompatible(  EventLoop loop){
    return true;
  }
  @Override protected SocketAddress localAddress0(){
    return null;
  }
  @Override protected SocketAddress remoteAddress0(){
    return null;
  }
  @Override protected void doBind(  SocketAddress localAddress) throws Exception {
  }
  @Override protected void doDisconnect() throws Exception {
  }
  @Override protected void doClose() throws Exception {
    closed=true;
  }
  @Override protected void doBeginRead() throws Exception {
  }
  @Override protected void doWrite(  ChannelOutboundBuffer in) throws Exception {
    throw new IOException();
  }
  protected void onUnhandledInboundChannelActive(){
  }
  protected void onUnhandledInboundChannelInactive(){
  }
  protected void onUnhandledInboundException(  Throwable cause){
  }
  protected void onUnhandledInboundMessage(  Object msg){
  }
  protected void onUnhandledInboundReadComplete(){
  }
  protected void onUnhandledInboundUserEventTriggered(  Object evt){
  }
  protected void onUnhandledInboundWritabilityChanged(){
  }
private class MyUnsafe extends AbstractUnsafe {
    @Override public void connect(    SocketAddress remoteAddress,    SocketAddress localAddress,    ChannelPromise promise){
      if (!ensureOpen(promise)) {
        return;
      }
      if (!active) {
        active=true;
        pipeline().fireChannelActive();
      }
      promise.setSuccess();
    }
  }
private class MyChannelPipeline extends DefaultChannelPipeline {
    public MyChannelPipeline(    Channel channel){
      super(channel);
    }
    @Override protected void onUnhandledInboundChannelActive(){
      MyChannel.this.onUnhandledInboundChannelActive();
    }
    @Override protected void onUnhandledInboundChannelInactive(){
      MyChannel.this.onUnhandledInboundChannelInactive();
    }
    @Override protected void onUnhandledInboundException(    Throwable cause){
      MyChannel.this.onUnhandledInboundException(cause);
    }
    @Override protected void onUnhandledInboundMessage(    Object msg){
      MyChannel.this.onUnhandledInboundMessage(msg);
    }
    @Override protected void onUnhandledInboundChannelReadComplete(){
      MyChannel.this.onUnhandledInboundReadComplete();
    }
    @Override protected void onUnhandledInboundUserEventTriggered(    Object evt){
      MyChannel.this.onUnhandledInboundUserEventTriggered(evt);
    }
    @Override protected void onUnhandledChannelWritabilityChanged(){
      MyChannel.this.onUnhandledInboundWritabilityChanged();
    }
  }
}
