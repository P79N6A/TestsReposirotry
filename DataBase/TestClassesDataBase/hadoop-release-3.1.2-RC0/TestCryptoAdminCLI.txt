public class TestCryptoAdminCLI extends CLITestHelperDFS {
  protected MiniDFSCluster dfsCluster=null;
  protected FileSystem fs=null;
  protected String namenode=null;
  private static File tmpDir;
  @Before @Override public void setUp() throws Exception {
    super.setUp();
    conf.setClass(PolicyProvider.POLICY_PROVIDER_CONFIG,HDFSPolicyProvider.class,PolicyProvider.class);
    conf.setInt(DFSConfigKeys.DFS_REPLICATION_KEY,1);
    conf.setLong(CommonConfigurationKeysPublic.FS_TRASH_INTERVAL_KEY,10);
    tmpDir=GenericTestUtils.getTestDir(UUID.randomUUID().toString());
    final Path jksPath=new Path(tmpDir.toString(),"test.jks");
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,JavaKeyStoreProvider.SCHEME_NAME + "://file" + jksPath.toUri());
    dfsCluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    dfsCluster.waitClusterUp();
    createAKey("mykey",conf);
    namenode=conf.get(DFSConfigKeys.FS_DEFAULT_NAME_KEY,"file:///");
    username=System.getProperty("user.name");
    fs=dfsCluster.getFileSystem();
    assertTrue("Not an HDFS: " + fs.getUri(),fs instanceof DistributedFileSystem);
  }
  @After @Override public void tearDown() throws Exception {
    if (fs != null) {
      fs.close();
      fs=null;
    }
    if (dfsCluster != null) {
      dfsCluster.shutdown();
      dfsCluster=null;
    }
    Thread.sleep(2000);
    super.tearDown();
  }
  private void createAKey(  String keyName,  Configuration conf) throws NoSuchAlgorithmException, IOException {
    final KeyProvider provider=dfsCluster.getNameNode().getNamesystem().getProvider();
    final KeyProvider.Options options=KeyProvider.options(conf);
    provider.createKey(keyName,options);
    provider.flush();
  }
  @Override protected String getTestFile(){
    return "testCryptoConf.xml";
  }
  @Override protected String expandCommand(  final String cmd){
    String expCmd=cmd;
    expCmd=expCmd.replaceAll("NAMENODE",namenode);
    expCmd=expCmd.replaceAll("#LF#",System.getProperty("line.separator"));
    expCmd=super.expandCommand(expCmd);
    return expCmd;
  }
  @Override protected TestConfigFileParser getConfigParser(){
    return new TestConfigFileParserCryptoAdmin();
  }
private class TestConfigFileParserCryptoAdmin extends CLITestHelperDFS.TestConfigFileParserDFS {
    @Override public void endElement(    String uri,    String localName,    String qName) throws SAXException {
      if (qName.equals("crypto-admin-command")) {
        if (testCommands != null) {
          testCommands.add(new CLITestCmdCryptoAdmin(charString,new CLICommandCryptoAdmin()));
        }
 else         if (cleanupCommands != null) {
          cleanupCommands.add(new CLITestCmdCryptoAdmin(charString,new CLICommandCryptoAdmin()));
        }
      }
 else {
        super.endElement(uri,localName,qName);
      }
    }
  }
private class CLITestCmdCryptoAdmin extends CLITestCmd {
    public CLITestCmdCryptoAdmin(    String str,    CLICommandTypes type){
      super(str,type);
    }
    @Override public CommandExecutor getExecutor(    String tag,    Configuration conf) throws IllegalArgumentException {
      if (getType() instanceof CLICommandCryptoAdmin) {
        return new CryptoAdminCmdExecutor(tag,new CryptoAdmin(conf));
      }
      return super.getExecutor(tag,conf);
    }
  }
  @Override protected Result execute(  CLICommand cmd) throws Exception {
    return cmd.getExecutor(namenode,conf).executeCommand(cmd.getCmd());
  }
  @Test @Override public void testAll(){
    super.testAll();
  }
}
