/** 
 * A worker to do one "unit" of read.
 */
static class ReadWorker extends Thread {
  static public final int N_ITERATIONS=1024;
  private static final double PROPORTION_NON_POSITIONAL_READ=0.10;
  private final TestFileInfo testInfo;
  private final long fileSize;
  private long bytesRead;
  private boolean error;
  private final ReadWorkerHelper helper;
  ReadWorker(  TestFileInfo testInfo,  int id,  ReadWorkerHelper helper){
    super("ReadWorker-" + id + "-"+ testInfo.filepath.toString());
    this.testInfo=testInfo;
    this.helper=helper;
    fileSize=testInfo.dis.getFileLength();
    assertEquals(fileSize,testInfo.authenticData.length);
    bytesRead=0;
    error=false;
  }
  /** 
 * Randomly do one of (1) Small read; and (2) Large Pread.
 */
  @Override public void run(){
    for (int i=0; i < N_ITERATIONS; ++i) {
      int startOff=rand.nextInt((int)fileSize);
      int len=0;
      try {
        double p=rand.nextDouble();
        if (p < PROPORTION_NON_POSITIONAL_READ) {
          len=Math.min(rand.nextInt(64),(int)fileSize - startOff);
          read(startOff,len);
          bytesRead+=len;
        }
 else {
          len=rand.nextInt((int)(fileSize - startOff));
          pRead(startOff,len);
          bytesRead+=len;
        }
      }
 catch (      Throwable t) {
        LOG.error(getName() + ": Error while testing read at " + startOff+ " length "+ len,t);
        error=true;
        fail(t.getMessage());
      }
    }
  }
  public long getBytesRead(){
    return bytesRead;
  }
  /** 
 * Raising error in a thread doesn't seem to fail the test. So check afterwards.
 */
  public boolean hasError(){
    return error;
  }
  static int readCount=0;
  /** 
 * Seek to somewhere random and read.
 */
  private void read(  int start,  int len) throws Exception {
    assertTrue("Bad args: " + start + " + "+ len+ " should be <= "+ fileSize,start + len <= fileSize);
    readCount++;
    DFSInputStream dis=testInfo.dis;
    byte buf[]=new byte[len];
    helper.read(dis,buf,start,len);
    verifyData("Read data corrupted",buf,start,start + len);
  }
  /** 
 * Positional read.
 */
  private void pRead(  int start,  int len) throws Exception {
    assertTrue("Bad args: " + start + " + "+ len+ " should be <= "+ fileSize,start + len <= fileSize);
    DFSInputStream dis=testInfo.dis;
    byte buf[]=new byte[len];
    helper.pRead(dis,buf,start,len);
    verifyData("Pread data corrupted",buf,start,start + len);
  }
  /** 
 * Verify read data vs authentic data
 */
  private void verifyData(  String msg,  byte actual[],  int start,  int end) throws Exception {
    byte auth[]=testInfo.authenticData;
    if (end > auth.length) {
      throw new Exception(msg + ": Actual array (" + end+ ") is past the end of authentic data ("+ auth.length+ ")");
    }
    int j=start;
    for (int i=0; i < actual.length; ++i, ++j) {
      if (auth[j] != actual[i]) {
        throw new Exception(msg + ": Arrays byte " + i+ " (at offset "+ j+ ") differs: expect "+ auth[j]+ " got "+ actual[i]);
      }
    }
  }
}
