public static abstract class FillWritable implements Writable, Configurable {
  private int len;
  protected boolean disableRead;
  private byte[] b;
  private final Random r;
  protected final byte fillChar;
  public FillWritable(  byte fillChar){
    this.fillChar=fillChar;
    r=new Random();
    final long seed=r.nextLong();
    LOG.info("seed: " + seed);
    r.setSeed(seed);
  }
  @Override public Configuration getConf(){
    return null;
  }
  public void setLength(  int len){
    this.len=len;
  }
  public int compareTo(  FillWritable o){
    if (o == this)     return 0;
    return len - o.len;
  }
  @Override public int hashCode(){
    return 37 * len;
  }
  @Override public boolean equals(  Object o){
    if (!(o instanceof FillWritable))     return false;
    return 0 == compareTo((FillWritable)o);
  }
  @Override public void readFields(  DataInput in) throws IOException {
    if (disableRead) {
      return;
    }
    len=WritableUtils.readVInt(in);
    for (int i=0; i < len; ++i) {
      assertEquals("Invalid byte at " + i,fillChar,in.readByte());
    }
  }
  @Override public void write(  DataOutput out) throws IOException {
    if (0 == len) {
      return;
    }
    int written=0;
    if (!disableRead) {
      WritableUtils.writeVInt(out,len);
      written-=WritableUtils.getVIntSize(len);
    }
    if (len > 1024) {
      if (null == b || b.length < len) {
        b=new byte[2 * len];
      }
      Arrays.fill(b,fillChar);
      do {
        final int write=Math.min(len - written,r.nextInt(len));
        out.write(b,0,write);
        written+=write;
      }
 while (written < len);
      assertEquals(len,written);
    }
 else {
      for (int i=written; i < len; ++i) {
        out.write(fillChar);
      }
    }
  }
}
