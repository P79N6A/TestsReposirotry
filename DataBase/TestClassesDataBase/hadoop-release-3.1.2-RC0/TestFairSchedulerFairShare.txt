public class TestFairSchedulerFairShare extends FairSchedulerTestBase {
  private final static String ALLOC_FILE=new File(TEST_DIR,TestFairSchedulerFairShare.class.getName() + ".xml").getAbsolutePath();
  @Before public void setup() throws IOException {
    conf=createConfiguration();
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE,ALLOC_FILE);
  }
  @After public void teardown(){
    if (resourceManager != null) {
      resourceManager.stop();
      resourceManager=null;
    }
    conf=null;
  }
  private void createClusterWithQueuesAndOneNode(  int mem,  String policy) throws IOException {
    createClusterWithQueuesAndOneNode(mem,0,policy);
  }
  private void createClusterWithQueuesAndOneNode(  int mem,  int vCores,  String policy) throws IOException {
    PrintWriter out=new PrintWriter(new FileWriter(ALLOC_FILE));
    out.println("<?xml version=\"1.0\"?>");
    out.println("<allocations>");
    out.println("<queue name=\"root\" >");
    out.println("   <queue name=\"parentA\" >");
    out.println("       <weight>8</weight>");
    out.println("       <queue name=\"childA1\" />");
    out.println("       <queue name=\"childA2\" />");
    out.println("       <queue name=\"childA3\" />");
    out.println("       <queue name=\"childA4\" />");
    out.println("   </queue>");
    out.println("   <queue name=\"parentB\" >");
    out.println("       <weight>1</weight>");
    out.println("       <queue name=\"childB1\" />");
    out.println("       <queue name=\"childB2\" />");
    out.println("   </queue>");
    out.println("</queue>");
    out.println("<defaultQueueSchedulingPolicy>" + policy + "</defaultQueueSchedulingPolicy>");
    out.println("</allocations>");
    out.close();
    resourceManager=new MockRM(conf);
    resourceManager.start();
    scheduler=(FairScheduler)resourceManager.getResourceScheduler();
    RMNode node1=MockNodes.newNodeInfo(1,Resources.createResource(mem,vCores),1,"127.0.0.1");
    NodeAddedSchedulerEvent nodeEvent1=new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);
  }
  @Test public void testFairShareNoAppsRunning() throws IOException {
    int nodeCapacity=16 * 1024;
    createClusterWithQueuesAndOneNode(nodeCapacity,"fair");
    scheduler.update();
    Collection<FSLeafQueue> leafQueues=scheduler.getQueueManager().getLeafQueues();
    for (    FSLeafQueue leaf : leafQueues) {
      if (leaf.getName().startsWith("root.parentA")) {
        assertEquals(0,(double)leaf.getFairShare().getMemorySize() / nodeCapacity,0);
      }
 else       if (leaf.getName().startsWith("root.parentB")) {
        assertEquals(0,(double)leaf.getFairShare().getMemorySize() / nodeCapacity,0);
      }
    }
    verifySteadyFairShareMemory(leafQueues,nodeCapacity);
  }
  @Test public void testFairShareOneAppRunning() throws IOException {
    int nodeCapacity=16 * 1024;
    createClusterWithQueuesAndOneNode(nodeCapacity,"fair");
    createSchedulingRequest(2 * 1024,"root.parentA.childA1","user1");
    scheduler.update();
    assertEquals(100,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA1",false).getFairShare().getMemorySize() / nodeCapacity * 100,0.1);
    assertEquals(0,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA2",false).getFairShare().getMemorySize() / nodeCapacity,0.1);
    verifySteadyFairShareMemory(scheduler.getQueueManager().getLeafQueues(),nodeCapacity);
  }
  @Test public void testFairShareMultipleActiveQueuesUnderSameParent() throws IOException {
    int nodeCapacity=16 * 1024;
    createClusterWithQueuesAndOneNode(nodeCapacity,"fair");
    createSchedulingRequest(2 * 1024,"root.parentA.childA1","user1");
    createSchedulingRequest(2 * 1024,"root.parentA.childA2","user2");
    createSchedulingRequest(2 * 1024,"root.parentA.childA3","user3");
    scheduler.update();
    for (int i=1; i <= 3; i++) {
      assertEquals(33,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA" + i,false).getFairShare().getMemorySize() / nodeCapacity * 100,.9);
    }
    verifySteadyFairShareMemory(scheduler.getQueueManager().getLeafQueues(),nodeCapacity);
  }
  @Test public void testFairShareMultipleActiveQueuesUnderDifferentParent() throws IOException {
    int nodeCapacity=16 * 1024;
    createClusterWithQueuesAndOneNode(nodeCapacity,"fair");
    createSchedulingRequest(2 * 1024,"root.parentA.childA1","user1");
    createSchedulingRequest(3 * 1024,"root.parentA.childA2","user2");
    createSchedulingRequest(1 * 1024,"root.parentB.childB1","user3");
    createSchedulingRequest(1 * 1024,"root.default","user4");
    scheduler.update();
    for (int i=1; i <= 2; i++) {
      assertEquals(40,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA" + i,false).getFairShare().getMemorySize() / nodeCapacity * 100,.9);
    }
    assertEquals(10,(double)scheduler.getQueueManager().getLeafQueue("root.parentB.childB1",false).getFairShare().getMemorySize() / nodeCapacity * 100,.9);
    verifySteadyFairShareMemory(scheduler.getQueueManager().getLeafQueues(),nodeCapacity);
  }
  @Test public void testFairShareResetsToZeroWhenAppsComplete() throws IOException {
    int nodeCapacity=16 * 1024;
    createClusterWithQueuesAndOneNode(nodeCapacity,"fair");
    ApplicationAttemptId app1=createSchedulingRequest(2 * 1024,"root.parentA.childA1","user1");
    ApplicationAttemptId app2=createSchedulingRequest(3 * 1024,"root.parentA.childA2","user2");
    scheduler.update();
    for (int i=1; i <= 2; i++) {
      assertEquals(50,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA" + i,false).getFairShare().getMemorySize() / nodeCapacity * 100,.9);
    }
    AppAttemptRemovedSchedulerEvent appRemovedEvent1=new AppAttemptRemovedSchedulerEvent(app1,RMAppAttemptState.FINISHED,false);
    scheduler.handle(appRemovedEvent1);
    scheduler.update();
    assertEquals(0,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA1",false).getFairShare().getMemorySize() / nodeCapacity * 100,0);
    assertEquals(100,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA2",false).getFairShare().getMemorySize() / nodeCapacity * 100,0.1);
    verifySteadyFairShareMemory(scheduler.getQueueManager().getLeafQueues(),nodeCapacity);
  }
  @Test public void testFairShareWithDRFMultipleActiveQueuesUnderDifferentParent() throws IOException {
    int nodeMem=16 * 1024;
    int nodeVCores=10;
    createClusterWithQueuesAndOneNode(nodeMem,nodeVCores,"drf");
    createSchedulingRequest(2 * 1024,"root.parentA.childA1","user1");
    createSchedulingRequest(3 * 1024,"root.parentA.childA2","user2");
    createSchedulingRequest(1 * 1024,"root.parentB.childB1","user3");
    createSchedulingRequest(1 * 1024,"root.default","user4");
    scheduler.update();
    for (int i=1; i <= 2; i++) {
      assertEquals(40,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA" + i,false).getFairShare().getMemorySize() / nodeMem * 100,.9);
      assertEquals(40,(double)scheduler.getQueueManager().getLeafQueue("root.parentA.childA" + i,false).getFairShare().getVirtualCores() / nodeVCores * 100,.9);
    }
    assertEquals(10,(double)scheduler.getQueueManager().getLeafQueue("root.parentB.childB1",false).getFairShare().getMemorySize() / nodeMem * 100,.9);
    assertEquals(10,(double)scheduler.getQueueManager().getLeafQueue("root.parentB.childB1",false).getFairShare().getVirtualCores() / nodeVCores * 100,.9);
    Collection<FSLeafQueue> leafQueues=scheduler.getQueueManager().getLeafQueues();
    for (    FSLeafQueue leaf : leafQueues) {
      if (leaf.getName().startsWith("root.parentA")) {
        assertEquals(0.2,(double)leaf.getSteadyFairShare().getMemorySize() / nodeMem,0.001);
        assertEquals(0.2,(double)leaf.getSteadyFairShare().getVirtualCores() / nodeVCores,0.001);
      }
 else       if (leaf.getName().startsWith("root.parentB")) {
        assertEquals(0.05,(double)leaf.getSteadyFairShare().getMemorySize() / nodeMem,0.001);
        assertEquals(0.1,(double)leaf.getSteadyFairShare().getVirtualCores() / nodeVCores,0.001);
      }
    }
  }
  /** 
 * Verify whether steady fair shares for all leaf queues still follow their weight, not related to active/inactive status.
 * @param leafQueues
 * @param nodeCapacity
 */
  private void verifySteadyFairShareMemory(  Collection<FSLeafQueue> leafQueues,  int nodeCapacity){
    for (    FSLeafQueue leaf : leafQueues) {
      if (leaf.getName().startsWith("root.parentA")) {
        assertEquals(0.2,(double)leaf.getSteadyFairShare().getMemorySize() / nodeCapacity,0.001);
      }
 else       if (leaf.getName().startsWith("root.parentB")) {
        assertEquals(0.05,(double)leaf.getSteadyFairShare().getMemorySize() / nodeCapacity,0.001);
      }
    }
  }
}
