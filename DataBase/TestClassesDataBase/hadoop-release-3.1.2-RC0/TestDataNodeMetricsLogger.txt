/** 
 * Test periodic logging of DataNode metrics.
 */
public class TestDataNodeMetricsLogger {
  static final Log LOG=LogFactory.getLog(TestDataNodeMetricsLogger.class);
  private static final String DATA_DIR=MiniDFSCluster.getBaseDirectory() + "data";
  private final static InetSocketAddress NN_ADDR=new InetSocketAddress("localhost",5020);
  private DataNode dn;
  static final Random random=new Random(System.currentTimeMillis());
  @Rule public Timeout timeout=new Timeout(300000);
  /** 
 * Starts an instance of DataNode
 * @throws IOException
 */
  public void startDNForTest(  boolean enableMetricsLogging) throws IOException {
    Configuration conf=new HdfsConfiguration();
    conf.set(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY,DATA_DIR);
    conf.set(DFSConfigKeys.DFS_DATANODE_ADDRESS_KEY,"0.0.0.0:0");
    conf.set(DFSConfigKeys.DFS_DATANODE_HTTP_ADDRESS_KEY,"0.0.0.0:0");
    conf.set(DFSConfigKeys.DFS_DATANODE_IPC_ADDRESS_KEY,"0.0.0.0:0");
    conf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECT_MAX_RETRIES_KEY,0);
    conf.setInt(DFS_DATANODE_METRICS_LOGGER_PERIOD_SECONDS_KEY,enableMetricsLogging ? 1 : 0);
    dn=InternalDataNodeTestUtils.startDNWithMockNN(conf,NN_ADDR,DATA_DIR);
  }
  /** 
 * Cleans the resources and closes the instance of datanode
 * @throws IOException if an error occurred
 */
  @After public void tearDown() throws IOException {
    if (dn != null) {
      try {
        dn.shutdown();
      }
 catch (      Exception e) {
        LOG.error("Cannot close: ",e);
      }
 finally {
        File dir=new File(DATA_DIR);
        if (dir.exists())         Assert.assertTrue("Cannot delete data-node dirs",FileUtil.fullyDelete(dir));
      }
    }
    dn=null;
  }
  @Test public void testMetricsLoggerOnByDefault() throws IOException {
    startDNForTest(true);
    assertNotNull(dn);
    assertNotNull(dn.getMetricsLoggerTimer());
  }
  @Test public void testDisableMetricsLogger() throws IOException {
    startDNForTest(false);
    assertNotNull(dn);
    assertNull(dn.getMetricsLoggerTimer());
  }
  @Test public void testMetricsLoggerIsAsync() throws IOException {
    startDNForTest(true);
    assertNotNull(dn);
    org.apache.log4j.Logger logger=((Log4JLogger)DataNode.METRICS_LOG).getLogger();
    @SuppressWarnings("unchecked") List<Appender> appenders=Collections.list(logger.getAllAppenders());
    assertTrue(appenders.get(0) instanceof AsyncAppender);
  }
  /** 
 * Publish a fake metric under the "Hadoop:" domain and ensure it is logged by the metrics logger.
 */
  @Test public void testMetricsLogOutput() throws IOException, InterruptedException, TimeoutException {
    TestFakeMetric metricsProvider=new TestFakeMetric();
    MBeans.register(this.getClass().getSimpleName(),"DummyMetrics",metricsProvider);
    startDNForTest(true);
    assertNotNull(dn);
    final PatternMatchingAppender appender=new PatternMatchingAppender("^.*FakeMetric.*$");
    addAppender(DataNode.METRICS_LOG,appender);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return appender.isMatched();
      }
    }
,1000,60000);
    dn.shutdown();
  }
  private void addAppender(  Log log,  Appender appender){
    org.apache.log4j.Logger logger=((Log4JLogger)log).getLogger();
    @SuppressWarnings("unchecked") List<Appender> appenders=Collections.list(logger.getAllAppenders());
    ((AsyncAppender)appenders.get(0)).addAppender(appender);
  }
public interface TestFakeMetricMXBean {
    int getFakeMetric();
  }
  /** 
 * MBean for testing
 */
public static class TestFakeMetric implements TestFakeMetricMXBean {
    @Override public int getFakeMetric(){
      return 0;
    }
  }
  /** 
 * An appender that matches logged messages against the given regular expression.
 */
public static class PatternMatchingAppender extends AppenderSkeleton {
    private final Pattern pattern;
    private volatile boolean matched;
    public PatternMatchingAppender(    String pattern){
      this.pattern=Pattern.compile(pattern);
      this.matched=false;
    }
    public boolean isMatched(){
      return matched;
    }
    @Override protected void append(    LoggingEvent event){
      if (pattern.matcher(event.getMessage().toString()).matches()) {
        matched=true;
      }
    }
    @Override public void close(){
    }
    @Override public boolean requiresLayout(){
      return false;
    }
  }
}
