/** 
 * Test various failure scenarios during saveNamespace() operation. Cases covered: <ol> <li>Recover from failure while saving into the second storage directory</li> <li>Recover from failure while moving current into lastcheckpoint.tmp</li> <li>Recover from failure while moving lastcheckpoint.tmp into previous.checkpoint</li> <li>Recover from failure while rolling edits file</li> </ol>
 */
public class TestSaveNamespace {
static {
    GenericTestUtils.setLogLevel(FSImage.LOG,Level.ALL);
  }
  private static final Log LOG=LogFactory.getLog(TestSaveNamespace.class);
private static class FaultySaveImage implements Answer<Void> {
    private int count=0;
    private boolean throwRTE=true;
    public FaultySaveImage(    boolean throwRTE){
      this.throwRTE=throwRTE;
    }
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Object[] args=invocation.getArguments();
      StorageDirectory sd=(StorageDirectory)args[1];
      if (count++ == 1) {
        LOG.info("Injecting fault for sd: " + sd);
        if (throwRTE) {
          throw new RuntimeException("Injected fault: saveFSImage second time");
        }
 else {
          throw new IOException("Injected fault: saveFSImage second time");
        }
      }
      LOG.info("Not injecting fault for sd: " + sd);
      return (Void)invocation.callRealMethod();
    }
  }
private static class FaultyWriteProperties implements Answer<Void> {
    private int count=0;
    private Fault faultType;
    FaultyWriteProperties(    Fault faultType){
      this.faultType=faultType;
    }
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Object[] args=invocation.getArguments();
      StorageDirectory sd=(StorageDirectory)args[0];
      if (faultType == Fault.WRITE_STORAGE_ALL || (faultType == Fault.WRITE_STORAGE_ONE && count++ == 1)) {
        LOG.info("Injecting fault for sd: " + sd);
        throw new IOException("Injected fault: writeProperties second time");
      }
      LOG.info("Not injecting fault for sd: " + sd);
      return (Void)invocation.callRealMethod();
    }
  }
  private enum Fault {  SAVE_SECOND_FSIMAGE_RTE,   SAVE_SECOND_FSIMAGE_IOE,   SAVE_ALL_FSIMAGES,   WRITE_STORAGE_ALL,   WRITE_STORAGE_ONE}
  private void saveNamespaceWithInjectedFault(  Fault fault) throws Exception {
    Configuration conf=getConf();
    NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
    DFSTestUtil.formatNameNode(conf);
    FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
    FSImage originalImage=fsn.getFSImage();
    NNStorage storage=originalImage.getStorage();
    NNStorage spyStorage=spy(storage);
    originalImage.storage=spyStorage;
    FSImage spyImage=spy(originalImage);
    Whitebox.setInternalState(fsn,"fsImage",spyImage);
    boolean shouldFail=false;
switch (fault) {
case SAVE_SECOND_FSIMAGE_RTE:
      doAnswer(new FaultySaveImage(true)).when(spyImage).saveFSImage(anyObject(),anyObject(),anyObject());
    shouldFail=false;
  break;
case SAVE_SECOND_FSIMAGE_IOE:
doAnswer(new FaultySaveImage(false)).when(spyImage).saveFSImage(anyObject(),anyObject(),anyObject());
shouldFail=false;
break;
case SAVE_ALL_FSIMAGES:
doThrow(new RuntimeException("Injected")).when(spyImage).saveFSImage(anyObject(),anyObject(),anyObject());
shouldFail=true;
break;
case WRITE_STORAGE_ALL:
doAnswer(new FaultyWriteProperties(Fault.WRITE_STORAGE_ALL)).when(spyStorage).writeProperties(anyObject());
shouldFail=true;
break;
case WRITE_STORAGE_ONE:
doAnswer(new FaultyWriteProperties(Fault.WRITE_STORAGE_ONE)).when(spyStorage).writeProperties(anyObject());
shouldFail=false;
break;
default :
fail("Unknown fail type");
break;
}
try {
doAnEdit(fsn,1);
fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
try {
fsn.saveNamespace(0,0);
if (shouldFail) {
fail("Did not fail!");
}
}
 catch (Exception e) {
if (!shouldFail) {
throw e;
}
 else {
LOG.info("Test caught expected exception",e);
}
}
fsn.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
doAnEdit(fsn,2);
originalImage.close();
fsn.close();
fsn=null;
fsn=FSNamesystem.loadFromDisk(conf);
checkEditExists(fsn,1);
checkEditExists(fsn,2);
}
  finally {
if (fsn != null) {
fsn.close();
}
}
}
/** 
 * Verify that a saveNamespace command brings faulty directories in fs.name.dir and fs.edit.dir back online.
 */
@Test(timeout=30000) public void testReinsertnamedirsInSavenamespace() throws Exception {
Configuration conf=getConf();
conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_RESTORE_KEY,true);
NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
DFSTestUtil.formatNameNode(conf);
FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
FSImage originalImage=fsn.getFSImage();
NNStorage storage=originalImage.getStorage();
FSImage spyImage=spy(originalImage);
Whitebox.setInternalState(fsn,"fsImage",spyImage);
FileSystem fs=FileSystem.getLocal(conf);
File rootDir=storage.getStorageDir(0).getRoot();
Path rootPath=new Path(rootDir.getPath(),"current");
final FsPermission permissionNone=new FsPermission((short)0);
final FsPermission permissionAll=new FsPermission(FsAction.ALL,FsAction.READ_EXECUTE,FsAction.READ_EXECUTE);
fs.setPermission(rootPath,permissionNone);
try {
doAnEdit(fsn,1);
fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
LOG.info("Doing the first savenamespace.");
fsn.saveNamespace(0,0);
LOG.info("First savenamespace sucessful.");
assertTrue("Savenamespace should have marked one directory as bad." + " But found " + storage.getRemovedStorageDirs().size() + " bad directories.",storage.getRemovedStorageDirs().size() == 1);
fs.setPermission(rootPath,permissionAll);
LOG.info("Doing the second savenamespace.");
fsn.saveNamespace(0,0);
LOG.warn("Second savenamespace sucessful.");
assertTrue("Savenamespace should have been successful in removing " + " bad directories from Image." + " But found " + storage.getRemovedStorageDirs().size() + " bad directories.",storage.getRemovedStorageDirs().size() == 0);
LOG.info("Shutting down fsimage.");
originalImage.close();
fsn.close();
fsn=null;
LOG.info("Loading new FSmage from disk.");
fsn=FSNamesystem.loadFromDisk(conf);
LOG.info("Checking reloaded image.");
checkEditExists(fsn,1);
LOG.info("Reloaded image is good.");
}
  finally {
if (rootDir.exists()) {
fs.setPermission(rootPath,permissionAll);
}
if (fsn != null) {
try {
fsn.close();
}
 catch (Throwable t) {
LOG.fatal("Failed to shut down",t);
}
}
}
}
@Test(timeout=30000) public void testRTEWhileSavingSecondImage() throws Exception {
saveNamespaceWithInjectedFault(Fault.SAVE_SECOND_FSIMAGE_RTE);
}
@Test(timeout=30000) public void testIOEWhileSavingSecondImage() throws Exception {
saveNamespaceWithInjectedFault(Fault.SAVE_SECOND_FSIMAGE_IOE);
}
@Test(timeout=30000) public void testCrashInAllImageDirs() throws Exception {
saveNamespaceWithInjectedFault(Fault.SAVE_ALL_FSIMAGES);
}
@Test(timeout=30000) public void testCrashWhenWritingVersionFiles() throws Exception {
saveNamespaceWithInjectedFault(Fault.WRITE_STORAGE_ALL);
}
@Test(timeout=30000) public void testCrashWhenWritingVersionFileInOneDir() throws Exception {
saveNamespaceWithInjectedFault(Fault.WRITE_STORAGE_ONE);
}
/** 
 * Test case where savenamespace fails in all directories and then the NN shuts down. Here we should recover from the failed checkpoint since it only affected ".ckpt" files, not valid image files
 */
@Test(timeout=30000) public void testFailedSaveNamespace() throws Exception {
doTestFailedSaveNamespace(false);
}
/** 
 * Test case where saveNamespace fails in all directories, but then the operator restores the directories and calls it again. This should leave the NN in a clean state for next start.
 */
@Test(timeout=30000) public void testFailedSaveNamespaceWithRecovery() throws Exception {
doTestFailedSaveNamespace(true);
}
/** 
 * Injects a failure on all storage directories while saving namespace.
 * @param restoreStorageAfterFailure if true, will try to save again afterclearing the failure injection
 */
public void doTestFailedSaveNamespace(boolean restoreStorageAfterFailure) throws Exception {
Configuration conf=getConf();
NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
DFSTestUtil.formatNameNode(conf);
FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
final FSImage originalImage=fsn.getFSImage();
NNStorage storage=originalImage.getStorage();
storage.close();
NNStorage spyStorage=spy(storage);
originalImage.storage=spyStorage;
FSImage spyImage=spy(originalImage);
Whitebox.setInternalState(fsn,"fsImage",spyImage);
spyImage.storage.setStorageDirectories(FSNamesystem.getNamespaceDirs(conf),FSNamesystem.getNamespaceEditsDirs(conf));
doThrow(new IOException("Injected fault: saveFSImage")).when(spyImage).saveFSImage(anyObject(),anyObject(),anyObject());
try {
doAnEdit(fsn,1);
fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
try {
fsn.saveNamespace(0,0);
fail("saveNamespace did not fail even when all directories failed!");
}
 catch (IOException ioe) {
LOG.info("Got expected exception",ioe);
}
if (restoreStorageAfterFailure) {
Mockito.reset(spyImage);
spyStorage.setRestoreFailedStorage(true);
fsn.saveNamespace(0,0);
checkEditExists(fsn,1);
}
originalImage.close();
fsn.close();
fsn=null;
fsn=FSNamesystem.loadFromDisk(conf);
checkEditExists(fsn,1);
}
  finally {
if (fsn != null) {
fsn.close();
}
}
}
@Test(timeout=30000) public void testSaveWhileEditsRolled() throws Exception {
Configuration conf=getConf();
NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
DFSTestUtil.formatNameNode(conf);
FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
try {
doAnEdit(fsn,1);
CheckpointSignature sig=fsn.rollEditLog();
LOG.warn("Checkpoint signature: " + sig);
doAnEdit(fsn,2);
fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
fsn.saveNamespace(0,0);
fsn.close();
fsn=null;
fsn=FSNamesystem.loadFromDisk(conf);
checkEditExists(fsn,1);
checkEditExists(fsn,2);
}
  finally {
if (fsn != null) {
fsn.close();
}
}
}
@Test(timeout=30000) public void testTxIdPersistence() throws Exception {
Configuration conf=getConf();
NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
DFSTestUtil.formatNameNode(conf);
FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
try {
assertEquals(1,fsn.getEditLog().getLastWrittenTxId());
doAnEdit(fsn,1);
assertEquals(2,fsn.getEditLog().getLastWrittenTxId());
fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
fsn.saveNamespace(0,0);
assertEquals(4,fsn.getEditLog().getLastWrittenTxId());
fsn.getFSImage().close();
fsn.close();
assertEquals(5,fsn.getEditLog().getLastWrittenTxId());
fsn=null;
fsn=FSNamesystem.loadFromDisk(conf);
assertEquals(6,fsn.getEditLog().getLastWrittenTxId());
}
  finally {
if (fsn != null) {
fsn.close();
}
}
}
@Test(timeout=20000) public void testCancelSaveNamespace() throws Exception {
Configuration conf=getConf();
NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
DFSTestUtil.formatNameNode(conf);
FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
final FSImage image=fsn.getFSImage();
NNStorage storage=image.getStorage();
storage.close();
storage.setStorageDirectories(FSNamesystem.getNamespaceDirs(conf),FSNamesystem.getNamespaceEditsDirs(conf));
FSNamesystem spyFsn=spy(fsn);
final FSNamesystem finalFsn=spyFsn;
DelayAnswer delayer=new GenericTestUtils.DelayAnswer(LOG);
BlockIdManager bid=spy(spyFsn.getBlockManager().getBlockIdManager());
Whitebox.setInternalState(finalFsn.getBlockManager(),"blockIdManager",bid);
doAnswer(delayer).when(bid).getGenerationStamp();
ExecutorService pool=Executors.newFixedThreadPool(2);
try {
doAnEdit(fsn,1);
final Canceler canceler=new Canceler();
fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
try {
Future<Void> saverFuture=pool.submit(new Callable<Void>(){
@Override public Void call() throws Exception {
image.saveNamespace(finalFsn,NameNodeFile.IMAGE,canceler);
return null;
}
}
);
delayer.waitForCall();
Future<Void> cancelFuture=pool.submit(new Callable<Void>(){
@Override public Void call() throws Exception {
canceler.cancel("cancelled");
return null;
}
}
);
Thread.sleep(500);
delayer.proceed();
cancelFuture.get();
saverFuture.get();
fail("saveNamespace did not fail even though cancelled!");
}
 catch (Throwable t) {
GenericTestUtils.assertExceptionContains("SaveNamespaceCancelledException",t);
}
LOG.info("Successfully cancelled a saveNamespace");
FSImageTestUtil.logStorageContents(LOG,storage);
for (StorageDirectory sd : storage.dirIterable(null)) {
File curDir=sd.getCurrentDir();
GenericTestUtils.assertGlobEquals(curDir,"fsimage_.*",NNStorage.getImageFileName(0),NNStorage.getImageFileName(0) + MD5FileUtils.MD5_SUFFIX);
}
}
  finally {
fsn.close();
}
}
/** 
 * Test for save namespace should succeed when parent directory renamed with open lease and destination directory exist.  This test is a regression for HDFS-2827
 */
@Test(timeout=30000) public void testSaveNamespaceWithRenamedLease() throws Exception {
MiniDFSCluster cluster=new MiniDFSCluster.Builder(new Configuration()).numDataNodes(1).build();
cluster.waitActive();
DistributedFileSystem fs=cluster.getFileSystem();
OutputStream out=null;
try {
fs.mkdirs(new Path("/test-target"));
out=fs.create(new Path("/test-source/foo"));
fs.rename(new Path("/test-source/"),new Path("/test-target/"));
fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
cluster.getNameNodeRpc().saveNamespace(0,0);
fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
}
  finally {
IOUtils.cleanup(LOG,out,fs);
cluster.shutdown();
}
}
@Test(timeout=30000) public void testSaveNamespaceWithDanglingLease() throws Exception {
MiniDFSCluster cluster=new MiniDFSCluster.Builder(new Configuration()).numDataNodes(1).build();
cluster.waitActive();
DistributedFileSystem fs=cluster.getFileSystem();
try {
cluster.getNamesystem().leaseManager.addLease("me",INodeId.ROOT_INODE_ID + 1);
fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
cluster.getNameNodeRpc().saveNamespace(0,0);
fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
}
  finally {
cluster.shutdown();
}
}
@Test public void testSkipSnapshotSection() throws Exception {
MiniDFSCluster cluster=new MiniDFSCluster.Builder(new Configuration()).numDataNodes(1).build();
cluster.waitActive();
DistributedFileSystem fs=cluster.getFileSystem();
OutputStream out=null;
try {
String path="/skipSnapshot";
out=fs.create(new Path(path));
out.close();
FSDirectory dir=cluster.getNamesystem().getFSDirectory();
INodeFile file=dir.getINode(path).asFile();
file.addSnapshotFeature(null).getDiffs().saveSelf2Snapshot(-1,file,null,false);
assertTrue("Snapshot fileDiff is missing.",file.getFileWithSnapshotFeature().getDiffs() != null);
fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
cluster.getNameNodeRpc().saveNamespace(0,0);
fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
cluster.restartNameNode(true);
dir=cluster.getNamesystem().getFSDirectory();
file=dir.getINode(path).asFile();
assertTrue("There should be no snapshot feature for this INode.",file.getFileWithSnapshotFeature() == null);
}
  finally {
cluster.shutdown();
}
}
@Test public void testSaveNamespaceBeforeShutdown() throws Exception {
Configuration conf=new HdfsConfiguration();
MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
cluster.waitActive();
DistributedFileSystem fs=cluster.getFileSystem();
try {
final FSImage fsimage=cluster.getNameNode().getFSImage();
final long before=fsimage.getStorage().getMostRecentCheckpointTxId();
fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
cluster.getNameNodeRpc().saveNamespace(3600,1000);
long after=fsimage.getStorage().getMostRecentCheckpointTxId();
Assert.assertEquals(before,after);
Thread.sleep(1000);
cluster.getNameNodeRpc().saveNamespace(1,1000);
fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
after=fsimage.getStorage().getMostRecentCheckpointTxId();
Assert.assertTrue(after > before);
fs.mkdirs(new Path("/foo/bar/baz"));
fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
cluster.getNameNodeRpc().saveNamespace(3600,5);
long after2=fsimage.getStorage().getMostRecentCheckpointTxId();
Assert.assertEquals(after,after2);
cluster.getNameNodeRpc().saveNamespace(3600,3);
after2=fsimage.getStorage().getMostRecentCheckpointTxId();
Assert.assertTrue(after2 > after);
}
  finally {
cluster.shutdown();
}
}
@Test(timeout=30000) public void testTxFaultTolerance() throws Exception {
String baseDir=MiniDFSCluster.getBaseDirectory();
List<String> nameDirs=new ArrayList<>();
nameDirs.add(fileAsURI(new File(baseDir,"name1")).toString());
nameDirs.add(fileAsURI(new File(baseDir,"name2")).toString());
Configuration conf=new HdfsConfiguration();
String nameDirsStr=StringUtils.join(",",nameDirs);
conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameDirsStr);
conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameDirsStr);
NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
DFSTestUtil.formatNameNode(conf);
FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
try {
assertEquals(1,fsn.getEditLog().getLastWrittenTxId());
doAnEdit(fsn,1);
assertEquals(2,fsn.getEditLog().getLastWrittenTxId());
fsn.close();
File txidFile0=new File(new URI(nameDirs.get(0) + "/current/seen_txid"));
FileWriter fw=new FileWriter(txidFile0,false);
try (PrintWriter pw=new PrintWriter(fw)){
pw.print("corrupt____!");
}
 fsn=FSNamesystem.loadFromDisk(conf);
assertEquals(4,fsn.getEditLog().getLastWrittenTxId());
File txidFile1=new File(new URI(nameDirs.get(1) + "/current/seen_txid"));
assertTrue(FileUtils.contentEquals(txidFile0,txidFile1));
}
  finally {
if (fsn != null) {
fsn.close();
}
}
}
private void doAnEdit(FSNamesystem fsn,int id) throws IOException {
fsn.mkdirs("/test" + id,new PermissionStatus("test","Test",new FsPermission((short)0777)),true);
}
private void checkEditExists(FSNamesystem fsn,int id) throws IOException {
assertNotNull(fsn.getFileInfo("/test" + id,false,false,false));
}
private Configuration getConf() throws IOException {
String baseDir=MiniDFSCluster.getBaseDirectory();
String nameDirs=fileAsURI(new File(baseDir,"name1")) + "," + fileAsURI(new File(baseDir,"name2"));
Configuration conf=new HdfsConfiguration();
FileSystem.setDefaultUri(conf,"hdfs://localhost:0");
conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,"0.0.0.0:0");
conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameDirs);
conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameDirs);
conf.set(DFSConfigKeys.DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY,"0.0.0.0:0");
conf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,false);
return conf;
}
}
