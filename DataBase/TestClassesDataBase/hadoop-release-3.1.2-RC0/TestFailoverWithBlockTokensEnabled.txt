public class TestFailoverWithBlockTokensEnabled {
  private static final Path TEST_PATH=new Path("/test-path");
  private static final String TEST_DATA="very important text";
  private static final int numNNs=3;
  private Configuration conf;
  private MiniDFSCluster cluster;
  @Before public void startCluster() throws IOException {
    conf=new Configuration();
    conf.setBoolean(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,true);
    conf.setInt(HdfsClientConfigKeys.Retry.WINDOW_BASE_KEY,10);
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology(numNNs)).numDataNodes(1).build();
  }
  @After public void shutDownCluster(){
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  @Test public void ensureSerialNumbersNeverOverlap(){
    BlockTokenSecretManager btsm1=cluster.getNamesystem(0).getBlockManager().getBlockTokenSecretManager();
    BlockTokenSecretManager btsm2=cluster.getNamesystem(1).getBlockManager().getBlockTokenSecretManager();
    BlockTokenSecretManager btsm3=cluster.getNamesystem(2).getBlockManager().getBlockTokenSecretManager();
    setAndCheckSerialNumber(0,btsm1,btsm2,btsm3);
    setAndCheckSerialNumber(Integer.MAX_VALUE,btsm1,btsm2,btsm3);
    setAndCheckSerialNumber(Integer.MIN_VALUE,btsm1,btsm2,btsm3);
    setAndCheckSerialNumber(Integer.MAX_VALUE / 2,btsm1,btsm2,btsm3);
    setAndCheckSerialNumber(Integer.MIN_VALUE / 2,btsm1,btsm2,btsm3);
    setAndCheckSerialNumber(Integer.MAX_VALUE / 3,btsm1,btsm2,btsm3);
    setAndCheckSerialNumber(Integer.MIN_VALUE / 3,btsm1,btsm2,btsm3);
  }
  private void setAndCheckSerialNumber(  int serialNumber,  BlockTokenSecretManager... btsms){
    for (    BlockTokenSecretManager btsm : btsms) {
      btsm.setSerialNo(serialNumber);
    }
    for (int i=0; i < btsms.length; i++) {
      for (int j=0; j < btsms.length; j++) {
        if (j == i) {
          continue;
        }
        int first=btsms[i].getSerialNoForTesting();
        int second=btsms[j].getSerialNoForTesting();
        assertFalse("Overlap found for set serial number (" + serialNumber + ") is "+ i+ ": "+ first+ " == "+ j+ ": "+ second,first == second);
      }
    }
  }
  @Test public void ensureInvalidBlockTokensAreRejected() throws IOException, URISyntaxException {
    cluster.transitionToActive(0);
    FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
    DFSTestUtil.writeFile(fs,TEST_PATH,TEST_DATA);
    assertEquals(TEST_DATA,DFSTestUtil.readFile(fs,TEST_PATH));
    DFSClient dfsClient=DFSClientAdapter.getDFSClient((DistributedFileSystem)fs);
    DFSClient spyDfsClient=Mockito.spy(dfsClient);
    Mockito.doAnswer(new Answer<LocatedBlocks>(){
      @Override public LocatedBlocks answer(      InvocationOnMock arg0) throws Throwable {
        LocatedBlocks locatedBlocks=(LocatedBlocks)arg0.callRealMethod();
        for (        LocatedBlock lb : locatedBlocks.getLocatedBlocks()) {
          Token<BlockTokenIdentifier> token=lb.getBlockToken();
          BlockTokenIdentifier id=lb.getBlockToken().decodeIdentifier();
          id.setExpiryDate(Time.now() + 10);
          Token<BlockTokenIdentifier> newToken=new Token<BlockTokenIdentifier>(id.getBytes(),token.getPassword(),token.getKind(),token.getService());
          lb.setBlockToken(newToken);
        }
        return locatedBlocks;
      }
    }
).when(spyDfsClient).getLocatedBlocks(Mockito.anyString(),Mockito.anyLong(),Mockito.anyLong());
    DFSClientAdapter.setDFSClient((DistributedFileSystem)fs,spyDfsClient);
    try {
      assertEquals(TEST_DATA,DFSTestUtil.readFile(fs,TEST_PATH));
      fail("Shouldn't have been able to read a file with invalid block tokens");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Could not obtain block",ioe);
    }
  }
  @Test public void testFailoverAfterRegistration() throws IOException, URISyntaxException {
    writeUsingBothNameNodes();
  }
  @Test public void TestFailoverAfterAccessKeyUpdate() throws IOException, URISyntaxException, InterruptedException {
    lowerKeyUpdateIntervalAndClearKeys(cluster);
    Thread.sleep(10 * 1000);
    writeUsingBothNameNodes();
  }
  private void writeUsingBothNameNodes() throws ServiceFailedException, IOException, URISyntaxException {
    cluster.transitionToActive(0);
    FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
    DFSTestUtil.writeFile(fs,TEST_PATH,TEST_DATA);
    cluster.transitionToStandby(0);
    cluster.transitionToActive(1);
    fs.delete(TEST_PATH,false);
    DFSTestUtil.writeFile(fs,TEST_PATH,TEST_DATA);
  }
  private static void lowerKeyUpdateIntervalAndClearKeys(  MiniDFSCluster cluster){
    lowerKeyUpdateIntervalAndClearKeys(cluster.getNamesystem(0));
    lowerKeyUpdateIntervalAndClearKeys(cluster.getNamesystem(1));
    for (    DataNode dn : cluster.getDataNodes()) {
      dn.clearAllBlockSecretKeys();
    }
  }
  private static void lowerKeyUpdateIntervalAndClearKeys(  FSNamesystem namesystem){
    BlockTokenSecretManager btsm=namesystem.getBlockManager().getBlockTokenSecretManager();
    btsm.setKeyUpdateIntervalForTesting(2 * 1000);
    btsm.setTokenLifetime(2 * 1000);
    btsm.clearAllKeysForTesting();
  }
}
