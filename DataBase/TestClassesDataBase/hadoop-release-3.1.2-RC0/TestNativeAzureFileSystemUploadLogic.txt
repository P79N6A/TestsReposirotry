/** 
 * Tests for the upload, buffering and flush logic in WASB.
 */
public class TestNativeAzureFileSystemUploadLogic extends AbstractWasbTestBase {
  static final int byteValuePeriod=47;
  @Override protected AzureBlobStorageTestAccount createTestAccount() throws Exception {
    return AzureBlobStorageTestAccount.createMock();
  }
  /** 
 * Various scenarios to test in how often we flush data while uploading.
 */
  private enum FlushFrequencyVariation {  /** 
 * Flush before even a single in-memory buffer is full.
 */
  BeforeSingleBufferFull,   /** 
 * Flush after a single in-memory buffer is full.
 */
  AfterSingleBufferFull,   /** 
 * Flush after all the in-memory buffers got full and were automatically flushed to the backing store.
 */
  AfterAllRingBufferFull}
  /** 
 * Tests that we upload consistently if we flush after every little bit of data.
 */
  @Test @Ignore public void testConsistencyAfterSmallFlushes() throws Exception {
    testConsistencyAfterManyFlushes(FlushFrequencyVariation.BeforeSingleBufferFull);
  }
  /** 
 * Tests that we upload consistently if we flush after every medium-sized bit of data.
 */
  @Test @Ignore public void testConsistencyAfterMediumFlushes() throws Exception {
    testConsistencyAfterManyFlushes(FlushFrequencyVariation.AfterSingleBufferFull);
  }
  /** 
 * Tests that we upload consistently if we flush after every large chunk of data.
 */
  @Test @Ignore public void testConsistencyAfterLargeFlushes() throws Exception {
    testConsistencyAfterManyFlushes(FlushFrequencyVariation.AfterAllRingBufferFull);
  }
  /** 
 * Makes sure the data in the given input is what I'd expect.
 * @param inStream The input stream.
 * @param expectedSize The expected size of the data in there.
 */
  private void assertDataInStream(  InputStream inStream,  int expectedSize) throws Exception {
    int byteRead;
    int countBytes=0;
    while ((byteRead=inStream.read()) != -1) {
      assertEquals(countBytes % byteValuePeriod,byteRead);
      countBytes++;
    }
    assertEquals(expectedSize,countBytes);
  }
  /** 
 * Checks that the data in the given file is what I'd expect.
 * @param file The file to check.
 * @param expectedSize The expected size of the data in there.
 */
  private void assertDataInFile(  Path file,  int expectedSize) throws Exception {
    try (InputStream inStream=getFileSystem().open(file)){
      assertDataInStream(inStream,expectedSize);
    }
   }
  /** 
 * Checks that the data in the current temporary upload blob is what I'd expect.
 * @param expectedSize The expected size of the data in there.
 */
  private void assertDataInTempBlob(  int expectedSize) throws Exception {
    InMemoryBlockBlobStore backingStore=getTestAccount().getMockStorage().getBackingStore();
    String tempKey=null;
    for (    String key : backingStore.getKeys()) {
      if (key.contains(NativeAzureFileSystem.AZURE_TEMP_FOLDER)) {
        tempKey=key;
        break;
      }
    }
    assertNotNull(tempKey);
    try (InputStream inStream=new ByteArrayInputStream(backingStore.getContent(tempKey))){
      assertDataInStream(inStream,expectedSize);
    }
   }
  /** 
 * Tests the given scenario for uploading a file while flushing periodically and making sure the data is always consistent with what I'd expect.
 * @param variation The variation/scenario to test.
 */
  private void testConsistencyAfterManyFlushes(  FlushFrequencyVariation variation) throws Exception {
    Path uploadedFile=methodPath();
    try {
      OutputStream outStream=getFileSystem().create(uploadedFile);
      final int totalSize=9123;
      int flushPeriod;
switch (variation) {
case BeforeSingleBufferFull:
        flushPeriod=300;
      break;
case AfterSingleBufferFull:
    flushPeriod=600;
  break;
case AfterAllRingBufferFull:
flushPeriod=1600;
break;
default :
throw new IllegalArgumentException("Unknown variation: " + variation);
}
for (int i=0; i < totalSize; i++) {
outStream.write(i % byteValuePeriod);
if ((i + 1) % flushPeriod == 0) {
outStream.flush();
assertDataInTempBlob(i + 1);
}
}
outStream.close();
assertDataInFile(uploadedFile,totalSize);
}
  finally {
getFileSystem().delete(uploadedFile,false);
}
}
}
