public class TestIPCLoggerChannel {
  private static final Log LOG=LogFactory.getLog(TestIPCLoggerChannel.class);
  private final Configuration conf=new Configuration();
  private static final NamespaceInfo FAKE_NSINFO=new NamespaceInfo(12345,"mycluster","my-bp",0L);
  private static final String JID="test-journalid";
  private static final InetSocketAddress FAKE_ADDR=new InetSocketAddress(0);
  private static final byte[] FAKE_DATA=new byte[4096];
  private final QJournalProtocol mockProxy=Mockito.mock(QJournalProtocol.class);
  private IPCLoggerChannel ch;
  private static final int LIMIT_QUEUE_SIZE_MB=1;
  private static final int LIMIT_QUEUE_SIZE_BYTES=LIMIT_QUEUE_SIZE_MB * 1024 * 1024;
  @Before public void setupMock(){
    conf.setInt(DFSConfigKeys.DFS_QJOURNAL_QUEUE_SIZE_LIMIT_KEY,LIMIT_QUEUE_SIZE_MB);
    ch=new IPCLoggerChannel(conf,FAKE_NSINFO,JID,FAKE_ADDR){
      @Override protected QJournalProtocol getProxy() throws IOException {
        return mockProxy;
      }
    }
;
    ch.setEpoch(1);
  }
  @Test public void testSimpleCall() throws Exception {
    ch.sendEdits(1,1,3,FAKE_DATA).get();
    Mockito.verify(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(3),Mockito.same(FAKE_DATA));
  }
  /** 
 * Test that, once the queue eclipses the configure size limit, calls to journal more data are rejected.
 */
  @Test public void testQueueLimiting() throws Exception {
    DelayAnswer delayer=new DelayAnswer(LOG);
    Mockito.doAnswer(delayer).when(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
    int numToQueue=LIMIT_QUEUE_SIZE_BYTES / FAKE_DATA.length;
    for (int i=1; i <= numToQueue; i++) {
      ch.sendEdits(1L,(long)i,1,FAKE_DATA);
    }
    assertEquals(LIMIT_QUEUE_SIZE_BYTES,ch.getQueuedEditsSize());
    try {
      ch.sendEdits(1L,numToQueue + 1,1,FAKE_DATA).get(1,TimeUnit.SECONDS);
      fail("Did not fail to queue more calls after queue was full");
    }
 catch (    ExecutionException ee) {
      if (!(ee.getCause() instanceof LoggerTooFarBehindException)) {
        throw ee;
      }
    }
    delayer.proceed();
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return ch.getQueuedEditsSize() == 0;
      }
    }
,10,1000);
  }
  /** 
 * Test that, if the remote node gets unsynchronized (eg some edits were missed or the node rebooted), the client stops sending edits until the next roll. Test for HDFS-3726.
 */
  @Test public void testStopSendingEditsWhenOutOfSync() throws Exception {
    Mockito.doThrow(new IOException("injected error")).when(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
    try {
      ch.sendEdits(1L,1L,1,FAKE_DATA).get();
      fail("Injected JOOSE did not cause sendEdits() to throw");
    }
 catch (    ExecutionException ee) {
      GenericTestUtils.assertExceptionContains("injected",ee);
    }
    Mockito.verify(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
    assertTrue(ch.isOutOfSync());
    try {
      ch.sendEdits(1L,2L,1,FAKE_DATA).get();
      fail("sendEdits() should throw until next roll");
    }
 catch (    ExecutionException ee) {
      GenericTestUtils.assertExceptionContains("disabled until next roll",ee.getCause());
    }
    Mockito.verify(mockProxy,Mockito.never()).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(2L),Mockito.eq(1),Mockito.same(FAKE_DATA));
    Mockito.verify(mockProxy).heartbeat(Mockito.<RequestInfo>any());
    ch.startLogSegment(3L,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION).get();
    assertFalse(ch.isOutOfSync());
    ch.sendEdits(3L,3L,1,FAKE_DATA).get();
  }
}
