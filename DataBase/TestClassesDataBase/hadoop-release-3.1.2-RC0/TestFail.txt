/** 
 * Tests the state machine with respect to Job/Task/TaskAttempt failure  scenarios.
 */
@SuppressWarnings("unchecked") public class TestFail {
  @Test public void testFailTask() throws Exception {
    MRApp app=new MockFirstFailingAttemptMRApp(1,0);
    Configuration conf=new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,false);
    Job job=app.submit(conf);
    app.waitForState(job,JobState.SUCCEEDED);
    Map<TaskId,Task> tasks=job.getTasks();
    Assert.assertEquals("Num tasks is not correct",1,tasks.size());
    Task task=tasks.values().iterator().next();
    Assert.assertEquals("Task state not correct",TaskState.SUCCEEDED,task.getReport().getTaskState());
    Map<TaskAttemptId,TaskAttempt> attempts=tasks.values().iterator().next().getAttempts();
    Assert.assertEquals("Num attempts is not correct",2,attempts.size());
    Iterator<TaskAttempt> it=attempts.values().iterator();
    Assert.assertEquals("Attempt state not correct",TaskAttemptState.FAILED,it.next().getReport().getTaskAttemptState());
    Assert.assertEquals("Attempt state not correct",TaskAttemptState.SUCCEEDED,it.next().getReport().getTaskAttemptState());
  }
  @Test public void testMapFailureMaxPercent() throws Exception {
    MRApp app=new MockFirstFailingTaskMRApp(4,0);
    Configuration conf=new Configuration();
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,2);
    conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS,1);
    conf.setInt(MRJobConfig.MAP_FAILURES_MAX_PERCENT,20);
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,1);
    Job job=app.submit(conf);
    app.waitForState(job,JobState.FAILED);
    app=new MockFirstFailingTaskMRApp(4,0);
    conf=new Configuration();
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,2);
    conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS,1);
    conf.setInt(MRJobConfig.MAP_FAILURES_MAX_PERCENT,25);
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,1);
    job=app.submit(conf);
    app.waitForState(job,JobState.SUCCEEDED);
  }
  @Test public void testReduceFailureMaxPercent() throws Exception {
    MRApp app=new MockFirstFailingTaskMRApp(2,4);
    Configuration conf=new Configuration();
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,1);
    conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS,2);
    conf.setInt(MRJobConfig.MAP_FAILURES_MAX_PERCENT,50);
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,1);
    conf.setInt(MRJobConfig.REDUCE_FAILURES_MAXPERCENT,20);
    conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS,1);
    Job job=app.submit(conf);
    app.waitForState(job,JobState.FAILED);
    app=new MockFirstFailingTaskMRApp(2,4);
    conf=new Configuration();
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,1);
    conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS,2);
    conf.setInt(MRJobConfig.MAP_FAILURES_MAX_PERCENT,50);
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,1);
    conf.setInt(MRJobConfig.REDUCE_FAILURES_MAXPERCENT,25);
    conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS,1);
    job=app.submit(conf);
    app.waitForState(job,JobState.SUCCEEDED);
  }
  @Test public void testTimedOutTask() throws Exception {
    MRApp app=new TimeOutTaskMRApp(1,0);
    Configuration conf=new Configuration();
    int maxAttempts=2;
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,maxAttempts);
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,false);
    Job job=app.submit(conf);
    app.waitForState(job,JobState.FAILED);
    Map<TaskId,Task> tasks=job.getTasks();
    Assert.assertEquals("Num tasks is not correct",1,tasks.size());
    Task task=tasks.values().iterator().next();
    Assert.assertEquals("Task state not correct",TaskState.FAILED,task.getReport().getTaskState());
    Map<TaskAttemptId,TaskAttempt> attempts=tasks.values().iterator().next().getAttempts();
    Assert.assertEquals("Num attempts is not correct",maxAttempts,attempts.size());
    for (    TaskAttempt attempt : attempts.values()) {
      Assert.assertEquals("Attempt state not correct",TaskAttemptState.FAILED,attempt.getReport().getTaskAttemptState());
    }
  }
  @Test public void testTaskFailWithUnusedContainer() throws Exception {
    MRApp app=new MRAppWithFailingTaskAndUnusedContainer();
    Configuration conf=new Configuration();
    int maxAttempts=1;
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,maxAttempts);
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,false);
    Job job=app.submit(conf);
    app.waitForState(job,JobState.RUNNING);
    Map<TaskId,Task> tasks=job.getTasks();
    Assert.assertEquals("Num tasks is not correct",1,tasks.size());
    Task task=tasks.values().iterator().next();
    app.waitForState(task,TaskState.SCHEDULED);
    Map<TaskAttemptId,TaskAttempt> attempts=tasks.values().iterator().next().getAttempts();
    Assert.assertEquals("Num attempts is not correct",maxAttempts,attempts.size());
    TaskAttempt attempt=attempts.values().iterator().next();
    app.waitForInternalState((TaskAttemptImpl)attempt,TaskAttemptStateInternal.ASSIGNED);
    app.getDispatcher().getEventHandler().handle(new TaskAttemptEvent(attempt.getID(),TaskAttemptEventType.TA_CONTAINER_COMPLETED));
    app.waitForState(job,JobState.FAILED);
  }
static class MRAppWithFailingTaskAndUnusedContainer extends MRApp {
    public MRAppWithFailingTaskAndUnusedContainer(){
      super(1,0,false,"TaskFailWithUnsedContainer",true);
    }
    @Override protected ContainerLauncher createContainerLauncher(    AppContext context){
      return new ContainerLauncherImpl(context){
        @Override public void handle(        ContainerLauncherEvent event){
switch (event.getType()) {
case CONTAINER_REMOTE_LAUNCH:
            super.handle(event);
          break;
case CONTAINER_REMOTE_CLEANUP:
        getContext().getEventHandler().handle(new TaskAttemptEvent(event.getTaskAttemptID(),TaskAttemptEventType.TA_CONTAINER_CLEANED));
      break;
case CONTAINER_COMPLETED:
    super.handle(event);
}
}
@Override public ContainerManagementProtocolProxyData getCMProxy(String containerMgrBindAddr,ContainerId containerId) throws IOException {
try {
synchronized (this) {
    wait();
  }
}
 catch (InterruptedException e) {
  e.printStackTrace();
}
return null;
}
}
;
}
}
static class TimeOutTaskMRApp extends MRApp {
TimeOutTaskMRApp(int maps,int reduces){
super(maps,reduces,false,"TimeOutTaskMRApp",true);
}
@Override protected TaskAttemptListener createTaskAttemptListener(AppContext context,AMPreemptionPolicy policy){
return new TaskAttemptListenerImpl(getContext(),null,null,policy){
@Override public void startRpcServer(){
}
@Override public void stopRpcServer(){
}
@Override public InetSocketAddress getAddress(){
return NetUtils.createSocketAddr("localhost",1234);
}
protected void serviceInit(Configuration conf) throws Exception {
conf.setInt(MRJobConfig.TASK_TIMEOUT,1 * 1000);
conf.setInt(MRJobConfig.TASK_TIMEOUT_CHECK_INTERVAL_MS,1 * 1000);
super.serviceInit(conf);
}
}
;
}
}
static class MockFirstFailingTaskMRApp extends MRApp {
MockFirstFailingTaskMRApp(int maps,int reduces){
super(maps,reduces,true,"MockFirstFailingTaskMRApp",true);
}
@Override protected void attemptLaunched(TaskAttemptId attemptID){
if (attemptID.getTaskId().getId() == 0) {
getContext().getEventHandler().handle(new TaskAttemptFailEvent(attemptID));
}
 else {
getContext().getEventHandler().handle(new TaskAttemptEvent(attemptID,TaskAttemptEventType.TA_DONE));
}
}
}
static class MockFirstFailingAttemptMRApp extends MRApp {
MockFirstFailingAttemptMRApp(int maps,int reduces){
super(maps,reduces,true,"MockFirstFailingAttemptMRApp",true);
}
@Override protected void attemptLaunched(TaskAttemptId attemptID){
if (attemptID.getTaskId().getId() == 0 && attemptID.getId() == 0) {
getContext().getEventHandler().handle(new TaskAttemptFailEvent(attemptID));
}
 else {
getContext().getEventHandler().handle(new TaskAttemptEvent(attemptID,TaskAttemptEventType.TA_DONE));
}
}
}
public static void main(String[] args) throws Exception {
TestFail t=new TestFail();
t.testFailTask();
t.testTimedOutTask();
t.testMapFailureMaxPercent();
t.testReduceFailureMaxPercent();
t.testTaskFailWithUnusedContainer();
}
}
