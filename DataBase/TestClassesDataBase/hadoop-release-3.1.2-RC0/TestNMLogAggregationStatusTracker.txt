/** 
 * Function test for  {@link NMLogAggregationStatusTracker}.
 */
public class TestNMLogAggregationStatusTracker {
  @SuppressWarnings("resource") @Test public void testNMLogAggregationStatusUpdate(){
    long baseTime=System.currentTimeMillis();
    Context mockContext=mock(Context.class);
    ConcurrentMap<ApplicationId,Application> apps=new ConcurrentHashMap<>();
    ApplicationId appId1=ApplicationId.newInstance(System.currentTimeMillis(),1);
    apps.putIfAbsent(appId1,mock(Application.class));
    when(mockContext.getApplications()).thenReturn(apps);
    Configuration conf=new YarnConfiguration();
    conf.setBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,false);
    when(mockContext.getConf()).thenReturn(conf);
    NMLogAggregationStatusTracker tracker=new NMLogAggregationStatusTracker(mockContext);
    ApplicationId appId0=ApplicationId.newInstance(0,0);
    tracker.updateLogAggregationStatus(appId0,LogAggregationStatus.RUNNING,System.currentTimeMillis(),"",false);
    List<LogAggregationReport> reports=tracker.pullCachedLogAggregationReports();
    Assert.assertTrue("No cached log aggregation status because " + "log aggregation is disabled.",reports.isEmpty());
    conf.setBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,true);
    when(mockContext.getConf()).thenReturn(conf);
    tracker=new NMLogAggregationStatusTracker(mockContext);
    appId0=ApplicationId.newInstance(0,0);
    tracker.updateLogAggregationStatus(appId0,LogAggregationStatus.RUNNING,baseTime,"",false);
    reports=tracker.pullCachedLogAggregationReports();
    Assert.assertTrue("No cached log aggregation status " + "because the application is finished or not existed.",reports.isEmpty());
    tracker.updateLogAggregationStatus(appId1,LogAggregationStatus.RUNNING,baseTime,"",false);
    reports=tracker.pullCachedLogAggregationReports();
    Assert.assertEquals("Should have one cached log aggregation status.",1,reports.size());
    Assert.assertEquals("The cached log aggregation status should be RUNNING.",LogAggregationStatus.RUNNING,reports.get(0).getLogAggregationStatus());
    tracker.updateLogAggregationStatus(appId1,LogAggregationStatus.SUCCEEDED,baseTime + 60 * 1000,"",true);
    reports=tracker.pullCachedLogAggregationReports();
    Assert.assertEquals(1,reports.size());
    Assert.assertEquals("Update cached log aggregation status to SUCCEEDED",LogAggregationStatus.SUCCEEDED,reports.get(0).getLogAggregationStatus());
    tracker.updateLogAggregationStatus(appId1,LogAggregationStatus.FAILED,baseTime + 10 * 60 * 1000,"",true);
    reports=tracker.pullCachedLogAggregationReports();
    Assert.assertEquals(1,reports.size());
    Assert.assertEquals("The cached log aggregation status " + "should be still SUCCEEDED.",LogAggregationStatus.SUCCEEDED,reports.get(0).getLogAggregationStatus());
  }
  public void testLogAggregationStatusRoller() throws Exception {
    Context mockContext=mock(Context.class);
    Configuration conf=new YarnConfiguration();
    conf.setLong(YarnConfiguration.LOG_AGGREGATION_STATUS_TIME_OUT_MS,10 * 1000);
    when(mockContext.getConf()).thenReturn(conf);
    ConcurrentMap<ApplicationId,Application> apps=new ConcurrentHashMap<>();
    ApplicationId appId1=ApplicationId.newInstance(System.currentTimeMillis(),1);
    apps.putIfAbsent(appId1,mock(Application.class));
    when(mockContext.getApplications()).thenReturn(apps);
    final NMLogAggregationStatusTracker tracker=new NMLogAggregationStatusTracker(mockContext);
    tracker.updateLogAggregationStatus(appId1,LogAggregationStatus.RUNNING,System.currentTimeMillis(),"",false);
    List<LogAggregationReport> reports=tracker.pullCachedLogAggregationReports();
    Assert.assertEquals("Should have one cached log aggregation status.",1,reports.size());
    Assert.assertEquals("The cached log aggregation status should be RUNNING.",LogAggregationStatus.RUNNING,reports.get(0).getLogAggregationStatus());
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        List<LogAggregationReport> reports=tracker.pullCachedLogAggregationReports();
        return reports.size() == 0;
      }
    }
,2000,10000);
  }
}
