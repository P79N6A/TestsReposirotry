/** 
 * Test cases that validate S3Guard's behavior for writing things like directory listings back to the MetadataStore.
 */
public class ITestS3GuardWriteBack extends AbstractS3ATestBase {
  /** 
 * In listStatus(), when S3Guard is enabled, the full listing for a directory is "written back" to the MetadataStore before the listing is returned.  Currently this "write back" behavior occurs when fs.s3a.metadatastore.authoritative is true.  This test validates this behavior.
 * @throws Exception on failure
 */
  @Test public void testListStatusWriteBack() throws Exception {
    Assume.assumeTrue(getFileSystem().hasMetadataStore());
    Path directory=path("ListStatusWriteBack");
    S3AFileSystem noS3Guard=createTestFS(directory.toUri(),true,false);
    S3AFileSystem noWriteBack=createTestFS(directory.toUri(),false,false);
    S3AFileSystem yesWriteBack=createTestFS(directory.toUri(),false,true);
    noS3Guard.delete(directory,true);
    noS3Guard.mkdirs(new Path(directory,"OnS3"));
    Path p=new Path(directory,"OnS3AndMS");
    ContractTestUtils.assertPathDoesNotExist(noWriteBack,"path",p);
    noWriteBack.mkdirs(p);
    FileStatus[] fsResults;
    DirListingMetadata mdResults;
    fsResults=noWriteBack.listStatus(directory);
    assertEquals("Filesystem enabled S3Guard without write back should have " + "both /OnS3 and /OnS3AndMS: " + Arrays.toString(fsResults),2,fsResults.length);
    mdResults=noWriteBack.getMetadataStore().listChildren(directory);
    assertEquals("Metadata store without write back should still only know " + "about /OnS3AndMS, but it has: " + mdResults,1,mdResults.numEntries());
    fsResults=yesWriteBack.listStatus(directory);
    assertEquals("Filesystem enabled S3Guard with write back should have" + " both /OnS3 and /OnS3AndMS: " + Arrays.toString(fsResults),2,fsResults.length);
    mdResults=yesWriteBack.getMetadataStore().listChildren(directory);
    assertEquals("Unexpected number of results from metadata store. " + "Should have /OnS3 and /OnS3AndMS: " + mdResults,2,mdResults.numEntries());
    getFileSystem().getMetadataStore().forgetMetadata(new Path(directory,"OnS3"));
  }
  /** 
 * Create a separate S3AFileSystem instance for testing. There's a bit of complexity as it forces pushes up s3guard options from the base values to the per-bucket options. This stops explicit bucket settings in test XML configs from unintentionally breaking tests.
 */
  private S3AFileSystem createTestFS(  URI fsURI,  boolean disableS3Guard,  boolean authoritativeMeta) throws IOException {
    Configuration conf;
    conf=createConfiguration();
    S3ATestUtils.disableFilesystemCaching(conf);
    String host=fsURI.getHost();
    if (disableS3Guard) {
      conf.set(Constants.S3_METADATA_STORE_IMPL,Constants.S3GUARD_METASTORE_NULL);
      S3AUtils.setBucketOption(conf,host,S3_METADATA_STORE_IMPL,S3GUARD_METASTORE_NULL);
    }
 else {
      S3ATestUtils.maybeEnableS3Guard(conf);
      conf.setBoolean(METADATASTORE_AUTHORITATIVE,authoritativeMeta);
      S3AUtils.setBucketOption(conf,host,METADATASTORE_AUTHORITATIVE,Boolean.toString(authoritativeMeta));
      S3AUtils.setBucketOption(conf,host,S3_METADATA_STORE_IMPL,conf.get(S3_METADATA_STORE_IMPL));
    }
    FileSystem fs=FileSystem.get(fsURI,conf);
    return asS3AFS(fs);
  }
  private static S3AFileSystem asS3AFS(  FileSystem fs){
    assertTrue("Not a S3AFileSystem: " + fs,fs instanceof S3AFileSystem);
    return (S3AFileSystem)fs;
  }
}
