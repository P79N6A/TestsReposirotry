public class TestContainerResourceUsage {
  private YarnConfiguration conf;
  @Before public void setup() throws UnknownHostException {
    Logger rootLogger=LogManager.getRootLogger();
    rootLogger.setLevel(Level.DEBUG);
    conf=new YarnConfiguration();
    UserGroupInformation.setConfiguration(conf);
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,YarnConfiguration.DEFAULT_RM_AM_MAX_ATTEMPTS);
  }
  @After public void tearDown(){
  }
  @Test(timeout=120000) public void testUsageWithOneAttemptAndOneContainer() throws Exception {
    MockRM rm=new MockRM(conf);
    rm.start();
    MockNM nm=new MockNM("127.0.0.1:1234",15120,rm.getResourceTrackerService());
    nm.registerNode();
    RMApp app0=rm.submitApp(200);
    RMAppMetrics rmAppMetrics=app0.getRMAppMetrics();
    Assert.assertTrue("Before app submittion, memory seconds should have been 0 but was " + rmAppMetrics.getMemorySeconds(),rmAppMetrics.getMemorySeconds() == 0);
    Assert.assertTrue("Before app submission, vcore seconds should have been 0 but was " + rmAppMetrics.getVcoreSeconds(),rmAppMetrics.getVcoreSeconds() == 0);
    RMAppAttempt attempt0=app0.getCurrentAppAttempt();
    nm.nodeHeartbeat(true);
    MockAM am0=rm.sendAMLaunched(attempt0.getAppAttemptId());
    am0.registerAppAttempt();
    RMContainer rmContainer=rm.getResourceScheduler().getRMContainer(attempt0.getMasterContainer().getId());
    int sleepInterval=1000;
    int cumulativeSleepTime=0;
    while (rmAppMetrics.getMemorySeconds() <= 0 && cumulativeSleepTime < 5000) {
      Thread.sleep(sleepInterval);
      cumulativeSleepTime+=sleepInterval;
    }
    rmAppMetrics=app0.getRMAppMetrics();
    Assert.assertTrue("While app is running, memory seconds should be >0 but is " + rmAppMetrics.getMemorySeconds(),rmAppMetrics.getMemorySeconds() > 0);
    Assert.assertTrue("While app is running, vcore seconds should be >0 but is " + rmAppMetrics.getVcoreSeconds(),rmAppMetrics.getVcoreSeconds() > 0);
    MockRM.finishAMAndVerifyAppState(app0,rm,nm,am0);
    AggregateAppResourceUsage ru=calculateContainerResourceMetrics(rmContainer);
    rmAppMetrics=app0.getRMAppMetrics();
    Assert.assertEquals("Unexpected MemorySeconds value",ru.getMemorySeconds(),rmAppMetrics.getMemorySeconds());
    Assert.assertEquals("Unexpected VcoreSeconds value",ru.getVcoreSeconds(),rmAppMetrics.getVcoreSeconds());
    rm.stop();
  }
  @Test(timeout=120000) public void testUsageWithMultipleContainersAndRMRestart() throws Exception {
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,1);
    conf.setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
    conf.setBoolean(YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_ENABLED,false);
    conf.set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    MockRM rm0=new MockRM(conf);
    rm0.start();
    MockMemoryRMStateStore memStore=(MockMemoryRMStateStore)rm0.getRMStateStore();
    MockNM nm=new MockNM("127.0.0.1:1234",65536,rm0.getResourceTrackerService());
    nm.registerNode();
    RMApp app0=rm0.submitApp(200);
    rm0.waitForState(app0.getApplicationId(),RMAppState.ACCEPTED);
    RMAppAttempt attempt0=app0.getCurrentAppAttempt();
    ApplicationAttemptId attemptId0=attempt0.getAppAttemptId();
    rm0.waitForState(attemptId0,RMAppAttemptState.SCHEDULED);
    nm.nodeHeartbeat(true);
    rm0.waitForState(attemptId0,RMAppAttemptState.ALLOCATED);
    MockAM am0=rm0.sendAMLaunched(attempt0.getAppAttemptId());
    am0.registerAppAttempt();
    int NUM_CONTAINERS=2;
    am0.allocate("127.0.0.1",1000,NUM_CONTAINERS,new ArrayList<ContainerId>());
    nm.nodeHeartbeat(true);
    List<Container> conts=am0.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
    while (conts.size() != NUM_CONTAINERS) {
      nm.nodeHeartbeat(true);
      conts.addAll(am0.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers());
      Thread.sleep(500);
    }
    for (    Container c : conts) {
      nm.nodeHeartbeat(attempt0.getAppAttemptId(),c.getId().getContainerId(),ContainerState.RUNNING);
      rm0.waitForState(nm,c.getId(),RMContainerState.RUNNING);
    }
    Collection<RMContainer> rmContainers=rm0.scheduler.getSchedulerAppInfo(attempt0.getAppAttemptId()).getLiveContainers();
    int sleepInterval=1000;
    int cumulativeSleepTime=0;
    while (app0.getRMAppMetrics().getMemorySeconds() <= 0 && cumulativeSleepTime < 5000) {
      Thread.sleep(sleepInterval);
      cumulativeSleepTime+=sleepInterval;
    }
    for (    Container c : conts) {
      if (c.getId().getContainerId() == 1)       continue;
      nm.nodeHeartbeat(attempt0.getAppAttemptId(),c.getId().getContainerId(),ContainerState.COMPLETE);
      rm0.waitForState(nm,c.getId(),RMContainerState.COMPLETED);
    }
    ContainerId cId=ContainerId.newContainerId(attempt0.getAppAttemptId(),1);
    nm.nodeHeartbeat(attempt0.getAppAttemptId(),cId.getContainerId(),ContainerState.COMPLETE);
    rm0.waitForState(nm,cId,RMContainerState.COMPLETED);
    long memorySeconds=0;
    long vcoreSeconds=0;
    for (    RMContainer c : rmContainers) {
      AggregateAppResourceUsage ru=calculateContainerResourceMetrics(c);
      memorySeconds+=ru.getMemorySeconds();
      vcoreSeconds+=ru.getVcoreSeconds();
    }
    RMAppMetrics metricsBefore=app0.getRMAppMetrics();
    Assert.assertEquals("Unexpected MemorySeconds value",memorySeconds,metricsBefore.getMemorySeconds());
    Assert.assertEquals("Unexpected VcoreSeconds value",vcoreSeconds,metricsBefore.getVcoreSeconds());
    MockRM rm1=new MockRM(conf,memStore);
    rm1.start();
    RMApp app0After=rm1.getRMContext().getRMApps().get(app0.getApplicationId());
    RMAppMetrics metricsAfter=app0After.getRMAppMetrics();
    Assert.assertEquals("Vcore seconds were not the same after RM Restart",metricsBefore.getVcoreSeconds(),metricsAfter.getVcoreSeconds());
    Assert.assertEquals("Memory seconds were not the same after RM Restart",metricsBefore.getMemorySeconds(),metricsAfter.getMemorySeconds());
    rm0.stop();
    rm0.close();
    rm1.stop();
    rm1.close();
  }
  @Test(timeout=60000) public void testUsageAfterAMRestartWithMultipleContainers() throws Exception {
    amRestartTests(false);
  }
  @Test(timeout=60000) public void testUsageAfterAMRestartKeepContainers() throws Exception {
    amRestartTests(true);
  }
  private void amRestartTests(  boolean keepRunningContainers) throws Exception {
    MockRM rm=new MockRM(conf);
    rm.start();
    RMApp app=rm.submitApp(200,"name","user",new HashMap<ApplicationAccessType,String>(),false,"default",-1,null,"MAPREDUCE",false,keepRunningContainers);
    MockNM nm=new MockNM("127.0.0.1:1234",10240,rm.getResourceTrackerService());
    nm.registerNode();
    MockAM am0=MockRM.launchAndRegisterAM(app,rm,nm);
    int NUM_CONTAINERS=1;
    am0.allocate("127.0.0.1",1024,NUM_CONTAINERS,new ArrayList<ContainerId>());
    nm.nodeHeartbeat(true);
    List<Container> containers=am0.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
    while (containers.size() != NUM_CONTAINERS) {
      nm.nodeHeartbeat(true);
      containers.addAll(am0.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers());
      Thread.sleep(200);
    }
    ContainerId containerId2=ContainerId.newContainerId(am0.getApplicationAttemptId(),2);
    nm.nodeHeartbeat(am0.getApplicationAttemptId(),containerId2.getContainerId(),ContainerState.RUNNING);
    rm.waitForState(nm,containerId2,RMContainerState.RUNNING);
    Collection<RMContainer> rmContainers=rm.scheduler.getSchedulerAppInfo(am0.getApplicationAttemptId()).getLiveContainers();
    ContainerId amContainerId=app.getCurrentAppAttempt().getMasterContainer().getId();
    nm.nodeHeartbeat(am0.getApplicationAttemptId(),amContainerId.getContainerId(),ContainerState.COMPLETE);
    rm.waitForState(am0.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm.drainEvents();
    long memorySeconds=0;
    long vcoreSeconds=0;
    if (keepRunningContainers) {
      for (      RMContainer c : rmContainers) {
        if (c.getContainerId().equals(amContainerId)) {
          AggregateAppResourceUsage ru=calculateContainerResourceMetrics(c);
          memorySeconds+=ru.getMemorySeconds();
          vcoreSeconds+=ru.getVcoreSeconds();
        }
 else {
          Assert.assertTrue("After first attempt failed, remaining container " + "should still be running. ",c.getContainerState().equals(ContainerState.RUNNING));
        }
      }
    }
 else {
      for (      RMContainer c : rmContainers) {
        waitforContainerCompletion(rm,nm,amContainerId,c);
        AggregateAppResourceUsage ru=calculateContainerResourceMetrics(c);
        memorySeconds+=ru.getMemorySeconds();
        vcoreSeconds+=ru.getVcoreSeconds();
      }
    }
    rm.waitForState(app.getApplicationId(),RMAppState.ACCEPTED);
    RMAppAttempt attempt2=app.getCurrentAppAttempt();
    Assert.assertFalse(attempt2.getAppAttemptId().equals(am0.getApplicationAttemptId()));
    rm.waitForState(attempt2.getAppAttemptId(),RMAppAttemptState.SCHEDULED);
    nm.nodeHeartbeat(true);
    MockAM am1=rm.sendAMLaunched(attempt2.getAppAttemptId());
    am1.registerAppAttempt();
    rm.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    am1.allocate("127.0.0.1",1024,NUM_CONTAINERS,new ArrayList<ContainerId>());
    nm.nodeHeartbeat(true);
    containers=am1.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
    while (containers.size() != NUM_CONTAINERS) {
      nm.nodeHeartbeat(true);
      containers.addAll(am1.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers());
      Thread.sleep(200);
    }
    rm.waitForState(app.getApplicationId(),RMAppState.RUNNING);
    rmContainers=rm.scheduler.getSchedulerAppInfo(attempt2.getAppAttemptId()).getLiveContainers();
    amContainerId=app.getCurrentAppAttempt().getMasterContainer().getId();
    nm.nodeHeartbeat(am0.getApplicationAttemptId(),amContainerId.getContainerId(),ContainerState.COMPLETE);
    MockRM.finishAMAndVerifyAppState(app,rm,nm,am1);
    for (    RMContainer c : rmContainers) {
      waitforContainerCompletion(rm,nm,amContainerId,c);
      AggregateAppResourceUsage ru=calculateContainerResourceMetrics(c);
      memorySeconds+=ru.getMemorySeconds();
      vcoreSeconds+=ru.getVcoreSeconds();
    }
    RMAppMetrics rmAppMetrics=app.getRMAppMetrics();
    Assert.assertEquals("Unexpected MemorySeconds value",memorySeconds,rmAppMetrics.getMemorySeconds());
    Assert.assertEquals("Unexpected VcoreSeconds value",vcoreSeconds,rmAppMetrics.getVcoreSeconds());
    rm.stop();
    return;
  }
  private void waitforContainerCompletion(  MockRM rm,  MockNM nm,  ContainerId amContainerId,  RMContainer container) throws Exception {
    ContainerId containerId=container.getContainerId();
    if (null != rm.scheduler.getRMContainer(containerId)) {
      if (containerId.equals(amContainerId)) {
        rm.waitForState(nm,containerId,RMContainerState.COMPLETED);
      }
 else {
        rm.waitForState(nm,containerId,RMContainerState.KILLED);
      }
    }
 else {
      rm.drainEvents();
    }
  }
  private AggregateAppResourceUsage calculateContainerResourceMetrics(  RMContainer rmContainer){
    Resource resource=rmContainer.getContainer().getResource();
    long usedMillis=rmContainer.getFinishTime() - rmContainer.getCreationTime();
    long memorySeconds=resource.getMemorySize() * usedMillis / DateUtils.MILLIS_PER_SECOND;
    long vcoreSeconds=resource.getVirtualCores() * usedMillis / DateUtils.MILLIS_PER_SECOND;
    Map<String,Long> map=new HashMap<>();
    map.put(ResourceInformation.MEMORY_MB.getName(),memorySeconds);
    map.put(ResourceInformation.VCORES.getName(),vcoreSeconds);
    return new AggregateAppResourceUsage(map);
  }
}
