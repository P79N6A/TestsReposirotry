static class FileWorker extends Worker {
  final Path file;
  final File localFile;
  FileWorker(  Path dir,  File localDir,  String filename) throws IOException {
    super(filename);
    this.file=new Path(dir,filename);
    this.localFile=new File(localDir,filename);
    localFile.createNewFile();
    dfs.create(file,false,4096,REPLICATION,BLOCK_SIZE).close();
  }
  @Override public String call() throws IOException {
    final int op=ThreadLocalRandom.current().nextInt(9);
    if (op == 0) {
      return checkFullFile();
    }
 else {
      final int nBlocks=ThreadLocalRandom.current().nextInt(4) + 1;
      final int lastBlockSize=ThreadLocalRandom.current().nextInt(BLOCK_SIZE) + 1;
      final int nBytes=nBlocks * BLOCK_SIZE + lastBlockSize;
      if (op <= 4) {
        return append(nBytes);
      }
 else       if (op <= 6) {
        return truncateArbitrarily(nBytes);
      }
 else {
        return truncateToBlockBoundary(nBlocks);
      }
    }
  }
  String append(  int n) throws IOException {
    final StringBuilder b=new StringBuilder("append ").append(n).append(" bytes to ").append(file.getName());
    final byte[] bytes=new byte[n];
    ThreadLocalRandom.current().nextBytes(bytes);
{
      final FileOutputStream out=new FileOutputStream(localFile,true);
      out.write(bytes,0,bytes.length);
      out.close();
    }
{
      final FSDataOutputStream out=dfs.append(file);
      out.write(bytes,0,bytes.length);
      out.close();
    }
    return b.toString();
  }
  String truncateArbitrarily(  int nBytes) throws IOException {
    Preconditions.checkArgument(nBytes > 0);
    final int length=checkLength();
    final StringBuilder b=new StringBuilder("truncateArbitrarily: ").append(nBytes).append(" bytes from ").append(file.getName()).append(", length=" + length);
    truncate(length > nBytes ? length - nBytes : 0,b);
    return b.toString();
  }
  String truncateToBlockBoundary(  int nBlocks) throws IOException {
    Preconditions.checkArgument(nBlocks > 0);
    final int length=checkLength();
    final StringBuilder b=new StringBuilder("truncateToBlockBoundary: ").append(nBlocks).append(" blocks from ").append(file.getName()).append(", length=" + length);
    final int n=(nBlocks - 1) * BLOCK_SIZE + (length % BLOCK_SIZE);
    Preconditions.checkState(truncate(length > n ? length - n : 0,b),b);
    return b.toString();
  }
  private boolean truncate(  long newLength,  StringBuilder b) throws IOException {
    final RandomAccessFile raf=new RandomAccessFile(localFile,"rw");
    raf.setLength(newLength);
    raf.close();
    final boolean isReady=dfs.truncate(file,newLength);
    b.append(", newLength=").append(newLength).append(", isReady=").append(isReady);
    if (!isReady) {
      TestFileTruncate.checkBlockRecovery(file,dfs,100,300L);
    }
    return isReady;
  }
  int checkLength() throws IOException {
    return checkLength(file,localFile);
  }
  static int checkLength(  Path file,  File localFile) throws IOException {
    final long length=dfs.getFileStatus(file).getLen();
    Assert.assertEquals(localFile.length(),length);
    Assert.assertTrue(length <= Integer.MAX_VALUE);
    return (int)length;
  }
  String checkFullFile() throws IOException {
    return checkFullFile(file,localFile);
  }
  static String checkFullFile(  Path file,  File localFile) throws IOException {
    final StringBuilder b=new StringBuilder("checkFullFile: ").append(file.getName()).append(" vs ").append(localFile);
    final byte[] bytes=new byte[checkLength(file,localFile)];
    b.append(", length=").append(bytes.length);
    final FileInputStream in=new FileInputStream(localFile);
    for (int n=0; n < bytes.length; ) {
      n+=in.read(bytes,n,bytes.length - n);
    }
    in.close();
    AppendTestUtil.checkFullFile(dfs,file,bytes.length,bytes,"File content mismatch: " + b,false);
    return b.toString();
  }
}
