public class TestClientToAMTokens extends ParameterizedSchedulerTestBase {
  private YarnConfiguration conf;
  public TestClientToAMTokens(  SchedulerType type) throws IOException {
    super(type);
  }
  @Before public void setup(){
    conf=getConf();
  }
@TokenInfo(ClientToAMTokenSelector.class) @ProtocolInfo(protocolName="org.apache.hadoop.yarn.server.resourcemanager.security$CustomProtocol",protocolVersion=1) public interface CustomProtocol extends TestRpcServiceProtos.CustomProto.BlockingInterface {
  }
private static class CustomSecurityInfo extends SecurityInfo {
    @Override public TokenInfo getTokenInfo(    Class<?> protocol,    Configuration conf){
      return new TokenInfo(){
        @Override public Class<? extends Annotation> annotationType(){
          return null;
        }
        @Override public Class<? extends TokenSelector<? extends TokenIdentifier>> value(){
          return ClientToAMTokenSelector.class;
        }
      }
;
    }
    @Override public KerberosInfo getKerberosInfo(    Class<?> protocol,    Configuration conf){
      return null;
    }
  }
private static class CustomAM extends AbstractService implements CustomProtocol {
    private final ApplicationAttemptId appAttemptId;
    private final byte[] secretKey;
    private InetSocketAddress address;
    private boolean pinged=false;
    private ClientToAMTokenSecretManager secretMgr;
    public CustomAM(    ApplicationAttemptId appId,    byte[] secretKey){
      super("CustomAM");
      this.appAttemptId=appId;
      this.secretKey=secretKey;
    }
    @Override public TestProtos.EmptyResponseProto ping(    RpcController unused,    TestProtos.EmptyRequestProto request) throws ServiceException {
      this.pinged=true;
      return TestProtos.EmptyResponseProto.newBuilder().build();
    }
    public ClientToAMTokenSecretManager getClientToAMTokenSecretManager(){
      return secretMgr;
    }
    @Override protected void serviceStart() throws Exception {
      Configuration conf=getConfig();
      RPC.setProtocolEngine(conf,CustomProtocol.class,ProtobufRpcEngine.class);
      UserGroupInformation.setConfiguration(conf);
      BlockingService service=TestRpcServiceProtos.CustomProto.newReflectiveBlockingService(this);
      Server server;
      try {
        secretMgr=new ClientToAMTokenSecretManager(this.appAttemptId,secretKey);
        server=new RPC.Builder(conf).setProtocol(CustomProtocol.class).setNumHandlers(1).setSecretManager(secretMgr).setInstance(service).build();
      }
 catch (      Exception e) {
        throw new YarnRuntimeException(e);
      }
      server.start();
      this.address=NetUtils.getConnectAddress(server);
      super.serviceStart();
    }
    public void setClientSecretKey(    byte[] key){
      secretMgr.setMasterKey(key);
    }
  }
  @Test public void testClientToAMTokens() throws Exception {
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
    RPC.setProtocolEngine(conf,CustomProtocol.class,ProtobufRpcEngine.class);
    UserGroupInformation.setConfiguration(conf);
    ContainerManagementProtocol containerManager=mock(ContainerManagementProtocol.class);
    StartContainersResponse mockResponse=mock(StartContainersResponse.class);
    when(containerManager.startContainers((StartContainersRequest)any())).thenReturn(mockResponse);
    MockRM rm=new MockRMWithCustomAMLauncher(conf,containerManager){
      protected ClientRMService createClientRMService(){
        return new ClientRMService(this.rmContext,scheduler,this.rmAppManager,this.applicationACLsManager,this.queueACLsManager,getRMContext().getRMDelegationTokenSecretManager());
      }
      @Override protected void doSecureLogin() throws IOException {
      }
    }
;
    rm.start();
    RMApp app=rm.submitApp(1024);
    MockNM nm1=rm.registerNode("localhost:1234",3072);
    nm1.nodeHeartbeat(true);
    rm.drainEvents();
    nm1.nodeHeartbeat(true);
    rm.drainEvents();
    ApplicationAttemptId appAttempt=app.getCurrentAppAttempt().getAppAttemptId();
    final MockAM mockAM=new MockAM(rm.getRMContext(),rm.getApplicationMasterService(),app.getCurrentAppAttempt().getAppAttemptId());
    UserGroupInformation appUgi=UserGroupInformation.createRemoteUser(appAttempt.toString());
    RegisterApplicationMasterResponse response=appUgi.doAs(new PrivilegedAction<RegisterApplicationMasterResponse>(){
      @Override public RegisterApplicationMasterResponse run(){
        RegisterApplicationMasterResponse response=null;
        try {
          response=mockAM.registerAppAttempt();
        }
 catch (        Exception e) {
          Assert.fail("Exception was not expected");
        }
        return response;
      }
    }
);
    GetApplicationReportRequest request=Records.newRecord(GetApplicationReportRequest.class);
    request.setApplicationId(app.getApplicationId());
    GetApplicationReportResponse reportResponse=rm.getClientRMService().getApplicationReport(request);
    ApplicationReport appReport=reportResponse.getApplicationReport();
    org.apache.hadoop.yarn.api.records.Token originalClientToAMToken=appReport.getClientToAMToken();
    Assert.assertNotNull(response.getClientToAMTokenMasterKey());
    Assert.assertTrue(response.getClientToAMTokenMasterKey().array().length > 0);
    ApplicationAttemptId appAttemptId=app.getAppAttempts().keySet().iterator().next();
    Assert.assertNotNull(appAttemptId);
    final CustomAM am=new CustomAM(appAttemptId,response.getClientToAMTokenMasterKey().array());
    am.init(conf);
    am.start();
    SecurityUtil.setSecurityInfoProviders(new CustomSecurityInfo());
    try {
      CustomProtocol client=RPC.getProxy(CustomProtocol.class,1L,am.address,conf);
      client.ping(null,TestRpcBase.newEmptyRequest());
      fail("Access by unauthenticated user should fail!!");
    }
 catch (    Exception e) {
      Assert.assertFalse(am.pinged);
    }
    Token<ClientToAMTokenIdentifier> token=ConverterUtils.convertFromYarn(originalClientToAMToken,am.address);
    verifyTokenWithTamperedID(conf,am,token);
    verifyTokenWithTamperedUserName(conf,am,token);
    verifyValidToken(conf,am,token);
    verifyNewVersionToken(conf,am,token,rm);
    am.stop();
    rm.stop();
  }
  private void verifyTokenWithTamperedID(  final Configuration conf,  final CustomAM am,  Token<ClientToAMTokenIdentifier> token) throws IOException {
    UserGroupInformation ugi=UserGroupInformation.createRemoteUser("me");
    ClientToAMTokenIdentifier maliciousID=new ClientToAMTokenIdentifier(BuilderUtils.newApplicationAttemptId(BuilderUtils.newApplicationId(am.appAttemptId.getApplicationId().getClusterTimestamp(),42),43),UserGroupInformation.getCurrentUser().getShortUserName());
    verifyTamperedToken(conf,am,token,ugi,maliciousID);
  }
  private void verifyTokenWithTamperedUserName(  final Configuration conf,  final CustomAM am,  Token<ClientToAMTokenIdentifier> token) throws IOException {
    UserGroupInformation ugi=UserGroupInformation.createRemoteUser("me");
    ClientToAMTokenIdentifier maliciousID=new ClientToAMTokenIdentifier(am.appAttemptId,"evilOrc");
    verifyTamperedToken(conf,am,token,ugi,maliciousID);
  }
  private void verifyTamperedToken(  final Configuration conf,  final CustomAM am,  Token<ClientToAMTokenIdentifier> token,  UserGroupInformation ugi,  ClientToAMTokenIdentifier maliciousID){
    Token<ClientToAMTokenIdentifier> maliciousToken=new Token<ClientToAMTokenIdentifier>(maliciousID.getBytes(),token.getPassword(),token.getKind(),token.getService());
    ugi.addToken(maliciousToken);
    try {
      ugi.doAs(new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          try {
            CustomProtocol client=RPC.getProxy(CustomProtocol.class,1L,am.address,conf);
            client.ping(null,TestRpcBase.newEmptyRequest());
            fail("Connection initiation with illegally modified " + "tokens is expected to fail.");
            return null;
          }
 catch (          ServiceException ex) {
            throw (Exception)ex.getCause();
          }
        }
      }
);
    }
 catch (    Exception e) {
      Assert.assertEquals(RemoteException.class.getName(),e.getClass().getName());
      e=((RemoteException)e).unwrapRemoteException();
      Assert.assertEquals(SaslException.class.getCanonicalName(),e.getClass().getCanonicalName());
      Assert.assertTrue(e.getMessage().contains("DIGEST-MD5: digest response format violation. " + "Mismatched response."));
      Assert.assertFalse(am.pinged);
    }
  }
  private void verifyNewVersionToken(  final Configuration conf,  final CustomAM am,  Token<ClientToAMTokenIdentifier> token,  MockRM rm) throws IOException, InterruptedException {
    UserGroupInformation ugi;
    ugi=UserGroupInformation.createRemoteUser("me");
    Token<ClientToAMTokenIdentifier> newToken=new Token<ClientToAMTokenIdentifier>(new ClientToAMTokenIdentifierForTest(token.decodeIdentifier(),"message"),am.getClientToAMTokenSecretManager());
    newToken.setService(token.getService());
    ugi.addToken(newToken);
    ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        CustomProtocol client=RPC.getProxy(CustomProtocol.class,1L,am.address,conf);
        client.ping(null,TestRpcBase.newEmptyRequest());
        Assert.assertTrue(am.pinged);
        return null;
      }
    }
);
  }
  private void verifyValidToken(  final Configuration conf,  final CustomAM am,  Token<ClientToAMTokenIdentifier> token) throws IOException, InterruptedException {
    UserGroupInformation ugi;
    ugi=UserGroupInformation.createRemoteUser("me");
    ugi.addToken(token);
    ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        CustomProtocol client=RPC.getProxy(CustomProtocol.class,1L,am.address,conf);
        client.ping(null,TestRpcBase.newEmptyRequest());
        Assert.assertTrue(am.pinged);
        return null;
      }
    }
);
  }
  @Test(timeout=20000) public void testClientTokenRace() throws Exception {
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
    UserGroupInformation.setConfiguration(conf);
    ContainerManagementProtocol containerManager=mock(ContainerManagementProtocol.class);
    StartContainersResponse mockResponse=mock(StartContainersResponse.class);
    when(containerManager.startContainers((StartContainersRequest)any())).thenReturn(mockResponse);
    MockRM rm=new MockRMWithCustomAMLauncher(conf,containerManager){
      protected ClientRMService createClientRMService(){
        return new ClientRMService(this.rmContext,scheduler,this.rmAppManager,this.applicationACLsManager,this.queueACLsManager,getRMContext().getRMDelegationTokenSecretManager());
      }
      @Override protected void doSecureLogin() throws IOException {
      }
    }
;
    rm.start();
    RMApp app=rm.submitApp(1024);
    MockNM nm1=rm.registerNode("localhost:1234",3072);
    nm1.nodeHeartbeat(true);
    rm.drainEvents();
    nm1.nodeHeartbeat(true);
    rm.drainEvents();
    ApplicationAttemptId appAttempt=app.getCurrentAppAttempt().getAppAttemptId();
    final MockAM mockAM=new MockAM(rm.getRMContext(),rm.getApplicationMasterService(),app.getCurrentAppAttempt().getAppAttemptId());
    UserGroupInformation appUgi=UserGroupInformation.createRemoteUser(appAttempt.toString());
    RegisterApplicationMasterResponse response=appUgi.doAs(new PrivilegedAction<RegisterApplicationMasterResponse>(){
      @Override public RegisterApplicationMasterResponse run(){
        RegisterApplicationMasterResponse response=null;
        try {
          response=mockAM.registerAppAttempt();
        }
 catch (        Exception e) {
          Assert.fail("Exception was not expected");
        }
        return response;
      }
    }
);
    GetApplicationReportRequest request=Records.newRecord(GetApplicationReportRequest.class);
    request.setApplicationId(app.getApplicationId());
    GetApplicationReportResponse reportResponse=rm.getClientRMService().getApplicationReport(request);
    ApplicationReport appReport=reportResponse.getApplicationReport();
    org.apache.hadoop.yarn.api.records.Token originalClientToAMToken=appReport.getClientToAMToken();
    final ByteBuffer clientMasterKey=response.getClientToAMTokenMasterKey();
    Assert.assertNotNull(clientMasterKey);
    Assert.assertTrue(clientMasterKey.array().length > 0);
    ApplicationAttemptId appAttemptId=app.getAppAttempts().keySet().iterator().next();
    Assert.assertNotNull(appAttemptId);
    final CustomAM am=new CustomAM(appAttemptId,null);
    am.init(conf);
    am.start();
    SecurityUtil.setSecurityInfoProviders(new CustomSecurityInfo());
    Token<ClientToAMTokenIdentifier> token=ConverterUtils.convertFromYarn(originalClientToAMToken,am.address);
    Timer timer=new Timer();
    TimerTask timerTask=new TimerTask(){
      @Override public void run(){
        am.setClientSecretKey(clientMasterKey.array());
      }
    }
;
    timer.schedule(timerTask,250);
    verifyValidToken(conf,am,token);
    am.stop();
    rm.stop();
  }
}
