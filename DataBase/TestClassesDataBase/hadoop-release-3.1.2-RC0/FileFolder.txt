private class FileFolder {
  private String name;
  private boolean present;
  ArrayList<FileFolder> members;
  public FileFolder(  String name){
    this.name=name;
    this.present=true;
    members=new ArrayList<FileFolder>();
  }
  public FileFolder getMember(  int i){
    return members.get(i);
  }
  public void verifyGone() throws IllegalArgumentException, IOException {
    assertFalse(fs.exists(new Path(name)));
    assertTrue(isFolder());
    verifyGone(new Path(name),members);
  }
  private void verifyGone(  Path prefix,  ArrayList<FileFolder> members2) throws IOException {
    for (    FileFolder f : members2) {
      f.verifyGone(prefix);
    }
  }
  private void verifyGone(  Path prefix) throws IOException {
    assertFalse(fs.exists(new Path(prefix,name)));
    if (isLeaf()) {
      return;
    }
    for (    FileFolder f : members) {
      f.verifyGone(new Path(prefix,name));
    }
  }
  public void verifyExists() throws IllegalArgumentException, IOException {
    assertTrue(fs.exists(new Path(name)));
    assertTrue(isFolder());
    verifyExists(new Path(name),members);
  }
  private void verifyExists(  Path prefix,  ArrayList<FileFolder> members2) throws IOException {
    for (    FileFolder f : members2) {
      f.verifyExists(prefix);
    }
  }
  private void verifyExists(  Path prefix) throws IOException {
    assertTrue(fs.exists(new Path(prefix,name)));
    if (isLeaf()) {
      return;
    }
    for (    FileFolder f : members) {
      f.verifyExists(new Path(prefix,name));
    }
  }
  public boolean exists() throws IOException {
    return fs.exists(new Path(name));
  }
  public void makeRenamePending(  FileFolder dst) throws IOException {
    Path home=fs.getHomeDirectory();
    String relativeHomeDir=getRelativePath(home.toString());
    NativeAzureFileSystem.FolderRenamePending pending=new NativeAzureFileSystem.FolderRenamePending(relativeHomeDir + "/" + this.getName(),relativeHomeDir + "/" + dst.getName(),null,(NativeAzureFileSystem)fs);
    String renameDescription=pending.makeRenamePendingFileContents();
    final String renamePendingStr=this.getName() + "-RenamePending.json";
    Path renamePendingFile=new Path(renamePendingStr);
    FSDataOutputStream out=fs.create(renamePendingFile,true);
    assertTrue(out != null);
    writeString(out,renameDescription);
  }
  public void setPresent(  int i,  boolean b){
    members.get(i).setPresent(b);
  }
  private FileFolder(){
    this.present=true;
  }
  public void setPresent(  boolean value){
    present=value;
  }
  public FileFolder makeLeaf(  String name){
    FileFolder f=new FileFolder();
    f.setName(name);
    return f;
  }
  void setName(  String name){
    this.name=name;
  }
  public String getName(){
    return name;
  }
  public boolean isLeaf(){
    return members == null;
  }
  public boolean isFolder(){
    return members != null;
  }
  FileFolder add(  FileFolder folder){
    members.add(folder);
    return this;
  }
  FileFolder add(  String file){
    FileFolder leaf=makeLeaf(file);
    members.add(leaf);
    return this;
  }
  public FileFolder copy(){
    if (isLeaf()) {
      return makeLeaf(name);
    }
 else {
      FileFolder f=new FileFolder(name);
      for (      FileFolder member : members) {
        f.add(member.copy());
      }
      return f;
    }
  }
  public void create() throws IllegalArgumentException, IOException {
    create(null);
  }
  private void create(  Path prefix) throws IllegalArgumentException, IOException {
    if (isFolder()) {
      if (present) {
        assertTrue(fs.mkdirs(makePath(prefix,name)));
      }
      create(makePath(prefix,name),members);
    }
 else     if (isLeaf()) {
      if (present) {
        assertTrue(fs.createNewFile(makePath(prefix,name)));
      }
    }
 else {
      assertTrue("The object must be a (leaf) file or a folder.",false);
    }
  }
  private void create(  Path prefix,  ArrayList<FileFolder> members2) throws IllegalArgumentException, IOException {
    for (    FileFolder f : members2) {
      f.create(prefix);
    }
  }
  private Path makePath(  Path prefix,  String name){
    if (prefix == null) {
      return new Path(name);
    }
 else {
      return new Path(prefix,name);
    }
  }
  public void prune() throws IOException {
    prune(null);
  }
  private void prune(  Path prefix) throws IOException {
    Path path=null;
    if (prefix == null) {
      path=new Path(name);
    }
 else {
      path=new Path(prefix,name);
    }
    if (isLeaf() && !present) {
      assertTrue(fs.delete(path,false));
    }
 else     if (isFolder() && !present) {
      assertTrue(fs.delete(path,true));
    }
 else     if (isFolder()) {
      for (      FileFolder f : members) {
        f.prune(path);
      }
    }
  }
}
