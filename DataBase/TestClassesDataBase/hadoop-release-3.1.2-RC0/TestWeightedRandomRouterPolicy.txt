/** 
 * Simple test class for the  {@link WeightedRandomRouterPolicy}. Generate large number of randomized tests to check we are weighiting correctly even if clusters go inactive.
 */
public class TestWeightedRandomRouterPolicy extends BaseRouterPoliciesTest {
  @Before public void setUp() throws Exception {
    setPolicy(new WeightedRandomRouterPolicy());
    setPolicyInfo(new WeightedPolicyInfo());
    Map<SubClusterIdInfo,Float> routerWeights=new HashMap<>();
    Map<SubClusterIdInfo,Float> amrmWeights=new HashMap<>();
    float numSubClusters=20;
    for (int i=0; i < numSubClusters; i++) {
      SubClusterIdInfo sc=new SubClusterIdInfo("sc" + i);
      if (getRand().nextFloat() < 0.95f) {
        SubClusterInfo sci=mock(SubClusterInfo.class);
        when(sci.getState()).thenReturn(SubClusterState.SC_RUNNING);
        when(sci.getSubClusterId()).thenReturn(sc.toId());
        getActiveSubclusters().put(sc.toId(),sci);
      }
      float weight=(0.8f * 1f / numSubClusters) + (0.2f * getRand().nextFloat());
      if (i <= 5 || getRand().nextFloat() > 0.05f) {
        routerWeights.put(sc,weight);
        amrmWeights.put(sc,weight);
      }
    }
    getPolicyInfo().setRouterPolicyWeights(routerWeights);
    getPolicyInfo().setAMRMPolicyWeights(amrmWeights);
    FederationPoliciesTestUtil.initializePolicyContext(getPolicy(),getPolicyInfo(),getActiveSubclusters());
  }
  @Test public void testClusterChosenWithRightProbability() throws YarnException {
    ApplicationSubmissionContext context=mock(ApplicationSubmissionContext.class);
    when(context.getQueue()).thenReturn("queue1");
    setApplicationSubmissionContext(context);
    Map<SubClusterId,AtomicLong> counter=new HashMap<>();
    for (    SubClusterIdInfo id : getPolicyInfo().getRouterPolicyWeights().keySet()) {
      counter.put(id.toId(),new AtomicLong(0));
    }
    float numberOfDraws=10000;
    for (float i=0; i < numberOfDraws; i++) {
      SubClusterId chosenId=((FederationRouterPolicy)getPolicy()).getHomeSubcluster(getApplicationSubmissionContext(),null);
      counter.get(chosenId).incrementAndGet();
    }
    float totalActiveWeight=0;
    for (    SubClusterId id : getActiveSubclusters().keySet()) {
      SubClusterIdInfo idInfo=new SubClusterIdInfo(id);
      if (getPolicyInfo().getRouterPolicyWeights().containsKey(idInfo)) {
        totalActiveWeight+=getPolicyInfo().getRouterPolicyWeights().get(idInfo);
      }
    }
    for (    Map.Entry<SubClusterId,AtomicLong> counterEntry : counter.entrySet()) {
      float expectedWeight=getPolicyInfo().getRouterPolicyWeights().get(new SubClusterIdInfo(counterEntry.getKey())) / totalActiveWeight;
      float actualWeight=counterEntry.getValue().floatValue() / numberOfDraws;
      if (getActiveSubclusters().containsKey(counterEntry.getKey())) {
        Assert.assertTrue("Id " + counterEntry.getKey() + " Actual weight: "+ actualWeight+ " expected weight: "+ expectedWeight,Math.abs(actualWeight - expectedWeight) < 0.01);
      }
 else {
        Assert.assertTrue("Id " + counterEntry.getKey() + " Actual weight: "+ actualWeight+ " expected weight: "+ expectedWeight,actualWeight == 0);
      }
    }
  }
}
