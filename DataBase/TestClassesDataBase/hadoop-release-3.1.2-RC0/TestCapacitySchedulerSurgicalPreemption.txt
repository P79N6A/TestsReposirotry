public class TestCapacitySchedulerSurgicalPreemption extends CapacitySchedulerPreemptionTestBase {
  private static final int NUM_NM=5;
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    conf.setBoolean(CapacitySchedulerConfiguration.PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,true);
  }
  @Test(timeout=60000) public void testSimpleSurgicalPreemption() throws Exception {
    testSimpleSurgicalPreemption("a","c","user","user");
  }
  protected void testSimpleSurgicalPreemption(  String queue1,  String queue2,  String user1,  String user2) throws Exception {
    MockRM rm1=new MockRM(conf){
      protected RMNodeLabelsManager createNodeLabelManager(){
        return mgr;
      }
    }
;
    rm1.start();
    MockNM nm1=rm1.registerNode("h1:1234",20 * GB);
    MockNM nm2=rm1.registerNode("h2:1234",20 * GB);
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMNode rmNode1=rm1.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm1.getRMContext().getRMNodes().get(nm2.getNodeId());
    RMApp app1=rm1.submitApp(1 * GB,"app",user1,null,queue1);
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    am1.allocate("*",1 * GB,32,new ArrayList<ContainerId>());
    for (int i=0; i < 32; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(33,schedulerApp1.getLiveContainers().size());
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode1.getNodeID()),am1.getApplicationAttemptId(),17);
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode2.getNodeID()),am1.getApplicationAttemptId(),16);
    RMApp app2=rm1.submitApp(1 * GB,"app",user2,null,queue2);
    MockAM am2=MockRM.launchAndRegisterAM(app2,rm1,nm1);
    Assert.assertEquals(2 * GB,cs.getNode(nm1.getNodeId()).getUnallocatedResource().getMemorySize());
    Assert.assertEquals(4 * GB,cs.getNode(nm2.getNodeId()).getUnallocatedResource().getMemorySize());
    am2.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),ResourceRequest.ANY,Resources.createResource(6 * GB),1)),null);
    cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
    Assert.assertNotNull(cs.getNode(nm1.getNodeId()).getReservedContainer());
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,29);
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode1.getNodeID()),am1.getApplicationAttemptId(),13);
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode2.getNodeID()),am1.getApplicationAttemptId(),16);
    Assert.assertEquals("Number of preempted containers incorrectly recorded:",4,cs.getQueue("root").getMetrics().getAggregatePreemptedContainers());
    rm1.close();
  }
  @Test(timeout=60000) public void testSurgicalPreemptionWithAvailableResource() throws Exception {
    MockRM rm1=new MockRM(conf);
    rm1.getRMContext().setNodeLabelManager(mgr);
    rm1.start();
    MockNM nm1=rm1.registerNode("h1:1234",20 * GB);
    MockNM nm2=rm1.registerNode("h2:1234",20 * GB);
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMNode rmNode1=rm1.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm1.getRMContext().getRMNodes().get(nm2.getNodeId());
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"a");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    am1.allocate("*",1 * GB,38,new ArrayList<ContainerId>());
    for (int i=0; i < 38; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(39,schedulerApp1.getLiveContainers().size());
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode1.getNodeID()),am1.getApplicationAttemptId(),20);
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode2.getNodeID()),am1.getApplicationAttemptId(),19);
    RMApp app2=rm1.submitApp(4 * GB,"app","user",null,"c");
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app2.getApplicationId(),1));
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    Assert.assertEquals(3,editPolicy.getToPreemptContainers().size());
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,36);
    cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
    cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
    waitNumberOfReservedContainersFromApp(schedulerApp2,1);
    editPolicy.editSchedule();
    editPolicy.editSchedule();
    int tick=0;
    while (schedulerApp2.getLiveContainers().size() != 1 && tick < 10) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
      tick++;
      Thread.sleep(100);
    }
    waitNumberOfReservedContainersFromApp(schedulerApp2,0);
    rm1.close();
  }
  @Test(timeout=60000) public void testPriorityPreemptionWhenAllQueuesAreBelowGuaranteedCapacities() throws Exception {
    conf.setPUOrderingPolicyUnderUtilizedPreemptionEnabled(true);
    conf.setPUOrderingPolicyUnderUtilizedPreemptionDelay(1000);
    conf.setQueueOrderingPolicy(CapacitySchedulerConfiguration.ROOT,CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY);
    conf.setQueuePriority(CapacitySchedulerConfiguration.ROOT + ".c",1);
    MockRM rm1=new MockRM(conf);
    rm1.getRMContext().setNodeLabelManager(mgr);
    rm1.start();
    MockNM nm1=rm1.registerNode("h1:1234",20 * GB);
    MockNM nm2=rm1.registerNode("h2:1234",20 * GB);
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMNode rmNode1=rm1.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm1.getRMContext().getRMNodes().get(nm2.getNodeId());
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"b");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    am1.allocate("*",1 * GB,6,new ArrayList<>());
    for (int i=0; i < 3; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(7,schedulerApp1.getLiveContainers().size());
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode1.getNodeID()),am1.getApplicationAttemptId(),4);
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode2.getNodeID()),am1.getApplicationAttemptId(),3);
    RMApp app2=rm1.submitApp(18 * GB,"app","user",null,"c");
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app2.getApplicationId(),1));
    while (cs.getNode(rmNode1.getNodeID()).getReservedContainer() == null) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      Thread.sleep(10);
    }
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    Assert.assertEquals(0,editPolicy.getToPreemptContainers().size());
    Thread.sleep(1000);
    editPolicy.editSchedule();
    Assert.assertEquals(2,editPolicy.getToPreemptContainers().size());
    editPolicy.editSchedule();
    while (cs.getNode(rmNode1.getNodeID()).getReservedContainer() != null) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      Thread.sleep(10);
    }
    waitNumberOfLiveContainersFromApp(schedulerApp2,1);
    rm1.close();
  }
  @Test(timeout=300000) public void testPriorityPreemptionRequiresMoveReservation() throws Exception {
    conf.setPUOrderingPolicyUnderUtilizedPreemptionEnabled(true);
    conf.setPUOrderingPolicyUnderUtilizedPreemptionDelay(1000);
    conf.setQueueOrderingPolicy(CapacitySchedulerConfiguration.ROOT,CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY);
    conf.setPUOrderingPolicyUnderUtilizedPreemptionMoveReservation(true);
    conf.setQueuePriority(CapacitySchedulerConfiguration.ROOT + ".c",1);
    MockRM rm1=new MockRM(conf);
    rm1.getRMContext().setNodeLabelManager(mgr);
    rm1.start();
    MockNM nm1=rm1.registerNode("h1:1234",10 * GB);
    MockNM nm2=rm1.registerNode("h2:1234",10 * GB);
    MockNM nm3=rm1.registerNode("h3:1234",10 * GB);
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMNode rmNode1=rm1.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm1.getRMContext().getRMNodes().get(nm2.getNodeId());
    RMNode rmNode3=rm1.getRMContext().getRMNodes().get(nm3.getNodeId());
    RMApp app1=rm1.submitApp(2 * GB,"app","user",null,"b");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    am1.allocate("*",2 * GB,2,new ArrayList<>());
    for (int i=0; i < 2; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(3,schedulerApp1.getLiveContainers().size());
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode1.getNodeID()),am1.getApplicationAttemptId(),1);
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode2.getNodeID()),am1.getApplicationAttemptId(),2);
    RMApp app2=rm1.submitApp(2 * GB,"app","user",null,"c");
    MockAM am2=MockRM.launchAndRegisterAM(app2,rm1,nm3);
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app2.getApplicationId(),1));
    am2.allocate("*",9 * GB,1,new ArrayList<>());
    cs.handle(new NodeUpdateSchedulerEvent(rmNode3));
    Assert.assertNotNull(cs.getNode(rmNode3.getNodeID()).getReservedContainer());
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    Assert.assertNotNull(cs.getNode(rmNode3.getNodeID()).getReservedContainer());
    Thread.sleep(1000);
    editPolicy.editSchedule();
    Assert.assertNull(cs.getNode(rmNode3.getNodeID()).getReservedContainer());
    Assert.assertNotNull(cs.getNode(rmNode2.getNodeID()).getReservedContainer());
    Assert.assertEquals(am2.getApplicationAttemptId(),cs.getNode(rmNode2.getNodeID()).getReservedContainer().getApplicationAttemptId());
    editPolicy.editSchedule();
    Assert.assertEquals(2,editPolicy.getToPreemptContainers().size());
    editPolicy.editSchedule();
    while (schedulerApp2.getLiveContainers().size() < 2) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
      Thread.sleep(200);
    }
    waitNumberOfLiveContainersFromApp(schedulerApp1,1);
    rm1.close();
  }
  @Test(timeout=60000) public void testPriorityPreemptionOnlyTriggeredWhenDemandingQueueUnsatisfied() throws Exception {
    conf.setPUOrderingPolicyUnderUtilizedPreemptionEnabled(true);
    conf.setPUOrderingPolicyUnderUtilizedPreemptionDelay(1000);
    conf.setQueueOrderingPolicy(CapacitySchedulerConfiguration.ROOT,CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY);
    conf.setQueuePriority(CapacitySchedulerConfiguration.ROOT + ".c",1);
    MockRM rm1=new MockRM(conf);
    rm1.getRMContext().setNodeLabelManager(mgr);
    rm1.start();
    MockNM[] mockNMs=new MockNM[10];
    for (int i=0; i < 10; i++) {
      mockNMs[i]=rm1.registerNode("h" + i + ":1234",10 * GB);
    }
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMNode[] rmNodes=new RMNode[10];
    for (int i=0; i < 10; i++) {
      rmNodes[i]=rm1.getRMContext().getRMNodes().get(mockNMs[i].getNodeId());
    }
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"b");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,mockNMs[0]);
    am1.allocate("*",1 * GB,8,new ArrayList<>());
    for (int i=1; i < 9; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(9,schedulerApp1.getLiveContainers().size());
    for (int i=0; i < 9; i++) {
      waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNodes[i].getNodeID()),am1.getApplicationAttemptId(),1);
    }
    RMApp app2=rm1.submitApp(10 * GB,"app","user",null,"c");
    MockAM am2=MockRM.launchAndRegisterAM(app2,rm1,mockNMs[9]);
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app2.getApplicationId(),1));
    am2.allocate("*",10 * GB,10,new ArrayList<>());
    for (int i=1; i < 10; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    for (int i=1; i < 9; i++) {
      Assert.assertNotNull("Should reserve on nm-" + i,cs.getNode(rmNodes[i].getNodeID()).getReservedContainer());
    }
    Thread.sleep(1000);
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    checkNumberOfPreemptionCandidateFromApp(editPolicy,6,am1.getApplicationAttemptId());
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,3);
    for (int i=1; i < 10; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    waitNumberOfLiveContainersFromApp(schedulerApp2,7);
    waitNumberOfLiveContainersFromApp(schedulerApp1,3);
    rm1.close();
  }
  @Test(timeout=600000) public void testPriorityPreemptionFromHighestPriorityQueueAndOldestContainer() throws Exception {
    conf.setQueuePriority(CapacitySchedulerConfiguration.ROOT + ".a",1);
    conf.setQueuePriority(CapacitySchedulerConfiguration.ROOT + ".b",2);
    conf.setCapacity(CapacitySchedulerConfiguration.ROOT + ".a",45f);
    conf.setCapacity(CapacitySchedulerConfiguration.ROOT + ".b",45f);
    conf.setCapacity(CapacitySchedulerConfiguration.ROOT + ".c",10f);
    testPriorityPreemptionFromHighestPriorityQueueAndOldestContainer(new String[]{"a","b","c"},new String[]{"user","user","user"});
  }
  protected void testPriorityPreemptionFromHighestPriorityQueueAndOldestContainer(  String[] queues,  String[] users) throws Exception {
    conf.setFloat(CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,0.05f);
    conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB,512);
    conf.setPUOrderingPolicyUnderUtilizedPreemptionEnabled(true);
    conf.setPUOrderingPolicyUnderUtilizedPreemptionDelay(1000);
    conf.setQueueOrderingPolicy(CapacitySchedulerConfiguration.ROOT,CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY);
    MockRM rm1=new MockRM(conf){
      protected RMNodeLabelsManager createNodeLabelManager(){
        return mgr;
      }
    }
;
    rm1.start();
    MockNM[] mockNMs=new MockNM[5];
    for (int i=0; i < 5; i++) {
      mockNMs[i]=rm1.registerNode("h" + i + ":1234",4 * GB);
    }
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMNode[] rmNodes=new RMNode[5];
    for (int i=0; i < 5; i++) {
      rmNodes[i]=rm1.getRMContext().getRMNodes().get(mockNMs[i].getNodeId());
    }
    RMApp app1=rm1.submitApp(1 * GB,"app",users[2],null,queues[2]);
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,mockNMs[4]);
    am1.allocate("*",1 * GB,4,new ArrayList<>());
    for (int i=0; i < 4; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(5,schedulerApp1.getLiveContainers().size());
    for (int i=0; i < 5; i++) {
      waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNodes[i].getNodeID()),am1.getApplicationAttemptId(),1);
    }
    RMApp app2=rm1.submitApp(512,"app",users[0],null,queues[0]);
    MockAM am2=MockRM.launchAndRegisterAM(app2,rm1,mockNMs[0]);
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app2.getApplicationId(),1));
    am2.allocate("*",3 * GB + 512,2,new ArrayList<>());
    for (int i=0; i < 2; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    for (int i=0; i < 2; i++) {
      Assert.assertNotNull("Should reserve on nm-" + i,cs.getNode(rmNodes[i].getNodeID()).getReservedContainer());
      Assert.assertEquals(cs.getNode(rmNodes[i].getNodeID()).getReservedContainer().getQueueName(),queues[0]);
    }
    RMApp app3=rm1.submitApp(512,"app",users[1],null,queues[1]);
    MockAM am3=MockRM.launchAndRegisterAM(app3,rm1,mockNMs[2]);
    FiCaSchedulerApp schedulerApp3=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app3.getApplicationId(),1));
    am3.allocate("*",3 * GB + 512,2,new ArrayList<>());
    for (int i=2; i < 4; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    for (int i=2; i < 4; i++) {
      Assert.assertNotNull("Should reserve on nm-" + i,cs.getNode(rmNodes[i].getNodeID()).getReservedContainer());
      Assert.assertEquals(cs.getNode(rmNodes[i].getNodeID()).getReservedContainer().getQueueName(),queues[1]);
    }
    Thread.sleep(1000);
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    Set<RMContainer> selectedToPreempt=editPolicy.getToPreemptContainers().keySet();
    Assert.assertEquals(1,selectedToPreempt.size());
    Assert.assertEquals(mockNMs[2].getNodeId(),selectedToPreempt.iterator().next().getAllocatedNode());
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,4);
    for (int i=0; i < 4; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    waitNumberOfLiveContainersFromApp(schedulerApp1,4);
    waitNumberOfLiveContainersFromApp(schedulerApp2,1);
    waitNumberOfLiveContainersFromApp(schedulerApp3,2);
    editPolicy.editSchedule();
    selectedToPreempt=editPolicy.getToPreemptContainers().keySet();
    Assert.assertEquals(1,selectedToPreempt.size());
    Assert.assertEquals(mockNMs[3].getNodeId(),selectedToPreempt.iterator().next().getAllocatedNode());
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,3);
    for (int i=0; i < 4; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    waitNumberOfLiveContainersFromApp(schedulerApp1,3);
    waitNumberOfLiveContainersFromApp(schedulerApp2,1);
    waitNumberOfLiveContainersFromApp(schedulerApp3,3);
    editPolicy.editSchedule();
    selectedToPreempt=editPolicy.getToPreemptContainers().keySet();
    Assert.assertEquals(1,selectedToPreempt.size());
    Assert.assertEquals(mockNMs[0].getNodeId(),selectedToPreempt.iterator().next().getAllocatedNode());
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,2);
    for (int i=0; i < 4; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    waitNumberOfLiveContainersFromApp(schedulerApp1,2);
    waitNumberOfLiveContainersFromApp(schedulerApp2,2);
    waitNumberOfLiveContainersFromApp(schedulerApp3,3);
    editPolicy.editSchedule();
    selectedToPreempt=editPolicy.getToPreemptContainers().keySet();
    Assert.assertEquals(1,selectedToPreempt.size());
    Assert.assertEquals(mockNMs[1].getNodeId(),selectedToPreempt.iterator().next().getAllocatedNode());
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,1);
    for (int i=0; i < 4; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    waitNumberOfLiveContainersFromApp(schedulerApp1,1);
    waitNumberOfLiveContainersFromApp(schedulerApp2,3);
    waitNumberOfLiveContainersFromApp(schedulerApp3,3);
    rm1.close();
  }
  private void initializeConfProperties(  CapacitySchedulerConfiguration conf) throws IOException {
    conf.setQueues("root",new String[]{"A","B"});
    conf.setCapacity("root.A",50);
    conf.setCapacity("root.B",50);
    conf.setQueuePriority("root.A",1);
    conf.setQueuePriority("root.B",2);
    conf.set(PREFIX + "root.ordering-policy","priority-utilization");
    conf.set(PREFIX + "ordering-policy.priority-utilization.underutilized-preemption.enabled","true");
    conf.set(PREFIX + "ordering-policy.priority-utilization.underutilized-preemption.allow-move-reservation","false");
    conf.set(PREFIX + "ordering-policy.priority-utilization.underutilized-preemption.reserved-container-delay-ms","0");
    conf.set(PREFIX + "root.accessible-node-labels.x.capacity","100");
    conf.set(PREFIX + "root.A.accessible-node-labels","x");
    conf.set(PREFIX + "root.B.accessible-node-labels","x");
    conf.set(PREFIX + "root.A.default-node-label-expression","x");
    conf.set(PREFIX + "root.B.default-node-label-expression","x");
    conf.set(PREFIX + "root.A.accessible-node-labels.x.capacity","50");
    conf.set(PREFIX + "root.B.accessible-node-labels.x.capacity","50");
    conf.set(PREFIX + "root.A.user-limit-factor","100");
    conf.set(PREFIX + "root.B.user-limit-factor","100");
    conf.set(PREFIX + "maximum-am-resource-percent","1");
    conf.setBoolean(YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS,true);
    conf.set(YarnConfiguration.RM_AM_MAX_ATTEMPTS,"1");
    conf.set(CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,"1000");
    conf.set(CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,"1000");
    conf.set(CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,"0.5");
    conf.set(CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,"1");
  }
  @Test public void testPriorityPreemptionWithNodeLabels() throws Exception {
    CapacitySchedulerConfiguration conf=new CapacitySchedulerConfiguration();
    initializeConfProperties(conf);
    MockRM rm1=new MockRM(conf){
      protected RMNodeLabelsManager createNodeLabelManager(){
        return mgr;
      }
    }
;
    rm1.start();
    MockNM[] mockNMs=new MockNM[NUM_NM];
    for (int i=0; i < NUM_NM; i++) {
      mockNMs[i]=rm1.registerNode("h" + i + ":1234",6144);
    }
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    mgr.addToCluserNodeLabels(Arrays.asList(NodeLabel.newInstance("x")));
    RMNode[] rmNodes=new RMNode[5];
    for (int i=0; i < NUM_NM; i++) {
      rmNodes[i]=rm1.getRMContext().getRMNodes().get(mockNMs[i].getNodeId());
      mgr.replaceLabelsOnNode(ImmutableMap.of(rmNodes[i].getNodeID(),ImmutableSet.of("x")));
    }
    RMApp app1=rm1.submitApp(4096,"app","user",null,"B");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,mockNMs[4]);
    am1.allocate("*",4096,NUM_NM - 1,new ArrayList<>());
    for (int i=0; i < NUM_NM - 1; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(NUM_NM,schedulerApp1.getLiveContainers().size());
    for (int i=0; i < NUM_NM; i++) {
      waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNodes[i].getNodeID()),am1.getApplicationAttemptId(),1);
    }
    RMApp app2=rm1.submitApp(1024,"app","user",null,"A");
    MockAM am2=MockRM.launchAndRegisterAM(app2,rm1,mockNMs[0]);
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app2.getApplicationId(),1));
    am2.allocate("*",2048,NUM_NM - 1,new ArrayList<>());
    for (int i=1; i < NUM_NM; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    rm1.killApp(app1.getApplicationId());
    RMApp app3=rm1.submitApp(1024,"app","user",null,"B");
    MockAM am3=MockRM.launchAndRegisterAM(app3,rm1,mockNMs[2]);
    FiCaSchedulerApp schedulerApp3=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app3.getApplicationId(),1));
    am3.allocate("*",5120,NUM_NM,new ArrayList<>());
    for (int i=0; i < NUM_NM; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNodes[i]));
    }
    Thread.sleep(1000);
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    Set<RMContainer> selectedToPreempt=editPolicy.getToPreemptContainers().keySet();
    Assert.assertEquals(2,selectedToPreempt.size());
    List<NodeId> selectedToPreemptNodeIds=new ArrayList<>();
    for (    RMContainer rmc : selectedToPreempt) {
      selectedToPreemptNodeIds.add(rmc.getAllocatedNode());
    }
    assertThat(selectedToPreemptNodeIds,CoreMatchers.hasItems(mockNMs[1].getNodeId(),mockNMs[2].getNodeId()));
    rm1.close();
  }
  @Test(timeout=60000) public void testPreemptionForFragmentatedCluster() throws Exception {
    conf.setBoolean(CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,true);
    CapacitySchedulerConfiguration conf=new CapacitySchedulerConfiguration(this.conf);
    conf.setLong(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,1024 * 21);
    conf.setQueues("root",new String[]{"a","b"});
    conf.setCapacity("root.a",50);
    conf.setUserLimitFactor("root.a",100);
    conf.setCapacity("root.b",50);
    conf.setUserLimitFactor("root.b",100);
    MockRM rm1=new MockRM(conf);
    rm1.getRMContext().setNodeLabelManager(mgr);
    rm1.start();
    List<MockNM> nms=new ArrayList<>();
    for (int i=0; i < 5; i++) {
      nms.add(rm1.registerNode("h" + i + ":1234",30 * GB));
    }
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMApp app1=rm1.submitApp(3 * GB,"app","user",null,"a");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nms.get(0));
    am1.allocate("*",21 * GB,4,new ArrayList<ContainerId>());
    for (int i=0; i < 10; i++) {
      MockNM mockNM=nms.get(i % nms.size());
      RMNode rmNode=cs.getRMContext().getRMNodes().get(mockNM.getNodeId());
      cs.handle(new NodeUpdateSchedulerEvent(rmNode));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(5,schedulerApp1.getLiveContainers().size());
    RMApp app2=rm1.submitApp(3 * GB,"app","user",null,"b");
    MockAM am2=MockRM.launchAndRegisterAM(app2,rm1,nms.get(2));
    am2.allocate("*",21 * GB,4,new ArrayList<ContainerId>());
    for (int i=0; i < 10; i++) {
      MockNM mockNM=nms.get(i % nms.size());
      RMNode rmNode=cs.getRMContext().getRMNodes().get(mockNM.getNodeId());
      cs.handle(new NodeUpdateSchedulerEvent(rmNode));
    }
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(am2.getApplicationAttemptId());
    Assert.assertEquals(2,schedulerApp2.getLiveContainers().size());
    waitNumberOfReservedContainersFromApp(schedulerApp2,1);
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    editPolicy.editSchedule();
    int tick=0;
    while (schedulerApp2.getLiveContainers().size() != 4 && tick < 10) {
      for (int i=0; i < 10; i++) {
        MockNM mockNM=nms.get(i % nms.size());
        RMNode rmNode=cs.getRMContext().getRMNodes().get(mockNM.getNodeId());
        cs.handle(new NodeUpdateSchedulerEvent(rmNode));
      }
      tick++;
      Thread.sleep(100);
    }
    Assert.assertEquals(3,schedulerApp2.getLiveContainers().size());
    rm1.close();
  }
  @Test(timeout=600000) public void testPreemptionToBalanceWithCustomTimeout() throws Exception {
    conf.setBoolean(CapacitySchedulerConfiguration.PREEMPTION_TO_BALANCE_QUEUES_BEYOND_GUARANTEED,true);
    conf.setLong(CapacitySchedulerConfiguration.MAX_WAIT_BEFORE_KILL_FOR_QUEUE_BALANCE_PREEMPTION,20 * 1000);
    CapacitySchedulerConfiguration conf=new CapacitySchedulerConfiguration(this.conf);
    MockRM rm1=new MockRM(conf);
    rm1.getRMContext().setNodeLabelManager(mgr);
    rm1.start();
    MockNM nm1=rm1.registerNode("h1:1234",20 * GB);
    MockNM nm2=rm1.registerNode("h2:1234",20 * GB);
    CapacityScheduler cs=(CapacityScheduler)rm1.getResourceScheduler();
    RMNode rmNode1=rm1.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm1.getRMContext().getRMNodes().get(nm2.getNodeId());
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"a");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    am1.allocate("*",1 * GB,38,new ArrayList<ContainerId>());
    for (int i=0; i < 38; i++) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
    }
    FiCaSchedulerApp schedulerApp1=cs.getApplicationAttempt(am1.getApplicationAttemptId());
    Assert.assertEquals(39,schedulerApp1.getLiveContainers().size());
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode1.getNodeID()),am1.getApplicationAttemptId(),20);
    waitNumberOfLiveContainersOnNodeFromApp(cs.getNode(rmNode2.getNodeID()),am1.getApplicationAttemptId(),19);
    RMApp app2=rm1.submitApp(4 * GB,"app","user",null,"c");
    FiCaSchedulerApp schedulerApp2=cs.getApplicationAttempt(ApplicationAttemptId.newInstance(app2.getApplicationId(),1));
    SchedulingMonitorManager smm=((CapacityScheduler)rm1.getResourceScheduler()).getSchedulingMonitorManager();
    SchedulingMonitor smon=smm.getAvailableSchedulingMonitor();
    ProportionalCapacityPreemptionPolicy editPolicy=(ProportionalCapacityPreemptionPolicy)smon.getSchedulingEditPolicy();
    editPolicy.editSchedule();
    Assert.assertEquals(4,editPolicy.getToPreemptContainers().size());
    Assert.assertEquals(39,schedulerApp1.getLiveContainers().size());
    Thread.sleep(20 * 1000);
    editPolicy.editSchedule();
    waitNumberOfLiveContainersFromApp(schedulerApp1,35);
    cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
    cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
    waitNumberOfReservedContainersFromApp(schedulerApp2,1);
    editPolicy.editSchedule();
    editPolicy.editSchedule();
    int tick=0;
    while (schedulerApp2.getLiveContainers().size() != 1 && tick < 10) {
      cs.handle(new NodeUpdateSchedulerEvent(rmNode1));
      cs.handle(new NodeUpdateSchedulerEvent(rmNode2));
      tick++;
      Thread.sleep(100);
    }
    waitNumberOfReservedContainersFromApp(schedulerApp2,0);
    rm1.close();
  }
}
