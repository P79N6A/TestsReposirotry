public class TestOfflineEditsViewer {
  private static final Log LOG=LogFactory.getLog(TestOfflineEditsViewer.class);
  private static final String buildDir=PathUtils.getTestDirName(TestOfflineEditsViewer.class);
  private static final OfflineEditsViewerHelper nnHelper=new OfflineEditsViewerHelper();
  private static final ImmutableSet<FSEditLogOpCodes> skippedOps=skippedOps();
  @SuppressWarnings("deprecation") private static ImmutableSet<FSEditLogOpCodes> skippedOps(){
    ImmutableSet.Builder<FSEditLogOpCodes> b=ImmutableSet.builder();
    b.add(FSEditLogOpCodes.OP_DATANODE_ADD).add(FSEditLogOpCodes.OP_DATANODE_REMOVE).add(FSEditLogOpCodes.OP_SET_NS_QUOTA).add(FSEditLogOpCodes.OP_CLEAR_NS_QUOTA).add(FSEditLogOpCodes.OP_SET_GENSTAMP_V1);
    b.add(FSEditLogOpCodes.OP_GET_DELEGATION_TOKEN).add(FSEditLogOpCodes.OP_RENEW_DELEGATION_TOKEN).add(FSEditLogOpCodes.OP_CANCEL_DELEGATION_TOKEN);
    b.add(FSEditLogOpCodes.OP_INVALID);
    return b.build();
  }
  @Rule public final TemporaryFolder folder=new TemporaryFolder();
  @Before public void setUp() throws IOException {
    nnHelper.startCluster(buildDir + "/dfs/");
  }
  @After public void tearDown() throws IOException {
    nnHelper.shutdownCluster();
  }
  /** 
 * Test the OfflineEditsViewer
 */
  @Test public void testGenerated() throws IOException {
    String edits=nnHelper.generateEdits();
    LOG.info("Generated edits=" + edits);
    String editsParsedXml=folder.newFile("editsParsed.xml").getAbsolutePath();
    String editsReparsed=folder.newFile("editsParsed").getAbsolutePath();
    String editsParsedXML_caseInSensitive=folder.newFile("editsRecoveredParsed.XML").getAbsolutePath();
    assertEquals(0,runOev(edits,editsParsedXml,"xml",false));
    assertEquals(0,runOev(edits,editsParsedXML_caseInSensitive,"xml",false));
    assertEquals(0,runOev(editsParsedXml,editsReparsed,"binary",false));
    assertEquals(0,runOev(editsParsedXML_caseInSensitive,editsReparsed,"binary",false));
    assertTrue("Edits " + edits + " should have all op codes",hasAllOpCodes(edits));
    LOG.info("Comparing generated file " + editsReparsed + " with reference file "+ edits);
    assertTrue("Generated edits and reparsed (bin to XML to bin) should be same",filesEqualIgnoreTrailingZeros(edits,editsReparsed));
  }
  @Test public void testRecoveryMode() throws IOException {
    String edits=nnHelper.generateEdits();
    FileOutputStream os=new FileOutputStream(edits,true);
    FileChannel editsFile=os.getChannel();
    editsFile.truncate(editsFile.size() - 5);
    String editsParsedXml=folder.newFile("editsRecoveredParsed.xml").getAbsolutePath();
    String editsReparsed=folder.newFile("editsRecoveredReparsed").getAbsolutePath();
    String editsParsedXml2=folder.newFile("editsRecoveredParsed2.xml").getAbsolutePath();
    assertEquals(-1,runOev(edits,editsParsedXml,"xml",false));
    assertEquals(0,runOev(edits,editsParsedXml,"xml",true));
    assertEquals(0,runOev(editsParsedXml,editsReparsed,"binary",false));
    assertEquals(0,runOev(editsReparsed,editsParsedXml2,"xml",false));
    assertTrue("Test round trip",FileUtils.contentEqualsIgnoreEOL(new File(editsParsedXml),new File(editsParsedXml2),"UTF-8"));
    os.close();
  }
  @Test public void testStored() throws IOException {
    final String cacheDir=System.getProperty("test.cache.data","build/test/cache");
    String editsStored=cacheDir + "/editsStored";
    String editsStoredParsedXml=cacheDir + "/editsStoredParsed.xml";
    String editsStoredReparsed=cacheDir + "/editsStoredReparsed";
    String editsStoredXml=cacheDir + "/editsStored.xml";
    assertEquals(0,runOev(editsStored,editsStoredParsedXml,"xml",false));
    assertEquals(0,runOev(editsStoredParsedXml,editsStoredReparsed,"binary",false));
    assertTrue("Edits " + editsStored + " should have all op codes",hasAllOpCodes(editsStored));
    assertTrue("Reference XML edits and parsed to XML should be same",FileUtils.contentEqualsIgnoreEOL(new File(editsStoredXml),new File(editsStoredParsedXml),"UTF-8"));
    assertTrue("Reference edits and reparsed (bin to XML to bin) should be same",filesEqualIgnoreTrailingZeros(editsStored,editsStoredReparsed));
  }
  /** 
 * Run OfflineEditsViewer
 * @param inFilename input edits filename
 * @param outFilename oputput edits filename
 */
  private int runOev(  String inFilename,  String outFilename,  String processor,  boolean recovery) throws IOException {
    LOG.info("Running oev [" + inFilename + "] ["+ outFilename+ "]");
    OfflineEditsViewer oev=new OfflineEditsViewer();
    Flags flags=new Flags();
    flags.setPrintToScreen();
    if (recovery) {
      flags.setRecoveryMode();
    }
    return oev.go(inFilename,outFilename,processor,flags,null);
  }
  /** 
 * Checks that the edits file has all opCodes
 * @param filename edits file
 * @return true is edits (filename) has all opCodes
 */
  private boolean hasAllOpCodes(  String inFilename) throws IOException {
    String outFilename=inFilename + ".stats";
    FileOutputStream fout=new FileOutputStream(outFilename);
    StatisticsEditsVisitor visitor=new StatisticsEditsVisitor(fout);
    OfflineEditsViewer oev=new OfflineEditsViewer();
    if (oev.go(inFilename,outFilename,"stats",new Flags(),visitor) != 0)     return false;
    LOG.info("Statistics for " + inFilename + "\n"+ visitor.getStatisticsString());
    boolean hasAllOpCodes=true;
    for (    FSEditLogOpCodes opCode : FSEditLogOpCodes.values()) {
      if (skippedOps.contains(opCode))       continue;
      Long count=visitor.getStatistics().get(opCode);
      if ((count == null) || (count == 0)) {
        hasAllOpCodes=false;
        LOG.info("Opcode " + opCode + " not tested in "+ inFilename);
      }
    }
    return hasAllOpCodes;
  }
  /** 
 * Compare two files, ignore trailing zeros at the end, for edits log the trailing zeros do not make any difference, throw exception is the files are not same
 * @param filenameSmall first file to compare (doesn't have to be smaller)
 * @param filenameLarge second file to compare (doesn't have to be larger)
 */
  private boolean filesEqualIgnoreTrailingZeros(  String filenameSmall,  String filenameLarge) throws IOException {
    ByteBuffer small=ByteBuffer.wrap(DFSTestUtil.loadFile(filenameSmall));
    ByteBuffer large=ByteBuffer.wrap(DFSTestUtil.loadFile(filenameLarge));
    small.put(3,(byte)NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    if (small.capacity() > large.capacity()) {
      ByteBuffer tmpByteBuffer=small;
      small=large;
      large=tmpByteBuffer;
      String tmpFilename=filenameSmall;
      filenameSmall=filenameLarge;
      filenameLarge=tmpFilename;
    }
    small.position(0);
    small.limit(small.capacity());
    large.position(0);
    large.limit(small.capacity());
    if (!small.equals(large)) {
      return false;
    }
    int i=large.limit();
    large.clear();
    for (; i < large.capacity(); i++) {
      if (large.get(i) != FSEditLogOpCodes.OP_INVALID.getOpCode()) {
        return false;
      }
    }
    return true;
  }
  @Test public void testOfflineEditsViewerHelpMessage() throws Throwable {
    final ByteArrayOutputStream bytes=new ByteArrayOutputStream();
    final PrintStream out=new PrintStream(bytes);
    final PrintStream oldOut=System.out;
    try {
      System.setOut(out);
      int status=new OfflineEditsViewer().run(new String[]{"-h"});
      assertTrue("" + "Exit code returned for help option is incorrect",status == 0);
      Assert.assertFalse("Invalid Command error displayed when help option is passed.",bytes.toString().contains("Error parsing command-line options"));
    }
  finally {
      System.setOut(oldOut);
      IOUtils.closeStream(out);
    }
  }
  @Test public void testStatisticsStrWithNullOpCodeCount() throws IOException {
    String editFilename=nnHelper.generateEdits();
    String outFilename=editFilename + ".stats";
    FileOutputStream fout=new FileOutputStream(outFilename);
    StatisticsEditsVisitor visitor=new StatisticsEditsVisitor(fout);
    OfflineEditsViewer oev=new OfflineEditsViewer();
    String statisticsStr=null;
    if (oev.go(editFilename,outFilename,"stats",new Flags(),visitor) == 0) {
      statisticsStr=visitor.getStatisticsString();
    }
    Assert.assertNotNull(statisticsStr);
    String str;
    Long count;
    Map<FSEditLogOpCodes,Long> opCodeCount=visitor.getStatistics();
    for (    FSEditLogOpCodes opCode : FSEditLogOpCodes.values()) {
      count=opCodeCount.get(opCode);
      if (count == null) {
        str=String.format("    %-30.30s (%3d): %d%n",opCode.toString(),opCode.getOpCode(),Long.valueOf(0L));
        assertTrue(statisticsStr.contains(str));
      }
    }
  }
  @Test public void testProcessorWithSameTypeFormatFile() throws IOException {
    String edits=nnHelper.generateEdits();
    LOG.info("Generated edits=" + edits);
    String binaryEdits=folder.newFile("binaryEdits").getAbsolutePath();
    String editsParsedXml=folder.newFile("editsParsed.xml").getAbsolutePath();
    String editsReparsedXml=folder.newFile("editsReparsed.xml").getAbsolutePath();
    assertEquals(-1,runOev(edits,binaryEdits,"binary",false));
    assertEquals(0,runOev(edits,editsParsedXml,"xml",false));
    assertEquals(-1,runOev(editsParsedXml,editsReparsedXml,"xml",false));
  }
}
