/** 
 * Tests various functions of the JobImpl class
 */
@SuppressWarnings({"rawtypes"}) public class TestJobImpl {
  static String stagingDir="target/test-staging/";
  @BeforeClass public static void setup(){
    File dir=new File(stagingDir);
    stagingDir=dir.getAbsolutePath();
  }
  @Before public void cleanup() throws IOException {
    File dir=new File(stagingDir);
    if (dir.exists()) {
      FileUtils.deleteDirectory(dir);
    }
    dir.mkdirs();
  }
  @Test public void testJobNoTasks(){
    Configuration conf=new Configuration();
    conf.setInt(MRJobConfig.NUM_REDUCES,0);
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    conf.set(MRJobConfig.WORKFLOW_ID,"testId");
    conf.set(MRJobConfig.WORKFLOW_NAME,"testName");
    conf.set(MRJobConfig.WORKFLOW_NODE_NAME,"testNodeName");
    conf.set(MRJobConfig.WORKFLOW_ADJACENCY_PREFIX_STRING + "key1","value1");
    conf.set(MRJobConfig.WORKFLOW_ADJACENCY_PREFIX_STRING + "key2","value2");
    conf.set(MRJobConfig.WORKFLOW_TAGS,"tag1,tag2");
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    OutputCommitter committer=mock(OutputCommitter.class);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobSubmittedEventHandler jseHandler=new JobSubmittedEventHandler("testId","testName","testNodeName","\"key2\"=\"value2\" \"key1\"=\"value1\" ","tag1,tag2");
    dispatcher.register(EventType.class,jseHandler);
    JobImpl job=createStubbedJob(conf,dispatcher,0,null);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(job.getID()));
    assertJobState(job,JobStateInternal.SUCCEEDED);
    dispatcher.stop();
    commitHandler.stop();
    try {
      Assert.assertTrue(jseHandler.getAssertValue());
    }
 catch (    InterruptedException e) {
      Assert.fail("Workflow related attributes are not tested properly");
    }
  }
  @Test(timeout=20000) public void testCommitJobFailsJob() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    CyclicBarrier syncBarrier=new CyclicBarrier(2);
    OutputCommitter committer=new TestingOutputCommitter(syncBarrier,false);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobImpl job=createRunningStubbedJob(conf,dispatcher,2,null);
    completeJobTasks(job);
    assertJobState(job,JobStateInternal.COMMITTING);
    syncBarrier.await();
    assertJobState(job,JobStateInternal.FAILED);
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test(timeout=20000) public void testCheckJobCompleteSuccess() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    CyclicBarrier syncBarrier=new CyclicBarrier(2);
    OutputCommitter committer=new TestingOutputCommitter(syncBarrier,true);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobImpl job=createRunningStubbedJob(conf,dispatcher,2,null);
    completeJobTasks(job);
    assertJobState(job,JobStateInternal.COMMITTING);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_TASK_ATTEMPT_COMPLETED));
    assertJobState(job,JobStateInternal.COMMITTING);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_MAP_TASK_RESCHEDULED));
    assertJobState(job,JobStateInternal.COMMITTING);
    syncBarrier.await();
    assertJobState(job,JobStateInternal.SUCCEEDED);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_TASK_ATTEMPT_COMPLETED));
    assertJobState(job,JobStateInternal.SUCCEEDED);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_MAP_TASK_RESCHEDULED));
    assertJobState(job,JobStateInternal.SUCCEEDED);
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test(timeout=20000) public void testRebootedDuringSetup() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    OutputCommitter committer=new StubbedOutputCommitter(){
      @Override public synchronized void setupJob(      JobContext jobContext) throws IOException {
        while (!Thread.interrupted()) {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
;
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    AppContext mockContext=mock(AppContext.class);
    when(mockContext.isLastAMRetry()).thenReturn(false);
    JobImpl job=createStubbedJob(conf,dispatcher,2,mockContext);
    JobId jobId=job.getID();
    job.handle(new JobEvent(jobId,JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(jobId));
    assertJobState(job,JobStateInternal.SETUP);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_AM_REBOOT));
    assertJobState(job,JobStateInternal.REBOOT);
    Assert.assertEquals(JobState.RUNNING,job.getState());
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test(timeout=20000) public void testRebootedDuringCommit() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    conf.setInt(MRJobConfig.MR_AM_MAX_ATTEMPTS,2);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    CyclicBarrier syncBarrier=new CyclicBarrier(2);
    OutputCommitter committer=new WaitingOutputCommitter(syncBarrier,true);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    AppContext mockContext=mock(AppContext.class);
    when(mockContext.isLastAMRetry()).thenReturn(true);
    when(mockContext.hasSuccessfullyUnregistered()).thenReturn(false);
    JobImpl job=createRunningStubbedJob(conf,dispatcher,2,mockContext);
    completeJobTasks(job);
    assertJobState(job,JobStateInternal.COMMITTING);
    syncBarrier.await();
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_AM_REBOOT));
    assertJobState(job,JobStateInternal.REBOOT);
    Assert.assertEquals(JobState.RUNNING,job.getState());
    when(mockContext.hasSuccessfullyUnregistered()).thenReturn(true);
    Assert.assertEquals(JobState.ERROR,job.getState());
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test(timeout=20000) public void testKilledDuringSetup() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    OutputCommitter committer=new StubbedOutputCommitter(){
      @Override public synchronized void setupJob(      JobContext jobContext) throws IOException {
        while (!Thread.interrupted()) {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
;
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobImpl job=createStubbedJob(conf,dispatcher,2,null);
    JobId jobId=job.getID();
    job.handle(new JobEvent(jobId,JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(jobId));
    assertJobState(job,JobStateInternal.SETUP);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_KILL));
    assertJobState(job,JobStateInternal.KILLED);
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test(timeout=20000) public void testKilledDuringCommit() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    CyclicBarrier syncBarrier=new CyclicBarrier(2);
    OutputCommitter committer=new WaitingOutputCommitter(syncBarrier,true);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobImpl job=createRunningStubbedJob(conf,dispatcher,2,null);
    completeJobTasks(job);
    assertJobState(job,JobStateInternal.COMMITTING);
    syncBarrier.await();
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_KILL));
    assertJobState(job,JobStateInternal.KILLED);
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test public void testAbortJobCalledAfterKillingTasks() throws IOException {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    conf.set(MRJobConfig.MR_AM_COMMITTER_CANCEL_TIMEOUT_MS,"1000");
    InlineDispatcher dispatcher=new InlineDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    OutputCommitter committer=Mockito.mock(OutputCommitter.class);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobImpl job=createRunningStubbedJob(conf,dispatcher,2,null);
    job.handle(new JobTaskEvent(MRBuilderUtils.newTaskId(job.getID(),1,TaskType.MAP),TaskState.FAILED));
    Mockito.verify(committer,Mockito.never()).abortJob((JobContext)Mockito.any(),(State)Mockito.any());
    assertJobState(job,JobStateInternal.FAIL_WAIT);
    Mockito.verify(committer,Mockito.timeout(2000).times(1)).abortJob((JobContext)Mockito.any(),(State)Mockito.any());
    assertJobState(job,JobStateInternal.FAILED);
    dispatcher.stop();
  }
  @Test(timeout=10000) public void testFailAbortDoesntHang() throws IOException {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    conf.set(MRJobConfig.MR_AM_COMMITTER_CANCEL_TIMEOUT_MS,"1000");
    DrainDispatcher dispatcher=new DrainDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    OutputCommitter committer=Mockito.mock(OutputCommitter.class);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    conf.setInt(MRJobConfig.NUM_REDUCES,0);
    conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS,1);
    JobImpl job=createRunningStubbedJob(conf,dispatcher,1,null);
    for (    Task t : job.tasks.values()) {
      TaskImpl task=(TaskImpl)t;
      task.handle(new TaskEvent(task.getID(),TaskEventType.T_SCHEDULE));
      for (      TaskAttempt ta : task.getAttempts().values()) {
        task.handle(new TaskTAttemptFailedEvent(ta.getID()));
      }
    }
    dispatcher.await();
    Mockito.verify(committer,Mockito.timeout(2000).times(1)).abortJob((JobContext)Mockito.any(),(State)Mockito.any());
    assertJobState(job,JobStateInternal.FAILED);
    dispatcher.stop();
  }
  @Test(timeout=20000) public void testKilledDuringFailAbort() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    OutputCommitter committer=new StubbedOutputCommitter(){
      @Override public void setupJob(      JobContext jobContext) throws IOException {
        throw new IOException("forced failure");
      }
      @Override public synchronized void abortJob(      JobContext jobContext,      State state) throws IOException {
        while (!Thread.interrupted()) {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
;
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobImpl job=createStubbedJob(conf,dispatcher,2,null);
    JobId jobId=job.getID();
    job.handle(new JobEvent(jobId,JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(jobId));
    assertJobState(job,JobStateInternal.FAIL_ABORT);
    job.handle(new JobEvent(jobId,JobEventType.JOB_KILL));
    assertJobState(job,JobStateInternal.KILLED);
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test(timeout=20000) public void testKilledDuringKillAbort() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    OutputCommitter committer=new StubbedOutputCommitter(){
      @Override public synchronized void abortJob(      JobContext jobContext,      State state) throws IOException {
        while (!Thread.interrupted()) {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
;
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    JobImpl job=createStubbedJob(conf,dispatcher,2,null);
    JobId jobId=job.getID();
    job.handle(new JobEvent(jobId,JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(jobId));
    assertJobState(job,JobStateInternal.SETUP);
    job.handle(new JobEvent(jobId,JobEventType.JOB_KILL));
    assertJobState(job,JobStateInternal.KILL_ABORT);
    job.handle(new JobEvent(jobId,JobEventType.JOB_KILL));
    assertJobState(job,JobStateInternal.KILLED);
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test(timeout=20000) public void testUnusableNodeTransition() throws Exception {
    Configuration conf=new Configuration();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    conf.setInt(MRJobConfig.NUM_REDUCES,1);
    DrainDispatcher dispatcher=new DrainDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    CyclicBarrier syncBarrier=new CyclicBarrier(2);
    OutputCommitter committer=new TestingOutputCommitter(syncBarrier,true);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    final JobImpl job=createRunningStubbedJob(conf,dispatcher,2,null);
    EventHandler<TaskAttemptEvent> taskAttemptEventHandler=new EventHandler<TaskAttemptEvent>(){
      @Override public void handle(      TaskAttemptEvent event){
        if (event.getType() == TaskAttemptEventType.TA_KILL) {
          job.decrementSucceededMapperCount();
        }
      }
    }
;
    dispatcher.register(TaskAttemptEventType.class,taskAttemptEventHandler);
    Map<TaskId,Task> spiedTasks=new HashMap<>();
    List<NodeReport> nodeReports=new ArrayList<>();
    Map<NodeReport,TaskId> nodeReportsToTaskIds=new HashMap<>();
    createSpiedMapTasks(nodeReportsToTaskIds,spiedTasks,job,NodeState.UNHEALTHY,nodeReports);
    job.tasks.putAll(spiedTasks);
    for (    TaskId taskId : job.tasks.keySet()) {
      if (taskId.getTaskType() == TaskType.MAP) {
        TaskAttemptCompletionEvent tce=Records.newRecord(TaskAttemptCompletionEvent.class);
        TaskAttemptId attemptId=MRBuilderUtils.newTaskAttemptId(taskId,0);
        tce.setAttemptId(attemptId);
        tce.setStatus(TaskAttemptCompletionEventStatus.SUCCEEDED);
        job.handle(new JobTaskAttemptCompletedEvent(tce));
        job.handle(new JobTaskEvent(taskId,TaskState.SUCCEEDED));
        Assert.assertEquals(JobState.RUNNING,job.getState());
      }
    }
    NodeReport firstMapperNodeReport=nodeReports.get(0);
    NodeReport secondMapperNodeReport=nodeReports.get(1);
    job.handle(new JobUpdatedNodesEvent(job.getID(),Collections.singletonList(firstMapperNodeReport)));
    dispatcher.await();
    for (    TaskId taskId : job.tasks.keySet()) {
      if (taskId.getTaskType() == TaskType.REDUCE) {
        job.handle(new JobTaskEvent(taskId,TaskState.SUCCEEDED));
      }
    }
    job.handle(new JobUpdatedNodesEvent(job.getID(),Collections.singletonList(secondMapperNodeReport)));
    TaskId firstMapper=nodeReportsToTaskIds.get(firstMapperNodeReport);
    job.handle(new JobTaskEvent(firstMapper,TaskState.SUCCEEDED));
    assertJobState(job,JobStateInternal.COMMITTING);
    syncBarrier.await();
    assertJobState(job,JobStateInternal.SUCCEEDED);
    dispatcher.stop();
    commitHandler.stop();
  }
  @Test public void testJobNCompletedWhenAllReducersAreFinished() throws Exception {
    testJobCompletionWhenReducersAreFinished(true);
  }
  @Test public void testJobNotCompletedWhenAllReducersAreFinished() throws Exception {
    testJobCompletionWhenReducersAreFinished(false);
  }
  private void testJobCompletionWhenReducersAreFinished(  boolean killMappers) throws InterruptedException, BrokenBarrierException {
    Configuration conf=new Configuration();
    conf.setBoolean(MRJobConfig.FINISH_JOB_WHEN_REDUCERS_DONE,killMappers);
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    conf.setInt(MRJobConfig.NUM_REDUCES,1);
    DrainDispatcher dispatcher=new DrainDispatcher();
    dispatcher.init(conf);
    final List<TaskEvent> killedEvents=Collections.synchronizedList(new ArrayList<TaskEvent>());
    dispatcher.register(TaskEventType.class,new EventHandler<TaskEvent>(){
      @Override public void handle(      TaskEvent event){
        if (event.getType() == TaskEventType.T_KILL) {
          killedEvents.add(event);
        }
      }
    }
);
    dispatcher.start();
    CyclicBarrier syncBarrier=new CyclicBarrier(2);
    OutputCommitter committer=new TestingOutputCommitter(syncBarrier,true);
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    final JobImpl job=createRunningStubbedJob(conf,dispatcher,2,null);
    Map<TaskId,Task> spiedTasks=new HashMap<>();
    List<NodeReport> nodeReports=new ArrayList<>();
    Map<NodeReport,TaskId> nodeReportsToTaskIds=new HashMap<>();
    createSpiedMapTasks(nodeReportsToTaskIds,spiedTasks,job,NodeState.RUNNING,nodeReports);
    job.tasks.putAll(spiedTasks);
    for (    TaskId taskId : job.tasks.keySet()) {
      if (taskId.getTaskType() == TaskType.REDUCE) {
        job.handle(new JobTaskEvent(taskId,TaskState.SUCCEEDED));
      }
    }
    dispatcher.await();
    if (killMappers) {
      Assert.assertEquals("Number of killed events",2,killedEvents.size());
      Assert.assertEquals("AttemptID","task_1234567890000_0001_m_000000",killedEvents.get(0).getTaskID().toString());
      Assert.assertEquals("AttemptID","task_1234567890000_0001_m_000001",killedEvents.get(1).getTaskID().toString());
    }
 else {
      Assert.assertEquals("Number of killed events",0,killedEvents.size());
    }
  }
  public static void main(  String[] args) throws Exception {
    TestJobImpl t=new TestJobImpl();
    t.testJobNoTasks();
    t.testCheckJobCompleteSuccess();
    t.testCheckAccess();
    t.testReportDiagnostics();
    t.testUberDecision();
  }
  @Test public void testCheckAccess(){
    String user1=System.getProperty("user.name");
    String user2=user1 + "1234";
    UserGroupInformation ugi1=UserGroupInformation.createRemoteUser(user1);
    UserGroupInformation ugi2=UserGroupInformation.createRemoteUser(user2);
    JobID jobID=JobID.forName("job_1234567890000_0001");
    JobId jobId=TypeConverter.toYarn(jobID);
    Configuration conf1=new Configuration();
    conf1.setBoolean(MRConfig.MR_ACLS_ENABLED,true);
    conf1.set(MRJobConfig.JOB_ACL_VIEW_JOB,"");
    JobImpl job1=new JobImpl(jobId,null,conf1,null,null,null,null,null,null,null,null,true,user1,0,null,null,null,null);
    Assert.assertTrue(job1.checkAccess(ugi1,JobACL.VIEW_JOB));
    Assert.assertFalse(job1.checkAccess(ugi2,JobACL.VIEW_JOB));
    Configuration conf2=new Configuration();
    conf2.setBoolean(MRConfig.MR_ACLS_ENABLED,true);
    conf2.set(MRJobConfig.JOB_ACL_VIEW_JOB,user2);
    JobImpl job2=new JobImpl(jobId,null,conf2,null,null,null,null,null,null,null,null,true,user1,0,null,null,null,null);
    Assert.assertTrue(job2.checkAccess(ugi1,JobACL.VIEW_JOB));
    Assert.assertTrue(job2.checkAccess(ugi2,JobACL.VIEW_JOB));
    Configuration conf3=new Configuration();
    conf3.setBoolean(MRConfig.MR_ACLS_ENABLED,true);
    conf3.set(MRJobConfig.JOB_ACL_VIEW_JOB,"*");
    JobImpl job3=new JobImpl(jobId,null,conf3,null,null,null,null,null,null,null,null,true,user1,0,null,null,null,null);
    Assert.assertTrue(job3.checkAccess(ugi1,JobACL.VIEW_JOB));
    Assert.assertTrue(job3.checkAccess(ugi2,JobACL.VIEW_JOB));
    Configuration conf4=new Configuration();
    conf4.setBoolean(MRConfig.MR_ACLS_ENABLED,false);
    conf4.set(MRJobConfig.JOB_ACL_VIEW_JOB,"");
    JobImpl job4=new JobImpl(jobId,null,conf4,null,null,null,null,null,null,null,null,true,user1,0,null,null,null,null);
    Assert.assertTrue(job4.checkAccess(ugi1,JobACL.VIEW_JOB));
    Assert.assertTrue(job4.checkAccess(ugi2,JobACL.VIEW_JOB));
    Configuration conf5=new Configuration();
    conf5.setBoolean(MRConfig.MR_ACLS_ENABLED,true);
    conf5.set(MRJobConfig.JOB_ACL_VIEW_JOB,"");
    JobImpl job5=new JobImpl(jobId,null,conf5,null,null,null,null,null,null,null,null,true,user1,0,null,null,null,null);
    Assert.assertTrue(job5.checkAccess(ugi1,null));
    Assert.assertTrue(job5.checkAccess(ugi2,null));
  }
  @Test public void testReportDiagnostics() throws Exception {
    JobID jobID=JobID.forName("job_1234567890000_0001");
    JobId jobId=TypeConverter.toYarn(jobID);
    final String diagMsg="some diagnostic message";
    final JobDiagnosticsUpdateEvent diagUpdateEvent=new JobDiagnosticsUpdateEvent(jobId,diagMsg);
    MRAppMetrics mrAppMetrics=MRAppMetrics.create();
    AppContext mockContext=mock(AppContext.class);
    when(mockContext.hasSuccessfullyUnregistered()).thenReturn(true);
    JobImpl job=new JobImpl(jobId,Records.newRecord(ApplicationAttemptId.class),new Configuration(),mock(EventHandler.class),null,mock(JobTokenSecretManager.class),null,SystemClock.getInstance(),null,mrAppMetrics,null,true,null,0,null,mockContext,null,null);
    job.handle(diagUpdateEvent);
    String diagnostics=job.getReport().getDiagnostics();
    Assert.assertNotNull(diagnostics);
    Assert.assertTrue(diagnostics.contains(diagMsg));
    job=new JobImpl(jobId,Records.newRecord(ApplicationAttemptId.class),new Configuration(),mock(EventHandler.class),null,mock(JobTokenSecretManager.class),null,SystemClock.getInstance(),null,mrAppMetrics,null,true,null,0,null,mockContext,null,null);
    job.handle(new JobEvent(jobId,JobEventType.JOB_KILL));
    job.handle(diagUpdateEvent);
    diagnostics=job.getReport().getDiagnostics();
    Assert.assertNotNull(diagnostics);
    Assert.assertTrue(diagnostics.contains(diagMsg));
  }
  @Test public void testUberDecision() throws Exception {
    Configuration conf=new Configuration();
    boolean isUber=testUberDecision(conf);
    Assert.assertFalse(isUber);
    conf=new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,true);
    isUber=testUberDecision(conf);
    Assert.assertTrue(isUber);
    conf=new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,true);
    conf.setInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES,0);
    conf.setInt(MRJobConfig.NUM_REDUCES,1);
    isUber=testUberDecision(conf);
    Assert.assertFalse(isUber);
    conf=new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,true);
    conf.setInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES,1);
    conf.setInt(MRJobConfig.NUM_REDUCES,1);
    isUber=testUberDecision(conf);
    Assert.assertTrue(isUber);
    conf=new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,true);
    conf.setInt(MRJobConfig.JOB_UBERTASK_MAXMAPS,1);
    isUber=testUberDecision(conf);
    Assert.assertFalse(isUber);
    conf=new Configuration();
    conf.setBoolean(MRJobConfig.JOB_UBERTASK_ENABLE,true);
    conf.setInt(MRJobConfig.NUM_REDUCES,0);
    conf.setInt(MRJobConfig.REDUCE_MEMORY_MB,2048);
    conf.setInt(MRJobConfig.REDUCE_CPU_VCORES,10);
    isUber=testUberDecision(conf);
    Assert.assertTrue(isUber);
  }
  private boolean testUberDecision(  Configuration conf){
    JobID jobID=JobID.forName("job_1234567890000_0001");
    JobId jobId=TypeConverter.toYarn(jobID);
    MRAppMetrics mrAppMetrics=MRAppMetrics.create();
    JobImpl job=new JobImpl(jobId,ApplicationAttemptId.newInstance(ApplicationId.newInstance(0,0),0),conf,mock(EventHandler.class),null,new JobTokenSecretManager(),new Credentials(),null,null,mrAppMetrics,null,true,null,0,null,null,null,null);
    InitTransition initTransition=getInitTransition(2);
    JobEvent mockJobEvent=mock(JobEvent.class);
    initTransition.transition(job,mockJobEvent);
    boolean isUber=job.isUber();
    return isUber;
  }
  private static InitTransition getInitTransition(  final int numSplits){
    InitTransition initTransition=new InitTransition(){
      @Override protected TaskSplitMetaInfo[] createSplits(      JobImpl job,      JobId jobId){
        TaskSplitMetaInfo[] splits=new TaskSplitMetaInfo[numSplits];
        for (int i=0; i < numSplits; ++i) {
          splits[i]=new TaskSplitMetaInfo();
        }
        return splits;
      }
    }
;
    return initTransition;
  }
  @Test public void testTransitionsAtFailed() throws IOException {
    Configuration conf=new Configuration();
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    dispatcher.init(conf);
    dispatcher.start();
    OutputCommitter committer=mock(OutputCommitter.class);
    doThrow(new IOException("forcefail")).when(committer).setupJob(any(JobContext.class));
    CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
    commitHandler.init(conf);
    commitHandler.start();
    AppContext mockContext=mock(AppContext.class);
    when(mockContext.hasSuccessfullyUnregistered()).thenReturn(false);
    JobImpl job=createStubbedJob(conf,dispatcher,2,mockContext);
    JobId jobId=job.getID();
    job.handle(new JobEvent(jobId,JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(jobId));
    assertJobState(job,JobStateInternal.FAILED);
    job.handle(new JobEvent(jobId,JobEventType.JOB_TASK_COMPLETED));
    assertJobState(job,JobStateInternal.FAILED);
    job.handle(new JobEvent(jobId,JobEventType.JOB_TASK_ATTEMPT_COMPLETED));
    assertJobState(job,JobStateInternal.FAILED);
    job.handle(new JobEvent(jobId,JobEventType.JOB_MAP_TASK_RESCHEDULED));
    assertJobState(job,JobStateInternal.FAILED);
    job.handle(new JobEvent(jobId,JobEventType.JOB_TASK_ATTEMPT_FETCH_FAILURE));
    assertJobState(job,JobStateInternal.FAILED);
    Assert.assertEquals(JobState.RUNNING,job.getState());
    when(mockContext.hasSuccessfullyUnregistered()).thenReturn(true);
    Assert.assertEquals(JobState.FAILED,job.getState());
    dispatcher.stop();
    commitHandler.stop();
  }
  static final String EXCEPTIONMSG="Splits max exceeded";
  @Test public void testMetaInfoSizeOverMax() throws Exception {
    Configuration conf=new Configuration();
    JobID jobID=JobID.forName("job_1234567890000_0001");
    JobId jobId=TypeConverter.toYarn(jobID);
    MRAppMetrics mrAppMetrics=MRAppMetrics.create();
    JobImpl job=new JobImpl(jobId,ApplicationAttemptId.newInstance(ApplicationId.newInstance(0,0),0),conf,mock(EventHandler.class),null,new JobTokenSecretManager(),new Credentials(),null,null,mrAppMetrics,null,true,null,0,null,null,null,null);
    InitTransition initTransition=new InitTransition(){
      @Override protected TaskSplitMetaInfo[] createSplits(      JobImpl job,      JobId jobId){
        throw new YarnRuntimeException(EXCEPTIONMSG);
      }
    }
;
    JobEvent mockJobEvent=mock(JobEvent.class);
    JobStateInternal jobSI=initTransition.transition(job,mockJobEvent);
    Assert.assertTrue("When init fails, return value from InitTransition.transition should equal NEW.",jobSI.equals(JobStateInternal.NEW));
    Assert.assertTrue("Job diagnostics should contain YarnRuntimeException",job.getDiagnostics().toString().contains("YarnRuntimeException"));
    Assert.assertTrue("Job diagnostics should contain " + EXCEPTIONMSG,job.getDiagnostics().toString().contains(EXCEPTIONMSG));
  }
  @Test public void testJobPriorityUpdate() throws Exception {
    Configuration conf=new Configuration();
    AsyncDispatcher dispatcher=new AsyncDispatcher();
    Priority submittedPriority=Priority.newInstance(5);
    AppContext mockContext=mock(AppContext.class);
    when(mockContext.hasSuccessfullyUnregistered()).thenReturn(false);
    JobImpl job=createStubbedJob(conf,dispatcher,2,mockContext);
    JobId jobId=job.getID();
    job.handle(new JobEvent(jobId,JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(jobId));
    assertJobState(job,JobStateInternal.SETUP);
    job.setJobPriority(submittedPriority);
    Assert.assertEquals(submittedPriority,job.getReport().getJobPriority());
    job.handle(new JobSetupCompletedEvent(jobId));
    assertJobState(job,JobStateInternal.RUNNING);
    Priority updatedPriority=Priority.newInstance(8);
    job.setJobPriority(updatedPriority);
    assertJobState(job,JobStateInternal.RUNNING);
    Priority jobPriority=job.getReport().getJobPriority();
    Assert.assertNotNull(jobPriority);
    Assert.assertEquals(updatedPriority,jobPriority);
  }
  private static CommitterEventHandler createCommitterEventHandler(  Dispatcher dispatcher,  OutputCommitter committer){
    final SystemClock clock=SystemClock.getInstance();
    AppContext appContext=mock(AppContext.class);
    when(appContext.getEventHandler()).thenReturn(dispatcher.getEventHandler());
    when(appContext.getClock()).thenReturn(clock);
    RMHeartbeatHandler heartbeatHandler=new RMHeartbeatHandler(){
      @Override public long getLastHeartbeatTime(){
        return clock.getTime();
      }
      @Override public void runOnNextHeartbeat(      Runnable callback){
        callback.run();
      }
    }
;
    ApplicationAttemptId id=ApplicationAttemptId.fromString("appattempt_1234567890000_0001_0");
    when(appContext.getApplicationID()).thenReturn(id.getApplicationId());
    when(appContext.getApplicationAttemptId()).thenReturn(id);
    CommitterEventHandler handler=new CommitterEventHandler(appContext,committer,heartbeatHandler);
    dispatcher.register(CommitterEventType.class,handler);
    return handler;
  }
  private static StubbedJob createStubbedJob(  Configuration conf,  Dispatcher dispatcher,  int numSplits,  AppContext appContext){
    JobID jobID=JobID.forName("job_1234567890000_0001");
    JobId jobId=TypeConverter.toYarn(jobID);
    if (appContext == null) {
      appContext=mock(AppContext.class);
      when(appContext.hasSuccessfullyUnregistered()).thenReturn(true);
    }
    StubbedJob job=new StubbedJob(jobId,ApplicationAttemptId.newInstance(ApplicationId.newInstance(0,0),0),conf,dispatcher.getEventHandler(),true,"somebody",numSplits,appContext);
    dispatcher.register(JobEventType.class,job);
    EventHandler mockHandler=mock(EventHandler.class);
    dispatcher.register(TaskEventType.class,mockHandler);
    dispatcher.register(org.apache.hadoop.mapreduce.jobhistory.EventType.class,mockHandler);
    dispatcher.register(JobFinishEvent.Type.class,mockHandler);
    return job;
  }
  private static StubbedJob createRunningStubbedJob(  Configuration conf,  Dispatcher dispatcher,  int numSplits,  AppContext appContext){
    StubbedJob job=createStubbedJob(conf,dispatcher,numSplits,appContext);
    job.handle(new JobEvent(job.getID(),JobEventType.JOB_INIT));
    assertJobState(job,JobStateInternal.INITED);
    job.handle(new JobStartEvent(job.getID()));
    assertJobState(job,JobStateInternal.RUNNING);
    return job;
  }
  private static void completeJobTasks(  JobImpl job){
    int numMaps=job.getTotalMaps();
    for (int i=0; i < numMaps; ++i) {
      job.handle(new JobTaskEvent(MRBuilderUtils.newTaskId(job.getID(),1,TaskType.MAP),TaskState.SUCCEEDED));
      Assert.assertEquals(JobState.RUNNING,job.getState());
    }
    int numReduces=job.getTotalReduces();
    for (int i=0; i < numReduces; ++i) {
      job.handle(new JobTaskEvent(MRBuilderUtils.newTaskId(job.getID(),1,TaskType.MAP),TaskState.SUCCEEDED));
      Assert.assertEquals(JobState.RUNNING,job.getState());
    }
  }
  private static void assertJobState(  JobImpl job,  JobStateInternal state){
    int timeToWaitMsec=5 * 1000;
    while (timeToWaitMsec > 0 && job.getInternalState() != state) {
      try {
        Thread.sleep(10);
        timeToWaitMsec-=10;
      }
 catch (      InterruptedException e) {
        break;
      }
    }
    Assert.assertEquals(state,job.getInternalState());
  }
  private void createSpiedMapTasks(  Map<NodeReport,TaskId> nodeReportsToTaskIds,  Map<TaskId,Task> spiedTasks,  JobImpl job,  NodeState nodeState,  List<NodeReport> nodeReports){
    for (    Map.Entry<TaskId,Task> e : job.tasks.entrySet()) {
      TaskId taskId=e.getKey();
      Task task=e.getValue();
      if (taskId.getTaskType() == TaskType.MAP) {
        NodeId nodeId=mock(NodeId.class);
        TaskAttempt attempt=mock(TaskAttempt.class);
        when(attempt.getNodeId()).thenReturn(nodeId);
        TaskAttemptId attemptId=MRBuilderUtils.newTaskAttemptId(taskId,0);
        when(attempt.getID()).thenReturn(attemptId);
        Task spied=spy(task);
        Map<TaskAttemptId,TaskAttempt> attemptMap=new HashMap<>();
        attemptMap.put(attemptId,attempt);
        when(spied.getAttempts()).thenReturn(attemptMap);
        doReturn(attempt).when(spied).getAttempt(any(TaskAttemptId.class));
        spiedTasks.put(taskId,spied);
        NodeReport report=mock(NodeReport.class);
        when(report.getNodeState()).thenReturn(nodeState);
        when(report.getNodeId()).thenReturn(nodeId);
        nodeReports.add(report);
        nodeReportsToTaskIds.put(report,taskId);
      }
    }
  }
private static class JobSubmittedEventHandler implements EventHandler<JobHistoryEvent> {
    private String workflowId;
    private String workflowName;
    private String workflowNodeName;
    private String workflowAdjacencies;
    private String workflowTags;
    private Boolean assertBoolean;
    public JobSubmittedEventHandler(    String workflowId,    String workflowName,    String workflowNodeName,    String workflowAdjacencies,    String workflowTags){
      this.workflowId=workflowId;
      this.workflowName=workflowName;
      this.workflowNodeName=workflowNodeName;
      this.workflowAdjacencies=workflowAdjacencies;
      this.workflowTags=workflowTags;
      assertBoolean=null;
    }
    @Override public void handle(    JobHistoryEvent jhEvent){
      if (jhEvent.getType() != EventType.JOB_SUBMITTED) {
        return;
      }
      JobSubmittedEvent jsEvent=(JobSubmittedEvent)jhEvent.getHistoryEvent();
      if (!workflowId.equals(jsEvent.getWorkflowId())) {
        setAssertValue(false);
        return;
      }
      if (!workflowName.equals(jsEvent.getWorkflowName())) {
        setAssertValue(false);
        return;
      }
      if (!workflowNodeName.equals(jsEvent.getWorkflowNodeName())) {
        setAssertValue(false);
        return;
      }
      String[] wrkflowAdj=workflowAdjacencies.split(" ");
      String[] jswrkflowAdj=jsEvent.getWorkflowAdjacencies().split(" ");
      Arrays.sort(wrkflowAdj);
      Arrays.sort(jswrkflowAdj);
      if (!Arrays.equals(wrkflowAdj,jswrkflowAdj)) {
        setAssertValue(false);
        return;
      }
      if (!workflowTags.equals(jsEvent.getWorkflowTags())) {
        setAssertValue(false);
        return;
      }
      setAssertValue(true);
    }
    private synchronized void setAssertValue(    Boolean bool){
      assertBoolean=bool;
      notify();
    }
    public synchronized boolean getAssertValue() throws InterruptedException {
      while (assertBoolean == null) {
        wait();
      }
      return assertBoolean;
    }
  }
private static class StubbedJob extends JobImpl {
    private final InitTransition initTransition;
    StateMachineFactory<JobImpl,JobStateInternal,JobEventType,JobEvent> localFactory;
    private final StateMachine<JobStateInternal,JobEventType,JobEvent> localStateMachine;
    @Override protected StateMachine<JobStateInternal,JobEventType,JobEvent> getStateMachine(){
      return localStateMachine;
    }
    public StubbedJob(    JobId jobId,    ApplicationAttemptId applicationAttemptId,    Configuration conf,    EventHandler eventHandler,    boolean newApiCommitter,    String user,    int numSplits,    AppContext appContext){
      super(jobId,applicationAttemptId,conf,eventHandler,null,new JobTokenSecretManager(),new Credentials(),SystemClock.getInstance(),Collections.<TaskId,TaskInfo>emptyMap(),MRAppMetrics.create(),null,newApiCommitter,user,System.currentTimeMillis(),null,appContext,null,null);
      initTransition=getInitTransition(numSplits);
      localFactory=stateMachineFactory.addTransition(JobStateInternal.NEW,EnumSet.of(JobStateInternal.INITED,JobStateInternal.FAILED),JobEventType.JOB_INIT,initTransition);
      localStateMachine=localFactory.make(this);
    }
  }
private static class StubbedOutputCommitter extends OutputCommitter {
    public StubbedOutputCommitter(){
      super();
    }
    @Override public void setupJob(    JobContext jobContext) throws IOException {
    }
    @Override public void setupTask(    TaskAttemptContext taskContext) throws IOException {
    }
    @Override public boolean needsTaskCommit(    TaskAttemptContext taskContext) throws IOException {
      return false;
    }
    @Override public void commitTask(    TaskAttemptContext taskContext) throws IOException {
    }
    @Override public void abortTask(    TaskAttemptContext taskContext) throws IOException {
    }
  }
private static class TestingOutputCommitter extends StubbedOutputCommitter {
    CyclicBarrier syncBarrier;
    boolean shouldSucceed;
    public TestingOutputCommitter(    CyclicBarrier syncBarrier,    boolean shouldSucceed){
      super();
      this.syncBarrier=syncBarrier;
      this.shouldSucceed=shouldSucceed;
    }
    @Override public void commitJob(    JobContext jobContext) throws IOException {
      try {
        syncBarrier.await();
      }
 catch (      BrokenBarrierException e) {
      }
catch (      InterruptedException e) {
      }
      if (!shouldSucceed) {
        throw new IOException("forced failure");
      }
    }
  }
private static class WaitingOutputCommitter extends TestingOutputCommitter {
    public WaitingOutputCommitter(    CyclicBarrier syncBarrier,    boolean shouldSucceed){
      super(syncBarrier,shouldSucceed);
    }
    @Override public void commitJob(    JobContext jobContext) throws IOException {
      try {
        syncBarrier.await();
      }
 catch (      BrokenBarrierException e) {
      }
catch (      InterruptedException e) {
      }
      while (!Thread.interrupted()) {
        try {
synchronized (this) {
            wait();
          }
        }
 catch (        InterruptedException e) {
          break;
        }
      }
    }
  }
}
