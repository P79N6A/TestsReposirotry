public class TestClientRedirect {
static {
    DefaultMetricsSystem.setMiniClusterMode(true);
  }
  private static final Logger LOG=LoggerFactory.getLogger(TestClientRedirect.class);
  private static final String RMADDRESS="0.0.0.0:8054";
  private static final RecordFactory recordFactory=RecordFactoryProvider.getRecordFactory(null);
  private static final String AMHOSTADDRESS="0.0.0.0:10020";
  private static final String HSHOSTADDRESS="0.0.0.0:10021";
  private volatile boolean amContact=false;
  private volatile boolean hsContact=false;
  private volatile boolean amRunning=false;
  private volatile boolean amRestarting=false;
  @Test public void testRedirect() throws Exception {
    Configuration conf=new YarnConfiguration();
    conf.set(MRConfig.FRAMEWORK_NAME,MRConfig.YARN_FRAMEWORK_NAME);
    conf.set(YarnConfiguration.RM_ADDRESS,RMADDRESS);
    conf.set(JHAdminConfig.MR_HISTORY_ADDRESS,HSHOSTADDRESS);
    RMService rmService=new RMService("test");
    rmService.init(conf);
    rmService.start();
    AMService amService=new AMService();
    amService.init(conf);
    amService.start(conf);
    HistoryService historyService=new HistoryService();
    historyService.init(conf);
    historyService.start(conf);
    LOG.info("services started");
    Cluster cluster=new Cluster(conf);
    org.apache.hadoop.mapreduce.JobID jobID=new org.apache.hadoop.mapred.JobID("201103121733",1);
    org.apache.hadoop.mapreduce.Counters counters=cluster.getJob(jobID).getCounters();
    validateCounters(counters);
    Assert.assertTrue(amContact);
    LOG.info("Sleeping for 5 seconds before stop for" + " the client socket to not get EOF immediately..");
    Thread.sleep(5000);
    amService.stop();
    LOG.info("Sleeping for 5 seconds after stop for" + " the server to exit cleanly..");
    Thread.sleep(5000);
    amRestarting=true;
    counters=cluster.getJob(jobID).getCounters();
    Assert.assertEquals(0,counters.countCounters());
    Job job=cluster.getJob(jobID);
    org.apache.hadoop.mapreduce.TaskID taskId=new org.apache.hadoop.mapreduce.TaskID(jobID,TaskType.MAP,0);
    TaskAttemptID tId=new TaskAttemptID(taskId,0);
    job.killJob();
    job.killTask(tId);
    job.failTask(tId);
    job.getTaskCompletionEvents(0,100);
    job.getStatus();
    job.getTaskDiagnostics(tId);
    job.getTaskReports(TaskType.MAP);
    job.getTrackingURL();
    amRestarting=false;
    amService=new AMService();
    amService.init(conf);
    amService.start(conf);
    amContact=false;
    counters=cluster.getJob(jobID).getCounters();
    validateCounters(counters);
    Assert.assertTrue(amContact);
    amService.stop();
    counters=cluster.getJob(jobID).getCounters();
    validateCounters(counters);
    Assert.assertTrue(hsContact);
    rmService.stop();
    historyService.stop();
  }
  private void validateCounters(  org.apache.hadoop.mapreduce.Counters counters){
    Iterator<org.apache.hadoop.mapreduce.CounterGroup> it=counters.iterator();
    while (it.hasNext()) {
      org.apache.hadoop.mapreduce.CounterGroup group=it.next();
      LOG.info("Group " + group.getDisplayName());
      Iterator<org.apache.hadoop.mapreduce.Counter> itc=group.iterator();
      while (itc.hasNext()) {
        LOG.info("Counter is " + itc.next().getDisplayName());
      }
    }
    Assert.assertEquals(1,counters.countCounters());
  }
class RMService extends AbstractService implements ApplicationClientProtocol {
    private String clientServiceBindAddress;
    InetSocketAddress clientBindAddress;
    private Server server;
    public RMService(    String name){
      super(name);
    }
    @Override protected void serviceInit(    Configuration conf) throws Exception {
      clientServiceBindAddress=RMADDRESS;
      clientBindAddress=NetUtils.createSocketAddr(clientServiceBindAddress);
      super.serviceInit(conf);
    }
    @Override protected void serviceStart() throws Exception {
      YarnRPC rpc=YarnRPC.create(getConfig());
      Configuration clientServerConf=new Configuration(getConfig());
      this.server=rpc.getServer(ApplicationClientProtocol.class,this,clientBindAddress,clientServerConf,null,1);
      this.server.start();
      super.serviceStart();
    }
    @Override public GetNewApplicationResponse getNewApplication(    GetNewApplicationRequest request) throws IOException {
      return null;
    }
    @Override public GetApplicationReportResponse getApplicationReport(    GetApplicationReportRequest request) throws IOException {
      ApplicationId applicationId=request.getApplicationId();
      ApplicationReport application=recordFactory.newRecordInstance(ApplicationReport.class);
      application.setApplicationId(applicationId);
      application.setFinalApplicationStatus(FinalApplicationStatus.UNDEFINED);
      if (amRunning) {
        application.setYarnApplicationState(YarnApplicationState.RUNNING);
      }
 else       if (amRestarting) {
        application.setYarnApplicationState(YarnApplicationState.SUBMITTED);
      }
 else {
        application.setYarnApplicationState(YarnApplicationState.FINISHED);
        application.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);
      }
      String[] split=AMHOSTADDRESS.split(":");
      application.setHost(split[0]);
      application.setRpcPort(Integer.parseInt(split[1]));
      application.setUser("TestClientRedirect-user");
      application.setName("N/A");
      application.setQueue("N/A");
      application.setStartTime(0);
      application.setFinishTime(0);
      application.setTrackingUrl("N/A");
      application.setDiagnostics("N/A");
      GetApplicationReportResponse response=recordFactory.newRecordInstance(GetApplicationReportResponse.class);
      response.setApplicationReport(application);
      return response;
    }
    @Override public SubmitApplicationResponse submitApplication(    SubmitApplicationRequest request) throws IOException {
      throw new IOException("Test");
    }
    @Override public FailApplicationAttemptResponse failApplicationAttempt(    FailApplicationAttemptRequest request) throws IOException {
      return recordFactory.newRecordInstance(FailApplicationAttemptResponse.class);
    }
    @Override public KillApplicationResponse forceKillApplication(    KillApplicationRequest request) throws IOException {
      return KillApplicationResponse.newInstance(true);
    }
    @Override public GetClusterMetricsResponse getClusterMetrics(    GetClusterMetricsRequest request) throws IOException {
      return null;
    }
    @Override public GetApplicationsResponse getApplications(    GetApplicationsRequest request) throws IOException {
      return null;
    }
    @Override public GetClusterNodesResponse getClusterNodes(    GetClusterNodesRequest request) throws IOException {
      return null;
    }
    @Override public GetQueueInfoResponse getQueueInfo(    GetQueueInfoRequest request) throws IOException {
      return null;
    }
    @Override public GetQueueUserAclsInfoResponse getQueueUserAcls(    GetQueueUserAclsInfoRequest request) throws IOException {
      return null;
    }
    @Override public GetDelegationTokenResponse getDelegationToken(    GetDelegationTokenRequest request) throws IOException {
      return null;
    }
    @Override public RenewDelegationTokenResponse renewDelegationToken(    RenewDelegationTokenRequest request) throws IOException {
      return null;
    }
    @Override public CancelDelegationTokenResponse cancelDelegationToken(    CancelDelegationTokenRequest request) throws IOException {
      return null;
    }
    @Override public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(    MoveApplicationAcrossQueuesRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetApplicationAttemptReportResponse getApplicationAttemptReport(    GetApplicationAttemptReportRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetApplicationAttemptsResponse getApplicationAttempts(    GetApplicationAttemptsRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetContainerReportResponse getContainerReport(    GetContainerReportRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetContainersResponse getContainers(    GetContainersRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetNewReservationResponse getNewReservation(    GetNewReservationRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public ReservationSubmissionResponse submitReservation(    ReservationSubmissionRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public ReservationUpdateResponse updateReservation(    ReservationUpdateRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public ReservationDeleteResponse deleteReservation(    ReservationDeleteRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public ReservationListResponse listReservations(    ReservationListRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetNodesToLabelsResponse getNodeToLabels(    GetNodesToLabelsRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetClusterNodeLabelsResponse getClusterNodeLabels(    GetClusterNodeLabelsRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetLabelsToNodesResponse getLabelsToNodes(    GetLabelsToNodesRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public UpdateApplicationPriorityResponse updateApplicationPriority(    UpdateApplicationPriorityRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public SignalContainerResponse signalToContainer(    SignalContainerRequest request) throws IOException {
      return null;
    }
    @Override public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(    UpdateApplicationTimeoutsRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetAllResourceProfilesResponse getResourceProfiles(    GetAllResourceProfilesRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetResourceProfileResponse getResourceProfile(    GetResourceProfileRequest request) throws YarnException, IOException {
      return null;
    }
    @Override public GetAllResourceTypeInfoResponse getResourceTypeInfo(    GetAllResourceTypeInfoRequest request) throws YarnException, IOException {
      return null;
    }
  }
class HistoryService extends AMService implements HSClientProtocol {
    public HistoryService(){
      super(HSHOSTADDRESS);
      this.protocol=HSClientProtocol.class;
    }
    @Override public GetCountersResponse getCounters(    GetCountersRequest request) throws IOException {
      hsContact=true;
      Counters counters=getMyCounters();
      GetCountersResponse response=recordFactory.newRecordInstance(GetCountersResponse.class);
      response.setCounters(counters);
      return response;
    }
  }
class AMService extends AbstractService implements MRClientProtocol {
    protected Class<?> protocol;
    private InetSocketAddress bindAddress;
    private Server server;
    private final String hostAddress;
    public AMService(){
      this(AMHOSTADDRESS);
    }
    @Override public InetSocketAddress getConnectAddress(){
      return bindAddress;
    }
    public AMService(    String hostAddress){
      super("AMService");
      this.protocol=MRClientProtocol.class;
      this.hostAddress=hostAddress;
    }
    public void start(    Configuration conf){
      YarnRPC rpc=YarnRPC.create(conf);
      InetSocketAddress address=NetUtils.createSocketAddr(hostAddress);
      InetAddress hostNameResolved=null;
      try {
        address.getAddress();
        hostNameResolved=InetAddress.getLocalHost();
      }
 catch (      UnknownHostException e) {
        throw new YarnRuntimeException(e);
      }
      server=rpc.getServer(protocol,this,address,conf,null,1);
      server.start();
      this.bindAddress=NetUtils.getConnectAddress(server);
      super.start();
      amRunning=true;
    }
    @Override protected void serviceStop() throws Exception {
      if (server != null) {
        server.stop();
      }
      super.serviceStop();
      amRunning=false;
    }
    @Override public GetCountersResponse getCounters(    GetCountersRequest request) throws IOException {
      JobId jobID=request.getJobId();
      amContact=true;
      Counters counters=getMyCounters();
      GetCountersResponse response=recordFactory.newRecordInstance(GetCountersResponse.class);
      response.setCounters(counters);
      return response;
    }
    @Override public GetJobReportResponse getJobReport(    GetJobReportRequest request) throws IOException {
      amContact=true;
      JobReport jobReport=recordFactory.newRecordInstance(JobReport.class);
      jobReport.setJobId(request.getJobId());
      jobReport.setJobState(JobState.RUNNING);
      jobReport.setJobName("TestClientRedirect-jobname");
      jobReport.setUser("TestClientRedirect-user");
      jobReport.setStartTime(0L);
      jobReport.setFinishTime(1L);
      GetJobReportResponse response=recordFactory.newRecordInstance(GetJobReportResponse.class);
      response.setJobReport(jobReport);
      return response;
    }
    @Override public GetTaskReportResponse getTaskReport(    GetTaskReportRequest request) throws IOException {
      return null;
    }
    @Override public GetTaskAttemptReportResponse getTaskAttemptReport(    GetTaskAttemptReportRequest request) throws IOException {
      return null;
    }
    @Override public GetTaskAttemptCompletionEventsResponse getTaskAttemptCompletionEvents(    GetTaskAttemptCompletionEventsRequest request) throws IOException {
      return null;
    }
    @Override public GetTaskReportsResponse getTaskReports(    GetTaskReportsRequest request) throws IOException {
      return null;
    }
    @Override public GetDiagnosticsResponse getDiagnostics(    GetDiagnosticsRequest request) throws IOException {
      return null;
    }
    @Override public KillJobResponse killJob(    KillJobRequest request) throws IOException {
      return recordFactory.newRecordInstance(KillJobResponse.class);
    }
    @Override public KillTaskResponse killTask(    KillTaskRequest request) throws IOException {
      return null;
    }
    @Override public KillTaskAttemptResponse killTaskAttempt(    KillTaskAttemptRequest request) throws IOException {
      return null;
    }
    @Override public FailTaskAttemptResponse failTaskAttempt(    FailTaskAttemptRequest request) throws IOException {
      return null;
    }
    @Override public org.apache.hadoop.mapreduce.v2.api.protocolrecords.GetDelegationTokenResponse getDelegationToken(    org.apache.hadoop.mapreduce.v2.api.protocolrecords.GetDelegationTokenRequest request) throws IOException {
      return null;
    }
    @Override public org.apache.hadoop.mapreduce.v2.api.protocolrecords.RenewDelegationTokenResponse renewDelegationToken(    org.apache.hadoop.mapreduce.v2.api.protocolrecords.RenewDelegationTokenRequest request) throws IOException {
      return null;
    }
    @Override public org.apache.hadoop.mapreduce.v2.api.protocolrecords.CancelDelegationTokenResponse cancelDelegationToken(    org.apache.hadoop.mapreduce.v2.api.protocolrecords.CancelDelegationTokenRequest request) throws IOException {
      return null;
    }
  }
  static Counters getMyCounters(){
    Counter counter=recordFactory.newRecordInstance(Counter.class);
    counter.setName("Mycounter");
    counter.setDisplayName("My counter display name");
    counter.setValue(12345);
    CounterGroup group=recordFactory.newRecordInstance(CounterGroup.class);
    group.setName("MyGroup");
    group.setDisplayName("My groupd display name");
    group.setCounter("myCounter",counter);
    Counters counters=recordFactory.newRecordInstance(Counters.class);
    counters.setCounterGroup("myGroupd",group);
    return counters;
  }
}
