/** 
 * This test provokes partial writes in the server, which is  serving multiple clients.
 */
public class TestIPCServerResponder {
  public static final Logger LOG=LoggerFactory.getLogger(TestIPCServerResponder.class);
  private static Configuration conf=new Configuration();
  private static final Random RANDOM=new Random();
  private static final String ADDRESS="0.0.0.0";
  private static final int BYTE_COUNT=1024;
  private static final byte[] BYTES=new byte[BYTE_COUNT];
static {
    for (int i=0; i < BYTE_COUNT; i++)     BYTES[i]=(byte)('a' + (i % 26));
  }
  static Writable call(  Client client,  Writable param,  InetSocketAddress address) throws IOException {
    final ConnectionId remoteId=ConnectionId.getConnectionId(address,null,null,0,null,conf);
    return client.call(RpcKind.RPC_BUILTIN,param,remoteId,RPC.RPC_SERVICE_CLASS_DEFAULT,null);
  }
private static class TestServer extends Server {
    private boolean sleep;
    public TestServer(    final int handlerCount,    final boolean sleep) throws IOException {
      super(ADDRESS,0,BytesWritable.class,handlerCount,conf);
      this.setSocketSendBufSize(BYTE_COUNT / 2);
      this.sleep=sleep;
    }
    @Override public Writable call(    RPC.RpcKind rpcKind,    String protocol,    Writable param,    long receiveTime) throws IOException {
      if (sleep) {
        try {
          Thread.sleep(RANDOM.nextInt(20));
        }
 catch (        InterruptedException e) {
        }
      }
      return param;
    }
  }
private static class Caller extends Thread {
    private Client client;
    private int count;
    private InetSocketAddress address;
    private boolean failed;
    public Caller(    final Client client,    final InetSocketAddress address,    final int count){
      this.client=client;
      this.address=address;
      this.count=count;
    }
    @Override public void run(){
      for (int i=0; i < count; i++) {
        try {
          int byteSize=RANDOM.nextInt(BYTE_COUNT);
          byte[] bytes=new byte[byteSize];
          System.arraycopy(BYTES,0,bytes,0,byteSize);
          Writable param=new BytesWritable(bytes);
          call(client,param,address);
          Thread.sleep(RANDOM.nextInt(20));
        }
 catch (        Exception e) {
          LOG.error("Caught Exception",e);
          failed=true;
        }
      }
    }
  }
  @Test public void testResponseBuffer() throws IOException, InterruptedException {
    Server.INITIAL_RESP_BUF_SIZE=1;
    conf.setInt(CommonConfigurationKeys.IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY,1);
    checkServerResponder(1,true,1,1,5);
    conf=new Configuration();
  }
  @Test public void testServerResponder() throws IOException, InterruptedException {
    checkServerResponder(10,true,1,10,200);
  }
  public void checkServerResponder(  final int handlerCount,  final boolean handlerSleep,  final int clientCount,  final int callerCount,  final int callCount) throws IOException, InterruptedException {
    Server server=new TestServer(handlerCount,handlerSleep);
    server.start();
    InetSocketAddress address=NetUtils.getConnectAddress(server);
    Client[] clients=new Client[clientCount];
    for (int i=0; i < clientCount; i++) {
      clients[i]=new Client(BytesWritable.class,conf);
    }
    Caller[] callers=new Caller[callerCount];
    for (int i=0; i < callerCount; i++) {
      callers[i]=new Caller(clients[i % clientCount],address,callCount);
      callers[i].start();
    }
    for (int i=0; i < callerCount; i++) {
      callers[i].join();
      assertFalse(callers[i].failed);
    }
    for (int i=0; i < clientCount; i++) {
      clients[i].stop();
    }
    server.stop();
  }
  @Test(timeout=10000) public void testDeferResponse() throws IOException, InterruptedException {
    final AtomicReference<Call> deferredCall=new AtomicReference<Call>();
    final AtomicInteger count=new AtomicInteger();
    final Writable wait0=new IntWritable(0);
    final Writable wait1=new IntWritable(1);
    final Writable wait2=new IntWritable(2);
    Server server=new Server(ADDRESS,0,IntWritable.class,1,conf){
      @Override public Writable call(      RPC.RpcKind rpcKind,      String protocol,      Writable waitCount,      long receiveTime) throws IOException {
        Call call=Server.getCurCall().get();
        int wait=((IntWritable)waitCount).get();
        while (wait-- > 0) {
          call.postponeResponse();
          deferredCall.set(call);
        }
        return new IntWritable(count.getAndIncrement());
      }
    }
;
    server.start();
    final InetSocketAddress address=NetUtils.getConnectAddress(server);
    final Client client=new Client(IntWritable.class,conf);
    Call[] waitingCalls=new Call[2];
    assertEquals(0,((IntWritable)call(client,wait0,address)).get());
    assertEquals(1,((IntWritable)call(client,wait0,address)).get());
    final ExecutorService exec=Executors.newCachedThreadPool();
    Future<Integer> future1=exec.submit(new Callable<Integer>(){
      @Override public Integer call() throws IOException {
        return ((IntWritable)TestIPCServerResponder.call(client,wait1,address)).get();
      }
    }
);
    try {
      future1.get(1,TimeUnit.SECONDS);
      Assert.fail("ipc shouldn't have responded");
    }
 catch (    TimeoutException te) {
    }
catch (    Exception ex) {
      Assert.fail("unexpected exception:" + ex);
    }
    assertFalse(future1.isDone());
    waitingCalls[0]=deferredCall.get();
    assertNotNull(waitingCalls[0]);
    assertEquals(3,((IntWritable)call(client,wait0,address)).get());
    Future<Integer> future2=exec.submit(new Callable<Integer>(){
      @Override public Integer call() throws IOException {
        return ((IntWritable)TestIPCServerResponder.call(client,wait2,address)).get();
      }
    }
);
    try {
      future2.get(1,TimeUnit.SECONDS);
      Assert.fail("ipc shouldn't have responded");
    }
 catch (    TimeoutException te) {
    }
catch (    Exception ex) {
      Assert.fail("unexpected exception:" + ex);
    }
    assertFalse(future2.isDone());
    waitingCalls[1]=deferredCall.get();
    assertNotNull(waitingCalls[1]);
    assertFalse(future1.isDone());
    assertFalse(future2.isDone());
    waitingCalls[0].sendResponse();
    waitingCalls[1].sendResponse();
    try {
      int val=future1.get(1,TimeUnit.SECONDS);
      assertEquals(2,val);
    }
 catch (    Exception ex) {
      Assert.fail("unexpected exception:" + ex);
    }
    try {
      future2.get(1,TimeUnit.SECONDS);
      Assert.fail("ipc shouldn't have responded");
    }
 catch (    TimeoutException te) {
    }
catch (    Exception ex) {
      Assert.fail("unexpected exception:" + ex);
    }
    assertFalse(future2.isDone());
    assertEquals(5,((IntWritable)call(client,wait0,address)).get());
    waitingCalls[1].sendResponse();
    try {
      int val=future2.get(1,TimeUnit.SECONDS);
      assertEquals(4,val);
    }
 catch (    Exception ex) {
      Assert.fail("unexpected exception:" + ex);
    }
    server.stop();
  }
}
