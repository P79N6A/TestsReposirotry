/** 
 * Test partitioned uploads. This is done by forcing a very small partition size and verifying that it is picked up.
 */
public class TestSwiftFileSystemPartitionedUploads extends SwiftFileSystemBaseTest {
  public static final String WRONG_PARTITION_COUNT="wrong number of partitions written into ";
  public static final int PART_SIZE=1;
  public static final int PART_SIZE_BYTES=PART_SIZE * 1024;
  public static final int BLOCK_SIZE=1024;
  private URI uri;
  @Override protected Configuration createConfiguration(){
    Configuration conf=super.createConfiguration();
    conf.setInt(SwiftProtocolConstants.SWIFT_PARTITION_SIZE,PART_SIZE);
    return conf;
  }
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testPartitionPropertyPropagatesToConf() throws Throwable {
    assertEquals(1,getConf().getInt(SwiftProtocolConstants.SWIFT_PARTITION_SIZE,0));
  }
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testPartionPropertyPropagatesToStore() throws Throwable {
    assertEquals(1,fs.getStore().getPartsizeKB());
  }
  /** 
 * tests functionality for big files ( > 5Gb) upload
 */
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testFilePartUpload() throws Throwable {
    final Path path=new Path("/test/testFilePartUpload");
    int len=8192;
    final byte[] src=SwiftTestUtils.dataset(len,32,144);
    FSDataOutputStream out=fs.create(path,false,getBufferSize(),(short)1,BLOCK_SIZE);
    try {
      int totalPartitionsToWrite=len / PART_SIZE_BYTES;
      assertPartitionsWritten("Startup",out,0);
      int firstWriteLen=2048;
      out.write(src,0,firstWriteLen);
      long expected=getExpectedPartitionsWritten(firstWriteLen,PART_SIZE_BYTES,false);
      SwiftUtils.debug(LOG,"First write: predict %d partitions written",expected);
      assertPartitionsWritten("First write completed",out,expected);
      int remainder=len - firstWriteLen;
      SwiftUtils.debug(LOG,"remainder: writing: %d bytes",remainder);
      out.write(src,firstWriteLen,remainder);
      expected=getExpectedPartitionsWritten(len,PART_SIZE_BYTES,false);
      assertPartitionsWritten("Remaining data",out,expected);
      out.close();
      expected=getExpectedPartitionsWritten(len,PART_SIZE_BYTES,true);
      assertPartitionsWritten("Stream closed",out,expected);
      Header[] headers=fs.getStore().getObjectHeaders(path,true);
      for (      Header header : headers) {
        LOG.info(header.toString());
      }
      byte[] dest=readDataset(fs,path,len);
      LOG.info("Read dataset from " + path + ": data length ="+ len);
      SwiftTestUtils.compareByteArrays(src,dest,len);
      FileStatus status;
      final Path qualifiedPath=fs.makeQualified(path);
      status=fs.getFileStatus(qualifiedPath);
      BlockLocation[] locations=fs.getFileBlockLocations(status,0,len);
      assertNotNull("Null getFileBlockLocations()",locations);
      assertTrue("empty array returned for getFileBlockLocations()",locations.length > 0);
      try {
        validatePathLen(path,len);
      }
 catch (      AssertionError e) {
        throw new AssumptionViolatedException(e,null);
      }
    }
  finally {
      IOUtils.closeStream(out);
    }
  }
  /** 
 * tests functionality for big files ( > 5Gb) upload
 */
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testFilePartUploadNoLengthCheck() throws IOException, URISyntaxException {
    final Path path=new Path("/test/testFilePartUploadLengthCheck");
    int len=8192;
    final byte[] src=SwiftTestUtils.dataset(len,32,144);
    FSDataOutputStream out=fs.create(path,false,getBufferSize(),(short)1,BLOCK_SIZE);
    try {
      int totalPartitionsToWrite=len / PART_SIZE_BYTES;
      assertPartitionsWritten("Startup",out,0);
      int firstWriteLen=2048;
      out.write(src,0,firstWriteLen);
      long expected=getExpectedPartitionsWritten(firstWriteLen,PART_SIZE_BYTES,false);
      SwiftUtils.debug(LOG,"First write: predict %d partitions written",expected);
      assertPartitionsWritten("First write completed",out,expected);
      int remainder=len - firstWriteLen;
      SwiftUtils.debug(LOG,"remainder: writing: %d bytes",remainder);
      out.write(src,firstWriteLen,remainder);
      expected=getExpectedPartitionsWritten(len,PART_SIZE_BYTES,false);
      assertPartitionsWritten("Remaining data",out,expected);
      out.close();
      expected=getExpectedPartitionsWritten(len,PART_SIZE_BYTES,true);
      assertPartitionsWritten("Stream closed",out,expected);
      Header[] headers=fs.getStore().getObjectHeaders(path,true);
      for (      Header header : headers) {
        LOG.info(header.toString());
      }
      byte[] dest=readDataset(fs,path,len);
      LOG.info("Read dataset from " + path + ": data length ="+ len);
      SwiftTestUtils.compareByteArrays(src,dest,len);
      FileStatus status=fs.getFileStatus(path);
      BlockLocation[] locations=fs.getFileBlockLocations(status,0,len);
      assertNotNull("Null getFileBlockLocations()",locations);
      assertTrue("empty array returned for getFileBlockLocations()",locations.length > 0);
    }
  finally {
      IOUtils.closeStream(out);
    }
  }
  private FileStatus validatePathLen(  Path path,  int len) throws IOException {
    final Path qualifiedPath=fs.makeQualified(path);
    FileStatus[] parentDirListing=fs.listStatus(qualifiedPath.getParent());
    StringBuilder listing=lsToString(parentDirListing);
    String parentDirLS=listing.toString();
    FileStatus status=fs.getFileStatus(qualifiedPath);
    assertEquals("Length of written file " + qualifiedPath + " from status check "+ status+ " in dir "+ listing,len,status.getLen());
    String fileInfo=qualifiedPath + "  " + status;
    assertFalse("File claims to be a directory " + fileInfo,status.isDirectory());
    FileStatus listedFileStat=resolveChild(parentDirListing,qualifiedPath);
    assertNotNull("Did not find " + path + " in "+ parentDirLS,listedFileStat);
    assertEquals("Wrong len for " + path + " in listing "+ parentDirLS,len,listedFileStat.getLen());
    listedFileStat.toString();
    return status;
  }
  private FileStatus resolveChild(  FileStatus[] parentDirListing,  Path childPath){
    FileStatus listedFileStat=null;
    for (    FileStatus stat : parentDirListing) {
      if (stat.getPath().equals(childPath)) {
        listedFileStat=stat;
      }
    }
    return listedFileStat;
  }
  private StringBuilder lsToString(  FileStatus[] parentDirListing){
    StringBuilder listing=new StringBuilder();
    for (    FileStatus stat : parentDirListing) {
      listing.append(stat).append("\n");
    }
    return listing;
  }
  /** 
 * Calculate the #of partitions expected from the upload
 * @param uploaded number of bytes uploaded
 * @param partSizeBytes the partition size
 * @param closed whether or not the stream has closed
 * @return the expected number of partitions, for use in assertions.
 */
  private int getExpectedPartitionsWritten(  long uploaded,  int partSizeBytes,  boolean closed){
    int partitions=(int)(uploaded / partSizeBytes);
    int remainder=(int)(uploaded % partSizeBytes);
    if (closed) {
      return partitions + ((remainder > 0) ? 1 : 0);
    }
 else {
      return partitions;
    }
  }
  private int getBufferSize(){
    return fs.getConf().getInt("io.file.buffer.size",4096);
  }
  /** 
 * Test sticks up a very large partitioned file and verifies that it comes back unchanged.
 * @throws Throwable
 */
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testManyPartitionedFile() throws Throwable {
    final Path path=new Path("/test/testManyPartitionedFile");
    int len=PART_SIZE_BYTES * 15;
    final byte[] src=SwiftTestUtils.dataset(len,32,144);
    FSDataOutputStream out=fs.create(path,false,getBufferSize(),(short)1,BLOCK_SIZE);
    out.write(src,0,src.length);
    int expected=getExpectedPartitionsWritten(len,PART_SIZE_BYTES,true);
    out.close();
    assertPartitionsWritten("write completed",out,expected);
    assertEquals("too few bytes written",len,SwiftNativeFileSystem.getBytesWritten(out));
    assertEquals("too few bytes uploaded",len,SwiftNativeFileSystem.getBytesUploaded(out));
    byte[] dest=readDataset(fs,path,len);
    SwiftTestUtils.compareByteArrays(src,dest,len);
    FileStatus[] stats=fs.listStatus(path);
    assertEquals("wrong entry count in " + SwiftTestUtils.dumpStats(path.toString(),stats),expected,stats.length);
  }
  /** 
 * Test that when a partitioned file is overwritten by a smaller one, all the old partitioned files go away
 * @throws Throwable
 */
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testOverwritePartitionedFile() throws Throwable {
    final Path path=new Path("/test/testOverwritePartitionedFile");
    final int len1=8192;
    final byte[] src1=SwiftTestUtils.dataset(len1,'A','Z');
    FSDataOutputStream out=fs.create(path,false,getBufferSize(),(short)1,1024);
    out.write(src1,0,len1);
    out.close();
    long expected=getExpectedPartitionsWritten(len1,PART_SIZE_BYTES,false);
    assertPartitionsWritten("initial upload",out,expected);
    assertExists("Exists",path);
    FileStatus status=fs.getFileStatus(path);
    assertEquals("Length",len1,status.getLen());
    final int len2=4095;
    final byte[] src2=SwiftTestUtils.dataset(len2,'a','z');
    out=fs.create(path,true,getBufferSize(),(short)1,1024);
    out.write(src2,0,len2);
    out.close();
    status=fs.getFileStatus(path);
    assertEquals("Length",len2,status.getLen());
    byte[] dest=readDataset(fs,path,len2);
    SwiftTestUtils.compareByteArrays(src2,dest,len2);
  }
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testDeleteSmallPartitionedFile() throws Throwable {
    final Path path=new Path("/test/testDeleteSmallPartitionedFile");
    final int len1=1024;
    final byte[] src1=SwiftTestUtils.dataset(len1,'A','Z');
    SwiftTestUtils.writeDataset(fs,path,src1,len1,1024,false);
    assertExists("Exists",path);
    Path part_0001=new Path(path,SwiftUtils.partitionFilenameFromNumber(1));
    Path part_0002=new Path(path,SwiftUtils.partitionFilenameFromNumber(2));
    String ls=SwiftTestUtils.ls(fs,path);
    assertExists("Partition 0001 Exists in " + ls,part_0001);
    assertPathDoesNotExist("partition 0002 found under " + ls,part_0002);
    assertExists("Partition 0002 Exists in " + ls,part_0001);
    fs.delete(path,false);
    assertPathDoesNotExist("deleted file still there",path);
    ls=SwiftTestUtils.ls(fs,path);
    assertPathDoesNotExist("partition 0001 file still under " + ls,part_0001);
  }
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testDeletePartitionedFile() throws Throwable {
    final Path path=new Path("/test/testDeletePartitionedFile");
    SwiftTestUtils.writeDataset(fs,path,data,data.length,1024,false);
    assertExists("Exists",path);
    Path part_0001=new Path(path,SwiftUtils.partitionFilenameFromNumber(1));
    Path part_0002=new Path(path,SwiftUtils.partitionFilenameFromNumber(2));
    String ls=SwiftTestUtils.ls(fs,path);
    assertExists("Partition 0001 Exists in " + ls,part_0001);
    assertExists("Partition 0002 Exists in " + ls,part_0001);
    fs.delete(path,false);
    assertPathDoesNotExist("deleted file still there",path);
    ls=SwiftTestUtils.ls(fs,path);
    assertPathDoesNotExist("partition 0001 file still under " + ls,part_0001);
    assertPathDoesNotExist("partition 0002 file still under " + ls,part_0002);
  }
  @Test(timeout=SWIFT_BULK_IO_TEST_TIMEOUT) public void testRenamePartitionedFile() throws Throwable {
    Path src=new Path("/test/testRenamePartitionedFileSrc");
    int len=data.length;
    SwiftTestUtils.writeDataset(fs,src,data,len,1024,false);
    assertExists("Exists",src);
    String partOneName=SwiftUtils.partitionFilenameFromNumber(1);
    Path srcPart=new Path(src,partOneName);
    Path dest=new Path("/test/testRenamePartitionedFileDest");
    Path destPart=new Path(src,partOneName);
    assertExists("Partition Exists",srcPart);
    fs.rename(src,dest);
    assertPathExists(fs,"dest file missing",dest);
    FileStatus status=fs.getFileStatus(dest);
    assertEquals("Length of renamed file is wrong",len,status.getLen());
    byte[] destData=readDataset(fs,dest,len);
    SwiftTestUtils.compareByteArrays(data,destData,len);
    String srcLs=SwiftTestUtils.ls(fs,src);
    String destLs=SwiftTestUtils.ls(fs,dest);
    assertPathDoesNotExist("deleted file still found in " + srcLs,src);
    assertPathDoesNotExist("partition file still found in " + srcLs,srcPart);
  }
}
