@RunWith(Parameterized.class) public class TestAMRMTokens {
  private static final Log LOG=LogFactory.getLog(TestAMRMTokens.class);
  private final Configuration conf;
  private static final int maxWaitAttempts=50;
  private static final int rolling_interval_sec=13;
  private static final long am_expire_ms=4000;
  @Parameters public static Collection<Object[]> configs(){
    Configuration conf=new Configuration();
    Configuration confWithSecurity=new Configuration();
    confWithSecurity.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
    return Arrays.asList(new Object[][]{{conf},{confWithSecurity}});
  }
  public TestAMRMTokens(  Configuration conf){
    this.conf=conf;
    UserGroupInformation.setConfiguration(conf);
  }
  /** 
 * Validate that application tokens are unusable after the application-finishes.
 * @throws Exception
 */
  @SuppressWarnings("unchecked") @Test public void testTokenExpiry() throws Exception {
    conf.setLong(YarnConfiguration.RM_AMRM_TOKEN_MASTER_KEY_ROLLING_INTERVAL_SECS,YarnConfiguration.DEFAULT_RM_AMRM_TOKEN_MASTER_KEY_ROLLING_INTERVAL_SECS);
    conf.setLong(YarnConfiguration.RM_AM_EXPIRY_INTERVAL_MS,YarnConfiguration.DEFAULT_RM_AM_EXPIRY_INTERVAL_MS);
    conf.set(YarnConfiguration.RM_SCHEDULER_ADDRESS,"0.0.0.0:0");
    MyContainerManager containerManager=new MyContainerManager();
    final MockRMWithAMS rm=new MockRMWithAMS(conf,containerManager);
    rm.start();
    final Configuration conf=rm.getConfig();
    final YarnRPC rpc=YarnRPC.create(conf);
    ApplicationMasterProtocol rmClient=null;
    try {
      MockNM nm1=rm.registerNode("localhost:1234",5120);
      RMApp app=rm.submitApp(1024);
      nm1.nodeHeartbeat(true);
      int waitCount=0;
      while (containerManager.containerTokens == null && waitCount++ < 20) {
        LOG.info("Waiting for AM Launch to happen..");
        Thread.sleep(1000);
      }
      Assert.assertNotNull(containerManager.containerTokens);
      RMAppAttempt attempt=app.getCurrentAppAttempt();
      ApplicationAttemptId applicationAttemptId=attempt.getAppAttemptId();
      UserGroupInformation currentUser=UserGroupInformation.createRemoteUser(applicationAttemptId.toString());
      Credentials credentials=containerManager.getContainerCredentials();
      final InetSocketAddress rmBindAddress=rm.getApplicationMasterService().getBindAddress();
      Token<? extends TokenIdentifier> amRMToken=MockRMWithAMS.setupAndReturnAMRMToken(rmBindAddress,credentials.getAllTokens());
      currentUser.addToken(amRMToken);
      rmClient=createRMClient(rm,conf,rpc,currentUser);
      RegisterApplicationMasterRequest request=Records.newRecord(RegisterApplicationMasterRequest.class);
      rmClient.registerApplicationMaster(request);
      FinishApplicationMasterRequest finishAMRequest=Records.newRecord(FinishApplicationMasterRequest.class);
      finishAMRequest.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);
      finishAMRequest.setDiagnostics("diagnostics");
      finishAMRequest.setTrackingUrl("url");
      rmClient.finishApplicationMaster(finishAMRequest);
      ContainerStatus containerStatus=BuilderUtils.newContainerStatus(attempt.getMasterContainer().getId(),ContainerState.COMPLETE,"AM Container Finished",0,attempt.getMasterContainer().getResource());
      rm.getRMContext().getDispatcher().getEventHandler().handle(new RMAppAttemptContainerFinishedEvent(applicationAttemptId,containerStatus,nm1.getNodeId()));
      int count=0;
      while (attempt.getState() != RMAppAttemptState.FINISHED && count < maxWaitAttempts) {
        Thread.sleep(100);
        count++;
      }
      Assert.assertTrue(attempt.getState() == RMAppAttemptState.FINISHED);
      rpc.stopProxy(rmClient,conf);
      rmClient=createRMClient(rm,conf,rpc,currentUser);
      AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
      try {
        rmClient.allocate(allocateRequest);
        Assert.fail("You got to be kidding me! " + "Using App tokens after app-finish should fail!");
      }
 catch (      Throwable t) {
        LOG.info("Exception found is ",t);
        Assert.assertTrue(t.getCause().getMessage().contains(applicationAttemptId.toString() + " not found in AMRMTokenSecretManager."));
      }
    }
  finally {
      rm.stop();
      if (rmClient != null) {
        rpc.stopProxy(rmClient,conf);
      }
    }
  }
  /** 
 * Validate master-key-roll-over and that tokens are usable even after master-key-roll-over.
 * @throws Exception
 */
  @Test public void testMasterKeyRollOver() throws Exception {
    conf.setLong(YarnConfiguration.RM_AMRM_TOKEN_MASTER_KEY_ROLLING_INTERVAL_SECS,rolling_interval_sec);
    conf.setLong(YarnConfiguration.RM_AM_EXPIRY_INTERVAL_MS,am_expire_ms);
    conf.set(YarnConfiguration.RM_SCHEDULER_ADDRESS,"0.0.0.0:0");
    MyContainerManager containerManager=new MyContainerManager();
    final MockRMWithAMS rm=new MockRMWithAMS(conf,containerManager);
    rm.start();
    Long startTime=System.currentTimeMillis();
    final Configuration conf=rm.getConfig();
    final YarnRPC rpc=YarnRPC.create(conf);
    ApplicationMasterProtocol rmClient=null;
    AMRMTokenSecretManager appTokenSecretManager=rm.getRMContext().getAMRMTokenSecretManager();
    MasterKeyData oldKey=appTokenSecretManager.getMasterKey();
    Assert.assertNotNull(oldKey);
    try {
      MockNM nm1=rm.registerNode("localhost:1234",5120);
      RMApp app=rm.submitApp(1024);
      nm1.nodeHeartbeat(true);
      int waitCount=0;
      while (containerManager.containerTokens == null && waitCount++ < maxWaitAttempts) {
        LOG.info("Waiting for AM Launch to happen..");
        Thread.sleep(1000);
      }
      Assert.assertNotNull(containerManager.containerTokens);
      RMAppAttempt attempt=app.getCurrentAppAttempt();
      ApplicationAttemptId applicationAttemptId=attempt.getAppAttemptId();
      UserGroupInformation currentUser=UserGroupInformation.createRemoteUser(applicationAttemptId.toString());
      Credentials credentials=containerManager.getContainerCredentials();
      final InetSocketAddress rmBindAddress=rm.getApplicationMasterService().getBindAddress();
      Token<? extends TokenIdentifier> amRMToken=MockRMWithAMS.setupAndReturnAMRMToken(rmBindAddress,credentials.getAllTokens());
      currentUser.addToken(amRMToken);
      rmClient=createRMClient(rm,conf,rpc,currentUser);
      RegisterApplicationMasterRequest request=Records.newRecord(RegisterApplicationMasterRequest.class);
      rmClient.registerApplicationMaster(request);
      AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
      Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
      while (System.currentTimeMillis() - startTime < rolling_interval_sec * 1000) {
        rmClient.allocate(allocateRequest);
        Thread.sleep(500);
      }
      MasterKeyData newKey=appTokenSecretManager.getMasterKey();
      Assert.assertNotNull(newKey);
      Assert.assertFalse("Master key should have changed!",oldKey.equals(newKey));
      rpc.stopProxy(rmClient,conf);
      rmClient=createRMClient(rm,conf,rpc,currentUser);
      Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
      waitCount=0;
      while (waitCount++ <= maxWaitAttempts) {
        if (appTokenSecretManager.getCurrnetMasterKeyData() != oldKey) {
          break;
        }
        try {
          rmClient.allocate(allocateRequest);
        }
 catch (        Exception ex) {
          break;
        }
        Thread.sleep(200);
      }
      Assert.assertTrue(appTokenSecretManager.getCurrnetMasterKeyData().equals(newKey));
      Assert.assertTrue(appTokenSecretManager.getMasterKey().equals(newKey));
      Assert.assertTrue(appTokenSecretManager.getNextMasterKeyData() == null);
      Token<AMRMTokenIdentifier> newToken=appTokenSecretManager.createAndGetAMRMToken(applicationAttemptId);
      SecurityUtil.setTokenService(newToken,rmBindAddress);
      currentUser.addToken(newToken);
      rpc.stopProxy(rmClient,conf);
      rmClient=createRMClient(rm,conf,rpc,currentUser);
      allocateRequest=Records.newRecord(AllocateRequest.class);
      Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
      rpc.stopProxy(rmClient,conf);
      try {
        currentUser.addToken(amRMToken);
        rmClient=createRMClient(rm,conf,rpc,currentUser);
        allocateRequest=Records.newRecord(AllocateRequest.class);
        Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
        Assert.fail("The old Token should not work");
      }
 catch (      Exception ex) {
      }
    }
  finally {
      rm.stop();
      if (rmClient != null) {
        rpc.stopProxy(rmClient,conf);
      }
    }
  }
  @Test(timeout=20000) public void testAMRMMasterKeysUpdate() throws Exception {
    final AtomicReference<AMRMTokenSecretManager> spySecretMgrRef=new AtomicReference<AMRMTokenSecretManager>();
    MockRM rm=new MockRM(conf){
      @Override protected void doSecureLogin() throws IOException {
      }
      @Override protected RMSecretManagerService createRMSecretManagerService(){
        return new RMSecretManagerService(conf,rmContext){
          @Override protected AMRMTokenSecretManager createAMRMTokenSecretManager(          Configuration conf,          RMContext rmContext){
            AMRMTokenSecretManager spySecretMgr=spy(super.createAMRMTokenSecretManager(conf,rmContext));
            spySecretMgrRef.set(spySecretMgr);
            return spySecretMgr;
          }
        }
;
      }
    }
;
    rm.start();
    MockNM nm=rm.registerNode("127.0.0.1:1234",8000);
    RMApp app=rm.submitApp(200);
    MockAM am=MockRM.launchAndRegisterAM(app,rm,nm);
    AMRMTokenSecretManager spySecretMgr=spySecretMgrRef.get();
    AllocateResponse response=am.allocate(Records.newRecord(AllocateRequest.class));
    Assert.assertNull(response.getAMRMToken());
    Token<AMRMTokenIdentifier> oldToken=rm.getRMContext().getRMApps().get(app.getApplicationId()).getRMAppAttempt(am.getApplicationAttemptId()).getAMRMToken();
    rm.getRMContext().getAMRMTokenSecretManager().rollMasterKey();
    response=am.allocate(Records.newRecord(AllocateRequest.class));
    Assert.assertNotNull(response.getAMRMToken());
    Token<AMRMTokenIdentifier> amrmToken=ConverterUtils.convertFromYarn(response.getAMRMToken(),new Text(response.getAMRMToken().getService()));
    Assert.assertEquals(amrmToken.decodeIdentifier().getKeyId(),rm.getRMContext().getAMRMTokenSecretManager().getMasterKey().getMasterKey().getKeyId());
    reset(spySecretMgr);
    UserGroupInformation ugi=UserGroupInformation.createUserForTesting(am.getApplicationAttemptId().toString(),new String[0]);
    ugi.addTokenIdentifier(oldToken.decodeIdentifier());
    response=am.doAllocateAs(ugi,Records.newRecord(AllocateRequest.class));
    Assert.assertNotNull(response.getAMRMToken());
    verify(spySecretMgr,never()).createAndGetAMRMToken(isA(ApplicationAttemptId.class));
    response=am.allocate(Records.newRecord(AllocateRequest.class));
    Assert.assertNull(response.getAMRMToken());
    rm.getRMContext().getAMRMTokenSecretManager().activateNextMasterKey();
    response=am.allocate(Records.newRecord(AllocateRequest.class));
    Assert.assertNull(response.getAMRMToken());
    rm.stop();
  }
  private ApplicationMasterProtocol createRMClient(  final MockRM rm,  final Configuration conf,  final YarnRPC rpc,  UserGroupInformation currentUser){
    return currentUser.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
      @Override public ApplicationMasterProtocol run(){
        return (ApplicationMasterProtocol)rpc.getProxy(ApplicationMasterProtocol.class,rm.getApplicationMasterService().getBindAddress(),conf);
      }
    }
);
  }
}
