/** 
 * A JUnit test for checking if restarting DFS preserves integrity. Specifically with FSImage being written in parallel
 */
public class TestParallelImageWrite {
  private static final int NUM_DATANODES=4;
  /** 
 * check if DFS remains in proper condition after a restart 
 */
  @Test public void testRestartDFS() throws Exception {
    final Configuration conf=new HdfsConfiguration();
    MiniDFSCluster cluster=null;
    FSNamesystem fsn=null;
    int numNamenodeDirs;
    DFSTestUtil files=new DFSTestUtil.Builder().setName("TestRestartDFS").setNumFiles(200).build();
    final String dir="/srcdat";
    final Path rootpath=new Path("/");
    final Path dirpath=new Path(dir);
    long rootmtime;
    FileStatus rootstatus;
    FileStatus dirstatus;
    try {
      cluster=new MiniDFSCluster.Builder(conf).format(true).numDataNodes(NUM_DATANODES).build();
      String[] nameNodeDirs=conf.getStrings(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,new String[]{});
      numNamenodeDirs=nameNodeDirs.length;
      assertTrue("failed to get number of Namenode StorageDirs",numNamenodeDirs != 0);
      FileSystem fs=cluster.getFileSystem();
      files.createFiles(fs,dir);
      rootmtime=fs.getFileStatus(rootpath).getModificationTime();
      rootstatus=fs.getFileStatus(dirpath);
      dirstatus=fs.getFileStatus(dirpath);
      fs.setOwner(rootpath,rootstatus.getOwner() + "_XXX",null);
      fs.setOwner(dirpath,null,dirstatus.getGroup() + "_XXX");
    }
  finally {
      if (cluster != null) {
        cluster.shutdown();
      }
    }
    try {
      conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_TXNS_KEY,1);
      cluster=new MiniDFSCluster.Builder(conf).format(false).numDataNodes(NUM_DATANODES).build();
      fsn=cluster.getNamesystem();
      FileSystem fs=cluster.getFileSystem();
      assertTrue("Filesystem corrupted after restart.",files.checkFiles(fs,dir));
      final FileStatus newrootstatus=fs.getFileStatus(rootpath);
      assertEquals(rootmtime,newrootstatus.getModificationTime());
      assertEquals(rootstatus.getOwner() + "_XXX",newrootstatus.getOwner());
      assertEquals(rootstatus.getGroup(),newrootstatus.getGroup());
      final FileStatus newdirstatus=fs.getFileStatus(dirpath);
      assertEquals(dirstatus.getOwner(),newdirstatus.getOwner());
      assertEquals(dirstatus.getGroup() + "_XXX",newdirstatus.getGroup());
      rootmtime=fs.getFileStatus(rootpath).getModificationTime();
      final String checkAfterRestart=checkImages(fsn,numNamenodeDirs);
      files.cleanup(fs,dir);
      files.createFiles(fs,dir);
      fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
      cluster.getNameNodeRpc().saveNamespace(0,0);
      final String checkAfterModify=checkImages(fsn,numNamenodeDirs);
      assertFalse("Modified namespace should change fsimage contents. " + "was: " + checkAfterRestart + " now: "+ checkAfterModify,checkAfterRestart.equals(checkAfterModify));
      fsn.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
      files.cleanup(fs,dir);
    }
  finally {
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
  /** 
 * Confirm that FSImage files in all StorageDirectory are the same, and non-empty, and there are the expected number of them.
 * @param fsn - the FSNamesystem being checked.
 * @param numImageDirs - the configured number of StorageDirectory of type IMAGE. 
 * @return - the md5 hash of the most recent FSImage files, which must all be the same.
 * @throws AssertionError if image files are empty or different,if less than two StorageDirectory are provided, or if the actual number of StorageDirectory is less than configured.
 */
  public static String checkImages(  FSNamesystem fsn,  int numImageDirs) throws Exception {
    NNStorage stg=fsn.getFSImage().getStorage();
    assertEquals("Some StorageDirectories failed Upgrade",numImageDirs,stg.getNumStorageDirs(NameNodeDirType.IMAGE));
    assertTrue("Not enough fsimage copies in MiniDFSCluster " + "to test parallel write",numImageDirs > 1);
    List<File> dirs=FSImageTestUtil.getCurrentDirs(stg,NameNodeDirType.IMAGE);
    FSImageTestUtil.assertParallelFilesAreIdentical(dirs,Collections.<String>emptySet());
    FSImageTestUtil.assertSameNewestImage(dirs);
    StorageDirectory firstSd=stg.dirIterator(NameNodeDirType.IMAGE).next();
    File latestImage=FSImageTestUtil.findLatestImageFile(firstSd);
    String md5=FSImageTestUtil.getImageFileMD5IgnoringTxId(latestImage);
    System.err.println("md5 of " + latestImage + ": "+ md5);
    return md5;
  }
}
