/** 
 * Extends the TestAMRMProxyService and overrides methods in order to use the AMRMProxyService's pipeline test cases for testing the FederationInterceptor class. The tests for AMRMProxyService has been written cleverly so that it can be reused to validate different request intercepter chains.
 */
public class TestFederationInterceptor extends BaseAMRMProxyTest {
  private static final Logger LOG=LoggerFactory.getLogger(TestFederationInterceptor.class);
  public static final String HOME_SC_ID="SC-home";
  private TestableFederationInterceptor interceptor;
  private MemoryFederationStateStore stateStore;
  private NMStateStoreService nmStateStore;
  private RegistryOperations registry;
  private Context nmContext;
  private int testAppId;
  private ApplicationAttemptId attemptId;
  @Override public void setUp() throws IOException {
    super.setUp();
    interceptor=new TestableFederationInterceptor();
    stateStore=new MemoryFederationStateStore();
    stateStore.init(getConf());
    FederationStateStoreFacade.getInstance().reinitialize(stateStore,getConf());
    nmStateStore=new NMMemoryStateStoreService();
    nmStateStore.init(getConf());
    nmStateStore.start();
    registry=new FSRegistryOperationsService();
    registry.init(getConf());
    registry.start();
    testAppId=1;
    attemptId=getApplicationAttemptId(testAppId);
    nmContext=new NMContext(null,null,null,null,nmStateStore,false,getConf());
    interceptor.init(new AMRMProxyApplicationContextImpl(nmContext,getConf(),attemptId,"test-user",null,null,null,registry));
    interceptor.cleanupRegistry();
  }
  @Override public void tearDown(){
    interceptor.cleanupRegistry();
    interceptor.shutdown();
    registry.stop();
    super.tearDown();
  }
  @Override protected YarnConfiguration createConfiguration(){
    YarnConfiguration conf=new YarnConfiguration();
    conf.setBoolean(YarnConfiguration.AMRM_PROXY_ENABLED,true);
    conf.setBoolean(YarnConfiguration.FEDERATION_ENABLED,true);
    String mockPassThroughInterceptorClass=PassThroughRequestInterceptor.class.getName();
    conf.set(YarnConfiguration.AMRM_PROXY_INTERCEPTOR_CLASS_PIPELINE,mockPassThroughInterceptorClass + "," + mockPassThroughInterceptorClass+ ","+ TestableFederationInterceptor.class.getName());
    conf.set(YarnConfiguration.FEDERATION_POLICY_MANAGER,UniformBroadcastPolicyManager.class.getName());
    conf.set(YarnConfiguration.RM_CLUSTER_ID,HOME_SC_ID);
    conf.setInt(YarnConfiguration.FEDERATION_CACHE_TIME_TO_LIVE_SECS,0);
    return conf;
  }
  private void registerSubCluster(  SubClusterId subClusterId) throws YarnException {
    stateStore.registerSubCluster(SubClusterRegisterRequest.newInstance(SubClusterInfo.newInstance(subClusterId,"1.2.3.4:1","1.2.3.4:2","1.2.3.4:3","1.2.3.4:4",SubClusterState.SC_RUNNING,0,"capacity")));
  }
  private void deRegisterSubCluster(  SubClusterId subClusterId) throws YarnException {
    stateStore.deregisterSubCluster(SubClusterDeregisterRequest.newInstance(subClusterId,SubClusterState.SC_UNREGISTERED));
  }
  private List<Container> getContainersAndAssert(  int numberOfResourceRequests,  int numberOfAllocationExcepted) throws Exception {
    AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
    allocateRequest.setResponseId(1);
    List<Container> containers=new ArrayList<Container>(numberOfResourceRequests);
    List<ResourceRequest> askList=new ArrayList<ResourceRequest>(numberOfResourceRequests);
    for (int id=0; id < numberOfResourceRequests; id++) {
      askList.add(createResourceRequest("test-node-" + Integer.toString(id),6000,2,id % 5,1));
    }
    allocateRequest.setAskList(askList);
    AllocateResponse allocateResponse=interceptor.allocate(allocateRequest);
    Assert.assertNotNull("allocate() returned null response",allocateResponse);
    containers.addAll(allocateResponse.getAllocatedContainers());
    LOG.info("Number of allocated containers in the original request: " + Integer.toString(allocateResponse.getAllocatedContainers().size()));
    int numHeartbeat=0;
    while (containers.size() < numberOfAllocationExcepted && numHeartbeat++ < 10) {
      allocateResponse=interceptor.allocate(Records.newRecord(AllocateRequest.class));
      Assert.assertNotNull("allocate() returned null response",allocateResponse);
      containers.addAll(allocateResponse.getAllocatedContainers());
      LOG.info("Number of allocated containers in this request: " + Integer.toString(allocateResponse.getAllocatedContainers().size()));
      LOG.info("Total number of allocated containers: " + Integer.toString(containers.size()));
      Thread.sleep(10);
    }
    Assert.assertEquals(numberOfAllocationExcepted,containers.size());
    return containers;
  }
  private void releaseContainersAndAssert(  List<Container> containers) throws Exception {
    Assert.assertTrue(containers.size() > 0);
    AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
    allocateRequest.setResponseId(1);
    List<ContainerId> relList=new ArrayList<ContainerId>(containers.size());
    for (    Container container : containers) {
      relList.add(container.getId());
    }
    allocateRequest.setReleaseList(relList);
    AllocateResponse allocateResponse=interceptor.allocate(allocateRequest);
    Assert.assertNotNull(allocateResponse);
    List<ContainerId> containersForReleasedContainerIds=new ArrayList<ContainerId>();
    List<ContainerId> newlyFinished=getCompletedContainerIds(allocateResponse.getCompletedContainersStatuses());
    containersForReleasedContainerIds.addAll(newlyFinished);
    LOG.info("Number of containers received in the original request: " + Integer.toString(newlyFinished.size()));
    int numHeartbeat=0;
    while (containersForReleasedContainerIds.size() < relList.size() && numHeartbeat++ < 10) {
      allocateResponse=interceptor.allocate(Records.newRecord(AllocateRequest.class));
      Assert.assertNotNull(allocateResponse);
      newlyFinished=getCompletedContainerIds(allocateResponse.getCompletedContainersStatuses());
      containersForReleasedContainerIds.addAll(newlyFinished);
      LOG.info("Number of containers received in this request: " + Integer.toString(newlyFinished.size()));
      LOG.info("Total number of containers received: " + Integer.toString(containersForReleasedContainerIds.size()));
      Thread.sleep(10);
    }
    Assert.assertEquals(relList.size(),containersForReleasedContainerIds.size());
  }
  @Test public void testMultipleSubClusters() throws Exception {
    RegisterApplicationMasterRequest registerReq=Records.newRecord(RegisterApplicationMasterRequest.class);
    registerReq.setHost(Integer.toString(testAppId));
    registerReq.setRpcPort(0);
    registerReq.setTrackingUrl("");
    RegisterApplicationMasterResponse registerResponse=interceptor.registerApplicationMaster(registerReq);
    Assert.assertNotNull(registerResponse);
    Assert.assertEquals(0,interceptor.getUnmanagedAMPoolSize());
    registerSubCluster(SubClusterId.newInstance("SC-1"));
    registerSubCluster(SubClusterId.newInstance("SC-2"));
    int numberOfContainers=3;
    List<Container> containers=getContainersAndAssert(numberOfContainers,numberOfContainers * 2);
    Assert.assertEquals(2,interceptor.getUnmanagedAMPoolSize());
    deRegisterSubCluster(SubClusterId.newInstance("SC-2"));
    registerSubCluster(SubClusterId.newInstance("SC-3"));
    numberOfContainers=1;
    containers.addAll(getContainersAndAssert(numberOfContainers,numberOfContainers * 2));
    Assert.assertEquals(3,interceptor.getUnmanagedAMPoolSize());
    deRegisterSubCluster(SubClusterId.newInstance("SC-1"));
    deRegisterSubCluster(SubClusterId.newInstance("SC-3"));
    registerSubCluster(SubClusterId.newInstance(HOME_SC_ID));
    numberOfContainers=2;
    containers.addAll(getContainersAndAssert(numberOfContainers,numberOfContainers * 1));
    Assert.assertEquals(3,interceptor.getUnmanagedAMPoolSize());
    releaseContainersAndAssert(containers);
    FinishApplicationMasterRequest finishReq=Records.newRecord(FinishApplicationMasterRequest.class);
    finishReq.setDiagnostics("");
    finishReq.setTrackingUrl("");
    finishReq.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);
    FinishApplicationMasterResponse finshResponse=interceptor.finishApplicationMaster(finishReq);
    Assert.assertNotNull(finshResponse);
    Assert.assertEquals(true,finshResponse.getIsUnregistered());
  }
  @Test public void testReregister() throws Exception {
    RegisterApplicationMasterRequest registerReq=Records.newRecord(RegisterApplicationMasterRequest.class);
    registerReq.setHost(Integer.toString(testAppId));
    registerReq.setRpcPort(0);
    registerReq.setTrackingUrl("");
    RegisterApplicationMasterResponse registerResponse=interceptor.registerApplicationMaster(registerReq);
    Assert.assertNotNull(registerResponse);
    Assert.assertEquals(0,interceptor.getUnmanagedAMPoolSize());
    registerSubCluster(SubClusterId.newInstance("SC-1"));
    registerSubCluster(SubClusterId.newInstance(HOME_SC_ID));
    interceptor.setShouldReRegisterNext();
    int numberOfContainers=3;
    List<Container> containers=getContainersAndAssert(numberOfContainers,numberOfContainers * 2);
    Assert.assertEquals(1,interceptor.getUnmanagedAMPoolSize());
    interceptor.setShouldReRegisterNext();
    releaseContainersAndAssert(containers);
    interceptor.setShouldReRegisterNext();
    FinishApplicationMasterRequest finishReq=Records.newRecord(FinishApplicationMasterRequest.class);
    finishReq.setDiagnostics("");
    finishReq.setTrackingUrl("");
    finishReq.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);
    FinishApplicationMasterResponse finshResponse=interceptor.finishApplicationMaster(finishReq);
    Assert.assertNotNull(finshResponse);
    Assert.assertEquals(true,finshResponse.getIsUnregistered());
  }
  @Test(timeout=5000) public void testConcurrentRegister() throws InterruptedException, ExecutionException {
    ExecutorService threadpool=Executors.newCachedThreadPool();
    ExecutorCompletionService<RegisterApplicationMasterResponse> compSvc=new ExecutorCompletionService<>(threadpool);
    Object syncObj=MockResourceManagerFacade.getSyncObj();
synchronized (syncObj) {
      LOG.info("Starting first register thread");
      compSvc.submit(new ConcurrentRegisterAMCallable());
      try {
        LOG.info("Test main starts waiting for the first thread to block");
        syncObj.wait();
        LOG.info("Test main wait finished");
      }
 catch (      Exception e) {
        LOG.info("Test main wait interrupted",e);
      }
    }
    LOG.info("Starting second register thread");
    compSvc.submit(new ConcurrentRegisterAMCallable());
    LOG.info("Let first blocked register thread move on");
synchronized (syncObj) {
      syncObj.notifyAll();
    }
    RegisterApplicationMasterResponse response=compSvc.take().get();
    Assert.assertNotNull(response);
    response=compSvc.take().get();
    Assert.assertNotNull(response);
    threadpool.shutdown();
  }
  /** 
 * A callable that calls registerAM to RM with blocking.
 */
public class ConcurrentRegisterAMCallable implements Callable<RegisterApplicationMasterResponse> {
    @Override public RegisterApplicationMasterResponse call() throws Exception {
      RegisterApplicationMasterResponse response=null;
      try {
        response=interceptor.registerApplicationMaster(RegisterApplicationMasterRequest.newInstance(null,1001,null));
      }
 catch (      Exception e) {
        LOG.info("Register thread exception",e);
        response=null;
      }
      return response;
    }
  }
  @Test public void testRecoverWithAMRMProxyHA() throws Exception {
    testRecover(registry);
  }
  @Test public void testRecoverWithoutAMRMProxyHA() throws Exception {
    testRecover(null);
  }
  public void testRecover(  RegistryOperations registryObj) throws Exception {
    ApplicationUserInfo userInfo=getApplicationUserInfo(testAppId);
    userInfo.getUser().doAs(new PrivilegedExceptionAction<Object>(){
      @Override public Object run() throws Exception {
        interceptor=new TestableFederationInterceptor();
        interceptor.init(new AMRMProxyApplicationContextImpl(nmContext,getConf(),attemptId,"test-user",null,null,null,registryObj));
        interceptor.cleanupRegistry();
        RegisterApplicationMasterRequest registerReq=Records.newRecord(RegisterApplicationMasterRequest.class);
        registerReq.setHost(Integer.toString(testAppId));
        registerReq.setRpcPort(testAppId);
        registerReq.setTrackingUrl("");
        RegisterApplicationMasterResponse registerResponse=interceptor.registerApplicationMaster(registerReq);
        Assert.assertNotNull(registerResponse);
        Assert.assertEquals(0,interceptor.getUnmanagedAMPoolSize());
        registerSubCluster(SubClusterId.newInstance("SC-1"));
        registerSubCluster(SubClusterId.newInstance(HOME_SC_ID));
        int numberOfContainers=3;
        List<Container> containers=getContainersAndAssert(numberOfContainers,numberOfContainers * 2);
        Assert.assertEquals(1,interceptor.getUnmanagedAMPoolSize());
        Map<String,byte[]> recoveredDataMap=recoverDataMapForAppAttempt(nmStateStore,attemptId);
        String scEntry=FederationInterceptor.NMSS_SECONDARY_SC_PREFIX + "SC-1";
        if (registryObj == null) {
          Assert.assertTrue(recoveredDataMap.containsKey(scEntry));
        }
 else {
          Assert.assertFalse(recoveredDataMap.containsKey(scEntry));
        }
        MockResourceManagerFacade homeRM=interceptor.getHomeRM();
        ConcurrentHashMap<String,MockResourceManagerFacade> secondaries=interceptor.getSecondaryRMs();
        interceptor=new TestableFederationInterceptor(homeRM,secondaries);
        interceptor.init(new AMRMProxyApplicationContextImpl(nmContext,getConf(),attemptId,"test-user",null,null,null,registryObj));
        interceptor.recover(recoveredDataMap);
        Assert.assertEquals(1,interceptor.getUnmanagedAMPoolSize());
        releaseContainersAndAssert(containers);
        FinishApplicationMasterRequest finishReq=Records.newRecord(FinishApplicationMasterRequest.class);
        finishReq.setDiagnostics("");
        finishReq.setTrackingUrl("");
        finishReq.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);
        FinishApplicationMasterResponse finshResponse=interceptor.finishApplicationMaster(finishReq);
        Assert.assertNotNull(finshResponse);
        Assert.assertEquals(true,finshResponse.getIsUnregistered());
        if (registryObj != null) {
          Assert.assertEquals(0,interceptor.getRegistryClient().getAllApplications().size());
        }
 else {
          recoveredDataMap=recoverDataMapForAppAttempt(nmStateStore,attemptId);
          Assert.assertFalse(recoveredDataMap.containsKey(scEntry));
        }
        return null;
      }
    }
);
  }
  @Test public void testRequestInterceptorChainCreation() throws Exception {
    RequestInterceptor root=super.getAMRMProxyService().createRequestInterceptorChain();
    int index=0;
    while (root != null) {
switch (index) {
case 0:
case 1:
        Assert.assertEquals(PassThroughRequestInterceptor.class.getName(),root.getClass().getName());
      break;
case 2:
    Assert.assertEquals(TestableFederationInterceptor.class.getName(),root.getClass().getName());
  break;
default :
Assert.fail();
}
root=root.getNextInterceptor();
index++;
}
Assert.assertEquals("The number of interceptors in chain does not match",Integer.toString(3),Integer.toString(index));
}
/** 
 * Between AM and AMRMProxy, FederationInterceptor modifies the RM behavior, so that when AM registers more than once, it returns the same register success response instead of throwing {@link InvalidApplicationMasterRequestException}We did this because FederationInterceptor can receive concurrent register requests from AM because of timeout between AM and AMRMProxy. This can possible since the timeout between FederationInterceptor and RM longer because of performFailover + timeout.
 */
@Test public void testTwoIdenticalRegisterRequest() throws Exception {
RegisterApplicationMasterRequest registerReq=Records.newRecord(RegisterApplicationMasterRequest.class);
registerReq.setHost(Integer.toString(testAppId));
registerReq.setRpcPort(0);
registerReq.setTrackingUrl("");
for (int i=0; i < 2; i++) {
RegisterApplicationMasterResponse registerResponse=interceptor.registerApplicationMaster(registerReq);
Assert.assertNotNull(registerResponse);
}
}
@Test public void testTwoDifferentRegisterRequest() throws Exception {
RegisterApplicationMasterRequest registerReq=Records.newRecord(RegisterApplicationMasterRequest.class);
registerReq.setHost(Integer.toString(testAppId));
registerReq.setRpcPort(0);
registerReq.setTrackingUrl("");
RegisterApplicationMasterResponse registerResponse=interceptor.registerApplicationMaster(registerReq);
Assert.assertNotNull(registerResponse);
registerReq=Records.newRecord(RegisterApplicationMasterRequest.class);
registerReq.setHost(Integer.toString(testAppId));
registerReq.setRpcPort(0);
registerReq.setTrackingUrl("different");
try {
registerResponse=interceptor.registerApplicationMaster(registerReq);
Assert.fail("Should throw if a different request obj is used");
}
 catch (YarnException e) {
}
}
@Test public void testAllocateResponse() throws Exception {
interceptor.registerApplicationMaster(RegisterApplicationMasterRequest.newInstance(null,0,null));
AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
Map<SubClusterId,List<AllocateResponse>> asyncResponseSink=interceptor.getAsyncResponseSink();
ContainerId cid=ContainerId.newContainerId(attemptId,0);
ContainerStatus cStatus=Records.newRecord(ContainerStatus.class);
cStatus.setContainerId(cid);
Container container=Container.newInstance(cid,null,null,null,null,null);
AllocateResponse response=Records.newRecord(AllocateResponse.class);
response.setAllocatedContainers(Collections.singletonList(container));
response.setCompletedContainersStatuses(Collections.singletonList(cStatus));
response.setUpdatedNodes(Collections.singletonList(Records.newRecord(NodeReport.class)));
response.setNMTokens(Collections.singletonList(Records.newRecord(NMToken.class)));
response.setUpdatedContainers(Collections.singletonList(Records.newRecord(UpdatedContainer.class)));
response.setUpdateErrors(Collections.singletonList(Records.newRecord(UpdateContainerError.class)));
response.setAvailableResources(Records.newRecord(Resource.class));
response.setPreemptionMessage(Records.newRecord(PreemptionMessage.class));
List<AllocateResponse> list=new ArrayList<>();
list.add(response);
asyncResponseSink.put(SubClusterId.newInstance("SC-1"),list);
response=interceptor.allocate(allocateRequest);
Assert.assertEquals(1,response.getAllocatedContainers().size());
Assert.assertNotNull(response.getAvailableResources());
Assert.assertEquals(1,response.getCompletedContainersStatuses().size());
Assert.assertEquals(1,response.getUpdatedNodes().size());
Assert.assertNotNull(response.getPreemptionMessage());
Assert.assertEquals(1,response.getNMTokens().size());
Assert.assertEquals(1,response.getUpdatedContainers().size());
Assert.assertEquals(1,response.getUpdateErrors().size());
}
@Test public void testSecondAttempt() throws Exception {
ApplicationUserInfo userInfo=getApplicationUserInfo(testAppId);
userInfo.getUser().doAs(new PrivilegedExceptionAction<Object>(){
@Override public Object run() throws Exception {
RegisterApplicationMasterRequest registerReq=Records.newRecord(RegisterApplicationMasterRequest.class);
registerReq.setHost(Integer.toString(testAppId));
registerReq.setRpcPort(testAppId);
registerReq.setTrackingUrl("");
RegisterApplicationMasterResponse registerResponse=interceptor.registerApplicationMaster(registerReq);
Assert.assertNotNull(registerResponse);
Assert.assertEquals(0,interceptor.getUnmanagedAMPoolSize());
registerSubCluster(SubClusterId.newInstance("SC-1"));
registerSubCluster(SubClusterId.newInstance(HOME_SC_ID));
int numberOfContainers=3;
List<Container> containers=getContainersAndAssert(numberOfContainers,numberOfContainers * 2);
for (Container c : containers) {
System.out.println(c.getId() + " ha");
}
Assert.assertEquals(1,interceptor.getUnmanagedAMPoolSize());
ConcurrentHashMap<String,MockResourceManagerFacade> secondaries=interceptor.getSecondaryRMs();
attemptId=ApplicationAttemptId.newInstance(attemptId.getApplicationId(),attemptId.getAttemptId() + 1);
interceptor=new TestableFederationInterceptor(null,secondaries);
interceptor.init(new AMRMProxyApplicationContextImpl(nmContext,getConf(),attemptId,"test-user",null,null,null,registry));
registerResponse=interceptor.registerApplicationMaster(registerReq);
Assert.assertEquals(1,interceptor.getUnmanagedAMPoolSize());
Assert.assertEquals(numberOfContainers,registerResponse.getContainersFromPreviousAttempts().size());
releaseContainersAndAssert(registerResponse.getContainersFromPreviousAttempts());
FinishApplicationMasterRequest finishReq=Records.newRecord(FinishApplicationMasterRequest.class);
finishReq.setDiagnostics("");
finishReq.setTrackingUrl("");
finishReq.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);
FinishApplicationMasterResponse finshResponse=interceptor.finishApplicationMaster(finishReq);
Assert.assertNotNull(finshResponse);
Assert.assertEquals(true,finshResponse.getIsUnregistered());
if (interceptor.getRegistryClient() != null) {
Assert.assertEquals(0,interceptor.getRegistryClient().getAllApplications().size());
}
return null;
}
}
);
}
}
