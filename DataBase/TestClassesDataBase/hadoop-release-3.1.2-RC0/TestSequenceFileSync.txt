/** 
 * Tests sync based seek reads/write intervals inside SequenceFiles. 
 */
public class TestSequenceFileSync {
  private static final int NUMRECORDS=2000;
  private static final int RECORDSIZE=80;
  private static final Random RAND=new Random();
  private final static String REC_FMT="%d RECORDID %d : ";
  private static void forOffset(  SequenceFile.Reader reader,  IntWritable key,  Text val,  int iter,  long off,  int expectedRecord) throws IOException {
    val.clear();
    reader.sync(off);
    reader.next(key,val);
    assertEquals(key.get(),expectedRecord);
    final String test=String.format(REC_FMT,expectedRecord,expectedRecord);
    assertEquals("Invalid value in iter " + iter + ": "+ val,0,val.find(test,0));
  }
  @Test public void testDefaultSyncInterval() throws IOException {
    final Configuration conf=new Configuration();
    final FileSystem fs=FileSystem.getLocal(conf);
    final Path path=new Path(GenericTestUtils.getTempPath("sequencefile.sync.test"));
    final IntWritable input=new IntWritable();
    final Text val=new Text();
    SequenceFile.Writer writer=new SequenceFile.Writer(conf,SequenceFile.Writer.file(path),SequenceFile.Writer.compression(CompressionType.NONE),SequenceFile.Writer.keyClass(IntWritable.class),SequenceFile.Writer.valueClass(Text.class));
    try {
      writeSequenceFile(writer,NUMRECORDS * 4);
      for (int i=0; i < 5; i++) {
        final SequenceFile.Reader reader;
        if (i % 2 == 0) {
          final int buffersize=conf.getInt("io.file.buffer.size",4096);
          reader=new SequenceFile.Reader(conf,SequenceFile.Reader.file(path),SequenceFile.Reader.bufferSize(buffersize));
        }
 else {
          final FSDataInputStream in=fs.open(path);
          final long length=fs.getFileStatus(path).getLen();
          reader=new SequenceFile.Reader(conf,SequenceFile.Reader.stream(in),SequenceFile.Reader.start(0L),SequenceFile.Reader.length(length));
        }
        try {
          forOffset(reader,input,val,i,0,0);
          forOffset(reader,input,val,i,65,0);
          forOffset(reader,input,val,i,2000,1101);
          forOffset(reader,input,val,i,0,0);
        }
  finally {
          reader.close();
        }
      }
    }
  finally {
      fs.delete(path,false);
    }
  }
  @Test public void testLowSyncpoint() throws IOException {
    final Configuration conf=new Configuration();
    final FileSystem fs=FileSystem.getLocal(conf);
    final Path path=new Path(GenericTestUtils.getTempPath("sequencefile.sync.test"));
    final IntWritable input=new IntWritable();
    final Text val=new Text();
    SequenceFile.Writer writer=new SequenceFile.Writer(conf,SequenceFile.Writer.file(path),SequenceFile.Writer.compression(CompressionType.NONE),SequenceFile.Writer.keyClass(IntWritable.class),SequenceFile.Writer.valueClass(Text.class),SequenceFile.Writer.syncInterval(20 * 100));
    assertEquals(writer.syncInterval,20 * 100);
    try {
      writeSequenceFile(writer,NUMRECORDS);
      for (int i=0; i < 5; i++) {
        final SequenceFile.Reader reader;
        if (i % 2 == 0) {
          final int bufferSize=conf.getInt("io.file.buffer.size",4096);
          reader=new SequenceFile.Reader(conf,SequenceFile.Reader.file(path),SequenceFile.Reader.bufferSize(bufferSize));
        }
 else {
          final FSDataInputStream in=fs.open(path);
          final long length=fs.getFileStatus(path).getLen();
          reader=new SequenceFile.Reader(conf,SequenceFile.Reader.stream(in),SequenceFile.Reader.start(0L),SequenceFile.Reader.length(length));
        }
        try {
          forOffset(reader,input,val,i,0,0);
          forOffset(reader,input,val,i,65,0);
          forOffset(reader,input,val,i,2000,21);
          forOffset(reader,input,val,i,0,0);
        }
  finally {
          reader.close();
        }
      }
    }
  finally {
      fs.delete(path,false);
    }
  }
  private static void writeSequenceFile(  SequenceFile.Writer writer,  int numRecords) throws IOException {
    final IntWritable key=new IntWritable();
    final Text val=new Text();
    for (int numWritten=0; numWritten < numRecords; ++numWritten) {
      key.set(numWritten);
      randomText(val,numWritten,RECORDSIZE);
      writer.append(key,val);
    }
    writer.close();
  }
  private static void randomText(  Text val,  int id,  int recordSize){
    val.clear();
    final StringBuilder ret=new StringBuilder(recordSize);
    ret.append(String.format(REC_FMT,id,id));
    recordSize-=ret.length();
    for (int i=0; i < recordSize; ++i) {
      ret.append(RAND.nextInt(9));
    }
    val.set(ret.toString());
  }
}
