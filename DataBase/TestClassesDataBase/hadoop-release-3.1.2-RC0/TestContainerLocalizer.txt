public class TestContainerLocalizer {
  static final Logger LOG=LoggerFactory.getLogger(TestContainerLocalizer.class);
  static final Path basedir=new Path("target",TestContainerLocalizer.class.getName());
  static final FsPermission CACHE_DIR_PERM=new FsPermission((short)0710);
  static final FsPermission USERCACHE_DIR_PERM=new FsPermission((short)0755);
  static final String appUser="yak";
  static final String appId="app_RM_0";
  static final String containerId="container_0";
  static final InetSocketAddress nmAddr=new InetSocketAddress("foobar",8040);
  @After public void cleanUp() throws IOException {
    FileUtils.deleteDirectory(new File(basedir.toUri().getRawPath()));
  }
  @Test public void testMain() throws Exception {
    ContainerLocalizerWrapper wrapper=new ContainerLocalizerWrapper();
    ContainerLocalizer localizer=wrapper.setupContainerLocalizerForTest();
    Random random=wrapper.random;
    List<Path> localDirs=wrapper.localDirs;
    Path tokenPath=wrapper.tokenPath;
    LocalizationProtocol nmProxy=wrapper.nmProxy;
    AbstractFileSystem spylfs=wrapper.spylfs;
    mockOutDownloads(localizer);
    List<Path> privCacheList=new ArrayList<Path>();
    List<Path> appCacheList=new ArrayList<Path>();
    for (    Path p : localDirs) {
      Path base=new Path(new Path(p,ContainerLocalizer.USERCACHE),appUser);
      Path privcache=new Path(base,ContainerLocalizer.FILECACHE);
      privCacheList.add(privcache);
      Path appDir=new Path(base,new Path(ContainerLocalizer.APPCACHE,appId));
      Path appcache=new Path(appDir,ContainerLocalizer.FILECACHE);
      appCacheList.add(appcache);
    }
    ResourceLocalizationSpec rsrcA=getMockRsrc(random,LocalResourceVisibility.PRIVATE,privCacheList.get(0));
    ResourceLocalizationSpec rsrcB=getMockRsrc(random,LocalResourceVisibility.PRIVATE,privCacheList.get(0));
    ResourceLocalizationSpec rsrcC=getMockRsrc(random,LocalResourceVisibility.APPLICATION,appCacheList.get(0));
    ResourceLocalizationSpec rsrcD=getMockRsrc(random,LocalResourceVisibility.PRIVATE,privCacheList.get(0));
    when(nmProxy.heartbeat(isA(LocalizerStatus.class))).thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE,Collections.singletonList(rsrcA))).thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE,Collections.singletonList(rsrcB))).thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE,Collections.singletonList(rsrcC))).thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE,Collections.singletonList(rsrcD))).thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE,Collections.<ResourceLocalizationSpec>emptyList())).thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.DIE,null));
    LocalResource tRsrcA=rsrcA.getResource();
    LocalResource tRsrcB=rsrcB.getResource();
    LocalResource tRsrcC=rsrcC.getResource();
    LocalResource tRsrcD=rsrcD.getResource();
    doReturn(new FakeDownload(rsrcA.getResource().getResource().getFile(),true)).when(localizer).download(isA(Path.class),eq(tRsrcA),isA(UserGroupInformation.class));
    doReturn(new FakeDownload(rsrcB.getResource().getResource().getFile(),true)).when(localizer).download(isA(Path.class),eq(tRsrcB),isA(UserGroupInformation.class));
    doReturn(new FakeDownload(rsrcC.getResource().getResource().getFile(),true)).when(localizer).download(isA(Path.class),eq(tRsrcC),isA(UserGroupInformation.class));
    doReturn(new FakeDownload(rsrcD.getResource().getResource().getFile(),true)).when(localizer).download(isA(Path.class),eq(tRsrcD),isA(UserGroupInformation.class));
    localizer.runLocalization(nmAddr);
    for (    Path p : localDirs) {
      Path base=new Path(new Path(p,ContainerLocalizer.USERCACHE),appUser);
      Path privcache=new Path(base,ContainerLocalizer.FILECACHE);
      verify(spylfs).mkdir(eq(privcache),eq(CACHE_DIR_PERM),eq(false));
      Path appDir=new Path(base,new Path(ContainerLocalizer.APPCACHE,appId));
      Path appcache=new Path(appDir,ContainerLocalizer.FILECACHE);
      verify(spylfs).mkdir(eq(appcache),eq(CACHE_DIR_PERM),eq(false));
    }
    verify(spylfs).open(tokenPath);
    verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcA.getResource())));
    verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcB.getResource())));
    verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcC.getResource())));
    verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcD.getResource())));
    verify(nmProxy,never()).heartbeat(argThat(new ArgumentMatcher<LocalizerStatus>(){
      @Override public boolean matches(      Object o){
        LocalizerStatus status=(LocalizerStatus)o;
        return !containerId.equals(status.getLocalizerId());
      }
    }
));
  }
  @Test(timeout=15000) public void testMainFailure() throws Exception {
    ContainerLocalizerWrapper wrapper=new ContainerLocalizerWrapper();
    ContainerLocalizer localizer=wrapper.setupContainerLocalizerForTest();
    LocalizationProtocol nmProxy=wrapper.nmProxy;
    mockOutDownloads(localizer);
    when(nmProxy.heartbeat(isA(LocalizerStatus.class))).thenThrow(new YarnException("Sigh, no token!"));
    try {
      localizer.runLocalization(nmAddr);
      Assert.fail("Localization succeeded unexpectedly!");
    }
 catch (    IOException e) {
      Assert.assertTrue(e.getMessage().contains("Sigh, no token!"));
    }
  }
  @Test @SuppressWarnings("unchecked") public void testLocalizerTokenIsGettingRemoved() throws Exception {
    ContainerLocalizerWrapper wrapper=new ContainerLocalizerWrapper();
    ContainerLocalizer localizer=wrapper.setupContainerLocalizerForTest();
    Path tokenPath=wrapper.tokenPath;
    AbstractFileSystem spylfs=wrapper.spylfs;
    mockOutDownloads(localizer);
    doNothing().when(localizer).localizeFiles(any(LocalizationProtocol.class),any(CompletionService.class),any(UserGroupInformation.class));
    localizer.runLocalization(nmAddr);
    verify(spylfs,times(1)).delete(tokenPath,false);
  }
  @Test @SuppressWarnings("unchecked") public void testContainerLocalizerClosesFilesystems() throws Exception {
    ContainerLocalizerWrapper wrapper=new ContainerLocalizerWrapper();
    ContainerLocalizer localizer=wrapper.setupContainerLocalizerForTest();
    mockOutDownloads(localizer);
    doNothing().when(localizer).localizeFiles(any(LocalizationProtocol.class),any(CompletionService.class),any(UserGroupInformation.class));
    verify(localizer,never()).closeFileSystems(any(UserGroupInformation.class));
    localizer.runLocalization(nmAddr);
    verify(localizer).closeFileSystems(any(UserGroupInformation.class));
    localizer=wrapper.setupContainerLocalizerForTest();
    doThrow(new YarnRuntimeException("Forced Failure")).when(localizer).localizeFiles(any(LocalizationProtocol.class),any(CompletionService.class),any(UserGroupInformation.class));
    verify(localizer,never()).closeFileSystems(any(UserGroupInformation.class));
    try {
      localizer.runLocalization(nmAddr);
      Assert.fail("Localization succeeded unexpectedly!");
    }
 catch (    IOException e) {
      verify(localizer).closeFileSystems(any(UserGroupInformation.class));
    }
  }
  @Test public void testMultipleLocalizers() throws Exception {
    FakeContainerLocalizerWrapper testA=new FakeContainerLocalizerWrapper();
    FakeContainerLocalizerWrapper testB=new FakeContainerLocalizerWrapper();
    FakeContainerLocalizer localizerA=testA.init();
    FakeContainerLocalizer localizerB=testB.init();
    Thread threadA=new Thread(){
      @Override public void run(){
        try {
          localizerA.runLocalization(nmAddr);
        }
 catch (        Exception e) {
          LOG.warn(e.toString());
        }
      }
    }
;
    Thread threadB=new Thread(){
      @Override public void run(){
        try {
          localizerB.runLocalization(nmAddr);
        }
 catch (        Exception e) {
          LOG.warn(e.toString());
        }
      }
    }
;
    ShellCommandExecutor shexcA=null;
    ShellCommandExecutor shexcB=null;
    try {
      threadA.start();
      threadB.start();
      GenericTestUtils.waitFor(new Supplier<Boolean>(){
        @Override public Boolean get(){
          FakeContainerLocalizer.FakeLongDownload downloader=localizerA.getDownloader();
          return downloader != null && downloader.getShexc() != null && downloader.getShexc().getProcess() != null;
        }
      }
,10,30000);
      GenericTestUtils.waitFor(new Supplier<Boolean>(){
        @Override public Boolean get(){
          FakeContainerLocalizer.FakeLongDownload downloader=localizerB.getDownloader();
          return downloader != null && downloader.getShexc() != null && downloader.getShexc().getProcess() != null;
        }
      }
,10,30000);
      shexcA=localizerA.getDownloader().getShexc();
      shexcB=localizerB.getDownloader().getShexc();
      assertTrue("Localizer A process not running, but should be",shexcA.getProcess().isAlive());
      assertTrue("Localizer B process not running, but should be",shexcB.getProcess().isAlive());
      testA.heartbeatResponse++;
      testB.heartbeatResponse++;
      testA.heartbeatResponse++;
      threadA.join();
      shexcA.getProcess().waitFor(10000,TimeUnit.MILLISECONDS);
      assertFalse("Localizer A process is still running, but shouldn't be",shexcA.getProcess().isAlive());
      assertTrue("Localizer B process not running, but should be",shexcB.getProcess().isAlive());
    }
  finally {
      shexcA.getProcess().destroy();
      shexcB.getProcess().destroy();
      shexcA.getProcess().waitFor(10000,TimeUnit.MILLISECONDS);
      shexcB.getProcess().waitFor(10000,TimeUnit.MILLISECONDS);
      threadA.join();
      testB.heartbeatResponse++;
      threadB.join();
    }
  }
  private void mockOutDownloads(  ContainerLocalizer localizer){
    ExecutorService syncExec=mock(ExecutorService.class);
    CompletionService<Path> cs=mock(CompletionService.class);
    when(cs.submit(isA(Callable.class))).thenAnswer(new Answer<Future<Path>>(){
      @Override public Future<Path> answer(      InvocationOnMock invoc) throws Throwable {
        Future<Path> done=mock(Future.class);
        when(done.isDone()).thenReturn(true);
        FakeDownload d=(FakeDownload)invoc.getArguments()[0];
        when(done.get()).thenReturn(d.call());
        return done;
      }
    }
);
    doReturn(syncExec).when(localizer).createDownloadThreadPool();
    doReturn(cs).when(localizer).createCompletionService(syncExec);
  }
static class HBMatches extends ArgumentMatcher<LocalizerStatus> {
    final LocalResource rsrc;
    HBMatches(    LocalResource rsrc){
      this.rsrc=rsrc;
    }
    @Override public boolean matches(    Object o){
      LocalizerStatus status=(LocalizerStatus)o;
      for (      LocalResourceStatus localized : status.getResources()) {
switch (localized.getStatus()) {
case FETCH_SUCCESS:
          if (localized.getLocalPath().getFile().contains(rsrc.getResource().getFile())) {
            return true;
          }
        break;
default :
      fail("Unexpected: " + localized.getStatus());
    break;
}
}
return false;
}
}
static class FakeDownload implements Callable<Path> {
private final Path localPath;
private final boolean succeed;
FakeDownload(String absPath,boolean succeed){
this.localPath=new Path("file:///localcache" + absPath);
this.succeed=succeed;
}
@Override public Path call() throws IOException {
if (!succeed) {
throw new IOException("FAIL " + localPath);
}
return localPath;
}
}
class FakeContainerLocalizer extends ContainerLocalizer {
private FakeLongDownload downloader;
FakeContainerLocalizer(FileContext lfs,String user,String appId,String localizerId,List<Path> localDirs,RecordFactory recordFactory) throws IOException {
super(lfs,user,appId,localizerId,localDirs,recordFactory);
}
FakeLongDownload getDownloader(){
return downloader;
}
@Override Callable<Path> download(Path path,LocalResource rsrc,UserGroupInformation ugi) throws IOException {
downloader=new FakeLongDownload(Mockito.mock(FileContext.class),ugi,new Configuration(),path,rsrc);
return downloader;
}
class FakeLongDownload extends ContainerLocalizer.FSDownloadWrapper {
private final Path localPath;
private Shell.ShellCommandExecutor shexc;
FakeLongDownload(FileContext files,UserGroupInformation ugi,Configuration conf,Path destDirPath,LocalResource resource){
super(files,ugi,conf,destDirPath,resource);
this.localPath=new Path("file:///localcache");
}
Shell.ShellCommandExecutor getShexc(){
return shexc;
}
@Override public Path doDownloadCall() throws IOException {
String sleepCommand="sleep 30";
String[] shellCmd={"bash","-c",sleepCommand};
shexc=new Shell.ShellCommandExecutor(shellCmd);
shexc.execute();
return localPath;
}
}
}
class ContainerLocalizerWrapper {
AbstractFileSystem spylfs;
Random random;
List<Path> localDirs;
Path tokenPath;
LocalizationProtocol nmProxy;
@SuppressWarnings("unchecked") FakeContainerLocalizer setupContainerLocalizerForTest() throws Exception {
FileContext fs=FileContext.getLocalFSFileContext();
spylfs=spy(fs.getDefaultFileSystem());
doNothing().when(spylfs).mkdir(isA(Path.class),isA(FsPermission.class),anyBoolean());
Configuration conf=new Configuration();
FileContext lfs=FileContext.getFileContext(spylfs,conf);
localDirs=new ArrayList<Path>();
for (int i=0; i < 4; ++i) {
localDirs.add(lfs.makeQualified(new Path(basedir,i + "")));
}
RecordFactory mockRF=getMockLocalizerRecordFactory();
FakeContainerLocalizer concreteLoc=new FakeContainerLocalizer(lfs,appUser,appId,containerId,localDirs,mockRF);
FakeContainerLocalizer localizer=spy(concreteLoc);
random=new Random();
long seed=random.nextLong();
System.out.println("SEED: " + seed);
random.setSeed(seed);
DataInputBuffer appTokens=createFakeCredentials(random,10);
tokenPath=lfs.makeQualified(new Path(String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,containerId)));
doReturn(new FSDataInputStream(new FakeFSDataInputStream(appTokens))).when(spylfs).open(tokenPath);
nmProxy=mock(LocalizationProtocol.class);
doReturn(nmProxy).when(localizer).getProxy(nmAddr);
doNothing().when(localizer).sleep(anyInt());
return localizer;
}
}
class FakeContainerLocalizerWrapper extends ContainerLocalizerWrapper {
private int heartbeatResponse=0;
public FakeContainerLocalizer init() throws Exception {
FileContext fs=FileContext.getLocalFSFileContext();
FakeContainerLocalizer localizer=setupContainerLocalizerForTest();
List<Path> privCacheList=new ArrayList<Path>();
for (Path p : localDirs) {
Path base=new Path(new Path(p,ContainerLocalizer.USERCACHE),appUser);
Path privcache=new Path(base,ContainerLocalizer.FILECACHE);
privCacheList.add(privcache);
}
ResourceLocalizationSpec rsrc=getMockRsrc(random,LocalResourceVisibility.PRIVATE,privCacheList.get(0));
doAnswer(new Answer<MockLocalizerHeartbeatResponse>(){
@Override public MockLocalizerHeartbeatResponse answer(InvocationOnMock invocationOnMock) throws Throwable {
  if (heartbeatResponse == 0) {
    return new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE,Collections.singletonList(rsrc));
  }
 else   if (heartbeatResponse < 2) {
    return new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE,Collections.<ResourceLocalizationSpec>emptyList());
  }
 else {
    return new MockLocalizerHeartbeatResponse(LocalizerAction.DIE,null);
  }
}
}
).when(nmProxy).heartbeat(isA(LocalizerStatus.class));
return localizer;
}
}
static RecordFactory getMockLocalizerRecordFactory(){
RecordFactory mockRF=mock(RecordFactory.class);
when(mockRF.newRecordInstance(same(LocalResourceStatus.class))).thenAnswer(new Answer<LocalResourceStatus>(){
@Override public LocalResourceStatus answer(InvocationOnMock invoc) throws Throwable {
return new MockLocalResourceStatus();
}
}
);
when(mockRF.newRecordInstance(same(LocalizerStatus.class))).thenAnswer(new Answer<LocalizerStatus>(){
@Override public LocalizerStatus answer(InvocationOnMock invoc) throws Throwable {
return new MockLocalizerStatus();
}
}
);
return mockRF;
}
static ResourceLocalizationSpec getMockRsrc(Random r,LocalResourceVisibility vis,Path p){
ResourceLocalizationSpec resourceLocalizationSpec=mock(ResourceLocalizationSpec.class);
LocalResource rsrc=mock(LocalResource.class);
String name=Long.toHexString(r.nextLong());
URL uri=mock(org.apache.hadoop.yarn.api.records.URL.class);
when(uri.getScheme()).thenReturn("file");
when(uri.getHost()).thenReturn(null);
when(uri.getFile()).thenReturn("/local/" + vis + "/"+ name);
when(rsrc.getResource()).thenReturn(uri);
when(rsrc.getSize()).thenReturn(r.nextInt(1024) + 1024L);
when(rsrc.getTimestamp()).thenReturn(r.nextInt(1024) + 2048L);
when(rsrc.getType()).thenReturn(LocalResourceType.FILE);
when(rsrc.getVisibility()).thenReturn(vis);
when(resourceLocalizationSpec.getResource()).thenReturn(rsrc);
when(resourceLocalizationSpec.getDestinationDirectory()).thenReturn(URL.fromPath(p));
return resourceLocalizationSpec;
}
@SuppressWarnings({"rawtypes","unchecked"}) static DataInputBuffer createFakeCredentials(Random r,int nTok) throws IOException {
Credentials creds=new Credentials();
byte[] password=new byte[20];
Text kind=new Text();
Text service=new Text();
Text alias=new Text();
for (int i=0; i < nTok; ++i) {
byte[] identifier=("idef" + i).getBytes();
r.nextBytes(password);
kind.set("kind" + i);
service.set("service" + i);
alias.set("token" + i);
Token token=new Token(identifier,password,kind,service);
creds.addToken(alias,token);
}
DataOutputBuffer buf=new DataOutputBuffer();
creds.writeTokenStorageToStream(buf);
DataInputBuffer ret=new DataInputBuffer();
ret.reset(buf.getData(),0,buf.getLength());
return ret;
}
@Test(timeout=10000) public void testUserCacheDirPermission() throws Exception {
Configuration conf=new Configuration();
conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY,"077");
FileContext lfs=FileContext.getLocalFSFileContext(conf);
Path fileCacheDir=lfs.makeQualified(new Path(basedir,"filecache"));
lfs.mkdir(fileCacheDir,FsPermission.getDefault(),true);
RecordFactory recordFactory=mock(RecordFactory.class);
ContainerLocalizer localizer=new ContainerLocalizer(lfs,UserGroupInformation.getCurrentUser().getUserName(),"application_01","container_01",new ArrayList<Path>(),recordFactory);
LocalResource rsrc=mock(LocalResource.class);
when(rsrc.getVisibility()).thenReturn(LocalResourceVisibility.PRIVATE);
Path destDirPath=new Path(fileCacheDir,"0/0/85");
FsPermission wrongPerm=new FsPermission((short)0700);
lfs.mkdir(destDirPath.getParent().getParent(),wrongPerm,false);
lfs.mkdir(destDirPath.getParent(),wrongPerm,false);
localizer.download(destDirPath,rsrc,UserGroupInformation.getCurrentUser());
Assert.assertEquals("Cache directory permissions filecache/0/0 is incorrect",USERCACHE_DIR_PERM,lfs.getFileStatus(destDirPath.getParent()).getPermission());
Assert.assertEquals("Cache directory permissions filecache/0 is incorrect",USERCACHE_DIR_PERM,lfs.getFileStatus(destDirPath.getParent().getParent()).getPermission());
}
}
