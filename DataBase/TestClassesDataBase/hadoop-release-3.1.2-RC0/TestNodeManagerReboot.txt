public class TestNodeManagerReboot {
  static final File basedir=new File("target",TestNodeManagerReboot.class.getName());
  static final File logsDir=new File(basedir,"logs");
  static final File nmLocalDir=new File(basedir,"nm0");
  static final File localResourceDir=new File(basedir,"resource");
  static final String user=System.getProperty("user.name");
  private FileContext localFS;
  private MyNodeManager nm;
  private DeletionService delService;
  static final Logger LOG=LoggerFactory.getLogger(TestNodeManagerReboot.class);
  @Before public void setup() throws UnsupportedFileSystemException {
    localFS=FileContext.getLocalFSFileContext();
  }
  @After public void tearDown() throws IOException, InterruptedException {
    localFS.delete(new Path(basedir.getPath()),true);
    if (nm != null) {
      nm.stop();
    }
  }
  @Test(timeout=2000000) public void testClearLocalDirWhenNodeReboot() throws IOException, YarnException, InterruptedException {
    nm=new MyNodeManager();
    nm.start();
    final ContainerManagementProtocol containerManager=nm.getContainerManager();
    createFiles(nmLocalDir.getAbsolutePath(),ContainerLocalizer.FILECACHE,100);
    localResourceDir.mkdirs();
    ContainerLaunchContext containerLaunchContext=Records.newRecord(ContainerLaunchContext.class);
    ContainerId cId=createContainerId();
    URL localResourceUri=URL.fromPath(localFS.makeQualified(new Path(localResourceDir.getAbsolutePath())));
    LocalResource localResource=LocalResource.newInstance(localResourceUri,LocalResourceType.FILE,LocalResourceVisibility.APPLICATION,-1,localResourceDir.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,localResource);
    containerLaunchContext.setLocalResources(localResources);
    List<String> commands=new ArrayList<String>();
    containerLaunchContext.setCommands(commands);
    NodeId nodeId=nm.getNMContext().getNodeId();
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,TestContainerManager.createContainerToken(cId,0,nodeId,destinationFile,nm.getNMContext().getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<StartContainerRequest>();
    list.add(scRequest);
    final StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    final UserGroupInformation currentUser=UserGroupInformation.createRemoteUser(cId.getApplicationAttemptId().toString());
    NMTokenIdentifier nmIdentifier=new NMTokenIdentifier(cId.getApplicationAttemptId(),nodeId,user,123);
    currentUser.addTokenIdentifier(nmIdentifier);
    currentUser.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws YarnException, IOException {
        nm.getContainerManager().startContainers(allRequests);
        return null;
      }
    }
);
    List<ContainerId> containerIds=new ArrayList<ContainerId>();
    containerIds.add(cId);
    GetContainerStatusesRequest request=GetContainerStatusesRequest.newInstance(containerIds);
    Container container=nm.getNMContext().getContainers().get(request.getContainerIds().get(0));
    final int MAX_TRIES=20;
    int numTries=0;
    while (!container.getContainerState().equals(ContainerState.DONE) && numTries <= MAX_TRIES) {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException ex) {
      }
      numTries++;
    }
    Assert.assertEquals(ContainerState.DONE,container.getContainerState());
    Assert.assertTrue("The container should create a subDir named currentUser: " + user + "under localDir/usercache",numOfLocalDirs(nmLocalDir.getAbsolutePath(),ContainerLocalizer.USERCACHE) > 0);
    Assert.assertTrue("There should be files or Dirs under nm_private when " + "container is launched",numOfLocalDirs(nmLocalDir.getAbsolutePath(),ResourceLocalizationService.NM_PRIVATE_DIR) > 0);
    restartNM(MAX_TRIES);
    checkNumOfLocalDirs();
    verify(delService,times(1)).delete(argThat(new FileDeletionMatcher(delService,null,new Path(ResourceLocalizationService.NM_PRIVATE_DIR + "_DEL_"),null)));
    verify(delService,times(1)).delete(argThat(new FileDeletionMatcher(delService,null,new Path(ContainerLocalizer.FILECACHE + "_DEL_"),null)));
    verify(delService,times(1)).delete(argThat(new FileDeletionMatcher(delService,user,null,Arrays.asList(new Path(destinationFile)))));
    verify(delService,times(1)).delete(argThat(new FileDeletionMatcher(delService,null,new Path(ContainerLocalizer.USERCACHE + "_DEL_"),new ArrayList<Path>())));
    restartNM(MAX_TRIES);
    checkNumOfLocalDirs();
  }
  private void restartNM(  int maxTries) throws IOException {
    nm.stop();
    nm=new MyNodeManager();
    nm.start();
    int numTries=0;
    while ((numOfLocalDirs(nmLocalDir.getAbsolutePath(),ContainerLocalizer.USERCACHE) > 0 || numOfLocalDirs(nmLocalDir.getAbsolutePath(),ContainerLocalizer.FILECACHE) > 0 || numOfLocalDirs(nmLocalDir.getAbsolutePath(),ResourceLocalizationService.NM_PRIVATE_DIR) > 0) && numTries < maxTries) {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException ex) {
      }
      numTries++;
    }
  }
  private void checkNumOfLocalDirs() throws IOException {
    Assert.assertTrue("After NM reboots, all local files should be deleted",numOfLocalDirs(nmLocalDir.getAbsolutePath(),ContainerLocalizer.USERCACHE) == 0 && numOfLocalDirs(nmLocalDir.getAbsolutePath(),ContainerLocalizer.FILECACHE) == 0 && numOfLocalDirs(nmLocalDir.getAbsolutePath(),ResourceLocalizationService.NM_PRIVATE_DIR) == 0);
    Assert.assertTrue("After NM reboots, usercache_DEL_* directory should be deleted",numOfUsercacheDELDirs(nmLocalDir.getAbsolutePath()) == 0);
  }
  private int numOfLocalDirs(  String localDir,  String localSubDir){
    File[] listOfFiles=new File(localDir,localSubDir).listFiles();
    if (listOfFiles == null) {
      return 0;
    }
 else {
      return listOfFiles.length;
    }
  }
  private int numOfUsercacheDELDirs(  String localDir) throws IOException {
    int count=0;
    RemoteIterator<FileStatus> fileStatus=localFS.listStatus(new Path(localDir));
    while (fileStatus.hasNext()) {
      FileStatus status=fileStatus.next();
      if (status.getPath().getName().matches(".*" + ContainerLocalizer.USERCACHE + "_DEL_.*")) {
        count++;
      }
    }
    return count;
  }
  private void createFiles(  String dir,  String subDir,  int numOfFiles){
    for (int i=0; i < numOfFiles; i++) {
      File newFile=new File(dir + "/" + subDir,"file_" + (i + 1));
      try {
        newFile.createNewFile();
      }
 catch (      IOException e) {
      }
    }
  }
  private ContainerId createContainerId(){
    ApplicationId appId=ApplicationId.newInstance(0,0);
    ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,1);
    ContainerId containerId=ContainerId.newContainerId(appAttemptId,0);
    return containerId;
  }
private class MyNodeManager extends NodeManager {
    public MyNodeManager() throws IOException {
      super();
      this.init(createNMConfig());
    }
    @Override protected NodeStatusUpdater createNodeStatusUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker){
      MockNodeStatusUpdater myNodeStatusUpdater=new MockNodeStatusUpdater(context,dispatcher,healthChecker,metrics);
      return myNodeStatusUpdater;
    }
    @Override protected DeletionService createDeletionService(    ContainerExecutor exec){
      delService=spy(new DeletionService(exec));
      return delService;
    }
    private YarnConfiguration createNMConfig() throws IOException {
      YarnConfiguration conf=new YarnConfiguration();
      conf.setInt(YarnConfiguration.NM_PMEM_MB,5 * 1024);
      conf.set(YarnConfiguration.NM_ADDRESS,"127.0.0.1:" + ServerSocketUtil.getPort(49152,10));
      conf.set(YarnConfiguration.NM_LOCALIZER_ADDRESS,"127.0.0.1:" + ServerSocketUtil.getPort(49153,10));
      conf.set(YarnConfiguration.NM_LOG_DIRS,logsDir.getAbsolutePath());
      conf.set(YarnConfiguration.NM_LOCAL_DIRS,nmLocalDir.getAbsolutePath());
      conf.setLong(YarnConfiguration.NM_LOG_RETAIN_SECONDS,1);
      return conf;
    }
  }
}
