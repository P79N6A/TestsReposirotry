public class TestNameNodeResourceChecker {
  private final static File BASE_DIR=PathUtils.getTestDir(TestNameNodeResourceChecker.class);
  private Configuration conf;
  private File baseDir;
  private File nameDir;
  @Before public void setUp() throws IOException {
    conf=new Configuration();
    nameDir=new File(BASE_DIR,"resource-check-name-dir");
    nameDir.mkdirs();
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameDir.getAbsolutePath());
  }
  /** 
 * Tests that hasAvailableDiskSpace returns true if disk usage is below threshold.
 */
  @Test public void testCheckAvailability() throws IOException {
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_DU_RESERVED_KEY,0);
    NameNodeResourceChecker nb=new NameNodeResourceChecker(conf);
    assertTrue("isResourceAvailable must return true if " + "disk usage is lower than threshold",nb.hasAvailableDiskSpace());
  }
  /** 
 * Tests that hasAvailableDiskSpace returns false if disk usage is above threshold.
 */
  @Test public void testCheckAvailabilityNeg() throws IOException {
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_DU_RESERVED_KEY,Long.MAX_VALUE);
    NameNodeResourceChecker nb=new NameNodeResourceChecker(conf);
    assertFalse("isResourceAvailable must return false if " + "disk usage is higher than threshold",nb.hasAvailableDiskSpace());
  }
  /** 
 * Tests that NameNode resource monitor causes the NN to enter safe mode when resources are low.
 */
  @Test public void testCheckThatNameNodeResourceMonitorIsRunning() throws IOException, InterruptedException {
    MiniDFSCluster cluster=null;
    try {
      conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameDir.getAbsolutePath());
      conf.setLong(DFSConfigKeys.DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY,1);
      cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
      MockNameNodeResourceChecker mockResourceChecker=new MockNameNodeResourceChecker(conf);
      cluster.getNameNode().getNamesystem().nnResourceChecker=mockResourceChecker;
      cluster.waitActive();
      String name=NameNodeResourceMonitor.class.getName();
      boolean isNameNodeMonitorRunning=false;
      Set<Thread> runningThreads=Thread.getAllStackTraces().keySet();
      for (      Thread runningThread : runningThreads) {
        if (runningThread.toString().startsWith("Thread[" + name)) {
          isNameNodeMonitorRunning=true;
          break;
        }
      }
      assertTrue("NN resource monitor should be running",isNameNodeMonitorRunning);
      assertFalse("NN should not presently be in safe mode",cluster.getNameNode().isInSafeMode());
      mockResourceChecker.setResourcesAvailable(false);
      long startMillis=Time.now();
      while (!cluster.getNameNode().isInSafeMode() && Time.now() < startMillis + (60 * 1000)) {
        Thread.sleep(1000);
      }
      assertTrue("NN should be in safe mode after resources crossed threshold",cluster.getNameNode().isInSafeMode());
    }
  finally {
      if (cluster != null)       cluster.shutdown();
    }
  }
  /** 
 * Tests that only a single space check is performed if two name dirs are supplied which are on the same volume.
 */
  @Test public void testChecking2NameDirsOnOneVolume() throws IOException {
    Configuration conf=new Configuration();
    File nameDir1=new File(BASE_DIR,"name-dir1");
    File nameDir2=new File(BASE_DIR,"name-dir2");
    nameDir1.mkdirs();
    nameDir2.mkdirs();
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameDir1.getAbsolutePath() + "," + nameDir2.getAbsolutePath());
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_DU_RESERVED_KEY,Long.MAX_VALUE);
    NameNodeResourceChecker nb=new NameNodeResourceChecker(conf);
    assertEquals("Should not check the same volume more than once.",1,nb.getVolumesLowOnSpace().size());
  }
  /** 
 * Tests that only a single space check is performed if extra volumes are configured manually which also coincide with a volume the name dir is on.
 */
  @Test public void testCheckingExtraVolumes() throws IOException {
    Configuration conf=new Configuration();
    File nameDir=new File(BASE_DIR,"name-dir");
    nameDir.mkdirs();
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameDir.getAbsolutePath());
    conf.set(DFSConfigKeys.DFS_NAMENODE_CHECKED_VOLUMES_KEY,nameDir.getAbsolutePath());
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_DU_RESERVED_KEY,Long.MAX_VALUE);
    NameNodeResourceChecker nb=new NameNodeResourceChecker(conf);
    assertEquals("Should not check the same volume more than once.",1,nb.getVolumesLowOnSpace().size());
  }
  /** 
 * Test that the NN is considered to be out of resources only once all redundant configured volumes are low on resources, or when any required volume is low on resources. 
 */
  @Test public void testLowResourceVolumePolicy() throws IOException, URISyntaxException {
    Configuration conf=new Configuration();
    File nameDir1=new File(BASE_DIR,"name-dir1");
    File nameDir2=new File(BASE_DIR,"name-dir2");
    nameDir1.mkdirs();
    nameDir2.mkdirs();
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameDir1.getAbsolutePath() + "," + nameDir2.getAbsolutePath());
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKED_VOLUMES_MINIMUM_KEY,2);
    NameNodeResourceChecker nnrc=new NameNodeResourceChecker(conf);
    Map<String,CheckedVolume> volumes=new HashMap<String,CheckedVolume>();
    CheckedVolume volume1=Mockito.mock(CheckedVolume.class);
    CheckedVolume volume2=Mockito.mock(CheckedVolume.class);
    CheckedVolume volume3=Mockito.mock(CheckedVolume.class);
    CheckedVolume volume4=Mockito.mock(CheckedVolume.class);
    CheckedVolume volume5=Mockito.mock(CheckedVolume.class);
    Mockito.when(volume1.isResourceAvailable()).thenReturn(true);
    Mockito.when(volume2.isResourceAvailable()).thenReturn(true);
    Mockito.when(volume3.isResourceAvailable()).thenReturn(true);
    Mockito.when(volume4.isResourceAvailable()).thenReturn(true);
    Mockito.when(volume5.isResourceAvailable()).thenReturn(true);
    Mockito.when(volume4.isRequired()).thenReturn(true);
    Mockito.when(volume5.isRequired()).thenReturn(true);
    volumes.put("volume1",volume1);
    volumes.put("volume2",volume2);
    volumes.put("volume3",volume3);
    volumes.put("volume4",volume4);
    volumes.put("volume5",volume5);
    nnrc.setVolumes(volumes);
    assertTrue(nnrc.hasAvailableDiskSpace());
    Mockito.when(volume1.isResourceAvailable()).thenReturn(false);
    assertTrue(nnrc.hasAvailableDiskSpace());
    Mockito.when(volume2.isResourceAvailable()).thenReturn(false);
    assertFalse(nnrc.hasAvailableDiskSpace());
    nnrc.setMinimumReduntdantVolumes(1);
    assertTrue(nnrc.hasAvailableDiskSpace());
    Mockito.when(volume3.isResourceAvailable()).thenReturn(false);
    assertFalse(nnrc.hasAvailableDiskSpace());
    Mockito.when(volume3.isResourceAvailable()).thenReturn(true);
    Mockito.when(volume4.isResourceAvailable()).thenReturn(false);
    assertFalse(nnrc.hasAvailableDiskSpace());
  }
}
