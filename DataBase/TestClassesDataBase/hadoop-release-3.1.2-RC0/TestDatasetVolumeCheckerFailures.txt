/** 
 * Test a few more conditions not covered by TestDatasetVolumeChecker.
 */
public class TestDatasetVolumeCheckerFailures {
  public static final Logger LOG=LoggerFactory.getLogger(TestDatasetVolumeCheckerFailures.class);
  private FakeTimer timer;
  private Configuration conf;
  private static final long MIN_DISK_CHECK_GAP_MS=1000;
  @Before public void commonInit(){
    timer=new FakeTimer();
    conf=new HdfsConfiguration();
    conf.setTimeDuration(DFSConfigKeys.DFS_DATANODE_DISK_CHECK_MIN_GAP_KEY,MIN_DISK_CHECK_GAP_MS,TimeUnit.MILLISECONDS);
  }
  /** 
 * Test timeout in  {@link DatasetVolumeChecker#checkAllVolumes}.
 * @throws Exception
 */
  @Test(timeout=60000) public void testTimeout() throws Exception {
    final List<FsVolumeSpi> volumes=Collections.singletonList(makeHungVolume());
    final FsDatasetSpi<FsVolumeSpi> dataset=TestDatasetVolumeChecker.makeDataset(volumes);
    conf.setTimeDuration(DFSConfigKeys.DFS_DATANODE_DISK_CHECK_TIMEOUT_KEY,1,TimeUnit.SECONDS);
    final DatasetVolumeChecker checker=new DatasetVolumeChecker(conf,new FakeTimer());
    Set<FsVolumeSpi> failedVolumes=checker.checkAllVolumes(dataset);
    assertThat(failedVolumes.size(),is(1));
  }
  /** 
 * Test checking a closed volume i.e. one which cannot be referenced.
 * @throws Exception
 */
  @Test(timeout=60000) public void testCheckingClosedVolume() throws Exception {
    final List<FsVolumeSpi> volumes=Collections.singletonList(makeClosedVolume());
    final FsDatasetSpi<FsVolumeSpi> dataset=TestDatasetVolumeChecker.makeDataset(volumes);
    DatasetVolumeChecker checker=new DatasetVolumeChecker(conf,timer);
    Set<FsVolumeSpi> failedVolumes=checker.checkAllVolumes(dataset);
    assertThat(failedVolumes.size(),is(0));
    assertThat(checker.getNumSyncDatasetChecks(),is(0L));
    verify(volumes.get(0),times(0)).check(anyObject());
  }
  @Test(timeout=60000) public void testMinGapIsEnforcedForSyncChecks() throws Exception {
    final List<FsVolumeSpi> volumes=TestDatasetVolumeChecker.makeVolumes(1,VolumeCheckResult.HEALTHY);
    final FsDatasetSpi<FsVolumeSpi> dataset=TestDatasetVolumeChecker.makeDataset(volumes);
    final DatasetVolumeChecker checker=new DatasetVolumeChecker(conf,timer);
    checker.checkAllVolumes(dataset);
    assertThat(checker.getNumSyncDatasetChecks(),is(1L));
    checker.checkAllVolumes(dataset);
    assertThat(checker.getNumSyncDatasetChecks(),is(1L));
    assertThat(checker.getNumSkippedChecks(),is(1L));
    timer.advance(MIN_DISK_CHECK_GAP_MS);
    checker.checkAllVolumes(dataset);
    assertThat(checker.getNumSyncDatasetChecks(),is(2L));
    assertThat(checker.getNumSkippedChecks(),is(1L));
  }
  /** 
 * Create a mock FsVolumeSpi whose  {@link FsVolumeSpi#check} routinehangs forever.
 * @return volume
 * @throws Exception
 */
  private static FsVolumeSpi makeHungVolume() throws Exception {
    final FsVolumeSpi volume=mock(FsVolumeSpi.class);
    final FsVolumeReference reference=mock(FsVolumeReference.class);
    final StorageLocation location=mock(StorageLocation.class);
    when(reference.getVolume()).thenReturn(volume);
    when(volume.obtainReference()).thenReturn(reference);
    when(volume.getStorageLocation()).thenReturn(location);
    when(volume.check(anyObject())).thenAnswer(new Answer<VolumeCheckResult>(){
      @Override public VolumeCheckResult answer(      InvocationOnMock invocation) throws Throwable {
        Thread.sleep(Long.MAX_VALUE);
        return VolumeCheckResult.HEALTHY;
      }
    }
);
    return volume;
  }
  /** 
 * Create a mock FsVolumeSpi which is closed and hence cannot be referenced.
 * @return volume
 * @throws Exception
 */
  private static FsVolumeSpi makeClosedVolume() throws Exception {
    final FsVolumeSpi volume=mock(FsVolumeSpi.class);
    final StorageLocation location=mock(StorageLocation.class);
    when(volume.obtainReference()).thenThrow(new ClosedChannelException());
    when(volume.getStorageLocation()).thenReturn(location);
    return volume;
  }
}
