/** 
 * This class implements some of tests posted in HADOOP-2658. 
 */
public class TestFileAppend3 {
{
    DFSTestUtil.setNameNodeLogLevel(Level.ALL);
    GenericTestUtils.setLogLevel(DataNode.LOG,Level.ALL);
    GenericTestUtils.setLogLevel(DFSClient.LOG,Level.ALL);
    GenericTestUtils.setLogLevel(InterDatanodeProtocol.LOG,org.slf4j.event.Level.TRACE);
  }
  static final long BLOCK_SIZE=64 * 1024;
  static final short REPLICATION=3;
  static final int DATANODE_NUM=5;
  private static Configuration conf;
  private static int buffersize;
  private static MiniDFSCluster cluster;
  private static DistributedFileSystem fs;
  @BeforeClass public static void setUp() throws java.lang.Exception {
    AppendTestUtil.LOG.info("setUp()");
    conf=new HdfsConfiguration();
    conf.setInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY,512);
    buffersize=conf.getInt(CommonConfigurationKeys.IO_FILE_BUFFER_SIZE_KEY,4096);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(DATANODE_NUM).build();
    fs=cluster.getFileSystem();
  }
  @AfterClass public static void tearDown() throws Exception {
    AppendTestUtil.LOG.info("tearDown()");
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
  /** 
 * TC1: Append on block boundary.
 * @throws IOException an exception might be thrown
 */
  @Test public void testTC1() throws Exception {
    final Path p=new Path("/TC1/foo");
    System.out.println("p=" + p);
    final int len1=(int)BLOCK_SIZE;
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,len1);
      out.close();
    }
    final int len2=(int)BLOCK_SIZE / 2;
{
      FSDataOutputStream out=fs.append(p);
      AppendTestUtil.write(out,len1,len2);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1 + len2);
  }
  @Test public void testTC1ForAppend2() throws Exception {
    final Path p=new Path("/TC1/foo2");
    final int len1=(int)BLOCK_SIZE;
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,len1);
      out.close();
    }
    final int len2=(int)BLOCK_SIZE / 2;
{
      FSDataOutputStream out=fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null);
      AppendTestUtil.write(out,len1,len2);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1 + len2);
  }
  /** 
 * TC2: Append on non-block boundary.
 * @throws IOException an exception might be thrown
 */
  @Test public void testTC2() throws Exception {
    final Path p=new Path("/TC2/foo");
    System.out.println("p=" + p);
    final int len1=(int)(BLOCK_SIZE + BLOCK_SIZE / 2);
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,len1);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1);
    final int len2=(int)BLOCK_SIZE / 4;
{
      FSDataOutputStream out=fs.append(p);
      AppendTestUtil.write(out,len1,len2);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1 + len2);
  }
  @Test public void testTC2ForAppend2() throws Exception {
    final Path p=new Path("/TC2/foo2");
    final int len1=(int)(BLOCK_SIZE + BLOCK_SIZE / 2);
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,len1);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1);
    final int len2=(int)BLOCK_SIZE / 4;
{
      FSDataOutputStream out=fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null);
      AppendTestUtil.write(out,len1,len2);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1 + len2);
    List<LocatedBlock> blocks=fs.getClient().getLocatedBlocks(p.toString(),0L).getLocatedBlocks();
    Assert.assertEquals(3,blocks.size());
    Assert.assertEquals(BLOCK_SIZE,blocks.get(0).getBlockSize());
    Assert.assertEquals(BLOCK_SIZE / 2,blocks.get(1).getBlockSize());
    Assert.assertEquals(BLOCK_SIZE / 4,blocks.get(2).getBlockSize());
  }
  /** 
 * TC5: Only one simultaneous append.
 * @throws IOException an exception might be thrown
 */
  @Test public void testTC5() throws Exception {
    final Path p=new Path("/TC5/foo");
    System.out.println("p=" + p);
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,(int)(BLOCK_SIZE / 2));
      out.close();
    }
    FSDataOutputStream out=fs.append(p);
    try {
      AppendTestUtil.createHdfsWithDifferentUsername(conf).append(p);
      fail("This should fail.");
    }
 catch (    IOException ioe) {
      AppendTestUtil.LOG.info("GOOD: got an exception",ioe);
    }
    try {
      ((DistributedFileSystem)AppendTestUtil.createHdfsWithDifferentUsername(conf)).append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null);
      fail("This should fail.");
    }
 catch (    IOException ioe) {
      AppendTestUtil.LOG.info("GOOD: got an exception",ioe);
    }
    out.close();
  }
  @Test public void testTC5ForAppend2() throws Exception {
    final Path p=new Path("/TC5/foo2");
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,(int)(BLOCK_SIZE / 2));
      out.close();
    }
    FSDataOutputStream out=fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null);
    try {
      ((DistributedFileSystem)AppendTestUtil.createHdfsWithDifferentUsername(conf)).append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null);
      fail("This should fail.");
    }
 catch (    IOException ioe) {
      AppendTestUtil.LOG.info("GOOD: got an exception",ioe);
    }
    try {
      AppendTestUtil.createHdfsWithDifferentUsername(conf).append(p);
      fail("This should fail.");
    }
 catch (    IOException ioe) {
      AppendTestUtil.LOG.info("GOOD: got an exception",ioe);
    }
    out.close();
  }
  /** 
 * TC7: Corrupted replicas are present.
 * @throws IOException an exception might be thrown
 */
  private void testTC7(  boolean appendToNewBlock) throws Exception {
    final short repl=2;
    final Path p=new Path("/TC7/foo" + (appendToNewBlock ? "0" : "1"));
    System.out.println("p=" + p);
    final int len1=(int)(BLOCK_SIZE / 2);
{
      FSDataOutputStream out=fs.create(p,false,buffersize,repl,BLOCK_SIZE);
      AppendTestUtil.write(out,0,len1);
      out.close();
    }
    DFSTestUtil.waitReplication(fs,p,repl);
    final LocatedBlocks locatedblocks=fs.dfs.getNamenode().getBlockLocations(p.toString(),0L,len1);
    assertEquals(1,locatedblocks.locatedBlockCount());
    final LocatedBlock lb=locatedblocks.get(0);
    final ExtendedBlock blk=lb.getBlock();
    assertEquals(len1,lb.getBlockSize());
    DatanodeInfo[] datanodeinfos=lb.getLocations();
    assertEquals(repl,datanodeinfos.length);
    final DataNode dn=cluster.getDataNode(datanodeinfos[0].getIpcPort());
    cluster.getMaterializedReplica(dn,blk).truncateData(0);
    final int len2=(int)BLOCK_SIZE;
{
      FSDataOutputStream out=appendToNewBlock ? fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null) : fs.append(p);
      AppendTestUtil.write(out,len1,len2);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1 + len2);
  }
  @Test public void testTC7() throws Exception {
    testTC7(false);
  }
  @Test public void testTC7ForAppend2() throws Exception {
    testTC7(true);
  }
  /** 
 * TC11: Racing rename
 */
  private void testTC11(  boolean appendToNewBlock) throws Exception {
    final Path p=new Path("/TC11/foo" + (appendToNewBlock ? "0" : "1"));
    System.out.println("p=" + p);
    final int len1=(int)BLOCK_SIZE;
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,len1);
      out.close();
    }
    FSDataOutputStream out=appendToNewBlock ? fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null) : fs.append(p);
    final int len2=(int)BLOCK_SIZE / 2;
    AppendTestUtil.write(out,len1,len2);
    out.hflush();
    final Path pnew=new Path(p + ".new");
    assertTrue(fs.rename(p,pnew));
    out.close();
    final long len=fs.getFileStatus(pnew).getLen();
    final LocatedBlocks locatedblocks=fs.dfs.getNamenode().getBlockLocations(pnew.toString(),0L,len);
    final int numblock=locatedblocks.locatedBlockCount();
    for (int i=0; i < numblock; i++) {
      final LocatedBlock lb=locatedblocks.get(i);
      final ExtendedBlock blk=lb.getBlock();
      final long size=lb.getBlockSize();
      if (i < numblock - 1) {
        assertEquals(BLOCK_SIZE,size);
      }
      for (      DatanodeInfo datanodeinfo : lb.getLocations()) {
        final DataNode dn=cluster.getDataNode(datanodeinfo.getIpcPort());
        final Block metainfo=DataNodeTestUtils.getFSDataset(dn).getStoredBlock(blk.getBlockPoolId(),blk.getBlockId());
        assertEquals(size,metainfo.getNumBytes());
      }
    }
  }
  @Test public void testTC11() throws Exception {
    testTC11(false);
  }
  @Test public void testTC11ForAppend2() throws Exception {
    testTC11(true);
  }
  /** 
 * TC12: Append to partial CRC chunk
 */
  private void testTC12(  boolean appendToNewBlock) throws Exception {
    final Path p=new Path("/TC12/foo" + (appendToNewBlock ? "0" : "1"));
    System.out.println("p=" + p);
    final int len1=25687;
{
      FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
      AppendTestUtil.write(out,0,len1);
      out.close();
    }
    final int len2=5877;
{
      FSDataOutputStream out=appendToNewBlock ? fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null) : fs.append(p);
      AppendTestUtil.write(out,len1,len2);
      out.close();
    }
    AppendTestUtil.check(fs,p,len1 + len2);
    if (appendToNewBlock) {
      LocatedBlocks blks=fs.dfs.getLocatedBlocks(p.toString(),0);
      Assert.assertEquals(2,blks.getLocatedBlocks().size());
      Assert.assertEquals(len1,blks.getLocatedBlocks().get(0).getBlockSize());
      Assert.assertEquals(len2,blks.getLocatedBlocks().get(1).getBlockSize());
      AppendTestUtil.check(fs,p,0,len1);
      AppendTestUtil.check(fs,p,len1,len2);
    }
  }
  @Test public void testTC12() throws Exception {
    testTC12(false);
  }
  @Test public void testTC12ForAppend2() throws Exception {
    testTC12(true);
  }
  /** 
 * Append to a partial CRC chunk and the first write does not fill up the partial CRC trunk
 */
  private void testAppendToPartialChunk(  boolean appendToNewBlock) throws IOException {
    final Path p=new Path("/partialChunk/foo" + (appendToNewBlock ? "0" : "1"));
    final int fileLen=513;
    System.out.println("p=" + p);
    byte[] fileContents=AppendTestUtil.initBuffer(fileLen);
    FSDataOutputStream stm=AppendTestUtil.createFile(fs,p,1);
    stm.write(fileContents,0,1);
    stm.close();
    System.out.println("Wrote 1 byte and closed the file " + p);
    stm=appendToNewBlock ? fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null) : fs.append(p);
    stm.write(fileContents,1,1);
    stm.hflush();
    stm.close();
    System.out.println("Append 1 byte and closed the file " + p);
    stm=appendToNewBlock ? fs.append(p,EnumSet.of(CreateFlag.APPEND,CreateFlag.NEW_BLOCK),4096,null) : fs.append(p);
    assertEquals(2,stm.getPos());
    stm.write(fileContents,2,1);
    stm.hflush();
    System.out.println("Append and flush 1 byte");
    stm.write(fileContents,3,2);
    stm.hflush();
    System.out.println("Append and flush 2 byte");
    stm.write(fileContents,5,fileLen - 5);
    stm.close();
    System.out.println("Flush 508 byte and closed the file " + p);
    AppendTestUtil.checkFullFile(fs,p,fileLen,fileContents,"Failed to append to a partial chunk");
  }
  void doSmallAppends(  Path file,  DistributedFileSystem fs,  int iterations) throws IOException {
    for (int i=0; i < iterations; i++) {
      FSDataOutputStream stm;
      try {
        stm=fs.append(file);
      }
 catch (      IOException e) {
        continue;
      }
      AppendTestUtil.write(stm,0,123);
      stm.close();
    }
  }
  @Test public void testSmallAppendRace() throws Exception {
    final Path file=new Path("/testSmallAppendRace");
    final String fName=file.toUri().getPath();
    FSDataOutputStream stm=fs.create(file);
    AppendTestUtil.write(stm,0,123);
    stm.close();
    final DFSClient client=DFSClientAdapter.getDFSClient(fs);
    DFSClient spyClient=spy(client);
    when(spyClient.getFileInfo(fName)).thenAnswer(new Answer<HdfsFileStatus>(){
      @Override public HdfsFileStatus answer(      InvocationOnMock invocation){
        try {
          HdfsFileStatus stat=client.getFileInfo(fName);
          Thread.sleep(100);
          return stat;
        }
 catch (        Exception e) {
          return null;
        }
      }
    }
);
    DFSClientAdapter.setDFSClient(fs,spyClient);
    Thread worker1=new Thread(){
      @Override public void run(){
        try {
          doSmallAppends(file,fs,20);
        }
 catch (        IOException e) {
        }
      }
    }
;
    Thread worker2=new Thread(){
      @Override public void run(){
        try {
          doSmallAppends(file,fs,20);
        }
 catch (        IOException e) {
        }
      }
    }
;
    worker1.start();
    worker2.start();
    doSmallAppends(file,fs,20);
  }
  @Test public void testAppendToPartialChunk() throws IOException {
    testAppendToPartialChunk(false);
  }
  @Test public void testAppendToPartialChunkforAppend2() throws IOException {
    testAppendToPartialChunk(true);
  }
}
