public class TestLease {
  static boolean hasLease(  MiniDFSCluster cluster,  Path src){
    return NameNodeAdapter.getLeaseForPath(cluster.getNameNode(),src.toString()) != null;
  }
  static int leaseCount(  MiniDFSCluster cluster){
    return NameNodeAdapter.getLeaseManager(cluster.getNamesystem()).countLease();
  }
  static final String dirString="/test/lease";
  final Path dir=new Path(dirString);
  static final Log LOG=LogFactory.getLog(TestLease.class);
  final Configuration conf=new HdfsConfiguration();
  @Test public void testLeaseAbort() throws Exception {
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
    try {
      cluster.waitActive();
      NamenodeProtocols preSpyNN=cluster.getNameNodeRpc();
      NamenodeProtocols spyNN=spy(preSpyNN);
      DFSClient dfs=new DFSClient(null,spyNN,conf,null);
      byte[] buf=new byte[1024];
      FSDataOutputStream c_out=createFsOut(dfs,dirString + "c");
      c_out.write(buf,0,1024);
      c_out.close();
      DFSInputStream c_in=dfs.open(dirString + "c");
      FSDataOutputStream d_out=createFsOut(dfs,dirString + "d");
      doThrow(new RemoteException(InvalidToken.class.getName(),"Your token is worthless")).when(spyNN).renewLease(anyString());
      LeaseRenewer originalRenewer=dfs.getLeaseRenewer();
      dfs.lastLeaseRenewal=Time.monotonicNow() - HdfsConstants.LEASE_SOFTLIMIT_PERIOD - 1000;
      try {
        dfs.renewLease();
      }
 catch (      IOException e) {
      }
      try {
        d_out.write(buf,0,1024);
        LOG.info("Write worked beyond the soft limit as expected.");
      }
 catch (      IOException e) {
        Assert.fail("Write failed.");
      }
      dfs.lastLeaseRenewal=Time.monotonicNow() - HdfsConstants.LEASE_HARDLIMIT_PERIOD - 1000;
      dfs.renewLease();
      try {
        d_out.write(buf,0,1024);
        d_out.close();
        Assert.fail("Write did not fail even after the fatal lease renewal failure");
      }
 catch (      IOException e) {
        LOG.info("Write failed as expected. ",e);
      }
      Thread.sleep(1000);
      Assert.assertTrue(originalRenewer.isEmpty());
      doNothing().when(spyNN).renewLease(anyString());
      try {
        int num=c_in.read(buf,0,1);
        if (num != 1) {
          Assert.fail("Failed to read 1 byte");
        }
        c_in.close();
      }
 catch (      IOException e) {
        LOG.error("Read failed with ",e);
        Assert.fail("Read after lease renewal failure failed");
      }
      try {
        c_out=createFsOut(dfs,dirString + "c");
        c_out.write(buf,0,1024);
        c_out.close();
      }
 catch (      IOException e) {
        LOG.error("Write failed with ",e);
        Assert.fail("Write failed");
      }
    }
  finally {
      cluster.shutdown();
    }
  }
  @Test public void testLeaseAfterRename() throws Exception {
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
    try {
      Path p=new Path("/test-file");
      Path d=new Path("/test-d");
      Path d2=new Path("/test-d-other");
      FileSystem fs=cluster.getFileSystem();
      FSDataOutputStream out=fs.create(p);
      out.writeBytes("something");
      Assert.assertTrue(hasLease(cluster,p));
      Assert.assertEquals(1,leaseCount(cluster));
      DistributedFileSystem fs2=(DistributedFileSystem)FileSystem.newInstance(fs.getUri(),fs.getConf());
      LOG.info("DMS: rename file into dir");
      Path pRenamed=new Path(d,p.getName());
      fs2.mkdirs(d);
      fs2.rename(p,pRenamed);
      Assert.assertFalse(p + " exists",fs2.exists(p));
      Assert.assertTrue(pRenamed + " not found",fs2.exists(pRenamed));
      Assert.assertFalse("has lease for " + p,hasLease(cluster,p));
      Assert.assertTrue("no lease for " + pRenamed,hasLease(cluster,pRenamed));
      Assert.assertEquals(1,leaseCount(cluster));
      LOG.info("DMS: rename parent dir");
      Path pRenamedAgain=new Path(d2,pRenamed.getName());
      fs2.rename(d,d2);
      Assert.assertFalse(d + " exists",fs2.exists(d));
      Assert.assertFalse("has lease for " + pRenamed,hasLease(cluster,pRenamed));
      Assert.assertTrue(d2 + " not found",fs2.exists(d2));
      Assert.assertTrue(pRenamedAgain + " not found",fs2.exists(pRenamedAgain));
      Assert.assertTrue("no lease for " + pRenamedAgain,hasLease(cluster,pRenamedAgain));
      Assert.assertEquals(1,leaseCount(cluster));
      LOG.info("DMS: rename parent again");
      pRenamed=pRenamedAgain;
      pRenamedAgain=new Path(new Path(d,d2.getName()),p.getName());
      fs2.mkdirs(d);
      fs2.rename(d2,d);
      Assert.assertFalse(d2 + " exists",fs2.exists(d2));
      Assert.assertFalse("no lease for " + pRenamed,hasLease(cluster,pRenamed));
      Assert.assertTrue(d + " not found",fs2.exists(d));
      Assert.assertTrue(pRenamedAgain + " not found",fs2.exists(pRenamedAgain));
      Assert.assertTrue("no lease for " + pRenamedAgain,hasLease(cluster,pRenamedAgain));
      Assert.assertEquals(1,leaseCount(cluster));
      pRenamed=pRenamedAgain;
      pRenamedAgain=new Path(d2,p.getName());
      fs2.rename(pRenamed.getParent(),d2,Options.Rename.OVERWRITE);
      Assert.assertFalse(pRenamed.getParent() + " not found",fs2.exists(pRenamed.getParent()));
      Assert.assertFalse("has lease for " + pRenamed,hasLease(cluster,pRenamed));
      Assert.assertTrue(d2 + " not found",fs2.exists(d2));
      Assert.assertTrue(pRenamedAgain + " not found",fs2.exists(pRenamedAgain));
      Assert.assertTrue("no lease for " + pRenamedAgain,hasLease(cluster,pRenamedAgain));
      Assert.assertEquals(1,leaseCount(cluster));
      pRenamed=pRenamedAgain;
      pRenamedAgain=new Path(d,p.getName());
      fs2.rename(pRenamed.getParent(),d,Options.Rename.OVERWRITE);
      Assert.assertFalse(pRenamed.getParent() + " not found",fs2.exists(pRenamed.getParent()));
      Assert.assertFalse("has lease for " + pRenamed,hasLease(cluster,pRenamed));
      Assert.assertTrue(d + " not found",fs2.exists(d));
      Assert.assertTrue(pRenamedAgain + " not found",fs2.exists(pRenamedAgain));
      Assert.assertTrue("no lease for " + pRenamedAgain,hasLease(cluster,pRenamedAgain));
      Assert.assertEquals(1,leaseCount(cluster));
      out.close();
    }
  finally {
      cluster.shutdown();
    }
  }
  /** 
 * Test that we can open up a file for write, move it to another location, and then create a new file in the previous location, without causing any lease conflicts.  This is possible because we now use unique inode IDs to identify files to the NameNode.
 */
  @Test public void testLeaseAfterRenameAndRecreate() throws Exception {
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
    try {
      final Path path1=new Path("/test-file");
      final String contents1="contents1";
      final Path path2=new Path("/test-file-new-location");
      final String contents2="contents2";
      FileSystem fs=cluster.getFileSystem();
      FSDataOutputStream out1=fs.create(path1);
      out1.writeBytes(contents1);
      Assert.assertTrue(hasLease(cluster,path1));
      Assert.assertEquals(1,leaseCount(cluster));
      DistributedFileSystem fs2=(DistributedFileSystem)FileSystem.newInstance(fs.getUri(),fs.getConf());
      fs2.rename(path1,path2);
      FSDataOutputStream out2=fs2.create(path1);
      out2.writeBytes(contents2);
      out2.close();
      Assert.assertTrue(hasLease(cluster,path2));
      out1.close();
      DistributedFileSystem fs3=(DistributedFileSystem)FileSystem.newInstance(fs.getUri(),fs.getConf());
      Assert.assertEquals(contents1,DFSTestUtil.readFile(fs3,path2));
      Assert.assertEquals(contents2,DFSTestUtil.readFile(fs3,path1));
    }
  finally {
      cluster.shutdown();
    }
  }
  @Test public void testLease() throws Exception {
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
    try {
      FileSystem fs=cluster.getFileSystem();
      Assert.assertTrue(fs.mkdirs(dir));
      Path a=new Path(dir,"a");
      Path b=new Path(dir,"b");
      DataOutputStream a_out=fs.create(a);
      a_out.writeBytes("something");
      Assert.assertTrue(hasLease(cluster,a));
      Assert.assertTrue(!hasLease(cluster,b));
      DataOutputStream b_out=fs.create(b);
      b_out.writeBytes("something");
      Assert.assertTrue(hasLease(cluster,a));
      Assert.assertTrue(hasLease(cluster,b));
      a_out.close();
      b_out.close();
      Assert.assertTrue(!hasLease(cluster,a));
      Assert.assertTrue(!hasLease(cluster,b));
      Path fileA=new Path(dir,"fileA");
      FSDataOutputStream fileA_out=fs.create(fileA);
      fileA_out.writeBytes("something");
      Assert.assertTrue("Failed to get the lease!",hasLease(cluster,fileA));
      fs.delete(dir,true);
      try {
        fileA_out.hflush();
        Assert.fail("Should validate file existence!");
      }
 catch (      FileNotFoundException e) {
        GenericTestUtils.assertExceptionContains("File does not exist",e);
      }
    }
  finally {
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
  @SuppressWarnings("unchecked") @Test public void testFactory() throws Exception {
    final String[] groups=new String[]{"supergroup"};
    final UserGroupInformation[] ugi=new UserGroupInformation[3];
    for (int i=0; i < ugi.length; i++) {
      ugi[i]=UserGroupInformation.createUserForTesting("user" + i,groups);
    }
    Mockito.doReturn(new HdfsFileStatus.Builder().replication(1).blocksize(1024).perm(new FsPermission((short)777)).owner("owner").group("group").symlink(new byte[0]).path(new byte[0]).fileId(1010).build()).when(mcp).getFileInfo(anyString());
    Mockito.doReturn(new HdfsFileStatus.Builder().replication(1).blocksize(1024).perm(new FsPermission((short)777)).owner("owner").group("group").symlink(new byte[0]).path(new byte[0]).fileId(1010).build()).when(mcp).create(anyString(),(FsPermission)anyObject(),anyString(),(EnumSetWritable<CreateFlag>)anyObject(),anyBoolean(),anyShort(),anyLong(),(CryptoProtocolVersion[])anyObject(),anyObject());
    final Configuration conf=new Configuration();
    final DFSClient c1=createDFSClientAs(ugi[0],conf);
    FSDataOutputStream out1=createFsOut(c1,"/out1");
    final DFSClient c2=createDFSClientAs(ugi[0],conf);
    FSDataOutputStream out2=createFsOut(c2,"/out2");
    Assert.assertEquals(c1.getLeaseRenewer(),c2.getLeaseRenewer());
    final DFSClient c3=createDFSClientAs(ugi[1],conf);
    FSDataOutputStream out3=createFsOut(c3,"/out3");
    Assert.assertTrue(c1.getLeaseRenewer() != c3.getLeaseRenewer());
    final DFSClient c4=createDFSClientAs(ugi[1],conf);
    FSDataOutputStream out4=createFsOut(c4,"/out4");
    Assert.assertEquals(c3.getLeaseRenewer(),c4.getLeaseRenewer());
    final DFSClient c5=createDFSClientAs(ugi[2],conf);
    FSDataOutputStream out5=createFsOut(c5,"/out5");
    Assert.assertTrue(c1.getLeaseRenewer() != c5.getLeaseRenewer());
    Assert.assertTrue(c3.getLeaseRenewer() != c5.getLeaseRenewer());
  }
  private FSDataOutputStream createFsOut(  DFSClient dfs,  String path) throws IOException {
    return new FSDataOutputStream(dfs.create(path,true),null);
  }
  static final ClientProtocol mcp=Mockito.mock(ClientProtocol.class);
  static public DFSClient createDFSClientAs(  UserGroupInformation ugi,  final Configuration conf) throws Exception {
    return ugi.doAs(new PrivilegedExceptionAction<DFSClient>(){
      @Override public DFSClient run() throws Exception {
        return new DFSClient(null,mcp,conf,null);
      }
    }
);
  }
}
