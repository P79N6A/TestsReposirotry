public class TestInMemorySCMStore extends SCMStoreBaseTest {
  private InMemorySCMStore store;
  private AppChecker checker;
  @Override Class<? extends SCMStore> getStoreClass(){
    return InMemorySCMStore.class;
  }
  @Before public void setup(){
    this.checker=spy(new DummyAppChecker());
    this.store=spy(new InMemorySCMStore(checker));
  }
  @After public void cleanup(){
    if (this.store != null) {
      this.store.stop();
    }
  }
  private void startEmptyStore() throws Exception {
    doReturn(new ArrayList<ApplicationId>()).when(checker).getActiveApplications();
    doReturn(new HashMap<String,String>()).when(store).getInitialCachedResources(isA(FileSystem.class),isA(Configuration.class));
    this.store.init(new Configuration());
    this.store.start();
  }
  private Map<String,String> startStoreWithResources() throws Exception {
    Map<String,String> initialCachedResources=new HashMap<String,String>();
    int count=10;
    for (int i=0; i < count; i++) {
      String key=String.valueOf(i);
      String fileName=key + ".jar";
      initialCachedResources.put(key,fileName);
    }
    doReturn(new ArrayList<ApplicationId>()).when(checker).getActiveApplications();
    doReturn(initialCachedResources).when(store).getInitialCachedResources(isA(FileSystem.class),isA(Configuration.class));
    this.store.init(new Configuration());
    this.store.start();
    return initialCachedResources;
  }
  private void startStoreWithApps() throws Exception {
    ArrayList<ApplicationId> list=new ArrayList<ApplicationId>();
    int count=5;
    for (int i=0; i < count; i++) {
      list.add(createAppId(i,i));
    }
    doReturn(list).when(checker).getActiveApplications();
    doReturn(new HashMap<String,String>()).when(store).getInitialCachedResources(isA(FileSystem.class),isA(Configuration.class));
    this.store.init(new Configuration());
    this.store.start();
  }
  @Test public void testAddResourceConcurrency() throws Exception {
    startEmptyStore();
    final String key="key1";
    int count=5;
    ExecutorService exec=HadoopExecutors.newFixedThreadPool(count);
    List<Future<String>> futures=new ArrayList<Future<String>>(count);
    final CountDownLatch start=new CountDownLatch(1);
    for (int i=0; i < count; i++) {
      final String fileName="foo-" + i + ".jar";
      Callable<String> task=new Callable<String>(){
        public String call() throws Exception {
          start.await();
          String result=store.addResource(key,fileName);
          System.out.println("fileName: " + fileName + ", result: "+ result);
          return result;
        }
      }
;
      futures.add(exec.submit(task));
    }
    start.countDown();
    Set<String> results=new HashSet<String>();
    for (    Future<String> future : futures) {
      results.add(future.get());
    }
    assertSame(1,results.size());
    exec.shutdown();
  }
  @Test public void testAddResourceRefNonExistentResource() throws Exception {
    startEmptyStore();
    String key="key1";
    ApplicationId id=createAppId(1,1L);
    assertNull(store.addResourceReference(key,new SharedCacheResourceReference(id,"user")));
  }
  @Test public void testRemoveResourceEmptyRefs() throws Exception {
    startEmptyStore();
    String key="key1";
    String fileName="foo.jar";
    store.addResource(key,fileName);
    assertTrue(store.removeResource(key));
  }
  @Test public void testAddResourceRefRemoveResource() throws Exception {
    startEmptyStore();
    String key="key1";
    ApplicationId id=createAppId(1,1L);
    String user="user";
    store.addResource(key,"foo.jar");
    store.addResourceReference(key,new SharedCacheResourceReference(id,user));
    assertTrue(!store.removeResource(key));
    Collection<SharedCacheResourceReference> refs=store.getResourceReferences(key);
    assertTrue(refs != null);
    assertEquals(Collections.singleton(new SharedCacheResourceReference(id,user)),refs);
  }
  @Test public void testAddResourceRefConcurrency() throws Exception {
    startEmptyStore();
    final String key="key1";
    final String user="user";
    String fileName="foo.jar";
    store.addResource(key,fileName);
    int count=5;
    ExecutorService exec=HadoopExecutors.newFixedThreadPool(count);
    List<Future<String>> futures=new ArrayList<Future<String>>(count);
    final CountDownLatch start=new CountDownLatch(1);
    for (int i=0; i < count; i++) {
      final ApplicationId id=createAppId(i,i);
      Callable<String> task=new Callable<String>(){
        public String call() throws Exception {
          start.await();
          return store.addResourceReference(key,new SharedCacheResourceReference(id,user));
        }
      }
;
      futures.add(exec.submit(task));
    }
    start.countDown();
    Set<String> results=new HashSet<String>();
    for (    Future<String> future : futures) {
      results.add(future.get());
    }
    assertSame(1,results.size());
    assertEquals(Collections.singleton(fileName),results);
    Collection<SharedCacheResourceReference> refs=store.getResourceReferences(key);
    assertSame(count,refs.size());
    exec.shutdown();
  }
  @Test public void testAddResourceRefAddResourceConcurrency() throws Exception {
    startEmptyStore();
    final String key="key1";
    final String fileName="foo.jar";
    final String user="user";
    final ApplicationId id=createAppId(1,1L);
    ExecutorService exec=HadoopExecutors.newFixedThreadPool(2);
    final CountDownLatch start=new CountDownLatch(1);
    Callable<String> addKeyTask=new Callable<String>(){
      public String call() throws Exception {
        start.await();
        return store.addResource(key,fileName);
      }
    }
;
    Callable<String> addAppIdTask=new Callable<String>(){
      public String call() throws Exception {
        start.await();
        return store.addResourceReference(key,new SharedCacheResourceReference(id,user));
      }
    }
;
    Future<String> addAppIdFuture=exec.submit(addAppIdTask);
    Future<String> addKeyFuture=exec.submit(addKeyTask);
    start.countDown();
    String addKeyResult=addKeyFuture.get();
    String addAppIdResult=addAppIdFuture.get();
    assertEquals(fileName,addKeyResult);
    System.out.println("addAppId() result: " + addAppIdResult);
    assertTrue(addAppIdResult == null || addAppIdResult.equals(fileName));
    exec.shutdown();
  }
  @Test public void testRemoveRef() throws Exception {
    startEmptyStore();
    String key="key1";
    String fileName="foo.jar";
    String user="user";
    store.addResource(key,fileName);
    ApplicationId id=createAppId(1,1L);
    SharedCacheResourceReference myRef=new SharedCacheResourceReference(id,user);
    String result=store.addResourceReference(key,myRef);
    assertEquals(fileName,result);
    Collection<SharedCacheResourceReference> refs=store.getResourceReferences(key);
    assertSame(1,refs.size());
    assertEquals(Collections.singleton(myRef),refs);
    store.removeResourceReferences(key,Collections.singleton(myRef),true);
    Collection<SharedCacheResourceReference> newRefs=store.getResourceReferences(key);
    assertTrue(newRefs == null || newRefs.isEmpty());
  }
  @Test public void testBootstrapping() throws Exception {
    Map<String,String> initialCachedResources=startStoreWithResources();
    int count=initialCachedResources.size();
    ApplicationId id=createAppId(1,1L);
    for (int i=0; i < count; i++) {
      String key=String.valueOf(i);
      String fileName=key + ".jar";
      String result=store.addResourceReference(key,new SharedCacheResourceReference(id,"user"));
      assertEquals(fileName,result);
      assertTrue(initialCachedResources.isEmpty());
    }
  }
  @Test public void testEvictableWithInitialApps() throws Exception {
    startStoreWithApps();
    assertFalse(store.isResourceEvictable("key",mock(FileStatus.class)));
  }
  private ApplicationId createAppId(  int id,  long timestamp){
    return ApplicationId.newInstance(timestamp,id);
  }
}
