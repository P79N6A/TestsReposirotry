public class TestMetricsSourceAdapter {
  private static final int RACE_TEST_RUNTIME=10000;
  @Test public void testPurgeOldMetrics() throws Exception {
    PurgableSource source=new PurgableSource();
    MetricsSourceBuilder sb=MetricsAnnotations.newSourceBuilder(source);
    final MetricsSource s=sb.build();
    List<MetricsTag> injectedTags=new ArrayList<MetricsTag>();
    MetricsSourceAdapter sa=new MetricsSourceAdapter("tst","tst","testdesc",s,injectedTags,null,null,1,false);
    MBeanInfo info=sa.getMBeanInfo();
    boolean sawIt=false;
    for (    MBeanAttributeInfo mBeanAttributeInfo : info.getAttributes()) {
      sawIt|=mBeanAttributeInfo.getName().equals(source.lastKeyName);
    }
    ;
    assertTrue("The last generated metric is not exported to jmx",sawIt);
    Thread.sleep(1000);
    info=sa.getMBeanInfo();
    sawIt=false;
    for (    MBeanAttributeInfo mBeanAttributeInfo : info.getAttributes()) {
      sawIt|=mBeanAttributeInfo.getName().equals(source.lastKeyName);
    }
    ;
    assertTrue("The last generated metric is not exported to jmx",sawIt);
  }
private static class PurgableSource implements MetricsSource {
    int nextKey=0;
    String lastKeyName=null;
    @Override public void getMetrics(    MetricsCollector collector,    boolean all){
      MetricsRecordBuilder rb=collector.addRecord("purgablesource").setContext("test");
      lastKeyName="key" + nextKey++;
      rb.addGauge(info(lastKeyName,"desc"),1);
    }
  }
  @Test public void testGetMetricsAndJmx() throws Exception {
    TestSource source=new TestSource("test");
    MetricsSourceBuilder sb=MetricsAnnotations.newSourceBuilder(source);
    final MetricsSource s=sb.build();
    List<MetricsTag> injectedTags=new ArrayList<MetricsTag>();
    MetricsSourceAdapter sa=new MetricsSourceAdapter("test","test","test desc",s,injectedTags,null,null,1,false);
    MetricsCollectorImpl builder=new MetricsCollectorImpl();
    Iterable<MetricsRecordImpl> metricsRecords=sa.getMetrics(builder,true);
    MetricsRecordImpl metricsRecord=metricsRecords.iterator().next();
    assertEquals(0L,metricsRecord.metrics().iterator().next().value().longValue());
    Thread.sleep(100);
    assertEquals(0L,(Number)sa.getAttribute("C1"));
    source.incrementCnt();
    builder=new MetricsCollectorImpl();
    metricsRecords=sa.getMetrics(builder,true);
    metricsRecord=metricsRecords.iterator().next();
    assertTrue(metricsRecord.metrics().iterator().hasNext());
    Thread.sleep(100);
    assertEquals(1L,(Number)sa.getAttribute("C1"));
  }
@SuppressWarnings("unused") @Metrics(context="test") private static class TestSource {
    @Metric("C1 desc") MutableCounterLong c1;
    final MetricsRegistry registry;
    TestSource(    String recName){
      registry=new MetricsRegistry(recName);
    }
    public void incrementCnt(){
      c1.incr();
    }
  }
  /** 
 * Test a race condition when updating the JMX cache (HADOOP-12482): 1. Thread A reads the JMX metric every 2 JMX cache TTL. It marks the JMX cache to be updated by marking lastRecs to null. After this it adds a new key to the metrics. The next call to read should pick up this new key. 2. Thread B triggers JMX metric update every 1 JMX cache TTL. It assigns lastRecs to a new object (not null any more). 3. Thread A tries to read JMX metric again, sees lastRecs is not null and does not update JMX cache. As a result the read does not pickup the new metric.
 * @throws Exception
 */
  @Test public void testMetricCacheUpdateRace() throws Exception {
    TestMetricsSource source=new TestMetricsSource();
    MetricsSourceBuilder sourceBuilder=MetricsAnnotations.newSourceBuilder(source);
    final long JMX_CACHE_TTL=250;
    List<MetricsTag> injectedTags=new ArrayList<>();
    MetricsSourceAdapter sourceAdapter=new MetricsSourceAdapter("test","test","test JMX cache update race condition",sourceBuilder.build(),injectedTags,null,null,JMX_CACHE_TTL,false);
    ScheduledExecutorService updaterExecutor=Executors.newScheduledThreadPool(1,new ThreadFactoryBuilder().build());
    ScheduledExecutorService readerExecutor=Executors.newScheduledThreadPool(1,new ThreadFactoryBuilder().build());
    final AtomicBoolean hasError=new AtomicBoolean(false);
    SourceUpdater srcUpdater=new SourceUpdater(sourceAdapter,hasError);
    ScheduledFuture<?> updaterFuture=updaterExecutor.scheduleAtFixedRate(srcUpdater,sourceAdapter.getJmxCacheTTL(),sourceAdapter.getJmxCacheTTL(),TimeUnit.MILLISECONDS);
    srcUpdater.setFuture(updaterFuture);
    SourceReader srcReader=new SourceReader(source,sourceAdapter,hasError);
    ScheduledFuture<?> readerFuture=readerExecutor.scheduleAtFixedRate(srcReader,0,2 * sourceAdapter.getJmxCacheTTL(),TimeUnit.MILLISECONDS);
    srcReader.setFuture(readerFuture);
    Thread.sleep(RACE_TEST_RUNTIME);
    assertFalse("Hit error",hasError.get());
    updaterExecutor.shutdownNow();
    readerExecutor.shutdownNow();
    updaterExecutor.awaitTermination(1000,TimeUnit.MILLISECONDS);
    readerExecutor.awaitTermination(1000,TimeUnit.MILLISECONDS);
  }
  /** 
 * Thread safe source: stores a key value pair. Allows thread safe key-value pair reads/writes.
 */
private static class TestMetricsSource implements MetricsSource {
    private String key="key0";
    private int val=0;
    synchronized String getKey(){
      return key;
    }
    synchronized void setKV(    final String newKey,    final int newVal){
      key=newKey;
      val=newVal;
    }
    @Override public void getMetrics(    MetricsCollector collector,    boolean all){
      MetricsRecordBuilder rb=collector.addRecord("TestMetricsSource").setContext("test");
synchronized (this) {
        rb.addGauge(info(key,"TestMetricsSource key"),val);
      }
    }
  }
  /** 
 * An thread that updates the metrics source every 1 JMX cache TTL
 */
private static class SourceUpdater implements Runnable {
    private MetricsSourceAdapter sa=null;
    private ScheduledFuture<?> future=null;
    private AtomicBoolean hasError=null;
    private static final Logger LOG=Logger.getLogger(SourceUpdater.class);
    public SourceUpdater(    MetricsSourceAdapter sourceAdapter,    AtomicBoolean err){
      sa=sourceAdapter;
      hasError=err;
    }
    public void setFuture(    ScheduledFuture<?> f){
      future=f;
    }
    @Override public void run(){
      MetricsCollectorImpl builder=new MetricsCollectorImpl();
      try {
        sa.getMetrics(builder,true);
        LOG.info("reset lastRecs");
      }
 catch (      Exception e) {
        hasError.set(true);
        LOG.error(e.getStackTrace());
      }
 finally {
        if (hasError.get()) {
          LOG.error("Hit error, stopping now");
          future.cancel(false);
        }
      }
    }
  }
  /** 
 * An thread that reads the metrics source every JMX cache TTL. After each read it updates the metric source to report a new key. The next read must be able to pick up this new key.
 */
private static class SourceReader implements Runnable {
    private MetricsSourceAdapter sa=null;
    private TestMetricsSource src=null;
    private int cnt=0;
    private ScheduledFuture<?> future=null;
    private AtomicBoolean hasError=null;
    private static final Logger LOG=Logger.getLogger(SourceReader.class);
    public SourceReader(    TestMetricsSource source,    MetricsSourceAdapter sourceAdapter,    AtomicBoolean err){
      src=source;
      sa=sourceAdapter;
      hasError=err;
    }
    public void setFuture(    ScheduledFuture<?> f){
      future=f;
    }
    @Override public void run(){
      try {
        MBeanInfo info=sa.getMBeanInfo();
        final String key=src.getKey();
        for (        MBeanAttributeInfo mBeanAttributeInfo : info.getAttributes()) {
          if (mBeanAttributeInfo.getName().equals(key)) {
            LOG.info("found key/val=" + cnt + "/"+ cnt);
            cnt++;
            src.setKV("key" + cnt,cnt);
            return;
          }
        }
        LOG.error("key=" + key + " not found. Stopping now.");
        hasError.set(true);
      }
 catch (      Exception e) {
        hasError.set(true);
        LOG.error(e.getStackTrace());
      }
 finally {
        if (hasError.get()) {
          future.cancel(false);
        }
      }
    }
  }
}
