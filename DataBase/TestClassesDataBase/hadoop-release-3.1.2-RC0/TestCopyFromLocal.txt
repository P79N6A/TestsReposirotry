/** 
 * Test for copyFromLocal.
 */
public class TestCopyFromLocal {
  private static final String FROM_DIR_NAME="fromDir";
  private static final String TO_DIR_NAME="toDir";
  private static FileSystem fs;
  private static Path testDir;
  private static Configuration conf;
  public static int initialize(  Path dir) throws Exception {
    fs.mkdirs(dir);
    Path fromDirPath=new Path(dir,FROM_DIR_NAME);
    fs.mkdirs(fromDirPath);
    Path toDirPath=new Path(dir,TO_DIR_NAME);
    fs.mkdirs(toDirPath);
    int numTotalFiles=0;
    int numDirs=RandomUtils.nextInt(5);
    for (int dirCount=0; dirCount < numDirs; ++dirCount) {
      Path subDirPath=new Path(fromDirPath,"subdir" + dirCount);
      fs.mkdirs(subDirPath);
      int numFiles=RandomUtils.nextInt(10);
      for (int fileCount=0; fileCount < numFiles; ++fileCount) {
        numTotalFiles++;
        Path subFile=new Path(subDirPath,"file" + fileCount);
        fs.createNewFile(subFile);
        FSDataOutputStream output=fs.create(subFile,true);
        for (int i=0; i < 100; ++i) {
          output.writeInt(i);
          output.writeChar('\n');
        }
        output.close();
      }
    }
    return numTotalFiles;
  }
  @BeforeClass public static void init() throws Exception {
    conf=new Configuration(false);
    conf.set("fs.file.impl",LocalFileSystem.class.getName());
    fs=FileSystem.getLocal(conf);
    testDir=new FileSystemTestHelper().getTestRootPath(fs);
    testDir=new Path(fs.makeQualified(testDir).toUri().getPath());
    FileSystem.setDefaultUri(conf,fs.getUri());
    fs.setWorkingDirectory(testDir);
  }
  @AfterClass public static void cleanup() throws Exception {
    fs.delete(testDir,true);
    fs.close();
  }
  private void run(  CommandWithDestination cmd,  String... args){
    cmd.setConf(conf);
    assertEquals(0,cmd.run(args));
  }
  @Test(timeout=10000) public void testCopyFromLocal() throws Exception {
    Path dir=new Path("dir" + RandomStringUtils.randomNumeric(4));
    TestCopyFromLocal.initialize(dir);
    run(new TestMultiThreadedCopy(1,0),new Path(dir,FROM_DIR_NAME).toString(),new Path(dir,TO_DIR_NAME).toString());
  }
  @Test(timeout=10000) public void testCopyFromLocalWithThreads() throws Exception {
    Path dir=new Path("dir" + RandomStringUtils.randomNumeric(4));
    int numFiles=TestCopyFromLocal.initialize(dir);
    int maxThreads=Runtime.getRuntime().availableProcessors() * 2;
    int randThreads=RandomUtils.nextInt(maxThreads - 1) + 1;
    String numThreads=Integer.toString(randThreads);
    run(new TestMultiThreadedCopy(randThreads,randThreads == 1 ? 0 : numFiles),"-t",numThreads,new Path(dir,FROM_DIR_NAME).toString(),new Path(dir,TO_DIR_NAME).toString());
  }
  @Test(timeout=10000) public void testCopyFromLocalWithThreadWrong() throws Exception {
    Path dir=new Path("dir" + RandomStringUtils.randomNumeric(4));
    int numFiles=TestCopyFromLocal.initialize(dir);
    int maxThreads=Runtime.getRuntime().availableProcessors() * 2;
    String numThreads=Integer.toString(maxThreads * 2);
    run(new TestMultiThreadedCopy(maxThreads,numFiles),"-t",numThreads,new Path(dir,FROM_DIR_NAME).toString(),new Path(dir,TO_DIR_NAME).toString());
  }
  @Test(timeout=10000) public void testCopyFromLocalWithZeroThreads() throws Exception {
    Path dir=new Path("dir" + RandomStringUtils.randomNumeric(4));
    TestCopyFromLocal.initialize(dir);
    run(new TestMultiThreadedCopy(1,0),"-t","0",new Path(dir,FROM_DIR_NAME).toString(),new Path(dir,TO_DIR_NAME).toString());
  }
private class TestMultiThreadedCopy extends CopyFromLocal {
    public static final String NAME="testCopyFromLocal";
    private int expectedThreads;
    private int expectedCompletedTaskCount;
    TestMultiThreadedCopy(    int expectedThreads,    int expectedCompletedTaskCount){
      this.expectedThreads=expectedThreads;
      this.expectedCompletedTaskCount=expectedCompletedTaskCount;
    }
    @Override protected void processArguments(    LinkedList<PathData> args) throws IOException {
      Assert.assertEquals(expectedThreads,getNumThreads());
      super.processArguments(args);
      ThreadPoolExecutor executor=getExecutor();
      Assert.assertEquals(expectedCompletedTaskCount,executor.getCompletedTaskCount());
      Assert.assertEquals(0,executor.getActiveCount());
      Assert.assertTrue(executor.isTerminated());
    }
  }
}
