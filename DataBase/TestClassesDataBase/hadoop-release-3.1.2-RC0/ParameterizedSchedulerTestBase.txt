@RunWith(Parameterized.class) public abstract class ParameterizedSchedulerTestBase {
  protected final static String TEST_DIR=new File(System.getProperty("test.build.data","/tmp")).getAbsolutePath();
  private final static String FS_ALLOC_FILE=new File(TEST_DIR,"test-fs-queues.xml").getAbsolutePath();
  public enum SchedulerType {  CAPACITY,   FAIR}
  @Parameterized.Parameters(name="{0}") public static Collection<Object[]> getParameters(){
    return Arrays.stream(SchedulerType.values()).map(type -> new Object[]{type}).collect(Collectors.toList());
  }
  private SchedulerType schedulerType;
  private YarnConfiguration conf=null;
  private AbstractYarnScheduler scheduler=null;
  public YarnConfiguration getConf(){
    return conf;
  }
  public ParameterizedSchedulerTestBase(  SchedulerType type) throws IOException {
    conf=new YarnConfiguration();
    QueueMetrics.clearQueueMetrics();
    DefaultMetricsSystem.setMiniClusterMode(true);
    schedulerType=type;
switch (schedulerType) {
case FAIR:
      configureFairScheduler(conf);
    scheduler=new FairScheduler();
  conf.set(YarnConfiguration.RM_SCHEDULER,FairScheduler.class.getName());
break;
case CAPACITY:
scheduler=new CapacityScheduler();
((CapacityScheduler)scheduler).setConf(conf);
conf.set(YarnConfiguration.RM_SCHEDULER,CapacityScheduler.class.getName());
break;
default :
throw new IllegalArgumentException("Invalid type: " + type);
}
}
protected void configureFairScheduler(YarnConfiguration conf) throws IOException {
PrintWriter out=new PrintWriter(new FileWriter(FS_ALLOC_FILE));
out.println("<?xml version=\"1.0\"?>");
out.println("<allocations>");
out.println("<queueMaxAMShareDefault>-1.0</queueMaxAMShareDefault>");
out.println("<defaultQueueSchedulingPolicy>fair</defaultQueueSchedulingPolicy>");
out.println("<queue name=\"root\">");
out.println("  <schedulingPolicy>drf</schedulingPolicy>");
out.println("  <weight>1.0</weight>");
out.println("  <fairSharePreemptionTimeout>100</fairSharePreemptionTimeout>");
out.println("  <minSharePreemptionTimeout>120</minSharePreemptionTimeout>");
out.println("  <fairSharePreemptionThreshold>.5</fairSharePreemptionThreshold>");
out.println("</queue>");
out.println("</allocations>");
out.close();
conf.set(FairSchedulerConfiguration.ALLOCATION_FILE,FS_ALLOC_FILE);
conf.setLong(FairSchedulerConfiguration.UPDATE_INTERVAL_MS,10);
}
@After public void tearDown(){
if (schedulerType == SchedulerType.FAIR) {
(new File(FS_ALLOC_FILE)).delete();
}
}
public SchedulerType getSchedulerType(){
return schedulerType;
}
/** 
 * Return a scheduler configured by  {@code YarnConfiguration.RM_SCHEDULER}<p>The scheduler is configured by {@link #ParameterizedSchedulerTestBase(SchedulerType)}. Client test code can obtain the scheduler with this getter method. Schedulers supported by this class are  {@link FairScheduler} or{@link CapacityScheduler}. </p>
 * @return   The scheduler configured by{@code YarnConfiguration.RM_SCHEDULER}
 */
public AbstractYarnScheduler getScheduler(){
return scheduler;
}
}
