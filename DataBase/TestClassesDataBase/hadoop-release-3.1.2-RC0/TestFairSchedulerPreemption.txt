/** 
 * Tests to verify fairshare and minshare preemption, using parameterization.
 */
@RunWith(Parameterized.class) public class TestFairSchedulerPreemption extends FairSchedulerTestBase {
  private static final File ALLOC_FILE=new File(TEST_DIR,"test-queues");
  private static final int GB=1024;
  private final ControlledClock clock=new ControlledClock();
  private static final int NODE_CAPACITY_MULTIPLE=4;
  private final boolean fairsharePreemption;
  private final boolean drf;
  private FSAppAttempt greedyApp;
  private FSAppAttempt starvingApp;
  @Parameterized.Parameters(name="{0}") public static Collection<Object[]> getParameters(){
    return Arrays.asList(new Object[][]{{"MinSharePreemption",0},{"MinSharePreemptionWithDRF",1},{"FairSharePreemption",2},{"FairSharePreemptionWithDRF",3}});
  }
  public TestFairSchedulerPreemption(  String name,  int mode) throws IOException {
    fairsharePreemption=(mode > 1);
    drf=(mode % 2 == 1);
    writeAllocFile();
  }
  @Before public void setup() throws IOException {
    createConfiguration();
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE,ALLOC_FILE.getAbsolutePath());
    conf.setBoolean(FairSchedulerConfiguration.PREEMPTION,true);
    conf.setFloat(FairSchedulerConfiguration.PREEMPTION_THRESHOLD,0f);
    conf.setInt(FairSchedulerConfiguration.WAIT_TIME_BEFORE_KILL,0);
    setupCluster();
  }
  @After public void teardown(){
    ALLOC_FILE.delete();
    conf=null;
    if (resourceManager != null) {
      resourceManager.stop();
      resourceManager=null;
    }
  }
  private void writeAllocFile() throws IOException {
    PrintWriter out=new PrintWriter(new FileWriter(ALLOC_FILE));
    out.println("<?xml version=\"1.0\"?>");
    out.println("<allocations>");
    out.println("<queue name=\"preemptable\">");
    writePreemptionParams(out);
    out.println("<queue name=\"child-1\">");
    writeResourceParams(out);
    out.println("</queue>");
    out.println("<queue name=\"child-2\">");
    writeResourceParams(out);
    out.println("</queue>");
    out.println("</queue>");
    out.println("<queue name=\"preemptable-sibling\">");
    writePreemptionParams(out);
    out.println("</queue>");
    out.println("<queue name=\"nonpreemptable\">");
    out.println("<allowPreemptionFrom>false" + "</allowPreemptionFrom>");
    writePreemptionParams(out);
    out.println("<queue name=\"child-1\">");
    writeResourceParams(out);
    out.println("</queue>");
    out.println("<queue name=\"child-2\">");
    writeResourceParams(out);
    out.println("</queue>");
    out.println("</queue>");
    if (drf) {
      out.println("<defaultQueueSchedulingPolicy>drf" + "</defaultQueueSchedulingPolicy>");
    }
    out.println("</allocations>");
    out.close();
    assertTrue("Allocation file does not exist, not running the test",ALLOC_FILE.exists());
  }
  private void writePreemptionParams(  PrintWriter out){
    if (fairsharePreemption) {
      out.println("<fairSharePreemptionThreshold>1" + "</fairSharePreemptionThreshold>");
      out.println("<fairSharePreemptionTimeout>0" + "</fairSharePreemptionTimeout>");
    }
 else {
      out.println("<minSharePreemptionTimeout>0" + "</minSharePreemptionTimeout>");
    }
  }
  private void writeResourceParams(  PrintWriter out){
    if (!fairsharePreemption) {
      out.println("<minResources>4096mb,4vcores</minResources>");
    }
  }
  private void setupCluster() throws IOException {
    resourceManager=new MockRM(conf);
    scheduler=(FairScheduler)resourceManager.getResourceScheduler();
    clock.setTime(SystemClock.getInstance().getTime());
    scheduler.setClock(clock);
    resourceManager.start();
    addNode(NODE_CAPACITY_MULTIPLE * GB,3 * NODE_CAPACITY_MULTIPLE);
    addNode(NODE_CAPACITY_MULTIPLE * GB,3 * NODE_CAPACITY_MULTIPLE);
    scheduler.reinitialize(conf,resourceManager.getRMContext());
    FSQueue child1=scheduler.getQueueManager().getQueue("nonpreemptable.child-1");
    assertFalse(child1.isPreemptable());
    FSQueue child2=scheduler.getQueueManager().getQueue("nonpreemptable.child-2");
    assertFalse(child2.isPreemptable());
  }
  private void sendEnoughNodeUpdatesToAssignFully(){
    for (    RMNode node : rmNodes) {
      NodeUpdateSchedulerEvent nodeUpdateSchedulerEvent=new NodeUpdateSchedulerEvent(node);
      for (int i=0; i < NODE_CAPACITY_MULTIPLE; i++) {
        scheduler.handle(nodeUpdateSchedulerEvent);
      }
    }
  }
  /** 
 * Submit an application to a given queue and take over the entire cluster.
 * @param queueName queue name
 */
  private void takeAllResources(  String queueName){
    ApplicationAttemptId appAttemptId=createSchedulingRequest(GB,1,queueName,"default",NODE_CAPACITY_MULTIPLE * rmNodes.size());
    greedyApp=scheduler.getSchedulerApp(appAttemptId);
    scheduler.update();
    sendEnoughNodeUpdatesToAssignFully();
    assertEquals(8,greedyApp.getLiveContainers().size());
    assertTrue(scheduler.getQueueManager().getQueue(queueName).isPreemptable() == greedyApp.isPreemptable());
  }
  /** 
 * Submit an application to a given queue and preempt half resources of the cluster.
 * @param queueName queue name
 * @throws InterruptedException if any thread has interrupted the current thread.
 */
  private void preemptHalfResources(  String queueName) throws InterruptedException {
    ApplicationAttemptId appAttemptId=createSchedulingRequest(2 * GB,2,queueName,"default",NODE_CAPACITY_MULTIPLE * rmNodes.size() / 2);
    starvingApp=scheduler.getSchedulerApp(appAttemptId);
    clock.tickSec(1);
    scheduler.update();
  }
  /** 
 * Submit application to  {@code queue1} and take over the entire cluster.Submit application with larger containers to  {@code queue2} thatrequires preemption from the first application.
 * @param queue1 first queue
 * @param queue2 second queue
 * @throws InterruptedException if interrupted while waiting
 */
  private void submitApps(  String queue1,  String queue2) throws InterruptedException {
    takeAllResources(queue1);
    preemptHalfResources(queue2);
  }
  private void verifyPreemption(  int numStarvedAppContainers,  int numGreedyAppContainers) throws InterruptedException {
    for (int i=0; i < 1000; i++) {
      if (greedyApp.getLiveContainers().size() == numGreedyAppContainers) {
        break;
      }
      Thread.sleep(10);
    }
    assertEquals("Incorrect # of containers on the greedy app",numGreedyAppContainers,greedyApp.getLiveContainers().size());
    assertEquals("Incorrect # of preempted containers in QueueMetrics",8 - numGreedyAppContainers,greedyApp.getQueue().getMetrics().getAggregatePreemptedContainers());
    for (    RMNode rmNode : rmNodes) {
      FSSchedulerNode node=(FSSchedulerNode)scheduler.getNodeTracker().getNode(rmNode.getNodeID());
      if (node.getContainersForPreemption().size() > 0) {
        assertTrue("node should be reserved for the starvingApp",node.getPreemptionList().keySet().contains(starvingApp));
      }
    }
    sendEnoughNodeUpdatesToAssignFully();
    assertEquals("Starved app is not assigned the right # of containers",numStarvedAppContainers,starvingApp.getLiveContainers().size());
    for (    RMNode rmNode : rmNodes) {
      FSSchedulerNode node=(FSSchedulerNode)scheduler.getNodeTracker().getNode(rmNode.getNodeID());
      if (node.getContainersForPreemption().size() > 0) {
        assertFalse(node.getPreemptionList().keySet().contains(starvingApp));
      }
    }
  }
  private void verifyNoPreemption() throws InterruptedException {
    for (int i=0; i < 100; i++) {
      if (greedyApp.getLiveContainers().size() != 8) {
        break;
      }
      Thread.sleep(10);
    }
    assertEquals(8,greedyApp.getLiveContainers().size());
  }
  @Test public void testPreemptionWithinSameLeafQueue() throws Exception {
    String queue="root.preemptable.child-1";
    submitApps(queue,queue);
    if (fairsharePreemption) {
      verifyPreemption(2,4);
    }
 else {
      verifyNoPreemption();
    }
  }
  @Test public void testPreemptionBetweenTwoSiblingLeafQueues() throws Exception {
    submitApps("root.preemptable.child-1","root.preemptable.child-2");
    verifyPreemption(2,4);
  }
  @Test public void testPreemptionBetweenNonSiblingQueues() throws Exception {
    submitApps("root.preemptable.child-1","root.nonpreemptable.child-1");
    verifyPreemption(2,4);
  }
  @Test public void testNoPreemptionFromDisallowedQueue() throws Exception {
    submitApps("root.nonpreemptable.child-1","root.preemptable.child-1");
    verifyNoPreemption();
  }
  /** 
 * Set the number of AM containers for each node.
 * @param numAMContainersPerNode number of AM containers per node
 */
  private void setNumAMContainersPerNode(  int numAMContainersPerNode){
    List<FSSchedulerNode> potentialNodes=scheduler.getNodeTracker().getNodesByResourceName("*");
    for (    FSSchedulerNode node : potentialNodes) {
      List<RMContainer> containers=node.getCopiedListOfRunningContainers();
      for (int i=0; i < numAMContainersPerNode; i++) {
        ((RMContainerImpl)containers.get(i)).setAMContainer(true);
      }
    }
  }
  private void setAllAMContainersOnNode(  NodeId nodeId){
    SchedulerNode node=scheduler.getNodeTracker().getNode(nodeId);
    for (    RMContainer container : node.getCopiedListOfRunningContainers()) {
      ((RMContainerImpl)container).setAMContainer(true);
    }
  }
  @Test public void testPreemptionSelectNonAMContainer() throws Exception {
    takeAllResources("root.preemptable.child-1");
    setNumAMContainersPerNode(2);
    preemptHalfResources("root.preemptable.child-2");
    verifyPreemption(2,4);
    ArrayList<RMContainer> containers=(ArrayList<RMContainer>)starvingApp.getLiveContainers();
    String host0=containers.get(0).getNodeId().getHost();
    String host1=containers.get(1).getNodeId().getHost();
    assertTrue("Preempted containers should come from two different " + "nodes.",!host0.equals(host1));
  }
  @Test public void testRelaxLocalityToNotPreemptAM() throws Exception {
    takeAllResources("root.preemptable.child-1");
    RMNode node1=rmNodes.get(0);
    setAllAMContainersOnNode(node1.getNodeID());
    SchedulerNode node=scheduler.getNodeTracker().getNode(node1.getNodeID());
    ApplicationAttemptId greedyAppAttemptId=node.getCopiedListOfRunningContainers().get(0).getApplicationAttemptId();
    ResourceRequest nodeRequest=createResourceRequest(GB,node1.getHostName(),1,4,true);
    ResourceRequest rackRequest=createResourceRequest(GB * 10,node1.getRackName(),1,1,true);
    ResourceRequest anyRequest=createResourceRequest(GB * 10,ResourceRequest.ANY,1,1,true);
    List<ResourceRequest> resourceRequests=Arrays.asList(nodeRequest,rackRequest,anyRequest);
    ApplicationAttemptId starvedAppAttemptId=createSchedulingRequest("root.preemptable.child-2","default",resourceRequests);
    starvingApp=scheduler.getSchedulerApp(starvedAppAttemptId);
    clock.tickSec(1);
    scheduler.update();
    verifyPreemption(0,4);
    for (    RMContainer container : node.getCopiedListOfRunningContainers()) {
      assert (container.isAMContainer());
      assert (container.getApplicationAttemptId().equals(greedyAppAttemptId));
    }
  }
  @Test public void testAppNotPreemptedBelowFairShare() throws Exception {
    takeAllResources("root.preemptable.child-1");
    tryPreemptMoreThanFairShare("root.preemptable.child-2");
  }
  private void tryPreemptMoreThanFairShare(  String queueName) throws InterruptedException {
    ApplicationAttemptId appAttemptId=createSchedulingRequest(3 * GB,3,queueName,"default",NODE_CAPACITY_MULTIPLE * rmNodes.size() / 2);
    starvingApp=scheduler.getSchedulerApp(appAttemptId);
    verifyPreemption(1,5);
  }
  @Test public void testPreemptionBetweenSiblingQueuesWithParentAtFairShare() throws InterruptedException {
    if (!fairsharePreemption) {
      return;
    }
    takeAllResources("root.preemptable.child-1");
    preemptHalfResources("root.preemptable-sibling");
    verifyPreemption(2,4);
    preemptHalfResources("root.preemptable.child-2");
    verifyPreemption(1,2);
  }
}
