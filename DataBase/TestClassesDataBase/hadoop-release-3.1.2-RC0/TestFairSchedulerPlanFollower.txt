public class TestFairSchedulerPlanFollower extends TestSchedulerPlanFollowerBase {
  private final static String ALLOC_FILE=new File(FairSchedulerTestBase.TEST_DIR,TestSchedulerPlanFollowerBase.class.getName() + ".xml").getAbsolutePath();
  private RMContext rmContext;
  private RMContext spyRMContext;
  private FairScheduler fs;
  private Configuration conf;
  private FairSchedulerTestBase testHelper=new FairSchedulerTestBase();
  @Rule public TestName name=new TestName();
  protected Configuration createConfiguration(){
    Configuration conf=testHelper.createConfiguration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER,FairScheduler.class,ResourceScheduler.class);
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE,ALLOC_FILE);
    return conf;
  }
  @Before public void setUp() throws Exception {
    conf=createConfiguration();
    ReservationSystemTestUtil.setupFSAllocationFile(ALLOC_FILE);
    rmContext=TestUtils.getMockRMContext();
    spyRMContext=spy(rmContext);
    fs=ReservationSystemTestUtil.setupFairScheduler(spyRMContext,conf,125);
    scheduler=fs;
    ConcurrentMap<ApplicationId,RMApp> spyApps=spy(new ConcurrentHashMap<ApplicationId,RMApp>());
    RMApp rmApp=mock(RMApp.class);
    when(rmApp.getRMAppAttempt((ApplicationAttemptId)Matchers.any())).thenReturn(null);
    Mockito.doReturn(rmApp).when(spyApps).get((ApplicationId)Matchers.any());
    when(spyRMContext.getRMApps()).thenReturn(spyApps);
    ReservationSystemTestUtil.setupFSAllocationFile(ALLOC_FILE);
    setupPlanFollower();
  }
  private void setupPlanFollower() throws Exception {
    mClock=mock(Clock.class);
    mAgent=mock(ReservationAgent.class);
    String reservationQ=ReservationSystemTestUtil.getFullReservationQueueName();
    AllocationConfiguration allocConf=fs.getAllocationConfiguration();
    allocConf.setReservationWindow(20L);
    allocConf.setAverageCapacity(20);
    policy.init(reservationQ,allocConf);
  }
  @Test public void testWithMoveOnExpiry() throws PlanningException, InterruptedException, AccessControlException {
    testPlanFollower(true);
  }
  @Test public void testWithKillOnExpiry() throws PlanningException, InterruptedException, AccessControlException {
    testPlanFollower(false);
  }
  @Override protected void checkDefaultQueueBeforePlanFollowerRun(){
    Assert.assertNull(getDefaultQueue());
  }
  @Override protected void verifyCapacity(  Queue defQ){
    assertTrue(((FSQueue)defQ).getWeight() > 0.9);
  }
  @Override protected Queue getDefaultQueue(){
    return getReservationQueue("dedicated" + ReservationConstants.DEFAULT_QUEUE_SUFFIX);
  }
  @Override protected int getNumberOfApplications(  Queue queue){
    int numberOfApplications=fs.getAppsInQueue(queue.getQueueName()).size();
    return numberOfApplications;
  }
  @Override protected AbstractSchedulerPlanFollower createPlanFollower(){
    FairSchedulerPlanFollower planFollower=new FairSchedulerPlanFollower();
    planFollower.init(mClock,scheduler,Collections.singletonList(plan));
    return planFollower;
  }
  @Override protected void assertReservationQueueExists(  ReservationId r){
    Queue q=getReservationQueue(r.toString());
    assertNotNull(q);
  }
  @Override protected void assertReservationQueueExists(  ReservationId r,  double expectedCapacity,  double expectedMaxCapacity){
    FSLeafQueue q=fs.getQueueManager().getLeafQueue(plan.getQueueName() + "" + "."+ r,false);
    assertNotNull(q);
    Assert.assertEquals(expectedCapacity,q.getWeight(),0.01);
  }
  @Override protected void assertReservationQueueDoesNotExist(  ReservationId r){
    Queue q=getReservationQueue(r.toString());
    assertNull(q);
  }
  @Override protected Queue getReservationQueue(  String r){
    return fs.getQueueManager().getLeafQueue(plan.getQueueName() + "" + "."+ r,false);
  }
  public static ApplicationACLsManager mockAppACLsManager(){
    Configuration conf=new Configuration();
    return new ApplicationACLsManager(conf);
  }
  @After public void tearDown() throws Exception {
    if (scheduler != null) {
      fs.stop();
    }
  }
}
