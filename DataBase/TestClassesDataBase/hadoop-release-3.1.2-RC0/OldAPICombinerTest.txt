public class OldAPICombinerTest {
  private FileSystem fs;
  private String inputpath;
  @Test public void testWordCountCombinerWithOldAPI() throws Exception {
    final Configuration nativeConf=ScenarioConfiguration.getNativeConfiguration();
    nativeConf.addResource(TestConstants.COMBINER_CONF_PATH);
    final String nativeoutput=TestConstants.NATIVETASK_OLDAPI_COMBINER_TEST_NATIVE_OUTPUTPATH;
    final JobConf nativeJob=getOldAPIJobconf(nativeConf,"nativeCombinerWithOldAPI",inputpath,nativeoutput);
    RunningJob nativeRunning=JobClient.runJob(nativeJob);
    Counter nativeReduceGroups=nativeRunning.getCounters().findCounter(TaskCounter.REDUCE_INPUT_RECORDS);
    final Configuration normalConf=ScenarioConfiguration.getNormalConfiguration();
    normalConf.addResource(TestConstants.COMBINER_CONF_PATH);
    final String normaloutput=TestConstants.NATIVETASK_OLDAPI_COMBINER_TEST_NORMAL_OUTPUTPATH;
    final JobConf normalJob=getOldAPIJobconf(normalConf,"normalCombinerWithOldAPI",inputpath,normaloutput);
    RunningJob normalRunning=JobClient.runJob(normalJob);
    Counter normalReduceGroups=normalRunning.getCounters().findCounter(TaskCounter.REDUCE_INPUT_RECORDS);
    final boolean compareRet=ResultVerifier.verify(nativeoutput,normaloutput);
    assertEquals("file compare result: if they are the same ,then return true",true,compareRet);
    assertEquals("The input reduce record count must be same",nativeReduceGroups.getValue(),normalReduceGroups.getValue());
  }
  @Before public void startUp() throws Exception {
    Assume.assumeTrue(NativeCodeLoader.isNativeCodeLoaded());
    Assume.assumeTrue(NativeRuntime.isNativeLibraryLoaded());
    final ScenarioConfiguration conf=new ScenarioConfiguration();
    conf.addcombinerConf();
    this.fs=FileSystem.get(conf);
    this.inputpath=TestConstants.NATIVETASK_COMBINER_TEST_INPUTDIR + "/wordcount";
    if (!fs.exists(new Path(inputpath))) {
      new TestInputFile(conf.getInt(TestConstants.NATIVETASK_COMBINER_WORDCOUNT_FILESIZE,1000000),Text.class.getName(),Text.class.getName(),conf).createSequenceTestFile(inputpath,1,(byte)('a'));
    }
  }
  @AfterClass public static void cleanUp() throws IOException {
    final FileSystem fs=FileSystem.get(new ScenarioConfiguration());
    fs.delete(new Path(TestConstants.NATIVETASK_COMBINER_TEST_DIR),true);
    fs.close();
  }
  private static JobConf getOldAPIJobconf(  Configuration configuration,  String name,  String input,  String output) throws Exception {
    final JobConf jobConf=new JobConf(configuration);
    final FileSystem fs=FileSystem.get(configuration);
    if (fs.exists(new Path(output))) {
      fs.delete(new Path(output),true);
    }
    fs.close();
    jobConf.setJobName(name);
    jobConf.setOutputKeyClass(Text.class);
    jobConf.setOutputValueClass(IntWritable.class);
    jobConf.setMapperClass(WordCountWithOldAPI.TokenizerMapperWithOldAPI.class);
    jobConf.setCombinerClass(WordCountWithOldAPI.IntSumReducerWithOldAPI.class);
    jobConf.setReducerClass(WordCountWithOldAPI.IntSumReducerWithOldAPI.class);
    jobConf.setInputFormat(SequenceFileInputFormat.class);
    jobConf.setOutputFormat(TextOutputFormat.class);
    FileInputFormat.setInputPaths(jobConf,new Path(input));
    FileOutputFormat.setOutputPath(jobConf,new Path(output));
    return jobConf;
  }
}
