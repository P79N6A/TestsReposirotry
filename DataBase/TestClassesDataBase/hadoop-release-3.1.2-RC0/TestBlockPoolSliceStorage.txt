/** 
 * Test that BlockPoolSliceStorage can correctly generate trash and restore directories for a given block file path.
 */
public class TestBlockPoolSliceStorage {
  public static final Logger LOG=LoggerFactory.getLogger(TestBlockPoolSliceStorage.class);
  final Random rand=new Random();
  BlockPoolSliceStorage storage;
  /** 
 * BlockPoolSliceStorage with a dummy storage directory. The directory need not exist. We need to extend BlockPoolSliceStorage so we can call  {@link Storage#addStorageDir}.
 */
private static class StubBlockPoolSliceStorage extends BlockPoolSliceStorage {
    StubBlockPoolSliceStorage(    int namespaceID,    String bpID,    long cTime,    String clusterId){
      super(namespaceID,bpID,cTime,clusterId);
      addStorageDir(new StorageDirectory(new File("/tmp/dontcare/" + bpID)));
      assertThat(getStorageDirs().size(),is(1));
    }
  }
  private String makeRandomIpAddress(){
    return rand.nextInt(256) + "." + rand.nextInt(256)+ "."+ rand.nextInt(256)+ "."+ rand.nextInt(256);
  }
  private String makeRandomBlockpoolId(){
    return "BP-" + rand.nextInt(Integer.MAX_VALUE) + "-"+ makeRandomIpAddress()+ "-"+ rand.nextInt(Integer.MAX_VALUE);
  }
  private BlockPoolSliceStorage makeBlockPoolStorage(){
    return new StubBlockPoolSliceStorage(rand.nextInt(Integer.MAX_VALUE),makeRandomBlockpoolId(),rand.nextInt(Integer.MAX_VALUE),UUID.randomUUID().toString());
  }
  private String makeRandomBlockFileSubdir(  int nestingLevel){
    StringBuilder sb=new StringBuilder();
    sb.append(File.separator);
    for (int i=0; i < nestingLevel; ++i) {
      sb.append("subdir" + rand.nextInt(64) + File.separator);
    }
    return sb.toString();
  }
  /** 
 * Test conversion from a block file path to its target trash directory.
 */
  public void getTrashDirectoryForBlockFile(  String fileName,  int nestingLevel){
    final String blockFileSubdir=makeRandomBlockFileSubdir(nestingLevel);
    final String blockFileName=fileName;
    String testFilePath=storage.getSingularStorageDir().getRoot() + File.separator + Storage.STORAGE_DIR_CURRENT+ blockFileSubdir+ blockFileName;
    String expectedTrashPath=storage.getSingularStorageDir().getRoot() + File.separator + BlockPoolSliceStorage.TRASH_ROOT_DIR+ blockFileSubdir.substring(0,blockFileSubdir.length() - 1);
    LOG.info("Got subdir {}",blockFileSubdir);
    LOG.info("Generated file path {}",testFilePath);
    ReplicaInfo info=Mockito.mock(ReplicaInfo.class);
    Mockito.when(info.getBlockURI()).thenReturn(new File(testFilePath).toURI());
    assertThat(storage.getTrashDirectory(info),is(expectedTrashPath));
  }
  public void getRestoreDirectoryForBlockFile(  String fileName,  int nestingLevel){
    BlockPoolSliceStorage storage=makeBlockPoolStorage();
    final String blockFileSubdir=makeRandomBlockFileSubdir(nestingLevel);
    final String blockFileName=fileName;
    String deletedFilePath=storage.getSingularStorageDir().getRoot() + File.separator + BlockPoolSliceStorage.TRASH_ROOT_DIR+ blockFileSubdir+ blockFileName;
    String expectedRestorePath=storage.getSingularStorageDir().getRoot() + File.separator + Storage.STORAGE_DIR_CURRENT+ blockFileSubdir.substring(0,blockFileSubdir.length() - 1);
    LOG.info("Generated deleted file path {}",deletedFilePath);
    assertThat(storage.getRestoreDirectory(new File(deletedFilePath)),is(expectedRestorePath));
  }
  @Test(timeout=300000) public void testGetTrashAndRestoreDirectories(){
    storage=makeBlockPoolStorage();
    for (int i=0; i < 3; ++i) {
      getTrashDirectoryForBlockFile("blk_myblockfile",i);
      getTrashDirectoryForBlockFile("blk_myblockfile.meta",i);
      getRestoreDirectoryForBlockFile("blk_myblockfile",i);
      getRestoreDirectoryForBlockFile("blk_myblockfile.meta",i);
    }
  }
}
