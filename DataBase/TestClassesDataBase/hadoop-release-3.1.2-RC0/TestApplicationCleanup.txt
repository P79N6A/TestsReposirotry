public class TestApplicationCleanup {
  private static final Log LOG=LogFactory.getLog(TestApplicationCleanup.class);
  private YarnConfiguration conf;
  @Before public void setup() throws UnknownHostException {
    Logger rootLogger=LogManager.getRootLogger();
    rootLogger.setLevel(Level.DEBUG);
    conf=new YarnConfiguration();
    UserGroupInformation.setConfiguration(conf);
    conf.set(YarnConfiguration.RECOVERY_ENABLED,"true");
    conf.set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    Assert.assertTrue(YarnConfiguration.DEFAULT_RM_AM_MAX_ATTEMPTS > 1);
  }
  @SuppressWarnings("resource") @Test public void testAppCleanup() throws Exception {
    Logger rootLogger=LogManager.getRootLogger();
    rootLogger.setLevel(Level.DEBUG);
    MockRM rm=new MockRM();
    rm.start();
    MockNM nm1=rm.registerNode("127.0.0.1:1234",5000);
    RMApp app=rm.submitApp(2000);
    nm1.nodeHeartbeat(true);
    RMAppAttempt attempt=app.getCurrentAppAttempt();
    MockAM am=rm.sendAMLaunched(attempt.getAppAttemptId());
    am.registerAppAttempt();
    int request=2;
    am.allocate("127.0.0.1",1000,request,new ArrayList<ContainerId>());
    nm1.nodeHeartbeat(true);
    List<Container> conts=am.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
    int contReceived=conts.size();
    int waitCount=0;
    while (contReceived < request && waitCount++ < 200) {
      LOG.info("Got " + contReceived + " containers. Waiting to get "+ request);
      Thread.sleep(100);
      conts=am.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
      contReceived+=conts.size();
      nm1.nodeHeartbeat(true);
    }
    Assert.assertEquals(request,contReceived);
    am.unregisterAppAttempt();
    NodeHeartbeatResponse resp=nm1.nodeHeartbeat(attempt.getAppAttemptId(),1,ContainerState.COMPLETE);
    rm.waitForState(am.getApplicationAttemptId(),RMAppAttemptState.FINISHED);
    resp=nm1.nodeHeartbeat(true);
    List<ContainerId> containersToCleanup=resp.getContainersToCleanup();
    List<ApplicationId> appsToCleanup=resp.getApplicationsToCleanup();
    int numCleanedContainers=containersToCleanup.size();
    int numCleanedApps=appsToCleanup.size();
    waitCount=0;
    while ((numCleanedContainers < 2 || numCleanedApps < 1) && waitCount++ < 200) {
      LOG.info("Waiting to get cleanup events.. cleanedConts: " + numCleanedContainers + " cleanedApps: "+ numCleanedApps);
      Thread.sleep(100);
      resp=nm1.nodeHeartbeat(true);
      List<ContainerId> deltaContainersToCleanup=resp.getContainersToCleanup();
      List<ApplicationId> deltaAppsToCleanup=resp.getApplicationsToCleanup();
      containersToCleanup.addAll(deltaContainersToCleanup);
      appsToCleanup.addAll(deltaAppsToCleanup);
      numCleanedContainers=containersToCleanup.size();
      numCleanedApps=appsToCleanup.size();
    }
    Assert.assertEquals(1,appsToCleanup.size());
    Assert.assertEquals(app.getApplicationId(),appsToCleanup.get(0));
    Assert.assertEquals(1,numCleanedApps);
    Assert.assertEquals(2,numCleanedContainers);
    rm.stop();
  }
  @Test public void testContainerCleanup() throws Exception {
    Logger rootLogger=LogManager.getRootLogger();
    rootLogger.setLevel(Level.DEBUG);
    MockRM rm=new MockRM();
    rm.start();
    MockNM nm1=rm.registerNode("127.0.0.1:1234",5000);
    RMApp app=rm.submitApp(2000);
    nm1.nodeHeartbeat(true);
    RMAppAttempt attempt=app.getCurrentAppAttempt();
    MockAM am=rm.sendAMLaunched(attempt.getAppAttemptId());
    am.registerAppAttempt();
    int request=2;
    am.allocate("127.0.0.1",1000,request,new ArrayList<ContainerId>());
    rm.drainEvents();
    nm1.nodeHeartbeat(true);
    List<Container> conts=am.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
    int contReceived=conts.size();
    int waitCount=0;
    while (contReceived < request && waitCount++ < 200) {
      LOG.info("Got " + contReceived + " containers. Waiting to get "+ request);
      Thread.sleep(100);
      conts=am.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
      rm.drainEvents();
      contReceived+=conts.size();
      nm1.nodeHeartbeat(true);
    }
    Assert.assertEquals(request,contReceived);
    ArrayList<ContainerId> release=new ArrayList<ContainerId>();
    release.add(conts.get(0).getId());
    am.allocate(new ArrayList<ResourceRequest>(),release);
    rm.drainEvents();
    Map<ApplicationId,List<ContainerStatus>> containerStatuses=new HashMap<ApplicationId,List<ContainerStatus>>();
    ArrayList<ContainerStatus> containerStatusList=new ArrayList<ContainerStatus>();
    containerStatusList.add(BuilderUtils.newContainerStatus(conts.get(0).getId(),ContainerState.RUNNING,"nothing",0,conts.get(0).getResource()));
    containerStatuses.put(app.getApplicationId(),containerStatusList);
    NodeHeartbeatResponse resp=nm1.nodeHeartbeat(containerStatuses,true);
    waitForContainerCleanup(rm,nm1,resp);
    LOG.info("Testing container launch much after release and " + "NM getting cleanup");
    containerStatuses.clear();
    containerStatusList.clear();
    containerStatusList.add(BuilderUtils.newContainerStatus(conts.get(0).getId(),ContainerState.RUNNING,"nothing",0,conts.get(0).getResource()));
    containerStatuses.put(app.getApplicationId(),containerStatusList);
    resp=nm1.nodeHeartbeat(containerStatuses,true);
    waitForContainerCleanup(rm,nm1,resp);
    rm.stop();
  }
  protected void waitForContainerCleanup(  MockRM rm,  MockNM nm,  NodeHeartbeatResponse resp) throws Exception {
    int waitCount=0, cleanedConts=0;
    List<ContainerId> contsToClean;
    do {
      rm.drainEvents();
      contsToClean=resp.getContainersToCleanup();
      cleanedConts+=contsToClean.size();
      if (cleanedConts >= 1) {
        break;
      }
      Thread.sleep(100);
      resp=nm.nodeHeartbeat(true);
    }
 while (waitCount++ < 200);
    if (contsToClean.isEmpty()) {
      LOG.error("Failed to get any containers to cleanup");
    }
 else {
      LOG.info("Got cleanup for " + contsToClean.get(0));
    }
    Assert.assertEquals(1,cleanedConts);
  }
  private void waitForAppCleanupMessageRecved(  MockNM nm,  ApplicationId appId) throws Exception {
    while (true) {
      NodeHeartbeatResponse response=nm.nodeHeartbeat(true);
      if (response.getApplicationsToCleanup() != null && response.getApplicationsToCleanup().size() == 1 && appId.equals(response.getApplicationsToCleanup().get(0))) {
        return;
      }
      LOG.info("Haven't got application=" + appId.toString() + " in cleanup list from node heartbeat response, "+ "sleep for a while before next heartbeat");
      Thread.sleep(1000);
    }
  }
  private MockAM launchAM(  RMApp app,  MockRM rm,  MockNM nm) throws Exception {
    RMAppAttempt attempt=app.getCurrentAppAttempt();
    nm.nodeHeartbeat(true);
    MockAM am=rm.sendAMLaunched(attempt.getAppAttemptId());
    am.registerAppAttempt();
    rm.waitForState(app.getApplicationId(),RMAppState.RUNNING);
    return am;
  }
  @SuppressWarnings("resource") @Test(timeout=60000) public void testAppCleanupWhenRMRestartedAfterAppFinished() throws Exception {
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,1);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    MockMemoryRMStateStore memStore=(MockMemoryRMStateStore)rm1.getRMStateStore();
    MockNM nm1=new MockNM("127.0.0.1:1234",15120,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app0=rm1.submitApp(200);
    MockAM am0=launchAM(app0,rm1,nm1);
    nm1.nodeHeartbeat(am0.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(app0.getApplicationId(),RMAppState.FAILED);
    MockRM rm2=new MockRM(conf,memStore);
    rm2.start();
    nm1.setResourceTrackerService(rm2.getResourceTrackerService());
    nm1.registerNode(Arrays.asList(app0.getApplicationId()));
    rm2.waitForState(app0.getApplicationId(),RMAppState.FAILED);
    waitForAppCleanupMessageRecved(nm1,app0.getApplicationId());
    rm1.stop();
    rm2.stop();
  }
  @SuppressWarnings("resource") @Test(timeout=60000) public void testAppCleanupWhenRMRestartedBeforeAppFinished() throws Exception {
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,1);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",1024,rm1.getResourceTrackerService());
    nm1.registerNode();
    MockNM nm2=new MockNM("127.0.0.1:5678",1024,rm1.getResourceTrackerService());
    nm2.registerNode();
    RMApp app0=rm1.submitApp(200);
    MockAM am0=launchAM(app0,rm1,nm1);
    AllocateResponse allocResponse=am0.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resource.newInstance(1024,0),1)),null);
    while (null == allocResponse.getAllocatedContainers() || allocResponse.getAllocatedContainers().isEmpty()) {
      nm2.nodeHeartbeat(true);
      allocResponse=am0.allocate(null,null);
      Thread.sleep(1000);
    }
    MockRM rm2=new MockRM(conf,rm1.getRMStateStore());
    rm2.start();
    nm1.setResourceTrackerService(rm2.getResourceTrackerService());
    nm1.registerNode(Arrays.asList(NMContainerStatus.newInstance(ContainerId.newContainerId(am0.getApplicationAttemptId(),1),0,ContainerState.COMPLETE,Resource.newInstance(1024,1),"",0,Priority.newInstance(0),1234)),Arrays.asList(app0.getApplicationId()));
    nm2.setResourceTrackerService(rm2.getResourceTrackerService());
    nm2.registerNode(Arrays.asList(app0.getApplicationId()));
    rm2.waitForState(app0.getApplicationId(),RMAppState.FAILED);
    waitForAppCleanupMessageRecved(nm1,app0.getApplicationId());
    waitForAppCleanupMessageRecved(nm2,app0.getApplicationId());
    rm1.stop();
    rm2.stop();
  }
  @Test(timeout=60000) public void testContainerCleanupWhenRMRestartedAppNotRegistered() throws Exception {
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,1);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",15120,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app0=rm1.submitApp(200);
    MockAM am0=launchAM(app0,rm1,nm1);
    nm1.nodeHeartbeat(am0.getApplicationAttemptId(),1,ContainerState.RUNNING);
    rm1.waitForState(app0.getApplicationId(),RMAppState.RUNNING);
    MockRM rm2=new MockRM(conf,rm1.getRMStateStore());
    rm2.start();
    nm1.setResourceTrackerService(rm2.getResourceTrackerService());
    nm1.registerNode(Arrays.asList(app0.getApplicationId()));
    rm2.waitForState(app0.getApplicationId(),RMAppState.ACCEPTED);
    NodeHeartbeatResponse response=nm1.nodeHeartbeat(am0.getApplicationAttemptId(),2,ContainerState.RUNNING);
    waitForContainerCleanup(rm2,nm1,response);
    rm1.stop();
    rm2.stop();
  }
  @Test(timeout=60000) public void testAppCleanupWhenNMReconnects() throws Exception {
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,1);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",15120,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app0=rm1.submitApp(200);
    MockAM am0=launchAM(app0,rm1,nm1);
    nm1.nodeHeartbeat(am0.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(app0.getApplicationId(),RMAppState.FAILED);
    waitForAppCleanupMessageRecved(nm1,app0.getApplicationId());
    nm1.registerNode(Arrays.asList(app0.getApplicationId()));
    waitForAppCleanupMessageRecved(nm1,app0.getApplicationId());
    rm1.stop();
  }
  @Test(timeout=60000) public void testProcessingNMContainerStatusesOnNMRestart() throws Exception {
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,1);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    int nmMemory=8192;
    int amMemory=1024;
    int containerMemory=2048;
    MockNM nm1=new MockNM("127.0.0.1:1234",nmMemory,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app0=rm1.submitApp(amMemory);
    MockAM am0=MockRM.launchAndRegisterAM(app0,rm1,nm1);
    int noOfContainers=1;
    List<Container> allocateContainers=am0.allocateAndWaitForContainers(noOfContainers,containerMemory,nm1);
    Assert.assertEquals(noOfContainers,allocateContainers.size());
    Container container=allocateContainers.get(0);
    nm1.nodeHeartbeat(am0.getApplicationAttemptId(),1,ContainerState.RUNNING);
    nm1.nodeHeartbeat(am0.getApplicationAttemptId(),container.getId().getContainerId(),ContainerState.RUNNING);
    rm1.waitForState(app0.getApplicationId(),RMAppState.RUNNING);
    ResourceScheduler rs=rm1.getRMContext().getScheduler();
    long allocatedMB=rs.getRootQueueMetrics().getAllocatedMB();
    Assert.assertEquals(amMemory + containerMemory,allocatedMB);
    List<NMContainerStatus> nMContainerStatusForApp=createNMContainerStatusForApp(am0);
    nm1.registerNode(nMContainerStatusForApp,Arrays.asList(app0.getApplicationId()));
    waitForClusterMemory(nm1,rs,amMemory);
    Assert.assertEquals(amMemory,rs.getRootQueueMetrics().getAllocatedMB());
    AllocateRequest req=AllocateRequest.newInstance(0,0F,new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>(),null);
    AllocateResponse allocate=am0.allocate(req);
    List<ContainerStatus> completedContainersStatuses=allocate.getCompletedContainersStatuses();
    Assert.assertEquals(noOfContainers,completedContainersStatuses.size());
    nm1.nodeHeartbeat(am0.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    waitForClusterMemory(nm1,rs,0);
    rm1.stop();
  }
  private void waitForClusterMemory(  MockNM nm1,  ResourceScheduler rs,  int clusterMemory) throws Exception, InterruptedException {
    int counter=0;
    while (rs.getRootQueueMetrics().getAllocatedMB() != clusterMemory) {
      nm1.nodeHeartbeat(true);
      Thread.sleep(100);
      if (counter++ == 50) {
        Assert.fail("Wait for cluster memory is timed out.Expected=" + clusterMemory + " Actual="+ rs.getRootQueueMetrics().getAllocatedMB());
      }
    }
  }
  public static List<NMContainerStatus> createNMContainerStatusForApp(  MockAM am){
    List<NMContainerStatus> list=new ArrayList<NMContainerStatus>();
    NMContainerStatus amContainer=createNMContainerStatus(am.getApplicationAttemptId(),1,ContainerState.RUNNING,1024);
    NMContainerStatus completedContainer=createNMContainerStatus(am.getApplicationAttemptId(),2,ContainerState.COMPLETE,2048);
    list.add(amContainer);
    list.add(completedContainer);
    return list;
  }
  public static NMContainerStatus createNMContainerStatus(  ApplicationAttemptId appAttemptId,  int id,  ContainerState containerState,  int memory){
    ContainerId containerId=ContainerId.newContainerId(appAttemptId,id);
    NMContainerStatus containerReport=NMContainerStatus.newInstance(containerId,0,containerState,Resource.newInstance(memory,1),"recover container",0,Priority.newInstance(0),0);
    return containerReport;
  }
  public static void main(  String[] args) throws Exception {
    TestApplicationCleanup t=new TestApplicationCleanup();
    t.testAppCleanup();
  }
}
