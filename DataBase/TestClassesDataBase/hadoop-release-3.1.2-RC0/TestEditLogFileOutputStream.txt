/** 
 * Test the EditLogFileOutputStream
 */
public class TestEditLogFileOutputStream {
  private final static File TEST_DIR=PathUtils.getTestDir(TestEditLogFileOutputStream.class);
  private static final File TEST_EDITS=new File(TEST_DIR,"testEditLogFileOutput.log");
  final static int MIN_PREALLOCATION_LENGTH=EditLogFileOutputStream.MIN_PREALLOCATION_LENGTH;
  private Configuration conf;
  @BeforeClass public static void disableFsync(){
    EditLogFileOutputStream.setShouldSkipFsyncForTesting(true);
  }
  @Before @After public void deleteEditsFile(){
    if (TEST_EDITS.exists())     TEST_EDITS.delete();
  }
  @Before public void setUp(){
    conf=new Configuration();
  }
  static void flushAndCheckLength(  EditLogFileOutputStream elos,  long expectedLength) throws IOException {
    elos.setReadyToFlush();
    elos.flushAndSync(true);
    assertEquals(expectedLength,elos.getFile().length());
  }
  /** 
 * Tests writing to the EditLogFileOutputStream. Due to preallocation, the length of the edit log will usually be longer than its valid contents.
 */
  @Test public void testRawWrites() throws IOException {
    EditLogFileOutputStream elos=new EditLogFileOutputStream(conf,TEST_EDITS,0);
    try {
      byte[] small=new byte[]{1,2,3,4,5,8,7};
      elos.create(NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
      elos.writeRaw(small,0,small.length);
      flushAndCheckLength(elos,MIN_PREALLOCATION_LENGTH);
      elos.writeRaw(small,0,small.length);
      flushAndCheckLength(elos,MIN_PREALLOCATION_LENGTH);
      final int BIG_WRITE_LENGTH=3 * MIN_PREALLOCATION_LENGTH;
      byte[] buf=new byte[4096];
      for (int i=0; i < buf.length; i++) {
        buf[i]=0;
      }
      int total=BIG_WRITE_LENGTH;
      while (total > 0) {
        int toWrite=(total > buf.length) ? buf.length : total;
        elos.writeRaw(buf,0,toWrite);
        total-=toWrite;
      }
      flushAndCheckLength(elos,4 * MIN_PREALLOCATION_LENGTH);
    }
  finally {
      if (elos != null)       elos.close();
    }
  }
  /** 
 * Tests EditLogFileOutputStream doesn't throw NullPointerException on close/abort sequence. See HDFS-2011.
 */
  @Test public void testEditLogFileOutputStreamCloseAbort() throws IOException {
    EditLogFileOutputStream editLogStream=new EditLogFileOutputStream(conf,TEST_EDITS,0);
    editLogStream.close();
    editLogStream.abort();
  }
  /** 
 * Tests EditLogFileOutputStream doesn't throw NullPointerException on close/close sequence. See HDFS-2011.
 */
  @Test public void testEditLogFileOutputStreamCloseClose() throws IOException {
    EditLogFileOutputStream editLogStream=new EditLogFileOutputStream(conf,TEST_EDITS,0);
    editLogStream.close();
    try {
      editLogStream.close();
    }
 catch (    IOException ioe) {
      String msg=StringUtils.stringifyException(ioe);
      assertTrue(msg,msg.contains("Trying to use aborted output stream"));
    }
  }
  /** 
 * Tests EditLogFileOutputStream doesn't throw NullPointerException on being abort/abort sequence. See HDFS-2011.
 */
  @Test public void testEditLogFileOutputStreamAbortAbort() throws IOException {
    EditLogFileOutputStream editLogStream=null;
    try {
      editLogStream=new EditLogFileOutputStream(conf,TEST_EDITS,0);
      editLogStream.abort();
      editLogStream.abort();
    }
  finally {
      IOUtils.cleanup(null,editLogStream);
    }
  }
}
