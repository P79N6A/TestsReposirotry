private class TestCallbackHandler extends AMRMClientAsync.AbstractCallbackHandler {
  private volatile List<ContainerStatus> completedContainers;
  private volatile List<Container> allocatedContainers;
  private final List<UpdatedContainer> changedContainers=new ArrayList<>();
  Exception savedException=null;
  volatile boolean reboot=false;
  Object notifier=new Object();
  int callbackCount=0;
  public List<ContainerStatus> takeCompletedContainers(){
    List<ContainerStatus> ret=completedContainers;
    if (ret == null) {
      return null;
    }
    completedContainers=null;
synchronized (ret) {
      ret.notify();
    }
    return ret;
  }
  public List<UpdatedContainer> takeChangedContainers(){
    List<UpdatedContainer> ret=null;
synchronized (changedContainers) {
      if (!changedContainers.isEmpty()) {
        ret=new ArrayList<>(changedContainers);
        changedContainers.clear();
        changedContainers.notify();
      }
    }
    return ret;
  }
  public List<Container> takeAllocatedContainers(){
    List<Container> ret=allocatedContainers;
    if (ret == null) {
      return null;
    }
    allocatedContainers=null;
synchronized (ret) {
      ret.notify();
    }
    return ret;
  }
  @Override public void onContainersCompleted(  List<ContainerStatus> statuses){
    completedContainers=statuses;
synchronized (completedContainers) {
      while (completedContainers != null) {
        try {
          completedContainers.wait();
        }
 catch (        InterruptedException ex) {
          LOG.error("Interrupted during wait",ex);
        }
      }
    }
  }
  @Override public void onContainersUpdated(  List<UpdatedContainer> changed){
synchronized (changedContainers) {
      changedContainers.clear();
      changedContainers.addAll(changed);
      while (!changedContainers.isEmpty()) {
        try {
          changedContainers.wait();
        }
 catch (        InterruptedException ex) {
          LOG.error("Interrupted during wait",ex);
        }
      }
    }
  }
  @Override public void onContainersAllocated(  List<Container> containers){
    allocatedContainers=containers;
synchronized (allocatedContainers) {
      while (allocatedContainers != null) {
        try {
          allocatedContainers.wait();
        }
 catch (        InterruptedException ex) {
          LOG.error("Interrupted during wait",ex);
        }
      }
    }
  }
  @Override public void onShutdownRequest(){
    reboot=true;
synchronized (notifier) {
      notifier.notifyAll();
    }
  }
  @Override public void onNodesUpdated(  List<NodeReport> updatedNodes){
  }
  @Override public float getProgress(){
    callbackCount++;
    return 0.5f;
  }
  @Override public void onError(  Throwable e){
    savedException=new Exception(e.getMessage());
synchronized (notifier) {
      notifier.notifyAll();
    }
  }
}
