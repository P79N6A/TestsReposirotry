/** 
 * Testcase for HADOOP-13433 that verifies the logic of fixKerberosTicketOrder.
 */
public class TestFixKerberosTicketOrder extends KerberosSecurityTestcase {
  private String clientPrincipal="client";
  private String server1Protocol="server1";
  private String server2Protocol="server2";
  private String host="localhost";
  private String server1Principal=server1Protocol + "/" + host;
  private String server2Principal=server2Protocol + "/" + host;
  private File keytabFile;
  private Configuration conf=new Configuration();
  private Map<String,String> props;
  @Before public void setUp() throws Exception {
    keytabFile=new File(getWorkDir(),"keytab");
    getKdc().createPrincipal(keytabFile,clientPrincipal,server1Principal,server2Principal);
    SecurityUtil.setAuthenticationMethod(AuthenticationMethod.KERBEROS,conf);
    UserGroupInformation.setConfiguration(conf);
    UserGroupInformation.setShouldRenewImmediatelyForTests(true);
    props=new HashMap<String,String>();
    props.put(Sasl.QOP,QualityOfProtection.AUTHENTICATION.saslQop);
  }
  @Test public void test() throws Exception {
    UserGroupInformation ugi=UserGroupInformation.loginUserFromKeytabAndReturnUGI(clientPrincipal,keytabFile.getCanonicalPath());
    ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        SaslClient client=Sasl.createSaslClient(new String[]{AuthMethod.KERBEROS.getMechanismName()},clientPrincipal,server1Protocol,host,props,null);
        client.evaluateChallenge(new byte[0]);
        client.dispose();
        return null;
      }
    }
);
    Subject subject=ugi.getSubject();
    for (    KerberosTicket ticket : subject.getPrivateCredentials(KerberosTicket.class)) {
      if (ticket.getServer().getName().startsWith("krbtgt")) {
        subject.getPrivateCredentials().remove(ticket);
        subject.getPrivateCredentials().add(ticket);
        break;
      }
    }
    assertFalse("The first ticket is still tgt, " + "the implementation in jdk may have been changed, " + "please reconsider the problem in HADOOP-13433",subject.getPrivateCredentials().stream().filter(c -> c instanceof KerberosTicket).map(c -> ((KerberosTicket)c).getServer().getName()).findFirst().get().startsWith("krbtgt"));
    intercept(SaslException.class,() -> ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        SaslClient client=Sasl.createSaslClient(new String[]{AuthMethod.KERBEROS.getMechanismName()},clientPrincipal,server2Protocol,host,props,null);
        client.evaluateChallenge(new byte[0]);
        client.dispose();
        return null;
      }
    }
));
    ugi.fixKerberosTicketOrder();
    assertTrue("The first ticket is not tgt",subject.getPrivateCredentials().stream().filter(c -> c instanceof KerberosTicket).map(c -> ((KerberosTicket)c).getServer().getName()).findFirst().get().startsWith("krbtgt"));
    ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        SaslClient client=Sasl.createSaslClient(new String[]{AuthMethod.KERBEROS.getMechanismName()},clientPrincipal,server2Protocol,host,props,null);
        client.evaluateChallenge(new byte[0]);
        client.dispose();
        return null;
      }
    }
);
    assertTrue("No service ticket for " + server2Protocol + " found",subject.getPrivateCredentials(KerberosTicket.class).stream().filter(t -> t.getServer().getName().startsWith(server2Protocol)).findAny().isPresent());
  }
  @Test public void testWithDestroyedTGT() throws Exception {
    UserGroupInformation ugi=UserGroupInformation.loginUserFromKeytabAndReturnUGI(clientPrincipal,keytabFile.getCanonicalPath());
    ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        SaslClient client=Sasl.createSaslClient(new String[]{AuthMethod.KERBEROS.getMechanismName()},clientPrincipal,server1Protocol,host,props,null);
        client.evaluateChallenge(new byte[0]);
        client.dispose();
        return null;
      }
    }
);
    Subject subject=ugi.getSubject();
    for (    KerberosTicket ticket : subject.getPrivateCredentials(KerberosTicket.class)) {
      if (ticket.getServer().getName().startsWith("krbtgt")) {
        ticket.destroy();
        break;
      }
    }
    ugi.fixKerberosTicketOrder();
    assertFalse("The first ticket is not tgt",subject.getPrivateCredentials().stream().filter(c -> c instanceof KerberosTicket).map(c -> ((KerberosTicket)c).getServer().getName()).findFirst().isPresent());
    intercept(SaslException.class,() -> ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        SaslClient client=Sasl.createSaslClient(new String[]{AuthMethod.KERBEROS.getMechanismName()},clientPrincipal,server2Protocol,host,props,null);
        client.evaluateChallenge(new byte[0]);
        client.dispose();
        return null;
      }
    }
));
    ugi.reloginFromKeytab();
    ugi.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        SaslClient client=Sasl.createSaslClient(new String[]{AuthMethod.KERBEROS.getMechanismName()},clientPrincipal,server2Protocol,host,props,null);
        client.evaluateChallenge(new byte[0]);
        client.dispose();
        return null;
      }
    }
);
    assertTrue("No service ticket for " + server2Protocol + " found",subject.getPrivateCredentials(KerberosTicket.class).stream().filter(t -> t.getServer().getName().startsWith(server2Protocol)).findAny().isPresent());
  }
}
