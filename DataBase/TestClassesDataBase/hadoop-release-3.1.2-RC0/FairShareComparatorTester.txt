/** 
 * This class is responsible for testing the transitivity of {@link FairSharePolicy.FairShareComparator}. We will generate a lot of triples(each triple contains three  {@link Schedulable}), and then we verify transitivity by using each triple. <p>How to generate:</p> For each field in  {@link Schedulable} we all have a data collection. Wecombine these data to construct a  {@link Schedulable}, and generate all cases of triple by DFS(depth first search algorithm). We can get 100% code coverage by DFS.
 */
private class FairShareComparatorTester {
  private Comparator<Schedulable> fairShareComparator;
  private Resource minShare=Resource.newInstance(0,1);
  private Resource demand=Resource.newInstance(4,1);
  private Resource[] demandCollection={Resource.newInstance(0,0),Resource.newInstance(4,1)};
  private String[] nameCollection={"A","B","C"};
  private long[] startTimeColloection={1L,2L,3L};
  private Resource[] usageCollection={Resource.newInstance(0,1),Resource.newInstance(2,1),Resource.newInstance(4,1)};
  private float[] weightsCollection={0.0f,1.0f,2.0f};
  public FairShareComparatorTester(  Comparator<Schedulable> fairShareComparator){
    this.fairShareComparator=fairShareComparator;
  }
  public void testTransitivity(){
    generateAndTest(new Stack<Schedulable>());
  }
  private void generateAndTest(  Stack<Schedulable> genSchedulable){
    if (genSchedulable.size() == 3) {
      Assert.assertTrue("The comparator must ensure transitivity",checkTransitivity(genSchedulable));
      return;
    }
    for (int i=0; i < nameCollection.length; i++) {
      for (int j=0; j < startTimeColloection.length; j++) {
        for (int k=0; k < usageCollection.length; k++) {
          for (int t=0; t < weightsCollection.length; t++) {
            for (int m=0; m < demandCollection.length; m++) {
              genSchedulable.push(createSchedulable(m,i,j,k,t));
              generateAndTest(genSchedulable);
              genSchedulable.pop();
            }
          }
        }
      }
    }
  }
  private Schedulable createSchedulable(  int demandId,  int nameIdx,  int startTimeIdx,  int usageIdx,  int weightsIdx){
    return new MockSchedulable(minShare,demandCollection[demandId],nameCollection[nameIdx],startTimeColloection[startTimeIdx],usageCollection[usageIdx],weightsCollection[weightsIdx]);
  }
  private boolean checkTransitivity(  Collection<Schedulable> schedulableObjs){
    Assert.assertEquals(3,schedulableObjs.size());
    Schedulable[] copy=schedulableObjs.toArray(new Schedulable[3]);
    if (fairShareComparator.compare(copy[0],copy[1]) > 0) {
      swap(copy,0,1);
    }
    if (fairShareComparator.compare(copy[1],copy[2]) > 0) {
      swap(copy,1,2);
      if (fairShareComparator.compare(copy[0],copy[1]) > 0) {
        swap(copy,0,1);
      }
    }
    if (fairShareComparator.compare(copy[0],copy[2]) <= 0) {
      return true;
    }
 else {
      LOG.fatal("Failure data: " + copy[0] + " "+ copy[1]+ " "+ copy[2]);
      return false;
    }
  }
  private void swap(  Schedulable[] array,  int x,  int y){
    Schedulable tmp=array[x];
    array[x]=array[y];
    array[y]=tmp;
  }
private class MockSchedulable implements Schedulable {
    private Resource minShare;
    private Resource demand;
    private String name;
    private long startTime;
    private Resource usage;
    private float weights;
    public MockSchedulable(    Resource minShare,    Resource demand,    String name,    long startTime,    Resource usage,    float weights){
      this.minShare=minShare;
      this.demand=demand;
      this.name=name;
      this.startTime=startTime;
      this.usage=usage;
      this.weights=weights;
    }
    @Override public String getName(){
      return name;
    }
    @Override public Resource getDemand(){
      return demand;
    }
    @Override public Resource getResourceUsage(){
      return usage;
    }
    @Override public Resource getMinShare(){
      return minShare;
    }
    @Override public float getWeight(){
      return weights;
    }
    @Override public long getStartTime(){
      return startTime;
    }
    @Override public Resource getMaxShare(){
      throw new UnsupportedOperationException();
    }
    @Override public Priority getPriority(){
      throw new UnsupportedOperationException();
    }
    @Override public void updateDemand(){
      throw new UnsupportedOperationException();
    }
    @Override public Resource assignContainer(    FSSchedulerNode node){
      throw new UnsupportedOperationException();
    }
    @Override public Resource getFairShare(){
      throw new UnsupportedOperationException();
    }
    @Override public void setFairShare(    Resource fairShare){
      throw new UnsupportedOperationException();
    }
    @Override public String toString(){
      return "{name:" + name + ", start:"+ startTime+ ", usage:"+ usage+ ", weights:"+ weights+ ", demand:"+ demand+ ", minShare:"+ minShare+ "}";
    }
    @Override public boolean isPreemptable(){
      return true;
    }
  }
}
