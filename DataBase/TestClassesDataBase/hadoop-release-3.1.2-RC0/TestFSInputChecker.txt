/** 
 * This class tests if FSInputChecker works correctly.
 */
public class TestFSInputChecker {
  static final long seed=0xDEADBEEFL;
  static final int BYTES_PER_SUM=10;
  static final int BLOCK_SIZE=2 * BYTES_PER_SUM;
  static final int HALF_CHUNK_SIZE=BYTES_PER_SUM / 2;
  static final int FILE_SIZE=2 * BLOCK_SIZE - 1;
  static final short NUM_OF_DATANODES=2;
  final byte[] expected=new byte[FILE_SIZE];
  byte[] actual;
  FSDataInputStream stm;
  final Random rand=new Random(seed);
  private void writeFile(  FileSystem fileSys,  Path name) throws IOException {
    FSDataOutputStream stm=fileSys.create(name,new FsPermission((short)0777),true,fileSys.getConf().getInt(CommonConfigurationKeys.IO_FILE_BUFFER_SIZE_KEY,4096),NUM_OF_DATANODES,BLOCK_SIZE,null);
    stm.write(expected);
    stm.close();
  }
  private void checkAndEraseData(  byte[] actual,  int from,  byte[] expected,  String message) throws Exception {
    for (int idx=0; idx < actual.length; idx++) {
      assertEquals(message + " byte " + (from + idx)+ " differs. expected "+ expected[from + idx]+ " actual "+ actual[idx],actual[idx],expected[from + idx]);
      actual[idx]=0;
    }
  }
  private void checkReadAndGetPos() throws Exception {
    actual=new byte[FILE_SIZE];
    stm.seek(0);
    int offset;
    for (offset=0; offset < BLOCK_SIZE + BYTES_PER_SUM; offset+=BYTES_PER_SUM) {
      assertEquals(stm.getPos(),offset);
      stm.readFully(actual,offset,BYTES_PER_SUM);
    }
    stm.readFully(actual,offset,FILE_SIZE - BLOCK_SIZE - BYTES_PER_SUM);
    assertEquals(stm.getPos(),FILE_SIZE);
    checkAndEraseData(actual,0,expected,"Read Sanity Test");
    stm.seek(0L);
    assertEquals(stm.getPos(),0L);
    stm.readFully(actual,0,HALF_CHUNK_SIZE);
    assertEquals(stm.getPos(),HALF_CHUNK_SIZE);
    stm.readFully(actual,HALF_CHUNK_SIZE,BLOCK_SIZE - HALF_CHUNK_SIZE);
    assertEquals(stm.getPos(),BLOCK_SIZE);
    stm.readFully(actual,BLOCK_SIZE,BYTES_PER_SUM + HALF_CHUNK_SIZE);
    assertEquals(stm.getPos(),BLOCK_SIZE + BYTES_PER_SUM + HALF_CHUNK_SIZE);
    stm.readFully(actual,2 * BLOCK_SIZE - HALF_CHUNK_SIZE,FILE_SIZE - (2 * BLOCK_SIZE - HALF_CHUNK_SIZE));
    assertEquals(stm.getPos(),FILE_SIZE);
    checkAndEraseData(actual,0,expected,"Read Sanity Test");
    stm.seek(0L);
    stm.readFully(actual,0,BYTES_PER_SUM + HALF_CHUNK_SIZE);
    assertEquals(stm.getPos(),BYTES_PER_SUM + HALF_CHUNK_SIZE);
    stm.readFully(actual,BYTES_PER_SUM + HALF_CHUNK_SIZE,BYTES_PER_SUM);
    assertEquals(stm.getPos(),BLOCK_SIZE + HALF_CHUNK_SIZE);
    stm.readFully(actual,BLOCK_SIZE + HALF_CHUNK_SIZE,FILE_SIZE - BLOCK_SIZE - HALF_CHUNK_SIZE);
    assertEquals(stm.getPos(),FILE_SIZE);
    checkAndEraseData(actual,0,expected,"Read Sanity Test");
  }
  private void testSeek1(  int offset) throws Exception {
    stm.seek(offset);
    assertEquals(offset,stm.getPos());
    stm.readFully(actual);
    checkAndEraseData(actual,offset,expected,"Read Sanity Test");
  }
  private void checkSeek() throws Exception {
    actual=new byte[HALF_CHUNK_SIZE];
    testSeek1(0);
    testSeek1(BYTES_PER_SUM);
    testSeek1(BLOCK_SIZE);
    testSeek1(BLOCK_SIZE + HALF_CHUNK_SIZE);
    testSeek1(HALF_CHUNK_SIZE);
    testSeek1(HALF_CHUNK_SIZE / 2);
    testSeek1(HALF_CHUNK_SIZE * 3 / 2);
    actual=new byte[1];
    testSeek1(FILE_SIZE - 1);
    String errMsg=null;
    try {
      stm.seek(FILE_SIZE);
    }
 catch (    IOException e) {
      errMsg=e.getMessage();
    }
    assertTrue(errMsg == null);
  }
  private void testSkip1(  int skippedBytes) throws Exception {
    long oldPos=stm.getPos();
    IOUtils.skipFully(stm,skippedBytes);
    long newPos=oldPos + skippedBytes;
    assertEquals(stm.getPos(),newPos);
    stm.readFully(actual);
    checkAndEraseData(actual,(int)newPos,expected,"Read Sanity Test");
  }
  private void checkSkip() throws Exception {
    actual=new byte[HALF_CHUNK_SIZE];
    stm.seek(0);
    testSkip1(BYTES_PER_SUM);
    testSkip1(HALF_CHUNK_SIZE);
    testSkip1(HALF_CHUNK_SIZE);
    stm.seek(0);
    testSkip1(HALF_CHUNK_SIZE + 1);
    testSkip1(BYTES_PER_SUM);
    testSkip1(HALF_CHUNK_SIZE);
    stm.seek(0);
    testSkip1(1);
    testSkip1(1);
    stm.seek(0);
    actual=new byte[1];
    testSkip1(FILE_SIZE - 1);
    stm.seek(0);
    IOUtils.skipFully(stm,FILE_SIZE);
    try {
      IOUtils.skipFully(stm,10);
      fail("expected to get a PrematureEOFException");
    }
 catch (    EOFException e) {
      assertEquals(e.getMessage(),"Premature EOF from inputStream " + "after skipping 0 byte(s).");
    }
    stm.seek(0);
    try {
      IOUtils.skipFully(stm,FILE_SIZE + 10);
      fail("expected to get a PrematureEOFException");
    }
 catch (    EOFException e) {
      assertEquals(e.getMessage(),"Premature EOF from inputStream " + "after skipping " + FILE_SIZE + " byte(s).");
    }
    stm.seek(10);
    try {
      IOUtils.skipFully(stm,FILE_SIZE);
      fail("expected to get a PrematureEOFException");
    }
 catch (    EOFException e) {
      assertEquals(e.getMessage(),"Premature EOF from inputStream " + "after skipping " + (FILE_SIZE - 10) + " byte(s).");
    }
  }
  private void cleanupFile(  FileSystem fileSys,  Path name) throws IOException {
    assertTrue(fileSys.exists(name));
    fileSys.delete(name,true);
    assertTrue(!fileSys.exists(name));
  }
  /** 
 * Tests read/seek/getPos/skipped opeation for input stream.
 */
  private void testChecker(  FileSystem fileSys,  boolean readCS) throws Exception {
    Path file=new Path("try.dat");
    writeFile(fileSys,file);
    try {
      if (!readCS) {
        fileSys.setVerifyChecksum(false);
      }
      stm=fileSys.open(file);
      checkReadAndGetPos();
      checkSeek();
      checkSkip();
      assertFalse(stm.markSupported());
      stm.close();
    }
  finally {
      if (!readCS) {
        fileSys.setVerifyChecksum(true);
      }
      cleanupFile(fileSys,file);
    }
  }
  private void testFileCorruption(  LocalFileSystem fileSys) throws IOException {
    String dir=PathUtils.getTestDirName(getClass());
    Path file=new Path(dir + "/corruption-test.dat");
    Path crcFile=new Path(dir + "/.corruption-test.dat.crc");
    writeFile(fileSys,file);
    int fileLen=(int)fileSys.getFileStatus(file).getLen();
    byte[] buf=new byte[fileLen];
    InputStream in=fileSys.open(file);
    IOUtils.readFully(in,buf,0,buf.length);
    in.close();
    checkFileCorruption(fileSys,file,crcFile);
    fileSys.delete(file,true);
    writeFile(fileSys,file);
    checkFileCorruption(fileSys,file,file);
    fileSys.delete(file,true);
  }
  private void checkFileCorruption(  LocalFileSystem fileSys,  Path file,  Path fileToCorrupt) throws IOException {
    RandomAccessFile out=new RandomAccessFile(new File(fileToCorrupt.toString()),"rw");
    byte[] buf=new byte[(int)fileSys.getFileStatus(file).getLen()];
    int corruptFileLen=(int)fileSys.getFileStatus(fileToCorrupt).getLen();
    assertTrue(buf.length >= corruptFileLen);
    rand.nextBytes(buf);
    out.seek(corruptFileLen / 2);
    out.write(buf,0,corruptFileLen / 4);
    out.close();
    boolean gotException=false;
    InputStream in=fileSys.open(file);
    try {
      IOUtils.readFully(in,buf,0,buf.length);
    }
 catch (    ChecksumException e) {
      gotException=true;
    }
    assertTrue(gotException);
    in.close();
  }
  @Test public void testFSInputChecker() throws Exception {
    Configuration conf=new HdfsConfiguration();
    conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,BLOCK_SIZE);
    conf.setInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY,BYTES_PER_SUM);
    rand.nextBytes(expected);
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
    FileSystem fileSys=cluster.getFileSystem();
    try {
      testChecker(fileSys,true);
      testChecker(fileSys,false);
      testSeekAndRead(fileSys);
    }
  finally {
      fileSys.close();
      cluster.shutdown();
    }
    fileSys=FileSystem.getLocal(conf);
    try {
      testChecker(fileSys,true);
      testChecker(fileSys,false);
      testFileCorruption((LocalFileSystem)fileSys);
      testSeekAndRead(fileSys);
    }
  finally {
      fileSys.close();
    }
  }
  private void testSeekAndRead(  FileSystem fileSys) throws IOException {
    Path file=new Path("try.dat");
    writeFile(fileSys,file);
    stm=fileSys.open(file,fileSys.getConf().getInt(CommonConfigurationKeys.IO_FILE_BUFFER_SIZE_KEY,4096));
    checkSeekAndRead();
    stm.close();
    cleanupFile(fileSys,file);
  }
  private void checkSeekAndRead() throws IOException {
    int position=1;
    int len=2 * BYTES_PER_SUM - position;
    readAndCompare(stm,position,len);
    position=BYTES_PER_SUM;
    len=BYTES_PER_SUM;
    readAndCompare(stm,position,len);
  }
  private void readAndCompare(  FSDataInputStream in,  int position,  int len) throws IOException {
    byte[] b=new byte[len];
    in.seek(position);
    IOUtils.readFully(in,b,0,b.length);
    for (int i=0; i < b.length; i++) {
      assertEquals(expected[position + i],b[i]);
    }
  }
}
