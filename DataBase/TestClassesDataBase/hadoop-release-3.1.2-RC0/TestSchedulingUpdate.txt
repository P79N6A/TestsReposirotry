public class TestSchedulingUpdate extends FairSchedulerTestBase {
  @Override public Configuration createConfiguration(){
    Configuration conf=super.createConfiguration();
    conf.setInt(FairSchedulerConfiguration.UPDATE_INTERVAL_MS,Integer.MAX_VALUE);
    return conf;
  }
  @Before public void setup(){
    conf=createConfiguration();
    resourceManager=new MockRM(conf);
    resourceManager.start();
    scheduler=(FairScheduler)resourceManager.getResourceScheduler();
  }
  @After public void teardown(){
    if (resourceManager != null) {
      resourceManager.stop();
      resourceManager=null;
    }
  }
  @Test(timeout=3000) public void testSchedulingUpdateOnNodeJoinLeave() throws InterruptedException {
    verifyNoCalls();
    String host="127.0.0.1";
    final int memory=4096;
    final int cores=4;
    RMNode node1=MockNodes.newNodeInfo(1,Resources.createResource(memory,cores),1,host);
    NodeAddedSchedulerEvent nodeEvent1=new NodeAddedSchedulerEvent(node1);
    scheduler.handle(nodeEvent1);
    long expectedCalls=1;
    verifyExpectedCalls(expectedCalls,memory,cores);
    NodeRemovedSchedulerEvent nodeEvent2=new NodeRemovedSchedulerEvent(node1);
    scheduler.handle(nodeEvent2);
    expectedCalls=2;
    verifyExpectedCalls(expectedCalls,0,0);
  }
  private void verifyExpectedCalls(  long expectedCalls,  int memory,  int vcores) throws InterruptedException {
    boolean verified=false;
    int count=0;
    while (count < 100) {
      if (scheduler.fsOpDurations.hasUpdateThreadRunChanged()) {
        break;
      }
      count++;
      Thread.sleep(10);
    }
    assertTrue("Update Thread has not run based on its metrics",scheduler.fsOpDurations.hasUpdateThreadRunChanged());
    assertEquals("Root queue metrics memory does not have expected value",memory,scheduler.getRootQueueMetrics().getAvailableMB());
    assertEquals("Root queue metrics cpu does not have expected value",vcores,scheduler.getRootQueueMetrics().getAvailableVirtualCores());
    MetricsCollectorImpl collector=new MetricsCollectorImpl();
    scheduler.fsOpDurations.getMetrics(collector,true);
    MetricsRecord record=collector.getRecords().get(0);
    for (    AbstractMetric abstractMetric : record.metrics()) {
      if (abstractMetric.name().contains("UpdateThreadRunNumOps")) {
        assertEquals("Update Thread did not run expected number of times " + "based on metric record count",expectedCalls,abstractMetric.value());
        verified=true;
      }
    }
    assertTrue("Did not find metric for UpdateThreadRunNumOps",verified);
  }
  private void verifyNoCalls(){
    assertFalse("Update thread should not have executed",scheduler.fsOpDurations.hasUpdateThreadRunChanged());
    assertEquals("Scheduler queue memory should not have been updated",0,scheduler.getRootQueueMetrics().getAvailableMB());
    assertEquals("Scheduler queue cpu should not have been updated",0,scheduler.getRootQueueMetrics().getAvailableVirtualCores());
  }
}
