/** 
 * Tests the Native Azure file system (WASB) using parallel threads for rename and delete operations.
 */
public class ITestFileSystemOperationsWithThreads extends AbstractWasbTestBase {
  private final int renameThreads=10;
  private final int deleteThreads=20;
  private int iterations=1;
  private LogCapturer logs=null;
  @Rule public ExpectedException exception=ExpectedException.none();
  @Before public void setUp() throws Exception {
    super.setUp();
    Configuration conf=fs.getConf();
    conf.setInt(NativeAzureFileSystem.AZURE_RENAME_THREADS,renameThreads);
    conf.setInt(NativeAzureFileSystem.AZURE_DELETE_THREADS,deleteThreads);
    conf.setBoolean(AzureNativeFileSystemStore.KEY_ENABLE_FLAT_LISTING,true);
    URI uri=fs.getUri();
    fs.initialize(uri,conf);
    logs=LogCapturer.captureLogs(new Log4JLogger(org.apache.log4j.Logger.getRootLogger()));
  }
  private void createFolder(  FileSystem fs,  String root) throws Exception {
    fs.mkdirs(new Path(root));
    for (int i=0; i < this.iterations; i++) {
      fs.mkdirs(new Path(root + "/" + i));
      fs.createNewFile(new Path(root + "/" + i+ "/fileToRename"));
      fs.createNewFile(new Path(root + "/" + i+ "/file/to/rename"));
      fs.createNewFile(new Path(root + "/" + i+ "/file+to%rename"));
      fs.createNewFile(new Path(root + "/fileToRename" + i));
    }
  }
  private void validateRenameFolder(  FileSystem fs,  String source,  String dest) throws Exception {
    createFolder(fs,source);
    Path sourceFolder=new Path(source);
    Path destFolder=new Path(dest);
    assertTrue(fs.rename(sourceFolder,destFolder));
    assertTrue(fs.exists(destFolder));
    for (int i=0; i < this.iterations; i++) {
      assertTrue(fs.exists(new Path(dest + "/" + i)));
      assertTrue(fs.exists(new Path(dest + "/" + i+ "/fileToRename")));
      assertTrue(fs.exists(new Path(dest + "/" + i+ "/file/to/rename")));
      assertTrue(fs.exists(new Path(dest + "/" + i+ "/file+to%rename")));
      assertTrue(fs.exists(new Path(dest + "/fileToRename" + i)));
      assertFalse(fs.exists(new Path(source + "/" + i)));
      assertFalse(fs.exists(new Path(source + "/" + i+ "/fileToRename")));
      assertFalse(fs.exists(new Path(source + "/" + i+ "/file/to/rename")));
      assertFalse(fs.exists(new Path(source + "/" + i+ "/file+to%rename")));
      assertFalse(fs.exists(new Path(source + "/fileToRename" + i)));
    }
  }
  @Test public void testRenameSmallFolderWithThreads() throws Exception {
    validateRenameFolder(fs,"root","rootnew");
    int expectedThreadsCreated=Math.min(7,renameThreads);
    String content=logs.getOutput();
    assertInLog(content,"ms with threads: " + expectedThreadsCreated);
    for (int i=0; i < expectedThreadsCreated; i++) {
      assertInLog(content,"AzureBlobRenameThread-" + Thread.currentThread().getName() + "-"+ i);
    }
    if (expectedThreadsCreated < renameThreads) {
      for (int i=expectedThreadsCreated; i < renameThreads; i++) {
        assertNotInLog(content,"AzureBlobRenameThread-" + Thread.currentThread().getName() + "-"+ i);
      }
    }
  }
  @Test public void testRenameLargeFolderWithThreads() throws Exception {
    this.iterations=10;
    validateRenameFolder(fs,"root","rootnew");
    String content=logs.getOutput();
    assertInLog(content,"ms with threads: " + renameThreads);
    for (int i=0; i < renameThreads; i++) {
      assertInLog(content,"AzureBlobRenameThread-" + Thread.currentThread().getName() + "-"+ i);
    }
  }
  @Test public void testRenameLargeFolderDisableThreads() throws Exception {
    Configuration conf=fs.getConf();
    conf.setInt(NativeAzureFileSystem.AZURE_RENAME_THREADS,0);
    URI uri=fs.getUri();
    fs.initialize(uri,conf);
    this.iterations=10;
    validateRenameFolder(fs,"root","rootnew");
    String content=logs.getOutput();
    assertInLog(content,"Disabling threads for Rename operation as thread count 0");
    for (int i=0; i < renameThreads; i++) {
      String term="AzureBlobRenameThread-" + Thread.currentThread().getName() + "-"+ i;
      assertNotInLog(content,term);
    }
  }
  /** 
 * Assert that a log contains the given term.
 * @param content log output
 * @param term search term
 */
  protected void assertInLog(  String content,  String term){
    assertTrue("Empty log",!content.isEmpty());
    if (!content.contains(term)) {
      String message="No " + term + " found in logs";
      LOG.error(message);
      System.err.println(content);
      fail(message);
    }
  }
  /** 
 * Assert that a log does not contain the given term.
 * @param content log output
 * @param term search term
 */
  protected void assertNotInLog(  String content,  String term){
    assertTrue("Empty log",!content.isEmpty());
    if (content.contains(term)) {
      String message=term + " found in logs";
      LOG.error(message);
      System.err.println(content);
      fail(message);
    }
  }
  @Test public void testRenameSmallFolderDisableThreadsDisableFlatListing() throws Exception {
    Configuration conf=fs.getConf();
    conf=fs.getConf();
    conf.setInt(NativeAzureFileSystem.AZURE_RENAME_THREADS,1);
    conf.setBoolean(AzureNativeFileSystemStore.KEY_ENABLE_FLAT_LISTING,false);
    URI uri=fs.getUri();
    fs.initialize(uri,conf);
    validateRenameFolder(fs,"root","rootnew");
    String content=logs.getOutput();
    assertInLog(content,"Disabling threads for Rename operation as thread count 1");
    for (int i=0; i < renameThreads; i++) {
      assertNotInLog(content,"AzureBlobRenameThread-" + Thread.currentThread().getName() + "-"+ i);
    }
  }
  private void validateDeleteFolder(  FileSystem fs,  String source) throws Exception {
    createFolder(fs,"root");
    Path sourceFolder=new Path(source);
    assertTrue(fs.delete(sourceFolder,true));
    assertFalse(fs.exists(sourceFolder));
    for (int i=0; i < this.iterations; i++) {
      assertFalse(fs.exists(new Path(source + "/" + i)));
      assertFalse(fs.exists(new Path(source + "/" + i+ "/fileToRename")));
      assertFalse(fs.exists(new Path(source + "/" + i+ "/file/to/rename")));
      assertFalse(fs.exists(new Path(source + "/" + i+ "/file+to%rename")));
      assertFalse(fs.exists(new Path(source + "/fileToRename" + i)));
    }
  }
  @Test public void testDeleteSmallFolderWithThreads() throws Exception {
    validateDeleteFolder(fs,"root");
    int expectedThreadsCreated=Math.min(7,deleteThreads);
    String content=logs.getOutput();
    assertInLog(content,"ms with threads: " + expectedThreadsCreated);
    for (int i=0; i < expectedThreadsCreated; i++) {
      assertInLog(content,"AzureBlobDeleteThread-" + Thread.currentThread().getName() + "-"+ i);
    }
    if (expectedThreadsCreated < deleteThreads) {
      for (int i=expectedThreadsCreated; i < deleteThreads; i++) {
        assertNotInLog(content,"AzureBlobDeleteThread-" + Thread.currentThread().getName() + "-"+ i);
      }
    }
  }
  @Test public void testDeleteLargeFolderWithThreads() throws Exception {
    this.iterations=10;
    validateDeleteFolder(fs,"root");
    String content=logs.getOutput();
    assertInLog(content,"ms with threads: " + deleteThreads);
    for (int i=0; i < deleteThreads; i++) {
      assertInLog(content,"AzureBlobDeleteThread-" + Thread.currentThread().getName() + "-"+ i);
    }
  }
  @Test public void testDeleteLargeFolderDisableThreads() throws Exception {
    Configuration conf=fs.getConf();
    conf.setInt(NativeAzureFileSystem.AZURE_DELETE_THREADS,0);
    URI uri=fs.getUri();
    fs.initialize(uri,conf);
    this.iterations=10;
    validateDeleteFolder(fs,"root");
    String content=logs.getOutput();
    assertInLog(content,"Disabling threads for Delete operation as thread count 0");
    for (int i=0; i < deleteThreads; i++) {
      assertNotInLog(content,"AzureBlobDeleteThread-" + Thread.currentThread().getName() + "-"+ i);
    }
  }
  @Test public void testDeleteSmallFolderDisableThreadsDisableFlatListing() throws Exception {
    Configuration conf=fs.getConf();
    conf.setInt(NativeAzureFileSystem.AZURE_DELETE_THREADS,1);
    conf.setBoolean(AzureNativeFileSystemStore.KEY_ENABLE_FLAT_LISTING,false);
    URI uri=fs.getUri();
    fs.initialize(uri,conf);
    validateDeleteFolder(fs,"root");
    String content=logs.getOutput();
    assertInLog(content,"Disabling threads for Delete operation as thread count 1");
    for (int i=0; i < deleteThreads; i++) {
      assertNotInLog(content,"AzureBlobDeleteThread-" + Thread.currentThread().getName() + "-"+ i);
    }
  }
  @Test public void testDeleteThreadPoolExceptionFailure() throws Exception {
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(mockFs.getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS));
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenThrow(new Exception());
    Mockito.when(mockFs.getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS)).thenReturn(mockThreadPoolExecutor);
    validateDeleteFolder(mockFs,"root");
    String content=logs.getOutput();
    assertInLog(content,"Failed to create thread pool with threads");
    assertInLog(content,"Serializing the Delete operation");
  }
  @Test public void testDeleteThreadPoolExecuteFailure() throws Exception {
    ThreadPoolExecutor mockThreadExecutor=Mockito.mock(ThreadPoolExecutor.class);
    Mockito.doThrow(new RejectedExecutionException()).when(mockThreadExecutor).execute(Mockito.any(Runnable.class));
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(mockFs.getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS));
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenReturn(mockThreadExecutor);
    Mockito.when(mockFs.getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS)).thenReturn(mockThreadPoolExecutor);
    validateDeleteFolder(mockFs,"root");
    String content=logs.getOutput();
    assertInLog(content,"Rejected execution of thread for Delete operation on blob");
    assertInLog(content,"Serializing the Delete operation");
  }
  @Test public void testDeleteThreadPoolExecuteSingleThreadFailure() throws Exception {
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(mockFs.getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS));
    Mockito.when(mockFs.getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS)).thenReturn(mockThreadPoolExecutor);
    ThreadPoolExecutor mockThreadExecutor=Mockito.spy(mockThreadPoolExecutor.getThreadPool(7));
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenReturn(mockThreadExecutor);
    Mockito.doCallRealMethod().doThrow(new RejectedExecutionException()).when(mockThreadExecutor).execute(Mockito.any(Runnable.class));
    validateDeleteFolder(mockFs,"root");
    String content=logs.getOutput();
    assertInLog(content,"Using thread pool for Delete operation with threads 7");
    assertInLog(content,"6 threads not used for Delete operation on blob");
  }
  @Test public void testDeleteThreadPoolTerminationFailure() throws Exception {
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(((NativeAzureFileSystem)fs).getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS));
    ThreadPoolExecutor mockThreadExecutor=Mockito.mock(ThreadPoolExecutor.class);
    Mockito.doNothing().when(mockThreadExecutor).execute(Mockito.any(Runnable.class));
    Mockito.when(mockThreadExecutor.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS)).thenThrow(new InterruptedException());
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenReturn(mockThreadExecutor);
    Mockito.when(mockFs.getThreadPoolExecutor(deleteThreads,"AzureBlobDeleteThread","Delete",path,NativeAzureFileSystem.AZURE_DELETE_THREADS)).thenReturn(mockThreadPoolExecutor);
    createFolder(mockFs,"root");
    Path sourceFolder=new Path("root");
    boolean exception=false;
    try {
      mockFs.delete(sourceFolder,true);
    }
 catch (    IOException e) {
      exception=true;
    }
    assertTrue(exception);
    assertTrue(mockFs.exists(sourceFolder));
    String content=logs.getOutput();
    assertInLog(content,"Using thread pool for Delete operation with threads");
    assertInLog(content,"Threads got interrupted Delete blob operation");
    assertInLog(content,"Delete failed as operation on subfolders and files failed.");
  }
  @Test public void testRecursiveDirectoryDeleteWhenChildDirectoryDeleted() throws Exception {
    testRecusiveDirectoryDelete(true);
  }
  @Test public void testRecursiveDirectoryDeleteWhenDeletingChildFileReturnsFalse() throws Exception {
    testRecusiveDirectoryDelete(false);
  }
  private void testRecusiveDirectoryDelete(  boolean useDir) throws Exception {
    String childPathToBeDeletedByExternalAgent=(useDir) ? "root/0" : "root/0/fileToRename";
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path(childPathToBeDeletedByExternalAgent)));
    Answer<Boolean> answer=new Answer<Boolean>(){
      public Boolean answer(      InvocationOnMock invocation) throws Throwable {
        String path=(String)invocation.getArguments()[0];
        boolean isDir=(boolean)invocation.getArguments()[1];
        boolean realResult=fs.deleteFile(path,isDir);
        assertTrue(realResult);
        boolean fakeResult=false;
        return fakeResult;
      }
    }
;
    Mockito.when(mockFs.deleteFile(path,useDir)).thenAnswer(answer);
    createFolder(mockFs,"root");
    Path sourceFolder=new Path("root");
    assertTrue(mockFs.delete(sourceFolder,true));
    assertFalse(mockFs.exists(sourceFolder));
    String content=logs.getOutput();
    assertInLog(content,"Using thread pool for Delete operation with threads");
    assertInLog(content,String.format("Attempt to delete non-existent %s %s",useDir ? "directory" : "file",path));
  }
  @Test public void testDeleteSingleDeleteException() throws Exception {
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root/0")));
    Mockito.doThrow(new IOException()).when(mockFs).deleteFile(path,true);
    createFolder(mockFs,"root");
    Path sourceFolder=new Path("root");
    boolean exception=false;
    try {
      mockFs.delete(sourceFolder,true);
    }
 catch (    IOException e) {
      exception=true;
    }
    assertTrue(exception);
    assertTrue(mockFs.exists(sourceFolder));
    String content=logs.getOutput();
    assertInLog(content,"Using thread pool for Delete operation with threads");
    assertInLog(content,"Encountered Exception for Delete operation for file " + path);
    assertInLog(content,"Terminating execution of Delete operation now as some other thread already got exception or operation failed");
  }
  @Test public void testRenameThreadPoolExceptionFailure() throws Exception {
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(((NativeAzureFileSystem)fs).getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS));
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenThrow(new Exception());
    Mockito.doReturn(mockThreadPoolExecutor).when(mockFs).getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS);
    validateRenameFolder(mockFs,"root","rootnew");
    String content=logs.getOutput();
    assertInLog(content,"Failed to create thread pool with threads");
    assertInLog(content,"Serializing the Rename operation");
  }
  @Test public void testRenameThreadPoolExecuteFailure() throws Exception {
    ThreadPoolExecutor mockThreadExecutor=Mockito.mock(ThreadPoolExecutor.class);
    Mockito.doThrow(new RejectedExecutionException()).when(mockThreadExecutor).execute(Mockito.any(Runnable.class));
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS));
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenReturn(mockThreadExecutor);
    Mockito.when(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS)).thenReturn(mockThreadPoolExecutor);
    validateRenameFolder(mockFs,"root","rootnew");
    String content=logs.getOutput();
    assertInLog(content,"Rejected execution of thread for Rename operation on blob");
    assertInLog(content,"Serializing the Rename operation");
  }
  @Test public void testRenameThreadPoolExecuteSingleThreadFailure() throws Exception {
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS));
    Mockito.when(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS)).thenReturn(mockThreadPoolExecutor);
    ThreadPoolExecutor mockThreadExecutor=Mockito.spy(mockThreadPoolExecutor.getThreadPool(7));
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenReturn(mockThreadExecutor);
    Mockito.doCallRealMethod().doThrow(new RejectedExecutionException()).when(mockThreadExecutor).execute(Mockito.any(Runnable.class));
    validateRenameFolder(mockFs,"root","rootnew");
    String content=logs.getOutput();
    assertInLog(content,"Using thread pool for Rename operation with threads 7");
    assertInLog(content,"6 threads not used for Rename operation on blob");
  }
  @Test public void testRenameThreadPoolTerminationFailure() throws Exception {
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root")));
    AzureFileSystemThreadPoolExecutor mockThreadPoolExecutor=Mockito.spy(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS));
    Mockito.when(mockFs.getThreadPoolExecutor(renameThreads,"AzureBlobRenameThread","Rename",path,NativeAzureFileSystem.AZURE_RENAME_THREADS)).thenReturn(mockThreadPoolExecutor);
    ThreadPoolExecutor mockThreadExecutor=Mockito.mock(ThreadPoolExecutor.class);
    Mockito.doNothing().when(mockThreadExecutor).execute(Mockito.any(Runnable.class));
    Mockito.when(mockThreadExecutor.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS)).thenThrow(new InterruptedException());
    Mockito.when(mockThreadPoolExecutor.getThreadPool(7)).thenReturn(mockThreadExecutor);
    createFolder(mockFs,"root");
    Path sourceFolder=new Path("root");
    Path destFolder=new Path("rootnew");
    boolean exception=false;
    try {
      mockFs.rename(sourceFolder,destFolder);
    }
 catch (    IOException e) {
      exception=true;
    }
    assertTrue(exception);
    assertTrue(mockFs.exists(sourceFolder));
    String content=logs.getOutput();
    assertInLog(content,"Using thread pool for Rename operation with threads");
    assertInLog(content,"Threads got interrupted Rename blob operation");
    assertInLog(content,"Rename failed as operation on subfolders and files failed.");
  }
  @Test public void testRenameSingleRenameException() throws Exception {
    Path sourceFolder=new Path("root");
    Path destFolder=new Path("rootnew");
    NativeAzureFileSystem mockFs=Mockito.spy((NativeAzureFileSystem)fs);
    createFolder(mockFs,"root");
    String srcKey=mockFs.pathToKey(mockFs.makeAbsolute(sourceFolder));
    String dstKey=mockFs.pathToKey(mockFs.makeAbsolute(destFolder));
    FolderRenamePending mockRenameFs=Mockito.spy(mockFs.prepareAtomicFolderRename(srcKey,dstKey));
    Mockito.when(mockFs.prepareAtomicFolderRename(srcKey,dstKey)).thenReturn(mockRenameFs);
    String path=mockFs.pathToKey(mockFs.makeAbsolute(new Path("root/0")));
    Mockito.doThrow(new IOException()).when(mockRenameFs).renameFile(Mockito.any(FileMetadata.class));
    boolean exception=false;
    try {
      mockFs.rename(sourceFolder,destFolder);
    }
 catch (    IOException e) {
      exception=true;
    }
    assertTrue(exception);
    assertTrue(mockFs.exists(sourceFolder));
    String content=logs.getOutput();
    assertInLog(content,"Using thread pool for Rename operation with threads");
    assertInLog(content,"Encountered Exception for Rename operation for file " + path);
    assertInLog(content,"Terminating execution of Rename operation now as some other thread already got exception or operation failed");
  }
  @Override protected AzureBlobStorageTestAccount createTestAccount() throws Exception {
    return AzureBlobStorageTestAccount.create();
  }
}
