/** 
 * Verify that TestCommitBlockSynchronization is idempotent.
 */
public class TestCommitBlockSynchronization {
  private static final long blockId=100;
  private static final long length=200;
  private static final long genStamp=300;
  private FSNamesystem makeNameSystemSpy(  Block block,  INodeFile file) throws IOException {
    Configuration conf=new Configuration();
    FSEditLog editlog=mock(FSEditLog.class);
    FSImage image=new FSImage(conf);
    Whitebox.setInternalState(image,"editLog",editlog);
    final DatanodeStorageInfo[] targets={};
    FSNamesystem namesystem=new FSNamesystem(conf,image);
    namesystem.setImageLoaded(true);
    if (file.getParent() == null) {
      INodeDirectory parent=namesystem.getFSDirectory().getRoot();
      parent.addChild(file);
    }
    namesystem.dir.getINodeMap().put(file);
    FSNamesystem namesystemSpy=spy(namesystem);
    BlockInfo blockInfo=new BlockInfoContiguous(block,(short)1);
    blockInfo.convertToBlockUnderConstruction(HdfsServerConstants.BlockUCState.UNDER_CONSTRUCTION,targets);
    blockInfo.setBlockCollectionId(file.getId());
    blockInfo.setGenerationStamp(genStamp);
    blockInfo.getUnderConstructionFeature().initializeBlockRecovery(blockInfo,genStamp,true);
    doReturn(blockInfo).when(file).removeLastBlock(any(Block.class));
    doReturn(true).when(file).isUnderConstruction();
    doReturn(new BlockInfoContiguous[1]).when(file).getBlocks();
    doReturn(blockInfo).when(namesystemSpy).getStoredBlock(any(Block.class));
    doReturn(blockInfo).when(file).getLastBlock();
    doNothing().when(namesystemSpy).closeFileCommitBlocks(any(String.class),any(INodeFile.class),any(BlockInfo.class));
    doReturn(mock(FSEditLog.class)).when(namesystemSpy).getEditLog();
    return namesystemSpy;
  }
  private INodeFile mockFileUnderConstruction(){
    return mock(INodeFile.class);
  }
  @Test public void testCommitBlockSynchronization() throws IOException {
    INodeFile file=mockFileUnderConstruction();
    Block block=new Block(blockId,length,genStamp);
    FSNamesystem namesystemSpy=makeNameSystemSpy(block,file);
    DatanodeID[] newTargets=new DatanodeID[0];
    ExtendedBlock lastBlock=new ExtendedBlock();
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,false,false,newTargets,null);
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,false,false,newTargets,null);
    BlockInfo completedBlockInfo=new BlockInfoContiguous(block,(short)1);
    completedBlockInfo.setBlockCollectionId(file.getId());
    completedBlockInfo.setGenerationStamp(genStamp);
    doReturn(completedBlockInfo).when(namesystemSpy).getStoredBlock(any(Block.class));
    doReturn(completedBlockInfo).when(file).getLastBlock();
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,false,false,newTargets,null);
  }
  @Test public void testCommitBlockSynchronization2() throws IOException {
    INodeFile file=mockFileUnderConstruction();
    Block block=new Block(blockId,length,genStamp);
    FSNamesystem namesystemSpy=makeNameSystemSpy(block,file);
    DatanodeID[] newTargets=new DatanodeID[0];
    ExtendedBlock lastBlock=new ExtendedBlock();
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,false,false,newTargets,null);
    try {
      namesystemSpy.commitBlockSynchronization(lastBlock,genStamp - 1,length,false,false,newTargets,null);
      fail("Failed to get expected IOException on generation stamp/" + "recovery ID mismatch");
    }
 catch (    IOException ioe) {
    }
  }
  @Test public void testCommitBlockSynchronizationWithDelete() throws IOException {
    INodeFile file=mockFileUnderConstruction();
    Block block=new Block(blockId,length,genStamp);
    FSNamesystem namesystemSpy=makeNameSystemSpy(block,file);
    DatanodeID[] newTargets=new DatanodeID[0];
    ExtendedBlock lastBlock=new ExtendedBlock();
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,false,true,newTargets,null);
    doReturn(null).when(file).removeLastBlock(any(Block.class));
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,false,true,newTargets,null);
  }
  @Test public void testCommitBlockSynchronizationWithClose() throws IOException {
    INodeFile file=mockFileUnderConstruction();
    Block block=new Block(blockId,length,genStamp);
    FSNamesystem namesystemSpy=makeNameSystemSpy(block,file);
    DatanodeID[] newTargets=new DatanodeID[0];
    ExtendedBlock lastBlock=new ExtendedBlock();
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,true,false,newTargets,null);
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,true,false,newTargets,null);
    BlockInfo completedBlockInfo=new BlockInfoContiguous(block,(short)1);
    completedBlockInfo.setBlockCollectionId(file.getId());
    completedBlockInfo.setGenerationStamp(genStamp);
    doReturn(completedBlockInfo).when(namesystemSpy).getStoredBlock(any(Block.class));
    doReturn(completedBlockInfo).when(file).getLastBlock();
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,true,false,newTargets,null);
  }
  @Test public void testCommitBlockSynchronizationWithCloseAndNonExistantTarget() throws IOException {
    INodeFile file=mockFileUnderConstruction();
    Block block=new Block(blockId,length,genStamp);
    FSNamesystem namesystemSpy=makeNameSystemSpy(block,file);
    DatanodeID[] newTargets=new DatanodeID[]{new DatanodeID("0.0.0.0","nonexistantHost","1",0,0,0,0)};
    String[] storageIDs=new String[]{"fake-storage-ID"};
    ExtendedBlock lastBlock=new ExtendedBlock();
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,true,false,newTargets,storageIDs);
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,true,false,newTargets,storageIDs);
  }
}
