@RunWith(Parameterized.class) public class KVTest {
  private static final Logger LOG=LoggerFactory.getLogger(KVTest.class);
  private static Configuration nativekvtestconf=ScenarioConfiguration.getNativeConfiguration();
  private static Configuration hadoopkvtestconf=ScenarioConfiguration.getNormalConfiguration();
static {
    nativekvtestconf.addResource(TestConstants.KVTEST_CONF_PATH);
    hadoopkvtestconf.addResource(TestConstants.KVTEST_CONF_PATH);
  }
  private static List<Class<?>> parseClassNames(  String spec){
    List<Class<?>> ret=Lists.newArrayList();
    Iterable<String> classNames=Splitter.on(';').trimResults().omitEmptyStrings().split(spec);
    for (    String className : classNames) {
      try {
        ret.add(Class.forName(className));
      }
 catch (      ClassNotFoundException e) {
        throw new RuntimeException(e);
      }
    }
    return ret;
  }
  /** 
 * Parameterize the test with the specified key and value types.
 */
  @Parameters(name="key:{0}\nvalue:{1}") public static Iterable<Class<?>[]> data() throws Exception {
    final String valueClassesStr=nativekvtestconf.get(TestConstants.NATIVETASK_KVTEST_VALUECLASSES);
    LOG.info("Parameterizing with value classes: " + valueClassesStr);
    List<Class<?>> valueClasses=parseClassNames(valueClassesStr);
    final String keyClassesStr=nativekvtestconf.get(TestConstants.NATIVETASK_KVTEST_KEYCLASSES);
    LOG.info("Parameterizing with key classes: " + keyClassesStr);
    List<Class<?>> keyClasses=parseClassNames(keyClassesStr);
    List<Class<?>[]> pairs=Lists.newArrayList();
    for (    Class<?> keyClass : keyClasses) {
      pairs.add(new Class<?>[]{keyClass,LongWritable.class});
    }
    for (    Class<?> valueClass : valueClasses) {
      pairs.add(new Class<?>[]{LongWritable.class,valueClass});
    }
    return pairs;
  }
  private final Class<?> keyclass;
  private final Class<?> valueclass;
  public KVTest(  Class<?> keyclass,  Class<?> valueclass){
    this.keyclass=keyclass;
    this.valueclass=valueclass;
  }
  @Before public void startUp() throws Exception {
    Assume.assumeTrue(NativeCodeLoader.isNativeCodeLoaded());
    Assume.assumeTrue(NativeRuntime.isNativeLibraryLoaded());
  }
  @Test public void testKVCompability() throws Exception {
    final FileSystem fs=FileSystem.get(nativekvtestconf);
    final String jobName="Test:" + keyclass.getSimpleName() + "--"+ valueclass.getSimpleName();
    final String inputPath=TestConstants.NATIVETASK_KVTEST_INPUTDIR + "/" + keyclass.getName()+ "/"+ valueclass.getName();
    final String nativeOutputPath=TestConstants.NATIVETASK_KVTEST_NATIVE_OUTPUTDIR + "/" + keyclass.getName()+ "/"+ valueclass.getName();
    fs.delete(new Path(nativeOutputPath),true);
    nativekvtestconf.set(TestConstants.NATIVETASK_KVTEST_CREATEFILE,"true");
    final KVJob nativeJob=new KVJob(jobName,nativekvtestconf,keyclass,valueclass,inputPath,nativeOutputPath);
    assertTrue("job should complete successfully",nativeJob.runJob());
    final String normalOutputPath=TestConstants.NATIVETASK_KVTEST_NORMAL_OUTPUTDIR + "/" + keyclass.getName()+ "/"+ valueclass.getName();
    fs.delete(new Path(normalOutputPath),true);
    hadoopkvtestconf.set(TestConstants.NATIVETASK_KVTEST_CREATEFILE,"false");
    final KVJob normalJob=new KVJob(jobName,hadoopkvtestconf,keyclass,valueclass,inputPath,normalOutputPath);
    assertTrue("job should complete successfully",normalJob.runJob());
    final boolean compareRet=ResultVerifier.verify(normalOutputPath,nativeOutputPath);
    assertEquals("job output not the same",true,compareRet);
    ResultVerifier.verifyCounters(normalJob.job,nativeJob.job);
    fs.close();
  }
  @AfterClass public static void cleanUp() throws IOException {
    final FileSystem fs=FileSystem.get(new ScenarioConfiguration());
    fs.delete(new Path(TestConstants.NATIVETASK_KVTEST_DIR),true);
    fs.close();
  }
}
