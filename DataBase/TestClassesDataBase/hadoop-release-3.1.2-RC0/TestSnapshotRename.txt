/** 
 * Test for renaming snapshot
 */
public class TestSnapshotRename {
  static final long seed=0;
  static final short REPLICATION=3;
  static final long BLOCKSIZE=1024;
  private final Path dir=new Path("/TestSnapshot");
  private final Path sub1=new Path(dir,"sub1");
  private final Path file1=new Path(sub1,"file1");
  Configuration conf;
  MiniDFSCluster cluster;
  FSNamesystem fsn;
  DistributedFileSystem hdfs;
  FSDirectory fsdir;
  @Before public void setUp() throws Exception {
    conf=new Configuration();
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION).build();
    cluster.waitActive();
    fsn=cluster.getNamesystem();
    hdfs=cluster.getFileSystem();
    fsdir=fsn.getFSDirectory();
  }
  @After public void tearDown() throws Exception {
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  @Rule public ExpectedException exception=ExpectedException.none();
  /** 
 * Check the correctness of snapshot list within snapshottable dir
 */
  private void checkSnapshotList(  INodeDirectory srcRoot,  String[] sortedNames,  String[] names){
    assertTrue(srcRoot.isSnapshottable());
    ReadOnlyList<Snapshot> listByName=srcRoot.getDirectorySnapshottableFeature().getSnapshotList();
    assertEquals(sortedNames.length,listByName.size());
    for (int i=0; i < listByName.size(); i++) {
      assertEquals(sortedNames[i],listByName.get(i).getRoot().getLocalName());
    }
    DiffList<DirectoryDiff> listByTime=srcRoot.getDiffs().asList();
    assertEquals(names.length,listByTime.size());
    for (int i=0; i < listByTime.size(); i++) {
      Snapshot s=srcRoot.getDirectorySnapshottableFeature().getSnapshotById(listByTime.get(i).getSnapshotId());
      assertEquals(names[i],s.getRoot().getLocalName());
    }
  }
  /** 
 * Rename snapshot(s), and check the correctness of the snapshot list within {@link INodeDirectorySnapshottable}
 */
  @Test(timeout=60000) public void testSnapshotList() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s1");
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s2");
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s3");
    hdfs.renameSnapshot(sub1,"s3","s22");
    INodeDirectory srcRoot=fsdir.getINode(sub1.toString()).asDirectory();
    checkSnapshotList(srcRoot,new String[]{"s1","s2","s22"},new String[]{"s1","s2","s22"});
    hdfs.renameSnapshot(sub1,"s1","s4");
    checkSnapshotList(srcRoot,new String[]{"s2","s22","s4"},new String[]{"s4","s2","s22"});
    hdfs.renameSnapshot(sub1,"s22","s0");
    checkSnapshotList(srcRoot,new String[]{"s0","s2","s4"},new String[]{"s4","s2","s0"});
  }
  /** 
 * Test FileStatus of snapshot file before/after rename
 */
  @Test(timeout=60000) public void testSnapshotRename() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    Path snapshotRoot=SnapshotTestHelper.createSnapshot(hdfs,sub1,"s1");
    Path ssPath=new Path(snapshotRoot,file1.getName());
    assertTrue(hdfs.exists(ssPath));
    FileStatus statusBeforeRename=hdfs.getFileStatus(ssPath);
    hdfs.renameSnapshot(sub1,"s1","s2");
    assertFalse(hdfs.exists(ssPath));
    snapshotRoot=SnapshotTestHelper.getSnapshotRoot(sub1,"s2");
    ssPath=new Path(snapshotRoot,file1.getName());
    assertTrue(hdfs.exists(ssPath));
    FileStatus statusAfterRename=hdfs.getFileStatus(ssPath);
    assertFalse(statusBeforeRename.equals(statusAfterRename));
    statusBeforeRename.setPath(statusAfterRename.getPath());
    assertEquals(statusBeforeRename.toString(),statusAfterRename.toString());
  }
  /** 
 * Test rename a non-existing snapshot
 */
  @Test(timeout=60000) public void testRenameNonExistingSnapshot() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s1");
    exception.expect(SnapshotException.class);
    String error="The snapshot wrongName does not exist for directory " + sub1.toString();
    exception.expectMessage(error);
    hdfs.renameSnapshot(sub1,"wrongName","s2");
  }
  /** 
 * Test rename a non-existing snapshot to itself.
 */
  @Test(timeout=60000) public void testRenameNonExistingSnapshotToItself() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s1");
    exception.expect(SnapshotException.class);
    String error="The snapshot wrongName does not exist for directory " + sub1.toString();
    exception.expectMessage(error);
    hdfs.renameSnapshot(sub1,"wrongName","wrongName");
  }
  /** 
 * Test rename a snapshot to another existing snapshot 
 */
  @Test(timeout=60000) public void testRenameToExistingSnapshot() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s1");
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s2");
    exception.expect(SnapshotException.class);
    String error="The snapshot s2 already exists for directory " + sub1.toString();
    exception.expectMessage(error);
    hdfs.renameSnapshot(sub1,"s1","s2");
  }
  /** 
 * Test renaming a snapshot with illegal name
 */
  @Test public void testRenameWithIllegalName() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    SnapshotTestHelper.createSnapshot(hdfs,sub1,"s1");
    final String name1=HdfsConstants.DOT_SNAPSHOT_DIR;
    try {
      hdfs.renameSnapshot(sub1,"s1",name1);
      fail("Exception expected when an illegal name is given for rename");
    }
 catch (    RemoteException e) {
      String errorMsg="\"" + HdfsConstants.DOT_SNAPSHOT_DIR + "\" is a reserved name.";
      GenericTestUtils.assertExceptionContains(errorMsg,e);
    }
    String errorMsg="Snapshot name cannot contain \"" + Path.SEPARATOR + "\"";
    final String[] badNames=new String[]{"foo" + Path.SEPARATOR,Path.SEPARATOR + "foo",Path.SEPARATOR,"foo" + Path.SEPARATOR + "bar"};
    for (    String badName : badNames) {
      try {
        hdfs.renameSnapshot(sub1,"s1",badName);
        fail("Exception expected when an illegal name is given");
      }
 catch (      RemoteException e) {
        GenericTestUtils.assertExceptionContains(errorMsg,e);
      }
    }
  }
  @Test public void testRenameSnapshotCommandWithIllegalArguments() throws Exception {
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    PrintStream psOut=new PrintStream(out);
    PrintStream oldOut=System.out;
    PrintStream oldErr=System.err;
    try {
      System.setOut(psOut);
      System.setErr(psOut);
      FsShell shell=new FsShell();
      shell.setConf(conf);
      String[] argv1={"-renameSnapshot","/tmp","s1"};
      int val=shell.run(argv1);
      assertTrue(val == -1);
      assertTrue(out.toString().contains(argv1[0] + ": Incorrect number of arguments."));
      out.reset();
      String[] argv2={"-renameSnapshot","/tmp","s1","s2","s3"};
      val=shell.run(argv2);
      assertTrue(val == -1);
      assertTrue(out.toString().contains(argv2[0] + ": Incorrect number of arguments."));
      psOut.close();
      out.close();
    }
  finally {
      System.setOut(oldOut);
      System.setErr(oldErr);
    }
  }
}
