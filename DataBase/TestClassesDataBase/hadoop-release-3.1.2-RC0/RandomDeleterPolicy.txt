/** 
 * A BlockPlacementPolicy which, rather than using space available, makes random decisions about which excess replica to delete. This is because, in the test cases, the two NNs will usually (but not quite always) make the same decision of which replica to delete. The fencing issues are exacerbated when the two NNs make different decisions, which can happen in "real life" when they have slightly out-of-sync heartbeat information regarding disk usage.
 */
public static class RandomDeleterPolicy extends BlockPlacementPolicyDefault {
  public RandomDeleterPolicy(){
    super();
  }
  @Override public DatanodeStorageInfo chooseReplicaToDelete(  Collection<DatanodeStorageInfo> moreThanOne,  Collection<DatanodeStorageInfo> exactlyOne,  List<StorageType> excessTypes,  Map<String,List<DatanodeStorageInfo>> rackMap){
    Collection<DatanodeStorageInfo> chooseFrom=!moreThanOne.isEmpty() ? moreThanOne : exactlyOne;
    List<DatanodeStorageInfo> l=Lists.newArrayList(chooseFrom);
    return l.get(ThreadLocalRandom.current().nextInt(l.size()));
  }
}
