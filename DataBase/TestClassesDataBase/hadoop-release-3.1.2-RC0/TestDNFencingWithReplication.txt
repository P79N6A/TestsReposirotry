/** 
 * Stress-test for potential bugs when replication is changing on blocks during a failover.
 */
public class TestDNFencingWithReplication {
static {
    GenericTestUtils.setLogLevel(FSNamesystem.auditLog,Level.WARN);
    GenericTestUtils.setLogLevel(Server.LOG,Level.FATAL);
    GenericTestUtils.setLogLevel(RetryInvocationHandler.LOG,Level.FATAL);
  }
  private static final int NUM_THREADS=20;
  private static final long RUNTIME=35000;
  private static final int BLOCK_SIZE=1024;
private static class ReplicationToggler extends RepeatingTestThread {
    private final FileSystem fs;
    private final Path path;
    private final MiniDFSCluster cluster;
    ReplicationToggler(    TestContext ctx,    FileSystem fs,    Path p,    MiniDFSCluster cluster){
      super(ctx);
      this.fs=fs;
      this.path=p;
      this.cluster=cluster;
    }
    @Override public void doAnAction() throws Exception {
      fs.setReplication(path,(short)1);
      waitForReplicas(1);
      fs.setReplication(path,(short)2);
      waitForReplicas(2);
    }
    private void waitForReplicas(    final int replicas) throws Exception {
      try {
        GenericTestUtils.waitFor(new Supplier<Boolean>(){
          @Override public Boolean get(){
            try {
              cluster.waitActive();
              BlockLocation[] blocks=fs.getFileBlockLocations(path,0,10);
              Assert.assertEquals(1,blocks.length);
              return blocks[0].getHosts().length == replicas;
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
          }
        }
,100,60000);
      }
 catch (      TimeoutException te) {
        throw new IOException("Timed out waiting for " + replicas + " replicas on path "+ path);
      }
    }
    @Override public String toString(){
      return "Toggler for " + path;
    }
  }
  @Test public void testFencingStress() throws Exception {
    HAStressTestHarness harness=new HAStressTestHarness();
    harness.setNumberOfNameNodes(3);
    harness.conf.setInt(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,1000);
    harness.conf.setInt(DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1);
    harness.conf.setInt(DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,1);
    final MiniDFSCluster cluster=harness.startCluster();
    try {
      cluster.waitActive();
      cluster.transitionToActive(0);
      FileSystem fs=harness.getFailoverFs();
      TestContext togglers=new TestContext();
      for (int i=0; i < NUM_THREADS; i++) {
        Path p=new Path("/test-" + i);
        DFSTestUtil.createFile(fs,p,BLOCK_SIZE * 10,(short)3,(long)i);
        togglers.addThread(new ReplicationToggler(togglers,fs,p,cluster));
      }
      harness.addReplicationTriggerThread(500);
      harness.addFailoverThread(5000);
      harness.startThreads();
      togglers.startThreads();
      togglers.waitFor(RUNTIME);
      togglers.stop();
      harness.stopThreads();
      for (int i=0; i < NUM_THREADS; i++) {
        Path p=new Path("/test-" + i);
        DFSTestUtil.readFile(fs,p);
      }
    }
  finally {
      System.err.println("===========================\n\n\n\n");
      harness.shutdown();
    }
  }
}
