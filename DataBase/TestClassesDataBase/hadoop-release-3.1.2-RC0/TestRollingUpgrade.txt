/** 
 * This class tests rolling upgrade.
 */
public class TestRollingUpgrade {
  private static final Log LOG=LogFactory.getLog(TestRollingUpgrade.class);
  public static void runCmd(  DFSAdmin dfsadmin,  boolean success,  String... args) throws Exception {
    if (success) {
      assertEquals(0,dfsadmin.run(args));
    }
 else {
      Assert.assertTrue(dfsadmin.run(args) != 0);
    }
  }
  /** 
 * Test DFSAdmin Upgrade Command.
 */
  @Test public void testDFSAdminRollingUpgradeCommands() throws Exception {
    final Configuration conf=new HdfsConfiguration();
    MiniDFSCluster cluster=null;
    try {
      cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
      cluster.waitActive();
      final Path foo=new Path("/foo");
      final Path bar=new Path("/bar");
      final Path baz=new Path("/baz");
{
        final DistributedFileSystem dfs=cluster.getFileSystem();
        final DFSAdmin dfsadmin=new DFSAdmin(conf);
        dfs.mkdirs(foo);
        runCmd(dfsadmin,false,"-rollingUpgrade","abc");
        checkMxBeanIsNull();
        runCmd(dfsadmin,true,"-rollingUpgrade");
        dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
        runCmd(dfsadmin,true,"-rollingUpgrade","prepare");
        dfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
        runCmd(dfsadmin,true,"-rollingUpgrade","query");
        checkMxBean();
        dfs.mkdirs(bar);
        runCmd(dfsadmin,true,"-rollingUpgrade","finalize");
        assertNull(dfs.rollingUpgrade(RollingUpgradeAction.QUERY));
        checkMxBeanIsNull();
        dfs.mkdirs(baz);
        runCmd(dfsadmin,true,"-rollingUpgrade");
        Assert.assertTrue(dfs.exists(foo));
        Assert.assertTrue(dfs.exists(bar));
        Assert.assertTrue(dfs.exists(baz));
        dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
        dfs.saveNamespace();
        dfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
      }
      cluster.restartNameNode();
{
        final DistributedFileSystem dfs=cluster.getFileSystem();
        Assert.assertTrue(dfs.exists(foo));
        Assert.assertTrue(dfs.exists(bar));
        Assert.assertTrue(dfs.exists(baz));
      }
    }
  finally {
      if (cluster != null)       cluster.shutdown();
    }
  }
  private static Configuration setConf(  Configuration conf,  File dir,  MiniJournalCluster mjc){
    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,dir.getAbsolutePath());
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,mjc.getQuorumJournalURI("myjournal").toString());
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_TXNS_KEY,0L);
    return conf;
  }
  @Test(timeout=30000) public void testRollingUpgradeWithQJM() throws Exception {
    String nnDirPrefix=MiniDFSCluster.getBaseDirectory() + "/nn/";
    final File nn1Dir=new File(nnDirPrefix + "image1");
    final File nn2Dir=new File(nnDirPrefix + "image2");
    LOG.info("nn1Dir=" + nn1Dir);
    LOG.info("nn2Dir=" + nn2Dir);
    final Configuration conf=new HdfsConfiguration();
    final MiniJournalCluster mjc=new MiniJournalCluster.Builder(conf).build();
    mjc.waitActive();
    setConf(conf,nn1Dir,mjc);
{
      final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).manageNameDfsDirs(false).checkExitOnShutdown(false).build();
      cluster.shutdown();
    }
    MiniDFSCluster cluster2=null;
    try {
      FileUtil.fullyDelete(nn2Dir);
      FileUtil.copy(nn1Dir,FileSystem.getLocal(conf).getRaw(),new Path(nn2Dir.getAbsolutePath()),false,conf);
      final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(false).manageNameDfsDirs(false).checkExitOnShutdown(false).build();
      final Path foo=new Path("/foo");
      final Path bar=new Path("/bar");
      final Path baz=new Path("/baz");
      final RollingUpgradeInfo info1;
{
        final DistributedFileSystem dfs=cluster.getFileSystem();
        dfs.mkdirs(foo);
        dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
        info1=dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
        dfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
        LOG.info("START\n" + info1);
        assertEquals(info1,dfs.rollingUpgrade(RollingUpgradeAction.QUERY));
        dfs.mkdirs(bar);
        cluster.shutdown();
      }
      final Configuration conf2=setConf(new Configuration(),nn2Dir,mjc);
      cluster2=new MiniDFSCluster.Builder(conf2).numDataNodes(0).format(false).manageNameDfsDirs(false).build();
      final DistributedFileSystem dfs2=cluster2.getFileSystem();
      Assert.assertTrue(dfs2.exists(foo));
      Assert.assertTrue(dfs2.exists(bar));
      Assert.assertFalse(dfs2.exists(baz));
      assertEquals(info1,dfs2.rollingUpgrade(RollingUpgradeAction.QUERY));
      dfs2.mkdirs(baz);
      LOG.info("RESTART cluster 2");
      cluster2.restartNameNode();
      assertEquals(info1,dfs2.rollingUpgrade(RollingUpgradeAction.QUERY));
      Assert.assertTrue(dfs2.exists(foo));
      Assert.assertTrue(dfs2.exists(bar));
      Assert.assertTrue(dfs2.exists(baz));
      try {
        cluster2.restartNameNode("-upgrade");
      }
 catch (      IOException e) {
        LOG.info("The exception is expected.",e);
      }
      LOG.info("RESTART cluster 2 again");
      cluster2.restartNameNode();
      assertEquals(info1,dfs2.rollingUpgrade(RollingUpgradeAction.QUERY));
      Assert.assertTrue(dfs2.exists(foo));
      Assert.assertTrue(dfs2.exists(bar));
      Assert.assertTrue(dfs2.exists(baz));
      final RollingUpgradeInfo finalize=dfs2.rollingUpgrade(RollingUpgradeAction.FINALIZE);
      Assert.assertTrue(finalize.isFinalized());
      LOG.info("RESTART cluster 2 with regular startup option");
      cluster2.getNameNodeInfos()[0].setStartOpt(StartupOption.REGULAR);
      cluster2.restartNameNode();
      Assert.assertTrue(dfs2.exists(foo));
      Assert.assertTrue(dfs2.exists(bar));
      Assert.assertTrue(dfs2.exists(baz));
    }
  finally {
      if (cluster2 != null)       cluster2.shutdown();
    }
  }
  private static CompositeDataSupport getBean() throws MalformedObjectNameException, MBeanException, AttributeNotFoundException, InstanceNotFoundException, ReflectionException {
    MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
    ObjectName mxbeanName=new ObjectName("Hadoop:service=NameNode,name=NameNodeInfo");
    return (CompositeDataSupport)mbs.getAttribute(mxbeanName,"RollingUpgradeStatus");
  }
  private static void checkMxBeanIsNull() throws Exception {
    CompositeDataSupport ruBean=getBean();
    assertNull(ruBean);
  }
  private static void checkMxBean() throws Exception {
    CompositeDataSupport ruBean=getBean();
    assertNotEquals(0l,ruBean.get("startTime"));
    assertEquals(0l,ruBean.get("finalizeTime"));
  }
  @Test public void testRollback() throws Exception {
    final Configuration conf=new HdfsConfiguration();
    MiniDFSCluster cluster=null;
    try {
      cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
      cluster.waitActive();
      final Path foo=new Path("/foo");
      final Path bar=new Path("/bar");
      cluster.getFileSystem().mkdirs(foo);
      final Path file=new Path(foo,"file");
      final byte[] data=new byte[1024];
      ThreadLocalRandom.current().nextBytes(data);
      final FSDataOutputStream out=cluster.getFileSystem().create(file);
      out.write(data,0,data.length);
      out.close();
      checkMxBeanIsNull();
      startRollingUpgrade(foo,bar,file,data,cluster);
      checkMxBean();
      cluster.getFileSystem().rollEdits();
      cluster.getFileSystem().rollEdits();
      rollbackRollingUpgrade(foo,bar,file,data,cluster);
      checkMxBeanIsNull();
      startRollingUpgrade(foo,bar,file,data,cluster);
      cluster.getFileSystem().rollEdits();
      cluster.getFileSystem().rollEdits();
      rollbackRollingUpgrade(foo,bar,file,data,cluster);
      startRollingUpgrade(foo,bar,file,data,cluster);
      cluster.restartNameNode();
      rollbackRollingUpgrade(foo,bar,file,data,cluster);
      startRollingUpgrade(foo,bar,file,data,cluster);
      cluster.restartNameNode();
      rollbackRollingUpgrade(foo,bar,file,data,cluster);
      startRollingUpgrade(foo,bar,file,data,cluster);
      rollbackRollingUpgrade(foo,bar,file,data,cluster);
      startRollingUpgrade(foo,bar,file,data,cluster);
      rollbackRollingUpgrade(foo,bar,file,data,cluster);
    }
  finally {
      if (cluster != null)       cluster.shutdown();
    }
  }
  private static void startRollingUpgrade(  Path foo,  Path bar,  Path file,  byte[] data,  MiniDFSCluster cluster) throws IOException {
    final DistributedFileSystem dfs=cluster.getFileSystem();
    dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
    dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
    dfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
    dfs.mkdirs(bar);
    Assert.assertTrue(dfs.exists(foo));
    Assert.assertTrue(dfs.exists(bar));
    final int newLength=ThreadLocalRandom.current().nextInt(data.length - 1) + 1;
    dfs.truncate(file,newLength);
    TestFileTruncate.checkBlockRecovery(file,dfs);
    AppendTestUtil.checkFullFile(dfs,file,newLength,data);
  }
  private static void rollbackRollingUpgrade(  Path foo,  Path bar,  Path file,  byte[] data,  MiniDFSCluster cluster) throws IOException {
    final DataNodeProperties dnprop=cluster.stopDataNode(0);
    cluster.restartNameNode("-rollingUpgrade","rollback");
    cluster.restartDataNode(dnprop,true);
    final DistributedFileSystem dfs=cluster.getFileSystem();
    Assert.assertTrue(dfs.exists(foo));
    Assert.assertFalse(dfs.exists(bar));
    AppendTestUtil.checkFullFile(dfs,file,data.length,data);
  }
  @Test public void testDFSAdminDatanodeUpgradeControlCommands() throws Exception {
    final Configuration conf=new HdfsConfiguration();
    MiniDFSCluster cluster=null;
    try {
      cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
      cluster.waitActive();
      final DFSAdmin dfsadmin=new DFSAdmin(conf);
      DataNode dn=cluster.getDataNodes().get(0);
      final String dnAddr=dn.getDatanodeId().getIpcAddr(false);
      final String[] args1={"-getDatanodeInfo",dnAddr};
      runCmd(dfsadmin,true,args1);
      final String[] args2={"-shutdownDatanode",dnAddr,"upgrade"};
      runCmd(dfsadmin,true,args2);
      GenericTestUtils.waitForThreadTermination("Async datanode shutdown thread",100,10000);
      Assert.assertFalse("DataNode should exit",dn.isDatanodeUp());
      assertEquals(-1,dfsadmin.run(args1));
    }
  finally {
      if (cluster != null)       cluster.shutdown();
    }
  }
  @Test(timeout=300000) public void testFinalize() throws Exception {
    testFinalize(2);
  }
  @Test(timeout=300000) public void testFinalizeWithMultipleNN() throws Exception {
    testFinalize(3);
  }
  private void testFinalize(  int nnCount) throws Exception {
    final Configuration conf=new HdfsConfiguration();
    MiniQJMHACluster cluster=null;
    final Path foo=new Path("/foo");
    final Path bar=new Path("/bar");
    try {
      cluster=new MiniQJMHACluster.Builder(conf).setNumNameNodes(nnCount).build();
      MiniDFSCluster dfsCluster=cluster.getDfsCluster();
      dfsCluster.waitActive();
      for (int i=1; i < nnCount; i++) {
        dfsCluster.getConfiguration(i).setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
      }
      dfsCluster.restartNameNodes();
      dfsCluster.transitionToActive(0);
      DistributedFileSystem dfs=dfsCluster.getFileSystem(0);
      dfs.mkdirs(foo);
      FSImage fsimage=dfsCluster.getNamesystem(0).getFSImage();
      RollingUpgradeInfo info=dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      Assert.assertTrue(info.isStarted());
      dfs.mkdirs(bar);
      queryForPreparation(dfs);
      Assert.assertTrue(fsimage.hasRollbackFSImage());
      info=dfs.rollingUpgrade(RollingUpgradeAction.FINALIZE);
      Assert.assertTrue(info.isFinalized());
      Assert.assertTrue(dfs.exists(foo));
      Assert.assertFalse(fsimage.hasRollbackFSImage());
      dfsCluster.restartNameNode(0);
    }
  finally {
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
  @Test(timeout=300000) public void testQuery() throws Exception {
    testQuery(2);
  }
  @Test(timeout=300000) public void testQueryWithMultipleNN() throws Exception {
    testQuery(3);
  }
  private void testQuery(  int nnCount) throws Exception {
    final Configuration conf=new Configuration();
    MiniQJMHACluster cluster=null;
    try {
      cluster=new MiniQJMHACluster.Builder(conf).setNumNameNodes(nnCount).build();
      MiniDFSCluster dfsCluster=cluster.getDfsCluster();
      dfsCluster.waitActive();
      dfsCluster.transitionToActive(0);
      DistributedFileSystem dfs=dfsCluster.getFileSystem(0);
      for (int i=1; i < nnCount; i++) {
        dfsCluster.shutdownNameNode(i);
      }
      RollingUpgradeInfo info=dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      Assert.assertTrue(info.isStarted());
      info=dfs.rollingUpgrade(RollingUpgradeAction.QUERY);
      Assert.assertFalse(info.createdRollbackImages());
      for (int i=1; i < nnCount; i++) {
        dfsCluster.restartNameNode(i);
      }
      queryForPreparation(dfs);
      Assert.assertTrue(dfsCluster.getNamesystem(0).getFSImage().hasRollbackFSImage());
    }
  finally {
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
  @Test(timeout=300000) public void testQueryAfterRestart() throws IOException, InterruptedException {
    final Configuration conf=new Configuration();
    MiniDFSCluster cluster=null;
    try {
      cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
      cluster.waitActive();
      DistributedFileSystem dfs=cluster.getFileSystem();
      dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
      dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      queryForPreparation(dfs);
      dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
      dfs.saveNamespace();
      dfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
      cluster.restartNameNodes();
      dfs.rollingUpgrade(RollingUpgradeAction.QUERY);
    }
  finally {
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
  @Test(timeout=300000) public void testCheckpoint() throws IOException, InterruptedException {
    testCheckpoint(2);
  }
  @Test(timeout=300000) public void testCheckpointWithMultipleNN() throws IOException, InterruptedException {
    testCheckpoint(3);
  }
  @Test(timeout=60000) public void testRollBackImage() throws Exception {
    final Configuration conf=new Configuration();
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_TXNS_KEY,10);
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_CHECK_PERIOD_KEY,2);
    MiniQJMHACluster cluster=null;
    CheckpointFaultInjector old=CheckpointFaultInjector.getInstance();
    try {
      cluster=new MiniQJMHACluster.Builder(conf).setNumNameNodes(2).build();
      MiniDFSCluster dfsCluster=cluster.getDfsCluster();
      dfsCluster.waitActive();
      dfsCluster.transitionToActive(0);
      DistributedFileSystem dfs=dfsCluster.getFileSystem(0);
      for (int i=0; i <= 10; i++) {
        Path foo=new Path("/foo" + i);
        dfs.mkdirs(foo);
      }
      cluster.getDfsCluster().getNameNodeRpc(0).rollEdits();
      CountDownLatch ruEdit=new CountDownLatch(1);
      CheckpointFaultInjector.set(new CheckpointFaultInjector(){
        @Override public void duringUploadInProgess() throws IOException, InterruptedException {
          if (ruEdit.getCount() == 1) {
            ruEdit.countDown();
            Thread.sleep(180000);
          }
        }
      }
);
      ruEdit.await();
      RollingUpgradeInfo info=dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      Assert.assertTrue(info.isStarted());
      FSImage fsimage=dfsCluster.getNamesystem(0).getFSImage();
      queryForPreparation(dfs);
      Assert.assertTrue(fsimage.hasRollbackFSImage());
    }
  finally {
      CheckpointFaultInjector.set(old);
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
  public void testCheckpoint(  int nnCount) throws IOException, InterruptedException {
    final Configuration conf=new Configuration();
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,1);
    MiniQJMHACluster cluster=null;
    final Path foo=new Path("/foo");
    try {
      cluster=new MiniQJMHACluster.Builder(conf).setNumNameNodes(nnCount).build();
      MiniDFSCluster dfsCluster=cluster.getDfsCluster();
      dfsCluster.waitActive();
      dfsCluster.transitionToActive(0);
      DistributedFileSystem dfs=dfsCluster.getFileSystem(0);
      RollingUpgradeInfo info=dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      Assert.assertTrue(info.isStarted());
      queryForPreparation(dfs);
      dfs.mkdirs(foo);
      long txid=dfs.rollEdits();
      Assert.assertTrue(txid > 0);
      for (int i=1; i < nnCount; i++) {
        verifyNNCheckpoint(dfsCluster,txid,i);
      }
    }
  finally {
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
  /** 
 * Verify that the namenode at the given index has an FSImage with a TxId up to txid-1
 */
  private void verifyNNCheckpoint(  MiniDFSCluster dfsCluster,  long txid,  int nnIndex) throws InterruptedException {
    int retries=0;
    while (++retries < 5) {
      NNStorage storage=dfsCluster.getNamesystem(nnIndex).getFSImage().getStorage();
      if (storage.getFsImageName(txid - 1) != null) {
        return;
      }
      Thread.sleep(1000);
    }
    Assert.fail("new checkpoint does not exist");
  }
  static void queryForPreparation(  DistributedFileSystem dfs) throws IOException, InterruptedException {
    RollingUpgradeInfo info;
    int retries=0;
    while (++retries < 10) {
      info=dfs.rollingUpgrade(RollingUpgradeAction.QUERY);
      if (info.createdRollbackImages()) {
        break;
      }
      Thread.sleep(1000);
    }
    if (retries >= 10) {
      Assert.fail("Query return false");
    }
  }
  /** 
 * In non-HA setup, after rolling upgrade prepare, the Secondary NN should still be able to do checkpoint
 */
  @Test public void testCheckpointWithSNN() throws Exception {
    MiniDFSCluster cluster=null;
    DistributedFileSystem dfs=null;
    SecondaryNameNode snn=null;
    try {
      Configuration conf=new HdfsConfiguration();
      cluster=new MiniDFSCluster.Builder(conf).build();
      cluster.waitActive();
      conf.set(DFSConfigKeys.DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY,"0.0.0.0:0");
      snn=new SecondaryNameNode(conf);
      dfs=cluster.getFileSystem();
      dfs.mkdirs(new Path("/test/foo"));
      snn.doCheckpoint();
      dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
      dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      dfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
      dfs.mkdirs(new Path("/test/bar"));
      snn.doCheckpoint();
    }
  finally {
      IOUtils.cleanup(null,dfs);
      if (snn != null) {
        snn.shutdown();
      }
      if (cluster != null) {
        cluster.shutdown();
      }
    }
  }
}
