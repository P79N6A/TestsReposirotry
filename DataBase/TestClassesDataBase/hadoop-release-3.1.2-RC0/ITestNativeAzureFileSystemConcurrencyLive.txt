/** 
 * Test class to hold all Live Azure storage concurrency tests.
 */
public class ITestNativeAzureFileSystemConcurrencyLive extends AbstractWasbTestBase {
  private static final int THREAD_COUNT=102;
  private static final int TEST_EXECUTION_TIMEOUT=30000;
  @Override protected AzureBlobStorageTestAccount createTestAccount() throws Exception {
    return AzureBlobStorageTestAccount.create();
  }
  /** 
 * Validate contract for FileSystem.create when overwrite is true and there are concurrent callers of FileSystem.delete.  An existing file should be overwritten, even if the original destination exists but is deleted by an external agent during the create operation.
 */
  @Test(timeout=TEST_EXECUTION_TIMEOUT) public void testConcurrentCreateDeleteFile() throws Exception {
    Path testFile=methodPath();
    List<CreateFileTask> tasks=new ArrayList<>(THREAD_COUNT);
    for (int i=0; i < THREAD_COUNT; i++) {
      tasks.add(new CreateFileTask(fs,testFile));
    }
    ExecutorService es=null;
    try {
      es=Executors.newFixedThreadPool(THREAD_COUNT);
      List<Future<Void>> futures=es.invokeAll(tasks);
      for (      Future<Void> future : futures) {
        Assert.assertTrue(future.isDone());
        Assert.assertEquals(null,future.get());
      }
    }
  finally {
      if (es != null) {
        es.shutdownNow();
      }
    }
  }
  /** 
 * Validate contract for FileSystem.delete when invoked concurrently. One of the threads should successfully delete the file and return true; all other threads should return false.
 */
  @Test(timeout=TEST_EXECUTION_TIMEOUT) public void testConcurrentDeleteFile() throws Exception {
    Path testFile=new Path("test.dat");
    fs.create(testFile).close();
    List<DeleteFileTask> tasks=new ArrayList<>(THREAD_COUNT);
    for (int i=0; i < THREAD_COUNT; i++) {
      tasks.add(new DeleteFileTask(fs,testFile));
    }
    ExecutorService es=null;
    try {
      es=Executors.newFixedThreadPool(THREAD_COUNT);
      List<Future<Boolean>> futures=es.invokeAll(tasks);
      int successCount=0;
      for (      Future<Boolean> future : futures) {
        Assert.assertTrue(future.isDone());
        Boolean success=future.get();
        if (success) {
          successCount++;
        }
      }
      Assert.assertEquals("Exactly one delete operation should return true.",1,successCount);
    }
  finally {
      if (es != null) {
        es.shutdownNow();
      }
    }
  }
abstract class FileSystemTask<V> implements Callable<V> {
    private final FileSystem fileSystem;
    private final Path path;
    protected FileSystem getFileSystem(){
      return this.fileSystem;
    }
    protected Path getFilePath(){
      return this.path;
    }
    FileSystemTask(    FileSystem fs,    Path p){
      this.fileSystem=fs;
      this.path=p;
    }
    public abstract V call() throws Exception ;
  }
class DeleteFileTask extends FileSystemTask<Boolean> {
    DeleteFileTask(    FileSystem fs,    Path p){
      super(fs,p);
    }
    @Override public Boolean call() throws Exception {
      return this.getFileSystem().delete(this.getFilePath(),false);
    }
  }
class CreateFileTask extends FileSystemTask<Void> {
    CreateFileTask(    FileSystem fs,    Path p){
      super(fs,p);
    }
    public Void call() throws Exception {
      FileSystem fs=getFileSystem();
      Path p=getFilePath();
      FSDataOutputStream stream=fs.create(p,true);
      stream.close();
      this.getFileSystem().delete(this.getFilePath(),false);
      return null;
    }
  }
}
