/** 
 * This class is a base test for  {@code SharingPolicy} implementors.
 */
@RunWith(value=Parameterized.class) @NotThreadSafe @SuppressWarnings("VisibilityModifier") public abstract class BaseSharingPolicyTest {
  @Parameterized.Parameter(value=0) public long duration;
  @Parameterized.Parameter(value=1) public double height;
  @Parameterized.Parameter(value=2) public int numSubmissions;
  @Parameterized.Parameter(value=3) public String recurrenceExpression;
  @Parameterized.Parameter(value=4) public Class expectedError;
  private long step;
  private long initTime;
  private InMemoryPlan plan;
  private ReservationAgent mAgent;
  private Resource minAlloc;
  private ResourceCalculator res;
  private Resource maxAlloc;
  private int totCont=1000;
  protected ReservationSchedulerConfiguration conf;
  @Before public void setup(){
    step=1000L;
    initTime=System.currentTimeMillis();
    minAlloc=Resource.newInstance(1024,1);
    res=new DefaultResourceCalculator();
    maxAlloc=Resource.newInstance(1024 * 8,8);
    mAgent=mock(ReservationAgent.class);
    QueueMetrics rootQueueMetrics=mock(QueueMetrics.class);
    Resource clusterResource=ReservationSystemTestUtil.calculateClusterResource(totCont);
    SharingPolicy policy=getInitializedPolicy();
    RMContext context=ReservationSystemTestUtil.createMockRMContext();
    plan=new InMemoryPlan(rootQueueMetrics,policy,mAgent,clusterResource,step,res,minAlloc,maxAlloc,"dedicated",null,true,context);
  }
  public void runTest() throws IOException, PlanningException {
    long period=1;
    if (recurrenceExpression != null) {
      period=Long.parseLong(recurrenceExpression);
    }
    try {
      RLESparseResourceAllocation rle=generateRLEAlloc(period);
      Map<ReservationInterval,Resource> reservationIntervalResourceMap;
      if (period > 1) {
        rle=new PeriodicRLESparseResourceAllocation(rle,period);
        reservationIntervalResourceMap=ReservationSystemTestUtil.toAllocation(rle,0,period);
      }
 else {
        reservationIntervalResourceMap=ReservationSystemTestUtil.toAllocation(rle,Long.MIN_VALUE,Long.MAX_VALUE);
      }
      ReservationDefinition rDef=ReservationSystemTestUtil.createSimpleReservationDefinition(initTime % period,initTime % period + duration + 1,duration,1,recurrenceExpression);
      for (int i=0; i < numSubmissions; i++) {
        long rstart=rle.getEarliestStartTime();
        long rend=rle.getLatestNonNullTime();
        InMemoryReservationAllocation resAlloc=new InMemoryReservationAllocation(ReservationSystemTestUtil.getNewReservationId(),rDef,"u1","dedicated",rstart,rend,reservationIntervalResourceMap,res,minAlloc);
        assertTrue(plan.toString(),plan.addReservation(resAlloc,false));
      }
      if (expectedError != null) {
        System.out.println(plan.toString());
        fail();
      }
    }
 catch (    Exception e) {
      if (expectedError == null || !e.getClass().getCanonicalName().equals(expectedError.getCanonicalName())) {
        throw e;
      }
    }
  }
  private RLESparseResourceAllocation generateRLEAlloc(  long period){
    RLESparseResourceAllocation rle=new RLESparseResourceAllocation(new DefaultResourceCalculator());
    Resource alloc=Resources.multiply(minAlloc,height * totCont);
    long rStart=initTime % period;
    long rEnd=initTime % period + duration;
    if (period > 1 && rEnd > period) {
      long diff=rEnd - period;
      rEnd=period;
      if (duration > period) {
        rle.addInterval(new ReservationInterval(0,period),Resources.multiply(alloc,duration / period - 1));
        rle.addInterval(new ReservationInterval(0,diff % period),alloc);
      }
 else {
        rle.addInterval(new ReservationInterval(0,diff),alloc);
      }
    }
    if (rStart > rEnd) {
      rle.addInterval(new ReservationInterval(rStart,period),alloc);
      rle.addInterval(new ReservationInterval(0,rEnd),alloc);
    }
 else {
      rle.addInterval(new ReservationInterval(rStart,rEnd),alloc);
    }
    return rle;
  }
  public abstract SharingPolicy getInitializedPolicy();
}
