public class TestJHSSecurity {
  private static final Logger LOG=LoggerFactory.getLogger(TestJHSSecurity.class);
  @Test public void testDelegationToken() throws IOException, InterruptedException {
    org.apache.log4j.Logger rootLogger=LogManager.getRootLogger();
    rootLogger.setLevel(Level.DEBUG);
    final YarnConfiguration conf=new YarnConfiguration(new JobConf());
    conf.set(JHAdminConfig.MR_HISTORY_PRINCIPAL,"RandomOrc/localhost@apache.org");
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
    UserGroupInformation.setConfiguration(conf);
    final long initialInterval=10000l;
    final long maxLifetime=20000l;
    final long renewInterval=10000l;
    JobHistoryServer jobHistoryServer=null;
    MRClientProtocol clientUsingDT=null;
    long tokenFetchTime;
    try {
      jobHistoryServer=new JobHistoryServer(){
        protected void doSecureLogin(        Configuration conf) throws IOException {
        }
        @Override protected JHSDelegationTokenSecretManager createJHSSecretManager(        Configuration conf,        HistoryServerStateStoreService store){
          return new JHSDelegationTokenSecretManager(initialInterval,maxLifetime,renewInterval,3600000,store);
        }
        @Override protected HistoryClientService createHistoryClientService(){
          return new HistoryClientService(historyContext,this.jhsDTSecretManager){
            @Override protected void initializeWebApp(            Configuration conf){
            }
          }
;
        }
      }
;
      jobHistoryServer.init(conf);
      jobHistoryServer.start();
      final MRClientProtocol hsService=jobHistoryServer.getClientService().getClientHandler();
      UserGroupInformation loggedInUser=UserGroupInformation.createRemoteUser("testrenewer@APACHE.ORG");
      Assert.assertEquals("testrenewer",loggedInUser.getShortUserName());
      loggedInUser.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
      Token token=getDelegationToken(loggedInUser,hsService,loggedInUser.getShortUserName());
      tokenFetchTime=System.currentTimeMillis();
      LOG.info("Got delegation token at: " + tokenFetchTime);
      clientUsingDT=getMRClientProtocol(token,jobHistoryServer.getClientService().getBindAddress(),"TheDarkLord",conf);
      GetJobReportRequest jobReportRequest=Records.newRecord(GetJobReportRequest.class);
      jobReportRequest.setJobId(MRBuilderUtils.newJobId(123456,1,1));
      try {
        clientUsingDT.getJobReport(jobReportRequest);
      }
 catch (      IOException e) {
        Assert.assertEquals("Unknown job job_123456_0001",e.getMessage());
      }
      while (System.currentTimeMillis() < tokenFetchTime + initialInterval / 2) {
        Thread.sleep(500l);
      }
      long nextExpTime=renewDelegationToken(loggedInUser,hsService,token);
      long renewalTime=System.currentTimeMillis();
      LOG.info("Renewed token at: " + renewalTime + ", NextExpiryTime: "+ nextExpTime);
      while (System.currentTimeMillis() > tokenFetchTime + initialInterval && System.currentTimeMillis() < nextExpTime) {
        Thread.sleep(500l);
      }
      Thread.sleep(50l);
      try {
        clientUsingDT.getJobReport(jobReportRequest);
      }
 catch (      IOException e) {
        Assert.assertEquals("Unknown job job_123456_0001",e.getMessage());
      }
      while (System.currentTimeMillis() < renewalTime + renewInterval) {
        Thread.sleep(500l);
      }
      Thread.sleep(50l);
      LOG.info("At time: " + System.currentTimeMillis() + ", token should be invalid");
      try {
        clientUsingDT.getJobReport(jobReportRequest);
        fail("Should not have succeeded with an expired token");
      }
 catch (      IOException e) {
        assertTrue(e.getCause().getMessage().contains("is expired"));
      }
      if (clientUsingDT != null) {
        clientUsingDT=null;
      }
      token=getDelegationToken(loggedInUser,hsService,loggedInUser.getShortUserName());
      tokenFetchTime=System.currentTimeMillis();
      LOG.info("Got delegation token at: " + tokenFetchTime);
      clientUsingDT=getMRClientProtocol(token,jobHistoryServer.getClientService().getBindAddress(),"loginuser2",conf);
      try {
        clientUsingDT.getJobReport(jobReportRequest);
      }
 catch (      IOException e) {
        fail("Unexpected exception" + e);
      }
      cancelDelegationToken(loggedInUser,hsService,token);
      Token tokenWithDifferentRenewer=getDelegationToken(loggedInUser,hsService,"yarn");
      cancelDelegationToken(loggedInUser,hsService,tokenWithDifferentRenewer);
      if (clientUsingDT != null) {
        clientUsingDT=null;
      }
      clientUsingDT=getMRClientProtocol(token,jobHistoryServer.getClientService().getBindAddress(),"loginuser2",conf);
      LOG.info("Cancelled delegation token at: " + System.currentTimeMillis());
      try {
        clientUsingDT.getJobReport(jobReportRequest);
        fail("Should not have succeeded with a cancelled delegation token");
      }
 catch (      IOException e) {
      }
    }
  finally {
      jobHistoryServer.stop();
    }
  }
  private Token getDelegationToken(  final UserGroupInformation loggedInUser,  final MRClientProtocol hsService,  final String renewerString) throws IOException, InterruptedException {
    Token token=loggedInUser.doAs(new PrivilegedExceptionAction<Token>(){
      @Override public Token run() throws IOException {
        GetDelegationTokenRequest request=Records.newRecord(GetDelegationTokenRequest.class);
        request.setRenewer(renewerString);
        return hsService.getDelegationToken(request).getDelegationToken();
      }
    }
);
    return token;
  }
  private long renewDelegationToken(  final UserGroupInformation loggedInUser,  final MRClientProtocol hsService,  final Token dToken) throws IOException, InterruptedException {
    long nextExpTime=loggedInUser.doAs(new PrivilegedExceptionAction<Long>(){
      @Override public Long run() throws IOException {
        RenewDelegationTokenRequest request=Records.newRecord(RenewDelegationTokenRequest.class);
        request.setDelegationToken(dToken);
        return hsService.renewDelegationToken(request).getNextExpirationTime();
      }
    }
);
    return nextExpTime;
  }
  private void cancelDelegationToken(  final UserGroupInformation loggedInUser,  final MRClientProtocol hsService,  final Token dToken) throws IOException, InterruptedException {
    loggedInUser.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws IOException {
        CancelDelegationTokenRequest request=Records.newRecord(CancelDelegationTokenRequest.class);
        request.setDelegationToken(dToken);
        hsService.cancelDelegationToken(request);
        return null;
      }
    }
);
  }
  private MRClientProtocol getMRClientProtocol(  Token token,  final InetSocketAddress hsAddress,  String user,  final Configuration conf){
    UserGroupInformation ugi=UserGroupInformation.createRemoteUser(user);
    ugi.addToken(ConverterUtils.convertFromYarn(token,hsAddress));
    final YarnRPC rpc=YarnRPC.create(conf);
    MRClientProtocol hsWithDT=ugi.doAs(new PrivilegedAction<MRClientProtocol>(){
      @Override public MRClientProtocol run(){
        return (MRClientProtocol)rpc.getProxy(HSClientProtocol.class,hsAddress,conf);
      }
    }
);
    return hsWithDT;
  }
}
