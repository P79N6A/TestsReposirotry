/** 
 * Test Base for TimelineReaderServer HBase tests.
 */
public abstract class AbstractTimelineReaderHBaseTestBase {
  private static int serverPort;
  private static TimelineReaderServer server;
  private static HBaseTestingUtility util;
  public static void setup() throws Exception {
    util=new HBaseTestingUtility();
    Configuration conf=util.getConfiguration();
    conf.setInt("hfile.format.version",3);
    util.startMiniCluster();
    DataGeneratorForTest.createSchema(util.getConfiguration());
  }
  public static void tearDown() throws Exception {
    if (server != null) {
      server.stop();
      server=null;
    }
    if (util != null) {
      util.shutdownMiniCluster();
    }
  }
  protected static void initialize() throws Exception {
    try {
      Configuration config=util.getConfiguration();
      config.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,true);
      config.setFloat(YarnConfiguration.TIMELINE_SERVICE_VERSION,2.0f);
      config.set(YarnConfiguration.TIMELINE_SERVICE_READER_WEBAPP_ADDRESS,"localhost:0");
      config.set(YarnConfiguration.RM_CLUSTER_ID,"cluster1");
      config.set(YarnConfiguration.TIMELINE_SERVICE_READER_CLASS,"org.apache.hadoop.yarn.server.timelineservice.storage." + "HBaseTimelineReaderImpl");
      config.setInt("hfile.format.version",3);
      server=new TimelineReaderServer(){
        @Override protected void addFilters(        Configuration conf){
        }
      }
;
      server.init(config);
      server.start();
      serverPort=server.getWebServerPort();
    }
 catch (    Exception e) {
      Assert.fail("Web server failed to start");
    }
  }
  protected Client createClient(){
    ClientConfig cfg=new DefaultClientConfig();
    cfg.getClasses().add(YarnJacksonJaxbJsonProvider.class);
    return new Client(new URLConnectionClientHandler(new DummyURLConnectionFactory()),cfg);
  }
  protected ClientResponse getResponse(  Client client,  URI uri) throws Exception {
    ClientResponse resp=client.resource(uri).accept(MediaType.APPLICATION_JSON).type(MediaType.APPLICATION_JSON).get(ClientResponse.class);
    if (resp == null || resp.getStatusInfo().getStatusCode() != ClientResponse.Status.OK.getStatusCode()) {
      String msg="";
      if (resp != null) {
        msg=String.valueOf(resp.getStatusInfo().getStatusCode());
      }
      throw new IOException("Incorrect response from timeline reader. " + "Status=" + msg);
    }
    return resp;
  }
  protected void verifyHttpResponse(  Client client,  URI uri,  Status status){
    ClientResponse resp=client.resource(uri).accept(MediaType.APPLICATION_JSON).type(MediaType.APPLICATION_JSON).get(ClientResponse.class);
    assertNotNull(resp);
    assertTrue("Response from server should have been " + status,resp.getStatusInfo().getStatusCode() == status.getStatusCode());
    System.out.println("Response is: " + resp.getEntity(String.class));
  }
  protected List<FlowActivityEntity> verifyFlowEntites(  Client client,  URI uri,  int noOfEntities) throws Exception {
    ClientResponse resp=getResponse(client,uri);
    List<FlowActivityEntity> entities=resp.getEntity(new GenericType<List<FlowActivityEntity>>(){
    }
);
    assertNotNull(entities);
    assertEquals(noOfEntities,entities.size());
    return entities;
  }
protected static class DummyURLConnectionFactory implements HttpURLConnectionFactory {
    @Override public HttpURLConnection getHttpURLConnection(    final URL url) throws IOException {
      try {
        return (HttpURLConnection)url.openConnection();
      }
 catch (      UndeclaredThrowableException e) {
        throw new IOException(e.getCause());
      }
    }
  }
  protected static HBaseTestingUtility getHBaseTestingUtility(){
    return util;
  }
  public static int getServerPort(){
    return serverPort;
  }
}
