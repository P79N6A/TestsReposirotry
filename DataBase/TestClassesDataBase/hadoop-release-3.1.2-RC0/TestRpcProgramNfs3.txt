/** 
 * Tests for  {@link RpcProgramNfs3}
 */
public class TestRpcProgramNfs3 {
  static DistributedFileSystem hdfs;
  static MiniDFSCluster cluster=null;
  static NfsConfiguration config=new NfsConfiguration();
  static HdfsAdmin dfsAdmin;
  static NameNode nn;
  static Nfs3 nfs;
  static RpcProgramNfs3 nfsd;
  static SecurityHandler securityHandler;
  static SecurityHandler securityHandlerUnpriviledged;
  static String testdir="/tmp";
  private static final String TEST_KEY="test_key";
  private static FileSystemTestHelper fsHelper;
  private static File testRootDir;
  private static final EnumSet<CreateEncryptionZoneFlag> NO_TRASH=EnumSet.of(CreateEncryptionZoneFlag.NO_TRASH);
  @BeforeClass public static void setup() throws Exception {
    String currentUser=System.getProperty("user.name");
    config.set("fs.permissions.umask-mode","u=rwx,g=,o=");
    config.set(DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(currentUser),"*");
    config.set(DefaultImpersonationProvider.getTestProvider().getProxySuperuserIpConfKey(currentUser),"*");
    fsHelper=new FileSystemTestHelper();
    String testRoot=fsHelper.getTestRootDir();
    testRootDir=new File(testRoot).getAbsoluteFile();
    final Path jksPath=new Path(testRootDir.toString(),"test.jks");
    config.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,JavaKeyStoreProvider.SCHEME_NAME + "://file" + jksPath.toUri());
    ProxyUsers.refreshSuperUserGroupsConfiguration(config);
    cluster=new MiniDFSCluster.Builder(config).numDataNodes(1).build();
    cluster.waitActive();
    hdfs=cluster.getFileSystem();
    nn=cluster.getNameNode();
    dfsAdmin=new HdfsAdmin(cluster.getURI(),config);
    config.setInt("nfs3.mountd.port",0);
    config.setInt("nfs3.server.port",0);
    config.set("dfs.nfs.exports.allowed.hosts","* rw");
    nfs=new Nfs3(config);
    nfs.startServiceInternal(false);
    nfsd=(RpcProgramNfs3)nfs.getRpcProgram();
    hdfs.getClient().setKeyProvider(nn.getNamesystem().getProvider());
    DFSTestUtil.createKey(TEST_KEY,cluster,config);
    securityHandler=Mockito.mock(SecurityHandler.class);
    Mockito.when(securityHandler.getUser()).thenReturn(currentUser);
    securityHandlerUnpriviledged=Mockito.mock(SecurityHandler.class);
    Mockito.when(securityHandlerUnpriviledged.getUser()).thenReturn("harry");
  }
  @AfterClass public static void shutdown() throws Exception {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
  @Before public void createFiles() throws IllegalArgumentException, IOException {
    hdfs.delete(new Path(testdir),true);
    hdfs.mkdirs(new Path(testdir));
    hdfs.mkdirs(new Path(testdir + "/foo"));
    DFSTestUtil.createFile(hdfs,new Path(testdir + "/bar"),0,(short)1,0);
  }
  @Test(timeout=60000) public void testGetattr() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    GETATTR3Request req=new GETATTR3Request(handle);
    req.serialize(xdr_req);
    GETATTR3Response response1=nfsd.getattr(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    GETATTR3Response response2=nfsd.getattr(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testSetattr() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    SetAttr3 symAttr=new SetAttr3(0,1,0,0,null,null,EnumSet.of(SetAttrField.UID));
    SETATTR3Request req=new SETATTR3Request(handle,symAttr,false,null);
    req.serialize(xdr_req);
    SETATTR3Response response1=nfsd.setattr(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    SETATTR3Response response2=nfsd.setattr(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testLookup() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    LOOKUP3Request lookupReq=new LOOKUP3Request(handle,"bar");
    XDR xdr_req=new XDR();
    lookupReq.serialize(xdr_req);
    LOOKUP3Response response1=nfsd.lookup(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    LOOKUP3Response response2=nfsd.lookup(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testAccess() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    ACCESS3Request req=new ACCESS3Request(handle);
    req.serialize(xdr_req);
    ACCESS3Response response1=nfsd.access(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    ACCESS3Response response2=nfsd.access(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testReadlink() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    SYMLINK3Request req=new SYMLINK3Request(handle,"fubar",new SetAttr3(),"bar");
    req.serialize(xdr_req);
    SYMLINK3Response response=nfsd.symlink(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response.getStatus());
    FileHandle handle2=response.getObjFileHandle();
    XDR xdr_req2=new XDR();
    READLINK3Request req2=new READLINK3Request(handle2);
    req2.serialize(xdr_req2);
    READLINK3Response response1=nfsd.readlink(xdr_req2.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    READLINK3Response response2=nfsd.readlink(xdr_req2.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testRead() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    READ3Request readReq=new READ3Request(handle,0,5);
    XDR xdr_req=new XDR();
    readReq.serialize(xdr_req);
    READ3Response response1=nfsd.read(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    READ3Response response2=nfsd.read(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=120000) public void testEncryptedReadWrite() throws Exception {
    final int len=8192;
    final Path zone=new Path("/zone");
    hdfs.mkdirs(zone);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    final byte[] buffer=new byte[len];
    for (int i=0; i < len; i++) {
      buffer[i]=(byte)i;
    }
    final String encFile1="/zone/myfile";
    createFileUsingNfs(encFile1,buffer);
    commit(encFile1,len);
    assertArrayEquals("encFile1 not equal",getFileContentsUsingNfs(encFile1,len),getFileContentsUsingDfs(encFile1,len));
    final String encFile2="/zone/myfile2";
    final Path encFile2Path=new Path(encFile2);
    DFSTestUtil.createFile(hdfs,encFile2Path,len,(short)1,0xFEED);
    assertArrayEquals("encFile2 not equal",getFileContentsUsingNfs(encFile2,len),getFileContentsUsingDfs(encFile2,len));
  }
  private void createFileUsingNfs(  String fileName,  byte[] buffer) throws Exception {
    DFSTestUtil.createFile(hdfs,new Path(fileName),0,(short)1,0);
    final HdfsFileStatus status=nn.getRpcServer().getFileInfo(fileName);
    final long dirId=status.getFileId();
    final int namenodeId=Nfs3Utils.getNamenodeId(config);
    final FileHandle handle=new FileHandle(dirId,namenodeId);
    final WRITE3Request writeReq=new WRITE3Request(handle,0,buffer.length,WriteStableHow.DATA_SYNC,ByteBuffer.wrap(buffer));
    final XDR xdr_req=new XDR();
    writeReq.serialize(xdr_req);
    final WRITE3Response response=nfsd.write(xdr_req.asReadOnlyWrap(),null,1,securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect response: ",null,response);
  }
  private byte[] getFileContentsUsingNfs(  String fileName,  int len) throws Exception {
    final HdfsFileStatus status=nn.getRpcServer().getFileInfo(fileName);
    final long dirId=status.getFileId();
    final int namenodeId=Nfs3Utils.getNamenodeId(config);
    final FileHandle handle=new FileHandle(dirId,namenodeId);
    final READ3Request readReq=new READ3Request(handle,0,len);
    final XDR xdr_req=new XDR();
    readReq.serialize(xdr_req);
    final READ3Response response=nfsd.read(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code: ",Nfs3Status.NFS3_OK,response.getStatus());
    assertTrue("expected full read",response.isEof());
    return response.getData().array();
  }
  private byte[] getFileContentsUsingDfs(  String fileName,  int len) throws Exception {
    final FSDataInputStream in=hdfs.open(new Path(fileName));
    final byte[] ret=new byte[len];
    in.readFully(ret);
    try {
      in.readByte();
      Assert.fail("expected end of file");
    }
 catch (    EOFException e) {
    }
    in.close();
    return ret;
  }
  private void commit(  String fileName,  int len) throws Exception {
    final HdfsFileStatus status=nn.getRpcServer().getFileInfo(fileName);
    final long dirId=status.getFileId();
    final int namenodeId=Nfs3Utils.getNamenodeId(config);
    final FileHandle handle=new FileHandle(dirId,namenodeId);
    final XDR xdr_req=new XDR();
    final COMMIT3Request req=new COMMIT3Request(handle,0,len);
    req.serialize(xdr_req);
    Channel ch=Mockito.mock(Channel.class);
    COMMIT3Response response2=nfsd.commit(xdr_req.asReadOnlyWrap(),ch,1,securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect COMMIT3Response:",null,response2);
  }
  @Test(timeout=60000) public void testWrite() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    byte[] buffer=new byte[10];
    for (int i=0; i < 10; i++) {
      buffer[i]=(byte)i;
    }
    WRITE3Request writeReq=new WRITE3Request(handle,0,10,WriteStableHow.DATA_SYNC,ByteBuffer.wrap(buffer));
    XDR xdr_req=new XDR();
    writeReq.serialize(xdr_req);
    WRITE3Response response1=nfsd.write(xdr_req.asReadOnlyWrap(),null,1,securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    WRITE3Response response2=nfsd.write(xdr_req.asReadOnlyWrap(),null,1,securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect response:",null,response2);
  }
  @Test(timeout=60000) public void testCreate() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    CREATE3Request req=new CREATE3Request(handle,"fubar",Nfs3Constant.CREATE_UNCHECKED,new SetAttr3(),0);
    req.serialize(xdr_req);
    CREATE3Response response1=nfsd.create(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    CREATE3Response response2=nfsd.create(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testMkdir() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    MKDIR3Request req=new MKDIR3Request(handle,"fubar1",new SetAttr3());
    req.serialize(xdr_req);
    MKDIR3Response response1=nfsd.mkdir(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    XDR xdr_req2=new XDR();
    MKDIR3Request req2=new MKDIR3Request(handle,"fubar2",new SetAttr3());
    req2.serialize(xdr_req2);
    MKDIR3Response response2=nfsd.mkdir(xdr_req2.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testSymlink() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    SYMLINK3Request req=new SYMLINK3Request(handle,"fubar",new SetAttr3(),"bar");
    req.serialize(xdr_req);
    SYMLINK3Response response1=nfsd.symlink(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    SYMLINK3Response response2=nfsd.symlink(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testRemove() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    REMOVE3Request req=new REMOVE3Request(handle,"bar");
    req.serialize(xdr_req);
    REMOVE3Response response1=nfsd.remove(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    REMOVE3Response response2=nfsd.remove(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testRmdir() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    RMDIR3Request req=new RMDIR3Request(handle,"foo");
    req.serialize(xdr_req);
    RMDIR3Response response1=nfsd.rmdir(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    RMDIR3Response response2=nfsd.rmdir(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testRename() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    XDR xdr_req=new XDR();
    FileHandle handle=new FileHandle(dirId,namenodeId);
    RENAME3Request req=new RENAME3Request(handle,"bar",handle,"fubar");
    req.serialize(xdr_req);
    RENAME3Response response1=nfsd.rename(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    RENAME3Response response2=nfsd.rename(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testReaddir() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    READDIR3Request req=new READDIR3Request(handle,0,0,100);
    req.serialize(xdr_req);
    READDIR3Response response1=nfsd.readdir(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    READDIR3Response response2=nfsd.readdir(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testReaddirplus() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo(testdir);
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    READDIRPLUS3Request req=new READDIRPLUS3Request(handle,0,0,3,2);
    req.serialize(xdr_req);
    READDIRPLUS3Response response1=nfsd.readdirplus(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    READDIRPLUS3Response response2=nfsd.readdirplus(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testFsstat() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    FSSTAT3Request req=new FSSTAT3Request(handle);
    req.serialize(xdr_req);
    FSSTAT3Response response1=nfsd.fsstat(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    FSSTAT3Response response2=nfsd.fsstat(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testFsinfo() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    FSINFO3Request req=new FSINFO3Request(handle);
    req.serialize(xdr_req);
    FSINFO3Response response1=nfsd.fsinfo(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    FSINFO3Response response2=nfsd.fsinfo(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testPathconf() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    PATHCONF3Request req=new PATHCONF3Request(handle);
    req.serialize(xdr_req);
    PATHCONF3Response response1=nfsd.pathconf(xdr_req.asReadOnlyWrap(),securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    PATHCONF3Response response2=nfsd.pathconf(xdr_req.asReadOnlyWrap(),securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3_OK,response2.getStatus());
  }
  @Test(timeout=60000) public void testCommit() throws Exception {
    HdfsFileStatus status=nn.getRpcServer().getFileInfo("/tmp/bar");
    long dirId=status.getFileId();
    int namenodeId=Nfs3Utils.getNamenodeId(config);
    FileHandle handle=new FileHandle(dirId,namenodeId);
    XDR xdr_req=new XDR();
    COMMIT3Request req=new COMMIT3Request(handle,0,5);
    req.serialize(xdr_req);
    Channel ch=Mockito.mock(Channel.class);
    COMMIT3Response response1=nfsd.commit(xdr_req.asReadOnlyWrap(),ch,1,securityHandlerUnpriviledged,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect return code:",Nfs3Status.NFS3ERR_ACCES,response1.getStatus());
    COMMIT3Response response2=nfsd.commit(xdr_req.asReadOnlyWrap(),ch,1,securityHandler,new InetSocketAddress("localhost",1234));
    assertEquals("Incorrect COMMIT3Response:",null,response2);
  }
  @Test(timeout=10000) public void testIdempotent(){
    Object[][] procedures={{Nfs3Constant.NFSPROC3.NULL,1},{Nfs3Constant.NFSPROC3.GETATTR,1},{Nfs3Constant.NFSPROC3.SETATTR,1},{Nfs3Constant.NFSPROC3.LOOKUP,1},{Nfs3Constant.NFSPROC3.ACCESS,1},{Nfs3Constant.NFSPROC3.READLINK,1},{Nfs3Constant.NFSPROC3.READ,1},{Nfs3Constant.NFSPROC3.WRITE,1},{Nfs3Constant.NFSPROC3.CREATE,0},{Nfs3Constant.NFSPROC3.MKDIR,0},{Nfs3Constant.NFSPROC3.SYMLINK,0},{Nfs3Constant.NFSPROC3.MKNOD,0},{Nfs3Constant.NFSPROC3.REMOVE,0},{Nfs3Constant.NFSPROC3.RMDIR,0},{Nfs3Constant.NFSPROC3.RENAME,0},{Nfs3Constant.NFSPROC3.LINK,0},{Nfs3Constant.NFSPROC3.READDIR,1},{Nfs3Constant.NFSPROC3.READDIRPLUS,1},{Nfs3Constant.NFSPROC3.FSSTAT,1},{Nfs3Constant.NFSPROC3.FSINFO,1},{Nfs3Constant.NFSPROC3.PATHCONF,1},{Nfs3Constant.NFSPROC3.COMMIT,1}};
    for (    Object[] procedure : procedures) {
      boolean idempotent=procedure[1].equals(Integer.valueOf(1));
      Nfs3Constant.NFSPROC3 proc=(Nfs3Constant.NFSPROC3)procedure[0];
      if (idempotent) {
        Assert.assertTrue(("Procedure " + proc + " should be idempotent"),proc.isIdempotent());
      }
 else {
        Assert.assertFalse(("Procedure " + proc + " should be non-idempotent"),proc.isIdempotent());
      }
    }
  }
  @Test public void testDeprecatedKeys(){
    NfsConfiguration conf=new NfsConfiguration();
    conf.setInt("nfs3.server.port",998);
    assertTrue(conf.getInt(NfsConfigKeys.DFS_NFS_SERVER_PORT_KEY,0) == 998);
    conf.setInt("nfs3.mountd.port",999);
    assertTrue(conf.getInt(NfsConfigKeys.DFS_NFS_MOUNTD_PORT_KEY,0) == 999);
    conf.set("dfs.nfs.exports.allowed.hosts","host1");
    assertTrue(conf.get(CommonConfigurationKeys.NFS_EXPORTS_ALLOWED_HOSTS_KEY).equals("host1"));
    conf.setInt("dfs.nfs.exports.cache.expirytime.millis",1000);
    assertTrue(conf.getInt(Nfs3Constant.NFS_EXPORTS_CACHE_EXPIRYTIME_MILLIS_KEY,0) == 1000);
    conf.setInt("hadoop.nfs.userupdate.milly",10);
    assertTrue(conf.getInt(IdMappingConstant.USERGROUPID_UPDATE_MILLIS_KEY,0) == 10);
    conf.set("dfs.nfs3.dump.dir","/nfs/tmp");
    assertTrue(conf.get(NfsConfigKeys.DFS_NFS_FILE_DUMP_DIR_KEY).equals("/nfs/tmp"));
    conf.setBoolean("dfs.nfs3.enableDump",false);
    assertTrue(conf.getBoolean(NfsConfigKeys.DFS_NFS_FILE_DUMP_KEY,true) == false);
    conf.setInt("dfs.nfs3.max.open.files",500);
    assertTrue(conf.getInt(NfsConfigKeys.DFS_NFS_MAX_OPEN_FILES_KEY,0) == 500);
    conf.setInt("dfs.nfs3.stream.timeout",6000);
    assertTrue(conf.getInt(NfsConfigKeys.DFS_NFS_STREAM_TIMEOUT_KEY,0) == 6000);
    conf.set("dfs.nfs3.export.point","/dir1");
    assertTrue(conf.get(NfsConfigKeys.DFS_NFS_EXPORT_POINT_KEY).equals("/dir1"));
  }
}
