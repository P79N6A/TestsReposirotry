/** 
 * The the RPC interface of the  {@link Router} implemented by{@link RouterRpcServer}.
 */
public class TestRouterRpc {
  private static final Logger LOG=LoggerFactory.getLogger(TestRouterRpc.class);
  private static final Comparator<ErasureCodingPolicyInfo> EC_POLICY_CMP=new Comparator<ErasureCodingPolicyInfo>(){
    public int compare(    ErasureCodingPolicyInfo ec0,    ErasureCodingPolicyInfo ec1){
      String name0=ec0.getPolicy().getName();
      String name1=ec1.getPolicy().getName();
      return name0.compareTo(name1);
    }
  }
;
  /** 
 * Federated HDFS cluster. 
 */
  private static MiniRouterDFSCluster cluster;
  /** 
 * Random Router for this federated cluster. 
 */
  private RouterContext router;
  /** 
 * Random nameservice in the federated cluster.  
 */
  private String ns;
  /** 
 * First namenode in the nameservice. 
 */
  private NamenodeContext namenode;
  /** 
 * Client interface to the Router. 
 */
  private ClientProtocol routerProtocol;
  /** 
 * Client interface to the Namenode. 
 */
  private ClientProtocol nnProtocol;
  /** 
 * NameNodeProtocol interface to the Router. 
 */
  private NamenodeProtocol routerNamenodeProtocol;
  /** 
 * NameNodeProtocol interface to the Namenode. 
 */
  private NamenodeProtocol nnNamenodeProtocol;
  /** 
 * Filesystem interface to the Router. 
 */
  private FileSystem routerFS;
  /** 
 * Filesystem interface to the Namenode. 
 */
  private FileSystem nnFS;
  /** 
 * File in the Router. 
 */
  private String routerFile;
  /** 
 * File in the Namenode. 
 */
  private String nnFile;
  @BeforeClass public static void globalSetUp() throws Exception {
    cluster=new MiniRouterDFSCluster(false,2);
    cluster.setNumDatanodesPerNameservice(6);
    cluster.startCluster();
    Configuration routerConf=new RouterConfigBuilder().metrics().rpc().build();
    routerConf.setTimeDuration(NamenodeBeanMetrics.DN_REPORT_CACHE_EXPIRE,1,TimeUnit.SECONDS);
    cluster.addRouterOverrides(routerConf);
    cluster.startRouters();
    cluster.registerNamenodes();
    cluster.waitNamenodeRegistration();
  }
  @AfterClass public static void tearDown(){
    cluster.shutdown();
  }
  @Before public void testSetup() throws Exception {
    cluster.installMockLocations();
    cluster.deleteAllFiles();
    cluster.createTestDirectoriesNamenode();
    Thread.sleep(100);
    RouterContext rndRouter=cluster.getRandomRouter();
    this.setRouter(rndRouter);
    String ns0=cluster.getNameservices().get(0);
    this.setNs(ns0);
    this.setNamenode(cluster.getNamenode(ns0,null));
    Random rnd=new Random();
    String randomFile="testfile-" + rnd.nextInt();
    this.nnFile=cluster.getNamenodeTestDirectoryForNS(ns) + "/" + randomFile;
    this.routerFile=cluster.getFederatedTestDirectoryForNS(ns) + "/" + randomFile;
    createFile(nnFS,nnFile,32);
    verifyFileExists(nnFS,nnFile);
  }
  @Test public void testRpcService() throws IOException {
    Router testRouter=new Router();
    List<String> nss=cluster.getNameservices();
    String ns0=nss.get(0);
    Configuration routerConfig=cluster.generateRouterConfiguration(ns0,null);
    RouterRpcServer server=new RouterRpcServer(routerConfig,testRouter,testRouter.getNamenodeResolver(),testRouter.getSubclusterResolver());
    server.init(routerConfig);
    assertEquals(STATE.INITED,server.getServiceState());
    server.start();
    assertEquals(STATE.STARTED,server.getServiceState());
    server.stop();
    assertEquals(STATE.STOPPED,server.getServiceState());
    server.close();
    testRouter.close();
  }
  protected MiniRouterDFSCluster getCluster(){
    return TestRouterRpc.cluster;
  }
  protected RouterContext getRouterContext(){
    return this.router;
  }
  protected void setRouter(  RouterContext r) throws IOException, URISyntaxException {
    this.router=r;
    this.routerProtocol=r.getClient().getNamenode();
    this.routerFS=r.getFileSystem();
    this.routerNamenodeProtocol=NameNodeProxies.createProxy(router.getConf(),router.getFileSystem().getUri(),NamenodeProtocol.class).getProxy();
  }
  protected FileSystem getRouterFileSystem(){
    return this.routerFS;
  }
  protected FileSystem getNamenodeFileSystem(){
    return this.nnFS;
  }
  protected ClientProtocol getRouterProtocol(){
    return this.routerProtocol;
  }
  protected ClientProtocol getNamenodeProtocol(){
    return this.nnProtocol;
  }
  protected NamenodeContext getNamenode(){
    return this.namenode;
  }
  protected void setNamenodeFile(  String filename){
    this.nnFile=filename;
  }
  protected String getNamenodeFile(){
    return this.nnFile;
  }
  protected void setRouterFile(  String filename){
    this.routerFile=filename;
  }
  protected String getRouterFile(){
    return this.routerFile;
  }
  protected void setNamenode(  NamenodeContext nn) throws IOException, URISyntaxException {
    this.namenode=nn;
    this.nnProtocol=nn.getClient().getNamenode();
    this.nnFS=nn.getFileSystem();
    String ns0=cluster.getNameservices().get(0);
    NamenodeContext nn0=cluster.getNamenode(ns0,null);
    this.nnNamenodeProtocol=NameNodeProxies.createProxy(nn0.getConf(),nn0.getFileSystem().getUri(),NamenodeProtocol.class).getProxy();
  }
  protected String getNs(){
    return this.ns;
  }
  protected void setNs(  String nameservice){
    this.ns=nameservice;
  }
  protected static void compareResponses(  ClientProtocol protocol1,  ClientProtocol protocol2,  Method m,  Object[] paramList){
    Object return1=null;
    Exception exception1=null;
    try {
      return1=m.invoke(protocol1,paramList);
    }
 catch (    Exception ex) {
      exception1=ex;
    }
    Object return2=null;
    Exception exception2=null;
    try {
      return2=m.invoke(protocol2,paramList);
    }
 catch (    Exception ex) {
      exception2=ex;
    }
    assertEquals(return1,return2);
    if (exception1 == null && exception2 == null) {
      return;
    }
    assertEquals(exception1.getCause().getClass(),exception2.getCause().getClass());
  }
  @Test public void testProxyListFiles() throws IOException, InterruptedException, URISyntaxException, NoSuchMethodException, SecurityException {
    Set<String> requiredPaths=new TreeSet<>();
    FileSubclusterResolver fileResolver=router.getRouter().getSubclusterResolver();
    for (    String mount : fileResolver.getMountPoints("/")) {
      requiredPaths.add(mount);
    }
    String defaultNs=cluster.getNameservices().get(0);
    NamenodeContext nn=cluster.getNamenode(defaultNs,null);
    FileStatus[] iterator=nn.getFileSystem().listStatus(new Path("/"));
    for (    FileStatus file : iterator) {
      requiredPaths.add(file.getPath().getName());
    }
    DirectoryListing listing=routerProtocol.getListing("/",HdfsFileStatus.EMPTY_NAME,false);
    Iterator<String> requiredPathsIterator=requiredPaths.iterator();
    for (    HdfsFileStatus f : listing.getPartialListing()) {
      String fileName=requiredPathsIterator.next();
      String currentFile=f.getFullPath(new Path("/")).getName();
      assertEquals(currentFile,fileName);
    }
    assertEquals(requiredPaths.size(),listing.getPartialListing().length);
    Method m=ClientProtocol.class.getMethod("getListing",String.class,byte[].class,boolean.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,HdfsFileStatus.EMPTY_NAME,false});
  }
  @Test public void testProxyListFilesWithConflict() throws IOException, InterruptedException {
    NamenodeContext nn=cluster.getNamenode(ns,null);
    FileSystem nnFs=nn.getFileSystem();
    addDirectory(nnFs,cluster.getFederatedTestDirectoryForNS(ns));
    FileSystem routerFs=router.getFileSystem();
    int initialCount=countContents(routerFs,"/");
    int newCount=countContents(routerFs,"/");
    assertEquals(initialCount,newCount);
    assertEquals(1,countContents(routerFs,cluster.getFederatedPathForNS(ns)));
    assertEquals(1,countContents(nnFs,cluster.getNamenodePathForNS(ns)));
  }
  protected void testRename(  RouterContext testRouter,  String filename,  String renamedFile,  boolean exceptionExpected) throws IOException {
    createFile(testRouter.getFileSystem(),filename,32);
    verifyFileExists(testRouter.getFileSystem(),filename);
    boolean exceptionThrown=false;
    try {
      DFSClient client=testRouter.getClient();
      ClientProtocol clientProtocol=client.getNamenode();
      clientProtocol.rename(filename,renamedFile);
    }
 catch (    Exception ex) {
      exceptionThrown=true;
    }
    if (exceptionExpected) {
      assertTrue(exceptionThrown);
      FileContext fileContext=testRouter.getFileContext();
      assertTrue(fileContext.delete(new Path(filename),true));
    }
 else {
      assertFalse(exceptionThrown);
      assertTrue(verifyFileExists(testRouter.getFileSystem(),renamedFile));
      FileContext fileContext=testRouter.getFileContext();
      assertTrue(fileContext.delete(new Path(renamedFile),true));
    }
  }
  protected void testRename2(  RouterContext testRouter,  String filename,  String renamedFile,  boolean exceptionExpected) throws IOException {
    createFile(testRouter.getFileSystem(),filename,32);
    verifyFileExists(testRouter.getFileSystem(),filename);
    boolean exceptionThrown=false;
    try {
      DFSClient client=testRouter.getClient();
      ClientProtocol clientProtocol=client.getNamenode();
      clientProtocol.rename2(filename,renamedFile,new Options.Rename[]{});
    }
 catch (    Exception ex) {
      exceptionThrown=true;
    }
    assertEquals(exceptionExpected,exceptionThrown);
    if (exceptionExpected) {
      FileContext fileContext=testRouter.getFileContext();
      assertTrue(fileContext.delete(new Path(filename),true));
    }
 else {
      assertTrue(verifyFileExists(testRouter.getFileSystem(),renamedFile));
      FileContext fileContext=testRouter.getFileContext();
      assertTrue(fileContext.delete(new Path(renamedFile),true));
    }
  }
  @Test public void testProxyRenameFiles() throws IOException, InterruptedException {
    Thread.sleep(5000);
    List<String> nss=cluster.getNameservices();
    String ns0=nss.get(0);
    String ns1=nss.get(1);
    String filename=cluster.getFederatedTestDirectoryForNS(ns0) + "/testrename";
    String renamedFile=filename + "-append";
    testRename(router,filename,renamedFile,false);
    testRename2(router,filename,renamedFile,false);
    filename=cluster.getFederatedTestDirectoryForNS(ns0) + "/testrename";
    renamedFile=cluster.getFederatedTestDirectoryForNS(ns1) + "/testrename";
    testRename(router,filename,renamedFile,true);
    testRename2(router,filename,renamedFile,true);
  }
  @Test public void testProxyChownFiles() throws Exception {
    String newUsername="TestUser";
    String newGroup="TestGroup";
    routerProtocol.setOwner(routerFile,newUsername,newGroup);
    FileStatus file=getFileStatus(namenode.getFileSystem(),nnFile);
    assertEquals(file.getOwner(),newUsername);
    assertEquals(file.getGroup(),newGroup);
    Method m=ClientProtocol.class.getMethod("setOwner",String.class,String.class,String.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,newUsername,newGroup});
  }
  @Test public void testProxyGetStats() throws Exception {
    Supplier<Boolean> check=new Supplier<Boolean>(){
      @Override public Boolean get(){
        try {
          long[] combinedData=routerProtocol.getStats();
          long[] individualData=getAggregateStats();
          int len=Math.min(combinedData.length,individualData.length);
          for (int i=0; i < len; i++) {
            if (combinedData[i] != individualData[i]) {
              LOG.error("Stats for {} don't match: {} != {}",i,combinedData[i],individualData[i]);
              return false;
            }
          }
          return true;
        }
 catch (        Exception e) {
          LOG.error("Cannot get stats: {}",e.getMessage());
          return false;
        }
      }
    }
;
    GenericTestUtils.waitFor(check,500,5 * 1000);
  }
  /** 
 * Get the sum of each subcluster statistics.
 * @return Aggregated statistics.
 * @throws Exception If it cannot get the stats from the Router or Namenode.
 */
  private long[] getAggregateStats() throws Exception {
    long[] individualData=new long[10];
    for (    String nameservice : cluster.getNameservices()) {
      NamenodeContext n=cluster.getNamenode(nameservice,null);
      DFSClient client=n.getClient();
      ClientProtocol clientProtocol=client.getNamenode();
      long[] data=clientProtocol.getStats();
      for (int i=0; i < data.length; i++) {
        individualData[i]+=data[i];
      }
    }
    return individualData;
  }
  @Test public void testProxyGetDatanodeReport() throws Exception {
    DatanodeInfo[] combinedData=routerProtocol.getDatanodeReport(DatanodeReportType.ALL);
    Set<Integer> individualData=new HashSet<Integer>();
    for (    String nameservice : cluster.getNameservices()) {
      NamenodeContext n=cluster.getNamenode(nameservice,null);
      DFSClient client=n.getClient();
      ClientProtocol clientProtocol=client.getNamenode();
      DatanodeInfo[] data=clientProtocol.getDatanodeReport(DatanodeReportType.ALL);
      for (int i=0; i < data.length; i++) {
        DatanodeInfo info=data[i];
        individualData.add(info.getXferPort());
      }
    }
    assertEquals(combinedData.length,individualData.size());
  }
  @Test public void testProxyGetDatanodeStorageReport() throws IOException, InterruptedException, URISyntaxException {
    DatanodeStorageReport[] combinedData=routerProtocol.getDatanodeStorageReport(DatanodeReportType.ALL);
    Set<String> individualData=new HashSet<>();
    for (    String nameservice : cluster.getNameservices()) {
      NamenodeContext n=cluster.getNamenode(nameservice,null);
      DFSClient client=n.getClient();
      ClientProtocol clientProtocol=client.getNamenode();
      DatanodeStorageReport[] data=clientProtocol.getDatanodeStorageReport(DatanodeReportType.ALL);
      for (      DatanodeStorageReport report : data) {
        DatanodeInfo dn=report.getDatanodeInfo();
        individualData.add(dn.toString());
      }
    }
    assertEquals(combinedData.length,individualData.size());
  }
  @Test public void testProxyMkdir() throws Exception {
    FileStatus[] filesInitial=routerFS.listStatus(new Path("/"));
    String dirPath="/testdir";
    FsPermission permission=new FsPermission("705");
    routerProtocol.mkdirs(dirPath,permission,false);
    FileStatus[] files=routerFS.listStatus(new Path("/"));
    assertEquals(Arrays.toString(files) + " should be " + Arrays.toString(filesInitial)+ " + "+ dirPath,filesInitial.length + 1,files.length);
    assertTrue(verifyFileExists(routerFS,dirPath));
    int foundCount=0;
    for (    NamenodeContext n : cluster.getNamenodes()) {
      if (verifyFileExists(n.getFileSystem(),dirPath)) {
        foundCount++;
      }
    }
    assertEquals(1,foundCount);
    assertTrue(deleteFile(routerFS,dirPath));
    Method m=ClientProtocol.class.getMethod("mkdirs",String.class,FsPermission.class,boolean.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,permission,false});
  }
  @Test public void testProxyChmodFiles() throws Exception {
    FsPermission permission=new FsPermission("444");
    routerProtocol.setPermission(routerFile,permission);
    FileStatus file=getFileStatus(namenode.getFileSystem(),nnFile);
    assertEquals(permission,file.getPermission());
    Method m=ClientProtocol.class.getMethod("setPermission",String.class,FsPermission.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,permission});
  }
  @Test public void testProxySetReplication() throws Exception {
    FileStatus file=getFileStatus(nnFS,nnFile);
    assertEquals(1,file.getReplication());
    routerProtocol.setReplication(routerFile,(short)2);
    file=getFileStatus(nnFS,nnFile);
    assertEquals(2,file.getReplication());
    Method m=ClientProtocol.class.getMethod("setReplication",String.class,short.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,(short)2});
  }
  @Test public void testProxyTruncateFile() throws Exception {
    FileStatus file=getFileStatus(nnFS,nnFile);
    assertTrue(file.getLen() > 0);
    routerProtocol.truncate(routerFile,0,"testclient");
    file=getFileStatus(nnFS,nnFile);
    assertEquals(0,file.getLen());
    Method m=ClientProtocol.class.getMethod("truncate",String.class,long.class,String.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,(long)0,"testclient"});
  }
  @Test public void testProxyGetBlockLocations() throws Exception {
    LocatedBlocks locations=routerProtocol.getBlockLocations(routerFile,0,1024);
    assertEquals(1,locations.getLocatedBlocks().size());
    Method m=ClientProtocol.class.getMethod("getBlockLocations",String.class,long.class,long.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,(long)0,(long)0});
  }
  @Test public void testProxyStoragePolicy() throws Exception {
    HdfsFileStatus status=namenode.getClient().getFileInfo(nnFile);
    BlockStoragePolicy[] policies=namenode.getClient().getStoragePolicies();
    BlockStoragePolicy policy=policies[0];
    while (policy.isCopyOnCreateFile()) {
      Random rand=new Random();
      int randIndex=rand.nextInt(policies.length);
      policy=policies[randIndex];
    }
    routerProtocol.setStoragePolicy(routerFile,policy.getName());
    HdfsFileStatus newStatus=namenode.getClient().getFileInfo(nnFile);
    assertTrue(newStatus.getStoragePolicy() == policy.getId());
    assertTrue(newStatus.getStoragePolicy() != status.getStoragePolicy());
    Method m=ClientProtocol.class.getMethod("setStoragePolicy",String.class,String.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,"badpolicy"});
  }
  @Test public void testProxyGetPreferedBlockSize() throws Exception {
    long namenodeSize=nnProtocol.getPreferredBlockSize(nnFile);
    long routerSize=routerProtocol.getPreferredBlockSize(routerFile);
    assertEquals(routerSize,namenodeSize);
    Method m=ClientProtocol.class.getMethod("getPreferredBlockSize",String.class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath});
  }
  private void testConcat(  String source,  String target,  boolean failureExpected){
    boolean failure=false;
    try {
      routerProtocol.concat(target,new String[]{source});
    }
 catch (    IOException ex) {
      failure=true;
    }
    assertEquals(failureExpected,failure);
  }
  @Test public void testProxyConcatFile() throws Exception {
    String sameNameservice=ns;
    String existingFile=cluster.getFederatedTestDirectoryForNS(sameNameservice) + "_concatfile";
    int existingFileSize=32;
    createFile(routerFS,existingFile,existingFileSize);
    String alternateNameservice=null;
    for (    String n : cluster.getNameservices()) {
      if (!n.equals(sameNameservice)) {
        alternateNameservice=n;
        break;
      }
    }
    String altRouterFile=cluster.getFederatedTestDirectoryForNS(alternateNameservice) + "_newfile";
    String sameRouterFile=cluster.getFederatedTestDirectoryForNS(sameNameservice) + "_newfile";
    createFile(routerFS,altRouterFile,DFSConfigKeys.DFS_BLOCK_SIZE_DEFAULT);
    createFile(routerFS,sameRouterFile,DFSConfigKeys.DFS_BLOCK_SIZE_DEFAULT);
    testConcat(existingFile,altRouterFile,true);
    testConcat(existingFile,sameRouterFile,false);
    FileStatus status=getFileStatus(routerFS,sameRouterFile);
    assertEquals(existingFileSize + DFSConfigKeys.DFS_BLOCK_SIZE_DEFAULT,status.getLen());
    Method m=ClientProtocol.class.getMethod("concat",String.class,String[].class);
    String badPath="/unknownlocation/unknowndir";
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,new String[]{routerFile}});
  }
  @Test public void testProxyAppend() throws Exception {
    EnumSet<CreateFlag> createFlag=EnumSet.of(CreateFlag.APPEND);
    DFSClient routerClient=getRouterContext().getClient();
    HdfsDataOutputStream stream=routerClient.append(routerFile,1024,createFlag,null,null);
    stream.writeBytes(TEST_STRING);
    stream.close();
    FileStatus status=getFileStatus(nnFS,nnFile);
    assertTrue(status.getLen() > TEST_STRING.length());
    Method m=ClientProtocol.class.getMethod("append",String.class,String.class,EnumSetWritable.class);
    String badPath="/unknownlocation/unknowndir";
    EnumSetWritable<CreateFlag> createFlagWritable=new EnumSetWritable<CreateFlag>(createFlag);
    compareResponses(routerProtocol,nnProtocol,m,new Object[]{badPath,"testClient",createFlagWritable});
  }
  @Test public void testProxyGetAdditionalDatanode() throws IOException, InterruptedException, URISyntaxException {
    EnumSet<CreateFlag> createFlag=EnumSet.of(CreateFlag.CREATE);
    String clientName=getRouterContext().getClient().getClientName();
    String newRouterFile=routerFile + "_additionalDatanode";
    HdfsFileStatus status=routerProtocol.create(newRouterFile,new FsPermission("777"),clientName,new EnumSetWritable<CreateFlag>(createFlag),true,(short)1,(long)1024,CryptoProtocolVersion.supported(),null);
    LocatedBlock block=routerProtocol.addBlock(newRouterFile,clientName,null,null,status.getFileId(),null,null);
    DatanodeInfo[] exclusions=new DatanodeInfo[0];
    LocatedBlock newBlock=routerProtocol.getAdditionalDatanode(newRouterFile,status.getFileId(),block.getBlock(),block.getLocations(),block.getStorageIDs(),exclusions,1,clientName);
    assertNotNull(newBlock);
  }
  @Test public void testProxyCreateFileAlternateUser() throws IOException, URISyntaxException, InterruptedException {
    String routerDir=cluster.getFederatedTestDirectoryForNS(ns);
    String namenodeDir=cluster.getNamenodeTestDirectoryForNS(ns);
    String newRouterFile=routerDir + "/unknownuser";
    String newNamenodeFile=namenodeDir + "/unknownuser";
    String username="unknownuser";
    namenode.getFileContext().setPermission(new Path(namenodeDir),new FsPermission("777"));
    UserGroupInformation ugi=UserGroupInformation.createRemoteUser(username);
    DFSClient client=getRouterContext().getClient(ugi);
    client.create(newRouterFile,true);
    FileStatus status=getFileStatus(nnFS,newNamenodeFile);
    assertEquals(status.getOwner(),username);
  }
  @Test public void testProxyGetFileInfoAcessException() throws IOException {
    UserGroupInformation ugi=UserGroupInformation.createRemoteUser("unknownuser");
    Exception nnFailure=null;
    try {
      String testFile=cluster.getNamenodeTestFileForNS(ns);
      namenode.getClient(ugi).getLocatedBlocks(testFile,0);
    }
 catch (    Exception e) {
      nnFailure=e;
    }
    assertNotNull(nnFailure);
    Exception routerFailure=null;
    try {
      String testFile=cluster.getFederatedTestFileForNS(ns);
      getRouterContext().getClient(ugi).getLocatedBlocks(testFile,0);
    }
 catch (    Exception e) {
      routerFailure=e;
    }
    assertNotNull(routerFailure);
    assertEquals(routerFailure.getClass(),nnFailure.getClass());
  }
  @Test public void testProxyVersionRequest() throws Exception {
    NamespaceInfo rVersion=routerNamenodeProtocol.versionRequest();
    NamespaceInfo nnVersion=nnNamenodeProtocol.versionRequest();
    assertEquals(nnVersion.getBlockPoolID(),rVersion.getBlockPoolID());
    assertEquals(nnVersion.getNamespaceID(),rVersion.getNamespaceID());
    assertEquals(nnVersion.getClusterID(),rVersion.getClusterID());
    assertEquals(nnVersion.getLayoutVersion(),rVersion.getLayoutVersion());
    assertEquals(nnVersion.getCTime(),rVersion.getCTime());
  }
  @Test public void testProxyGetBlockKeys() throws Exception {
    ExportedBlockKeys rKeys=routerNamenodeProtocol.getBlockKeys();
    ExportedBlockKeys nnKeys=nnNamenodeProtocol.getBlockKeys();
    assertEquals(nnKeys.getCurrentKey(),rKeys.getCurrentKey());
    assertEquals(nnKeys.getKeyUpdateInterval(),rKeys.getKeyUpdateInterval());
    assertEquals(nnKeys.getTokenLifetime(),rKeys.getTokenLifetime());
  }
  @Test public void testProxyGetBlocks() throws Exception {
    DatanodeInfo[] dns=routerProtocol.getDatanodeReport(DatanodeReportType.ALL);
    DatanodeInfo dn0=dns[0];
    BlocksWithLocations routerBlockLocations=routerNamenodeProtocol.getBlocks(dn0,1024,0);
    BlocksWithLocations nnBlockLocations=nnNamenodeProtocol.getBlocks(dn0,1024,0);
    BlockWithLocations[] routerBlocks=routerBlockLocations.getBlocks();
    BlockWithLocations[] nnBlocks=nnBlockLocations.getBlocks();
    assertEquals(nnBlocks.length,routerBlocks.length);
    for (int i=0; i < routerBlocks.length; i++) {
      assertEquals(nnBlocks[i].getBlock().getBlockId(),routerBlocks[i].getBlock().getBlockId());
    }
  }
  @Test public void testProxyGetTransactionID() throws IOException {
    long routerTransactionID=routerNamenodeProtocol.getTransactionID();
    long nnTransactionID=nnNamenodeProtocol.getTransactionID();
    assertEquals(nnTransactionID,routerTransactionID);
  }
  @Test public void testProxyGetMostRecentCheckpointTxId() throws IOException {
    long routerCheckPointId=routerNamenodeProtocol.getMostRecentCheckpointTxId();
    long nnCheckPointId=nnNamenodeProtocol.getMostRecentCheckpointTxId();
    assertEquals(nnCheckPointId,routerCheckPointId);
  }
  @Test public void testProxySetSafemode() throws Exception {
    boolean routerSafemode=routerProtocol.setSafeMode(SafeModeAction.SAFEMODE_GET,false);
    boolean nnSafemode=nnProtocol.setSafeMode(SafeModeAction.SAFEMODE_GET,false);
    assertEquals(nnSafemode,routerSafemode);
    routerSafemode=routerProtocol.setSafeMode(SafeModeAction.SAFEMODE_GET,true);
    nnSafemode=nnProtocol.setSafeMode(SafeModeAction.SAFEMODE_GET,true);
    assertEquals(nnSafemode,routerSafemode);
    assertFalse(routerProtocol.setSafeMode(SafeModeAction.SAFEMODE_GET,false));
    assertTrue(routerProtocol.setSafeMode(SafeModeAction.SAFEMODE_ENTER,false));
    assertTrue(routerProtocol.setSafeMode(SafeModeAction.SAFEMODE_GET,false));
    assertFalse(routerProtocol.setSafeMode(SafeModeAction.SAFEMODE_LEAVE,false));
    assertFalse(routerProtocol.setSafeMode(SafeModeAction.SAFEMODE_GET,false));
  }
  @Test public void testProxyRestoreFailedStorage() throws Exception {
    boolean routerSuccess=routerProtocol.restoreFailedStorage("check");
    boolean nnSuccess=nnProtocol.restoreFailedStorage("check");
    assertEquals(nnSuccess,routerSuccess);
  }
  @Test public void testProxyExceptionMessages() throws IOException {
    MockResolver resolver=(MockResolver)router.getRouter().getSubclusterResolver();
    String ns0=cluster.getNameservices().get(0);
    resolver.addLocation("/mnt",ns0,"/");
    try {
      FsPermission permission=new FsPermission("777");
      routerProtocol.mkdirs("/mnt/folder0/folder1",permission,false);
      fail("mkdirs for non-existing parent folder should have failed");
    }
 catch (    IOException ioe) {
      assertExceptionContains("/mnt/folder0",ioe,"Wrong path in exception for mkdirs");
    }
    try {
      FsPermission permission=new FsPermission("777");
      routerProtocol.setPermission("/mnt/testfile.txt",permission);
      fail("setPermission for non-existing file should have failed");
    }
 catch (    IOException ioe) {
      assertExceptionContains("/mnt/testfile.txt",ioe,"Wrong path in exception for setPermission");
    }
    try {
      FsPermission permission=new FsPermission("777");
      routerProtocol.mkdirs("/mnt/folder0/folder1",permission,false);
      routerProtocol.delete("/mnt/folder0",false);
      fail("delete for non-existing file should have failed");
    }
 catch (    IOException ioe) {
      assertExceptionContains("/mnt/folder0",ioe,"Wrong path in exception for delete");
    }
    resolver.cleanRegistrations();
    assertEquals("Parent directory doesn't exist: /ns1/a/a/b",RouterRpcClient.processExceptionMsg("Parent directory doesn't exist: /a/a/b","/a","/ns1/a"));
  }
  @Test public void testErasureCoding() throws IOException {
    LOG.info("List the available erasurce coding policies");
    ErasureCodingPolicyInfo[] policies=checkErasureCodingPolicies();
    for (    ErasureCodingPolicyInfo policy : policies) {
      LOG.info("  {}",policy);
    }
    LOG.info("List the erasure coding codecs");
    Map<String,String> codecsRouter=routerProtocol.getErasureCodingCodecs();
    Map<String,String> codecsNamenode=nnProtocol.getErasureCodingCodecs();
    assertTrue(Maps.difference(codecsRouter,codecsNamenode).areEqual());
    for (    Entry<String,String> entry : codecsRouter.entrySet()) {
      LOG.info("  {}: {}",entry.getKey(),entry.getValue());
    }
    LOG.info("Create a testing directory via the router at the root level");
    String dirPath="/testec";
    String filePath1=dirPath + "/testfile1";
    FsPermission permission=new FsPermission("755");
    routerProtocol.mkdirs(dirPath,permission,false);
    createFile(routerFS,filePath1,32);
    assertTrue(verifyFileExists(routerFS,filePath1));
    DFSClient file1Protocol=getFileDFSClient(filePath1);
    LOG.info("The policy for the new file should not be set");
    assertNull(routerProtocol.getErasureCodingPolicy(filePath1));
    assertNull(file1Protocol.getErasureCodingPolicy(filePath1));
    String policyName="RS-6-3-1024k";
    LOG.info("Set policy \"{}\" for \"{}\"",policyName,dirPath);
    routerProtocol.setErasureCodingPolicy(dirPath,policyName);
    String filePath2=dirPath + "/testfile2";
    LOG.info("Create {} in the path with the new EC policy",filePath2);
    createFile(routerFS,filePath2,32);
    assertTrue(verifyFileExists(routerFS,filePath2));
    DFSClient file2Protocol=getFileDFSClient(filePath2);
    LOG.info("Check that the policy is set for {}",filePath2);
    ErasureCodingPolicy policyRouter1=routerProtocol.getErasureCodingPolicy(filePath2);
    ErasureCodingPolicy policyNamenode1=file2Protocol.getErasureCodingPolicy(filePath2);
    assertNotNull(policyRouter1);
    assertEquals(policyName,policyRouter1.getName());
    assertEquals(policyName,policyNamenode1.getName());
    LOG.info("Create a new erasure coding policy");
    String newPolicyName="RS-6-3-128k";
    ECSchema ecSchema=new ECSchema(ErasureCodeConstants.RS_CODEC_NAME,6,3);
    ErasureCodingPolicy ecPolicy=new ErasureCodingPolicy(newPolicyName,ecSchema,128 * 1024,(byte)-1);
    ErasureCodingPolicy[] newPolicies=new ErasureCodingPolicy[]{ecPolicy};
    AddErasureCodingPolicyResponse[] responses=routerProtocol.addErasureCodingPolicies(newPolicies);
    assertEquals(1,responses.length);
    assertTrue(responses[0].isSucceed());
    routerProtocol.disableErasureCodingPolicy(newPolicyName);
    LOG.info("The new policy should be there and disabled");
    policies=checkErasureCodingPolicies();
    boolean found=false;
    for (    ErasureCodingPolicyInfo policy : policies) {
      LOG.info("  {}" + policy);
      if (policy.getPolicy().getName().equals(newPolicyName)) {
        found=true;
        assertEquals(ErasureCodingPolicyState.DISABLED,policy.getState());
        break;
      }
    }
    assertTrue(found);
    LOG.info("Set the test folder to use the new policy");
    routerProtocol.enableErasureCodingPolicy(newPolicyName);
    routerProtocol.setErasureCodingPolicy(dirPath,newPolicyName);
    LOG.info("Create a file in the path with the new EC policy");
    String filePath3=dirPath + "/testfile3";
    createFile(routerFS,filePath3,32);
    assertTrue(verifyFileExists(routerFS,filePath3));
    DFSClient file3Protocol=getFileDFSClient(filePath3);
    ErasureCodingPolicy policyRouterFile3=routerProtocol.getErasureCodingPolicy(filePath3);
    assertEquals(newPolicyName,policyRouterFile3.getName());
    ErasureCodingPolicy policyNamenodeFile3=file3Protocol.getErasureCodingPolicy(filePath3);
    assertEquals(newPolicyName,policyNamenodeFile3.getName());
    LOG.info("Remove the policy and check the one for the test folder");
    routerProtocol.removeErasureCodingPolicy(newPolicyName);
    ErasureCodingPolicy policyRouter3=routerProtocol.getErasureCodingPolicy(filePath3);
    assertEquals(newPolicyName,policyRouter3.getName());
    ErasureCodingPolicy policyNamenode3=file3Protocol.getErasureCodingPolicy(filePath3);
    assertEquals(newPolicyName,policyNamenode3.getName());
    LOG.info("Check the stats");
    ECBlockGroupStats statsRouter=routerProtocol.getECBlockGroupStats();
    ECBlockGroupStats statsNamenode=nnProtocol.getECBlockGroupStats();
    assertEquals(statsNamenode.toString(),statsRouter.toString());
  }
  @Test public void testNamenodeMetrics() throws Exception {
    final NamenodeBeanMetrics metrics=router.getRouter().getNamenodeMetrics();
    final String jsonString0=metrics.getLiveNodes();
    JSONObject jsonObject=new JSONObject(jsonString0);
    assertEquals(12,jsonObject.names().length());
    String jsonString1=metrics.getLiveNodes();
    assertEquals(jsonString0,jsonString1);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return !jsonString0.equals(metrics.getLiveNodes());
      }
    }
,500,5 * 1000);
    final String jsonString2=metrics.getLiveNodes();
    assertNotEquals(jsonString0,jsonString2);
    MockResolver resolver=(MockResolver)router.getRouter().getNamenodeResolver();
    resolver.cleanRegistrations();
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return !jsonString2.equals(metrics.getLiveNodes());
      }
    }
,500,5 * 1000);
    assertEquals("{}",metrics.getLiveNodes());
    cluster.registerNamenodes();
    cluster.waitNamenodeRegistration();
  }
  /** 
 * Check the erasure coding policies in the Router and the Namenode.
 * @return The erasure coding policies.
 */
  private ErasureCodingPolicyInfo[] checkErasureCodingPolicies() throws IOException {
    ErasureCodingPolicyInfo[] policiesRouter=routerProtocol.getErasureCodingPolicies();
    assertNotNull(policiesRouter);
    ErasureCodingPolicyInfo[] policiesNamenode=nnProtocol.getErasureCodingPolicies();
    Arrays.sort(policiesRouter,EC_POLICY_CMP);
    Arrays.sort(policiesNamenode,EC_POLICY_CMP);
    assertArrayEquals(policiesRouter,policiesNamenode);
    return policiesRouter;
  }
  /** 
 * Find the Namenode for a particular file and return the DFSClient.
 * @param path Path of the file to check.
 * @return The DFSClient to the Namenode holding the file.
 */
  private DFSClient getFileDFSClient(  final String path){
    for (    String nsId : cluster.getNameservices()) {
      LOG.info("Checking {} for {}",nsId,path);
      NamenodeContext nn=cluster.getNamenode(nsId,null);
      try {
        DFSClient nnClientProtocol=nn.getClient();
        if (nnClientProtocol.getFileInfo(path) != null) {
          return nnClientProtocol;
        }
      }
 catch (      Exception ignore) {
      }
    }
    return null;
  }
}
