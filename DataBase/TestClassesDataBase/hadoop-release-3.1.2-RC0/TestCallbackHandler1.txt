private class TestCallbackHandler1 extends NMClientAsync.AbstractCallbackHandler {
  private boolean path=true;
  private int expectedSuccess;
  private int expectedFailure;
  private final Map<OpsToTest,TestData> testMap=new HashMap<>();
  private Set<String> errorMsgs=Collections.synchronizedSet(new HashSet<String>());
  public TestCallbackHandler1(  int expectedSuccess,  int expectedFailure){
    this.expectedSuccess=expectedSuccess;
    this.expectedFailure=expectedFailure;
    for (    OpsToTest op : OpsToTest.values()) {
      testMap.put(op,new TestData(expectedSuccess,expectedFailure));
    }
  }
  @SuppressWarnings("deprecation") @Override public void onContainerStarted(  ContainerId containerId,  Map<String,ByteBuffer> allServiceResponse){
    if (path) {
      if (containerId.getId() >= expectedSuccess) {
        errorMsgs.add("Container " + containerId + " should throw the exception onContainerStarted");
        return;
      }
      TestData td=testMap.get(OpsToTest.START);
      td.success.addAndGet(1);
      td.successArray.set(containerId.getId(),1);
      asyncClient.getContainerStatusAsync(containerId,nodeId);
    }
 else {
      Container container=Container.newInstance(containerId,nodeId,null,null,null,containerToken);
      int t=containerId.getId() % 5;
switch (t) {
case 0:
        asyncClient.updateContainerResourceAsync(container);
      break;
case 1:
    asyncClient.reInitializeContainerAsync(containerId,recordFactory.newRecordInstance(ContainerLaunchContext.class),true);
  break;
case 2:
asyncClient.restartContainerAsync(containerId);
break;
case 3:
asyncClient.rollbackLastReInitializationAsync(containerId);
break;
case 4:
asyncClient.commitLastReInitializationAsync(containerId);
break;
default :
break;
}
}
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerStatusReceived(ContainerId containerId,ContainerStatus containerStatus){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerStatusReceived");
return;
}
TestData td=testMap.get(OpsToTest.QUERY);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
Container container=Container.newInstance(containerId,nodeId,null,null,null,containerToken);
asyncClient.updateContainerResourceAsync(container);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerResourceIncreased(ContainerId containerId,Resource resource){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerResourceIncreased");
return;
}
TestData td=testMap.get(OpsToTest.INCR);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
asyncClient.reInitializeContainerAsync(containerId,Records.newRecord(ContainerLaunchContext.class),true);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerResourceUpdated(ContainerId containerId,Resource resource){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerResourceUpdated");
return;
}
TestData td=testMap.get(OpsToTest.INCR);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
asyncClient.reInitializeContainerAsync(containerId,Records.newRecord(ContainerLaunchContext.class),true);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerReInitialize(ContainerId containerId){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerReInitialize");
return;
}
TestData td=testMap.get(OpsToTest.REINIT);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
asyncClient.restartContainerAsync(containerId);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerRestart(ContainerId containerId){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerReInitialize");
return;
}
TestData td=testMap.get(OpsToTest.RESTART);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
asyncClient.rollbackLastReInitializationAsync(containerId);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onRollbackLastReInitialization(ContainerId containerId){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerReInitialize");
return;
}
TestData td=testMap.get(OpsToTest.ROLLBACK);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
asyncClient.commitLastReInitializationAsync(containerId);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onCommitLastReInitialization(ContainerId containerId){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerReInitialize");
return;
}
TestData td=testMap.get(OpsToTest.COMMIT);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
asyncClient.stopContainerAsync(containerId,nodeId);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerStopped(ContainerId containerId){
if (containerId.getId() >= expectedSuccess) {
errorMsgs.add("Container " + containerId + " should throw the exception onContainerStopped");
return;
}
TestData td=testMap.get(OpsToTest.STOP);
td.success.addAndGet(1);
td.successArray.set(containerId.getId(),1);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onStartContainerError(ContainerId containerId,Throwable t){
if (t instanceof RuntimeException) {
errorMsgs.add("Unexpected throwable from callback functions should be" + " ignored by Container " + containerId);
}
if (containerId.getId() < expectedSuccess) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onStartContainerError");
return;
}
TestData td=testMap.get(OpsToTest.START);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess,1);
asyncClient.getContainerStatusAsync(containerId,nodeId);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onIncreaseContainerResourceError(ContainerId containerId,Throwable t){
if (containerId.getId() < expectedSuccess + expectedFailure) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onIncreaseContainerResourceError");
return;
}
TestData td=testMap.get(OpsToTest.INCR);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
asyncClient.stopContainerAsync(containerId,nodeId);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onUpdateContainerResourceError(ContainerId containerId,Throwable t){
if (containerId.getId() < expectedSuccess + expectedFailure) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onUpdatedContainerResourceError");
return;
}
TestData td=testMap.get(OpsToTest.INCR);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
asyncClient.stopContainerAsync(containerId,nodeId);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerReInitializeError(ContainerId containerId,Throwable t){
if (containerId.getId() < expectedSuccess + expectedFailure) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onContainerReInitializeError");
return;
}
TestData td=testMap.get(OpsToTest.REINIT);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
td=testMap.get(OpsToTest.STOP);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onContainerRestartError(ContainerId containerId,Throwable t){
if (containerId.getId() < expectedSuccess + expectedFailure) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onContainerRestartError");
return;
}
TestData td=testMap.get(OpsToTest.RESTART);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
td=testMap.get(OpsToTest.STOP);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onRollbackLastReInitializationError(ContainerId containerId,Throwable t){
if (containerId.getId() < expectedSuccess + expectedFailure) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception"+ " onRollbackLastReInitializationError");
return;
}
TestData td=testMap.get(OpsToTest.ROLLBACK);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
td=testMap.get(OpsToTest.STOP);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onCommitLastReInitializationError(ContainerId containerId,Throwable t){
if (containerId.getId() < expectedSuccess + expectedFailure) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onCommitLastReInitializationError");
return;
}
TestData td=testMap.get(OpsToTest.COMMIT);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
td=testMap.get(OpsToTest.STOP);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onStopContainerError(ContainerId containerId,Throwable t){
if (t instanceof RuntimeException) {
errorMsgs.add("Unexpected throwable from callback functions should be" + " ignored by Container " + containerId);
}
if (containerId.getId() < expectedSuccess + expectedFailure) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onStopContainerError");
return;
}
TestData td=testMap.get(OpsToTest.STOP);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess - expectedFailure,1);
throw new RuntimeException("Ignorable Exception");
}
@SuppressWarnings("deprecation") @Override public void onGetContainerStatusError(ContainerId containerId,Throwable t){
if (t instanceof RuntimeException) {
errorMsgs.add("Unexpected throwable from callback functions should be" + " ignored by Container " + containerId);
}
if (containerId.getId() < expectedSuccess) {
errorMsgs.add("Container " + containerId + " shouldn't throw the exception onGetContainerStatusError");
return;
}
TestData td=testMap.get(OpsToTest.QUERY);
td.failure.addAndGet(1);
td.failureArray.set(containerId.getId() - expectedSuccess,1);
throw new RuntimeException("Ignorable Exception");
}
public boolean isAllSuccessCallsExecuted(){
boolean isAllSuccessCallsExecuted=testMap.get(OpsToTest.START).success.get() == expectedSuccess && testMap.get(OpsToTest.QUERY).success.get() == expectedSuccess && testMap.get(OpsToTest.INCR).success.get() == expectedSuccess && testMap.get(OpsToTest.REINIT).success.get() == expectedSuccess && testMap.get(OpsToTest.RESTART).success.get() == expectedSuccess && testMap.get(OpsToTest.ROLLBACK).success.get() == expectedSuccess && testMap.get(OpsToTest.COMMIT).success.get() == expectedSuccess && testMap.get(OpsToTest.STOP).success.get() == expectedSuccess;
if (isAllSuccessCallsExecuted) {
assertAtomicIntegerArray(testMap.get(OpsToTest.START).successArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.QUERY).successArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.INCR).successArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.REINIT).successArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.RESTART).successArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.ROLLBACK).successArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.COMMIT).successArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.STOP).successArray);
}
return isAllSuccessCallsExecuted;
}
public boolean isStartAndQueryFailureCallsExecuted(){
boolean isStartAndQueryFailureCallsExecuted=testMap.get(OpsToTest.START).failure.get() == expectedFailure && testMap.get(OpsToTest.QUERY).failure.get() == expectedFailure;
if (isStartAndQueryFailureCallsExecuted) {
assertAtomicIntegerArray(testMap.get(OpsToTest.START).failureArray);
assertAtomicIntegerArray(testMap.get(OpsToTest.QUERY).failureArray);
}
return isStartAndQueryFailureCallsExecuted;
}
public boolean isIncreaseResourceFailureCallsExecuted(){
boolean isIncreaseResourceFailureCallsExecuted=testMap.get(OpsToTest.INCR).failure.get() + testMap.get(OpsToTest.REINIT).failure.get() + testMap.get(OpsToTest.RESTART).failure.get()+ testMap.get(OpsToTest.ROLLBACK).failure.get()+ testMap.get(OpsToTest.COMMIT).failure.get() == expectedFailure;
if (isIncreaseResourceFailureCallsExecuted) {
AtomicIntegerArray testArray=new AtomicIntegerArray(testMap.get(OpsToTest.INCR).failureArray.length());
for (int i=0; i < testArray.length(); i++) {
for (OpsToTest op : EnumSet.of(OpsToTest.REINIT,OpsToTest.RESTART,OpsToTest.ROLLBACK,OpsToTest.COMMIT,OpsToTest.INCR)) {
testArray.addAndGet(i,testMap.get(op).failureArray.get(i));
}
}
assertAtomicIntegerArray(testArray);
}
return isIncreaseResourceFailureCallsExecuted;
}
public boolean isStopFailureCallsExecuted(){
boolean isStopFailureCallsExecuted=testMap.get(OpsToTest.STOP).failure.get() == expectedFailure;
if (isStopFailureCallsExecuted) {
assertAtomicIntegerArray(testMap.get(OpsToTest.STOP).failureArray);
}
return isStopFailureCallsExecuted;
}
private void assertAtomicIntegerArray(AtomicIntegerArray array){
for (int i=0; i < array.length(); ++i) {
Assert.assertEquals(1,array.get(i));
}
}
}
