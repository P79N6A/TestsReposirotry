/** 
 * Test that  {@link DynamoDBMetadataStore} implements {@link MetadataStore}. In this unit test, we use an in-memory DynamoDBLocal server instead of real AWS DynamoDB. An  {@link S3AFileSystem} object is created and shared forinitializing  {@link DynamoDBMetadataStore} objects.  There are no real S3request issued as the underlying AWS S3Client is mocked.  You won't be charged bills for AWS S3 or DynamoDB when you run this test. According to the base class, every test case will have independent contract to create a new  {@link DynamoDBMetadataStore} instance and initializes it.A table will be created for each test by the test contract, and will be destroyed after the test case finishes.
 */
public class TestDynamoDBMetadataStore extends MetadataStoreTestBase {
  private static final Logger LOG=LoggerFactory.getLogger(TestDynamoDBMetadataStore.class);
  private static final String BUCKET="TestDynamoDBMetadataStore";
  private static final String S3URI=URI.create(FS_S3A + "://" + BUCKET+ "/").toString();
  public static final PrimaryKey VERSION_MARKER_PRIMARY_KEY=createVersionMarkerPrimaryKey(DynamoDBMetadataStore.VERSION_MARKER);
  /** 
 * The DynamoDB instance that can issue requests directly to server. 
 */
  private static DynamoDB dynamoDB;
  @Rule public final Timeout timeout=new Timeout(60 * 1000);
  /** 
 * Start the in-memory DynamoDBLocal server and initializes s3 file system.
 */
  @BeforeClass public static void setUpBeforeClass() throws Exception {
    DynamoDBLocalClientFactory.startSingletonServer();
    try {
      dynamoDB=new DynamoDBMSContract().getMetadataStore().getDynamoDB();
    }
 catch (    AmazonServiceException e) {
      final String msg="Cannot initialize a DynamoDBMetadataStore instance " + "against the local DynamoDB server. Perhaps the DynamoDBLocal " + "server is not configured correctly. ";
      LOG.error(msg,e);
      throw e;
    }
  }
  @AfterClass public static void tearDownAfterClass() throws Exception {
    if (dynamoDB != null) {
      dynamoDB.shutdown();
    }
    DynamoDBLocalClientFactory.stopSingletonServer();
  }
  /** 
 * Each contract has its own S3AFileSystem and DynamoDBMetadataStore objects.
 */
private static class DynamoDBMSContract extends AbstractMSContract {
    private final S3AFileSystem s3afs;
    private final DynamoDBMetadataStore ms=new DynamoDBMetadataStore();
    DynamoDBMSContract() throws IOException {
      this(new Configuration());
    }
    DynamoDBMSContract(    Configuration conf) throws IOException {
      conf.setClass(S3_CLIENT_FACTORY_IMPL,MockS3ClientFactory.class,S3ClientFactory.class);
      conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY,S3URI);
      conf.set(ACCESS_KEY,"dummy-access-key");
      conf.set(SECRET_KEY,"dummy-secret-key");
      conf.setBoolean(S3GUARD_DDB_TABLE_CREATE_KEY,true);
      conf.setClass(S3Guard.S3GUARD_DDB_CLIENT_FACTORY_IMPL,DynamoDBLocalClientFactory.class,DynamoDBClientFactory.class);
      s3afs=(S3AFileSystem)FileSystem.newInstance(conf);
      ms.initialize(s3afs);
    }
    @Override public S3AFileSystem getFileSystem(){
      return s3afs;
    }
    @Override public DynamoDBMetadataStore getMetadataStore(){
      return ms;
    }
  }
  @Override public DynamoDBMSContract createContract() throws IOException {
    return new DynamoDBMSContract();
  }
  @Override public DynamoDBMSContract createContract(  Configuration conf) throws IOException {
    return new DynamoDBMSContract(conf);
  }
  @Override FileStatus basicFileStatus(  Path path,  int size,  boolean isDir) throws IOException {
    String owner=UserGroupInformation.getCurrentUser().getShortUserName();
    return isDir ? new S3AFileStatus(true,path,owner) : new S3AFileStatus(size,getModTime(),path,BLOCK_SIZE,owner);
  }
  private DynamoDBMetadataStore getDynamoMetadataStore() throws IOException {
    return (DynamoDBMetadataStore)getContract().getMetadataStore();
  }
  private S3AFileSystem getFileSystem() throws IOException {
    return (S3AFileSystem)getContract().getFileSystem();
  }
  /** 
 * This tests that after initialize() using an S3AFileSystem object, the instance should have been initialized successfully, and tables are ACTIVE.
 */
  @Test public void testInitialize() throws IOException {
    final String tableName="testInitializeWithFileSystem";
    final S3AFileSystem s3afs=getFileSystem();
    final Configuration conf=s3afs.getConf();
    conf.set(S3GUARD_DDB_TABLE_NAME_KEY,tableName);
    try (DynamoDBMetadataStore ddbms=new DynamoDBMetadataStore()){
      ddbms.initialize(s3afs);
      verifyTableInitialized(tableName);
      assertNotNull(ddbms.getTable());
      assertEquals(tableName,ddbms.getTable().getTableName());
      String expectedRegion=conf.get(S3GUARD_DDB_REGION_KEY,s3afs.getBucketLocation(tableName));
      assertEquals("DynamoDB table should be in configured region or the same" + " region as S3 bucket",expectedRegion,ddbms.getRegion());
    }
   }
  /** 
 * This tests that after initialize() using a Configuration object, the instance should have been initialized successfully, and tables are ACTIVE.
 */
  @Test public void testInitializeWithConfiguration() throws IOException {
    final String tableName="testInitializeWithConfiguration";
    final Configuration conf=getFileSystem().getConf();
    conf.unset(S3GUARD_DDB_TABLE_NAME_KEY);
    String savedRegion=conf.get(S3GUARD_DDB_REGION_KEY,getFileSystem().getBucketLocation());
    conf.unset(S3GUARD_DDB_REGION_KEY);
    try (DynamoDBMetadataStore ddbms=new DynamoDBMetadataStore()){
      ddbms.initialize(conf);
      fail("Should have failed because the table name is not set!");
    }
 catch (    IllegalArgumentException ignored) {
    }
    conf.set(S3GUARD_DDB_TABLE_NAME_KEY,tableName);
    try (DynamoDBMetadataStore ddbms=new DynamoDBMetadataStore()){
      ddbms.initialize(conf);
      fail("Should have failed because as the region is not set!");
    }
 catch (    IllegalArgumentException ignored) {
    }
    conf.set(S3GUARD_DDB_REGION_KEY,savedRegion);
    try (DynamoDBMetadataStore ddbms=new DynamoDBMetadataStore()){
      ddbms.initialize(conf);
      verifyTableInitialized(tableName);
      assertNotNull(ddbms.getTable());
      assertEquals(tableName,ddbms.getTable().getTableName());
      assertEquals("Unexpected key schema found!",keySchema(),ddbms.getTable().describe().getKeySchema());
    }
   }
  /** 
 * Test that for a large batch write request, the limit is handled correctly.
 */
  @Test public void testBatchWrite() throws IOException {
    final int[] numMetasToDeleteOrPut={-1,0,1,S3GUARD_DDB_BATCH_WRITE_REQUEST_LIMIT,S3GUARD_DDB_BATCH_WRITE_REQUEST_LIMIT + 1};
    for (    int numOldMetas : numMetasToDeleteOrPut) {
      for (      int numNewMetas : numMetasToDeleteOrPut) {
        doTestBatchWrite(numOldMetas,numNewMetas);
      }
    }
  }
  private void doTestBatchWrite(  int numDelete,  int numPut) throws IOException {
    final String root=S3URI + "/testBatchWrite_" + numDelete+ '_'+ numPut;
    final Path oldDir=new Path(root,"oldDir");
    final Path newDir=new Path(root,"newDir");
    LOG.info("doTestBatchWrite: oldDir={}, newDir={}",oldDir,newDir);
    DynamoDBMetadataStore ms=getDynamoMetadataStore();
    ms.put(new PathMetadata(basicFileStatus(oldDir,0,true)));
    ms.put(new PathMetadata(basicFileStatus(newDir,0,true)));
    final List<PathMetadata> oldMetas=numDelete < 0 ? null : new ArrayList<PathMetadata>(numDelete);
    for (int i=0; i < numDelete; i++) {
      oldMetas.add(new PathMetadata(basicFileStatus(new Path(oldDir,"child" + i),i,true)));
    }
    final List<PathMetadata> newMetas=numPut < 0 ? null : new ArrayList<PathMetadata>(numPut);
    for (int i=0; i < numPut; i++) {
      newMetas.add(new PathMetadata(basicFileStatus(new Path(newDir,"child" + i),i,false)));
    }
    Collection<Path> pathsToDelete=null;
    if (oldMetas != null) {
      ms.put(new DirListingMetadata(oldDir,oldMetas,false));
      assertEquals(0,ms.listChildren(newDir).withoutTombstones().numEntries());
      assertTrue(CollectionUtils.isEqualCollection(oldMetas,ms.listChildren(oldDir).getListing()));
      pathsToDelete=new ArrayList<>(oldMetas.size());
      for (      PathMetadata meta : oldMetas) {
        pathsToDelete.add(meta.getFileStatus().getPath());
      }
    }
    ms.move(pathsToDelete,newMetas);
    assertEquals(0,ms.listChildren(oldDir).withoutTombstones().numEntries());
    if (newMetas != null) {
      assertTrue(CollectionUtils.isEqualCollection(newMetas,ms.listChildren(newDir).getListing()));
    }
  }
  @Test public void testInitExistingTable() throws IOException {
    final DynamoDBMetadataStore ddbms=getDynamoMetadataStore();
    final String tableName=ddbms.getTable().getTableName();
    verifyTableInitialized(tableName);
    ddbms.initTable();
    verifyTableInitialized(tableName);
  }
  /** 
 * Test the low level version check code.
 */
  @Test public void testItemVersionCompatibility() throws Throwable {
    verifyVersionCompatibility("table",createVersionMarker(VERSION_MARKER,VERSION,0));
  }
  /** 
 * Test that a version marker entry without the version number field is rejected as incompatible with a meaningful error message.
 */
  @Test public void testItemLacksVersion() throws Throwable {
    intercept(IOException.class,E_NOT_VERSION_MARKER,new VoidCallable(){
      @Override public void call() throws Exception {
        verifyVersionCompatibility("table",new Item().withPrimaryKey(createVersionMarkerPrimaryKey(VERSION_MARKER)));
      }
    }
);
  }
  /** 
 * Delete the version marker and verify that table init fails.
 */
  @Test public void testTableVersionRequired() throws Exception {
    Configuration conf=getFileSystem().getConf();
    int maxRetries=conf.getInt(S3GUARD_DDB_MAX_RETRIES,S3GUARD_DDB_MAX_RETRIES_DEFAULT);
    conf.setInt(S3GUARD_DDB_MAX_RETRIES,3);
    final DynamoDBMetadataStore ddbms=createContract(conf).getMetadataStore();
    String tableName=conf.get(S3GUARD_DDB_TABLE_NAME_KEY,BUCKET);
    Table table=verifyTableInitialized(tableName);
    table.deleteItem(VERSION_MARKER_PRIMARY_KEY);
    intercept(IOException.class,E_NO_VERSION_MARKER,new VoidCallable(){
      @Override public void call() throws Exception {
        ddbms.initTable();
      }
    }
);
    conf.setInt(S3GUARD_DDB_MAX_RETRIES,maxRetries);
  }
  /** 
 * Set the version value to a different number and verify that table init fails.
 */
  @Test public void testTableVersionMismatch() throws Exception {
    final DynamoDBMetadataStore ddbms=createContract().getMetadataStore();
    String tableName=getFileSystem().getConf().get(S3GUARD_DDB_TABLE_NAME_KEY,BUCKET);
    Table table=verifyTableInitialized(tableName);
    table.deleteItem(VERSION_MARKER_PRIMARY_KEY);
    Item v200=createVersionMarker(VERSION_MARKER,200,0);
    table.putItem(v200);
    intercept(IOException.class,E_INCOMPATIBLE_VERSION,new VoidCallable(){
      @Override public void call() throws Exception {
        ddbms.initTable();
      }
    }
);
  }
  /** 
 * Test that initTable fails with IOException when table does not exist and table auto-creation is disabled.
 */
  @Test public void testFailNonexistentTable() throws IOException {
    final String tableName="testFailNonexistentTable";
    final S3AFileSystem s3afs=getFileSystem();
    final Configuration conf=s3afs.getConf();
    conf.set(S3GUARD_DDB_TABLE_NAME_KEY,tableName);
    conf.unset(S3GUARD_DDB_TABLE_CREATE_KEY);
    try (DynamoDBMetadataStore ddbms=new DynamoDBMetadataStore()){
      ddbms.initialize(s3afs);
      fail("Should have failed as table does not exist and table auto-creation" + " is disabled");
    }
 catch (    IOException ignored) {
    }
  }
  /** 
 * Test cases about root directory as it is not in the DynamoDB table.
 */
  @Test public void testRootDirectory() throws IOException {
    final DynamoDBMetadataStore ddbms=getDynamoMetadataStore();
    Path rootPath=new Path(S3URI);
    verifyRootDirectory(ddbms.get(rootPath),true);
    ddbms.put(new PathMetadata(new S3AFileStatus(true,new Path(rootPath,"foo"),UserGroupInformation.getCurrentUser().getShortUserName())));
    verifyRootDirectory(ddbms.get(new Path(S3URI)),false);
  }
  private void verifyRootDirectory(  PathMetadata rootMeta,  boolean isEmpty){
    assertNotNull(rootMeta);
    final FileStatus status=rootMeta.getFileStatus();
    assertNotNull(status);
    assertTrue(status.isDirectory());
    if (isEmpty) {
      assertNotSame("Should not be marked non-empty",Tristate.FALSE,rootMeta.isEmptyDirectory());
    }
 else {
      assertNotSame("Should not be marked empty",Tristate.TRUE,rootMeta.isEmptyDirectory());
    }
  }
  /** 
 * Test that when moving nested paths, all its ancestors up to destination root will also be created. Here is the directory tree before move: <pre> testMovePopulateAncestors ├── a │   └── b │       └── src │           ├── dir1 │           │   └── dir2 │           └── file1.txt └── c └── d └── dest </pre> As part of rename(a/b/src, d/c/dest), S3A will enumerate the subtree at a/b/src.  This test verifies that after the move, the new subtree at 'dest' is reachable from the root (i.e. c/ and c/d exist in the table. DynamoDBMetadataStore depends on this property to do recursive delete without a full table scan.
 */
  @Test public void testMovePopulatesAncestors() throws IOException {
    final DynamoDBMetadataStore ddbms=getDynamoMetadataStore();
    final String testRoot="/testMovePopulatesAncestors";
    final String srcRoot=testRoot + "/a/b/src";
    final String destRoot=testRoot + "/c/d/e/dest";
    final Path nestedPath1=strToPath(srcRoot + "/file1.txt");
    ddbms.put(new PathMetadata(basicFileStatus(nestedPath1,1024,false)));
    final Path nestedPath2=strToPath(srcRoot + "/dir1/dir2");
    ddbms.put(new PathMetadata(basicFileStatus(nestedPath2,0,true)));
    final Collection<Path> fullSourcePaths=Lists.newArrayList(strToPath(srcRoot),strToPath(srcRoot + "/dir1"),strToPath(srcRoot + "/dir1/dir2"),strToPath(srcRoot + "/file1.txt"));
    final Collection<PathMetadata> pathsToCreate=Lists.newArrayList(new PathMetadata(basicFileStatus(strToPath(destRoot),0,true)),new PathMetadata(basicFileStatus(strToPath(destRoot + "/dir1"),0,true)),new PathMetadata(basicFileStatus(strToPath(destRoot + "/dir1/dir2"),0,true)),new PathMetadata(basicFileStatus(strToPath(destRoot + "/file1.txt"),1024,false)));
    ddbms.move(fullSourcePaths,pathsToCreate);
    assertCached(testRoot + "/c");
    assertCached(testRoot + "/c/d");
    assertCached(testRoot + "/c/d/e");
    assertCached(destRoot);
    assertCached(destRoot + "/dir1");
    assertCached(destRoot + "/dir1/dir2");
    assertCached(destRoot + "/file1.txt");
  }
  @Test public void testProvisionTable() throws IOException {
    final DynamoDBMetadataStore ddbms=getDynamoMetadataStore();
    final String tableName=ddbms.getTable().getTableName();
    final ProvisionedThroughputDescription oldProvision=dynamoDB.getTable(tableName).describe().getProvisionedThroughput();
    ddbms.provisionTable(oldProvision.getReadCapacityUnits() * 2,oldProvision.getWriteCapacityUnits() * 2);
    final ProvisionedThroughputDescription newProvision=dynamoDB.getTable(tableName).describe().getProvisionedThroughput();
    LOG.info("Old provision = {}, new provision = {}",oldProvision,newProvision);
    assertEquals(oldProvision.getReadCapacityUnits() * 2,newProvision.getReadCapacityUnits().longValue());
    assertEquals(oldProvision.getWriteCapacityUnits() * 2,newProvision.getWriteCapacityUnits().longValue());
  }
  @Test public void testDeleteTable() throws Exception {
    final String tableName="testDeleteTable";
    final S3AFileSystem s3afs=getFileSystem();
    final Configuration conf=s3afs.getConf();
    conf.set(S3GUARD_DDB_TABLE_NAME_KEY,tableName);
    try (DynamoDBMetadataStore ddbms=new DynamoDBMetadataStore()){
      ddbms.initialize(s3afs);
      ddbms.listChildren(new Path(S3URI));
      ddbms.destroy();
      verifyTableNotExist(tableName);
      ddbms.destroy();
      verifyTableNotExist(tableName);
      try {
        ddbms.listChildren(new Path(S3URI));
        fail("Should have failed after the table is destroyed!");
      }
 catch (      IOException ignored) {
      }
    }
   }
  /** 
 * This validates the table is created and ACTIVE in DynamoDB. This should not rely on the  {@link DynamoDBMetadataStore} implementation.Return the table
 */
  private static Table verifyTableInitialized(  String tableName){
    final Table table=dynamoDB.getTable(tableName);
    final TableDescription td=table.describe();
    assertEquals(tableName,td.getTableName());
    assertEquals("ACTIVE",td.getTableStatus());
    return table;
  }
  /** 
 * This validates the table is not found in DynamoDB. This should not rely on the  {@link DynamoDBMetadataStore} implementation.
 */
  private static void verifyTableNotExist(  String tableName) throws Exception {
    intercept(ResourceNotFoundException.class,() -> dynamoDB.getTable(tableName).describe());
  }
}
