public class TestNameNodeMetadataConsistency {
  private static final Path filePath1=new Path("/testdata1.txt");
  private static final Path filePath2=new Path("/testdata2.txt");
  private static final String TEST_DATA_IN_FUTURE="This is test data";
  private static final int SCAN_INTERVAL=1;
  private static final int SCAN_WAIT=3;
  MiniDFSCluster cluster;
  HdfsConfiguration conf;
  @Before public void InitTest() throws IOException {
    conf=new HdfsConfiguration();
    conf.setLong(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY,SCAN_INTERVAL);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  }
  @After public void cleanup(){
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  /** 
 * This test creates a file and modifies the block generation stamp to number that name node has not seen yet. It then asserts that name node moves into safe mode while it is in startup mode.
 */
  @Test public void testGenerationStampInFuture() throws Exception {
    cluster.waitActive();
    FileSystem fs=cluster.getFileSystem();
    OutputStream ostream=fs.create(filePath1);
    ostream.write(TEST_DATA_IN_FUTURE.getBytes());
    ostream.close();
    ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,filePath1);
    final long genStamp=block.getGenerationStamp();
    final int datanodeIndex=0;
    cluster.changeGenStampOfBlock(datanodeIndex,block,genStamp + 1);
    final DataNodeProperties dnProps=cluster.stopDataNode(datanodeIndex);
    cluster.restartNameNode(true);
    cluster.getNameNode().getNamesystem().writeLock();
    BlockInfo bInfo=cluster.getNameNode().getNamesystem().getBlockManager().getStoredBlock(block.getLocalBlock());
    bInfo.delete();
    cluster.getNameNode().getNamesystem().getBlockManager().removeBlock(bInfo);
    cluster.getNameNode().getNamesystem().writeUnlock();
    BlockManagerTestUtil.setStartupSafeModeForTest(cluster.getNameNode().getNamesystem().getBlockManager());
    cluster.restartDataNode(dnProps);
    waitForNumBytes(TEST_DATA_IN_FUTURE.length());
    assertEquals(TEST_DATA_IN_FUTURE.length(),cluster.getNameNode().getBytesWithFutureGenerationStamps());
    assertTrue(cluster.getNameNode().getNamesystem().getSafeModeTip().contains("Name node detected blocks with generation stamps in future"));
  }
  /** 
 * Pretty much the same tests as above but does not setup safeMode == true, hence we should not have positive count of Blocks in future.
 */
  @Test public void testEnsureGenStampsIsStartupOnly() throws Exception {
    String testData=" This is test data";
    cluster.restartDataNodes();
    cluster.restartNameNodes();
    cluster.waitActive();
    FileSystem fs=cluster.getFileSystem();
    OutputStream ostream=fs.create(filePath2);
    ostream.write(testData.getBytes());
    ostream.close();
    ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,filePath2);
    long genStamp=block.getGenerationStamp();
    cluster.changeGenStampOfBlock(0,block,genStamp + 1);
    MiniDFSCluster.DataNodeProperties dnProps=cluster.stopDataNode(0);
    cluster.restartNameNode(true);
    BlockInfo bInfo=cluster.getNameNode().getNamesystem().getBlockManager().getStoredBlock(block.getLocalBlock());
    cluster.getNameNode().getNamesystem().writeLock();
    bInfo.delete();
    cluster.getNameNode().getNamesystem().getBlockManager().removeBlock(bInfo);
    cluster.getNameNode().getNamesystem().writeUnlock();
    cluster.restartDataNode(dnProps);
    waitForNumBytes(0);
    assertEquals(0,cluster.getNameNode().getBytesWithFutureGenerationStamps());
  }
  private void waitForNumBytes(  final int numBytes) throws Exception {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        try {
          cluster.triggerBlockReports();
          if (cluster.getNameNode().getBytesWithFutureGenerationStamps() == numBytes) {
            return true;
          }
        }
 catch (        Exception e) {
        }
        return false;
      }
    }
,SCAN_WAIT * 1000,60000);
  }
}
