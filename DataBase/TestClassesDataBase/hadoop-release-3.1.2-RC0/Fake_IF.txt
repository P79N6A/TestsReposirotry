public static class Fake_IF<K,V> implements InputFormat<K,V>, JobConfigurable {
public static class FakeSplit implements InputSplit {
    public void write(    DataOutput out) throws IOException {
    }
    public void readFields(    DataInput in) throws IOException {
    }
    public long getLength(){
      return 0L;
    }
    public String[] getLocations(){
      return new String[0];
    }
  }
  public static void setKeyClass(  JobConf job,  Class<?> k){
    job.setClass("test.fakeif.keyclass",k,WritableComparable.class);
  }
  public static void setValClass(  JobConf job,  Class<?> v){
    job.setClass("test.fakeif.valclass",v,Writable.class);
  }
  private Class<? extends K> keyclass;
  private Class<? extends V> valclass;
  @SuppressWarnings("unchecked") public void configure(  JobConf job){
    keyclass=(Class<? extends K>)job.getClass("test.fakeif.keyclass",IncomparableKey.class,WritableComparable.class);
    valclass=(Class<? extends V>)job.getClass("test.fakeif.valclass",NullWritable.class,WritableComparable.class);
  }
  public Fake_IF(){
  }
  public InputSplit[] getSplits(  JobConf conf,  int splits){
    return new InputSplit[]{new FakeSplit()};
  }
  public RecordReader<K,V> getRecordReader(  InputSplit ignored,  JobConf conf,  Reporter reporter){
    return new RecordReader<K,V>(){
      public boolean next(      K key,      V value) throws IOException {
        return false;
      }
      public K createKey(){
        return ReflectionUtils.newInstance(keyclass,null);
      }
      public V createValue(){
        return ReflectionUtils.newInstance(valclass,null);
      }
      public long getPos() throws IOException {
        return 0L;
      }
      public void close() throws IOException {
      }
      public float getProgress() throws IOException {
        return 0.0f;
      }
    }
;
  }
}
