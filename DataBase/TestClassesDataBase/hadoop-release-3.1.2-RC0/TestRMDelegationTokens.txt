public class TestRMDelegationTokens {
  private YarnConfiguration testConf;
  @Before public void setup(){
    Logger rootLogger=LogManager.getRootLogger();
    rootLogger.setLevel(Level.DEBUG);
    ExitUtil.disableSystemExit();
    testConf=new YarnConfiguration();
    testConf.set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    UserGroupInformation.setLoginUser(null);
    UserGroupInformation.setConfiguration(testConf);
  }
  @Test(timeout=15000) public void testRMDTMasterKeyStateOnRollingMasterKey() throws Exception {
    Configuration conf=new Configuration(testConf);
    conf.set("hadoop.security.authentication","kerberos");
    UserGroupInformation.setConfiguration(conf);
    UserGroupInformation.getLoginUser().setAuthenticationMethod(AuthenticationMethod.KERBEROS);
    MemoryRMStateStore memStore=new MockMemoryRMStateStore();
    memStore.init(conf);
    RMState rmState=memStore.getState();
    Map<RMDelegationTokenIdentifier,Long> rmDTState=rmState.getRMDTSecretManagerState().getTokenState();
    Set<DelegationKey> rmDTMasterKeyState=rmState.getRMDTSecretManagerState().getMasterKeyState();
    MockRM rm1=new MyMockRM(conf,memStore);
    rm1.start();
    RMDelegationTokenSecretManager dtSecretManager=rm1.getRMContext().getRMDelegationTokenSecretManager();
    dtSecretManager.getAllMasterKeys().forEach(managerKey -> {
      int keyId=managerKey.getKeyId();
      boolean found=false;
      for (      DelegationKey stateKey : rmDTMasterKeyState) {
        if (stateKey.getKeyId() == keyId) {
          found=true;
          break;
        }
      }
      Assert.assertTrue("Master key not found: " + keyId,found);
    }
);
    GetDelegationTokenRequest request=mock(GetDelegationTokenRequest.class);
    when(request.getRenewer()).thenReturn("renewer1");
    GetDelegationTokenResponse response=rm1.getClientRMService().getDelegationToken(request);
    org.apache.hadoop.yarn.api.records.Token delegationToken=response.getRMDelegationToken();
    Token<RMDelegationTokenIdentifier> token1=ConverterUtils.convertFromYarn(delegationToken,(Text)null);
    RMDelegationTokenIdentifier dtId1=token1.decodeIdentifier();
    while (((TestRMDelegationTokenSecretManager)dtSecretManager).numUpdatedKeys.get() < 3) {
      ((TestRMDelegationTokenSecretManager)dtSecretManager).checkCurrentKeyInStateStore(rmDTMasterKeyState);
      Thread.sleep(100);
    }
    int count=0;
    while (rmDTState.containsKey(dtId1) && count < 100) {
      Thread.sleep(100);
      count++;
    }
    rm1.stop();
  }
  @Test(timeout=15000) public void testRemoveExpiredMasterKeyInRMStateStore() throws Exception {
    MemoryRMStateStore memStore=new MockMemoryRMStateStore();
    memStore.init(testConf);
    RMState rmState=memStore.getState();
    Set<DelegationKey> rmDTMasterKeyState=rmState.getRMDTSecretManagerState().getMasterKeyState();
    MockRM rm1=new MyMockRM(testConf,memStore);
    rm1.start();
    RMDelegationTokenSecretManager dtSecretManager=rm1.getRMContext().getRMDelegationTokenSecretManager();
    Assert.assertEquals(dtSecretManager.getAllMasterKeys(),rmDTMasterKeyState);
    Set<DelegationKey> expiringKeys=new HashSet<DelegationKey>();
    expiringKeys.addAll(dtSecretManager.getAllMasterKeys());
    while (true) {
      boolean allExpired=true;
      for (      DelegationKey key : expiringKeys) {
        if (rmDTMasterKeyState.contains(key)) {
          allExpired=false;
        }
      }
      if (allExpired)       break;
      Thread.sleep(500);
    }
    rm1.stop();
  }
  @Test(timeout=15000) public void testUnknownKeyTokensOnRecover() throws Exception {
    final int masterID=1234;
    final int sequenceNumber=1000;
    MemoryRMStateStore memStore=new MockMemoryRMStateStore();
    memStore.init(testConf);
    MockRM rm1=new MyMockRM(testConf,memStore);
    rm1.start();
    RMDelegationTokenSecretManager dtSecretManager=rm1.getRMContext().getRMDelegationTokenSecretManager();
    RMState rmState=memStore.getState();
    RMDelegationTokenIdentifier rmDT=new RMDelegationTokenIdentifier(new Text("owner"),new Text("renewer"),new Text("realuser"));
    rmDT.setMasterKeyId(masterID);
    rmDT.setSequenceNumber(sequenceNumber);
    final long tokenTime=Time.now() + 60000;
    rmDT.setMaxDate(tokenTime);
    dtSecretManager.storeNewToken(rmDT,tokenTime);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      public Boolean get(){
        return rmState.getRMDTSecretManagerState().getTokenState().containsKey(rmDT);
      }
    }
,10,2000);
    dtSecretManager.stopThreads();
    dtSecretManager.reset();
    Assert.assertEquals("Secret manager should have no tokens",dtSecretManager.getAllTokens().size(),0);
    Assert.assertEquals("Secret manager should have no keys",dtSecretManager.getAllMasterKeys().size(),0);
    dtSecretManager.recover(rmState);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      public Boolean get(){
        return rmState.getRMDTSecretManagerState().getTokenState().containsKey(rmDT);
      }
    }
,10,2000);
    Assert.assertEquals("Token should have been expired but is not",0L,dtSecretManager.getRenewDate(rmDT));
    dtSecretManager.startThreads();
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      public Boolean get(){
        return !rmState.getRMDTSecretManagerState().getTokenState().containsKey(rmDT);
      }
    }
,10,2000);
    rm1.stop();
  }
class MyMockRM extends TestSecurityMockRM {
    public MyMockRM(    Configuration conf,    RMStateStore store){
      super(conf,store);
    }
    @Override protected RMSecretManagerService createRMSecretManagerService(){
      return new RMSecretManagerService(testConf,rmContext){
        @Override protected RMDelegationTokenSecretManager createRMDelegationTokenSecretManager(        Configuration conf,        RMContext rmContext){
          return new TestRMDelegationTokenSecretManager(1000,1000,2000,1000,rmContext);
        }
      }
;
    }
  }
public class TestRMDelegationTokenSecretManager extends RMDelegationTokenSecretManager {
    public AtomicInteger numUpdatedKeys=new AtomicInteger(0);
    public TestRMDelegationTokenSecretManager(    long delegationKeyUpdateInterval,    long delegationTokenMaxLifetime,    long delegationTokenRenewInterval,    long delegationTokenRemoverScanInterval,    RMContext rmContext){
      super(delegationKeyUpdateInterval,delegationTokenMaxLifetime,delegationTokenRenewInterval,delegationTokenRemoverScanInterval,rmContext);
    }
    @Override protected void storeNewMasterKey(    DelegationKey newKey){
      super.storeNewMasterKey(newKey);
      numUpdatedKeys.incrementAndGet();
    }
    public synchronized DelegationKey checkCurrentKeyInStateStore(    Set<DelegationKey> rmDTMasterKeyState){
      for (      int keyId : allKeys.keySet()) {
        if (keyId == currentId) {
          DelegationKey currentKey=allKeys.get(keyId);
          boolean found=false;
          for (          DelegationKey k : rmDTMasterKeyState) {
            if (k.getKeyId() == keyId) {
              found=true;
              break;
            }
          }
          Assert.assertTrue(found);
          return currentKey;
        }
      }
      return null;
    }
  }
}
