public static class FakeGroupMapping extends ShellBasedUnixGroupsMapping {
  private static Set<String> allGroups=new HashSet<String>();
  private static Set<String> blackList=new HashSet<String>();
  private static int requestCount=0;
  private static long getGroupsDelayMs=0;
  private static boolean throwException;
  private static volatile CountDownLatch latch=null;
  @Override public List<String> getGroups(  String user) throws IOException {
    TESTLOG.info("Getting groups for " + user);
    delayIfNecessary();
    requestCount++;
    if (throwException) {
      throw new IOException("For test");
    }
    if (blackList.contains(user)) {
      return new LinkedList<String>();
    }
    return new LinkedList<String>(allGroups);
  }
  /** 
 * Delay returning on a latch or a specific amount of time.
 */
  private void delayIfNecessary(){
    if (latch != null) {
      try {
        latch.await();
        return;
      }
 catch (      InterruptedException e) {
      }
    }
    if (getGroupsDelayMs > 0) {
      try {
        Thread.sleep(getGroupsDelayMs);
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
  }
  @Override public void cacheGroupsRefresh() throws IOException {
    TESTLOG.info("Cache is being refreshed.");
    clearBlackList();
    return;
  }
  public static void clearBlackList() throws IOException {
    TESTLOG.info("Clearing the blacklist");
    blackList.clear();
  }
  public static void clearAll() throws IOException {
    TESTLOG.info("Resetting FakeGroupMapping");
    blackList.clear();
    allGroups.clear();
    requestCount=0;
    getGroupsDelayMs=0;
    throwException=false;
    latch=null;
  }
  @Override public void cacheGroupsAdd(  List<String> groups) throws IOException {
    TESTLOG.info("Adding " + groups + " to groups.");
    allGroups.addAll(groups);
  }
  public static void addToBlackList(  String user) throws IOException {
    TESTLOG.info("Adding " + user + " to the blacklist");
    blackList.add(user);
  }
  public static int getRequestCount(){
    return requestCount;
  }
  public static void resetRequestCount(){
    requestCount=0;
  }
  public static void setGetGroupsDelayMs(  long delayMs){
    getGroupsDelayMs=delayMs;
  }
  public static void setThrowException(  boolean throwIfTrue){
    throwException=throwIfTrue;
  }
  /** 
 * Hold on returning the group names unless being notified, ensure this method is called before  {@link #getGroups(String)}. Call  {@link #resume()} will resume the process.
 */
  public static void pause(){
    latch=new CountDownLatch(1);
  }
  /** 
 * Resume the background refresh thread and return the value of group names.
 */
  public static void resume(){
    if (latch != null) {
      latch.countDown();
    }
  }
}
