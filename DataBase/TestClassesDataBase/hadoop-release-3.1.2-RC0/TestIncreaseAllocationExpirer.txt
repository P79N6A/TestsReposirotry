public class TestIncreaseAllocationExpirer {
  private final int GB=1024;
  private YarnConfiguration conf;
  RMNodeLabelsManager mgr;
  @Before public void setUp() throws Exception {
    conf=new YarnConfiguration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER,CapacityScheduler.class,ResourceScheduler.class);
    mgr=new NullRMNodeLabelsManager();
    mgr.init(conf);
  }
  @Test public void testContainerIsRemovedFromAllocationExpirer() throws Exception {
    conf.setLong(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,5000);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    MockNM nm1=rm1.registerNode("127.0.0.1:1234",20 * GB);
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"default");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),1,ContainerState.RUNNING);
    am1.allocate("127.0.0.1",1 * GB,1,new ArrayList<ContainerId>());
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.ALLOCATED);
    List<Container> containers=am1.allocate(null,null).getAllocatedContainers();
    Assert.assertEquals(containerId2,containers.get(0).getId());
    Assert.assertNotNull(containers.get(0).getContainerToken());
    checkUsedResource(rm1,"default",2 * GB,null);
    FiCaSchedulerApp app=TestUtils.getFiCaSchedulerApp(rm1,app1.getApplicationId());
    Assert.assertEquals(2 * GB,app.getAppAttemptResourceUsage().getUsed().getMemorySize());
    verifyAvailableResourceOfSchedulerNode(rm1,nm1.getNodeId(),18 * GB);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),2,ContainerState.RUNNING);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    am1.sendContainerResizingRequest(Collections.singletonList(UpdateContainerRequest.newInstance(0,containerId2,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(3 * GB),null)));
    nm1.nodeHeartbeat(true);
    Thread.sleep(1000);
    am1.allocate(null,null);
    Resource resource=Resources.clone(rm1.getResourceScheduler().getRMContainer(containerId2).getAllocatedResource());
    nm1.containerIncreaseStatus(getContainer(rm1,containerId2,resource));
    Thread.sleep(10000);
    Assert.assertEquals(RMContainerState.RUNNING,rm1.getResourceScheduler().getRMContainer(containerId2).getState());
    Assert.assertEquals(3 * GB,rm1.getResourceScheduler().getRMContainer(containerId2).getAllocatedResource().getMemorySize());
    checkUsedResource(rm1,"default",4 * GB,null);
    Assert.assertEquals(4 * GB,app.getAppAttemptResourceUsage().getUsed().getMemorySize());
    verifyAvailableResourceOfSchedulerNode(rm1,nm1.getNodeId(),16 * GB);
    rm1.stop();
  }
  @Test public void testContainerIncreaseAllocationExpiration() throws Exception {
    conf.setLong(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,5000);
    final DrainDispatcher disp=new DrainDispatcher();
    MockRM rm1=new MockRM(conf){
      @Override protected Dispatcher createDispatcher(){
        return disp;
      }
    }
;
    rm1.start();
    MockNM nm1=rm1.registerNode("127.0.0.1:1234",20 * GB);
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"default");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),1,ContainerState.RUNNING);
    am1.allocate("127.0.0.1",1 * GB,1,new ArrayList<ContainerId>());
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.ALLOCATED);
    List<Container> containers=am1.allocate(null,null).getAllocatedContainers();
    Assert.assertEquals(containerId2,containers.get(0).getId());
    Assert.assertNotNull(containers.get(0).getContainerToken());
    checkUsedResource(rm1,"default",2 * GB,null);
    FiCaSchedulerApp app=TestUtils.getFiCaSchedulerApp(rm1,app1.getApplicationId());
    Assert.assertEquals(2 * GB,app.getAppAttemptResourceUsage().getUsed().getMemorySize());
    verifyAvailableResourceOfSchedulerNode(rm1,nm1.getNodeId(),18 * GB);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),2,ContainerState.RUNNING);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    am1.sendContainerResizingRequest(Collections.singletonList(UpdateContainerRequest.newInstance(0,containerId2,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(3 * GB),null)));
    nm1.nodeHeartbeat(true);
    Thread.sleep(1000);
    am1.allocate(null,null);
    checkUsedResource(rm1,"default",4 * GB,null);
    Assert.assertEquals(4 * GB,app.getAppAttemptResourceUsage().getUsed().getMemorySize());
    verifyAvailableResourceOfSchedulerNode(rm1,nm1.getNodeId(),16 * GB);
    Thread.sleep(10000);
    am1.allocate(null,null);
    Assert.assertEquals(1 * GB,rm1.getResourceScheduler().getRMContainer(containerId2).getAllocatedResource().getMemorySize());
    disp.waitForEventThreadToWait();
    checkUsedResource(rm1,"default",2 * GB,null);
    Assert.assertEquals(2 * GB,app.getAppAttemptResourceUsage().getUsed().getMemorySize());
    verifyAvailableResourceOfSchedulerNode(rm1,nm1.getNodeId(),18 * GB);
    rm1.stop();
  }
  @Test public void testConsecutiveContainerIncreaseAllocationExpiration() throws Exception {
    conf.setLong(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,5000);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    MockNM nm1=rm1.registerNode("127.0.0.1:1234",20 * GB);
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"default");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),1,ContainerState.RUNNING);
    am1.allocate("127.0.0.1",1 * GB,1,new ArrayList<ContainerId>());
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.ALLOCATED);
    am1.allocate(null,null).getAllocatedContainers();
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),2,ContainerState.RUNNING);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    am1.sendContainerResizingRequest(Collections.singletonList(UpdateContainerRequest.newInstance(0,containerId2,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(3 * GB),null)));
    nm1.nodeHeartbeat(true);
    Thread.sleep(1000);
    am1.allocate(null,null);
    Resource resource1=Resources.clone(rm1.getResourceScheduler().getRMContainer(containerId2).getAllocatedResource());
    AllocateResponse response=am1.sendContainerResizingRequest(Collections.singletonList(UpdateContainerRequest.newInstance(0,containerId2,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(5 * GB),null)));
    List<UpdateContainerError> updateErrors=response.getUpdateErrors();
    Assert.assertEquals(1,updateErrors.size());
    Assert.assertEquals("INCORRECT_CONTAINER_VERSION_ERROR",updateErrors.get(0).getReason());
    Assert.assertEquals(1,updateErrors.get(0).getCurrentContainerVersion());
    am1.sendContainerResizingRequest(Collections.singletonList(UpdateContainerRequest.newInstance(1,containerId2,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(5 * GB),null)));
    nm1.nodeHeartbeat(true);
    Thread.sleep(1000);
    am1.allocate(null,null);
    checkUsedResource(rm1,"default",6 * GB,null);
    FiCaSchedulerApp app=TestUtils.getFiCaSchedulerApp(rm1,app1.getApplicationId());
    Assert.assertEquals(6 * GB,app.getAppAttemptResourceUsage().getUsed().getMemorySize());
    verifyAvailableResourceOfSchedulerNode(rm1,nm1.getNodeId(),14 * GB);
    nm1.containerIncreaseStatus(getContainer(rm1,containerId2,resource1));
    Thread.sleep(10000);
    am1.allocate(null,null);
    Thread.sleep(2000);
    Assert.assertEquals(3 * GB,rm1.getResourceScheduler().getRMContainer(containerId2).getAllocatedResource().getMemorySize());
    checkUsedResource(rm1,"default",4 * GB,null);
    Assert.assertEquals(4 * GB,app.getAppAttemptResourceUsage().getUsed().getMemorySize());
    verifyAvailableResourceOfSchedulerNode(rm1,nm1.getNodeId(),16 * GB);
    List<Container> containersToDecrease=nm1.nodeHeartbeat(true).getContainersToUpdate();
    Assert.assertEquals(1,containersToDecrease.size());
    Assert.assertEquals(3 * GB,containersToDecrease.get(0).getResource().getMemorySize());
    rm1.stop();
  }
  @Test public void testDecreaseAfterIncreaseWithAllocationExpiration() throws Exception {
    conf.setLong(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,5000);
    MockRM rm1=new MockRM(conf);
    rm1.start();
    MockNM nm1=rm1.registerNode("127.0.0.1:1234",20 * GB);
    RMApp app1=rm1.submitApp(1 * GB,"app","user",null,"default");
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),1,ContainerState.RUNNING);
    am1.allocate("127.0.0.1",3 * GB,3,new ArrayList<ContainerId>());
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.ALLOCATED);
    ContainerId containerId3=ContainerId.newContainerId(am1.getApplicationAttemptId(),3);
    rm1.waitForState(nm1,containerId3,RMContainerState.ALLOCATED);
    ContainerId containerId4=ContainerId.newContainerId(am1.getApplicationAttemptId(),4);
    rm1.waitForState(nm1,containerId4,RMContainerState.ALLOCATED);
    List<Container> containers=am1.allocate(null,null).getAllocatedContainers();
    Assert.assertEquals(3,containers.size());
    Assert.assertNotNull(containers.get(0).getContainerToken());
    Assert.assertNotNull(containers.get(1).getContainerToken());
    Assert.assertNotNull(containers.get(2).getContainerToken());
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),2,ContainerState.RUNNING);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),3,ContainerState.RUNNING);
    nm1.nodeHeartbeat(app1.getCurrentAppAttempt().getAppAttemptId(),4,ContainerState.RUNNING);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    rm1.waitForState(nm1,containerId3,RMContainerState.RUNNING);
    rm1.waitForState(nm1,containerId4,RMContainerState.RUNNING);
    List<UpdateContainerRequest> increaseRequests=new ArrayList<>();
    increaseRequests.add(UpdateContainerRequest.newInstance(0,containerId2,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(6 * GB),null));
    increaseRequests.add(UpdateContainerRequest.newInstance(0,containerId3,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(6 * GB),null));
    increaseRequests.add(UpdateContainerRequest.newInstance(0,containerId4,ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(6 * GB),null));
    am1.sendContainerResizingRequest(increaseRequests);
    nm1.nodeHeartbeat(true);
    Thread.sleep(1000);
    am1.allocate(null,null);
    List<UpdateContainerRequest> decreaseRequests=new ArrayList<>();
    decreaseRequests.add(UpdateContainerRequest.newInstance(1,containerId2,ContainerUpdateType.DECREASE_RESOURCE,Resources.createResource(2 * GB),null));
    decreaseRequests.add(UpdateContainerRequest.newInstance(1,containerId3,ContainerUpdateType.DECREASE_RESOURCE,Resources.createResource(4 * GB),null));
    decreaseRequests.add(UpdateContainerRequest.newInstance(1,containerId4,ContainerUpdateType.DECREASE_RESOURCE,Resources.createResource(4 * GB),null));
    AllocateResponse response=am1.sendContainerResizingRequest(decreaseRequests);
    Assert.assertEquals(3,response.getUpdatedContainers().size());
    nm1.containerIncreaseStatus(getContainer(rm1,containerId4,Resources.createResource(6 * GB)));
    Thread.sleep(12000);
    am1.allocate(null,null);
    Assert.assertEquals(2 * GB,rm1.getResourceScheduler().getRMContainer(containerId2).getAllocatedResource().getMemorySize());
    Assert.assertEquals(3 * GB,rm1.getResourceScheduler().getRMContainer(containerId3).getAllocatedResource().getMemorySize());
    Assert.assertEquals(4 * GB,rm1.getResourceScheduler().getRMContainer(containerId4).getAllocatedResource().getMemorySize());
    List<Container> containersToDecrease=nm1.nodeHeartbeat(true).getContainersToUpdate();
    Assert.assertTrue(containersToDecrease.size() >= 2);
    Collections.sort(containersToDecrease);
    int i=0;
    if (containersToDecrease.size() > 2) {
      Assert.assertEquals(2 * GB,containersToDecrease.get(i++).getResource().getMemorySize());
    }
    Assert.assertEquals(3 * GB,containersToDecrease.get(i++).getResource().getMemorySize());
    Assert.assertEquals(4 * GB,containersToDecrease.get(i++).getResource().getMemorySize());
    rm1.stop();
  }
  private void checkUsedResource(  MockRM rm,  String queueName,  int memory,  String label){
    CapacityScheduler cs=(CapacityScheduler)rm.getResourceScheduler();
    CSQueue queue=cs.getQueue(queueName);
    Assert.assertEquals(memory,queue.getQueueResourceUsage().getUsed(label == null ? RMNodeLabelsManager.NO_LABEL : label).getMemorySize());
  }
  private void verifyAvailableResourceOfSchedulerNode(  MockRM rm,  NodeId nodeId,  int expectedMemory){
    CapacityScheduler cs=(CapacityScheduler)rm.getResourceScheduler();
    SchedulerNode node=cs.getNode(nodeId);
    Assert.assertEquals(expectedMemory,node.getUnallocatedResource().getMemorySize());
  }
  private Container getContainer(  MockRM rm,  ContainerId containerId,  Resource resource){
    RMContainer rmContainer=rm.getResourceScheduler().getRMContainer(containerId);
    return Container.newInstance(containerId,rmContainer.getAllocatedNode(),null,resource,null,null);
  }
}
