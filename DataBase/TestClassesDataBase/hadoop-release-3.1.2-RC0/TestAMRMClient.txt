/** 
 * Test application master client class to resource manager.
 */
@RunWith(value=Parameterized.class) public class TestAMRMClient extends BaseAMRMClientTest {
  private final static int DEFAULT_ITERATION=3;
  public TestAMRMClient(  String schedulerName,  boolean autoUpdate){
    this.schedulerName=schedulerName;
    this.autoUpdate=autoUpdate;
  }
  @Parameterized.Parameters public static Collection<Object[]> data(){
    return Arrays.asList(new Object[][]{{CapacityScheduler.class.getName(),true},{CapacityScheduler.class.getName(),false},{FairScheduler.class.getName(),false}});
  }
  @Test(timeout=60000) public void testAMRMClientNoMatchingRequests() throws IOException, YarnException {
    AMRMClient<ContainerRequest> amClient=AMRMClient.createAMRMClient();
    amClient.init(conf);
    amClient.start();
    amClient.registerApplicationMaster("Host",10000,"");
    Resource testCapability1=Resource.newInstance(1024,2);
    List<? extends Collection<ContainerRequest>> matches=amClient.getMatchingRequests(priority,node,testCapability1);
    assertEquals("Expected no matching requests.",matches.size(),0);
  }
  @Test(timeout=60000) public void testAMRMClientMatchingFit() throws YarnException, IOException {
    AMRMClient<ContainerRequest> amClient=null;
    try {
      amClient=AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      Resource capability1=Resource.newInstance(1024,2);
      Resource capability2=Resource.newInstance(1024,1);
      Resource capability3=Resource.newInstance(1000,2);
      Resource capability4=Resource.newInstance(2000,1);
      Resource capability5=Resource.newInstance(1000,3);
      Resource capability6=Resource.newInstance(2000,1);
      Resource capability7=Resource.newInstance(2000,1);
      ContainerRequest storedContainer1=new ContainerRequest(capability1,nodes,racks,priority);
      ContainerRequest storedContainer2=new ContainerRequest(capability2,nodes,racks,priority);
      ContainerRequest storedContainer3=new ContainerRequest(capability3,nodes,racks,priority);
      ContainerRequest storedContainer4=new ContainerRequest(capability4,nodes,racks,priority);
      ContainerRequest storedContainer5=new ContainerRequest(capability5,nodes,racks,priority);
      ContainerRequest storedContainer6=new ContainerRequest(capability6,nodes,racks,priority);
      ContainerRequest storedContainer7=new ContainerRequest(capability7,nodes,racks,priority2,false);
      amClient.addContainerRequest(storedContainer1);
      amClient.addContainerRequest(storedContainer2);
      amClient.addContainerRequest(storedContainer3);
      amClient.addContainerRequest(storedContainer4);
      amClient.addContainerRequest(storedContainer5);
      amClient.addContainerRequest(storedContainer6);
      amClient.addContainerRequest(storedContainer7);
      ContainerRequest storedContainer11=new ContainerRequest(capability1,nodes,racks,priority,1);
      ContainerRequest storedContainer33=new ContainerRequest(capability3,nodes,racks,priority,3);
      ContainerRequest storedContainer43=new ContainerRequest(capability4,nodes,racks,priority,3);
      amClient.addContainerRequest(storedContainer11);
      amClient.addContainerRequest(storedContainer33);
      amClient.addContainerRequest(storedContainer43);
      List<? extends Collection<ContainerRequest>> matches;
      ContainerRequest storedRequest;
      Resource testCapability1=Resource.newInstance(1024,2);
      matches=amClient.getMatchingRequests(priority,node,testCapability1);
      verifyMatches(matches,1);
      storedRequest=matches.get(0).iterator().next();
      assertEquals(storedContainer1,storedRequest);
      amClient.removeContainerRequest(storedContainer1);
      Collection<ContainerRequest> reqIdMatches=amClient.getMatchingRequests(1);
      assertEquals(1,reqIdMatches.size());
      storedRequest=reqIdMatches.iterator().next();
      assertEquals(storedContainer11,storedRequest);
      amClient.removeContainerRequest(storedContainer11);
      reqIdMatches=amClient.getMatchingRequests(3);
      assertEquals(2,reqIdMatches.size());
      Iterator<ContainerRequest> iter=reqIdMatches.iterator();
      storedRequest=iter.next();
      assertEquals(storedContainer43,storedRequest);
      amClient.removeContainerRequest(storedContainer43);
      storedRequest=iter.next();
      assertEquals(storedContainer33,storedRequest);
      amClient.removeContainerRequest(storedContainer33);
      Resource testCapability2=Resource.newInstance(2000,1);
      matches=amClient.getMatchingRequests(priority,node,testCapability2);
      verifyMatches(matches,2);
      int i=0;
      for (      ContainerRequest storedRequest1 : matches.get(0)) {
        if (i++ == 0) {
          assertEquals(storedContainer4,storedRequest1);
        }
 else {
          assertEquals(storedContainer6,storedRequest1);
        }
      }
      amClient.removeContainerRequest(storedContainer6);
      Resource testCapability3=Resource.newInstance(4000,4);
      matches=amClient.getMatchingRequests(priority,node,testCapability3);
      assert (matches.size() == 4);
      Resource testCapability4=Resource.newInstance(1024,2);
      matches=amClient.getMatchingRequests(priority,node,testCapability4);
      assert (matches.size() == 2);
      for (      Collection<ContainerRequest> testSet : matches) {
        assertEquals(1,testSet.size());
        ContainerRequest testRequest=testSet.iterator().next();
        assertTrue(testRequest != storedContainer4);
        assertTrue(testRequest != storedContainer5);
        assert (testRequest == storedContainer2 || testRequest == storedContainer3);
      }
      Resource testCapability5=Resource.newInstance(512,4);
      matches=amClient.getMatchingRequests(priority,node,testCapability5);
      assert (matches.size() == 0);
      Resource testCapability7=Resource.newInstance(2000,1);
      matches=amClient.getMatchingRequests(priority2,ResourceRequest.ANY,testCapability7);
      assert (matches.size() == 0);
      matches=amClient.getMatchingRequests(priority2,node,testCapability7);
      assert (matches.size() == 1);
      amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  /** 
 * Test fit of both GUARANTEED and OPPORTUNISTIC containers.
 */
  @Test(timeout=60000) public void testAMRMClientMatchingFitExecType() throws YarnException, IOException {
    AMRMClient<ContainerRequest> amClient=null;
    try {
      amClient=AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      Resource capability1=Resource.newInstance(1024,2);
      Resource capability2=Resource.newInstance(1024,1);
      Resource capability3=Resource.newInstance(1000,2);
      Resource capability4=Resource.newInstance(1000,2);
      Resource capability5=Resource.newInstance(2000,2);
      Resource capability6=Resource.newInstance(2000,3);
      Resource capability7=Resource.newInstance(6000,3);
      ContainerRequest storedGuarContainer1=new ContainerRequest(capability1,nodes,racks,priority);
      ContainerRequest storedGuarContainer2=new ContainerRequest(capability2,nodes,racks,priority);
      ContainerRequest storedOpportContainer1=new ContainerRequest(capability1,nodes,racks,priority,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC));
      ContainerRequest storedOpportContainer2=new ContainerRequest(capability2,nodes,racks,priority,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC));
      ContainerRequest storedOpportContainer3=new ContainerRequest(capability3,nodes,racks,priority,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC));
      ContainerRequest storedOpportContainer4=new ContainerRequest(capability4,nodes,racks,priority,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC));
      ContainerRequest storedOpportContainer5=new ContainerRequest(capability5,nodes,racks,priority,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC));
      ContainerRequest storedOpportContainer6=new ContainerRequest(capability6,nodes,racks,priority,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC));
      ContainerRequest storedOpportContainer7=new ContainerRequest(capability7,nodes,racks,priority2,0,false,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC));
      amClient.addContainerRequest(storedGuarContainer1);
      amClient.addContainerRequest(storedGuarContainer2);
      amClient.addContainerRequest(storedOpportContainer1);
      amClient.addContainerRequest(storedOpportContainer2);
      amClient.addContainerRequest(storedOpportContainer3);
      amClient.addContainerRequest(storedOpportContainer4);
      amClient.addContainerRequest(storedOpportContainer5);
      amClient.addContainerRequest(storedOpportContainer6);
      amClient.addContainerRequest(storedOpportContainer7);
      assertEquals(24,(((AMRMClientImpl<ContainerRequest>)amClient).ask.size()));
      List<? extends Collection<ContainerRequest>> matches;
      ContainerRequest storedRequest;
      Resource testCapability1=Resource.newInstance(1024,2);
      matches=amClient.getMatchingRequests(priority,node,ExecutionType.GUARANTEED,testCapability1);
      verifyMatches(matches,1);
      storedRequest=matches.get(0).iterator().next();
      assertEquals(storedGuarContainer1,storedRequest);
      amClient.removeContainerRequest(storedGuarContainer1);
      matches=amClient.getMatchingRequests(priority,node,ExecutionType.OPPORTUNISTIC,testCapability1);
      verifyMatches(matches,1);
      storedRequest=matches.get(0).iterator().next();
      assertEquals(storedOpportContainer1,storedRequest);
      amClient.removeContainerRequest(storedOpportContainer1);
      Resource testCapability2=Resource.newInstance(1000,2);
      matches=amClient.getMatchingRequests(priority,node,ExecutionType.OPPORTUNISTIC,testCapability2);
      verifyMatches(matches,2);
      int i=0;
      for (      ContainerRequest storedRequest1 : matches.get(0)) {
        if (i++ == 0) {
          assertEquals(storedOpportContainer3,storedRequest1);
        }
 else {
          assertEquals(storedOpportContainer4,storedRequest1);
        }
      }
      amClient.removeContainerRequest(storedOpportContainer3);
      Resource testCapability3=Resource.newInstance(4000,4);
      matches=amClient.getMatchingRequests(priority,node,ExecutionType.OPPORTUNISTIC,testCapability3);
      assert (matches.size() == 4);
      Resource testCapability4=Resource.newInstance(6000,3);
      matches=amClient.getMatchingRequests(priority2,ResourceRequest.ANY,ExecutionType.OPPORTUNISTIC,testCapability4);
      assert (matches.size() == 0);
      matches=amClient.getMatchingRequests(priority2,node,ExecutionType.OPPORTUNISTIC,testCapability4);
      assert (matches.size() == 1);
      amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  private void verifyMatches(  List<? extends Collection<ContainerRequest>> matches,  int matchSize){
    assertEquals(1,matches.size());
    assertEquals(matchSize,matches.get(0).size());
  }
  @Test(timeout=60000) public void testAMRMClientMatchingFitInferredRack() throws YarnException, IOException {
    AMRMClientImpl<ContainerRequest> amClient=null;
    try {
      amClient=new AMRMClientImpl<ContainerRequest>();
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      Resource capability=Resource.newInstance(1024,2);
      ContainerRequest storedContainer1=new ContainerRequest(capability,nodes,null,priority);
      amClient.addContainerRequest(storedContainer1);
      List<? extends Collection<ContainerRequest>> matches;
      ContainerRequest storedRequest;
      matches=amClient.getMatchingRequests(priority,node,capability);
      verifyMatches(matches,1);
      storedRequest=matches.get(0).iterator().next();
      assertEquals(storedContainer1,storedRequest);
      matches=amClient.getMatchingRequests(priority,rack,capability);
      verifyMatches(matches,1);
      storedRequest=matches.get(0).iterator().next();
      assertEquals(storedContainer1,storedRequest);
      amClient.removeContainerRequest(storedContainer1);
      matches=amClient.getMatchingRequests(priority,rack,capability);
      assertTrue(matches.isEmpty());
      amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  @Test public void testAMRMClientMatchStorage() throws YarnException, IOException {
    AMRMClientImpl<ContainerRequest> amClient=null;
    try {
      amClient=(AMRMClientImpl<ContainerRequest>)AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      Priority priority1=Records.newRecord(Priority.class);
      priority1.setPriority(2);
      ContainerRequest storedContainer1=new ContainerRequest(capability,nodes,racks,priority);
      ContainerRequest storedContainer2=new ContainerRequest(capability,nodes,racks,priority);
      ContainerRequest storedContainer3=new ContainerRequest(capability,null,null,priority1);
      amClient.addContainerRequest(storedContainer1);
      amClient.addContainerRequest(storedContainer2);
      amClient.addContainerRequest(storedContainer3);
      RemoteRequestsTable<ContainerRequest> remoteRequestsTable=amClient.getTable(0);
      int containersRequestedAny=remoteRequestsTable.get(priority,ResourceRequest.ANY,ExecutionType.GUARANTEED,capability).remoteRequest.getNumContainers();
      assertEquals(2,containersRequestedAny);
      containersRequestedAny=remoteRequestsTable.get(priority1,ResourceRequest.ANY,ExecutionType.GUARANTEED,capability).remoteRequest.getNumContainers();
      assertEquals(1,containersRequestedAny);
      List<? extends Collection<ContainerRequest>> matches=amClient.getMatchingRequests(priority,node,capability);
      verifyMatches(matches,2);
      matches=amClient.getMatchingRequests(priority,rack,capability);
      verifyMatches(matches,2);
      matches=amClient.getMatchingRequests(priority,ResourceRequest.ANY,capability);
      verifyMatches(matches,2);
      matches=amClient.getMatchingRequests(priority1,rack,capability);
      assertTrue(matches.isEmpty());
      matches=amClient.getMatchingRequests(priority1,ResourceRequest.ANY,capability);
      verifyMatches(matches,1);
      amClient.removeContainerRequest(storedContainer3);
      matches=amClient.getMatchingRequests(priority,node,capability);
      verifyMatches(matches,2);
      amClient.removeContainerRequest(storedContainer2);
      matches=amClient.getMatchingRequests(priority,node,capability);
      verifyMatches(matches,1);
      matches=amClient.getMatchingRequests(priority,rack,capability);
      verifyMatches(matches,1);
      ContainerRequest storedRequest=matches.get(0).iterator().next();
      assertEquals(storedContainer1,storedRequest);
      amClient.removeContainerRequest(storedContainer1);
      matches=amClient.getMatchingRequests(priority,ResourceRequest.ANY,capability);
      assertTrue(matches.isEmpty());
      matches=amClient.getMatchingRequests(priority1,ResourceRequest.ANY,capability);
      assertTrue(matches.isEmpty());
      assertTrue(amClient.getTable(0).isEmpty());
      amClient.addContainerRequest(storedContainer1);
      amClient.addContainerRequest(storedContainer3);
      int allocatedContainerCount=0;
      int iterationsLeft=3;
      while (allocatedContainerCount < 2 && iterationsLeft-- > 0) {
        Log.getLog().info("Allocated " + allocatedContainerCount + " containers"+ " with "+ iterationsLeft+ " iterations left");
        AllocateResponse allocResponse=amClient.allocate(0.1f);
        assertEquals(0,amClient.ask.size());
        assertEquals(0,amClient.release.size());
        assertEquals(nodeCount,amClient.getClusterNodeCount());
        allocatedContainerCount+=allocResponse.getAllocatedContainers().size();
        for (        Container container : allocResponse.getAllocatedContainers()) {
          ContainerRequest expectedRequest=container.getPriority().equals(storedContainer1.getPriority()) ? storedContainer1 : storedContainer3;
          matches=amClient.getMatchingRequests(container.getPriority(),ResourceRequest.ANY,container.getResource());
          verifyMatches(matches,1);
          ContainerRequest matchedRequest=matches.get(0).iterator().next();
          assertEquals(matchedRequest,expectedRequest);
          amClient.removeContainerRequest(matchedRequest);
          amClient.releaseAssignedContainer(container.getId());
        }
        if (allocatedContainerCount < containersRequestedAny) {
          triggerSchedulingWithNMHeartBeat();
        }
      }
      assertEquals(2,allocatedContainerCount);
      AllocateResponse allocResponse=amClient.allocate(0.1f);
      assertEquals(0,amClient.release.size());
      assertEquals(0,amClient.ask.size());
      assertEquals(0,allocResponse.getAllocatedContainers().size());
      assertTrue(remoteRequestsTable.isEmpty());
      amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  /** 
 * Make sure we get allocations regardless of timing issues.
 */
  private void triggerSchedulingWithNMHeartBeat(){
    RMContext context=yarnCluster.getResourceManager().getRMContext();
    if (context.getScheduler() instanceof FairScheduler) {
      FairScheduler scheduler=(FairScheduler)context.getScheduler();
      scheduler.update();
    }
    for (    RMNode rmNode : context.getRMNodes().values()) {
      context.getScheduler().handle(new NodeUpdateSchedulerEvent(rmNode));
    }
    if (context.getScheduler() instanceof FairScheduler) {
      FairScheduler scheduler=(FairScheduler)context.getScheduler();
      scheduler.update();
    }
  }
  @Test(timeout=60000) public void testAllocationWithBlacklist() throws YarnException, IOException {
    AMRMClientImpl<ContainerRequest> amClient=null;
    try {
      amClient=(AMRMClientImpl<ContainerRequest>)AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      assertEquals(0,amClient.ask.size());
      assertEquals(0,amClient.release.size());
      ContainerRequest storedContainer1=new ContainerRequest(capability,nodes,racks,priority);
      amClient.addContainerRequest(storedContainer1);
      assertEquals(3,amClient.ask.size());
      assertEquals(0,amClient.release.size());
      List<String> localNodeBlacklist=new ArrayList<String>();
      localNodeBlacklist.add(node);
      amClient.updateBlacklist(localNodeBlacklist,null);
      int allocatedContainerCount=getAllocatedContainersNumber(amClient,DEFAULT_ITERATION);
      assertEquals(0,allocatedContainerCount);
      amClient.updateBlacklist(null,localNodeBlacklist);
      ContainerRequest storedContainer2=new ContainerRequest(capability,nodes,racks,priority);
      amClient.addContainerRequest(storedContainer2);
      allocatedContainerCount=getAllocatedContainersNumber(amClient,DEFAULT_ITERATION);
      assertEquals(2,allocatedContainerCount);
      assertTrue(amClient.blacklistAdditions.isEmpty());
      assertTrue(amClient.blacklistRemovals.isEmpty());
      ContainerRequest invalidContainerRequest=new ContainerRequest(Resource.newInstance(-1024,1),nodes,racks,priority);
      amClient.addContainerRequest(invalidContainerRequest);
      amClient.updateBlacklist(localNodeBlacklist,null);
      try {
        amClient.allocate(0.1f);
        fail("there should be an exception here.");
      }
 catch (      Exception e) {
        assertEquals(1,amClient.blacklistAdditions.size());
      }
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  @Test(timeout=60000) public void testAMRMClientWithBlacklist() throws YarnException, IOException {
    AMRMClientImpl<ContainerRequest> amClient=null;
    try {
      amClient=(AMRMClientImpl<ContainerRequest>)AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      String[] nodes={"node1","node2","node3"};
      List<String> nodeList01=new ArrayList<String>();
      nodeList01.add(nodes[0]);
      nodeList01.add(nodes[1]);
      amClient.updateBlacklist(nodeList01,null);
      assertEquals(2,amClient.blacklistAdditions.size());
      assertEquals(0,amClient.blacklistRemovals.size());
      List<String> nodeList02=new ArrayList<String>();
      nodeList02.add(nodes[0]);
      nodeList02.add(nodes[2]);
      amClient.updateBlacklist(nodeList02,null);
      assertEquals(3,amClient.blacklistAdditions.size());
      assertEquals(0,amClient.blacklistRemovals.size());
      List<String> nodeList12=new ArrayList<String>();
      nodeList12.add(nodes[1]);
      nodeList12.add(nodes[2]);
      amClient.updateBlacklist(null,nodeList12);
      assertEquals(1,amClient.blacklistAdditions.size());
      assertEquals(2,amClient.blacklistRemovals.size());
      List<String> nodeList1=new ArrayList<String>();
      nodeList1.add(nodes[1]);
      amClient.updateBlacklist(nodeList1,null);
      assertEquals(2,amClient.blacklistAdditions.size());
      assertEquals(1,amClient.blacklistRemovals.size());
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  private int getAllocatedContainersNumber(  AMRMClientImpl<ContainerRequest> amClient,  int iterationsLeft) throws YarnException, IOException {
    int allocatedContainerCount=0;
    while (iterationsLeft-- > 0) {
      Log.getLog().info("Allocated " + allocatedContainerCount + " containers"+ " with "+ iterationsLeft+ " iterations left");
      AllocateResponse allocResponse=amClient.allocate(0.1f);
      assertEquals(0,amClient.ask.size());
      assertEquals(0,amClient.release.size());
      assertEquals(nodeCount,amClient.getClusterNodeCount());
      allocatedContainerCount+=allocResponse.getAllocatedContainers().size();
      if (allocatedContainerCount == 0) {
        triggerSchedulingWithNMHeartBeat();
      }
    }
    return allocatedContainerCount;
  }
  @Test(timeout=60000) public void testAMRMClient() throws YarnException, IOException {
    initAMRMClientAndTest(false);
  }
  @Test(timeout=60000) public void testAMRMClientAllocReqId() throws YarnException, IOException {
    initAMRMClientAndTest(true);
  }
  @Test(timeout=60000) public void testAMRMClientWithSaslEncryption() throws Exception {
    teardown();
    conf=new YarnConfiguration();
    conf.set(CommonConfigurationKeysPublic.HADOOP_RPC_PROTECTION,"privacy");
    createClusterAndStartApplication(conf);
    initAMRMClientAndTest(false);
  }
  protected void initAMRMClientAndTest(  boolean useAllocReqId) throws YarnException, IOException {
    AMRMClient<ContainerRequest> amClient=null;
    try {
      amClient=AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.setNMTokenCache(new NMTokenCache());
      Assert.assertNotSame(NMTokenCache.getSingleton(),amClient.getNMTokenCache());
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      if (useAllocReqId) {
        testAllocRequestId((AMRMClientImpl<ContainerRequest>)amClient);
      }
 else {
        testAllocation((AMRMClientImpl<ContainerRequest>)amClient);
      }
      amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  @Test(timeout=30000) public void testAskWithNodeLabels(){
    AMRMClientImpl<ContainerRequest> client=new AMRMClientImpl<ContainerRequest>();
    client.addContainerRequest(new ContainerRequest(Resource.newInstance(1024,1),null,null,Priority.UNDEFINED,true,"x"));
    assertEquals(1,client.ask.size());
    assertEquals("x",client.ask.iterator().next().getNodeLabelExpression());
    client.addContainerRequest(new ContainerRequest(Resource.newInstance(1024,1),null,null,Priority.UNDEFINED,true,"x"));
    client.addContainerRequest(new ContainerRequest(Resource.newInstance(1024,1),null,null,Priority.UNDEFINED,true,"a"));
    assertEquals(1,client.ask.size());
    assertEquals("a",client.ask.iterator().next().getNodeLabelExpression());
    client.addContainerRequest(new ContainerRequest(Resource.newInstance(1024,1),null,null,Priority.UNDEFINED,true,"y"));
    assertEquals(1,client.ask.size());
    for (    ResourceRequest req : client.ask) {
      if (ResourceRequest.ANY.equals(req.getResourceName())) {
        assertEquals("y",req.getNodeLabelExpression());
      }
 else {
        Assert.assertNull(req.getNodeLabelExpression());
      }
    }
    client.addContainerRequest(new ContainerRequest(Resource.newInstance(1024,1),new String[]{"rack1"},new String[]{"node1","node2"},Priority.UNDEFINED,true,"y"));
    for (    ResourceRequest req : client.ask) {
      if (ResourceRequest.ANY.equals(req.getResourceName())) {
        assertEquals("y",req.getNodeLabelExpression());
      }
 else {
        Assert.assertNull(req.getNodeLabelExpression());
      }
    }
  }
  private void verifyAddRequestFailed(  AMRMClient<ContainerRequest> client,  ContainerRequest request){
    try {
      client.addContainerRequest(request);
    }
 catch (    InvalidContainerRequestException e) {
      return;
    }
    fail();
  }
  @Test(timeout=30000) public void testAskWithInvalidNodeLabels(){
    AMRMClientImpl<ContainerRequest> client=new AMRMClientImpl<ContainerRequest>();
    verifyAddRequestFailed(client,new ContainerRequest(Resource.newInstance(1024,1),null,null,Priority.UNDEFINED,true,"x && y"));
  }
  @Test(timeout=60000) public void testAMRMClientWithContainerResourceChange() throws YarnException, IOException {
    Assume.assumeTrue(schedulerName.equals(CapacityScheduler.class.getName()));
    AMRMClient<ContainerRequest> amClient=null;
    try {
      amClient=AMRMClient.createAMRMClient();
      Assert.assertNotNull(amClient);
      Assert.assertSame(NMTokenCache.getSingleton(),amClient.getNMTokenCache());
      amClient.init(conf);
      amClient.start();
      assertEquals(STATE.STARTED,amClient.getServiceState());
      NMClientImpl nmClient=(NMClientImpl)NMClient.createNMClient();
      Assert.assertNotNull(nmClient);
      Assert.assertSame(NMTokenCache.getSingleton(),nmClient.getNMTokenCache());
      nmClient.init(conf);
      nmClient.start();
      assertEquals(STATE.STARTED,nmClient.getServiceState());
      amClient.registerApplicationMaster("Host",10000,"");
      List<Container> containers=allocateAndStartContainers(amClient,nmClient,3);
      doContainerResourceChange(amClient,containers);
      amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  private List<Container> allocateAndStartContainers(  final AMRMClient<ContainerRequest> amClient,  final NMClient nmClient,  int num) throws YarnException, IOException {
    for (int i=0; i < num; ++i) {
      amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    }
    amClient.allocate(0.1f);
    triggerSchedulingWithNMHeartBeat();
    AllocateResponse allocResponse=amClient.allocate(0.1f);
    List<Container> containers=allocResponse.getAllocatedContainers();
    assertEquals(num,containers.size());
    Credentials ts=new Credentials();
    DataOutputBuffer dob=new DataOutputBuffer();
    ts.writeTokenStorageToStream(dob);
    ByteBuffer securityTokens=ByteBuffer.wrap(dob.getData(),0,dob.getLength());
    ContainerLaunchContext clc=BuilderUtils.newContainerLaunchContext(Collections.<String,LocalResource>emptyMap(),new HashMap<String,String>(),Arrays.asList("sleep","100"),new HashMap<String,ByteBuffer>(),securityTokens,new HashMap<ApplicationAccessType,String>());
    try {
      for (int i=0; i < num; i++) {
        Container container=containers.get(i);
        nmClient.startContainer(container,clc);
        while (true) {
          ContainerStatus status=nmClient.getContainerStatus(container.getId(),container.getNodeId());
          if (status.getState() == ContainerState.RUNNING) {
            break;
          }
          sleep(10);
        }
      }
    }
 catch (    YarnException e) {
      throw new AssertionError("Exception is not expected: " + e);
    }
    triggerSchedulingWithNMHeartBeat();
    return containers;
  }
  private void doContainerResourceChange(  final AMRMClient<ContainerRequest> amClient,  List<Container> containers) throws YarnException, IOException {
    assertEquals(3,containers.size());
    Container container1=containers.get(0);
    Container container2=containers.get(1);
    Container container3=containers.get(2);
    AMRMClientImpl<ContainerRequest> amClientImpl=(AMRMClientImpl<ContainerRequest>)amClient;
    assertEquals(0,amClientImpl.change.size());
    amClientImpl.requestContainerUpdate(container1,UpdateContainerRequest.newInstance(container1.getVersion(),container1.getId(),ContainerUpdateType.INCREASE_RESOURCE,Resource.newInstance(2048,1),null));
    amClientImpl.requestContainerUpdate(container1,UpdateContainerRequest.newInstance(container1.getVersion(),container1.getId(),ContainerUpdateType.INCREASE_RESOURCE,Resource.newInstance(4096,1),null));
    assertEquals(Resource.newInstance(4096,1),amClientImpl.change.get(container1.getId()).getValue().getCapability());
    amClientImpl.requestContainerUpdate(container1,UpdateContainerRequest.newInstance(container1.getVersion(),container1.getId(),ContainerUpdateType.DECREASE_RESOURCE,Resource.newInstance(512,1),null));
    assertEquals(Resource.newInstance(512,1),amClientImpl.change.get(container1.getId()).getValue().getCapability());
    amClientImpl.requestContainerUpdate(container2,UpdateContainerRequest.newInstance(container2.getVersion(),container2.getId(),ContainerUpdateType.INCREASE_RESOURCE,Resource.newInstance(2048,1),null));
    assertEquals(Resource.newInstance(2048,1),amClientImpl.change.get(container2.getId()).getValue().getCapability());
    amClientImpl.requestContainerUpdate(container3,UpdateContainerRequest.newInstance(container3.getVersion(),container3.getId(),ContainerUpdateType.INCREASE_RESOURCE,Resource.newInstance(2048,1),null));
    assertEquals(3,amClientImpl.pendingChange.size());
    amClientImpl.releaseAssignedContainer(container3.getId());
    assertEquals(2,amClientImpl.pendingChange.size());
    AllocateResponse allocResponse=amClient.allocate(0.1f);
    assertEquals(0,amClientImpl.change.size());
    List<UpdatedContainer> updatedContainers=allocResponse.getUpdatedContainers();
    assertEquals(1,updatedContainers.size());
    triggerSchedulingWithNMHeartBeat();
    allocResponse=amClient.allocate(0.1f);
    updatedContainers=allocResponse.getUpdatedContainers();
    assertEquals(1,updatedContainers.size());
  }
  @Test public void testAMRMContainerPromotionAndDemotionWithAutoUpdate() throws Exception {
    AMRMClientImpl<AMRMClient.ContainerRequest> amClient=(AMRMClientImpl<AMRMClient.ContainerRequest>)AMRMClient.createAMRMClient();
    amClient.init(conf);
    amClient.start();
    NMClientImpl nmClient=(NMClientImpl)NMClient.createNMClient();
    Assert.assertNotNull(nmClient);
    nmClient.init(conf);
    nmClient.start();
    assertEquals(STATE.STARTED,nmClient.getServiceState());
    amClient.registerApplicationMaster("Host",10000,"");
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    Resource reqResource=Resource.newInstance(512,1);
    amClient.addContainerRequest(new AMRMClient.ContainerRequest(reqResource,null,null,priority2,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true)));
    AllocateResponse allocResponse=waitForAllocation(amClient,1,0);
    assertEquals(1,allocResponse.getAllocatedContainers().size());
    startContainer(allocResponse,nmClient);
    Container c=allocResponse.getAllocatedContainers().get(0);
    amClient.requestContainerUpdate(c,UpdateContainerRequest.newInstance(c.getVersion(),c.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED));
    allocResponse=waitForAllocation(amClient,0,1);
    UpdatedContainer updatedContainer=allocResponse.getUpdatedContainers().get(0);
    if (!autoUpdate) {
      nmClient.updateContainerResource(updatedContainer.getContainer());
    }
    waitForNMContextUpdate(updatedContainer,ExecutionType.GUARANTEED);
    amClient.requestContainerUpdate(updatedContainer.getContainer(),UpdateContainerRequest.newInstance(updatedContainer.getContainer().getVersion(),updatedContainer.getContainer().getId(),ContainerUpdateType.DEMOTE_EXECUTION_TYPE,null,ExecutionType.OPPORTUNISTIC));
    allocResponse=waitForAllocation(amClient,0,1);
    updatedContainer=allocResponse.getUpdatedContainers().get(0);
    if (!autoUpdate) {
      nmClient.updateContainerResource(updatedContainer.getContainer());
    }
    waitForNMContextUpdate(updatedContainer,ExecutionType.OPPORTUNISTIC);
    amClient.close();
  }
  private AllocateResponse waitForAllocation(  AMRMClient amrmClient,  int expectedAllocatedContainerNum,  int expectedUpdatedContainerNum) throws Exception {
    AllocateResponse allocResponse=null;
    int iteration=100;
    while (iteration > 0) {
      allocResponse=amrmClient.allocate(0.1f);
      int actualAllocated=allocResponse.getAllocatedContainers().size();
      int actualUpdated=allocResponse.getUpdatedContainers().size();
      if (expectedAllocatedContainerNum == actualAllocated && expectedUpdatedContainerNum == actualUpdated) {
        break;
      }
      Thread.sleep(100);
      iteration--;
    }
    return allocResponse;
  }
  private void waitForNMContextUpdate(  UpdatedContainer updatedContainer,  ExecutionType expectedType){
    for (int i=0; i < nodeCount; i++) {
      NodeManager nm=yarnCluster.getNodeManager(i);
      if (nm.getNMContext().getNodeId().equals(updatedContainer.getContainer().getNodeId())) {
        try {
          GenericTestUtils.waitFor(() -> {
            org.apache.hadoop.yarn.server.nodemanager.containermanager.container.Container nmContainer=nm.getNMContext().getContainers().get(updatedContainer.getContainer().getId());
            if (nmContainer != null) {
              ExecutionType actual=nmContainer.getContainerTokenIdentifier().getExecutionType();
              return actual.equals(expectedType);
            }
            return false;
          }
,1000,30000);
        }
 catch (        TimeoutException e) {
          fail("Times out waiting for container state in" + " NM context to be updated");
        }
catch (        InterruptedException e) {
        }
        break;
      }
      if (i == nodeCount - 1) {
        fail("Container doesn't exist in NM context.");
      }
    }
  }
  @Test(timeout=60000) public void testAMRMClientWithContainerPromotion() throws YarnException, IOException {
    AMRMClientImpl<AMRMClient.ContainerRequest> amClient=(AMRMClientImpl<AMRMClient.ContainerRequest>)AMRMClient.createAMRMClient();
    Assert.assertSame(NMTokenCache.getSingleton(),amClient.getNMTokenCache());
    amClient.init(conf);
    amClient.start();
    NMClientImpl nmClient=(NMClientImpl)NMClient.createNMClient();
    Assert.assertNotNull(nmClient);
    Assert.assertSame(NMTokenCache.getSingleton(),nmClient.getNMTokenCache());
    nmClient.init(conf);
    nmClient.start();
    assertEquals(STATE.STARTED,nmClient.getServiceState());
    amClient.registerApplicationMaster("Host",10000,"");
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    amClient.addContainerRequest(new AMRMClient.ContainerRequest(capability,null,null,priority2,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true)));
    int oppContainersRequestedAny=amClient.getTable(0).get(priority2,ResourceRequest.ANY,ExecutionType.OPPORTUNISTIC,capability).remoteRequest.getNumContainers();
    assertEquals(1,oppContainersRequestedAny);
    assertEquals(1,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    int allocatedContainerCount=0;
    Map<ContainerId,Container> allocatedOpportContainers=new HashMap<>();
    int iterationsLeft=50;
    amClient.getNMTokenCache().clearCache();
    assertEquals(0,amClient.getNMTokenCache().numberOfTokensInCache());
    AllocateResponse allocResponse=null;
    while (allocatedContainerCount < oppContainersRequestedAny && iterationsLeft-- > 0) {
      allocResponse=amClient.allocate(0.1f);
      assertEquals(0,amClient.ask.size());
      assertEquals(0,amClient.release.size());
      allocatedContainerCount+=allocResponse.getAllocatedContainers().size();
      for (      Container container : allocResponse.getAllocatedContainers()) {
        if (container.getExecutionType() == ExecutionType.OPPORTUNISTIC) {
          allocatedOpportContainers.put(container.getId(),container);
        }
      }
      if (allocatedContainerCount < oppContainersRequestedAny) {
        sleep(100);
      }
    }
    assertEquals(oppContainersRequestedAny,allocatedContainerCount);
    assertEquals(oppContainersRequestedAny,allocatedOpportContainers.size());
    startContainer(allocResponse,nmClient);
    try {
      Container c=allocatedOpportContainers.values().iterator().next();
      amClient.requestContainerUpdate(c,UpdateContainerRequest.newInstance(c.getVersion(),c.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.OPPORTUNISTIC));
      fail("Should throw Exception..");
    }
 catch (    IllegalArgumentException e) {
      System.out.println("## " + e.getMessage());
      assertTrue(e.getMessage().contains("target should be GUARANTEED and original should be OPPORTUNISTIC"));
    }
    Container c=allocatedOpportContainers.values().iterator().next();
    amClient.requestContainerUpdate(c,UpdateContainerRequest.newInstance(c.getVersion(),c.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED));
    iterationsLeft=120;
    Map<ContainerId,UpdatedContainer> updatedContainers=new HashMap<>();
    while (iterationsLeft-- > 0 && updatedContainers.isEmpty()) {
      allocResponse=amClient.allocate(0.1f);
      if (allocResponse.getUpdatedContainers() != null) {
        for (        UpdatedContainer updatedContainer : allocResponse.getUpdatedContainers()) {
          System.out.println("Got update..");
          updatedContainers.put(updatedContainer.getContainer().getId(),updatedContainer);
        }
      }
      if (iterationsLeft > 0) {
        sleep(100);
      }
    }
    assertEquals(1,updatedContainers.size());
    for (    ContainerId cId : allocatedOpportContainers.keySet()) {
      Container orig=allocatedOpportContainers.get(cId);
      UpdatedContainer updatedContainer=updatedContainers.get(cId);
      assertNotNull(updatedContainer);
      assertEquals(ExecutionType.GUARANTEED,updatedContainer.getContainer().getExecutionType());
      assertEquals(orig.getResource(),updatedContainer.getContainer().getResource());
      assertEquals(orig.getNodeId(),updatedContainer.getContainer().getNodeId());
      assertEquals(orig.getVersion() + 1,updatedContainer.getContainer().getVersion());
    }
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    updateContainerExecType(allocResponse,ExecutionType.GUARANTEED,nmClient);
    amClient.ask.clear();
  }
  @Test(timeout=60000) public void testAMRMClientWithContainerDemotion() throws YarnException, IOException {
    AMRMClientImpl<AMRMClient.ContainerRequest> amClient=(AMRMClientImpl<AMRMClient.ContainerRequest>)AMRMClient.createAMRMClient();
    Assert.assertSame(NMTokenCache.getSingleton(),amClient.getNMTokenCache());
    amClient.init(conf);
    amClient.start();
    NMClientImpl nmClient=(NMClientImpl)NMClient.createNMClient();
    Assert.assertNotNull(nmClient);
    Assert.assertSame(NMTokenCache.getSingleton(),nmClient.getNMTokenCache());
    nmClient.init(conf);
    nmClient.start();
    assertEquals(STATE.STARTED,nmClient.getServiceState());
    amClient.registerApplicationMaster("Host",10000,"");
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    amClient.addContainerRequest(new AMRMClient.ContainerRequest(capability,null,null,priority2,0,true,null,ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED,true)));
    int oppContainersRequestedAny=amClient.getTable(0).get(priority2,ResourceRequest.ANY,ExecutionType.GUARANTEED,capability).remoteRequest.getNumContainers();
    assertEquals(1,oppContainersRequestedAny);
    assertEquals(1,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    int allocatedContainerCount=0;
    Map<ContainerId,Container> allocatedGuaranteedContainers=new HashMap<>();
    int iterationsLeft=50;
    amClient.getNMTokenCache().clearCache();
    assertEquals(0,amClient.getNMTokenCache().numberOfTokensInCache());
    AllocateResponse allocResponse=null;
    while (allocatedContainerCount < oppContainersRequestedAny && iterationsLeft-- > 0) {
      allocResponse=amClient.allocate(0.1f);
      assertEquals(0,amClient.ask.size());
      assertEquals(0,amClient.release.size());
      allocatedContainerCount+=allocResponse.getAllocatedContainers().size();
      for (      Container container : allocResponse.getAllocatedContainers()) {
        if (container.getExecutionType() == ExecutionType.GUARANTEED) {
          allocatedGuaranteedContainers.put(container.getId(),container);
        }
      }
      if (allocatedContainerCount < oppContainersRequestedAny) {
        sleep(100);
      }
    }
    assertEquals(oppContainersRequestedAny,allocatedContainerCount);
    assertEquals(oppContainersRequestedAny,allocatedGuaranteedContainers.size());
    startContainer(allocResponse,nmClient);
    try {
      Container c=allocatedGuaranteedContainers.values().iterator().next();
      amClient.requestContainerUpdate(c,UpdateContainerRequest.newInstance(c.getVersion(),c.getId(),ContainerUpdateType.DEMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED));
      fail("Should throw Exception..");
    }
 catch (    IllegalArgumentException e) {
      System.out.println("## " + e.getMessage());
      assertTrue(e.getMessage().contains("target should be OPPORTUNISTIC and original should be GUARANTEED"));
    }
    Container c=allocatedGuaranteedContainers.values().iterator().next();
    amClient.requestContainerUpdate(c,UpdateContainerRequest.newInstance(c.getVersion(),c.getId(),ContainerUpdateType.DEMOTE_EXECUTION_TYPE,null,ExecutionType.OPPORTUNISTIC));
    iterationsLeft=120;
    Map<ContainerId,UpdatedContainer> updatedContainers=new HashMap<>();
    while (iterationsLeft-- > 0 && updatedContainers.isEmpty()) {
      allocResponse=amClient.allocate(0.1f);
      if (allocResponse.getUpdatedContainers() != null) {
        for (        UpdatedContainer updatedContainer : allocResponse.getUpdatedContainers()) {
          System.out.println("Got update..");
          updatedContainers.put(updatedContainer.getContainer().getId(),updatedContainer);
        }
      }
      if (iterationsLeft > 0) {
        sleep(100);
      }
    }
    assertEquals(1,updatedContainers.size());
    for (    ContainerId cId : allocatedGuaranteedContainers.keySet()) {
      Container orig=allocatedGuaranteedContainers.get(cId);
      UpdatedContainer updatedContainer=updatedContainers.get(cId);
      assertNotNull(updatedContainer);
      assertEquals(ExecutionType.OPPORTUNISTIC,updatedContainer.getContainer().getExecutionType());
      assertEquals(orig.getResource(),updatedContainer.getContainer().getResource());
      assertEquals(orig.getNodeId(),updatedContainer.getContainer().getNodeId());
      assertEquals(orig.getVersion() + 1,updatedContainer.getContainer().getVersion());
    }
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    updateContainerExecType(allocResponse,ExecutionType.OPPORTUNISTIC,nmClient);
    amClient.ask.clear();
  }
  @SuppressWarnings("deprecation") private void updateContainerExecType(  AllocateResponse allocResponse,  ExecutionType expectedExecType,  NMClientImpl nmClient) throws IOException, YarnException {
    for (    UpdatedContainer updatedContainer : allocResponse.getUpdatedContainers()) {
      Container container=updatedContainer.getContainer();
      if (!autoUpdate) {
        nmClient.increaseContainerResource(container);
      }
      while (true) {
        ContainerStatus status=nmClient.getContainerStatus(container.getId(),container.getNodeId());
        if (status.getExecutionType() == expectedExecType) {
          break;
        }
        sleep(10);
      }
    }
  }
  private void startContainer(  AllocateResponse allocResponse,  NMClientImpl nmClient) throws IOException, YarnException {
    Credentials ts=new Credentials();
    DataOutputBuffer dob=new DataOutputBuffer();
    ts.writeTokenStorageToStream(dob);
    ByteBuffer securityTokens=ByteBuffer.wrap(dob.getData(),0,dob.getLength());
    ContainerLaunchContext clc=BuilderUtils.newContainerLaunchContext(Collections.<String,LocalResource>emptyMap(),new HashMap<String,String>(),Arrays.asList("sleep","100"),new HashMap<String,ByteBuffer>(),securityTokens,new HashMap<ApplicationAccessType,String>());
    for (    Container container : allocResponse.getAllocatedContainers()) {
      nmClient.startContainer(container,clc);
      while (true) {
        ContainerStatus status=nmClient.getContainerStatus(container.getId(),container.getNodeId());
        if (status.getState() == ContainerState.RUNNING) {
          break;
        }
        sleep(10);
      }
    }
  }
  private void testAllocation(  final AMRMClientImpl<ContainerRequest> amClient) throws YarnException, IOException {
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    assertNumContainers(amClient,0,2,2,2,3,0);
    int containersRequestedAny=2;
    int allocatedContainerCount=0;
    int iterationsLeft=3;
    Set<ContainerId> releases=new TreeSet<ContainerId>();
    amClient.getNMTokenCache().clearCache();
    assertEquals(0,amClient.getNMTokenCache().numberOfTokensInCache());
    HashMap<String,Token> receivedNMTokens=new HashMap<String,Token>();
    while (allocatedContainerCount < containersRequestedAny && iterationsLeft-- > 0) {
      AllocateResponse allocResponse=amClient.allocate(0.1f);
      assertEquals(0,amClient.ask.size());
      assertEquals(0,amClient.release.size());
      assertEquals(nodeCount,amClient.getClusterNodeCount());
      allocatedContainerCount+=allocResponse.getAllocatedContainers().size();
      for (      Container container : allocResponse.getAllocatedContainers()) {
        ContainerId rejectContainerId=container.getId();
        releases.add(rejectContainerId);
        amClient.releaseAssignedContainer(rejectContainerId);
      }
      for (      NMToken token : allocResponse.getNMTokens()) {
        String nodeID=token.getNodeId().toString();
        if (receivedNMTokens.containsKey(nodeID)) {
          fail("Received token again for : " + nodeID);
        }
        receivedNMTokens.put(nodeID,token.getToken());
      }
      if (allocatedContainerCount < containersRequestedAny) {
        triggerSchedulingWithNMHeartBeat();
      }
    }
    assertTrue(receivedNMTokens.size() > 0 && receivedNMTokens.size() <= nodeCount);
    assertEquals(allocatedContainerCount,containersRequestedAny);
    assertEquals(2,releases.size());
    assertEquals(0,amClient.ask.size());
    amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    assertEquals(3,amClient.ask.size());
    ResourceRequest snoopRequest=amClient.ask.iterator().next();
    assertEquals(0,snoopRequest.getNumContainers());
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    snoopRequest=amClient.ask.iterator().next();
    assertEquals(2,snoopRequest.getNumContainers());
    ApplicationMasterProtocol realRM=amClient.rmClient;
    try {
      ApplicationMasterProtocol mockRM=mock(ApplicationMasterProtocol.class);
      when(mockRM.allocate(any(AllocateRequest.class))).thenAnswer(new Answer<AllocateResponse>(){
        public AllocateResponse answer(        InvocationOnMock invocation) throws Exception {
          amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
          amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
          throw new Exception();
        }
      }
);
      amClient.rmClient=mockRM;
      amClient.allocate(0.1f);
    }
 catch (    Exception ioe) {
    }
 finally {
      amClient.rmClient=realRM;
    }
    assertEquals(2,amClient.release.size());
    assertEquals(3,amClient.ask.size());
    snoopRequest=amClient.ask.iterator().next();
    assertEquals(0,snoopRequest.getNumContainers());
    waitForContainerCompletion(3,amClient,releases);
  }
  private void waitForContainerCompletion(  int numIterations,  AMRMClientImpl<ContainerRequest> amClient,  Set<ContainerId> releases) throws YarnException, IOException {
    while (!releases.isEmpty() || numIterations-- > 0) {
      AllocateResponse allocResponse=amClient.allocate(0.1f);
      assertEquals(0,allocResponse.getAllocatedContainers().size());
      if (allocResponse.getCompletedContainersStatuses().size() > 0) {
        for (        ContainerStatus cStatus : allocResponse.getCompletedContainersStatuses()) {
          if (releases.contains(cStatus.getContainerId())) {
            assertEquals(cStatus.getState(),ContainerState.COMPLETE);
            assertEquals(-100,cStatus.getExitStatus());
            releases.remove(cStatus.getContainerId());
          }
        }
      }
      if (numIterations > 0) {
        triggerSchedulingWithNMHeartBeat();
      }
    }
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
  }
  private void testAllocRequestId(  final AMRMClientImpl<ContainerRequest> amClient) throws YarnException, IOException {
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority,1));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority,1));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority,2));
    amClient.addContainerRequest(new ContainerRequest(capability,nodes,racks,priority,2));
    amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority));
    amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority,1));
    amClient.removeContainerRequest(new ContainerRequest(capability,nodes,racks,priority,2));
    assertNumContainers(amClient,0,1,1,1,9,0);
    assertNumContainers(amClient,1,1,1,1,9,0);
    assertNumContainers(amClient,2,1,1,1,9,0);
    int containersRequestedAny=3;
    List<Container> allocatedContainers=new ArrayList<>();
    int iterationsLeft=5;
    Set<ContainerId> releases=new TreeSet<ContainerId>();
    while (allocatedContainers.size() < containersRequestedAny && iterationsLeft-- > 0) {
      AllocateResponse allocResponse=amClient.allocate(0.1f);
      assertEquals(0,amClient.ask.size());
      assertEquals(0,amClient.release.size());
      allocatedContainers.addAll(allocResponse.getAllocatedContainers());
      for (      Container container : allocResponse.getAllocatedContainers()) {
        ContainerId rejectContainerId=container.getId();
        releases.add(rejectContainerId);
        amClient.releaseAssignedContainer(rejectContainerId);
      }
      if (allocatedContainers.size() < containersRequestedAny) {
        triggerSchedulingWithNMHeartBeat();
      }
    }
    assertEquals(containersRequestedAny,allocatedContainers.size());
    Set<Long> expAllocIds=new HashSet<>(Arrays.asList(Long.valueOf(0),Long.valueOf(1),Long.valueOf(2)));
    Set<Long> actAllocIds=new HashSet<>();
    for (    Container ac : allocatedContainers) {
      actAllocIds.add(Long.valueOf(ac.getAllocationRequestId()));
    }
    assertEquals(expAllocIds,actAllocIds);
    assertEquals(3,amClient.release.size());
    assertEquals(0,amClient.ask.size());
    waitForContainerCompletion(3,amClient,releases);
  }
  private void assertNumContainers(  AMRMClientImpl<ContainerRequest> amClient,  long allocationReqId,  int expNode,  int expRack,  int expAny,  int expAsks,  int expRelease){
    RemoteRequestsTable<ContainerRequest> remoteRequestsTable=amClient.getTable(allocationReqId);
    int containersRequestedNode=remoteRequestsTable.get(priority,node,ExecutionType.GUARANTEED,capability).remoteRequest.getNumContainers();
    int containersRequestedRack=remoteRequestsTable.get(priority,rack,ExecutionType.GUARANTEED,capability).remoteRequest.getNumContainers();
    int containersRequestedAny=remoteRequestsTable.get(priority,ResourceRequest.ANY,ExecutionType.GUARANTEED,capability).remoteRequest.getNumContainers();
    assertEquals(expNode,containersRequestedNode);
    assertEquals(expRack,containersRequestedRack);
    assertEquals(expAny,containersRequestedAny);
    assertEquals(expAsks,amClient.ask.size());
    assertEquals(expRelease,amClient.release.size());
  }
class CountDownSupplier implements Supplier<Boolean> {
    int counter=0;
    @Override public Boolean get(){
      counter++;
      if (counter >= 3) {
        return true;
      }
 else {
        return false;
      }
    }
  }
  @Test public void testWaitFor() throws InterruptedException {
    AMRMClientImpl<ContainerRequest> amClient=null;
    CountDownSupplier countDownChecker=new CountDownSupplier();
    try {
      amClient=(AMRMClientImpl<ContainerRequest>)AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(new YarnConfiguration());
      amClient.start();
      amClient.waitFor(countDownChecker,1000);
      assertEquals(3,countDownChecker.counter);
    }
  finally {
      if (amClient != null) {
        amClient.stop();
      }
    }
  }
  private void sleep(  int sleepTime){
    try {
      Thread.sleep(sleepTime);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  @Test(timeout=60000) public void testAMRMClientOnAMRMTokenRollOver() throws YarnException, IOException {
    AMRMClient<ContainerRequest> amClient=null;
    try {
      AMRMTokenSecretManager amrmTokenSecretManager=yarnCluster.getResourceManager().getRMContext().getAMRMTokenSecretManager();
      amClient=AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(conf);
      amClient.start();
      Long startTime=System.currentTimeMillis();
      amClient.registerApplicationMaster("Host",10000,"");
      org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> amrmToken_1=getAMRMToken();
      Assert.assertNotNull(amrmToken_1);
      assertEquals(amrmToken_1.decodeIdentifier().getKeyId(),amrmTokenSecretManager.getMasterKey().getMasterKey().getKeyId());
      while (System.currentTimeMillis() - startTime < rollingIntervalSec * 1000) {
        amClient.allocate(0.1f);
        sleep(1000);
      }
      amClient.allocate(0.1f);
      org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> amrmToken_2=getAMRMToken();
      Assert.assertNotNull(amrmToken_2);
      assertEquals(amrmToken_2.decodeIdentifier().getKeyId(),amrmTokenSecretManager.getMasterKey().getMasterKey().getKeyId());
      Assert.assertNotEquals(amrmToken_1,amrmToken_2);
      AllocateResponse response=amClient.allocate(0.1f);
      UserGroupInformation testUser1=UserGroupInformation.createRemoteUser("testUser1");
      AMRMTokenIdentifierForTest newVersionTokenIdentifier=new AMRMTokenIdentifierForTest(amrmToken_2.decodeIdentifier(),"message");
      assertEquals("Message is changed after set to newVersionTokenIdentifier","message",newVersionTokenIdentifier.getMessage());
      org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> newVersionToken=new org.apache.hadoop.security.token.Token<AMRMTokenIdentifier>(newVersionTokenIdentifier.getBytes(),amrmTokenSecretManager.retrievePassword(newVersionTokenIdentifier),newVersionTokenIdentifier.getKind(),new Text());
      SecurityUtil.setTokenService(newVersionToken,yarnCluster.getResourceManager().getApplicationMasterService().getBindAddress());
      testUser1.addToken(newVersionToken);
      AllocateRequest request=Records.newRecord(AllocateRequest.class);
      request.setResponseId(response.getResponseId());
      testUser1.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
        @Override public ApplicationMasterProtocol run(){
          return (ApplicationMasterProtocol)YarnRPC.create(conf).getProxy(ApplicationMasterProtocol.class,yarnCluster.getResourceManager().getApplicationMasterService().getBindAddress(),conf);
        }
      }
).allocate(request);
      while (true) {
        if (amrmToken_2.decodeIdentifier().getKeyId() != amrmTokenSecretManager.getCurrnetMasterKeyData().getMasterKey().getKeyId()) {
          if (amrmTokenSecretManager.getNextMasterKeyData() == null) {
            break;
          }
 else           if (amrmToken_2.decodeIdentifier().getKeyId() != amrmTokenSecretManager.getNextMasterKeyData().getMasterKey().getKeyId()) {
            break;
          }
        }
        amClient.allocate(0.1f);
        sleep(1000);
      }
      try {
        UserGroupInformation testUser2=UserGroupInformation.createRemoteUser("testUser2");
        SecurityUtil.setTokenService(amrmToken_2,yarnCluster.getResourceManager().getApplicationMasterService().getBindAddress());
        testUser2.addToken(amrmToken_2);
        testUser2.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
          @Override public ApplicationMasterProtocol run(){
            return (ApplicationMasterProtocol)YarnRPC.create(conf).getProxy(ApplicationMasterProtocol.class,yarnCluster.getResourceManager().getApplicationMasterService().getBindAddress(),conf);
          }
        }
).allocate(Records.newRecord(AllocateRequest.class));
        fail("The old Token should not work");
      }
 catch (      Exception ex) {
        assertTrue(ex instanceof InvalidToken);
        assertTrue(ex.getMessage().contains("Invalid AMRMToken from " + amrmToken_2.decodeIdentifier().getApplicationAttemptId()));
      }
      amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
    }
  finally {
      if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
        amClient.stop();
      }
    }
  }
  @SuppressWarnings("unchecked") private org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> getAMRMToken() throws IOException {
    Credentials credentials=UserGroupInformation.getCurrentUser().getCredentials();
    Iterator<org.apache.hadoop.security.token.Token<?>> iter=credentials.getAllTokens().iterator();
    org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> result=null;
    while (iter.hasNext()) {
      org.apache.hadoop.security.token.Token<?> token=iter.next();
      if (token.getKind().equals(AMRMTokenIdentifier.KIND_NAME)) {
        if (result != null) {
          fail("credentials has more than one AMRM token." + " token1: " + result + " token2: "+ token);
        }
        result=(org.apache.hadoop.security.token.Token<AMRMTokenIdentifier>)token;
      }
    }
    return result;
  }
  @Test(timeout=60000) public void testGetMatchingFitWithProfiles() throws Exception {
    teardown();
    conf.setBoolean(YarnConfiguration.RM_RESOURCE_PROFILES_ENABLED,true);
    createClusterAndStartApplication(conf);
    AMRMClient<ContainerRequest> amClient=null;
    try {
      amClient=AMRMClient.<ContainerRequest>createAMRMClient();
      amClient.init(conf);
      amClient.start();
      amClient.registerApplicationMaster("Host",10000,"");
      ContainerRequest storedContainer1=new ContainerRequest(Resource.newInstance(0,0),nodes,racks,priority,"minimum");
      ContainerRequest storedContainer2=new ContainerRequest(Resource.newInstance(0,0),nodes,racks,priority,"default");
      ContainerRequest storedContainer3=new ContainerRequest(Resource.newInstance(0,0),nodes,racks,priority,"maximum");
      ContainerRequest storedContainer4=new ContainerRequest(Resource.newInstance(2048,1),nodes,racks,priority,"minimum");
      ContainerRequest storedContainer5=new ContainerRequest(Resource.newInstance(2048,1),nodes,racks,priority2,"default");
      ContainerRequest storedContainer6=new ContainerRequest(Resource.newInstance(2048,1),nodes,racks,priority,"default");
      ContainerRequest storedContainer7=new ContainerRequest(Resource.newInstance(0,0),nodes,racks,priority,"http");
      amClient.addContainerRequest(storedContainer1);
      amClient.addContainerRequest(storedContainer2);
      amClient.addContainerRequest(storedContainer3);
      amClient.addContainerRequest(storedContainer4);
      amClient.addContainerRequest(storedContainer5);
      amClient.addContainerRequest(storedContainer6);
      amClient.addContainerRequest(storedContainer7);
      List<? extends Collection<ContainerRequest>> matches;
      ContainerRequest storedRequest;
      matches=amClient.getMatchingRequests(priority,node,ExecutionType.GUARANTEED,Resource.newInstance(0,0),"minimum");
      verifyMatches(matches,1);
      storedRequest=matches.get(0).iterator().next();
      assertEquals(storedContainer1,storedRequest);
      amClient.removeContainerRequest(storedContainer1);
      matches=amClient.getMatchingRequests(priority,node,ExecutionType.GUARANTEED,Resource.newInstance(0,0),"default");
      verifyMatches(matches,2);
      int i=0;
      for (      ContainerRequest storedRequest1 : matches.get(0)) {
switch (i) {
case 0:
          assertEquals(storedContainer2,storedRequest1);
        break;
case 1:
      assertEquals(storedContainer7,storedRequest1);
    break;
}
i++;
}
amClient.removeContainerRequest(storedContainer5);
Resource testCapability3=Resource.newInstance(8192,8);
matches=amClient.getMatchingRequests(priority,node,testCapability3);
assertEquals(3,matches.size());
Resource testCapability4=Resource.newInstance(2048,1);
matches=amClient.getMatchingRequests(priority,node,testCapability4);
assertEquals(1,matches.size());
}
  finally {
if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
amClient.stop();
}
}
}
@Test(timeout=60000) public void testNoUpdateTrackingUrl(){
try {
AMRMClientImpl<ContainerRequest> amClient=null;
amClient=new AMRMClientImpl<>();
amClient.init(conf);
amClient.start();
amClient.registerApplicationMaster("Host",10000,"");
assertEquals("",amClient.appTrackingUrl);
ApplicationMasterProtocol mockRM=mock(ApplicationMasterProtocol.class);
AllocateResponse mockResponse=mock(AllocateResponse.class);
when(mockRM.allocate(any(AllocateRequest.class))).thenReturn(mockResponse);
ApplicationMasterProtocol realRM=amClient.rmClient;
amClient.rmClient=mockRM;
amClient.allocate(0.1f);
ArgumentCaptor<AllocateRequest> argument=ArgumentCaptor.forClass(AllocateRequest.class);
verify(mockRM).allocate(argument.capture());
assertNull(argument.getValue().getTrackingUrl());
amClient.rmClient=realRM;
amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
}
 catch (IOException|YarnException e) {
throw new AssertionError("testNoUpdateTrackingUrl unexpectedly threw exception: " + e);
}
}
@Test(timeout=60000) public void testUpdateTrackingUrl(){
try {
AMRMClientImpl<ContainerRequest> amClient=null;
amClient=new AMRMClientImpl<>();
amClient.init(conf);
amClient.start();
amClient.registerApplicationMaster("Host",10000,"");
String trackingUrl="hadoop.apache.org";
assertEquals("",amClient.appTrackingUrl);
ApplicationMasterProtocol mockRM=mock(ApplicationMasterProtocol.class);
AllocateResponse mockResponse=mock(AllocateResponse.class);
when(mockRM.allocate(any(AllocateRequest.class))).thenReturn(mockResponse);
ApplicationMasterProtocol realRM=amClient.rmClient;
amClient.rmClient=mockRM;
amClient.updateTrackingUrl(trackingUrl);
assertEquals(trackingUrl,amClient.newTrackingUrl);
assertEquals("",amClient.appTrackingUrl);
amClient.allocate(0.1f);
assertNull(amClient.newTrackingUrl);
assertEquals(trackingUrl,amClient.appTrackingUrl);
ArgumentCaptor<AllocateRequest> argument=ArgumentCaptor.forClass(AllocateRequest.class);
verify(mockRM).allocate(argument.capture());
assertEquals(trackingUrl,argument.getValue().getTrackingUrl());
amClient.rmClient=realRM;
amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
}
 catch (IOException|YarnException e) {
throw new AssertionError("testUpdateTrackingUrl unexpectedly threw exception: " + e);
}
}
}
