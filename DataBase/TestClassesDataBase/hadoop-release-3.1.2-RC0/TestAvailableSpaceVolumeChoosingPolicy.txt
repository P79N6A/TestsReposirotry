public class TestAvailableSpaceVolumeChoosingPolicy {
  private static final int RANDOMIZED_ITERATIONS=10000;
  private static final float RANDOMIZED_ERROR_PERCENT=0.05f;
  private static final long RANDOMIZED_ALLOWED_ERROR=(long)(RANDOMIZED_ERROR_PERCENT * RANDOMIZED_ITERATIONS);
  private static void initPolicy(  VolumeChoosingPolicy<FsVolumeSpi> policy,  float preferencePercent){
    Configuration conf=new Configuration();
    conf.setLong(DFS_DATANODE_AVAILABLE_SPACE_VOLUME_CHOOSING_POLICY_BALANCED_SPACE_THRESHOLD_KEY,1024 * 1024);
    conf.setFloat(DFS_DATANODE_AVAILABLE_SPACE_VOLUME_CHOOSING_POLICY_BALANCED_SPACE_PREFERENCE_FRACTION_KEY,preferencePercent);
    ((Configurable)policy).setConf(conf);
  }
  @Test(timeout=60000) public void testRR() throws Exception {
    @SuppressWarnings("unchecked") final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=ReflectionUtils.newInstance(AvailableSpaceVolumeChoosingPolicy.class,null);
    initPolicy(policy,1.0f);
    TestRoundRobinVolumeChoosingPolicy.testRR(policy);
  }
  @Test(timeout=60000) public void testRRPolicyExceptionMessage() throws Exception {
    final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=new AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi>();
    initPolicy(policy,1.0f);
    TestRoundRobinVolumeChoosingPolicy.testRRPolicyExceptionMessage(policy);
  }
  @Test(timeout=60000) public void testTwoUnbalancedVolumes() throws Exception {
    @SuppressWarnings("unchecked") final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=ReflectionUtils.newInstance(AvailableSpaceVolumeChoosingPolicy.class,null);
    initPolicy(policy,1.0f);
    List<FsVolumeSpi> volumes=new ArrayList<FsVolumeSpi>();
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(0).getAvailable()).thenReturn(1024L * 1024L);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(1).getAvailable()).thenReturn(1024L * 1024L * 3);
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
  }
  @Test(timeout=60000) public void testThreeUnbalancedVolumes() throws Exception {
    @SuppressWarnings("unchecked") final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=ReflectionUtils.newInstance(AvailableSpaceVolumeChoosingPolicy.class,null);
    List<FsVolumeSpi> volumes=new ArrayList<FsVolumeSpi>();
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(0).getAvailable()).thenReturn(1024L * 1024L);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(1).getAvailable()).thenReturn(1024L * 1024L * 3);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(2).getAvailable()).thenReturn(1024L * 1024L * 3);
    initPolicy(policy,1.0f);
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(2),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(2),policy.chooseVolume(volumes,100,null));
    initPolicy(policy,0.0f);
    Assert.assertEquals(volumes.get(0),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(0),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(0),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(0),policy.chooseVolume(volumes,100,null));
  }
  @Test(timeout=60000) public void testFourUnbalancedVolumes() throws Exception {
    @SuppressWarnings("unchecked") final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=ReflectionUtils.newInstance(AvailableSpaceVolumeChoosingPolicy.class,null);
    List<FsVolumeSpi> volumes=new ArrayList<FsVolumeSpi>();
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(0).getAvailable()).thenReturn(1024L * 1024L);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(1).getAvailable()).thenReturn(1024L * 1024L + 1);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(2).getAvailable()).thenReturn(1024L * 1024L * 3);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(3).getAvailable()).thenReturn(1024L * 1024L * 3);
    initPolicy(policy,1.0f);
    Assert.assertEquals(volumes.get(2),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(3),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(2),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(3),policy.chooseVolume(volumes,100,null));
    initPolicy(policy,0.0f);
    Assert.assertEquals(volumes.get(0),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(0),policy.chooseVolume(volumes,100,null));
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
  }
  @Test(timeout=60000) public void testNotEnoughSpaceOnSelectedVolume() throws Exception {
    @SuppressWarnings("unchecked") final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=ReflectionUtils.newInstance(AvailableSpaceVolumeChoosingPolicy.class,null);
    List<FsVolumeSpi> volumes=new ArrayList<FsVolumeSpi>();
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(0).getAvailable()).thenReturn(1024L * 1024L);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(1).getAvailable()).thenReturn(1024L * 1024L * 3);
    initPolicy(policy,0.0f);
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,1024L * 1024L * 2,null));
  }
  @Test(timeout=60000) public void testAvailableSpaceChanges() throws Exception {
    @SuppressWarnings("unchecked") final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=ReflectionUtils.newInstance(AvailableSpaceVolumeChoosingPolicy.class,null);
    initPolicy(policy,1.0f);
    List<FsVolumeSpi> volumes=new ArrayList<FsVolumeSpi>();
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(0).getAvailable()).thenReturn(1024L * 1024L);
    volumes.add(Mockito.mock(FsVolumeSpi.class));
    Mockito.when(volumes.get(1).getAvailable()).thenReturn(1024L * 1024L * 3).thenReturn(1024L * 1024L * 3).thenReturn(1024L * 1024L * 3).thenReturn(1024L * 1024L * 1);
    Assert.assertEquals(volumes.get(1),policy.chooseVolume(volumes,100,null));
  }
  @Test(timeout=60000) public void randomizedTest1() throws Exception {
    doRandomizedTest(0.75f,1,1);
  }
  @Test(timeout=60000) public void randomizedTest2() throws Exception {
    doRandomizedTest(0.75f,5,1);
  }
  @Test(timeout=60000) public void randomizedTest3() throws Exception {
    doRandomizedTest(0.75f,1,5);
  }
  @Test(timeout=60000) public void randomizedTest4() throws Exception {
    doRandomizedTest(0.90f,5,1);
  }
  public void doRandomizedTest(  float preferencePercent,  int lowSpaceVolumes,  int highSpaceVolumes) throws Exception {
    Random random=new Random(123L);
    final AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi> policy=new AvailableSpaceVolumeChoosingPolicy<FsVolumeSpi>(random);
    List<FsVolumeSpi> volumes=new ArrayList<FsVolumeSpi>();
    for (int i=0; i < lowSpaceVolumes; i++) {
      FsVolumeSpi volume=Mockito.mock(FsVolumeSpi.class);
      Mockito.when(volume.getAvailable()).thenReturn(1024L * 1024L);
      volumes.add(volume);
    }
    for (int i=0; i < highSpaceVolumes; i++) {
      FsVolumeSpi volume=Mockito.mock(FsVolumeSpi.class);
      Mockito.when(volume.getAvailable()).thenReturn(1024L * 1024L * 3);
      volumes.add(volume);
    }
    initPolicy(policy,preferencePercent);
    long lowAvailableSpaceVolumeSelected=0;
    long highAvailableSpaceVolumeSelected=0;
    for (int i=0; i < RANDOMIZED_ITERATIONS; i++) {
      FsVolumeSpi volume=policy.chooseVolume(volumes,100,null);
      for (int j=0; j < volumes.size(); j++) {
        if (volume == volumes.get(j) && j == 0) {
          lowAvailableSpaceVolumeSelected++;
        }
        if (volume == volumes.get(j) && j == lowSpaceVolumes) {
          highAvailableSpaceVolumeSelected++;
          break;
        }
      }
    }
    float expectedSelectionRatio=preferencePercent / (1 - preferencePercent);
    GenericTestUtils.assertValueNear((long)(lowAvailableSpaceVolumeSelected * expectedSelectionRatio),highAvailableSpaceVolumeSelected,RANDOMIZED_ALLOWED_ERROR);
  }
}
