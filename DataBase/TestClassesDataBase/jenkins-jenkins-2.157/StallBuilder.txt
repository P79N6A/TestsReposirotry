public static class StallBuilder extends TestBuilder {
  private int syncBuildNumber;
  private final Object syncLock=new Object();
  private int waitBuildNumber;
  private final Object waitLock=new Object();
  private final ArtifactArchiver archiver=new ArtifactArchiver("f");
  public @Override boolean perform(  AbstractBuild<?,?> build,  Launcher launcher,  BuildListener listener) throws IOException, InterruptedException {
    archiver.perform(build,launcher,listener);
    Logger.getAnonymousLogger().log(Level.INFO,"Building #{0}",build.getNumber());
synchronized (waitLock) {
      if (waitBuildNumber < build.getNumber()) {
        waitBuildNumber=build.getNumber();
        waitLock.notifyAll();
      }
    }
    Logger.getAnonymousLogger().log(Level.INFO,"Waiting #{0}",build.getNumber());
synchronized (syncLock) {
      while (build.getNumber() > syncBuildNumber) {
        try {
          syncLock.wait(10);
        }
 catch (        InterruptedException e) {
          e.printStackTrace(listener.fatalError("Interrupted: %s",e.getMessage()));
          return false;
        }
      }
    }
    Logger.getAnonymousLogger().log(Level.INFO,"Done #{0}",build.getNumber());
    return true;
  }
  public void release(  int upToBuildNumber){
synchronized (syncLock) {
      if (syncBuildNumber < upToBuildNumber) {
        Logger.getAnonymousLogger().log(Level.INFO,"Signal #{0}",upToBuildNumber);
        syncBuildNumber=upToBuildNumber;
        syncLock.notifyAll();
      }
    }
  }
  public void waitFor(  int buildNumber,  long timeout,  TimeUnit units) throws TimeoutException, InterruptedException {
    long giveUp=System.nanoTime() + units.toNanos(timeout);
synchronized (waitLock) {
      while (waitBuildNumber < buildNumber) {
        long remaining=giveUp - System.nanoTime();
        if (remaining < 0) {
          throw new TimeoutException();
        }
        waitLock.wait(remaining / 1000000L,(int)(remaining % 1000000L));
      }
    }
  }
  public BuildStepMonitor getRequiredMonitorService(){
    return BuildStepMonitor.NONE;
  }
}
