public class SecretTest {
  @Rule public ConfidentialStoreRule confidentialStore=new ConfidentialStoreRule();
  @Rule public MockSecretRule mockSecretRule=new MockSecretRule();
  private static final Pattern ENCRYPTED_VALUE_PATTERN=Pattern.compile("\\{?[A-Za-z0-9+/]+={0,2}}?");
  @Test public void encrypt(){
    Secret secret=Secret.fromString("abc");
    assertEquals("abc",secret.getPlainText());
    assertNotEquals("abc",secret.getEncryptedValue());
    assertEquals(secret,Secret.fromString(secret.getEncryptedValue()));
    assertEquals(secret.getEncryptedValue(),secret.getEncryptedValue());
    assertNotEquals(secret.getEncryptedValue(),Secret.fromString(secret.getPlainText()).getEncryptedValue());
  }
  @Test public void encryptedValuePattern(){
    for (int i=1; i < 100; i++) {
      String plaintext=RandomStringUtils.random(new Random().nextInt(i));
      String ciphertext=Secret.fromString(plaintext).getEncryptedValue();
      assert ENCRYPTED_VALUE_PATTERN.matcher(ciphertext).matches();
    }
    assert !ENCRYPTED_VALUE_PATTERN.matcher("hello world").matches();
    assert !ENCRYPTED_VALUE_PATTERN.matcher("helloworld!").matches();
    assert ENCRYPTED_VALUE_PATTERN.matcher("abcdefghijklmnopqr0123456789").matches();
    assert ENCRYPTED_VALUE_PATTERN.matcher("abcdefghijklmnopqr012345678==").matches();
  }
  @Test public void decrypt(){
    assertEquals("abc",Secret.toString(Secret.fromString("abc")));
  }
  @Test public void serialization(){
    Secret s=Secret.fromString("Mr.Jenkins");
    String xml=Jenkins.XSTREAM.toXML(s);
    assertThat(xml,not(containsString(s.getPlainText())));
    assertTrue(xml,xml.matches("<hudson[.]util[.]Secret>[{][A-Za-z0-9+/]+={0,2}[}]</hudson[.]util[.]Secret>"));
    Object o=Jenkins.XSTREAM.fromXML(xml);
    assertEquals(xml,s,o);
  }
public static class Foo {
    Secret password;
  }
  /** 
 * Makes sure the serialization form is backward compatible with String.
 */
  @Test public void testCompatibilityFromString(){
    String tagName=Foo.class.getName().replace("$","_-");
    String xml="<" + tagName + "><password>secret</password></"+ tagName+ ">";
    Foo foo=new Foo();
    Jenkins.XSTREAM.fromXML(xml,foo);
    assertEquals("secret",Secret.toString(foo.password));
  }
  /** 
 * Secret persisted with Jenkins.getSecretKey() should still decrypt OK.
 */
  @Test public void migrationFromLegacyKeyToConfidentialStore() throws Exception {
    SecretKey legacy=HistoricalSecrets.getLegacyKey();
    for (    String str : new String[]{"Hello world","","\u0000unprintable"}) {
      Cipher cipher=Secret.getCipher("AES");
      cipher.init(Cipher.ENCRYPT_MODE,legacy);
      String old=new String(Base64.encode(cipher.doFinal((str + HistoricalSecrets.MAGIC).getBytes("UTF-8"))));
      Secret s=Secret.fromString(old);
      assertEquals("secret by the old key should decrypt",str,s.getPlainText());
      assertNotEquals("but when encrypting, ConfidentialKey should be in use",old,s.getEncryptedValue());
    }
  }
}
