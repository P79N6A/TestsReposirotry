/** 
 * @author Kohsuke Kawaguchi
 */
public class LoadPredictorTest {
  @Rule public JenkinsRule j=new JenkinsRule();
@TestExtension public static class LoadPredictorImpl extends LoadPredictor {
    @Override public Iterable<FutureLoad> predict(    MappingWorksheet plan,    Computer computer,    long start,    long end){
      return asList(new FutureLoad(start + 5000,end - (start + 5000),1));
    }
  }
  /** 
 * Makes sure that  {@link LoadPredictor} is taken into account when building {@link MappingWorksheet}. The scenario is: - a computer with 1 executor, idle. - a future load of size 1 is predicted - hence the consideration of the current task at hand shall fail, as it'll collide with the estimated future load.
 */
  @Test public void test1() throws Exception {
    Task t=mock(Task.class);
    when(t.getEstimatedDuration()).thenReturn(10000L);
    when(t.getSubTasks()).thenReturn((Collection)asList(t));
    Computer c=createMockComputer(1);
    JobOffer o=createMockOffer(c.getExecutors().get(0));
    MappingWorksheet mw=new MappingWorksheet(wrap(t),asList(o));
    assertTrue(mw.executors.isEmpty());
    assertEquals(1,mw.works.size());
  }
  private BuildableItem wrap(  Queue.Task t){
    return new BuildableItem(new WaitingItem(new GregorianCalendar(),t,new ArrayList<Action>()));
  }
  /** 
 * Test scenario is: - a computer with two executors, one is building something now - a future load of size 1 is predicted but it'll start after the currently building something is completed. - hence the currently available executor should be considered available (unlike in test1)
 */
  @Test public void test2() throws Exception {
    Task t=mock(Task.class);
    when(t.getEstimatedDuration()).thenReturn(10000L);
    when(t.getSubTasks()).thenReturn((Collection)asList(t));
    Computer c=createMockComputer(2);
    Executor e=c.getExecutors().get(0);
    when(e.isIdle()).thenReturn(false);
    when(e.getEstimatedRemainingTimeMillis()).thenReturn(300L);
    JobOffer o=createMockOffer(c.getExecutors().get(1));
    MappingWorksheet mw=new MappingWorksheet(wrap(t),asList(o));
    assertEquals(1,mw.executors.size());
    assertEquals(1,mw.works.size());
  }
  private JobOffer createMockOffer(  Executor e) throws NoSuchFieldException, IllegalAccessException {
    JobOffer o=mock(JobOffer.class);
    when(o.getExecutor()).thenReturn(e);
    return o;
  }
  private Computer createMockComputer(  int nExecutors) throws Exception {
    Node n=mock(Node.class);
    Computer c=mock(Computer.class);
    when(c.getNode()).thenReturn(n);
    List executors=new CopyOnWriteArrayList();
    for (int i=0; i < nExecutors; i++) {
      Executor e=mock(Executor.class);
      when(e.isIdle()).thenReturn(true);
      when(e.getOwner()).thenReturn(c);
      executors.add(e);
    }
    Field f=Computer.class.getDeclaredField("executors");
    f.setAccessible(true);
    f.set(c,executors);
    when(c.getExecutors()).thenReturn(executors);
    return c;
  }
}
