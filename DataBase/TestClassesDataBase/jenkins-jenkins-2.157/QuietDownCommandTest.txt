public class QuietDownCommandTest {
  private CLICommandInvoker command;
  private final static QueueTest.TestFlyweightTask task=new QueueTest.TestFlyweightTask(new AtomicInteger(),null);
  @Rule public final JenkinsRule j=new JenkinsRule();
  @Before public void setUp(){
    command=new CLICommandInvoker(j,"quiet-down");
  }
  @Test public void quietDownShouldFailWithoutAdministerPermission() throws Exception {
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ).invoke();
    assertThat(result,failedWith(6));
    assertThat(result,hasNoStandardOutput());
    assertThat(result.stderr(),containsString("ERROR: user is missing the Overall/Administer permission"));
  }
  @Test public void quietDownShouldSuccess() throws Exception {
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invoke();
    assertThat(result,succeededSilently());
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlock() throws Exception {
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block");
    assertThat(result,succeededSilently());
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithTimeout() throws Exception {
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-timeout","0");
    assertThat(result,succeededSilently());
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockAndTimeout() throws Exception {
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block","-timeout","0");
    assertThat(result,succeededSilently());
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldFailWithEmptyTimeout() throws Exception {
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-timeout");
    assertThat(result,failedWith(2));
    assertThat(result,hasNoStandardOutput());
    assertThat(result.stderr(),containsString("ERROR: Option \"-timeout\" takes an operand"));
  }
  @Test public void quietDownShouldSuccessOnAlreadyQuietDownedJenkins() throws Exception {
    j.jenkins.getActiveInstance().doQuietDown();
    assertJenkinsInQuietMode();
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invoke();
    assertThat(result,succeededSilently());
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockOnAlreadyQuietDownedJenkins() throws Exception {
    j.jenkins.getActiveInstance().doQuietDown(true,0);
    assertJenkinsInQuietMode();
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block");
    assertThat(result,succeededSilently());
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockAndTimeoutOnAlreadyQuietDownedJenkins() throws Exception {
    j.jenkins.getActiveInstance().doQuietDown(true,0);
    assertJenkinsInQuietMode();
    final long time_before=System.currentTimeMillis();
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block","-timeout","20000");
    assertThat(result,succeededSilently());
    assertThat(System.currentTimeMillis() < time_before + 20000,equalTo(true));
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessAndRunningExecutor() throws Exception {
    final FreeStyleProject project=j.createFreeStyleProject("aProject");
    final OneShotEvent finish=new OneShotEvent();
    final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invoke();
    assertThat(result,succeededSilently());
    assertJenkinsInQuietMode();
    finish.signal();
    build.get();
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    assertThat(project.isBuilding(),equalTo(false));
    j.assertBuildStatusSuccess(build);
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockAndRunningExecutor() throws Exception {
    final FreeStyleProject project=j.createFreeStyleProject("aProject");
    final ExecutorService threadPool=Executors.newSingleThreadExecutor();
    final OneShotEvent beforeCli=new OneShotEvent();
    final OneShotEvent finish=new OneShotEvent();
    final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    boolean timeoutOccurred=false;
    final FutureTask exec_task=new FutureTask(new Callable(){
      public Object call(){
        assertJenkinsNotInQuietMode();
        beforeCli.signal();
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block");
        fail("Should never return from previous CLI call!");
        return null;
      }
    }
);
    try {
      threadPool.submit(exec_task);
      beforeCli.block();
      assertJenkinsInQuietMode();
      exec_task.get(10,TimeUnit.SECONDS);
    }
 catch (    TimeoutException e) {
      timeoutOccurred=true;
    }
    if (!timeoutOccurred)     fail("Missing timeout for CLI call");
    finish.signal();
    build.get();
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    assertThat(project.isBuilding(),equalTo(false));
    j.assertBuildStatusSuccess(build);
    exec_task.cancel(true);
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockAndZeroTimeoutAndRunningExecutor() throws Exception {
    final FreeStyleProject project=j.createFreeStyleProject("aProject");
    final ExecutorService threadPool=Executors.newSingleThreadExecutor();
    final OneShotEvent beforeCli=new OneShotEvent();
    final OneShotEvent finish=new OneShotEvent();
    final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    boolean timeoutOccurred=false;
    final FutureTask exec_task=new FutureTask(new Callable(){
      public Object call(){
        assertJenkinsNotInQuietMode();
        beforeCli.signal();
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block","-timeout","0");
        fail("Should never return from previous CLI call!");
        return null;
      }
    }
);
    try {
      threadPool.submit(exec_task);
      beforeCli.block();
      assertJenkinsInQuietMode();
      exec_task.get(10,TimeUnit.SECONDS);
    }
 catch (    TimeoutException e) {
      timeoutOccurred=true;
    }
    if (!timeoutOccurred)     fail("Missing timeout for CLI call");
    finish.signal();
    build.get();
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    assertThat(project.isBuilding(),equalTo(false));
    j.assertBuildStatusSuccess(build);
    exec_task.cancel(true);
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockPlusExpiredTimeoutAndRunningExecutor() throws Exception {
    final int TIMEOUT=5000;
    final FreeStyleProject project=j.createFreeStyleProject("aProject");
    final ExecutorService threadPool=Executors.newSingleThreadExecutor();
    final OneShotEvent beforeCli=new OneShotEvent();
    final OneShotEvent finish=new OneShotEvent();
    final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    final FutureTask exec_task=new FutureTask(new Callable(){
      public Object call(){
        assertJenkinsNotInQuietMode();
        final long time_before=System.currentTimeMillis();
        beforeCli.signal();
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block","-timeout",Integer.toString(TIMEOUT));
        assertThat(result,succeededSilently());
        assertThat(System.currentTimeMillis() > time_before + TIMEOUT,equalTo(true));
        assertJenkinsInQuietMode();
        return null;
      }
    }
);
    threadPool.submit(exec_task);
    beforeCli.block();
    assertJenkinsInQuietMode();
    try {
      exec_task.get(2 * TIMEOUT,TimeUnit.MILLISECONDS);
    }
 catch (    TimeoutException e) {
      fail("Blocking call didn't finish after timeout!");
    }
    assertThat(exec_task.isDone(),equalTo(true));
    finish.signal();
    build.get();
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    assertThat(project.isBuilding(),equalTo(false));
    j.assertBuildStatusSuccess(build);
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockPlusNonExpiredTimeoutAndRunningExecutor() throws Exception {
    final int TIMEOUT=5000;
    final FreeStyleProject project=j.createFreeStyleProject("aProject");
    final ExecutorService threadPool=Executors.newSingleThreadExecutor();
    final OneShotEvent beforeCli=new OneShotEvent();
    final OneShotEvent finish=new OneShotEvent();
    final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    boolean timeoutOccurred=false;
    final FutureTask exec_task=new FutureTask(new Callable(){
      public Object call(){
        assertJenkinsNotInQuietMode();
        beforeCli.signal();
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block","-timeout",Integer.toString(2 * TIMEOUT));
        fail("Blocking call shouldn't finish, should be killed by called thread!");
        return null;
      }
    }
);
    threadPool.submit(exec_task);
    beforeCli.block();
    assertJenkinsInQuietMode();
    final boolean timeout_occured=false;
    try {
      exec_task.get(TIMEOUT,TimeUnit.MILLISECONDS);
    }
 catch (    TimeoutException e) {
      timeoutOccurred=true;
    }
    if (!timeoutOccurred)     fail("Missing timeout for CLI call");
    finish.signal();
    build.get();
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    assertThat(project.isBuilding(),equalTo(false));
    j.assertBuildStatusSuccess(build);
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockAndFinishingExecutor() throws Exception {
    final FreeStyleProject project=j.createFreeStyleProject("aProject");
    final ExecutorService threadPool=Executors.newSingleThreadExecutor();
    final OneShotEvent beforeCli=new OneShotEvent();
    final OneShotEvent finish=new OneShotEvent();
    final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    boolean timeoutOccurred=false;
    final FutureTask exec_task=new FutureTask(new Callable(){
      public Object call(){
        assertJenkinsNotInQuietMode();
        final long time_before=System.currentTimeMillis();
        beforeCli.signal();
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block");
        assertThat(result,succeededSilently());
        assertThat(System.currentTimeMillis() > time_before + 1000,equalTo(true));
        assertJenkinsInQuietMode();
        return null;
      }
    }
);
    threadPool.submit(exec_task);
    beforeCli.block();
    assertJenkinsInQuietMode();
    finish.signal();
    build.get();
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    assertThat(project.isBuilding(),equalTo(false));
    j.assertBuildStatusSuccess(build);
    assertJenkinsInQuietMode();
    get(exec_task);
    assertJenkinsInQuietMode();
  }
  @Test public void quietDownShouldSuccessWithBlockAndNonExpiredTimeoutAndFinishingExecutor() throws Exception {
    final int TIMEOUT=5000;
    final FreeStyleProject project=j.createFreeStyleProject("aProject");
    final ExecutorService threadPool=Executors.newSingleThreadExecutor();
    final OneShotEvent beforeCli=new OneShotEvent();
    final OneShotEvent finish=new OneShotEvent();
    final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    final FutureTask exec_task=new FutureTask(new Callable(){
      public Object call(){
        assertJenkinsNotInQuietMode();
        final long time_before=System.currentTimeMillis();
        beforeCli.signal();
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block","-timeout",Integer.toString(TIMEOUT));
        assertThat(result,succeededSilently());
        assertThat(System.currentTimeMillis() > time_before + 1000,equalTo(true));
        assertThat(System.currentTimeMillis() < time_before + TIMEOUT,equalTo(true));
        assertJenkinsInQuietMode();
        return null;
      }
    }
);
    threadPool.submit(exec_task);
    beforeCli.block();
    assertJenkinsInQuietMode();
    finish.signal();
    build.get();
    assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
    assertThat(project.isBuilding(),equalTo(false));
    j.assertBuildStatusSuccess(build);
    assertJenkinsInQuietMode();
    get(exec_task);
  }
  /** 
 * Will try to get the result and retry for some time before failing.
 */
  private static void get(  FutureTask exec_task){
    await().atMost(10,TimeUnit.SECONDS).until(exec_task::isDone);
  }
  /** 
 * Asserts if Jenkins is in quiet mode. Will retry for some time before actually failing.
 */
  private final void assertJenkinsInQuietMode(){
    assertJenkinsInQuietMode(j);
  }
  /** 
 * Asserts if Jenkins is <strong>not</strong> in quiet mode. Will retry for some time before actually failing.
 */
  private final void assertJenkinsNotInQuietMode(){
    assertJenkinsNotInQuietMode(j);
  }
  /** 
 * Asserts if Jenkins is in quiet mode, retrying for some time before failing.
 * @throws TimeoutException
 */
  public static final void assertJenkinsInQuietMode(  final JenkinsRule j){
    await().pollInterval(250,TimeUnit.MILLISECONDS).atMost(10,TimeUnit.SECONDS).until(() -> j.jenkins.getActiveInstance().getQueue().isBlockedByShutdown(task));
  }
  /** 
 * Asserts if Jenkins is <strong>not</strong> in quiet mode, retrying for some time before failing.
 * @throws TimeoutException
 */
  public static final void assertJenkinsNotInQuietMode(  final JenkinsRule j){
    await().pollInterval(250,TimeUnit.MILLISECONDS).atMost(10,TimeUnit.SECONDS).until(() -> !j.jenkins.getActiveInstance().getQueue().isBlockedByShutdown(task));
  }
}
