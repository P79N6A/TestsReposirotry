/** 
 * Contains tests for  {@link ProcStarter} class.
 * @author Oleg Nenashev, Synopsys Inc.
 * @since 1.568
 */
public class ProcStarterTest {
  @Rule public JenkinsRule rule=new JenkinsRule();
  @Test @Issue("JENKINS-20559") public void testNonInitializedEnvsNPE() throws Exception {
    rule.jenkins.setNumExecutors(0);
    rule.createSlave();
    FreeStyleProject project=rule.createFreeStyleProject();
    project.getBuildWrappersList().add(new DecoratedWrapper());
    project.getBuildWrappersList().add(new EchoWrapper());
    rule.buildAndAssertSuccess(project);
  }
  @Test @Issue("JENKINS-36277") public void testNonExistingPwd() throws Exception {
    rule.jenkins.setNumExecutors(0);
    rule.createSlave();
    FreeStyleProject project=rule.createFreeStyleProject();
    project.getBuildersList().add(new EchoBuilder());
    FreeStyleBuild run=project.scheduleBuild2(0).get();
    rule.assertBuildStatus(Result.FAILURE,run);
    rule.assertLogContains("java.io.IOException: Process working directory",run);
  }
  /** 
 * A stub descriptor for  {@link BuildWrapper}s.
 */
public abstract static class TestWrapperDescriptor extends BuildWrapperDescriptor {
    @Override public boolean isApplicable(    AbstractProject<?,?> ap){
      return true;
    }
  }
  /** 
 * A wrapper, which contains a nested launch.
 */
public static class EchoWrapper extends BuildWrapper {
    @Override public Environment setUp(    AbstractBuild build,    Launcher launcher,    BuildListener listener) throws IOException, InterruptedException {
      String[] cmds=Functions.isWindows() ? new String[]{"cmd.exe","/C","echo","Hello"} : new String[]{"echo","Hello"};
      Launcher.ProcStarter starter=launcher.launch().cmds(cmds);
      starter.start();
      starter.join();
      return new Environment(){
      }
;
    }
@Extension public static class DescriptorImpl extends TestWrapperDescriptor {
    }
  }
  /** 
 * A wrapper, which decorates launchers.
 */
public static class DecoratedWrapper extends BuildWrapper {
    @Override public Launcher decorateLauncher(    AbstractBuild build,    Launcher launcher,    BuildListener listener) throws IOException, InterruptedException, Run.RunnerAbortedException {
      final BuildListener l=listener;
      return new DecoratedLauncher(launcher){
        @Override public Proc launch(        Launcher.ProcStarter starter) throws IOException {
          String[] envs=starter.envs();
          l.getLogger().println("[DecoratedWrapper]: Number of environment variables is " + envs.length);
          return super.launch(starter);
        }
      }
;
    }
    @Override public Environment setUp(    AbstractBuild build,    Launcher launcher,    BuildListener listener) throws IOException, InterruptedException {
      return new Environment(){
      }
;
    }
@Extension public static class DescriptorImpl extends TestWrapperDescriptor {
    }
  }
public static class EchoBuilder extends Builder {
    @Override public boolean perform(    AbstractBuild<?,?> build,    Launcher launcher,    BuildListener listener) throws InterruptedException, IOException {
      String[] cmds=Functions.isWindows() ? new String[]{"cmd.exe","/C","echo","Hello"} : new String[]{"echo","Hello"};
      String path=Functions.isWindows() ? "C:\\this\\path\\doesn't\\exist" : "/this/path/doesnt/exist";
      Launcher.ProcStarter starter=launcher.launch().cmds(cmds).pwd(new File(path));
      starter.start();
      starter.join();
      return true;
    }
@Extension public static class DescriptorImpl extends BuildStepDescriptor<Builder> {
      @Override public boolean isApplicable(      Class<? extends AbstractProject> aClass){
        return true;
      }
    }
  }
}
