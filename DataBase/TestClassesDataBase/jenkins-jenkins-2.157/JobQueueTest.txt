public class JobQueueTest {
  @Rule public JenkinsRule j=new JenkinsRule();
  private static volatile boolean fireCompletedFlag=false;
  private static volatile boolean fireFinalizeFlag=false;
  @Before public void setUp(){
    RunListener<Run> listener=new RunListener<Run>(){
      @Override public void onCompleted(      Run r,      TaskListener listener){
        JobQueueTest.fireCompletedFlag=true;
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException e) {
        }
      }
      @Override public void onFinalized(      Run r){
        JobQueueTest.fireFinalizeFlag=true;
        try {
          Thread.sleep(2000);
        }
 catch (        InterruptedException e) {
        }
      }
    }
;
    RunListener.all().add(listener);
  }
  @Test public void buildPendingWhenBuildRunning() throws Exception {
    FreeStyleProject project=j.createFreeStyleProject("project");
    project.getBuildersList().add(new SleepBuilder(2000));
    project.scheduleBuild2(1);
    project.scheduleBuild2(1);
    assertTrue(project.isInQueue());
    j.jenkins.getQueue().cancel(project.getQueueItem());
    assertTrue(j.jenkins.getQueue().isEmpty());
  }
  @Test public void buildPendingWhenBuildInPostProduction() throws Exception {
    FreeStyleProject project=j.createFreeStyleProject("project");
    project.getBuildersList().add(new SleepBuilder(1000));
    project.scheduleBuild2(1);
    int count=0;
    while (!JobQueueTest.fireCompletedFlag && count < 100) {
      Thread.sleep(100);
      count++;
    }
    if (JobQueueTest.fireCompletedFlag) {
      project.scheduleBuild2(0);
      assertTrue(project.isInQueue());
      j.jenkins.getQueue().maintain();
      while (j.jenkins.getQueue().getItem(project) instanceof WaitingItem) {
        System.out.println(j.jenkins.getQueue().getItem(project));
        j.jenkins.getQueue().maintain();
        Thread.sleep(10);
      }
      assertTrue(j.jenkins.getQueue().getItem(project) instanceof BlockedItem);
    }
 else {
      fail("The maximum attempts for checking if the job is in POST_PRODUCTION State have reached");
    }
    count=0;
    while (!JobQueueTest.fireFinalizeFlag && count < 100) {
      Thread.sleep(100);
      count++;
    }
    if (JobQueueTest.fireFinalizeFlag) {
      j.jenkins.getQueue().maintain();
      assertFalse(j.jenkins.getQueue().getItem(project) instanceof BlockedItem);
    }
 else {
      fail("The maximum attempts for checking if the job is in COMPLETED State have reached");
    }
    Thread.sleep(1000);
  }
}
