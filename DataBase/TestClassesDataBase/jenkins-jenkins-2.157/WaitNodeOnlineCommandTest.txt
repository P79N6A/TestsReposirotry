public class WaitNodeOnlineCommandTest {
  private CLICommandInvoker command;
  @Rule public final JenkinsRule j=new JenkinsRule();
  @Before public void setUp(){
    command=new CLICommandInvoker(j,"wait-node-online");
  }
  @Test public void waitNodeOnlineShouldFailIfNodeDoesNotExist() throws Exception {
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ).invokeWithArgs("never_created");
    assertThat(result,failedWith(3));
    assertThat(result,hasNoStandardOutput());
    assertThat(result.stderr(),containsString("ERROR: No such node 'never_created'"));
  }
  @Test public void waitNodeOnlineShouldSucceedOnGoingOnlineNode() throws Exception {
    DumbSlave slave=j.createSlave("aNode","",null);
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ).invokeWithArgs("aNode");
    assertThat(result,succeededSilently());
    assertThat(slave.toComputer().isOnline(),equalTo(true));
  }
  @Test public void waitNodeOnlineShouldTimeoutOnGoingOfflineNode() throws Exception {
    DumbSlave slave=j.createSlave("aNode","",null);
    slave.toComputer().setTemporarilyOffline(true);
    boolean timeoutOccurred=false;
    FutureTask task=new FutureTask(new Callable(){
      public Object call(){
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ).invokeWithArgs("aNode");
        fail("Never should return from previous CLI call!");
        return null;
      }
    }
);
    try {
      task.get(30,TimeUnit.SECONDS);
    }
 catch (    TimeoutException e) {
      timeoutOccurred=true;
    }
 finally {
      task.cancel(true);
    }
    if (!timeoutOccurred)     fail("Missing timeout for CLI call");
  }
  @Test public void waitNodeOnlineShouldTimeoutOnDisconnectedNode() throws Exception {
    DumbSlave slave=j.createSlave("aNode","",null);
    slave.toComputer().disconnect();
    slave.toComputer().waitUntilOffline();
    boolean timeoutOccurred=false;
    FutureTask task=new FutureTask(new Callable(){
      public Object call(){
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ).invokeWithArgs("aNode");
        fail("Never should return from previous CLI call!");
        return null;
      }
    }
);
    try {
      task.get(30,TimeUnit.SECONDS);
    }
 catch (    TimeoutException e) {
      timeoutOccurred=true;
    }
 finally {
      task.cancel(true);
    }
    if (!timeoutOccurred)     fail("Missing timeout for CLI call");
  }
  @Test public void waitNodeOnlineShouldTimeoutOnDisconnectingNode() throws Exception {
    DumbSlave slave=j.createSlave("aNode","",null);
    slave.toComputer().disconnect();
    boolean timeoutOccurred=false;
    FutureTask task=new FutureTask(new Callable(){
      public Object call(){
        final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ).invokeWithArgs("aNode");
        fail("Never should return from previous CLI call!");
        return null;
      }
    }
);
    try {
      task.get(30,TimeUnit.SECONDS);
    }
 catch (    TimeoutException e) {
      timeoutOccurred=true;
    }
 finally {
      task.cancel(true);
    }
    if (!timeoutOccurred)     fail("Missing timeout for CLI call");
  }
  @Test public void waitNodeOnlineShouldSuccessOnOnlineNode() throws Exception {
    DumbSlave slave=j.createSlave("aNode","",null);
    slave.toComputer().waitUntilOnline();
    while (true) {
      if (slave.toComputer().isOnline())       break;
      Thread.sleep(100);
    }
    final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ).invokeWithArgs("aNode");
    assertThat(result,succeededSilently());
    assertThat(slave.toComputer().isOnline(),equalTo(true));
  }
}
