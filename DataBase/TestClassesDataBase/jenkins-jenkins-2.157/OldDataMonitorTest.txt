public class OldDataMonitorTest {
static {
    System.setProperty(BuildReference.DefaultHolderFactory.MODE_PROPERTY,"weak");
  }
  @Rule public JenkinsRule r=new JenkinsRule();
  @Ignore("constantly failing on CI builders, makes problems for memory()") @Issue("JENKINS-19544") @LocalData @Test public void robustness() throws Exception {
    OldDataMonitor odm=OldDataMonitor.get(r.jenkins);
    FreeStyleProject p=r.jenkins.getItemByFullName("busted",FreeStyleProject.class);
    assertNotNull(p);
    assertEquals(Collections.singleton(p),odm.getData().keySet());
    odm.doDiscard(null,null);
    assertEquals(Collections.emptySet(),odm.getData().keySet());
  }
  @Issue("JENKINS-19544") @Test public void memory() throws Exception {
    FreeStyleProject p=r.createFreeStyleProject("p");
    FreeStyleBuild b=r.assertBuildStatusSuccess(p.scheduleBuild2(0));
    b.addAction(new BadAction2());
    b.save();
    r.jenkins.getQueue().clearLeftItems();
    p._getRuns().purgeCache();
    b=p.getBuildByNumber(1);
    assertEquals(Collections.singleton(b),OldDataMonitor.get(r.jenkins).getData().keySet());
    WeakReference<?> ref=new WeakReference<Object>(b);
    b=null;
    MemoryAssert.assertGC(ref);
  }
  /** 
 * Note that this doesn't actually run slowly, it just ensures that the  {@link OldDataMonitor#changeListener's onChange()} can completewhile  {@link OldDataMonitor#doDiscard(org.kohsuke.stapler.StaplerRequest,org.kohsuke.stapler.StaplerResponse)}is still running.
 */
  @Issue("JENKINS-24763") @Test public void slowDiscard() throws InterruptedException, IOException, ExecutionException {
    final OldDataMonitor oldDataMonitor=OldDataMonitor.get(r.jenkins);
    final CountDownLatch ensureEntry=new CountDownLatch(1);
    final CountDownLatch preventExit=new CountDownLatch(1);
    Saveable slowSavable=new Saveable(){
      @Override public void save() throws IOException {
        try {
          ensureEntry.countDown();
          preventExit.await();
        }
 catch (        InterruptedException e) {
        }
      }
    }
;
    OldDataMonitor.report(slowSavable,(String)null);
    ExecutorService executors=Executors.newSingleThreadExecutor();
    Future<Void> discardFuture=executors.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        oldDataMonitor.doDiscard(Stapler.getCurrentRequest(),Stapler.getCurrentResponse());
        return null;
      }
    }
);
    ensureEntry.await();
    File xml=File.createTempFile("OldDataMonitorTest.slowDiscard","xml");
    xml.deleteOnExit();
    OldDataMonitor.changeListener.onChange(new Saveable(){
      public void save() throws IOException {
      }
    }
,new XmlFile(xml));
    preventExit.countDown();
    discardFuture.get();
  }
  @Issue("JENKINS-26718") @Test public void unlocatableRun() throws Exception {
    OldDataMonitor odm=OldDataMonitor.get(r.jenkins);
    FreeStyleProject p=r.createFreeStyleProject();
    FreeStyleBuild build=r.buildAndAssertSuccess(p);
    p.delete();
    OldDataMonitor.report(build,(String)null);
    assertEquals(Collections.singleton(build),odm.getData().keySet());
    odm.doDiscard(null,null);
    assertEquals(Collections.emptySet(),odm.getData().keySet());
  }
public static final class BadAction extends InvisibleAction {
    private Object writeReplace(){
      throw new IllegalStateException("broken");
    }
  }
public static final class BadAction2 extends InvisibleAction {
    private Object readResolve(){
      throw new IllegalStateException("broken");
    }
  }
}
