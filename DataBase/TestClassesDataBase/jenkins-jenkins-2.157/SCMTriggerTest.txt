/** 
 * @author Alan Harder
 */
public class SCMTriggerTest {
  @Rule public JenkinsRule j=new JenkinsRule();
  /** 
 * Make sure that SCMTrigger doesn't trigger another build when a build has just started, but not yet completed its SCM update.
 */
  @Test @Issue("JENKINS-2671") public void simultaneousPollAndBuild() throws Exception {
    FreeStyleProject p=j.createFreeStyleProject();
    final OneShotEvent checkoutStarted=new OneShotEvent();
    p.setScm(new TestSCM(checkoutStarted));
    Future<FreeStyleBuild> build=p.scheduleBuild2(0,new Cause.UserCause());
    checkoutStarted.block();
    assertFalse("SCM-poll after build has started should wait until that build finishes SCM-update",p.pollSCMChanges(StreamTaskListener.fromStdout()));
    build.get();
  }
  /** 
 * Make sure that SCMTrigger doesn't poll when there is a polling veto in place.
 */
  @Test @Issue("JENKINS-36123") public void pollingExcludedByExtensionPoint() throws Exception {
    FreeStyleProject p=j.createFreeStyleProject();
    PollDecisionHandlerImpl handler=ExtensionList.lookup(SCMDecisionHandler.class).get(PollDecisionHandlerImpl.class);
    handler.blacklist.add(p);
    final OneShotEvent checkoutStarted=new OneShotEvent();
    p.setScm(new TestSCM(checkoutStarted));
    assertFalse("SCM-poll with blacklist should report no changes",p.pollSCMChanges(StreamTaskListener.fromStdout()));
    handler.blacklist.remove(p);
    assertTrue("SCM-poll with blacklist removed should report changes",p.pollSCMChanges(StreamTaskListener.fromStdout()));
  }
private static class TestSCM extends NullSCM {
    private volatile int myRev=1;
    private final OneShotEvent checkoutStarted;
    public TestSCM(    OneShotEvent checkoutStarted){
      this.checkoutStarted=checkoutStarted;
    }
    @Override synchronized public boolean pollChanges(    AbstractProject project,    Launcher launcher,    FilePath dir,    TaskListener listener) throws IOException {
      return myRev < 2;
    }
    @Override public boolean checkout(    AbstractBuild<?,?> build,    Launcher launcher,    FilePath remoteDir,    BuildListener listener,    File changeLogFile) throws IOException, InterruptedException {
      checkoutStarted.signal();
      Thread.sleep(400);
synchronized (this) {
        if (myRev < 2)         myRev=2;
      }
      return super.checkout(build,launcher,remoteDir,listener,changeLogFile);
    }
  }
  /** 
 * Make sure that only one polling result shows up per build.
 */
  @Test @Issue("JENKINS-7649") public void multiplePollingOneBuildAction() throws Exception {
    final OneShotEvent buildStarted=new OneShotEvent();
    final OneShotEvent buildShouldComplete=new OneShotEvent();
    FreeStyleProject p=j.createFreeStyleProject();
    p.getBuildersList().add(new TestBuilder(){
      public boolean perform(      AbstractBuild<?,?> build,      Launcher launcher,      BuildListener listener) throws InterruptedException, IOException {
        buildStarted.signal();
        buildShouldComplete.block();
        return true;
      }
    }
);
    SCMTrigger t=new SCMTrigger("@daily");
    t.start(p,true);
    p.addTrigger(t);
    assertTrue(p.scheduleBuild(new UserCause()));
    buildStarted.block();
    Future<FreeStyleBuild> fb=p.scheduleBuild2(0,new UserCause());
    assertNotNull(fb);
    assertTrue(p.scheduleBuild(new SCMTriggerCause("First poll")));
    assertTrue(p.scheduleBuild(new SCMTriggerCause("Second poll")));
    assertTrue(p.scheduleBuild(new SCMTriggerCause("Third poll")));
    buildShouldComplete.signal();
    FreeStyleBuild build=fb.get();
    List<BuildAction> ba=build.getActions(BuildAction.class);
    assertFalse("There should only be one BuildAction.",ba.size() != 1);
  }
@TestExtension public static class PollDecisionHandlerImpl extends SCMDecisionHandler {
    Set<Item> blacklist=new HashSet<>();
    @Override public boolean shouldPoll(    Item item){
      return !blacklist.contains(item);
    }
  }
}
