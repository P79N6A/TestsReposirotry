static class TestablePeerEurekaNodes extends PeerEurekaNodes {
  private AtomicReference<List<String>> peerUrlsRef=new AtomicReference<>(Collections.<String>emptyList());
  private final ConcurrentHashMap<String,PeerEurekaNode> peerEurekaNodeByUrl=new ConcurrentHashMap<>();
  private final AtomicInteger reloadCounter=new AtomicInteger();
  TestablePeerEurekaNodes(  PeerAwareInstanceRegistry registry,  EurekaServerConfig serverConfig){
    super(registry,serverConfig,new DefaultEurekaClientConfig(),new DefaultServerCodecs(serverConfig),mock(ApplicationInfoManager.class));
  }
  void withPeerUrls(  String... peerUrls){
    this.peerUrlsRef.set(Arrays.asList(peerUrls));
  }
  boolean awaitNextReload(  long timeout,  TimeUnit timeUnit) throws InterruptedException {
    int lastReloadCounter=reloadCounter.get();
    long endTime=System.currentTimeMillis() + timeUnit.toMillis(timeout);
    while (endTime > System.currentTimeMillis() && lastReloadCounter == reloadCounter.get()) {
      Thread.sleep(10);
    }
    return lastReloadCounter != reloadCounter.get();
  }
  @Override protected void updatePeerEurekaNodes(  List<String> newPeerUrls){
    super.updatePeerEurekaNodes(newPeerUrls);
    reloadCounter.incrementAndGet();
  }
  @Override protected List<String> resolvePeerUrls(){
    return peerUrlsRef.get();
  }
  @Override protected PeerEurekaNode createPeerEurekaNode(  String peerEurekaNodeUrl){
    if (peerEurekaNodeByUrl.containsKey(peerEurekaNodeUrl)) {
      throw new IllegalStateException("PeerEurekaNode for URL " + peerEurekaNodeUrl + " is already created");
    }
    PeerEurekaNode peerEurekaNode=mock(PeerEurekaNode.class);
    when(peerEurekaNode.getServiceUrl()).thenReturn(peerEurekaNodeUrl);
    return peerEurekaNode;
  }
}
