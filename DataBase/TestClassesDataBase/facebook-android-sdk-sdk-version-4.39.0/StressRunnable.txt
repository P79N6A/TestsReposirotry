static class StressRunnable implements Runnable {
  static ArrayList<WorkQueue.WorkItem> tracked=new ArrayList<WorkQueue.WorkItem>();
  final WorkQueue manager;
  final SecureRandom random=new SecureRandom();
  final int iterationCount;
  int iterationIndex=0;
  boolean isDone=false;
  StressRunnable(  WorkQueue manager,  int iterationCount){
    this.manager=manager;
    this.iterationCount=iterationCount;
  }
  @Override public void run(){
    if (iterationIndex++ < iterationCount) {
      final int sleepWeight=80;
      final int trackThisWeight=10;
      final int prioritizeTrackedWeight=6;
      final int validateWeight=2;
      int weight=0;
      final int n=random.nextInt(sleepWeight + trackThisWeight + prioritizeTrackedWeight+ validateWeight);
      WorkQueue.WorkItem workItem=manager.addActiveWorkItem(this);
      if (n < (weight+=sleepWeight)) {
        try {
          Thread.sleep(n / 4);
        }
 catch (        InterruptedException e) {
        }
      }
 else       if (n < (weight+=trackThisWeight)) {
synchronized (tracked) {
          tracked.add(workItem);
        }
      }
 else       if (n < (weight+=prioritizeTrackedWeight)) {
        ArrayList<WorkQueue.WorkItem> items=new ArrayList<WorkQueue.WorkItem>();
synchronized (tracked) {
          items.addAll(tracked);
          tracked.clear();
        }
        for (        WorkQueue.WorkItem item : items) {
          item.moveToFront();
        }
      }
 else {
        manager.validate();
      }
    }
 else {
      manager.validate();
synchronized (this) {
        isDone=true;
        this.notifyAll();
      }
    }
  }
  void waitForDone(){
synchronized (this) {
      while (!isDone) {
        try {
          this.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
}
