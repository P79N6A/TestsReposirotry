public final class FileLruCacheTest extends FacebookTestCase {
  private static final Random random=new Random();
  @Before public void before(){
    FacebookSdk.setApplicationId("123456789");
    FacebookSdk.setAutoLogAppEventsEnabled(false);
    FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
  }
  @Test public void testCacheOutputStream() throws Exception {
    int dataSize=1024;
    byte[] data=generateBytes(dataSize);
    String key="a";
    FileLruCache cache=new FileLruCache("testCacheOutputStream",limitCacheSize(2 * dataSize));
    try {
      put(cache,key,data);
      checkValue(cache,key,data);
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testCacheInputStream() throws Exception {
    int dataSize=1024;
    byte[] data=generateBytes(dataSize);
    String key="a";
    InputStream stream=new ByteArrayInputStream(data);
    FileLruCache cache=new FileLruCache("testCacheInputStream",limitCacheSize(2 * dataSize));
    try {
      TestUtils.clearFileLruCache(cache);
      InputStream wrapped=cache.interceptAndPut(key,stream);
      consumeAndClose(wrapped);
      checkValue(cache,key,data);
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testCacheClear() throws Exception {
    int dataSize=1024;
    byte[] data=generateBytes(dataSize);
    String key="a";
    FileLruCache cache=new FileLruCache("testCacheClear",limitCacheSize(2 * dataSize));
    try {
      TestUtils.clearFileLruCache(cache);
      put(cache,key,data);
      checkValue(cache,key,data);
      TestUtils.clearFileLruCache(cache);
      assertEquals(false,hasValue(cache,key));
      assertEquals(0,cache.sizeInBytesForTest());
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testCacheClearMidBuffer() throws Exception {
    int dataSize=1024;
    byte[] data=generateBytes(dataSize);
    String key="a";
    String key2="b";
    FileLruCache cache=new FileLruCache("testCacheClear",limitCacheSize(2 * dataSize));
    try {
      TestUtils.clearFileLruCache(cache);
      put(cache,key,data);
      checkValue(cache,key,data);
      OutputStream stream=cache.openPutStream(key2);
      Thread.sleep(200);
      TestUtils.clearFileLruCache(cache);
      stream.write(data);
      stream.close();
      assertEquals(false,hasValue(cache,key));
      assertEquals(false,hasValue(cache,key2));
      assertEquals(0,cache.sizeInBytesForTest());
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testSizeInBytes() throws Exception {
    int count=17;
    int dataSize=53;
    int cacheSize=count * dataSize;
    byte[] data=generateBytes(dataSize);
    FileLruCache cache=new FileLruCache("testSizeInBytes",limitCacheSize(2 * cacheSize));
    try {
      TestUtils.clearFileLruCache(cache);
      for (int i=0; i < count; i++) {
        put(cache,i,data);
        int totalDataSize=(i + 1) * dataSize;
        assertTrue(cache.sizeInBytesForTest() > totalDataSize);
        assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
      }
      for (int i=0; i < count; i++) {
        String key=Integer.valueOf(i).toString();
        checkValue(cache,key,data);
      }
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testCacheSizeLimit() throws Exception {
    int count=64;
    int dataSize=32;
    int cacheSize=count * dataSize / 2;
    byte[] data=generateBytes(dataSize);
    FileLruCache cache=new FileLruCache("testCacheSizeLimit",limitCacheSize(cacheSize));
    try {
      TestUtils.clearFileLruCache(cache);
      for (int i=0; i < count; i++) {
        put(cache,i,data);
        int totalDataSize=(i + 1) * dataSize;
        assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize,cacheSize / 2));
        assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize,cacheSize));
      }
      Thread.sleep(200);
      boolean hasValueExists=false;
      boolean hasNoValueExists=false;
      for (int i=0; i < count; i++) {
        String key=Integer.valueOf(i).toString();
        if (hasValue(cache,key)) {
          hasValueExists=true;
          checkValue(cache,key,data);
        }
 else {
          hasNoValueExists=true;
        }
      }
      assertEquals(true,hasValueExists);
      assertEquals(true,hasNoValueExists);
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testCacheCountLimit() throws Exception {
    int count=64;
    int dataSize=32;
    int cacheCount=count / 2;
    byte[] data=generateBytes(dataSize);
    FileLruCache cache=new FileLruCache("testCacheCountLimit",limitCacheCount(cacheCount));
    try {
      TestUtils.clearFileLruCache(cache);
      for (int i=0; i < count; i++) {
        put(cache,i,data);
      }
      Thread.sleep(200);
      boolean hasValueExists=false;
      boolean hasNoValueExists=false;
      for (int i=0; i < count; i++) {
        if (hasValue(cache,i)) {
          hasValueExists=true;
          checkValue(cache,i,data);
        }
 else {
          hasNoValueExists=true;
        }
      }
      assertEquals(true,hasValueExists);
      assertEquals(true,hasNoValueExists);
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testCacheLru() throws IOException, InterruptedException {
    int keepCount=10;
    int otherCount=5;
    int dataSize=64;
    byte[] data=generateBytes(dataSize);
    FileLruCache cache=new FileLruCache("testCacheLru",limitCacheCount(keepCount + 1));
    try {
      TestUtils.clearFileLruCache(cache);
      for (int i=0; i < keepCount; i++) {
        put(cache,i,data);
      }
      Thread.sleep(1000);
      for (int i=0; i < otherCount; i++) {
        put(cache,keepCount + i,data);
        Thread.sleep(1000);
        for (int keepIndex=0; keepIndex < keepCount; keepIndex++) {
          checkValue(cache,keepIndex,data);
        }
        Thread.sleep(200);
      }
      for (int i=0; i < (otherCount - 1); i++) {
        String key=Integer.valueOf(keepCount + i).toString();
        assertEquals(false,hasValue(cache,key));
      }
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  @Test public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
    final int count=5;
    final int dataSize=81;
    final int threadCount=31;
    final int iterationCount=10;
    final byte[] data=generateBytes(dataSize);
    final FileLruCache cache=new FileLruCache("testConcurrentWritesToSameKey",limitCacheCount(count + 1));
    try {
      TestUtils.clearFileLruCache(cache);
      Runnable run=new Runnable(){
        @Override public void run(){
          for (int iterations=0; iterations < iterationCount; iterations++) {
            for (int i=0; i < count; i++) {
              put(cache,i,data);
            }
          }
        }
      }
;
      Thread[] threads=new Thread[threadCount];
      for (int i=0; i < threads.length; i++) {
        threads[i]=new Thread(run);
      }
      for (      Thread thread : threads) {
        thread.start();
      }
      for (      Thread thread : threads) {
        thread.join(10 * 1000,0);
      }
      for (int i=0; i < count; i++) {
        checkValue(cache,i,data);
      }
    }
  finally {
      TestUtils.clearAndDeleteLruCacheDirectory(cache);
    }
  }
  byte[] generateBytes(  int n){
    byte[] bytes=new byte[n];
    random.nextBytes(bytes);
    return bytes;
  }
  FileLruCache.Limits limitCacheSize(  int n){
    FileLruCache.Limits limits=new FileLruCache.Limits();
    limits.setByteCount(n);
    return limits;
  }
  FileLruCache.Limits limitCacheCount(  int n){
    FileLruCache.Limits limits=new FileLruCache.Limits();
    limits.setFileCount(n);
    return limits;
  }
  void put(  FileLruCache cache,  int i,  byte[] data){
    put(cache,Integer.valueOf(i).toString(),data);
  }
  void put(  FileLruCache cache,  String key,  byte[] data){
    try {
      OutputStream stream=cache.openPutStream(key);
      assertNotNull(stream);
      stream.write(data);
      stream.close();
    }
 catch (    IOException e) {
      assertNull(e);
    }
  }
  void checkValue(  FileLruCache cache,  int i,  byte[] expected){
    checkValue(cache,Integer.valueOf(i).toString(),expected);
  }
  void checkValue(  FileLruCache cache,  String key,  byte[] expected){
    try {
      InputStream stream=cache.get(key);
      assertNotNull(stream);
      checkInputStream(expected,stream);
      stream.close();
    }
 catch (    IOException e) {
      assertNull(e);
    }
  }
  boolean hasValue(  FileLruCache cache,  int i){
    return hasValue(cache,Integer.valueOf(i).toString());
  }
  boolean hasValue(  FileLruCache cache,  String key){
    InputStream stream=null;
    try {
      stream=cache.get(key);
    }
 catch (    IOException e) {
      assertNull(e);
    }
    return stream != null;
  }
  void checkInputStream(  byte[] expected,  InputStream actual){
    try {
      for (int i=0; i < expected.length; i++) {
        int b=actual.read();
        assertEquals(((int)expected[i]) & 0xff,b);
      }
      int eof=actual.read();
      assertEquals(-1,eof);
    }
 catch (    IOException e) {
      assertNull(e);
    }
  }
  void consumeAndClose(  InputStream stream){
    try {
      byte[] buffer=new byte[1024];
      while (stream.read(buffer) > -1) {
      }
      stream.close();
    }
 catch (    IOException e) {
      assertNull(e);
    }
  }
}
