@PrepareForTest({FacebookSdk.class,AccessTokenCache.class,Utility.class}) public class AccessTokenManagerTest extends FacebookPowerMockTestCase {
  private final String TOKEN_STRING="A token of my esteem";
  private final String USER_ID="1000";
  private final List<String> PERMISSIONS=Arrays.asList("walk","chew gum");
  private final Date EXPIRES=new Date(2025,5,3);
  private final Date LAST_REFRESH=new Date(2023,8,15);
  private final Date DATA_ACCESS_EXPIRATION_TIME=new Date(2025,5,3);
  private final String APP_ID="1234";
  private LocalBroadcastManager localBroadcastManager;
  private AccessTokenCache accessTokenCache;
  @Before public void before() throws Exception {
    mockStatic(FacebookSdk.class);
    when(FacebookSdk.isInitialized()).thenReturn(true);
    when(FacebookSdk.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
    suppress(method(Utility.class,"clearFacebookCookies"));
    localBroadcastManager=LocalBroadcastManager.getInstance(RuntimeEnvironment.application);
    accessTokenCache=mock(AccessTokenCache.class);
  }
  @Test public void testRequiresLocalBroadcastManager(){
    try {
      AccessTokenManager accessTokenManager=new AccessTokenManager(null,accessTokenCache);
      fail();
    }
 catch (    NullPointerException ex) {
    }
  }
  @Test public void testRequiresTokenCache(){
    try {
      AccessTokenManager accessTokenManager=new AccessTokenManager(localBroadcastManager,null);
      fail();
    }
 catch (    NullPointerException ex) {
    }
  }
  @Test public void testDefaultsToNoCurrentAccessToken(){
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    assertNull(accessTokenManager.getCurrentAccessToken());
  }
  @Test public void testCanSetCurrentAccessToken(){
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    AccessToken accessToken=createAccessToken();
    accessTokenManager.setCurrentAccessToken(accessToken);
    assertEquals(accessToken,accessTokenManager.getCurrentAccessToken());
  }
  @Test public void testChangingAccessTokenSendsBroadcast(){
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    AccessToken accessToken=createAccessToken();
    accessTokenManager.setCurrentAccessToken(accessToken);
    final Intent intents[]=new Intent[1];
    final BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
      @Override public void onReceive(      Context context,      Intent intent){
        intents[0]=intent;
      }
    }
;
    localBroadcastManager.registerReceiver(broadcastReceiver,new IntentFilter(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED));
    AccessToken anotherAccessToken=createAccessToken("another string","1000");
    accessTokenManager.setCurrentAccessToken(anotherAccessToken);
    localBroadcastManager.unregisterReceiver(broadcastReceiver);
    Intent intent=intents[0];
    assertNotNull(intent);
    AccessToken oldAccessToken=intent.getParcelableExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN);
    AccessToken newAccessToken=intent.getParcelableExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN);
    assertEquals(accessToken.getToken(),oldAccessToken.getToken());
    assertEquals(anotherAccessToken.getToken(),newAccessToken.getToken());
  }
  @Test public void testLoadReturnsFalseIfNoCachedToken(){
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    boolean result=accessTokenManager.loadCurrentAccessToken();
    assertFalse(result);
  }
  @Test public void testLoadReturnsTrueIfCachedToken(){
    AccessToken accessToken=createAccessToken();
    when(accessTokenCache.load()).thenReturn(accessToken);
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    boolean result=accessTokenManager.loadCurrentAccessToken();
    assertTrue(result);
  }
  @Test public void testLoadSetsCurrentTokenIfCached(){
    AccessToken accessToken=createAccessToken();
    when(accessTokenCache.load()).thenReturn(accessToken);
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    accessTokenManager.loadCurrentAccessToken();
    assertEquals(accessToken,accessTokenManager.getCurrentAccessToken());
  }
  @Test public void testSaveWritesToCacheIfToken() throws JSONException {
    AccessToken accessToken=createAccessToken();
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    accessTokenManager.setCurrentAccessToken(accessToken);
    verify(accessTokenCache,times(1)).save(any(AccessToken.class));
  }
  @Test public void testSetEmptyTokenClearsCache(){
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    accessTokenManager.setCurrentAccessToken(null);
    verify(accessTokenCache,times(1)).clear();
  }
  @Test public void testLoadDoesNotSave(){
    AccessToken accessToken=createAccessToken();
    when(accessTokenCache.load()).thenReturn(accessToken);
    AccessTokenManager accessTokenManager=createAccessTokenManager();
    accessTokenManager.loadCurrentAccessToken();
    verify(accessTokenCache,never()).save(any(AccessToken.class));
  }
  private AccessTokenManager createAccessTokenManager(){
    return new AccessTokenManager(localBroadcastManager,accessTokenCache);
  }
  private AccessToken createAccessToken(){
    return createAccessToken(TOKEN_STRING,USER_ID);
  }
  private AccessToken createAccessToken(  String tokenString,  String userId){
    return new AccessToken(tokenString,APP_ID,userId,PERMISSIONS,null,AccessTokenSource.WEB_VIEW,EXPIRES,LAST_REFRESH,DATA_ACCESS_EXPIRATION_TIME);
  }
}
