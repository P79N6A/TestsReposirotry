static class FinishableStatusUpdateTestAnswer implements Answer<Void> {
  final Lock lock;
  final Condition condition;
  final AtomicBoolean opDone;
  final AtomicBoolean successInvoked=new AtomicBoolean(false);
  final AtomicBoolean failInvoked=new AtomicBoolean(false);
  FinishableStatusUpdateTestAnswer(  Lock lock,  Condition condition,  AtomicBoolean opDone){
    this.lock=lock;
    this.condition=condition;
    this.opDone=opDone;
  }
  void reset(){
    opDone.set(false);
    successInvoked.set(false);
    failInvoked.set(false);
  }
  @Override public Void answer(  InvocationOnMock invocation) throws Throwable {
    if (invocation.getMethod().getName().equals("sendSourceStateUpdate")) {
      LlapNodeId nodeId=(LlapNodeId)invocation.getArguments()[1];
      final LlapProtocolClientProxy.ExecuteRequestCallback callback=(LlapProtocolClientProxy.ExecuteRequestCallback)invocation.getArguments()[2];
      if (nodeId.getHostname().equals(LlapTaskCommunicatorWrapperForTest.HOSTS[0])) {
        new Thread(){
          public void run(){
            callback.indicateError(new IOException("Force failing " + LlapTaskCommunicatorWrapperForTest.HOSTS[0]));
            successInvoked.set(true);
            signalOpDoneIfBothInvoked();
          }
        }
.start();
      }
 else {
        new Thread(){
          public void run(){
            callback.setResponse(LlapDaemonProtocolProtos.SourceStateUpdatedResponseProto.getDefaultInstance());
            failInvoked.set(true);
            signalOpDoneIfBothInvoked();
          }
        }
.start();
      }
    }
    return null;
  }
  private void signalOpDoneIfBothInvoked(){
    lock.lock();
    try {
      if (failInvoked.get() && successInvoked.get()) {
        opDone.set(true);
        condition.signal();
      }
    }
  finally {
      lock.unlock();
    }
  }
}
