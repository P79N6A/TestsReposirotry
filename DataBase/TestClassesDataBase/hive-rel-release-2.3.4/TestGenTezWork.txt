/** 
 * Tests for GenTezWork.
 */
public class TestGenTezWork {
  GenTezProcContext ctx;
  GenTezWork proc;
  ReduceSinkOperator rs;
  FileSinkOperator fs;
  TableScanOperator ts;
  /** 
 * @throws java.lang.Exception
 */
  @SuppressWarnings("unchecked") @Before public void setUp() throws Exception {
    final HiveConf conf=new HiveConf(SemanticAnalyzer.class);
    SessionState.start(conf);
    final ParseContext pctx=new ParseContext();
    pctx.setContext(new Context(conf));
    ctx=new GenTezProcContext(conf,pctx,Collections.EMPTY_LIST,new ArrayList<Task<? extends Serializable>>(),Collections.EMPTY_SET,Collections.EMPTY_SET);
    proc=new GenTezWork(new GenTezUtils(){
      @Override protected void setupMapWork(      MapWork mapWork,      GenTezProcContext context,      PrunedPartitionList partitions,      TableScanOperator root,      String alias) throws SemanticException {
        LinkedHashMap<String,Operator<? extends OperatorDesc>> map=new LinkedHashMap<String,Operator<? extends OperatorDesc>>();
        map.put("foo",root);
        mapWork.setAliasToWork(map);
        return;
      }
    }
);
    CompilationOpContext cCtx=new CompilationOpContext();
    fs=new FileSinkOperator(cCtx);
    fs.setConf(new FileSinkDesc());
    rs=new ReduceSinkOperator(cCtx);
    rs.setConf(new ReduceSinkDesc());
    TableDesc tableDesc=new TableDesc();
    tableDesc.setProperties(new Properties());
    rs.getConf().setKeySerializeInfo(tableDesc);
    ts=new TableScanOperator(cCtx);
    ts.setConf(new TableScanDesc(null));
    ts.getChildOperators().add(rs);
    rs.getParentOperators().add(ts);
    rs.getChildOperators().add(fs);
    fs.getParentOperators().add(rs);
    ctx.preceedingWork=null;
    ctx.currentRootOperator=ts;
  }
  /** 
 * @throws java.lang.Exception
 */
  @After public void tearDown() throws Exception {
    ctx=null;
    proc=null;
    ts=null;
    rs=null;
    fs=null;
  }
  @Test public void testCreateMap() throws SemanticException {
    proc.process(rs,null,ctx,(Object[])null);
    assertNotNull(ctx.currentTask);
    assertTrue(ctx.rootTasks.contains(ctx.currentTask));
    TezWork work=ctx.currentTask.getWork();
    assertEquals(work.getAllWork().size(),1);
    BaseWork w=work.getAllWork().get(0);
    assertTrue(w instanceof MapWork);
    MapWork mw=(MapWork)w;
    assertNotNull(w.getName());
    assertSame(mw.getAliasToWork().entrySet().iterator().next().getValue(),ts);
    assertSame(ctx.preceedingWork,mw);
    assertSame(ctx.currentRootOperator,fs);
  }
  @Test public void testCreateReduce() throws SemanticException {
    proc.process(rs,null,ctx,(Object[])null);
    proc.process(fs,null,ctx,(Object[])null);
    TezWork work=ctx.currentTask.getWork();
    assertEquals(work.getAllWork().size(),2);
    BaseWork w=work.getAllWork().get(1);
    assertTrue(w instanceof ReduceWork);
    assertTrue(work.getParents(w).contains(work.getAllWork().get(0)));
    ReduceWork rw=(ReduceWork)w;
    assertNotNull(w.getName());
    assertSame(rw.getReducer(),fs);
    assertEquals(fs.getParentOperators().size(),0);
  }
}
