public class TestViewEntity {
  /** 
 * Hook used in the test to capture the set of ReadEntities
 */
public static class CheckInputReadEntity extends AbstractSemanticAnalyzerHook {
    public static ReadEntity[] readEntities;
    @Override public void postAnalyze(    HiveSemanticAnalyzerHookContext context,    List<Task<? extends Serializable>> rootTasks) throws SemanticException {
      readEntities=context.getInputs().toArray(new ReadEntity[0]);
    }
  }
  private static Driver driver;
  private final String NAME_PREFIX="TestViewEntity5".toLowerCase();
  @BeforeClass public static void onetimeSetup() throws Exception {
    HiveConf conf=new HiveConf(Driver.class);
    conf.setVar(HiveConf.ConfVars.HIVE_AUTHORIZATION_MANAGER,"org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory");
    conf.setVar(HiveConf.ConfVars.SEMANTIC_ANALYZER_HOOK,CheckInputReadEntity.class.getName());
    HiveConf.setBoolVar(conf,HiveConf.ConfVars.HIVE_SUPPORT_CONCURRENCY,false);
    SessionState.start(conf);
    driver=new Driver(conf);
    driver.init();
  }
  @AfterClass public static void cleanUp() throws Exception {
    driver.close();
    driver.destroy();
  }
  /** 
 * Verify that the parent entities are captured correctly for union views
 * @throws Exception
 */
  @Test public void testUnionView() throws Exception {
    String prefix="tunionview" + NAME_PREFIX;
    final String tab1=prefix + "t1";
    final String tab2=prefix + "t2";
    final String view1=prefix + "v1";
    int ret=driver.run("create table " + tab1 + "(id int)").getResponseCode();
    assertEquals("Checking command success",0,ret);
    ret=driver.run("create table " + tab2 + "(id int)").getResponseCode();
    assertEquals("Checking command success",0,ret);
    ret=driver.run("create view " + view1 + " as select t.id from "+ "(select "+ tab1+ ".id from "+ tab1+ " union all select "+ tab2+ ".id from "+ tab2+ ") as t").getResponseCode();
    assertEquals("Checking command success",0,ret);
    driver.compile("select * from " + view1);
    assertEquals("default@" + view1,CheckInputReadEntity.readEntities[0].getName());
    assertEquals("default@" + tab1,CheckInputReadEntity.readEntities[1].getName());
    assertFalse("Table is not direct input",CheckInputReadEntity.readEntities[1].isDirect());
    assertEquals("default@" + view1,CheckInputReadEntity.readEntities[1].getParents().iterator().next().getName());
    assertEquals("default@" + tab2,CheckInputReadEntity.readEntities[2].getName());
    assertFalse("Table is not direct input",CheckInputReadEntity.readEntities[2].isDirect());
    assertEquals("default@" + view1,CheckInputReadEntity.readEntities[2].getParents().iterator().next().getName());
  }
  /** 
 * Verify that the parent entities are captured correctly for view in subquery
 * @throws Exception
 */
  @Test public void testViewInSubQuery() throws Exception {
    String prefix="tvsubquery" + NAME_PREFIX;
    final String tab1=prefix + "t";
    final String view1=prefix + "v";
    int ret=driver.run("create table " + tab1 + "(id int)").getResponseCode();
    assertEquals("Checking command success",0,ret);
    ret=driver.run("create view " + view1 + " as select * from "+ tab1).getResponseCode();
    assertEquals("Checking command success",0,ret);
    driver.compile("select * from " + view1);
    assertEquals("default@" + view1,CheckInputReadEntity.readEntities[0].getName());
    assertEquals("default@" + tab1,CheckInputReadEntity.readEntities[1].getName());
    assertFalse("Table is not direct input",CheckInputReadEntity.readEntities[1].isDirect());
  }
  /** 
 * Verify that the the query with the subquery inside a view will have the correct direct and indirect inputs.
 * @throws Exception
 */
  @Test public void testSubQueryInSubView() throws Exception {
    String prefix="tvsubqueryinsubview" + NAME_PREFIX;
    final String tab1=prefix + "t";
    final String view1=prefix + "v";
    final String view2=prefix + "v2";
    int ret=driver.run("create table " + tab1 + "(id int)").getResponseCode();
    assertEquals("Checking command success",0,ret);
    ret=driver.run("create view " + view1 + " as select * from "+ tab1).getResponseCode();
    assertEquals("Checking command success",0,ret);
    ret=driver.run("create view " + view2 + " as select * from (select * from "+ view1+ ") x").getResponseCode();
    assertEquals("Checking command success",0,ret);
    driver.compile("select * from " + view2);
    assertEquals("default@" + view2,CheckInputReadEntity.readEntities[0].getName());
    assertEquals("default@" + view1,CheckInputReadEntity.readEntities[1].getName());
    assertFalse("Table is not direct input",CheckInputReadEntity.readEntities[1].isDirect());
    Set<ReadEntity> parents=CheckInputReadEntity.readEntities[1].getParents();
    assertTrue("Table does not have parent",parents != null && parents.size() > 0);
    assertEquals("default@" + tab1,CheckInputReadEntity.readEntities[2].getName());
    assertFalse("Table is not direct input",CheckInputReadEntity.readEntities[2].isDirect());
  }
  /** 
 * Verify that the the query with the subquery inside a view will have the correct direct and indirect inputs.
 * @throws Exception
 */
  @Test public void testUnionAllInSubView() throws Exception {
    String prefix="tvunionallinsubview" + NAME_PREFIX;
    final String tab1=prefix + "t";
    final String view1=prefix + "v";
    final String view2=prefix + "v2";
    int ret=driver.run("create table " + tab1 + "(id int)").getResponseCode();
    assertEquals("Checking command success",0,ret);
    ret=driver.run("create view " + view1 + " as select * from "+ tab1).getResponseCode();
    assertEquals("Checking command success",0,ret);
    ret=driver.run("create view " + view2 + " as select * from (select * from "+ view1+ " union all select * from "+ view1+ ") x").getResponseCode();
    assertEquals("Checking command success",0,ret);
    driver.compile("select * from " + view2);
    assertEquals("default@" + view2,CheckInputReadEntity.readEntities[0].getName());
    assertEquals("default@" + view1,CheckInputReadEntity.readEntities[1].getName());
    assertFalse("Table is not direct input",CheckInputReadEntity.readEntities[1].isDirect());
    Set<ReadEntity> parents=CheckInputReadEntity.readEntities[1].getParents();
    assertTrue("Table does not have parent",parents != null && parents.size() > 0);
    assertEquals("default@" + tab1,CheckInputReadEntity.readEntities[2].getName());
    assertFalse("Table is not direct input",CheckInputReadEntity.readEntities[2].isDirect());
  }
}
