private static class LlapTaskSchedulerServiceForTest extends LlapTaskSchedulerService {
  private AtomicBoolean controlScheduling=new AtomicBoolean(false);
  private final Lock testLock=new ReentrantLock();
  private final Condition schedulingCompleteCondition=testLock.newCondition();
  private boolean schedulingComplete=false;
  private final Condition triggerSchedulingCondition=testLock.newCondition();
  private boolean schedulingTriggered=false;
  private final AtomicInteger numSchedulerRuns=new AtomicInteger(0);
  public LlapTaskSchedulerServiceForTest(  TaskSchedulerContext appClient,  Clock clock){
    super(appClient,clock,false);
  }
  @Override protected void schedulePendingTasks(){
    LOG.info("Attempted schedulPendingTasks");
    testLock.lock();
    try {
      if (controlScheduling.get()) {
        while (!schedulingTriggered) {
          try {
            triggerSchedulingCondition.await();
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
      numSchedulerRuns.incrementAndGet();
      super.schedulePendingTasks();
      schedulingTriggered=false;
      schedulingComplete=true;
      schedulingCompleteCondition.signal();
    }
  finally {
      testLock.unlock();
    }
  }
  void forTestsetControlScheduling(  boolean control){
    this.controlScheduling.set(control);
  }
  void forTestSignalSchedulingRun() throws InterruptedException {
    testLock.lock();
    try {
      schedulingTriggered=true;
      triggerSchedulingCondition.signal();
    }
  finally {
      testLock.unlock();
    }
  }
  boolean forTestAwaitSchedulingRun(  long timeout) throws InterruptedException {
    testLock.lock();
    try {
      boolean success=true;
      while (!schedulingComplete) {
        if (timeout == -1) {
          schedulingCompleteCondition.await();
        }
 else {
          success=schedulingCompleteCondition.await(timeout,TimeUnit.MILLISECONDS);
          break;
        }
      }
      schedulingComplete=false;
      return success;
    }
  finally {
      testLock.unlock();
    }
  }
}
