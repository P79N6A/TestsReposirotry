public static class VerifyFastRowHashMap {
  private int count;
  private FastRowHashMapElement[] array;
  private TreeMap<BytesWritable,Integer> keyValueMap;
  public VerifyFastRowHashMap(){
    count=0;
    array=new FastRowHashMapElement[50];
    keyValueMap=new TreeMap<BytesWritable,Integer>();
  }
  public int getCount(){
    return count;
  }
  public boolean contains(  byte[] key){
    BytesWritable keyBytesWritable=new BytesWritable(key,key.length);
    return keyValueMap.containsKey(keyBytesWritable);
  }
  public void add(  byte[] key,  Object[] keyRow,  byte[] value,  Object[] valueRow){
    BytesWritable keyBytesWritable=new BytesWritable(key,key.length);
    if (keyValueMap.containsKey(keyBytesWritable)) {
      int index=keyValueMap.get(keyBytesWritable);
      array[index].add(value,valueRow);
    }
 else {
      if (count >= array.length) {
        FastRowHashMapElement[] newArray=new FastRowHashMapElement[array.length * 2];
        System.arraycopy(array,0,newArray,0,count);
        array=newArray;
      }
      array[count]=new FastRowHashMapElement(key,keyRow,value,valueRow);
      keyValueMap.put(keyBytesWritable,count);
      count++;
    }
  }
  public byte[] addRandomExisting(  byte[] value,  Object[] valueRow,  Random r){
    Preconditions.checkState(count > 0);
    int index=r.nextInt(count);
    array[index].add(value,valueRow);
    return array[index].getKey();
  }
  public byte[] getKey(  int index){
    return array[index].getKey();
  }
  public List<byte[]> getValues(  int index){
    return array[index].getValues();
  }
  public void verify(  VectorMapJoinFastHashTable map,  HashTableKeyType hashTableKeyType,  PrimitiveTypeInfo[] valuePrimitiveTypeInfos,  boolean doClipping,  boolean useExactBytes,  Random random) throws IOException {
    int mapSize=map.size();
    if (mapSize != count) {
      TestCase.fail("map.size() does not match expected count");
    }
    for (int index=0; index < count; index++) {
      FastRowHashMapElement element=array[index];
      List<byte[]> values=element.getValues();
      VectorMapJoinHashMapResult hashMapResult=null;
      JoinUtil.JoinResult joinResult=JoinUtil.JoinResult.NOMATCH;
switch (hashTableKeyType) {
case BOOLEAN:
case BYTE:
case SHORT:
case INT:
case LONG:
{
          Object[] keyRow=element.getKeyRow();
          Object keyObject=keyRow[0];
          VectorMapJoinFastLongHashMap longHashMap=(VectorMapJoinFastLongHashMap)map;
          hashMapResult=longHashMap.createHashMapResult();
          long longKey;
switch (hashTableKeyType) {
case BOOLEAN:
            longKey=((BooleanWritable)keyObject).get() ? 1 : 0;
          break;
case BYTE:
        longKey=((ByteWritable)keyObject).get();
      break;
case SHORT:
    longKey=((ShortWritable)keyObject).get();
  break;
case INT:
longKey=((IntWritable)keyObject).get();
break;
case LONG:
longKey=((LongWritable)keyObject).get();
break;
default :
throw new RuntimeException("Unexpected hash table key type " + hashTableKeyType.name());
}
joinResult=longHashMap.lookup(longKey,hashMapResult);
if (joinResult != JoinUtil.JoinResult.MATCH) {
assertTrue(false);
}
}
break;
case STRING:
{
Object[] keyRow=element.getKeyRow();
Object keyObject=keyRow[0];
VectorMapJoinFastStringHashMap stringHashMap=(VectorMapJoinFastStringHashMap)map;
hashMapResult=stringHashMap.createHashMapResult();
Text text=(Text)keyObject;
byte[] bytes=text.getBytes();
int length=text.getLength();
joinResult=stringHashMap.lookup(bytes,0,length,hashMapResult);
if (joinResult != JoinUtil.JoinResult.MATCH) {
assertTrue(false);
}
}
break;
case MULTI_KEY:
{
byte[] keyBytes=element.getKey();
VectorMapJoinFastMultiKeyHashMap stringHashMap=(VectorMapJoinFastMultiKeyHashMap)map;
hashMapResult=stringHashMap.createHashMapResult();
joinResult=stringHashMap.lookup(keyBytes,0,keyBytes.length,hashMapResult);
if (joinResult != JoinUtil.JoinResult.MATCH) {
assertTrue(false);
}
}
break;
default :
throw new RuntimeException("Unexpected hash table key type " + hashTableKeyType.name());
}
int[] actualToValueMap=verifyHashMapValues(hashMapResult,values);
List<Object[]> rows=element.getValueRows();
if (!doClipping && !useExactBytes) {
verifyHashMapRows(rows,actualToValueMap,hashMapResult,valuePrimitiveTypeInfos);
}
 else {
int clipIndex=random.nextInt(rows.size());
verifyHashMapRowsMore(rows,actualToValueMap,hashMapResult,valuePrimitiveTypeInfos,clipIndex,useExactBytes);
}
}
}
}
