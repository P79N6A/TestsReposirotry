@RunWith(MockitoJUnitRunner.class) public class TestMutatorImpl {
  private static final Object RECORD=new Object();
  private static final int RECORD_ID_COLUMN=2;
  private static final int BUCKET_ID=0;
  private static final Path PATH=new Path("X");
  private static final long TRANSACTION_ID=1L;
  @Mock private AcidOutputFormat<?,?> mockOutputFormat;
  @Mock private ObjectInspector mockObjectInspector;
  @Mock private RecordUpdater mockRecordUpdater;
  @Captor private ArgumentCaptor<AcidOutputFormat.Options> captureOptions;
  private final HiveConf configuration=new HiveConf();
  private Mutator mutator;
  @Before public void injectMocks() throws IOException {
    when(mockOutputFormat.getRecordUpdater(eq(PATH),any(Options.class))).thenReturn(mockRecordUpdater);
    mutator=new MutatorImpl(configuration,RECORD_ID_COLUMN,mockObjectInspector,mockOutputFormat,TRANSACTION_ID,PATH,BUCKET_ID);
  }
  @Test public void testCreatesRecordReader() throws IOException {
    verify(mockOutputFormat).getRecordUpdater(eq(PATH),captureOptions.capture());
    Options options=captureOptions.getValue();
    assertThat(options.getBucket(),is(BUCKET_ID));
    assertThat(options.getConfiguration(),is((Configuration)configuration));
    assertThat(options.getInspector(),is(mockObjectInspector));
    assertThat(options.getRecordIdColumn(),is(RECORD_ID_COLUMN));
    assertThat(options.getMinimumTransactionId(),is(TRANSACTION_ID));
    assertThat(options.getMaximumTransactionId(),is(TRANSACTION_ID));
  }
  @Test public void testInsertDelegates() throws IOException {
    mutator.insert(RECORD);
    verify(mockRecordUpdater).insert(TRANSACTION_ID,RECORD);
  }
  @Test public void testUpdateDelegates() throws IOException {
    mutator.update(RECORD);
    verify(mockRecordUpdater).update(TRANSACTION_ID,RECORD);
  }
  @Test public void testDeleteDelegates() throws IOException {
    mutator.delete(RECORD);
    verify(mockRecordUpdater).delete(TRANSACTION_ID,RECORD);
  }
  @Test public void testCloseDelegates() throws IOException {
    mutator.close();
    verify(mockRecordUpdater).close(false);
  }
  @Test public void testFlushDoesNothing() throws IOException {
    mutator.flush();
    verify(mockRecordUpdater,never()).flush();
  }
}
