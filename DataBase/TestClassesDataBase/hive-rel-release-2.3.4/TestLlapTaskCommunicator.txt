public class TestLlapTaskCommunicator {
  @Test(timeout=5000) public void testEntityTracker1(){
    LlapTaskCommunicator.EntityTracker entityTracker=new LlapTaskCommunicator.EntityTracker();
    String host1="host1";
    int port=1451;
    ContainerId containerId101=constructContainerId(101);
    entityTracker.registerContainer(containerId101,host1,port);
    assertEquals(LlapNodeId.getInstance(host1,port),entityTracker.getNodeIdForContainer(containerId101));
    entityTracker.unregisterContainer(containerId101);
    assertNull(entityTracker.getContainerAttemptMapForNode(LlapNodeId.getInstance(host1,port)));
    assertNull(entityTracker.getNodeIdForContainer(containerId101));
    assertEquals(0,entityTracker.nodeMap.size());
    assertEquals(0,entityTracker.attemptToNodeMap.size());
    assertEquals(0,entityTracker.containerToNodeMap.size());
    ContainerId containerId1=constructContainerId(1);
    TezTaskAttemptID taskAttemptId1=constructTaskAttemptId(1);
    entityTracker.registerTaskAttempt(containerId1,taskAttemptId1,host1,port);
    assertEquals(LlapNodeId.getInstance(host1,port),entityTracker.getNodeIdForContainer(containerId1));
    assertEquals(LlapNodeId.getInstance(host1,port),entityTracker.getNodeIdForTaskAttempt(taskAttemptId1));
    entityTracker.unregisterTaskAttempt(taskAttemptId1);
    assertNull(entityTracker.getContainerAttemptMapForNode(LlapNodeId.getInstance(host1,port)));
    assertNull(entityTracker.getNodeIdForContainer(containerId1));
    assertNull(entityTracker.getNodeIdForTaskAttempt(taskAttemptId1));
    assertEquals(0,entityTracker.nodeMap.size());
    assertEquals(0,entityTracker.attemptToNodeMap.size());
    assertEquals(0,entityTracker.containerToNodeMap.size());
    ContainerId containerId201=constructContainerId(201);
    TezTaskAttemptID taskAttemptId201=constructTaskAttemptId(201);
    entityTracker.registerTaskAttempt(containerId201,taskAttemptId201,host1,port);
    assertEquals(LlapNodeId.getInstance(host1,port),entityTracker.getNodeIdForContainer(containerId201));
    assertEquals(LlapNodeId.getInstance(host1,port),entityTracker.getNodeIdForTaskAttempt(taskAttemptId201));
    entityTracker.unregisterContainer(containerId201);
    assertNull(entityTracker.getContainerAttemptMapForNode(LlapNodeId.getInstance(host1,port)));
    assertNull(entityTracker.getNodeIdForContainer(containerId201));
    assertNull(entityTracker.getNodeIdForTaskAttempt(taskAttemptId201));
    assertEquals(0,entityTracker.nodeMap.size());
    assertEquals(0,entityTracker.attemptToNodeMap.size());
    assertEquals(0,entityTracker.containerToNodeMap.size());
    entityTracker.unregisterTaskAttempt(taskAttemptId201);
  }
  @Test(timeout=5000) public void testFinishableStateUpdateFailure() throws Exception {
    LlapTaskCommunicatorWrapperForTest wrapper=null;
    Lock lock=new ReentrantLock();
    Condition condition=lock.newCondition();
    final AtomicBoolean opDone=new AtomicBoolean(false);
    LlapProtocolClientProxy proxy=mock(LlapProtocolClientProxy.class,new FinishableStatusUpdateTestAnswer(lock,condition,opDone));
    try {
      wrapper=new LlapTaskCommunicatorWrapperForTest(proxy);
      ContainerId cId11=wrapper.registerContainer(1,0);
      TaskSpec ts11=wrapper.registerRunningTaskAttemptWithSourceVertex(cId11,1);
      ContainerId cId12=wrapper.registerContainer(2,0);
      TaskSpec ts12=wrapper.registerRunningTaskAttemptWithSourceVertex(cId12,2);
      ContainerId cId21=wrapper.registerContainer(3,1);
      TaskSpec ts21=wrapper.registerRunningTaskAttemptWithSourceVertex(cId21,3);
      VertexStateUpdate vertexStateUpdate=new VertexStateUpdate(LlapTaskCommunicatorWrapperForTest.VERTEX_NAME1,VertexState.SUCCEEDED);
      wrapper.getTaskCommunicator().onVertexStateUpdated(vertexStateUpdate);
      lock.lock();
      try {
        while (!opDone.get()) {
          condition.await();
        }
      }
  finally {
        lock.unlock();
      }
      verify(wrapper.getTaskCommunicatorContext(),times(2)).taskKilled(any(TezTaskAttemptID.class),any(TaskAttemptEndReason.class),any(String.class));
      verify(wrapper.getTaskCommunicatorContext()).taskKilled(eq(ts11.getTaskAttemptID()),eq(TaskAttemptEndReason.NODE_FAILED),any(String.class));
      verify(wrapper.getTaskCommunicatorContext()).taskKilled(eq(ts12.getTaskAttemptID()),eq(TaskAttemptEndReason.NODE_FAILED),any(String.class));
      wrapper.getTaskCommunicator().sendStateUpdate(LlapNodeId.getInstance(LlapTaskCommunicatorWrapperForTest.HOSTS[1],LlapTaskCommunicatorWrapperForTest.RPC_PORT),LlapDaemonProtocolProtos.SourceStateUpdatedRequestProto.getDefaultInstance());
      verify(wrapper.getTaskCommunicatorContext(),times(2)).taskKilled(any(TezTaskAttemptID.class),any(TaskAttemptEndReason.class),any(String.class));
    }
  finally {
      if (wrapper != null) {
        wrapper.shutdown();
      }
    }
  }
static class FinishableStatusUpdateTestAnswer implements Answer<Void> {
    final Lock lock;
    final Condition condition;
    final AtomicBoolean opDone;
    final AtomicBoolean successInvoked=new AtomicBoolean(false);
    final AtomicBoolean failInvoked=new AtomicBoolean(false);
    FinishableStatusUpdateTestAnswer(    Lock lock,    Condition condition,    AtomicBoolean opDone){
      this.lock=lock;
      this.condition=condition;
      this.opDone=opDone;
    }
    void reset(){
      opDone.set(false);
      successInvoked.set(false);
      failInvoked.set(false);
    }
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      if (invocation.getMethod().getName().equals("sendSourceStateUpdate")) {
        LlapNodeId nodeId=(LlapNodeId)invocation.getArguments()[1];
        final LlapProtocolClientProxy.ExecuteRequestCallback callback=(LlapProtocolClientProxy.ExecuteRequestCallback)invocation.getArguments()[2];
        if (nodeId.getHostname().equals(LlapTaskCommunicatorWrapperForTest.HOSTS[0])) {
          new Thread(){
            public void run(){
              callback.indicateError(new IOException("Force failing " + LlapTaskCommunicatorWrapperForTest.HOSTS[0]));
              successInvoked.set(true);
              signalOpDoneIfBothInvoked();
            }
          }
.start();
        }
 else {
          new Thread(){
            public void run(){
              callback.setResponse(LlapDaemonProtocolProtos.SourceStateUpdatedResponseProto.getDefaultInstance());
              failInvoked.set(true);
              signalOpDoneIfBothInvoked();
            }
          }
.start();
        }
      }
      return null;
    }
    private void signalOpDoneIfBothInvoked(){
      lock.lock();
      try {
        if (failInvoked.get() && successInvoked.get()) {
          opDone.set(true);
          condition.signal();
        }
      }
  finally {
        lock.unlock();
      }
    }
  }
  /** 
 * Wrapper class which is responsible for setting up various mocks required for different tests.
 */
private static class LlapTaskCommunicatorWrapperForTest {
    static final String[] HOSTS=new String[]{"host1","host2","host3"};
    static final int RPC_PORT=15002;
    static final String DAG_NAME="dagName";
    static final String VERTEX_NAME1="vertexName1";
    static final String VERTEX_NAME2="vertexName2";
    final TaskCommunicatorContext taskCommunicatorContext=mock(TaskCommunicatorContext.class);
    final ApplicationId appId=ApplicationId.newInstance(1000,1);
    final ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,100);
    final TezDAGID dagid=TezDAGID.getInstance(appId,200);
    final TezVertexID vertexId1=TezVertexID.getInstance(dagid,300);
    final TezVertexID vertexId2=TezVertexID.getInstance(dagid,301);
    final Configuration conf=new Configuration(false);
    final UserPayload userPayload;
    final LlapTaskCommunicatorForTest taskCommunicator;
    public LlapTaskCommunicatorWrapperForTest(    LlapProtocolClientProxy llapProxy) throws Exception {
      HiveConf.setVar(conf,HiveConf.ConfVars.LLAP_DAEMON_SERVICE_HOSTS,"fake-non-zk-cluster");
      userPayload=TezUtils.createUserPayloadFromConf(conf);
      doReturn(appAttemptId).when(taskCommunicatorContext).getApplicationAttemptId();
      doReturn(new Credentials()).when(taskCommunicatorContext).getAMCredentials();
      doReturn(userPayload).when(taskCommunicatorContext).getInitialUserPayload();
      doReturn(appId.toString()).when(taskCommunicatorContext).getCurrentAppIdentifier();
      DagInfo dagInfo=mock(DagInfo.class);
      doReturn(dagInfo).when(taskCommunicatorContext).getCurrentDagInfo();
      doReturn(DAG_NAME).when(dagInfo).getName();
      doReturn(new Credentials()).when(dagInfo).getCredentials();
      doReturn(new LinkedList<String>()).when(taskCommunicatorContext).getInputVertexNames(any(String.class));
      this.taskCommunicator=new LlapTaskCommunicatorForTest(taskCommunicatorContext,llapProxy);
      this.taskCommunicator.initialize();
      this.taskCommunicator.start();
    }
    void shutdown(){
      this.taskCommunicator.shutdown();
    }
    TaskCommunicatorContext getTaskCommunicatorContext(){
      return taskCommunicatorContext;
    }
    LlapTaskCommunicatorForTest getTaskCommunicator(){
      return taskCommunicator;
    }
    ContainerId registerContainer(    int containerIdx,    int hostIdx){
      ContainerId containerId=ContainerId.newInstance(appAttemptId,containerIdx);
      taskCommunicator.registerRunningContainer(containerId,HOSTS[hostIdx],RPC_PORT);
      return containerId;
    }
    TaskSpec registerRunningTaskAttemptWithSourceVertex(    ContainerId containerId,    int taskIdx){
      TaskSpec taskSpec=createBaseTaskSpec(VERTEX_NAME2,vertexId2,taskIdx);
      InputSpec inputSpec=new InputSpec(VERTEX_NAME1,InputDescriptor.create("fakeInputClassName"),3);
      List<InputSpec> inputs=Lists.newArrayList(inputSpec);
      doReturn(inputs).when(taskSpec).getInputs();
      taskCommunicator.registerRunningTaskAttempt(containerId,taskSpec,new HashMap<String,LocalResource>(),new Credentials(),false,2);
      return taskSpec;
    }
    TaskSpec registerRunningTaskAttempt(    ContainerId containerId,    int taskIdx){
      TaskSpec taskSpec=createBaseTaskSpec(VERTEX_NAME1,vertexId1,taskIdx);
      taskCommunicator.registerRunningTaskAttempt(containerId,taskSpec,new HashMap<String,LocalResource>(),new Credentials(),false,2);
      return taskSpec;
    }
    private TaskSpec createBaseTaskSpec(    String vertexName,    TezVertexID vertexId,    int taskIdx){
      TaskSpec taskSpec=mock(TaskSpec.class);
      Configuration conf=new Configuration(false);
      HiveConf.setVar(conf,HiveConf.ConfVars.HIVEQUERYID,"fakeQueryId");
      UserPayload userPayload;
      try {
        userPayload=TezUtils.createUserPayloadFromConf(conf);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
      TezTaskAttemptID taskAttemptId=TezTaskAttemptID.getInstance(TezTaskID.getInstance(vertexId,taskIdx),0);
      doReturn(taskAttemptId).when(taskSpec).getTaskAttemptID();
      doReturn(DAG_NAME).when(taskSpec).getDAGName();
      doReturn(vertexName).when(taskSpec).getVertexName();
      ProcessorDescriptor processorDescriptor=ProcessorDescriptor.create("fakeClassName").setUserPayload(userPayload);
      doReturn(processorDescriptor).when(taskSpec).getProcessorDescriptor();
      return taskSpec;
    }
  }
  private ContainerId constructContainerId(  int id){
    ContainerId containerId=mock(ContainerId.class);
    doReturn(id).when(containerId).getId();
    doReturn((long)id).when(containerId).getContainerId();
    return containerId;
  }
  private TezTaskAttemptID constructTaskAttemptId(  int id){
    TezTaskAttemptID taskAttemptId=mock(TezTaskAttemptID.class);
    doReturn(id).when(taskAttemptId).getId();
    return taskAttemptId;
  }
private static class LlapTaskCommunicatorForTest extends LlapTaskCommunicator {
    private final LlapProtocolClientProxy llapProxy;
    public LlapTaskCommunicatorForTest(    TaskCommunicatorContext taskCommunicatorContext){
      this(taskCommunicatorContext,mock(LlapProtocolClientProxy.class));
    }
    public LlapTaskCommunicatorForTest(    TaskCommunicatorContext taskCommunicatorContext,    LlapProtocolClientProxy llapProxy){
      super(taskCommunicatorContext);
      this.llapProxy=llapProxy;
    }
    @Override protected void startRpcServer(){
    }
    @Override protected LlapProtocolClientProxy createLlapProtocolClientProxy(    int numThreads,    Configuration conf){
      return llapProxy;
    }
    @Override public InetSocketAddress getAddress(){
      return InetSocketAddress.createUnresolved("localhost",15001);
    }
    @Override public String getAmHostString(){
      return "localhost";
    }
  }
}
