@RunWith(MockitoJUnitRunner.class) public class TestLock {
  private static final Table SOURCE_TABLE_1=createTable("DB","SOURCE_1");
  private static final Table SOURCE_TABLE_2=createTable("DB","SOURCE_2");
  private static final Table SINK_TABLE=createTable("DB","SINK");
  private static final Set<Table> SOURCES=ImmutableSet.of(SOURCE_TABLE_1,SOURCE_TABLE_2);
  private static final Set<Table> SINKS=ImmutableSet.of(SINK_TABLE);
  private static final Set<Table> TABLES=ImmutableSet.of(SOURCE_TABLE_1,SOURCE_TABLE_2,SINK_TABLE);
  private static final long LOCK_ID=42;
  private static final long TRANSACTION_ID=109;
  private static final String USER="ewest";
  @Mock private IMetaStoreClient mockMetaStoreClient;
  @Mock private LockFailureListener mockListener;
  @Mock private LockResponse mockLockResponse;
  @Mock private HeartbeatFactory mockHeartbeatFactory;
  @Mock private Timer mockHeartbeat;
  @Captor private ArgumentCaptor<LockRequest> requestCaptor;
  private Lock readLock;
  private Lock writeLock;
  private HiveConf configuration=new HiveConf();
  @Before public void injectMocks() throws Exception {
    when(mockMetaStoreClient.lock(any(LockRequest.class))).thenReturn(mockLockResponse);
    when(mockLockResponse.getLockid()).thenReturn(LOCK_ID);
    when(mockLockResponse.getState()).thenReturn(ACQUIRED);
    when(mockHeartbeatFactory.newInstance(any(IMetaStoreClient.class),any(LockFailureListener.class),any(Long.class),any(Collection.class),anyLong(),anyInt())).thenReturn(mockHeartbeat);
    readLock=new Lock(mockMetaStoreClient,mockHeartbeatFactory,configuration,mockListener,USER,SOURCES,Collections.<Table>emptySet(),3,0);
    writeLock=new Lock(mockMetaStoreClient,mockHeartbeatFactory,configuration,mockListener,USER,SOURCES,SINKS,3,0);
  }
  @Test public void testAcquireReadLockWithNoIssues() throws Exception {
    readLock.acquire();
    assertEquals(Long.valueOf(LOCK_ID),readLock.getLockId());
    assertNull(readLock.getTransactionId());
  }
  @Test(expected=IllegalArgumentException.class) public void testAcquireWriteLockWithoutTxn() throws Exception {
    writeLock.acquire();
  }
  @Test(expected=IllegalArgumentException.class) public void testAcquireWriteLockWithInvalidTxn() throws Exception {
    writeLock.acquire(0);
  }
  @Test public void testAcquireTxnLockWithNoIssues() throws Exception {
    writeLock.acquire(TRANSACTION_ID);
    assertEquals(Long.valueOf(LOCK_ID),writeLock.getLockId());
    assertEquals(Long.valueOf(TRANSACTION_ID),writeLock.getTransactionId());
  }
  @Test public void testAcquireReadLockCheckHeartbeatCreated() throws Exception {
    configuration.set("hive.txn.timeout","100s");
    readLock.acquire();
    verify(mockHeartbeatFactory).newInstance(eq(mockMetaStoreClient),eq(mockListener),any(Long.class),eq(SOURCES),eq(LOCK_ID),eq(75));
  }
  @Test public void testAcquireTxnLockCheckHeartbeatCreated() throws Exception {
    configuration.set("hive.txn.timeout","100s");
    writeLock.acquire(TRANSACTION_ID);
    verify(mockHeartbeatFactory).newInstance(eq(mockMetaStoreClient),eq(mockListener),eq(TRANSACTION_ID),eq(TABLES),eq(LOCK_ID),eq(75));
  }
  @Test public void testAcquireLockCheckUser() throws Exception {
    readLock.acquire();
    verify(mockMetaStoreClient).lock(requestCaptor.capture());
    LockRequest actualRequest=requestCaptor.getValue();
    assertEquals(USER,actualRequest.getUser());
  }
  @Test public void testAcquireReadLockCheckLocks() throws Exception {
    readLock.acquire();
    verify(mockMetaStoreClient).lock(requestCaptor.capture());
    LockRequest request=requestCaptor.getValue();
    assertEquals(0,request.getTxnid());
    assertEquals(USER,request.getUser());
    assertEquals(InetAddress.getLocalHost().getHostName(),request.getHostname());
    List<LockComponent> components=request.getComponent();
    assertEquals(2,components.size());
    LockComponent expected1=new LockComponent(LockType.SHARED_READ,LockLevel.TABLE,"DB");
    expected1.setTablename("SOURCE_1");
    expected1.setOperationType(DataOperationType.INSERT);
    expected1.setIsAcid(true);
    assertTrue(components.contains(expected1));
    LockComponent expected2=new LockComponent(LockType.SHARED_READ,LockLevel.TABLE,"DB");
    expected2.setTablename("SOURCE_2");
    expected2.setOperationType(DataOperationType.INSERT);
    expected2.setIsAcid(true);
    assertTrue(components.contains(expected2));
  }
  @Test public void testAcquireTxnLockCheckLocks() throws Exception {
    writeLock.acquire(TRANSACTION_ID);
    verify(mockMetaStoreClient).lock(requestCaptor.capture());
    LockRequest request=requestCaptor.getValue();
    assertEquals(TRANSACTION_ID,request.getTxnid());
    assertEquals(USER,request.getUser());
    assertEquals(InetAddress.getLocalHost().getHostName(),request.getHostname());
    List<LockComponent> components=request.getComponent();
    assertEquals(3,components.size());
    LockComponent expected1=new LockComponent(LockType.SHARED_READ,LockLevel.TABLE,"DB");
    expected1.setTablename("SOURCE_1");
    expected1.setOperationType(DataOperationType.INSERT);
    expected1.setIsAcid(true);
    assertTrue(components.contains(expected1));
    LockComponent expected2=new LockComponent(LockType.SHARED_READ,LockLevel.TABLE,"DB");
    expected2.setTablename("SOURCE_2");
    expected2.setOperationType(DataOperationType.INSERT);
    expected2.setIsAcid(true);
    assertTrue(components.contains(expected2));
    LockComponent expected3=new LockComponent(LockType.SHARED_WRITE,LockLevel.TABLE,"DB");
    expected3.setTablename("SINK");
    expected3.setOperationType(DataOperationType.UPDATE);
    expected3.setIsAcid(true);
    assertTrue(components.contains(expected3));
  }
  @Test(expected=LockException.class) public void testAcquireLockNotAcquired() throws Exception {
    when(mockLockResponse.getState()).thenReturn(NOT_ACQUIRED);
    readLock.acquire();
  }
  @Test(expected=LockException.class) public void testAcquireLockAborted() throws Exception {
    when(mockLockResponse.getState()).thenReturn(ABORT);
    readLock.acquire();
  }
  @Test(expected=LockException.class) public void testAcquireLockWithWaitRetriesExceeded() throws Exception {
    when(mockLockResponse.getState()).thenReturn(WAITING,WAITING,WAITING);
    readLock.acquire();
  }
  @Test public void testAcquireLockWithWaitRetries() throws Exception {
    when(mockLockResponse.getState()).thenReturn(WAITING,WAITING,ACQUIRED);
    readLock.acquire();
    assertEquals(Long.valueOf(LOCK_ID),readLock.getLockId());
  }
  @Test public void testReleaseLock() throws Exception {
    readLock.acquire();
    readLock.release();
    verify(mockMetaStoreClient).unlock(LOCK_ID);
  }
  @Test public void testReleaseLockNoLock() throws Exception {
    readLock.release();
    verifyNoMoreInteractions(mockMetaStoreClient);
  }
  @Test public void testReleaseLockCancelsHeartbeat() throws Exception {
    readLock.acquire();
    readLock.release();
    verify(mockHeartbeat).cancel();
  }
  @Test public void testReadHeartbeat() throws Exception {
    HeartbeatTimerTask task=new HeartbeatTimerTask(mockMetaStoreClient,mockListener,null,SOURCES,LOCK_ID);
    task.run();
    verify(mockMetaStoreClient).heartbeat(0,LOCK_ID);
  }
  @Test public void testTxnHeartbeat() throws Exception {
    HeartbeatTimerTask task=new HeartbeatTimerTask(mockMetaStoreClient,mockListener,TRANSACTION_ID,SOURCES,LOCK_ID);
    task.run();
    verify(mockMetaStoreClient).heartbeat(TRANSACTION_ID,LOCK_ID);
  }
  @Test public void testReadHeartbeatFailsNoSuchLockException() throws Exception {
    Throwable t=new NoSuchLockException();
    doThrow(t).when(mockMetaStoreClient).heartbeat(0,LOCK_ID);
    HeartbeatTimerTask task=new HeartbeatTimerTask(mockMetaStoreClient,mockListener,null,SOURCES,LOCK_ID);
    task.run();
    verify(mockListener).lockFailed(LOCK_ID,null,Lock.asStrings(SOURCES),t);
  }
  @Test public void testTxnHeartbeatFailsNoSuchLockException() throws Exception {
    Throwable t=new NoSuchLockException();
    doThrow(t).when(mockMetaStoreClient).heartbeat(TRANSACTION_ID,LOCK_ID);
    HeartbeatTimerTask task=new HeartbeatTimerTask(mockMetaStoreClient,mockListener,TRANSACTION_ID,SOURCES,LOCK_ID);
    task.run();
    verify(mockListener).lockFailed(LOCK_ID,TRANSACTION_ID,Lock.asStrings(SOURCES),t);
  }
  @Test public void testHeartbeatFailsNoSuchTxnException() throws Exception {
    Throwable t=new NoSuchTxnException();
    doThrow(t).when(mockMetaStoreClient).heartbeat(TRANSACTION_ID,LOCK_ID);
    HeartbeatTimerTask task=new HeartbeatTimerTask(mockMetaStoreClient,mockListener,TRANSACTION_ID,SOURCES,LOCK_ID);
    task.run();
    verify(mockListener).lockFailed(LOCK_ID,TRANSACTION_ID,Lock.asStrings(SOURCES),t);
  }
  @Test public void testHeartbeatFailsTxnAbortedException() throws Exception {
    Throwable t=new TxnAbortedException();
    doThrow(t).when(mockMetaStoreClient).heartbeat(TRANSACTION_ID,LOCK_ID);
    HeartbeatTimerTask task=new HeartbeatTimerTask(mockMetaStoreClient,mockListener,TRANSACTION_ID,SOURCES,LOCK_ID);
    task.run();
    verify(mockListener).lockFailed(LOCK_ID,TRANSACTION_ID,Lock.asStrings(SOURCES),t);
  }
  @Test public void testHeartbeatContinuesTException() throws Exception {
    Throwable t=new TException();
    doThrow(t).when(mockMetaStoreClient).heartbeat(0,LOCK_ID);
    HeartbeatTimerTask task=new HeartbeatTimerTask(mockMetaStoreClient,mockListener,TRANSACTION_ID,SOURCES,LOCK_ID);
    task.run();
    verifyZeroInteractions(mockListener);
  }
  private static Table createTable(  String databaseName,  String tableName){
    Table table=new Table();
    table.setDbName(databaseName);
    table.setTableName(tableName);
    return table;
  }
}
