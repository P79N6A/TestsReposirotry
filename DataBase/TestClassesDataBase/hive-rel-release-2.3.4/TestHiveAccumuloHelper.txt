public class TestHiveAccumuloHelper {
  private static final Logger log=Logger.getLogger(TestHiveAccumuloHelper.class);
  private HiveAccumuloHelper helper;
  @Before public void setup(){
    helper=new HiveAccumuloHelper();
  }
  @Test public void testTokenMerge() throws Exception {
    final Text service=new Text("service");
    Token<?> token=Mockito.mock(Token.class);
    JobConf jobConf=new JobConf();
    Mockito.when(token.getService()).thenReturn(service);
    try {
      helper.mergeTokenIntoJobConf(jobConf,token);
    }
 catch (    IOException e) {
      log.info("Ignoring exception, likely coming from Hadoop 1",e);
      return;
    }
    Collection<Token<?>> tokens=jobConf.getCredentials().getAllTokens();
    assertEquals(1,tokens.size());
    assertEquals(service,tokens.iterator().next().getService());
  }
  @Test public void testTokenToConfFromUser() throws Exception {
    UserGroupInformation ugi=Mockito.mock(UserGroupInformation.class);
    JobConf jobConf=new JobConf();
    ArrayList<Token<?>> tokens=new ArrayList<>();
    Text service=new Text("service");
    Token<?> token=Mockito.mock(Token.class);
    tokens.add(token);
    Mockito.when(ugi.getTokens()).thenReturn(tokens);
    Mockito.when(token.getKind()).thenReturn(HiveAccumuloHelper.ACCUMULO_SERVICE);
    Mockito.when(token.getService()).thenReturn(service);
    try {
      helper.addTokenFromUserToJobConf(ugi,jobConf);
    }
 catch (    IOException e) {
      log.info("Ignoring exception, likely coming from Hadoop 1",e);
      return;
    }
    Collection<Token<?>> credTokens=jobConf.getCredentials().getAllTokens();
    assertEquals(1,credTokens.size());
    assertEquals(service,credTokens.iterator().next().getService());
  }
  @Test(expected=IllegalStateException.class) public void testISEIsPropagated() throws Exception {
    final HiveAccumuloHelper helper=Mockito.mock(HiveAccumuloHelper.class);
    final JobConf jobConf=Mockito.mock(JobConf.class);
    final Class<?> inputOrOutputFormatClass=AccumuloInputFormat.class;
    final String zookeepers="localhost:2181";
    final String instanceName="accumulo_instance";
    final boolean useSasl=false;
    Mockito.doCallRealMethod().when(helper).setZooKeeperInstance(jobConf,inputOrOutputFormatClass,zookeepers,instanceName,useSasl);
    Mockito.doThrow(new IllegalStateException()).when(helper).setZooKeeperInstanceWithReflection(jobConf,inputOrOutputFormatClass,zookeepers,instanceName,useSasl);
    helper.setZooKeeperInstance(jobConf,inputOrOutputFormatClass,zookeepers,instanceName,useSasl);
  }
  @Test(expected=IllegalStateException.class) public void testISEIsPropagatedWithReflection() throws Exception {
    final HiveAccumuloHelper helper=Mockito.mock(HiveAccumuloHelper.class);
    final JobConf jobConf=Mockito.mock(JobConf.class);
    final Class<?> inputOrOutputFormatClass=AccumuloInputFormat.class;
    final String zookeepers="localhost:2181";
    final String instanceName="accumulo_instance";
    final boolean useSasl=false;
    Mockito.doCallRealMethod().when(helper).setZooKeeperInstance(jobConf,inputOrOutputFormatClass,zookeepers,instanceName,useSasl);
    Mockito.doThrow(new InvocationTargetException(new IllegalStateException())).when(helper).setZooKeeperInstanceWithReflection(jobConf,inputOrOutputFormatClass,zookeepers,instanceName,useSasl);
    helper.setZooKeeperInstance(jobConf,inputOrOutputFormatClass,zookeepers,instanceName,useSasl);
  }
}
