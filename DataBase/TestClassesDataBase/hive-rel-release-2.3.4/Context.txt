/** 
 * class used to encapsulate a context which is normally used by a single TestSuite or across TestSuites when multi-threaded testing is turned on
 */
public static class Context {
  protected String testDir;
  protected ManyMiniCluster cluster;
  protected Configuration hbaseConf;
  protected Configuration jobConf;
  protected HiveConf hiveConf;
  protected FileSystem fileSystem;
  protected int usageCount=0;
  public Context(  String handle){
    testDir=new File(TEST_DIR + "/test_" + handle+ "_"+ Math.abs(new Random().nextLong())+ "/").getPath();
    System.out.println("Cluster work directory: " + testDir);
  }
  public void start(){
    if (usageCount++ == 0) {
      ManyMiniCluster.Builder b=ManyMiniCluster.create(new File(testDir));
      if (testConf != null) {
        b.hbaseConf(HBaseConfiguration.create(testConf));
      }
      cluster=b.build();
      cluster.start();
      this.hbaseConf=cluster.getHBaseConf();
      jobConf=cluster.getJobConf();
      fileSystem=cluster.getFileSystem();
      hiveConf=cluster.getHiveConf();
    }
  }
  public void stop(){
    if (--usageCount == 0) {
      try {
        cluster.stop();
        cluster=null;
      }
  finally {
        System.out.println("Trying to cleanup: " + testDir);
        try {
          FileSystem fs=FileSystem.get(jobConf);
          fs.delete(new Path(testDir),true);
        }
 catch (        IOException e) {
          throw new IllegalStateException("Failed to cleanup test dir",e);
        }
      }
    }
  }
  public String getTestDir(){
    return testDir;
  }
  public ManyMiniCluster getCluster(){
    return cluster;
  }
  public Configuration getHbaseConf(){
    return hbaseConf;
  }
  public Configuration getJobConf(){
    return jobConf;
  }
  public HiveConf getHiveConf(){
    return hiveConf;
  }
  public FileSystem getFileSystem(){
    return fileSystem;
  }
}
