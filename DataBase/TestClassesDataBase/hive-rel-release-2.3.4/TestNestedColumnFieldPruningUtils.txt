@RunWith(Parameterized.class) public class TestNestedColumnFieldPruningUtils {
  @Parameterized.Parameters public static Collection<Object[]> data(){
    return Arrays.asList(new Object[][]{{"root[a]",new String[]{"root.a.b.c"},"root[a]"},{"root[a[b[d,e]],c]",new String[]{"root.a.b.c"},"root[a[b[d,e,c]],c]"},{"root[a[b[c]]]",new String[]{"root.a.b.c.d"},"root[a[b[c]]]"},{null,new String[]{"a.b.c"},"a[b[c]]"},{null,new String[]{"a.b","a.c"},"a[b,c]"},{"a[b]",new String[]{"a.b.c"},"a[b]"}});
  }
  @Parameterized.Parameter(value=0) public String origTreeExpr;
  @Parameterized.Parameter(value=1) public String[] paths;
  @Parameterized.Parameter(value=2) public String resTreeExpr;
  @org.junit.Test public void testAddNodeByPath(){
    FieldNode root=null;
    if (origTreeExpr != null) {
      root=buildTreeByExpr(origTreeExpr);
      Assert.assertEquals("The original tree is built incorrect",root.toString(),origTreeExpr);
    }
    for (    String p : paths) {
      root=NestedColumnFieldPruningUtils.addNodeByPath(root,p);
    }
    Assert.assertEquals(resTreeExpr,root.toString());
  }
  private static boolean isSpecialChar(  char element){
    return (element == '[') || (element == ']') || (element == ',');
  }
  private static FieldNode buildTreeByExpr(  String expr){
    int index=0;
    LinkedList<FieldNode> fieldStack=new LinkedList<>();
    while (index < expr.length()) {
      int i=index;
      if (isSpecialChar(expr.charAt(i))) {
        if ((expr.charAt(index) == ',') || (expr.charAt(index) == ']')) {
          FieldNode node=fieldStack.pop();
          FieldNode pre=fieldStack.peek();
          pre.addFieldNodes(node);
        }
        index++;
      }
 else {
        while (i < expr.length() && !isSpecialChar(expr.charAt(i))) {
          i++;
        }
        FieldNode current=new FieldNode(expr.substring(index,i));
        fieldStack.push(current);
        index=i;
      }
    }
    return fieldStack.pop();
  }
}
