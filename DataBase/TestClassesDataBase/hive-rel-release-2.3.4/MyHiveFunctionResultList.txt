private static class MyHiveFunctionResultList extends HiveBaseFunctionResultList {
  private static final long serialVersionUID=-1L;
  private long primaryRows;
  private int thresholdRows;
  private long separateRows;
  private Thread separateRowGenerator;
  private long rowsEmitted;
  private long separateRowsEmitted;
  private String prefix1;
  private String prefix2;
  private LinkedBlockingQueue<Boolean> queue;
  MyHiveFunctionResultList(  Iterator inputIterator){
    super(inputIterator);
  }
  void init(  long rows,  int threshold,  int separate,  String p1,  String p2){
    Preconditions.checkArgument((threshold > 0 || separate == 0) && separate < 100 && separate >= 0 && rows > 0);
    primaryRows=rows * (100 - separate) / 100;
    separateRows=rows - primaryRows;
    thresholdRows=threshold;
    prefix1=p1;
    prefix2=p2;
    if (separateRows > 0) {
      separateRowGenerator=new Thread(new Runnable(){
        @Override public void run(){
          try {
            long separateBatchSize=thresholdRows * separateRows / primaryRows;
            while (!queue.take().booleanValue()) {
              for (int i=0; i < separateBatchSize; i++) {
                collect(prefix2,separateRowsEmitted++);
              }
            }
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
          for (; separateRowsEmitted < separateRows; ) {
            collect(prefix2,separateRowsEmitted++);
          }
        }
      }
);
      queue=new LinkedBlockingQueue<Boolean>();
      separateRowGenerator.start();
    }
  }
  public void collect(  String prefix,  long id){
    String k=prefix + "_key_" + id;
    String v=prefix + "_value_" + id;
    HiveKey key=new HiveKey(k.getBytes(),k.hashCode());
    BytesWritable value=new BytesWritable(v.getBytes());
    try {
      collect(key,value);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  @Override protected void processNextRecord(  Object inputRecord) throws IOException {
    for (int i=0; i < thresholdRows; i++) {
      collect(prefix1,rowsEmitted++);
    }
    if (separateRowGenerator != null) {
      queue.add(Boolean.FALSE);
    }
  }
  @Override protected boolean processingDone(){
    return false;
  }
  @Override protected void closeRecordProcessor(){
    for (; rowsEmitted < primaryRows; ) {
      collect(prefix1,rowsEmitted++);
    }
    if (separateRowGenerator != null) {
      queue.add(Boolean.TRUE);
      try {
        separateRowGenerator.join();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}
