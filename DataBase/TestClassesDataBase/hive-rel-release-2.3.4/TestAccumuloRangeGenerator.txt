/** 
 */
public class TestAccumuloRangeGenerator {
  private AccumuloPredicateHandler handler;
  private HiveAccumuloRowIdColumnMapping rowIdMapping;
  @Before public void setup(){
    handler=AccumuloPredicateHandler.getInstance();
    rowIdMapping=new HiveAccumuloRowIdColumnMapping(AccumuloHiveConstants.ROWID,ColumnEncoding.STRING,"row",TypeInfoFactory.stringTypeInfo.toString());
  }
  @Test public void testRangeConjunction() throws Exception {
    ExprNodeDesc column=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"f");
    List<ExprNodeDesc> children=Lists.newArrayList();
    children.add(column);
    children.add(constant);
    ExprNodeDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),children);
    assertNotNull(node);
    ExprNodeDesc column2=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant2=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"m");
    List<ExprNodeDesc> children2=Lists.newArrayList();
    children2.add(column2);
    children2.add(constant2);
    ExprNodeDesc node2=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrLessThan(),children2);
    assertNotNull(node2);
    List<ExprNodeDesc> bothFilters=Lists.newArrayList();
    bothFilters.add(node);
    bothFilters.add(node2);
    ExprNodeGenericFuncDesc both=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPAnd(),bothFilters);
    List<Range> expectedRanges=Arrays.asList(new Range(new Key("f"),true,new Key("m\0"),false));
    AccumuloRangeGenerator rangeGenerator=new AccumuloRangeGenerator(handler,rowIdMapping,"rid");
    Dispatcher disp=new DefaultRuleDispatcher(rangeGenerator,Collections.<Rule,NodeProcessor>emptyMap(),null);
    GraphWalker ogw=new DefaultGraphWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    topNodes.add(both);
    HashMap<Node,Object> nodeOutput=new HashMap<Node,Object>();
    try {
      ogw.startWalking(topNodes,nodeOutput);
    }
 catch (    SemanticException ex) {
      throw new RuntimeException(ex);
    }
    Object result=nodeOutput.get(both);
    Assert.assertNotNull(result);
    Assert.assertTrue("Result from graph walk was not a List",result instanceof List);
    @SuppressWarnings("unchecked") List<Range> actualRanges=(List<Range>)result;
    Assert.assertEquals(expectedRanges,actualRanges);
  }
  @Test public void testRangeDisjunction() throws Exception {
    ExprNodeDesc column=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"f");
    List<ExprNodeDesc> children=Lists.newArrayList();
    children.add(column);
    children.add(constant);
    ExprNodeDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),children);
    assertNotNull(node);
    ExprNodeDesc column2=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant2=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"m");
    List<ExprNodeDesc> children2=Lists.newArrayList();
    children2.add(column2);
    children2.add(constant2);
    ExprNodeDesc node2=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrLessThan(),children2);
    assertNotNull(node2);
    List<ExprNodeDesc> bothFilters=Lists.newArrayList();
    bothFilters.add(node);
    bothFilters.add(node2);
    ExprNodeGenericFuncDesc both=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPOr(),bothFilters);
    List<Range> expectedRanges=Arrays.asList(new Range());
    AccumuloRangeGenerator rangeGenerator=new AccumuloRangeGenerator(handler,rowIdMapping,"rid");
    Dispatcher disp=new DefaultRuleDispatcher(rangeGenerator,Collections.<Rule,NodeProcessor>emptyMap(),null);
    GraphWalker ogw=new DefaultGraphWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    topNodes.add(both);
    HashMap<Node,Object> nodeOutput=new HashMap<Node,Object>();
    try {
      ogw.startWalking(topNodes,nodeOutput);
    }
 catch (    SemanticException ex) {
      throw new RuntimeException(ex);
    }
    Object result=nodeOutput.get(both);
    Assert.assertNotNull(result);
    Assert.assertTrue("Result from graph walk was not a List",result instanceof List);
    @SuppressWarnings("unchecked") List<Range> actualRanges=(List<Range>)result;
    Assert.assertEquals(expectedRanges,actualRanges);
  }
  @Test public void testRangeConjunctionWithDisjunction() throws Exception {
    ExprNodeDesc column=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"h");
    List<ExprNodeDesc> children=Lists.newArrayList();
    children.add(column);
    children.add(constant);
    ExprNodeDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),children);
    assertNotNull(node);
    ExprNodeDesc column2=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant2=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"d");
    List<ExprNodeDesc> children2=Lists.newArrayList();
    children2.add(column2);
    children2.add(constant2);
    ExprNodeDesc node2=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrLessThan(),children2);
    assertNotNull(node2);
    ExprNodeDesc column3=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant3=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"q");
    List<ExprNodeDesc> children3=Lists.newArrayList();
    children3.add(column3);
    children3.add(constant3);
    ExprNodeDesc node3=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),children3);
    assertNotNull(node3);
    List<ExprNodeDesc> orFilters=Lists.newArrayList();
    orFilters.add(node2);
    orFilters.add(node3);
    ExprNodeGenericFuncDesc orNode=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPOr(),orFilters);
    List<ExprNodeDesc> andFilters=Lists.newArrayList();
    andFilters.add(node);
    andFilters.add(orNode);
    ExprNodeGenericFuncDesc both=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPAnd(),andFilters);
    List<Range> expectedRanges=Arrays.asList(new Range(new Key("q"),true,null,false));
    AccumuloRangeGenerator rangeGenerator=new AccumuloRangeGenerator(handler,rowIdMapping,"rid");
    Dispatcher disp=new DefaultRuleDispatcher(rangeGenerator,Collections.<Rule,NodeProcessor>emptyMap(),null);
    GraphWalker ogw=new DefaultGraphWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    topNodes.add(both);
    HashMap<Node,Object> nodeOutput=new HashMap<Node,Object>();
    try {
      ogw.startWalking(topNodes,nodeOutput);
    }
 catch (    SemanticException ex) {
      throw new RuntimeException(ex);
    }
    Object result=nodeOutput.get(both);
    Assert.assertNotNull(result);
    Assert.assertTrue("Result from graph walk was not a List",result instanceof List);
    @SuppressWarnings("unchecked") List<Range> actualRanges=(List<Range>)result;
    Assert.assertEquals(expectedRanges,actualRanges);
  }
  @Test public void testPartialRangeConjunction() throws Exception {
    ExprNodeDesc column=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"f");
    List<ExprNodeDesc> children=Lists.newArrayList();
    children.add(column);
    children.add(constant);
    ExprNodeDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),children);
    assertNotNull(node);
    ExprNodeDesc column2=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"anythingElse",null,false);
    ExprNodeDesc constant2=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"foo");
    List<ExprNodeDesc> children2=Lists.newArrayList();
    children2.add(column2);
    children2.add(constant2);
    ExprNodeDesc node2=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrLessThan(),children2);
    assertNotNull(node2);
    List<ExprNodeDesc> bothFilters=Lists.newArrayList();
    bothFilters.add(node);
    bothFilters.add(node2);
    ExprNodeGenericFuncDesc both=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPAnd(),bothFilters);
    List<Range> expectedRanges=Arrays.asList(new Range(new Key("f"),true,null,false));
    AccumuloRangeGenerator rangeGenerator=new AccumuloRangeGenerator(handler,rowIdMapping,"rid");
    Dispatcher disp=new DefaultRuleDispatcher(rangeGenerator,Collections.<Rule,NodeProcessor>emptyMap(),null);
    GraphWalker ogw=new DefaultGraphWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    topNodes.add(both);
    HashMap<Node,Object> nodeOutput=new HashMap<Node,Object>();
    try {
      ogw.startWalking(topNodes,nodeOutput);
    }
 catch (    SemanticException ex) {
      throw new RuntimeException(ex);
    }
    Object result=nodeOutput.get(both);
    Assert.assertNotNull(result);
    Assert.assertTrue("Result from graph walk was not a List",result instanceof List);
    @SuppressWarnings("unchecked") List<Range> actualRanges=(List<Range>)result;
    Assert.assertEquals(expectedRanges,actualRanges);
  }
  @Test public void testDateRangeConjunction() throws Exception {
    ExprNodeDesc column=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant=new ExprNodeConstantDesc(TypeInfoFactory.dateTypeInfo,Date.valueOf("2014-01-01"));
    List<ExprNodeDesc> children=Lists.newArrayList();
    children.add(column);
    children.add(constant);
    ExprNodeDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),children);
    assertNotNull(node);
    ExprNodeDesc column2=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"rid",null,false);
    ExprNodeDesc constant2=new ExprNodeConstantDesc(TypeInfoFactory.dateTypeInfo,Date.valueOf("2014-07-01"));
    List<ExprNodeDesc> children2=Lists.newArrayList();
    children2.add(column2);
    children2.add(constant2);
    ExprNodeDesc node2=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPLessThan(),children2);
    assertNotNull(node2);
    List<ExprNodeDesc> bothFilters=Lists.newArrayList();
    bothFilters.add(node);
    bothFilters.add(node2);
    ExprNodeGenericFuncDesc both=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPAnd(),bothFilters);
    List<Range> expectedRanges=Arrays.asList(new Range(new Key("2014-01-01"),true,new Key("2014-07-01"),false));
    AccumuloRangeGenerator rangeGenerator=new AccumuloRangeGenerator(handler,rowIdMapping,"rid");
    Dispatcher disp=new DefaultRuleDispatcher(rangeGenerator,Collections.<Rule,NodeProcessor>emptyMap(),null);
    GraphWalker ogw=new DefaultGraphWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    topNodes.add(both);
    HashMap<Node,Object> nodeOutput=new HashMap<Node,Object>();
    try {
      ogw.startWalking(topNodes,nodeOutput);
    }
 catch (    SemanticException ex) {
      throw new RuntimeException(ex);
    }
    Object result=nodeOutput.get(both);
    Assert.assertNotNull(result);
    Assert.assertTrue("Result from graph walk was not a List",result instanceof List);
    @SuppressWarnings("unchecked") List<Range> actualRanges=(List<Range>)result;
    Assert.assertEquals(expectedRanges,actualRanges);
  }
  @Test public void testCastExpression() throws Exception {
    ExprNodeDesc fourty=new ExprNodeConstantDesc(TypeInfoFactory.intTypeInfo,40), fifty=new ExprNodeConstantDesc(TypeInfoFactory.intTypeInfo,50);
    GenericUDFOPPlus plus=new GenericUDFOPPlus();
    ExprNodeGenericFuncDesc addition=new ExprNodeGenericFuncDesc(TypeInfoFactory.intTypeInfo,plus,Arrays.asList(fourty,fifty));
    UDFToString stringCast=new UDFToString();
    GenericUDFBridge stringCastBridge=new GenericUDFBridge("cast",false,stringCast.getClass().getName());
    ExprNodeGenericFuncDesc cast=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,stringCastBridge,"cast",Collections.<ExprNodeDesc>singletonList(addition));
    ExprNodeDesc key=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"key",null,false);
    ExprNodeGenericFuncDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),Arrays.asList(key,cast));
    AccumuloRangeGenerator rangeGenerator=new AccumuloRangeGenerator(handler,rowIdMapping,"key");
    Dispatcher disp=new DefaultRuleDispatcher(rangeGenerator,Collections.<Rule,NodeProcessor>emptyMap(),null);
    GraphWalker ogw=new DefaultGraphWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    topNodes.add(node);
    HashMap<Node,Object> nodeOutput=new HashMap<Node,Object>();
    try {
      ogw.startWalking(topNodes,nodeOutput);
    }
 catch (    SemanticException ex) {
      throw new RuntimeException(ex);
    }
    Object result=nodeOutput.get(node);
    Assert.assertNull(result);
  }
  @Test public void testRangeOverNonRowIdField() throws Exception {
    ExprNodeDesc column=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"foo",null,false);
    ExprNodeDesc constant=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"f");
    List<ExprNodeDesc> children=Lists.newArrayList();
    children.add(column);
    children.add(constant);
    ExprNodeDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrGreaterThan(),children);
    assertNotNull(node);
    ExprNodeDesc column2=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"foo",null,false);
    ExprNodeDesc constant2=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"m");
    List<ExprNodeDesc> children2=Lists.newArrayList();
    children2.add(column2);
    children2.add(constant2);
    ExprNodeDesc node2=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrLessThan(),children2);
    assertNotNull(node2);
    List<ExprNodeDesc> bothFilters=Lists.newArrayList();
    bothFilters.add(node);
    bothFilters.add(node2);
    ExprNodeGenericFuncDesc both=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPAnd(),bothFilters);
    AccumuloRangeGenerator rangeGenerator=new AccumuloRangeGenerator(handler,rowIdMapping,"rid");
    Dispatcher disp=new DefaultRuleDispatcher(rangeGenerator,Collections.<Rule,NodeProcessor>emptyMap(),null);
    GraphWalker ogw=new DefaultGraphWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    topNodes.add(both);
    HashMap<Node,Object> nodeOutput=new HashMap<Node,Object>();
    try {
      ogw.startWalking(topNodes,nodeOutput);
    }
 catch (    SemanticException ex) {
      throw new RuntimeException(ex);
    }
    Object result=nodeOutput.get(both);
    Assert.assertNull(result);
  }
}
