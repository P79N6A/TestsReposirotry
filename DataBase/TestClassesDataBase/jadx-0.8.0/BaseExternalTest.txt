public abstract class BaseExternalTest extends IntegrationTest {
  private static final Logger LOG=LoggerFactory.getLogger(BaseExternalTest.class);
  protected abstract String getSamplesDir();
  protected JadxArgs prepare(  String inputFile){
    JadxArgs args=new JadxArgs();
    args.getInputFiles().add(new File(getSamplesDir(),inputFile));
    args.setOutDir(new File("../jadx-external-tests-tmp"));
    return args;
  }
  protected void decompile(  JadxArgs jadxArgs){
    decompile(jadxArgs,null,null);
  }
  protected void decompile(  JadxArgs jadxArgs,  String clsPatternStr){
    decompile(jadxArgs,clsPatternStr,null);
  }
  protected void decompile(  JadxArgs jadxArgs,  @Nullable String clsPatternStr,  @Nullable String mthPatternStr){
    JadxDecompiler jadx=new JadxDecompiler(jadxArgs);
    jadx.load();
    if (clsPatternStr == null) {
      processAll(jadx);
    }
 else {
      Pattern clsPtrn=Pattern.compile(clsPatternStr);
      Pattern mthPtrn=mthPatternStr == null ? null : Pattern.compile(mthPatternStr);
      processByPatterns(jadx,clsPtrn,mthPtrn);
    }
    printErrorReport(jadx);
  }
  private void processAll(  JadxDecompiler jadx){
    for (    JavaClass javaClass : jadx.getClasses()) {
      javaClass.decompile();
    }
  }
  private void processByPatterns(  JadxDecompiler jadx,  Pattern clsPattern,  @Nullable Pattern mthPattern){
    List<IDexTreeVisitor> passes=Jadx.getPassesList(jadx.getArgs());
    RootNode root=JadxInternalAccess.getRoot(jadx);
    int processed=0;
    for (    ClassNode classNode : root.getClasses(true)) {
      String clsFullName=classNode.getClassInfo().getFullName();
      if (clsPattern.matcher(clsFullName).matches()) {
        if (processCls(mthPattern,passes,classNode)) {
          processed++;
        }
      }
    }
    assertThat("No classes processed",processed,greaterThan(0));
  }
  private boolean processCls(  @Nullable Pattern mthPattern,  List<IDexTreeVisitor> passes,  ClassNode classNode){
    classNode.load();
    boolean decompile=false;
    if (mthPattern == null) {
      decompile=true;
    }
 else {
      for (      MethodNode mth : classNode.getMethods()) {
        if (mthPattern.matcher(mth.getName()).matches()) {
          decompile=true;
          break;
        }
      }
    }
    if (!decompile) {
      return false;
    }
    for (    IDexTreeVisitor visitor : passes) {
      DepthTraversal.visit(visitor,classNode);
    }
    try {
      new CodeGen().visit(classNode);
    }
 catch (    Exception e) {
      throw new JadxRuntimeException("Codegen failed",e);
    }
    LOG.warn("\n Print class: {}, {}",classNode.getFullName(),classNode.dex());
    if (mthPattern != null) {
      printMethods(classNode,mthPattern);
    }
 else {
      LOG.info("Code: \n{}",classNode.getCode());
    }
    checkCode(classNode);
    return true;
  }
  private void printMethods(  ClassNode classNode,  @NotNull Pattern mthPattern){
    String code=classNode.getCode().getCodeStr();
    if (code == null) {
      return;
    }
    String[] lines=code.split(CodeWriter.NL);
    for (    MethodNode mth : classNode.getMethods()) {
      if (mthPattern.matcher(mth.getName()).matches()) {
        int decompiledLine=mth.getDecompiledLine();
        StringBuilder mthCode=new StringBuilder();
        int brackets=0;
        for (int i=decompiledLine - 1; i > 0 && i < lines.length; i++) {
          String line=lines[i];
          mthCode.append(line).append(CodeWriter.NL);
          brackets+=StringUtils.countMatches(line,'{');
          brackets-=StringUtils.countMatches(line,'}');
          if (brackets <= 0) {
            break;
          }
        }
        LOG.info("\n{}",mthCode);
      }
    }
  }
  private void printErrorReport(  JadxDecompiler jadx){
    jadx.printErrorsReport();
    assertThat(jadx.getErrorsCount(),is(0));
  }
}
