/** 
 * Test class to verify identification of app starvation
 */
public class TestFSAppStarvation extends FairSchedulerTestBase {
  private static final File ALLOC_FILE=new File(TEST_DIR,"test-QUEUES");
  private final ControlledClock clock=new ControlledClock();
  private static final int NODE_CAPACITY_MULTIPLE=4;
  private static final String[] QUEUES={"no-preemption","minshare","fairshare.child","drf.child"};
  private FairSchedulerWithMockPreemption.MockPreemptionThread preemptionThread;
  @Before public void setup(){
    createConfiguration();
    conf.set(YarnConfiguration.RM_SCHEDULER,FairSchedulerWithMockPreemption.class.getCanonicalName());
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE,ALLOC_FILE.getAbsolutePath());
    conf.setBoolean(FairSchedulerConfiguration.PREEMPTION,true);
    conf.setFloat(FairSchedulerConfiguration.PREEMPTION_THRESHOLD,0f);
    conf.setLong(FairSchedulerConfiguration.UPDATE_INTERVAL_MS,Long.MAX_VALUE);
  }
  @After public void teardown(){
    ALLOC_FILE.delete();
    conf=null;
    if (resourceManager != null) {
      resourceManager.stop();
      resourceManager=null;
    }
  }
  @Test public void testPreemptionDisabled() throws Exception {
    conf.setBoolean(FairSchedulerConfiguration.PREEMPTION,false);
    setupClusterAndSubmitJobs();
    assertNull("Found starved apps even when preemption is turned off",scheduler.getContext().getStarvedApps());
  }
  @Test public void testPreemptionEnabled() throws Exception {
    setupClusterAndSubmitJobs();
    for (int i=0; i < 6000; ++i) {
      if (preemptionThread.uniqueAppsAdded() >= 3) {
        break;
      }
      Thread.sleep(10);
    }
    assertNotNull("FSContext does not have an FSStarvedApps instance",scheduler.getContext().getStarvedApps());
    assertEquals("Expecting 3 starved applications, one each for the " + "minshare and fairshare queues",3,preemptionThread.uniqueAppsAdded());
    clock.tickSec(1);
    scheduler.update();
    assertEquals("Apps re-added even before starvation delay passed",preemptionThread.totalAppsAdded(),preemptionThread.uniqueAppsAdded());
    verifyLeafQueueStarvation();
    clock.tickMsec(FairSchedulerWithMockPreemption.DELAY_FOR_NEXT_STARVATION_CHECK_MS);
    scheduler.update();
    for (int i=0; i < 6000; ++i) {
      if (preemptionThread.totalAppsAdded() >= preemptionThread.uniqueAppsAdded() * 2) {
        break;
      }
      Thread.sleep(10);
    }
    assertEquals("Each app should be marked as starved once" + " at each scheduler update above",preemptionThread.totalAppsAdded(),preemptionThread.uniqueAppsAdded() * 2);
  }
  @Test public void testClusterUtilizationThreshold() throws Exception {
    conf.setFloat(FairSchedulerConfiguration.PREEMPTION_THRESHOLD,1.1f);
    setupClusterAndSubmitJobs();
    assertNotNull("FSContext does not have an FSStarvedApps instance",scheduler.getContext().getStarvedApps());
    assertEquals("Found starved apps when preemption threshold is over 100%",0,preemptionThread.totalAppsAdded());
  }
  private void verifyLeafQueueStarvation(){
    for (    String q : QUEUES) {
      if (!q.equals("no-preemption")) {
        boolean isStarved=scheduler.getQueueManager().getLeafQueue(q,false).isStarved();
        assertTrue(isStarved);
      }
    }
  }
  private void setupClusterAndSubmitJobs() throws Exception {
    setupStarvedCluster();
    submitAppsToEachLeafQueue();
    sendEnoughNodeUpdatesToAssignFully();
    clock.tickMsec(10);
    scheduler.update();
  }
  /** 
 * Setup the cluster for starvation testing: 1. Create FS allocation file 2. Create and start MockRM 3. Add two nodes to the cluster 4. Submit an app that uses up all resources on the cluster
 */
  private void setupStarvedCluster() throws IOException {
    PrintWriter out=new PrintWriter(new FileWriter(ALLOC_FILE));
    out.println("<?xml version=\"1.0\"?>");
    out.println("<allocations>");
    out.println("<queue name=\"default\">");
    out.println("</queue>");
    out.println("<queue name=\"no-preemption\">");
    out.println("<fairSharePreemptionThreshold>0" + "</fairSharePreemptionThreshold>");
    out.println("</queue>");
    out.println("<queue name=\"minshare\">");
    out.println("<fairSharePreemptionThreshold>0" + "</fairSharePreemptionThreshold>");
    out.println("<minSharePreemptionTimeout>0" + "</minSharePreemptionTimeout>");
    out.println("<minResources>2048mb,2vcores</minResources>");
    out.println("</queue>");
    out.println("<queue name=\"fairshare\">");
    out.println("<fairSharePreemptionThreshold>1" + "</fairSharePreemptionThreshold>");
    out.println("<fairSharePreemptionTimeout>0" + "</fairSharePreemptionTimeout>");
    out.println("<schedulingPolicy>fair</schedulingPolicy>");
    addChildQueue(out,"fair");
    out.println("</queue>");
    out.println("<queue name=\"drf\">");
    out.println("<fairSharePreemptionThreshold>1" + "</fairSharePreemptionThreshold>");
    out.println("<fairSharePreemptionTimeout>0" + "</fairSharePreemptionTimeout>");
    out.println("<schedulingPolicy>drf</schedulingPolicy>");
    addChildQueue(out,"drf");
    out.println("</queue>");
    out.println("<defaultQueueSchedulingPolicy>drf" + "</defaultQueueSchedulingPolicy>");
    out.println("</allocations>");
    out.close();
    assertTrue("Allocation file does not exist, not running the test",ALLOC_FILE.exists());
    resourceManager=new MockRM(conf);
    scheduler=(FairScheduler)resourceManager.getResourceScheduler();
    scheduler.setClock(clock);
    resourceManager.start();
    preemptionThread=(FairSchedulerWithMockPreemption.MockPreemptionThread)scheduler.preemptionThread;
    addNode(NODE_CAPACITY_MULTIPLE * 1024,NODE_CAPACITY_MULTIPLE);
    addNode(NODE_CAPACITY_MULTIPLE * 1024,NODE_CAPACITY_MULTIPLE);
    ApplicationAttemptId app=createSchedulingRequest(1024,1,"root.default","default",8);
    scheduler.update();
    sendEnoughNodeUpdatesToAssignFully();
    assertEquals(8,scheduler.getSchedulerApp(app).getLiveContainers().size());
  }
  private void addChildQueue(  PrintWriter out,  String policy){
    out.println("<queue name=\"child\">");
    out.println("<fairSharePreemptionThreshold>1" + "</fairSharePreemptionThreshold>");
    out.println("<fairSharePreemptionTimeout>0" + "</fairSharePreemptionTimeout>");
    out.println("<schedulingPolicy>" + policy + "</schedulingPolicy>");
    out.println("</queue>");
  }
  private void submitAppsToEachLeafQueue(){
    for (    String queue : QUEUES) {
      createSchedulingRequest(1024,1,"root." + queue,"user",1);
    }
    scheduler.update();
  }
  private void sendEnoughNodeUpdatesToAssignFully(){
    for (    RMNode node : rmNodes) {
      NodeUpdateSchedulerEvent nodeUpdateSchedulerEvent=new NodeUpdateSchedulerEvent(node);
      for (int i=0; i < NODE_CAPACITY_MULTIPLE; i++) {
        scheduler.handle(nodeUpdateSchedulerEvent);
      }
    }
  }
}
