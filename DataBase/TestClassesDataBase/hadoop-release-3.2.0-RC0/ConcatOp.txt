/** 
 * concat 
 */
class ConcatOp extends AtMostOnceOp {
  private final String target;
  private final String[] srcs;
  private final Path[] srcPaths;
  ConcatOp(  DFSClient client,  Path target,  int numSrc){
    super("concat",client);
    this.target=target.toString();
    this.srcs=new String[numSrc];
    this.srcPaths=new Path[numSrc];
    Path parent=target.getParent();
    for (int i=0; i < numSrc; i++) {
      srcPaths[i]=new Path(parent,"srcfile" + i);
      srcs[i]=srcPaths[i].toString();
    }
  }
  @Override void prepare() throws Exception {
    final Path targetPath=new Path(target);
    DFSTestUtil.createFile(dfs,targetPath,BlockSize,DataNodes,0);
    for (int i=0; i < srcPaths.length; i++) {
      DFSTestUtil.createFile(dfs,srcPaths[i],BlockSize,DataNodes,0);
    }
    assertEquals(BlockSize,dfs.getFileStatus(targetPath).getLen());
  }
  @Override void invoke() throws Exception {
    client.concat(target,srcs);
  }
  @Override boolean checkNamenodeBeforeReturn() throws Exception {
    Path targetPath=new Path(target);
    boolean done=dfs.getFileStatus(targetPath).getLen() == BlockSize * (srcs.length + 1);
    for (int i=0; i < CHECKTIMES && !done; i++) {
      Thread.sleep(1000);
      done=dfs.getFileStatus(targetPath).getLen() == BlockSize * (srcs.length + 1);
    }
    return done;
  }
  @Override Object getResult(){
    return null;
  }
}
