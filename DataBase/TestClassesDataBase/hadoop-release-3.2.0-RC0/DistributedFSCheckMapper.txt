/** 
 * DistributedFSCheck mapper class.
 */
public static class DistributedFSCheckMapper extends IOMapperBase<Object> {
  public DistributedFSCheckMapper(){
  }
  public Object doIO(  Reporter reporter,  String name,  long offset) throws IOException {
    FSDataInputStream in=null;
    Path p=new Path(name);
    try {
      in=fs.open(p);
    }
 catch (    IOException e) {
      return name + "@(missing)";
    }
    in.seek(offset);
    long actualSize=0;
    try {
      long blockSize=fs.getDefaultBlockSize(p);
      reporter.setStatus("reading " + name + "@"+ offset+ "/"+ blockSize);
      for (int curSize=bufferSize; curSize == bufferSize && actualSize < blockSize; actualSize+=curSize) {
        curSize=in.read(buffer,0,bufferSize);
      }
    }
 catch (    IOException e) {
      LOG.info("Corrupted block detected in \"" + name + "\" at "+ offset);
      return name + "@" + offset;
    }
 finally {
      in.close();
    }
    return new Long(actualSize);
  }
  void collectStats(  OutputCollector<Text,Text> output,  String name,  long execTime,  Object corruptedBlock) throws IOException {
    output.collect(new Text(AccumulatingReducer.VALUE_TYPE_LONG + "blocks"),new Text(String.valueOf(1)));
    if (corruptedBlock.getClass().getName().endsWith("String")) {
      output.collect(new Text(AccumulatingReducer.VALUE_TYPE_STRING + "badBlocks"),new Text((String)corruptedBlock));
      return;
    }
    long totalSize=((Long)corruptedBlock).longValue();
    float ioRateMbSec=(float)totalSize * 1000 / (execTime * 0x100000);
    LOG.info("Number of bytes processed = " + totalSize);
    LOG.info("Exec time = " + execTime);
    LOG.info("IO rate = " + ioRateMbSec);
    output.collect(new Text(AccumulatingReducer.VALUE_TYPE_LONG + "size"),new Text(String.valueOf(totalSize)));
    output.collect(new Text(AccumulatingReducer.VALUE_TYPE_LONG + "time"),new Text(String.valueOf(execTime)));
    output.collect(new Text(AccumulatingReducer.VALUE_TYPE_FLOAT + "rate"),new Text(String.valueOf(ioRateMbSec * 1000)));
  }
}
