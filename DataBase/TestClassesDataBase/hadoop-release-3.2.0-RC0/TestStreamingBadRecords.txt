public class TestStreamingBadRecords extends ClusterMapReduceTestCase {
  private static final Logger LOG=LoggerFactory.getLogger(TestStreamingBadRecords.class);
  private static final List<String> MAPPER_BAD_RECORDS=Arrays.asList("hey022","hey023","hey099");
  private static final List<String> REDUCER_BAD_RECORDS=Arrays.asList("hey001","hey018");
  private static final String badMapper=UtilTest.makeJavaCommand(BadApp.class,new String[]{});
  private static final String badReducer=UtilTest.makeJavaCommand(BadApp.class,new String[]{"true"});
  private static final int INPUTSIZE=100;
  public TestStreamingBadRecords() throws IOException {
    UtilTest utilTest=new UtilTest(getClass().getName());
    utilTest.checkUserDir();
    utilTest.redirectIfAntJunit();
  }
  @Before public void setUp() throws Exception {
    Properties props=new Properties();
    props.setProperty(JTConfig.JT_RETIREJOBS,"false");
    props.setProperty(JTConfig.JT_PERSIST_JOBSTATUS,"false");
    startCluster(true,props);
  }
  private void createInput() throws Exception {
    OutputStream os=getFileSystem().create(new Path(getInputDir(),"text.txt"));
    Writer wr=new OutputStreamWriter(os);
    String prefix=new String(new byte[20 * 1024]);
    for (int i=1; i <= INPUTSIZE; i++) {
      String str="" + i;
      int zerosToPrepend=3 - str.length();
      for (int j=0; j < zerosToPrepend; j++) {
        str="0" + str;
      }
      wr.write(prefix + "hey" + str+ "\n");
    }
    wr.close();
  }
  private void validateOutput(  RunningJob runningJob,  boolean validateCount) throws Exception {
    LOG.info(runningJob.getCounters().toString());
    assertTrue(runningJob.isSuccessful());
    if (validateCount) {
      String counterGrp="org.apache.hadoop.mapred.Task$Counter";
      Counters counters=runningJob.getCounters();
      assertEquals(counters.findCounter(counterGrp,"MAP_SKIPPED_RECORDS").getCounter(),MAPPER_BAD_RECORDS.size());
      int mapRecs=INPUTSIZE - MAPPER_BAD_RECORDS.size();
      assertEquals(counters.findCounter(counterGrp,"MAP_INPUT_RECORDS").getCounter(),mapRecs);
      assertEquals(counters.findCounter(counterGrp,"MAP_OUTPUT_RECORDS").getCounter(),mapRecs);
      int redRecs=mapRecs - REDUCER_BAD_RECORDS.size();
      assertEquals(counters.findCounter(counterGrp,"REDUCE_SKIPPED_RECORDS").getCounter(),REDUCER_BAD_RECORDS.size());
      assertEquals(counters.findCounter(counterGrp,"REDUCE_SKIPPED_GROUPS").getCounter(),REDUCER_BAD_RECORDS.size());
      assertEquals(counters.findCounter(counterGrp,"REDUCE_INPUT_GROUPS").getCounter(),redRecs);
      assertEquals(counters.findCounter(counterGrp,"REDUCE_INPUT_RECORDS").getCounter(),redRecs);
      assertEquals(counters.findCounter(counterGrp,"REDUCE_OUTPUT_RECORDS").getCounter(),redRecs);
    }
    List<String> badRecs=new ArrayList<String>();
    badRecs.addAll(MAPPER_BAD_RECORDS);
    badRecs.addAll(REDUCER_BAD_RECORDS);
    Path[] outputFiles=FileUtil.stat2Paths(getFileSystem().listStatus(getOutputDir(),new Utils.OutputFileUtils.OutputFilesFilter()));
    if (outputFiles.length > 0) {
      InputStream is=getFileSystem().open(outputFiles[0]);
      BufferedReader reader=new BufferedReader(new InputStreamReader(is));
      String line=reader.readLine();
      int counter=0;
      while (line != null) {
        counter++;
        StringTokenizer tokeniz=new StringTokenizer(line,"\t");
        String value=tokeniz.nextToken();
        int index=value.indexOf("hey");
        assertTrue(index > -1);
        if (index > -1) {
          String heyStr=value.substring(index);
          assertTrue(!badRecs.contains(heyStr));
        }
        line=reader.readLine();
      }
      reader.close();
      if (validateCount) {
        assertEquals(INPUTSIZE - badRecs.size(),counter);
      }
    }
  }
  @Test public void testNoOp(){
  }
static class App {
    boolean isReducer;
    public App(    String[] args) throws Exception {
      if (args.length > 0) {
        isReducer=Boolean.parseBoolean(args[0]);
      }
      String counter=SkipBadRecords.COUNTER_MAP_PROCESSED_RECORDS;
      if (isReducer) {
        counter=SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS;
      }
      BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
      String line;
      int count=0;
      while ((line=in.readLine()) != null) {
        processLine(line);
        count++;
        if (count >= 10) {
          System.err.println("reporter:counter:" + SkipBadRecords.COUNTER_GROUP + ","+ counter+ ","+ count);
          count=0;
        }
      }
    }
    protected void processLine(    String line) throws Exception {
      System.out.println(line);
    }
    public static void main(    String[] args) throws Exception {
      new App(args);
    }
  }
static class BadApp extends App {
    public BadApp(    String[] args) throws Exception {
      super(args);
    }
    protected void processLine(    String line) throws Exception {
      List<String> badRecords=MAPPER_BAD_RECORDS;
      if (isReducer) {
        badRecords=REDUCER_BAD_RECORDS;
      }
      if (badRecords.size() > 0 && line.contains(badRecords.get(0))) {
        LOG.warn("Encountered BAD record");
        System.exit(-1);
      }
 else       if (badRecords.size() > 1 && line.contains(badRecords.get(1))) {
        LOG.warn("Encountered BAD record");
        throw new Exception("Got bad record..crashing");
      }
 else       if (badRecords.size() > 2 && line.contains(badRecords.get(2))) {
        LOG.warn("Encountered BAD record");
        System.exit(-1);
      }
      super.processLine(line);
    }
    public static void main(    String[] args) throws Exception {
      new BadApp(args);
    }
  }
}
