public class TestHDFSFileContextMainOperations extends FileContextMainOperationsBaseTest {
  private static MiniDFSCluster cluster;
  private static Path defaultWorkingDirectory;
  private static final HdfsConfiguration CONF=new HdfsConfiguration();
  @Override protected FileContextTestHelper createFileContextHelper(){
    return new FileContextTestHelper("/tmp/TestHDFSFileContextMainOperations");
  }
  @BeforeClass public static void clusterSetupAtBegining() throws IOException, LoginException, URISyntaxException {
    cluster=new MiniDFSCluster.Builder(CONF).numDataNodes(2).build();
    cluster.waitClusterUp();
    URI uri0=cluster.getURI(0);
    fc=FileContext.getFileContext(uri0,CONF);
    defaultWorkingDirectory=fc.makeQualified(new Path("/user/" + UserGroupInformation.getCurrentUser().getShortUserName()));
    fc.mkdir(defaultWorkingDirectory,FileContext.DEFAULT_PERM,true);
  }
  private static void restartCluster() throws IOException, LoginException {
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
    cluster=new MiniDFSCluster.Builder(CONF).numDataNodes(1).format(false).build();
    cluster.waitClusterUp();
    fc=FileContext.getFileContext(cluster.getURI(0),CONF);
    defaultWorkingDirectory=fc.makeQualified(new Path("/user/" + UserGroupInformation.getCurrentUser().getShortUserName()));
    fc.mkdir(defaultWorkingDirectory,FileContext.DEFAULT_PERM,true);
  }
  @AfterClass public static void ClusterShutdownAtEnd() throws Exception {
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  @Override @Before public void setUp() throws Exception {
    super.setUp();
  }
  @Override @After public void tearDown() throws Exception {
    super.tearDown();
  }
  @Override protected Path getDefaultWorkingDirectory(){
    return defaultWorkingDirectory;
  }
  @Override protected IOException unwrapException(  IOException e){
    if (e instanceof RemoteException) {
      return ((RemoteException)e).unwrapRemoteException();
    }
    return e;
  }
  private Path getTestRootPath(  FileContext fc,  String path){
    return fileContextTestHelper.getTestRootPath(fc,path);
  }
  @Test public void testTruncate() throws Exception {
    final short repl=3;
    final int blockSize=1024;
    final int numOfBlocks=2;
    DistributedFileSystem fs=cluster.getFileSystem();
    Path dir=getTestRootPath(fc,"test/hadoop");
    Path file=getTestRootPath(fc,"test/hadoop/file");
    final byte[] data=FileSystemTestHelper.getFileData(numOfBlocks,blockSize);
    FileSystemTestHelper.createFile(fs,file,data,blockSize,repl);
    final int newLength=blockSize;
    boolean isReady=fc.truncate(file,newLength);
    Assert.assertTrue("Recovery is not expected.",isReady);
    FileStatus fileStatus=fc.getFileStatus(file);
    Assert.assertEquals(fileStatus.getLen(),newLength);
    AppendTestUtil.checkFullFile(fs,file,newLength,data,file.toString());
    ContentSummary cs=fs.getContentSummary(dir);
    Assert.assertEquals("Bad disk space usage",cs.getSpaceConsumed(),newLength * repl);
    Assert.assertTrue(fs.delete(dir,true));
  }
  @Test public void testOldRenameWithQuota() throws Exception {
    DistributedFileSystem fs=cluster.getFileSystem();
    Path src1=getTestRootPath(fc,"test/testOldRenameWithQuota/srcdir/src1");
    Path src2=getTestRootPath(fc,"test/testOldRenameWithQuota/srcdir/src2");
    Path dst1=getTestRootPath(fc,"test/testOldRenameWithQuota/dstdir/dst1");
    Path dst2=getTestRootPath(fc,"test/testOldRenameWithQuota/dstdir/dst2");
    createFile(src1);
    createFile(src2);
    fs.setQuota(src1.getParent(),HdfsConstants.QUOTA_DONT_SET,HdfsConstants.QUOTA_DONT_SET);
    fc.mkdir(dst1.getParent(),FileContext.DEFAULT_PERM,true);
    fs.setQuota(dst1.getParent(),2,HdfsConstants.QUOTA_DONT_SET);
    oldRename(src1,dst1,true,false);
    oldRename(src2,dst2,false,true);
    fs.setQuota(src1.getParent(),1,HdfsConstants.QUOTA_DONT_SET);
    oldRename(dst1,src1,false,true);
  }
  @Test public void testRenameWithQuota() throws Exception {
    DistributedFileSystem fs=cluster.getFileSystem();
    Path src1=getTestRootPath(fc,"test/testRenameWithQuota/srcdir/src1");
    Path src2=getTestRootPath(fc,"test/testRenameWithQuota/srcdir/src2");
    Path dst1=getTestRootPath(fc,"test/testRenameWithQuota/dstdir/dst1");
    Path dst2=getTestRootPath(fc,"test/testRenameWithQuota/dstdir/dst2");
    createFile(src1);
    createFile(src2);
    fs.setQuota(src1.getParent(),HdfsConstants.QUOTA_DONT_SET,HdfsConstants.QUOTA_DONT_SET);
    fc.mkdir(dst1.getParent(),FileContext.DEFAULT_PERM,true);
    fs.setQuota(dst1.getParent(),2,HdfsConstants.QUOTA_DONT_SET);
    rename(src1,dst1,false,true,Rename.NONE);
    rename(src2,dst1,false,true,Rename.OVERWRITE);
    createFile(src2);
    try {
      rename(src2,dst2,true,false,Rename.NONE);
      fail("NSQuotaExceededException excepted");
    }
 catch (    NSQuotaExceededException e) {
    }
    fs.setQuota(src1.getParent(),1,HdfsConstants.QUOTA_DONT_SET);
    try {
      rename(dst1,src1,true,false,Rename.NONE);
      fail("NSQuotaExceededException excepted");
    }
 catch (    NSQuotaExceededException e) {
    }
    fs.setQuota(src1.getParent(),100,HdfsConstants.QUOTA_DONT_SET);
    createFile(src1);
    fs.setQuota(src1.getParent(),1,HdfsConstants.QUOTA_DONT_SET);
    rename(dst1,src1,false,true,Rename.OVERWRITE);
  }
  @Test(expected=RemoteException.class) public void testRenameRoot() throws Exception {
    Path src=getTestRootPath(fc,"test/testRenameRoot/srcdir/src1");
    Path dst=new Path("/");
    createFile(src);
    rename(dst,src,true,true,Rename.OVERWRITE);
  }
  @Test(expected=RemoteException.class) public void testRenameToRoot() throws Exception {
    Path src=getTestRootPath(fc,"test/testRenameRoot/srcdir/src1");
    Path dst=new Path("/");
    createFile(src);
    rename(src,dst,true,true,Rename.OVERWRITE);
  }
  /** 
 * Perform operations such as setting quota, deletion of files, rename and ensure system can apply edits log during startup.
 */
  @Test public void testEditsLogOldRename() throws Exception {
    DistributedFileSystem fs=cluster.getFileSystem();
    Path src1=getTestRootPath(fc,"testEditsLogOldRename/srcdir/src1");
    Path dst1=getTestRootPath(fc,"testEditsLogOldRename/dstdir/dst1");
    createFile(src1);
    fs.mkdirs(dst1.getParent());
    createFile(dst1);
    fs.setQuota(dst1.getParent(),2,HdfsConstants.QUOTA_DONT_SET);
    fs.delete(dst1,true);
    oldRename(src1,dst1,true,false);
    restartCluster();
    fs=cluster.getFileSystem();
    src1=getTestRootPath(fc,"testEditsLogOldRename/srcdir/src1");
    dst1=getTestRootPath(fc,"testEditsLogOldRename/dstdir/dst1");
    Assert.assertFalse(fs.exists(src1));
    Assert.assertTrue(fs.exists(dst1));
  }
  /** 
 * Perform operations such as setting quota, deletion of files, rename and ensure system can apply edits log during startup.
 */
  @Test public void testEditsLogRename() throws Exception {
    DistributedFileSystem fs=cluster.getFileSystem();
    Path src1=getTestRootPath(fc,"testEditsLogRename/srcdir/src1");
    Path dst1=getTestRootPath(fc,"testEditsLogRename/dstdir/dst1");
    createFile(src1);
    fs.mkdirs(dst1.getParent());
    createFile(dst1);
    fs.setQuota(dst1.getParent(),2,HdfsConstants.QUOTA_DONT_SET);
    fs.delete(dst1,true);
    rename(src1,dst1,false,true,Rename.OVERWRITE);
    restartCluster();
    fs=cluster.getFileSystem();
    src1=getTestRootPath(fc,"testEditsLogRename/srcdir/src1");
    dst1=getTestRootPath(fc,"testEditsLogRename/dstdir/dst1");
    Assert.assertFalse(fs.exists(src1));
    Assert.assertTrue(fs.exists(dst1));
  }
  @Test public void testIsValidNameInvalidNames(){
    String[] invalidNames={"/foo/../bar","/foo/./bar","/foo/:/bar","/foo:bar"};
    for (    String invalidName : invalidNames) {
      Assert.assertFalse(invalidName + " is not valid",fc.getDefaultFileSystem().isValidName(invalidName));
    }
  }
  private void oldRename(  Path src,  Path dst,  boolean renameSucceeds,  boolean exception) throws Exception {
    DistributedFileSystem fs=cluster.getFileSystem();
    try {
      Assert.assertEquals(renameSucceeds,fs.rename(src,dst));
    }
 catch (    Exception ex) {
      Assert.assertTrue(exception);
    }
    Assert.assertEquals(renameSucceeds,!exists(fc,src));
    Assert.assertEquals(renameSucceeds,exists(fc,dst));
  }
  @Override protected boolean listCorruptedBlocksSupported(){
    return true;
  }
  @Test public void testCrossFileSystemRename() throws IOException {
    try {
      fc.rename(new Path("hdfs://127.0.0.1/aaa/bbb/Foo"),new Path("file://aaa/bbb/Moo"),Options.Rename.OVERWRITE);
      fail("IOexception expected.");
    }
 catch (    IOException ioe) {
    }
  }
}
