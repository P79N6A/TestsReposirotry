/** 
 * Test the  {@link AvailableSpaceResolver}.
 */
public class TestAvailableSpaceResolver {
  private static final int SUBCLUSTER_NUM=10;
  @Test public void testResolverWithNoPreference() throws IOException {
    MultipleDestinationMountTableResolver mountTableResolver=mockAvailableSpaceResolver(1.0f);
    PathLocation loc=mountTableResolver.getDestinationForPath("/space");
    assertEquals("subcluster9",loc.getDestinations().get(0).getNameserviceId());
    loc=mountTableResolver.getDestinationForPath("/space/subdir");
    assertEquals("subcluster9",loc.getDestinations().get(0).getNameserviceId());
  }
  @Test public void testResolverWithDefaultPreference() throws IOException {
    MultipleDestinationMountTableResolver mountTableResolver=mockAvailableSpaceResolver(BALANCER_PREFERENCE_DEFAULT);
    int retries=10;
    int retryTimes=0;
    for (retryTimes=0; retryTimes < retries; retryTimes++) {
      PathLocation loc=mountTableResolver.getDestinationForPath("/space");
      if (!"subcluster9".equals(loc.getDestinations().get(0).getNameserviceId())) {
        break;
      }
    }
    assertNotEquals(retries,retryTimes);
  }
  /** 
 * Mock the available space based resolver.
 * @param balancerPreference The balancer preference for the resolver.
 * @throws IOException
 * @return MultipleDestinationMountTableResolver instance.
 */
  @SuppressWarnings("unchecked") private MultipleDestinationMountTableResolver mockAvailableSpaceResolver(  float balancerPreference) throws IOException {
    Configuration conf=new Configuration();
    conf.setFloat(BALANCER_PREFERENCE_KEY,balancerPreference);
    Router router=mock(Router.class);
    StateStoreService stateStore=mock(StateStoreService.class);
    MembershipStore membership=mock(MembershipStore.class);
    when(router.getStateStore()).thenReturn(stateStore);
    when(stateStore.getRegisteredRecordStore(any(Class.class))).thenReturn(membership);
    GetNamenodeRegistrationsResponse response=GetNamenodeRegistrationsResponse.newInstance();
    List<MembershipState> records=new LinkedList<>();
    for (int i=0; i < SUBCLUSTER_NUM; i++) {
      records.add(newMembershipState("subcluster" + i,i));
    }
    response.setNamenodeMemberships(records);
    when(membership.getNamenodeRegistrations(any(GetNamenodeRegistrationsRequest.class))).thenReturn(response);
    AvailableSpaceResolver resolver=new AvailableSpaceResolver(conf,router);
    MultipleDestinationMountTableResolver mountTableResolver=new MultipleDestinationMountTableResolver(conf,router);
    mountTableResolver.addResolver(DestinationOrder.SPACE,resolver);
    Map<String,String> destinations=new HashMap<>();
    for (int i=0; i < SUBCLUSTER_NUM; i++) {
      destinations.put("subcluster" + i,"/space");
    }
    MountTable spaceEntry=MountTable.newInstance("/space",destinations);
    spaceEntry.setDestOrder(DestinationOrder.SPACE);
    mountTableResolver.addEntry(spaceEntry);
    return mountTableResolver;
  }
  public static MembershipState newMembershipState(  String nameservice,  long availableSpace){
    MembershipState record=MembershipState.newInstance();
    record.setNameserviceId(nameservice);
    MembershipStats stats=new MembershipStatsPBImpl();
    stats.setAvailableSpace(availableSpace);
    record.setStats(stats);
    return record;
  }
  @Test public void testSubclusterSpaceComparator(){
    verifyRank(0.0f,true,false);
    verifyRank(1.0f,true,true);
    verifyRank(0.5f,false,false);
    verifyRank(BALANCER_PREFERENCE_DEFAULT,false,false);
    try {
      verifyRank(2.0f,false,false);
      fail("Subcluster comparison should be failed.");
    }
 catch (    IllegalArgumentException e) {
      GenericTestUtils.assertExceptionContains("The balancer preference value should be in the range 0.0 - 1.0",e);
    }
    try {
      verifyRank(-1.0f,false,false);
      fail("Subcluster comparison should be failed.");
    }
 catch (    IllegalArgumentException e) {
      GenericTestUtils.assertExceptionContains("The balancer preference value should be in the range 0.0 - 1.0",e);
    }
  }
  /** 
 * Verify result rank with  {@link SubclusterSpaceComparator}.
 * @param balancerPreference The balancer preference usedin  {@link SubclusterSpaceComparator}.
 * @param shouldOrdered The result rank should be ordered.
 * @param isDesc If the rank result is in a descending order.
 */
  private void verifyRank(  float balancerPreference,  boolean shouldOrdered,  boolean isDesc){
    List<SubclusterAvailableSpace> subclusters=new LinkedList<>();
    for (int i=0; i < SUBCLUSTER_NUM; i++) {
      subclusters.add(new SubclusterAvailableSpace("subcluster" + i,i));
    }
    if (shouldOrdered) {
      Collections.shuffle(subclusters);
    }
    SubclusterSpaceComparator comparator=new SubclusterSpaceComparator(balancerPreference);
    Collections.sort(subclusters,comparator);
    int i=SUBCLUSTER_NUM - 1;
    for (; i >= 0; i--) {
      SubclusterAvailableSpace cluster=subclusters.get(SUBCLUSTER_NUM - 1 - i);
      if (shouldOrdered) {
        if (isDesc) {
          assertEquals("subcluster" + i,cluster.getNameserviceId());
          assertEquals(i,cluster.getAvailableSpace());
        }
 else {
          assertEquals("subcluster" + (SUBCLUSTER_NUM - 1 - i),cluster.getNameserviceId());
          assertEquals(SUBCLUSTER_NUM - 1 - i,cluster.getAvailableSpace());
        }
      }
 else {
        if (!cluster.getNameserviceId().equals("subcluster" + i) && cluster.getAvailableSpace() != i) {
          break;
        }
      }
    }
    if (!shouldOrdered) {
      assertNotEquals(0,i);
    }
    subclusters.clear();
  }
}
