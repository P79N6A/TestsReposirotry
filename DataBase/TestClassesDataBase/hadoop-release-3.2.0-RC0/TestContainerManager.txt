public class TestContainerManager extends BaseContainerManagerTest {
  public TestContainerManager() throws UnsupportedFileSystemException {
    super();
  }
static {
    LOG=LoggerFactory.getLogger(TestContainerManager.class);
  }
private static class Listener implements ContainerStateTransitionListener {
    private final Map<ContainerId,List<org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState>> states=new HashMap<>();
    private final Map<ContainerId,List<ContainerEventType>> events=new HashMap<>();
    @Override public void init(    Context context){
    }
    @Override public void preTransition(    ContainerImpl op,    org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState beforeState,    ContainerEvent eventToBeProcessed){
      if (!states.containsKey(op.getContainerId())) {
        states.put(op.getContainerId(),new ArrayList<>());
        states.get(op.getContainerId()).add(beforeState);
        events.put(op.getContainerId(),new ArrayList<>());
      }
    }
    @Override public void postTransition(    ContainerImpl op,    org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState beforeState,    org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState afterState,    ContainerEvent processedEvent){
      states.get(op.getContainerId()).add(afterState);
      events.get(op.getContainerId()).add(processedEvent.getType());
    }
  }
  private boolean delayContainers=false;
  @Override protected ContainerExecutor createContainerExecutor(){
    DefaultContainerExecutor exec=new DefaultContainerExecutor(){
      @Override public int launchContainer(      ContainerStartContext ctx) throws IOException, ConfigurationException {
        if (delayContainers) {
          try {
            Thread.sleep(10000);
          }
 catch (          InterruptedException e) {
          }
        }
        return super.launchContainer(ctx);
      }
    }
;
    exec.setConf(conf);
    return spy(exec);
  }
  @Override protected ContainerManagerImpl createContainerManager(  DeletionService delSrvc){
    return new ContainerManagerImpl(context,exec,delSrvc,nodeStatusUpdater,metrics,dirsHandler){
      @Override protected UserGroupInformation getRemoteUgi() throws YarnException {
        ApplicationId appId=ApplicationId.newInstance(0,0);
        ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,1);
        UserGroupInformation ugi=UserGroupInformation.createRemoteUser(appAttemptId.toString());
        ugi.addTokenIdentifier(new NMTokenIdentifier(appAttemptId,context.getNodeId(),user,context.getNMTokenSecretManager().getCurrentKey().getKeyId()));
        return ugi;
      }
    }
;
  }
  @Test public void testContainerManagerInitialization() throws IOException {
    containerManager.start();
    InetAddress localAddr=InetAddress.getLocalHost();
    String fqdn=localAddr.getCanonicalHostName();
    if (!localAddr.getHostAddress().equals(fqdn)) {
      Assert.assertEquals(fqdn,context.getNodeId().getHost());
    }
    boolean throwsException=false;
    try {
      List<ContainerId> containerIds=new ArrayList<>();
      ContainerId id=createContainerId(0);
      containerIds.add(id);
      GetContainerStatusesRequest request=GetContainerStatusesRequest.newInstance(containerIds);
      GetContainerStatusesResponse response=containerManager.getContainerStatuses(request);
      if (response.getFailedRequests().containsKey(id)) {
        throw response.getFailedRequests().get(id).deSerialize();
      }
    }
 catch (    Throwable e) {
      throwsException=true;
    }
    Assert.assertTrue(throwsException);
  }
  @Test public void testContainerSetup() throws Exception {
    containerManager.start();
    File dir=new File(tmpDir,"dir");
    dir.mkdirs();
    File file=new File(dir,"file");
    PrintWriter fileWriter=new PrintWriter(file);
    fileWriter.write("Hello World!");
    fileWriter.close();
    ContainerId cId=createContainerId(0);
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    URL resource_alpha=URL.fromPath(localFS.makeQualified(new Path(file.getAbsolutePath())));
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(resource_alpha);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(file.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,rsrc_alpha);
    containerLaunchContext.setLocalResources(localResources);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.COMPLETE,40);
    ApplicationId appId=cId.getApplicationAttemptId().getApplicationId();
    String appIDStr=appId.toString();
    String containerIDStr=cId.toString();
    File userCacheDir=new File(localDir,ContainerLocalizer.USERCACHE);
    File userDir=new File(userCacheDir,user);
    File appCache=new File(userDir,ContainerLocalizer.APPCACHE);
    File appDir=new File(appCache,appIDStr);
    File containerDir=new File(appDir,containerIDStr);
    File targetFile=new File(containerDir,destinationFile);
    File sysDir=new File(localDir,ResourceLocalizationService.NM_PRIVATE_DIR);
    File appSysDir=new File(sysDir,appIDStr);
    File containerSysDir=new File(appSysDir,containerIDStr);
    for (    File f : new File[]{localDir,sysDir,userCacheDir,appDir,appSysDir,containerDir,containerSysDir}) {
      Assert.assertTrue(f.getAbsolutePath() + " doesn't exist!!",f.exists());
      Assert.assertTrue(f.getAbsolutePath() + " is not a directory!!",f.isDirectory());
    }
    Assert.assertTrue(targetFile.getAbsolutePath() + " doesn't exist!!",targetFile.exists());
    BufferedReader reader=new BufferedReader(new FileReader(targetFile));
    Assert.assertEquals("Hello World!",reader.readLine());
    Assert.assertEquals(null,reader.readLine());
  }
  @Test(timeout=10000L) public void testAuxPathHandler() throws Exception {
    File testDir=GenericTestUtils.getTestDir(TestContainerManager.class.getSimpleName() + "LocDir");
    testDir.mkdirs();
    File testFile=new File(testDir,"test");
    testFile.createNewFile();
    YarnConfiguration configuration=new YarnConfiguration();
    configuration.set(YarnConfiguration.NM_LOCAL_DIRS,testDir.getAbsolutePath());
    LocalDirsHandlerService spyDirHandlerService=Mockito.spy(new LocalDirsHandlerService());
    spyDirHandlerService.init(configuration);
    when(spyDirHandlerService.getConfig()).thenReturn(configuration);
    AuxiliaryLocalPathHandler auxiliaryLocalPathHandler=new ContainerManagerImpl.AuxiliaryLocalPathHandlerImpl(spyDirHandlerService);
    Path p=auxiliaryLocalPathHandler.getLocalPathForRead("test");
    assertTrue(p != null && !spyDirHandlerService.getLocalDirsForRead().isEmpty());
    when(spyDirHandlerService.getLocalDirsForRead()).thenReturn(new ArrayList<String>());
    try {
      auxiliaryLocalPathHandler.getLocalPathForRead("test");
      fail("Should not have passed!");
    }
 catch (    IOException e) {
      Assert.assertTrue(e.getMessage().contains("Could not find"));
    }
 finally {
      testFile.delete();
      testDir.delete();
    }
  }
  public void testContainerLaunchAndStop() throws IOException, InterruptedException, YarnException {
    containerManager.start();
    File scriptFile=Shell.appendScriptExtension(tmpDir,"scriptFile");
    PrintWriter fileWriter=new PrintWriter(scriptFile);
    File processStartFile=new File(tmpDir,"start_file.txt").getAbsoluteFile();
    ContainerId cId=createContainerId(0);
    if (Shell.WINDOWS) {
      fileWriter.println("@echo Hello World!> " + processStartFile);
      fileWriter.println("@echo " + cId + ">> "+ processStartFile);
      fileWriter.println("@ping -n 100 127.0.0.1 >nul");
    }
 else {
      fileWriter.write("\numask 0");
      fileWriter.write("\necho Hello World! > " + processStartFile);
      fileWriter.write("\necho $$ >> " + processStartFile);
      fileWriter.write("\nexec sleep 100");
    }
    fileWriter.close();
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    URL resource_alpha=URL.fromPath(localFS.makeQualified(new Path(scriptFile.getAbsolutePath())));
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(resource_alpha);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(scriptFile.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,rsrc_alpha);
    containerLaunchContext.setLocalResources(localResources);
    List<String> commands=Arrays.asList(Shell.getRunScriptCommand(scriptFile));
    containerLaunchContext.setCommands(commands);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    int timeoutSecs=0;
    while (!processStartFile.exists() && timeoutSecs++ < 20) {
      Thread.sleep(1000);
      LOG.info("Waiting for process start-file to be created");
    }
    Assert.assertTrue("ProcessStartFile doesn't exist!",processStartFile.exists());
    BufferedReader reader=new BufferedReader(new FileReader(processStartFile));
    Assert.assertEquals("Hello World!",reader.readLine());
    String pid=reader.readLine().trim();
    Assert.assertEquals(null,reader.readLine());
    Assert.assertTrue("Process is not alive!",DefaultContainerExecutor.containerIsAlive(pid));
    Assert.assertTrue("Process is not alive!",DefaultContainerExecutor.containerIsAlive(pid));
    List<ContainerId> containerIds=new ArrayList<>();
    containerIds.add(cId);
    StopContainersRequest stopRequest=StopContainersRequest.newInstance(containerIds);
    containerManager.stopContainers(stopRequest);
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.COMPLETE);
    GetContainerStatusesRequest gcsRequest=GetContainerStatusesRequest.newInstance(containerIds);
    ContainerStatus containerStatus=containerManager.getContainerStatuses(gcsRequest).getContainerStatuses().get(0);
    int expectedExitCode=ContainerExitStatus.KILLED_BY_APPMASTER;
    Assert.assertEquals(expectedExitCode,containerStatus.getExitStatus());
    Assert.assertFalse("Process is still alive!",DefaultContainerExecutor.containerIsAlive(pid));
  }
  @Test public void testContainerRestart() throws IOException, InterruptedException, YarnException {
    containerManager.start();
    ContainerId cId=createContainerId(0);
    File oldStartFile=new File(tmpDir,"start_file_o.txt").getAbsoluteFile();
    String pid=prepareInitialContainer(cId,oldStartFile);
    doRestartTests(cId,oldStartFile,"Hello World!",pid,false);
  }
  private String doRestartTests(  ContainerId cId,  File oldStartFile,  String testString,  String pid,  boolean canRollback) throws YarnException, IOException, InterruptedException {
    int beforeRestart=metrics.getRunningContainers();
    Container container=containerManager.getContext().getContainers().get(cId);
    Assert.assertFalse(container.isReInitializing());
    containerManager.restartContainer(cId);
    Assert.assertTrue(container.isReInitializing());
    int timeoutSecs=0;
    while (DefaultContainerExecutor.containerIsAlive(pid) && (metrics.getRunningContainers() == beforeRestart) && container.isReInitializing()&& timeoutSecs++ < 20) {
      Thread.sleep(1000);
      LOG.info("Waiting for Original process to die.." + "and new process to start!!");
    }
    Assert.assertFalse("Old Process Still alive!!",DefaultContainerExecutor.containerIsAlive(pid));
    String newPid=null;
    timeoutSecs=0;
    while (timeoutSecs++ < 20) {
      LOG.info("Waiting for New process file to be created!!");
      BufferedReader reader=new BufferedReader(new FileReader(oldStartFile));
      Assert.assertEquals(testString,reader.readLine());
      newPid=reader.readLine().trim();
      Assert.assertEquals(null,reader.readLine());
      reader.close();
      if (!newPid.equals(pid)) {
        break;
      }
      Thread.sleep(1000);
    }
    Assert.assertNotEquals(pid,newPid);
    Assert.assertEquals(canRollback,container.canRollback());
    return newPid;
  }
  private String[] testContainerReInitSuccess(  boolean autoCommit) throws IOException, InterruptedException, YarnException {
    containerManager.start();
    ContainerId cId=createContainerId(0);
    File oldStartFile=new File(tmpDir,"start_file_o.txt").getAbsoluteFile();
    String pid=prepareInitialContainer(cId,oldStartFile);
    File newStartFile=new File(tmpDir,"start_file_n.txt").getAbsoluteFile();
    ResourceUtilization beforeUpgrade=ResourceUtilization.newInstance(containerManager.getContainerScheduler().getCurrentUtilization());
    prepareContainerUpgrade(autoCommit,false,false,cId,newStartFile);
    ResourceUtilization afterUpgrade=ResourceUtilization.newInstance(containerManager.getContainerScheduler().getCurrentUtilization());
    Assert.assertEquals("Possible resource leak detected !!",beforeUpgrade,afterUpgrade);
    Assert.assertFalse("Process is still alive!",DefaultContainerExecutor.containerIsAlive(pid));
    BufferedReader reader=new BufferedReader(new FileReader(newStartFile));
    Assert.assertEquals("Upgrade World!",reader.readLine());
    String newPid=reader.readLine().trim();
    Assert.assertNotEquals("Old and New Pids must be different !",pid,newPid);
    Assert.assertEquals(null,reader.readLine());
    reader.close();
    reader=new BufferedReader(new FileReader(oldStartFile));
    Assert.assertEquals("Hello World!",reader.readLine());
    Assert.assertTrue("New Process is not alive!",DefaultContainerExecutor.containerIsAlive(newPid));
    return new String[]{pid,newPid};
  }
  @Test public void testContainerUpgradeSuccessAutoCommit() throws IOException, InterruptedException, YarnException {
    Listener listener=new Listener();
    ((NodeManager.DefaultContainerStateListener)containerManager.context.getContainerStateTransitionListener()).addListener(listener);
    testContainerReInitSuccess(true);
    try {
      containerManager.commitLastReInitialization(createContainerId(0));
      Assert.fail();
    }
 catch (    Exception e) {
      Assert.assertTrue(e.getMessage().contains("Nothing to Commit"));
    }
    List<org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState> containerStates=listener.states.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.NEW,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.LOCALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING),containerStates);
    List<ContainerEventType> containerEventTypes=listener.events.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(ContainerEventType.INIT_CONTAINER,ContainerEventType.RESOURCE_LOCALIZED,ContainerEventType.CONTAINER_LAUNCHED,ContainerEventType.REINITIALIZE_CONTAINER,ContainerEventType.RESOURCE_LOCALIZED,ContainerEventType.UPDATE_DIAGNOSTICS_MSG,ContainerEventType.CONTAINER_KILLED_ON_REQUEST,ContainerEventType.CONTAINER_LAUNCHED),containerEventTypes);
  }
  @Test public void testContainerUpgradeSuccessExplicitCommit() throws IOException, InterruptedException, YarnException {
    testContainerReInitSuccess(false);
    ContainerId cId=createContainerId(0);
    containerManager.commitLastReInitialization(cId);
    try {
      containerManager.rollbackLastReInitialization(cId);
      Assert.fail();
    }
 catch (    Exception e) {
      Assert.assertTrue(e.getMessage().contains("Nothing to rollback to"));
    }
  }
  @Test public void testContainerUpgradeSuccessExplicitRollback() throws IOException, InterruptedException, YarnException {
    Listener listener=new Listener();
    ((NodeManager.DefaultContainerStateListener)containerManager.context.getContainerStateTransitionListener()).addListener(listener);
    String[] pids=testContainerReInitSuccess(false);
    pids[1]=doRestartTests(createContainerId(0),new File(tmpDir,"start_file_n.txt").getAbsoluteFile(),"Upgrade World!",pids[1],true);
    File oldStartFile=new File(tmpDir,"start_file_o.txt").getAbsoluteFile();
    oldStartFile.delete();
    ContainerId cId=createContainerId(0);
    containerManager.rollbackLastReInitialization(cId);
    Container container=containerManager.getContext().getContainers().get(cId);
    Assert.assertTrue(container.isReInitializing());
    Assert.assertFalse("Original Process is still alive!",DefaultContainerExecutor.containerIsAlive(pids[0]));
    int timeoutSecs=0;
    while (container.isReInitializing() && timeoutSecs++ < 20) {
      Thread.sleep(1000);
      LOG.info("Waiting for ReInitialization to complete..");
    }
    Assert.assertFalse(container.isReInitializing());
    timeoutSecs=0;
    while (!oldStartFile.exists() && timeoutSecs++ < 20) {
      Thread.sleep(1000);
      LOG.info("Waiting for New process start-file to be created");
    }
    BufferedReader reader=new BufferedReader(new FileReader(oldStartFile));
    Assert.assertEquals("Hello World!",reader.readLine());
    String rolledBackPid=reader.readLine().trim();
    Assert.assertEquals(null,reader.readLine());
    Assert.assertNotEquals("The Rolled-back process should be a different pid",pids[0],rolledBackPid);
    List<org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState> containerStates=listener.states.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.NEW,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.LOCALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING),containerStates);
    List<ContainerEventType> containerEventTypes=listener.events.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(ContainerEventType.INIT_CONTAINER,ContainerEventType.RESOURCE_LOCALIZED,ContainerEventType.CONTAINER_LAUNCHED,ContainerEventType.REINITIALIZE_CONTAINER,ContainerEventType.RESOURCE_LOCALIZED,ContainerEventType.UPDATE_DIAGNOSTICS_MSG,ContainerEventType.CONTAINER_KILLED_ON_REQUEST,ContainerEventType.CONTAINER_LAUNCHED,ContainerEventType.REINITIALIZE_CONTAINER,ContainerEventType.UPDATE_DIAGNOSTICS_MSG,ContainerEventType.CONTAINER_KILLED_ON_REQUEST,ContainerEventType.CONTAINER_LAUNCHED,ContainerEventType.ROLLBACK_REINIT,ContainerEventType.UPDATE_DIAGNOSTICS_MSG,ContainerEventType.CONTAINER_KILLED_ON_REQUEST,ContainerEventType.CONTAINER_LAUNCHED),containerEventTypes);
  }
  @Test public void testContainerUpgradeLocalizationFailure() throws IOException, InterruptedException, YarnException {
    if (Shell.WINDOWS) {
      return;
    }
    containerManager.start();
    Listener listener=new Listener();
    ((NodeManager.DefaultContainerStateListener)containerManager.context.getContainerStateTransitionListener()).addListener(listener);
    ContainerId cId=createContainerId(0);
    File oldStartFile=new File(tmpDir,"start_file_o.txt").getAbsoluteFile();
    String pid=prepareInitialContainer(cId,oldStartFile);
    File newStartFile=new File(tmpDir,"start_file_n.txt").getAbsoluteFile();
    prepareContainerUpgrade(false,true,true,cId,newStartFile);
    Assert.assertTrue("Process is NOT alive!",DefaultContainerExecutor.containerIsAlive(pid));
    List<org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState> containerStates=listener.states.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.NEW,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.LOCALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING),containerStates);
    List<ContainerEventType> containerEventTypes=listener.events.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(ContainerEventType.INIT_CONTAINER,ContainerEventType.RESOURCE_LOCALIZED,ContainerEventType.CONTAINER_LAUNCHED,ContainerEventType.REINITIALIZE_CONTAINER,ContainerEventType.RESOURCE_FAILED),containerEventTypes);
  }
  @Test public void testContainerUpgradeProcessFailure() throws IOException, InterruptedException, YarnException {
    if (Shell.WINDOWS) {
      return;
    }
    containerManager.start();
    ContainerId cId=createContainerId(0);
    File oldStartFile=new File(tmpDir,"start_file_o.txt").getAbsoluteFile();
    String pid=prepareInitialContainer(cId,oldStartFile);
    File newStartFile=new File(tmpDir,"start_file_n.txt").getAbsoluteFile();
    prepareContainerUpgrade(true,true,false,cId,newStartFile);
    Assert.assertFalse("Process is still alive!",DefaultContainerExecutor.containerIsAlive(pid));
  }
  @Test public void testContainerUpgradeRollbackDueToFailure() throws IOException, InterruptedException, YarnException {
    if (Shell.WINDOWS) {
      return;
    }
    containerManager.start();
    Listener listener=new Listener();
    ((NodeManager.DefaultContainerStateListener)containerManager.context.getContainerStateTransitionListener()).addListener(listener);
    ContainerId cId=createContainerId(0);
    File oldStartFile=new File(tmpDir,"start_file_o.txt").getAbsoluteFile();
    String pid=prepareInitialContainer(cId,oldStartFile);
    File newStartFile=new File(tmpDir,"start_file_n.txt").getAbsoluteFile();
    prepareContainerUpgrade(false,true,false,cId,newStartFile);
    Assert.assertFalse("Original Process is still alive!",DefaultContainerExecutor.containerIsAlive(pid));
    int timeoutSecs=0;
    while (!oldStartFile.exists() && timeoutSecs++ < 20) {
      System.out.println("\nFiles: " + Arrays.toString(oldStartFile.getParentFile().list()));
      Thread.sleep(1000);
      LOG.info("Waiting for New process start-file to be created");
    }
    BufferedReader reader=new BufferedReader(new FileReader(oldStartFile));
    Assert.assertEquals("Hello World!",reader.readLine());
    String rolledBackPid=reader.readLine().trim();
    Assert.assertEquals(null,reader.readLine());
    Assert.assertNotEquals("The Rolled-back process should be a different pid",pid,rolledBackPid);
    List<org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState> containerStates=listener.states.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.NEW,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.LOCALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.REINITIALIZING_AWAITING_KILL,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.SCHEDULED,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING),containerStates);
    List<ContainerEventType> containerEventTypes=listener.events.get(createContainerId(0));
    Assert.assertEquals(Arrays.asList(ContainerEventType.INIT_CONTAINER,ContainerEventType.RESOURCE_LOCALIZED,ContainerEventType.CONTAINER_LAUNCHED,ContainerEventType.REINITIALIZE_CONTAINER,ContainerEventType.RESOURCE_LOCALIZED,ContainerEventType.UPDATE_DIAGNOSTICS_MSG,ContainerEventType.CONTAINER_KILLED_ON_REQUEST,ContainerEventType.CONTAINER_LAUNCHED,ContainerEventType.UPDATE_DIAGNOSTICS_MSG,ContainerEventType.CONTAINER_EXITED_WITH_FAILURE,ContainerEventType.CONTAINER_LAUNCHED),containerEventTypes);
  }
  /** 
 * Prepare a launch Context for container upgrade and request the Container Manager to re-initialize a running container using the new launch context.
 * @param autoCommit Enable autoCommit.
 * @param failCmd injects a start script that intentionally fails.
 * @param failLoc injects a bad file Location that will fail localization.
 */
  private void prepareContainerUpgrade(  boolean autoCommit,  boolean failCmd,  boolean failLoc,  ContainerId cId,  File startFile) throws FileNotFoundException, YarnException, InterruptedException {
    File scriptFile=Shell.appendScriptExtension(tmpDir,"scriptFile_new");
    PrintWriter fileWriter=new PrintWriter(scriptFile);
    writeScriptFile(fileWriter,"Upgrade World!",startFile,cId,failCmd);
    ContainerLaunchContext containerLaunchContext=prepareContainerLaunchContext(scriptFile,"dest_file_new",failLoc,0);
    containerManager.reInitializeContainer(cId,containerLaunchContext,autoCommit);
    try {
      containerManager.reInitializeContainer(cId,containerLaunchContext,autoCommit);
    }
 catch (    Exception e) {
      Assert.assertTrue(e.getMessage().contains("Cannot perform RE_INIT"));
    }
    int timeoutSecs=0;
    int maxTimeToWait=failLoc ? 10 : 20;
    while (!startFile.exists() && timeoutSecs++ < maxTimeToWait) {
      Thread.sleep(1000);
      LOG.info("Waiting for New process start-file to be created");
    }
  }
  /** 
 * Prepare and start an initial container. This container will be subsequently re-initialized for upgrade. It also waits for the container to start and returns the Pid of the running container.
 */
  private String prepareInitialContainer(  ContainerId cId,  File startFile) throws IOException, YarnException, InterruptedException {
    File scriptFileOld=Shell.appendScriptExtension(tmpDir,"scriptFile");
    PrintWriter fileWriterOld=new PrintWriter(scriptFileOld);
    writeScriptFile(fileWriterOld,"Hello World!",startFile,cId,false);
    ContainerLaunchContext containerLaunchContext=prepareContainerLaunchContext(scriptFileOld,"dest_file",false,4);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    int timeoutSecs=0;
    while (!startFile.exists() && timeoutSecs++ < 20) {
      Thread.sleep(1000);
      LOG.info("Waiting for process start-file to be created");
    }
    Assert.assertTrue("ProcessStartFile doesn't exist!",startFile.exists());
    BufferedReader reader=new BufferedReader(new FileReader(startFile));
    Assert.assertEquals("Hello World!",reader.readLine());
    String pid=reader.readLine().trim();
    Assert.assertEquals(null,reader.readLine());
    Assert.assertTrue("Process is not alive!",DefaultContainerExecutor.containerIsAlive(pid));
    Assert.assertTrue("Process is not alive!",DefaultContainerExecutor.containerIsAlive(pid));
    return pid;
  }
  private void writeScriptFile(  PrintWriter fileWriter,  String startLine,  File processStartFile,  ContainerId cId,  boolean isFailure){
    if (Shell.WINDOWS) {
      fileWriter.println("@echo " + startLine + "> "+ processStartFile);
      fileWriter.println("@echo " + cId + ">> "+ processStartFile);
      fileWriter.println("@ping -n 100 127.0.0.1 >nul");
    }
 else {
      fileWriter.write("\numask 0");
      if (isFailure) {
        fileWriter.write("\necho $$ >> " + processStartFile);
        fileWriter.write("\nexit 111");
      }
 else {
        fileWriter.write("\necho " + startLine + " > "+ processStartFile);
        fileWriter.write("\necho $$ >> " + processStartFile);
        fileWriter.write("\nexec sleep 100");
      }
    }
    fileWriter.close();
  }
  private ContainerLaunchContext prepareContainerLaunchContext(  File scriptFile,  String destFName,  boolean putBadFile,  int numRetries){
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    URL resourceAlpha=null;
    if (putBadFile) {
      File fileToDelete=new File(tmpDir,"fileToDelete").getAbsoluteFile();
      resourceAlpha=URL.fromPath(localFS.makeQualified(new Path(fileToDelete.getAbsolutePath())));
      fileToDelete.delete();
    }
 else {
      resourceAlpha=URL.fromPath(localFS.makeQualified(new Path(scriptFile.getAbsolutePath())));
    }
    LocalResource rsrcAlpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrcAlpha.setResource(resourceAlpha);
    rsrcAlpha.setSize(-1);
    rsrcAlpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrcAlpha.setType(LocalResourceType.FILE);
    rsrcAlpha.setTimestamp(scriptFile.lastModified());
    Map<String,LocalResource> localResources=new HashMap<>();
    localResources.put(destFName,rsrcAlpha);
    containerLaunchContext.setLocalResources(localResources);
    ContainerRetryContext containerRetryContext=ContainerRetryContext.newInstance(ContainerRetryPolicy.RETRY_ON_SPECIFIC_ERROR_CODES,new HashSet<>(Arrays.asList(Integer.valueOf(111))),numRetries,0);
    containerLaunchContext.setContainerRetryContext(containerRetryContext);
    List<String> commands=Arrays.asList(Shell.getRunScriptCommand(scriptFile));
    containerLaunchContext.setCommands(commands);
    return containerLaunchContext;
  }
  protected void testContainerLaunchAndExit(  int exitCode) throws IOException, InterruptedException, YarnException {
    File scriptFile=Shell.appendScriptExtension(tmpDir,"scriptFile");
    PrintWriter fileWriter=new PrintWriter(scriptFile);
    File processStartFile=new File(tmpDir,"start_file.txt").getAbsoluteFile();
    ContainerId cId=createContainerId(0);
    if (Shell.WINDOWS) {
      fileWriter.println("@echo Hello World!> " + processStartFile);
      fileWriter.println("@echo " + cId + ">> "+ processStartFile);
      if (exitCode != 0) {
        fileWriter.println("@exit " + exitCode);
      }
    }
 else {
      fileWriter.write("\numask 0");
      fileWriter.write("\necho Hello World! > " + processStartFile);
      fileWriter.write("\necho $$ >> " + processStartFile);
      if (exitCode != 0) {
        fileWriter.write("\nexit " + exitCode);
      }
    }
    fileWriter.close();
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    URL resource_alpha=URL.fromPath(localFS.makeQualified(new Path(scriptFile.getAbsolutePath())));
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(resource_alpha);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(scriptFile.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,rsrc_alpha);
    containerLaunchContext.setLocalResources(localResources);
    List<String> commands=Arrays.asList(Shell.getRunScriptCommand(scriptFile));
    containerLaunchContext.setCommands(commands);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.COMPLETE);
    List<ContainerId> containerIds=new ArrayList<>();
    containerIds.add(cId);
    GetContainerStatusesRequest gcsRequest=GetContainerStatusesRequest.newInstance(containerIds);
    ContainerStatus containerStatus=containerManager.getContainerStatuses(gcsRequest).getContainerStatuses().get(0);
    Assert.assertEquals(exitCode,containerStatus.getExitStatus());
  }
  @Test public void testContainerLaunchAndExitSuccess() throws IOException, InterruptedException, YarnException {
    containerManager.start();
    int exitCode=0;
    testContainerLaunchAndExit(exitCode);
  }
  @Test public void testContainerLaunchAndExitFailure() throws IOException, InterruptedException, YarnException {
    containerManager.start();
    int exitCode=50;
    testContainerLaunchAndExit(exitCode);
  }
  private Map<String,LocalResource> setupLocalResources(  String fileName,  String symLink) throws Exception {
    File dir=new File(tmpDir,"dir");
    dir.mkdirs();
    File file=new File(dir,fileName);
    PrintWriter fileWriter=new PrintWriter(file);
    fileWriter.write("Hello World!");
    fileWriter.close();
    URL resourceURL=URL.fromPath(FileContext.getLocalFSFileContext().makeQualified(new Path(file.getAbsolutePath())));
    LocalResource resource=recordFactory.newRecordInstance(LocalResource.class);
    resource.setResource(resourceURL);
    resource.setSize(-1);
    resource.setVisibility(LocalResourceVisibility.APPLICATION);
    resource.setType(LocalResourceType.FILE);
    resource.setTimestamp(file.lastModified());
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(symLink,resource);
    return localResources;
  }
  @Test public void testLocalingResourceWhileContainerRunning() throws Exception {
    delSrvc=new DeletionService(exec);
    delSrvc.init(conf);
    ((NodeManager.NMContext)context).setContainerExecutor(exec);
    containerManager=createContainerManager(delSrvc);
    containerManager.init(conf);
    containerManager.start();
    Map<String,LocalResource> localResource=setupLocalResources("file","symLink1");
    ContainerLaunchContext context=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    context.setLocalResources(localResource);
    context.setCommands(Arrays.asList("sleep 6"));
    ContainerId cId=createContainerId(0);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(context,createContainerToken(cId,DUMMY_RM_IDENTIFIER,this.context.getNodeId(),user,this.context.getContainerTokenSecretManager()));
    StartContainersRequest allRequests=StartContainersRequest.newInstance(Arrays.asList(scRequest));
    containerManager.startContainers(allRequests);
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.RUNNING);
    BaseContainerManagerTest.waitForApplicationState(containerManager,cId.getApplicationAttemptId().getApplicationId(),ApplicationState.RUNNING);
    checkResourceLocalized(cId,"symLink1");
    Map<String,LocalResource> localResource2=setupLocalResources("file2","symLink2");
    ResourceLocalizationRequest request=ResourceLocalizationRequest.newInstance(cId,localResource2);
    containerManager.localize(request);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      public Boolean get(){
        try {
          checkResourceLocalized(cId,"symLink2");
          return true;
        }
 catch (        Throwable e) {
          return false;
        }
      }
    }
,500,20000);
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.COMPLETE);
    try {
      containerManager.localize(request);
      Assert.fail();
    }
 catch (    YarnException e) {
      Assert.assertTrue(e.getMessage().contains("Cannot perform LOCALIZE"));
    }
  }
  private void checkResourceLocalized(  ContainerId containerId,  String symLink){
    String appId=containerId.getApplicationAttemptId().getApplicationId().toString();
    File userCacheDir=new File(localDir,ContainerLocalizer.USERCACHE);
    File userDir=new File(userCacheDir,user);
    File appCache=new File(userDir,ContainerLocalizer.APPCACHE);
    File appDir=new File(appCache,appId);
    File containerDir=new File(appDir,containerId.toString());
    File targetFile=new File(containerDir,symLink);
    File sysDir=new File(localDir,ResourceLocalizationService.NM_PRIVATE_DIR);
    File appSysDir=new File(sysDir,appId);
    File containerSysDir=new File(appSysDir,containerId.toString());
    Assert.assertTrue("AppDir " + appDir.getAbsolutePath() + " doesn't exist!!",appDir.exists());
    Assert.assertTrue("AppSysDir " + appSysDir.getAbsolutePath() + " doesn't exist!!",appSysDir.exists());
    Assert.assertTrue("containerDir " + containerDir.getAbsolutePath() + " doesn't exist !",containerDir.exists());
    Assert.assertTrue("containerSysDir " + containerSysDir.getAbsolutePath() + " doesn't exist !",containerDir.exists());
    Assert.assertTrue("targetFile " + targetFile.getAbsolutePath() + " doesn't exist !!",targetFile.exists());
  }
  @Test public void testLocalFilesCleanup() throws InterruptedException, IOException, YarnException {
    delSrvc=new DeletionService(exec);
    delSrvc.init(conf);
    containerManager=createContainerManager(delSrvc);
    containerManager.init(conf);
    containerManager.start();
    File dir=new File(tmpDir,"dir");
    dir.mkdirs();
    File file=new File(dir,"file");
    PrintWriter fileWriter=new PrintWriter(file);
    fileWriter.write("Hello World!");
    fileWriter.close();
    ContainerId cId=createContainerId(0);
    ApplicationId appId=cId.getApplicationAttemptId().getApplicationId();
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    URL resource_alpha=URL.fromPath(FileContext.getLocalFSFileContext().makeQualified(new Path(file.getAbsolutePath())));
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(resource_alpha);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(file.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,rsrc_alpha);
    containerLaunchContext.setLocalResources(localResources);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.COMPLETE);
    BaseContainerManagerTest.waitForApplicationState(containerManager,cId.getApplicationAttemptId().getApplicationId(),ApplicationState.RUNNING);
    String appIDStr=appId.toString();
    String containerIDStr=cId.toString();
    File userCacheDir=new File(localDir,ContainerLocalizer.USERCACHE);
    File userDir=new File(userCacheDir,user);
    File appCache=new File(userDir,ContainerLocalizer.APPCACHE);
    File appDir=new File(appCache,appIDStr);
    File containerDir=new File(appDir,containerIDStr);
    File targetFile=new File(containerDir,destinationFile);
    File sysDir=new File(localDir,ResourceLocalizationService.NM_PRIVATE_DIR);
    File appSysDir=new File(sysDir,appIDStr);
    File containerSysDir=new File(appSysDir,containerIDStr);
    Assert.assertTrue("AppDir " + appDir.getAbsolutePath() + " doesn't exist!!",appDir.exists());
    Assert.assertTrue("AppSysDir " + appSysDir.getAbsolutePath() + " doesn't exist!!",appSysDir.exists());
    for (    File f : new File[]{containerDir,containerSysDir}) {
      Assert.assertFalse(f.getAbsolutePath() + " exists!!",f.exists());
    }
    Assert.assertFalse(targetFile.getAbsolutePath() + " exists!!",targetFile.exists());
    containerManager.handle(new CMgrCompletedAppsEvent(Arrays.asList(new ApplicationId[]{appId}),CMgrCompletedAppsEvent.Reason.ON_SHUTDOWN));
    BaseContainerManagerTest.waitForApplicationState(containerManager,cId.getApplicationAttemptId().getApplicationId(),ApplicationState.FINISHED);
    for (    File f : new File[]{appDir,containerDir,appSysDir,containerSysDir}) {
      int timeout=0;
      while (f.exists() && timeout++ < 15) {
        Thread.sleep(1000);
      }
      Assert.assertFalse(f.getAbsolutePath() + " exists!!",f.exists());
    }
    int timeout=0;
    while (targetFile.exists() && timeout++ < 15) {
      Thread.sleep(1000);
    }
    Assert.assertFalse(targetFile.getAbsolutePath() + " exists!!",targetFile.exists());
  }
  @Test public void testContainerLaunchFromPreviousRM() throws IOException, InterruptedException, YarnException {
    containerManager.start();
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    ContainerId cId1=createContainerId(0);
    ContainerId cId2=createContainerId(0);
    containerLaunchContext.setLocalResources(new HashMap<String,LocalResource>());
    StartContainerRequest startRequest1=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId1,ResourceManagerConstants.RM_INVALID_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(startRequest1);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    boolean catchException=false;
    try {
      StartContainersResponse response=containerManager.startContainers(allRequests);
      if (response.getFailedRequests().containsKey(cId1)) {
        throw response.getFailedRequests().get(cId1).deSerialize();
      }
    }
 catch (    Throwable e) {
      e.printStackTrace();
      catchException=true;
      Assert.assertTrue(e.getMessage().contains("Container " + cId1 + " rejected as it is allocated by a previous RM"));
      Assert.assertTrue(e.getClass().getName().equalsIgnoreCase(InvalidContainerException.class.getName()));
    }
    Assert.assertTrue(catchException);
    StartContainerRequest startRequest2=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId2,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list2=new ArrayList<>();
    list.add(startRequest2);
    StartContainersRequest allRequests2=StartContainersRequest.newInstance(list2);
    containerManager.startContainers(allRequests2);
    boolean noException=true;
    try {
      containerManager.startContainers(allRequests2);
    }
 catch (    YarnException e) {
      noException=false;
    }
    Assert.assertTrue(noException);
  }
  @Test public void testMultipleContainersLaunch() throws Exception {
    containerManager.start();
    List<StartContainerRequest> list=new ArrayList<>();
    for (int i=0; i < 10; i++) {
      ContainerId cId=createContainerId(i);
      long identifier=0;
      if ((i & 1) == 0)       identifier=ResourceManagerConstants.RM_INVALID_IDENTIFIER;
 else       identifier=DUMMY_RM_IDENTIFIER;
      Token containerToken=createContainerToken(cId,identifier,context.getNodeId(),user,context.getContainerTokenSecretManager());
      StartContainerRequest request=StartContainerRequest.newInstance(recordFactory.newRecordInstance(ContainerLaunchContext.class),containerToken);
      list.add(request);
    }
    StartContainersRequest requestList=StartContainersRequest.newInstance(list);
    StartContainersResponse response=containerManager.startContainers(requestList);
    Thread.sleep(5000);
    Assert.assertEquals(5,response.getSuccessfullyStartedContainers().size());
    for (    ContainerId id : response.getSuccessfullyStartedContainers()) {
      Assert.assertEquals(1,id.getContainerId() & 1);
    }
    Assert.assertEquals(5,response.getFailedRequests().size());
    for (    Map.Entry<ContainerId,SerializedException> entry : response.getFailedRequests().entrySet()) {
      Assert.assertEquals(0,entry.getKey().getContainerId() & 1);
      Assert.assertTrue(entry.getValue().getMessage().contains("Container " + entry.getKey() + " rejected as it is allocated by a previous RM"));
    }
  }
  @Test public void testMultipleContainersStopAndGetStatus() throws Exception {
    containerManager.start();
    List<StartContainerRequest> startRequest=new ArrayList<>();
    List<ContainerId> containerIds=new ArrayList<>();
    for (int i=0; i < 10; i++) {
      ContainerId cId;
      if ((i & 1) == 0) {
        cId=createContainerId(i,1);
      }
 else {
        cId=createContainerId(i,0);
      }
      Token containerToken=createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager());
      StartContainerRequest request=StartContainerRequest.newInstance(recordFactory.newRecordInstance(ContainerLaunchContext.class),containerToken);
      startRequest.add(request);
      containerIds.add(cId);
    }
    StartContainersRequest requestList=StartContainersRequest.newInstance(startRequest);
    containerManager.startContainers(requestList);
    Thread.sleep(5000);
    GetContainerStatusesRequest statusRequest=GetContainerStatusesRequest.newInstance(containerIds);
    GetContainerStatusesResponse statusResponse=containerManager.getContainerStatuses(statusRequest);
    Assert.assertEquals(5,statusResponse.getContainerStatuses().size());
    for (    ContainerStatus status : statusResponse.getContainerStatuses()) {
      Assert.assertEquals(1,status.getContainerId().getContainerId() & 1);
    }
    Assert.assertEquals(5,statusResponse.getFailedRequests().size());
    for (    Map.Entry<ContainerId,SerializedException> entry : statusResponse.getFailedRequests().entrySet()) {
      Assert.assertEquals(0,entry.getKey().getContainerId() & 1);
      Assert.assertTrue(entry.getValue().getMessage().contains("attempted to get status for non-application container"));
    }
    StopContainersRequest stopRequest=StopContainersRequest.newInstance(containerIds);
    StopContainersResponse stopResponse=containerManager.stopContainers(stopRequest);
    Assert.assertEquals(5,stopResponse.getSuccessfullyStoppedContainers().size());
    for (    ContainerId id : stopResponse.getSuccessfullyStoppedContainers()) {
      Assert.assertEquals(1,id.getContainerId() & 1);
    }
    Assert.assertEquals(5,stopResponse.getFailedRequests().size());
    for (    Map.Entry<ContainerId,SerializedException> entry : stopResponse.getFailedRequests().entrySet()) {
      Assert.assertEquals(0,entry.getKey().getContainerId() & 1);
      Assert.assertTrue(entry.getValue().getMessage().contains("attempted to stop non-application container"));
    }
  }
  @Test public void testUnauthorizedRequests() throws IOException, YarnException {
    containerManager.start();
    ContainerId cId=createContainerId(0,1);
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    StartContainersResponse startResponse=containerManager.startContainers(allRequests);
    Assert.assertFalse("Should not be authorized to start container",startResponse.getSuccessfullyStartedContainers().contains(cId));
    Assert.assertTrue("Start container request should fail",startResponse.getFailedRequests().containsKey(cId));
    ContainerTokenIdentifier containerTokenIdentifier=BuilderUtils.newContainerTokenIdentifier(scRequest.getContainerToken());
    Container container=new ContainerImpl(conf,null,containerLaunchContext,null,metrics,containerTokenIdentifier,context);
    context.getContainers().put(cId,container);
    List<ContainerId> containerIds=new ArrayList<>();
    containerIds.add(cId);
    StopContainersRequest stopRequest=StopContainersRequest.newInstance(containerIds);
    StopContainersResponse stopResponse=containerManager.stopContainers(stopRequest);
    Assert.assertFalse("Should not be authorized to stop container",stopResponse.getSuccessfullyStoppedContainers().contains(cId));
    Assert.assertTrue("Stop container request should fail",stopResponse.getFailedRequests().containsKey(cId));
    containerIds=new ArrayList<>();
    containerIds.add(cId);
    GetContainerStatusesRequest request=GetContainerStatusesRequest.newInstance(containerIds);
    GetContainerStatusesResponse response=containerManager.getContainerStatuses(request);
    Assert.assertEquals("Should not be authorized to get container status",response.getContainerStatuses().size(),0);
    Assert.assertTrue("Get status request should fail",response.getFailedRequests().containsKey(cId));
  }
  @Test public void testStartContainerFailureWithUnknownAuxService() throws Exception {
    conf.setStrings(YarnConfiguration.NM_AUX_SERVICES,new String[]{"existService"});
    conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"existService"),ServiceA.class,Service.class);
    containerManager.start();
    List<StartContainerRequest> startRequest=new ArrayList<>();
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    Map<String,ByteBuffer> serviceData=new HashMap<String,ByteBuffer>();
    String serviceName="non_exist_auxService";
    serviceData.put(serviceName,ByteBuffer.wrap(serviceName.getBytes()));
    containerLaunchContext.setServiceData(serviceData);
    ContainerId cId=createContainerId(0);
    String user="start_container_fail";
    Token containerToken=createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager());
    StartContainerRequest request=StartContainerRequest.newInstance(containerLaunchContext,containerToken);
    startRequest.add(request);
    StartContainersRequest requestList=StartContainersRequest.newInstance(startRequest);
    StartContainersResponse response=containerManager.startContainers(requestList);
    Assert.assertEquals(1,response.getFailedRequests().size());
    Assert.assertEquals(0,response.getSuccessfullyStartedContainers().size());
    Assert.assertTrue(response.getFailedRequests().containsKey(cId));
    Assert.assertTrue(response.getFailedRequests().get(cId).getMessage().contains("The auxService:" + serviceName + " does not exist"));
  }
  @Test public void testNullTokens() throws Exception {
    ContainerManagerImpl cMgrImpl=new ContainerManagerImpl(context,exec,delSrvc,nodeStatusUpdater,metrics,dirsHandler);
    String strExceptionMsg="";
    try {
      cMgrImpl.authorizeStartAndResourceIncreaseRequest(null,new ContainerTokenIdentifier(),true);
    }
 catch (    YarnException ye) {
      strExceptionMsg=ye.getMessage();
    }
    Assert.assertEquals(strExceptionMsg,ContainerManagerImpl.INVALID_NMTOKEN_MSG);
    strExceptionMsg="";
    try {
      cMgrImpl.authorizeStartAndResourceIncreaseRequest(new NMTokenIdentifier(),null,true);
    }
 catch (    YarnException ye) {
      strExceptionMsg=ye.getMessage();
    }
    Assert.assertEquals(strExceptionMsg,ContainerManagerImpl.INVALID_CONTAINERTOKEN_MSG);
    strExceptionMsg="";
    try {
      cMgrImpl.authorizeGetAndStopContainerRequest(null,null,true,null);
    }
 catch (    YarnException ye) {
      strExceptionMsg=ye.getMessage();
    }
    Assert.assertEquals(strExceptionMsg,ContainerManagerImpl.INVALID_NMTOKEN_MSG);
    strExceptionMsg="";
    try {
      cMgrImpl.authorizeUser(null,null);
    }
 catch (    YarnException ye) {
      strExceptionMsg=ye.getMessage();
    }
    Assert.assertEquals(strExceptionMsg,ContainerManagerImpl.INVALID_NMTOKEN_MSG);
    ContainerManagerImpl spyContainerMgr=spy(cMgrImpl);
    UserGroupInformation ugInfo=UserGroupInformation.createRemoteUser("a");
    Mockito.when(spyContainerMgr.getRemoteUgi()).thenReturn(ugInfo);
    Mockito.when(spyContainerMgr.selectNMTokenIdentifier(ugInfo)).thenReturn(null);
    strExceptionMsg="";
    try {
      spyContainerMgr.stopContainers(new StopContainersRequestPBImpl());
    }
 catch (    YarnException ye) {
      strExceptionMsg=ye.getMessage();
    }
    Assert.assertEquals(strExceptionMsg,ContainerManagerImpl.INVALID_NMTOKEN_MSG);
    strExceptionMsg="";
    try {
      spyContainerMgr.getContainerStatuses(new GetContainerStatusesRequestPBImpl());
    }
 catch (    YarnException ye) {
      strExceptionMsg=ye.getMessage();
    }
    Assert.assertEquals(strExceptionMsg,ContainerManagerImpl.INVALID_NMTOKEN_MSG);
    Mockito.doNothing().when(spyContainerMgr).authorizeUser(ugInfo,null);
    List<StartContainerRequest> reqList=new ArrayList<>();
    reqList.add(StartContainerRequest.newInstance(null,null));
    StartContainersRequest reqs=new StartContainersRequestPBImpl();
    reqs.setStartContainerRequests(reqList);
    strExceptionMsg="";
    try {
      spyContainerMgr.startContainers(reqs);
    }
 catch (    YarnException ye) {
      strExceptionMsg=ye.getCause().getMessage();
    }
    Assert.assertEquals(strExceptionMsg,ContainerManagerImpl.INVALID_CONTAINERTOKEN_MSG);
  }
  @Test public void testIncreaseContainerResourceWithInvalidRequests() throws Exception {
    containerManager.start();
    List<StartContainerRequest> list=new ArrayList<>();
    for (int i=0; i < 4; i++) {
      ContainerId cId=createContainerId(i);
      long identifier=DUMMY_RM_IDENTIFIER;
      Token containerToken=createContainerToken(cId,identifier,context.getNodeId(),user,context.getContainerTokenSecretManager());
      StartContainerRequest request=StartContainerRequest.newInstance(recordFactory.newRecordInstance(ContainerLaunchContext.class),containerToken);
      list.add(request);
    }
    StartContainersRequest requestList=StartContainersRequest.newInstance(list);
    StartContainersResponse response=containerManager.startContainers(requestList);
    Assert.assertEquals(4,response.getSuccessfullyStartedContainers().size());
    int i=0;
    for (    ContainerId id : response.getSuccessfullyStartedContainers()) {
      Assert.assertEquals(i,id.getContainerId());
      i++;
    }
    Thread.sleep(2000);
    List<Token> increaseTokens=new ArrayList<>();
    ContainerId cId0=createContainerId(0);
    Token containerToken=createContainerToken(cId0,1,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,Resource.newInstance(1234,3),context.getContainerTokenSecretManager(),null);
    increaseTokens.add(containerToken);
    ContainerId cId7=createContainerId(7);
    containerToken=createContainerToken(cId7,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,Resource.newInstance(1234,3),context.getContainerTokenSecretManager(),null);
    increaseTokens.add(containerToken);
    ContainerUpdateRequest updateRequest=ContainerUpdateRequest.newInstance(increaseTokens);
    ContainerUpdateResponse updateResponse=containerManager.updateContainer(updateRequest);
    Assert.assertEquals(1,updateResponse.getSuccessfullyUpdatedContainers().size());
    Assert.assertEquals(1,updateResponse.getFailedRequests().size());
    for (    Map.Entry<ContainerId,SerializedException> entry : updateResponse.getFailedRequests().entrySet()) {
      Assert.assertNotNull("Failed message",entry.getValue().getMessage());
      if (cId7.equals(entry.getKey())) {
        Assert.assertTrue(entry.getValue().getMessage().contains("Container " + cId7.toString() + " is not handled by this NodeManager"));
      }
 else {
        throw new YarnException("Received failed request from wrong" + " container: " + entry.getKey().toString());
      }
    }
  }
  @Test public void testChangeContainerResource() throws Exception {
    containerManager.start();
    File scriptFile=Shell.appendScriptExtension(tmpDir,"scriptFile");
    PrintWriter fileWriter=new PrintWriter(scriptFile);
    ContainerId cId=createContainerId(0);
    if (Shell.WINDOWS) {
      fileWriter.println("@ping -n 100 127.0.0.1 >nul");
    }
 else {
      fileWriter.write("\numask 0");
      fileWriter.write("\nexec sleep 100");
    }
    fileWriter.close();
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    URL resource_alpha=URL.fromPath(localFS.makeQualified(new Path(scriptFile.getAbsolutePath())));
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(resource_alpha);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(scriptFile.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,rsrc_alpha);
    containerLaunchContext.setLocalResources(localResources);
    List<String> commands=Arrays.asList(Shell.getRunScriptCommand(scriptFile));
    containerLaunchContext.setCommands(commands);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    BaseContainerManagerTest.waitForNMContainerState(containerManager,cId,org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING);
    List<Token> increaseTokens=new ArrayList<>();
    Resource targetResource=Resource.newInstance(4096,2);
    Token containerToken=createContainerToken(cId,1,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,targetResource,context.getContainerTokenSecretManager(),null);
    increaseTokens.add(containerToken);
    ContainerUpdateRequest updateRequest=ContainerUpdateRequest.newInstance(increaseTokens);
    ContainerUpdateResponse updateResponse=containerManager.updateContainer(updateRequest);
    Assert.assertEquals(1,updateResponse.getSuccessfullyUpdatedContainers().size());
    Assert.assertTrue(updateResponse.getFailedRequests().isEmpty());
    List<ContainerId> containerIds=new ArrayList<>();
    containerIds.add(cId);
    GetContainerStatusesRequest gcsRequest=GetContainerStatusesRequest.newInstance(containerIds);
    ContainerStatus containerStatus=containerManager.getContainerStatuses(gcsRequest).getContainerStatuses().get(0);
    assertEquals(targetResource,containerStatus.getCapability());
    List<Token> decreaseTokens=new ArrayList<>();
    targetResource=Resource.newInstance(2048,2);
    Token token=createContainerToken(cId,2,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,targetResource,context.getContainerTokenSecretManager(),null);
    decreaseTokens.add(token);
    updateRequest=ContainerUpdateRequest.newInstance(decreaseTokens);
    updateResponse=containerManager.updateContainer(updateRequest);
    Assert.assertEquals(1,updateResponse.getSuccessfullyUpdatedContainers().size());
    Assert.assertTrue(updateResponse.getFailedRequests().isEmpty());
    containerStatus=containerManager.getContainerStatuses(gcsRequest).getContainerStatuses().get(0);
    int retry=0;
    while (!targetResource.equals(containerStatus.getCapability()) && (retry++ < 5)) {
      Thread.sleep(200);
      containerStatus=containerManager.getContainerStatuses(gcsRequest).getContainerStatuses().get(0);
    }
    assertEquals(targetResource,containerStatus.getCapability());
  }
  @Test public void testOutputThreadDumpSignal() throws IOException, InterruptedException, YarnException {
    testContainerLaunchAndSignal(SignalContainerCommand.OUTPUT_THREAD_DUMP);
  }
  @Test public void testGracefulShutdownSignal() throws IOException, InterruptedException, YarnException {
    testContainerLaunchAndSignal(SignalContainerCommand.GRACEFUL_SHUTDOWN);
  }
  @Test public void testForcefulShutdownSignal() throws IOException, InterruptedException, YarnException {
    testContainerLaunchAndSignal(SignalContainerCommand.FORCEFUL_SHUTDOWN);
  }
  private void testContainerLaunchAndSignal(  SignalContainerCommand command) throws IOException, InterruptedException, YarnException {
    Signal signal=ContainerLaunch.translateCommandToSignal(command);
    containerManager.start();
    File scriptFile=Shell.appendScriptExtension(tmpDir,"scriptFile");
    PrintWriter fileWriter=new PrintWriter(scriptFile);
    File processStartFile=new File(tmpDir,"start_file.txt").getAbsoluteFile();
    writeScriptFile(fileWriter,"Hello world!",processStartFile,null,false);
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    ContainerId cId=createContainerId(0);
    URL resource_alpha=URL.fromPath(localFS.makeQualified(new Path(scriptFile.getAbsolutePath())));
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(resource_alpha);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(scriptFile.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,rsrc_alpha);
    containerLaunchContext.setLocalResources(localResources);
    List<String> commands=Arrays.asList(Shell.getRunScriptCommand(scriptFile));
    containerLaunchContext.setCommands(commands);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager()));
    List<StartContainerRequest> list=new ArrayList<>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    int timeoutSecs=0;
    while (!processStartFile.exists() && timeoutSecs++ < 20) {
      Thread.sleep(1000);
      LOG.info("Waiting for process start-file to be created");
    }
    Assert.assertTrue("ProcessStartFile doesn't exist!",processStartFile.exists());
    SignalContainerRequest signalReq=SignalContainerRequest.newInstance(cId,command);
    List<SignalContainerRequest> reqs=new ArrayList<>();
    reqs.add(signalReq);
    containerManager.handle(new CMgrSignalContainersEvent(reqs));
    final ArgumentCaptor<ContainerSignalContext> signalContextCaptor=ArgumentCaptor.forClass(ContainerSignalContext.class);
    if (signal.equals(Signal.NULL)) {
      verify(exec,never()).signalContainer(signalContextCaptor.capture());
    }
 else {
      verify(exec,timeout(10000).atLeastOnce()).signalContainer(signalContextCaptor.capture());
      ContainerSignalContext signalContext=signalContextCaptor.getAllValues().get(0);
      Assert.assertEquals(cId,signalContext.getContainer().getContainerId());
      Assert.assertEquals(signal,signalContext.getSignal());
    }
  }
  @Test public void testStartContainerFailureWithInvalidLocalResource() throws Exception {
    containerManager.start();
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(null);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(System.currentTimeMillis());
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put("invalid_resource",rsrc_alpha);
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    ContainerLaunchContext spyContainerLaunchContext=spy(containerLaunchContext);
    Mockito.when(spyContainerLaunchContext.getLocalResources()).thenReturn(localResources);
    ContainerId cId=createContainerId(0);
    String user="start_container_fail";
    Token containerToken=createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager());
    StartContainerRequest request=StartContainerRequest.newInstance(spyContainerLaunchContext,containerToken);
    List<StartContainerRequest> startRequest=new ArrayList<StartContainerRequest>();
    startRequest.add(request);
    StartContainersRequest requestList=StartContainersRequest.newInstance(startRequest);
    StartContainersResponse response=containerManager.startContainers(requestList);
    Assert.assertTrue(response.getFailedRequests().size() == 1);
    Assert.assertTrue(response.getSuccessfullyStartedContainers().size() == 0);
    Assert.assertTrue(response.getFailedRequests().containsKey(cId));
    Assert.assertTrue(response.getFailedRequests().get(cId).getMessage().contains("Null resource URL for local resource"));
  }
  @Test public void testStartContainerFailureWithNullTypeLocalResource() throws Exception {
    containerManager.start();
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(URL.fromPath(new Path("./")));
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(null);
    rsrc_alpha.setTimestamp(System.currentTimeMillis());
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put("null_type_resource",rsrc_alpha);
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    ContainerLaunchContext spyContainerLaunchContext=spy(containerLaunchContext);
    Mockito.when(spyContainerLaunchContext.getLocalResources()).thenReturn(localResources);
    ContainerId cId=createContainerId(0);
    String user="start_container_fail";
    Token containerToken=createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager());
    StartContainerRequest request=StartContainerRequest.newInstance(spyContainerLaunchContext,containerToken);
    List<StartContainerRequest> startRequest=new ArrayList<StartContainerRequest>();
    startRequest.add(request);
    StartContainersRequest requestList=StartContainersRequest.newInstance(startRequest);
    StartContainersResponse response=containerManager.startContainers(requestList);
    Assert.assertTrue(response.getFailedRequests().size() == 1);
    Assert.assertTrue(response.getSuccessfullyStartedContainers().size() == 0);
    Assert.assertTrue(response.getFailedRequests().containsKey(cId));
    Assert.assertTrue(response.getFailedRequests().get(cId).getMessage().contains("Null resource type for local resource"));
  }
  @Test public void testStartContainerFailureWithNullVisibilityLocalResource() throws Exception {
    containerManager.start();
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(URL.fromPath(new Path("./")));
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(null);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(System.currentTimeMillis());
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put("null_visibility_resource",rsrc_alpha);
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    ContainerLaunchContext spyContainerLaunchContext=spy(containerLaunchContext);
    Mockito.when(spyContainerLaunchContext.getLocalResources()).thenReturn(localResources);
    ContainerId cId=createContainerId(0);
    String user="start_container_fail";
    Token containerToken=createContainerToken(cId,DUMMY_RM_IDENTIFIER,context.getNodeId(),user,context.getContainerTokenSecretManager());
    StartContainerRequest request=StartContainerRequest.newInstance(spyContainerLaunchContext,containerToken);
    List<StartContainerRequest> startRequest=new ArrayList<StartContainerRequest>();
    startRequest.add(request);
    StartContainersRequest requestList=StartContainersRequest.newInstance(startRequest);
    StartContainersResponse response=containerManager.startContainers(requestList);
    Assert.assertTrue(response.getFailedRequests().size() == 1);
    Assert.assertTrue(response.getSuccessfullyStartedContainers().size() == 0);
    Assert.assertTrue(response.getFailedRequests().containsKey(cId));
    Assert.assertTrue(response.getFailedRequests().get(cId).getMessage().contains("Null resource visibility for local resource"));
  }
}
