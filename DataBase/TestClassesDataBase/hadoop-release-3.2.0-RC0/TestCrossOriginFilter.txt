public class TestCrossOriginFilter {
  @Test public void testSameOrigin() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    HttpServletRequest mockReq=Mockito.mock(HttpServletRequest.class);
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ORIGIN)).thenReturn(null);
    HttpServletResponse mockRes=Mockito.mock(HttpServletResponse.class);
    FilterChain mockChain=Mockito.mock(FilterChain.class);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    filter.doFilter(mockReq,mockRes,mockChain);
    Mockito.verifyZeroInteractions(mockRes);
    Mockito.verify(mockChain).doFilter(mockReq,mockRes);
  }
  @Test public void testAllowAllOrigins() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"*");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    Assert.assertTrue(filter.areOriginsAllowed("example.com"));
  }
  @Test public void testEncodeHeaders(){
    String validOrigin="http://localhost:12345";
    String encodedValidOrigin=CrossOriginFilter.encodeHeader(validOrigin);
    Assert.assertEquals("Valid origin encoding should match exactly",validOrigin,encodedValidOrigin);
    String httpResponseSplitOrigin=validOrigin + " \nSecondHeader: value";
    String encodedResponseSplitOrigin=CrossOriginFilter.encodeHeader(httpResponseSplitOrigin);
    Assert.assertEquals("Http response split origin should be protected against",validOrigin,encodedResponseSplitOrigin);
    String validOriginList="http://foo.example.com:12345 http://bar.example.com:12345";
    String encodedValidOriginList=CrossOriginFilter.encodeHeader(validOriginList);
    Assert.assertEquals("Valid origin list encoding should match exactly",validOriginList,encodedValidOriginList);
  }
  @Test public void testPatternMatchingOrigins() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"*.example.com");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    Assert.assertFalse(filter.areOriginsAllowed("example.com"));
    Assert.assertFalse(filter.areOriginsAllowed("foo:example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.bar.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.example.com foo.nomatch.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.nomatch.com foo.example.com"));
    Assert.assertFalse(filter.areOriginsAllowed("foo.nomatch1.com foo.nomatch2.com"));
  }
  @Test public void testRegexPatternMatchingOrigins() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"regex:.*[.]example[.]com");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    Assert.assertFalse(filter.areOriginsAllowed("example.com"));
    Assert.assertFalse(filter.areOriginsAllowed("foo:example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.bar.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.example.com foo.nomatch.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.nomatch.com foo.example.com"));
    Assert.assertFalse(filter.areOriginsAllowed("foo.nomatch1.com foo.nomatch2.com"));
  }
  @Test public void testComplexRegexPatternMatchingOrigins() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"regex:https?:\\/\\/sub1[.]example[.]com(:[0-9]+)?");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    Assert.assertTrue(filter.areOriginsAllowed("http://sub1.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("https://sub1.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("http://sub1.example.com:1234"));
    Assert.assertTrue(filter.areOriginsAllowed("https://sub1.example.com:8080"));
    Assert.assertFalse(filter.areOriginsAllowed("foo.nomatch1.com foo.nomatch2.com"));
  }
  @Test public void testMixedRegexPatternMatchingOrigins() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"regex:https?:\\/\\/sub1[.]example[.]com(:[0-9]+)?, " + "*.example2.com");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    Assert.assertTrue(filter.areOriginsAllowed("http://sub1.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("https://sub1.example.com"));
    Assert.assertTrue(filter.areOriginsAllowed("http://sub1.example.com:1234"));
    Assert.assertTrue(filter.areOriginsAllowed("https://sub1.example.com:8080"));
    Assert.assertFalse(filter.areOriginsAllowed("example2.com"));
    Assert.assertFalse(filter.areOriginsAllowed("foo:example2.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.example2.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.bar.example2.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.example2.com foo.nomatch.com"));
    Assert.assertTrue(filter.areOriginsAllowed("foo.nomatch.com foo.example2.com"));
    Assert.assertFalse(filter.areOriginsAllowed("foo.nomatch1.com foo.nomatch2.com"));
  }
  @Test public void testDisallowedOrigin() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"example.com");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    HttpServletRequest mockReq=Mockito.mock(HttpServletRequest.class);
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ORIGIN)).thenReturn("example.org");
    HttpServletResponse mockRes=Mockito.mock(HttpServletResponse.class);
    FilterChain mockChain=Mockito.mock(FilterChain.class);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    filter.doFilter(mockReq,mockRes,mockChain);
    Mockito.verifyZeroInteractions(mockRes);
    Mockito.verify(mockChain).doFilter(mockReq,mockRes);
  }
  @Test public void testDisallowedMethod() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"example.com");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    HttpServletRequest mockReq=Mockito.mock(HttpServletRequest.class);
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ORIGIN)).thenReturn("example.com");
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ACCESS_CONTROL_REQUEST_METHOD)).thenReturn("DISALLOWED_METHOD");
    HttpServletResponse mockRes=Mockito.mock(HttpServletResponse.class);
    FilterChain mockChain=Mockito.mock(FilterChain.class);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    filter.doFilter(mockReq,mockRes,mockChain);
    Mockito.verifyZeroInteractions(mockRes);
    Mockito.verify(mockChain).doFilter(mockReq,mockRes);
  }
  @Test public void testDisallowedHeader() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"example.com");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    HttpServletRequest mockReq=Mockito.mock(HttpServletRequest.class);
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ORIGIN)).thenReturn("example.com");
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ACCESS_CONTROL_REQUEST_METHOD)).thenReturn("GET");
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ACCESS_CONTROL_REQUEST_HEADERS)).thenReturn("Disallowed-Header");
    HttpServletResponse mockRes=Mockito.mock(HttpServletResponse.class);
    FilterChain mockChain=Mockito.mock(FilterChain.class);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    filter.doFilter(mockReq,mockRes,mockChain);
    Mockito.verifyZeroInteractions(mockRes);
    Mockito.verify(mockChain).doFilter(mockReq,mockRes);
  }
  @Test public void testCrossOriginFilter() throws ServletException, IOException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"example.com");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    HttpServletRequest mockReq=Mockito.mock(HttpServletRequest.class);
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ORIGIN)).thenReturn("example.com");
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ACCESS_CONTROL_REQUEST_METHOD)).thenReturn("GET");
    Mockito.when(mockReq.getHeader(CrossOriginFilter.ACCESS_CONTROL_REQUEST_HEADERS)).thenReturn("X-Requested-With");
    HttpServletResponse mockRes=Mockito.mock(HttpServletResponse.class);
    FilterChain mockChain=Mockito.mock(FilterChain.class);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    filter.doFilter(mockReq,mockRes,mockChain);
    Mockito.verify(mockRes).setHeader(CrossOriginFilter.ACCESS_CONTROL_ALLOW_ORIGIN,"example.com");
    Mockito.verify(mockRes).setHeader(CrossOriginFilter.ACCESS_CONTROL_ALLOW_CREDENTIALS,Boolean.TRUE.toString());
    Mockito.verify(mockRes).setHeader(CrossOriginFilter.ACCESS_CONTROL_ALLOW_METHODS,filter.getAllowedMethodsHeader());
    Mockito.verify(mockRes).setHeader(CrossOriginFilter.ACCESS_CONTROL_ALLOW_HEADERS,filter.getAllowedHeadersHeader());
    Mockito.verify(mockChain).doFilter(mockReq,mockRes);
  }
  @Test public void testCrossOriginFilterAfterRestart() throws ServletException {
    Map<String,String> conf=new HashMap<String,String>();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"example.com");
    conf.put(CrossOriginFilter.ALLOWED_HEADERS,"X-Requested-With,Accept");
    conf.put(CrossOriginFilter.ALLOWED_METHODS,"GET,POST");
    FilterConfig filterConfig=new FilterConfigTest(conf);
    CrossOriginFilter filter=new CrossOriginFilter();
    filter.init(filterConfig);
    Assert.assertTrue("Allowed headers do not match",filter.getAllowedHeadersHeader().compareTo("X-Requested-With,Accept") == 0);
    Assert.assertTrue("Allowed methods do not match",filter.getAllowedMethodsHeader().compareTo("GET,POST") == 0);
    Assert.assertTrue(filter.areOriginsAllowed("example.com"));
    filter.destroy();
    conf.clear();
    conf.put(CrossOriginFilter.ALLOWED_ORIGINS,"newexample.com");
    conf.put(CrossOriginFilter.ALLOWED_HEADERS,"Content-Type,Origin");
    conf.put(CrossOriginFilter.ALLOWED_METHODS,"GET,HEAD");
    filterConfig=new FilterConfigTest(conf);
    filter.init(filterConfig);
    Assert.assertTrue("Allowed headers do not match",filter.getAllowedHeadersHeader().compareTo("Content-Type,Origin") == 0);
    Assert.assertTrue("Allowed methods do not match",filter.getAllowedMethodsHeader().compareTo("GET,HEAD") == 0);
    Assert.assertTrue(filter.areOriginsAllowed("newexample.com"));
    filter.destroy();
  }
private static class FilterConfigTest implements FilterConfig {
    final Map<String,String> map;
    FilterConfigTest(    Map<String,String> map){
      this.map=map;
    }
    @Override public String getFilterName(){
      return "test-filter";
    }
    @Override public String getInitParameter(    String key){
      return map.get(key);
    }
    @Override public Enumeration<String> getInitParameterNames(){
      return Collections.enumeration(map.keySet());
    }
    @Override public ServletContext getServletContext(){
      return null;
    }
  }
}
