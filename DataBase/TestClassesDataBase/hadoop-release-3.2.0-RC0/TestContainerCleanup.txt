/** 
 * Tests for  {@link ContainerCleanup}.
 */
public class TestContainerCleanup {
  private YarnConfiguration conf;
  private ContainerId containerId;
  private ContainerExecutor executor;
  private ContainerLaunch launch;
  private ContainerCleanup cleanup;
  @Before public void setup() throws Exception {
    conf=new YarnConfiguration();
    conf.setLong(NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,60000);
    Context context=mock(Context.class);
    NMStateStoreService storeService=mock(NMStateStoreService.class);
    when(context.getNMStateStore()).thenReturn(storeService);
    Dispatcher dispatcher=new InlineDispatcher();
    executor=mock(ContainerExecutor.class);
    when(executor.signalContainer(Mockito.any(ContainerSignalContext.class))).thenReturn(true);
    ApplicationId appId=ApplicationId.newInstance(System.currentTimeMillis(),1);
    ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(appId,1);
    containerId=ContainerId.newContainerId(attemptId,1);
    Container container=mock(Container.class);
    when(container.getContainerId()).thenReturn(containerId);
    launch=mock(ContainerLaunch.class);
    launch.containerAlreadyLaunched=new AtomicBoolean(false);
    launch.pidFilePath=new Path("target/" + containerId.toString() + ".pid");
    when(launch.getContainerPid()).thenReturn(containerId.toString());
    cleanup=new ContainerCleanup(context,conf,dispatcher,executor,container,launch);
  }
  @Test public void testNoCleanupWhenContainerNotLaunched() throws IOException {
    cleanup.run();
    verify(launch,Mockito.times(0)).signalContainer(Mockito.any(SignalContainerCommand.class));
  }
  @Test public void testCleanup() throws Exception {
    launch.containerAlreadyLaunched.set(true);
    cleanup.run();
    ArgumentCaptor<ContainerSignalContext> captor=ArgumentCaptor.forClass(ContainerSignalContext.class);
    verify(executor,Mockito.times(1)).signalContainer(captor.capture());
    Assert.assertEquals("signal",ContainerExecutor.Signal.TERM,captor.getValue().getSignal());
  }
}
