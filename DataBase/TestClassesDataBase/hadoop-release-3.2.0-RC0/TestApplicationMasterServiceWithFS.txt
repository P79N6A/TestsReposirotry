/** 
 * Test Application master service using Fair scheduler.
 */
public class TestApplicationMasterServiceWithFS {
  private static final Log LOG=LogFactory.getLog(TestApplicationMasterServiceWithFS.class);
  private static final int GB=1024;
  private static final int MEMORY_ALLOCATION=3 * GB;
  private static final String TEST_FOLDER="test-queues";
  private AllocateResponse allocateResponse;
  private static YarnConfiguration configuration;
  @BeforeClass public static void setup() throws IOException {
    String allocFile=GenericTestUtils.getTestDir(TEST_FOLDER).getAbsolutePath();
    configuration=new YarnConfiguration();
    configuration.setClass(YarnConfiguration.RM_SCHEDULER,FairScheduler.class,ResourceScheduler.class);
    configuration.set(FairSchedulerConfiguration.ALLOCATION_FILE,allocFile);
    PrintWriter out=new PrintWriter(new FileWriter(allocFile));
    out.println("<?xml version=\"1.0\"?>");
    out.println("<allocations>");
    out.println("  <queue name=\"queueA\">");
    out.println("   <maxContainerAllocation>2048 mb 1 vcores</maxContainerAllocation>");
    out.println("  </queue>");
    out.println("  <queue name=\"queueB\">");
    out.println("   <maxContainerAllocation>3072 mb 1 vcores</maxContainerAllocation>");
    out.println("  </queue>");
    out.println("  <queue name=\"queueC\">");
    out.println("  </queue>");
    out.println("</allocations>");
    out.close();
  }
  @AfterClass public static void teardown(){
    File allocFile=GenericTestUtils.getTestDir(TEST_FOLDER);
    allocFile.delete();
  }
  @Test(timeout=3000000) public void testQueueLevelContainerAllocationFail() throws Exception {
    MockRM rm=new MockRM(configuration);
    rm.start();
    MockNM nm1=rm.registerNode("127.0.0.1:1234",6 * GB);
    RMApp app1=rm.submitApp(2 * GB,"queueA");
    nm1.nodeHeartbeat(true);
    RMAppAttempt attempt1=app1.getCurrentAppAttempt();
    MockAM am1=rm.sendAMLaunched(attempt1.getAppAttemptId());
    am1.registerAppAttempt();
    am1.addRequests(new String[]{"127.0.0.1"},MEMORY_ALLOCATION,1,1);
    try {
      allocateResponse=am1.schedule();
      Assert.fail();
    }
 catch (    Exception e) {
      Assert.assertTrue(e instanceof InvalidResourceRequestException);
      Assert.assertEquals(InvalidResourceRequestException.InvalidResourceType.GREATER_THEN_MAX_ALLOCATION,((InvalidResourceRequestException)e).getInvalidResourceType());
    }
 finally {
      rm.stop();
    }
  }
  @Test(timeout=3000000) public void testQueueLevelContainerAllocationSuccess() throws Exception {
    testFairSchedulerContainerAllocationSuccess("queueB");
  }
  @Test(timeout=3000000) public void testSchedulerLevelContainerAllocationSuccess() throws Exception {
    testFairSchedulerContainerAllocationSuccess("queueC");
  }
  private void testFairSchedulerContainerAllocationSuccess(  String queueName) throws Exception {
    MockRM rm=new MockRM(configuration);
    rm.start();
    MockNM nm1=rm.registerNode("127.0.0.1:1234",6 * GB);
    RMApp app1=rm.submitApp(2 * GB,queueName);
    nm1.nodeHeartbeat(true);
    RMAppAttempt attempt1=app1.getCurrentAppAttempt();
    MockAM am1=rm.sendAMLaunched(attempt1.getAppAttemptId());
    am1.registerAppAttempt();
    am1.addRequests(new String[]{"127.0.0.1"},MEMORY_ALLOCATION,1,1);
    allocateResponse=am1.schedule();
    ((FairScheduler)rm.getResourceScheduler()).update();
    nm1.nodeHeartbeat(true);
    GenericTestUtils.waitFor(() -> {
      LOG.info("Waiting for containers to be created for app 1");
      try {
        allocateResponse=am1.schedule();
      }
 catch (      Exception e) {
        Assert.fail("Allocation should be successful");
      }
      return allocateResponse.getAllocatedContainers().size() > 0;
    }
,1000,10000);
    Container allocatedContainer=allocateResponse.getAllocatedContainers().get(0);
    Assert.assertEquals(MEMORY_ALLOCATION,allocatedContainer.getResource().getMemorySize());
    Assert.assertEquals(1,allocatedContainer.getResource().getVirtualCores());
    rm.stop();
  }
}
