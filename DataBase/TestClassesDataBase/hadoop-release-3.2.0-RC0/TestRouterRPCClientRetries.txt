/** 
 * Test retry behavior of the Router RPC Client.
 */
public class TestRouterRPCClientRetries {
  private static StateStoreDFSCluster cluster;
  private static NamenodeContext nnContext1;
  private static RouterContext routerContext;
  private static MembershipNamenodeResolver resolver;
  private static ClientProtocol routerProtocol;
  @Rule public final Timeout testTimeout=new Timeout(100000);
  @Before public void setUp() throws Exception {
    cluster=new StateStoreDFSCluster(false,2);
    Configuration routerConf=new RouterConfigBuilder().stateStore().metrics().admin().rpc().build();
    routerConf.setTimeDuration(NamenodeBeanMetrics.DN_REPORT_CACHE_EXPIRE,1,TimeUnit.SECONDS);
    Configuration clientConf=new Configuration(false);
    clientConf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECT_MAX_RETRIES_KEY,1);
    clientConf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY,100);
    cluster.setIndependentDNs();
    cluster.addRouterOverrides(routerConf);
    cluster.startCluster(clientConf);
    cluster.startRouters();
    cluster.waitClusterUp();
    nnContext1=cluster.getNamenode(cluster.getNameservices().get(0),null);
    routerContext=cluster.getRandomRouter();
    resolver=(MembershipNamenodeResolver)routerContext.getRouter().getNamenodeResolver();
    routerProtocol=routerContext.getClient().getNamenode();
  }
  @After public void tearDown(){
    if (cluster != null) {
      cluster.stopRouter(routerContext);
      cluster.shutdown();
      cluster=null;
    }
  }
  @Test public void testRetryWhenAllNameServiceDown() throws Exception {
    MiniDFSCluster dfsCluster=cluster.getCluster();
    dfsCluster.shutdown();
    registerInvalidNameReport();
    String dirPath="/testRetryWhenClusterisDown";
    FsPermission permission=new FsPermission("705");
    try {
      routerProtocol.mkdirs(dirPath,permission,false);
      fail("Should have thrown RemoteException error.");
    }
 catch (    RemoteException e) {
      String ns0=cluster.getNameservices().get(0);
      assertExceptionContains("No namenode available under nameservice " + ns0,e);
    }
    FederationRPCMetrics rpcMetrics=routerContext.getRouter().getRpcServer().getRPCMetrics();
    assertEquals(1,rpcMetrics.getProxyOpRetries());
  }
  @Test public void testRetryWhenOneNameServiceDown() throws Exception {
    MiniDFSCluster dfsCluster=cluster.getCluster();
    dfsCluster.shutdownNameNode(0);
    registerInvalidNameReport();
    DFSClient client=nnContext1.getClient();
    routerProtocol.renewLease(client.getClientName());
    FederationRPCMetrics rpcMetrics=routerContext.getRouter().getRpcServer().getRPCMetrics();
    assertEquals(1,rpcMetrics.getProxyOpRetries());
  }
  /** 
 * Register an invalid namenode report.
 * @throws IOException
 */
  private void registerInvalidNameReport() throws IOException {
    String ns0=cluster.getNameservices().get(0);
    List<? extends FederationNamenodeContext> origin=resolver.getNamenodesForNameserviceId(ns0);
    FederationNamenodeContext nnInfo=origin.get(0);
    NamenodeStatusReport report=new NamenodeStatusReport(ns0,nnInfo.getNamenodeId(),nnInfo.getRpcAddress(),nnInfo.getServiceAddress(),nnInfo.getLifelineAddress(),nnInfo.getWebAddress());
    report.setRegistrationValid(false);
    assertTrue(resolver.registerNamenode(report));
    resolver.loadCache(true);
  }
  @Test public void testNamenodeMetricsSlow() throws Exception {
    final Router router=routerContext.getRouter();
    final NamenodeBeanMetrics metrics=router.getNamenodeMetrics();
    final String jsonString0=metrics.getLiveNodes();
    assertEquals(4,getNumDatanodes(jsonString0));
    assertEquals(jsonString0,metrics.getLiveNodes());
    waitUpdateLiveNodes(jsonString0,metrics);
    final String jsonString2=metrics.getLiveNodes();
    assertNotEquals(jsonString0,jsonString2);
    assertEquals(4,getNumDatanodes(jsonString2));
    MiniDFSCluster dfsCluster=cluster.getCluster();
    NameNode nn0=dfsCluster.getNameNode(0);
    simulateSlowNamenode(nn0,3);
    waitUpdateLiveNodes(jsonString2,metrics);
    final String jsonString3=metrics.getLiveNodes();
    assertEquals(2,getNumDatanodes(jsonString3));
    NameNode nn1=dfsCluster.getNameNode(1);
    simulateSlowNamenode(nn1,3);
    waitUpdateLiveNodes(jsonString3,metrics);
    final String jsonString4=metrics.getLiveNodes();
    assertEquals(0,getNumDatanodes(jsonString4));
  }
  /** 
 * Get the number of nodes in a JSON string.
 * @param jsonString JSON string containing nodes.
 * @return Number of nodes.
 * @throws JSONException If the JSON string is not properly formed.
 */
  private static int getNumDatanodes(  final String jsonString) throws JSONException {
    JSONObject jsonObject=new JSONObject(jsonString);
    if (jsonObject.length() == 0) {
      return 0;
    }
    return jsonObject.names().length();
  }
  /** 
 * Wait until the cached live nodes value is updated.
 * @param oldValue Old cached value.
 * @param metrics Namenode metrics beans to get the live nodes from.
 * @throws Exception If it cannot wait.
 */
  private static void waitUpdateLiveNodes(  final String oldValue,  final NamenodeBeanMetrics metrics) throws Exception {
    waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return !oldValue.equals(metrics.getLiveNodes());
      }
    }
,500,5 * 1000);
  }
}
