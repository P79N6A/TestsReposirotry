public class TestAnd {
  @Rule public Timeout globalTimeout=new Timeout(10000);
  @Test public void testPass() throws IOException {
    And and=new And();
    PathData pathData=mock(PathData.class);
    Expression first=mock(Expression.class);
    when(first.apply(pathData,-1)).thenReturn(Result.PASS);
    Expression second=mock(Expression.class);
    when(second.apply(pathData,-1)).thenReturn(Result.PASS);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    assertEquals(Result.PASS,and.apply(pathData,-1));
    verify(first).apply(pathData,-1);
    verify(second).apply(pathData,-1);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testFailFirst() throws IOException {
    And and=new And();
    PathData pathData=mock(PathData.class);
    Expression first=mock(Expression.class);
    when(first.apply(pathData,-1)).thenReturn(Result.FAIL);
    Expression second=mock(Expression.class);
    when(second.apply(pathData,-1)).thenReturn(Result.PASS);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    assertEquals(Result.FAIL,and.apply(pathData,-1));
    verify(first).apply(pathData,-1);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testFailSecond() throws IOException {
    And and=new And();
    PathData pathData=mock(PathData.class);
    Expression first=mock(Expression.class);
    when(first.apply(pathData,-1)).thenReturn(Result.PASS);
    Expression second=mock(Expression.class);
    when(second.apply(pathData,-1)).thenReturn(Result.FAIL);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    assertEquals(Result.FAIL,and.apply(pathData,-1));
    verify(first).apply(pathData,-1);
    verify(second).apply(pathData,-1);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testFailBoth() throws IOException {
    And and=new And();
    PathData pathData=mock(PathData.class);
    Expression first=mock(Expression.class);
    when(first.apply(pathData,-1)).thenReturn(Result.FAIL);
    Expression second=mock(Expression.class);
    when(second.apply(pathData,-1)).thenReturn(Result.FAIL);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    assertEquals(Result.FAIL,and.apply(pathData,-1));
    verify(first).apply(pathData,-1);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testStopFirst() throws IOException {
    And and=new And();
    PathData pathData=mock(PathData.class);
    Expression first=mock(Expression.class);
    when(first.apply(pathData,-1)).thenReturn(Result.STOP);
    Expression second=mock(Expression.class);
    when(second.apply(pathData,-1)).thenReturn(Result.PASS);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    assertEquals(Result.STOP,and.apply(pathData,-1));
    verify(first).apply(pathData,-1);
    verify(second).apply(pathData,-1);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testStopSecond() throws IOException {
    And and=new And();
    PathData pathData=mock(PathData.class);
    Expression first=mock(Expression.class);
    when(first.apply(pathData,-1)).thenReturn(Result.PASS);
    Expression second=mock(Expression.class);
    when(second.apply(pathData,-1)).thenReturn(Result.STOP);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    assertEquals(Result.STOP,and.apply(pathData,-1));
    verify(first).apply(pathData,-1);
    verify(second).apply(pathData,-1);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testStopFail() throws IOException {
    And and=new And();
    PathData pathData=mock(PathData.class);
    Expression first=mock(Expression.class);
    when(first.apply(pathData,-1)).thenReturn(Result.STOP);
    Expression second=mock(Expression.class);
    when(second.apply(pathData,-1)).thenReturn(Result.FAIL);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    assertEquals(Result.STOP.combine(Result.FAIL),and.apply(pathData,-1));
    verify(first).apply(pathData,-1);
    verify(second).apply(pathData,-1);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testSetOptions() throws IOException {
    And and=new And();
    Expression first=mock(Expression.class);
    Expression second=mock(Expression.class);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    FindOptions options=mock(FindOptions.class);
    and.setOptions(options);
    verify(first).setOptions(options);
    verify(second).setOptions(options);
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testPrepare() throws IOException {
    And and=new And();
    Expression first=mock(Expression.class);
    Expression second=mock(Expression.class);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    and.prepare();
    verify(first).prepare();
    verify(second).prepare();
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
  @Test public void testFinish() throws IOException {
    And and=new And();
    Expression first=mock(Expression.class);
    Expression second=mock(Expression.class);
    Deque<Expression> children=new LinkedList<Expression>();
    children.add(second);
    children.add(first);
    and.addChildren(children);
    and.finish();
    verify(first).finish();
    verify(second).finish();
    verifyNoMoreInteractions(first);
    verifyNoMoreInteractions(second);
  }
}
