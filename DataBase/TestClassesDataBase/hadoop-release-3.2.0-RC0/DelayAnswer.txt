/** 
 * Mockito answer helper that triggers one latch as soon as the method is called, then waits on another before continuing.
 */
public static class DelayAnswer implements Answer<Object> {
  private final org.slf4j.Logger LOG;
  private final CountDownLatch fireLatch=new CountDownLatch(1);
  private final CountDownLatch waitLatch=new CountDownLatch(1);
  private final CountDownLatch resultLatch=new CountDownLatch(1);
  private final AtomicInteger fireCounter=new AtomicInteger(0);
  private final AtomicInteger resultCounter=new AtomicInteger(0);
  private volatile Throwable thrown;
  private volatile Object returnValue;
  public DelayAnswer(  org.slf4j.Logger log){
    this.LOG=log;
  }
  /** 
 * Wait until the method is called.
 */
  public void waitForCall() throws InterruptedException {
    fireLatch.await();
  }
  /** 
 * Tell the method to proceed. This should only be called after waitForCall()
 */
  public void proceed(){
    waitLatch.countDown();
  }
  @Override public Object answer(  InvocationOnMock invocation) throws Throwable {
    LOG.info("DelayAnswer firing fireLatch");
    fireCounter.getAndIncrement();
    fireLatch.countDown();
    try {
      LOG.info("DelayAnswer waiting on waitLatch");
      waitLatch.await();
      LOG.info("DelayAnswer delay complete");
    }
 catch (    InterruptedException ie) {
      throw new IOException("Interrupted waiting on latch",ie);
    }
    return passThrough(invocation);
  }
  protected Object passThrough(  InvocationOnMock invocation) throws Throwable {
    try {
      Object ret=invocation.callRealMethod();
      returnValue=ret;
      return ret;
    }
 catch (    Throwable t) {
      thrown=t;
      throw t;
    }
 finally {
      resultCounter.incrementAndGet();
      resultLatch.countDown();
    }
  }
  /** 
 * After calling proceed(), this will wait until the call has completed and a result has been returned to the caller.
 */
  public void waitForResult() throws InterruptedException {
    resultLatch.await();
  }
  /** 
 * After the call has gone through, return any exception that was thrown, or null if no exception was thrown.
 */
  public Throwable getThrown(){
    return thrown;
  }
  /** 
 * After the call has gone through, return the call's return value, or null in case it was void or an exception was thrown.
 */
  public Object getReturnValue(){
    return returnValue;
  }
  public int getFireCount(){
    return fireCounter.get();
  }
  public int getResultCount(){
    return resultCounter.get();
  }
}
