/** 
 * Testing applications being retired from RM with fair scheduler.
 */
public class TestAppManagerWithFairScheduler extends AppManagerTestBase {
  private static final String TEST_FOLDER="test-queues";
  private static YarnConfiguration conf=new YarnConfiguration();
  @BeforeClass public static void setup() throws IOException {
    String allocFile=GenericTestUtils.getTestDir(TEST_FOLDER).getAbsolutePath();
    int queueMaxAllocation=512;
    PrintWriter out=new PrintWriter(new FileWriter(allocFile));
    out.println("<?xml version=\"1.0\"?>");
    out.println("<allocations>");
    out.println(" <queue name=\"queueA\">");
    out.println("  <maxContainerAllocation>" + queueMaxAllocation + " mb 1 vcores"+ "</maxContainerAllocation>");
    out.println(" </queue>");
    out.println(" <queue name=\"queueB\">");
    out.println(" </queue>");
    out.println("</allocations>");
    out.close();
    conf.setClass(YarnConfiguration.RM_SCHEDULER,FairScheduler.class,ResourceScheduler.class);
    conf.set(FairSchedulerConfiguration.ALLOCATION_FILE,allocFile);
  }
  @AfterClass public static void teardown(){
    File allocFile=GenericTestUtils.getTestDir(TEST_FOLDER);
    allocFile.delete();
  }
  @Test public void testQueueSubmitWithHighQueueContainerSize() throws YarnException {
    ApplicationId appId=MockApps.newAppID(1);
    RecordFactory recordFactory=RecordFactoryProvider.getRecordFactory(null);
    Resource resource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB);
    ApplicationSubmissionContext asContext=recordFactory.newRecordInstance(ApplicationSubmissionContext.class);
    asContext.setApplicationId(appId);
    asContext.setResource(resource);
    asContext.setPriority(Priority.newInstance(0));
    asContext.setAMContainerSpec(mockContainerLaunchContext(recordFactory));
    asContext.setQueue("queueA");
    QueueInfo mockDefaultQueueInfo=mock(QueueInfo.class);
    PlacementManager placementMgr=mock(PlacementManager.class);
    doAnswer(new Answer<ApplicationPlacementContext>(){
      @Override public ApplicationPlacementContext answer(      InvocationOnMock invocation) throws Throwable {
        return new ApplicationPlacementContext("queueA");
      }
    }
).when(placementMgr).placeApplication(any(ApplicationSubmissionContext.class),matches("test1"));
    doAnswer(new Answer<ApplicationPlacementContext>(){
      @Override public ApplicationPlacementContext answer(      InvocationOnMock invocation) throws Throwable {
        return new ApplicationPlacementContext("queueB");
      }
    }
).when(placementMgr).placeApplication(any(ApplicationSubmissionContext.class),matches("test2"));
    MockRM newMockRM=new MockRM(conf);
    RMContext newMockRMContext=newMockRM.getRMContext();
    newMockRMContext.setQueuePlacementManager(placementMgr);
    ApplicationMasterService masterService=new ApplicationMasterService(newMockRMContext,newMockRMContext.getScheduler());
    TestRMAppManager newAppMonitor=new TestRMAppManager(newMockRMContext,new ClientToAMTokenSecretManagerInRM(),newMockRMContext.getScheduler(),masterService,new ApplicationACLsManager(conf),conf);
    try {
      newAppMonitor.submitApplication(asContext,"test1");
      Assert.fail("Test should fail on too high allocation!");
    }
 catch (    InvalidResourceRequestException e) {
      Assert.assertEquals(GREATER_THEN_MAX_ALLOCATION,e.getInvalidResourceType());
    }
    newAppMonitor.submitApplication(asContext,"test2");
  }
  private static ContainerLaunchContext mockContainerLaunchContext(  RecordFactory recordFactory){
    ContainerLaunchContext amContainer=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    amContainer.setApplicationACLs(new HashMap<ApplicationAccessType,String>());
    return amContainer;
  }
}
