/** 
 * This unit test verifies the functionality of "multi-scheme" auth handler.
 */
@RunWith(FrameworkRunner.class) @CreateLdapServer(transports={@CreateTransport(protocol="LDAP",address=LDAP_SERVER_ADDR)}) @CreateDS(allowAnonAccess=true,partitions={@CreatePartition(name="Test_Partition",suffix=LDAP_BASE_DN,contextEntry=@ContextEntry(entryLdif="dn: " + LDAP_BASE_DN + " \n"+ "dc: example\n"+ "objectClass: top\n"+ "objectClass: domain\n\n"))}) @ApplyLdifs({"dn: uid=bjones," + LDAP_BASE_DN,"cn: Bob Jones","sn: Jones","objectClass: inetOrgPerson","uid: bjones","userPassword: p@ssw0rd"}) public class TestMultiSchemeAuthenticationHandler extends AbstractLdapTestUnit {
  private KerberosSecurityTestcase krbTest=new KerberosSecurityTestcase();
  private MultiSchemeAuthenticationHandler handler;
  @Before public void setUp() throws Exception {
    krbTest.startMiniKdc();
    File keytabFile=new File(KerberosTestUtils.getKeytabFile());
    String clientPrinc=KerberosTestUtils.getClientPrincipal();
    String serverPrinc=KerberosTestUtils.getServerPrincipal();
    clientPrinc=clientPrinc.substring(0,clientPrinc.lastIndexOf("@"));
    serverPrinc=serverPrinc.substring(0,serverPrinc.lastIndexOf("@"));
    krbTest.getKdc().createPrincipal(keytabFile,clientPrinc,serverPrinc);
    handler=new MultiSchemeAuthenticationHandler();
    try {
      handler.init(getDefaultProperties());
    }
 catch (    Exception e) {
      throw e;
    }
  }
  @After public void tearDown() throws Exception {
    krbTest.stopMiniKdc();
  }
  private Properties getDefaultProperties(){
    Properties p=new Properties();
    p.setProperty(SCHEMES_PROPERTY,BASIC + "," + NEGOTIATE);
    p.setProperty(String.format(AUTH_HANDLER_PROPERTY,"negotiate"),"kerberos");
    p.setProperty(String.format(AUTH_HANDLER_PROPERTY,"basic"),"ldap");
    p.setProperty(PRINCIPAL,KerberosTestUtils.getServerPrincipal());
    p.setProperty(KEYTAB,KerberosTestUtils.getKeytabFile());
    p.setProperty(NAME_RULES,"RULE:[1:$1@$0](.*@" + KerberosTestUtils.getRealm() + ")s/@.*//\n");
    p.setProperty(BASE_DN,LDAP_BASE_DN);
    p.setProperty(PROVIDER_URL,String.format("ldap://%s:%s",LDAP_SERVER_ADDR,getLdapServer().getPort()));
    return p;
  }
  @Test(timeout=60000) public void testRequestWithoutAuthorization() throws Exception {
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    Assert.assertNull(handler.authenticate(request,response));
    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER,BASIC);
    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER,NEGOTIATE);
    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  }
  @Test(timeout=60000) public void testRequestWithInvalidAuthorization() throws Exception {
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    final Base64 base64=new Base64(0);
    String credentials="bjones:invalidpassword";
    Mockito.when(request.getHeader(AUTHORIZATION_HEADER)).thenReturn(base64.encodeToString(credentials.getBytes()));
    Assert.assertNull(handler.authenticate(request,response));
    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER,BASIC);
    Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER,NEGOTIATE);
    Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
  }
  @Test(timeout=60000) public void testRequestWithLdapAuthorization() throws Exception {
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    final Base64 base64=new Base64(0);
    String credentials=base64.encodeToString("bjones:p@ssw0rd".getBytes());
    String authHeader=BASIC + " " + credentials;
    Mockito.when(request.getHeader(AUTHORIZATION_HEADER)).thenReturn(authHeader);
    AuthenticationToken token=handler.authenticate(request,response);
    Assert.assertNotNull(token);
    Mockito.verify(response).setStatus(HttpServletResponse.SC_OK);
    Assert.assertEquals(TYPE,token.getType());
    Assert.assertEquals("bjones",token.getUserName());
    Assert.assertEquals("bjones",token.getName());
  }
  @Test(timeout=60000) public void testRequestWithInvalidKerberosAuthorization() throws Exception {
    String token=new Base64(0).encodeToString(new byte[]{0,1,2});
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    Mockito.when(request.getHeader(AUTHORIZATION_HEADER)).thenReturn(NEGOTIATE + token);
    try {
      handler.authenticate(request,response);
      Assert.fail();
    }
 catch (    AuthenticationException ex) {
    }
catch (    Exception ex) {
      Assert.fail("Wrong exception :" + ex);
    }
  }
}
