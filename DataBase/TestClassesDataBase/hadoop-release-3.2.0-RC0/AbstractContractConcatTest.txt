/** 
 * Test concat -if supported
 */
public abstract class AbstractContractConcatTest extends AbstractFSContractTestBase {
  private static final Logger LOG=LoggerFactory.getLogger(AbstractContractConcatTest.class);
  private Path testPath;
  private Path srcFile;
  private Path zeroByteFile;
  private Path target;
  @Override public void setup() throws Exception {
    super.setup();
    skipIfUnsupported(SUPPORTS_CONCAT);
    testPath=path("test");
    srcFile=new Path(testPath,"small.txt");
    zeroByteFile=new Path(testPath,"zero.txt");
    target=new Path(testPath,"target");
    byte[] block=dataset(TEST_FILE_LEN,0,255);
    createFile(getFileSystem(),srcFile,true,block);
    touch(getFileSystem(),zeroByteFile);
  }
  @Test public void testConcatEmptyFiles() throws Throwable {
    touch(getFileSystem(),target);
    handleExpectedException(intercept(Exception.class,() -> getFileSystem().concat(target,new Path[0])));
  }
  @Test public void testConcatMissingTarget() throws Throwable {
    handleExpectedException(intercept(Exception.class,() -> getFileSystem().concat(target,new Path[]{zeroByteFile})));
  }
  @Test public void testConcatFileOnFile() throws Throwable {
    byte[] block=dataset(TEST_FILE_LEN,0,255);
    createFile(getFileSystem(),target,false,block);
    getFileSystem().concat(target,new Path[]{srcFile});
    assertFileHasLength(getFileSystem(),target,TEST_FILE_LEN * 2);
    ContractTestUtils.validateFileContent(ContractTestUtils.readDataset(getFileSystem(),target,TEST_FILE_LEN * 2),new byte[][]{block,block});
  }
  @Test public void testConcatOnSelf() throws Throwable {
    byte[] block=dataset(TEST_FILE_LEN,0,255);
    createFile(getFileSystem(),target,false,block);
    handleExpectedException(intercept(Exception.class,() -> getFileSystem().concat(target,new Path[]{target})));
  }
}
