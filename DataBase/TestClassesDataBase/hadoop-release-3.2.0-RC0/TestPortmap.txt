public class TestPortmap {
  private static Portmap pm=new Portmap();
  private static final int SHORT_TIMEOUT_MILLISECONDS=10;
  private static final int RETRY_TIMES=5;
  private int xid;
  @BeforeClass public static void setup(){
    pm.start(SHORT_TIMEOUT_MILLISECONDS,new InetSocketAddress("localhost",0),new InetSocketAddress("localhost",0));
  }
  @AfterClass public static void tearDown(){
    pm.shutdown();
  }
  @Test(timeout=10000) public void testIdle() throws InterruptedException, IOException {
    Socket s=new Socket();
    try {
      s.connect(pm.getTcpServerLocalAddress());
      int i=0;
      while (!s.isConnected() && i < RETRY_TIMES) {
        ++i;
        Thread.sleep(SHORT_TIMEOUT_MILLISECONDS);
      }
      Assert.assertTrue("Failed to connect to the server",s.isConnected() && i < RETRY_TIMES);
      int b=s.getInputStream().read();
      Assert.assertTrue("The server failed to disconnect",b == -1);
    }
  finally {
      s.close();
    }
  }
  @Test(timeout=10000) public void testRegistration() throws IOException, InterruptedException {
    XDR req=new XDR();
    RpcCall.getInstance(++xid,RpcProgramPortmap.PROGRAM,RpcProgramPortmap.VERSION,RpcProgramPortmap.PMAPPROC_SET,new CredentialsNone(),new VerifierNone()).write(req);
    PortmapMapping sent=new PortmapMapping(90000,1,PortmapMapping.TRANSPORT_TCP,1234);
    sent.serialize(req);
    byte[] reqBuf=req.getBytes();
    DatagramSocket s=new DatagramSocket();
    DatagramPacket p=new DatagramPacket(reqBuf,reqBuf.length,pm.getUdpServerLoAddress());
    try {
      s.send(p);
    }
  finally {
      s.close();
    }
    Thread.sleep(100);
    boolean found=false;
    @SuppressWarnings("unchecked") Map<String,PortmapMapping> map=(Map<String,PortmapMapping>)Whitebox.getInternalState(pm.getHandler(),"map");
    for (    PortmapMapping m : map.values()) {
      if (m.getPort() == sent.getPort() && PortmapMapping.key(m).equals(PortmapMapping.key(sent))) {
        found=true;
        break;
      }
    }
    Assert.assertTrue("Registration failed",found);
  }
}
