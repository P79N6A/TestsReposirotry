/** 
 * This class tests the  {@code AlignedPlannerWithGreedy} agent.
 */
@RunWith(value=Parameterized.class) @NotThreadSafe @SuppressWarnings("VisibilityModifier") public class TestAlignedPlanner {
  @Parameterized.Parameter(value=0) public String recurrenceExpression;
  final static String NONPERIODIC="0";
  final static String THREEHOURPERIOD="10800000";
  final static String ONEDAYPERIOD="86400000";
  private static final Logger LOG=LoggerFactory.getLogger(TestAlignedPlanner.class);
  private ReservationAgent agentRight;
  private ReservationAgent agentLeft;
  private InMemoryPlan plan;
  private final Resource minAlloc=Resource.newInstance(1024,1);
  private final ResourceCalculator res=new DefaultResourceCalculator();
  private final Resource maxAlloc=Resource.newInstance(1024 * 8,8);
  private final Random rand=new Random();
  private Resource clusterCapacity;
  private long step;
  @Parameterized.Parameters(name="Testing: periodicity {0})") public static Collection<Object[]> data(){
    return Arrays.asList(new Object[][]{{NONPERIODIC},{THREEHOURPERIOD},{ONEDAYPERIOD}});
  }
  @Test public void testSingleReservationAccept() throws PlanningException {
    int numJobsInScenario=initializeScenario1();
    ReservationDefinition rr1=createReservationDefinition(5 * step,20 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(2048,2),10,5,10 * step)},ReservationRequestInterpreter.R_ORDER,"u1");
    ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
    agentRight.createReservation(reservationID,"u1",plan,rr1);
    assertTrue("Agent-based allocation failed",reservationID != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == numJobsInScenario + 1);
    ReservationAllocation alloc1=plan.getReservationById(reservationID);
    assertTrue(alloc1.toString(),check(alloc1,10 * step,20 * step,10,2048,2));
    System.out.println("--------AFTER AGENT----------");
    System.out.println(plan.toString());
  }
  @Test public void testOrderNoGapImpossible() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(10 * step,15 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step)},ReservationRequestInterpreter.R_ORDER_NO_GAP,"u1");
    try {
      ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID,"u1",plan,rr1);
      fail();
    }
 catch (    PlanningException e) {
    }
    assertTrue("Agent-based allocation should have failed",plan.getAllReservations().size() == numJobsInScenario);
  }
  @Test public void testOrderNoGapImpossible2() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(10 * step,13 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step),ReservationRequest.newInstance(Resource.newInstance(1024,1),10,10,step)},ReservationRequestInterpreter.R_ORDER_NO_GAP,"u1");
    try {
      ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID,"u1",plan,rr1);
      fail();
    }
 catch (    PlanningException e) {
    }
    assertTrue("Agent-based allocation should have failed",plan.getAllReservations().size() == numJobsInScenario);
  }
  @Test public void testOrderImpossible() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(10 * step,15 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,2 * step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step)},ReservationRequestInterpreter.R_ORDER,"u1");
    try {
      ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID,"u1",plan,rr1);
      fail();
    }
 catch (    PlanningException e) {
    }
    assertTrue("Agent-based allocation should have failed",plan.getAllReservations().size() == numJobsInScenario);
  }
  @Test public void testAnyImpossible() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(10 * step,15 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,3 * step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,2 * step)},ReservationRequestInterpreter.R_ANY,"u1");
    try {
      ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID,"u1",plan,rr1);
      fail();
    }
 catch (    PlanningException e) {
    }
    assertTrue("Agent-based allocation should have failed",plan.getAllReservations().size() == numJobsInScenario);
  }
  @Test public void testAnyAccept() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(10 * step,15 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,2 * step)},ReservationRequestInterpreter.R_ANY,"u1");
    ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
    agentRight.createReservation(reservationID,"u1",plan,rr1);
    assertTrue("Agent-based allocation failed",reservationID != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == numJobsInScenario + 1);
    ReservationAllocation alloc1=plan.getReservationById(reservationID);
    assertTrue(alloc1.toString(),check(alloc1,14 * step,15 * step,20,1024,1));
  }
  @Test public void testAllAccept() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(10 * step,15 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step)},ReservationRequestInterpreter.R_ALL,"u1");
    ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
    agentRight.createReservation(reservationID,"u1",plan,rr1);
    assertTrue("Agent-based allocation failed",reservationID != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == numJobsInScenario + 1);
    ReservationAllocation alloc1=plan.getReservationById(reservationID);
    assertTrue(alloc1.toString(),check(alloc1,10 * step,11 * step,20,1024,1));
    assertTrue(alloc1.toString(),check(alloc1,14 * step,15 * step,20,1024,1));
  }
  @Test public void testAllImpossible() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(10 * step,15 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,2 * step)},ReservationRequestInterpreter.R_ALL,"u1");
    try {
      ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID,"u1",plan,rr1);
      fail();
    }
 catch (    PlanningException e) {
    }
    assertTrue("Agent-based allocation should have failed",plan.getAllReservations().size() == numJobsInScenario);
  }
  @Test public void testUpdate() throws PlanningException {
    ReservationDefinition rrFlex=createReservationDefinition(10 * step,14 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),100,1,2 * step)},ReservationRequestInterpreter.R_ALL,"u1");
    ReservationDefinition rrBlock=createReservationDefinition(10 * step,11 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),100,100,step)},ReservationRequestInterpreter.R_ALL,"u1");
    ReservationId flexReservationID=ReservationSystemTestUtil.getNewReservationId();
    ReservationId blockReservationID=ReservationSystemTestUtil.getNewReservationId();
    agentRight.createReservation(blockReservationID,"uBlock",plan,rrBlock);
    agentRight.createReservation(flexReservationID,"uFlex",plan,rrFlex);
    agentRight.deleteReservation(blockReservationID,"uBlock",plan);
    agentRight.updateReservation(flexReservationID,"uFlex",plan,rrFlex);
    assertTrue("Agent-based allocation failed",flexReservationID != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == 1);
    ReservationAllocation alloc1=plan.getReservationById(flexReservationID);
    assertTrue(alloc1.toString(),check(alloc1,10 * step,14 * step,50,1024,1));
  }
  @Test public void testImpossibleDuration() throws PlanningException {
    ReservationDefinition rr1=createReservationDefinition(10 * step,15 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,10 * step)},ReservationRequestInterpreter.R_ALL,"u1");
    try {
      ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID,"u1",plan,rr1);
      fail();
    }
 catch (    PlanningException e) {
    }
    assertTrue("Agent-based allocation should have failed",plan.getAllReservations().size() == 0);
  }
  @Test public void testLoadedDurationIntervals() throws PlanningException {
    int numJobsInScenario=initializeScenario3();
    ReservationDefinition rr1=createReservationDefinition(10 * step,13 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),80,10,step)},ReservationRequestInterpreter.R_ALL,"u1");
    ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
    agentRight.createReservation(reservationID,"u1",plan,rr1);
    assertTrue("Agent-based allocation failed",reservationID != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == numJobsInScenario + 1);
    ReservationAllocation alloc1=plan.getReservationById(reservationID);
    assertTrue(alloc1.toString(),check(alloc1,10 * step,11 * step,20,1024,1));
    assertTrue(alloc1.toString(),check(alloc1,11 * step,12 * step,20,1024,1));
    assertTrue(alloc1.toString(),check(alloc1,12 * step,13 * step,40,1024,1));
  }
  @Test public void testCostFunction() throws PlanningException {
    ReservationDefinition rr7Mem1Core=createReservationDefinition(10 * step,11 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(7 * 1024,1),1,1,step)},ReservationRequestInterpreter.R_ALL,"u1");
    ReservationDefinition rr6Mem6Cores=createReservationDefinition(10 * step,11 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(6 * 1024,6),1,1,step)},ReservationRequestInterpreter.R_ALL,"u2");
    ReservationDefinition rr=createReservationDefinition(10 * step,12 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),1,1,step)},ReservationRequestInterpreter.R_ALL,"u3");
    ReservationId reservationID1=ReservationSystemTestUtil.getNewReservationId();
    ReservationId reservationID2=ReservationSystemTestUtil.getNewReservationId();
    ReservationId reservationID3=ReservationSystemTestUtil.getNewReservationId();
    agentRight.createReservation(reservationID1,"u1",plan,rr7Mem1Core);
    agentRight.createReservation(reservationID2,"u2",plan,rr6Mem6Cores);
    agentRight.createReservation(reservationID3,"u3",plan,rr);
    ReservationAllocation alloc3=plan.getReservationById(reservationID3);
    assertTrue(alloc3.toString(),check(alloc3,10 * step,11 * step,0,1024,1));
    assertTrue(alloc3.toString(),check(alloc3,11 * step,12 * step,1,1024,1));
  }
  @Test public void testFromCluster() throws PlanningException {
    List<ReservationDefinition> list=new ArrayList<ReservationDefinition>();
    list.add(createReservationDefinition(1425716392178L,1425722262791L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),7,1,587000)},ReservationRequestInterpreter.R_ALL,"u1"));
    list.add(createReservationDefinition(1425716406178L,1425721255841L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),6,1,485000)},ReservationRequestInterpreter.R_ALL,"u2"));
    list.add(createReservationDefinition(1425716399178L,1425723780138L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),6,1,738000)},ReservationRequestInterpreter.R_ALL,"u3"));
    list.add(createReservationDefinition(1425716437178L,1425722968378L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),7,1,653000)},ReservationRequestInterpreter.R_ALL,"u4"));
    list.add(createReservationDefinition(1425716406178L,1425721926090L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),6,1,552000)},ReservationRequestInterpreter.R_ALL,"u5"));
    list.add(createReservationDefinition(1425716379178L,1425722238553L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),6,1,586000)},ReservationRequestInterpreter.R_ALL,"u6"));
    list.add(createReservationDefinition(1425716407178L,1425722908317L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),7,1,650000)},ReservationRequestInterpreter.R_ALL,"u7"));
    list.add(createReservationDefinition(1425716452178L,1425722841562L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),6,1,639000)},ReservationRequestInterpreter.R_ALL,"u8"));
    list.add(createReservationDefinition(1425716384178L,1425721766129L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),7,1,538000)},ReservationRequestInterpreter.R_ALL,"u9"));
    list.add(createReservationDefinition(1425716437178L,1425722507886L,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),5,1,607000)},ReservationRequestInterpreter.R_ALL,"u10"));
    int i=1;
    for (    ReservationDefinition rr : list) {
      ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID,"u" + Integer.toString(i),plan,rr);
      ++i;
    }
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == list.size());
  }
  @Test public void testSingleReservationAcceptAllocateLeft() throws PlanningException {
    ReservationDefinition rr1=createReservationDefinition(10 * step,35 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,10 * step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,10 * step)},ReservationRequestInterpreter.R_ORDER,"u1");
    ReservationId reservationID=ReservationSystemTestUtil.getNewReservationId();
    agentLeft.createReservation(reservationID,"u1",plan,rr1);
    assertTrue("Agent-based allocation failed",reservationID != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == 1);
    ReservationAllocation alloc1=plan.getReservationById(reservationID);
    assertTrue(alloc1.toString(),check(alloc1,10 * step,30 * step,20,1024,1));
  }
  @Test public void testLeftSucceedsRightFails() throws PlanningException {
    int numJobsInScenario=initializeScenario2();
    ReservationDefinition rr1=createReservationDefinition(7 * step,16 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,2 * step),ReservationRequest.newInstance(Resource.newInstance(1024,1),20,20,2 * step)},ReservationRequestInterpreter.R_ORDER,"u1");
    ReservationDefinition rr2=createReservationDefinition(14 * step,16 * step,new ReservationRequest[]{ReservationRequest.newInstance(Resource.newInstance(1024,1),100,100,2 * step)},ReservationRequestInterpreter.R_ORDER,"u2");
    ReservationId reservationID1=ReservationSystemTestUtil.getNewReservationId();
    agentLeft.createReservation(reservationID1,"u1",plan,rr1);
    assertTrue("Agent-based allocation failed",reservationID1 != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == numJobsInScenario + 1);
    ReservationAllocation alloc1=plan.getReservationById(reservationID1);
    assertTrue(alloc1.toString(),check(alloc1,7 * step,11 * step,20,1024,1));
    ReservationId reservationID2=ReservationSystemTestUtil.getNewReservationId();
    agentLeft.createReservation(reservationID2,"u2",plan,rr2);
    assertTrue("Agent-based allocation failed",reservationID2 != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == numJobsInScenario + 2);
    ReservationAllocation alloc2=plan.getReservationById(reservationID2);
    assertTrue(alloc2.toString(),check(alloc2,14 * step,16 * step,100,1024,1));
    agentLeft.deleteReservation(reservationID1,"u1",plan);
    agentLeft.deleteReservation(reservationID2,"u2",plan);
    ReservationId reservationID3=ReservationSystemTestUtil.getNewReservationId();
    agentRight.createReservation(reservationID3,"u1",plan,rr1);
    assertTrue("Agent-based allocation failed",reservationID3 != null);
    assertTrue("Agent-based allocation failed",plan.getAllReservations().size() == numJobsInScenario + 1);
    try {
      ReservationId reservationID4=ReservationSystemTestUtil.getNewReservationId();
      agentRight.createReservation(reservationID4,"u2",plan,rr2);
      fail();
    }
 catch (    PlanningException e) {
    }
  }
  @Test public void testValidateOrderNoGap(){
    RLESparseResourceAllocation allocation=new RLESparseResourceAllocation(res);
    allocation.addInterval(new ReservationInterval(10 * step,13 * step),Resource.newInstance(1024,1));
    Map<ReservationInterval,Resource> curAlloc=new HashMap<ReservationInterval,Resource>();
    curAlloc.clear();
    curAlloc.put(new ReservationInterval(9 * step,10 * step),Resource.newInstance(1024,1));
    assertTrue("validateOrderNoFap() should have succeeded",IterativePlanner.validateOrderNoGap(allocation,curAlloc,false));
    curAlloc.put(new ReservationInterval(7 * step,8 * step),Resource.newInstance(1024,1));
    assertFalse("validateOrderNoGap() failed to identify a gap in curAlloc",IterativePlanner.validateOrderNoGap(allocation,curAlloc,false));
    curAlloc.clear();
    curAlloc.put(new ReservationInterval(8 * step,9 * step),Resource.newInstance(1024,1));
    assertFalse("validateOrderNoGap() failed to identify a gap between " + "allocations and curAlloc",IterativePlanner.validateOrderNoGap(allocation,curAlloc,false));
    curAlloc.clear();
    curAlloc.put(new ReservationInterval(13 * step,14 * step),Resource.newInstance(1024,1));
    assertTrue("validateOrderNoFap() should have succeeded",IterativePlanner.validateOrderNoGap(allocation,curAlloc,true));
    curAlloc.put(new ReservationInterval(15 * step,16 * step),Resource.newInstance(1024,1));
    assertFalse("validateOrderNoGap() failed to identify a gap in curAlloc",IterativePlanner.validateOrderNoGap(allocation,curAlloc,true));
    curAlloc.clear();
    curAlloc.put(new ReservationInterval(14 * step,15 * step),Resource.newInstance(1024,1));
    assertFalse("validateOrderNoGap() failed to identify a gap between " + "allocations and curAlloc",IterativePlanner.validateOrderNoGap(allocation,curAlloc,true));
  }
  @Test public void testGetDurationInterval() throws PlanningException {
    DurationInterval durationInterval=null;
    RLESparseResourceAllocation netRLERes=new RLESparseResourceAllocation(res);
    netRLERes.addInterval(new ReservationInterval(10 * step,40 * step),Resource.newInstance(4096,4));
    netRLERes.addInterval(new ReservationInterval(20 * step,30 * step),Resource.newInstance(4096,4));
    RLESparseResourceAllocation planLoads=new RLESparseResourceAllocation(res);
    planLoads.addInterval(new ReservationInterval(20 * step,30 * step),Resource.newInstance(5120,5));
    RLESparseResourceAllocation planModifications=new RLESparseResourceAllocation(res);
    planModifications.addInterval(new ReservationInterval(25 * step,35 * step),Resource.newInstance(1024,1));
    Resource requestedResources=Resource.newInstance(1024,1);
    durationInterval=StageAllocatorLowCostAligned.getDurationInterval(10 * step,30 * step,planLoads,planModifications,clusterCapacity,netRLERes,res,step,requestedResources);
    assertEquals(durationInterval.numCanFit(),4);
    assertEquals(durationInterval.getTotalCost(),0.55,0.00001);
    durationInterval=StageAllocatorLowCostAligned.getDurationInterval(10 * step,31 * step,planLoads,planModifications,clusterCapacity,netRLERes,res,step,requestedResources);
    System.out.println(durationInterval);
    assertEquals(durationInterval.numCanFit(),3);
    assertEquals(durationInterval.getTotalCost(),0.56,0.00001);
    durationInterval=StageAllocatorLowCostAligned.getDurationInterval(15 * step,30 * step,planLoads,planModifications,clusterCapacity,netRLERes,res,step,requestedResources);
    assertEquals(durationInterval.numCanFit(),4);
    assertEquals(durationInterval.getTotalCost(),0.55,0.00001);
    durationInterval=StageAllocatorLowCostAligned.getDurationInterval(15 * step,31 * step,planLoads,planModifications,clusterCapacity,netRLERes,res,step,requestedResources);
    System.out.println(durationInterval);
    assertEquals(durationInterval.numCanFit(),3);
    assertEquals(durationInterval.getTotalCost(),0.56,0.00001);
    durationInterval=StageAllocatorLowCostAligned.getDurationInterval(22 * step,23 * step,planLoads,planModifications,clusterCapacity,netRLERes,res,step,requestedResources);
    System.out.println(durationInterval);
    assertEquals(durationInterval.numCanFit(),8);
    assertEquals(durationInterval.getTotalCost(),0.05,0.00001);
    durationInterval=StageAllocatorLowCostAligned.getDurationInterval(39 * step,41 * step,planLoads,planModifications,clusterCapacity,netRLERes,res,step,requestedResources);
    System.out.println(durationInterval);
    assertEquals(durationInterval.numCanFit(),0);
    assertEquals(durationInterval.getTotalCost(),0,0.00001);
  }
  @Before public void setup() throws Exception {
    long seed=rand.nextLong();
    rand.setSeed(seed);
    LOG.info("Running with seed: " + seed);
    long timeWindow=1000000L;
    int capacityMem=100 * 1024;
    int capacityCores=100;
    step=60000L;
    clusterCapacity=Resource.newInstance(capacityMem,capacityCores);
    String reservationQ=ReservationSystemTestUtil.getFullReservationQueueName();
    float instConstraint=100;
    float avgConstraint=100;
    ReservationSchedulerConfiguration conf=ReservationSystemTestUtil.createConf(reservationQ,timeWindow,instConstraint,avgConstraint);
    CapacityOverTimePolicy policy=new CapacityOverTimePolicy();
    policy.init(reservationQ,conf);
    QueueMetrics queueMetrics=mock(QueueMetrics.class);
    RMContext context=ReservationSystemTestUtil.createMockRMContext();
    conf.setInt(AlignedPlannerWithGreedy.SMOOTHNESS_FACTOR,AlignedPlannerWithGreedy.DEFAULT_SMOOTHNESS_FACTOR);
    conf.setBoolean(ReservationAgent.FAVOR_EARLY_ALLOCATION,false);
    agentRight=new AlignedPlannerWithGreedy();
    agentRight.init(conf);
    conf.setBoolean(ReservationAgent.FAVOR_EARLY_ALLOCATION,true);
    agentLeft=new AlignedPlannerWithGreedy();
    agentLeft.init(conf);
    plan=new InMemoryPlan(queueMetrics,policy,agentRight,clusterCapacity,step,res,minAlloc,maxAlloc,"dedicated",null,true,context);
  }
  private int initializeScenario1() throws PlanningException {
    addFixedAllocation(0L,step,new int[]{10,10,20,20,20,10,10});
    System.out.println("--------BEFORE AGENT----------");
    System.out.println(plan.toString());
    System.out.println(plan.toCumulativeString());
    return 1;
  }
  private int initializeScenario2() throws PlanningException {
    addFixedAllocation(11 * step,step,new int[]{90,90,90});
    System.out.println("--------BEFORE AGENT----------");
    System.out.println(plan.toString());
    System.out.println(plan.toCumulativeString());
    return 1;
  }
  private int initializeScenario3() throws PlanningException {
    addFixedAllocation(10 * step,step,new int[]{70,80,60});
    System.out.println("--------BEFORE AGENT----------");
    System.out.println(plan.toString());
    System.out.println(plan.toCumulativeString());
    return 1;
  }
  private void addFixedAllocation(  long start,  long step,  int[] f) throws PlanningException {
    ReservationDefinition rDef=ReservationSystemTestUtil.createSimpleReservationDefinition(start,start + f.length * step,f.length * step);
    assertTrue(plan.toString(),plan.addReservation(new InMemoryReservationAllocation(ReservationSystemTestUtil.getNewReservationId(),rDef,"user_fixed","dedicated",start,start + f.length * step,ReservationSystemTestUtil.generateAllocation(start,step,f),res,minAlloc),false));
  }
  private ReservationDefinition createReservationDefinition(  long arrival,  long deadline,  ReservationRequest[] reservationRequests,  ReservationRequestInterpreter rType,  String username){
    return ReservationDefinition.newInstance(arrival,deadline,ReservationRequests.newInstance(Arrays.asList(reservationRequests),rType),username,recurrenceExpression,Priority.UNDEFINED);
  }
  private boolean check(  ReservationAllocation alloc,  long start,  long end,  int containers,  int mem,  int cores){
    Resource expectedResources=Resource.newInstance(mem * containers,cores * containers);
    for (long i=start; i < end; i++) {
      if (!Resources.equals(alloc.getResourcesAtTime(i),expectedResources)) {
        return false;
      }
    }
    return true;
  }
}
