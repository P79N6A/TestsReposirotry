public class TestPathData {
  private static final String TEST_ROOT_DIR=GenericTestUtils.getTestDir("testPD").getAbsolutePath();
  protected Configuration conf;
  protected FileSystem fs;
  protected Path testDir;
  @Before public void initialize() throws Exception {
    conf=new Configuration();
    fs=FileSystem.getLocal(conf);
    testDir=new Path(TEST_ROOT_DIR);
    testDir=new Path(fs.makeQualified(testDir).toUri().getPath());
    fs.mkdirs(testDir);
    FileSystem.setDefaultUri(conf,fs.getUri());
    fs.setWorkingDirectory(testDir);
    fs.mkdirs(new Path("d1"));
    fs.createNewFile(new Path("d1","f1"));
    fs.createNewFile(new Path("d1","f1.1"));
    fs.createNewFile(new Path("d1","f2"));
    fs.mkdirs(new Path("d2"));
    fs.create(new Path("d2","f3"));
  }
  @After public void cleanup() throws Exception {
    fs.delete(testDir,true);
    fs.close();
  }
  @Test(timeout=30000) public void testWithDirStringAndConf() throws Exception {
    String dirString="d1";
    PathData item=new PathData(dirString,conf);
    checkPathData(dirString,item);
    dirString="d1/";
    item=new PathData(dirString,conf);
    checkPathData(dirString,item);
  }
  @Test(timeout=30000) public void testUnqualifiedUriContents() throws Exception {
    String dirString="d1";
    PathData item=new PathData(dirString,conf);
    PathData[] items=item.getDirectoryContents();
    assertEquals(sortedString("d1/f1","d1/f1.1","d1/f2"),sortedString(items));
  }
  @Test(timeout=30000) public void testQualifiedUriContents() throws Exception {
    String dirString=fs.makeQualified(new Path("d1")).toString();
    PathData item=new PathData(dirString,conf);
    PathData[] items=item.getDirectoryContents();
    assertEquals(sortedString(dirString + "/f1",dirString + "/f1.1",dirString + "/f2"),sortedString(items));
  }
  @Test(timeout=30000) public void testCwdContents() throws Exception {
    String dirString=Path.CUR_DIR;
    PathData item=new PathData(dirString,conf);
    PathData[] items=item.getDirectoryContents();
    assertEquals(sortedString("d1","d2"),sortedString(items));
  }
  @Test(timeout=30000) public void testToFile() throws Exception {
    PathData item=new PathData(".",conf);
    assertEquals(new File(testDir.toString()),item.toFile());
    item=new PathData("d1/f1",conf);
    assertEquals(new File(testDir + "/d1/f1"),item.toFile());
    item=new PathData(testDir + "/d1/f1",conf);
    assertEquals(new File(testDir + "/d1/f1"),item.toFile());
  }
  @Test(timeout=5000) public void testToFileRawWindowsPaths() throws Exception {
    assumeWindows();
    String[] winPaths={"n:\\","N:\\","N:\\foo","N:\\foo\\bar","N:/","N:/foo","N:/foo/bar"};
    PathData item;
    for (    String path : winPaths) {
      item=new PathData(path,conf);
      assertEquals(new File(path),item.toFile());
    }
    item=new PathData("foo\\bar",conf);
    assertEquals(new File(testDir + "\\foo\\bar"),item.toFile());
  }
  @Test(timeout=5000) public void testInvalidWindowsPath() throws Exception {
    assumeWindows();
    String[] winPaths={"N:\\foo/bar"};
    for (    String path : winPaths) {
      try {
        PathData item=new PathData(path,conf);
        fail("Did not throw for invalid path " + path);
      }
 catch (      IOException ioe) {
      }
    }
  }
  @Test(timeout=30000) public void testAbsoluteGlob() throws Exception {
    PathData[] items=PathData.expandAsGlob(testDir + "/d1/f1*",conf);
    assertEquals(sortedString(testDir + "/d1/f1",testDir + "/d1/f1.1"),sortedString(items));
    String absolutePathNoDriveLetter=testDir + "/d1/f1";
    if (Shell.WINDOWS) {
      absolutePathNoDriveLetter=absolutePathNoDriveLetter.substring(2);
    }
    items=PathData.expandAsGlob(absolutePathNoDriveLetter,conf);
    assertEquals(sortedString(absolutePathNoDriveLetter),sortedString(items));
    items=PathData.expandAsGlob(".",conf);
    assertEquals(sortedString("."),sortedString(items));
  }
  @Test(timeout=30000) public void testRelativeGlob() throws Exception {
    PathData[] items=PathData.expandAsGlob("d1/f1*",conf);
    assertEquals(sortedString("d1/f1","d1/f1.1"),sortedString(items));
  }
  @Test(timeout=30000) public void testRelativeGlobBack() throws Exception {
    fs.setWorkingDirectory(new Path("d1"));
    PathData[] items=PathData.expandAsGlob("../d2/*",conf);
    assertEquals(sortedString("../d2/f3"),sortedString(items));
  }
  @Test public void testGlobThrowsExceptionForUnreadableDir() throws Exception {
    Path obscuredDir=new Path("foo");
    Path subDir=new Path(obscuredDir,"bar");
    fs.mkdirs(subDir);
    fs.setPermission(obscuredDir,new FsPermission((short)0));
    try {
      PathData.expandAsGlob("foo/*",conf);
      Assert.fail("Should throw IOException");
    }
 catch (    IOException ioe) {
    }
 finally {
      fs.setPermission(obscuredDir,new FsPermission((short)0755));
    }
  }
  @Test(timeout=30000) public void testWithStringAndConfForBuggyPath() throws Exception {
    String dirString="file:///tmp";
    Path tmpDir=new Path(dirString);
    PathData item=new PathData(dirString,conf);
    assertEquals("file:/tmp",tmpDir.toString());
    checkPathData(dirString,item);
  }
  public void checkPathData(  String dirString,  PathData item) throws Exception {
    assertEquals("checking fs",fs,item.fs);
    assertEquals("checking string",dirString,item.toString());
    assertEquals("checking path",fs.makeQualified(new Path(item.toString())),item.path);
    assertTrue("checking exist",item.stat != null);
    assertTrue("checking isDir",item.stat.isDirectory());
  }
  private static String sortedString(  Object... list){
    String[] strings=new String[list.length];
    for (int i=0; i < list.length; i++) {
      strings[i]=String.valueOf(list[i]);
    }
    Arrays.sort(strings);
    StringBuilder result=new StringBuilder();
    for (int i=0; i < strings.length; i++) {
      if (result.length() > 0) {
        result.append(", ");
      }
      result.append(i + ":<" + strings[i]+ ">");
    }
    return result.toString();
  }
  private static String sortedString(  PathData... items){
    return sortedString((Object[])items);
  }
}
