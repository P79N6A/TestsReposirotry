public class TestRandomSignerSecretProvider {
  private final int timeout=100;
  private final long rolloverFrequency=timeout / 2;
{
    LogManager.getLogger(RolloverSignerSecretProvider.LOG.getName()).setLevel(Level.DEBUG);
  }
  @Test public void testGetAndRollSecrets() throws Exception {
    long seed=System.currentTimeMillis();
    Random rand=new Random(seed);
    byte[] secret1=generateNewSecret(rand);
    byte[] secret2=generateNewSecret(rand);
    byte[] secret3=generateNewSecret(rand);
    MockRandomSignerSecretProvider secretProvider=spy(new MockRandomSignerSecretProvider(seed));
    try {
      secretProvider.init(null,null,rolloverFrequency);
      byte[] currentSecret=secretProvider.getCurrentSecret();
      byte[][] allSecrets=secretProvider.getAllSecrets();
      Assert.assertArrayEquals(secret1,currentSecret);
      Assert.assertEquals(2,allSecrets.length);
      Assert.assertArrayEquals(secret1,allSecrets[0]);
      Assert.assertNull(allSecrets[1]);
      verify(secretProvider,timeout(timeout).atLeastOnce()).rollSecret();
      secretProvider.realRollSecret();
      currentSecret=secretProvider.getCurrentSecret();
      allSecrets=secretProvider.getAllSecrets();
      Assert.assertArrayEquals(secret2,currentSecret);
      Assert.assertEquals(2,allSecrets.length);
      Assert.assertArrayEquals(secret2,allSecrets[0]);
      Assert.assertArrayEquals(secret1,allSecrets[1]);
      verify(secretProvider,timeout(timeout).atLeast(2)).rollSecret();
      secretProvider.realRollSecret();
      currentSecret=secretProvider.getCurrentSecret();
      allSecrets=secretProvider.getAllSecrets();
      Assert.assertArrayEquals(secret3,currentSecret);
      Assert.assertEquals(2,allSecrets.length);
      Assert.assertArrayEquals(secret3,allSecrets[0]);
      Assert.assertArrayEquals(secret2,allSecrets[1]);
      verify(secretProvider,timeout(timeout).atLeast(3)).rollSecret();
      secretProvider.realRollSecret();
    }
  finally {
      secretProvider.destroy();
    }
  }
  /** 
 * A hack to test RandomSignerSecretProvider. We want to test that RandomSignerSecretProvider.rollSecret() is periodically called at the expected frequency, but we want to exclude the race-condition and not take a long time to run the test.
 */
private class MockRandomSignerSecretProvider extends RandomSignerSecretProvider {
    MockRandomSignerSecretProvider(    long seed){
      super(seed);
    }
    @Override protected synchronized void rollSecret(){
    }
    public void realRollSecret(){
      super.rollSecret();
    }
  }
  private byte[] generateNewSecret(  Random rand){
    byte[] secret=new byte[32];
    rand.nextBytes(secret);
    return secret;
  }
}
