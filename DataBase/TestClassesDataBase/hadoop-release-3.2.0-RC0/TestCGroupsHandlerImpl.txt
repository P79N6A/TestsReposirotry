/** 
 * Tests for the CGroups handler implementation.
 */
public class TestCGroupsHandlerImpl {
  private static final Logger LOG=LoggerFactory.getLogger(TestCGroupsHandlerImpl.class);
  private PrivilegedOperationExecutor privilegedOperationExecutorMock;
  private String tmpPath;
  private String hierarchy;
  private CGroupsHandler.CGroupController controller;
  private String controllerPath;
  @Before public void setup(){
    privilegedOperationExecutorMock=mock(PrivilegedOperationExecutor.class);
    tmpPath=System.getProperty("test.build.data") + "/cgroups";
    File tmpDir=new File(tmpPath);
    FileUtils.deleteQuietly(tmpDir);
    assertTrue(tmpDir.mkdirs());
    hierarchy="test-hadoop-yarn";
    controller=CGroupsHandler.CGroupController.NET_CLS;
    controllerPath=new File(new File(tmpPath,controller.getName()),hierarchy).getAbsolutePath();
  }
  @After public void teardown(){
    FileUtil.fullyDelete(new File(tmpPath));
  }
  /** 
 * Security manager simulating access denied.
 */
private class MockSecurityManagerDenyWrite extends SecurityManager {
    @Override public void checkPermission(    Permission perm){
      if (perm.getActions().equals("write")) {
        throw new SecurityException("Mock not allowed");
      }
    }
  }
  /** 
 * Create configuration to mount cgroups that do not exist.
 * @return configuration object
 */
  private YarnConfiguration createMountConfiguration(){
    YarnConfiguration conf=new YarnConfiguration();
    conf.set(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_HIERARCHY,hierarchy);
    conf.setBoolean(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_MOUNT,true);
    conf.set(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_MOUNT_PATH,tmpPath);
    return conf;
  }
  /** 
 * Create configuration where the cgroups are premounted.
 * @param myHierarchy YARN cgroup
 * @return configuration object
 */
  private Configuration createNoMountConfiguration(  String myHierarchy){
    Configuration confNoMount=new Configuration();
    confNoMount.set(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_HIERARCHY,myHierarchy);
    confNoMount.setBoolean(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_MOUNT,false);
    return confNoMount;
  }
  /** 
 * Create an empty mtab file. No cgroups are premounted
 * @return mtab file
 * @throws IOException could not create file
 */
  private File createEmptyCgroups() throws IOException {
    File emptyMtab=new File(tmpPath,"mtab");
    assertTrue("New file should have been created",emptyMtab.createNewFile());
    return emptyMtab;
  }
  /** 
 * Create simulated cgroups mount point.
 * @param parentDir cgroups mount point
 * @param cpuAcct simulate newer Linux behavior by mounting cpu with cpuacct
 * @return simulated mtab file location
 * @throws IOException mtab file was not created
 */
  public static File createPremountedCgroups(  File parentDir,  boolean cpuAcct) throws IOException {
    String cpuMtabContentMissing="none " + parentDir.getAbsolutePath() + "/cp cgroup rw,relatime,cpu 0 0\n";
    File cpuCgroup=new File(parentDir,"cpu");
    String cpuMtabContent="none " + cpuCgroup.getAbsolutePath() + " cgroup rw,relatime,cpu"+ (cpuAcct ? ",cpuacct" : "")+ " 0 0\n";
    assertTrue("Directory should be created",cpuCgroup.mkdirs());
    File blkioCgroup=new File(parentDir,"blkio");
    String blkioMtabContent="none " + blkioCgroup.getAbsolutePath() + " cgroup rw,relatime,blkio 0 0\n";
    assertTrue("Directory should be created",blkioCgroup.mkdirs());
    File mockMtab=new File(parentDir,UUID.randomUUID().toString());
    if (!mockMtab.exists()) {
      if (!mockMtab.createNewFile()) {
        String message="Could not create file " + mockMtab.getAbsolutePath();
        throw new IOException(message);
      }
    }
    FileWriter mtabWriter=new FileWriter(mockMtab.getAbsoluteFile());
    mtabWriter.write(cpuMtabContentMissing);
    mtabWriter.write(cpuMtabContent);
    mtabWriter.write(blkioMtabContent);
    mtabWriter.close();
    mockMtab.deleteOnExit();
    return mockMtab;
  }
  @Test public void testMountController() throws IOException {
    File parentDir=new File(tmpPath);
    File cgroup=new File(parentDir,controller.getName());
    assertTrue("cgroup dir should be cerated",cgroup.mkdirs());
    verifyZeroInteractions(privilegedOperationExecutorMock);
    File emptyMtab=createEmptyCgroups();
    try {
      CGroupsHandler cGroupsHandler=new CGroupsHandlerImpl(createMountConfiguration(),privilegedOperationExecutorMock,emptyMtab.getAbsolutePath());
      PrivilegedOperation expectedOp=new PrivilegedOperation(PrivilegedOperation.OperationType.MOUNT_CGROUPS);
      String controllerKV=controller.getName() + "=" + tmpPath+ Path.SEPARATOR+ controller.getName();
      expectedOp.appendArgs(hierarchy,controllerKV);
      cGroupsHandler.initializeCGroupController(controller);
      try {
        ArgumentCaptor<PrivilegedOperation> opCaptor=ArgumentCaptor.forClass(PrivilegedOperation.class);
        verify(privilegedOperationExecutorMock).executePrivilegedOperation(opCaptor.capture(),eq(false));
        Assert.assertEquals(expectedOp,opCaptor.getValue());
        verifyNoMoreInteractions(privilegedOperationExecutorMock);
        cGroupsHandler.initializeCGroupController(controller);
        verifyNoMoreInteractions(privilegedOperationExecutorMock);
      }
 catch (      PrivilegedOperationException e) {
        LOG.error("Caught exception: " + e);
        assertTrue("Unexpected PrivilegedOperationException from mock!",false);
      }
    }
 catch (    ResourceHandlerException e) {
      LOG.error("Caught exception: " + e);
      assertTrue("Unexpected ResourceHandler Exception!",false);
    }
  }
  @Test public void testCGroupPaths() throws IOException {
    verifyZeroInteractions(privilegedOperationExecutorMock);
    CGroupsHandler cGroupsHandler=null;
    File mtab=createEmptyCgroups();
    assertTrue("Sample subsystem should be created",new File(controllerPath).mkdirs());
    try {
      cGroupsHandler=new CGroupsHandlerImpl(createMountConfiguration(),privilegedOperationExecutorMock,mtab.getAbsolutePath());
      cGroupsHandler.initializeCGroupController(controller);
    }
 catch (    ResourceHandlerException e) {
      LOG.error("Caught exception: " + e);
      assertTrue("Unexpected ResourceHandlerException when mounting controller!",false);
    }
    String testCGroup="container_01";
    String expectedPath=controllerPath + Path.SEPARATOR + testCGroup;
    String path=cGroupsHandler.getPathForCGroup(controller,testCGroup);
    Assert.assertEquals(expectedPath,path);
    String expectedPathTasks=expectedPath + Path.SEPARATOR + CGroupsHandler.CGROUP_FILE_TASKS;
    path=cGroupsHandler.getPathForCGroupTasks(controller,testCGroup);
    Assert.assertEquals(expectedPathTasks,path);
    String param=CGroupsHandler.CGROUP_PARAM_CLASSID;
    String expectedPathParam=expectedPath + Path.SEPARATOR + controller.getName()+ "."+ param;
    path=cGroupsHandler.getPathForCGroupParam(controller,testCGroup,param);
    Assert.assertEquals(expectedPathParam,path);
  }
  @Test public void testCGroupOperations() throws IOException {
    verifyZeroInteractions(privilegedOperationExecutorMock);
    CGroupsHandler cGroupsHandler=null;
    File mtab=createEmptyCgroups();
    assertTrue("Sample subsystem should be created",new File(controllerPath).mkdirs());
    try {
      cGroupsHandler=new CGroupsHandlerImpl(createMountConfiguration(),privilegedOperationExecutorMock,mtab.getAbsolutePath());
      cGroupsHandler.initializeCGroupController(controller);
    }
 catch (    ResourceHandlerException e) {
      LOG.error("Caught exception: " + e);
      assertTrue("Unexpected ResourceHandlerException when mounting controller!",false);
    }
    String testCGroup="container_01";
    String expectedPath=controllerPath + Path.SEPARATOR + testCGroup;
    try {
      String path=cGroupsHandler.createCGroup(controller,testCGroup);
      assertTrue(new File(expectedPath).exists());
      Assert.assertEquals(expectedPath,path);
      String param="test_param";
      String paramValue="test_param_value";
      cGroupsHandler.updateCGroupParam(controller,testCGroup,param,paramValue);
      String paramPath=expectedPath + Path.SEPARATOR + controller.getName()+ "."+ param;
      File paramFile=new File(paramPath);
      assertTrue(paramFile.exists());
      try {
        Assert.assertEquals(paramValue,new String(Files.readAllBytes(paramFile.toPath())));
      }
 catch (      IOException e) {
        LOG.error("Caught exception: " + e);
        Assert.fail("Unexpected IOException trying to read cgroup param!");
      }
      Assert.assertEquals(paramValue,cGroupsHandler.getCGroupParam(controller,testCGroup,param));
    }
 catch (    ResourceHandlerException e) {
      LOG.error("Caught exception: " + e);
      Assert.fail("Unexpected ResourceHandlerException during cgroup operations!");
    }
  }
  /** 
 * Tests whether mtab parsing works as expected with a valid hierarchy set.
 * @throws Exception the test will fail
 */
  @Test public void testMtabParsing() throws Exception {
    File parentDir=new File(tmpPath);
    File mockMtabFile=createPremountedCgroups(parentDir,false);
    Map<String,Set<String>> newMtab=CGroupsHandlerImpl.parseMtab(mockMtabFile.getAbsolutePath());
    Map<CGroupsHandler.CGroupController,String> controllerPaths=CGroupsHandlerImpl.initializeControllerPathsFromMtab(newMtab);
    Assert.assertEquals(2,controllerPaths.size());
    assertTrue(controllerPaths.containsKey(CGroupsHandler.CGroupController.CPU));
    assertTrue(controllerPaths.containsKey(CGroupsHandler.CGroupController.BLKIO));
    String cpuDir=controllerPaths.get(CGroupsHandler.CGroupController.CPU);
    String blkioDir=controllerPaths.get(CGroupsHandler.CGroupController.BLKIO);
    Assert.assertEquals(parentDir.getAbsolutePath() + "/cpu",cpuDir);
    Assert.assertEquals(parentDir.getAbsolutePath() + "/blkio",blkioDir);
  }
  /** 
 * Tests whether mtab parsing works as expected with the specified hierarchy.
 * @param myHierarchy path to local cgroup hierarchy
 * @throws Exception the test will fail
 */
  private void testPreMountedControllerInitialization(  String myHierarchy) throws Exception {
    File parentDir=new File(tmpPath);
    File mtab=createPremountedCgroups(parentDir,false);
    File mountPoint=new File(parentDir,"cpu");
    Configuration confNoMount=createNoMountConfiguration(myHierarchy);
    CGroupsHandlerImpl cGroupsHandler=new CGroupsHandlerImpl(confNoMount,privilegedOperationExecutorMock,mtab.getAbsolutePath());
    File cpuCgroupMountDir=new File(cGroupsHandler.getPathForCGroup(CGroupsHandler.CGroupController.CPU,""));
    if (!cpuCgroupMountDir.equals(mountPoint)) {
      assertTrue("Directory should be deleted",!cpuCgroupMountDir.exists());
    }
    cGroupsHandler.initializeCGroupController(CGroupsHandler.CGroupController.CPU);
    assertTrue("Cgroups not writable",cpuCgroupMountDir.exists() && cpuCgroupMountDir.canWrite());
    assertTrue(cpuCgroupMountDir.setWritable(false));
    try {
      cGroupsHandler.initializeCGroupController(CGroupsHandler.CGroupController.CPU);
      Assert.fail("An inaccessible path should result in an exception");
    }
 catch (    Exception e) {
      assertTrue("Unexpected exception " + e.getClass().toString(),e instanceof ResourceHandlerException);
    }
 finally {
      assertTrue("Could not revert writable permission",cpuCgroupMountDir.setWritable(true));
    }
    if (!cpuCgroupMountDir.equals(mountPoint)) {
      assertTrue("Could not delete cgroups",cpuCgroupMountDir.delete());
      assertTrue("Directory should be deleted",!cpuCgroupMountDir.exists());
    }
    assertTrue(mountPoint.setWritable(false));
    try {
      cGroupsHandler.initializeCGroupController(CGroupsHandler.CGroupController.CPU);
      Assert.fail("An inaccessible path should result in an exception");
    }
 catch (    Exception e) {
      assertTrue("Unexpected exception " + e.getClass().toString(),e instanceof ResourceHandlerException);
    }
 finally {
      assertTrue("Could not revert writable permission",mountPoint.setWritable(true));
    }
    if (!cpuCgroupMountDir.equals(mountPoint)) {
      Assert.assertFalse("Could not delete cgroups",cpuCgroupMountDir.delete());
      assertTrue("Directory should be deleted",!cpuCgroupMountDir.exists());
      SecurityManager manager=System.getSecurityManager();
      System.setSecurityManager(new MockSecurityManagerDenyWrite());
      try {
        cGroupsHandler.initializeCGroupController(CGroupsHandler.CGroupController.CPU);
        Assert.fail("An inaccessible path should result in an exception");
      }
 catch (      Exception e) {
        assertTrue("Unexpected exception " + e.getClass().toString(),e instanceof ResourceHandlerException);
      }
 finally {
        System.setSecurityManager(manager);
      }
    }
    if (!cpuCgroupMountDir.equals(mountPoint)) {
      Assert.assertFalse("Could not delete cgroups",cpuCgroupMountDir.delete());
      assertTrue("Directory should be deleted",!cpuCgroupMountDir.exists());
    }
    FileUtils.deleteQuietly(mountPoint);
    assertTrue("cgroups mount point should be deleted",!mountPoint.exists());
    try {
      cGroupsHandler.initializeCGroupController(CGroupsHandler.CGroupController.CPU);
      Assert.fail("An inaccessible path should result in an exception");
    }
 catch (    Exception e) {
      assertTrue("Unexpected exception " + e.getClass().toString(),e instanceof ResourceHandlerException);
    }
  }
  @Test public void testSelectCgroup() throws Exception {
    File cpu=new File(tmpPath,"cpu");
    File cpuNoExist=new File(tmpPath,"cpuNoExist");
    File memory=new File(tmpPath,"memory");
    try {
      CGroupsHandlerImpl handler=new CGroupsHandlerImpl(createNoMountConfiguration(tmpPath),privilegedOperationExecutorMock);
      Map<String,Set<String>> cgroups=new LinkedHashMap<>();
      Assert.assertTrue("temp dir should be created",cpu.mkdirs());
      Assert.assertTrue("temp dir should be created",memory.mkdirs());
      Assert.assertFalse("temp dir should not be created",cpuNoExist.exists());
      cgroups.put(memory.getAbsolutePath(),Collections.singleton("memory"));
      cgroups.put(cpuNoExist.getAbsolutePath(),Collections.singleton("cpu"));
      cgroups.put(cpu.getAbsolutePath(),Collections.singleton("cpu"));
      String selectedCPU=handler.findControllerInMtab("cpu",cgroups);
      Assert.assertEquals("Wrong CPU mount point selected",cpu.getAbsolutePath(),selectedCPU);
    }
  finally {
      FileUtils.deleteQuietly(cpu);
      FileUtils.deleteQuietly(memory);
    }
  }
  /** 
 * Tests whether mtab parsing works as expected with an empty hierarchy set.
 * @throws Exception the test will fail
 */
  @Test public void testPreMountedControllerEmpty() throws Exception {
    testPreMountedControllerInitialization("");
  }
  /** 
 * Tests whether mtab parsing works as expected with a / hierarchy set.
 * @throws Exception the test will fail
 */
  @Test public void testPreMountedControllerRoot() throws Exception {
    testPreMountedControllerInitialization("/");
  }
  /** 
 * Tests whether mtab parsing works as expected with the specified hierarchy.
 * @throws Exception the test will fail
 */
  @Test public void testRemount() throws Exception {
    File parentDir=new File(tmpPath);
    final String oldMountPointDir="oldmount";
    final String newMountPointDir="newmount";
    File oldMountPoint=new File(parentDir,oldMountPointDir);
    File mtab=createPremountedCgroups(oldMountPoint,true);
    File newMountPoint=new File(parentDir,newMountPointDir);
    assertTrue("Could not create dirs",new File(newMountPoint,"cpu").mkdirs());
    Configuration confMount=createMountConfiguration();
    confMount.set(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_MOUNT_PATH,parentDir.getAbsolutePath() + Path.SEPARATOR + newMountPointDir);
    CGroupsHandlerImpl cGroupsHandler=new CGroupsHandlerImpl(confMount,privilegedOperationExecutorMock,mtab.getAbsolutePath());
    cGroupsHandler.initializeCGroupController(CGroupsHandler.CGroupController.CPU);
    ArgumentCaptor<PrivilegedOperation> opCaptor=ArgumentCaptor.forClass(PrivilegedOperation.class);
    verify(privilegedOperationExecutorMock).executePrivilegedOperation(opCaptor.capture(),eq(false));
    File hierarchyFile=new File(new File(newMountPoint,"cpu"),this.hierarchy);
    assertTrue("Yarn cgroup should exist",hierarchyFile.exists());
  }
  @Test public void testManualCgroupSetting() throws ResourceHandlerException {
    YarnConfiguration conf=new YarnConfiguration();
    conf.set(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_MOUNT_PATH,tmpPath);
    conf.set(YarnConfiguration.NM_LINUX_CONTAINER_CGROUPS_HIERARCHY,"/hadoop-yarn");
    File cpu=new File(new File(tmpPath,"cpuacct,cpu"),"/hadoop-yarn");
    try {
      Assert.assertTrue("temp dir should be created",cpu.mkdirs());
      CGroupsHandlerImpl cGroupsHandler=new CGroupsHandlerImpl(conf,null);
      cGroupsHandler.initializeCGroupController(CGroupsHandler.CGroupController.CPU);
      Assert.assertEquals("CPU CGRoup path was not set",cpu.getAbsolutePath(),new File(cGroupsHandler.getPathForCGroup(CGroupsHandler.CGroupController.CPU,"")).getAbsolutePath());
    }
  finally {
      FileUtils.deleteQuietly(cpu);
    }
  }
}
