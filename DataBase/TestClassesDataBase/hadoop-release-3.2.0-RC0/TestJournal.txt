public class TestJournal {
  private static final NamespaceInfo FAKE_NSINFO=new NamespaceInfo(12345,"mycluster","my-bp",0L);
  private static final NamespaceInfo FAKE_NSINFO_2=new NamespaceInfo(6789,"mycluster","my-bp",0L);
  private static final String JID="test-journal";
  private static final File TEST_LOG_DIR=new File(new File(MiniDFSCluster.getBaseDirectory()),"TestJournal");
  private final StorageErrorReporter mockErrorReporter=Mockito.mock(StorageErrorReporter.class);
  private Configuration conf;
  private Journal journal;
  @Before public void setup() throws Exception {
    FileUtil.fullyDelete(TEST_LOG_DIR);
    conf=new Configuration();
    journal=new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
    journal.format(FAKE_NSINFO,false);
  }
  @After public void verifyNoStorageErrors() throws Exception {
    Mockito.verify(mockErrorReporter,Mockito.never()).reportErrorOnFile(Mockito.<File>any());
  }
  @After public void cleanup(){
    IOUtils.closeStream(journal);
  }
  /** 
 * Test whether JNs can correctly handle editlog that cannot be decoded.
 */
  @Test public void testScanEditLog() throws Exception {
    journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION - 1);
    final int numTxns=5;
    byte[] ops=QJMTestUtil.createGabageTxns(1,5);
    journal.journal(makeRI(2),1,1,numTxns,ops);
    SegmentStateProto segmentState=journal.getSegmentInfo(1);
    assertTrue(segmentState.getIsInProgress());
    Assert.assertEquals(numTxns,segmentState.getEndTxId());
    Assert.assertEquals(1,segmentState.getStartTxId());
    journal.finalizeLogSegment(makeRI(3),1,numTxns);
    segmentState=journal.getSegmentInfo(1);
    assertFalse(segmentState.getIsInProgress());
    Assert.assertEquals(numTxns,segmentState.getEndTxId());
    Assert.assertEquals(1,segmentState.getStartTxId());
  }
  @Test(timeout=10000) public void testEpochHandling() throws Exception {
    assertEquals(0,journal.getLastPromisedEpoch());
    NewEpochResponseProto newEpoch=journal.newEpoch(FAKE_NSINFO,1);
    assertFalse(newEpoch.hasLastSegmentTxId());
    assertEquals(1,journal.getLastPromisedEpoch());
    journal.newEpoch(FAKE_NSINFO,3);
    assertFalse(newEpoch.hasLastSegmentTxId());
    assertEquals(3,journal.getLastPromisedEpoch());
    try {
      journal.newEpoch(FAKE_NSINFO,3);
      fail("Should have failed to promise same epoch twice");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Proposed epoch 3 <= last promise 3",ioe);
    }
    try {
      journal.startLogSegment(makeRI(1),12345L,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
      fail("Should have rejected call from prior epoch");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("epoch 1 is less than the last promised epoch 3",ioe);
    }
    try {
      journal.journal(makeRI(1),12345L,100L,0,new byte[0]);
      fail("Should have rejected call from prior epoch");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("epoch 1 is less than the last promised epoch 3",ioe);
    }
  }
  @Test(timeout=10000) public void testMaintainCommittedTxId() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(new RequestInfo(JID,null,1,2,0),1,1,3,QJMTestUtil.createTxnData(1,3));
    assertEquals(0,journal.getCommittedTxnId());
    journal.journal(new RequestInfo(JID,null,1,3,3),1,4,3,QJMTestUtil.createTxnData(4,6));
    assertEquals(3,journal.getCommittedTxnId());
  }
  @Test(timeout=10000) public void testRestartJournal() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(makeRI(2),1,1,2,QJMTestUtil.createTxnData(1,2));
    String storageString=journal.getStorage().toColonSeparatedString();
    System.err.println("storage string: " + storageString);
    journal.close();
    journal=new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
    assertEquals(storageString,journal.getStorage().toColonSeparatedString());
    assertEquals(1,journal.getLastPromisedEpoch());
    NewEpochResponseProtoOrBuilder newEpoch=journal.newEpoch(FAKE_NSINFO,2);
    assertEquals(1,newEpoch.getLastSegmentTxId());
  }
  @Test(timeout=10000) public void testFormatResetsCachedValues() throws Exception {
    journal.newEpoch(FAKE_NSINFO,12345L);
    journal.startLogSegment(new RequestInfo(JID,null,12345L,1L,0L),1L,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    assertEquals(12345L,journal.getLastPromisedEpoch());
    assertEquals(12345L,journal.getLastWriterEpoch());
    assertTrue(journal.isFormatted());
    journal.close();
    journal.getStorage().getJournalManager().getStorageDirectory().clearDirectory();
    journal.format(FAKE_NSINFO_2,false);
    assertEquals(0,journal.getLastPromisedEpoch());
    assertEquals(0,journal.getLastWriterEpoch());
    assertTrue(journal.isFormatted());
  }
  /** 
 * Test that, if the writer crashes at the very beginning of a segment, before any transactions are written, that the next newEpoch() call returns the prior segment txid as its most recent segment.
 */
  @Test(timeout=10000) public void testNewEpochAtBeginningOfSegment() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(makeRI(2),1,1,2,QJMTestUtil.createTxnData(1,2));
    journal.finalizeLogSegment(makeRI(3),1,2);
    journal.startLogSegment(makeRI(4),3,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    NewEpochResponseProto resp=journal.newEpoch(FAKE_NSINFO,2);
    assertEquals(1,resp.getLastSegmentTxId());
  }
  @Test(timeout=10000) public void testJournalLocking() throws Exception {
    Assume.assumeTrue(journal.getStorage().getStorageDir(0).isLockSupported());
    StorageDirectory sd=journal.getStorage().getStorageDir(0);
    File lockFile=new File(sd.getRoot(),Storage.STORAGE_FILE_LOCK);
    GenericTestUtils.assertExists(lockFile);
    journal.newEpoch(FAKE_NSINFO,1);
    try {
      new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
      fail("Did not fail to create another journal in same dir");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Cannot lock storage",ioe);
    }
    journal.close();
    Journal journal2=new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
    journal2.newEpoch(FAKE_NSINFO,2);
    journal2.close();
  }
  /** 
 * Test finalizing a segment after some batch of edits were missed. This should fail, since we validate the log before finalization.
 */
  @Test(timeout=10000) public void testFinalizeWhenEditsAreMissed() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(makeRI(2),1,1,3,QJMTestUtil.createTxnData(1,3));
    try {
      journal.finalizeLogSegment(makeRI(3),1,6);
      fail("did not fail to finalize");
    }
 catch (    JournalOutOfSyncException e) {
      GenericTestUtils.assertExceptionContains("but only written up to txid 3",e);
    }
    journal.close();
    journal=new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
    try {
      journal.finalizeLogSegment(makeRI(4),1,6);
      fail("did not fail to finalize");
    }
 catch (    JournalOutOfSyncException e) {
      GenericTestUtils.assertExceptionContains("disk only contains up to txid 3",e);
    }
  }
  /** 
 * Ensure that finalizing a segment which doesn't exist throws the appropriate exception.
 */
  @Test(timeout=10000) public void testFinalizeMissingSegment() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    try {
      journal.finalizeLogSegment(makeRI(1),1000,1001);
      fail("did not fail to finalize");
    }
 catch (    JournalOutOfSyncException e) {
      GenericTestUtils.assertExceptionContains("No log file to finalize at transaction ID 1000",e);
    }
  }
  /** 
 * Assume that a client is writing to a journal, but loses its connection in the middle of a segment. Thus, any future journal() calls in that segment may fail, because some txns were missed while the connection was down. Eventually, the connection comes back, and the NN tries to start a new segment at a higher txid. This should abort the old one and succeed.
 */
  @Test(timeout=10000) public void testAbortOldSegmentIfFinalizeIsMissed() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(makeRI(2),1,1,3,QJMTestUtil.createTxnData(1,3));
    GenericTestUtils.assertExists(journal.getStorage().getInProgressEditLog(1));
    journal.startLogSegment(makeRI(3),6,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(makeRI(4),6,6,3,QJMTestUtil.createTxnData(6,3));
    GenericTestUtils.assertExists(journal.getStorage().getInProgressEditLog(1));
    GenericTestUtils.assertExists(journal.getStorage().getInProgressEditLog(6));
  }
  /** 
 * Test behavior of startLogSegment() when a segment with the same transaction ID already exists.
 */
  @Test(timeout=10000) public void testStartLogSegmentWhenAlreadyExists() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(makeRI(2),1,1,1,QJMTestUtil.createTxnData(1,1));
    journal.startLogSegment(makeRI(3),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    journal.journal(makeRI(4),1,1,1,QJMTestUtil.createTxnData(1,1));
    journal.journal(makeRI(5),1,2,3,QJMTestUtil.createTxnData(2,3));
    try {
      journal.startLogSegment(makeRI(6),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
      fail("Did not fail to start log segment which would overwrite " + "an existing one");
    }
 catch (    IllegalStateException ise) {
      GenericTestUtils.assertExceptionContains("seems to contain valid transactions",ise);
    }
    journal.finalizeLogSegment(makeRI(7),1,4);
    try {
      journal.startLogSegment(makeRI(8),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
      fail("Did not fail to start log segment which would overwrite " + "an existing one");
    }
 catch (    IllegalStateException ise) {
      GenericTestUtils.assertExceptionContains("have a finalized segment",ise);
    }
  }
  private static RequestInfo makeRI(  int serial){
    return new RequestInfo(JID,null,1,serial,0);
  }
  @Test(timeout=10000) public void testNamespaceVerification() throws Exception {
    journal.newEpoch(FAKE_NSINFO,1);
    try {
      journal.newEpoch(FAKE_NSINFO_2,2);
      fail("Did not fail newEpoch() when namespaces mismatched");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Incompatible namespaceID",ioe);
    }
  }
  @Test public void testFormatNonEmptyStorageDirectories() throws Exception {
    try {
      journal.format(FAKE_NSINFO,false);
      fail("Did not fail to format non-empty directories in journal node.");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Can't format the storage directory because the current " + "directory is not empty.",ioe);
    }
  }
  @Test public void testFormatNonEmptyStorageDirectoriesWhenforceOptionIsTrue() throws Exception {
    try {
      journal.format(FAKE_NSINFO,true);
    }
 catch (    IOException ioe) {
      fail("Format should be success with force option.");
    }
  }
}
