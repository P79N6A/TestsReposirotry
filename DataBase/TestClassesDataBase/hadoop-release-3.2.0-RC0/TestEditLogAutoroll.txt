@RunWith(Parameterized.class) public class TestEditLogAutoroll {
static {
    GenericTestUtils.setLogLevel(FSEditLog.LOG,Level.DEBUG);
  }
  @Parameters public static Collection<Object[]> data(){
    Collection<Object[]> params=new ArrayList<Object[]>();
    params.add(new Object[]{Boolean.FALSE});
    params.add(new Object[]{Boolean.TRUE});
    return params;
  }
  private static boolean useAsyncEditLog;
  public TestEditLogAutoroll(  Boolean async){
    useAsyncEditLog=async;
  }
  private Configuration conf;
  private MiniDFSCluster cluster;
  private NameNode nn0;
  private FileSystem fs;
  private FSEditLog editLog;
  private final Random random=new Random();
  public static final Logger LOG=LoggerFactory.getLogger(FSEditLog.class);
  @Before public void setUp() throws Exception {
    conf=new Configuration();
    conf.setLong(DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,Long.MAX_VALUE);
    conf.setLong(DFS_NAMENODE_CHECKPOINT_TXNS_KEY,20);
    conf.setFloat(DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD,0.5f);
    conf.setInt(DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS,100);
    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_EDITS_ASYNC_LOGGING,useAsyncEditLog);
    int retryCount=0;
    while (true) {
      try {
        int basePort=10060 + random.nextInt(100) * 2;
        MiniDFSNNTopology topology=new MiniDFSNNTopology().addNameservice(new MiniDFSNNTopology.NSConf("ns1").addNN(new MiniDFSNNTopology.NNConf("nn1").setHttpPort(basePort)).addNN(new MiniDFSNNTopology.NNConf("nn2").setHttpPort(basePort + 1)));
        cluster=new MiniDFSCluster.Builder(conf).nnTopology(topology).numDataNodes(0).build();
        cluster.waitActive();
        nn0=cluster.getNameNode(0);
        fs=HATestUtil.configureFailoverFs(cluster,conf);
        cluster.transitionToActive(0);
        fs=cluster.getFileSystem(0);
        editLog=nn0.getNamesystem().getEditLog();
        ++retryCount;
        break;
      }
 catch (      BindException e) {
        LOG.info("Set up MiniDFSCluster failed due to port conflicts, retry " + retryCount + " times");
      }
    }
  }
  @After public void tearDown() throws Exception {
    if (fs != null) {
      fs.close();
      fs=null;
    }
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  @Test(timeout=60000) public void testEditLogAutoroll() throws Exception {
    final long startTxId=editLog.getCurSegmentTxId();
    for (int i=0; i < 11; i++) {
      fs.mkdirs(new Path("testEditLogAutoroll-" + i));
    }
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return editLog.getCurSegmentTxId() > startTxId;
      }
    }
,1000,5000);
    nn0.transitionToStandby();
    GenericTestUtils.assertNoThreadsMatching(".*" + NameNodeEditLogRoller.class.getSimpleName() + ".*");
  }
}
