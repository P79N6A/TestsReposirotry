/** 
 * The test case contains two data structures, a cache and a hashMap. The hashMap is used to verify the correctness of the cache.  Note that no automatic eviction is performed in the hashMap.  Thus, we have (1) If an entry exists in cache, it MUST exist in the hashMap. (2) If an entry does not exist in the cache, it may or may not exist in the hashMap.  If it exists, it must be expired.
 */
private static class LightWeightCacheTestCase implements GSet<IntEntry,IntEntry> {
  /** 
 * hashMap will not evict entries automatically. 
 */
  final GSet<IntEntry,IntEntry> hashMap=new GSetByHashMap<IntEntry,IntEntry>(1024,0.75f);
  final LightWeightCache<IntEntry,IntEntry> cache;
  final IntData data;
  final String info;
  final long starttime=Time.now();
  /** 
 * Determine the probability in  {@link #check()}. 
 */
  final int denominator;
  int iterate_count=0;
  int contain_count=0;
  private FakeTimer fakeTimer=new FakeTimer();
  LightWeightCacheTestCase(  int tablelength,  int sizeLimit,  long creationExpirationPeriod,  long accessExpirationPeriod,  int datasize,  int modulus){
    denominator=Math.min((datasize >> 7) + 1,1 << 16);
    info=getClass().getSimpleName() + "(" + new Date(starttime)+ "): tablelength="+ tablelength+ ", creationExpirationPeriod="+ creationExpirationPeriod+ ", accessExpirationPeriod="+ accessExpirationPeriod+ ", datasize="+ datasize+ ", modulus="+ modulus+ ", denominator="+ denominator;
    println(info);
    data=new IntData(datasize,modulus);
    cache=new LightWeightCache<IntEntry,IntEntry>(tablelength,sizeLimit,creationExpirationPeriod,0,fakeTimer);
    Assert.assertEquals(0,cache.size());
  }
  private boolean containsTest(  IntEntry key){
    final boolean c=cache.contains(key);
    if (c) {
      Assert.assertTrue(hashMap.contains(key));
    }
 else {
      final IntEntry h=hashMap.remove(key);
      if (h != null) {
        Assert.assertTrue(cache.isExpired(h,fakeTimer.monotonicNowNanos()));
      }
    }
    return c;
  }
  @Override public boolean contains(  IntEntry key){
    final boolean e=containsTest(key);
    check();
    return e;
  }
  private IntEntry getTest(  IntEntry key){
    final IntEntry c=cache.get(key);
    if (c != null) {
      Assert.assertEquals(hashMap.get(key).id,c.id);
    }
 else {
      final IntEntry h=hashMap.remove(key);
      if (h != null) {
        Assert.assertTrue(cache.isExpired(h,fakeTimer.monotonicNowNanos()));
      }
    }
    return c;
  }
  @Override public IntEntry get(  IntEntry key){
    final IntEntry e=getTest(key);
    check();
    return e;
  }
  private IntEntry putTest(  IntEntry entry){
    final IntEntry c=cache.put(entry);
    if (c != null) {
      Assert.assertEquals(hashMap.put(entry).id,c.id);
    }
 else {
      final IntEntry h=hashMap.put(entry);
      if (h != null && h != entry) {
        Assert.assertTrue(cache.isExpired(h,fakeTimer.monotonicNowNanos()));
      }
    }
    return c;
  }
  @Override public IntEntry put(  IntEntry entry){
    final IntEntry e=putTest(entry);
    check();
    return e;
  }
  private IntEntry removeTest(  IntEntry key){
    final IntEntry c=cache.remove(key);
    if (c != null) {
      Assert.assertEquals(c.id,hashMap.remove(key).id);
    }
 else {
      final IntEntry h=hashMap.remove(key);
      if (h != null) {
        Assert.assertTrue(cache.isExpired(h,fakeTimer.monotonicNowNanos()));
      }
    }
    return c;
  }
  @Override public IntEntry remove(  IntEntry key){
    final IntEntry e=removeTest(key);
    check();
    return e;
  }
  private int sizeTest(){
    final int c=cache.size();
    Assert.assertTrue(hashMap.size() >= c);
    return c;
  }
  @Override public int size(){
    final int s=sizeTest();
    check();
    return s;
  }
  @Override public Iterator<IntEntry> iterator(){
    throw new UnsupportedOperationException();
  }
  boolean tossCoin(){
    return ran.nextInt(denominator) == 0;
  }
  void check(){
    fakeTimer.advanceNanos(ran.nextInt() & 0x3);
    sizeTest();
    if (tossCoin()) {
      iterate_count++;
      for (      IntEntry i : cache) {
        getTest(i);
      }
    }
    if (tossCoin()) {
      contain_count++;
      final int count=Math.min(data.size(),1000);
      if (count == data.size()) {
        for (        IntEntry i : data.integers) {
          containsTest(i);
        }
      }
 else {
        for (int j=0; j < count; j++) {
          containsTest(data.get(ran.nextInt(data.size())));
        }
      }
    }
  }
  String stat(){
    final long t=Time.now() - starttime;
    return String.format(" iterate=%5d, contain=%5d, time elapsed=%5d.%03ds",iterate_count,contain_count,t / 1000,t % 1000);
  }
  @Override public void clear(){
    hashMap.clear();
    cache.clear();
    Assert.assertEquals(0,size());
  }
  @Override public Collection<IntEntry> values(){
    throw new UnsupportedOperationException();
  }
}
