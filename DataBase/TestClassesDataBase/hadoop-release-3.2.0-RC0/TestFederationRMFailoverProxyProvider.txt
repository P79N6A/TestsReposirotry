/** 
 * Unit tests for FederationRMFailoverProxyProvider.
 */
public class TestFederationRMFailoverProxyProvider {
  private Configuration conf;
  private FederationStateStore stateStore;
  private final String dummyCapability="cap";
  private GetClusterMetricsResponse threadResponse;
  @Before public void setUp() throws IOException, YarnException {
    conf=new YarnConfiguration();
    conf.setInt(YarnConfiguration.FEDERATION_CACHE_TIME_TO_LIVE_SECS,60 * 60);
    stateStore=spy(new MemoryFederationStateStore());
    stateStore.init(conf);
    FederationStateStoreFacade.getInstance().reinitialize(stateStore,conf);
    verify(stateStore,times(0)).getSubClusters(any(GetSubClustersInfoRequest.class));
  }
  @After public void tearDown() throws Exception {
    stateStore.close();
    stateStore=null;
  }
  @Test(timeout=60000) public void testFederationRMFailoverProxyProvider() throws Exception {
    testProxyProvider(true);
  }
  @Test(timeout=60000) public void testFederationRMFailoverProxyProviderWithoutFlushFacadeCache() throws Exception {
    testProxyProvider(false);
  }
  private void testProxyProvider(  boolean facadeFlushCache) throws Exception {
    final SubClusterId subClusterId=SubClusterId.newInstance("SC-1");
    final MiniYARNCluster cluster=new MiniYARNCluster("testFederationRMFailoverProxyProvider",3,0,1,1);
    conf.setBoolean(YarnConfiguration.FEDERATION_FLUSH_CACHE_FOR_RM_ADDR,facadeFlushCache);
    conf.setBoolean(YarnConfiguration.RM_HA_ENABLED,true);
    conf.setBoolean(YarnConfiguration.AUTO_FAILOVER_ENABLED,false);
    conf.set(YarnConfiguration.RM_CLUSTER_ID,"cluster1");
    conf.set(YarnConfiguration.RM_HA_IDS,"rm1,rm2,rm3");
    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS,2000);
    HATestUtil.setRpcAddressForRM("rm1",10000,conf);
    HATestUtil.setRpcAddressForRM("rm2",20000,conf);
    HATestUtil.setRpcAddressForRM("rm3",30000,conf);
    conf.setBoolean(YarnConfiguration.YARN_MINICLUSTER_FIXED_PORTS,true);
    cluster.init(conf);
    cluster.start();
    makeRMActive(subClusterId,cluster,2);
    ApplicationClientProtocol client=FederationProxyProviderUtil.createRMProxy(conf,ApplicationClientProtocol.class,subClusterId,UserGroupInformation.getCurrentUser());
    verify(stateStore,times(1)).getSubClusters(any(GetSubClustersInfoRequest.class));
    GetClusterMetricsResponse response=client.getClusterMetrics(GetClusterMetricsRequest.newInstance());
    verify(stateStore,times(1)).getSubClusters(any(GetSubClustersInfoRequest.class));
    checkResponse(response);
    cluster.getResourceManager(2).getRMContext().getRMAdminService().transitionToStandby(new HAServiceProtocol.StateChangeRequestInfo(HAServiceProtocol.RequestSource.REQUEST_BY_USER));
    makeRMActive(subClusterId,cluster,1);
    verify(stateStore,times(1)).getSubClusters(any(GetSubClustersInfoRequest.class));
    threadResponse=null;
    Thread thread=new Thread(new Runnable(){
      @Override public void run(){
        try {
          threadResponse=client.getClusterMetrics(GetClusterMetricsRequest.newInstance());
        }
 catch (        YarnException|IOException e) {
          e.printStackTrace();
        }
      }
    }
);
    thread.start();
    if (!facadeFlushCache) {
      Thread.sleep(500);
      verify(stateStore,times(1)).getSubClusters(any(GetSubClustersInfoRequest.class));
      FederationStateStoreFacade.getInstance().getSubCluster(subClusterId,true);
    }
    thread.join();
    response=threadResponse;
    if (facadeFlushCache) {
      verify(stateStore,atLeast(2)).getSubClusters(any(GetSubClustersInfoRequest.class));
    }
 else {
      verify(stateStore,times(2)).getSubClusters(any(GetSubClustersInfoRequest.class));
    }
    checkResponse(response);
    cluster.stop();
  }
  private void checkResponse(  GetClusterMetricsResponse response){
    Assert.assertNotNull(response.getClusterMetrics());
    Assert.assertEquals(0,response.getClusterMetrics().getNumActiveNodeManagers());
  }
  private void makeRMActive(  final SubClusterId subClusterId,  final MiniYARNCluster cluster,  final int index){
    try {
      System.out.println("Transition rm" + (index + 1) + " to active");
      String dummyAddress="host:" + index;
      cluster.getResourceManager(index).getRMContext().getRMAdminService().transitionToActive(new HAServiceProtocol.StateChangeRequestInfo(HAServiceProtocol.RequestSource.REQUEST_BY_USER));
      ResourceManager rm=cluster.getResourceManager(index);
      InetSocketAddress amRMAddress=rm.getApplicationMasterService().getBindAddress();
      InetSocketAddress clientRMAddress=rm.getClientRMService().getBindAddress();
      SubClusterRegisterRequest request=SubClusterRegisterRequest.newInstance(SubClusterInfo.newInstance(subClusterId,amRMAddress.getAddress().getHostAddress() + ":" + amRMAddress.getPort(),clientRMAddress.getAddress().getHostAddress() + ":" + clientRMAddress.getPort(),dummyAddress,dummyAddress,SubClusterState.SC_NEW,1,dummyCapability));
      stateStore.registerSubCluster(request);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  @SuppressWarnings({"rawtypes","unchecked"}) @Test public void testUGIForProxyCreation() throws IOException, InterruptedException {
    conf.set(YarnConfiguration.RM_CLUSTER_ID,"cluster1");
    UserGroupInformation currentUser=UserGroupInformation.getCurrentUser();
    UserGroupInformation user1=UserGroupInformation.createProxyUser("user1",currentUser);
    UserGroupInformation user2=UserGroupInformation.createProxyUser("user2",currentUser);
    final TestableFederationRMFailoverProxyProvider provider=new TestableFederationRMFailoverProxyProvider();
    InetSocketAddress addr=conf.getSocketAddr(YarnConfiguration.RM_SCHEDULER_ADDRESS,YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);
    final ClientRMProxy rmProxy=mock(ClientRMProxy.class);
    when(rmProxy.getRMAddress(any(YarnConfiguration.class),any(Class.class))).thenReturn(addr);
    user1.doAs(new PrivilegedExceptionAction<Object>(){
      @Override public Object run(){
        provider.init(conf,rmProxy,ApplicationMasterProtocol.class);
        return null;
      }
    }
);
    final ProxyInfo currentProxy=provider.getProxy();
    Assert.assertEquals("user1",provider.getLastProxyUGI().getUserName());
    user2.doAs(new PrivilegedExceptionAction<Object>(){
      @Override public Object run(){
        provider.performFailover(currentProxy.proxy);
        return null;
      }
    }
);
    Assert.assertEquals("user1",provider.getLastProxyUGI().getUserName());
    provider.close();
  }
protected static class TestableFederationRMFailoverProxyProvider<T> extends FederationRMFailoverProxyProvider<T> {
    private UserGroupInformation lastProxyUGI=null;
    @Override protected T createRMProxy(    InetSocketAddress rmAddress) throws IOException {
      lastProxyUGI=UserGroupInformation.getCurrentUser();
      return super.createRMProxy(rmAddress);
    }
    public UserGroupInformation getLastProxyUGI(){
      return lastProxyUGI;
    }
  }
}
