public class TestFSParentQueue {
  private FairSchedulerConfiguration conf;
  private QueueManager queueManager;
  private Set<FSQueue> notEmptyQueues;
  @Before public void setUp() throws Exception {
    conf=new FairSchedulerConfiguration();
    FairScheduler scheduler=mock(FairScheduler.class);
    AllocationConfiguration allocConf=new AllocationConfiguration(conf);
    when(scheduler.getAllocationConfiguration()).thenReturn(allocConf);
    when(scheduler.getConf()).thenReturn(conf);
    when(scheduler.getResourceCalculator()).thenReturn(new DefaultResourceCalculator());
    SystemClock clock=SystemClock.getInstance();
    when(scheduler.getClock()).thenReturn(clock);
    notEmptyQueues=new HashSet<FSQueue>();
    queueManager=new QueueManager(scheduler){
      @Override public boolean isEmpty(      FSQueue queue){
        return !notEmptyQueues.contains(queue);
      }
    }
;
    FSQueueMetrics.forQueue("root",null,true,conf);
    queueManager.initialize(conf);
  }
  @Test public void testConcurrentChangeToGetChildQueue(){
    queueManager.getLeafQueue("parent.child",true);
    queueManager.getLeafQueue("parent.child2",true);
    FSParentQueue test=queueManager.getParentQueue("parent",false);
    assertEquals(2,test.getChildQueues().size());
    boolean first=true;
    int childQueuesFound=0;
    for (    FSQueue childQueue : test.getChildQueues()) {
      if (first) {
        first=false;
        queueManager.getLeafQueue("parent.child3",true);
      }
      childQueuesFound++;
    }
    assertEquals(2,childQueuesFound);
    assertEquals(3,test.getChildQueues().size());
  }
}
