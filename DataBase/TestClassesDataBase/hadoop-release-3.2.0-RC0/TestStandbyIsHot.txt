/** 
 * The hotornot.com of unit tests: makes sure that the standby not only has namespace information, but also has the correct block reports, etc.
 */
public class TestStandbyIsHot {
  protected static final Logger LOG=LoggerFactory.getLogger(TestStandbyIsHot.class);
  private static final String TEST_FILE_DATA="hello highly available world";
  private static final String TEST_FILE="/testStandbyIsHot";
  private static final Path TEST_FILE_PATH=new Path(TEST_FILE);
static {
    DFSTestUtil.setNameNodeLogLevel(Level.ALL);
  }
  @Test(timeout=60000) public void testStandbyIsHot() throws Exception {
    Configuration conf=new Configuration();
    HAUtil.setAllowStandbyReads(conf,true);
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(3).build();
    try {
      cluster.waitActive();
      cluster.transitionToActive(0);
      NameNode nn1=cluster.getNameNode(0);
      NameNode nn2=cluster.getNameNode(1);
      FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
      Thread.sleep(1000);
      System.err.println("==================================");
      DFSTestUtil.writeFile(fs,TEST_FILE_PATH,TEST_FILE_DATA);
      nn1.getRpcServer().rollEditLog();
      System.err.println("==================================");
      LOG.info("Waiting for block locations to appear on standby node");
      waitForBlockLocations(cluster,nn2,TEST_FILE,3);
      cluster.triggerHeartbeats();
      cluster.triggerBlockReports();
      LOG.info("Changing replication to 1");
      fs.setReplication(TEST_FILE_PATH,(short)1);
      BlockManagerTestUtil.computeAllPendingWork(nn1.getNamesystem().getBlockManager());
      waitForBlockLocations(cluster,nn1,TEST_FILE,1);
      nn1.getRpcServer().rollEditLog();
      LOG.info("Waiting for lowered replication to show up on standby");
      waitForBlockLocations(cluster,nn2,TEST_FILE,1);
      LOG.info("Changing replication to 3");
      fs.setReplication(TEST_FILE_PATH,(short)3);
      BlockManagerTestUtil.computeAllPendingWork(nn1.getNamesystem().getBlockManager());
      nn1.getRpcServer().rollEditLog();
      LOG.info("Waiting for higher replication to show up on standby");
      waitForBlockLocations(cluster,nn2,TEST_FILE,3);
    }
  finally {
      cluster.shutdown();
    }
  }
  /** 
 * Regression test for HDFS-2795: - Start an HA cluster with a DN. - Write several blocks to the FS with replication 1. - Shutdown the DN - Wait for the NNs to declare the DN dead. All blocks will be under-replicated. - Restart the DN. In the bug, the standby node would only very slowly notice the blocks returning to the cluster.
 */
  @Test(timeout=60000) public void testDatanodeRestarts() throws Exception {
    Configuration conf=new Configuration();
    conf.setInt(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,1024);
    HAUtil.setAllowStandbyReads(conf,true);
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_ACCESSTIME_PRECISION_KEY,0);
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(1).build();
    try {
      NameNode nn0=cluster.getNameNode(0);
      NameNode nn1=cluster.getNameNode(1);
      cluster.transitionToActive(0);
      DFSTestUtil.createFile(cluster.getFileSystem(0),TEST_FILE_PATH,5 * 1024,(short)1,1L);
      HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
      DataNode dn=cluster.getDataNodes().get(0);
      String dnName=dn.getDatanodeId().getXferAddr();
      DataNodeProperties dnProps=cluster.stopDataNode(0);
      BlockManagerTestUtil.noticeDeadDatanode(nn0,dnName);
      BlockManagerTestUtil.noticeDeadDatanode(nn1,dnName);
      BlockManagerTestUtil.updateState(nn0.getNamesystem().getBlockManager());
      BlockManagerTestUtil.updateState(nn1.getNamesystem().getBlockManager());
      assertEquals(5,nn0.getNamesystem().getUnderReplicatedBlocks());
      assertEquals(0,nn1.getNamesystem().getUnderReplicatedBlocks());
      LocatedBlocks locs=nn1.getRpcServer().getBlockLocations(TEST_FILE,0,1);
      assertEquals("Standby should have registered that the block has no replicas",0,locs.get(0).getLocations().length);
      cluster.restartDataNode(dnProps);
      cluster.waitActive(0);
      cluster.waitActive(1);
      cluster.waitFirstBRCompleted(0,10000);
      cluster.waitFirstBRCompleted(1,10000);
      BlockManagerTestUtil.updateState(nn0.getNamesystem().getBlockManager());
      BlockManagerTestUtil.updateState(nn1.getNamesystem().getBlockManager());
      assertEquals(0,nn0.getNamesystem().getUnderReplicatedBlocks());
      assertEquals(0,nn1.getNamesystem().getUnderReplicatedBlocks());
      locs=nn1.getRpcServer().getBlockLocations(TEST_FILE,0,1);
      assertEquals("Standby should have registered that the block has replicas again",1,locs.get(0).getLocations().length);
    }
  finally {
      cluster.shutdown();
    }
  }
  static void waitForBlockLocations(  final MiniDFSCluster cluster,  final NameNode nn,  final String path,  final int expectedReplicas) throws Exception {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        try {
          LocatedBlocks locs=NameNodeAdapter.getBlockLocations(nn,path,0,1000);
          DatanodeInfo[] dnis=locs.getLastLocatedBlock().getLocations();
          for (          DatanodeInfo dni : dnis) {
            Assert.assertNotNull(dni);
          }
          int numReplicas=dnis.length;
          LOG.info("Got " + numReplicas + " locs: "+ locs);
          if (numReplicas > expectedReplicas) {
            cluster.triggerDeletionReports();
          }
          cluster.triggerHeartbeats();
          return numReplicas == expectedReplicas;
        }
 catch (        IOException e) {
          LOG.warn("No block locations yet: " + e.getMessage());
          return false;
        }
      }
    }
,500,20000);
  }
}
