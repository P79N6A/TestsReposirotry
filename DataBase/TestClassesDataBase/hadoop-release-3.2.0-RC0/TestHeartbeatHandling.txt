/** 
 * Test if FSNamesystem handles heartbeat right
 */
public class TestHeartbeatHandling {
  /** 
 * Set a timeout for every test case.
 */
  @Rule public Timeout testTimeout=new Timeout(300_000);
  /** 
 * Test if {@link FSNamesystem#handleHeartbeat}can pick up replication and/or invalidate requests and observes the max limit
 */
  @Test public void testHeartbeat() throws Exception {
    final Configuration conf=new HdfsConfiguration();
    final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
    try {
      cluster.waitActive();
      final FSNamesystem namesystem=cluster.getNamesystem();
      final HeartbeatManager hm=namesystem.getBlockManager().getDatanodeManager().getHeartbeatManager();
      final String poolId=namesystem.getBlockPoolId();
      final DatanodeRegistration nodeReg=InternalDataNodeTestUtils.getDNRegistrationForBP(cluster.getDataNodes().get(0),poolId);
      final DatanodeDescriptor dd=NameNodeAdapter.getDatanode(namesystem,nodeReg);
      final String storageID=DatanodeStorage.generateUuid();
      dd.updateStorage(new DatanodeStorage(storageID));
      final int REMAINING_BLOCKS=1;
      final int MAX_REPLICATE_LIMIT=conf.getInt(DFSConfigKeys.DFS_NAMENODE_REPLICATION_MAX_STREAMS_KEY,2);
      final int MAX_INVALIDATE_LIMIT=DFSConfigKeys.DFS_BLOCK_INVALIDATE_LIMIT_DEFAULT;
      final int MAX_INVALIDATE_BLOCKS=2 * MAX_INVALIDATE_LIMIT + REMAINING_BLOCKS;
      final int MAX_REPLICATE_BLOCKS=2 * MAX_REPLICATE_LIMIT + REMAINING_BLOCKS;
      final DatanodeStorageInfo[] ONE_TARGET={dd.getStorageInfo(storageID)};
      try {
        namesystem.writeLock();
synchronized (hm) {
          for (int i=0; i < MAX_REPLICATE_BLOCKS; i++) {
            dd.addBlockToBeReplicated(new Block(i,0,GenerationStamp.LAST_RESERVED_STAMP),ONE_TARGET);
          }
          DatanodeCommand[] cmds=NameNodeAdapter.sendHeartBeat(nodeReg,dd,namesystem).getCommands();
          assertEquals(1,cmds.length);
          assertEquals(DatanodeProtocol.DNA_TRANSFER,cmds[0].getAction());
          assertEquals(MAX_REPLICATE_LIMIT,((BlockCommand)cmds[0]).getBlocks().length);
          ArrayList<Block> blockList=new ArrayList<Block>(MAX_INVALIDATE_BLOCKS);
          for (int i=0; i < MAX_INVALIDATE_BLOCKS; i++) {
            blockList.add(new Block(i,0,GenerationStamp.LAST_RESERVED_STAMP));
          }
          dd.addBlocksToBeInvalidated(blockList);
          cmds=NameNodeAdapter.sendHeartBeat(nodeReg,dd,namesystem).getCommands();
          assertEquals(2,cmds.length);
          assertEquals(DatanodeProtocol.DNA_TRANSFER,cmds[0].getAction());
          assertEquals(MAX_REPLICATE_LIMIT,((BlockCommand)cmds[0]).getBlocks().length);
          assertEquals(DatanodeProtocol.DNA_INVALIDATE,cmds[1].getAction());
          assertEquals(MAX_INVALIDATE_LIMIT,((BlockCommand)cmds[1]).getBlocks().length);
          cmds=NameNodeAdapter.sendHeartBeat(nodeReg,dd,namesystem).getCommands();
          assertEquals(2,cmds.length);
          assertEquals(DatanodeProtocol.DNA_TRANSFER,cmds[0].getAction());
          assertEquals(REMAINING_BLOCKS,((BlockCommand)cmds[0]).getBlocks().length);
          assertEquals(DatanodeProtocol.DNA_INVALIDATE,cmds[1].getAction());
          assertEquals(MAX_INVALIDATE_LIMIT,((BlockCommand)cmds[1]).getBlocks().length);
          cmds=NameNodeAdapter.sendHeartBeat(nodeReg,dd,namesystem).getCommands();
          assertEquals(1,cmds.length);
          assertEquals(DatanodeProtocol.DNA_INVALIDATE,cmds[0].getAction());
          assertEquals(REMAINING_BLOCKS,((BlockCommand)cmds[0]).getBlocks().length);
          cmds=NameNodeAdapter.sendHeartBeat(nodeReg,dd,namesystem).getCommands();
          assertEquals(0,cmds.length);
        }
      }
  finally {
        namesystem.writeUnlock();
      }
    }
  finally {
      cluster.shutdown();
    }
  }
  /** 
 * Test if {@link FSNamesystem#handleHeartbeat}correctly selects data node targets for block recovery.
 */
  @Test public void testHeartbeatBlockRecovery() throws Exception {
    final Configuration conf=new HdfsConfiguration();
    final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
    try {
      cluster.waitActive();
      final FSNamesystem namesystem=cluster.getNamesystem();
      final HeartbeatManager hm=namesystem.getBlockManager().getDatanodeManager().getHeartbeatManager();
      final String poolId=namesystem.getBlockPoolId();
      final DatanodeRegistration nodeReg1=InternalDataNodeTestUtils.getDNRegistrationForBP(cluster.getDataNodes().get(0),poolId);
      final DatanodeDescriptor dd1=NameNodeAdapter.getDatanode(namesystem,nodeReg1);
      dd1.updateStorage(new DatanodeStorage(DatanodeStorage.generateUuid()));
      final DatanodeRegistration nodeReg2=InternalDataNodeTestUtils.getDNRegistrationForBP(cluster.getDataNodes().get(1),poolId);
      final DatanodeDescriptor dd2=NameNodeAdapter.getDatanode(namesystem,nodeReg2);
      dd2.updateStorage(new DatanodeStorage(DatanodeStorage.generateUuid()));
      final DatanodeRegistration nodeReg3=InternalDataNodeTestUtils.getDNRegistrationForBP(cluster.getDataNodes().get(2),poolId);
      final DatanodeDescriptor dd3=NameNodeAdapter.getDatanode(namesystem,nodeReg3);
      dd3.updateStorage(new DatanodeStorage(DatanodeStorage.generateUuid()));
      try {
        namesystem.writeLock();
synchronized (hm) {
          NameNodeAdapter.sendHeartBeat(nodeReg1,dd1,namesystem);
          NameNodeAdapter.sendHeartBeat(nodeReg2,dd2,namesystem);
          NameNodeAdapter.sendHeartBeat(nodeReg3,dd3,namesystem);
          DFSTestUtil.resetLastUpdatesWithOffset(dd1,0);
          DFSTestUtil.resetLastUpdatesWithOffset(dd2,0);
          DFSTestUtil.resetLastUpdatesWithOffset(dd3,0);
          final DatanodeStorageInfo[] storages={dd1.getStorageInfos()[0],dd2.getStorageInfos()[0],dd3.getStorageInfos()[0]};
          BlockInfo blockInfo=new BlockInfoContiguous(new Block(0,0,GenerationStamp.LAST_RESERVED_STAMP),(short)3);
          blockInfo.convertToBlockUnderConstruction(BlockUCState.UNDER_RECOVERY,storages);
          dd1.addBlockToBeRecovered(blockInfo);
          DatanodeCommand[] cmds=NameNodeAdapter.sendHeartBeat(nodeReg1,dd1,namesystem).getCommands();
          assertEquals(1,cmds.length);
          assertEquals(DatanodeProtocol.DNA_RECOVERBLOCK,cmds[0].getAction());
          BlockRecoveryCommand recoveryCommand=(BlockRecoveryCommand)cmds[0];
          assertEquals(1,recoveryCommand.getRecoveringBlocks().size());
          DatanodeInfo[] recoveringNodes=recoveryCommand.getRecoveringBlocks().toArray(new BlockRecoveryCommand.RecoveringBlock[0])[0].getLocations();
          assertEquals(3,recoveringNodes.length);
          assertEquals(recoveringNodes[0],dd1);
          assertEquals(recoveringNodes[1],dd2);
          assertEquals(recoveringNodes[2],dd3);
          DFSTestUtil.resetLastUpdatesWithOffset(dd1,0);
          DFSTestUtil.resetLastUpdatesWithOffset(dd2,-40 * 1000);
          DFSTestUtil.resetLastUpdatesWithOffset(dd3,0);
          blockInfo=new BlockInfoContiguous(new Block(0,0,GenerationStamp.LAST_RESERVED_STAMP),(short)3);
          blockInfo.convertToBlockUnderConstruction(BlockUCState.UNDER_RECOVERY,storages);
          dd1.addBlockToBeRecovered(blockInfo);
          cmds=NameNodeAdapter.sendHeartBeat(nodeReg1,dd1,namesystem).getCommands();
          assertEquals(1,cmds.length);
          assertEquals(DatanodeProtocol.DNA_RECOVERBLOCK,cmds[0].getAction());
          recoveryCommand=(BlockRecoveryCommand)cmds[0];
          assertEquals(1,recoveryCommand.getRecoveringBlocks().size());
          recoveringNodes=recoveryCommand.getRecoveringBlocks().toArray(new BlockRecoveryCommand.RecoveringBlock[0])[0].getLocations();
          assertEquals(2,recoveringNodes.length);
          assertEquals(recoveringNodes[0],dd1);
          assertEquals(recoveringNodes[1],dd3);
          DFSTestUtil.resetLastUpdatesWithOffset(dd1,-60 * 1000);
          DFSTestUtil.resetLastUpdatesWithOffset(dd2,-40 * 1000);
          DFSTestUtil.resetLastUpdatesWithOffset(dd3,-80 * 1000);
          blockInfo=new BlockInfoContiguous(new Block(0,0,GenerationStamp.LAST_RESERVED_STAMP),(short)3);
          blockInfo.convertToBlockUnderConstruction(BlockUCState.UNDER_RECOVERY,storages);
          dd1.addBlockToBeRecovered(blockInfo);
          cmds=NameNodeAdapter.sendHeartBeat(nodeReg1,dd1,namesystem).getCommands();
          assertEquals(1,cmds.length);
          assertEquals(DatanodeProtocol.DNA_RECOVERBLOCK,cmds[0].getAction());
          recoveryCommand=(BlockRecoveryCommand)cmds[0];
          assertEquals(1,recoveryCommand.getRecoveringBlocks().size());
          recoveringNodes=recoveryCommand.getRecoveringBlocks().toArray(new BlockRecoveryCommand.RecoveringBlock[0])[0].getLocations();
          assertEquals(3,recoveringNodes.length);
          assertEquals(recoveringNodes[0],dd1);
          assertEquals(recoveringNodes[1],dd2);
          assertEquals(recoveringNodes[2],dd3);
        }
      }
  finally {
        namesystem.writeUnlock();
      }
    }
  finally {
      cluster.shutdown();
    }
  }
  @Test public void testHeartbeatStopWatch() throws Exception {
    Namesystem ns=Mockito.mock(Namesystem.class);
    BlockManager bm=Mockito.mock(BlockManager.class);
    Configuration conf=new Configuration();
    long recheck=2000;
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,recheck);
    HeartbeatManager monitor=new HeartbeatManager(ns,bm,conf);
    monitor.restartHeartbeatStopWatch();
    assertFalse(monitor.shouldAbortHeartbeatCheck(0));
    Thread.sleep(100);
    assertFalse(monitor.shouldAbortHeartbeatCheck(0));
    Thread.sleep(recheck);
    assertTrue(monitor.shouldAbortHeartbeatCheck(0));
    assertFalse(monitor.shouldAbortHeartbeatCheck(-recheck * 3));
    monitor.restartHeartbeatStopWatch();
    assertFalse(monitor.shouldAbortHeartbeatCheck(0));
  }
}
