public class TestFsDatasetCacheRevocation {
  private static final Logger LOG=LoggerFactory.getLogger(TestFsDatasetCacheRevocation.class);
  private static CacheManipulator prevCacheManipulator;
  private static TemporarySocketDirectory sockDir;
  private static final int BLOCK_SIZE=4096;
  @Before public void setUp() throws Exception {
    prevCacheManipulator=NativeIO.POSIX.getCacheManipulator();
    NativeIO.POSIX.setCacheManipulator(new NoMlockCacheManipulator());
    DomainSocket.disableBindPathValidation();
    sockDir=new TemporarySocketDirectory();
  }
  @After public void tearDown() throws Exception {
    NativeIO.POSIX.setCacheManipulator(prevCacheManipulator);
    sockDir.close();
  }
  private static Configuration getDefaultConf(){
    HdfsConfiguration conf=new HdfsConfiguration();
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_PATH_BASED_CACHE_REFRESH_INTERVAL_MS,50);
    conf.setLong(DFSConfigKeys.DFS_CACHEREPORT_INTERVAL_MSEC_KEY,250);
    conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,BLOCK_SIZE);
    conf.setLong(DFSConfigKeys.DFS_DATANODE_MAX_LOCKED_MEMORY_KEY,TestFsDatasetCache.CACHE_CAPACITY);
    conf.setLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,1);
    conf.setBoolean(HdfsClientConfigKeys.Read.ShortCircuit.KEY,true);
    conf.set(DFSConfigKeys.DFS_DOMAIN_SOCKET_PATH_KEY,new File(sockDir.getDir(),"sock").getAbsolutePath());
    return conf;
  }
  /** 
 * Test that when a client has a replica mmapped, we will not un-mlock that replica for a reasonable amount of time, even if an uncache request occurs.
 */
  @Test(timeout=120000) public void testPinning() throws Exception {
    assumeTrue(NativeCodeLoader.isNativeCodeLoaded());
    assumeNotWindows();
    Configuration conf=getDefaultConf();
    conf.setLong(DFSConfigKeys.DFS_DATANODE_CACHE_REVOCATION_TIMEOUT_MS,1800000L);
    conf.setLong(DFSConfigKeys.DFS_DATANODE_CACHE_REVOCATION_POLLING_MS,2L);
    MiniDFSCluster cluster=null;
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    DistributedFileSystem dfs=cluster.getFileSystem();
    final String TEST_FILE="/test_file";
    DFSTestUtil.createFile(dfs,new Path(TEST_FILE),BLOCK_SIZE,(short)1,0xcafe);
    dfs.addCachePool(new CachePoolInfo("pool"));
    long cacheDirectiveId=dfs.addCacheDirective(new CacheDirectiveInfo.Builder().setPool("pool").setPath(new Path(TEST_FILE)).setReplication((short)1).build());
    FsDatasetSpi<?> fsd=cluster.getDataNodes().get(0).getFSDataset();
    DFSTestUtil.verifyExpectedCacheUsage(BLOCK_SIZE,1,fsd);
    FSDataInputStream in=dfs.open(new Path(TEST_FILE));
    ByteBuffer buf=in.read(null,BLOCK_SIZE,EnumSet.noneOf(ReadOption.class));
    dfs.removeCacheDirective(cacheDirectiveId);
    Thread.sleep(500);
    DFSTestUtil.verifyExpectedCacheUsage(BLOCK_SIZE,1,fsd);
    in.releaseBuffer(buf);
    DFSTestUtil.verifyExpectedCacheUsage(0,0,fsd);
    in.close();
    cluster.shutdown();
  }
  /** 
 * Test that when we have an uncache request, and the client refuses to release the replica for a long time, we will un-mlock it.
 */
  @Test(timeout=120000) public void testRevocation() throws Exception {
    assumeTrue(NativeCodeLoader.isNativeCodeLoaded());
    assumeNotWindows();
    BlockReaderTestUtil.enableHdfsCachingTracing();
    BlockReaderTestUtil.enableShortCircuitShmTracing();
    Configuration conf=getDefaultConf();
    conf.setLong(DFSConfigKeys.DFS_DATANODE_CACHE_REVOCATION_TIMEOUT_MS,250L);
    conf.setLong(DFSConfigKeys.DFS_DATANODE_CACHE_REVOCATION_POLLING_MS,2L);
    MiniDFSCluster cluster=null;
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    DistributedFileSystem dfs=cluster.getFileSystem();
    final String TEST_FILE="/test_file2";
    DFSTestUtil.createFile(dfs,new Path(TEST_FILE),BLOCK_SIZE,(short)1,0xcafe);
    dfs.addCachePool(new CachePoolInfo("pool"));
    long cacheDirectiveId=dfs.addCacheDirective(new CacheDirectiveInfo.Builder().setPool("pool").setPath(new Path(TEST_FILE)).setReplication((short)1).build());
    FsDatasetSpi<?> fsd=cluster.getDataNodes().get(0).getFSDataset();
    DFSTestUtil.verifyExpectedCacheUsage(BLOCK_SIZE,1,fsd);
    FSDataInputStream in=dfs.open(new Path(TEST_FILE));
    ByteBuffer buf=in.read(null,BLOCK_SIZE,EnumSet.noneOf(ReadOption.class));
    LOG.info("removing cache directive {}",cacheDirectiveId);
    dfs.removeCacheDirective(cacheDirectiveId);
    LOG.info("finished removing cache directive {}",cacheDirectiveId);
    Thread.sleep(1000);
    DFSTestUtil.verifyExpectedCacheUsage(0,0,fsd);
    in.releaseBuffer(buf);
    in.close();
    cluster.shutdown();
  }
}
