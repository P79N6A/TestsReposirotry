/** 
 * This tests basic operations of  {@link DFSOpsCountStatistics} class.
 */
public class TestDFSOpsCountStatistics {
  private static final Logger LOG=LoggerFactory.getLogger(TestDFSOpsCountStatistics.class);
  private static final String NO_SUCH_OP="no-such-dfs-operation-dude";
  private final DFSOpsCountStatistics statistics=new DFSOpsCountStatistics();
  private final Map<OpType,AtomicLong> expectedOpsCountMap=new HashMap<>();
  @Rule public final Timeout globalTimeout=new Timeout(10 * 1000);
  @Rule public final ExpectedException exception=ExpectedException.none();
  @Before public void setup(){
    for (    OpType opType : OpType.values()) {
      expectedOpsCountMap.put(opType,new AtomicLong());
    }
    incrementOpsCountByRandomNumbers();
  }
  /** 
 * This is to test the the  {@link OpType} symbols are unique.
 */
  @Test public void testOpTypeSymbolsAreUnique(){
    final Set<String> opTypeSymbols=new HashSet<>();
    for (    OpType opType : OpType.values()) {
      assertFalse(opTypeSymbols.contains(opType.getSymbol()));
      opTypeSymbols.add(opType.getSymbol());
    }
    assertEquals(OpType.values().length,opTypeSymbols.size());
  }
  @Test public void testGetLongStatistics(){
    short iterations=0;
    final Iterator<LongStatistic> iter=statistics.getLongStatistics();
    while (iter.hasNext()) {
      final LongStatistic longStat=iter.next();
      assertNotNull(longStat);
      final OpType opType=OpType.fromSymbol(longStat.getName());
      assertNotNull(opType);
      assertTrue(expectedOpsCountMap.containsKey(opType));
      assertEquals(expectedOpsCountMap.get(opType).longValue(),longStat.getValue());
      iterations++;
    }
    assertEquals(OpType.values().length,iterations);
  }
  @Test public void testGetLong(){
    assertNull(statistics.getLong(null));
    assertNull(statistics.getLong(NO_SUCH_OP));
    verifyStatistics();
  }
  @Test public void testIsTracked(){
    assertFalse(statistics.isTracked(null));
    assertFalse(statistics.isTracked(NO_SUCH_OP));
    final Iterator<LongStatistic> iter=statistics.getLongStatistics();
    while (iter.hasNext()) {
      final LongStatistic longStatistic=iter.next();
      assertTrue(statistics.isTracked(longStatistic.getName()));
    }
  }
  @Test public void testReset(){
    statistics.reset();
    for (    OpType opType : OpType.values()) {
      expectedOpsCountMap.get(opType).set(0);
    }
    final Iterator<LongStatistic> iter=statistics.getLongStatistics();
    while (iter.hasNext()) {
      final LongStatistic longStat=iter.next();
      assertEquals(0,longStat.getValue());
    }
    incrementOpsCountByRandomNumbers();
    verifyStatistics();
  }
  @Test public void testCurrentAccess() throws InterruptedException {
    final int numThreads=10;
    final ExecutorService threadPool=newFixedThreadPool(numThreads);
    try {
      final CountDownLatch allReady=new CountDownLatch(numThreads);
      final CountDownLatch startBlocker=new CountDownLatch(1);
      final CountDownLatch allDone=new CountDownLatch(numThreads);
      final AtomicReference<Throwable> childError=new AtomicReference<>();
      for (int i=0; i < numThreads; i++) {
        threadPool.submit(new Runnable(){
          @Override public void run(){
            allReady.countDown();
            try {
              startBlocker.await();
              incrementOpsCountByRandomNumbers();
            }
 catch (            Throwable t) {
              LOG.error("Child failed when calling mkdir",t);
              childError.compareAndSet(null,t);
            }
 finally {
              allDone.countDown();
            }
          }
        }
);
      }
      allReady.await();
      startBlocker.countDown();
      allDone.await();
      assertNull("Child failed with exception.",childError.get());
      verifyStatistics();
    }
  finally {
      threadPool.shutdownNow();
    }
  }
  /** 
 * This is helper method to increment the statistics by random data.
 */
  private void incrementOpsCountByRandomNumbers(){
    for (    OpType opType : OpType.values()) {
      final Long randomCount=RandomUtils.nextLong(0,100);
      expectedOpsCountMap.get(opType).addAndGet(randomCount);
      for (long i=0; i < randomCount; i++) {
        statistics.incrementOpCounter(opType);
      }
    }
  }
  /** 
 * We have the expected ops count in  {@link #expectedOpsCountMap}, and this method is to verify that its ops count is the same as the one in {@link #statistics}.
 */
  private void verifyStatistics(){
    for (    OpType opType : OpType.values()) {
      assertNotNull(expectedOpsCountMap.get(opType));
      assertNotNull(statistics.getLong(opType.getSymbol()));
      assertEquals("Not expected count for operation " + opType.getSymbol(),expectedOpsCountMap.get(opType).longValue(),statistics.getLong(opType.getSymbol()).longValue());
    }
  }
}
