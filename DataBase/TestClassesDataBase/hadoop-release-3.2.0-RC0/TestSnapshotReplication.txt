/** 
 * This class tests the replication handling/calculation of snapshots to make sure the number of replication is calculated correctly with/without snapshots.
 */
public class TestSnapshotReplication {
  private static final long seed=0;
  private static final short REPLICATION=3;
  private static final int NUMDATANODE=5;
  private static final long BLOCKSIZE=1024;
  private final Path dir=new Path("/TestSnapshot");
  private final Path sub1=new Path(dir,"sub1");
  private final Path file1=new Path(sub1,"file1");
  Configuration conf;
  MiniDFSCluster cluster;
  FSNamesystem fsn;
  DistributedFileSystem hdfs;
  FSDirectory fsdir;
  @Before public void setUp() throws Exception {
    conf=new Configuration();
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUMDATANODE).build();
    cluster.waitActive();
    fsn=cluster.getNamesystem();
    hdfs=cluster.getFileSystem();
    fsdir=fsn.getFSDirectory();
  }
  @After public void tearDown() throws Exception {
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  /** 
 * Check the replication of a given file.
 * @param file The given file
 * @param replication The expected replication number
 * @param blockReplication The expected replication number for the block
 * @throws Exception
 */
  private void checkFileReplication(  Path file,  short replication,  short blockReplication) throws Exception {
    short fileReplication=hdfs.getFileStatus(file1).getReplication();
    assertEquals(replication,fileReplication);
    INode inode=fsdir.getINode(file1.toString());
    assertTrue(inode instanceof INodeFile);
    for (    BlockInfo b : inode.asFile().getBlocks()) {
      assertEquals(blockReplication,b.getReplication());
    }
  }
  /** 
 * Test replication number calculation for a normal file without snapshots.
 */
  @Test(timeout=60000) public void testReplicationWithoutSnapshot() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    checkFileReplication(file1,REPLICATION,REPLICATION);
    hdfs.setReplication(file1,(short)(REPLICATION - 1));
    checkFileReplication(file1,(short)(REPLICATION - 1),(short)(REPLICATION - 1));
  }
  INodeFile getINodeFile(  Path p) throws Exception {
    final String s=p.toString();
    return INodeFile.valueOf(fsdir.getINode(s),s);
  }
  /** 
 * Check the replication for both the current file and all its prior snapshots
 * @param currentFile the Path of the current file
 * @param snapshotRepMap A map maintaining all the snapshots of the current file, as well as their expected replication number stored in their corresponding INodes
 * @param expectedBlockRep The expected replication number
 * @throws Exception
 */
  private void checkSnapshotFileReplication(  Path currentFile,  Map<Path,Short> snapshotRepMap,  short expectedBlockRep) throws Exception {
    final INodeFile inodeOfCurrentFile=getINodeFile(currentFile);
    for (    BlockInfo b : inodeOfCurrentFile.getBlocks()) {
      assertEquals(expectedBlockRep,b.getReplication());
    }
    for (    Path ss : snapshotRepMap.keySet()) {
      final INodesInPath iip=fsdir.getINodesInPath(ss.toString(),DirOp.READ);
      final INodeFile ssInode=iip.getLastINode().asFile();
      for (      BlockInfo b : ssInode.getBlocks()) {
        assertEquals(expectedBlockRep,b.getReplication());
      }
      assertEquals(snapshotRepMap.get(ss).shortValue(),ssInode.getFileReplication(iip.getPathSnapshotId()));
    }
  }
  /** 
 * Test replication number calculation for a file with snapshots.
 */
  @Test(timeout=60000) public void testReplicationWithSnapshot() throws Exception {
    short fileRep=1;
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,fileRep,seed);
    Map<Path,Short> snapshotRepMap=new HashMap<Path,Short>();
    for (; fileRep < NUMDATANODE; ) {
      Path snapshotRoot=SnapshotTestHelper.createSnapshot(hdfs,sub1,"s" + fileRep);
      Path snapshot=new Path(snapshotRoot,file1.getName());
      assertEquals(fileRep,getINodeFile(snapshot).getFileReplication());
      snapshotRepMap.put(snapshot,fileRep);
      hdfs.setReplication(file1,++fileRep);
      checkFileReplication(file1,fileRep,fileRep);
      checkSnapshotFileReplication(file1,snapshotRepMap,fileRep);
    }
    hdfs.setReplication(file1,REPLICATION);
    checkFileReplication(file1,REPLICATION,(short)(NUMDATANODE - 1));
    checkSnapshotFileReplication(file1,snapshotRepMap,(short)(NUMDATANODE - 1));
  }
  /** 
 * Test replication for a file with snapshots, also including the scenario where the original file is deleted
 */
  @Test(timeout=60000) public void testReplicationAfterDeletion() throws Exception {
    DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
    Map<Path,Short> snapshotRepMap=new HashMap<Path,Short>();
    for (int i=1; i <= 3; i++) {
      Path root=SnapshotTestHelper.createSnapshot(hdfs,sub1,"s" + i);
      Path ssFile=new Path(root,file1.getName());
      snapshotRepMap.put(ssFile,REPLICATION);
    }
    checkFileReplication(file1,REPLICATION,REPLICATION);
    checkSnapshotFileReplication(file1,snapshotRepMap,REPLICATION);
    hdfs.delete(file1,true);
    for (    Path ss : snapshotRepMap.keySet()) {
      final INodeFile ssInode=getINodeFile(ss);
      for (      BlockInfo b : ssInode.getBlocks()) {
        assertEquals(REPLICATION,b.getReplication());
      }
      assertEquals(snapshotRepMap.get(ss).shortValue(),ssInode.getFileReplication());
    }
  }
}
