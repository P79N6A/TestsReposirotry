@SuppressWarnings({"rawtypes","unchecked"}) public class TestKVSerializer {
  int inputArraySize=1000;
  int bufferSize=100;
  private KV<BytesWritable,BytesWritable>[] inputArray;
  final ByteArrayOutputStream result=new ByteArrayOutputStream();
  private SizedWritable key;
  private SizedWritable value;
  private KVSerializer serializer;
  @Before public void setUp() throws IOException {
    this.inputArray=TestInput.getMapInputs(inputArraySize);
    this.key=new SizedWritable(BytesWritable.class);
    this.value=new SizedWritable(BytesWritable.class);
    this.serializer=new KVSerializer(BytesWritable.class,BytesWritable.class);
    key.reset(inputArray[4].key);
    value.reset(inputArray[4].value);
    serializer.updateLength(key,value);
  }
  @Test public void testUpdateLength() throws IOException {
    Mockito.mock(DataOutputStream.class);
    int kvLength=0;
    for (int i=0; i < inputArraySize; i++) {
      key.reset(inputArray[i].key);
      value.reset(inputArray[i].value);
      serializer.updateLength(key,value);
      Assert.assertTrue(key.length + value.length > kvLength);
      kvLength=key.length + value.length;
    }
  }
  @Test public void testSerializeKV() throws IOException {
    final DataOutputStream dataOut=Mockito.mock(DataOutputStream.class);
    Mockito.when(dataOut.hasUnFlushedData()).thenReturn(true);
    Mockito.when(dataOut.shortOfSpace(key.length + value.length + Constants.SIZEOF_KV_LENGTH)).thenReturn(true);
    final int written=serializer.serializeKV(dataOut,key,value);
    Mockito.verify(dataOut,Mockito.times(1)).flush();
    Mockito.verify(dataOut,Mockito.times(4)).writeInt(Matchers.anyInt());
    Mockito.verify(dataOut,Mockito.times(2)).write(Matchers.any(byte[].class),Matchers.anyInt(),Matchers.anyInt());
    Assert.assertEquals(written,key.length + value.length + Constants.SIZEOF_KV_LENGTH);
  }
  @Test public void testSerializeNoFlush() throws IOException {
    final DataOutputStream dataOut=Mockito.mock(DataOutputStream.class);
    Mockito.when(dataOut.hasUnFlushedData()).thenReturn(true);
    Mockito.when(dataOut.shortOfSpace(Matchers.anyInt())).thenReturn(false);
    final int written=serializer.serializeKV(dataOut,key,value);
    Mockito.verify(dataOut,Mockito.times(0)).flush();
    Mockito.verify(dataOut,Mockito.times(4)).writeInt(Matchers.anyInt());
    Mockito.verify(dataOut,Mockito.times(2)).write(Matchers.any(byte[].class),Matchers.anyInt(),Matchers.anyInt());
    Assert.assertEquals(written,key.length + value.length + Constants.SIZEOF_KV_LENGTH);
  }
  @Test public void testSerializePartitionKV() throws IOException {
    final DataOutputStream dataOut=Mockito.mock(DataOutputStream.class);
    Mockito.when(dataOut.hasUnFlushedData()).thenReturn(true);
    Mockito.when(dataOut.shortOfSpace(key.length + value.length + Constants.SIZEOF_KV_LENGTH+ Constants.SIZEOF_PARTITION_LENGTH)).thenReturn(true);
    final int written=serializer.serializePartitionKV(dataOut,100,key,value);
    Mockito.verify(dataOut,Mockito.times(1)).flush();
    Mockito.verify(dataOut,Mockito.times(5)).writeInt(Matchers.anyInt());
    Mockito.verify(dataOut,Mockito.times(2)).write(Matchers.any(byte[].class),Matchers.anyInt(),Matchers.anyInt());
    Assert.assertEquals(written,key.length + value.length + Constants.SIZEOF_KV_LENGTH+ Constants.SIZEOF_PARTITION_LENGTH);
  }
  @Test public void testDeserializerNoData() throws IOException {
    final DataInputStream in=Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0,serializer.deserializeKV(in,key,value));
  }
  @Test public void testDeserializer() throws IOException {
    final DataInputStream in=Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in,key,value) > 0);
    Mockito.verify(in,Mockito.times(4)).readInt();
    Mockito.verify(in,Mockito.times(2)).readFully(Matchers.any(byte[].class),Matchers.anyInt(),Matchers.anyInt());
  }
}
