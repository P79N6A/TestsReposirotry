public class TestSequenceFileAppend {
  private static Configuration conf;
  private static FileSystem fs;
  private static Path ROOT_PATH=new Path(GenericTestUtils.getTestDir().getAbsolutePath());
  @BeforeClass public static void setUp() throws Exception {
    conf=new Configuration();
    conf.set("io.serializations","org.apache.hadoop.io.serializer.JavaSerialization");
    conf.set("fs.file.impl","org.apache.hadoop.fs.RawLocalFileSystem");
    fs=FileSystem.get(conf);
  }
  @AfterClass public static void tearDown() throws Exception {
    fs.close();
  }
  @Test(timeout=30000) public void testAppend() throws Exception {
    Path file=new Path(ROOT_PATH,"testseqappend.seq");
    fs.delete(file,true);
    Text key1=new Text("Key1");
    Text value1=new Text("Value1");
    Text value2=new Text("Updated");
    SequenceFile.Metadata metadata=new SequenceFile.Metadata();
    metadata.set(key1,value1);
    Writer.Option metadataOption=Writer.metadata(metadata);
    Writer writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),metadataOption);
    writer.append(1L,"one");
    writer.append(2L,"two");
    writer.close();
    verify2Values(file);
    metadata.set(key1,value2);
    writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),metadataOption);
    assertEquals(value1,writer.metadata.get(key1));
    writer.append(3L,"three");
    writer.append(4L,"four");
    writer.close();
    verifyAll4Values(file);
    Reader reader=new Reader(conf,Reader.file(file));
    assertEquals(value1,reader.getMetadata().get(key1));
    reader.close();
    try {
      Option wrongCompressOption=Writer.compression(CompressionType.RECORD,new GzipCodec());
      writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),wrongCompressOption);
      writer.close();
      fail("Expected IllegalArgumentException for compression options");
    }
 catch (    IllegalArgumentException IAE) {
    }
    try {
      Option wrongCompressOption=Writer.compression(CompressionType.BLOCK,new DefaultCodec());
      writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),wrongCompressOption);
      writer.close();
      fail("Expected IllegalArgumentException for compression options");
    }
 catch (    IllegalArgumentException IAE) {
    }
    fs.deleteOnExit(file);
  }
  @Test(timeout=30000) public void testAppendRecordCompression() throws Exception {
    GenericTestUtils.assumeInNativeProfile();
    Path file=new Path(ROOT_PATH,"testseqappendblockcompr.seq");
    fs.delete(file,true);
    Option compressOption=Writer.compression(CompressionType.RECORD,new GzipCodec());
    Writer writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),compressOption);
    writer.append(1L,"one");
    writer.append(2L,"two");
    writer.close();
    verify2Values(file);
    writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),compressOption);
    writer.append(3L,"three");
    writer.append(4L,"four");
    writer.close();
    verifyAll4Values(file);
    fs.deleteOnExit(file);
  }
  @Test(timeout=30000) public void testAppendBlockCompression() throws Exception {
    GenericTestUtils.assumeInNativeProfile();
    Path file=new Path(ROOT_PATH,"testseqappendblockcompr.seq");
    fs.delete(file,true);
    Option compressOption=Writer.compression(CompressionType.BLOCK,new GzipCodec());
    Writer writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),compressOption);
    writer.append(1L,"one");
    writer.append(2L,"two");
    writer.close();
    verify2Values(file);
    writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),compressOption);
    writer.append(3L,"three");
    writer.append(4L,"four");
    writer.close();
    verifyAll4Values(file);
    try {
      writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true));
      writer.close();
      fail("Expected IllegalArgumentException for compression options");
    }
 catch (    IllegalArgumentException IAE) {
    }
    try {
      Option wrongCompressOption=Writer.compression(CompressionType.RECORD,new GzipCodec());
      writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),wrongCompressOption);
      writer.close();
      fail("Expected IllegalArgumentException for compression options");
    }
 catch (    IllegalArgumentException IAE) {
    }
    try {
      Option wrongCompressOption=Writer.compression(CompressionType.BLOCK,new DefaultCodec());
      writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),wrongCompressOption);
      writer.close();
      fail("Expected IllegalArgumentException for compression options");
    }
 catch (    IllegalArgumentException IAE) {
    }
    fs.deleteOnExit(file);
  }
  @Test(timeout=30000) public void testAppendNoneCompression() throws Exception {
    Path file=new Path(ROOT_PATH,"testseqappendnonecompr.seq");
    fs.delete(file,true);
    Option compressOption=Writer.compression(CompressionType.NONE);
    Writer writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),compressOption);
    writer.append(1L,"one");
    writer.append(2L,"two");
    writer.close();
    verify2Values(file);
    writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),compressOption);
    writer.append(3L,"three");
    writer.append(4L,"four");
    writer.close();
    verifyAll4Values(file);
    try {
      writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true));
      writer.close();
      fail("Expected IllegalArgumentException for compression options");
    }
 catch (    IllegalArgumentException iae) {
    }
    try {
      Option wrongCompressOption=Writer.compression(CompressionType.RECORD,new GzipCodec());
      writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),wrongCompressOption);
      writer.close();
      fail("Expected IllegalArgumentException for compression options");
    }
 catch (    IllegalArgumentException iae) {
    }
    Option noneWithCodec=Writer.compression(CompressionType.NONE,new DefaultCodec());
    writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),noneWithCodec);
    writer.close();
    fs.deleteOnExit(file);
  }
  @Test(timeout=30000) public void testAppendSort() throws Exception {
    GenericTestUtils.assumeInNativeProfile();
    Path file=new Path(ROOT_PATH,"testseqappendSort.seq");
    fs.delete(file,true);
    Path sortedFile=new Path(ROOT_PATH,"testseqappendSort.seq.sort");
    fs.delete(sortedFile,true);
    SequenceFile.Sorter sorter=new SequenceFile.Sorter(fs,new JavaSerializationComparator<Long>(),Long.class,String.class,conf);
    Option compressOption=Writer.compression(CompressionType.BLOCK,new GzipCodec());
    Writer writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),compressOption);
    writer.append(2L,"two");
    writer.append(1L,"one");
    writer.close();
    writer=SequenceFile.createWriter(conf,SequenceFile.Writer.file(file),SequenceFile.Writer.keyClass(Long.class),SequenceFile.Writer.valueClass(String.class),SequenceFile.Writer.appendIfExists(true),compressOption);
    writer.append(4L,"four");
    writer.append(3L,"three");
    writer.close();
    sorter.sort(file,sortedFile);
    verifyAll4Values(sortedFile);
    fs.deleteOnExit(file);
    fs.deleteOnExit(sortedFile);
  }
  private void verify2Values(  Path file) throws IOException {
    Reader reader=new Reader(conf,Reader.file(file));
    assertEquals(1L,reader.next((Object)null));
    assertEquals("one",reader.getCurrentValue((Object)null));
    assertEquals(2L,reader.next((Object)null));
    assertEquals("two",reader.getCurrentValue((Object)null));
    assertNull(reader.next((Object)null));
    reader.close();
  }
  private void verifyAll4Values(  Path file) throws IOException {
    Reader reader=new Reader(conf,Reader.file(file));
    assertEquals(1L,reader.next((Object)null));
    assertEquals("one",reader.getCurrentValue((Object)null));
    assertEquals(2L,reader.next((Object)null));
    assertEquals("two",reader.getCurrentValue((Object)null));
    assertEquals(3L,reader.next((Object)null));
    assertEquals("three",reader.getCurrentValue((Object)null));
    assertEquals(4L,reader.next((Object)null));
    assertEquals("four",reader.getCurrentValue((Object)null));
    assertNull(reader.next((Object)null));
    reader.close();
  }
}
