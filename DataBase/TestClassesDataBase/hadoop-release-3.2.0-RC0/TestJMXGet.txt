/** 
 * Startup and checkpoint tests
 */
public class TestJMXGet {
  public static final String WRONG_METRIC_VALUE_ERROR_MSG="Unable to get the correct value for %s.";
  private Configuration config;
  private MiniDFSCluster cluster;
  static final long seed=0xAAAAEEFL;
  static final int blockSize=4096;
  static final int fileSize=8192;
  @Before public void setUp() throws Exception {
    config=new HdfsConfiguration();
  }
  /** 
 * clean up
 */
  @After public void tearDown() throws Exception {
    if (cluster != null) {
      if (cluster.isClusterUp()) {
        cluster.shutdown();
      }
      File data_dir=new File(cluster.getDataDirectory());
      if (data_dir.exists() && !FileUtil.fullyDelete(data_dir)) {
        throw new IOException("Could not delete hdfs directory in tearDown '" + data_dir + "'");
      }
      cluster=null;
    }
  }
  /** 
 * test JMX connection to NameNode..
 * @throws Exception 
 */
  @Test public void testNameNode() throws Exception {
    int numDatanodes=2;
    cluster=new MiniDFSCluster.Builder(config).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    DFSTestUtil.createFile(cluster.getFileSystem(),new Path("/test1"),fileSize,fileSize,blockSize,(short)2,seed);
    JMXGet jmx=new JMXGet();
    String serviceName="NameNode";
    jmx.setService(serviceName);
    jmx.init();
    assertTrue("error printAllValues",checkPrintAllValues(jmx));
    try {
      DFSTestUtil.waitForMetric(jmx,"NumLiveDataNodes",numDatanodes);
    }
 catch (    TimeoutException e) {
      assertEquals(String.format(WRONG_METRIC_VALUE_ERROR_MSG,"NumLiveDataNodes"),numDatanodes,Integer.parseInt(jmx.getValue("NumLiveDataNodes")));
    }
    assertGauge("CorruptBlocks",Long.parseLong(jmx.getValue("CorruptBlocks")),getMetrics("FSNamesystem"));
    cluster.shutdown();
    MBeanServerConnection mbsc=ManagementFactory.getPlatformMBeanServer();
    ObjectName query=new ObjectName("Hadoop:service=" + serviceName + ",*");
    Set<ObjectName> names=mbsc.queryNames(query,null);
    assertTrue("No beans should be registered for " + serviceName,names.isEmpty());
  }
  private static boolean checkPrintAllValues(  JMXGet jmx) throws Exception {
    int size=0;
    byte[] bytes=null;
    String pattern="List of all the available keys:";
    PipedOutputStream pipeOut=new PipedOutputStream();
    PipedInputStream pipeIn=new PipedInputStream(pipeOut,1024 * 1024);
    PrintStream oldErr=System.err;
    System.setErr(new PrintStream(pipeOut));
    try {
      jmx.printAllValues();
      if ((size=pipeIn.available()) != 0) {
        bytes=new byte[size];
        pipeIn.read(bytes,0,bytes.length);
      }
      pipeOut.close();
      pipeIn.close();
    }
  finally {
      System.setErr(oldErr);
    }
    return bytes != null ? new String(bytes).contains(pattern) : false;
  }
  /** 
 * test JMX connection to DataNode..
 * @throws Exception 
 */
  @Test public void testDataNode() throws Exception {
    int numDatanodes=2;
    cluster=new MiniDFSCluster.Builder(config).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    DFSTestUtil.createFile(cluster.getFileSystem(),new Path("/test"),fileSize,fileSize,blockSize,(short)2,seed);
    JMXGet jmx=new JMXGet();
    String serviceName="DataNode";
    jmx.setService(serviceName);
    jmx.init();
    try {
      DFSTestUtil.waitForMetric(jmx,"BytesWritten",fileSize);
    }
 catch (    TimeoutException e) {
      assertEquals(String.format(WRONG_METRIC_VALUE_ERROR_MSG,"BytesWritten"),fileSize,Integer.parseInt(jmx.getValue("BytesWritten")));
    }
    cluster.shutdown();
    MBeanServerConnection mbsc=ManagementFactory.getPlatformMBeanServer();
    ObjectName query=new ObjectName("Hadoop:service=" + serviceName + ",*");
    Set<ObjectName> names=mbsc.queryNames(query,null);
    assertTrue("No beans should be registered for " + serviceName,names.isEmpty());
  }
}
