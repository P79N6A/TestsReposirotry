/** 
 * Validate system behavior when the am-scheduling logic 'blacklists' a node for an application because of AM failures.
 */
public class TestNodeBlacklistingOnAMFailures {
  @Before public void setup(){
    QueueMetrics.clearQueueMetrics();
    DefaultMetricsSystem.setMiniClusterMode(true);
  }
  @Test(timeout=100000) public void testNodeBlacklistingOnAMFailure() throws Exception {
    YarnConfiguration conf=new YarnConfiguration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER,CapacityScheduler.class,ResourceScheduler.class);
    conf.setBoolean(YarnConfiguration.AM_SCHEDULING_NODE_BLACKLISTING_ENABLED,true);
    MockRM rm=startRM(conf);
    CapacityScheduler scheduler=(CapacityScheduler)rm.getResourceScheduler();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm.getResourceTrackerService());
    nm1.registerNode();
    MockNM nm2=new MockNM("127.0.0.2:2345",8000,rm.getResourceTrackerService());
    nm2.registerNode();
    RMApp app=rm.submitApp(200);
    MockAM am1=MockRM.launchAndRegisterAM(app,rm,nm1);
    ContainerId amContainerId=ContainerId.newContainerId(am1.getApplicationAttemptId(),1);
    RMContainer rmContainer=scheduler.getRMContainer(amContainerId);
    NodeId nodeWhereAMRan=rmContainer.getAllocatedNode();
    MockNM currentNode, otherNode;
    if (nodeWhereAMRan.equals(nm1.getNodeId())) {
      currentNode=nm1;
      otherNode=nm2;
    }
 else {
      currentNode=nm2;
      otherNode=nm1;
    }
    MockNM nm3=new MockNM("127.0.0.3:2345",8000,rm.getResourceTrackerService());
    nm3.registerNode();
    MockNM nm4=new MockNM("127.0.0.4:2345",8000,rm.getResourceTrackerService());
    nm4.registerNode();
    MockNM nm5=new MockNM("127.0.0.5:2345",8000,rm.getResourceTrackerService());
    nm5.registerNode();
    makeAMContainerExit(rm,amContainerId,currentNode,ContainerExitStatus.INVALID);
    RMAppAttempt attempt=MockRM.waitForAttemptScheduled(app,rm);
    System.out.println("New AppAttempt launched " + attempt.getAppAttemptId());
    for (int i=0; i <= 2; i++) {
      currentNode.nodeHeartbeat(true);
      rm.drainEvents();
      Assert.assertEquals("AppAttemptState should still be SCHEDULED if currentNode is " + "blacklisted correctly",RMAppAttemptState.SCHEDULED,attempt.getAppAttemptState());
    }
    otherNode.nodeHeartbeat(true);
    rm.drainEvents();
    MockRM.waitForState(attempt,RMAppAttemptState.ALLOCATED,20000);
    MockAM am2=rm.sendAMLaunched(attempt.getAppAttemptId());
    rm.waitForState(attempt.getAppAttemptId(),RMAppAttemptState.LAUNCHED);
    amContainerId=ContainerId.newContainerId(am2.getApplicationAttemptId(),1);
    rmContainer=scheduler.getRMContainer(amContainerId);
    nodeWhereAMRan=rmContainer.getAllocatedNode();
    Assert.assertEquals("After blacklisting, AM should have run on the other node",otherNode.getNodeId(),nodeWhereAMRan);
    am2.registerAppAttempt();
    rm.waitForState(app.getApplicationId(),RMAppState.RUNNING);
    List<Container> allocatedContainers=TestAMRestart.allocateContainers(currentNode,am2,1);
    Assert.assertEquals("Even though AM is blacklisted from the node, application can " + "still allocate non-AM containers there",currentNode.getNodeId(),allocatedContainers.get(0).getNodeId());
  }
  @Test(timeout=100000) public void testNodeBlacklistingOnAMFailureStrictNodeLocality() throws Exception {
    YarnConfiguration conf=new YarnConfiguration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER,CapacityScheduler.class,ResourceScheduler.class);
    conf.setBoolean(YarnConfiguration.AM_SCHEDULING_NODE_BLACKLISTING_ENABLED,true);
    MockRM rm=startRM(conf);
    CapacityScheduler scheduler=(CapacityScheduler)rm.getResourceScheduler();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm.getResourceTrackerService());
    nm1.registerNode();
    MockNM nm2=new MockNM("127.0.0.2:2345",8000,rm.getResourceTrackerService());
    nm2.registerNode();
    MockNM nm3=new MockNM("127.0.0.3:2345",8000,rm.getResourceTrackerService());
    nm3.registerNode();
    MockNM nm4=new MockNM("127.0.0.4:2345",8000,rm.getResourceTrackerService());
    nm4.registerNode();
    MockNM nm5=new MockNM("127.0.0.5:2345",8000,rm.getResourceTrackerService());
    nm5.registerNode();
    List<ResourceRequest> reqs=new ArrayList<>();
    ResourceRequest nodeReq=ResourceRequest.newInstance(Priority.newInstance(0),nm2.getNodeId().getHost(),Resource.newInstance(200,1),1,true);
    ResourceRequest rackReq=ResourceRequest.newInstance(Priority.newInstance(0),"/default-rack",Resource.newInstance(200,1),1,false);
    ResourceRequest anyReq=ResourceRequest.newInstance(Priority.newInstance(0),ResourceRequest.ANY,Resource.newInstance(200,1),1,false);
    reqs.add(anyReq);
    reqs.add(rackReq);
    reqs.add(nodeReq);
    RMApp app=rm.submitApp(reqs);
    MockAM am1=MockRM.launchAndRegisterAM(app,rm,nm2);
    ContainerId amContainerId=ContainerId.newContainerId(am1.getApplicationAttemptId(),1);
    RMContainer rmContainer=scheduler.getRMContainer(amContainerId);
    NodeId nodeWhereAMRan=rmContainer.getAllocatedNode();
    Assert.assertEquals(nm2.getNodeId(),nodeWhereAMRan);
    makeAMContainerExit(rm,amContainerId,nm2,ContainerExitStatus.INVALID);
    RMAppAttempt attempt=MockRM.waitForAttemptScheduled(app,rm);
    System.out.println("New AppAttempt launched " + attempt.getAppAttemptId());
    nm2.nodeHeartbeat(true);
    rm.drainEvents();
    MockRM.waitForState(attempt,RMAppAttemptState.ALLOCATED,20000);
    MockAM am2=rm.sendAMLaunched(attempt.getAppAttemptId());
    rm.waitForState(attempt.getAppAttemptId(),RMAppAttemptState.LAUNCHED);
    amContainerId=ContainerId.newContainerId(am2.getApplicationAttemptId(),1);
    rmContainer=scheduler.getRMContainer(amContainerId);
    nodeWhereAMRan=rmContainer.getAllocatedNode();
    System.out.println("AM ran on " + nodeWhereAMRan);
    Assert.assertEquals(nm2.getNodeId(),nodeWhereAMRan);
    am2.registerAppAttempt();
    rm.waitForState(app.getApplicationId(),RMAppState.RUNNING);
  }
  @Test(timeout=100000) public void testNodeBlacklistingOnAMFailureRelaxedNodeLocality() throws Exception {
    YarnConfiguration conf=new YarnConfiguration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER,CapacityScheduler.class,ResourceScheduler.class);
    conf.setBoolean(YarnConfiguration.AM_SCHEDULING_NODE_BLACKLISTING_ENABLED,true);
    MockRM rm=startRM(conf);
    CapacityScheduler scheduler=(CapacityScheduler)rm.getResourceScheduler();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm.getResourceTrackerService());
    nm1.registerNode();
    MockNM nm2=new MockNM("127.0.0.2:2345",8000,rm.getResourceTrackerService());
    nm2.registerNode();
    MockNM nm3=new MockNM("127.0.0.3:2345",8000,rm.getResourceTrackerService());
    nm3.registerNode();
    MockNM nm4=new MockNM("127.0.0.4:2345",8000,rm.getResourceTrackerService());
    nm4.registerNode();
    MockNM nm5=new MockNM("127.0.0.5:2345",8000,rm.getResourceTrackerService());
    nm5.registerNode();
    List<ResourceRequest> reqs=new ArrayList<>();
    ResourceRequest nodeReq=ResourceRequest.newInstance(Priority.newInstance(0),nm2.getNodeId().getHost(),Resource.newInstance(200,1),1,true);
    ResourceRequest rackReq=ResourceRequest.newInstance(Priority.newInstance(0),"/default-rack",Resource.newInstance(200,1),1,true);
    ResourceRequest anyReq=ResourceRequest.newInstance(Priority.newInstance(0),ResourceRequest.ANY,Resource.newInstance(200,1),1,true);
    reqs.add(anyReq);
    reqs.add(rackReq);
    reqs.add(nodeReq);
    RMApp app=rm.submitApp(reqs);
    MockAM am1=MockRM.launchAndRegisterAM(app,rm,nm2);
    ContainerId amContainerId=ContainerId.newContainerId(am1.getApplicationAttemptId(),1);
    RMContainer rmContainer=scheduler.getRMContainer(amContainerId);
    NodeId nodeWhereAMRan=rmContainer.getAllocatedNode();
    Assert.assertEquals(nm2.getNodeId(),nodeWhereAMRan);
    makeAMContainerExit(rm,amContainerId,nm2,ContainerExitStatus.INVALID);
    RMAppAttempt attempt=MockRM.waitForAttemptScheduled(app,rm);
    System.out.println("New AppAttempt launched " + attempt.getAppAttemptId());
    nm2.nodeHeartbeat(true);
    nm1.nodeHeartbeat(true);
    nm3.nodeHeartbeat(true);
    nm4.nodeHeartbeat(true);
    nm5.nodeHeartbeat(true);
    rm.drainEvents();
    MockRM.waitForState(attempt,RMAppAttemptState.ALLOCATED,20000);
    MockAM am2=rm.sendAMLaunched(attempt.getAppAttemptId());
    rm.waitForState(attempt.getAppAttemptId(),RMAppAttemptState.LAUNCHED);
    amContainerId=ContainerId.newContainerId(am2.getApplicationAttemptId(),1);
    rmContainer=scheduler.getRMContainer(amContainerId);
    nodeWhereAMRan=rmContainer.getAllocatedNode();
    System.out.println("AM ran on " + nodeWhereAMRan);
    Assert.assertNotEquals(nm2.getNodeId(),nodeWhereAMRan);
    am2.registerAppAttempt();
    rm.waitForState(app.getApplicationId(),RMAppState.RUNNING);
  }
  @Test(timeout=100000) public void testNoBlacklistingForNonSystemErrors() throws Exception {
    YarnConfiguration conf=new YarnConfiguration();
    conf.setBoolean(YarnConfiguration.AM_SCHEDULING_NODE_BLACKLISTING_ENABLED,true);
    conf.setFloat(YarnConfiguration.AM_SCHEDULING_NODE_BLACKLISTING_DISABLE_THRESHOLD,1.5f);
    conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,100);
    MockRM rm=startRM(conf);
    MockNM node=new MockNM("127.0.0.1:1234",8000,rm.getResourceTrackerService());
    node.registerNode();
    RMApp app=rm.submitApp(200);
    ApplicationId appId=app.getApplicationId();
    int numAppAttempts=1;
    RMAppAttempt attempt=MockRM.waitForAttemptScheduled(app,rm);
    node.nodeHeartbeat(true);
    ((AbstractYarnScheduler)rm.getResourceScheduler()).update();
    rm.drainEvents();
    MockRM.waitForState(attempt,RMAppAttemptState.ALLOCATED,20000);
    rm.sendAMLaunched(attempt.getAppAttemptId());
    rm.waitForState(attempt.getAppAttemptId(),RMAppAttemptState.LAUNCHED);
    ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,numAppAttempts);
    ContainerId amContainerId=ContainerId.newContainerId(appAttemptId,1);
    for (    int containerExitStatus : new int[]{ContainerExitStatus.PREEMPTED,ContainerExitStatus.KILLED_BY_RESOURCEMANAGER,ContainerExitStatus.KILLED_AFTER_APP_COMPLETION,ContainerExitStatus.ABORTED,ContainerExitStatus.DISKS_FAILED,ContainerExitStatus.KILLED_EXCEEDED_VMEM,ContainerExitStatus.KILLED_EXCEEDED_PMEM}) {
      makeAMContainerExit(rm,amContainerId,node,containerExitStatus);
      attempt=MockRM.waitForAttemptScheduled(app,rm);
      System.out.println("New AppAttempt launched " + attempt.getAppAttemptId());
      node.nodeHeartbeat(true);
      ((AbstractYarnScheduler)rm.getResourceScheduler()).update();
      rm.drainEvents();
      MockRM.waitForState(attempt,RMAppAttemptState.ALLOCATED,20000);
      rm.sendAMLaunched(attempt.getAppAttemptId());
      rm.waitForState(attempt.getAppAttemptId(),RMAppAttemptState.LAUNCHED);
      numAppAttempts++;
      appAttemptId=ApplicationAttemptId.newInstance(appId,numAppAttempts);
      amContainerId=ContainerId.newContainerId(appAttemptId,1);
      rm.waitForState(node,amContainerId,RMContainerState.ACQUIRED);
    }
  }
  private void makeAMContainerExit(  MockRM rm,  ContainerId amContainer,  MockNM node,  int exitStatus) throws Exception, InterruptedException {
    ContainerStatus containerStatus=BuilderUtils.newContainerStatus(amContainer,ContainerState.COMPLETE,"",exitStatus,Resources.createResource(200));
    node.containerStatus(containerStatus);
    ApplicationAttemptId amAttemptID=amContainer.getApplicationAttemptId();
    rm.waitForState(amAttemptID,RMAppAttemptState.FAILED);
    rm.waitForState(amAttemptID.getApplicationId(),RMAppState.ACCEPTED);
  }
  private MockRM startRM(  YarnConfiguration conf){
    conf.set(YarnConfiguration.RECOVERY_ENABLED,"true");
    conf.set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    MockRM rm=new MockRM(conf);
    rm.start();
    return rm;
  }
}
