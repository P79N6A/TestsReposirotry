private class FakeOutputStream extends OutputStream implements Syncable, CanSetDropBehind, StreamCapabilities {
  private final byte[] oneByteBuf=new byte[1];
  private final DataOutputBuffer out;
  private boolean closed;
  public FakeOutputStream(  DataOutputBuffer out){
    this.out=out;
  }
  @Override public void write(  byte b[],  int off,  int len) throws IOException {
    if (b == null) {
      throw new NullPointerException();
    }
 else     if (off < 0 || len < 0 || len > b.length - off) {
      throw new IndexOutOfBoundsException();
    }
 else     if (len == 0) {
      return;
    }
    checkStream();
    out.write(b,off,len);
  }
  @Override public void flush() throws IOException {
    checkStream();
    out.flush();
  }
  @Override public void close() throws IOException {
    if (closed) {
      return;
    }
    out.close();
    closed=true;
  }
  @Override public void write(  int b) throws IOException {
    oneByteBuf[0]=(byte)(b & 0xff);
    write(oneByteBuf,0,oneByteBuf.length);
  }
  @Override public void setDropBehind(  Boolean dropCache) throws IOException, UnsupportedOperationException {
  }
  @Override public void hflush() throws IOException {
    checkStream();
    flush();
  }
  @Override public void hsync() throws IOException {
    checkStream();
    flush();
  }
  @Override public boolean hasCapability(  String capability){
switch (capability.toLowerCase()) {
case StreamCapabilities.HFLUSH:
case StreamCapabilities.HSYNC:
case StreamCapabilities.DROPBEHIND:
      return true;
default :
    return false;
}
}
private void checkStream() throws IOException {
if (closed) {
  throw new IOException("Stream is closed!");
}
}
}
