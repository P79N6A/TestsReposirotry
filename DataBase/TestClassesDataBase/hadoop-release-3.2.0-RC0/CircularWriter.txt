private static class CircularWriter extends RepeatingTestThread {
  private final int maxLength;
  private final Path dir;
  private final FileSystem fs;
  private int currentListIndex=0;
  private CountDownLatch done=new CountDownLatch(1);
  public CircularWriter(  TestContext context,  int listLength,  FileSystem fs,  Path parentDir){
    super(context);
    this.fs=fs;
    this.maxLength=listLength;
    this.dir=parentDir;
  }
  @Override public String toString(){
    StringBuilder builder=new StringBuilder("Circular Writer:\n");
    builder.append("\t directory: " + dir + "\n");
    builder.append("\t target length: " + maxLength + "\n");
    builder.append("\t current item: " + currentListIndex + "\n");
    builder.append("\t done: " + (done.getCount() == 0) + "\n");
    return builder.toString();
  }
  @Override public void doAnAction() throws Exception {
    if (currentListIndex == maxLength) {
      checkList();
      this.stopTestThread();
      done.countDown();
    }
 else {
      writeList();
    }
  }
  /** 
 * Make sure we can traverse the entire linked list
 */
  private void checkList() throws IOException {
    for (int i=0; i < maxLength; i++) {
      Path nextFile=getNextFile(i);
      if (!fs.exists(nextFile)) {
        throw new RuntimeException("Next file " + nextFile + " for list does not exist!");
      }
      FSDataInputStream in=fs.open(nextFile);
      nextFile=getNextFile(in.read());
      in.close();
    }
  }
  private void cleanup() throws IOException {
    if (!fs.delete(dir,true)) {
      throw new RuntimeException("Didn't correctly delete " + dir);
    }
    if (!fs.mkdirs(dir)) {
      throw new RuntimeException("Didn't correctly make directory " + dir);
    }
  }
  private void writeList() throws IOException {
    Path nextPath=getNextFile(currentListIndex++);
    LOG.info("Writing next file: " + nextPath);
    FSDataOutputStream file=fs.create(nextPath);
    file.write(currentListIndex);
    file.close();
  }
  private Path getNextFile(  int i){
    return new Path(dir,Integer.toString(i));
  }
}
