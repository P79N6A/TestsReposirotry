/** 
 * Test behaviors of single constraint app placement allocator.
 */
public class TestSingleConstraintAppPlacementAllocator {
  private AppSchedulingInfo appSchedulingInfo;
  private AllocationTagsManager spyAllocationTagsManager;
  private RMContext rmContext;
  private SchedulerRequestKey schedulerRequestKey;
  private SingleConstraintAppPlacementAllocator allocator;
  @Before public void setup() throws Exception {
    appSchedulingInfo=mock(AppSchedulingInfo.class);
    when(appSchedulingInfo.getApplicationId()).thenReturn(TestUtils.getMockApplicationId(1));
    when(appSchedulingInfo.getApplicationAttemptId()).thenReturn(TestUtils.getMockApplicationAttemptId(1,1));
    rmContext=TestUtils.getMockRMContext();
    AllocationTagsManager allocationTagsManager=new AllocationTagsManager(rmContext);
    PlacementConstraintManager placementConstraintManager=new MemoryPlacementConstraintManager();
    spyAllocationTagsManager=spy(allocationTagsManager);
    schedulerRequestKey=new SchedulerRequestKey(Priority.newInstance(1),2L,TestUtils.getMockContainerId(1,1));
    rmContext.setAllocationTagsManager(spyAllocationTagsManager);
    rmContext.setPlacementConstraintManager(placementConstraintManager);
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
  }
  private void assertValidSchedulingRequest(  SchedulingRequest schedulingRequest){
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
  }
  private void assertInvalidSchedulingRequest(  SchedulingRequest schedulingRequest,  boolean recreateAllocator){
    try {
      if (recreateAllocator) {
        allocator=new SingleConstraintAppPlacementAllocator();
        allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
      }
      allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
    }
 catch (    SchedulerInvalidResoureRequestException e) {
      return;
    }
    Assert.fail("Expect failure for schedulingRequest=" + schedulingRequest.toString());
  }
  @Test public void testSchedulingRequestValidation(){
    assertValidSchedulingRequest(SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build());
    Assert.assertEquals("",allocator.getTargetNodePartition());
    assertValidSchedulingRequest(SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer"),PlacementConstraints.PlacementTargets.nodePartition("x")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build());
    Assert.assertEquals("x",allocator.getTargetNodePartition());
    assertValidSchedulingRequest(SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build());
    Assert.assertEquals("",allocator.getTargetNodePartition());
    assertValidSchedulingRequest(SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build());
    Assert.assertEquals("",allocator.getTargetNodePartition());
    assertInvalidSchedulingRequest(SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer")).build()).build(),true);
    assertInvalidSchedulingRequest(SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE).build()).build(),true);
    assertInvalidSchedulingRequest(SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build(),true);
  }
  @Test public void testSchedulingRequestUpdate(){
    SchedulingRequest schedulingRequest=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
    schedulingRequest.getResourceSizing().setNumAllocations(10);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
    schedulingRequest.getResourceSizing().setResources(Resource.newInstance(2048,1));
    assertInvalidSchedulingRequest(schedulingRequest,false);
    schedulingRequest=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetCardinality(PlacementConstraints.NODE,0,1,PlacementConstraints.PlacementTargets.allocationTag("mapper"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    assertInvalidSchedulingRequest(schedulingRequest,false);
    int existingNumAllocations=allocator.getSchedulingRequest().getResourceSizing().getNumAllocations();
    schedulingRequest=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,true);
    Assert.assertEquals(existingNumAllocations + 1,allocator.getSchedulingRequest().getResourceSizing().getNumAllocations());
  }
  @Test public void testFunctionality() throws InvalidAllocationTagsQueryException {
    SchedulingRequest schedulingRequest=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
    allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNode("host1","/rack1",123,1024));
    verify(spyAllocationTagsManager,Mockito.times(1)).getNodeCardinalityByOp(eq(NodeId.fromString("host1:123")),any(AllocationTags.class),any(LongBinaryOperator.class));
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    schedulingRequest=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNotIn(PlacementConstraints.NODE,PlacementConstraints.PlacementTargets.allocationTag("mapper","reducer"),PlacementConstraints.PlacementTargets.nodePartition("x")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
    allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNode("host1","/rack1",123,1024));
    verify(spyAllocationTagsManager,Mockito.atLeast(1)).getNodeCardinalityByOp(eq(NodeId.fromString("host1:123")),any(AllocationTags.class),any(LongBinaryOperator.class));
    SchedulerNode node1=mock(SchedulerNode.class);
    when(node1.getPartition()).thenReturn("x");
    when(node1.getNodeID()).thenReturn(NodeId.fromString("host1:123"));
    Assert.assertTrue(allocator.precheckNode(node1,SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY));
    SchedulerNode node2=mock(SchedulerNode.class);
    when(node1.getPartition()).thenReturn("");
    when(node1.getNodeID()).thenReturn(NodeId.fromString("host2:123"));
    Assert.assertFalse(allocator.precheckNode(node2,SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY));
  }
  @Test public void testNodeAttributesFunctionality(){
    SchedulingRequest schedulingRequest=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNodeAttribute(PlacementConstraints.NODE,NodeAttributeOpCode.EQ,PlacementConstraints.PlacementTargets.nodeAttribute("java","1.8"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest,false);
    Set<NodeAttribute> attributes=new HashSet<>();
    attributes.add(NodeAttribute.newInstance("java",NodeAttributeType.STRING,"1.8"));
    boolean result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertTrue("Allocation should be success for java=1.8",result);
    SchedulingRequest schedulingRequest2=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.targetNodeAttribute(PlacementConstraints.NODE,NodeAttributeOpCode.NE,PlacementConstraints.PlacementTargets.nodeAttribute("python","3"),PlacementConstraints.PlacementTargets.nodePartition("")).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest2,false);
    attributes=new HashSet<>();
    result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertTrue("Allocation should be success as python doesn't exist",result);
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest2,false);
    attributes=new HashSet<>();
    attributes.add(NodeAttribute.newInstance("python",NodeAttributeType.STRING,"2"));
    result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertTrue("Allocation should be success as python=3 doesn't exist in node",result);
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest2,false);
    attributes=new HashSet<>();
    attributes.add(NodeAttribute.newInstance("python",NodeAttributeType.STRING,"3"));
    result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertFalse("Allocation should fail as python=3 exist in node",result);
  }
  @Test public void testConjunctionNodeAttributesFunctionality(){
    SchedulingRequest schedulingRequest1=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.and(PlacementConstraints.targetNodeAttribute(PlacementConstraints.NODE,NodeAttributeOpCode.NE,PlacementConstraints.PlacementTargets.nodeAttribute("python","3")),PlacementConstraints.targetNodeAttribute(PlacementConstraints.NODE,NodeAttributeOpCode.EQ,PlacementConstraints.PlacementTargets.nodeAttribute("java","1.8"))).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest1,false);
    Set<NodeAttribute> attributes=new HashSet<>();
    attributes.add(NodeAttribute.newInstance("python",NodeAttributeType.STRING,"3"));
    attributes.add(NodeAttribute.newInstance("java",NodeAttributeType.STRING,"1.8"));
    boolean result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertFalse("Allocation should fail as python=3 exists in node",result);
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest1,false);
    attributes=new HashSet<>();
    attributes.add(NodeAttribute.newInstance("python",NodeAttributeType.STRING,"2"));
    attributes.add(NodeAttribute.newInstance("java",NodeAttributeType.STRING,"1.8"));
    result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertTrue("Allocation should be success as python=2 exists in node",result);
    SchedulingRequest schedulingRequest2=SchedulingRequest.newBuilder().executionType(ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED)).allocationRequestId(10L).priority(Priority.newInstance(1)).placementConstraintExpression(PlacementConstraints.or(PlacementConstraints.targetNodeAttribute(PlacementConstraints.NODE,NodeAttributeOpCode.NE,PlacementConstraints.PlacementTargets.nodeAttribute("python","3")),PlacementConstraints.targetNodeAttribute(PlacementConstraints.NODE,NodeAttributeOpCode.EQ,PlacementConstraints.PlacementTargets.nodeAttribute("java","1.8"))).build()).resourceSizing(ResourceSizing.newInstance(1,Resource.newInstance(1024,1))).build();
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest2,false);
    attributes=new HashSet<>();
    attributes.add(NodeAttribute.newInstance("python",NodeAttributeType.STRING,"3"));
    attributes.add(NodeAttribute.newInstance("java",NodeAttributeType.STRING,"1.8"));
    result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertTrue("Allocation should be success as java=1.8 exists in node",result);
    allocator=new SingleConstraintAppPlacementAllocator();
    allocator.initialize(appSchedulingInfo,schedulerRequestKey,rmContext);
    allocator.updatePendingAsk(schedulerRequestKey,schedulingRequest2,false);
    attributes=new HashSet<>();
    attributes.add(NodeAttribute.newInstance("python",NodeAttributeType.STRING,"3"));
    attributes.add(NodeAttribute.newInstance("java",NodeAttributeType.STRING,"1.7"));
    result=allocator.canAllocate(NodeType.NODE_LOCAL,TestUtils.getMockNodeWithAttributes("host1","/rack1",123,1024,attributes));
    Assert.assertFalse("Allocation should fail as java=1.8 doesnt exist in node",result);
  }
}
