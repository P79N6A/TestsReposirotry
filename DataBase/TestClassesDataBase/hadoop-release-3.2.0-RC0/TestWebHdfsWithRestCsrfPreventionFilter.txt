/** 
 * Tests use of the cross-site-request forgery (CSRF) prevention filter with WebHDFS.  This is a parameterized test that covers various combinations of CSRF protection enabled or disabled at the NameNode, the DataNode and the WebHDFS client.  If the server is configured with CSRF prevention, but the client is not, then protected operations are expected to fail.
 */
@RunWith(Parameterized.class) public class TestWebHdfsWithRestCsrfPreventionFilter {
  private static final Path FILE=new Path("/file");
  private final boolean nnRestCsrf;
  private final boolean dnRestCsrf;
  private final boolean clientRestCsrf;
  private MiniDFSCluster cluster;
  private FileSystem fs, webhdfs;
  @Rule public ExpectedException exception=ExpectedException.none();
  public TestWebHdfsWithRestCsrfPreventionFilter(  boolean nnRestCsrf,  boolean dnRestCsrf,  boolean clientRestCsrf){
    this.nnRestCsrf=nnRestCsrf;
    this.dnRestCsrf=dnRestCsrf;
    this.clientRestCsrf=clientRestCsrf;
  }
  @Parameters public static Iterable<Object[]> data(){
    return Arrays.asList(new Object[][]{{false,false,false},{true,true,true},{true,true,false},{true,false,true},{true,false,false},{false,true,true},{false,true,false},{false,false,true}});
  }
  @Before public void before() throws Exception {
    Configuration nnConf=new Configuration();
    nnConf.setBoolean(DFS_WEBHDFS_REST_CSRF_ENABLED_KEY,nnRestCsrf);
    nnConf.set(DFS_WEBHDFS_REST_CSRF_BROWSER_USERAGENTS_REGEX_KEY,".*");
    cluster=new MiniDFSCluster.Builder(nnConf).numDataNodes(0).build();
    Configuration dnConf=new Configuration(nnConf);
    dnConf.setBoolean(DFS_WEBHDFS_REST_CSRF_ENABLED_KEY,dnRestCsrf);
    cluster.startDataNodes(dnConf,1,true,null,null,null,null,false);
    cluster.waitActive();
    fs=cluster.getFileSystem();
    Configuration clientConf=new Configuration();
    clientConf.setBoolean(DFS_WEBHDFS_REST_CSRF_ENABLED_KEY,clientRestCsrf);
    InetSocketAddress addr=cluster.getNameNode().getHttpAddress();
    webhdfs=FileSystem.get(URI.create("webhdfs://" + NetUtils.getHostPortString(addr)),clientConf);
  }
  @After public void after(){
    IOUtils.closeStream(webhdfs);
    IOUtils.closeStream(fs);
    if (cluster != null) {
      cluster.shutdown();
    }
  }
  @Test public void testCreate() throws Exception {
    if ((nnRestCsrf || dnRestCsrf) && !clientRestCsrf) {
      expectException();
    }
    assertTrue(webhdfs.createNewFile(FILE));
  }
  @Test public void testDelete() throws Exception {
    DFSTestUtil.createFile(fs,FILE,1024,(short)1,0L);
    if (nnRestCsrf && !clientRestCsrf) {
      expectException();
    }
    assertTrue(webhdfs.delete(FILE,false));
  }
  @Test public void testGetFileStatus() throws Exception {
    assertNotNull(webhdfs.getFileStatus(new Path("/")));
  }
  @Test public void testTruncate() throws Exception {
    DFSTestUtil.createFile(fs,FILE,1024,(short)1,0L);
    if (nnRestCsrf && !clientRestCsrf) {
      expectException();
    }
    assertTrue(webhdfs.truncate(FILE,0L));
  }
  private void expectException(){
    exception.expect(IOException.class);
    exception.expectMessage("Missing Required Header");
  }
}
