/** 
 * Makes sure that standby doesn't do the unnecessary block management such as invalidate block, etc.
 */
public class TestStandbyBlockManagement {
  protected static final Logger LOG=LoggerFactory.getLogger(TestStandbyBlockManagement.class);
  private static final String TEST_FILE_DATA="hello world";
  private static final String TEST_FILE="/TestStandbyBlockManagement";
  private static final Path TEST_FILE_PATH=new Path(TEST_FILE);
static {
    DFSTestUtil.setNameNodeLogLevel(Level.ALL);
  }
  @Test(timeout=60000) public void testInvalidateBlock() throws Exception {
    Configuration conf=new Configuration();
    HAUtil.setAllowStandbyReads(conf,true);
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
    MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(3).build();
    try {
      cluster.waitActive();
      cluster.transitionToActive(0);
      NameNode nn1=cluster.getNameNode(0);
      NameNode nn2=cluster.getNameNode(1);
      FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
      Thread.sleep(1000);
      LOG.info("==================================");
      DFSTestUtil.writeFile(fs,TEST_FILE_PATH,TEST_FILE_DATA);
      nn1.getRpcServer().rollEditLog();
      LOG.info("==================================");
      fs.delete(TEST_FILE_PATH,false);
      BlockManagerTestUtil.computeAllPendingWork(nn1.getNamesystem().getBlockManager());
      nn1.getRpcServer().rollEditLog();
      assertEquals(0,nn2.getNamesystem().getBlockManager().getPendingDeletionBlocksCount());
      cluster.triggerHeartbeats();
      cluster.triggerBlockReports();
      assertEquals(0,nn2.getNamesystem().getBlockManager().getPendingDeletionBlocksCount());
    }
  finally {
      cluster.shutdown();
    }
  }
}
