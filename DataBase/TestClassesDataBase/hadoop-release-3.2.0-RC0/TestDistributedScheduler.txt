/** 
 * Test cases for  {@link DistributedScheduler}.
 */
public class TestDistributedScheduler {
  @Test public void testDistributedScheduler() throws Exception {
    Configuration conf=new Configuration();
    DistributedScheduler distributedScheduler=new DistributedScheduler();
    RequestInterceptor finalReqIntcptr=setup(conf,distributedScheduler);
    registerAM(distributedScheduler,finalReqIntcptr,Arrays.asList(RemoteNode.newInstance(NodeId.newInstance("a",1),"http://a:1"),RemoteNode.newInstance(NodeId.newInstance("b",2),"http://b:2"),RemoteNode.newInstance(NodeId.newInstance("c",3),"http://c:3"),RemoteNode.newInstance(NodeId.newInstance("d",4),"http://d:4")));
    final AtomicBoolean flipFlag=new AtomicBoolean(true);
    Mockito.when(finalReqIntcptr.allocateForDistributedScheduling(Mockito.any(DistributedSchedulingAllocateRequest.class))).thenAnswer(new Answer<DistributedSchedulingAllocateResponse>(){
      @Override public DistributedSchedulingAllocateResponse answer(      InvocationOnMock invocationOnMock) throws Throwable {
        flipFlag.set(!flipFlag.get());
        if (flipFlag.get()) {
          return createAllocateResponse(Arrays.asList(RemoteNode.newInstance(NodeId.newInstance("c",3),"http://c:3"),RemoteNode.newInstance(NodeId.newInstance("d",4),"http://d:4"),RemoteNode.newInstance(NodeId.newInstance("e",5),"http://e:5"),RemoteNode.newInstance(NodeId.newInstance("f",6),"http://f:6")));
        }
 else {
          return createAllocateResponse(Arrays.asList(RemoteNode.newInstance(NodeId.newInstance("f",6),"http://f:6"),RemoteNode.newInstance(NodeId.newInstance("e",5),"http://e:5"),RemoteNode.newInstance(NodeId.newInstance("d",4),"http://d:4"),RemoteNode.newInstance(NodeId.newInstance("c",3),"http://c:3")));
        }
      }
    }
);
    AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
    ResourceRequest guaranteedReq=createResourceRequest(ExecutionType.GUARANTEED,5,"*");
    ResourceRequest opportunisticReq=createResourceRequest(ExecutionType.OPPORTUNISTIC,4,"*");
    allocateRequest.setAskList(Arrays.asList(guaranteedReq,opportunisticReq));
    AllocateResponse allocateResponse=distributedScheduler.allocate(allocateRequest);
    Assert.assertEquals(4,allocateResponse.getAllocatedContainers().size());
    Map<NodeId,List<ContainerId>> allocs=mapAllocs(allocateResponse,4);
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("a",1)).size());
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("b",2)).size());
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("c",3)).size());
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("d",4)).size());
    Assert.assertNull(allocs.get(NodeId.newInstance("e",5)));
    Assert.assertNull(allocs.get(NodeId.newInstance("f",6)));
    allocateRequest=Records.newRecord(AllocateRequest.class);
    opportunisticReq=createResourceRequest(ExecutionType.OPPORTUNISTIC,4,"*");
    allocateRequest.setAskList(Arrays.asList(guaranteedReq,opportunisticReq));
    allocateResponse=distributedScheduler.allocate(allocateRequest);
    Assert.assertEquals(4,allocateResponse.getAllocatedContainers().size());
    allocs=mapAllocs(allocateResponse,4);
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("c",3)).size());
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("d",4)).size());
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("e",5)).size());
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("f",6)).size());
    Assert.assertNull(allocs.get(NodeId.newInstance("a",1)));
    Assert.assertNull(allocs.get(NodeId.newInstance("b",2)));
    allocateRequest=Records.newRecord(AllocateRequest.class);
    opportunisticReq=createResourceRequest(ExecutionType.OPPORTUNISTIC,1,"*");
    allocateRequest.setAskList(Arrays.asList(guaranteedReq,opportunisticReq));
    allocateResponse=distributedScheduler.allocate(allocateRequest);
    allocs=mapAllocs(allocateResponse,1);
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("c",3)).size());
    allocateRequest=Records.newRecord(AllocateRequest.class);
    opportunisticReq=createResourceRequest(ExecutionType.OPPORTUNISTIC,1,"*");
    allocateRequest.setAskList(Arrays.asList(guaranteedReq,opportunisticReq));
    allocateResponse=distributedScheduler.allocate(allocateRequest);
    allocs=mapAllocs(allocateResponse,1);
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("f",6)).size());
    allocateRequest=Records.newRecord(AllocateRequest.class);
    opportunisticReq=createResourceRequest(ExecutionType.OPPORTUNISTIC,1,"*");
    allocateRequest.setAskList(Arrays.asList(guaranteedReq,opportunisticReq));
    allocateResponse=distributedScheduler.allocate(allocateRequest);
    allocs=mapAllocs(allocateResponse,1);
    Assert.assertEquals(1,allocs.get(NodeId.newInstance("c",3)).size());
  }
  private void registerAM(  DistributedScheduler distributedScheduler,  RequestInterceptor finalReqIntcptr,  List<RemoteNode> nodeList) throws Exception {
    RegisterDistributedSchedulingAMResponse distSchedRegisterResponse=Records.newRecord(RegisterDistributedSchedulingAMResponse.class);
    distSchedRegisterResponse.setRegisterResponse(Records.newRecord(RegisterApplicationMasterResponse.class));
    distSchedRegisterResponse.setContainerTokenExpiryInterval(12345);
    distSchedRegisterResponse.setContainerIdStart(0);
    distSchedRegisterResponse.setMaxContainerResource(Resource.newInstance(1024,4));
    distSchedRegisterResponse.setMinContainerResource(Resource.newInstance(512,2));
    distSchedRegisterResponse.setNodesForScheduling(nodeList);
    Mockito.when(finalReqIntcptr.registerApplicationMasterForDistributedScheduling(Mockito.any(RegisterApplicationMasterRequest.class))).thenReturn(distSchedRegisterResponse);
    distributedScheduler.registerApplicationMaster(Records.newRecord(RegisterApplicationMasterRequest.class));
  }
  private RequestInterceptor setup(  Configuration conf,  DistributedScheduler distributedScheduler){
    NodeStatusUpdater nodeStatusUpdater=Mockito.mock(NodeStatusUpdater.class);
    Mockito.when(nodeStatusUpdater.getRMIdentifier()).thenReturn(12345l);
    NMContainerTokenSecretManager nmContainerTokenSecretManager=new NMContainerTokenSecretManager(conf);
    MasterKey mKey=new MasterKey(){
      @Override public int getKeyId(){
        return 1;
      }
      @Override public void setKeyId(      int keyId){
      }
      @Override public ByteBuffer getBytes(){
        return ByteBuffer.allocate(8);
      }
      @Override public void setBytes(      ByteBuffer bytes){
      }
    }
;
    nmContainerTokenSecretManager.setMasterKey(mKey);
    OpportunisticContainerAllocator containerAllocator=new OpportunisticContainerAllocator(nmContainerTokenSecretManager);
    NMTokenSecretManagerInNM nmTokenSecretManagerInNM=new NMTokenSecretManagerInNM();
    nmTokenSecretManagerInNM.setMasterKey(mKey);
    distributedScheduler.initLocal(1234,ApplicationAttemptId.newInstance(ApplicationId.newInstance(1,1),1),containerAllocator,nmTokenSecretManagerInNM,"test");
    RequestInterceptor finalReqIntcptr=Mockito.mock(RequestInterceptor.class);
    distributedScheduler.setNextInterceptor(finalReqIntcptr);
    return finalReqIntcptr;
  }
  private ResourceRequest createResourceRequest(  ExecutionType execType,  int numContainers,  String resourceName){
    ResourceRequest opportunisticReq=Records.newRecord(ResourceRequest.class);
    opportunisticReq.setExecutionTypeRequest(ExecutionTypeRequest.newInstance(execType,true));
    opportunisticReq.setNumContainers(numContainers);
    opportunisticReq.setCapability(Resource.newInstance(1024,4));
    opportunisticReq.setPriority(Priority.newInstance(100));
    opportunisticReq.setRelaxLocality(true);
    opportunisticReq.setResourceName(resourceName);
    return opportunisticReq;
  }
  private DistributedSchedulingAllocateResponse createAllocateResponse(  List<RemoteNode> nodes){
    DistributedSchedulingAllocateResponse distSchedAllocateResponse=Records.newRecord(DistributedSchedulingAllocateResponse.class);
    distSchedAllocateResponse.setAllocateResponse(Records.newRecord(AllocateResponse.class));
    distSchedAllocateResponse.setNodesForScheduling(nodes);
    return distSchedAllocateResponse;
  }
  private Map<NodeId,List<ContainerId>> mapAllocs(  AllocateResponse allocateResponse,  int expectedSize) throws Exception {
    Assert.assertEquals(expectedSize,allocateResponse.getAllocatedContainers().size());
    Map<NodeId,List<ContainerId>> allocs=new HashMap<>();
    for (    Container c : allocateResponse.getAllocatedContainers()) {
      ContainerTokenIdentifier cTokId=BuilderUtils.newContainerTokenIdentifier(c.getContainerToken());
      Assert.assertEquals(c.getNodeId().getHost() + ":" + c.getNodeId().getPort(),cTokId.getNmHostAddress());
      List<ContainerId> cIds=allocs.get(c.getNodeId());
      if (cIds == null) {
        cIds=new ArrayList<>();
        allocs.put(c.getNodeId(),cIds);
      }
      cIds.add(c.getId());
    }
    return allocs;
  }
}
