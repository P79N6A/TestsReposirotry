public class TestEditsDoubleBuffer {
  @Test public void testDoubleBuffer() throws IOException {
    EditsDoubleBuffer buf=new EditsDoubleBuffer(1024);
    assertTrue(buf.isFlushed());
    byte[] data=new byte[100];
    buf.writeRaw(data,0,data.length);
    assertEquals("Should count new data correctly",data.length,buf.countBufferedBytes());
    assertTrue("Writing to current buffer should not affect flush state",buf.isFlushed());
    buf.setReadyToFlush();
    assertEquals("Swapping buffers should still count buffered bytes",data.length,buf.countBufferedBytes());
    assertFalse(buf.isFlushed());
    DataOutputBuffer outBuf=new DataOutputBuffer();
    buf.flushTo(outBuf);
    assertEquals(data.length,outBuf.getLength());
    assertTrue(buf.isFlushed());
    assertEquals(0,buf.countBufferedBytes());
    buf.writeRaw(data,0,data.length);
    assertEquals("Should count new data correctly",data.length,buf.countBufferedBytes());
    buf.setReadyToFlush();
    buf.flushTo(outBuf);
    assertEquals(data.length * 2,outBuf.getLength());
    assertEquals(0,buf.countBufferedBytes());
    outBuf.close();
  }
  @Test public void shouldFailToCloseWhenUnflushed() throws IOException {
    EditsDoubleBuffer buf=new EditsDoubleBuffer(1024);
    buf.writeRaw(new byte[1],0,1);
    try {
      buf.close();
      fail("Did not fail to close with unflushed data");
    }
 catch (    IOException ioe) {
      if (!ioe.toString().contains("still to be flushed")) {
        throw ioe;
      }
    }
  }
  @Test public void testDumpEdits() throws IOException {
    final int defaultBufferSize=256;
    EditsDoubleBuffer buffer=new EditsDoubleBuffer(defaultBufferSize);
    FSEditLogOp.OpInstanceCache cache=new FSEditLogOp.OpInstanceCache();
    String src="/testdumpedits";
    short replication=1;
    FSEditLogOp.SetReplicationOp op=FSEditLogOp.SetReplicationOp.getInstance(cache.get()).setPath(src).setReplication(replication);
    op.setTransactionId(1);
    buffer.writeOp(op);
    src="/testdumpedits2";
    FSEditLogOp.DeleteOp op2=FSEditLogOp.DeleteOp.getInstance(cache.get()).setPath(src).setTimestamp(0);
    op2.setTransactionId(2);
    buffer.writeOp(op2);
    FSEditLogOp.AllocateBlockIdOp op3=FSEditLogOp.AllocateBlockIdOp.getInstance(cache.get()).setBlockId(0);
    op3.setTransactionId(3);
    buffer.writeOp(op3);
    GenericTestUtils.LogCapturer logs=GenericTestUtils.LogCapturer.captureLogs(EditsDoubleBuffer.LOG);
    try {
      buffer.close();
      fail();
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("bytes still to be flushed and cannot be closed.",ioe);
      EditsDoubleBuffer.LOG.info("Exception expected: ",ioe);
    }
    logs.stopCapturing();
    Assert.assertTrue("expected " + op.toString() + " in the log",logs.getOutput().contains(op.toString()));
    Assert.assertTrue("expected " + op2.toString() + " in the log",logs.getOutput().contains(op2.toString()));
    Assert.assertTrue("expected " + op3.toString() + " in the log",logs.getOutput().contains(op3.toString()));
  }
}
