/** 
 * Tests concurrent operations on S3Guard.
 */
public class ITestS3GuardConcurrentOps extends AbstractS3ATestBase {
  @Rule public final Timeout timeout=new Timeout(5 * 60 * 1000);
  private void failIfTableExists(  DynamoDB db,  String tableName){
    boolean tableExists=true;
    try {
      Table table=db.getTable(tableName);
      table.describe();
    }
 catch (    ResourceNotFoundException e) {
      tableExists=false;
    }
    if (tableExists) {
      fail("Table already exists: " + tableName);
    }
  }
  private void deleteTable(  DynamoDB db,  String tableName) throws InterruptedException {
    try {
      Table table=db.getTable(tableName);
      table.waitForActive();
      table.delete();
      table.waitForDelete();
    }
 catch (    ResourceNotFoundException e) {
      LOG.warn("Failed to delete {}, as it was not found",tableName,e);
    }
  }
  @Test public void testConcurrentTableCreations() throws Exception {
    S3AFileSystem fs=getFileSystem();
    final Configuration conf=fs.getConf();
    Assume.assumeTrue("Test only applies when DynamoDB is used for S3Guard",conf.get(Constants.S3_METADATA_STORE_IMPL).equals(Constants.S3GUARD_METASTORE_DYNAMO));
    AWSCredentialProviderList sharedCreds=fs.shareCredentials("testConcurrentTableCreations");
    sharedCreds.close();
    int originalRefCount=sharedCreds.getRefCount();
    DynamoDBMetadataStore ms=new DynamoDBMetadataStore();
    ms.initialize(fs);
    assertEquals("Credential Ref count unchanged after initializing metastore " + sharedCreds,originalRefCount + 1,sharedCreds.getRefCount());
    try {
      DynamoDB db=ms.getDynamoDB();
      String tableName="testConcurrentTableCreations" + new Random().nextInt();
      conf.setBoolean(Constants.S3GUARD_DDB_TABLE_CREATE_KEY,true);
      conf.set(Constants.S3GUARD_DDB_TABLE_NAME_KEY,tableName);
      String region=conf.getTrimmed(S3GUARD_DDB_REGION_KEY);
      if (StringUtils.isEmpty(region)) {
        conf.set(S3GUARD_DDB_REGION_KEY,fs.getBucketLocation());
      }
      int concurrentOps=16;
      int iterations=4;
      failIfTableExists(db,tableName);
      for (int i=0; i < iterations; i++) {
        ExecutorService executor=Executors.newFixedThreadPool(concurrentOps,new ThreadFactory(){
          private AtomicInteger count=new AtomicInteger(0);
          public Thread newThread(          Runnable r){
            return new Thread(r,"testConcurrentTableCreations" + count.getAndIncrement());
          }
        }
);
        ((ThreadPoolExecutor)executor).prestartAllCoreThreads();
        Future<Exception>[] futures=new Future[concurrentOps];
        for (int f=0; f < concurrentOps; f++) {
          final int index=f;
          futures[f]=executor.submit(new Callable<Exception>(){
            @Override public Exception call() throws Exception {
              ContractTestUtils.NanoTimer timer=new ContractTestUtils.NanoTimer();
              Exception result=null;
              try (DynamoDBMetadataStore store=new DynamoDBMetadataStore()){
                store.initialize(conf);
              }
 catch (              Exception e) {
                LOG.error(e.getClass() + ": " + e.getMessage());
                result=e;
              }
              timer.end("Parallel DynamoDB client creation %d",index);
              LOG.info("Parallel DynamoDB client creation {} ran from {} to {}",index,timer.getStartTime(),timer.getEndTime());
              return result;
            }
          }
);
        }
        List<Exception> exceptions=new ArrayList<>(concurrentOps);
        for (int f=0; f < concurrentOps; f++) {
          Exception outcome=futures[f].get();
          if (outcome != null) {
            exceptions.add(outcome);
          }
        }
        deleteTable(db,tableName);
        int exceptionsThrown=exceptions.size();
        if (exceptionsThrown > 0) {
          throw new AssertionError(exceptionsThrown + "/" + concurrentOps+ " threads threw exceptions while initializing on iteration "+ i,exceptions.get(0));
        }
      }
    }
  finally {
      ms.close();
    }
    assertEquals("Credential Ref count unchanged after closing metastore: " + sharedCreds,originalRefCount,sharedCreds.getRefCount());
  }
}
