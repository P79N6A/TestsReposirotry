/** 
 * Test if live nodes count per node is correct  so NN makes right decision for under/over-replicated blocks
 */
public class TestNodeCount {
  final short REPLICATION_FACTOR=(short)2;
  final long TIMEOUT=20000L;
  long timeout=0;
  long failtime=0;
  Block lastBlock=null;
  NumberReplicas lastNum=null;
  @Test(timeout=60000) public void testNodeCount() throws Exception {
    final Configuration conf=new HdfsConfiguration();
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_STARTUP_DELAY_BLOCK_DELETION_SEC_KEY,60);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY,1);
    conf.setInt(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,1);
    final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION_FACTOR).build();
    try {
      final FSNamesystem namesystem=cluster.getNamesystem();
      final BlockManager bm=namesystem.getBlockManager();
      final HeartbeatManager hm=bm.getDatanodeManager().getHeartbeatManager();
      final FileSystem fs=cluster.getFileSystem();
      final Path FILE_PATH=new Path("/testfile");
      DFSTestUtil.createFile(fs,FILE_PATH,1L,REPLICATION_FACTOR,1L);
      DFSTestUtil.waitReplication(fs,FILE_PATH,REPLICATION_FACTOR);
      ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,FILE_PATH);
      final DatanodeDescriptor[] datanodes=hm.getDatanodes();
      cluster.startDataNodes(conf,2,true,null,null);
      cluster.waitActive();
      DatanodeDescriptor datanode=datanodes[0];
      DataNodeProperties dnprop=cluster.stopDataNode(datanode.getXferAddr());
      BlockManagerTestUtil.noticeDeadDatanode(cluster.getNameNode(),datanode.getXferAddr());
      DFSTestUtil.waitReplication(fs,FILE_PATH,REPLICATION_FACTOR);
      cluster.restartDataNode(dnprop);
      cluster.waitActive();
      initializeTimeout(TIMEOUT);
      while (countNodes(block.getLocalBlock(),namesystem).excessReplicas() == 0) {
        checkTimeout("excess replicas not detected");
      }
      DatanodeDescriptor nonExcessDN=null;
      for (      DatanodeStorageInfo storage : bm.blocksMap.getStorages(block.getLocalBlock())) {
        final DatanodeDescriptor dn=storage.getDatanodeDescriptor();
        final BlockInfo info=new BlockInfoContiguous(block.getLocalBlock(),(short)0);
        if (!bm.isExcess(dn,info)) {
          nonExcessDN=dn;
          break;
        }
      }
      assertTrue(nonExcessDN != null);
      dnprop=cluster.stopDataNode(nonExcessDN.getXferAddr());
      BlockManagerTestUtil.noticeDeadDatanode(cluster.getNameNode(),nonExcessDN.getXferAddr());
      initializeTimeout(TIMEOUT);
      while (countNodes(block.getLocalBlock(),namesystem).liveReplicas() != REPLICATION_FACTOR) {
        checkTimeout("live replica count not correct",1000);
      }
      cluster.restartDataNode(dnprop);
      cluster.waitActive();
      initializeTimeout(TIMEOUT);
      while (countNodes(block.getLocalBlock(),namesystem).excessReplicas() != 2) {
        checkTimeout("excess replica count not equal to 2");
      }
    }
  finally {
      cluster.shutdown();
    }
  }
  void initializeTimeout(  long timeout){
    this.timeout=timeout;
    this.failtime=Time.monotonicNow() + ((timeout <= 0) ? Long.MAX_VALUE : timeout);
  }
  void checkTimeout(  String testLabel) throws TimeoutException {
    checkTimeout(testLabel,10);
  }
  void checkTimeout(  String testLabel,  long cycleTime) throws TimeoutException {
    if (Time.monotonicNow() > failtime) {
      throw new TimeoutException("Timeout: " + testLabel + " for block "+ lastBlock+ " after "+ timeout+ " msec.  Last counts: live = "+ lastNum.liveReplicas()+ ", excess = "+ lastNum.excessReplicas()+ ", corrupt = "+ lastNum.corruptReplicas());
    }
    if (cycleTime > 0) {
      try {
        Thread.sleep(cycleTime);
      }
 catch (      InterruptedException ie) {
      }
    }
  }
  NumberReplicas countNodes(  Block block,  FSNamesystem namesystem){
    BlockManager blockManager=namesystem.getBlockManager();
    namesystem.readLock();
    try {
      lastBlock=block;
      lastNum=blockManager.countNodes(blockManager.getStoredBlock(block));
      return lastNum;
    }
  finally {
      namesystem.readUnlock();
    }
  }
}
