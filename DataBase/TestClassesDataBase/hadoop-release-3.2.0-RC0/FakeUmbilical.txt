static class FakeUmbilical implements TaskUmbilicalProtocol {
  public long getProtocolVersion(  String protocol,  long clientVersion){
    return TaskUmbilicalProtocol.versionID;
  }
  @Override public ProtocolSignature getProtocolSignature(  String protocol,  long clientVersion,  int clientMethodsHash) throws IOException {
    return ProtocolSignature.getProtocolSignature(this,protocol,clientVersion,clientMethodsHash);
  }
  public void done(  TaskAttemptID taskid) throws IOException {
    LOG.info("Task " + taskid + " reporting done.");
  }
  public void fsError(  TaskAttemptID taskId,  String message) throws IOException {
    LOG.info("Task " + taskId + " reporting file system error: "+ message);
  }
  public void shuffleError(  TaskAttemptID taskId,  String message) throws IOException {
    LOG.info("Task " + taskId + " reporting shuffle error: "+ message);
  }
  public void fatalError(  TaskAttemptID taskId,  String msg,  boolean fastFail) throws IOException {
    LOG.info("Task " + taskId + " reporting fatal error: "+ msg+ " fast fail: "+ fastFail);
  }
  public JvmTask getTask(  JvmContext context) throws IOException {
    return null;
  }
  public boolean ping(  TaskAttemptID taskid) throws IOException {
    return true;
  }
  public void commitPending(  TaskAttemptID taskId,  TaskStatus taskStatus) throws IOException, InterruptedException {
    statusUpdate(taskId,taskStatus);
  }
  public void preempted(  TaskAttemptID taskId,  TaskStatus taskStatus) throws IOException, InterruptedException {
    statusUpdate(taskId,taskStatus);
  }
  public boolean canCommit(  TaskAttemptID taskid) throws IOException {
    return true;
  }
  public AMFeedback statusUpdate(  TaskAttemptID taskId,  TaskStatus taskStatus) throws IOException, InterruptedException {
    StringBuffer buf=new StringBuffer("Task ");
    buf.append(taskId);
    if (taskStatus != null) {
      buf.append(" making progress to ");
      buf.append(taskStatus.getProgress());
      String state=taskStatus.getStateString();
      if (state != null) {
        buf.append(" and state of ");
        buf.append(state);
      }
    }
    LOG.info(buf.toString());
    AMFeedback a=new AMFeedback();
    a.setTaskFound(true);
    return a;
  }
  public void reportDiagnosticInfo(  TaskAttemptID taskid,  String trace) throws IOException {
    LOG.info("Task " + taskid + " has problem "+ trace);
  }
  public MapTaskCompletionEventsUpdate getMapCompletionEvents(  JobID jobId,  int fromEventId,  int maxLocs,  TaskAttemptID id) throws IOException {
    return new MapTaskCompletionEventsUpdate(TaskCompletionEvent.EMPTY_ARRAY,false);
  }
  public void reportNextRecordRange(  TaskAttemptID taskid,  SortedRanges.Range range) throws IOException {
    LOG.info("Task " + taskid + " reportedNextRecordRange "+ range);
  }
  @Override public TaskCheckpointID getCheckpointID(  TaskID taskId){
    return null;
  }
  @Override public void setCheckpointID(  TaskID downgrade,  TaskCheckpointID cid){
  }
}
