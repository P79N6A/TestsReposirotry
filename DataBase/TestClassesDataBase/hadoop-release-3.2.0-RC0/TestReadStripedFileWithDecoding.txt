public class TestReadStripedFileWithDecoding {
  private static final Logger LOG=LoggerFactory.getLogger(TestReadStripedFileWithDecoding.class);
  private MiniDFSCluster cluster;
  private DistributedFileSystem dfs;
  @Rule public Timeout globalTimeout=new Timeout(300000);
  @Before public void setup() throws IOException {
    cluster=initializeCluster();
    dfs=cluster.getFileSystem();
  }
  @After public void tearDown() throws IOException {
    tearDownCluster(cluster);
  }
  /** 
 * After reading a corrupted block, make sure the client can correctly report the corruption to the NameNode.
 */
  @Test public void testReportBadBlock() throws IOException {
    final Path file=new Path("/corrupted");
    final int length=10;
    final byte[] bytes=StripedFileTestUtil.generateBytes(length);
    DFSTestUtil.writeFile(dfs,file,bytes);
    int dnIndex=ReadStripedFileWithDecodingHelper.findFirstDataNode(cluster,dfs,file,CELL_SIZE * NUM_DATA_UNITS);
    Assert.assertNotEquals(-1,dnIndex);
    LocatedStripedBlock slb=(LocatedStripedBlock)dfs.getClient().getLocatedBlocks(file.toString(),0,CELL_SIZE * NUM_DATA_UNITS).get(0);
    final LocatedBlock[] blks=StripedBlockUtil.parseStripedBlockGroup(slb,CELL_SIZE,NUM_DATA_UNITS,NUM_PARITY_UNITS);
    File storageDir=cluster.getInstanceStorageDir(dnIndex,0);
    File blkFile=MiniDFSCluster.getBlockFile(storageDir,blks[0].getBlock());
    Assert.assertTrue("Block file does not exist",blkFile.exists());
    LOG.info("Deliberately corrupting file " + blkFile.getName());
    try (FileOutputStream out=new FileOutputStream(blkFile)){
      out.write("corruption".getBytes());
    }
     for (    DataNode dn : cluster.getDataNodes()) {
      DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,true);
    }
    try {
      StripedFileTestUtil.verifyStatefulRead(dfs,file,length,bytes,ByteBuffer.allocate(1024));
      final FSNamesystem ns=cluster.getNamesystem();
      final BlockManager bm=ns.getBlockManager();
      BlockInfo blockInfo=(ns.getFSDirectory().getINode4Write(file.toString()).asFile().getBlocks())[0];
      Assert.assertEquals(1,bm.getCorruptReplicas(blockInfo).size());
    }
  finally {
      for (      DataNode dn : cluster.getDataNodes()) {
        DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,false);
      }
    }
  }
  @Test public void testInvalidateBlock() throws IOException {
    final Path file=new Path("/invalidate");
    final int length=10;
    final byte[] bytes=StripedFileTestUtil.generateBytes(length);
    DFSTestUtil.writeFile(dfs,file,bytes);
    int dnIndex=findFirstDataNode(cluster,dfs,file,CELL_SIZE * NUM_DATA_UNITS);
    Assert.assertNotEquals(-1,dnIndex);
    LocatedStripedBlock slb=(LocatedStripedBlock)dfs.getClient().getLocatedBlocks(file.toString(),0,CELL_SIZE * NUM_DATA_UNITS).get(0);
    final LocatedBlock[] blks=StripedBlockUtil.parseStripedBlockGroup(slb,CELL_SIZE,NUM_DATA_UNITS,NUM_PARITY_UNITS);
    final Block b=blks[0].getBlock().getLocalBlock();
    DataNode dn=cluster.getDataNodes().get(dnIndex);
    DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,true);
    try {
      dfs.delete(file,true);
      final FSNamesystem fsn=cluster.getNamesystem();
      final BlockManager bm=fsn.getBlockManager();
      DatanodeDescriptor dnd=NameNodeAdapter.getDatanode(fsn,dn.getDatanodeId());
      Assert.assertTrue(bm.containsInvalidateBlock(blks[0].getLocations()[0],b) || dnd.containsInvalidateBlock(b));
    }
  finally {
      DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,false);
    }
  }
}
