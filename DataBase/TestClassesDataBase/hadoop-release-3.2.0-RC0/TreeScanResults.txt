/** 
 * Results of recursive directory creation/scan operations.
 */
public static final class TreeScanResults {
  private Path basePath;
  private final List<Path> files=new ArrayList<>();
  private final List<Path> directories=new ArrayList<>();
  private final List<Path> other=new ArrayList<>();
  public TreeScanResults(){
  }
  public TreeScanResults(  Path basePath){
    this.basePath=basePath;
  }
  /** 
 * Build from a located file status iterator.
 * @param results results of the listFiles/listStatus call.
 * @throws IOException IO problems during the iteration.
 */
  public TreeScanResults(  RemoteIterator<LocatedFileStatus> results) throws IOException {
    while (results.hasNext()) {
      add(results.next());
    }
  }
  /** 
 * Construct results from an array of statistics.
 * @param stats statistics array. Must not be null.
 */
  public TreeScanResults(  FileStatus[] stats){
    assertNotNull("Null file status array",stats);
    for (    FileStatus stat : stats) {
      add(stat);
    }
  }
  /** 
 * Construct results from an iterable collection of statistics.
 * @param stats statistics source. Must not be null.
 */
  public <F extends FileStatus>TreeScanResults(  Iterable<F> stats){
    for (    FileStatus stat : stats) {
      add(stat);
    }
  }
  /** 
 * Add all paths in the other set of results to this instance.
 * @param that the other instance
 * @return this instance
 */
  public TreeScanResults add(  TreeScanResults that){
    files.addAll(that.files);
    directories.addAll(that.directories);
    other.addAll(that.other);
    return this;
  }
  /** 
 * Increment the counters based on the file status.
 * @param status path status to count.
 */
  public void add(  FileStatus status){
    if (status.isFile()) {
      files.add(status.getPath());
    }
 else     if (status.isDirectory()) {
      directories.add(status.getPath());
    }
 else {
      other.add(status.getPath());
    }
  }
  public void add(  FileSystem fs,  Path path) throws IOException {
    add(fs.getFileStatus(path));
  }
  @Override public String toString(){
    return String.format("%d director%s and %d file%s",getDirCount(),getDirCount() == 1 ? "y" : "ies",getFileCount(),getFileCount() == 1 ? "" : "s");
  }
  /** 
 * Equality check compares files and directory counts. As these are non-final fields, this class cannot be used in hash tables.
 * @param o other object
 * @return true iff the file and dir count match.
 */
  @Override public boolean equals(  Object o){
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TreeScanResults that=(TreeScanResults)o;
    return getFileCount() == that.getFileCount() && getDirCount() == that.getDirCount();
  }
  /** 
 * This is a spurious hash code subclass to keep findbugs quiet.
 * @return the base {@link Object#hashCode()}
 */
  @Override public int hashCode(){
    return super.hashCode();
  }
  /** 
 * Assert that the state of a listing has the specific number of files, directories and other entries. The error text will include the  {@code text} param, the field in question, and the entire object'sstring value.
 * @param text text prefix for assertions.
 * @param f file count
 * @param d expected directory count
 * @param o expected other entries.
 */
  public void assertSizeEquals(  String text,  long f,  long d,  long o){
    String self=toString();
    Assert.assertEquals(text + ": file count in " + self,f,getFileCount());
    Assert.assertEquals(text + ": directory count in " + self,d,getDirCount());
    Assert.assertEquals(text + ": 'other' count in " + self,o,getOtherCount());
  }
  /** 
 * Assert that the trees are equivalent: that every list matches (and that neither has any duplicates).
 * @param that the other entry
 */
  public void assertEquivalent(  TreeScanResults that){
    assertFieldsEquivalent("files",that,files,that.files);
    assertFieldsEquivalent("directories",that,directories,that.directories);
    assertFieldsEquivalent("other",that,other,that.other);
  }
  /** 
 * Assert that a field in two instances are equivalent.
 * @param fieldname field name for error messages
 * @param that the other instance to scan
 * @param ours our field's contents
 * @param theirs the other instance's field constants
 */
  public void assertFieldsEquivalent(  String fieldname,  TreeScanResults that,  List<Path> ours,  List<Path> theirs){
    String ourList=pathsToString(ours);
    String theirList=pathsToString(theirs);
    assertFalse("Duplicate  " + fieldname + " in "+ this+ ": "+ ourList,containsDuplicates(ours));
    assertFalse("Duplicate  " + fieldname + " in other "+ that+ ": "+ theirList,containsDuplicates(theirs));
    assertTrue(fieldname + " mismatch: between " + ourList+ " and "+ theirList,collectionsEquivalent(ours,theirs));
  }
  public List<Path> getFiles(){
    return files;
  }
  public List<Path> getDirectories(){
    return directories;
  }
  public List<Path> getOther(){
    return other;
  }
  public Path getBasePath(){
    return basePath;
  }
  public long getFileCount(){
    return files.size();
  }
  public long getDirCount(){
    return directories.size();
  }
  public long getOtherCount(){
    return other.size();
  }
  /** 
 * Total count of entries.
 * @return the total number of entries
 */
  public long totalCount(){
    return getFileCount() + getDirCount() + getOtherCount();
  }
}
