private static class CustomAM extends AbstractService implements CustomProtocol {
  private final ApplicationAttemptId appAttemptId;
  private final byte[] secretKey;
  private InetSocketAddress address;
  private boolean pinged=false;
  private ClientToAMTokenSecretManager secretMgr;
  public CustomAM(  ApplicationAttemptId appId,  byte[] secretKey){
    super("CustomAM");
    this.appAttemptId=appId;
    this.secretKey=secretKey;
  }
  @Override public TestProtos.EmptyResponseProto ping(  RpcController unused,  TestProtos.EmptyRequestProto request) throws ServiceException {
    this.pinged=true;
    return TestProtos.EmptyResponseProto.newBuilder().build();
  }
  public ClientToAMTokenSecretManager getClientToAMTokenSecretManager(){
    return secretMgr;
  }
  @Override protected void serviceStart() throws Exception {
    Configuration conf=getConfig();
    RPC.setProtocolEngine(conf,CustomProtocol.class,ProtobufRpcEngine.class);
    UserGroupInformation.setConfiguration(conf);
    BlockingService service=TestRpcServiceProtos.CustomProto.newReflectiveBlockingService(this);
    Server server;
    try {
      secretMgr=new ClientToAMTokenSecretManager(this.appAttemptId,secretKey);
      server=new RPC.Builder(conf).setProtocol(CustomProtocol.class).setNumHandlers(1).setSecretManager(secretMgr).setInstance(service).build();
    }
 catch (    Exception e) {
      throw new YarnRuntimeException(e);
    }
    server.start();
    this.address=NetUtils.getConnectAddress(server);
    super.serviceStart();
  }
  public void setClientSecretKey(  byte[] key){
    secretMgr.setMasterKey(key);
  }
}
