/** 
 * Test the PathMetadataDynamoDBTranslation is able to translate between domain model objects and DynamoDB items.
 */
public class TestPathMetadataDynamoDBTranslation extends Assert {
  private static final Path TEST_DIR_PATH=new Path("s3a://test-bucket/myDir");
  private static final Item TEST_DIR_ITEM=new Item();
  private static DDBPathMetadata testDirPathMetadata;
  private static final long TEST_FILE_LENGTH=100;
  private static final long TEST_MOD_TIME=9999;
  private static final long TEST_BLOCK_SIZE=128;
  private static final Path TEST_FILE_PATH=new Path(TEST_DIR_PATH,"myFile");
  private static final Item TEST_FILE_ITEM=new Item();
  private static DDBPathMetadata testFilePathMetadata;
  @BeforeClass public static void setUpBeforeClass() throws IOException {
    String username=UserGroupInformation.getCurrentUser().getShortUserName();
    testDirPathMetadata=new DDBPathMetadata(new S3AFileStatus(false,TEST_DIR_PATH,username));
    TEST_DIR_ITEM.withPrimaryKey(PARENT,"/test-bucket",CHILD,TEST_DIR_PATH.getName()).withBoolean(IS_DIR,true);
    testFilePathMetadata=new DDBPathMetadata(new S3AFileStatus(TEST_FILE_LENGTH,TEST_MOD_TIME,TEST_FILE_PATH,TEST_BLOCK_SIZE,username));
    TEST_FILE_ITEM.withPrimaryKey(PARENT,pathToParentKey(TEST_FILE_PATH.getParent()),CHILD,TEST_FILE_PATH.getName()).withBoolean(IS_DIR,false).withLong(FILE_LENGTH,TEST_FILE_LENGTH).withLong(MOD_TIME,TEST_MOD_TIME).withLong(BLOCK_SIZE,TEST_BLOCK_SIZE);
  }
  /** 
 * It should not take long time as it doesn't involve remote server operation.
 */
  @Rule public final Timeout timeout=new Timeout(30 * 1000);
  @Test public void testKeySchema(){
    final Collection<KeySchemaElement> keySchema=PathMetadataDynamoDBTranslation.keySchema();
    assertNotNull(keySchema);
    assertEquals("There should be HASH and RANGE key in key schema",2,keySchema.size());
    for (    KeySchemaElement element : keySchema) {
      assertThat(element.getAttributeName(),anyOf(is(PARENT),is(CHILD)));
      assertThat(element.getKeyType(),anyOf(is(HASH.toString()),is(RANGE.toString())));
    }
  }
  @Test public void testAttributeDefinitions(){
    final Collection<AttributeDefinition> attrs=PathMetadataDynamoDBTranslation.attributeDefinitions();
    assertNotNull(attrs);
    assertEquals("There should be HASH and RANGE attributes",2,attrs.size());
    for (    AttributeDefinition definition : attrs) {
      assertThat(definition.getAttributeName(),anyOf(is(PARENT),is(CHILD)));
      assertEquals(S.toString(),definition.getAttributeType());
    }
  }
  @Test public void testItemToPathMetadata() throws IOException {
    final String user=UserGroupInformation.getCurrentUser().getShortUserName();
    assertNull(itemToPathMetadata(null,user));
    verify(TEST_DIR_ITEM,itemToPathMetadata(TEST_DIR_ITEM,user));
    verify(TEST_FILE_ITEM,itemToPathMetadata(TEST_FILE_ITEM,user));
  }
  /** 
 * Verify that the Item and PathMetadata objects hold the same information.
 */
  private static void verify(  Item item,  PathMetadata meta){
    assertNotNull(meta);
    final FileStatus status=meta.getFileStatus();
    final Path path=status.getPath();
    assertEquals(item.get(PARENT),pathToParentKey(path.getParent()));
    assertEquals(item.get(CHILD),path.getName());
    boolean isDir=item.hasAttribute(IS_DIR) && item.getBoolean(IS_DIR);
    assertEquals(isDir,status.isDirectory());
    long len=item.hasAttribute(FILE_LENGTH) ? item.getLong(FILE_LENGTH) : 0;
    assertEquals(len,status.getLen());
    long bSize=item.hasAttribute(BLOCK_SIZE) ? item.getLong(BLOCK_SIZE) : 0;
    assertEquals(bSize,status.getBlockSize());
  }
  @Test public void testPathMetadataToItem(){
    verify(pathMetadataToItem(testDirPathMetadata),testDirPathMetadata);
    verify(pathMetadataToItem(testFilePathMetadata),testFilePathMetadata);
  }
  @Test public void testPathToParentKeyAttribute(){
    doTestPathToParentKeyAttribute(TEST_DIR_PATH);
    doTestPathToParentKeyAttribute(TEST_FILE_PATH);
  }
  private static void doTestPathToParentKeyAttribute(  Path path){
    final KeyAttribute attr=pathToParentKeyAttribute(path);
    assertNotNull(attr);
    assertEquals(PARENT,attr.getName());
    assertEquals(pathToParentKey(path),attr.getValue());
  }
  private static String pathToParentKey(  Path p){
    Preconditions.checkArgument(p.isUriPathAbsolute());
    URI parentUri=p.toUri();
    String bucket=parentUri.getHost();
    Preconditions.checkNotNull(bucket);
    String s="/" + bucket + parentUri.getPath();
    if (s.endsWith("/")) {
      s=s.substring(0,s.length() - 1);
    }
    return s;
  }
  @Test public void testPathToKey() throws Exception {
    LambdaTestUtils.intercept(IllegalArgumentException.class,new Callable<PrimaryKey>(){
      @Override public PrimaryKey call() throws Exception {
        return pathToKey(new Path("/"));
      }
    }
);
    doTestPathToKey(TEST_DIR_PATH);
    doTestPathToKey(TEST_FILE_PATH);
  }
  private static void doTestPathToKey(  Path path){
    final PrimaryKey key=pathToKey(path);
    assertNotNull(key);
    assertEquals("There should be both HASH and RANGE keys",2,key.getComponents().size());
    for (    KeyAttribute keyAttribute : key.getComponents()) {
      assertThat(keyAttribute.getName(),anyOf(is(PARENT),is(CHILD)));
      if (PARENT.equals(keyAttribute.getName())) {
        assertEquals(pathToParentKey(path.getParent()),keyAttribute.getValue());
      }
 else {
        assertEquals(path.getName(),keyAttribute.getValue());
      }
    }
  }
  @Test public void testVersionRoundTrip() throws Throwable {
    final Item marker=createVersionMarker(VERSION_MARKER,VERSION,0);
    assertEquals("Extracted version from " + marker,VERSION,extractVersionFromMarker(marker));
  }
  @Test public void testVersionMarkerNotStatusIllegalPath() throws Throwable {
    final Item marker=createVersionMarker(VERSION_MARKER,VERSION,0);
    assertNull("Path metadata fromfrom " + marker,itemToPathMetadata(marker,"alice"));
  }
  /** 
 * Test when translating an  {@link Item} to {@link DDBPathMetadata} worksif  {@code IS_AUTHORITATIVE} flag is ignored.
 */
  @Test public void testIsAuthoritativeCompatibilityItemToPathMetadata() throws Exception {
    Item item=Mockito.spy(TEST_DIR_ITEM);
    item.withBoolean(IS_AUTHORITATIVE,true);
    final String user=UserGroupInformation.getCurrentUser().getShortUserName();
    DDBPathMetadata meta=itemToPathMetadata(item,user,true);
    Mockito.verify(item,Mockito.never()).getBoolean(IS_AUTHORITATIVE);
    assertFalse(meta.isAuthoritativeDir());
  }
  /** 
 * Test when translating an  {@link DDBPathMetadata} to {@link Item} worksif  {@code IS_AUTHORITATIVE} flag is ignored.
 */
  @Test public void testIsAuthoritativeCompatibilityPathMetadataToItem(){
    DDBPathMetadata meta=Mockito.spy(testFilePathMetadata);
    meta.setAuthoritativeDir(true);
    Item item=pathMetadataToItem(meta,true);
    Mockito.verify(meta,never()).isAuthoritativeDir();
    assertFalse(item.hasAttribute(IS_AUTHORITATIVE));
  }
}
