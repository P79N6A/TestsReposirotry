/** 
 * Test cases that validate S3Guard's behavior for writing things like directory listings back to the MetadataStore.
 */
public class ITestS3GuardWriteBack extends AbstractS3ATestBase {
  /** 
 * In listStatus(), when S3Guard is enabled, the full listing for a directory is "written back" to the MetadataStore before the listing is returned.  Currently this "write back" behavior occurs when fs.s3a.metadatastore.authoritative is true.  This test validates this behavior.
 * @throws Exception on failure
 */
  @Test public void testListStatusWriteBack() throws Exception {
    Assume.assumeTrue(getFileSystem().hasMetadataStore());
    Path directory=path("ListStatusWriteBack");
    S3AFileSystem noS3Guard=createTestFS(directory.toUri(),true,false);
    S3AFileSystem noWriteBack=createTestFS(directory.toUri(),false,false);
    S3AFileSystem yesWriteBack=createTestFS(directory.toUri(),false,true);
    noS3Guard.delete(directory,true);
    Path onS3=new Path(directory,"OnS3");
    noS3Guard.mkdirs(onS3);
    Path onS3AndMS=new Path(directory,"OnS3AndMS");
    ContractTestUtils.assertPathDoesNotExist(noWriteBack,"path",onS3AndMS);
    noWriteBack.mkdirs(onS3AndMS);
    FileStatus[] fsResults;
    DirListingMetadata mdResults;
    fsResults=noWriteBack.listStatus(directory);
    assertEquals("Filesystem enabled S3Guard without write back should have " + "both /OnS3 and /OnS3AndMS: " + Arrays.toString(fsResults),2,fsResults.length);
    mdResults=noWriteBack.getMetadataStore().listChildren(directory);
    assertNotNull("No results from noWriteBack listChildren " + directory,mdResults);
    assertEquals("Metadata store without write back should still only know " + "about /OnS3AndMS, but it has: " + mdResults,1,mdResults.numEntries());
    fsResults=yesWriteBack.listStatus(directory);
    assertEquals("Filesystem enabled S3Guard with write back should have" + " both /OnS3 and /OnS3AndMS: " + Arrays.toString(fsResults),2,fsResults.length);
    mdResults=yesWriteBack.getMetadataStore().listChildren(directory);
    assertEquals("Unexpected number of results from metadata store. " + "Should have /OnS3 and /OnS3AndMS: " + mdResults,2,mdResults.numEntries());
    getFileSystem().getMetadataStore().forgetMetadata(onS3);
  }
  /** 
 * Create a separate S3AFileSystem instance for testing. There's a bit of complexity as it forces pushes up s3guard options from the base values to the per-bucket options. This stops explicit bucket settings in test XML configs from unintentionally breaking tests.
 */
  private S3AFileSystem createTestFS(  URI fsURI,  boolean disableS3Guard,  boolean authoritativeMeta) throws IOException {
    Configuration conf;
    conf=createConfiguration();
    String host=fsURI.getHost();
    String metastore;
    metastore=S3GUARD_METASTORE_NULL;
    if (!disableS3Guard) {
      metastore=getFileSystem().getConf().get(S3_METADATA_STORE_IMPL);
      assertNotEquals(S3GUARD_METASTORE_NULL,metastore);
    }
    conf.set(Constants.S3_METADATA_STORE_IMPL,metastore);
    conf.setBoolean(METADATASTORE_AUTHORITATIVE,authoritativeMeta);
    S3AUtils.setBucketOption(conf,host,METADATASTORE_AUTHORITATIVE,Boolean.toString(authoritativeMeta));
    S3AUtils.setBucketOption(conf,host,S3_METADATA_STORE_IMPL,metastore);
    S3AFileSystem fs=asS3AFS(FileSystem.newInstance(fsURI,conf));
    assertEquals("Metadata store should have been disabled: " + fs,disableS3Guard,!fs.hasMetadataStore());
    assertEquals("metastore option did not propagate",metastore,fs.getConf().get(S3_METADATA_STORE_IMPL));
    return fs;
  }
  private static S3AFileSystem asS3AFS(  FileSystem fs){
    assertTrue("Not a S3AFileSystem: " + fs,fs instanceof S3AFileSystem);
    return (S3AFileSystem)fs;
  }
}
