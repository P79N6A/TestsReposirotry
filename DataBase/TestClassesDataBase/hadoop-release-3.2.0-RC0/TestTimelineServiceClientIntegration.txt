public class TestTimelineServiceClientIntegration {
  private static final String ROOT_DIR=new File("target",TestTimelineServiceClientIntegration.class.getSimpleName()).getAbsolutePath();
  private static NodeTimelineCollectorManager collectorManager;
  private static PerNodeTimelineCollectorsAuxService auxService;
  private static Configuration conf;
  @BeforeClass public static void setupClass() throws Exception {
    try {
      collectorManager=new MockNodeTimelineCollectorManager();
      conf=new YarnConfiguration();
      conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,true);
      conf.setFloat(YarnConfiguration.TIMELINE_SERVICE_VERSION,2.0f);
      conf.setClass(YarnConfiguration.TIMELINE_SERVICE_WRITER_CLASS,FileSystemTimelineWriterImpl.class,TimelineWriter.class);
      conf.set(FileSystemTimelineWriterImpl.TIMELINE_SERVICE_STORAGE_DIR_ROOT,ROOT_DIR);
      auxService=PerNodeTimelineCollectorsAuxService.launchServer(new String[0],collectorManager,conf);
      auxService.addApplicationIfAbsent(ApplicationId.newInstance(0,1),"user");
    }
 catch (    ExitUtil.ExitException e) {
      fail();
    }
  }
  @AfterClass public static void tearDownClass() throws Exception {
    if (auxService != null) {
      auxService.stop();
    }
    FileUtils.deleteDirectory(new File(ROOT_DIR));
  }
  @Test public void testPutEntities() throws Exception {
    TimelineV2Client client=TimelineV2Client.createTimelineClient(ApplicationId.newInstance(0,1));
    try {
      client.setTimelineCollectorInfo(CollectorInfo.newInstance(collectorManager.getRestServerBindAddress()));
      client.init(conf);
      client.start();
      TimelineEntity entity=new TimelineEntity();
      entity.setType("test entity type");
      entity.setId("test entity id");
      TimelineMetric metric=new TimelineMetric(TimelineMetric.Type.TIME_SERIES);
      metric.setId("test metric id");
      metric.addValue(1L,1.0D);
      metric.addValue(2L,2.0D);
      entity.addMetric(metric);
      client.putEntities(entity);
      client.putEntitiesAsync(entity);
    }
  finally {
      client.stop();
    }
  }
  @Test public void testPutExtendedEntities() throws Exception {
    ApplicationId appId=ApplicationId.newInstance(0,1);
    TimelineV2Client client=TimelineV2Client.createTimelineClient(appId);
    try {
      client.setTimelineCollectorInfo(CollectorInfo.newInstance(collectorManager.getRestServerBindAddress()));
      client.init(conf);
      client.start();
      ClusterEntity cluster=new ClusterEntity();
      cluster.setId(YarnConfiguration.DEFAULT_RM_CLUSTER_ID);
      FlowRunEntity flow=new FlowRunEntity();
      flow.setUser(UserGroupInformation.getCurrentUser().getShortUserName());
      flow.setName("test_flow_name");
      flow.setVersion("test_flow_version");
      flow.setRunId(1L);
      flow.setParent(cluster.getType(),cluster.getId());
      ApplicationEntity app=new ApplicationEntity();
      app.setId(appId.toString());
      flow.addChild(app.getType(),app.getId());
      ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(appId,1);
      ApplicationAttemptEntity appAttempt=new ApplicationAttemptEntity();
      appAttempt.setId(attemptId.toString());
      ContainerId containerId=ContainerId.newContainerId(attemptId,1);
      ContainerEntity container=new ContainerEntity();
      container.setId(containerId.toString());
      UserEntity user=new UserEntity();
      user.setId(UserGroupInformation.getCurrentUser().getShortUserName());
      QueueEntity queue=new QueueEntity();
      queue.setId("default_queue");
      client.putEntities(cluster,flow,app,appAttempt,container,user,queue);
      client.putEntitiesAsync(cluster,flow,app,appAttempt,container,user,queue);
    }
  finally {
      client.stop();
    }
  }
private static class MockNodeTimelineCollectorManager extends NodeTimelineCollectorManager {
    public MockNodeTimelineCollectorManager(){
      super();
    }
    @Override protected CollectorNodemanagerProtocol getNMCollectorService(){
      CollectorNodemanagerProtocol protocol=mock(CollectorNodemanagerProtocol.class);
      try {
        GetTimelineCollectorContextResponse response=GetTimelineCollectorContextResponse.newInstance(UserGroupInformation.getCurrentUser().getShortUserName(),"test_flow_name","test_flow_version",1L);
        when(protocol.getTimelineCollectorContext(any(GetTimelineCollectorContextRequest.class))).thenReturn(response);
      }
 catch (      YarnException|IOException e) {
        fail();
      }
      return protocol;
    }
  }
}
