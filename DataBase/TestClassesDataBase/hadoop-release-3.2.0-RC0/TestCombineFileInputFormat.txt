public class TestCombineFileInputFormat {
  private static final String rack1[]=new String[]{"/r1"};
  private static final String hosts1[]=new String[]{"host1.rack1.com"};
  private static final String rack2[]=new String[]{"/r2"};
  private static final String hosts2[]=new String[]{"host2.rack2.com"};
  private static final String rack3[]=new String[]{"/r3"};
  private static final String hosts3[]=new String[]{"host3.rack3.com"};
  final Path inDir=new Path("/racktesting");
  final Path outputPath=new Path("/output");
  final Path dir1=new Path(inDir,"/dir1");
  final Path dir2=new Path(inDir,"/dir2");
  final Path dir3=new Path(inDir,"/dir3");
  final Path dir4=new Path(inDir,"/dir4");
  final Path dir5=new Path(inDir,"/dir5");
  static final int BLOCKSIZE=1024;
  static final byte[] databuf=new byte[BLOCKSIZE];
  @Mock private List<String> mockList;
  @Before public void initMocks(){
    MockitoAnnotations.initMocks(this);
  }
  private static final String DUMMY_FS_URI="dummyfs:///";
  /** 
 * Dummy class to extend CombineFileInputFormat
 */
private class DummyInputFormat extends CombineFileInputFormat<Text,Text> {
    @Override public RecordReader<Text,Text> createRecordReader(    InputSplit split,    TaskAttemptContext context) throws IOException {
      return null;
    }
  }
  /** 
 * Dummy class to extend CombineFileInputFormat. It allows  non-existent files to be passed into the CombineFileInputFormat, allows for easy testing without having to create real files.
 */
private class DummyInputFormat1 extends DummyInputFormat {
    @Override protected List<FileStatus> listStatus(    JobContext job) throws IOException {
      Path[] files=getInputPaths(job);
      List<FileStatus> results=new ArrayList<FileStatus>();
      for (int i=0; i < files.length; i++) {
        Path p=files[i];
        FileSystem fs=p.getFileSystem(job.getConfiguration());
        results.add(fs.getFileStatus(p));
      }
      return results;
    }
  }
  /** 
 * Dummy class to extend CombineFileInputFormat. It allows testing with files having missing blocks without actually removing replicas.
 */
public static class MissingBlockFileSystem extends DistributedFileSystem {
    String fileWithMissingBlocks;
    @Override public void initialize(    URI name,    Configuration conf) throws IOException {
      fileWithMissingBlocks="";
      super.initialize(name,conf);
    }
    @Override public BlockLocation[] getFileBlockLocations(    FileStatus stat,    long start,    long len) throws IOException {
      if (stat.isDirectory()) {
        return null;
      }
      System.out.println("File " + stat.getPath());
      String name=stat.getPath().toUri().getPath();
      BlockLocation[] locs=super.getFileBlockLocations(stat,start,len);
      if (name.equals(fileWithMissingBlocks)) {
        System.out.println("Returning missing blocks for " + fileWithMissingBlocks);
        locs[0]=new HdfsBlockLocation(new BlockLocation(new String[0],new String[0],locs[0].getOffset(),locs[0].getLength()),null);
      }
      return locs;
    }
    public void setFileWithMissingBlocks(    String f){
      fileWithMissingBlocks=f;
    }
  }
  private static final String DUMMY_KEY="dummy.rr.key";
private static class DummyRecordReader extends RecordReader<Text,Text> {
    private TaskAttemptContext context;
    private CombineFileSplit s;
    private int idx;
    private boolean used;
    public DummyRecordReader(    CombineFileSplit split,    TaskAttemptContext context,    Integer i){
      this.context=context;
      this.idx=i;
      this.s=split;
      this.used=true;
    }
    /** 
 * @return a value specified in the context to check whether thecontext is properly updated by the initialize() method.
 */
    public String getDummyConfVal(){
      return this.context.getConfiguration().get(DUMMY_KEY);
    }
    public void initialize(    InputSplit split,    TaskAttemptContext context){
      this.context=context;
      this.s=(CombineFileSplit)split;
      this.used=false;
    }
    public boolean nextKeyValue(){
      boolean ret=!used;
      this.used=true;
      return ret;
    }
    public Text getCurrentKey(){
      return new Text(this.context.getConfiguration().get(DUMMY_KEY));
    }
    public Text getCurrentValue(){
      return new Text(this.s.getPath(idx).toString());
    }
    public float getProgress(){
      return used ? 1.0f : 0.0f;
    }
    public void close(){
    }
  }
  /** 
 * Extend CFIF to use CFRR with DummyRecordReader 
 */
private class ChildRRInputFormat extends CombineFileInputFormat<Text,Text> {
    @SuppressWarnings("unchecked") @Override public RecordReader<Text,Text> createRecordReader(    InputSplit split,    TaskAttemptContext context) throws IOException {
      return new CombineFileRecordReader((CombineFileSplit)split,context,(Class)DummyRecordReader.class);
    }
  }
  @Test public void testRecordReaderInit() throws InterruptedException, IOException {
    TaskAttemptID taskId=new TaskAttemptID("jt",0,TaskType.MAP,0,0);
    Configuration conf1=new Configuration();
    conf1.set(DUMMY_KEY,"STATE1");
    TaskAttemptContext context1=new TaskAttemptContextImpl(conf1,taskId);
    InputFormat inputFormat=new ChildRRInputFormat();
    Path[] files={new Path("file1")};
    long[] lengths={1};
    CombineFileSplit split=new CombineFileSplit(files,lengths);
    RecordReader rr=inputFormat.createRecordReader(split,context1);
    assertTrue("Unexpected RR type!",rr instanceof CombineFileRecordReader);
    assertEquals("Invalid initial dummy key value","STATE1",rr.getCurrentKey().toString());
    Configuration conf2=new Configuration();
    conf2.set(DUMMY_KEY,"STATE2");
    TaskAttemptContext context2=new TaskAttemptContextImpl(conf2,taskId);
    rr.initialize(split,context2);
    assertEquals("Invalid secondary dummy key value","STATE2",rr.getCurrentKey().toString());
  }
  @Test public void testReinit() throws Exception {
    TaskAttemptID taskId=new TaskAttemptID("jt",0,TaskType.MAP,0,0);
    Configuration conf=new Configuration();
    TaskAttemptContext context=new TaskAttemptContextImpl(conf,taskId);
    InputFormat inputFormat=new ChildRRInputFormat();
    Path[] files={new Path("file1"),new Path("file2")};
    long[] lengths={1,1};
    CombineFileSplit split=new CombineFileSplit(files,lengths);
    RecordReader rr=inputFormat.createRecordReader(split,context);
    assertTrue("Unexpected RR type!",rr instanceof CombineFileRecordReader);
    rr.initialize(split,context);
    assertTrue(rr.nextKeyValue());
    assertEquals("file1",rr.getCurrentValue().toString());
    assertTrue(rr.nextKeyValue());
    assertEquals("file2",rr.getCurrentValue().toString());
    assertFalse(rr.nextKeyValue());
  }
  /** 
 * For testing each split has the expected name, length, and offset.
 */
private final class Split {
    private String name;
    private long length;
    private long offset;
    public Split(    String name,    long length,    long offset){
      this.name=name;
      this.length=length;
      this.offset=offset;
    }
    public String getName(){
      return name;
    }
    public long getLength(){
      return length;
    }
    public long getOffset(){
      return offset;
    }
    @Override public boolean equals(    Object obj){
      if (obj instanceof Split) {
        Split split=((Split)obj);
        return split.name.equals(name) && split.length == length && split.offset == offset;
      }
      return false;
    }
  }
  /** 
 * The test suppresses unchecked warnings in {@link org.mockito.Mockito#reset}. Although calling the method is a bad manner, we call the method instead of splitting the test (i.e. restarting MiniDFSCluster) to save time.
 */
  @Test @SuppressWarnings("unchecked") public void testSplitPlacement() throws Exception {
    MiniDFSCluster dfs=null;
    FileSystem fileSys=null;
    try {
      Configuration conf=new Configuration();
      conf.setBoolean("dfs.replication.considerLoad",false);
      dfs=new MiniDFSCluster.Builder(conf).racks(rack1).hosts(hosts1).build();
      dfs.waitActive();
      fileSys=dfs.getFileSystem();
      if (!fileSys.mkdirs(inDir)) {
        throw new IOException("Mkdirs failed to create " + inDir.toString());
      }
      Path file1=new Path(dir1 + "/file1");
      writeFile(conf,file1,(short)1,1);
      Path file5=new Path(dir5 + "/file5");
      writeFile(conf,file5,(short)1,1);
      DummyInputFormat inFormat=new DummyInputFormat();
      Job job=Job.getInstance(conf);
      FileInputFormat.setInputPaths(job,dir1 + "," + dir5);
      List<InputSplit> splits=inFormat.getSplits(job);
      System.out.println("Made splits(Test0): " + splits.size());
      for (      InputSplit split : splits) {
        System.out.println("File split(Test0): " + split);
      }
      assertEquals(1,splits.size());
      CombineFileSplit fileSplit=(CombineFileSplit)splits.get(0);
      assertEquals(2,fileSplit.getNumPaths());
      assertEquals(1,fileSplit.getLocations().length);
      assertEquals(file1.getName(),fileSplit.getPath(0).getName());
      assertEquals(0,fileSplit.getOffset(0));
      assertEquals(BLOCKSIZE,fileSplit.getLength(0));
      assertEquals(file5.getName(),fileSplit.getPath(1).getName());
      assertEquals(0,fileSplit.getOffset(1));
      assertEquals(BLOCKSIZE,fileSplit.getLength(1));
      assertEquals(hosts1[0],fileSplit.getLocations()[0]);
      dfs.startDataNodes(conf,1,true,null,rack2,hosts2,null);
      dfs.waitActive();
      Path file2=new Path(dir2 + "/file2");
      writeFile(conf,file2,(short)2,2);
      inFormat=new DummyInputFormat();
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2);
      inFormat.setMinSplitSizeRack(BLOCKSIZE);
      splits=inFormat.getSplits(job);
      System.out.println("Made splits(Test1): " + splits.size());
      for (      InputSplit split : splits) {
        System.out.println("File split(Test1): " + split);
      }
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(2,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file2.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(file2.getName(),fileSplit.getPath(1).getName());
            assertEquals(BLOCKSIZE,fileSplit.getOffset(1));
            assertEquals(BLOCKSIZE,fileSplit.getLength(1));
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file1.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 1) {
          assertEquals(3,fileSplit.getNumPaths());
          Set<Split> expected=new HashSet<>();
          expected.add(new Split(file1.getName(),BLOCKSIZE,0));
          expected.add(new Split(file2.getName(),BLOCKSIZE,0));
          expected.add(new Split(file2.getName(),BLOCKSIZE,BLOCKSIZE));
          List<Split> actual=new ArrayList<>();
          for (int i=0; i < 3; i++) {
            String name=fileSplit.getPath(i).getName();
            long length=fileSplit.getLength(i);
            long offset=fileSplit.getOffset(i);
            actual.add(new Split(name,length,offset));
          }
          assertTrue(actual.containsAll(expected));
          assertEquals(1,fileSplit.getLocations().length);
          assertEquals(hosts1[0],fileSplit.getLocations()[0]);
        }
 else {
          fail("Expected split size is 1 or 2, but actual size is " + splits.size());
        }
      }
      dfs.startDataNodes(conf,1,true,null,rack3,hosts3,null);
      dfs.waitActive();
      Path file3=new Path(dir3 + "/file3");
      writeFile(conf,new Path(dir3 + "/file3"),(short)3,3);
      inFormat=new DummyInputFormat();
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3);
      inFormat.setMinSplitSizeRack(BLOCKSIZE);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test2): " + split);
      }
      Set<Split> expected=new HashSet<>();
      expected.add(new Split(file1.getName(),BLOCKSIZE,0));
      expected.add(new Split(file2.getName(),BLOCKSIZE,0));
      expected.add(new Split(file2.getName(),BLOCKSIZE,BLOCKSIZE));
      expected.add(new Split(file3.getName(),BLOCKSIZE,0));
      expected.add(new Split(file3.getName(),BLOCKSIZE,BLOCKSIZE));
      expected.add(new Split(file3.getName(),BLOCKSIZE,BLOCKSIZE * 2));
      List<Split> actual=new ArrayList<>();
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 3) {
          if (split.equals(splits.get(0))) {
            assertEquals(3,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file3.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(file3.getName(),fileSplit.getPath(1).getName());
            assertEquals(BLOCKSIZE,fileSplit.getOffset(1));
            assertEquals(BLOCKSIZE,fileSplit.getLength(1));
            assertEquals(file3.getName(),fileSplit.getPath(2).getName());
            assertEquals(2 * BLOCKSIZE,fileSplit.getOffset(2));
            assertEquals(BLOCKSIZE,fileSplit.getLength(2));
            assertEquals(hosts3[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(2,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file2.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(file2.getName(),fileSplit.getPath(1).getName());
            assertEquals(BLOCKSIZE,fileSplit.getOffset(1));
            assertEquals(BLOCKSIZE,fileSplit.getLength(1));
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(2))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file1.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(1,fileSplit.getLocations().length);
            if (fileSplit.getLocations()[0].equals(hosts2[0])) {
              assertEquals(2,fileSplit.getNumPaths());
            }
 else             if (fileSplit.getLocations()[0].equals(hosts3[0])) {
              assertEquals(3,fileSplit.getNumPaths());
            }
 else {
              fail("First split should be on rack2 or rack3.");
            }
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 1) {
          assertEquals(1,fileSplit.getLocations().length);
          assertEquals(6,fileSplit.getNumPaths());
          assertEquals(hosts1[0],fileSplit.getLocations()[0]);
        }
 else {
          fail("Split size should be 1, 2, or 3.");
        }
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
      }
      assertEquals(6,actual.size());
      assertTrue(actual.containsAll(expected));
      Path file4=new Path(dir4 + "/file4");
      writeFile(conf,file4,(short)3,3);
      inFormat=new DummyInputFormat();
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      inFormat.setMinSplitSizeRack(BLOCKSIZE);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test3): " + split);
      }
      expected.add(new Split(file4.getName(),BLOCKSIZE,0));
      expected.add(new Split(file4.getName(),BLOCKSIZE,BLOCKSIZE));
      expected.add(new Split(file4.getName(),BLOCKSIZE,BLOCKSIZE * 2));
      actual.clear();
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 3) {
          if (split.equals(splits.get(0))) {
            assertEquals(6,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts3[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(2,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file2.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(file2.getName(),fileSplit.getPath(1).getName());
            assertEquals(BLOCKSIZE,fileSplit.getOffset(1));
            assertEquals(BLOCKSIZE,fileSplit.getLength(1));
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(2))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file1.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(1,fileSplit.getLocations().length);
            if (fileSplit.getLocations()[0].equals(hosts2[0])) {
              assertEquals(5,fileSplit.getNumPaths());
            }
 else             if (fileSplit.getLocations()[0].equals(hosts3[0])) {
              assertEquals(6,fileSplit.getNumPaths());
            }
 else {
              fail("First split should be on rack2 or rack3.");
            }
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 1) {
          assertEquals(1,fileSplit.getLocations().length);
          assertEquals(9,fileSplit.getNumPaths());
          assertEquals(hosts1[0],fileSplit.getLocations()[0]);
        }
 else {
          fail("Split size should be 1, 2, or 3.");
        }
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
      }
      assertEquals(9,actual.size());
      assertTrue(actual.containsAll(expected));
      inFormat=new DummyInputFormat();
      inFormat.setMinSplitSizeNode(BLOCKSIZE);
      inFormat.setMaxSplitSize(2 * BLOCKSIZE);
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test4): " + split);
      }
      assertEquals(5,splits.size());
      actual.clear();
      reset(mockList);
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
        mockList.add(fileSplit.getLocations()[0]);
      }
      assertEquals(9,actual.size());
      assertTrue(actual.containsAll(expected));
      verify(mockList,atLeastOnce()).add(hosts1[0]);
      verify(mockList,atLeastOnce()).add(hosts2[0]);
      verify(mockList,atLeastOnce()).add(hosts3[0]);
      inFormat=new DummyInputFormat();
      inFormat.setMinSplitSizeNode(BLOCKSIZE);
      inFormat.setMaxSplitSize(3 * BLOCKSIZE);
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test5): " + split);
      }
      assertEquals(3,splits.size());
      actual.clear();
      reset(mockList);
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
        mockList.add(fileSplit.getLocations()[0]);
      }
      assertEquals(9,actual.size());
      assertTrue(actual.containsAll(expected));
      verify(mockList,atLeastOnce()).add(hosts1[0]);
      verify(mockList,atLeastOnce()).add(hosts2[0]);
      inFormat=new DummyInputFormat();
      inFormat.setMaxSplitSize(4 * BLOCKSIZE);
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test6): " + split);
      }
      assertEquals(3,splits.size());
      actual.clear();
      reset(mockList);
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
        mockList.add(fileSplit.getLocations()[0]);
      }
      assertEquals(9,actual.size());
      assertTrue(actual.containsAll(expected));
      verify(mockList,atLeastOnce()).add(hosts1[0]);
      inFormat=new DummyInputFormat();
      inFormat.setMaxSplitSize(7 * BLOCKSIZE);
      inFormat.setMinSplitSizeNode(3 * BLOCKSIZE);
      inFormat.setMinSplitSizeRack(3 * BLOCKSIZE);
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test7): " + split);
      }
      assertEquals(2,splits.size());
      actual.clear();
      reset(mockList);
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
        mockList.add(fileSplit.getLocations()[0]);
      }
      assertEquals(9,actual.size());
      assertTrue(actual.containsAll(expected));
      verify(mockList,atLeastOnce()).add(hosts1[0]);
      inFormat=new DummyInputFormat();
      FileInputFormat.addInputPath(job,inDir);
      inFormat.setMinSplitSizeRack(1);
      inFormat.createPool(new TestFilter(dir1),new TestFilter(dir2));
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test1): " + split);
      }
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(3,fileSplit.getNumPaths());
            expected.clear();
            expected.add(new Split(file1.getName(),BLOCKSIZE,0));
            expected.add(new Split(file2.getName(),BLOCKSIZE,0));
            expected.add(new Split(file2.getName(),BLOCKSIZE,BLOCKSIZE));
            actual.clear();
            for (int i=0; i < 3; i++) {
              String name=fileSplit.getPath(i).getName();
              long length=fileSplit.getLength(i);
              long offset=fileSplit.getOffset(i);
              actual.add(new Split(name,length,offset));
            }
            assertTrue(actual.containsAll(expected));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(6,fileSplit.getNumPaths());
            expected.clear();
            expected.add(new Split(file3.getName(),BLOCKSIZE,0));
            expected.add(new Split(file3.getName(),BLOCKSIZE,BLOCKSIZE));
            expected.add(new Split(file3.getName(),BLOCKSIZE,BLOCKSIZE * 2));
            expected.add(new Split(file4.getName(),BLOCKSIZE,0));
            expected.add(new Split(file4.getName(),BLOCKSIZE,BLOCKSIZE));
            expected.add(new Split(file4.getName(),BLOCKSIZE,BLOCKSIZE * 2));
            actual.clear();
            for (int i=0; i < 6; i++) {
              String name=fileSplit.getPath(i).getName();
              long length=fileSplit.getLength(i);
              long offset=fileSplit.getOffset(i);
              actual.add(new Split(name,length,offset));
            }
            assertTrue(actual.containsAll(expected));
            assertEquals(1,fileSplit.getLocations().length);
          }
        }
 else         if (splits.size() == 3) {
          if (split.equals(splits.get(0))) {
            assertEquals(2,fileSplit.getNumPaths());
            expected.clear();
            expected.add(new Split(file2.getName(),BLOCKSIZE,0));
            expected.add(new Split(file2.getName(),BLOCKSIZE,BLOCKSIZE));
            actual.clear();
            for (int i=0; i < 2; i++) {
              String name=fileSplit.getPath(i).getName();
              long length=fileSplit.getLength(i);
              long offset=fileSplit.getOffset(i);
              actual.add(new Split(name,length,offset));
            }
            assertTrue(actual.containsAll(expected));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(file1.getName(),fileSplit.getPath(0).getName());
            assertEquals(BLOCKSIZE,fileSplit.getLength(0));
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(2))) {
            assertEquals(6,fileSplit.getNumPaths());
            expected.clear();
            expected.add(new Split(file3.getName(),BLOCKSIZE,0));
            expected.add(new Split(file3.getName(),BLOCKSIZE,BLOCKSIZE));
            expected.add(new Split(file3.getName(),BLOCKSIZE,BLOCKSIZE * 2));
            expected.add(new Split(file4.getName(),BLOCKSIZE,0));
            expected.add(new Split(file4.getName(),BLOCKSIZE,BLOCKSIZE));
            expected.add(new Split(file4.getName(),BLOCKSIZE,BLOCKSIZE * 2));
            actual.clear();
            for (int i=0; i < 6; i++) {
              String name=fileSplit.getPath(i).getName();
              long length=fileSplit.getLength(i);
              long offset=fileSplit.getOffset(i);
              actual.add(new Split(name,length,offset));
            }
            assertTrue(actual.containsAll(expected));
            assertEquals(1,fileSplit.getLocations().length);
          }
        }
 else {
          fail("Split size should be 2 or 3.");
        }
      }
      int numPools=100;
      int numFiles=1000;
      DummyInputFormat1 inFormat1=new DummyInputFormat1();
      for (int i=0; i < numFiles; i++) {
        FileInputFormat.setInputPaths(job,file1);
      }
      inFormat1.setMinSplitSizeRack(1);
      final Path dirNoMatch1=new Path(inDir,"/dirxx");
      final Path dirNoMatch2=new Path(inDir,"/diryy");
      for (int i=0; i < numPools; i++) {
        inFormat1.createPool(new TestFilter(dirNoMatch1),new TestFilter(dirNoMatch2));
      }
      long start=System.currentTimeMillis();
      splits=inFormat1.getSplits(job);
      long end=System.currentTimeMillis();
      System.out.println("Elapsed time for " + numPools + " pools "+ " and "+ numFiles+ " files is "+ ((end - start) / 1000)+ " seconds.");
      inFormat=new DummyInputFormat();
      inFormat.setMaxSplitSize(BLOCKSIZE / 2);
      FileInputFormat.setInputPaths(job,dir3);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test8): " + split);
      }
      assertEquals(splits.size(),6);
    }
  finally {
      if (dfs != null) {
        dfs.shutdown();
      }
    }
  }
  static void writeFile(  Configuration conf,  Path name,  short replication,  int numBlocks) throws IOException, TimeoutException, InterruptedException {
    FileSystem fileSys=FileSystem.get(conf);
    FSDataOutputStream stm=fileSys.create(name,true,conf.getInt("io.file.buffer.size",4096),replication,(long)BLOCKSIZE);
    writeDataAndSetReplication(fileSys,name,stm,replication,numBlocks);
  }
  static FileStatus writeGzipFile(  Configuration conf,  Path name,  short replication,  int numBlocks) throws IOException, TimeoutException, InterruptedException {
    FileSystem fileSys=FileSystem.get(conf);
    GZIPOutputStream out=new GZIPOutputStream(fileSys.create(name,true,conf.getInt("io.file.buffer.size",4096),replication,(long)BLOCKSIZE));
    writeDataAndSetReplication(fileSys,name,out,replication,numBlocks);
    return fileSys.getFileStatus(name);
  }
  private static void writeDataAndSetReplication(  FileSystem fileSys,  Path name,  OutputStream out,  short replication,  int numBlocks) throws IOException, TimeoutException, InterruptedException {
    for (int i=0; i < numBlocks; i++) {
      out.write(databuf);
    }
    out.close();
    DFSTestUtil.waitReplication(fileSys,name,replication);
  }
  @Test public void testNodeDistribution() throws IOException, InterruptedException {
    DummyInputFormat inFormat=new DummyInputFormat();
    int numBlocks=60;
    long totLength=0;
    long blockSize=100;
    int numNodes=10;
    long minSizeNode=50;
    long minSizeRack=50;
    int maxSplitSize=200;
    String[] locations=new String[numNodes];
    for (int i=0; i < numNodes; i++) {
      locations[i]="h" + i;
    }
    String[] racks=new String[0];
    Path path=new Path("hdfs://file");
    OneBlockInfo[] blocks=new OneBlockInfo[numBlocks];
    int hostCountBase=0;
    for (int i=0; i < numBlocks; i++) {
      int localHostCount=hostCountBase;
      String[] blockHosts=new String[3];
      for (int j=0; j < 3; j++) {
        int hostNum=localHostCount % numNodes;
        blockHosts[j]="h" + hostNum;
        localHostCount++;
      }
      hostCountBase++;
      blocks[i]=new OneBlockInfo(path,i * blockSize,blockSize,blockHosts,racks);
      totLength+=blockSize;
    }
    List<InputSplit> splits=new ArrayList<InputSplit>();
    HashMap<String,Set<String>> rackToNodes=new HashMap<String,Set<String>>();
    HashMap<String,List<OneBlockInfo>> rackToBlocks=new HashMap<String,List<OneBlockInfo>>();
    HashMap<OneBlockInfo,String[]> blockToNodes=new HashMap<OneBlockInfo,String[]>();
    Map<String,Set<OneBlockInfo>> nodeToBlocks=new TreeMap<String,Set<OneBlockInfo>>();
    OneFileInfo.populateBlockInfo(blocks,rackToBlocks,blockToNodes,nodeToBlocks,rackToNodes);
    inFormat.createSplits(nodeToBlocks,blockToNodes,rackToBlocks,totLength,maxSplitSize,minSizeNode,minSizeRack,splits);
    int expectedSplitCount=(int)(totLength / maxSplitSize);
    assertEquals(expectedSplitCount,splits.size());
    int numLocalSplits=0;
    for (    InputSplit inputSplit : splits) {
      assertEquals(maxSplitSize,inputSplit.getLength());
      if (inputSplit.getLocations().length == 1) {
        numLocalSplits++;
      }
    }
    assertTrue(numLocalSplits >= 0.9 * splits.size());
  }
  @Test public void testNodeInputSplit() throws IOException, InterruptedException {
    DummyInputFormat inFormat=new DummyInputFormat();
    int numBlocks=12;
    long totLength=0;
    long blockSize=100;
    long maxSize=200;
    long minSizeNode=50;
    long minSizeRack=50;
    String[] locations={"h1","h2"};
    String[] racks=new String[0];
    Path path=new Path("hdfs://file");
    OneBlockInfo[] blocks=new OneBlockInfo[numBlocks];
    for (int i=0; i < numBlocks; ++i) {
      blocks[i]=new OneBlockInfo(path,i * blockSize,blockSize,locations,racks);
      totLength+=blockSize;
    }
    List<InputSplit> splits=new ArrayList<InputSplit>();
    HashMap<String,Set<String>> rackToNodes=new HashMap<String,Set<String>>();
    HashMap<String,List<OneBlockInfo>> rackToBlocks=new HashMap<String,List<OneBlockInfo>>();
    HashMap<OneBlockInfo,String[]> blockToNodes=new HashMap<OneBlockInfo,String[]>();
    HashMap<String,Set<OneBlockInfo>> nodeToBlocks=new HashMap<String,Set<OneBlockInfo>>();
    OneFileInfo.populateBlockInfo(blocks,rackToBlocks,blockToNodes,nodeToBlocks,rackToNodes);
    inFormat.createSplits(nodeToBlocks,blockToNodes,rackToBlocks,totLength,maxSize,minSizeNode,minSizeRack,splits);
    int expectedSplitCount=(int)(totLength / maxSize);
    assertEquals(expectedSplitCount,splits.size());
    HashMultiset<String> nodeSplits=HashMultiset.create();
    for (int i=0; i < expectedSplitCount; ++i) {
      InputSplit inSplit=splits.get(i);
      assertEquals(maxSize,inSplit.getLength());
      assertEquals(1,inSplit.getLocations().length);
      nodeSplits.add(inSplit.getLocations()[0]);
    }
    assertEquals(3,nodeSplits.count(locations[0]));
    assertEquals(3,nodeSplits.count(locations[1]));
  }
  /** 
 * The test suppresses unchecked warnings in {@link org.mockito.Mockito#reset}. Although calling the method is a bad manner, we call the method instead of splitting the test (i.e. restarting MiniDFSCluster) to save time.
 */
  @Test @SuppressWarnings("unchecked") public void testSplitPlacementForCompressedFiles() throws Exception {
    MiniDFSCluster dfs=null;
    FileSystem fileSys=null;
    try {
      Configuration conf=new Configuration();
      conf.setBoolean("dfs.replication.considerLoad",false);
      dfs=new MiniDFSCluster.Builder(conf).racks(rack1).hosts(hosts1).build();
      dfs.waitActive();
      fileSys=dfs.getFileSystem();
      if (!fileSys.mkdirs(inDir)) {
        throw new IOException("Mkdirs failed to create " + inDir.toString());
      }
      Path file1=new Path(dir1 + "/file1.gz");
      FileStatus f1=writeGzipFile(conf,file1,(short)1,1);
      Path file5=new Path(dir5 + "/file5.gz");
      FileStatus f5=writeGzipFile(conf,file5,(short)1,1);
      DummyInputFormat inFormat=new DummyInputFormat();
      Job job=Job.getInstance(conf);
      FileInputFormat.setInputPaths(job,dir1 + "," + dir5);
      List<InputSplit> splits=inFormat.getSplits(job);
      System.out.println("Made splits(Test0): " + splits.size());
      for (      InputSplit split : splits) {
        System.out.println("File split(Test0): " + split);
      }
      assertEquals(1,splits.size());
      CombineFileSplit fileSplit=(CombineFileSplit)splits.get(0);
      assertEquals(2,fileSplit.getNumPaths());
      assertEquals(1,fileSplit.getLocations().length);
      assertEquals(file1.getName(),fileSplit.getPath(0).getName());
      assertEquals(0,fileSplit.getOffset(0));
      assertEquals(f1.getLen(),fileSplit.getLength(0));
      assertEquals(file5.getName(),fileSplit.getPath(1).getName());
      assertEquals(0,fileSplit.getOffset(1));
      assertEquals(f5.getLen(),fileSplit.getLength(1));
      assertEquals(hosts1[0],fileSplit.getLocations()[0]);
      dfs.startDataNodes(conf,1,true,null,rack2,hosts2,null);
      dfs.waitActive();
      Path file2=new Path(dir2 + "/file2.gz");
      FileStatus f2=writeGzipFile(conf,file2,(short)2,2);
      inFormat=new DummyInputFormat();
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2);
      inFormat.setMinSplitSizeRack(f1.getLen());
      splits=inFormat.getSplits(job);
      System.out.println("Made splits(Test1): " + splits.size());
      for (      InputSplit split : splits) {
        System.out.println("File split(Test1): " + split);
      }
      Set<Split> expected=new HashSet<>();
      expected.add(new Split(file1.getName(),f1.getLen(),0));
      expected.add(new Split(file2.getName(),f2.getLen(),0));
      List<Split> actual=new ArrayList<>();
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file2.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(f2.getLen(),fileSplit.getLength(0));
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(file1.getName(),fileSplit.getPath(0).getName());
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(f1.getLen(),fileSplit.getLength(0));
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 1) {
          assertEquals(2,fileSplit.getNumPaths());
          assertEquals(1,fileSplit.getLocations().length);
          assertEquals(hosts1[0],fileSplit.getLocations()[0]);
        }
 else {
          fail("Split size should be 1 or 2.");
        }
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
      }
      assertEquals(2,actual.size());
      assertTrue(actual.containsAll(expected));
      dfs.startDataNodes(conf,1,true,null,rack3,hosts3,null);
      dfs.waitActive();
      Path file3=new Path(dir3 + "/file3.gz");
      FileStatus f3=writeGzipFile(conf,file3,(short)3,3);
      inFormat=new DummyInputFormat();
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3);
      inFormat.setMinSplitSizeRack(f1.getLen());
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test2): " + split);
      }
      expected.add(new Split(file3.getName(),f3.getLen(),0));
      actual.clear();
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 3) {
          if (split.equals(splits.get(0))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(file3.getName(),fileSplit.getPath(0).getName());
            assertEquals(f3.getLen(),fileSplit.getLength(0));
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts3[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(file2.getName(),fileSplit.getPath(0).getName());
            assertEquals(f2.getLen(),fileSplit.getLength(0));
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(2))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(file1.getName(),fileSplit.getPath(0).getName());
            assertEquals(f1.getLen(),fileSplit.getLength(0));
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(1,fileSplit.getLocations().length);
            if (fileSplit.getLocations()[0].equals(hosts2[0])) {
              assertEquals(2,fileSplit.getNumPaths());
            }
 else             if (fileSplit.getLocations()[0].equals(hosts3[0])) {
              assertEquals(1,fileSplit.getNumPaths());
            }
 else {
              fail("First split should be on rack2 or rack3.");
            }
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 1) {
          assertEquals(1,fileSplit.getLocations().length);
          assertEquals(3,fileSplit.getNumPaths());
          assertEquals(hosts1[0],fileSplit.getLocations()[0]);
        }
 else {
          fail("Split size should be 1, 2, or 3.");
        }
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
      }
      assertEquals(3,actual.size());
      assertTrue(actual.containsAll(expected));
      Path file4=new Path(dir4 + "/file4.gz");
      FileStatus f4=writeGzipFile(conf,file4,(short)3,3);
      inFormat=new DummyInputFormat();
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      inFormat.setMinSplitSizeRack(f1.getLen());
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test3): " + split);
      }
      expected.add(new Split(file3.getName(),f3.getLen(),0));
      actual.clear();
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 3) {
          if (split.equals(splits.get(0))) {
            assertEquals(2,fileSplit.getNumPaths());
            assertEquals(hosts3[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(file2.getName(),fileSplit.getPath(0).getName());
            assertEquals(f2.getLen(),fileSplit.getLength(0));
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(2))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(file1.getName(),fileSplit.getPath(0).getName());
            assertEquals(f1.getLen(),fileSplit.getLength(0));
            assertEquals(0,fileSplit.getOffset(0));
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(1,fileSplit.getLocations().length);
            if (fileSplit.getLocations()[0].equals(hosts2[0])) {
              assertEquals(3,fileSplit.getNumPaths());
            }
 else             if (fileSplit.getLocations()[0].equals(hosts3[0])) {
              assertEquals(2,fileSplit.getNumPaths());
            }
 else {
              fail("First split should be on rack2 or rack3.");
            }
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 1) {
          assertEquals(1,fileSplit.getLocations().length);
          assertEquals(4,fileSplit.getNumPaths());
          assertEquals(hosts1[0],fileSplit.getLocations()[0]);
        }
 else {
          fail("Split size should be 1, 2, or 3.");
        }
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
      }
      assertEquals(4,actual.size());
      assertTrue(actual.containsAll(expected));
      inFormat=new DummyInputFormat();
      inFormat.setMinSplitSizeNode(f1.getLen());
      inFormat.setMaxSplitSize(f1.getLen());
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test4): " + split);
      }
      assertEquals(4,splits.size());
      actual.clear();
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
        mockList.add(fileSplit.getLocations()[0]);
      }
      assertEquals(4,actual.size());
      assertTrue(actual.containsAll(expected));
      verify(mockList,atLeastOnce()).add(hosts1[0]);
      verify(mockList,atLeastOnce()).add(hosts2[0]);
      verify(mockList,atLeastOnce()).add(hosts3[0]);
      inFormat=new DummyInputFormat();
      inFormat.setMinSplitSizeNode(f1.getLen());
      inFormat.setMaxSplitSize(2 * f1.getLen());
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test5): " + split);
      }
      actual.clear();
      reset(mockList);
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
        mockList.add(fileSplit.getLocations()[0]);
      }
      assertEquals(4,actual.size());
      assertTrue(actual.containsAll(expected));
      if (splits.size() == 3) {
        verify(mockList,times(1)).add(hosts1[0]);
        verify(mockList,times(1)).add(hosts2[0]);
        verify(mockList,times(1)).add(hosts3[0]);
      }
 else       if (splits.size() == 2) {
        verify(mockList,times(1)).add(hosts1[0]);
      }
 else {
        fail("Split size should be 2 or 3.");
      }
      inFormat=new DummyInputFormat();
      inFormat.setMinSplitSizeNode(2 * f1.getLen());
      inFormat.setMaxSplitSize(4 * f1.getLen());
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test6): " + split);
      }
      assertTrue("Split size should be 1 or 2.",splits.size() == 1 || splits.size() == 2);
      actual.clear();
      reset(mockList);
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
        mockList.add(fileSplit.getLocations()[0]);
      }
      assertEquals(4,actual.size());
      assertTrue(actual.containsAll(expected));
      verify(mockList,times(1)).add(hosts1[0]);
      inFormat=new DummyInputFormat();
      inFormat.setMaxSplitSize(4 * f1.getLen());
      inFormat.setMinSplitSizeRack(4 * f1.getLen());
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test7): " + split);
      }
      assertEquals(1,splits.size());
      fileSplit=(CombineFileSplit)splits.get(0);
      assertEquals(4,fileSplit.getNumPaths());
      assertEquals(1,fileSplit.getLocations().length);
      assertEquals(hosts1[0],fileSplit.getLocations()[0]);
      inFormat=new DummyInputFormat();
      inFormat.setMinSplitSizeNode(4 * f1.getLen());
      FileInputFormat.setInputPaths(job,dir1 + "," + dir2+ ","+ dir3+ ","+ dir4);
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test8): " + split);
      }
      assertEquals(1,splits.size());
      fileSplit=(CombineFileSplit)splits.get(0);
      assertEquals(4,fileSplit.getNumPaths());
      assertEquals(1,fileSplit.getLocations().length);
      assertEquals(hosts1[0],fileSplit.getLocations()[0]);
      inFormat=new DummyInputFormat();
      FileInputFormat.addInputPath(job,inDir);
      inFormat.setMinSplitSizeRack(1);
      inFormat.createPool(new TestFilter(dir1),new TestFilter(dir2));
      splits=inFormat.getSplits(job);
      for (      InputSplit split : splits) {
        System.out.println("File split(Test9): " + split);
      }
      actual.clear();
      for (      InputSplit split : splits) {
        fileSplit=(CombineFileSplit)split;
        if (splits.size() == 3) {
          if (split.equals(splits.get(0))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts2[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(1,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(2))) {
            assertEquals(2,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts3[0],fileSplit.getLocations()[0]);
          }
        }
 else         if (splits.size() == 2) {
          if (split.equals(splits.get(0))) {
            assertEquals(2,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts1[0],fileSplit.getLocations()[0]);
          }
          if (split.equals(splits.get(1))) {
            assertEquals(2,fileSplit.getNumPaths());
            assertEquals(1,fileSplit.getLocations().length);
            assertEquals(hosts3[0],fileSplit.getLocations()[0]);
          }
        }
 else {
          fail("Split size should be 2 or 3.");
        }
        for (int i=0; i < fileSplit.getNumPaths(); i++) {
          String name=fileSplit.getPath(i).getName();
          long length=fileSplit.getLength(i);
          long offset=fileSplit.getOffset(i);
          actual.add(new Split(name,length,offset));
        }
      }
      assertEquals(4,actual.size());
      assertTrue(actual.containsAll(expected));
      int numPools=100;
      int numFiles=1000;
      DummyInputFormat1 inFormat1=new DummyInputFormat1();
      for (int i=0; i < numFiles; i++) {
        FileInputFormat.setInputPaths(job,file1);
      }
      inFormat1.setMinSplitSizeRack(1);
      final Path dirNoMatch1=new Path(inDir,"/dirxx");
      final Path dirNoMatch2=new Path(inDir,"/diryy");
      for (int i=0; i < numPools; i++) {
        inFormat1.createPool(new TestFilter(dirNoMatch1),new TestFilter(dirNoMatch2));
      }
      long start=System.currentTimeMillis();
      splits=inFormat1.getSplits(job);
      long end=System.currentTimeMillis();
      System.out.println("Elapsed time for " + numPools + " pools "+ " and "+ numFiles+ " files is "+ ((end - start))+ " milli seconds.");
    }
  finally {
      if (dfs != null) {
        dfs.shutdown();
      }
    }
  }
  /** 
 * Test that CFIF can handle missing blocks.
 */
  @Test public void testMissingBlocks() throws Exception {
    String namenode=null;
    MiniDFSCluster dfs=null;
    FileSystem fileSys=null;
    String testName="testMissingBlocks";
    try {
      Configuration conf=new Configuration();
      conf.set("fs.hdfs.impl",MissingBlockFileSystem.class.getName());
      conf.setBoolean("dfs.replication.considerLoad",false);
      dfs=new MiniDFSCluster.Builder(conf).racks(rack1).hosts(hosts1).build();
      dfs.waitActive();
      namenode=(dfs.getFileSystem()).getUri().getHost() + ":" + (dfs.getFileSystem()).getUri().getPort();
      fileSys=dfs.getFileSystem();
      if (!fileSys.mkdirs(inDir)) {
        throw new IOException("Mkdirs failed to create " + inDir.toString());
      }
      Path file1=new Path(dir1 + "/file1");
      writeFile(conf,file1,(short)1,1);
      Path file5=new Path(dir5 + "/file5");
      writeFile(conf,file5,(short)1,1);
      ((MissingBlockFileSystem)fileSys).setFileWithMissingBlocks(file1.toUri().getPath());
      DummyInputFormat inFormat=new DummyInputFormat();
      Job job=Job.getInstance(conf);
      FileInputFormat.setInputPaths(job,dir1 + "," + dir5);
      List<InputSplit> splits=inFormat.getSplits(job);
      System.out.println("Made splits(Test0): " + splits.size());
      for (      InputSplit split : splits) {
        System.out.println("File split(Test0): " + split);
      }
      assertEquals(splits.size(),1);
      CombineFileSplit fileSplit=(CombineFileSplit)splits.get(0);
      assertEquals(2,fileSplit.getNumPaths());
      assertEquals(1,fileSplit.getLocations().length);
      assertEquals(file1.getName(),fileSplit.getPath(0).getName());
      assertEquals(0,fileSplit.getOffset(0));
      assertEquals(BLOCKSIZE,fileSplit.getLength(0));
      assertEquals(file5.getName(),fileSplit.getPath(1).getName());
      assertEquals(0,fileSplit.getOffset(1));
      assertEquals(BLOCKSIZE,fileSplit.getLength(1));
      assertEquals(hosts1[0],fileSplit.getLocations()[0]);
    }
  finally {
      if (dfs != null) {
        dfs.shutdown();
      }
    }
  }
  /** 
 * Test when the input file's length is 0.
 */
  @Test public void testForEmptyFile() throws Exception {
    Configuration conf=new Configuration();
    FileSystem fileSys=FileSystem.get(conf);
    Path file=new Path("test" + "/file");
    FSDataOutputStream out=fileSys.create(file,true,conf.getInt("io.file.buffer.size",4096),(short)1,(long)BLOCKSIZE);
    out.write(new byte[0]);
    out.close();
    DummyInputFormat inFormat=new DummyInputFormat();
    Job job=Job.getInstance(conf);
    FileInputFormat.setInputPaths(job,"test");
    List<InputSplit> splits=inFormat.getSplits(job);
    assertEquals(1,splits.size());
    CombineFileSplit fileSplit=(CombineFileSplit)splits.get(0);
    assertEquals(1,fileSplit.getNumPaths());
    assertEquals(file.getName(),fileSplit.getPath(0).getName());
    assertEquals(0,fileSplit.getOffset(0));
    assertEquals(0,fileSplit.getLength(0));
    fileSys.delete(file.getParent(),true);
  }
  /** 
 * Test that directories do not get included as part of getSplits()
 */
  @Test public void testGetSplitsWithDirectory() throws Exception {
    MiniDFSCluster dfs=null;
    try {
      Configuration conf=new Configuration();
      dfs=new MiniDFSCluster.Builder(conf).racks(rack1).hosts(hosts1).build();
      dfs.waitActive();
      FileSystem fileSys=dfs.getFileSystem();
      Path dir1=new Path("/dir1");
      Path file=new Path("/dir1/file1");
      Path dir2=new Path("/dir1/dir2");
      if (!fileSys.mkdirs(dir1)) {
        throw new IOException("Mkdirs failed to create " + dir1.toString());
      }
      FSDataOutputStream out=fileSys.create(file);
      out.write(new byte[0]);
      out.close();
      if (!fileSys.mkdirs(dir2)) {
        throw new IOException("Mkdirs failed to create " + dir2.toString());
      }
      DummyInputFormat inFormat=new DummyInputFormat();
      Job job=Job.getInstance(conf);
      FileInputFormat.setInputPaths(job,"/dir1");
      List<InputSplit> splits=inFormat.getSplits(job);
      assertEquals(1,splits.size());
      CombineFileSplit fileSplit=(CombineFileSplit)splits.get(0);
      assertEquals(1,fileSplit.getNumPaths());
      assertEquals(file.getName(),fileSplit.getPath(0).getName());
      assertEquals(0,fileSplit.getOffset(0));
      assertEquals(0,fileSplit.getLength(0));
    }
  finally {
      if (dfs != null) {
        dfs.shutdown();
      }
    }
  }
  /** 
 * Test when input files are from non-default file systems
 */
  @Test public void testForNonDefaultFileSystem() throws Throwable {
    Configuration conf=new Configuration();
    conf.set(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY,DUMMY_FS_URI);
    assertEquals(DUMMY_FS_URI,FileSystem.getDefaultUri(conf).toString());
    String localPathRoot=System.getProperty("test.build.data","build/test/data");
    Path localPath=new Path(localPathRoot,"testFile1");
    FileSystem lfs=FileSystem.getLocal(conf);
    FSDataOutputStream dos=lfs.create(localPath);
    dos.writeChars("Local file for CFIF");
    dos.close();
    Job job=Job.getInstance(conf);
    FileInputFormat.setInputPaths(job,lfs.makeQualified(localPath));
    DummyInputFormat inFormat=new DummyInputFormat();
    List<InputSplit> splits=inFormat.getSplits(job);
    assertTrue(splits.size() > 0);
    for (    InputSplit s : splits) {
      CombineFileSplit cfs=(CombineFileSplit)s;
      for (      Path p : cfs.getPaths()) {
        assertEquals(p.toUri().getScheme(),"file");
      }
    }
  }
static class TestFilter implements PathFilter {
    private Path p;
    public TestFilter(    Path p){
      this.p=p;
    }
    public boolean accept(    Path path){
      if (path.toUri().getPath().indexOf(p.toString()) == 0) {
        return true;
      }
      return false;
    }
    public String toString(){
      return "PathFilter:" + p;
    }
  }
  private void splitRealFiles(  String[] args) throws IOException {
    Configuration conf=new Configuration();
    Job job=Job.getInstance();
    FileSystem fs=FileSystem.get(conf);
    if (!(fs instanceof DistributedFileSystem)) {
      throw new IOException("Wrong file system: " + fs.getClass().getName());
    }
    long blockSize=fs.getDefaultBlockSize();
    DummyInputFormat inFormat=new DummyInputFormat();
    for (int i=0; i < args.length; i++) {
      FileInputFormat.addInputPaths(job,args[i]);
    }
    inFormat.setMinSplitSizeRack(blockSize);
    inFormat.setMaxSplitSize(10 * blockSize);
    List<InputSplit> splits=inFormat.getSplits(job);
    System.out.println("Total number of splits " + splits.size());
    for (int i=0; i < splits.size(); ++i) {
      CombineFileSplit fileSplit=(CombineFileSplit)splits.get(i);
      System.out.println("Split[" + i + "] "+ fileSplit);
    }
  }
  public static void main(  String[] args) throws Exception {
    if (args.length != 0) {
      TestCombineFileInputFormat test=new TestCombineFileInputFormat();
      test.splitRealFiles(args);
    }
 else {
      TestCombineFileInputFormat test=new TestCombineFileInputFormat();
      test.testSplitPlacement();
    }
  }
}
