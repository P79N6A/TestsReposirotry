/** 
 * This class tests the creation and validation of a checkpoint.
 */
public class TestSecurityTokenEditLog {
  static final int NUM_DATA_NODES=1;
  static final int NUM_TRANSACTIONS=100;
  static final int NUM_THREADS=100;
  static final int opsPerTrans=3;
static {
    EditLogFileOutputStream.setShouldSkipFsyncForTesting(true);
  }
static class Transactions implements Runnable {
    final FSNamesystem namesystem;
    final int numTransactions;
    short replication=3;
    long blockSize=64;
    Transactions(    FSNamesystem ns,    int num){
      namesystem=ns;
      numTransactions=num;
    }
    @Override public void run(){
      FSEditLog editLog=namesystem.getEditLog();
      for (int i=0; i < numTransactions; i++) {
        try {
          String renewer=UserGroupInformation.getLoginUser().getUserName();
          Token<DelegationTokenIdentifier> token=namesystem.getDelegationToken(new Text(renewer));
          namesystem.renewDelegationToken(token);
          namesystem.cancelDelegationToken(token);
          editLog.logSync();
        }
 catch (        IOException e) {
          System.out.println("Transaction " + i + " encountered exception "+ e);
        }
      }
    }
  }
  /** 
 * Tests transaction logging in dfs.
 */
  @Test public void testEditLog() throws IOException {
    Configuration conf=new HdfsConfiguration();
    MiniDFSCluster cluster=null;
    FileSystem fileSys=null;
    try {
      conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,true);
      cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).build();
      cluster.waitActive();
      fileSys=cluster.getFileSystem();
      final FSNamesystem namesystem=cluster.getNamesystem();
      for (Iterator<URI> it=cluster.getNameDirs(0).iterator(); it.hasNext(); ) {
        File dir=new File(it.next().getPath());
        System.out.println(dir);
      }
      FSImage fsimage=namesystem.getFSImage();
      FSEditLog editLog=fsimage.getEditLog();
      editLog.setOutputBufferCapacity(2048);
      Thread threadId[]=new Thread[NUM_THREADS];
      for (int i=0; i < NUM_THREADS; i++) {
        Transactions trans=new Transactions(namesystem,NUM_TRANSACTIONS);
        threadId[i]=new Thread(trans,"TransactionThread-" + i);
        threadId[i].start();
      }
      for (int i=0; i < NUM_THREADS; i++) {
        try {
          threadId[i].join();
        }
 catch (        InterruptedException e) {
          i--;
        }
      }
      editLog.close();
      namesystem.getDelegationTokenSecretManager().stopThreads();
      int numKeys=namesystem.getDelegationTokenSecretManager().getNumberOfKeys();
      int expectedTransactions=NUM_THREADS * opsPerTrans * NUM_TRANSACTIONS + numKeys + 2;
      for (      StorageDirectory sd : fsimage.getStorage().dirIterable(NameNodeDirType.EDITS)) {
        File editFile=NNStorage.getFinalizedEditsFile(sd,1,1 + expectedTransactions - 1);
        System.out.println("Verifying file: " + editFile);
        FSEditLogLoader loader=new FSEditLogLoader(namesystem,0);
        long numEdits=loader.loadFSEdits(new EditLogFileInputStream(editFile),1);
        assertEquals("Verification for " + editFile,expectedTransactions,numEdits);
      }
    }
  finally {
      if (fileSys != null)       fileSys.close();
      if (cluster != null)       cluster.shutdown();
    }
  }
  @Test(timeout=10000) public void testEditsForCancelOnTokenExpire() throws IOException, InterruptedException {
    long renewInterval=2000;
    Configuration conf=new Configuration();
    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,true);
    conf.setLong(DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY,renewInterval);
    conf.setLong(DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY,renewInterval * 2);
    Text renewer=new Text(UserGroupInformation.getCurrentUser().getUserName());
    FSImage fsImage=mock(FSImage.class);
    FSEditLog log=mock(FSEditLog.class);
    doReturn(log).when(fsImage).getEditLog();
    final AtomicReference<FSNamesystem> fsnRef=new AtomicReference<>();
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        Assert.assertTrue(fsnRef.get().hasReadLock());
        Assert.assertFalse(fsnRef.get().hasWriteLock());
        return null;
      }
    }
).when(log).logCancelDelegationToken(any(DelegationTokenIdentifier.class));
    FSNamesystem fsn=new FSNamesystem(conf,fsImage);
    fsnRef.set(fsn);
    DelegationTokenSecretManager dtsm=fsn.getDelegationTokenSecretManager();
    try {
      dtsm.startThreads();
      Token<DelegationTokenIdentifier> token1=fsn.getDelegationToken(renewer);
      Token<DelegationTokenIdentifier> token2=fsn.getDelegationToken(renewer);
      DelegationTokenIdentifier ident1=token1.decodeIdentifier();
      DelegationTokenIdentifier ident2=token2.decodeIdentifier();
      verify(log,times(1)).logGetDelegationToken(eq(ident1),anyLong());
      verify(log,times(1)).logGetDelegationToken(eq(ident2),anyLong());
      Thread.sleep(renewInterval / 2);
      fsn.renewDelegationToken(token2);
      verify(log,times(1)).logRenewDelegationToken(eq(ident2),anyLong());
      dtsm.stopThreads();
      dtsm.startThreads();
      Thread.sleep(250);
      verify(log,times(0)).logCancelDelegationToken(eq(ident1));
      verify(log,times(0)).logCancelDelegationToken(eq(ident2));
      Thread.sleep(renewInterval / 2);
      dtsm.stopThreads();
      dtsm.startThreads();
      Thread.sleep(250);
      verify(log,times(1)).logCancelDelegationToken(eq(ident1));
      verify(log,times(0)).logCancelDelegationToken(eq(ident2));
      Thread.sleep(renewInterval / 2);
      dtsm.stopThreads();
      dtsm.startThreads();
      Thread.sleep(250);
      verify(log,times(1)).logCancelDelegationToken(eq(ident1));
      verify(log,times(1)).logCancelDelegationToken(eq(ident2));
    }
  finally {
      dtsm.stopThreads();
    }
  }
}
