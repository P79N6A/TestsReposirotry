/** 
 * Test AM restart functions.
 */
public class TestAMRestart extends ParameterizedSchedulerTestBase {
  public TestAMRestart(  SchedulerType type) throws IOException {
    super(type);
  }
  @Test(timeout=30000) public void testAMRestartWithExistingContainers() throws Exception {
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    MockRM rm1=new MockRM(getConf());
    rm1.start();
    RMApp app1=rm1.submitApp(200,"name","user",new HashMap<ApplicationAccessType,String>(),false,"default",-1,null,"MAPREDUCE",false,true);
    MockNM nm1=new MockNM("127.0.0.1:1234",10240,rm1.getResourceTrackerService());
    nm1.registerNode();
    MockNM nm2=new MockNM("127.0.0.1:2351",4089,rm1.getResourceTrackerService());
    nm2.registerNode();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    int NUM_CONTAINERS=3;
    allocateContainers(nm1,am1,NUM_CONTAINERS);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),2,ContainerState.RUNNING);
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),3,ContainerState.RUNNING);
    ContainerId containerId3=ContainerId.newContainerId(am1.getApplicationAttemptId(),3);
    rm1.waitForState(nm1,containerId3,RMContainerState.RUNNING);
    ContainerId containerId4=ContainerId.newContainerId(am1.getApplicationAttemptId(),4);
    rm1.waitForState(nm1,containerId4,RMContainerState.ACQUIRED);
    am1.allocate("127.0.0.1",1024,1,new ArrayList<ContainerId>());
    nm1.nodeHeartbeat(true);
    ContainerId containerId5=ContainerId.newContainerId(am1.getApplicationAttemptId(),5);
    rm1.waitForState(nm1,containerId5,RMContainerState.ALLOCATED);
    am1.allocate("127.0.0.1",6000,1,new ArrayList<ContainerId>());
    ContainerId containerId6=ContainerId.newContainerId(am1.getApplicationAttemptId(),6);
    nm1.nodeHeartbeat(true);
    SchedulerApplicationAttempt schedulerAttempt=((AbstractYarnScheduler)rm1.getResourceScheduler()).getCurrentAttemptForContainer(containerId6);
    while (schedulerAttempt.getReservedContainers().isEmpty()) {
      System.out.println("Waiting for container " + containerId6 + " to be reserved.");
      nm1.nodeHeartbeat(true);
      Thread.sleep(200);
    }
    Assert.assertEquals(containerId6,schedulerAttempt.getReservedContainers().get(0).getContainerId());
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    Thread.sleep(3000);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    Assert.assertNull(rm1.getResourceScheduler().getRMContainer(containerId4));
    Assert.assertNull(rm1.getResourceScheduler().getRMContainer(containerId5));
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    ApplicationAttemptId newAttemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    Assert.assertFalse(newAttemptId.equals(am1.getApplicationAttemptId()));
    MockAM am2=rm1.launchAM(app1,rm1,nm1);
    RegisterApplicationMasterResponse registerResponse=am2.registerAppAttempt();
    Assert.assertEquals(2,registerResponse.getContainersFromPreviousAttempts().size());
    boolean containerId2Exists=false, containerId3Exists=false;
    for (    Container container : registerResponse.getContainersFromPreviousAttempts()) {
      if (container.getId().equals(containerId2)) {
        containerId2Exists=true;
      }
      if (container.getId().equals(containerId3)) {
        containerId3Exists=true;
      }
    }
    Assert.assertTrue(containerId2Exists && containerId3Exists);
    rm1.waitForState(app1.getApplicationId(),RMAppState.RUNNING);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),3,ContainerState.COMPLETE);
    RMAppAttempt newAttempt=app1.getRMAppAttempt(am2.getApplicationAttemptId());
    waitForContainersToFinish(4,newAttempt);
    boolean container3Exists=false, container4Exists=false, container5Exists=false, container6Exists=false;
    for (    ContainerStatus status : newAttempt.getJustFinishedContainers()) {
      if (status.getContainerId().equals(containerId3)) {
        container3Exists=true;
      }
      if (status.getContainerId().equals(containerId4)) {
        container4Exists=true;
      }
      if (status.getContainerId().equals(containerId5)) {
        container5Exists=true;
      }
      if (status.getContainerId().equals(containerId6)) {
        container6Exists=true;
      }
    }
    Assert.assertTrue(container3Exists && container4Exists && container5Exists&& container6Exists);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    SchedulerApplicationAttempt schedulerNewAttempt=((AbstractYarnScheduler)rm1.getResourceScheduler()).getCurrentAttemptForContainer(containerId2);
    MockRM.finishAMAndVerifyAppState(app1,rm1,nm1,am2);
    Assert.assertFalse(schedulerNewAttempt.getLiveContainers().contains(containerId2));
    System.out.println("New attempt's just finished containers: " + newAttempt.getJustFinishedContainers());
    waitForContainersToFinish(5,newAttempt);
    rm1.stop();
  }
  public static List<Container> allocateContainers(  MockNM nm1,  MockAM am1,  int NUM_CONTAINERS) throws Exception {
    am1.allocate("127.0.0.1",1024,NUM_CONTAINERS,new ArrayList<ContainerId>());
    nm1.nodeHeartbeat(true);
    List<Container> containers=am1.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers();
    while (containers.size() != NUM_CONTAINERS) {
      nm1.nodeHeartbeat(true);
      containers.addAll(am1.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>()).getAllocatedContainers());
      Thread.sleep(200);
    }
    Assert.assertEquals("Did not get all containers allocated",NUM_CONTAINERS,containers.size());
    return containers;
  }
  private void waitForContainersToFinish(  int expectedNum,  RMAppAttempt attempt) throws InterruptedException {
    int count=0;
    while (attempt.getJustFinishedContainers().size() < expectedNum && count < 500) {
      Thread.sleep(100);
      count++;
    }
  }
  @Test(timeout=30000) public void testNMTokensRebindOnAMRestart() throws Exception {
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,3);
    getConf().setFloat(YarnConfiguration.AM_SCHEDULING_NODE_BLACKLISTING_DISABLE_THRESHOLD,0.5f);
    MockRM rm1=new MockRM(getConf());
    rm1.start();
    RMApp app1=rm1.submitApp(200,"myname","myuser",new HashMap<ApplicationAccessType,String>(),false,"default",-1,null,"MAPREDUCE",false,true);
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm1.getResourceTrackerService());
    nm1.registerNode();
    MockNM nm2=new MockNM("127.1.1.1:4321",8000,rm1.getResourceTrackerService());
    nm2.registerNode();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    List<Container> containers=new ArrayList<Container>();
    List<NMToken> expectedNMTokens=new ArrayList<NMToken>();
    while (true) {
      AllocateResponse response=am1.allocate("127.0.0.1",2000,2,new ArrayList<ContainerId>());
      nm1.nodeHeartbeat(true);
      containers.addAll(response.getAllocatedContainers());
      expectedNMTokens.addAll(response.getNMTokens());
      if (containers.size() == 2) {
        break;
      }
      Thread.sleep(200);
      System.out.println("Waiting for container to be allocated.");
    }
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),2,ContainerState.RUNNING);
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),3,ContainerState.RUNNING);
    ContainerId containerId3=ContainerId.newContainerId(am1.getApplicationAttemptId(),3);
    rm1.waitForState(nm1,containerId3,RMContainerState.RUNNING);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am2=MockRM.launchAM(app1,rm1,nm1);
    RegisterApplicationMasterResponse registerResponse=am2.registerAppAttempt();
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    Assert.assertEquals(expectedNMTokens.size(),registerResponse.getNMTokensFromPreviousAttempts().size());
    for (int i=0; i < expectedNMTokens.size(); i++) {
      Assert.assertTrue(expectedNMTokens.get(i).equals(registerResponse.getNMTokensFromPreviousAttempts().get(i)));
    }
    containers=new ArrayList<Container>();
    while (true) {
      AllocateResponse allocateResponse=am2.allocate("127.1.1.1",4000,1,new ArrayList<ContainerId>());
      nm2.nodeHeartbeat(true);
      containers.addAll(allocateResponse.getAllocatedContainers());
      expectedNMTokens.addAll(allocateResponse.getNMTokens());
      if (containers.size() == 1) {
        break;
      }
      Thread.sleep(200);
      System.out.println("Waiting for container to be allocated.");
    }
    nm1.nodeHeartbeat(am2.getApplicationAttemptId(),2,ContainerState.RUNNING);
    ContainerId am2ContainerId2=ContainerId.newContainerId(am2.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,am2ContainerId2,RMContainerState.RUNNING);
    nm1.nodeHeartbeat(am2.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am3=MockRM.launchAM(app1,rm1,nm1);
    registerResponse=am3.registerAppAttempt();
    rm1.waitForState(am3.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    List<NMToken> transferredTokens=registerResponse.getNMTokensFromPreviousAttempts();
    Assert.assertEquals(2,transferredTokens.size());
    Assert.assertTrue(transferredTokens.containsAll(expectedNMTokens));
    rm1.stop();
  }
  @Test(timeout=100000) public void testShouldNotCountFailureToMaxAttemptRetry() throws Exception {
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    getConf().setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
    getConf().set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    MockRM rm1=new MockRM(getConf());
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app1=rm1.submitApp(200);
    RMAppAttempt attempt1=app1.getCurrentAppAttempt();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm1.getResourceScheduler();
    ContainerId amContainer=ContainerId.newContainerId(am1.getApplicationAttemptId(),1);
    scheduler.killContainer(scheduler.getRMContainer(amContainer));
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am1.getApplicationAttemptId());
    Assert.assertTrue(!attempt1.shouldCountTowardsMaxAttemptRetry());
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    ApplicationStateData appState=((MemoryRMStateStore)rm1.getRMStateStore()).getState().getApplicationState().get(app1.getApplicationId());
    MockAM am2=rm1.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),2,nm1);
    RMAppAttempt attempt2=app1.getCurrentAppAttempt();
    ContainerId amContainer2=ContainerId.newContainerId(am2.getApplicationAttemptId(),1);
    scheduler.killContainer(scheduler.getRMContainer(amContainer2));
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am2.getApplicationAttemptId());
    Assert.assertTrue(!attempt2.shouldCountTowardsMaxAttemptRetry());
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am3=rm1.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),3,nm1);
    RMAppAttempt attempt3=app1.getCurrentAppAttempt();
    ContainerStatus containerStatus=Records.newRecord(ContainerStatus.class);
    containerStatus.setContainerId(attempt3.getMasterContainer().getId());
    containerStatus.setDiagnostics("mimic NM disk_failure");
    containerStatus.setState(ContainerState.COMPLETE);
    containerStatus.setExitStatus(ContainerExitStatus.DISKS_FAILED);
    Map<ApplicationId,List<ContainerStatus>> conts=new HashMap<ApplicationId,List<ContainerStatus>>();
    conts.put(app1.getApplicationId(),Collections.singletonList(containerStatus));
    nm1.nodeHeartbeat(conts,true);
    rm1.waitForState(am3.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am3.getApplicationAttemptId());
    Assert.assertTrue(!attempt3.shouldCountTowardsMaxAttemptRetry());
    Assert.assertEquals(ContainerExitStatus.DISKS_FAILED,appState.getAttempt(am3.getApplicationAttemptId()).getAMContainerExitStatus());
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am4=rm1.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),4,nm1);
    RMAppAttempt attempt4=app1.getCurrentAppAttempt();
    MockNM nm2=new MockNM("127.0.0.1:2234",8000,rm1.getResourceTrackerService());
    nm2.registerNode();
    nm1.nodeHeartbeat(false);
    rm1.waitForState(am4.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am4.getApplicationAttemptId());
    Assert.assertFalse(attempt4.shouldCountTowardsMaxAttemptRetry());
    Assert.assertEquals(ContainerExitStatus.ABORTED,appState.getAttempt(am4.getApplicationAttemptId()).getAMContainerExitStatus());
    MockAM am5=rm1.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),5,nm2);
    RMAppAttempt attempt5=app1.getCurrentAppAttempt();
    nm2.nodeHeartbeat(am5.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am5.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am5.getApplicationAttemptId());
    Assert.assertTrue(attempt5.shouldCountTowardsMaxAttemptRetry());
    MockAM am6=rm1.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),6,nm2);
    RMAppAttempt attempt6=app1.getCurrentAppAttempt();
    nm2.nodeHeartbeat(am6.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am6.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am6.getApplicationAttemptId());
    Assert.assertTrue(attempt6.shouldCountTowardsMaxAttemptRetry());
    rm1.waitForState(app1.getApplicationId(),RMAppState.FAILED);
    Assert.assertEquals(6,app1.getAppAttempts().size());
    rm1.stop();
  }
  @Test(timeout=100000) public void testMaxAttemptOneMeansOne() throws Exception {
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,1);
    getConf().setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
    getConf().set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    MockRM rm1=new MockRM(getConf());
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app1=rm1.submitApp(200);
    RMAppAttempt attempt1=app1.getCurrentAppAttempt();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm1.getResourceScheduler();
    ContainerId amContainer=ContainerId.newContainerId(am1.getApplicationAttemptId(),1);
    scheduler.killContainer(scheduler.getRMContainer(amContainer));
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am1.getApplicationAttemptId());
    rm1.waitForState(app1.getApplicationId(),RMAppState.FAILED);
    Assert.assertEquals(1,app1.getAppAttempts().size());
    rm1.stop();
  }
  @Test(timeout=60000) public void testPreemptedAMRestartOnRMRestart() throws Exception {
    getConf().setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
    getConf().setBoolean(YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_ENABLED,false);
    getConf().set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    MockRM rm1=new MockRM(getConf());
    MemoryRMStateStore memStore=(MemoryRMStateStore)rm1.getRMStateStore();
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app1=rm1.submitApp(200);
    RMAppAttempt attempt1=app1.getCurrentAppAttempt();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm1.getResourceScheduler();
    ContainerId amContainer=ContainerId.newContainerId(am1.getApplicationAttemptId(),1);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am1.getApplicationAttemptId());
    Assert.assertTrue(attempt1.shouldCountTowardsMaxAttemptRetry());
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am2=rm1.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),2,nm1);
    RMAppAttempt attempt2=app1.getCurrentAppAttempt();
    amContainer=ContainerId.newContainerId(am2.getApplicationAttemptId(),1);
    scheduler.killContainer(scheduler.getRMContainer(amContainer));
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    Assert.assertFalse(attempt2.shouldCountTowardsMaxAttemptRetry());
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    ApplicationStateData appState=memStore.getState().getApplicationState().get(app1.getApplicationId());
    Assert.assertEquals(2,appState.getAttemptCount());
    if (getSchedulerType().equals(SchedulerType.FAIR)) {
      Assert.assertEquals(ContainerExitStatus.KILLED_BY_RESOURCEMANAGER,appState.getAttempt(am2.getApplicationAttemptId()).getAMContainerExitStatus());
    }
 else {
      Assert.assertEquals(ContainerExitStatus.PREEMPTED,appState.getAttempt(am2.getApplicationAttemptId()).getAMContainerExitStatus());
    }
    MockRM rm2=new MockRM(getConf(),memStore);
    nm1.setResourceTrackerService(rm2.getResourceTrackerService());
    nm1.registerNode();
    rm2.start();
    MockAM am3=rm2.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),2,nm1);
    MockRM.finishAMAndVerifyAppState(app1,rm2,nm1,am3);
    RMAppAttempt attempt3=rm2.getRMContext().getRMApps().get(app1.getApplicationId()).getCurrentAppAttempt();
    Assert.assertTrue(attempt3.shouldCountTowardsMaxAttemptRetry());
    Assert.assertEquals(ContainerExitStatus.INVALID,appState.getAttempt(am3.getApplicationAttemptId()).getAMContainerExitStatus());
    rm1.stop();
    rm2.stop();
  }
  @Test(timeout=50000) public void testRMRestartOrFailoverNotCountedForAMFailures() throws Exception {
    getConf().setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
    getConf().setBoolean(YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_ENABLED,false);
    getConf().set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    MockRM rm1=new MockRM(getConf());
    MemoryRMStateStore memStore=(MemoryRMStateStore)rm1.getRMStateStore();
    rm1.start();
    AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm1.getResourceScheduler();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app1=rm1.submitApp(200);
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    RMAppAttempt attempt1=app1.getCurrentAppAttempt();
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped(scheduler,am1.getApplicationAttemptId());
    Assert.assertTrue(attempt1.shouldCountTowardsMaxAttemptRetry());
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am2=rm1.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),2,nm1);
    RMAppAttempt attempt2=app1.getCurrentAppAttempt();
    MockRM rm2=new MockRM(getConf(),memStore);
    rm2.start();
    ApplicationStateData appState=memStore.getState().getApplicationState().get(app1.getApplicationId());
    nm1.setResourceTrackerService(rm2.getResourceTrackerService());
    NMContainerStatus status=Records.newRecord(NMContainerStatus.class);
    status.setContainerExitStatus(ContainerExitStatus.KILLED_BY_RESOURCEMANAGER);
    status.setContainerId(attempt2.getMasterContainer().getId());
    status.setContainerState(ContainerState.COMPLETE);
    status.setDiagnostics("");
    nm1.registerNode(Collections.singletonList(status),null);
    rm2.waitForState(attempt2.getAppAttemptId(),RMAppAttemptState.FAILED);
    Assert.assertEquals(ContainerExitStatus.KILLED_BY_RESOURCEMANAGER,appState.getAttempt(am2.getApplicationAttemptId()).getAMContainerExitStatus());
    rm2.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am3=rm2.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),3,nm1);
    MockRM.finishAMAndVerifyAppState(app1,rm2,nm1,am3);
    RMAppAttempt attempt3=rm2.getRMContext().getRMApps().get(app1.getApplicationId()).getCurrentAppAttempt();
    Assert.assertTrue(attempt3.shouldCountTowardsMaxAttemptRetry());
    Assert.assertEquals(ContainerExitStatus.INVALID,appState.getAttempt(am3.getApplicationAttemptId()).getAMContainerExitStatus());
    rm1.stop();
    rm2.stop();
  }
  @Test(timeout=120000) public void testRMAppAttemptFailuresValidityInterval() throws Exception {
    getConf().setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
    getConf().setBoolean(YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_ENABLED,false);
    getConf().set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    MockRM rm1=new MockRM(getConf());
    rm1.start();
    MockMemoryRMStateStore memStore=(MockMemoryRMStateStore)rm1.getRMStateStore();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMApp app=rm1.submitApp(200,60000,false);
    MockAM am=MockRM.launchAM(app,rm1,nm1);
    nm1.nodeHeartbeat(am.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app.getApplicationId(),RMAppState.ACCEPTED);
    Assert.assertEquals(2,app.getAppAttempts().size());
    MockAM am_2=MockRM.launchAndRegisterAM(app,rm1,nm1);
    rm1.waitForState(am_2.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    nm1.nodeHeartbeat(am_2.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am_2.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app.getApplicationId(),RMAppState.FAILED);
    ControlledClock clock=new ControlledClock();
    RMAppImpl app1=(RMAppImpl)rm1.submitApp(200,10000,false);
    app1.setSystemClock(clock);
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    Thread.sleep(15 * 1000);
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    Assert.assertEquals(2,app1.getAppAttempts().size());
    RMAppAttempt attempt2=app1.getCurrentAppAttempt();
    MockAM am2=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    clock.setTime(System.currentTimeMillis() + 10 * 1000);
    nm1.nodeHeartbeat(am2.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    Assert.assertEquals(3,app1.getAppAttempts().size());
    RMAppAttempt attempt3=app1.getCurrentAppAttempt();
    clock.reset();
    MockAM am3=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    rm1.waitForState(am3.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    @SuppressWarnings("resource") MockRM rm2=new MockRM(getConf(),memStore);
    rm2.start();
    MockMemoryRMStateStore memStore1=(MockMemoryRMStateStore)rm2.getRMStateStore();
    ApplicationStateData app1State=memStore1.getState().getApplicationState().get(app1.getApplicationId());
    Assert.assertEquals(1,app1State.getFirstAttemptId());
    nm1.setResourceTrackerService(rm2.getResourceTrackerService());
    NMContainerStatus status=Records.newRecord(NMContainerStatus.class);
    status.setContainerExitStatus(ContainerExitStatus.KILLED_BY_RESOURCEMANAGER);
    status.setContainerId(attempt3.getMasterContainer().getId());
    status.setContainerState(ContainerState.COMPLETE);
    status.setDiagnostics("");
    nm1.registerNode(Collections.singletonList(status),null);
    rm2.waitForState(attempt3.getAppAttemptId(),RMAppAttemptState.FAILED);
    Thread.sleep(15 * 1000);
    Assert.assertEquals(2,app1State.getAttemptCount());
    rm2.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am4=rm2.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),4,nm1);
    clock.setTime(System.currentTimeMillis() + 10 * 1000);
    nm1.nodeHeartbeat(am4.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm2.waitForState(am4.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    Assert.assertEquals(2,app1State.getAttemptCount());
    rm2.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    MockAM am5=rm2.waitForNewAMToLaunchAndRegister(app1.getApplicationId(),5,nm1);
    clock.reset();
    rm2.waitForState(am5.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    nm1.nodeHeartbeat(am5.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm2.waitForState(am5.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    Assert.assertEquals(2,app1State.getAttemptCount());
    rm2.waitForState(app1.getApplicationId(),RMAppState.FAILED);
    rm1.stop();
    rm2.stop();
  }
  private boolean isContainerIdInContainerStatus(  List<ContainerStatus> containerStatuses,  ContainerId containerId){
    for (    ContainerStatus status : containerStatuses) {
      if (status.getContainerId().equals(containerId)) {
        return true;
      }
    }
    return false;
  }
  @Test(timeout=40000) public void testAMRestartNotLostContainerCompleteMsg() throws Exception {
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    MockRM rm1=new MockRM(getConf());
    rm1.start();
    RMApp app1=rm1.submitApp(200,"name","user",new HashMap<ApplicationAccessType,String>(),false,"default",-1,null,"MAPREDUCE",false,true);
    MockNM nm1=new MockNM("127.0.0.1:1234",10240,rm1.getResourceTrackerService());
    nm1.registerNode();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    allocateContainers(nm1,am1,1);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),2,ContainerState.RUNNING);
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),2,ContainerState.COMPLETE);
    rm1.waitForState(nm1,containerId2,RMContainerState.COMPLETED);
    while (true) {
      AllocateResponse response=am1.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>());
      List<ContainerStatus> containerStatuses=response.getCompletedContainersStatuses();
      if (isContainerIdInContainerStatus(containerStatuses,containerId2) == false) {
        Thread.sleep(100);
        continue;
      }
      containerStatuses=app1.getCurrentAppAttempt().getJustFinishedContainers();
      if (isContainerIdInContainerStatus(containerStatuses,containerId2)) {
        Assert.fail();
      }
      break;
    }
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    ApplicationAttemptId newAttemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    Assert.assertFalse(newAttemptId.equals(am1.getApplicationAttemptId()));
    RMAppAttempt attempt2=app1.getCurrentAppAttempt();
    MockAM am2=rm1.launchAndRegisterAM(app1,rm1,nm1);
    AllocateResponse allocateResponse=am2.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>());
    List<ContainerStatus> containerStatuses=allocateResponse.getCompletedContainersStatuses();
    if (isContainerIdInContainerStatus(containerStatuses,containerId2) == false) {
      Assert.fail();
    }
    containerStatuses=attempt2.getJustFinishedContainers();
    if (isContainerIdInContainerStatus(containerStatuses,containerId2)) {
      Assert.fail();
    }
    allocateResponse=am2.allocate(new ArrayList<ResourceRequest>(),new ArrayList<ContainerId>());
    containerStatuses=allocateResponse.getCompletedContainersStatuses();
    if (isContainerIdInContainerStatus(containerStatuses,containerId2)) {
      Assert.fail();
    }
    rm1.stop();
  }
  @Test(timeout=20000) public void testAMRestartNotLostContainerAfterAttemptFailuresValidityInterval() throws Exception {
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    MockRM rm1=new MockRM(getConf());
    rm1.start();
    MockNM nm1=new MockNM("127.0.0.1:1234",8000,rm1.getResourceTrackerService());
    nm1.registerNode();
    RMAppImpl app1=(RMAppImpl)rm1.submitApp(200,10000,true);
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    int NUM_CONTAINERS=2;
    allocateContainers(nm1,am1,NUM_CONTAINERS);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),2,ContainerState.RUNNING);
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    Assert.assertEquals(2,app1.getAppAttempts().size());
    RMAppAttempt attempt2=app1.getCurrentAppAttempt();
    MockAM am2=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.RUNNING);
    Thread.sleep(10 * 1000);
    nm1.nodeHeartbeat(am2.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am2.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    rm1.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    Assert.assertEquals(3,app1.getAppAttempts().size());
    MockAM am3=rm1.launchAM(app1,rm1,nm1);
    RegisterApplicationMasterResponse registerResponse=am3.registerAppAttempt();
    Assert.assertEquals(1,registerResponse.getContainersFromPreviousAttempts().size());
    boolean containerId2Exists=false;
    Container container=registerResponse.getContainersFromPreviousAttempts().get(0);
    if (container.getId().equals(containerId2)) {
      containerId2Exists=true;
    }
    Assert.assertTrue(containerId2Exists);
    rm1.waitForState(app1.getApplicationId(),RMAppState.RUNNING);
    rm1.stop();
  }
  @Test(timeout=200000) public void testContainersFromPreviousAttemptsWithRMRestart() throws Exception {
    getConf().setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
    getConf().setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
    getConf().setBoolean(YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_ENABLED,true);
    getConf().setLong(YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_SCHEDULING_WAIT_MS,0);
    getConf().set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
    MockRM rm1=new MockRM(getConf());
    MemoryRMStateStore memStore=(MemoryRMStateStore)rm1.getRMStateStore();
    rm1.start();
    YarnScheduler scheduler=rm1.getResourceScheduler();
    String nm1Address="127.0.0.1:1234";
    MockNM nm1=new MockNM(nm1Address,10240,rm1.getResourceTrackerService());
    nm1.registerNode();
    String nm2Address="127.0.0.1:2351";
    MockNM nm2=new MockNM(nm2Address,4089,rm1.getResourceTrackerService());
    nm2.registerNode();
    RMApp app1=rm1.submitApp(200,"name","user",new HashMap<>(),false,"default",-1,null,"MAPREDUCE",false,true);
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm1,nm1);
    allocateContainers(nm1,am1,1);
    allocateContainers(nm2,am1,1);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),2,ContainerState.RUNNING);
    ContainerId containerId2=ContainerId.newContainerId(am1.getApplicationAttemptId(),2);
    rm1.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    nm2.nodeHeartbeat(am1.getApplicationAttemptId(),3,ContainerState.RUNNING);
    ContainerId containerId3=ContainerId.newContainerId(am1.getApplicationAttemptId(),3);
    rm1.waitForState(nm2,containerId3,RMContainerState.RUNNING);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),1,ContainerState.COMPLETE);
    rm1.waitForState(am1.getApplicationAttemptId(),RMAppAttemptState.FAILED);
    TestSchedulerUtils.waitSchedulerApplicationAttemptStopped((AbstractYarnScheduler)scheduler,am1.getApplicationAttemptId());
    MockRM rm2=new MockRM(getConf(),memStore);
    rm2.start();
    nm1.setResourceTrackerService(rm2.getResourceTrackerService());
    NMContainerStatus container2Status=TestRMRestart.createNMContainerStatus(am1.getApplicationAttemptId(),2,ContainerState.RUNNING);
    nm1.registerNode(Lists.newArrayList(container2Status),null);
    Thread.sleep(3000);
    nm1.nodeHeartbeat(am1.getApplicationAttemptId(),2,ContainerState.RUNNING);
    rm2.waitForState(nm1,containerId2,RMContainerState.RUNNING);
    Assert.assertNotNull(rm2.getResourceScheduler().getRMContainer(containerId2));
    rm2.waitForState(app1.getApplicationId(),RMAppState.ACCEPTED);
    ApplicationAttemptId newAttemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    Assert.assertFalse(newAttemptId.equals(am1.getApplicationAttemptId()));
    MockAM am2=MockRM.launchAMWhenAsyncSchedulingEnabled(app1,rm2);
    RegisterApplicationMasterResponse registerResponse=am2.registerAppAttempt();
    Assert.assertEquals(1,registerResponse.getContainersFromPreviousAttempts().size());
    Assert.assertEquals("container 2",containerId2,registerResponse.getContainersFromPreviousAttempts().get(0).getId());
    List<NMToken> prevNMTokens=registerResponse.getNMTokensFromPreviousAttempts();
    Assert.assertEquals(1,prevNMTokens.size());
    Assert.assertEquals(nm1Address,prevNMTokens.get(0).getNodeId().toString());
    rm2.waitForState(app1.getApplicationId(),RMAppState.RUNNING);
    nm2.setResourceTrackerService(rm2.getResourceTrackerService());
    NMContainerStatus container3Status=TestRMRestart.createNMContainerStatus(am1.getApplicationAttemptId(),3,ContainerState.RUNNING);
    nm2.registerNode(Lists.newArrayList(container3Status),null);
    nm2.nodeHeartbeat(am1.getApplicationAttemptId(),3,ContainerState.RUNNING);
    rm2.waitForState(nm2,containerId3,RMContainerState.RUNNING);
    Assert.assertNotNull(rm2.getResourceScheduler().getRMContainer(containerId3));
    List<Container> containersFromPreviousAttempts=new ArrayList<>();
    GenericTestUtils.waitFor(() -> {
      try {
        AllocateResponse allocateResponse=am2.doHeartbeat();
        if (allocateResponse.getContainersFromPreviousAttempts().size() > 0) {
          containersFromPreviousAttempts.addAll(allocateResponse.getContainersFromPreviousAttempts());
          Assert.assertEquals("new containers should not be allocated",0,allocateResponse.getAllocatedContainers().size());
          List<NMToken> nmTokens=allocateResponse.getNMTokens();
          Assert.assertEquals(1,nmTokens.size());
          Assert.assertEquals(nm2Address,nmTokens.get(0).getNodeId().toString());
          return true;
        }
      }
 catch (      Exception e) {
        Throwables.propagate(e);
      }
      return false;
    }
,2000,200000);
    Assert.assertEquals("container 3",containerId3,containersFromPreviousAttempts.get(0).getId());
    rm2.stop();
    rm1.stop();
  }
}
