static class Runner implements Runnable {
  static final int NUM_RUNNERS=5;
  static int index2arrayLength(  int index){
    return ByteArrayManager.MIN_ARRAY_LENGTH << (index - 1);
  }
  private final ByteArrayManager bam;
  final int maxArrayLength;
  final int countThreshold;
  final int maxArrays;
  final ExecutorService pool;
  final List<Future<byte[]>> arrays=new ArrayList<Future<byte[]>>();
  final AtomicInteger count=new AtomicInteger();
  final int p;
  private int n;
  final List<AssertionError> assertionErrors=new ArrayList<AssertionError>();
  Runner(  int index,  int countThreshold,  int maxArrays,  ExecutorService pool,  int p,  ByteArrayManager bam){
    this.maxArrayLength=index2arrayLength(index);
    this.countThreshold=countThreshold;
    this.maxArrays=maxArrays;
    this.pool=pool;
    this.p=p;
    this.bam=bam;
  }
  boolean isEmpty(){
synchronized (arrays) {
      return arrays.isEmpty();
    }
  }
  Future<byte[]> submitAllocate(){
    count.incrementAndGet();
    final Future<byte[]> f=pool.submit(new Callable<byte[]>(){
      @Override public byte[] call() throws Exception {
        final int lower=maxArrayLength == ByteArrayManager.MIN_ARRAY_LENGTH ? 0 : maxArrayLength >> 1;
        final int arrayLength=ThreadLocalRandom.current().nextInt(maxArrayLength - lower) + lower + 1;
        final byte[] array=bam.newByteArray(arrayLength);
        try {
          Assert.assertEquals("arrayLength=" + arrayLength + ", lower="+ lower,maxArrayLength,array.length);
        }
 catch (        AssertionError e) {
          assertionErrors.add(e);
        }
        return array;
      }
    }
);
synchronized (arrays) {
      arrays.add(f);
    }
    return f;
  }
  Future<byte[]> removeFirst() throws Exception {
synchronized (arrays) {
      return remove(arrays,0);
    }
  }
  void recycle() throws Exception {
    final Future<byte[]> f=removeFirst();
    if (f != null) {
      printf("randomRecycler: ");
      try {
        recycle(f.get(10,TimeUnit.MILLISECONDS));
      }
 catch (      TimeoutException e) {
        recycle(new byte[maxArrayLength]);
        printf("timeout, new byte[%d]\n",maxArrayLength);
      }
    }
  }
  int recycle(  final byte[] array){
    return bam.release(array);
  }
  Future<Integer> submitRecycle(  final byte[] array){
    count.decrementAndGet();
    final Future<Integer> f=pool.submit(new Callable<Integer>(){
      @Override public Integer call() throws Exception {
        return recycle(array);
      }
    }
);
    return f;
  }
  @Override public void run(){
    for (int i=0; i < n; i++) {
      final boolean isAllocate=ThreadLocalRandom.current().nextInt(NUM_RUNNERS) < p;
      if (isAllocate) {
        submitAllocate();
      }
 else {
        try {
          final Future<byte[]> f=removeFirst();
          if (f != null) {
            submitRecycle(f.get());
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
          Assert.fail(this + " has " + e);
        }
      }
      if ((i & 0xFF) == 0) {
        sleepMs(100);
      }
    }
  }
  Thread start(  int n){
    this.n=n;
    final Thread t=new Thread(this);
    t.start();
    return t;
  }
  @Override public String toString(){
    return getClass().getSimpleName() + ": max=" + maxArrayLength+ ", count="+ count;
  }
}
