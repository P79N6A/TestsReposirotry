public class TestThrottledAsyncCheckerTimeout {
  public static final org.slf4j.Logger LOG=LoggerFactory.getLogger(TestThrottledAsyncCheckerTimeout.class);
  @Rule public TestName testName=new TestName();
  @Rule public Timeout testTimeout=new Timeout(300_000);
  private static final long DISK_CHECK_TIMEOUT=10;
  private ReentrantLock lock;
  private ExecutorService getExecutorService(){
    return new ScheduledThreadPoolExecutor(1);
  }
  @Before public void initializeLock(){
    lock=new ReentrantLock();
  }
  @Test public void testDiskCheckTimeout() throws Exception {
    LOG.info("Executing {}",testName.getMethodName());
    final DummyCheckable target=new DummyCheckable();
    final FakeTimer timer=new FakeTimer();
    ThrottledAsyncChecker<Boolean,Boolean> checker=new ThrottledAsyncChecker<>(timer,0,DISK_CHECK_TIMEOUT,getExecutorService());
    lock.lock();
    final Optional<ListenableFuture<Boolean>> olf=checker.schedule(target,true);
    final AtomicLong numCallbackInvocationsSuccess=new AtomicLong(0);
    final AtomicLong numCallbackInvocationsFailure=new AtomicLong(0);
    AtomicBoolean callbackResult=new AtomicBoolean(false);
    final Throwable[] throwable=new Throwable[1];
    assertTrue(olf.isPresent());
    Futures.addCallback(olf.get(),new FutureCallback<Boolean>(){
      @Override public void onSuccess(      Boolean result){
        numCallbackInvocationsSuccess.incrementAndGet();
        callbackResult.set(true);
      }
      @Override public void onFailure(      Throwable t){
        throwable[0]=t;
        numCallbackInvocationsFailure.incrementAndGet();
        callbackResult.set(true);
      }
    }
);
    while (!callbackResult.get()) {
      Thread.sleep(DISK_CHECK_TIMEOUT);
    }
    lock.unlock();
    assertThat(numCallbackInvocationsFailure.get(),is(1L));
    assertThat(numCallbackInvocationsSuccess.get(),is(0L));
    assertTrue(throwable[0] instanceof TimeoutException);
  }
  @Test public void testDiskCheckTimeoutInvokesOneCallbackOnly() throws Exception {
    LOG.info("Executing {}",testName.getMethodName());
    final DummyCheckable target=new DummyCheckable();
    final FakeTimer timer=new FakeTimer();
    ThrottledAsyncChecker<Boolean,Boolean> checker=new ThrottledAsyncChecker<>(timer,0,DISK_CHECK_TIMEOUT,getExecutorService());
    FutureCallback<Boolean> futureCallback=mock(FutureCallback.class);
    lock.lock();
    final Optional<ListenableFuture<Boolean>> olf1=checker.schedule(target,true);
    assertTrue(olf1.isPresent());
    Futures.addCallback(olf1.get(),futureCallback);
    verify(futureCallback,timeout((int)DISK_CHECK_TIMEOUT * 10).times(1)).onFailure(any());
    verify(futureCallback,timeout((int)DISK_CHECK_TIMEOUT * 10).times(0)).onSuccess(any());
    lock.unlock();
    final Optional<ListenableFuture<Boolean>> olf2=checker.schedule(target,true);
    assertTrue(olf2.isPresent());
    Futures.addCallback(olf2.get(),futureCallback);
    verify(futureCallback,timeout((int)DISK_CHECK_TIMEOUT * 10).times(1)).onFailure(any());
    verify(futureCallback,timeout((int)DISK_CHECK_TIMEOUT * 10).times(1)).onSuccess(any());
  }
  @Test public void testTimeoutExceptionIsNotThrownForGoodDisk() throws Exception {
    LOG.info("Executing {}",testName.getMethodName());
    final DummyCheckable target=new DummyCheckable();
    final FakeTimer timer=new FakeTimer();
    ThrottledAsyncChecker<Boolean,Boolean> checker=new ThrottledAsyncChecker<>(timer,0,DISK_CHECK_TIMEOUT,getExecutorService());
    final Optional<ListenableFuture<Boolean>> olf=checker.schedule(target,true);
    AtomicBoolean callbackResult=new AtomicBoolean(false);
    final Throwable[] throwable=new Throwable[1];
    assertTrue(olf.isPresent());
    Futures.addCallback(olf.get(),new FutureCallback<Boolean>(){
      @Override public void onSuccess(      Boolean result){
        callbackResult.set(true);
      }
      @Override public void onFailure(      Throwable t){
        throwable[0]=t;
        callbackResult.set(true);
      }
    }
);
    while (!callbackResult.get()) {
      Thread.sleep(DISK_CHECK_TIMEOUT);
    }
    assertTrue(throwable[0] == null);
  }
  /** 
 * A dummy Checkable that just returns true after acquiring lock.
 */
protected class DummyCheckable implements Checkable<Boolean,Boolean> {
    @Override public Boolean check(    Boolean context) throws Exception {
      lock.lock();
      lock.unlock();
      return true;
    }
  }
}
