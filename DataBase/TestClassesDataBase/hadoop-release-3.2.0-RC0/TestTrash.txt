/** 
 * This class tests commands from Trash.
 */
public class TestTrash {
  private final static File BASE_PATH=new File(GenericTestUtils.getTempPath("testTrash"));
  private final static Path TEST_DIR=new Path(BASE_PATH.getAbsolutePath());
  @Before public void setUp() throws IOException {
    FileSystem.closeAll();
  }
  protected static Path mkdir(  FileSystem fs,  Path p) throws IOException {
    assertTrue(fs.mkdirs(p));
    assertTrue(fs.exists(p));
    assertTrue(fs.getFileStatus(p).isDirectory());
    return p;
  }
  protected static void checkTrash(  FileSystem trashFs,  Path trashRoot,  Path path) throws IOException {
    Path p=Path.mergePaths(trashRoot,path);
    assertTrue("Could not find file in trash: " + p,trashFs.exists(p));
  }
  protected static int countSameDeletedFiles(  FileSystem fs,  Path trashDir,  Path fileName) throws IOException {
    final String prefix=fileName.getName();
    System.out.println("Counting " + fileName + " in "+ trashDir.toString());
    PathFilter pf=new PathFilter(){
      @Override public boolean accept(      Path file){
        return file.getName().startsWith(prefix);
      }
    }
;
    FileStatus[] fss=fs.listStatus(trashDir,pf);
    return fss == null ? 0 : fss.length;
  }
  static void checkNotInTrash(  FileSystem fs,  Path trashRoot,  String pathname) throws IOException {
    Path p=new Path(trashRoot + "/" + new Path(pathname).getName());
    assertTrue(!fs.exists(p));
  }
  /** 
 * Test trash for the shell's delete command for the file system fs
 * @param fs
 * @param base - the base path where files are created
 * @throws IOException
 */
  public static void trashShell(  final FileSystem fs,  final Path base) throws IOException {
    Configuration conf=new Configuration();
    conf.set("fs.defaultFS",fs.getUri().toString());
    trashShell(conf,base,null,null);
  }
  /** 
 * Test trash for the shell's delete command for the default file system specified in the paramter conf
 * @param conf 
 * @param base - the base path where files are created
 * @param trashRoot - the expected place where the trashbin resides
 * @throws IOException
 */
  public static void trashShell(  final Configuration conf,  final Path base,  FileSystem trashRootFs,  Path trashRoot) throws IOException {
    FileSystem fs=FileSystem.get(conf);
    conf.setLong(FS_TRASH_INTERVAL_KEY,0);
    assertFalse(new Trash(conf).isEnabled());
    conf.setLong(FS_TRASH_INTERVAL_KEY,-1);
    assertFalse(new Trash(conf).isEnabled());
    conf.setLong(FS_TRASH_INTERVAL_KEY,10);
    assertTrue(new Trash(conf).isEnabled());
    FsShell shell=new FsShell();
    shell.setConf(conf);
    if (trashRoot == null) {
      trashRoot=shell.getCurrentTrashDir();
    }
    if (trashRootFs == null) {
      trashRootFs=fs;
    }
    Path myPath=new Path(base,"test/mkdirs");
    mkdir(fs,myPath);
    Path myFile=new Path(base,"test/mkdirs/myFile");
    writeFile(fs,myFile,10);
{
      String[] args=new String[1];
      args[0]="-expunge";
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
    }
{
      String[] args=new String[2];
      args[0]="-rm";
      args[1]=myFile.toString();
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
      checkTrash(trashRootFs,trashRoot,fs.makeQualified(myFile));
    }
    writeFile(fs,myFile,10);
{
      String[] args=new String[2];
      args[0]="-rm";
      args[1]=new Path(base,"test/mkdirs/myFile").toString();
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
    }
    writeFile(fs,myFile,10);
{
      String[] args=new String[2];
      args[0]="-rmr";
      args[1]=new Path(base,"test/mkdirs").toString();
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
    }
    mkdir(fs,myPath);
{
      String[] args=new String[2];
      args[0]="-rmr";
      args[1]=new Path(base,"test/mkdirs").toString();
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
    }
{
      Path toErase=new Path(trashRoot,"toErase");
      int retVal=-1;
      writeFile(trashRootFs,toErase,10);
      try {
        retVal=shell.run(new String[]{"-rm",toErase.toString()});
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(retVal == 0);
      checkNotInTrash(trashRootFs,trashRoot,toErase.toString());
      checkNotInTrash(trashRootFs,trashRoot,toErase.toString() + ".1");
    }
{
      String[] args=new String[1];
      args[0]="-expunge";
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
    }
    checkNotInTrash(trashRootFs,trashRoot,new Path(base,"test/mkdirs/myFile").toString());
    mkdir(fs,myPath);
    writeFile(fs,myFile,10);
{
      String[] args=new String[2];
      args[0]="-rm";
      args[1]=myFile.toString();
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
      checkTrash(trashRootFs,trashRoot,myFile);
      args=new String[2];
      args[0]="-rmr";
      args[1]=myPath.toString();
      val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
      checkTrash(trashRootFs,trashRoot,myPath);
    }
{
      String[] args=new String[2];
      args[0]="-rmr";
      args[1]=trashRoot.getParent().getParent().toString();
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertEquals("exit code",1,val);
      assertTrue(trashRootFs.exists(trashRoot));
    }
    mkdir(fs,myPath);
    writeFile(fs,myFile,10);
{
      String[] args=new String[3];
      args[0]="-rm";
      args[1]="-skipTrash";
      args[2]=myFile.toString();
      int val=-1;
      try {
        assertEquals("-expunge failed",0,shell.run(new String[]{"-expunge"}));
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertFalse("Expected TrashRoot (" + trashRoot + ") to exist in file system:"+ trashRootFs.getUri(),trashRootFs.exists(trashRoot));
      assertFalse(fs.exists(myFile));
      assertTrue(val == 0);
    }
    mkdir(fs,myPath);
    writeFile(fs,myFile,10);
{
      String[] args=new String[3];
      args[0]="-rmr";
      args[1]="-skipTrash";
      args[2]=myPath.toString();
      int val=-1;
      try {
        assertEquals(0,shell.run(new String[]{"-expunge"}));
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertFalse(trashRootFs.exists(trashRoot));
      assertFalse(fs.exists(myPath));
      assertFalse(fs.exists(myFile));
      assertTrue(val == 0);
    }
{
      int val=-1;
      mkdir(fs,myPath);
      try {
        assertEquals(0,shell.run(new String[]{"-expunge"}));
      }
 catch (      Exception e) {
        System.err.println("Exception raised from fs expunge " + e.getLocalizedMessage());
      }
      myFile=new Path(base,"test/mkdirs/myFile");
      String[] args=new String[]{"-rm",myFile.toString()};
      int num_runs=10;
      for (int i=0; i < num_runs; i++) {
        writeFile(fs,myFile,10);
        try {
          val=shell.run(args);
        }
 catch (        Exception e) {
          System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
        }
        assertTrue(val == 0);
      }
      Path trashDir=Path.mergePaths(new Path(trashRoot.toUri().getPath()),new Path(myFile.getParent().toUri().getPath()));
      System.out.println("Deleting same myFile: myFile.parent=" + myFile.getParent().toUri().getPath() + "; trashroot="+ trashRoot.toUri().getPath()+ "; trashDir="+ trashDir.toUri().getPath());
      int count=countSameDeletedFiles(fs,trashDir,myFile);
      System.out.println("counted " + count + " files "+ myFile.getName()+ "* in "+ trashDir);
      assertTrue(count == num_runs);
    }
{
      String[] args=new String[2];
      args[0]="-rmr";
      args[1]="/";
      PrintStream stdout=System.out;
      PrintStream stderr=System.err;
      ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
      PrintStream newOut=new PrintStream(byteStream);
      System.setOut(newOut);
      System.setErr(newOut);
      try {
        shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      String output=byteStream.toString();
      System.setOut(stdout);
      System.setErr(stderr);
      assertTrue("skipTrash wasn't suggested as remedy to failed rm command" + " or we deleted / even though we could not get server defaults",output.indexOf("Consider using -skipTrash option") != -1 || output.indexOf("Failed to determine server trash configuration") != -1);
    }
{
      long trashInterval=conf.getLong(FS_TRASH_INTERVAL_KEY,FS_TRASH_INTERVAL_DEFAULT);
      long now=Time.now();
      DateFormat oldCheckpointFormat=new SimpleDateFormat("yyMMddHHmm");
      Path dirToDelete=new Path(trashRoot.getParent(),oldCheckpointFormat.format(now - (trashInterval * 60 * 1000) - 1));
      Path dirToKeep=new Path(trashRoot.getParent(),oldCheckpointFormat.format(now));
      mkdir(trashRootFs,dirToDelete);
      mkdir(trashRootFs,dirToKeep);
      int rc=-1;
      try {
        rc=shell.run(new String[]{"-expunge"});
      }
 catch (      Exception e) {
        System.err.println("Exception raised from fs expunge " + e.getLocalizedMessage());
      }
      assertEquals(0,rc);
      assertFalse("old checkpoint format not recognized",trashRootFs.exists(dirToDelete));
      assertTrue("old checkpoint format directory should not be removed",trashRootFs.exists(dirToKeep));
    }
  }
  public static void trashNonDefaultFS(  Configuration conf) throws IOException {
    conf.setLong(FS_TRASH_INTERVAL_KEY,10);
{
      final FileSystem lfs=FileSystem.getLocal(conf);
      Path p=TEST_DIR;
      Path f=new Path(p,"foo/bar");
      if (lfs.exists(p)) {
        lfs.delete(p,true);
      }
      try {
        writeFile(lfs,f,10);
        FileSystem.closeAll();
        FileSystem localFs=FileSystem.get(URI.create("file:///"),conf);
        Trash lTrash=new Trash(localFs,conf);
        lTrash.moveToTrash(f.getParent());
        checkTrash(localFs,lTrash.getCurrentTrashDir(),f);
      }
  finally {
        if (lfs.exists(p)) {
          lfs.delete(p,true);
        }
      }
    }
  }
  @Test public void testTrash() throws IOException {
    Configuration conf=new Configuration();
    conf.setClass("fs.file.impl",TestLFS.class,FileSystem.class);
    trashShell(FileSystem.getLocal(conf),TEST_DIR);
  }
  @Test public void testExistingFileTrash() throws IOException {
    Configuration conf=new Configuration();
    conf.setClass("fs.file.impl",TestLFS.class,FileSystem.class);
    FileSystem fs=FileSystem.getLocal(conf);
    conf.set("fs.defaultFS",fs.getUri().toString());
    conf.setLong(FS_TRASH_INTERVAL_KEY,0);
    assertFalse(new Trash(conf).isEnabled());
    conf.setLong(FS_TRASH_INTERVAL_KEY,-1);
    assertFalse(new Trash(conf).isEnabled());
    conf.setLong(FS_TRASH_INTERVAL_KEY,10);
    assertTrue(new Trash(conf).isEnabled());
    FsShell shell=new FsShell();
    shell.setConf(conf);
    Path myPath=new Path(TEST_DIR,"test/mkdirs");
    mkdir(fs,myPath);
    Path myFile=new Path(TEST_DIR,"test/mkdirs/myExistingFile");
    writeFile(fs,myFile,10);
    mkdir(fs,myPath);
    writeFile(fs,myFile,10);
    String[] args1=new String[2];
    args1[0]="-rm";
    args1[1]=myFile.toString();
    int val1=-1;
    try {
      val1=shell.run(args1);
    }
 catch (    Exception e) {
      System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
    }
    assertTrue(val1 == 0);
    mkdir(fs,myFile);
    writeFile(fs,new Path(myFile,"mySubFile"),10);
    String[] args2=new String[2];
    args2[0]="-rm";
    args2[1]=new Path(myFile,"mySubFile").toString();
    int val2=-1;
    try {
      val2=shell.run(args2);
    }
 catch (    Exception e) {
      System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
    }
    assertTrue(val2 == 0);
  }
  @Test public void testNonDefaultFS() throws IOException {
    Configuration conf=new Configuration();
    conf.setClass("fs.file.impl",TestLFS.class,FileSystem.class);
    conf.set("fs.defaultFS","invalid://host/bar/foo");
    trashNonDefaultFS(conf);
  }
  @Test public void testPluggableTrash() throws IOException {
    Configuration conf=new Configuration();
    conf.setClass("fs.trash.classname",TestTrashPolicy.class,TrashPolicy.class);
    Trash trash=new Trash(conf);
    assertTrue(trash.getTrashPolicy().getClass().equals(TestTrashPolicy.class));
  }
  @Test public void testCheckpointInterval() throws IOException {
    verifyDefaultPolicyIntervalValues(10,12,10);
    verifyDefaultPolicyIntervalValues(10,5,5);
    verifyDefaultPolicyIntervalValues(10,0,10);
    verifyDefaultPolicyIntervalValues(10,-1,10);
  }
  @Test public void testMoveEmptyDirToTrash() throws Exception {
    Configuration conf=new Configuration();
    conf.setClass(FS_FILE_IMPL_KEY,RawLocalFileSystem.class,FileSystem.class);
    conf.setLong(FS_TRASH_INTERVAL_KEY,1);
    FileSystem fs=FileSystem.get(conf);
    verifyMoveEmptyDirToTrash(fs,conf);
  }
  /** 
 * Simulate the carrier process of the trash emptier restarts, verify it honors the <b>fs.trash.interval</b> before and after restart.
 * @throws Exception
 */
  @Test public void testTrashRestarts() throws Exception {
    Configuration conf=new Configuration();
    conf.setClass("fs.trash.classname",AuditableTrashPolicy.class,TrashPolicy.class);
    conf.setClass("fs.file.impl",TestLFS.class,FileSystem.class);
    conf.set(FS_TRASH_INTERVAL_KEY,"50");
    Trash trash=new Trash(conf);
    for (int i=0; i < 5; i++) {
      trash.checkpoint();
    }
    verifyAuditableTrashEmptier(trash,120,3);
    conf.set(FS_TRASH_INTERVAL_KEY,"100");
    Trash trashNew=new Trash(conf);
    verifyAuditableTrashEmptier(trashNew,120,2);
  }
  @Test public void testTrashPermission() throws IOException {
    Configuration conf=new Configuration();
    conf.setClass("fs.trash.classname",TrashPolicyDefault.class,TrashPolicy.class);
    conf.setClass("fs.file.impl",TestLFS.class,FileSystem.class);
    conf.set(FS_TRASH_INTERVAL_KEY,"0.2");
    verifyTrashPermission(FileSystem.getLocal(conf),conf);
  }
  @Test public void testTrashEmptier() throws Exception {
    Configuration conf=new Configuration();
    conf.set(FS_TRASH_INTERVAL_KEY,"0.2");
    conf.setClass("fs.file.impl",TestLFS.class,FileSystem.class);
    conf.set(FS_TRASH_CHECKPOINT_INTERVAL_KEY,"0.1");
    FileSystem fs=FileSystem.getLocal(conf);
    conf.set("fs.default.name",fs.getUri().toString());
    Trash trash=new Trash(conf);
    Runnable emptier=trash.getEmptier();
    Thread emptierThread=new Thread(emptier);
    emptierThread.start();
    FsShell shell=new FsShell();
    shell.setConf(conf);
    shell.init();
    Path myPath=new Path(TEST_DIR,"test/mkdirs");
    mkdir(fs,myPath);
    int fileIndex=0;
    Set<String> checkpoints=new HashSet<String>();
    while (true) {
      Path myFile=new Path(TEST_DIR,"test/mkdirs/myFile" + fileIndex++);
      writeFile(fs,myFile,10);
      String[] args=new String[2];
      args[0]="-rm";
      args[1]=myFile.toString();
      int val=-1;
      try {
        val=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
      }
      assertTrue(val == 0);
      Path trashDir=shell.getCurrentTrashDir();
      FileStatus files[]=fs.listStatus(trashDir.getParent());
      for (      FileStatus file : files) {
        String fileName=file.getPath().getName();
        checkpoints.add(fileName);
      }
      if (checkpoints.size() == 4) {
        assertTrue(checkpoints.size() > files.length);
        break;
      }
      Thread.sleep(5000);
    }
    emptierThread.interrupt();
    emptierThread.join();
  }
  @After public void tearDown() throws IOException {
    File trashDir=new File(TEST_DIR.toUri().getPath());
    if (trashDir.exists() && !FileUtil.fullyDelete(trashDir)) {
      throw new IOException("Cannot remove data directory: " + trashDir);
    }
  }
static class TestLFS extends LocalFileSystem {
    Path home;
    TestLFS(){
      this(TEST_DIR);
    }
    TestLFS(    final Path home){
      super(new RawLocalFileSystem(){
        @Override protected Path getInitialWorkingDirectory(){
          return makeQualified(home);
        }
        @Override public Path getHomeDirectory(){
          return makeQualified(home);
        }
      }
);
      this.home=home;
    }
    @Override public Path getHomeDirectory(){
      return home;
    }
  }
  /** 
 * test same file deletion - multiple time this is more of a performance test - shouldn't be run as a unit test
 * @throws IOException
 */
  public static void performanceTestDeleteSameFile() throws IOException {
    Path base=TEST_DIR;
    Configuration conf=new Configuration();
    conf.setClass("fs.file.impl",TestLFS.class,FileSystem.class);
    FileSystem fs=FileSystem.getLocal(conf);
    conf.set("fs.defaultFS",fs.getUri().toString());
    conf.setLong(FS_TRASH_INTERVAL_KEY,10);
    FsShell shell=new FsShell();
    shell.setConf(conf);
    Path myPath=new Path(base,"test/mkdirs");
    mkdir(fs,myPath);
    Path myFile;
    long start;
    long first=0;
    int retVal=0;
    int factor=10;
    myFile=new Path(base,"test/mkdirs/myFile");
    String[] args=new String[]{"-rm",myFile.toString()};
    int iters=1000;
    for (int i=0; i < iters; i++) {
      writeFile(fs,myFile,10);
      start=Time.now();
      try {
        retVal=shell.run(args);
      }
 catch (      Exception e) {
        System.err.println("Exception raised from Trash.run " + e.getLocalizedMessage());
        throw new IOException(e.getMessage());
      }
      assertTrue(retVal == 0);
      long iterTime=Time.now() - start;
      if (i < 10) {
        if (i == 0) {
          first=iterTime;
        }
 else {
          first=(first + iterTime) / 2;
        }
      }
      int print_freq=iters / 10;
      if (i > 10) {
        if ((i % print_freq) == 0)         System.out.println("iteration=" + i + ";res ="+ retVal+ "; start="+ start+ "; iterTime = "+ iterTime+ " vs. firstTime="+ first);
        long factoredTime=first * factor;
        assertTrue(iterTime < factoredTime);
      }
    }
  }
  public static void verifyMoveEmptyDirToTrash(  FileSystem fs,  Configuration conf) throws IOException {
    Path caseRoot=new Path(GenericTestUtils.getTempPath("testUserTrash"));
    Path testRoot=new Path(caseRoot,"trash-users");
    Path emptyDir=new Path(testRoot,"empty-dir");
    try (FileSystem fileSystem=fs){
      fileSystem.mkdirs(emptyDir);
      Trash trash=new Trash(fileSystem,conf);
      Path trashRoot=trash.getCurrentTrashDir(emptyDir);
      fileSystem.delete(trashRoot,true);
      assertTrue("Move an empty directory to trash failed",trash.moveToTrash(emptyDir));
      assertFalse("The empty directory still exists on file system",fileSystem.exists(emptyDir));
      emptyDir=fileSystem.makeQualified(emptyDir);
      Path dirInTrash=Path.mergePaths(trashRoot,emptyDir);
      assertTrue("Directory wasn't moved to trash",fileSystem.exists(dirInTrash));
      FileStatus[] flist=fileSystem.listStatus(dirInTrash);
      assertTrue("Directory is not empty",flist != null && flist.length == 0);
    }
   }
  /** 
 * Create a bunch of files and set with different permission, after moved to trash, verify the location in trash directory is expected and the permission is reserved.
 * @throws IOException
 */
  public static void verifyTrashPermission(  FileSystem fs,  Configuration conf) throws IOException {
    Path caseRoot=new Path(BASE_PATH.getPath(),"testTrashPermission");
    try (FileSystem fileSystem=fs){
      Trash trash=new Trash(fileSystem,conf);
      FileSystemTestWrapper wrapper=new FileSystemTestWrapper(fileSystem);
      short[] filePermssions={(short)0600,(short)0644,(short)0660,(short)0700,(short)0750,(short)0755,(short)0775,(short)0777};
      for (int i=0; i < filePermssions.length; i++) {
        FsPermission fsPermission=new FsPermission(filePermssions[i]);
        Path file=new Path(caseRoot,"file" + i);
        byte[] randomBytes=new byte[new Random().nextInt(10)];
        wrapper.writeFile(file,randomBytes);
        wrapper.setPermission(file,fsPermission);
        trash.moveToTrash(file);
        Path trashDir=trash.getCurrentTrashDir(file);
        if (!file.isAbsolute()) {
          file=wrapper.makeQualified(file);
        }
        Path fileInTrash=Path.mergePaths(trashDir,file);
        FileStatus fstat=wrapper.getFileStatus(fileInTrash);
        assertTrue(String.format("File %s is not moved to trash",fileInTrash.toString()),wrapper.exists(fileInTrash));
        assertTrue(String.format("Expected file: %s is %s, but actual is %s",fileInTrash.toString(),fsPermission.toString(),fstat.getPermission().toString()),fstat.getPermission().equals(fsPermission));
      }
      Path trashRoot=trash.getCurrentTrashDir();
      assertTrue(wrapper.delete(trashRoot,true));
    }
   }
  private void verifyDefaultPolicyIntervalValues(  long trashInterval,  long checkpointInterval,  long expectedInterval) throws IOException {
    Configuration conf=new Configuration();
    conf.setLong(FS_TRASH_INTERVAL_KEY,trashInterval);
    conf.set("fs.trash.classname",TrashPolicyDefault.class.getName());
    conf.setLong(FS_TRASH_CHECKPOINT_INTERVAL_KEY,checkpointInterval);
    Trash trash=new Trash(conf);
    Emptier emptier=(Emptier)trash.getEmptier();
    assertEquals(expectedInterval,emptier.getEmptierInterval());
  }
  /** 
 * Launch the  {@link Trash} emptier for given milliseconds,verify the number of checkpoints is expected.
 */
  private void verifyAuditableTrashEmptier(  Trash trash,  long timeAlive,  int expectedNumOfCheckpoints) throws IOException {
    Thread emptierThread=null;
    try {
      Runnable emptier=trash.getEmptier();
      emptierThread=new Thread(emptier);
      emptierThread.start();
      Thread.sleep(timeAlive);
      emptierThread.interrupt();
      emptierThread.join();
      AuditableTrashPolicy at=(AuditableTrashPolicy)trash.getTrashPolicy();
      assertEquals(String.format("Expected num of checkpoints is %s, but actual is %s",expectedNumOfCheckpoints,at.getNumberOfCheckpoints()),expectedNumOfCheckpoints,at.getNumberOfCheckpoints());
    }
 catch (    InterruptedException e) {
    }
 finally {
      if (emptierThread != null) {
        emptierThread.interrupt();
      }
    }
  }
public static class TestTrashPolicy extends TrashPolicy {
    public TestTrashPolicy(){
    }
    @Override public void initialize(    Configuration conf,    FileSystem fs,    Path home){
    }
    @Override public void initialize(    Configuration conf,    FileSystem fs){
    }
    @Override public boolean isEnabled(){
      return false;
    }
    @Override public boolean moveToTrash(    Path path) throws IOException {
      return false;
    }
    @Override public void createCheckpoint() throws IOException {
    }
    @Override public void deleteCheckpoint() throws IOException {
    }
    @Override public Path getCurrentTrashDir(){
      return null;
    }
    @Override public Path getCurrentTrashDir(    Path path) throws IOException {
      return null;
    }
    @Override public Runnable getEmptier() throws IOException {
      return null;
    }
  }
  /** 
 * A fake  {@link TrashPolicy} implementation, it keeps a counton number of checkpoints in the trash. It doesn't do anything other than updating the count.
 */
public static class AuditableTrashPolicy extends TrashPolicy {
    public AuditableTrashPolicy(){
    }
    public AuditableTrashPolicy(    Configuration conf) throws IOException {
      this.initialize(conf,null);
    }
    @Override @Deprecated public void initialize(    Configuration conf,    FileSystem fs,    Path home){
      this.deletionInterval=(long)(conf.getFloat(FS_TRASH_INTERVAL_KEY,FS_TRASH_INTERVAL_DEFAULT));
    }
    @Override public void initialize(    Configuration conf,    FileSystem fs){
      this.deletionInterval=(long)(conf.getFloat(FS_TRASH_INTERVAL_KEY,FS_TRASH_INTERVAL_DEFAULT));
    }
    @Override public boolean moveToTrash(    Path path) throws IOException {
      return false;
    }
    @Override public void createCheckpoint() throws IOException {
      AuditableCheckpoints.add();
    }
    @Override public void deleteCheckpoint() throws IOException {
      AuditableCheckpoints.delete();
    }
    @Override public Path getCurrentTrashDir(){
      return null;
    }
    @Override public Runnable getEmptier() throws IOException {
      return new AuditableEmptier(getConf());
    }
    public int getNumberOfCheckpoints(){
      return AuditableCheckpoints.get();
    }
    /** 
 * A fake emptier that simulates to delete a checkpoint in a fixed interval.
 */
private class AuditableEmptier implements Runnable {
      private Configuration conf=null;
      public AuditableEmptier(      Configuration conf){
        this.conf=conf;
      }
      @Override public void run(){
        AuditableTrashPolicy trash=null;
        try {
          trash=new AuditableTrashPolicy(conf);
        }
 catch (        IOException e1) {
        }
        while (true) {
          try {
            Thread.sleep(deletionInterval);
            trash.deleteCheckpoint();
          }
 catch (          IOException e) {
          }
catch (          InterruptedException e) {
            break;
          }
        }
      }
    }
    @Override public boolean isEnabled(){
      return true;
    }
  }
  /** 
 * Only counts the number of checkpoints, not do anything more. Declared as an inner static class to share state between testing threads.
 */
private static class AuditableCheckpoints {
    private static AtomicInteger numOfCheckpoint=new AtomicInteger(0);
    private static void add(){
      numOfCheckpoint.incrementAndGet();
      System.out.println(String.format("Create a checkpoint, current number of checkpoints %d",numOfCheckpoint.get()));
    }
    private static void delete(){
      if (numOfCheckpoint.get() > 0) {
        numOfCheckpoint.decrementAndGet();
        System.out.println(String.format("Delete a checkpoint, current number of checkpoints %d",numOfCheckpoint.get()));
      }
    }
    private static int get(){
      return numOfCheckpoint.get();
    }
  }
}
