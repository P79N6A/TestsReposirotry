public class TestSequenceFileInputFilter {
  private static final Logger LOG=FileInputFormat.LOG;
  private static final int MAX_LENGTH=15000;
  private static final Configuration conf=new Configuration();
  private static final JobConf job=new JobConf(conf);
  private static final FileSystem fs;
  private static final Path inDir=new Path(System.getProperty("test.build.data",".") + "/mapred");
  private static final Path inFile=new Path(inDir,"test.seq");
  private static final Random random=new Random(1);
  private static final Reporter reporter=Reporter.NULL;
static {
    FileInputFormat.setInputPaths(job,inDir);
    try {
      fs=FileSystem.getLocal(conf);
    }
 catch (    IOException e) {
      e.printStackTrace();
      throw new RuntimeException(e);
    }
  }
  private static void createSequenceFile(  int numRecords) throws Exception {
    SequenceFile.Writer writer=SequenceFile.createWriter(fs,conf,inFile,Text.class,BytesWritable.class);
    try {
      for (int i=1; i <= numRecords; i++) {
        Text key=new Text(Integer.toString(i));
        byte[] data=new byte[random.nextInt(10)];
        random.nextBytes(data);
        BytesWritable value=new BytesWritable(data);
        writer.append(key,value);
      }
    }
  finally {
      writer.close();
    }
  }
  private int countRecords(  int numSplits) throws IOException {
    InputFormat<Text,BytesWritable> format=new SequenceFileInputFilter<Text,BytesWritable>();
    Text key=new Text();
    BytesWritable value=new BytesWritable();
    if (numSplits == 0) {
      numSplits=random.nextInt(MAX_LENGTH / (SequenceFile.SYNC_INTERVAL / 20)) + 1;
    }
    InputSplit[] splits=format.getSplits(job,numSplits);
    int count=0;
    LOG.info("Generated " + splits.length + " splits.");
    for (int j=0; j < splits.length; j++) {
      RecordReader<Text,BytesWritable> reader=format.getRecordReader(splits[j],job,reporter);
      try {
        while (reader.next(key,value)) {
          LOG.info("Accept record " + key.toString());
          count++;
        }
      }
  finally {
        reader.close();
      }
    }
    return count;
  }
  @Test public void testRegexFilter() throws Exception {
    LOG.info("Testing Regex Filter with patter: \\A10*");
    SequenceFileInputFilter.setFilterClass(job,SequenceFileInputFilter.RegexFilter.class);
    SequenceFileInputFilter.RegexFilter.setPattern(job,"\\A10*");
    fs.delete(inDir,true);
    for (int length=1; length < MAX_LENGTH; length+=random.nextInt(MAX_LENGTH / 10) + 1) {
      LOG.info("******Number of records: " + length);
      createSequenceFile(length);
      int count=countRecords(0);
      assertEquals(count,length == 0 ? 0 : (int)Math.log10(length) + 1);
    }
    fs.delete(inDir,true);
  }
  @Test public void testPercentFilter() throws Exception {
    LOG.info("Testing Percent Filter with frequency: 1000");
    SequenceFileInputFilter.setFilterClass(job,SequenceFileInputFilter.PercentFilter.class);
    SequenceFileInputFilter.PercentFilter.setFrequency(job,1000);
    fs.delete(inDir,true);
    for (int length=0; length < MAX_LENGTH; length+=random.nextInt(MAX_LENGTH / 10) + 1) {
      LOG.info("******Number of records: " + length);
      createSequenceFile(length);
      int count=countRecords(1);
      LOG.info("Accepted " + count + " records");
      int expectedCount=length / 1000;
      if (expectedCount * 1000 != length)       expectedCount++;
      assertEquals(count,expectedCount);
    }
    fs.delete(inDir,true);
  }
  @Test public void testMD5Filter() throws Exception {
    LOG.info("Testing MD5 Filter with frequency: 1000");
    SequenceFileInputFilter.setFilterClass(job,SequenceFileInputFilter.MD5Filter.class);
    SequenceFileInputFilter.MD5Filter.setFrequency(job,1000);
    fs.delete(inDir,true);
    for (int length=0; length < MAX_LENGTH; length+=random.nextInt(MAX_LENGTH / 10) + 1) {
      LOG.info("******Number of records: " + length);
      createSequenceFile(length);
      LOG.info("Accepted " + countRecords(0) + " records");
    }
    fs.delete(inDir,true);
  }
}
