/** 
 * An thread that reads the metrics source every JMX cache TTL. After each read it updates the metric source to report a new key. The next read must be able to pick up this new key.
 */
private static class SourceReader implements Runnable {
  private MetricsSourceAdapter sa=null;
  private TestMetricsSource src=null;
  private int cnt=0;
  private ScheduledFuture<?> future=null;
  private AtomicBoolean hasError=null;
  private static final Logger LOG=Logger.getLogger(SourceReader.class);
  public SourceReader(  TestMetricsSource source,  MetricsSourceAdapter sourceAdapter,  AtomicBoolean err){
    src=source;
    sa=sourceAdapter;
    hasError=err;
  }
  public void setFuture(  ScheduledFuture<?> f){
    future=f;
  }
  @Override public void run(){
    try {
      MBeanInfo info=sa.getMBeanInfo();
      final String key=src.getKey();
      for (      MBeanAttributeInfo mBeanAttributeInfo : info.getAttributes()) {
        if (mBeanAttributeInfo.getName().equals(key)) {
          LOG.info("found key/val=" + cnt + "/"+ cnt);
          cnt++;
          src.setKV("key" + cnt,cnt);
          return;
        }
      }
      LOG.error("key=" + key + " not found. Stopping now.");
      hasError.set(true);
    }
 catch (    Exception e) {
      hasError.set(true);
      LOG.error(e.getStackTrace());
    }
 finally {
      if (hasError.get()) {
        future.cancel(false);
      }
    }
  }
}
