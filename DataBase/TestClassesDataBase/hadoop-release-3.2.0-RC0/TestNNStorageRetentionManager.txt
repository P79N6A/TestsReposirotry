public class TestNNStorageRetentionManager {
  final Configuration conf=new Configuration();
  /** 
 * For the purpose of this test, purge as many edits as we can  with no extra "safety cushion"
 */
  @Before public void setNoExtraEditRetention(){
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_NUM_EXTRA_EDITS_RETAINED_KEY,0);
  }
  /** 
 * Test the "easy case" where we have more images in the directory than we need to keep. Should purge the old ones.
 */
  @Test public void testPurgeEasyCase() throws IOException {
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE_AND_EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),true);
    tc.addImage("/foo1/current/" + getImageFileName(200),true);
    tc.addImage("/foo1/current/" + getImageFileName(300),false);
    tc.addImage("/foo1/current/" + getImageFileName(400),false);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(101,200),true);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(201,300),true);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(301,400),false);
    tc.addLog("/foo1/current/" + getInProgressEditsFileName(401),false);
    tc.addLog("/foo1/current/VERSION",false);
    runTest(tc);
  }
  /** 
 * Same as above, but across multiple directories
 */
  @Test public void testPurgeMultipleDirs() throws IOException {
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE_AND_EDITS);
    tc.addRoot("/foo2",NameNodeDirType.IMAGE_AND_EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),true);
    tc.addImage("/foo1/current/" + getImageFileName(200),true);
    tc.addImage("/foo2/current/" + getImageFileName(200),true);
    tc.addImage("/foo1/current/" + getImageFileName(300),false);
    tc.addImage("/foo1/current/" + getImageFileName(400),false);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(101,200),true);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(201,300),true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(201,300),true);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(301,400),false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(301,400),false);
    tc.addLog("/foo1/current/" + getInProgressEditsFileName(401),false);
    runTest(tc);
  }
  /** 
 * Test that if we have fewer fsimages than the configured retention, we don't purge any of them
 */
  @Test public void testPurgeLessThanRetention() throws IOException {
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE_AND_EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),false);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(101,200),false);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(201,300),false);
    tc.addLog("/foo1/current/" + getFinalizedEditsFileName(301,400),false);
    tc.addLog("/foo1/current/" + getInProgressEditsFileName(401),false);
    runTest(tc);
  }
  /** 
 * Check for edge case with no logs present at all.
 */
  @Test public void testNoLogs() throws IOException {
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE_AND_EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),true);
    tc.addImage("/foo1/current/" + getImageFileName(200),true);
    tc.addImage("/foo1/current/" + getImageFileName(300),false);
    tc.addImage("/foo1/current/" + getImageFileName(400),false);
    runTest(tc);
  }
  /** 
 * Check for edge case with no logs or images present at all.
 */
  @Test public void testEmptyDir() throws IOException {
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE_AND_EDITS);
    runTest(tc);
  }
  /** 
 * Test that old in-progress logs are properly purged
 */
  @Test public void testOldInProgress() throws IOException {
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE_AND_EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),true);
    tc.addImage("/foo1/current/" + getImageFileName(200),true);
    tc.addImage("/foo1/current/" + getImageFileName(300),false);
    tc.addImage("/foo1/current/" + getImageFileName(400),false);
    tc.addLog("/foo1/current/" + getInProgressEditsFileName(101),true);
    runTest(tc);
  }
  @Test public void testSeparateEditDirs() throws IOException {
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE);
    tc.addRoot("/foo2",NameNodeDirType.EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),true);
    tc.addImage("/foo1/current/" + getImageFileName(200),true);
    tc.addImage("/foo1/current/" + getImageFileName(300),false);
    tc.addImage("/foo1/current/" + getImageFileName(400),false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(101,200),true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(201,300),true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(301,400),false);
    tc.addLog("/foo2/current/" + getInProgressEditsFileName(401),false);
    runTest(tc);
  }
  @Test public void testRetainExtraLogs() throws IOException {
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_NUM_EXTRA_EDITS_RETAINED_KEY,50);
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE);
    tc.addRoot("/foo2",NameNodeDirType.EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),true);
    tc.addImage("/foo1/current/" + getImageFileName(200),true);
    tc.addImage("/foo1/current/" + getImageFileName(300),false);
    tc.addImage("/foo1/current/" + getImageFileName(400),false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(101,200),true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(201,300),false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(301,400),false);
    tc.addLog("/foo2/current/" + getInProgressEditsFileName(401),false);
    runTest(tc);
  }
  @Test public void testRetainExtraLogsLimitedSegments() throws IOException {
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_NUM_EXTRA_EDITS_RETAINED_KEY,150);
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_MAX_EXTRA_EDITS_SEGMENTS_RETAINED_KEY,2);
    TestCaseDescription tc=new TestCaseDescription();
    tc.addRoot("/foo1",NameNodeDirType.IMAGE);
    tc.addRoot("/foo2",NameNodeDirType.EDITS);
    tc.addImage("/foo1/current/" + getImageFileName(100),true);
    tc.addImage("/foo1/current/" + getImageFileName(200),true);
    tc.addImage("/foo1/current/" + getImageFileName(300),false);
    tc.addImage("/foo1/current/" + getImageFileName(400),false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(1,100),true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(101,175),true);
    tc.addLog("/foo2/current/" + getInProgressEditsFileName(176) + ".empty",true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(176,200),true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(201,225),true);
    tc.addLog("/foo2/current/" + getInProgressEditsFileName(226) + ".corrupt",true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(226,240),true);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(241,275),false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(276,300),false);
    tc.addLog("/foo2/current/" + getInProgressEditsFileName(301) + ".empty",false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(301,350),false);
    tc.addLog("/foo2/current/" + getInProgressEditsFileName(351) + ".corrupt",false);
    tc.addLog("/foo2/current/" + getFinalizedEditsFileName(351,400),false);
    tc.addLog("/foo2/current/" + getInProgressEditsFileName(401),false);
    runTest(tc);
  }
  private void runTest(  TestCaseDescription tc) throws IOException {
    StoragePurger mockPurger=Mockito.mock(NNStorageRetentionManager.StoragePurger.class);
    ArgumentCaptor<FSImageFile> imagesPurgedCaptor=ArgumentCaptor.forClass(FSImageFile.class);
    ArgumentCaptor<EditLogFile> logsPurgedCaptor=ArgumentCaptor.forClass(EditLogFile.class);
    new NNStorageRetentionManager(conf,tc.mockStorage(),tc.mockEditLog(mockPurger),mockPurger).purgeOldStorage(NameNodeFile.IMAGE);
    Mockito.verify(mockPurger,Mockito.atLeast(0)).purgeImage(imagesPurgedCaptor.capture());
    Mockito.verify(mockPurger,Mockito.atLeast(0)).purgeLog(logsPurgedCaptor.capture());
    Set<String> purgedPaths=Sets.newLinkedHashSet();
    for (    FSImageFile purged : imagesPurgedCaptor.getAllValues()) {
      purgedPaths.add(fileToPath(purged.getFile()));
    }
    Assert.assertEquals(Joiner.on(",").join(filesToPaths(tc.expectedPurgedImages)),Joiner.on(",").join(purgedPaths));
    purgedPaths.clear();
    for (    EditLogFile purged : logsPurgedCaptor.getAllValues()) {
      purgedPaths.add(fileToPath(purged.getFile()));
    }
    Assert.assertEquals(Joiner.on(",").join(filesToPaths(tc.expectedPurgedLogs)),Joiner.on(",").join(purgedPaths));
  }
private class TestCaseDescription {
    private final Map<File,FakeRoot> dirRoots=Maps.newLinkedHashMap();
    private final Set<File> expectedPurgedLogs=Sets.newLinkedHashSet();
    private final Set<File> expectedPurgedImages=Sets.newLinkedHashSet();
private class FakeRoot {
      final NameNodeDirType type;
      final List<File> files;
      FakeRoot(      NameNodeDirType type){
        this.type=type;
        files=Lists.newArrayList();
      }
      StorageDirectory mockStorageDir(){
        return FSImageTestUtil.mockStorageDirectory(type,false,filesToPaths(files).toArray(new String[0]));
      }
    }
    void addRoot(    String root,    NameNodeDirType dir){
      dirRoots.put(new File(root),new FakeRoot(dir));
    }
    private void addFile(    File file){
      for (      Map.Entry<File,FakeRoot> entry : dirRoots.entrySet()) {
        if (fileToPath(file).startsWith(fileToPath(entry.getKey()))) {
          entry.getValue().files.add(file);
        }
      }
    }
    void addLog(    String path,    boolean expectPurge){
      File file=new File(path);
      addFile(file);
      if (expectPurge) {
        expectedPurgedLogs.add(file);
      }
    }
    void addImage(    String path,    boolean expectPurge){
      File file=new File(path);
      addFile(file);
      if (expectPurge) {
        expectedPurgedImages.add(file);
      }
    }
    NNStorage mockStorage() throws IOException {
      List<StorageDirectory> sds=Lists.newArrayList();
      for (      FakeRoot root : dirRoots.values()) {
        sds.add(root.mockStorageDir());
      }
      return mockStorageForDirs(sds.toArray(new StorageDirectory[0]));
    }
    @SuppressWarnings("unchecked") public FSEditLog mockEditLog(    StoragePurger purger) throws IOException {
      final List<JournalManager> jms=Lists.newArrayList();
      final JournalSet journalSet=new JournalSet(0);
      for (      FakeRoot root : dirRoots.values()) {
        if (!root.type.isOfType(NameNodeDirType.EDITS))         continue;
        FileJournalManager fjm=new FileJournalManager(conf,root.mockStorageDir(),null);
        fjm.purger=purger;
        jms.add(fjm);
        journalSet.add(fjm,false);
      }
      FSEditLog mockLog=Mockito.mock(FSEditLog.class);
      Mockito.doAnswer(new Answer<Void>(){
        @Override public Void answer(        InvocationOnMock invocation) throws Throwable {
          Object[] args=invocation.getArguments();
          assert args.length == 1;
          long txId=(Long)args[0];
          for (          JournalManager jm : jms) {
            jm.purgeLogsOlderThan(txId);
          }
          return null;
        }
      }
).when(mockLog).purgeLogsOlderThan(Mockito.anyLong());
      Mockito.doAnswer(new Answer<Void>(){
        @Override public Void answer(        InvocationOnMock invocation) throws Throwable {
          Object[] args=invocation.getArguments();
          journalSet.selectInputStreams((Collection<EditLogInputStream>)args[0],(Long)args[1],(Boolean)args[2],(Boolean)args[3]);
          return null;
        }
      }
).when(mockLog).selectInputStreams(Mockito.anyCollection(),Mockito.anyLong(),Mockito.anyBoolean(),Mockito.anyBoolean());
      return mockLog;
    }
  }
  /** 
 * Converts a file to a platform-agnostic URI path.
 * @param file File to convert
 * @return String path
 */
  private static String fileToPath(  File file){
    return file.toURI().getPath();
  }
  /** 
 * Converts multiple files to platform-agnostic URI paths.
 * @param files Collection<File> files to convert
 * @return Collection<String> paths
 */
  private static Collection<String> filesToPaths(  Collection<File> files){
    List<String> paths=Lists.newArrayList();
    for (    File file : files) {
      paths.add(fileToPath(file));
    }
    return paths;
  }
  private static NNStorage mockStorageForDirs(  final StorageDirectory... mockDirs) throws IOException {
    NNStorage mockStorage=Mockito.mock(NNStorage.class);
    Mockito.doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        FSImageStorageInspector inspector=(FSImageStorageInspector)invocation.getArguments()[0];
        for (        StorageDirectory sd : mockDirs) {
          inspector.inspectDirectory(sd);
        }
        return null;
      }
    }
).when(mockStorage).inspectStorageDirs(Mockito.<FSImageStorageInspector>anyObject());
    return mockStorage;
  }
}
