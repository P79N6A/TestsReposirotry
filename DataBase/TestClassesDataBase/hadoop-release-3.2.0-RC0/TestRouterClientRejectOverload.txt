/** 
 * Test the Router overload control which rejects requests when the RPC client is overloaded. This feature is managed by {@link RBFConfigKeys#DFS_ROUTER_CLIENT_REJECT_OVERLOAD}.
 */
public class TestRouterClientRejectOverload {
  private static final Logger LOG=LoggerFactory.getLogger(TestRouterClientRejectOverload.class);
  private StateStoreDFSCluster cluster;
  @After public void cleanup(){
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  private void setupCluster(  boolean overloadControl) throws Exception {
    cluster=new StateStoreDFSCluster(false,2);
    Configuration routerConf=new RouterConfigBuilder().stateStore().metrics().admin().rpc().build();
    routerConf.setInt(RBFConfigKeys.DFS_ROUTER_CLIENT_THREADS_SIZE,4);
    routerConf.setBoolean(RBFConfigKeys.DFS_ROUTER_CLIENT_REJECT_OVERLOAD,overloadControl);
    cluster.setNumDatanodesPerNameservice(0);
    cluster.addRouterOverrides(routerConf);
    cluster.startCluster();
    cluster.startRouters();
    cluster.waitClusterUp();
  }
  @Test public void testWithoutOverloadControl() throws Exception {
    setupCluster(false);
    testOverloaded(0);
    MiniDFSCluster dfsCluster=cluster.getCluster();
    NameNode nn0=dfsCluster.getNameNode(0);
    simulateSlowNamenode(nn0,1);
    testOverloaded(0);
    for (    RouterContext router : cluster.getRouters()) {
      FederationRPCMetrics rpcMetrics=router.getRouter().getRpcServer().getRPCMetrics();
      assertEquals(0,rpcMetrics.getProxyOpFailureClientOverloaded());
    }
  }
  @Test public void testOverloadControl() throws Exception {
    setupCluster(true);
    List<RouterContext> routers=cluster.getRouters();
    FederationRPCMetrics rpcMetrics0=routers.get(0).getRouter().getRpcServer().getRPCMetrics();
    FederationRPCMetrics rpcMetrics1=routers.get(1).getRouter().getRpcServer().getRPCMetrics();
    testOverloaded(0);
    assertEquals(0,rpcMetrics0.getProxyOpFailureClientOverloaded());
    assertEquals(0,rpcMetrics1.getProxyOpFailureClientOverloaded());
    MiniDFSCluster dfsCluster=cluster.getCluster();
    NameNode nn0=dfsCluster.getNameNode(0);
    simulateSlowNamenode(nn0,1);
    testOverloaded(4,6);
    assertTrue(rpcMetrics0.getProxyOpFailureClientOverloaded() + rpcMetrics1.getProxyOpFailureClientOverloaded() >= 4);
    Configuration clientConf=cluster.getRouterClientConf();
    long iniProxyOps0=rpcMetrics0.getProxyOps();
    long iniProxyOps1=rpcMetrics1.getProxyOps();
    testOverloaded(0,0,new URI("hdfs://fed/"),clientConf,10);
    long proxyOps0=rpcMetrics0.getProxyOps() - iniProxyOps0;
    long proxyOps1=rpcMetrics1.getProxyOps() - iniProxyOps1;
    assertEquals(2 * 10,proxyOps0 + proxyOps1);
    assertTrue(proxyOps0 + " operations: not distributed",proxyOps0 >= 8);
    assertTrue(proxyOps1 + " operations: not distributed",proxyOps1 >= 8);
  }
  private void testOverloaded(  int expOverload) throws Exception {
    testOverloaded(expOverload,expOverload);
  }
  private void testOverloaded(  int expOverloadMin,  int expOverloadMax) throws Exception {
    RouterContext routerContext=cluster.getRandomRouter();
    URI address=routerContext.getFileSystemURI();
    Configuration conf=new HdfsConfiguration();
    testOverloaded(expOverloadMin,expOverloadMax,address,conf,10);
  }
  /** 
 * Test if the Router gets overloaded by submitting requests in parallel. We check how many requests got rejected at the end.
 * @param expOverloadMin Min number of requests expected as overloaded.
 * @param expOverloadMax Max number of requests expected as overloaded.
 * @param address Destination address.
 * @param conf Configuration of the client.
 * @param numOps Number of operations to submit.
 * @throws Exception If it cannot perform the test.
 */
  private void testOverloaded(  int expOverloadMin,  int expOverloadMax,  final URI address,  final Configuration conf,  final int numOps) throws Exception {
    final AtomicInteger overloadException=new AtomicInteger();
    ExecutorService exec=Executors.newFixedThreadPool(numOps);
    List<Future<?>> futures=new ArrayList<>();
    for (int i=0; i < numOps; i++) {
      final int sleepTime=i * 50;
      Future<?> future=exec.submit(new Runnable(){
        @Override public void run(){
          DFSClient routerClient=null;
          try {
            Thread.sleep(sleepTime);
            routerClient=new DFSClient(address,conf);
            String clientName=routerClient.getClientName();
            ClientProtocol routerProto=routerClient.getNamenode();
            routerProto.renewLease(clientName);
          }
 catch (          RemoteException re) {
            IOException ioe=re.unwrapRemoteException();
            assertTrue("Wrong exception: " + ioe,ioe instanceof StandbyException);
            assertExceptionContains("is overloaded",ioe);
            overloadException.incrementAndGet();
          }
catch (          IOException e) {
            fail("Unexpected exception: " + e);
          }
catch (          InterruptedException e) {
            fail("Cannot sleep: " + e);
          }
 finally {
            if (routerClient != null) {
              try {
                routerClient.close();
              }
 catch (              IOException e) {
                LOG.error("Cannot close the client");
              }
            }
          }
        }
      }
);
      futures.add(future);
    }
    while (!futures.isEmpty()) {
      futures.remove(0).get();
    }
    exec.shutdown();
    int num=overloadException.get();
    if (expOverloadMin == expOverloadMax) {
      assertEquals(expOverloadMin,num);
    }
 else {
      assertTrue("Expected >=" + expOverloadMin + " but was "+ num,num >= expOverloadMin);
      assertTrue("Expected <=" + expOverloadMax + " but was "+ num,num <= expOverloadMax);
    }
  }
}
