private static class InvocationCountingChannel extends IPCLoggerChannel {
  private int rpcCount=0;
  private final Map<Integer,Callable<Void>> injections=Maps.newHashMap();
  public InvocationCountingChannel(  Configuration conf,  NamespaceInfo nsInfo,  String journalId,  InetSocketAddress addr){
    super(conf,nsInfo,journalId,addr);
  }
  int getRpcCount(){
    return rpcCount;
  }
  void failIpcNumber(  final int idx){
    Preconditions.checkArgument(idx > 0,"id must be positive");
    inject(idx,new Callable<Void>(){
      @Override public Void call() throws Exception {
        throw new IOException("injected failed IPC at " + idx);
      }
    }
);
  }
  private void inject(  int beforeRpcNumber,  Callable<Void> injectedCode){
    injections.put(beforeRpcNumber,injectedCode);
  }
  @Override protected QJournalProtocol createProxy() throws IOException {
    final QJournalProtocol realProxy=super.createProxy();
    QJournalProtocol mock=mockProxy(new WrapEveryCall<Object>(realProxy){
      void beforeCall(      InvocationOnMock invocation) throws Exception {
        rpcCount++;
        String param="";
        for (        Object val : invocation.getArguments()) {
          param+=val + ",";
        }
        String callStr="[" + addr + "] "+ invocation.getMethod().getName()+ "("+ param+ ")";
        Callable<Void> inject=injections.get(rpcCount);
        if (inject != null) {
          LOG.info("Injecting code before IPC #" + rpcCount + ": "+ callStr);
          inject.call();
        }
 else {
          LOG.info("IPC call #" + rpcCount + ": "+ callStr);
        }
      }
    }
);
    return mock;
  }
}
