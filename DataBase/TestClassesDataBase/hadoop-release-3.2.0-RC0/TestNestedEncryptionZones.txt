/** 
 * Test the behavior of nested encryption zones.
 */
public class TestNestedEncryptionZones {
  private File testRootDir;
  private final String TOP_EZ_KEY="topezkey";
  private final String NESTED_EZ_KEY="nestedezkey";
  private MiniDFSCluster cluster;
  protected DistributedFileSystem fs;
  private final Path rootDir=new Path("/");
  private final Path rawDir=new Path("/.reserved/raw/");
  private Path nestedEZBaseFile=new Path(rootDir,"nestedEZBaseFile");
  private Path topEZBaseFile=new Path(rootDir,"topEZBaseFile");
  private Path topEZDir;
  private Path nestedEZDir;
  private Path topEZFile;
  private Path nestedEZFile;
  private Path topEZRawFile;
  private Path nestedEZRawFile;
  private final int len=8196;
  private String getKeyProviderURI(){
    return JavaKeyStoreProvider.SCHEME_NAME + "://file" + new Path(testRootDir.toString(),"test.jks").toUri();
  }
  private void setProvider(){
    fs.getClient().setKeyProvider(cluster.getNameNode().getNamesystem().getProvider());
  }
  @Before public void setup() throws Exception {
    Configuration conf=new HdfsConfiguration();
    FileSystemTestHelper fsHelper=new FileSystemTestHelper();
    String testRoot=fsHelper.getTestRootDir();
    testRootDir=new File(testRoot).getAbsoluteFile();
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,getKeyProviderURI());
    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,true);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_LIST_ENCRYPTION_ZONES_NUM_RESPONSES,2);
    conf.setLong(DFSConfigKeys.FS_TRASH_INTERVAL_KEY,1);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    Logger.getLogger(EncryptionZoneManager.class).setLevel(Level.TRACE);
    fs=cluster.getFileSystem();
    setProvider();
    DFSTestUtil.createKey(TOP_EZ_KEY,cluster,conf);
    DFSTestUtil.createKey(NESTED_EZ_KEY,cluster,conf);
  }
  @After public void tearDown() throws Exception {
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
  }
  @Test(timeout=60000) public void testNestedEncryptionZones() throws Exception {
    initTopEZDirAndNestedEZDir(new Path(rootDir,"topEZ"));
    verifyEncryption();
    cluster.restartNameNodes();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    verifyEncryption();
    fs.setSafeMode(HdfsConstants.SafeModeAction.SAFEMODE_ENTER);
    fs.saveNamespace();
    fs.setSafeMode(HdfsConstants.SafeModeAction.SAFEMODE_LEAVE);
    cluster.restartNameNodes();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    verifyEncryption();
    renameChildrenOfEZ();
    Path topEZ2Dir=new Path(rootDir,"topEZ2");
    fs.mkdir(topEZ2Dir,FsPermission.getDirDefault());
    fs.createEncryptionZone(topEZ2Dir,TOP_EZ_KEY);
    try {
      fs.rename(topEZ2Dir,new Path(topEZDir,"topEZ2"));
      fail("Shouldn't be able to move a non-nested EZ into another " + "existing EZ.");
    }
 catch (    Exception e) {
      assertTrue(e.getMessage().contains("can't be moved into an encryption zone"));
    }
    fs.rename(topEZDir,new Path(rootDir,"newTopEZ"));
    fs.rename(new Path(rootDir,"newTopEZ/nestedEZ"),new Path(rootDir,"newTopEZ/newNestedEZ"));
  }
  @Test(timeout=60000) public void testNestedEZWithRoot() throws Exception {
    initTopEZDirAndNestedEZDir(rootDir);
    verifyEncryption();
    renameChildrenOfEZ();
    final String currentUser=UserGroupInformation.getCurrentUser().getShortUserName();
    final Path suffixTrashPath=new Path(FileSystem.TRASH_PREFIX,currentUser);
    final Path rootTrash=fs.getTrashRoot(rootDir);
    final Path topEZTrash=fs.getTrashRoot(topEZFile);
    final Path nestedEZTrash=fs.getTrashRoot(nestedEZFile);
    final Path expectedTopEZTrash=fs.makeQualified(new Path(topEZDir,suffixTrashPath));
    final Path expectedNestedEZTrash=fs.makeQualified(new Path(nestedEZDir,suffixTrashPath));
    assertEquals("Top ez trash should be " + expectedTopEZTrash,expectedTopEZTrash,topEZTrash);
    assertEquals("Root trash should be equal with TopEZFile trash",topEZTrash,rootTrash);
    assertEquals("Nested ez Trash should be " + expectedNestedEZTrash,expectedNestedEZTrash,nestedEZTrash);
    FsShell shell=new FsShell(fs.getConf());
    final Path topTrashFile=new Path(shell.getCurrentTrashDir(topEZFile) + "/" + topEZFile);
    final Path nestedTrashFile=new Path(shell.getCurrentTrashDir(nestedEZFile) + "/" + nestedEZFile);
    ToolRunner.run(shell,new String[]{"-rm",topEZFile.toString()});
    ToolRunner.run(shell,new String[]{"-rm",nestedEZFile.toString()});
    assertTrue("File not in trash : " + topTrashFile,fs.exists(topTrashFile));
    assertTrue("File not in trash : " + nestedTrashFile,fs.exists(nestedTrashFile));
  }
  private void renameChildrenOfEZ() throws Exception {
    Path renamedTopEZFile=new Path(topEZDir,"renamedFile");
    Path renamedNestedEZFile=new Path(nestedEZDir,"renamedFile");
    fs.rename(topEZFile,renamedTopEZFile);
    fs.rename(nestedEZFile,renamedNestedEZFile);
    topEZFile=renamedTopEZFile;
    nestedEZFile=renamedNestedEZFile;
    topEZRawFile=new Path(rawDir + topEZFile.toUri().getPath());
    nestedEZRawFile=new Path(rawDir + nestedEZFile.toUri().getPath());
    verifyEncryption();
    try {
      fs.rename(topEZFile,new Path(nestedEZDir,"movedTopEZFile"));
      fail("Shouldn't be able to rename between top EZ and nested EZ.");
    }
 catch (    Exception e) {
      assertTrue(e.getMessage().contains("can't be moved from encryption zone " + topEZDir.toString() + " to encryption zone "+ nestedEZDir.toString()));
    }
    try {
      fs.rename(nestedEZFile,new Path(topEZDir,"movedNestedEZFile"));
      fail("Shouldn't be able to rename between top EZ and nested EZ.");
    }
 catch (    Exception e) {
      assertTrue(e.getMessage().contains("can't be moved from encryption zone " + nestedEZDir.toString() + " to encryption zone "+ topEZDir.toString()));
    }
    try {
      fs.rename(nestedEZFile,new Path(rootDir,"movedNestedEZFile"));
      fail("Shouldn't be able to move the nested EZ out of the top EZ.");
    }
 catch (    Exception e) {
      String exceptionMsg=e.getMessage();
      assertTrue(exceptionMsg.contains("can't be moved from") && exceptionMsg.contains("encryption zone"));
    }
  }
  private void initTopEZDirAndNestedEZDir(  Path topPath) throws Exception {
    fs.delete(rootDir,true);
    topEZDir=topPath;
    nestedEZDir=new Path(topEZDir,"nestedEZ");
    topEZFile=new Path(topEZDir,"file");
    nestedEZFile=new Path(nestedEZDir,"file");
    topEZRawFile=new Path(rawDir + topEZFile.toUri().getPath());
    nestedEZRawFile=new Path(rawDir + nestedEZFile.toUri().getPath());
    fs.mkdir(topEZDir,FsPermission.getDirDefault());
    fs.createEncryptionZone(topEZDir,TOP_EZ_KEY);
    fs.mkdir(nestedEZDir,FsPermission.getDirDefault());
    fs.createEncryptionZone(nestedEZDir,NESTED_EZ_KEY);
    DFSTestUtil.createFile(fs,topEZBaseFile,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,topEZFile,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,nestedEZBaseFile,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,nestedEZFile,len,(short)1,0xFEED);
  }
  private void verifyEncryption() throws Exception {
    assertEquals("Top EZ dir is encrypted",true,fs.getFileStatus(topEZDir).isEncrypted());
    assertEquals("Nested EZ dir is encrypted",true,fs.getFileStatus(nestedEZDir).isEncrypted());
    assertEquals("Top zone file is encrypted",true,fs.getFileStatus(topEZFile).isEncrypted());
    assertEquals("Nested zone file is encrypted",true,fs.getFileStatus(nestedEZFile).isEncrypted());
    DFSTestUtil.verifyFilesEqual(fs,topEZBaseFile,topEZFile,len);
    DFSTestUtil.verifyFilesEqual(fs,nestedEZBaseFile,nestedEZFile,len);
    DFSTestUtil.verifyFilesNotEqual(fs,topEZRawFile,nestedEZRawFile,len);
  }
}
