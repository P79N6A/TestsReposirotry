/** 
 * A class creating directories trees for snapshot testing. For simplicity, the directory tree is a binary tree, i.e., each directory has two children as snapshottable directories.
 */
static class TestDirectoryTree {
  /** 
 * Height of the directory tree 
 */
  final int height;
  /** 
 * Top node of the directory tree 
 */
  final Node topNode;
  /** 
 * A map recording nodes for each tree level 
 */
  final Map<Integer,ArrayList<Node>> levelMap;
  /** 
 * Constructor to build a tree of given  {@code height}
 */
  TestDirectoryTree(  int height,  FileSystem fs) throws Exception {
    this.height=height;
    this.topNode=new Node(new Path("/TestSnapshot"),0,null,fs);
    this.levelMap=new HashMap<Integer,ArrayList<Node>>();
    addDirNode(topNode,0);
    genChildren(topNode,height - 1,fs);
  }
  /** 
 * Add a node into the levelMap
 */
  private void addDirNode(  Node node,  int atLevel){
    ArrayList<Node> list=levelMap.get(atLevel);
    if (list == null) {
      list=new ArrayList<Node>();
      levelMap.put(atLevel,list);
    }
    list.add(node);
  }
  int id=0;
  /** 
 * Recursively generate the tree based on the height.
 * @param parent The parent node
 * @param level The remaining levels to generate
 * @param fs The FileSystem where to generate the files/dirs
 * @throws Exception
 */
  private void genChildren(  Node parent,  int level,  FileSystem fs) throws Exception {
    if (level == 0) {
      return;
    }
    parent.leftChild=new Node(new Path(parent.nodePath,"left" + ++id),height - level,parent,fs);
    parent.rightChild=new Node(new Path(parent.nodePath,"right" + ++id),height - level,parent,fs);
    addDirNode(parent.leftChild,parent.leftChild.level);
    addDirNode(parent.rightChild,parent.rightChild.level);
    genChildren(parent.leftChild,level - 1,fs);
    genChildren(parent.rightChild,level - 1,fs);
  }
  /** 
 * Randomly retrieve a node from the directory tree.
 * @param random A random instance passed by user.
 * @param excludedList Excluded list, i.e., the randomly generated nodecannot be one of the nodes in this list.
 * @return a random node from the tree.
 */
  Node getRandomDirNode(  Random random,  List<Node> excludedList){
    while (true) {
      int level=random.nextInt(height);
      ArrayList<Node> levelList=levelMap.get(level);
      int index=random.nextInt(levelList.size());
      Node randomNode=levelList.get(index);
      if (excludedList == null || !excludedList.contains(randomNode)) {
        return randomNode;
      }
    }
  }
  /** 
 * The class representing a node in  {@link TestDirectoryTree}. <br> This contains: <ul> <li>Two children representing the two snapshottable directories</li> <li>A list of files for testing, so that we can check snapshots after file creation/deletion/modification.</li> <li>A list of non-snapshottable directories, to test snapshots with directory creation/deletion. Note that this is needed because the deletion of a snapshottale directory with snapshots is not allowed.</li> </ul>
 */
static class Node {
    /** 
 * The level of this node in the directory tree 
 */
    final int level;
    /** 
 * Children 
 */
    Node leftChild;
    Node rightChild;
    /** 
 * Parent node of the node 
 */
    final Node parent;
    /** 
 * File path of the node 
 */
    final Path nodePath;
    /** 
 * The file path list for testing snapshots before/after file creation/deletion/modification
 */
    ArrayList<Path> fileList;
    /** 
 * Each time for testing snapshots with file creation, since we do not want to insert new files into the fileList, we always create the file that was deleted last time. Thus we record the index for deleted file in the fileList, and roll the file modification forward in the list.
 */
    int nullFileIndex=0;
    /** 
 * A list of non-snapshottable directories for testing snapshots with directory creation/deletion
 */
    final ArrayList<Node> nonSnapshotChildren;
    Node(    Path path,    int level,    Node parent,    FileSystem fs) throws Exception {
      this.nodePath=path;
      this.level=level;
      this.parent=parent;
      this.nonSnapshotChildren=new ArrayList<Node>();
      fs.mkdirs(nodePath);
    }
    /** 
 * Create files and add them in the fileList. Initially the last element in the fileList is set to null (where we start file creation).
 */
    void initFileList(    FileSystem fs,    String namePrefix,    long fileLen,    short replication,    long seed,    int numFiles) throws Exception {
      fileList=new ArrayList<Path>(numFiles);
      for (int i=0; i < numFiles; i++) {
        Path file=new Path(nodePath,namePrefix + "-f" + i);
        fileList.add(file);
        if (i < numFiles - 1) {
          DFSTestUtil.createFile(fs,file,fileLen,replication,seed);
        }
      }
      nullFileIndex=numFiles - 1;
    }
    @Override public boolean equals(    Object o){
      if (o != null && o instanceof Node) {
        Node node=(Node)o;
        return node.nodePath.equals(nodePath);
      }
      return false;
    }
    @Override public int hashCode(){
      return nodePath.hashCode();
    }
  }
}
