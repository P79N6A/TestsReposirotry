public class TestMoveApplication {
  private ResourceManager resourceManager=null;
  private static boolean failMove;
  private Configuration conf;
  @Before public void setUp() throws Exception {
    conf=new YarnConfiguration();
    conf.setClass(YarnConfiguration.RM_SCHEDULER,FifoSchedulerWithMove.class,FifoSchedulerWithMove.class);
    conf.set(YarnConfiguration.YARN_ADMIN_ACL," ");
    conf.setBoolean(YarnConfiguration.YARN_ACL_ENABLE,true);
    resourceManager=new MockRM(conf);
    resourceManager.getRMContext().getContainerTokenSecretManager().rollMasterKey();
    resourceManager.getRMContext().getNMTokenSecretManager().rollMasterKey();
    resourceManager.start();
    failMove=false;
  }
  @After public void tearDown(){
    resourceManager.stop();
  }
  @Test public void testMoveRejectedByScheduler() throws Exception {
    failMove=true;
    Application application=new Application("user1",resourceManager);
    application.submit();
    RMApp app=resourceManager.rmContext.getRMApps().get(application.getApplicationId());
    while (app.getState() != RMAppState.ACCEPTED) {
      Thread.sleep(100);
    }
    ClientRMService clientRMService=resourceManager.getClientRMService();
    try {
      clientRMService.moveApplicationAcrossQueues(MoveApplicationAcrossQueuesRequest.newInstance(application.getApplicationId(),"newqueue"));
      fail("Should have hit exception");
    }
 catch (    YarnException ex) {
      assertEquals("Move not supported",ex.getMessage());
    }
  }
  @Test(timeout=10000) public void testMoveTooLate() throws Exception {
    Application application=new Application("user1",resourceManager);
    ApplicationId appId=application.getApplicationId();
    application.submit();
    ClientRMService clientRMService=resourceManager.getClientRMService();
    clientRMService.forceKillApplication(KillApplicationRequest.newInstance(appId));
    RMApp rmApp=resourceManager.getRMContext().getRMApps().get(appId);
    while (rmApp.getState() != RMAppState.KILLED) {
      Thread.sleep(100);
    }
    try {
      clientRMService.moveApplicationAcrossQueues(MoveApplicationAcrossQueuesRequest.newInstance(appId,"newqueue"));
      fail("Should have hit exception");
    }
 catch (    YarnException ex) {
      assertEquals(YarnException.class,ex.getClass());
      assertEquals("App in KILLED state cannot be moved.",ex.getMessage());
    }
  }
  @Test(timeout=10000) public void testMoveSuccessful() throws Exception {
    MockRM rm1=new MockRM(conf);
    rm1.start();
    RMApp app=rm1.submitApp(1024);
    ClientRMService clientRMService=rm1.getClientRMService();
    clientRMService.moveApplicationAcrossQueues(MoveApplicationAcrossQueuesRequest.newInstance(app.getApplicationId(),"newqueue"));
    RMApp rmApp=rm1.getRMContext().getRMApps().get(app.getApplicationId());
    assertEquals("newqueue",rmApp.getQueue());
    rm1.stop();
  }
  @Test public void testMoveRejectedByPermissions() throws Exception {
    failMove=true;
    final Application application=new Application("user1",resourceManager);
    application.submit();
    final ClientRMService clientRMService=resourceManager.getClientRMService();
    try {
      UserGroupInformation.createRemoteUser("otheruser").doAs(new PrivilegedExceptionAction<MoveApplicationAcrossQueuesResponse>(){
        @Override public MoveApplicationAcrossQueuesResponse run() throws Exception {
          return clientRMService.moveApplicationAcrossQueues(MoveApplicationAcrossQueuesRequest.newInstance(application.getApplicationId(),"newqueue"));
        }
      }
);
      fail("Should have hit exception");
    }
 catch (    Exception ex) {
      assertEquals(AccessControlException.class,ex.getCause().getCause().getClass());
    }
  }
public static class FifoSchedulerWithMove extends FifoScheduler {
    @Override public String moveApplication(    ApplicationId appId,    String newQueue) throws YarnException {
      if (failMove) {
        throw new YarnException("Move not supported");
      }
      return newQueue;
    }
    @Override public synchronized boolean checkAccess(    UserGroupInformation callerUGI,    QueueACL acl,    String queueName){
      return acl != QueueACL.ADMINISTER_QUEUE;
    }
    @Override public void preValidateMoveApplication(    ApplicationId appId,    String newQueue) throws YarnException {
      if (failMove) {
        throw new YarnException("Move not supported");
      }
    }
  }
}
