/** 
 * Additional tests for  {@link CacheDataSource}.
 */
@RunWith(RobolectricTestRunner.class) public final class CacheDataSourceTest2 {
  private static final String EXO_CACHE_DIR="exo";
  private static final int EXO_CACHE_MAX_FILESIZE=128;
  private static final Uri URI=Uri.parse("http://test.com/content");
  private static final String KEY="key";
  private static final byte[] DATA=TestUtil.buildTestData(8 * EXO_CACHE_MAX_FILESIZE + 1);
  private static final DataSpec FULL=new DataSpec(URI,0,DATA.length,KEY);
  private static final int OFFSET_ON_BOUNDARY=EXO_CACHE_MAX_FILESIZE;
  private static final DataSpec END_ON_BOUNDARY=new DataSpec(URI,0,OFFSET_ON_BOUNDARY,KEY);
  private static final DataSpec START_ON_BOUNDARY=new DataSpec(URI,OFFSET_ON_BOUNDARY,DATA.length - OFFSET_ON_BOUNDARY,KEY);
  private static final int OFFSET_OFF_BOUNDARY=EXO_CACHE_MAX_FILESIZE * 2 + 1;
  private static final DataSpec END_OFF_BOUNDARY=new DataSpec(URI,0,OFFSET_OFF_BOUNDARY,KEY);
  private static final DataSpec START_OFF_BOUNDARY=new DataSpec(URI,OFFSET_OFF_BOUNDARY,DATA.length - OFFSET_OFF_BOUNDARY,KEY);
  @Test public void testWithoutEncryption() throws IOException {
    testReads(false);
  }
  @Test public void testWithEncryption() throws IOException {
    testReads(true);
  }
  private void testReads(  boolean useEncryption) throws IOException {
    FakeDataSource upstreamSource=buildFakeUpstreamSource();
    CacheDataSource source=buildCacheDataSource(RuntimeEnvironment.application,upstreamSource,useEncryption);
    testRead(END_ON_BOUNDARY,source);
    assertSingleOpen(upstreamSource,0,OFFSET_ON_BOUNDARY);
    testRead(START_OFF_BOUNDARY,source);
    assertSingleOpen(upstreamSource,OFFSET_OFF_BOUNDARY,DATA.length);
    testRead(END_OFF_BOUNDARY,source);
    assertSingleOpen(upstreamSource,OFFSET_ON_BOUNDARY,OFFSET_OFF_BOUNDARY);
    testRead(FULL,source);
    assertNoOpen(upstreamSource);
    testRead(FULL,source);
    assertNoOpen(upstreamSource);
    testRead(START_ON_BOUNDARY,source);
    assertNoOpen(upstreamSource);
    testRead(END_ON_BOUNDARY,source);
    assertNoOpen(upstreamSource);
    testRead(START_OFF_BOUNDARY,source);
    assertNoOpen(upstreamSource);
    testRead(END_OFF_BOUNDARY,source);
    assertNoOpen(upstreamSource);
  }
  private void testRead(  DataSpec dataSpec,  CacheDataSource source) throws IOException {
    byte[] scratch=new byte[4096];
    Random random=new Random(0);
    source.open(dataSpec);
    int position=(int)dataSpec.absoluteStreamPosition;
    int bytesRead=0;
    while (bytesRead != C.RESULT_END_OF_INPUT) {
      int maxBytesToRead=random.nextInt(scratch.length) + 1;
      bytesRead=source.read(scratch,0,maxBytesToRead);
      if (bytesRead != C.RESULT_END_OF_INPUT) {
        assertThat(copyOf(scratch,bytesRead)).isEqualTo(copyOfRange(DATA,position,position + bytesRead));
        position+=bytesRead;
      }
    }
    source.close();
  }
  /** 
 * Asserts that a single  {@link DataSource#open(DataSpec)} call has been made to the upstreamsource, with the specified start (inclusive) and end (exclusive) positions.
 */
  private void assertSingleOpen(  FakeDataSource upstreamSource,  int start,  int end){
    DataSpec[] openedDataSpecs=upstreamSource.getAndClearOpenedDataSpecs();
    assertThat(openedDataSpecs).hasLength(1);
    assertThat(openedDataSpecs[0].position).isEqualTo(start);
    assertThat(openedDataSpecs[0].absoluteStreamPosition).isEqualTo(start);
    assertThat(openedDataSpecs[0].length).isEqualTo(end - start);
  }
  /** 
 * Asserts that the upstream source was not opened.
 */
  private void assertNoOpen(  FakeDataSource upstreamSource){
    DataSpec[] openedDataSpecs=upstreamSource.getAndClearOpenedDataSpecs();
    assertThat(openedDataSpecs).hasLength(0);
  }
  private static FakeDataSource buildFakeUpstreamSource(){
    FakeDataSource fakeDataSource=new FakeDataSource();
    fakeDataSource.getDataSet().newDefaultData().appendReadData(DATA);
    return fakeDataSource;
  }
  private static CacheDataSource buildCacheDataSource(  Context context,  DataSource upstreamSource,  boolean useAesEncryption) throws CacheException {
    File cacheDir=context.getExternalCacheDir();
    Cache cache=new SimpleCache(new File(cacheDir,EXO_CACHE_DIR),new NoOpCacheEvictor());
    emptyCache(cache);
    final String secretKey="testKey:12345678";
    DataSource file=new FileDataSource();
    DataSource cacheReadDataSource=useAesEncryption ? new AesCipherDataSource(Util.getUtf8Bytes(secretKey),file) : file;
    CacheDataSink cacheSink=new CacheDataSink(cache,EXO_CACHE_MAX_FILESIZE);
    byte[] scratch=new byte[3897];
    DataSink cacheWriteDataSink=useAesEncryption ? new AesCipherDataSink(Util.getUtf8Bytes(secretKey),cacheSink,scratch) : cacheSink;
    return new CacheDataSource(cache,upstreamSource,cacheReadDataSource,cacheWriteDataSink,CacheDataSource.FLAG_BLOCK_ON_CACHE,null);
  }
  private static void emptyCache(  Cache cache) throws CacheException {
    for (    String key : cache.getKeys()) {
      for (      CacheSpan span : cache.getCachedSpans(key)) {
        cache.removeSpan(span);
      }
    }
    assertThat(cache.getKeys().isEmpty()).isTrue();
  }
}
