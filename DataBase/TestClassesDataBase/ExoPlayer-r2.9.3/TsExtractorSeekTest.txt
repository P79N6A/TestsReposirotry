/** 
 * Seeking tests for  {@link TsExtractor}. 
 */
@RunWith(RobolectricTestRunner.class) public final class TsExtractorSeekTest {
  private static final String TEST_FILE="ts/bbb_2500ms.ts";
  private static final int DURATION_US=2_500_000;
  private static final int AUDIO_TRACK_ID=257;
  private static final long MAXIMUM_TIMESTAMP_DELTA_US=500_000L;
  private static final Random random=new Random(1234L);
  private FakeTrackOutput expectedTrackOutput;
  private DefaultDataSource dataSource;
  private PositionHolder positionHolder;
  @Before public void setUp() throws IOException, InterruptedException {
    positionHolder=new PositionHolder();
    expectedTrackOutput=TestUtil.extractAllSamplesFromFile(new TsExtractor(),RuntimeEnvironment.application,TEST_FILE).trackOutputs.get(AUDIO_TRACK_ID);
    dataSource=new DefaultDataSourceFactory(RuntimeEnvironment.application,"UserAgent").createDataSource();
  }
  @Test public void testTsExtractorReads_nonSeekTableFile_returnSeekableSeekMap() throws IOException, InterruptedException {
    Uri fileUri=TestUtil.buildAssetUri(TEST_FILE);
    TsExtractor extractor=new TsExtractor();
    SeekMap seekMap=TestUtil.extractSeekMap(extractor,new FakeExtractorOutput(),dataSource,fileUri);
    assertThat(seekMap).isNotNull();
    assertThat(seekMap.getDurationUs()).isEqualTo(DURATION_US);
    assertThat(seekMap.isSeekable()).isTrue();
  }
  @Test public void testHandlePendingSeek_handlesSeekingToPositionInFile_extractsCorrectFrame() throws IOException, InterruptedException {
    TsExtractor extractor=new TsExtractor();
    Uri fileUri=TestUtil.buildAssetUri(TEST_FILE);
    FakeExtractorOutput extractorOutput=new FakeExtractorOutput();
    SeekMap seekMap=TestUtil.extractSeekMap(extractor,extractorOutput,dataSource,fileUri);
    FakeTrackOutput trackOutput=extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
    long targetSeekTimeUs=987_000;
    int extractedFrameIndex=TestUtil.seekToTimeUs(extractor,seekMap,targetSeekTimeUs,dataSource,trackOutput,fileUri);
    assertThat(extractedFrameIndex).isNotEqualTo(-1);
    assertFirstFrameAfterSeekContainTargetSeekTime(trackOutput,targetSeekTimeUs,extractedFrameIndex);
  }
  @Test public void testHandlePendingSeek_handlesSeekToEoF_extractsLastFrame() throws IOException, InterruptedException {
    TsExtractor extractor=new TsExtractor();
    Uri fileUri=TestUtil.buildAssetUri(TEST_FILE);
    FakeExtractorOutput extractorOutput=new FakeExtractorOutput();
    SeekMap seekMap=TestUtil.extractSeekMap(extractor,extractorOutput,dataSource,fileUri);
    FakeTrackOutput trackOutput=extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
    long targetSeekTimeUs=seekMap.getDurationUs();
    int extractedFrameIndex=TestUtil.seekToTimeUs(extractor,seekMap,targetSeekTimeUs,dataSource,trackOutput,fileUri);
    assertThat(extractedFrameIndex).isNotEqualTo(-1);
    assertFirstFrameAfterSeekContainTargetSeekTime(trackOutput,targetSeekTimeUs,extractedFrameIndex);
  }
  @Test public void testHandlePendingSeek_handlesSeekingBackward_extractsCorrectFrame() throws IOException, InterruptedException {
    TsExtractor extractor=new TsExtractor();
    Uri fileUri=TestUtil.buildAssetUri(TEST_FILE);
    FakeExtractorOutput extractorOutput=new FakeExtractorOutput();
    SeekMap seekMap=TestUtil.extractSeekMap(extractor,extractorOutput,dataSource,fileUri);
    FakeTrackOutput trackOutput=extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
    long firstSeekTimeUs=987_000;
    TestUtil.seekToTimeUs(extractor,seekMap,firstSeekTimeUs,dataSource,trackOutput,fileUri);
    long targetSeekTimeUs=0;
    int extractedFrameIndex=TestUtil.seekToTimeUs(extractor,seekMap,targetSeekTimeUs,dataSource,trackOutput,fileUri);
    assertThat(extractedFrameIndex).isNotEqualTo(-1);
    assertFirstFrameAfterSeekContainTargetSeekTime(trackOutput,targetSeekTimeUs,extractedFrameIndex);
  }
  @Test public void testHandlePendingSeek_handlesSeekingForward_extractsCorrectFrame() throws IOException, InterruptedException {
    TsExtractor extractor=new TsExtractor();
    Uri fileUri=TestUtil.buildAssetUri(TEST_FILE);
    FakeExtractorOutput extractorOutput=new FakeExtractorOutput();
    SeekMap seekMap=TestUtil.extractSeekMap(extractor,extractorOutput,dataSource,fileUri);
    FakeTrackOutput trackOutput=extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
    long firstSeekTimeUs=987_000;
    TestUtil.seekToTimeUs(extractor,seekMap,firstSeekTimeUs,dataSource,trackOutput,fileUri);
    long targetSeekTimeUs=1_234_000;
    int extractedFrameIndex=TestUtil.seekToTimeUs(extractor,seekMap,targetSeekTimeUs,dataSource,trackOutput,fileUri);
    assertThat(extractedFrameIndex).isNotEqualTo(-1);
    assertFirstFrameAfterSeekContainTargetSeekTime(trackOutput,targetSeekTimeUs,extractedFrameIndex);
  }
  @Test public void testHandlePendingSeek_handlesRandomSeeks_extractsCorrectFrame() throws IOException, InterruptedException {
    TsExtractor extractor=new TsExtractor();
    Uri fileUri=TestUtil.buildAssetUri(TEST_FILE);
    FakeExtractorOutput extractorOutput=new FakeExtractorOutput();
    SeekMap seekMap=TestUtil.extractSeekMap(extractor,extractorOutput,dataSource,fileUri);
    FakeTrackOutput trackOutput=extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
    long numSeek=100;
    for (long i=0; i < numSeek; i++) {
      long targetSeekTimeUs=random.nextInt(DURATION_US + 1);
      int extractedFrameIndex=TestUtil.seekToTimeUs(extractor,seekMap,targetSeekTimeUs,dataSource,trackOutput,fileUri);
      assertThat(extractedFrameIndex).isNotEqualTo(-1);
      assertFirstFrameAfterSeekContainTargetSeekTime(trackOutput,targetSeekTimeUs,extractedFrameIndex);
    }
  }
  @Test public void testHandlePendingSeek_handlesRandomSeeksAfterReadingFileOnce_extractsCorrectFrame() throws IOException, InterruptedException {
    TsExtractor extractor=new TsExtractor();
    Uri fileUri=TestUtil.buildAssetUri(TEST_FILE);
    FakeExtractorOutput extractorOutput=new FakeExtractorOutput();
    readInputFileOnce(extractor,extractorOutput,fileUri);
    SeekMap seekMap=extractorOutput.seekMap;
    FakeTrackOutput trackOutput=extractorOutput.trackOutputs.get(AUDIO_TRACK_ID);
    long numSeek=100;
    for (long i=0; i < numSeek; i++) {
      long targetSeekTimeUs=random.nextInt(DURATION_US + 1);
      int extractedFrameIndex=TestUtil.seekToTimeUs(extractor,seekMap,targetSeekTimeUs,dataSource,trackOutput,fileUri);
      assertThat(extractedFrameIndex).isNotEqualTo(-1);
      assertFirstFrameAfterSeekContainTargetSeekTime(trackOutput,targetSeekTimeUs,extractedFrameIndex);
    }
  }
  private void readInputFileOnce(  TsExtractor extractor,  FakeExtractorOutput extractorOutput,  Uri fileUri) throws IOException, InterruptedException {
    extractor.init(extractorOutput);
    int readResult=Extractor.RESULT_CONTINUE;
    ExtractorInput input=TestUtil.getExtractorInputFromPosition(dataSource,0,fileUri);
    while (readResult != Extractor.RESULT_END_OF_INPUT) {
      try {
        while (readResult == Extractor.RESULT_CONTINUE) {
          readResult=extractor.read(input,positionHolder);
        }
      }
  finally {
        Util.closeQuietly(dataSource);
      }
      if (readResult == Extractor.RESULT_SEEK) {
        input=TestUtil.getExtractorInputFromPosition(dataSource,positionHolder.position,fileUri);
        readResult=Extractor.RESULT_CONTINUE;
      }
    }
  }
  private void assertFirstFrameAfterSeekContainTargetSeekTime(  FakeTrackOutput trackOutput,  long seekTimeUs,  int firstFrameIndexAfterSeek){
    long outputSampleTimeUs=trackOutput.getSampleTimeUs(firstFrameIndexAfterSeek);
    int expectedSampleIndex=findOutputFrameInExpectedOutput(trackOutput.getSampleData(firstFrameIndexAfterSeek));
    assertThat(expectedSampleIndex).isNotEqualTo(-1);
    assertThat(Math.abs(outputSampleTimeUs - seekTimeUs)).isLessThan(MAXIMUM_TIMESTAMP_DELTA_US);
    assertThat(Math.abs(outputSampleTimeUs - expectedTrackOutput.getSampleTimeUs(expectedSampleIndex))).isLessThan(MAXIMUM_TIMESTAMP_DELTA_US);
    trackOutput.assertSample(firstFrameIndexAfterSeek,expectedTrackOutput.getSampleData(expectedSampleIndex),outputSampleTimeUs,expectedTrackOutput.getSampleFlags(expectedSampleIndex),expectedTrackOutput.getSampleCryptoData(expectedSampleIndex));
  }
  private int findOutputFrameInExpectedOutput(  byte[] sampleData){
    for (int i=0; i < expectedTrackOutput.getSampleCount(); i++) {
      byte[] currentSampleData=expectedTrackOutput.getSampleData(i);
      if (Arrays.equals(currentSampleData,sampleData)) {
        return i;
      }
    }
    return -1;
  }
}
