/** 
 * Unit tests for  {@link AesFlushingCipher}.
 */
@RunWith(RobolectricTestRunner.class) public class AesFlushingCipherTest {
  private static final int DATA_LENGTH=65536;
  private static final byte[] KEY=Util.getUtf8Bytes("testKey:12345678");
  private static final long NONCE=0;
  private static final long START_OFFSET=11;
  private static final long RANDOM_SEED=0x12345678;
  private AesFlushingCipher encryptCipher;
  private AesFlushingCipher decryptCipher;
  @Before public void setUp(){
    encryptCipher=new AesFlushingCipher(Cipher.ENCRYPT_MODE,KEY,NONCE,START_OFFSET);
    decryptCipher=new AesFlushingCipher(Cipher.DECRYPT_MODE,KEY,NONCE,START_OFFSET);
  }
  @After public void tearDown(){
    encryptCipher=null;
    decryptCipher=null;
  }
  private static long getMaxUnchangedBytesAllowedPostEncryption(  long length){
    return length / 10;
  }
  private static int getDifferingByteCount(  byte[] data1,  byte[] data2,  int startOffset){
    int count=0;
    for (int i=startOffset; i < data1.length; i++) {
      if (data1[i] != data2[i]) {
        count++;
      }
    }
    return count;
  }
  private static int getDifferingByteCount(  byte[] data1,  byte[] data2){
    return getDifferingByteCount(data1,data2,0);
  }
  @Test public void testSingle(){
    byte[] reference=TestUtil.buildTestData(DATA_LENGTH);
    byte[] data=reference.clone();
    encryptCipher.updateInPlace(data,0,data.length);
    int unchangedByteCount=data.length - getDifferingByteCount(reference,data);
    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length)).isTrue();
    decryptCipher.updateInPlace(data,0,data.length);
    int differingByteCount=getDifferingByteCount(reference,data);
    assertThat(differingByteCount).isEqualTo(0);
  }
  @Test public void testAligned(){
    byte[] reference=TestUtil.buildTestData(DATA_LENGTH);
    byte[] data=reference.clone();
    Random random=new Random(RANDOM_SEED);
    int offset=0;
    while (offset < data.length) {
      int bytes=(1 + random.nextInt(50)) * 16;
      bytes=Math.min(bytes,data.length - offset);
      assertThat(bytes % 16).isEqualTo(0);
      encryptCipher.updateInPlace(data,offset,bytes);
      offset+=bytes;
    }
    int unchangedByteCount=data.length - getDifferingByteCount(reference,data);
    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length)).isTrue();
    offset=0;
    while (offset < data.length) {
      int bytes=(1 + random.nextInt(50)) * 16;
      bytes=Math.min(bytes,data.length - offset);
      assertThat(bytes % 16).isEqualTo(0);
      decryptCipher.updateInPlace(data,offset,bytes);
      offset+=bytes;
    }
    int differingByteCount=getDifferingByteCount(reference,data);
    assertThat(differingByteCount).isEqualTo(0);
  }
  @Test public void testUnAligned(){
    byte[] reference=TestUtil.buildTestData(DATA_LENGTH);
    byte[] data=reference.clone();
    Random random=new Random(RANDOM_SEED);
    int offset=0;
    while (offset < data.length) {
      int bytes=1 + random.nextInt(4095);
      bytes=Math.min(bytes,data.length - offset);
      encryptCipher.updateInPlace(data,offset,bytes);
      offset+=bytes;
    }
    int unchangedByteCount=data.length - getDifferingByteCount(reference,data);
    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length)).isTrue();
    offset=0;
    while (offset < data.length) {
      int bytes=1 + random.nextInt(4095);
      bytes=Math.min(bytes,data.length - offset);
      decryptCipher.updateInPlace(data,offset,bytes);
      offset+=bytes;
    }
    int differingByteCount=getDifferingByteCount(reference,data);
    assertThat(differingByteCount).isEqualTo(0);
  }
  @Test public void testMidJoin(){
    byte[] reference=TestUtil.buildTestData(DATA_LENGTH);
    byte[] data=reference.clone();
    Random random=new Random(RANDOM_SEED);
    int offset=0;
    while (offset < data.length) {
      int bytes=1 + random.nextInt(4095);
      bytes=Math.min(bytes,data.length - offset);
      encryptCipher.updateInPlace(data,offset,bytes);
      offset+=bytes;
    }
    int unchangedByteCount=data.length - getDifferingByteCount(reference,data);
    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length)).isTrue();
    offset=random.nextInt(4096);
    decryptCipher=new AesFlushingCipher(Cipher.DECRYPT_MODE,KEY,NONCE,offset + START_OFFSET);
    int remainingLength=data.length - offset;
    int originalOffset=offset;
    while (remainingLength > 0) {
      int bytes=1 + random.nextInt(4095);
      bytes=Math.min(bytes,remainingLength);
      decryptCipher.updateInPlace(data,offset,bytes);
      offset+=bytes;
      remainingLength-=bytes;
    }
    int differingByteCount=getDifferingByteCount(reference,data,originalOffset);
    assertThat(differingByteCount).isEqualTo(0);
  }
}
