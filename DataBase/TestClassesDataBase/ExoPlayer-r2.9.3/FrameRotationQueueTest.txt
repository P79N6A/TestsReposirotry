/** 
 * Tests  {@link FrameRotationQueue}. 
 */
@RunWith(RobolectricTestRunner.class) public class FrameRotationQueueTest {
  private FrameRotationQueue frameRotationQueue;
  private float[] rotationMatrix;
  @Before public void setUp() throws Exception {
    frameRotationQueue=new FrameRotationQueue();
    rotationMatrix=new float[16];
  }
  @Test public void testGetRotationMatrixReturnsNull_whenEmpty() throws Exception {
    assertThat(frameRotationQueue.pollRotationMatrix(rotationMatrix,0)).isFalse();
  }
  @Test public void testGetRotationMatrixReturnsNotNull_whenNotEmpty() throws Exception {
    frameRotationQueue.setRotation(0,new float[]{1,2,3});
    assertThat(frameRotationQueue.pollRotationMatrix(rotationMatrix,0)).isTrue();
    assertThat(rotationMatrix).hasLength(16);
  }
  @Test public void testConvertsAngleAxisToRotationMatrix() throws Exception {
    doTestAngleAxisToRotationMatrix(0,1,0,0);
    frameRotationQueue.reset();
    doTestAngleAxisToRotationMatrix(1,1,0,0);
    frameRotationQueue.reset();
    doTestAngleAxisToRotationMatrix(1,0,0,1);
    doTestAngleAxisToRotationMatrix(-1,0,1,0);
    doTestAngleAxisToRotationMatrix(1,1,1,1);
  }
  @Test public void testRecentering_justYaw() throws Exception {
    float[] actualMatrix=getRotationMatrixFromAngleAxis((float)Math.PI,0,1,0);
    float[] expectedMatrix=new float[16];
    Matrix.setIdentityM(expectedMatrix,0);
    assertEquals(actualMatrix,expectedMatrix);
  }
  @Test public void testRecentering_yawAndPitch() throws Exception {
    float[] matrix=getRotationMatrixFromAngleAxis((float)Math.PI,1,1,0);
    assertMultiplication(0,0,1,matrix,0,0,1);
  }
  @Test public void testRecentering_yawAndPitch2() throws Exception {
    float[] matrix=getRotationMatrixFromAngleAxis((float)Math.PI / 2,1,1,0);
    float sqrt2=(float)Math.sqrt(2);
    assertMultiplication(sqrt2,0,0,matrix,1,-1,0);
  }
  @Test public void testRecentering_yawAndPitchAndRoll() throws Exception {
    float[] matrix=getRotationMatrixFromAngleAxis((float)Math.PI * 2 / 3,1,1,1);
    assertMultiplication(0,0,1,matrix,0,0,1);
  }
  private void doTestAngleAxisToRotationMatrix(  float angleRadian,  int x,  int y,  int z){
    float[] actualMatrix=getRotationMatrixFromAngleAxis(angleRadian,x,y,z);
    float[] expectedMatrix=createRotationMatrix(angleRadian,x,y,z);
    assertEquals(actualMatrix,expectedMatrix);
  }
  private float[] getRotationMatrixFromAngleAxis(  float angleRadian,  int x,  int y,  int z){
    float length=Matrix.length(x,y,z);
    float factor=angleRadian / length;
    frameRotationQueue.setRotation(0,new float[]{x * factor,-y * factor,-z * factor});
    frameRotationQueue.pollRotationMatrix(rotationMatrix,0);
    return rotationMatrix;
  }
  private static void assertMultiplication(  float xr,  float yr,  float zr,  float[] actualMatrix,  float x,  float y,  float z){
    float[] vector=new float[]{x,y,z,0};
    float[] resultVec=new float[4];
    Matrix.multiplyMV(resultVec,0,actualMatrix,0,vector,0);
    assertEquals(resultVec,new float[]{xr,yr,zr,0});
  }
  private static float[] createRotationMatrix(  float angleRadian,  int x,  int y,  int z){
    float[] expectedMatrix=new float[16];
    Matrix.setRotateM(expectedMatrix,0,(float)Math.toDegrees(angleRadian),x,y,z);
    return expectedMatrix;
  }
  private static void assertEquals(  float[] actual,  float[] expected){
    assertThat(actual).usingTolerance(1.0e-5).containsExactly(expected).inOrder();
  }
}
