/** 
 * Unit tests for  {@link SilenceSkippingAudioProcessor}. 
 */
@RunWith(RobolectricTestRunner.class) public final class SilenceSkippingAudioProcessorTest {
  private static final int TEST_SIGNAL_SAMPLE_RATE_HZ=1000;
  private static final int TEST_SIGNAL_CHANNEL_COUNT=2;
  private static final int TEST_SIGNAL_SILENCE_DURATION_MS=1000;
  private static final int TEST_SIGNAL_NOISE_DURATION_MS=1000;
  private static final int TEST_SIGNAL_FRAME_COUNT=100000;
  private static final int INPUT_BUFFER_SIZE=100;
  private SilenceSkippingAudioProcessor silenceSkippingAudioProcessor;
  @Before public void setUp(){
    silenceSkippingAudioProcessor=new SilenceSkippingAudioProcessor();
  }
  @Test public void testEnabledProcessor_isActive() throws Exception {
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    silenceSkippingAudioProcessor.flush();
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
  }
  @Test public void testDisabledProcessor_isNotActive() throws Exception {
    silenceSkippingAudioProcessor.setEnabled(false);
    silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    assertThat(silenceSkippingAudioProcessor.isActive()).isFalse();
  }
  @Test public void testDefaultProcessor_isNotEnabled() throws Exception {
    silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    assertThat(silenceSkippingAudioProcessor.isActive()).isFalse();
  }
  @Test public void testChangingSampleRate_requiresReconfiguration() throws Exception {
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    if (reconfigured) {
      silenceSkippingAudioProcessor.flush();
    }
    reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ * 2,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
  }
  @Test public void testReconfiguringWithSameSampleRate_doesNotRequireReconfiguration() throws Exception {
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    assertThat(reconfigured).isTrue();
    silenceSkippingAudioProcessor.flush();
    reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    assertThat(reconfigured).isFalse();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
  }
  @Test public void testSkipInSilentSignal_skipsEverything() throws Exception {
    InputBufferProvider inputBufferProvider=getInputBufferProviderForAlternatingSilenceAndNoise(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,TEST_SIGNAL_SILENCE_DURATION_MS,0,TEST_SIGNAL_FRAME_COUNT);
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    silenceSkippingAudioProcessor.flush();
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
    long totalOutputFrames=process(silenceSkippingAudioProcessor,inputBufferProvider,INPUT_BUFFER_SIZE);
    assertThat(totalOutputFrames).isEqualTo(0);
    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(TEST_SIGNAL_FRAME_COUNT);
  }
  @Test public void testSkipInNoisySignal_skipsNothing() throws Exception {
    InputBufferProvider inputBufferProvider=getInputBufferProviderForAlternatingSilenceAndNoise(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,0,TEST_SIGNAL_NOISE_DURATION_MS,TEST_SIGNAL_FRAME_COUNT);
    SilenceSkippingAudioProcessor silenceSkippingAudioProcessor=new SilenceSkippingAudioProcessor();
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    silenceSkippingAudioProcessor.flush();
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
    long totalOutputFrames=process(silenceSkippingAudioProcessor,inputBufferProvider,INPUT_BUFFER_SIZE);
    assertThat(totalOutputFrames).isEqualTo(TEST_SIGNAL_FRAME_COUNT);
    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(0);
  }
  @Test public void testSkipInAlternatingTestSignal_hasCorrectOutputAndSkippedFrameCounts() throws Exception {
    InputBufferProvider inputBufferProvider=getInputBufferProviderForAlternatingSilenceAndNoise(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,TEST_SIGNAL_SILENCE_DURATION_MS,TEST_SIGNAL_NOISE_DURATION_MS,TEST_SIGNAL_FRAME_COUNT);
    SilenceSkippingAudioProcessor silenceSkippingAudioProcessor=new SilenceSkippingAudioProcessor();
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    silenceSkippingAudioProcessor.flush();
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
    long totalOutputFrames=process(silenceSkippingAudioProcessor,inputBufferProvider,INPUT_BUFFER_SIZE);
    assertThat(totalOutputFrames).isEqualTo(57980);
    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(42020);
  }
  @Test public void testSkipWithSmallerInputBufferSize_hasCorrectOutputAndSkippedFrameCounts() throws Exception {
    InputBufferProvider inputBufferProvider=getInputBufferProviderForAlternatingSilenceAndNoise(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,TEST_SIGNAL_SILENCE_DURATION_MS,TEST_SIGNAL_NOISE_DURATION_MS,TEST_SIGNAL_FRAME_COUNT);
    SilenceSkippingAudioProcessor silenceSkippingAudioProcessor=new SilenceSkippingAudioProcessor();
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    silenceSkippingAudioProcessor.flush();
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
    long totalOutputFrames=process(silenceSkippingAudioProcessor,inputBufferProvider,80);
    assertThat(totalOutputFrames).isEqualTo(57980);
    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(42020);
  }
  @Test public void testSkipWithLargerInputBufferSize_hasCorrectOutputAndSkippedFrameCounts() throws Exception {
    InputBufferProvider inputBufferProvider=getInputBufferProviderForAlternatingSilenceAndNoise(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,TEST_SIGNAL_SILENCE_DURATION_MS,TEST_SIGNAL_NOISE_DURATION_MS,TEST_SIGNAL_FRAME_COUNT);
    SilenceSkippingAudioProcessor silenceSkippingAudioProcessor=new SilenceSkippingAudioProcessor();
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    silenceSkippingAudioProcessor.flush();
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
    long totalOutputFrames=process(silenceSkippingAudioProcessor,inputBufferProvider,120);
    assertThat(totalOutputFrames).isEqualTo(57980);
    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(42020);
  }
  @Test public void testSkipThenFlush_resetsSkippedFrameCount() throws Exception {
    InputBufferProvider inputBufferProvider=getInputBufferProviderForAlternatingSilenceAndNoise(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,TEST_SIGNAL_SILENCE_DURATION_MS,TEST_SIGNAL_NOISE_DURATION_MS,TEST_SIGNAL_FRAME_COUNT);
    SilenceSkippingAudioProcessor silenceSkippingAudioProcessor=new SilenceSkippingAudioProcessor();
    silenceSkippingAudioProcessor.setEnabled(true);
    boolean reconfigured=silenceSkippingAudioProcessor.configure(TEST_SIGNAL_SAMPLE_RATE_HZ,TEST_SIGNAL_CHANNEL_COUNT,C.ENCODING_PCM_16BIT);
    silenceSkippingAudioProcessor.flush();
    assertThat(reconfigured).isTrue();
    assertThat(silenceSkippingAudioProcessor.isActive()).isTrue();
    process(silenceSkippingAudioProcessor,inputBufferProvider,INPUT_BUFFER_SIZE);
    silenceSkippingAudioProcessor.flush();
    assertThat(silenceSkippingAudioProcessor.getSkippedFrames()).isEqualTo(0);
  }
  /** 
 * Processes the entire stream provided by  {@code inputBufferProvider} in chunks of {@code inputBufferSize} and returns the total number of output frames.
 */
  private static long process(  SilenceSkippingAudioProcessor processor,  InputBufferProvider inputBufferProvider,  int inputBufferSize) throws UnhandledFormatException {
    processor.flush();
    long totalOutputFrames=0;
    while (inputBufferProvider.hasRemaining()) {
      ByteBuffer inputBuffer=inputBufferProvider.getNextInputBuffer(inputBufferSize);
      while (inputBuffer.hasRemaining()) {
        processor.queueInput(inputBuffer);
        ByteBuffer outputBuffer=processor.getOutput();
        totalOutputFrames+=outputBuffer.remaining() / (2 * processor.getOutputChannelCount());
        outputBuffer.clear();
      }
    }
    processor.queueEndOfStream();
    while (!processor.isEnded()) {
      ByteBuffer outputBuffer=processor.getOutput();
      totalOutputFrames+=outputBuffer.remaining() / (2 * processor.getOutputChannelCount());
      outputBuffer.clear();
    }
    return totalOutputFrames;
  }
  /** 
 * Returns an  {@link InputBufferProvider} that provides input buffers for a stream that alternatesbetween silence/noise of the specified durations to fill  {@code totalFrameCount}.
 */
  private static InputBufferProvider getInputBufferProviderForAlternatingSilenceAndNoise(  int sampleRateHz,  int channelCount,  int silenceDurationMs,  int noiseDurationMs,  int totalFrameCount){
    Pcm16BitAudioBuilder audioBuilder=new Pcm16BitAudioBuilder(channelCount,totalFrameCount);
    while (!audioBuilder.isFull()) {
      int silenceDurationFrames=(silenceDurationMs * sampleRateHz) / 1000;
      audioBuilder.appendFrames(silenceDurationFrames,(short)0);
      int noiseDurationFrames=(noiseDurationMs * sampleRateHz) / 1000;
      audioBuilder.appendFrames(noiseDurationFrames,Short.MAX_VALUE);
    }
    return new InputBufferProvider(audioBuilder.build());
  }
  /** 
 * Wraps a  {@link ShortBuffer} and provides a sequence of {@link ByteBuffer}s of specified sizes that contain copies of its data.
 */
private static final class InputBufferProvider {
    private final ShortBuffer buffer;
    public InputBufferProvider(    ShortBuffer buffer){
      this.buffer=buffer;
    }
    /** 
 * Returns the next buffer with size up to  {@code sizeBytes}. 
 */
    public ByteBuffer getNextInputBuffer(    int sizeBytes){
      ByteBuffer inputBuffer=ByteBuffer.allocate(sizeBytes).order(ByteOrder.nativeOrder());
      ShortBuffer inputBufferAsShortBuffer=inputBuffer.asShortBuffer();
      int limit=buffer.limit();
      buffer.limit(Math.min(buffer.position() + sizeBytes / 2,limit));
      inputBufferAsShortBuffer.put(buffer);
      buffer.limit(limit);
      inputBuffer.limit(inputBufferAsShortBuffer.position() * 2);
      return inputBuffer;
    }
    /** 
 * Returns whether any more input can be provided via  {@link #getNextInputBuffer(int)}. 
 */
    public boolean hasRemaining(){
      return buffer.hasRemaining();
    }
  }
  /** 
 * Builder for  {@link ShortBuffer}s that contain 16-bit PCM audio samples. 
 */
private static final class Pcm16BitAudioBuilder {
    private final int channelCount;
    private final ShortBuffer buffer;
    private boolean built;
    public Pcm16BitAudioBuilder(    int channelCount,    int frameCount){
      this.channelCount=channelCount;
      buffer=ByteBuffer.allocate(frameCount * channelCount * 2).asShortBuffer();
    }
    /** 
 * Appends  {@code count} audio frames, using the specified {@code channelLevels} in each frame.
 */
    public void appendFrames(    int count,    short... channelLevels){
      Assertions.checkState(!built);
      for (int i=0; i < count; i+=channelCount) {
        for (        short channelLevel : channelLevels) {
          buffer.put(channelLevel);
        }
      }
    }
    /** 
 * Returns whether the buffer is full. 
 */
    public boolean isFull(){
      Assertions.checkState(!built);
      return !buffer.hasRemaining();
    }
    /** 
 * Returns the built buffer. After calling this method the builder should not be reused. 
 */
    public ShortBuffer build(){
      Assertions.checkState(!built);
      built=true;
      buffer.flip();
      return buffer;
    }
  }
}
