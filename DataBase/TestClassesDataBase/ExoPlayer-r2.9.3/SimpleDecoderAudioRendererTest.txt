/** 
 * Unit test for  {@link SimpleDecoderAudioRenderer}.
 */
@RunWith(RobolectricTestRunner.class) public class SimpleDecoderAudioRendererTest {
  private static final Format FORMAT=Format.createSampleFormat(null,MimeTypes.AUDIO_RAW,0);
  @Mock private AudioSink mockAudioSink;
  private SimpleDecoderAudioRenderer audioRenderer;
  @Before public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    audioRenderer=new SimpleDecoderAudioRenderer(null,null,null,false,mockAudioSink){
      @Override protected int supportsFormatInternal(      DrmSessionManager<ExoMediaCrypto> drmSessionManager,      Format format){
        return FORMAT_HANDLED;
      }
      @Override protected SimpleDecoder<DecoderInputBuffer,? extends SimpleOutputBuffer,? extends AudioDecoderException> createDecoder(      Format format,      ExoMediaCrypto mediaCrypto) throws AudioDecoderException {
        return new FakeDecoder();
      }
    }
;
  }
  @Config(sdk=19) @Test public void testSupportsFormatAtApi19(){
    assertThat(audioRenderer.supportsFormat(FORMAT)).isEqualTo(ADAPTIVE_NOT_SEAMLESS | TUNNELING_NOT_SUPPORTED | FORMAT_HANDLED);
  }
  @Config(sdk=21) @Test public void testSupportsFormatAtApi21(){
    assertThat(audioRenderer.supportsFormat(FORMAT)).isEqualTo(ADAPTIVE_NOT_SEAMLESS | TUNNELING_SUPPORTED | FORMAT_HANDLED);
  }
  @Test public void testImmediatelyReadEndOfStreamPlaysAudioSinkToEndOfStream() throws Exception {
    audioRenderer.enable(RendererConfiguration.DEFAULT,new Format[]{FORMAT},new FakeSampleStream(FORMAT,null,false),0,false,0);
    audioRenderer.setCurrentStreamFinal();
    when(mockAudioSink.isEnded()).thenReturn(true);
    while (!audioRenderer.isEnded()) {
      audioRenderer.render(0,0);
    }
    verify(mockAudioSink,times(1)).playToEndOfStream();
    audioRenderer.disable();
    verify(mockAudioSink,times(1)).release();
  }
private static final class FakeDecoder extends SimpleDecoder<DecoderInputBuffer,SimpleOutputBuffer,AudioDecoderException> {
    public FakeDecoder(){
      super(new DecoderInputBuffer[1],new SimpleOutputBuffer[1]);
    }
    @Override public String getName(){
      return "FakeDecoder";
    }
    @Override protected DecoderInputBuffer createInputBuffer(){
      return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DIRECT);
    }
    @Override protected SimpleOutputBuffer createOutputBuffer(){
      return new SimpleOutputBuffer(this);
    }
    @Override protected AudioDecoderException createUnexpectedDecodeException(    Throwable error){
      return new AudioDecoderException("Unexpected decode error",error);
    }
    @Override protected AudioDecoderException decode(    DecoderInputBuffer inputBuffer,    SimpleOutputBuffer outputBuffer,    boolean reset){
      if (inputBuffer.isEndOfStream()) {
        outputBuffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
      }
      return null;
    }
  }
}
