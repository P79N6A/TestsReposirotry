/** 
 * Unit tests for  {@link ByteArrayDataSource}.
 */
@RunWith(RobolectricTestRunner.class) public final class ByteArrayDataSourceTest {
  private static final byte[] TEST_DATA=new byte[]{0,1,2,3,4,5,6,7,8,9};
  private static final byte[] TEST_DATA_ODD=new byte[]{0,1,2,3,4,5,6,7,8,9,10};
  @Test public void testFullReadSingleBytes(){
    readTestData(TEST_DATA,0,C.LENGTH_UNSET,1,0,1,false);
  }
  @Test public void testFullReadAllBytes(){
    readTestData(TEST_DATA,0,C.LENGTH_UNSET,100,0,100,false);
  }
  @Test public void testLimitReadSingleBytes(){
    readTestData(TEST_DATA,0,TEST_DATA.length,1,0,1,false);
    readTestData(TEST_DATA,0,6,1,0,1,false);
  }
  @Test public void testFullReadTwoBytes(){
    readTestData(TEST_DATA,0,C.LENGTH_UNSET,2,0,2,false);
    readTestData(TEST_DATA_ODD,0,C.LENGTH_UNSET,2,0,2,false);
  }
  @Test public void testLimitReadTwoBytes(){
    readTestData(TEST_DATA,0,6,2,0,2,false);
    readTestData(TEST_DATA,0,7,2,0,2,false);
  }
  @Test public void testReadFromValidOffsets(){
    readTestData(TEST_DATA,1,C.LENGTH_UNSET,1,0,1,false);
    readTestData(TEST_DATA,1,6,1,0,1,false);
    readTestData(TEST_DATA,TEST_DATA.length - 1,C.LENGTH_UNSET,1,0,1,false);
    readTestData(TEST_DATA,TEST_DATA.length - 1,1,1,0,1,false);
  }
  @Test public void testReadFromInvalidOffsets(){
    readTestData(TEST_DATA,TEST_DATA.length,C.LENGTH_UNSET,1,0,1,true);
    readTestData(TEST_DATA,TEST_DATA.length,1,1,0,1,true);
  }
  @Test public void testReadWithInvalidLength(){
    readTestData(TEST_DATA,0,TEST_DATA.length + 1,1,0,1,true);
    readTestData(TEST_DATA,1,TEST_DATA.length,1,0,1,true);
  }
  /** 
 * Tests reading from a  {@link ByteArrayDataSource} with various parameters.
 * @param testData The data that the {@link ByteArrayDataSource} will wrap.
 * @param dataOffset The offset from which to read data.
 * @param dataLength The total length of data to read.
 * @param outputBufferLength The length of the target buffer for each read.
 * @param writeOffset The offset into {@code outputBufferLength} for each read.
 * @param maxReadLength The maximum length of each read.
 * @param expectFailOnOpen Whether it is expected that opening the source will fail.
 */
  private void readTestData(  byte[] testData,  int dataOffset,  int dataLength,  int outputBufferLength,  int writeOffset,  int maxReadLength,  boolean expectFailOnOpen){
    int expectedFinalBytesRead=dataLength == C.LENGTH_UNSET ? (testData.length - dataOffset) : dataLength;
    ByteArrayDataSource dataSource=new ByteArrayDataSource(testData);
    boolean opened=false;
    try {
      long length=dataSource.open(new DataSpec(null,dataOffset,dataLength,null));
      opened=true;
      assertThat(expectFailOnOpen).isFalse();
      assertThat(length).isEqualTo(expectedFinalBytesRead);
      byte[] outputBuffer=new byte[outputBufferLength];
      int accumulatedBytesRead=0;
      while (true) {
        int requestedReadLength=Math.min(maxReadLength,outputBufferLength - writeOffset);
        assertThat(requestedReadLength).isGreaterThan(0);
        int bytesRead=dataSource.read(outputBuffer,writeOffset,requestedReadLength);
        if (bytesRead != C.RESULT_END_OF_INPUT) {
          assertThat(bytesRead).isGreaterThan(0);
          assertThat(bytesRead).isAtMost(requestedReadLength);
          for (int i=0; i < bytesRead; i++) {
            assertThat(outputBuffer[writeOffset + i]).isEqualTo(testData[dataOffset + accumulatedBytesRead + i]);
          }
          accumulatedBytesRead+=bytesRead;
          assertThat(accumulatedBytesRead).isAtMost(expectedFinalBytesRead);
          assertThat(accumulatedBytesRead == expectedFinalBytesRead || bytesRead == requestedReadLength).isTrue();
        }
 else {
          assertThat(accumulatedBytesRead).isEqualTo(expectedFinalBytesRead);
          return;
        }
      }
    }
 catch (    IOException e) {
      if (expectFailOnOpen && !opened) {
        return;
      }
      fail();
    }
  }
}
