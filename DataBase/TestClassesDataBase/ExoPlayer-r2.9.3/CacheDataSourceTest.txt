/** 
 * Unit tests for  {@link CacheDataSource}.
 */
@RunWith(RobolectricTestRunner.class) public final class CacheDataSourceTest {
  private static final byte[] TEST_DATA=new byte[]{0,1,2,3,4,5,6,7,8,9};
  private static final int MAX_CACHE_FILE_SIZE=3;
  private static final String CACHE_KEY_PREFIX="myCacheKeyFactoryPrefix";
  private Uri testDataUri;
  private String fixedCacheKey;
  private String expectedCacheKey;
  private File tempFolder;
  private SimpleCache cache;
  private CacheKeyFactory cacheKeyFactory;
  @Before public void setUp() throws Exception {
    testDataUri=Uri.parse("test_data");
    fixedCacheKey=CacheUtil.generateKey(testDataUri);
    expectedCacheKey=fixedCacheKey;
    cacheKeyFactory=dataSpec -> CACHE_KEY_PREFIX + "." + CacheUtil.generateKey(dataSpec.uri);
    tempFolder=Util.createTempDirectory(RuntimeEnvironment.application,"ExoPlayerTest");
    cache=new SimpleCache(tempFolder,new NoOpCacheEvictor());
  }
  @After public void tearDown() throws Exception {
    Util.recursiveDelete(tempFolder);
  }
  @Test public void testMaxCacheFileSize() throws Exception {
    CacheDataSource cacheDataSource=createCacheDataSource(false,false);
    assertReadDataContentLength(cacheDataSource,false,false);
    for (    String key : cache.getKeys()) {
      for (      CacheSpan cacheSpan : cache.getCachedSpans(key)) {
        assertThat(cacheSpan.length <= MAX_CACHE_FILE_SIZE).isTrue();
        assertThat(cacheSpan.file.length() <= MAX_CACHE_FILE_SIZE).isTrue();
      }
    }
  }
  @Test public void testCacheAndReadUnboundedRequest() throws Exception {
    assertCacheAndRead(true,false);
  }
  @Test public void testCacheAndReadUnknownLength() throws Exception {
    assertCacheAndRead(false,true);
  }
  @Test public void testCacheAndReadUnboundedRequestUnknownLength() throws Exception {
    assertCacheAndRead(true,true);
  }
  @Test public void testCacheAndRead() throws Exception {
    assertCacheAndRead(false,false);
  }
  @Test public void testUnsatisfiableRange() throws Exception {
    assertCacheAndRead(false,true);
    CacheDataSource cacheDataSource=createCacheDataSource(true,true);
    assertReadDataContentLength(cacheDataSource,true,true);
    try {
      cacheDataSource=createCacheDataSource(false,false);
      cacheDataSource.open(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
      fail();
    }
 catch (    IOException e) {
    }
  }
  @Test public void testCacheAndReadUnboundedRequestWithCacheKeyFactoryWithNullDataSpecCacheKey() throws Exception {
    fixedCacheKey=null;
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,null));
    assertCacheAndRead(true,false,cacheKeyFactory);
  }
  @Test public void testCacheAndReadUnknownLengthWithCacheKeyFactoryOverridingWithNullDataSpecCacheKey() throws Exception {
    fixedCacheKey=null;
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,null));
    assertCacheAndRead(false,true,cacheKeyFactory);
  }
  @Test public void testCacheAndReadUnboundedRequestUnknownLengthWithCacheKeyFactoryWithNullDataSpecCacheKey() throws Exception {
    fixedCacheKey=null;
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,null));
    assertCacheAndRead(true,true,cacheKeyFactory);
  }
  @Test public void testCacheAndReadWithCacheKeyFactoryWithNullDataSpecCacheKey() throws Exception {
    fixedCacheKey=null;
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,null));
    assertCacheAndRead(false,false,cacheKeyFactory);
  }
  @Test public void testUnsatisfiableRangeWithCacheKeyFactoryNullDataSpecCacheKey() throws Exception {
    fixedCacheKey=null;
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,null));
    assertCacheAndRead(false,true,cacheKeyFactory);
    CacheDataSource cacheDataSource=createCacheDataSource(true,true,cacheKeyFactory);
    assertReadDataContentLength(cacheDataSource,true,true);
    try {
      cacheDataSource=createCacheDataSource(false,false,cacheKeyFactory);
      cacheDataSource.open(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
      fail();
    }
 catch (    IOException e) {
    }
  }
  @Test public void testCacheAndReadUnboundedRequestWithCacheKeyFactoryOverridingDataSpecCacheKey() throws Exception {
    fixedCacheKey=CacheUtil.generateKey(testDataUri);
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
    assertCacheAndRead(true,false,cacheKeyFactory);
  }
  @Test public void testCacheAndReadUnknownLengthWithCacheKeyFactoryOverridingDataSpecCacheKey() throws Exception {
    fixedCacheKey=CacheUtil.generateKey(testDataUri);
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
    assertCacheAndRead(false,true,cacheKeyFactory);
  }
  @Test public void testCacheAndReadUnboundedRequestUnknownLengthWithCacheKeyFactoryOverridingDataSpecCacheKey() throws Exception {
    fixedCacheKey=CacheUtil.generateKey(testDataUri);
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
    assertCacheAndRead(true,true,cacheKeyFactory);
  }
  @Test public void testCacheAndReadWithCacheKeyFactoryOverridingDataSpecCacheKey() throws Exception {
    fixedCacheKey=CacheUtil.generateKey(testDataUri);
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
    assertCacheAndRead(false,false,cacheKeyFactory);
  }
  @Test public void testUnsatisfiableRangeWithCacheKeyFactoryOverridingDataSpecCacheKey() throws Exception {
    fixedCacheKey=CacheUtil.generateKey(testDataUri);
    expectedCacheKey=cacheKeyFactory.buildCacheKey(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
    assertCacheAndRead(false,true,cacheKeyFactory);
    CacheDataSource cacheDataSource=createCacheDataSource(true,true,cacheKeyFactory);
    assertReadDataContentLength(cacheDataSource,true,true);
    try {
      cacheDataSource=createCacheDataSource(false,false,cacheKeyFactory);
      cacheDataSource.open(new DataSpec(testDataUri,TEST_DATA.length,5,fixedCacheKey));
      fail();
    }
 catch (    IOException e) {
    }
  }
  @Test public void testContentLengthEdgeCases() throws Exception {
    CacheDataSource cacheDataSource=createCacheDataSource(false,true);
    assertReadData(cacheDataSource,true,TEST_DATA.length - 2,2);
    assertThat(cache.getContentLength(expectedCacheKey)).isEqualTo(C.LENGTH_UNSET);
    cacheDataSource=createCacheDataSource(false,true);
    assertReadDataContentLength(cacheDataSource,true,true);
    assertThat(cacheDataSource.open(new DataSpec(testDataUri,TEST_DATA.length - 2,C.LENGTH_UNSET,expectedCacheKey))).isEqualTo(2);
    assertThat(cacheDataSource.open(new DataSpec(Uri.parse("notCachedUri"),TEST_DATA.length - 2,C.LENGTH_UNSET,null))).isEqualTo(C.LENGTH_UNSET);
  }
  @Test public void testUnknownLengthContentReadInOneConnectionAndLengthIsResolved() throws Exception {
    FakeDataSource upstream=new FakeDataSource();
    upstream.getDataSet().newData(testDataUri).appendReadData(TEST_DATA).setSimulateUnknownLength(true);
    CacheDataSource cacheDataSource=new CacheDataSource(cache,upstream,0);
    int flags=DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH;
    cacheDataSource.open(new DataSpec(testDataUri,0,C.LENGTH_UNSET,expectedCacheKey,flags));
    TestUtil.readToEnd(cacheDataSource);
    cacheDataSource.close();
    assertThat(upstream.getAndClearOpenedDataSpecs()).hasLength(1);
    assertThat(cache.getContentLength(expectedCacheKey)).isEqualTo(TEST_DATA.length);
  }
  @Test public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
    FakeDataSource upstream=new FakeDataSource();
    upstream.getDataSet().setData(testDataUri,TEST_DATA);
    CacheDataSource cacheDataSource=new CacheDataSource(cache,upstream,CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
    cacheDataSource.open(new DataSpec(testDataUri,0,C.LENGTH_UNSET,expectedCacheKey));
    TestUtil.readToEnd(cacheDataSource);
    cacheDataSource.close();
    assertThat(cache.getKeys()).isEmpty();
  }
  @Test public void testReadOnlyCache() throws Exception {
    CacheDataSource cacheDataSource=createCacheDataSource(false,false,0,null);
    assertReadDataContentLength(cacheDataSource,false,false);
    assertCacheEmpty(cache);
  }
  @Test public void testSwitchToCacheSourceWithReadOnlyCacheDataSource() throws Exception {
    FakeDataSource upstream=new FakeDataSource();
    FakeData fakeData=upstream.getDataSet().newDefaultData().appendReadData(1024 * 1024 - 1);
    fakeData.appendReadAction(() -> fail("Read from upstream shouldn't reach to the end of the data.")).appendReadData(1);
    CacheDataSource cacheDataSource=new CacheDataSource(cache,upstream,new FileDataSource(),null,0,null);
    DataSpec dataSpec=new DataSpec(testDataUri,0,C.LENGTH_UNSET,fixedCacheKey);
    cacheDataSource.open(dataSpec);
    byte[] buffer=new byte[1024];
    cacheDataSource.read(buffer,0,buffer.length);
    FakeDataSource upstream2=new FakeDataSource(new FakeDataSource().getDataSet().newDefaultData().appendReadData(1024 * 1024).endData());
    CacheUtil.cache(dataSpec,cache,upstream2,null,null);
    TestUtil.readToEnd(cacheDataSource);
    cacheDataSource.close();
  }
  @Test public void testSwitchToCacheSourceWithNonBlockingCacheDataSource() throws Exception {
    FakeDataSource upstream=new FakeDataSource();
    FakeData fakeData=upstream.getDataSet().newDefaultData().appendReadData(1024 * 1024 - 1);
    fakeData.appendReadAction(() -> fail("Read from upstream shouldn't reach to the end of the data.")).appendReadData(1);
    SimpleCacheSpan cacheSpan=cache.startReadWriteNonBlocking(expectedCacheKey,0);
    assertThat(cacheSpan).isNotNull();
    assertThat(cacheSpan.isHoleSpan()).isTrue();
    CacheDataSource cacheDataSource=new CacheDataSource(cache,upstream,0);
    DataSpec dataSpec=new DataSpec(testDataUri,0,C.LENGTH_UNSET,fixedCacheKey);
    cacheDataSource.open(dataSpec);
    byte[] buffer=new byte[1024];
    cacheDataSource.read(buffer,0,buffer.length);
    cache.releaseHoleSpan(cacheSpan);
    assertCacheEmpty(cache);
    FakeDataSource upstream2=new FakeDataSource(new FakeDataSource().getDataSet().newDefaultData().appendReadData(1024 * 1024).endData());
    CacheUtil.cache(dataSpec,cache,upstream2,null,null);
    TestUtil.readToEnd(cacheDataSource);
    cacheDataSource.close();
  }
  @Test public void testDeleteCachedWhileReadingFromUpstreamWithReadOnlyCacheDataSourceDoesNotCrash() throws Exception {
    FakeDataSource upstream=new FakeDataSource();
    upstream.getDataSet().newDefaultData().appendReadData(1024).endData();
    DataSpec dataSpec=new DataSpec(testDataUri,512,C.LENGTH_UNSET,fixedCacheKey);
    CacheUtil.cache(dataSpec,cache,upstream,null,null);
    CacheDataSource cacheDataSource=new CacheDataSource(cache,upstream,new FileDataSource(),null,0,null);
    dataSpec=new DataSpec(testDataUri,0,C.LENGTH_UNSET,fixedCacheKey);
    cacheDataSource.open(dataSpec);
    TestUtil.readExactly(cacheDataSource,100);
    CacheUtil.remove(cache,expectedCacheKey);
    assertCacheEmpty(cache);
    TestUtil.readToEnd(cacheDataSource);
    cacheDataSource.close();
  }
  @Test public void testDeleteCachedWhileReadingFromUpstreamWithBlockingCacheDataSourceDoesNotBlock() throws Exception {
    FakeDataSource upstream=new FakeDataSource();
    int dataLength=1024;
    upstream.getDataSet().newDefaultData().appendReadData(dataLength).endData();
    int halfDataLength=512;
    DataSpec dataSpec=new DataSpec(testDataUri,halfDataLength,C.LENGTH_UNSET,fixedCacheKey);
    CacheUtil.cache(dataSpec,cache,upstream,null,null);
    CacheDataSource cacheDataSource=new CacheDataSource(cache,upstream,CacheDataSource.FLAG_BLOCK_ON_CACHE);
    dataSpec=new DataSpec(testDataUri,0,C.LENGTH_UNSET,fixedCacheKey);
    cacheDataSource.open(dataSpec);
    TestUtil.readExactly(cacheDataSource,halfDataLength);
    NavigableSet<CacheSpan> cachedSpans=cache.getCachedSpans(expectedCacheKey);
    for (    CacheSpan cachedSpan : cachedSpans) {
      if (cachedSpan.position >= halfDataLength) {
        cache.removeSpan(cachedSpan);
      }
    }
    TestUtil.readToEnd(cacheDataSource);
    cacheDataSource.close();
  }
  private void assertCacheAndRead(  boolean unboundedRequest,  boolean simulateUnknownLength) throws IOException {
    CacheDataSource cacheDataSource=createCacheDataSource(false,simulateUnknownLength);
    assertReadDataContentLength(cacheDataSource,unboundedRequest,simulateUnknownLength);
    cacheDataSource=createCacheDataSource(true,simulateUnknownLength);
    assertReadDataContentLength(cacheDataSource,unboundedRequest,false);
  }
  private void assertCacheAndRead(  boolean unboundedRequest,  boolean simulateUnknownLength,  CacheKeyFactory cacheKeyFactory) throws IOException {
    CacheDataSource cacheDataSource=createCacheDataSource(false,simulateUnknownLength,cacheKeyFactory);
    assertReadDataContentLength(cacheDataSource,unboundedRequest,simulateUnknownLength);
    cacheDataSource=createCacheDataSource(true,simulateUnknownLength,cacheKeyFactory);
    assertReadDataContentLength(cacheDataSource,unboundedRequest,false);
  }
  /** 
 * Reads data until EOI and compares it to  {@link #TEST_DATA}. Also checks content length returned from open() call and the cached content length.
 */
  private void assertReadDataContentLength(  CacheDataSource cacheDataSource,  boolean unboundedRequest,  boolean unknownLength) throws IOException {
    int length=unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length;
    assertReadData(cacheDataSource,unknownLength,0,length);
    assertThat(cache.getContentLength(expectedCacheKey)).isEqualTo(!unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length);
  }
  private void assertReadData(  CacheDataSource cacheDataSource,  boolean unknownLength,  int position,  int length) throws IOException {
    int testDataLength=TEST_DATA.length - position;
    if (length != C.LENGTH_UNSET) {
      testDataLength=Math.min(testDataLength,length);
    }
    DataSpec dataSpec=new DataSpec(testDataUri,position,length,fixedCacheKey,DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
    assertThat(cacheDataSource.open(dataSpec)).isEqualTo(unknownLength ? length : testDataLength);
    cacheDataSource.close();
    byte[] expected=Arrays.copyOfRange(TEST_DATA,position,position + testDataLength);
    CacheAsserts.assertReadData(cacheDataSource,dataSpec,expected,"Cached data doesn't match the original data");
  }
  private CacheDataSource createCacheDataSource(  boolean setReadException,  boolean simulateUnknownLength){
    return createCacheDataSource(setReadException,simulateUnknownLength,CacheDataSource.FLAG_BLOCK_ON_CACHE);
  }
  private CacheDataSource createCacheDataSource(  boolean setReadException,  boolean simulateUnknownLength,  CacheKeyFactory cacheKeyFactory){
    return createCacheDataSource(setReadException,simulateUnknownLength,CacheDataSource.FLAG_BLOCK_ON_CACHE,new CacheDataSink(cache,MAX_CACHE_FILE_SIZE),cacheKeyFactory);
  }
  private CacheDataSource createCacheDataSource(  boolean setReadException,  boolean simulateUnknownLength,  @CacheDataSource.Flags int flags){
    return createCacheDataSource(setReadException,simulateUnknownLength,flags,new CacheDataSink(cache,MAX_CACHE_FILE_SIZE));
  }
  private CacheDataSource createCacheDataSource(  boolean setReadException,  boolean simulateUnknownLength,  @CacheDataSource.Flags int flags,  CacheDataSink cacheWriteDataSink){
    return createCacheDataSource(setReadException,simulateUnknownLength,flags,cacheWriteDataSink,null);
  }
  private CacheDataSource createCacheDataSource(  boolean setReadException,  boolean simulateUnknownLength,  @CacheDataSource.Flags int flags,  CacheDataSink cacheWriteDataSink,  CacheKeyFactory cacheKeyFactory){
    FakeDataSource upstream=new FakeDataSource();
    FakeData fakeData=upstream.getDataSet().newDefaultData().setSimulateUnknownLength(simulateUnknownLength).appendReadData(TEST_DATA);
    if (setReadException) {
      fakeData.appendReadError(new IOException("Shouldn't read from upstream"));
    }
    return new CacheDataSource(cache,upstream,new FileDataSource(),cacheWriteDataSink,flags,null,cacheKeyFactory);
  }
}
