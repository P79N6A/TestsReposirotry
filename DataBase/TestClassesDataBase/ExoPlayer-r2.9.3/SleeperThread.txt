private static final class SleeperThread extends Thread {
  private final Clock clock;
  private final long sleepDurationMs;
  private final CountDownLatch fallAsleepCountDownLatch;
  private final CountDownLatch wakeUpCountDownLatch;
  private volatile boolean isSleeping;
  public SleeperThread(  Clock clock,  long sleepDurationMs){
    this.clock=clock;
    this.sleepDurationMs=sleepDurationMs;
    this.fallAsleepCountDownLatch=new CountDownLatch(1);
    this.wakeUpCountDownLatch=new CountDownLatch(1);
  }
  public boolean waitUntilAsleep(  long timeoutMs) throws InterruptedException {
    return fallAsleepCountDownLatch.await(timeoutMs,TimeUnit.MILLISECONDS);
  }
  public boolean waitUntilAwake(  long timeoutMs) throws InterruptedException {
    return wakeUpCountDownLatch.await(timeoutMs,TimeUnit.MILLISECONDS);
  }
  public boolean isSleeping(){
    return isSleeping;
  }
  @Override public void run(){
synchronized (clock) {
      isSleeping=true;
      fallAsleepCountDownLatch.countDown();
      clock.sleep(sleepDurationMs);
      isSleeping=false;
      wakeUpCountDownLatch.countDown();
    }
  }
}
