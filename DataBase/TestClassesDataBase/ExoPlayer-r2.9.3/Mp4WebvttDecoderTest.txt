/** 
 * Unit test for  {@link Mp4WebvttDecoder}.
 */
@RunWith(RobolectricTestRunner.class) public final class Mp4WebvttDecoderTest {
  private static final byte[] SINGLE_CUE_SAMPLE={0x00,0x00,0x00,0x1C,0x76,0x74,0x74,0x63,0x00,0x00,0x00,0x14,0x70,0x61,0x79,0x6c,0x48,0x65,0x6c,0x6c,0x6f,0x20,0x57,0x6f,0x72,0x6c,0x64,0x0a};
  private static final byte[] DOUBLE_CUE_SAMPLE={0x00,0x00,0x00,0x1B,0x76,0x74,0x74,0x63,0x00,0x00,0x00,0x13,0x70,0x61,0x79,0x6c,0x48,0x65,0x6c,0x6c,0x6f,0x20,0x57,0x6f,0x72,0x6c,0x64,0x00,0x00,0x00,0x17,0x76,0x74,0x74,0x63,0x00,0x00,0x00,0x0F,0x70,0x61,0x79,0x6c,0x42,0x79,0x65,0x20,0x42,0x79,0x65};
  private static final byte[] NO_CUE_SAMPLE={0x00,0x00,0x00,0x1B,0x74,0x74,0x74,0x63,0x00,0x00,0x00,0x13,0x70,0x61,0x79,0x6c,0x48,0x65,0x6c,0x6c,0x6f,0x20,0x57,0x6f,0x72,0x6c,0x64};
  private static final byte[] INCOMPLETE_HEADER_SAMPLE={0x00,0x00,0x00,0x23,0x76,0x74,0x74,0x63,0x00,0x00,0x00,0x14,0x70,0x61,0x79,0x6c,0x48,0x65,0x6c,0x6c,0x6f,0x20,0x57,0x6f,0x72,0x6c,0x64,0x0a,0x00,0x00,0x00,0x07,0x76,0x74,0x74};
  @Test public void testSingleCueSample() throws SubtitleDecoderException {
    Mp4WebvttDecoder decoder=new Mp4WebvttDecoder();
    Subtitle result=decoder.decode(SINGLE_CUE_SAMPLE,SINGLE_CUE_SAMPLE.length,false);
    Cue expectedCue=new Cue("Hello World");
    assertMp4WebvttSubtitleEquals(result,expectedCue);
  }
  @Test public void testTwoCuesSample() throws SubtitleDecoderException {
    Mp4WebvttDecoder decoder=new Mp4WebvttDecoder();
    Subtitle result=decoder.decode(DOUBLE_CUE_SAMPLE,DOUBLE_CUE_SAMPLE.length,false);
    Cue firstExpectedCue=new Cue("Hello World");
    Cue secondExpectedCue=new Cue("Bye Bye");
    assertMp4WebvttSubtitleEquals(result,firstExpectedCue,secondExpectedCue);
  }
  @Test public void testNoCueSample() throws SubtitleDecoderException {
    Mp4WebvttDecoder decoder=new Mp4WebvttDecoder();
    Subtitle result=decoder.decode(NO_CUE_SAMPLE,NO_CUE_SAMPLE.length,false);
    assertMp4WebvttSubtitleEquals(result);
  }
  @Test public void testSampleWithIncompleteHeader(){
    Mp4WebvttDecoder decoder=new Mp4WebvttDecoder();
    try {
      decoder.decode(INCOMPLETE_HEADER_SAMPLE,INCOMPLETE_HEADER_SAMPLE.length,false);
    }
 catch (    SubtitleDecoderException e) {
      return;
    }
    fail();
  }
  /** 
 * Asserts that the Subtitle's cues (which are all part of the event at t=0) are equal to the expected Cues.
 * @param subtitle The {@link Subtitle} to check.
 * @param expectedCues The expected {@link Cue}s.
 */
  private static void assertMp4WebvttSubtitleEquals(  Subtitle subtitle,  Cue... expectedCues){
    assertThat(subtitle.getEventTimeCount()).isEqualTo(1);
    assertThat(subtitle.getEventTime(0)).isEqualTo(0);
    List<Cue> subtitleCues=subtitle.getCues(0);
    assertThat(subtitleCues).hasSize(expectedCues.length);
    for (int i=0; i < subtitleCues.size(); i++) {
      assertCueEquals(expectedCues[i],subtitleCues.get(i));
    }
  }
  /** 
 * Asserts that two cues are equal.
 */
  private static void assertCueEquals(  Cue expected,  Cue actual){
    assertThat(actual.line).isEqualTo(expected.line);
    assertThat(actual.lineAnchor).isEqualTo(expected.lineAnchor);
    assertThat(actual.lineType).isEqualTo(expected.lineType);
    assertThat(actual.position).isEqualTo(expected.position);
    assertThat(actual.positionAnchor).isEqualTo(expected.positionAnchor);
    assertThat(actual.size).isEqualTo(expected.size);
    assertThat(actual.text.toString()).isEqualTo(expected.text.toString());
    assertThat(actual.textAlignment).isEqualTo(expected.textAlignment);
  }
}
