/** 
 * Unit tests for  {@link DefaultLoadControl}. 
 */
@RunWith(RobolectricTestRunner.class) public class DefaultLoadControlTest {
  private static final float SPEED=1f;
  private static final long MIN_BUFFER_US=C.msToUs(DefaultLoadControl.DEFAULT_MIN_BUFFER_MS);
  private static final long MAX_BUFFER_US=C.msToUs(DefaultLoadControl.DEFAULT_MAX_BUFFER_MS);
  private static final int TARGET_BUFFER_BYTES=C.DEFAULT_BUFFER_SEGMENT_SIZE * 2;
  private Builder builder;
  private DefaultAllocator allocator;
  private DefaultLoadControl loadControl;
  @Before public void setUp() throws Exception {
    builder=new Builder();
    allocator=new DefaultAllocator(true,C.DEFAULT_BUFFER_SEGMENT_SIZE);
  }
  @Test public void testShouldContinueLoading_untilMaxBufferExceeded(){
    createDefaultLoadControl();
    assertThat(loadControl.shouldContinueLoading(0,SPEED)).isTrue();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US,SPEED)).isTrue();
    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US - 1,SPEED)).isTrue();
    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US,SPEED)).isFalse();
  }
  @Test public void testShouldNotContinueLoadingOnceBufferingStopped_untilBelowMinBuffer(){
    createDefaultLoadControl();
    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US,SPEED)).isFalse();
    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US - 1,SPEED)).isFalse();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US,SPEED)).isFalse();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US - 1,SPEED)).isTrue();
  }
  @Test public void testShouldContinueLoadingWithTargetBufferBytesReached_untilMinBufferReached(){
    createDefaultLoadControl();
    makeSureTargetBufferBytesReached();
    assertThat(loadControl.shouldContinueLoading(0,SPEED)).isTrue();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US - 1,SPEED)).isTrue();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US,SPEED)).isFalse();
    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US,SPEED)).isFalse();
  }
  @Test public void testShouldNeverContinueLoading_ifMaxBufferReachedAndNotPrioritizeTimeOverSize(){
    builder.setPrioritizeTimeOverSizeThresholds(false);
    createDefaultLoadControl();
    assertThat(loadControl.shouldContinueLoading(0,SPEED)).isTrue();
    makeSureTargetBufferBytesReached();
    assertThat(loadControl.shouldContinueLoading(0,SPEED)).isFalse();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US,SPEED)).isFalse();
    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US,SPEED)).isFalse();
  }
  @Test public void testShouldContinueLoadingWithMinBufferReached_inFastPlayback(){
    createDefaultLoadControl();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US,SPEED)).isFalse();
    assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US,2f)).isTrue();
  }
  @Test public void testShouldNotContinueLoadingWithMaxBufferReached_inFastPlayback(){
    createDefaultLoadControl();
    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US,100f)).isFalse();
  }
  @Test public void testStartsPlayback_whenMinBufferSizeReached(){
    createDefaultLoadControl();
    assertThat(loadControl.shouldStartPlayback(MIN_BUFFER_US,SPEED,false)).isTrue();
  }
  private void createDefaultLoadControl(){
    builder.setAllocator(allocator);
    builder.setTargetBufferBytes(TARGET_BUFFER_BYTES);
    loadControl=builder.createDefaultLoadControl();
    loadControl.onTracksSelected(new Renderer[0],null,null);
  }
  private void makeSureTargetBufferBytesReached(){
    while (allocator.getTotalBytesAllocated() < TARGET_BUFFER_BYTES) {
      allocator.allocate();
    }
  }
}
