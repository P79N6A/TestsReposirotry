private class FakeDownloadAction extends DownloadAction {
  private final FakeDownloader downloader;
  private FakeDownloadAction(  Uri uri,  boolean isRemoveAction){
    super("Fake",0,uri,isRemoveAction,null);
    this.downloader=new FakeDownloader(isRemoveAction);
  }
  @Override protected void writeToStream(  DataOutputStream output){
  }
  @Override public Downloader createDownloader(  DownloaderConstructorHelper downloaderConstructorHelper){
    return downloader;
  }
  private FakeDownloader getFakeDownloader(){
    return downloader;
  }
  private FakeDownloadAction post(){
    runOnMainThread(() -> downloadManager.handleAction(FakeDownloadAction.this));
    return this;
  }
  private FakeDownloadAction assertDoesNotStart() throws InterruptedException {
    Thread.sleep(ASSERT_FALSE_TIME);
    assertThat(downloader.started.getCount()).isEqualTo(1);
    return this;
  }
  private FakeDownloadAction assertStarted() throws InterruptedException {
    downloader.assertStarted(ASSERT_TRUE_TIMEOUT);
    return assertState(TaskState.STATE_STARTED);
  }
  private FakeDownloadAction assertCompleted(){
    return assertState(TaskState.STATE_COMPLETED);
  }
  private FakeDownloadAction assertFailed(){
    return assertState(TaskState.STATE_FAILED);
  }
  private FakeDownloadAction assertCanceled(){
    return assertState(TaskState.STATE_CANCELED);
  }
  private FakeDownloadAction assertStopped(){
    return assertState(TaskState.STATE_QUEUED);
  }
  private FakeDownloadAction assertState(  @State int expectedState){
    while (true) {
      Integer state=null;
      try {
        state=downloadManagerListener.pollStateChange(this,ASSERT_TRUE_TIMEOUT);
      }
 catch (      InterruptedException e) {
        fail(e.getMessage());
      }
      if (expectedState == state) {
        return this;
      }
    }
  }
  private FakeDownloadAction unblock(){
    downloader.unblock();
    return this;
  }
  private FakeDownloadAction ignoreInterrupts(){
    downloader.ignoreInterrupts=true;
    return this;
  }
}
