@Test public void testReductionGradients2(){
  Nd4j.getRandom().setSeed(12345);
  int d0=3;
  int d1=4;
  int d2=5;
  List<String> failed=new ArrayList<>();
  for (  int reduceDim : new int[]{0,1,2}) {
    for (int i=0; i < 18; i++) {
      int[] outShape;
switch (reduceDim) {
case 0:
        outShape=new int[]{d1,d2};
      break;
case 1:
    outShape=new int[]{d0,d2};
  break;
case 2:
outShape=new int[]{d0,d1};
break;
default :
throw new RuntimeException();
}
SameDiff sd=SameDiff.create();
sd.setLogExecution(false);
SDVariable in=sd.var("in",new int[]{-1,d1,d2});
SDVariable label=sd.var("label",outShape);
SDVariable second=in.mul(2);
double maxRelError=1e-4;
double minAbsError=1e-4;
INDArray inputArr=Nd4j.randn(new int[]{d0,d1,d2}).muli(1000);
INDArray labelArr=Nd4j.randn(outShape).muli(1000);
SDVariable reduced;
String name;
TestCase tc=new TestCase(sd);
switch (i) {
case 0:
reduced=sd.mean("reduced",second,reduceDim);
name="mean";
break;
case 1:
reduced=sd.sum("reduced",second,reduceDim);
name="sum";
break;
case 2:
reduced=sd.standardDeviation("reduced",second,true,reduceDim);
inputArr.divi(1000);
labelArr.divi(1000);
name="stdev";
break;
case 3:
reduced=sd.min("reduced",second,reduceDim);
name="min";
break;
case 4:
reduced=sd.max("reduced",second,reduceDim);
name="max";
break;
case 5:
maxRelError=1e-3;
minAbsError=1;
inputArr.divi(10);
labelArr.divi(100);
BooleanIndexing.replaceWhere(inputArr,Nd4j.rand(inputArr.shape()).muli(100).addi(100),Conditions.absLessThan(1.0));
reduced=sd.variance("reduced",second,true,reduceDim);
name="variance";
break;
case 6:
inputArr.assign(Nd4j.rand(new int[]{d0,d1,d2}).addi(0.5));
labelArr.assign(Nd4j.rand(outShape).addi(0.5));
reduced=sd.prod("reduced",second,reduceDim);
name="prod";
break;
case 7:
maxRelError=1e-4;
inputArr.assign(Nd4j.rand(new int[]{d0,d1,d2}).muli(10));
labelArr.assign(Nd4j.rand(outShape).muli(10));
reduced=sd.norm1("reduced",second,reduceDim);
name="norm1";
break;
case 8:
maxRelError=1e-4;
reduced=sd.norm2("reduced",second,reduceDim);
name="norm2";
break;
case 9:
inputArr=Nd4j.rand(new int[]{d0,d1,d2});
labelArr=Nd4j.rand(outShape);
reduced=sd.normmax("reduced",second,reduceDim);
name="normmax";
break;
case 10:
reduced=sd.argmax("reduced",second,reduceDim);
name="argmax";
break;
case 11:
reduced=sd.argmin("reduced",second,reduceDim);
name="argmin";
break;
case 12:
reduced=sd.countNonZero("reduced",second,reduceDim);
name="countNonZero";
break;
case 13:
reduced=sd.countZero("reduced",second,reduceDim);
name="countZero";
break;
case 14:
reduced=sd.amax("reduced",second,reduceDim);
name="amax";
break;
case 15:
reduced=sd.amin("reduced",second,reduceDim);
name="amin";
break;
case 16:
reduced=sd.asum("reduced",second,reduceDim);
name="asum";
break;
case 17:
reduced=sd.amean("reduced",second,reduceDim);
name="amean";
break;
default :
throw new RuntimeException();
}
SDVariable add=reduced.add(1.0);
SDVariable diff=label.sub(add);
SDVariable sqDiff=diff.mul(diff);
SDVariable mseLoss=sd.mean("loss",sqDiff);
String msg="(test " + i + " - "+ name+ ", dimension="+ reduceDim+ ")";
log.info("*** Starting test: " + msg);
sd.associateArrayWithVariable(inputArr,in);
sd.associateArrayWithVariable(labelArr,label);
tc.gradCheckMaxRelativeError(maxRelError);
tc.gradCheckMinAbsError(minAbsError);
String error=OpValidation.validate(tc);
if (error != null) {
failed.add(name + " - " + error);
}
}
}
assertEquals("Failed: " + failed,0,failed.size());
}
