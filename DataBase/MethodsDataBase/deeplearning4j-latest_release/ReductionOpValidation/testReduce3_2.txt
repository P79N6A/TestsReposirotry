@Test public void testReduce3_2(){
  Nd4j.getRandom().setSeed(12345);
  int d0=3;
  int d1=4;
  int d2=5;
  for (  val reduceDims : new int[][]{{Integer.MAX_VALUE},{0,1,2},{0},{1},{2},{0,1},{0,2},{1,2}}) {
    for (int i=0; i < 6; i++) {
      SameDiff sd=SameDiff.create();
      sd.setLogExecution(false);
      INDArray a=Nd4j.rand(new long[]{d0,d1,d2});
      INDArray b=Nd4j.rand(new long[]{d0,d1,d2});
      SDVariable in=sd.var("in",a);
      SDVariable in2=sd.var("in2",b);
      INDArray expOut;
      SDVariable reduced;
      String name;
switch (i) {
case 0:
        reduced=sd.manhattanDistance(in,in2,reduceDims);
      name="manhattan";
    expOut=Nd4j.getExecutioner().exec(new ManhattanDistance(a,b,null,true,false),reduceDims);
  break;
case 1:
reduced=sd.euclideanDistance(in,in2,reduceDims);
name="euclidean";
expOut=Nd4j.getExecutioner().exec(new EuclideanDistance(a,b,null,true,false),reduceDims);
break;
case 2:
reduced=sd.cosineSimilarity(in,in2,reduceDims);
name="cosine";
expOut=Nd4j.getExecutioner().exec(new CosineSimilarity(a,b,null,true,false),reduceDims);
break;
case 3:
reduced=sd.jaccardDistance(in,in2,reduceDims);
name="jaccard";
expOut=Nd4j.getExecutioner().exec(new JaccardDistance(a,b,null,true,false),reduceDims);
break;
case 4:
reduced=sd.hammingDistance(in,in2,reduceDims);
name="hamming";
expOut=Nd4j.getExecutioner().exec(new HammingDistance(a,b,null,true,false),reduceDims);
break;
case 5:
reduced=sd.cosineDistance(in,in2,reduceDims);
name="reduced";
expOut=Nd4j.getExecutioner().exec(new CosineDistance(a,b,null,true,false),reduceDims);
break;
default :
throw new RuntimeException();
}
long[] expShape;
if (Arrays.equals(new int[]{0},reduceDims)) {
expShape=new long[]{4,5};
}
 else if (Arrays.equals(new int[]{1},reduceDims)) {
expShape=new long[]{3,5};
}
 else if (Arrays.equals(new int[]{2},reduceDims)) {
expShape=new long[]{3,4};
}
 else if (Arrays.equals(new int[]{Integer.MAX_VALUE},reduceDims)) {
expShape=new long[]{};
}
 else if (Arrays.equals(new int[]{0,1},reduceDims)) {
expShape=new long[]{5};
}
 else if (Arrays.equals(new int[]{0,2},reduceDims)) {
expShape=new long[]{4};
}
 else if (Arrays.equals(new int[]{1,2},reduceDims)) {
expShape=new long[]{3};
}
 else if (Arrays.equals(new int[]{0,1,2},reduceDims)) {
expShape=new long[]{};
}
 else {
throw new RuntimeException();
}
String msg=name + " - dims=" + Arrays.toString(reduceDims);
INDArray out=sd.execAndEndResult();
log.info(msg + " - expected shape: " + Arrays.toString(expShape)+ ", out="+ Arrays.toString(out.shape())+ ", outExp="+ Arrays.toString(expOut.shape()));
assertArrayEquals(msg,expShape,out.shape());
assertArrayEquals(msg,expShape,expOut.shape());
assertEquals(msg,out,expOut);
}
}
}
