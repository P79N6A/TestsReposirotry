@Test public void testMiniBatchBalanced() throws Exception {
  int miniBatchSize=100;
  DataSetIterator iterator=new IrisDataSetIterator(miniBatchSize,150);
  File minibatches=testDir.newFolder();
  File saveDir=testDir.newFolder();
  BalanceMinibatches balanceMinibatches=BalanceMinibatches.builder().dataSetIterator(iterator).miniBatchSize(miniBatchSize).numLabels(iterator.totalOutcomes()).rootDir(minibatches).rootSaveDir(saveDir).build();
  balanceMinibatches.balance();
  DataSetIterator balanced=new ExistingMiniBatchDataSetIterator(balanceMinibatches.getRootSaveDir());
  assertTrue(iterator.resetSupported());
  iterator.reset();
  double[] totalCounts=new double[iterator.totalOutcomes()];
  while (iterator.hasNext()) {
    Map<Integer,Double> outcomes=iterator.next().labelCounts();
    for (int i=0; i < iterator.totalOutcomes(); i++) {
      if (outcomes.containsKey(i))       totalCounts[i]+=outcomes.get(i);
    }
  }
  ArrayList<Integer> fullBatches=new ArrayList(totalCounts.length);
  for (int i=0; i < totalCounts.length; i++) {
    fullBatches.add(iterator.totalOutcomes() * (int)totalCounts[i] / miniBatchSize);
  }
  int fullyBalanceableBatches=Collections.min(fullBatches);
  for (int b=0; b < fullyBalanceableBatches; b++) {
    Map<Integer,Double> balancedCounts=balanced.next().labelCounts();
    for (int i=0; i < iterator.totalOutcomes(); i++) {
      double bCounts=(balancedCounts.containsKey(i) ? balancedCounts.get(i) : 0);
      assertTrue("key " + i + " totalOutcomes: "+ iterator.totalOutcomes()+ " balancedCounts : "+ balancedCounts.containsKey(i)+ " val : "+ bCounts,balancedCounts.containsKey(i) && balancedCounts.get(i) >= (double)miniBatchSize / iterator.totalOutcomes());
    }
  }
}
