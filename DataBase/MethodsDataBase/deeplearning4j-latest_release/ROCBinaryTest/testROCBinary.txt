@Test public void testROCBinary(){
  Nd4j.getRandom().setSeed(12345);
  int nExamples=50;
  int nOut=4;
  int[] shape={nExamples,nOut};
  for (  int thresholdSteps : new int[]{30,0}) {
    INDArray labels=Nd4j.getExecutioner().exec(new BernoulliDistribution(Nd4j.createUninitialized(shape),0.5));
    INDArray predicted=Nd4j.rand(shape);
    INDArray binaryPredicted=predicted.gt(0.5);
    ROCBinary rb=new ROCBinary(thresholdSteps);
    for (int xe=0; xe < 2; xe++) {
      rb.eval(labels,predicted);
      System.out.println(rb.stats());
      double eps=1e-6;
      for (int i=0; i < nOut; i++) {
        INDArray lCol=labels.getColumn(i);
        INDArray pCol=predicted.getColumn(i);
        ROC r=new ROC(thresholdSteps);
        r.eval(lCol,pCol);
        double aucExp=r.calculateAUC();
        double auc=rb.calculateAUC(i);
        assertEquals(aucExp,auc,eps);
        long apExp=r.getCountActualPositive();
        long ap=rb.getCountActualPositive(i);
        assertEquals(ap,apExp);
        long anExp=r.getCountActualNegative();
        long an=rb.getCountActualNegative(i);
        assertEquals(anExp,an);
        PrecisionRecallCurve pExp=r.getPrecisionRecallCurve();
        PrecisionRecallCurve p=rb.getPrecisionRecallCurve(i);
        assertEquals(pExp,p);
      }
      rb.reset();
    }
  }
}
