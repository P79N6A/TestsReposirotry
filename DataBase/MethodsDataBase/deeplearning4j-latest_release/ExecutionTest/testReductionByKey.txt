@Test public void testReductionByKey(){
  List<List<Writable>> in=Arrays.asList(Arrays.<Writable>asList(new IntWritable(0),new Text("first"),new DoubleWritable(3.0)),Arrays.<Writable>asList(new IntWritable(0),new Text("second"),new DoubleWritable(5.0)),Arrays.<Writable>asList(new IntWritable(1),new Text("f"),new DoubleWritable(30.0)),Arrays.<Writable>asList(new IntWritable(1),new Text("s"),new DoubleWritable(50.0)));
  List<List<Writable>> inData=in;
  Schema s=new Schema.Builder().addColumnInteger("intCol").addColumnString("textCol").addColumnDouble("doubleCol").build();
  TransformProcess tp=new TransformProcess.Builder(s).reduce(new Reducer.Builder(ReduceOp.TakeFirst).keyColumns("intCol").takeFirstColumns("textCol").meanColumns("doubleCol").build()).build();
  List<List<Writable>> outRdd=LocalTransformExecutor.execute(inData,tp);
  List<List<Writable>> out=outRdd;
  List<List<Writable>> expOut=Arrays.asList(Arrays.<Writable>asList(new IntWritable(0),new Text("first"),new DoubleWritable(4.0)),Arrays.<Writable>asList(new IntWritable(1),new Text("f"),new DoubleWritable(40.0)));
  out=new ArrayList<>(out);
  Collections.sort(out,new Comparator<List<Writable>>(){
    @Override public int compare(    List<Writable> o1,    List<Writable> o2){
      return Integer.compare(o1.get(0).toInt(),o2.get(0).toInt());
    }
  }
);
  assertEquals(expOut,out);
}
