@Test public void testRepartitioning3(){
  List<Integer> ints=new ArrayList<>();
  for (int i=0; i < 224; i++) {
    ints.add(i);
  }
  JavaRDD<Integer> rdd=sc.parallelize(ints);
  JavaPairRDD<Integer,Integer> pRdd=SparkUtils.indexedRDD(rdd);
  JavaPairRDD<Integer,Integer> initial=pRdd.partitionBy(new Partitioner(){
    @Override public int getPartition(    Object key){
      int i=(Integer)key;
      if (i < 29) {
        return 0;
      }
 else       if (i < 29 + 29) {
        return 1;
      }
 else       if (i < 29 + 29 + 29) {
        return 2;
      }
 else       if (i < 29 + 29 + 29+ 34) {
        return 3;
      }
 else       if (i < 29 + 29 + 29+ 34+ 34) {
        return 4;
      }
 else       if (i < 29 + 29 + 29+ 34+ 34+ 35) {
        return 5;
      }
 else {
        return 6;
      }
    }
    @Override public int numPartitions(){
      return 7;
    }
  }
);
  List<Tuple2<Integer,Integer>> partitionCounts=initial.values().mapPartitionsWithIndex(new CountPartitionsFunction<Integer>(),true).collect();
  System.out.println(partitionCounts);
  List<Tuple2<Integer,Integer>> initialExpected=Arrays.asList(new Tuple2<>(0,29),new Tuple2<>(1,29),new Tuple2<>(2,29),new Tuple2<>(3,34),new Tuple2<>(4,34),new Tuple2<>(5,35),new Tuple2<>(6,34));
  Assert.assertEquals(initialExpected,partitionCounts);
  JavaRDD<Integer> afterRepartition=SparkUtils.repartitionBalanceIfRequired(initial.values(),Repartition.Always,2,112);
  List<Tuple2<Integer,Integer>> partitionCountsAfter=afterRepartition.mapPartitionsWithIndex(new CountPartitionsFunction<Integer>(),true).collect();
  System.out.println(partitionCountsAfter);
  for (  Tuple2<Integer,Integer> t2 : partitionCountsAfter) {
    assertEquals(2,(int)t2._2());
  }
}
