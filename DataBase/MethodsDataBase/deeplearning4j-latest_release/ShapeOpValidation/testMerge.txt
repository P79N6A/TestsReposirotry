@Test public void testMerge(){
  Nd4j.getRandom().setSeed(12345);
  List<String> failed=new ArrayList<>();
  for (int t=0; t < 3; t++) {
    for (    int numArrays : new int[]{3,1}) {
      for (      long[] shape : new long[][]{{1},{3,4},{3,4,5}}) {
        SameDiff sd=SameDiff.create();
        SDVariable[] arr=new SDVariable[numArrays];
        for (int i=0; i < numArrays; i++) {
          arr[i]=sd.var(String.valueOf(i),Nd4j.rand(shape));
        }
        INDArray exp=arr[0].getArr().dup();
        SDVariable merge;
        String name;
switch (t) {
case 0:
          name="mergeAdd";
        merge=sd.mergeAdd(arr);
      for (int i=1; i < numArrays; i++) {
        exp.addi(arr[i].getArr().dup());
      }
    break;
case 1:
  name="mergeMax";
merge=sd.mergeMax(arr);
for (int i=1; i < numArrays; i++) {
exp=Transforms.max(exp,arr[i].getArr(),true);
}
break;
case 2:
name="mergeAvg";
merge=sd.mergeAvg(arr);
for (int i=1; i < numArrays; i++) {
exp.addi(arr[i].getArr().dup());
}
exp.divi(numArrays);
break;
default :
throw new RuntimeException();
}
String msg=name + " - numArrays=" + numArrays+ ", shape="+ Arrays.toString(shape);
SDVariable loss;
if (shape.length > 1) {
loss=sd.standardDeviation("loss",merge,true);
}
 else {
loss=sd.mean("loss",merge);
}
TestCase tc=new TestCase(sd).expected(merge,exp).testName(msg);
String error=OpValidation.validate(tc,true);
if (error != null) {
failed.add(msg);
}
}
}
}
assertEquals(failed.toString(),0,failed.size());
}
