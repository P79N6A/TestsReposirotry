@Test public void testUnStack(){
  Nd4j.getRandom().setSeed(12345);
  List<String> failed=new ArrayList<>();
  List<long[]> unstackedShape=Arrays.asList(new long[]{1},new long[]{1,1},new long[]{3,4},new long[]{3,4,5},new long[]{3,4,5,6});
  for (  long[] shape : unstackedShape) {
    for (int axis=0; axis <= shape.length; axis++) {
      for (      int numInputs : new int[]{3}) {
        long[] stackedShape=new long[shape.length + 1];
        int x=0;
        for (int i=0; i <= shape.length; i++) {
          if (i == axis) {
            stackedShape[i]=numInputs;
          }
 else {
            stackedShape[i]=shape[x++];
          }
        }
        SameDiff sd=SameDiff.create();
        INDArray in=Nd4j.rand(stackedShape);
        SDVariable var=sd.var("var",in);
        SDVariable[] unstacked=sd.unstack(var,axis,numInputs);
        INDArray[] unstackedExp=null;
        if (Arrays.equals(new long[]{3,4},shape)) {
          unstackedExp=new INDArray[numInputs];
          if (axis == 0) {
            for (int i=0; i < numInputs; i++) {
              unstackedExp[i]=in.get(point(i),all(),all());
            }
          }
 else           if (axis == 1) {
            for (int i=0; i < numInputs; i++) {
              unstackedExp[i]=in.get(all(),point(i),all());
            }
          }
 else {
            for (int i=0; i < numInputs; i++) {
              unstackedExp[i]=in.get(all(),all(),point(i));
            }
          }
        }
        SDVariable merged=sd.mergeAvg(unstacked);
        if (ArrayUtil.prodLong(stackedShape) == 1 || ArrayUtil.prodLong(shape) == 1) {
          SDVariable loss=sd.sum("loss",merged);
        }
 else {
          SDVariable loss=sd.standardDeviation("loss",merged,true);
        }
        String msg="Unstacked shape = " + Arrays.toString(shape) + ", stacked shape = "+ Arrays.toString(stackedShape)+ ", axis="+ axis+ ", numInputs="+ numInputs;
        sd.execAndEndResult();
        for (        SDVariable v : unstacked) {
          assertArrayEquals(msg,shape,v.getArr().shape());
        }
        TestCase tc=new TestCase(sd).testName(msg);
        if (unstackedExp != null) {
          for (int i=0; i < numInputs; i++) {
            tc.expected(unstacked[i],unstackedExp[i]);
          }
        }
        String error=OpValidation.validate(tc,true);
        if (error != null) {
          failed.add(error);
        }
      }
    }
  }
  assertEquals(failed.toString(),0,failed.size());
}
