@Test public void testSegmentOps(){
  INDArray s=Nd4j.create(new double[]{0,0,0,1,2,2,3,3},new long[]{8});
  INDArray d=Nd4j.create(new double[]{5,1,7,2,3,4,1,3},new long[]{8});
  int numSegments=4;
  List<String> failed=new ArrayList<>();
  for (  String op : new String[]{"max","min","mean","prod","sum","umax","umin","umean","uprod","usum","usqrtn"}) {
    log.info("Starting test: {}",op);
    if (op.startsWith("u")) {
      s=Nd4j.create(new double[]{3,1,0,0,2,0,3,2},new long[]{8});
      d=Nd4j.create(new double[]{1,2,5,7,3,1,3,4},new long[]{8});
    }
    SameDiff sd=SameDiff.create();
    SDVariable data=sd.var("data",d);
    SDVariable segments=sd.var("segments",s);
    SDVariable sm;
    INDArray exp;
switch (op) {
case "max":
      sm=sd.segmentMax(data,segments);
    exp=Nd4j.create(new double[]{7,2,4,3});
  break;
case "min":
sm=sd.segmentMin(data,segments);
exp=Nd4j.create(new double[]{1,2,3,1});
break;
case "mean":
sm=sd.segmentMean(data,segments);
exp=Nd4j.create(new double[]{4.3333333333,2,3.5,2});
break;
case "prod":
sm=sd.segmentProd(data,segments);
exp=Nd4j.create(new double[]{35,2,12,3});
break;
case "sum":
sm=sd.segmentSum(data,segments);
exp=Nd4j.create(new double[]{13,2,7,4});
break;
case "umax":
sm=sd.unsortedSegmentMax(data,segments,numSegments);
exp=Nd4j.create(new double[]{7,2,4,3});
break;
case "umin":
sm=sd.unsortedSegmentMin(data,segments,numSegments);
exp=Nd4j.create(new double[]{1,2,3,1});
break;
case "umean":
sm=sd.unsortedSegmentMean(data,segments,numSegments);
exp=Nd4j.create(new double[]{4.3333333333,2,3.5,2});
break;
case "uprod":
sm=sd.unsortedSegmentProd(data,segments,numSegments);
exp=Nd4j.create(new double[]{35,2,12,3});
break;
case "usum":
sm=sd.unsortedSegmentSum(data,segments,numSegments);
exp=Nd4j.create(new double[]{13,2,7,4});
break;
case "usqrtn":
sm=sd.unsortedSegmentSqrtN(data,segments,numSegments);
exp=Nd4j.trueVector(new double[]{(5 + 7 + 1) / Math.sqrt(3),2,(3 + 4) / Math.sqrt(2),(1 + 3) / Math.sqrt(2)});
break;
default :
throw new RuntimeException();
}
SDVariable loss=sm.std(false);
TestCase tc=new TestCase(sd).testName(op).expected(sm,exp).gradientCheck(true).gradCheckSkipVariables(segments.getVarName());
String err=OpValidation.validate(tc);
if (err != null) failed.add(err);
}
assertEquals(failed.toString(),0,failed.size());
}
