@Test public void RocEvalSanityCheck(){
  DataSetIterator iter=new IrisDataSetIterator(150,150);
  Nd4j.getRandom().setSeed(12345);
  MultiLayerConfiguration conf=new NeuralNetConfiguration.Builder().weightInit(WeightInit.XAVIER).seed(12345).list().layer(0,new DenseLayer.Builder().nIn(4).nOut(4).activation(Activation.TANH).build()).layer(1,new OutputLayer.Builder().nIn(4).nOut(3).activation(Activation.SOFTMAX).lossFunction(LossFunctions.LossFunction.MCXENT).build()).build();
  MultiLayerNetwork net=new MultiLayerNetwork(conf);
  net.init();
  NormalizerStandardize ns=new NormalizerStandardize();
  DataSet ds=iter.next();
  ns.fit(ds);
  ns.transform(ds);
  iter.setPreProcessor(ns);
  for (int i=0; i < 10; i++) {
    net.fit(ds);
  }
  for (  int steps : new int[]{32,0}) {
    System.out.println("steps: " + steps);
    iter.reset();
    ds=iter.next();
    INDArray f=ds.getFeatures();
    INDArray l=ds.getLabels();
    INDArray out=net.output(f);
    ROCMultiClass manual=new ROCMultiClass(steps);
    manual.eval(l,out);
    iter.reset();
    ROCMultiClass roc=net.evaluateROCMultiClass(iter,steps);
    for (int i=0; i < 3; i++) {
      double rocExp=manual.calculateAUC(i);
      double rocAct=roc.calculateAUC(i);
      assertEquals(rocExp,rocAct,1e-6);
      RocCurve rc=roc.getRocCurve(i);
      RocCurve rm=manual.getRocCurve(i);
      assertEquals(rc,rm);
    }
  }
}
