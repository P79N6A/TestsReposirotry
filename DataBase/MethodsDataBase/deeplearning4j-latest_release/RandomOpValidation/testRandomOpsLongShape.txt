@Test public void testRandomOpsLongShape(){
  List<String> failed=new ArrayList<>();
  for (  long[] shape : Arrays.asList(new long[]{1000},new long[]{100,10},new long[]{40,5,5})) {
    for (int i=0; i < 6; i++) {
      Nd4j.getRandom().setSeed(12345);
      SameDiff sd=SameDiff.create();
      SDVariable rand;
      Function<INDArray,String> checkFn;
      String name;
switch (i) {
case 0:
        name="randomBernoulli";
      rand=sd.randomBernoulli(0.5,shape);
    checkFn=in -> {
      double mean=in.meanNumber().doubleValue();
      double min=in.minNumber().doubleValue();
      double max=in.maxNumber().doubleValue();
      int sum0=Transforms.not(in.dup()).sumNumber().intValue();
      int sum1=in.sumNumber().intValue();
      if ((in.length() == 1 && min == max && (min == 0 || min == 1)) || (Math.abs(mean - 0.5) < 0.1 && min == 0 && max == 1 && (sum0 + sum1) == in.length()))       return null;
      return "Failed: bernoulli - sum0 = " + sum0 + ", sum1 = "+ sum1;
    }
;
  break;
case 1:
name="normal";
rand=sd.randomNormal(1,2,shape);
checkFn=in -> {
double mean=in.meanNumber().doubleValue();
double stdev=in.std(true).getDouble(0);
if (in.length() == 1 || (Math.abs(mean - 1) < 0.1 && Math.abs(stdev - 2) < 0.1)) return null;
return "Failed: mean = " + mean + ", stdev = "+ stdev;
}
;
break;
case 2:
name="randomBinomial";
rand=sd.randomBinomial(4,0.5,shape);
checkFn=in -> {
NdIndexIterator iter=new NdIndexIterator(in.shape());
while (iter.hasNext()) {
long[] idx=iter.next();
double d=in.getDouble(idx);
if (d < 0 || d > 4 || d != Math.floor(d)) {
return "Falied - binomial: indexes " + Arrays.toString(idx) + ", value "+ d;
}
}
return null;
}
;
break;
case 3:
name="randomUniform";
rand=sd.randomUniform(1,2,shape);
checkFn=in -> {
double min=in.minNumber().doubleValue();
double max=in.maxNumber().doubleValue();
double mean=in.meanNumber().doubleValue();
if (min >= 1 && max <= 2 && (in.length() == 1 || Math.abs(mean - 1.5) < 0.1)) return null;
return "Failed: min = " + min + ", max = "+ max+ ", mean = "+ mean;
}
;
break;
case 4:
if (OpValidationSuite.IGNORE_FAILING) {
continue;
}
name="truncatednormal";
rand=sd.randomNormalTruncated(1,2,shape);
checkFn=in -> {
double mean=in.meanNumber().doubleValue();
double stdev=in.std(true).getDouble(0);
if (in.length() == 1 || (Math.abs(mean - 1) < 0.1 && Math.abs(stdev - 2) < 0.2)) return null;
return "Failed: mean = " + mean + ", stdev = "+ stdev;
}
;
break;
case 5:
name="lognormal";
rand=sd.randomLogNormal(1,2,shape);
checkFn=in -> {
INDArray log=Transforms.log(in,true);
double mean=log.meanNumber().doubleValue();
double stdev=log.std(true).getDouble(0);
if (in.length() == 1 || (Math.abs(mean - 1) < 0.1 && Math.abs(stdev - 2) < 0.1)) return null;
return "Failed: mean = " + mean + ", stdev = "+ stdev;
}
;
break;
default :
throw new RuntimeException();
}
SDVariable loss;
if (shape.length > 0) {
loss=rand.std(true);
}
 else {
loss=rand.mean();
}
String msg=name + " - " + Arrays.toString(shape);
TestCase tc=new TestCase(sd).gradCheckSkipVariables("shape").testName(msg).expected(rand,checkFn).testFlatBufferSerialization(TestCase.TestSerialization.NONE);
log.info("TEST: " + msg);
String err=OpValidation.validate(tc,true);
if (err != null) {
failed.add(err);
}
}
}
assertEquals(failed.toString(),0,failed.size());
}
