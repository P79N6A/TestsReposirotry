@Test public void testRandomOpsSDVarShape(){
  List<String> failed=new ArrayList<>();
  for (  double[] shape : Arrays.asList(new double[]{1000.0},new double[]{100,10},new double[]{40,5,5})) {
    for (int i=0; i < 4; i++) {
      INDArray arr=Nd4j.trueVector(shape);
      Nd4j.getRandom().setSeed(12345);
      SameDiff sd=SameDiff.create();
      SDVariable shapeVar=sd.var("shape",arr);
      SDVariable rand;
      Function<INDArray,String> checkFn;
      String name;
switch (i) {
case 0:
        name="randomUniform";
      rand=sd.randomUniform(1,2,shapeVar);
    checkFn=in -> {
      double min=in.minNumber().doubleValue();
      double max=in.maxNumber().doubleValue();
      double mean=in.meanNumber().doubleValue();
      if (min >= 1 && max <= 2 && (in.length() == 1 || Math.abs(mean - 1.5) < 0.1))       return null;
      return "Failed: min = " + min + ", max = "+ max+ ", mean = "+ mean;
    }
;
  break;
case 1:
name="randomNormal";
rand=sd.randomNormal(1,1,shapeVar);
checkFn=in -> {
double mean=in.meanNumber().doubleValue();
double stdev=in.std(true).getDouble(0);
if (in.length() == 1 || (Math.abs(mean - 1) < 0.1 && Math.abs(stdev - 1) < 0.1)) return null;
return "Failed: mean = " + mean + ", stdev = "+ stdev;
}
;
break;
case 2:
name="randomBernoulli";
rand=sd.randomBernoulli(0.5,shapeVar);
checkFn=in -> {
double mean=in.meanNumber().doubleValue();
double min=in.minNumber().doubleValue();
double max=in.maxNumber().doubleValue();
int sum0=Transforms.not(in.dup()).sumNumber().intValue();
int sum1=in.sumNumber().intValue();
if ((in.length() == 1 && min == max && (min == 0 || min == 1)) || (Math.abs(mean - 0.5) < 0.1 && min == 0 && max == 1 && (sum0 + sum1) == in.length())) return null;
return "Failed: bernoulli - sum0 = " + sum0 + ", sum1 = "+ sum1;
}
;
break;
case 3:
name="randomExponential";
final double lambda=2;
rand=sd.randomExponential(lambda,shapeVar);
checkFn=in -> {
double mean=in.meanNumber().doubleValue();
double min=in.minNumber().doubleValue();
double std=in.stdNumber().doubleValue();
if ((in.length() == 1 && min > 0) || (Math.abs(mean - 1 / lambda) < 0.1 && min >= 0 && Math.abs(std - 1 / lambda) < 0.1)) return null;
return "Failed: exponential: mean=" + mean + ", std = "+ std+ ", min="+ min;
}
;
break;
default :
throw new RuntimeException();
}
SDVariable loss;
if (shape.length > 0) {
loss=rand.std(true);
}
 else {
loss=rand.mean();
}
String msg=name + " - " + Arrays.toString(shape);
TestCase tc=new TestCase(sd).gradCheckSkipVariables("shape").testName(msg).expected(rand,checkFn).testFlatBufferSerialization(TestCase.TestSerialization.NONE);
log.info("TEST: " + msg);
String err=OpValidation.validate(tc,true);
if (err != null) {
failed.add(err);
}
}
}
assertEquals(failed.toString(),0,failed.size());
}
