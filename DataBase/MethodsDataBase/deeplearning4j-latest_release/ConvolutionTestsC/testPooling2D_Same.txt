@Test public void testPooling2D_Same(){
  int[] miniBatches={1,3,5};
  int[] depths={1,3,5};
  int[] inHeights={5,21};
  int[] inWidths={5,21};
  int[] strideH={1,2};
  int[] strideW={1,2};
  int[] sizeW={1,2,3};
  int[] sizeH={1,2,3};
  int[] padH={0};
  int[] padW={0};
  Pooling2D.Pooling2DType[] types=new Pooling2D.Pooling2DType[]{Pooling2D.Pooling2DType.PNORM,Pooling2D.Pooling2DType.AVG,Pooling2D.Pooling2DType.MAX};
  int cnt=0;
  for (  Pooling2D.Pooling2DType type : types) {
    log.info("Trying pooling type: [{}]",type);
    for (    int m : miniBatches) {
      for (      int d : depths) {
        for (        int h : inHeights) {
          for (          int w : inWidths) {
            for (            int sh : strideH) {
              for (              int sw : strideW) {
                for (                int kh : sizeH) {
                  for (                  int kw : sizeW) {
                    INDArray in=Nd4j.linspace(1,(m * d * h* w),(m * d * h* w)).reshape(new int[]{m,d,h,w});
                    int[] outSize=getOutputSize(in,new int[]{kh,kw},new int[]{sh,sw},null,true);
                    int pHTotal=(outSize[0] - 1) * sh + kh - h;
                    int pWTotal=(outSize[1] - 1) * sw + kw - w;
                    int padTop=pHTotal / 2;
                    int padLeft=pWTotal / 2;
                    INDArray col=Nd4j.create(new int[]{m,d,outSize[0],outSize[1],kh,kw},'c');
                    INDArray col2=col.permute(0,1,4,5,2,3);
                    Convolution.im2col(in,kh,kw,sh,sw,padTop,padLeft,true,col2);
                    INDArray col2d=col.reshape('c',m * d * outSize[0]* outSize[1],kh * kw);
                    INDArray output=Nd4j.create(m,d,outSize[0],outSize[1]);
                    INDArray reduced=null;
switch (type) {
case PNORM:
                      int pnorm=3;
                    Transforms.abs(col2d,false);
                  Transforms.pow(col2d,pnorm,false);
                reduced=col2d.sum(1);
              Transforms.pow(reduced,(1.0 / pnorm),false);
            Convolution.pooling2D(in,kh,kw,sh,sw,padTop,padLeft,1,1,true,Pooling2D.Pooling2DType.PNORM,Pooling2D.Divisor.INCLUDE_PADDING,(double)pnorm,outSize[0],outSize[1],output);
          break;
case MAX:
        Convolution.pooling2D(in,kh,kw,sh,sw,padTop,padLeft,1,1,true,Pooling2D.Pooling2DType.MAX,Pooling2D.Divisor.INCLUDE_PADDING,0.0,outSize[0],outSize[1],output);
      reduced=col2d.max(1);
    break;
case AVG:
  Convolution.pooling2D(in,kh,kw,sh,sw,padTop,padLeft,1,1,true,Pooling2D.Pooling2DType.AVG,Pooling2D.Divisor.INCLUDE_PADDING,0.0,outSize[0],outSize[1],output);
reduced=col2d.mean(1);
break;
}
reduced=reduced.reshape('c',m,d,outSize[0],outSize[1]).dup('c');
assertEquals("Failed opType: " + type,reduced,output);
}
}
}
}
}
}
}
}
}
}
