@Test public void testConditionalReduction(){
  Schema schema=new Schema.Builder().addColumnString("key").addColumnInteger("intCol").addColumnString("filterCol").addColumnString("textCol").build();
  List<List<Writable>> inputs=new ArrayList<>();
  inputs.add(Arrays.<Writable>asList(new Text("someKey"),new IntWritable(1),new Text("a"),new Text("zero")));
  inputs.add(Arrays.<Writable>asList(new Text("someKey"),new IntWritable(2),new Text("b"),new Text("one")));
  inputs.add(Arrays.<Writable>asList(new Text("someKey"),new IntWritable(3),new Text("a"),new Text("two")));
  inputs.add(Arrays.<Writable>asList(new Text("someKey"),new IntWritable(4),new Text("b"),new Text("three")));
  inputs.add(Arrays.<Writable>asList(new Text("someKey"),new IntWritable(5),new Text("a"),new Text("three")));
  inputs.add(Arrays.<Writable>asList(new Text("someKey"),new IntWritable(6),new Text("b"),new Text("three")));
  Condition condition=new StringColumnCondition("filterCol",ConditionOp.Equal,"a");
  Reducer reducer=new Reducer.Builder(ReduceOp.Stdev).keyColumns("key").conditionalReduction("intCol","sumOfAs",ReduceOp.Sum,condition).countUniqueColumns("filterCol","textCol").build();
  reducer.setInputSchema(schema);
  IAggregableReduceOp<List<Writable>,List<Writable>> accumulator=reducer.aggregableReducer();
  for (int i=0; i < inputs.size(); i++) {
    accumulator.accept(inputs.get(i));
  }
  List<Writable> out=accumulator.get();
  List<Writable> expected=Arrays.<Writable>asList(new Text("someKey"),new IntWritable(1 + 3 + 5),new LongWritable(2),new LongWritable(4));
  assertEquals(4,out.size());
  assertEquals(expected,out);
  Schema outSchema=reducer.transform(schema);
  assertEquals(4,outSchema.numColumns());
  assertEquals(Arrays.asList("key","sumOfAs","countunique(filterCol)","countunique(textCol)"),outSchema.getColumnNames());
  assertEquals(Arrays.asList(ColumnType.String,ColumnType.Integer,ColumnType.Long,ColumnType.Long),outSchema.getColumnTypes());
}
