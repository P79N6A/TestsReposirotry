@Test(timeout=180000) public void testConcurrentRelogin() throws Exception {
  final CyclicBarrier barrier=new CyclicBarrier(2);
  final CountDownLatch latch=new CountDownLatch(1);
  assertTrue(UserGroupInformation.isSecurityEnabled());
  KerberosPrincipal principal=new KerberosPrincipal("testUser");
  File keytab=new File(workDir,"user1.keytab");
  kdc.createPrincipal(keytab,principal.getName());
  final UserGroupInformation loginUgi=UserGroupInformation.loginUserFromKeytabAndReturnUGI(principal.getName(),keytab.getPath());
  assertEquals(AuthenticationMethod.KERBEROS,loginUgi.getAuthenticationMethod());
  assertTrue(loginUgi.isFromKeytab());
  final UserGroupInformation clonedUgi=UserGroupInformation.getUGIFromSubject(loginUgi.getSubject());
  assertEquals(AuthenticationMethod.KERBEROS,clonedUgi.getAuthenticationMethod());
  assertTrue(clonedUgi.isFromKeytab());
  User user=getUser(loginUgi.getSubject());
  final LoginContext spyLogin=Mockito.spy(user.getLogin());
  user.setLogin(spyLogin);
  Mockito.doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      invocation.callRealMethod();
      latch.countDown();
      barrier.await();
      return null;
    }
  }
).when(spyLogin).logout();
  Future<Void> relogin=executor.submit(new Callable<Void>(){
    @Override public Void call() throws Exception {
      Thread.currentThread().setName("relogin");
      loginUgi.reloginFromKeytab();
      return null;
    }
  }
);
  assertTrue("first relogin didn't block",latch.await(2,TimeUnit.SECONDS));
  assertTrue(clonedUgi.isFromKeytab());
  Mockito.doNothing().when(spyLogin).logout();
  Mockito.doNothing().when(spyLogin).login();
  Future<UserGroupInformation> clonedRelogin=executor.submit(new Callable<UserGroupInformation>(){
    @Override public UserGroupInformation call() throws Exception {
      Thread.currentThread().setName("clonedRelogin");
      clonedUgi.reloginFromKeytab();
      return clonedUgi;
    }
  }
);
  try {
    clonedRelogin.get(2,TimeUnit.SECONDS);
    fail("second relogin didn't block!");
  }
 catch (  TimeoutException te) {
  }
  loginUgi.doAs(new PrivilegedExceptionAction<Void>(){
    @Override public Void run() throws Exception {
      UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
      assertEquals(principal.getName(),ugi.getUserName());
      assertTrue(ugi.isFromKeytab());
      return null;
    }
  }
);
  clonedUgi.doAs(new PrivilegedExceptionAction<Void>(){
    @Override public Void run() throws Exception {
      UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
      assertEquals(principal.getName(),ugi.getUserName());
      assertTrue(ugi.isFromKeytab());
      return null;
    }
  }
);
  assertFalse(clonedRelogin.isDone());
  barrier.await();
  relogin.get();
  clonedRelogin.get();
}
