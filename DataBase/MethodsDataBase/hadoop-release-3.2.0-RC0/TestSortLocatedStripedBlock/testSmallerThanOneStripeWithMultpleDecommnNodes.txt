/** 
 * Test to verify sorting with decommissioned datanodes exists in storage list which is smaller than stripe size. We have storage list, marked decommissioned internal blocks with a ' d0, d1, d2, d3, d6, d7, d8, d9, d10, d11 mapping to indices 0', 1, 2', 3, 6, 7, 8, 0, 2', 2 Decommissioned node indices: 0', 2', 2' Here decommissioned has done twice to the datanode block index 2. So in the original list nodes d0, d2, d10 are decommissioned state. After sorting the expected block indices list should be, 0, 1, 2, 3, 6, 7, 8, 0', 2', 2' After sorting the expected storage list will be, d9, d1, d11, d3, d6, d7, d8, d0, d2, d10. Note: after sorting block indices will not be in ascending order.
 */
@Test(timeout=10000) public void testSmallerThanOneStripeWithMultpleDecommnNodes() throws Exception {
  LOG.info("Starting test testSmallerThanOneStripeWithDecommn");
  int lbsCount=2;
  List<Integer> decommnNodeIndices=new ArrayList<>();
  decommnNodeIndices.add(0);
  decommnNodeIndices.add(2);
  decommnNodeIndices.add(2);
  List<Integer> targetNodeIndices=new ArrayList<>();
  targetNodeIndices.addAll(decommnNodeIndices);
  HashMap<Integer,List<String>> decommissionedNodes=new HashMap<>(lbsCount * decommnNodeIndices.size());
  int dataBlksNum=dataBlocks - 2;
  List<LocatedBlock> lbs=createLocatedStripedBlocks(lbsCount,dataBlksNum,parityBlocks,decommnNodeIndices,targetNodeIndices,decommissionedNodes);
  List<HashMap<DatanodeInfo,Byte>> locToIndexList=new ArrayList<>();
  List<HashMap<DatanodeInfo,Token<BlockTokenIdentifier>>> locToTokenList=new ArrayList<>();
  prepareBlockIndexAndTokenList(lbs,locToIndexList,locToTokenList);
  dm.sortLocatedBlocks(null,lbs);
  int blkGrpWidth=dataBlksNum + parityBlocks;
  assertDecommnNodePosition(blkGrpWidth,decommissionedNodes,lbs);
  assertBlockIndexAndTokenPosition(lbs,locToIndexList,locToTokenList);
}
