/** 
 * Test to verify sorting with two decommissioned datanodes exists in storage lists for the same block index. We have storage list, marked decommissioned internal blocks with a ' d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13 mapping to indices 0', 1', 2, 3, 4', 5', 6, 7, 8, 0, 1', 4, 5, 1 Decommissioned node indices: 0', 1', 4', 5', 1' Here decommissioned has done twice to the datanode block index 1. So in the original list nodes d0, d1, d4, d5, d10 are decommissioned state. After sorting the expected block indices list will be, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0', 1', 1', 4', 5' After sorting the expected storage list will be, d9, d13, d2, d3, d11, d12, d6, d7, d8, d0, d1, d10, d4, d5. Note: after sorting block indices will not be in ascending order.
 */
@Test(timeout=10000) public void testTwoDatanodesWithSameBlockIndexAreDecommn(){
  LOG.info("Starting test testTwoDatanodesWithSameBlockIndexAreDecommn");
  int lbsCount=2;
  List<Integer> decommnNodeIndices=new ArrayList<>();
  decommnNodeIndices.add(0);
  decommnNodeIndices.add(1);
  decommnNodeIndices.add(4);
  decommnNodeIndices.add(5);
  decommnNodeIndices.add(1);
  List<Integer> targetNodeIndices=new ArrayList<>();
  targetNodeIndices.addAll(decommnNodeIndices);
  HashMap<Integer,List<String>> decommissionedNodes=new HashMap<>(lbsCount * decommnNodeIndices.size());
  List<LocatedBlock> lbs=createLocatedStripedBlocks(lbsCount,dataBlocks,parityBlocks,decommnNodeIndices,targetNodeIndices,decommissionedNodes);
  List<HashMap<DatanodeInfo,Byte>> locToIndexList=new ArrayList<>();
  List<HashMap<DatanodeInfo,Token<BlockTokenIdentifier>>> locToTokenList=new ArrayList<>();
  prepareBlockIndexAndTokenList(lbs,locToIndexList,locToTokenList);
  dm.sortLocatedBlocks(null,lbs);
  assertDecommnNodePosition(groupSize,decommissionedNodes,lbs);
  assertBlockIndexAndTokenPosition(lbs,locToIndexList,locToTokenList);
}
