/** 
 * The corrupt block has to be removed when the number of valid replicas matches replication factor for the file. In this the above condition is tested by reducing the replication factor  The test strategy :  Bring up Cluster with 3 DataNodes Create a file of replication factor 3  Corrupt one replica of a block of the file  Verify that there are still 2 good replicas and 1 corrupt replica (corrupt replica should not be removed since number of good replicas (2) is less than replication factor (3)) Set the replication factor to 2  Verify that the corrupt replica is removed.  (corrupt replica  should not be removed since number of good replicas (2) is equal to replication factor (2))
 */
@Test public void testWhenDecreasingReplication() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,1000L);
  conf.set(DFSConfigKeys.DFS_NAMENODE_RECONSTRUCTION_PENDING_TIMEOUT_SEC_KEY,Integer.toString(2));
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  FileSystem fs=cluster.getFileSystem();
  final FSNamesystem namesystem=cluster.getNamesystem();
  try {
    final Path fileName=new Path("/foo1");
    DFSTestUtil.createFile(fs,fileName,2,(short)3,0L);
    DFSTestUtil.waitReplication(fs,fileName,(short)3);
    ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,fileName);
    corruptBlock(cluster,fs,fileName,0,block);
    DFSTestUtil.waitReplication(fs,fileName,(short)2);
    assertEquals(2,countReplicas(namesystem,block).liveReplicas());
    assertEquals(1,countReplicas(namesystem,block).corruptReplicas());
    namesystem.setReplication(fileName.toString(),(short)2);
    try {
      Thread.sleep(3000);
    }
 catch (    InterruptedException ignored) {
    }
    assertEquals(2,countReplicas(namesystem,block).liveReplicas());
    assertEquals(0,countReplicas(namesystem,block).corruptReplicas());
  }
  finally {
    cluster.shutdown();
  }
}
