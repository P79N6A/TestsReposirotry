@Test(timeout=30000) public void testRemoveVolumes() throws IOException {
  final int NUM_BLOCKS=100;
  for (int i=0; i < NUM_BLOCKS; i++) {
    String bpid=BLOCK_POOL_IDS[NUM_BLOCKS % BLOCK_POOL_IDS.length];
    ExtendedBlock eb=new ExtendedBlock(bpid,i);
    try (ReplicaHandler replica=dataset.createRbw(StorageType.DEFAULT,null,eb,false)){
    }
   }
  final String[] dataDirs=conf.get(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY).split(",");
  final String volumePathToRemove=dataDirs[0];
  Set<StorageLocation> volumesToRemove=new HashSet<>();
  volumesToRemove.add(StorageLocation.parse(volumePathToRemove));
  FsVolumeReferences volReferences=dataset.getFsVolumeReferences();
  FsVolumeImpl volumeToRemove=null;
  for (  FsVolumeSpi vol : volReferences) {
    if (vol.getStorageLocation().equals(volumesToRemove.iterator().next())) {
      volumeToRemove=(FsVolumeImpl)vol;
    }
  }
  assertTrue(volumeToRemove != null);
  volReferences.close();
  dataset.removeVolumes(volumesToRemove,true);
  int expectedNumVolumes=dataDirs.length - 1;
  assertEquals("The volume has been removed from the volumeList.",expectedNumVolumes,getNumVolumes());
  assertEquals("The volume has been removed from the storageMap.",expectedNumVolumes,dataset.storageMap.size());
  try {
    dataset.asyncDiskService.execute(volumeToRemove,new Runnable(){
      @Override public void run(){
      }
    }
);
    fail("Expect RuntimeException: the volume has been removed from the " + "AsyncDiskService.");
  }
 catch (  RuntimeException e) {
    GenericTestUtils.assertExceptionContains("Cannot find volume",e);
  }
  int totalNumReplicas=0;
  for (  String bpid : dataset.volumeMap.getBlockPoolList()) {
    totalNumReplicas+=dataset.volumeMap.size(bpid);
  }
  assertEquals("The replica infos on this volume has been removed from the " + "volumeMap.",NUM_BLOCKS / NUM_INIT_VOLUMES,totalNumReplicas);
}
