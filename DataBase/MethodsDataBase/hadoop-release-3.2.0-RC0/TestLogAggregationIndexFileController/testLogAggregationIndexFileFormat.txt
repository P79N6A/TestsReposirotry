@Test(timeout=15000) public void testLogAggregationIndexFileFormat() throws Exception {
  if (fs.exists(rootLocalLogDirPath)) {
    fs.delete(rootLocalLogDirPath,true);
  }
  assertTrue(fs.mkdirs(rootLocalLogDirPath));
  Path appLogsDir=new Path(rootLocalLogDirPath,appId.toString());
  if (fs.exists(appLogsDir)) {
    fs.delete(appLogsDir,true);
  }
  assertTrue(fs.mkdirs(appLogsDir));
  List<String> logTypes=new ArrayList<String>();
  logTypes.add("syslog");
  logTypes.add("stdout");
  logTypes.add("stderr");
  Set<File> files=new HashSet<>();
  LogKey key1=new LogKey(containerId.toString());
  for (  String logType : logTypes) {
    File file=createAndWriteLocalLogFile(containerId,appLogsDir,logType);
    files.add(file);
  }
  LogValue value=mock(LogValue.class);
  when(value.getPendingLogFilesToUploadForThisContainer()).thenReturn(files);
  final ControlledClock clock=new ControlledClock();
  clock.setTime(System.currentTimeMillis());
  LogAggregationIndexedFileController fileFormat=new LogAggregationIndexedFileController(){
    private int rollOverCheck=0;
    @Override public Clock getSystemClock(){
      return clock;
    }
    @Override public boolean isRollover(    final FileContext fc,    final Path candidate) throws IOException {
      rollOverCheck++;
      if (rollOverCheck >= 3) {
        return true;
      }
      return false;
    }
  }
;
  fileFormat.initialize(conf,"Indexed");
  Map<ApplicationAccessType,String> appAcls=new HashMap<>();
  Path appDir=fileFormat.getRemoteAppLogDir(appId,USER_UGI.getShortUserName());
  if (fs.exists(appDir)) {
    fs.delete(appDir,true);
  }
  assertTrue(fs.mkdirs(appDir));
  Path logPath=fileFormat.getRemoteNodeLogFileForApp(appId,USER_UGI.getShortUserName(),nodeId);
  LogAggregationFileControllerContext context=new LogAggregationFileControllerContext(logPath,logPath,true,1000,appId,appAcls,nodeId,USER_UGI);
  fileFormat.initializeWriter(context);
  fileFormat.write(key1,value);
  fileFormat.postWrite(context);
  fileFormat.closeWriter();
  ContainerLogsRequest logRequest=new ContainerLogsRequest();
  logRequest.setAppId(appId);
  logRequest.setNodeId(nodeId.toString());
  logRequest.setAppOwner(USER_UGI.getShortUserName());
  logRequest.setContainerId(containerId.toString());
  logRequest.setBytes(Long.MAX_VALUE);
  List<ContainerLogMeta> meta=fileFormat.readAggregatedLogsMeta(logRequest);
  Assert.assertTrue(meta.size() == 1);
  List<String> fileNames=new ArrayList<>();
  for (  ContainerLogMeta log : meta) {
    Assert.assertTrue(log.getContainerId().equals(containerId.toString()));
    Assert.assertTrue(log.getNodeId().equals(nodeId.toString()));
    Assert.assertTrue(log.getContainerLogMeta().size() == 3);
    for (    ContainerLogFileInfo file : log.getContainerLogMeta()) {
      fileNames.add(file.getFileName());
    }
  }
  fileNames.removeAll(logTypes);
  Assert.assertTrue(fileNames.isEmpty());
  boolean foundLogs=fileFormat.readAggregatedLogs(logRequest,System.out);
  Assert.assertTrue(foundLogs);
  for (  String logType : logTypes) {
    Assert.assertTrue(sysOutStream.toString().contains(logMessage(containerId,logType)));
  }
  sysOutStream.reset();
  Configuration factoryConf=new Configuration(conf);
  factoryConf.set("yarn.log-aggregation.file-formats","Indexed");
  factoryConf.set("yarn.log-aggregation.file-controller.Indexed.class","org.apache.hadoop.yarn.logaggregation.filecontroller.ifile" + ".LogAggregationIndexedFileController");
  LogAggregationFileControllerFactory factory=new LogAggregationFileControllerFactory(factoryConf);
  LogAggregationFileController fileController=factory.getFileControllerForRead(appId,USER_UGI.getShortUserName());
  Assert.assertTrue(fileController instanceof LogAggregationIndexedFileController);
  foundLogs=fileController.readAggregatedLogs(logRequest,System.out);
  Assert.assertTrue(foundLogs);
  for (  String logType : logTypes) {
    Assert.assertTrue(sysOutStream.toString().contains(logMessage(containerId,logType)));
  }
  sysOutStream.reset();
  Path checksumFile=new Path(fileFormat.getRemoteAppLogDir(appId,USER_UGI.getShortUserName()),LogAggregationUtils.getNodeString(nodeId) + LogAggregationIndexedFileController.CHECK_SUM_FILE_SUFFIX);
  FSDataOutputStream fInput=null;
  try {
    String nodeName=logPath.getName() + "_" + clock.getTime();
    fInput=FileSystem.create(fs,checksumFile,LOG_FILE_UMASK);
    fInput.writeInt(nodeName.length());
    fInput.write(nodeName.getBytes(Charset.forName("UTF-8")));
    fInput.writeLong(0);
  }
  finally {
    IOUtils.closeQuietly(fInput);
  }
  meta=fileFormat.readAggregatedLogsMeta(logRequest);
  Assert.assertTrue(meta.size() == 0);
  foundLogs=fileFormat.readAggregatedLogs(logRequest,System.out);
  Assert.assertFalse(foundLogs);
  sysOutStream.reset();
  fs.delete(checksumFile,false);
  Assert.assertFalse(fs.exists(checksumFile));
  List<String> newLogTypes=new ArrayList<>(logTypes);
  files.clear();
  newLogTypes.add("test1");
  files.add(createAndWriteLocalLogFile(containerId,appLogsDir,"test1"));
  newLogTypes.add("test2");
  files.add(createAndWriteLocalLogFile(containerId,appLogsDir,"test2"));
  LogValue value2=mock(LogValue.class);
  when(value2.getPendingLogFilesToUploadForThisContainer()).thenReturn(files);
  fileFormat.initializeWriter(context);
  fileFormat.write(key1,value2);
  fileFormat.closeWriter();
  meta=fileFormat.readAggregatedLogsMeta(logRequest);
  Assert.assertEquals(meta.size(),1);
  for (  ContainerLogMeta log : meta) {
    Assert.assertTrue(log.getContainerId().equals(containerId.toString()));
    Assert.assertTrue(log.getNodeId().equals(nodeId.toString()));
    Assert.assertTrue(log.getContainerLogMeta().size() == 3);
    for (    ContainerLogFileInfo file : log.getContainerLogMeta()) {
      fileNames.add(file.getFileName());
    }
  }
  fileNames.removeAll(logTypes);
  Assert.assertTrue(fileNames.isEmpty());
  foundLogs=fileFormat.readAggregatedLogs(logRequest,System.out);
  Assert.assertTrue(foundLogs);
  for (  String logType : logTypes) {
    Assert.assertTrue(sysOutStream.toString().contains(logMessage(containerId,logType)));
  }
  Assert.assertFalse(sysOutStream.toString().contains(logMessage(containerId,"test1")));
  Assert.assertFalse(sysOutStream.toString().contains(logMessage(containerId,"test2")));
  sysOutStream.reset();
  fileFormat.initializeWriter(context);
  fileFormat.write(key1,value2);
  fileFormat.postWrite(context);
  fileFormat.closeWriter();
  meta=fileFormat.readAggregatedLogsMeta(logRequest);
  Assert.assertEquals(meta.size(),2);
  for (  ContainerLogMeta log : meta) {
    Assert.assertTrue(log.getContainerId().equals(containerId.toString()));
    Assert.assertTrue(log.getNodeId().equals(nodeId.toString()));
    for (    ContainerLogFileInfo file : log.getContainerLogMeta()) {
      fileNames.add(file.getFileName());
    }
  }
  fileNames.removeAll(newLogTypes);
  Assert.assertTrue(fileNames.isEmpty());
  foundLogs=fileFormat.readAggregatedLogs(logRequest,System.out);
  Assert.assertTrue(foundLogs);
  for (  String logType : newLogTypes) {
    Assert.assertTrue(sysOutStream.toString().contains(logMessage(containerId,logType)));
  }
  sysOutStream.reset();
  clock.setTime(System.currentTimeMillis());
  fileFormat.initializeWriter(context);
  fileFormat.write(key1,value2);
  fileFormat.postWrite(context);
  fileFormat.closeWriter();
  FileStatus[] status=fs.listStatus(logPath.getParent());
  Assert.assertTrue(status.length == 2);
  meta=fileFormat.readAggregatedLogsMeta(logRequest);
  Assert.assertEquals(meta.size(),3);
  for (  ContainerLogMeta log : meta) {
    Assert.assertTrue(log.getContainerId().equals(containerId.toString()));
    Assert.assertTrue(log.getNodeId().equals(nodeId.toString()));
    for (    ContainerLogFileInfo file : log.getContainerLogMeta()) {
      fileNames.add(file.getFileName());
    }
  }
  fileNames.removeAll(newLogTypes);
  Assert.assertTrue(fileNames.isEmpty());
  foundLogs=fileFormat.readAggregatedLogs(logRequest,System.out);
  Assert.assertTrue(foundLogs);
  for (  String logType : newLogTypes) {
    Assert.assertTrue(sysOutStream.toString().contains(logMessage(containerId,logType)));
  }
  sysOutStream.reset();
}
