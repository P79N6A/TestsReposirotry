/** 
 * Test that time eviction in cache used in  {@link LocalMetadataStore}implementation working properly. The test creates a Ticker instance, which will be used to control the internal clock of the cache to achieve eviction without having to wait for the system clock. The test creates 3 entry: 2nd and 3rd entry will survive the eviction, because it will be created later than the 1st - using the ticker.
 */
@Test public void testCacheTimedEvictionAfterWrite(){
  TestTicker testTicker=new TestTicker();
  final long t0=testTicker.read();
  final long t1=t0 + 100;
  final long t2=t1 + 100;
  final long ttl=t1 + 50;
  Cache<Path,LocalMetadataEntry> cache=CacheBuilder.newBuilder().expireAfterWrite(ttl,TimeUnit.NANOSECONDS).ticker(testTicker).build();
  String p="s3a://fake-bucket-name";
  Path path1=new Path(p + "/dirA/dirB/file1");
  Path path2=new Path(p + "/dirA/dirB/file2");
  Path path3=new Path(p + "/dirA/dirB/file3");
  populateEntry(cache,path1);
  testTicker.set(t1);
  populateEntry(cache,path2);
  populateEntry(cache,path3);
  assertEquals("Cache should contain 3 records before eviction",3,cache.size());
  LocalMetadataEntry pm1=cache.getIfPresent(path1);
  assertNotNull("PathMetadata should not be null before eviction",pm1);
  testTicker.set(t2);
  cache.cleanUp();
  assertEquals("Cache size should be 2 after eviction",2,cache.size());
  pm1=cache.getIfPresent(path1);
  assertNull("PathMetadata should be null after eviction",pm1);
}
