@Test(timeout=30000) public void testCommitOutdatedReservedProposal() throws Exception {
  Configuration disableAsyncConf=new Configuration(conf);
  disableAsyncConf.setBoolean(CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_ENABLE,false);
  final MockRM rm=new MockRM(disableAsyncConf);
  rm.start();
  final MockNM nm1=rm.registerNode("127.0.0.1:1234",9 * GB);
  final MockNM nm2=rm.registerNode("127.0.0.2:2234",9 * GB);
  int waitTime=1000;
  while (waitTime > 0 && ((AbstractYarnScheduler)rm.getRMContext().getScheduler()).getNodeTracker().nodeCount() < 2) {
    waitTime-=10;
    Thread.sleep(10);
  }
  Assert.assertEquals(2,((AbstractYarnScheduler)rm.getRMContext().getScheduler()).getNodeTracker().nodeCount());
  YarnScheduler scheduler=rm.getRMContext().getScheduler();
  final SchedulerNode sn1=((CapacityScheduler)scheduler).getSchedulerNode(nm1.getNodeId());
  final SchedulerNode sn2=((CapacityScheduler)scheduler).getSchedulerNode(nm2.getNodeId());
  RMApp app=rm.submitApp(200,"app","user",null,"default");
  final MockAM am=MockRM.launchAndRegisterAM(app,rm,nm1);
  RMApp app2=rm.submitApp(200,"app","user",null,"default");
  final MockAM am2=MockRM.launchAndRegisterAM(app2,rm,nm1);
  allocateAndLaunchContainers(am,nm1,rm,1,Resources.createResource(5 * GB),0,2);
  allocateAndLaunchContainers(am,nm2,rm,1,Resources.createResource(5 * GB),0,3);
  Assert.assertEquals(3,sn1.getNumContainers());
  Assert.assertEquals(1,sn2.getNumContainers());
  ResourceRequest rr2=ResourceRequest.newInstance(Priority.newInstance(0),"*",Resources.createResource(5 * GB),1);
  am.allocate(Arrays.asList(rr2),null);
  nm1.nodeHeartbeat(true);
  waitTime=1000;
  while (waitTime > 0 && sn1.getReservedContainer() == null) {
    waitTime-=10;
    Thread.sleep(10);
  }
  Assert.assertNotNull(sn1.getReservedContainer());
  final CapacityScheduler cs=(CapacityScheduler)scheduler;
  final CapacityScheduler spyCs=Mockito.spy(cs);
  final AtomicBoolean isFirstReserve=new AtomicBoolean(true);
  final AtomicBoolean isChecked=new AtomicBoolean(false);
  Mockito.doAnswer(new Answer<Object>(){
    public Object answer(    InvocationOnMock invocation) throws Exception {
      ResourceCommitRequest request=(ResourceCommitRequest)invocation.getArguments()[1];
      if (request.getContainersToReserve().size() > 0 && isFirstReserve.compareAndSet(true,false)) {
        RMContainer killableContainer=sn2.getCopiedListOfRunningContainers().get(0);
        cs.completedContainer(killableContainer,ContainerStatus.newInstance(killableContainer.getContainerId(),ContainerState.COMPLETE,"",ContainerExitStatus.KILLED_BY_RESOURCEMANAGER),RMContainerEventType.KILL);
        Assert.assertEquals(0,sn2.getCopiedListOfRunningContainers().size());
        cs.handle(new NodeUpdateSchedulerEvent(sn2.getRMNode()));
        int waitTime=1000;
        while (waitTime > 0 && sn2.getCopiedListOfRunningContainers().size() == 0) {
          waitTime-=10;
          Thread.sleep(10);
        }
        Assert.assertEquals(1,sn2.getCopiedListOfRunningContainers().size());
        Assert.assertNull(sn1.getReservedContainer());
        ResourceRequest rr3=ResourceRequest.newInstance(Priority.newInstance(0),"*",Resources.createResource(5 * GB),1);
        am2.allocate(Arrays.asList(rr3),null);
        cs.handle(new NodeUpdateSchedulerEvent(sn1.getRMNode()));
        waitTime=1000;
        while (waitTime > 0 && sn1.getReservedContainer() == null) {
          waitTime-=10;
          Thread.sleep(10);
        }
        Assert.assertNotNull(sn1.getReservedContainer());
        try {
          cs.tryCommit((Resource)invocation.getArguments()[0],(ResourceCommitRequest)invocation.getArguments()[1],true);
        }
 catch (        Exception e) {
          e.printStackTrace();
          Assert.fail();
        }
        isChecked.set(true);
      }
 else {
        cs.tryCommit((Resource)invocation.getArguments()[0],(ResourceCommitRequest)invocation.getArguments()[1],true);
      }
      return null;
    }
  }
).when(spyCs).tryCommit(Mockito.any(Resource.class),Mockito.any(ResourceCommitRequest.class),Mockito.anyBoolean());
  spyCs.handle(new NodeUpdateSchedulerEvent(sn1.getRMNode()));
  waitTime=1000;
  while (waitTime > 0 && !isChecked.get()) {
    waitTime-=10;
    Thread.sleep(10);
  }
  rm.stop();
}
