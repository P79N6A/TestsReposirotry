/** 
 * Tests expected values for minimum compatible layout version in NameNode features.  TRUNCATE, APPEND_NEW_BLOCK and QUOTA_BY_STORAGE_TYPE are all features that launched in the same release.  TRUNCATE was added first, so we expect all 3 features to have a minimum compatible layout version equal to TRUNCATE's layout version.  All features older than that existed prior to the concept of a minimum compatible layout version, so for each one, the minimum compatible layout version must be equal to itself.
 */
@Test public void testNameNodeFeatureMinimumCompatibleLayoutVersions(){
  int baseLV=NameNodeLayoutVersion.Feature.TRUNCATE.getInfo().getLayoutVersion();
  EnumSet<NameNodeLayoutVersion.Feature> compatibleFeatures=EnumSet.of(NameNodeLayoutVersion.Feature.TRUNCATE,NameNodeLayoutVersion.Feature.APPEND_NEW_BLOCK,NameNodeLayoutVersion.Feature.QUOTA_BY_STORAGE_TYPE,NameNodeLayoutVersion.Feature.ERASURE_CODING,NameNodeLayoutVersion.Feature.EXPANDED_STRING_TABLE);
  for (  LayoutFeature f : compatibleFeatures) {
    assertEquals(String.format("Expected minimum compatible layout version " + "%d for feature %s.",baseLV,f),baseLV,f.getInfo().getMinimumCompatibleLayoutVersion());
  }
  List<LayoutFeature> features=new ArrayList<>();
  features.addAll(EnumSet.allOf(LayoutVersion.Feature.class));
  features.addAll(EnumSet.allOf(NameNodeLayoutVersion.Feature.class));
  for (  LayoutFeature f : features) {
    if (!compatibleFeatures.contains(f)) {
      assertEquals(String.format("Expected feature %s to have minimum " + "compatible layout version set to itself.",f),f.getInfo().getLayoutVersion(),f.getInfo().getMinimumCompatibleLayoutVersion());
    }
  }
}
