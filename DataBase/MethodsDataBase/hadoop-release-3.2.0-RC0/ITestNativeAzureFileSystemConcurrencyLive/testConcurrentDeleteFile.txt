/** 
 * Validate contract for FileSystem.delete when invoked concurrently. One of the threads should successfully delete the file and return true; all other threads should return false.
 */
@Test(timeout=TEST_EXECUTION_TIMEOUT) public void testConcurrentDeleteFile() throws Exception {
  Path testFile=new Path("test.dat");
  fs.create(testFile).close();
  List<DeleteFileTask> tasks=new ArrayList<>(THREAD_COUNT);
  for (int i=0; i < THREAD_COUNT; i++) {
    tasks.add(new DeleteFileTask(fs,testFile));
  }
  ExecutorService es=null;
  try {
    es=Executors.newFixedThreadPool(THREAD_COUNT);
    List<Future<Boolean>> futures=es.invokeAll(tasks);
    int successCount=0;
    for (    Future<Boolean> future : futures) {
      Assert.assertTrue(future.isDone());
      Boolean success=future.get();
      if (success) {
        successCount++;
      }
    }
    Assert.assertEquals("Exactly one delete operation should return true.",1,successCount);
  }
  finally {
    if (es != null) {
      es.shutdownNow();
    }
  }
}
