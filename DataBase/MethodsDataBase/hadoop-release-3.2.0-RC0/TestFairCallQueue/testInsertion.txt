@SuppressWarnings("unchecked") @Test public void testInsertion() throws Exception {
  Configuration conf=new Configuration();
  fcq=Mockito.spy(new FairCallQueue<Schedulable>(3,6,"ns",conf));
  Schedulable p0=mockCall("a",0);
  Schedulable p1=mockCall("b",1);
  Schedulable p2=mockCall("c",2);
  Mockito.reset(fcq);
  fcq.add(p0);
  Mockito.verify(fcq,times(1)).offerQueue(0,p0);
  Mockito.verify(fcq,times(0)).offerQueue(1,p0);
  Mockito.verify(fcq,times(0)).offerQueue(2,p0);
  Mockito.reset(fcq);
  Mockito.reset(fcq);
  fcq.add(p1);
  Mockito.verify(fcq,times(0)).offerQueue(0,p1);
  Mockito.verify(fcq,times(1)).offerQueue(1,p1);
  Mockito.verify(fcq,times(0)).offerQueue(2,p1);
  Mockito.reset(fcq);
  fcq.add(p0);
  Mockito.verify(fcq,times(1)).offerQueue(0,p0);
  Mockito.verify(fcq,times(0)).offerQueue(1,p0);
  Mockito.verify(fcq,times(0)).offerQueue(2,p0);
  Mockito.reset(fcq);
  fcq.add(p0);
  Mockito.verify(fcq,times(1)).offerQueue(0,p0);
  Mockito.verify(fcq,times(1)).offerQueue(1,p0);
  Mockito.verify(fcq,times(0)).offerQueue(2,p0);
  Mockito.reset(fcq);
  fcq.add(p1);
  Mockito.verify(fcq,times(0)).offerQueue(0,p1);
  Mockito.verify(fcq,times(1)).offerQueue(1,p1);
  Mockito.verify(fcq,times(1)).offerQueue(2,p1);
  Mockito.reset(fcq);
  fcq.add(p0);
  Mockito.verify(fcq,times(1)).offerQueue(0,p0);
  Mockito.verify(fcq,times(1)).offerQueue(1,p0);
  Mockito.verify(fcq,times(1)).offerQueue(2,p0);
  Mockito.reset(fcq);
  try {
    fcq.add(p0);
    fail("didn't fail");
  }
 catch (  IllegalStateException ise) {
    checkOverflowException(ise,RpcStatusProto.ERROR);
  }
  Mockito.verify(fcq,times(1)).offerQueue(0,p0);
  Mockito.verify(fcq,times(1)).offerQueue(1,p0);
  Mockito.verify(fcq,times(1)).offerQueue(2,p0);
  Mockito.reset(fcq);
  try {
    fcq.add(p1);
    fail("didn't fail");
  }
 catch (  IllegalStateException ise) {
    checkOverflowException(ise,RpcStatusProto.ERROR);
  }
  Mockito.verify(fcq,times(0)).offerQueue(0,p1);
  Mockito.verify(fcq,times(1)).offerQueue(1,p1);
  Mockito.verify(fcq,times(1)).offerQueue(2,p1);
  Mockito.reset(fcq);
  try {
    fcq.add(p2);
    fail("didn't fail");
  }
 catch (  IllegalStateException ise) {
    checkOverflowException(ise,RpcStatusProto.FATAL);
  }
  Mockito.verify(fcq,times(0)).offerQueue(0,p2);
  Mockito.verify(fcq,times(0)).offerQueue(1,p2);
  Mockito.verify(fcq,times(1)).offerQueue(2,p2);
  Mockito.reset(fcq);
  Exception stopPuts=new RuntimeException();
  Mockito.reset(fcq);
  try {
    doThrow(stopPuts).when(fcq).putQueue(anyInt(),anyObject());
    fcq.put(p0);
    fail("didn't fail");
  }
 catch (  Exception e) {
    assertSame(stopPuts,e);
  }
  Mockito.verify(fcq,times(1)).offerQueue(0,p0);
  Mockito.verify(fcq,times(1)).offerQueue(1,p0);
  Mockito.verify(fcq,times(0)).offerQueue(2,p0);
  Mockito.verify(fcq,times(1)).putQueue(2,p0);
  Mockito.reset(fcq);
  try {
    doThrow(stopPuts).when(fcq).putQueue(anyInt(),anyObject());
    fcq.put(p2);
    fail("didn't fail");
  }
 catch (  Exception e) {
    assertSame(stopPuts,e);
  }
  Mockito.verify(fcq,times(0)).offerQueue(0,p2);
  Mockito.verify(fcq,times(0)).offerQueue(1,p2);
  Mockito.verify(fcq,times(0)).offerQueue(2,p2);
  Mockito.verify(fcq,times(1)).putQueue(2,p2);
}
