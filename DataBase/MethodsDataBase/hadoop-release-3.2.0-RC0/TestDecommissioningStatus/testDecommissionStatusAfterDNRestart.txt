/** 
 * Verify a DN remains in DECOMMISSION_INPROGRESS state if it is marked as dead before decommission has completed. That will allow DN to resume the replication process after it rejoins the cluster.
 */
@Test(timeout=120000) public void testDecommissionStatusAfterDNRestart() throws Exception {
  DistributedFileSystem fileSys=(DistributedFileSystem)cluster.getFileSystem();
  Path f=new Path("decommission.dat");
  DFSTestUtil.createFile(fileSys,f,fileSize,fileSize,fileSize,(short)1,seed);
  RemoteIterator<LocatedFileStatus> fileList=fileSys.listLocatedStatus(f);
  BlockLocation[] blockLocations=fileList.next().getBlockLocations();
  String dnName=blockLocations[0].getNames()[0];
  FSNamesystem fsn=cluster.getNamesystem();
  final DatanodeManager dm=fsn.getBlockManager().getDatanodeManager();
  decommissionNode(dnName);
  dm.refreshNodes(conf);
  DataNodeProperties dataNodeProperties=cluster.stopDataNode(dnName);
  final List<DatanodeDescriptor> dead=new ArrayList<DatanodeDescriptor>();
  while (true) {
    dm.fetchDatanodes(null,dead,false);
    if (dead.size() == 1) {
      break;
    }
    Thread.sleep(1000);
  }
  BlockManagerTestUtil.checkHeartbeat(fsn.getBlockManager());
  BlockManagerTestUtil.recheckDecommissionState(dm);
  assertTrue("the node should be DECOMMISSION_IN_PROGRESSS",dead.get(0).isDecommissionInProgress());
  List<DatanodeDescriptor> decomlist=dm.getDecommissioningNodes();
  assertTrue("The node should be be decommissioning",decomlist.size() == 1);
  AdminStatesBaseTest.cleanupFile(fileSys,f);
  BlockManagerTestUtil.recheckDecommissionState(dm);
  assertTrue("the node should be decommissioned",dead.get(0).isDecommissioned());
  cluster.restartDataNode(dataNodeProperties,true);
  cluster.waitActive();
  hostsFileWriter.initExcludeHost("");
  dm.refreshNodes(conf);
}
