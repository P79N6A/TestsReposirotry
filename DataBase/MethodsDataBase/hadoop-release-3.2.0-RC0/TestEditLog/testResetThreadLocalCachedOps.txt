/** 
 * Edit log op instances are cached internally using thread-local storage. This test checks that the cached instances are reset in between different transactions processed on the same thread, so that we don't accidentally apply incorrect attributes to an inode.
 * @throws IOException if there is an I/O error
 */
@Test public void testResetThreadLocalCachedOps() throws IOException {
  Configuration conf=new HdfsConfiguration();
  conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_ACLS_ENABLED_KEY,true);
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_HANDLER_COUNT_KEY,1);
  MiniDFSCluster cluster=null;
  FileSystem fileSys=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fileSys=cluster.getFileSystem();
    Path dir1=new Path("/dir1");
    fileSys.mkdirs(dir1);
    List<AclEntry> aclSpec=Lists.newArrayList(aclEntry(DEFAULT,USER,"foo",READ_EXECUTE));
    fileSys.modifyAclEntries(dir1,aclSpec);
    Path dir2=new Path("/dir1/dir2");
    fileSys.mkdirs(dir2);
    Path file1=new Path("/dir1/file1");
    fileSys.create(file1).close();
    Path dir3=new Path("/dir3");
    fileSys.mkdirs(dir3);
    Path file2=new Path("/file2");
    fileSys.create(file2).close();
    IOUtils.cleanupWithLogger(LOG,fileSys);
    cluster.restartNameNode();
    fileSys=cluster.getFileSystem();
    assertFalse(fileSys.getAclStatus(dir1).getEntries().isEmpty());
    assertFalse(fileSys.getAclStatus(dir2).getEntries().isEmpty());
    assertFalse(fileSys.getAclStatus(file1).getEntries().isEmpty());
    assertTrue(fileSys.getAclStatus(dir3).getEntries().isEmpty());
    assertTrue(fileSys.getAclStatus(file2).getEntries().isEmpty());
  }
  finally {
    IOUtils.cleanupWithLogger(LOG,fileSys);
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}
