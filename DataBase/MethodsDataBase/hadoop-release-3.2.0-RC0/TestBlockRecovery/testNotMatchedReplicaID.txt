/** 
 * BlockRecoveryFI_11. a replica's recovery id does not match new GS.
 * @throws IOException in case of an error
 */
@Test(timeout=60000) public void testNotMatchedReplicaID() throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug("Running " + GenericTestUtils.getMethodName());
  }
  ReplicaInPipeline replicaInfo=dn.data.createRbw(StorageType.DEFAULT,null,block,false).getReplica();
  ReplicaOutputStreams streams=null;
  try {
    streams=replicaInfo.createStreams(true,DataChecksum.newDataChecksum(DataChecksum.Type.CRC32,512));
    streams.getChecksumOut().write('a');
    dn.data.initReplicaRecovery(new RecoveringBlock(block,null,RECOVERY_ID + 1));
    BlockRecoveryWorker.RecoveryTaskContiguous RecoveryTaskContiguous=recoveryWorker.new RecoveryTaskContiguous(rBlock);
    try {
      RecoveryTaskContiguous.syncBlock(initBlockRecords(dn));
      fail("Sync should fail");
    }
 catch (    IOException e) {
      e.getMessage().startsWith("Cannot recover ");
    }
    DatanodeProtocol namenode=recoveryWorker.getActiveNamenodeForBP(POOL_ID);
    verify(namenode,never()).commitBlockSynchronization(any(ExtendedBlock.class),anyLong(),anyLong(),anyBoolean(),anyBoolean(),any(DatanodeID[].class),any(String[].class));
  }
  finally {
    streams.close();
  }
}
