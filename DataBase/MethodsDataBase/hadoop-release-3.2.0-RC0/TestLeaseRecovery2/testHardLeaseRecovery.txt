/** 
 * This test makes the client does not renew its lease and also set the hard lease expiration period to be short 1s. Thus triggering lease expiration to happen while the client is still alive. The test makes sure that the lease recovery completes and the client fails if it continues to write to the file.
 * @throws Exception
 */
@Test public void testHardLeaseRecovery() throws Exception {
  String filestr="/hardLeaseRecovery";
  AppendTestUtil.LOG.info("filestr=" + filestr);
  Path filepath=new Path(filestr);
  FSDataOutputStream stm=dfs.create(filepath,true,BUF_SIZE,REPLICATION_NUM,BLOCK_SIZE);
  assertTrue(dfs.dfs.exists(filestr));
  int size=AppendTestUtil.nextInt(FILE_SIZE);
  AppendTestUtil.LOG.info("size=" + size);
  stm.write(buffer,0,size);
  AppendTestUtil.LOG.info("hflush");
  stm.hflush();
  AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
  dfs.dfs.getLeaseRenewer().interruptAndJoin();
  cluster.setLeasePeriod(LONG_LEASE_PERIOD,SHORT_LEASE_PERIOD);
  LocatedBlocks locatedBlocks;
  do {
    Thread.sleep(SHORT_LEASE_PERIOD);
    locatedBlocks=dfs.dfs.getLocatedBlocks(filestr,0L,size);
  }
 while (locatedBlocks.isUnderConstruction());
  assertEquals(size,locatedBlocks.getFileLength());
  try {
    stm.write('b');
    stm.close();
    fail("Writer thread should have been killed");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  AppendTestUtil.LOG.info("File size is good. Now validating sizes from datanodes...");
  AppendTestUtil.checkFullFile(dfs,filepath,size,buffer,filestr);
}
