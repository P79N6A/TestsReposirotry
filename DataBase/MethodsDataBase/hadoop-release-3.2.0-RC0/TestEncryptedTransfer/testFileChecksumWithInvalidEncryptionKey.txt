@Test public void testFileChecksumWithInvalidEncryptionKey() throws IOException, InterruptedException, TimeoutException {
  if (resolverClazz != null) {
    return;
  }
  setEncryptionConfigKeys();
  cluster=new MiniDFSCluster.Builder(conf).build();
  fs=getFileSystem(conf);
  DFSClient client=DFSClientAdapter.getDFSClient((DistributedFileSystem)fs);
  DFSClient spyClient=Mockito.spy(client);
  DFSClientAdapter.setDFSClient((DistributedFileSystem)fs,spyClient);
  writeTestDataToFile(fs);
  FileChecksum checksum=fs.getFileChecksum(TEST_PATH);
  BlockTokenSecretManager btsm=cluster.getNamesystem().getBlockManager().getBlockTokenSecretManager();
  btsm.setKeyUpdateIntervalForTesting(2 * 1000);
  btsm.setTokenLifetime(2 * 1000);
  btsm.clearAllKeysForTesting();
  LOG.info("Wait until encryption keys become invalid...");
  DataEncryptionKey encryptionKey=spyClient.getEncryptionKey();
  List<DataNode> dataNodes=cluster.getDataNodes();
  for (  DataNode dn : dataNodes) {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return !dn.getBlockPoolTokenSecretManager().get(encryptionKey.blockPoolId).hasKey(encryptionKey.keyId);
      }
    }
,100,30 * 1000);
  }
  LOG.info("The encryption key is invalid on all nodes now.");
  fs.getFileChecksum(TEST_PATH);
  Assert.assertTrue(client.getEncryptionKey() == null);
  Mockito.verify(spyClient,times(1)).clearDataEncryptionKey();
  FileChecksum verifyChecksum=fs.getFileChecksum(TEST_PATH);
  Assert.assertEquals(checksum,verifyChecksum);
}
