/** 
 * Test dividing a byte range into aligned stripes and verify the aligned ranges can be translated back to the byte range.
 */
@Test public void testDivideByteRangeIntoStripes(){
  ByteBuffer assembled=ByteBuffer.allocate(stripesPerBlock * stripeSize);
  for (  int bgSize : blockGroupSizes) {
    LocatedStripedBlock blockGroup=createDummyLocatedBlock(bgSize);
    byte[][] internalBlkBufs=createInternalBlkBuffers(bgSize);
    for (    int brStart : byteRangeStartOffsets) {
      for (      int brSize : byteRangeSizes) {
        if (brStart + brSize > bgSize) {
          continue;
        }
        AlignedStripe[] stripes=divideByteRangeIntoStripes(ecPolicy,cellSize,blockGroup,brStart,brStart + brSize - 1,assembled);
        for (        AlignedStripe stripe : stripes) {
          for (int i=0; i < dataBlocks; i++) {
            StripingChunk chunk=stripe.chunks[i];
            if (chunk == null || chunk.state != StripingChunk.REQUESTED) {
              continue;
            }
            int done=0;
            int len;
            for (            ByteBuffer slice : chunk.getChunkBuffer().getSlices()) {
              len=slice.remaining();
              slice.put(internalBlkBufs[i],(int)stripe.getOffsetInBlock() + done,len);
              done+=len;
            }
          }
        }
        for (int i=0; i < brSize; i++) {
          if (hashIntToByte(brStart + i) != assembled.get(i)) {
            System.out.println("Oops");
          }
          assertEquals("Byte at " + (brStart + i) + " should be the same",hashIntToByte(brStart + i),assembled.get(i));
        }
      }
    }
  }
}
