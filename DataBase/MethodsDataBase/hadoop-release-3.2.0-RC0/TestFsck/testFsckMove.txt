@Test public void testFsckMove() throws Exception {
  final int dfsBlockSize=1024;
  final int numDatanodes=4;
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,dfsBlockSize);
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
  conf.setInt(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY,1);
  DFSTestUtil util=new DFSTestUtil("TestFsck",5,3,(5 * dfsBlockSize) + (dfsBlockSize - 1),5 * dfsBlockSize);
  FileSystem fs=null;
  File builderBaseDir=new File(GenericTestUtils.getRandomizedTempPath());
  cluster=new MiniDFSCluster.Builder(conf,builderBaseDir).numDataNodes(numDatanodes).build();
  String topDir="/srcdat";
  fs=cluster.getFileSystem();
  cluster.waitActive();
  util.createFiles(fs,topDir);
  util.waitReplication(fs,topDir,(short)3);
  String outStr=runFsck(conf,0,true,"/");
  assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
  DFSClient dfsClient=new DFSClient(new InetSocketAddress("localhost",cluster.getNameNodePort()),conf);
  String[] fileNames=util.getFileNames(topDir);
  CorruptedTestFile[] ctFiles=new CorruptedTestFile[]{new CorruptedTestFile(fileNames[0],Sets.newHashSet(0),dfsClient,numDatanodes,dfsBlockSize),new CorruptedTestFile(fileNames[1],Sets.newHashSet(2,3),dfsClient,numDatanodes,dfsBlockSize),new CorruptedTestFile(fileNames[2],Sets.newHashSet(4),dfsClient,numDatanodes,dfsBlockSize),new CorruptedTestFile(fileNames[3],Sets.newHashSet(0,1,2,3),dfsClient,numDatanodes,dfsBlockSize),new CorruptedTestFile(fileNames[4],Sets.newHashSet(1,2,3,4),dfsClient,numDatanodes,dfsBlockSize)};
  int totalMissingBlocks=0;
  for (  CorruptedTestFile ctFile : ctFiles) {
    totalMissingBlocks+=ctFile.getTotalMissingBlocks();
  }
  for (  CorruptedTestFile ctFile : ctFiles) {
    ctFile.removeBlocks(cluster);
  }
  while (true) {
    outStr=runFsck(conf,1,false,"/");
    String numMissing=null;
    String numCorrupt=null;
    for (    String line : outStr.split(LINE_SEPARATOR)) {
      Matcher m=NUM_MISSING_BLOCKS_PATTERN.matcher(line);
      if (m.matches()) {
        numMissing=m.group(1);
      }
      m=NUM_CORRUPT_BLOCKS_PATTERN.matcher(line);
      if (m.matches()) {
        numCorrupt=m.group(1);
      }
      if (numMissing != null && numCorrupt != null) {
        break;
      }
    }
    if (numMissing == null || numCorrupt == null) {
      throw new IOException("failed to find number of missing or corrupt" + " blocks in fsck output.");
    }
    if (numMissing.equals(Integer.toString(totalMissingBlocks))) {
      assertTrue(numCorrupt.equals(Integer.toString(0)));
      assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
      break;
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException ignore) {
    }
  }
  outStr=runFsck(conf,1,false,"/","-move");
  LOG.info("WATERMELON: outStr = " + outStr);
  assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
  for (  CorruptedTestFile ctFile : ctFiles) {
    ctFile.checkSalvagedRemains();
  }
  outStr=runFsck(conf,1,true,"/","-delete");
  assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
  outStr=runFsck(conf,0,true,"/");
  assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
  util.cleanup(fs,topDir);
}
