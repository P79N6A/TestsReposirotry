/** 
 * Test for the following case proposed by ATM: 1. Both NNs are up, one is active. There are 100 blocks. Both are out of safemode. 2. 10 block deletions get processed by NN1. NN2 enqueues these DN messages until it next reads from a checkpointed edits file. 3. NN2 gets restarted. Its queues are lost. 4. NN2 comes up, reads from all the finalized edits files. Concludes there should still be 100 blocks. 5. NN2 receives a block report from all the DNs, which only accounts for 90 blocks. It doesn't leave safemode. 6. NN1 dies or is transitioned to standby. 7. NN2 is transitioned to active. It reads all the edits from NN1. It now knows there should only be 90 blocks, but it's still in safemode. 8. NN2 doesn't ever recheck whether it should leave safemode. This is essentially the inverse of  {@link #testBlocksAddedBeforeStandbyRestart()}
 */
@Test public void testBlocksRemovedBeforeStandbyRestart() throws Exception {
  banner("Starting with NN0 active and NN1 standby, creating some blocks");
  DFSTestUtil.createFile(fs,new Path("/test"),5 * BLOCK_SIZE,(short)3,1L);
  nn0.getRpcServer().rollEditLog();
  banner("Removing the blocks without rolling the edit log");
  fs.delete(new Path("/test"),true);
  BlockManagerTestUtil.computeAllPendingWork(nn0.getNamesystem().getBlockManager());
  cluster.triggerHeartbeats();
  banner("Restarting standby");
  restartStandby();
  assertSafeMode(nn1,0,5,3,0);
  banner("Waiting for standby to catch up to active namespace");
  HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
  assertSafeMode(nn1,0,0,3,0);
}
