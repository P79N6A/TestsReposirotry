/** 
 * Test to make sure the checksum is set correctly after pipeline recovery transfers 0 byte partial block. If fails the test case will say "java.io.IOException: Failed to replace a bad datanode on the existing pipeline due to no more good datanodes being available to try."  This indicates there was a real failure after the staged failure.
 */
@Test public void testZeroByteBlockRecovery() throws Exception {
  DataNodeFaultInjector dnFaultInjector=new DataNodeFaultInjector(){
    int tries=1;
    @Override public void stopSendingPacketDownstream(    final String mirrAddr) throws IOException {
      if (tries > 0) {
        tries--;
        try {
          Thread.sleep(60000);
        }
 catch (        InterruptedException ie) {
          throw new IOException("Interrupted while sleeping. Bailing out.");
        }
      }
    }
  }
;
  DataNodeFaultInjector oldDnInjector=DataNodeFaultInjector.get();
  DataNodeFaultInjector.set(dnFaultInjector);
  Configuration conf=new HdfsConfiguration();
  conf.set(HdfsClientConfigKeys.DFS_CLIENT_SOCKET_TIMEOUT_KEY,"1000");
  conf.set(HdfsClientConfigKeys.BlockWrite.ReplaceDatanodeOnFailure.POLICY_KEY,"ALWAYS");
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
    cluster.waitActive();
    FileSystem fs=cluster.getFileSystem();
    FSDataOutputStream out=fs.create(new Path("noheartbeat.dat"),(short)2);
    out.write(0x31);
    out.hflush();
    out.close();
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
    DataNodeFaultInjector.set(oldDnInjector);
  }
}
