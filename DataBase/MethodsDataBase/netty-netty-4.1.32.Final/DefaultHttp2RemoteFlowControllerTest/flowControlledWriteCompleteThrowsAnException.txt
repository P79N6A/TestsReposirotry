@Test public void flowControlledWriteCompleteThrowsAnException() throws Exception {
  final Http2RemoteFlowController.FlowControlled flowControlled=mock(Http2RemoteFlowController.FlowControlled.class);
  Http2Stream streamA=stream(STREAM_A);
  final AtomicInteger size=new AtomicInteger(150);
  doAnswer(new Answer<Integer>(){
    @Override public Integer answer(    InvocationOnMock invocationOnMock) throws Throwable {
      return size.get();
    }
  }
).when(flowControlled).size();
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocationOnMock) throws Throwable {
      size.addAndGet(-50);
      return null;
    }
  }
).when(flowControlled).write(any(ChannelHandlerContext.class),anyInt());
  final Http2Stream stream=stream(STREAM_A);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocationOnMock){
      throw new RuntimeException("writeComplete failed");
    }
  }
).when(flowControlled).writeComplete();
  int windowBefore=window(STREAM_A);
  controller.addFlowControlled(stream,flowControlled);
  controller.writePendingBytes();
  verify(flowControlled,times(3)).write(any(ChannelHandlerContext.class),anyInt());
  verify(flowControlled,never()).error(any(ChannelHandlerContext.class),any(Throwable.class));
  verify(flowControlled).writeComplete();
  assertEquals(150,windowBefore - window(STREAM_A));
  verify(listener,times(1)).writabilityChanged(streamA);
  verify(listener,never()).writabilityChanged(stream(STREAM_B));
  verify(listener,never()).writabilityChanged(stream(STREAM_C));
  verify(listener,never()).writabilityChanged(stream(STREAM_D));
  assertFalse(controller.isWritable(streamA));
  assertTrue(controller.isWritable(stream(STREAM_B)));
  assertTrue(controller.isWritable(stream(STREAM_C)));
  assertTrue(controller.isWritable(stream(STREAM_D)));
}
