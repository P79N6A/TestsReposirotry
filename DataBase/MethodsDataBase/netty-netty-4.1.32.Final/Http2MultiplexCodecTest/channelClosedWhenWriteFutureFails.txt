@Test public void channelClosedWhenWriteFutureFails(){
  final Queue<ChannelPromise> writePromises=new ArrayDeque<ChannelPromise>();
  writer=new Writer(){
    @Override void write(    Object msg,    ChannelPromise promise){
      ReferenceCountUtil.release(msg);
      writePromises.offer(promise);
    }
  }
;
  LastInboundHandler inboundHandler=streamActiveAndWriteHeaders(inboundStream);
  Http2StreamChannel childChannel=(Http2StreamChannel)inboundHandler.channel();
  assertTrue(childChannel.isOpen());
  assertTrue(childChannel.isActive());
  final AtomicBoolean channelOpen=new AtomicBoolean(true);
  final AtomicBoolean channelActive=new AtomicBoolean(true);
  ChannelFuture f=childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));
  assertFalse(f.isDone());
  f.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    ChannelFuture future) throws Exception {
      channelOpen.set(future.channel().isOpen());
      channelActive.set(future.channel().isActive());
    }
  }
);
  ChannelPromise first=writePromises.poll();
  first.setFailure(new ClosedChannelException());
  f.awaitUninterruptibly();
  assertFalse(channelOpen.get());
  assertFalse(channelActive.get());
  assertFalse(childChannel.isActive());
}
