@Test(timeout=60000) public void testConcurrentUsage() throws Throwable {
  final AtomicBoolean finished=new AtomicBoolean();
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  Thread[] threads=new Thread[50];
  final CyclicBarrier barrier=new CyclicBarrier(threads.length);
  for (int i=0; i < threads.length; i++) {
    Thread t=new Thread(new Runnable(){
      Queue<LeakAwareResource> resources=new ArrayDeque<LeakAwareResource>(100);
      @Override public void run(){
        try {
          barrier.await();
          for (int b=0; b < 1000 && !finished.get(); b++) {
            for (int a=0; a < 100; a++) {
              DefaultResource resource=new DefaultResource();
              ResourceLeakTracker<Resource> leak=DefaultResource.detector.track(resource);
              LeakAwareResource leakAwareResource=new LeakAwareResource(resource,leak);
              resources.add(leakAwareResource);
            }
            if (closeResources(true)) {
              finished.set(true);
            }
          }
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
catch (        Throwable e) {
          error.compareAndSet(null,e);
        }
 finally {
          closeResources(false);
        }
      }
      private boolean closeResources(      boolean checkClosed){
        for (; ; ) {
          LeakAwareResource r=resources.poll();
          if (r == null) {
            return false;
          }
          boolean closed=r.close();
          if (checkClosed && !closed) {
            error.compareAndSet(null,new AssertionError("ResourceLeak.close() returned 'false' but expected 'true'"));
            return true;
          }
        }
      }
    }
);
    threads[i]=t;
    t.start();
  }
  for (  Thread t : threads) {
    t.join();
  }
  DefaultResource.detector.assertNoErrors();
  assertNoErrors(error);
}
