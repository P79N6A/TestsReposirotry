@Test(timeout=30000) public void testCorrectAlert() throws Exception {
  Assume.assumeTrue(OpenSsl.isAvailable());
  SelfSignedCertificate ssc=new SelfSignedCertificate();
  final SslContext sslServerCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(serverProvider).trustManager(new SimpleTrustManagerFactory(){
    @Override protected void engineInit(    KeyStore keyStore){
    }
    @Override protected void engineInit(    ManagerFactoryParameters managerFactoryParameters){
    }
    @Override protected TrustManager[] engineGetTrustManagers(){
      return new TrustManager[]{new X509TrustManager(){
        @Override public void checkClientTrusted(        X509Certificate[] x509Certificates,        String s) throws CertificateException {
          throw exception;
        }
        @Override public void checkServerTrusted(        X509Certificate[] x509Certificates,        String s) throws CertificateException {
        }
        @Override public X509Certificate[] getAcceptedIssuers(){
          return EmptyArrays.EMPTY_X509_CERTIFICATES;
        }
      }
};
    }
  }
).clientAuth(ClientAuth.REQUIRE).build();
  final SslContext sslClientCtx=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).keyManager(new File(getClass().getResource("test.crt").getFile()),new File(getClass().getResource("test_unencrypted.pem").getFile())).sslProvider(clientProvider).build();
  Channel serverChannel=null;
  Channel clientChannel=null;
  EventLoopGroup group=new NioEventLoopGroup();
  try {
    serverChannel=new ServerBootstrap().group(group).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        ch.pipeline().addLast(sslServerCtx.newHandler(ch.alloc()));
        ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
          @Override public void exceptionCaught(          ChannelHandlerContext ctx,          Throwable cause){
            ctx.close();
          }
        }
);
      }
    }
).bind(0).sync().channel();
    final Promise<Void> promise=group.next().newPromise();
    clientChannel=new Bootstrap().group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        ch.pipeline().addLast(sslClientCtx.newHandler(ch.alloc()));
        ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
          @Override public void exceptionCaught(          ChannelHandlerContext ctx,          Throwable cause){
            Throwable unwrappedCause=cause.getCause();
            if (unwrappedCause instanceof SSLException) {
              if (exception instanceof TestCertificateException) {
                CertPathValidatorException.Reason reason=((CertPathValidatorException)exception.getCause()).getReason();
                if (reason == CertPathValidatorException.BasicReason.EXPIRED) {
                  verifyException(unwrappedCause,"expired",promise);
                }
 else                 if (reason == CertPathValidatorException.BasicReason.NOT_YET_VALID) {
                  if (OpenSsl.isBoringSSL()) {
                    verifyException(unwrappedCause,"expired",promise);
                  }
 else {
                    verifyException(unwrappedCause,"bad",promise);
                  }
                }
 else                 if (reason == CertPathValidatorException.BasicReason.REVOKED) {
                  verifyException(unwrappedCause,"revoked",promise);
                }
              }
 else               if (exception instanceof CertificateExpiredException) {
                verifyException(unwrappedCause,"expired",promise);
              }
 else               if (exception instanceof CertificateNotYetValidException) {
                if (OpenSsl.isBoringSSL()) {
                  verifyException(unwrappedCause,"expired",promise);
                }
 else {
                  verifyException(unwrappedCause,"bad",promise);
                }
              }
 else               if (exception instanceof CertificateRevokedException) {
                verifyException(unwrappedCause,"revoked",promise);
              }
            }
          }
        }
);
      }
    }
).connect(serverChannel.localAddress()).syncUninterruptibly().channel();
    promise.syncUninterruptibly();
  }
  finally {
    if (clientChannel != null) {
      clientChannel.close().syncUninterruptibly();
    }
    if (serverChannel != null) {
      serverChannel.close().syncUninterruptibly();
    }
    group.shutdownGracefully();
    ReferenceCountUtil.release(sslServerCtx);
    ReferenceCountUtil.release(sslClientCtx);
  }
}
