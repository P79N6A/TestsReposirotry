@Test(timeout=30000) public void testRetainFromMultipleThreadsThrowsReferenceCountException() throws Exception {
  int threads=4;
  Queue<Future<?>> futures=new ArrayDeque<Future<?>>(threads);
  ExecutorService service=Executors.newFixedThreadPool(threads);
  final AtomicInteger refCountExceptions=new AtomicInteger();
  try {
    for (int i=0; i < 10000; i++) {
      final AbstractReferenceCounted referenceCounted=newReferenceCounted();
      final CountDownLatch retainLatch=new CountDownLatch(1);
      assertTrue(referenceCounted.release());
      for (int a=0; a < threads; a++) {
        final int retainCnt=ThreadLocalRandom.current().nextInt(1,Integer.MAX_VALUE);
        futures.add(service.submit(new Runnable(){
          @Override public void run(){
            try {
              retainLatch.await();
              try {
                referenceCounted.retain(retainCnt);
              }
 catch (              IllegalReferenceCountException e) {
                refCountExceptions.incrementAndGet();
              }
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
));
      }
      retainLatch.countDown();
      for (; ; ) {
        Future<?> f=futures.poll();
        if (f == null) {
          break;
        }
        f.get();
      }
      assertEquals(4,refCountExceptions.get());
      refCountExceptions.set(0);
    }
  }
  finally {
    service.shutdown();
  }
}
