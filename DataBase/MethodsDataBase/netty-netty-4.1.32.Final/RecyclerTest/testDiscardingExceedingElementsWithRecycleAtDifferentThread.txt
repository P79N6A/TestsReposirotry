@Test public void testDiscardingExceedingElementsWithRecycleAtDifferentThread() throws Exception {
  final int maxCapacity=32;
  final AtomicInteger instancesCount=new AtomicInteger(0);
  final Recycler<HandledObject> recycler=new Recycler<HandledObject>(maxCapacity,2){
    @Override protected HandledObject newObject(    Recycler.Handle<HandledObject> handle){
      instancesCount.incrementAndGet();
      return new HandledObject(handle);
    }
  }
;
  final HandledObject[] array=new HandledObject[maxCapacity * 2];
  for (int i=0; i < array.length; i++) {
    array[i]=recycler.get();
  }
  assertEquals(array.length,instancesCount.get());
  instancesCount.set(0);
  final Thread thread=new Thread(){
    @Override public void run(){
      for (      HandledObject object : array) {
        object.recycle();
      }
    }
  }
;
  thread.start();
  thread.join();
  assertEquals(0,instancesCount.get());
  for (int i=0; i < array.length; i++) {
    recycler.get();
  }
  assertTrue("The instances count (" + instancesCount.get() + ") must be <= array.length ("+ array.length+ ") - maxCapacity ("+ maxCapacity+ ") / 2 as we not pool all new handles"+ " internally",array.length - maxCapacity / 2 <= instancesCount.get());
}
