/** 
 * Reproduces the issue #1600
 */
@Test public void testFlushCloseReentrance() throws Exception {
  NioEventLoopGroup group=new NioEventLoopGroup(1);
  try {
    final Queue<ChannelFuture> futures=new LinkedBlockingQueue<ChannelFuture>();
    ServerBootstrap sb=new ServerBootstrap();
    sb.group(group).channel(NioServerSocketChannel.class);
    sb.childOption(ChannelOption.SO_SNDBUF,1024);
    sb.childHandler(new ChannelInboundHandlerAdapter(){
      @Override public void channelActive(      ChannelHandlerContext ctx) throws Exception {
        futures.add(ctx.write(ctx.alloc().buffer().writeZero(1048576)).addListener(ChannelFutureListener.CLOSE));
        futures.add(ctx.write(ctx.alloc().buffer().writeZero(1048576)));
        ctx.flush();
        futures.add(ctx.write(ctx.alloc().buffer().writeZero(1048576)));
        ctx.flush();
      }
    }
);
    SocketAddress address=sb.bind(0).sync().channel().localAddress();
    Socket s=new Socket(NetUtil.LOCALHOST,((InetSocketAddress)address).getPort());
    InputStream in=s.getInputStream();
    byte[] buf=new byte[8192];
    for (; ; ) {
      if (in.read(buf) == -1) {
        break;
      }
      Thread.sleep(10);
    }
    s.close();
    assertThat(futures.size(),is(3));
    ChannelFuture f1=futures.poll();
    ChannelFuture f2=futures.poll();
    ChannelFuture f3=futures.poll();
    assertThat(f1.isSuccess(),is(true));
    assertThat(f2.isDone(),is(true));
    assertThat(f2.isSuccess(),is(false));
    assertThat(f2.cause(),is(instanceOf(ClosedChannelException.class)));
    assertThat(f3.isDone(),is(true));
    assertThat(f3.isSuccess(),is(false));
    assertThat(f3.cause(),is(instanceOf(ClosedChannelException.class)));
  }
  finally {
    group.shutdownGracefully().sync();
  }
}
