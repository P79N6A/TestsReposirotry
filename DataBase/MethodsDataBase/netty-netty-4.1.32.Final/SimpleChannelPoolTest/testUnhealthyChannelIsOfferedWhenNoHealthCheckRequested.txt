/** 
 * Tests that if channel was unhealthy it is was offered back to the pool because it was requested not to validate channel health on release.
 * @throws Exception
 */
@Test public void testUnhealthyChannelIsOfferedWhenNoHealthCheckRequested() throws Exception {
  EventLoopGroup group=new LocalEventLoopGroup();
  LocalAddress addr=new LocalAddress(LOCAL_ADDR_ID);
  Bootstrap cb=new Bootstrap();
  cb.remoteAddress(addr);
  cb.group(group).channel(LocalChannel.class);
  ServerBootstrap sb=new ServerBootstrap();
  sb.group(group).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<LocalChannel>(){
    @Override public void initChannel(    LocalChannel ch) throws Exception {
      ch.pipeline().addLast(new ChannelInboundHandlerAdapter());
    }
  }
);
  Channel sc=sb.bind(addr).syncUninterruptibly().channel();
  ChannelPoolHandler handler=new CountingChannelPoolHandler();
  ChannelPool pool=new SimpleChannelPool(cb,handler,ChannelHealthChecker.ACTIVE,false);
  Channel channel1=pool.acquire().syncUninterruptibly().getNow();
  channel1.close().syncUninterruptibly();
  Future<Void> releaseFuture=pool.release(channel1,channel1.eventLoop().<Void>newPromise()).syncUninterruptibly();
  assertThat(releaseFuture.isSuccess(),CoreMatchers.is(true));
  Channel channel2=pool.acquire().syncUninterruptibly().getNow();
  assertNotSame(channel1,channel2);
  sc.close().syncUninterruptibly();
  channel2.close().syncUninterruptibly();
  group.shutdownGracefully();
}
