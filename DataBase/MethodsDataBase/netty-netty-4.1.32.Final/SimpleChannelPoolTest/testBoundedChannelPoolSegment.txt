@Test public void testBoundedChannelPoolSegment() throws Exception {
  EventLoopGroup group=new LocalEventLoopGroup();
  LocalAddress addr=new LocalAddress(LOCAL_ADDR_ID);
  Bootstrap cb=new Bootstrap();
  cb.remoteAddress(addr);
  cb.group(group).channel(LocalChannel.class);
  ServerBootstrap sb=new ServerBootstrap();
  sb.group(group).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<LocalChannel>(){
    @Override public void initChannel(    LocalChannel ch) throws Exception {
      ch.pipeline().addLast(new ChannelInboundHandlerAdapter());
    }
  }
);
  Channel sc=sb.bind(addr).sync().channel();
  CountingChannelPoolHandler handler=new CountingChannelPoolHandler();
  ChannelPool pool=new SimpleChannelPool(cb,handler,ChannelHealthChecker.ACTIVE){
    private final Queue<Channel> queue=new LinkedBlockingQueue<Channel>(1);
    @Override protected Channel pollChannel(){
      return queue.poll();
    }
    @Override protected boolean offerChannel(    Channel ch){
      return queue.offer(ch);
    }
  }
;
  Channel channel=pool.acquire().sync().getNow();
  Channel channel2=pool.acquire().sync().getNow();
  pool.release(channel).syncUninterruptibly().getNow();
  try {
    pool.release(channel2).syncUninterruptibly();
    fail();
  }
 catch (  IllegalStateException e) {
  }
  channel2.close().sync();
  assertEquals(2,handler.channelCount());
  assertEquals(0,handler.acquiredCount());
  assertEquals(1,handler.releasedCount());
  sc.close().sync();
  channel.close().sync();
  channel2.close().sync();
  group.shutdownGracefully();
}
