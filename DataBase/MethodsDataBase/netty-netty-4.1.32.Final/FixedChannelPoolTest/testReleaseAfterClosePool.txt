@Test public void testReleaseAfterClosePool() throws Exception {
  LocalAddress addr=new LocalAddress(LOCAL_ADDR_ID);
  Bootstrap cb=new Bootstrap();
  cb.remoteAddress(addr);
  cb.group(group).channel(LocalChannel.class);
  ServerBootstrap sb=new ServerBootstrap();
  sb.group(group).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<LocalChannel>(){
    @Override public void initChannel(    LocalChannel ch) throws Exception {
      ch.pipeline().addLast(new ChannelInboundHandlerAdapter());
    }
  }
);
  Channel sc=sb.bind(addr).syncUninterruptibly().channel();
  FixedChannelPool pool=new FixedChannelPool(cb,new TestChannelPoolHandler(),2);
  final Future<Channel> acquire=pool.acquire();
  final Channel channel=acquire.get();
  pool.close();
  group.submit(new Runnable(){
    @Override public void run(){
    }
  }
).syncUninterruptibly();
  try {
    pool.release(channel).syncUninterruptibly();
    fail();
  }
 catch (  IllegalStateException e) {
    assertSame(FixedChannelPool.POOL_CLOSED_ON_RELEASE_EXCEPTION,e);
  }
  channel.closeFuture().syncUninterruptibly();
  assertFalse("Unexpected open channel",channel.isOpen());
  sc.close().syncUninterruptibly();
}
