@Test public void testUsingX509TrustManagerVerifiesHostname() throws Exception {
  SslProvider clientProvider=sslClientProvider();
  if (clientProvider == SslProvider.OPENSSL || clientProvider == SslProvider.OPENSSL_REFCNT) {
    Assume.assumeTrue(OpenSsl.supportsHostnameValidation());
  }
  SelfSignedCertificate cert=new SelfSignedCertificate();
  clientSslCtx=SslContextBuilder.forClient().trustManager(new TrustManagerFactory(new TrustManagerFactorySpi(){
    @Override protected void engineInit(    KeyStore keyStore){
    }
    @Override protected TrustManager[] engineGetTrustManagers(){
      return new TrustManager[]{new X509TrustManager(){
        @Override public void checkClientTrusted(        java.security.cert.X509Certificate[] x509Certificates,        String s){
        }
        @Override public void checkServerTrusted(        java.security.cert.X509Certificate[] x509Certificates,        String s){
        }
        @Override public java.security.cert.X509Certificate[] getAcceptedIssuers(){
          return EmptyArrays.EMPTY_X509_CERTIFICATES;
        }
      }
};
    }
    @Override protected void engineInit(    ManagerFactoryParameters managerFactoryParameters){
    }
  }
,null,TrustManagerFactory.getDefaultAlgorithm()){
  }
).sslProvider(sslClientProvider()).build();
  SSLEngine client=wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT,"netty.io",1234));
  SSLParameters sslParameters=client.getSSLParameters();
  sslParameters.setEndpointIdentificationAlgorithm("HTTPS");
  client.setSSLParameters(sslParameters);
  serverSslCtx=SslContextBuilder.forServer(cert.certificate(),cert.privateKey()).sslProvider(sslServerProvider()).build();
  SSLEngine server=wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
  try {
    handshake(client,server);
    fail();
  }
 catch (  SSLException expected) {
  }
 finally {
    cleanupClientSslEngine(client);
    cleanupServerSslEngine(server);
    cert.delete();
  }
}
