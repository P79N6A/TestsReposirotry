@Test(timeout=30000) public void clientInitiatedRenegotiationWithFatalAlertDoesNotInfiniteLoopServer() throws CertificateException, SSLException, InterruptedException, ExecutionException {
  Assume.assumeTrue(PlatformDependent.javaVersion() >= 11);
  final SelfSignedCertificate ssc=new SelfSignedCertificate();
  serverSslCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(sslServerProvider()).sslContextProvider(serverSslContextProvider()).protocols(protocols()).ciphers(ciphers()).build();
  sb=new ServerBootstrap().group(new NioEventLoopGroup(1)).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch){
      ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(),type));
      ChannelPipeline p=ch.pipeline();
      p.addLast(serverSslCtx.newHandler(ch.alloc()));
      p.addLast(new ChannelInboundHandlerAdapter(){
        @Override public void userEventTriggered(        ChannelHandlerContext ctx,        Object evt){
          if (evt instanceof SslHandshakeCompletionEvent && ((SslHandshakeCompletionEvent)evt).isSuccess()) {
            ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(100));
          }
          ctx.fireUserEventTriggered(evt);
        }
        @Override public void channelRead(        final ChannelHandlerContext ctx,        Object msg){
          ReferenceCountUtil.release(msg);
          ctx.channel().eventLoop().schedule(new Runnable(){
            @Override public void run(){
              ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(101));
            }
          }
,500,TimeUnit.MILLISECONDS);
        }
        @Override public void channelInactive(        ChannelHandlerContext ctx){
          serverLatch.countDown();
        }
      }
);
      serverConnectedChannel=ch;
    }
  }
);
  serverChannel=sb.bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
  clientSslCtx=SslContextBuilder.forClient().sslProvider(SslProvider.JDK).trustManager(InsecureTrustManagerFactory.INSTANCE).protocols(protocols()).ciphers(ciphers()).build();
  cb=new Bootstrap();
  cb.group(new NioEventLoopGroup(1)).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch){
      ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(),type));
      ChannelPipeline p=ch.pipeline();
      SslHandler sslHandler=clientSslCtx.newHandler(ch.alloc());
      sslHandler.setHandshakeTimeout(1,TimeUnit.SECONDS);
      p.addLast(sslHandler);
      p.addLast(new ChannelInboundHandlerAdapter(){
        private int handshakeCount;
        @Override public void userEventTriggered(        ChannelHandlerContext ctx,        Object evt){
          if (evt instanceof SslHandshakeCompletionEvent && ++handshakeCount == 2) {
            ctx.close();
            return;
          }
          ctx.fireUserEventTriggered(evt);
        }
        @Override public void channelRead(        ChannelHandlerContext ctx,        Object msg){
          ReferenceCountUtil.release(msg);
          ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(102));
          ctx.pipeline().get(SslHandler.class).renegotiate();
        }
      }
);
    }
  }
);
  ChannelFuture ccf=cb.connect(serverChannel.localAddress());
  assertTrue(ccf.syncUninterruptibly().isSuccess());
  clientChannel=ccf.channel();
  serverLatch.await();
  ssc.delete();
}
