@Test(timeout=30000) public void testMutualAuthSameCertChain() throws Exception {
  serverSslCtx=SslContextBuilder.forServer(new ByteArrayInputStream(X509_CERT_PEM.getBytes(CharsetUtil.UTF_8)),new ByteArrayInputStream(PRIVATE_KEY_PEM.getBytes(CharsetUtil.UTF_8))).trustManager(new ByteArrayInputStream(X509_CERT_PEM.getBytes(CharsetUtil.UTF_8))).clientAuth(ClientAuth.REQUIRE).sslProvider(sslServerProvider()).sslContextProvider(serverSslContextProvider()).protocols(protocols()).ciphers(ciphers()).build();
  sb=new ServerBootstrap();
  sb.group(new NioEventLoopGroup(),new NioEventLoopGroup());
  sb.channel(NioServerSocketChannel.class);
  final Promise<String> promise=sb.config().group().next().newPromise();
  serverChannel=sb.childHandler(new ChannelInitializer<Channel>(){
    @Override protected void initChannel(    Channel ch) throws Exception {
      ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(),type));
      ch.pipeline().addFirst(serverSslCtx.newHandler(ch.alloc()));
      ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){
        @Override public void userEventTriggered(        ChannelHandlerContext ctx,        Object evt) throws Exception {
          if (evt instanceof SslHandshakeCompletionEvent) {
            Throwable cause=((SslHandshakeCompletionEvent)evt).cause();
            if (cause == null) {
              SSLSession session=((SslHandler)ctx.pipeline().first()).engine().getSession();
              X509Certificate[] peerCertificateChain=session.getPeerCertificateChain();
              Certificate[] peerCertificates=session.getPeerCertificates();
              if (peerCertificateChain == null) {
                promise.setFailure(new NullPointerException("peerCertificateChain"));
              }
 else               if (peerCertificates == null) {
                promise.setFailure(new NullPointerException("peerCertificates"));
              }
 else               if (peerCertificateChain.length + peerCertificates.length != 4) {
                String excTxtFmt="peerCertificateChain.length:%s, peerCertificates.length:%s";
                promise.setFailure(new IllegalStateException(String.format(excTxtFmt,peerCertificateChain.length,peerCertificates.length)));
              }
 else {
                for (int i=0; i < peerCertificateChain.length; i++) {
                  if (peerCertificateChain[i] == null || peerCertificates[i] == null) {
                    promise.setFailure(new IllegalStateException("Certificate in chain is null"));
                    return;
                  }
                }
                promise.setSuccess(null);
              }
            }
 else {
              promise.setFailure(cause);
            }
          }
        }
      }
);
      serverConnectedChannel=ch;
    }
  }
).bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
  clientSslCtx=SslContextBuilder.forClient().keyManager(new ByteArrayInputStream(CLIENT_X509_CERT_CHAIN_PEM.getBytes(CharsetUtil.UTF_8)),new ByteArrayInputStream(CLIENT_PRIVATE_KEY_PEM.getBytes(CharsetUtil.UTF_8))).trustManager(new ByteArrayInputStream(X509_CERT_PEM.getBytes(CharsetUtil.UTF_8))).sslProvider(sslClientProvider()).sslContextProvider(clientSslContextProvider()).protocols(protocols()).ciphers(ciphers()).build();
  cb=new Bootstrap();
  cb.group(new NioEventLoopGroup());
  cb.channel(NioSocketChannel.class);
  clientChannel=cb.handler(new ChannelInitializer<Channel>(){
    @Override protected void initChannel(    Channel ch) throws Exception {
      ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(),type));
      ch.pipeline().addLast(new SslHandler(wrapEngine(clientSslCtx.newEngine(ch.alloc()))));
    }
  }
).connect(serverChannel.localAddress()).syncUninterruptibly().channel();
  promise.syncUninterruptibly();
}
