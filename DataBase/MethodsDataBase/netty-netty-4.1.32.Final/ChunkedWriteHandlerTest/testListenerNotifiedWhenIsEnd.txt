@Test public void testListenerNotifiedWhenIsEnd(){
  ByteBuf buffer=Unpooled.copiedBuffer("Test",CharsetUtil.ISO_8859_1);
  ChunkedInput<ByteBuf> input=new ChunkedInput<ByteBuf>(){
    private boolean done;
    private final ByteBuf buffer=Unpooled.copiedBuffer("Test",CharsetUtil.ISO_8859_1);
    @Override public boolean isEndOfInput() throws Exception {
      return done;
    }
    @Override public void close() throws Exception {
      buffer.release();
    }
    @Deprecated @Override public ByteBuf readChunk(    ChannelHandlerContext ctx) throws Exception {
      return readChunk(ctx.alloc());
    }
    @Override public ByteBuf readChunk(    ByteBufAllocator allocator) throws Exception {
      if (done) {
        return null;
      }
      done=true;
      return buffer.retainedDuplicate();
    }
    @Override public long length(){
      return -1;
    }
    @Override public long progress(){
      return 1;
    }
  }
;
  final AtomicBoolean listenerNotified=new AtomicBoolean(false);
  final ChannelFutureListener listener=new ChannelFutureListener(){
    @Override public void operationComplete(    ChannelFuture future) throws Exception {
      listenerNotified.set(true);
    }
  }
;
  EmbeddedChannel ch=new EmbeddedChannel(new ChunkedWriteHandler());
  ch.writeAndFlush(input).addListener(listener).syncUninterruptibly();
  ch.checkException();
  ch.finish();
  assertTrue(listenerNotified.get());
  ByteBuf buffer2=ch.readOutbound();
  assertEquals(buffer,buffer2);
  assertNull(ch.readOutbound());
  buffer.release();
  buffer2.release();
}
