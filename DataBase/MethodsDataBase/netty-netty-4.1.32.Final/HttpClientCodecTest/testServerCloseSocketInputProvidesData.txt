@Test public void testServerCloseSocketInputProvidesData() throws InterruptedException {
  ServerBootstrap sb=new ServerBootstrap();
  Bootstrap cb=new Bootstrap();
  final CountDownLatch serverChannelLatch=new CountDownLatch(1);
  final CountDownLatch responseReceivedLatch=new CountDownLatch(1);
  try {
    sb.group(new NioEventLoopGroup(2));
    sb.channel(NioServerSocketChannel.class);
    sb.childHandler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        ch.pipeline().addLast(new HttpRequestDecoder(4096,8192,8192,true));
        ch.pipeline().addLast(new HttpObjectAggregator(4096));
        ch.pipeline().addLast(new SimpleChannelInboundHandler<FullHttpRequest>(){
          @Override protected void channelRead0(          ChannelHandlerContext ctx,          FullHttpRequest msg){
            assertTrue(ctx.channel() instanceof SocketChannel);
            final SocketChannel sChannel=(SocketChannel)ctx.channel();
            sChannel.writeAndFlush(Unpooled.wrappedBuffer(("HTTP/1.0 200 OK\r\n" + "Date: Fri, 31 Dec 1999 23:59:59 GMT\r\n" + "Content-Type: text/html\r\n\r\n").getBytes(CharsetUtil.ISO_8859_1))).addListener(new ChannelFutureListener(){
              @Override public void operationComplete(              ChannelFuture future) throws Exception {
                assertTrue(future.isSuccess());
                sChannel.writeAndFlush(Unpooled.wrappedBuffer("<html><body>hello half closed!</body></html>\r\n".getBytes(CharsetUtil.ISO_8859_1))).addListener(new ChannelFutureListener(){
                  @Override public void operationComplete(                  ChannelFuture future) throws Exception {
                    assertTrue(future.isSuccess());
                    sChannel.shutdownOutput();
                  }
                }
);
              }
            }
);
          }
        }
);
        serverChannelLatch.countDown();
      }
    }
);
    cb.group(new NioEventLoopGroup(1));
    cb.channel(NioSocketChannel.class);
    cb.option(ChannelOption.ALLOW_HALF_CLOSURE,true);
    cb.handler(new ChannelInitializer<Channel>(){
      @Override protected void initChannel(      Channel ch) throws Exception {
        ch.pipeline().addLast(new HttpClientCodec(4096,8192,8192,true,true));
        ch.pipeline().addLast(new HttpObjectAggregator(4096));
        ch.pipeline().addLast(new SimpleChannelInboundHandler<FullHttpResponse>(){
          @Override protected void channelRead0(          ChannelHandlerContext ctx,          FullHttpResponse msg){
            responseReceivedLatch.countDown();
          }
        }
);
      }
    }
);
    Channel serverChannel=sb.bind(new InetSocketAddress(0)).sync().channel();
    int port=((InetSocketAddress)serverChannel.localAddress()).getPort();
    ChannelFuture ccf=cb.connect(new InetSocketAddress(NetUtil.LOCALHOST,port));
    assertTrue(ccf.awaitUninterruptibly().isSuccess());
    Channel clientChannel=ccf.channel();
    assertTrue(serverChannelLatch.await(5,SECONDS));
    clientChannel.writeAndFlush(new DefaultHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.GET,"/"));
    assertTrue(responseReceivedLatch.await(5,SECONDS));
  }
  finally {
    sb.config().group().shutdownGracefully();
    sb.config().childGroup().shutdownGracefully();
    cb.config().group().shutdownGracefully();
  }
}
