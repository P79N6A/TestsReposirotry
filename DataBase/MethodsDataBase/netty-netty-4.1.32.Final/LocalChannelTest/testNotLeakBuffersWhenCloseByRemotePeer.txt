@Test public void testNotLeakBuffersWhenCloseByRemotePeer() throws Exception {
  Bootstrap cb=new Bootstrap();
  ServerBootstrap sb=new ServerBootstrap();
  cb.group(sharedGroup).channel(LocalChannel.class).handler(new SimpleChannelInboundHandler<ByteBuf>(){
    @Override public void channelActive(    final ChannelHandlerContext ctx) throws Exception {
      ctx.writeAndFlush(ctx.alloc().buffer().writeZero(100));
    }
    @Override public void channelRead0(    ChannelHandlerContext ctx,    ByteBuf buffer) throws Exception {
    }
  }
);
  sb.group(sharedGroup).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<LocalChannel>(){
    @Override public void initChannel(    LocalChannel ch) throws Exception {
      ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>(){
        @Override public void channelRead0(        ChannelHandlerContext ctx,        ByteBuf buffer) throws Exception {
          while (buffer.isReadable()) {
            ctx.write(buffer.readRetainedSlice(1));
          }
          ctx.flush();
          ctx.close();
        }
      }
);
    }
  }
);
  Channel sc=null;
  LocalChannel cc=null;
  try {
    sc=sb.bind(TEST_ADDRESS).sync().channel();
    cc=(LocalChannel)cb.connect(sc.localAddress()).sync().channel();
    closeChannel(cc);
    assertTrue(cc.inboundBuffer.isEmpty());
    closeChannel(sc);
  }
  finally {
    closeChannel(cc);
    closeChannel(sc);
  }
}
