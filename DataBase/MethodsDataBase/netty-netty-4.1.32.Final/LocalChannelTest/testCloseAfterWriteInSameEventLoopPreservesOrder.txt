@Test public void testCloseAfterWriteInSameEventLoopPreservesOrder() throws InterruptedException {
  Bootstrap cb=new Bootstrap();
  ServerBootstrap sb=new ServerBootstrap();
  final CountDownLatch messageLatch=new CountDownLatch(3);
  final ByteBuf data=Unpooled.wrappedBuffer(new byte[1024]);
  try {
    cb.group(sharedGroup).channel(LocalChannel.class).handler(new ChannelInboundHandlerAdapter(){
      @Override public void channelActive(      ChannelHandlerContext ctx) throws Exception {
        ctx.writeAndFlush(data.retainedDuplicate());
      }
      @Override public void channelRead(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        if (data.equals(msg)) {
          ReferenceCountUtil.safeRelease(msg);
          messageLatch.countDown();
        }
 else {
          super.channelRead(ctx,msg);
        }
      }
    }
);
    sb.group(sharedGroup).channel(LocalServerChannel.class).childHandler(new ChannelInboundHandlerAdapter(){
      @Override public void channelRead(      ChannelHandlerContext ctx,      Object msg) throws Exception {
        if (data.equals(msg)) {
          messageLatch.countDown();
          ctx.writeAndFlush(data);
          ctx.close();
        }
 else {
          super.channelRead(ctx,msg);
        }
      }
      @Override public void channelInactive(      ChannelHandlerContext ctx) throws Exception {
        messageLatch.countDown();
        super.channelInactive(ctx);
      }
    }
);
    Channel sc=null;
    Channel cc=null;
    try {
      sc=sb.bind(TEST_ADDRESS).syncUninterruptibly().channel();
      cc=cb.connect(sc.localAddress()).syncUninterruptibly().channel();
      assertTrue(messageLatch.await(5,SECONDS));
      assertFalse(cc.isOpen());
    }
  finally {
      closeChannel(cc);
      closeChannel(sc);
    }
  }
  finally {
    data.release();
  }
}
