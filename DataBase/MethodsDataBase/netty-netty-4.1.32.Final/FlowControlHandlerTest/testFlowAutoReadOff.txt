/** 
 * The  {@link FlowControlHandler} will pass down messages one by oneif auto reading is off and the user is calling  {@code read()} ontheir own.
 */
@Test public void testFlowAutoReadOff() throws Exception {
  final Exchanger<Channel> peerRef=new Exchanger<Channel>();
  final CountDownLatch msgRcvLatch1=new CountDownLatch(1);
  final CountDownLatch msgRcvLatch2=new CountDownLatch(2);
  final CountDownLatch msgRcvLatch3=new CountDownLatch(3);
  ChannelInboundHandlerAdapter handler=new ChannelDuplexHandler(){
    @Override public void channelActive(    ChannelHandlerContext ctx) throws Exception {
      ctx.fireChannelActive();
      peerRef.exchange(ctx.channel(),1L,SECONDS);
    }
    @Override public void channelRead(    ChannelHandlerContext ctx,    Object msg){
      msgRcvLatch1.countDown();
      msgRcvLatch2.countDown();
      msgRcvLatch3.countDown();
    }
  }
;
  FlowControlHandler flow=new FlowControlHandler();
  Channel server=newServer(false,flow,handler);
  Channel client=newClient(server.localAddress());
  try {
    Channel peer=peerRef.exchange(null,1L,SECONDS);
    client.writeAndFlush(newOneMessage()).syncUninterruptibly();
    peer.read();
    assertTrue(msgRcvLatch1.await(1L,SECONDS));
    peer.read();
    assertTrue(msgRcvLatch2.await(1L,SECONDS));
    peer.read();
    assertTrue(msgRcvLatch3.await(1L,SECONDS));
    assertTrue(flow.isQueueEmpty());
  }
  finally {
    client.close();
    server.close();
  }
}
