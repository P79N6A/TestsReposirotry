@Test public void testSrcsLenOverFlowCorrectlyHandled() throws Exception {
  clientSslCtx=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).sslProvider(sslClientProvider()).protocols(protocols()).ciphers(ciphers()).build();
  SelfSignedCertificate ssc=new SelfSignedCertificate();
  serverSslCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(sslServerProvider()).protocols(protocols()).ciphers(ciphers()).build();
  SSLEngine clientEngine=null;
  SSLEngine serverEngine=null;
  try {
    clientEngine=wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
    serverEngine=wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
    handshake(clientEngine,serverEngine);
    ByteBuffer src=allocateBuffer(1024);
    List<ByteBuffer> srcList=new ArrayList<ByteBuffer>();
    long srcsLen=0;
    long maxLen=((long)MAX_VALUE) * 2;
    while (srcsLen < maxLen) {
      ByteBuffer dup=src.duplicate();
      srcList.add(dup);
      srcsLen+=dup.capacity();
    }
    ByteBuffer[] srcs=srcList.toArray(new ByteBuffer[0]);
    ByteBuffer dst=allocateBuffer(unwrapEngine(clientEngine).maxEncryptedPacketLength() - 1);
    SSLEngineResult result=clientEngine.wrap(srcs,dst);
    assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW,result.getStatus());
    for (    ByteBuffer buffer : srcs) {
      assertEquals(0,buffer.position());
    }
    assertEquals(0,dst.position());
    assertEquals(0,result.bytesConsumed());
    assertEquals(0,result.bytesProduced());
  }
  finally {
    cleanupClientSslEngine(clientEngine);
    cleanupServerSslEngine(serverEngine);
  }
}
