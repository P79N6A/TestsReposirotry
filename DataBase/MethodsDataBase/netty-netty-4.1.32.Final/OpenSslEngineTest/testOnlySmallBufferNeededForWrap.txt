@Test public void testOnlySmallBufferNeededForWrap() throws Exception {
  clientSslCtx=SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).sslProvider(sslClientProvider()).protocols(protocols()).ciphers(ciphers()).build();
  SelfSignedCertificate ssc=new SelfSignedCertificate();
  serverSslCtx=SslContextBuilder.forServer(ssc.certificate(),ssc.privateKey()).sslProvider(sslServerProvider()).protocols(protocols()).ciphers(ciphers()).build();
  SSLEngine clientEngine=null;
  SSLEngine serverEngine=null;
  try {
    clientEngine=wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
    serverEngine=wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
    handshake(clientEngine,serverEngine);
    int srcLen=1024;
    ByteBuffer src=allocateBuffer(srcLen);
    ByteBuffer dstTooSmall=allocateBuffer(src.capacity() + unwrapEngine(clientEngine).maxWrapOverhead() - 1);
    ByteBuffer dst=allocateBuffer(src.capacity() + unwrapEngine(clientEngine).maxWrapOverhead());
    SSLEngineResult result=clientEngine.wrap(src,dstTooSmall);
    assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW,result.getStatus());
    assertEquals(0,result.bytesConsumed());
    assertEquals(0,result.bytesProduced());
    assertEquals(src.remaining(),src.capacity());
    assertEquals(dst.remaining(),dst.capacity());
    result=clientEngine.wrap(src,dst);
    assertEquals(SSLEngineResult.Status.OK,result.getStatus());
    assertEquals(srcLen,result.bytesConsumed());
    assertEquals(0,src.remaining());
    assertTrue(result.bytesProduced() > srcLen);
    assertEquals(src.capacity() - result.bytesConsumed(),src.remaining());
    assertEquals(dst.capacity() - result.bytesProduced(),dst.remaining());
  }
  finally {
    cleanupClientSslEngine(clientEngine);
    cleanupServerSslEngine(serverEngine);
  }
}
