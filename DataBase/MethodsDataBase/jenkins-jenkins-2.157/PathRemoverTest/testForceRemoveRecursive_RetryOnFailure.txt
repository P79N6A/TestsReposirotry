@Test public void testForceRemoveRecursive_RetryOnFailure() throws Exception {
  assumeTrue(Functions.isWindows());
  File dir=tmp.newFolder();
  File d1=new File(dir,"d1");
  File d2=new File(dir,"d2");
  File f1=new File(dir,"f1");
  File d1f1=new File(d1,"d1f1");
  File d2f2=new File(d2,"d1f2");
  mkdirs(d1,d2);
  touchWithFileName(f1,d1f1,d2f2);
  locker.acquireLock(d2f2);
  CountDownLatch unlockLatch=new CountDownLatch(1);
  CountDownLatch deleteLatch=new CountDownLatch(1);
  AtomicBoolean lockedFileExists=new AtomicBoolean();
  Thread thread=new Thread(() -> {
    try {
      unlockLatch.await();
      locker.releaseLock(d2f2);
      deleteLatch.countDown();
    }
 catch (    Exception ignored) {
    }
  }
);
  thread.start();
  PathRemover remover=PathRemover.newRemoverWithStrategy(retriesAttempted -> {
    if (retriesAttempted == 0) {
      lockedFileExists.set(d2f2.exists());
      unlockLatch.countDown();
      try {
        deleteLatch.await();
        return true;
      }
 catch (      InterruptedException e) {
        return false;
      }
    }
    return false;
  }
);
  remover.forceRemoveRecursive(dir.toPath());
  thread.join();
  assertTrue(lockedFileExists.get());
  assertFalse(dir.exists());
}
