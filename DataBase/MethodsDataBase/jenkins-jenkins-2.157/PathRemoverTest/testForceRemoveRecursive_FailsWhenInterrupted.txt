@Test public void testForceRemoveRecursive_FailsWhenInterrupted() throws Exception {
  assumeTrue(Functions.isWindows());
  File dir=tmp.newFolder();
  File d1=new File(dir,"d1");
  File d2=new File(dir,"d2");
  File f1=new File(dir,"f1");
  File d1f1=new File(d1,"d1f1");
  File d2f2=new File(d2,"d1f2");
  mkdirs(d1,d2);
  touchWithFileName(f1,d1f1,d2f2);
  locker.acquireLock(d1f1);
  AtomicReference<InterruptedException> interrupted=new AtomicReference<>();
  AtomicReference<IOException> removed=new AtomicReference<>();
  PathRemover remover=PathRemover.newRemoverWithStrategy(retriesAttempted -> {
    try {
      TimeUnit.SECONDS.sleep(retriesAttempted + 1);
      return true;
    }
 catch (    InterruptedException e) {
      interrupted.set(e);
      return false;
    }
  }
);
  Thread thread=new Thread(() -> {
    try {
      remover.forceRemoveRecursive(dir.toPath());
    }
 catch (    IOException e) {
      removed.set(e);
    }
  }
);
  thread.start();
  TimeUnit.MILLISECONDS.sleep(100);
  thread.interrupt();
  thread.join();
  assertFalse(thread.isAlive());
  assertTrue(d1f1.exists());
  IOException ioException=removed.get();
  assertNotNull(ioException);
  assertThat(ioException.getMessage(),containsString(dir.getPath()));
  assertNotNull(interrupted.get());
}
