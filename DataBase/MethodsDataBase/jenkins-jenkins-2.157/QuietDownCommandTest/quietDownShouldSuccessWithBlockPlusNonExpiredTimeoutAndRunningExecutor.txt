@Test public void quietDownShouldSuccessWithBlockPlusNonExpiredTimeoutAndRunningExecutor() throws Exception {
  final int TIMEOUT=5000;
  final FreeStyleProject project=j.createFreeStyleProject("aProject");
  final ExecutorService threadPool=Executors.newSingleThreadExecutor();
  final OneShotEvent beforeCli=new OneShotEvent();
  final OneShotEvent finish=new OneShotEvent();
  final Future<FreeStyleBuild> build=OnlineNodeCommandTest.startBlockingAndFinishingBuild(project,finish);
  assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
  boolean timeoutOccurred=false;
  final FutureTask exec_task=new FutureTask(new Callable(){
    public Object call(){
      assertJenkinsNotInQuietMode();
      beforeCli.signal();
      final CLICommandInvoker.Result result=command.authorizedTo(Jenkins.READ,Jenkins.ADMINISTER).invokeWithArgs("-block","-timeout",Integer.toString(2 * TIMEOUT));
      fail("Blocking call shouldn't finish, should be killed by called thread!");
      return null;
    }
  }
);
  threadPool.submit(exec_task);
  beforeCli.block();
  assertJenkinsInQuietMode();
  final boolean timeout_occured=false;
  try {
    exec_task.get(TIMEOUT,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
    timeoutOccurred=true;
  }
  if (!timeoutOccurred)   fail("Missing timeout for CLI call");
  finish.signal();
  build.get();
  assertThat(((FreeStyleProject)j.jenkins.getItem("aProject")).getBuilds(),hasSize(1));
  assertThat(project.isBuilding(),equalTo(false));
  j.assertBuildStatusSuccess(build);
  assertJenkinsInQuietMode();
}
