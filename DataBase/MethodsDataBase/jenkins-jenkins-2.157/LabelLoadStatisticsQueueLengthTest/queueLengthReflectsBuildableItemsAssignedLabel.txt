/** 
 * Verify that when a  {@link Label} is assigned to a queued build using a{@link LabelAssignmentAction}, that label's {@link LoadStatistics#queueLength} reflects the number of items in thequeue, and continues to do so if the  {@link Project}'s label is changed.
 */
@Test public void queueLengthReflectsBuildableItemsAssignedLabel() throws Exception {
  final Label label=Label.get(LABEL_STRING);
  final Label altLabel=Label.get(ALT_LABEL_STRING);
  FreeStyleProject project=createTestProject();
  assertTrue("Initially the rolling queue length for the label is 0.",label.loadStatistics.queueLength.getLatest(TimeScale.SEC10) == 0f);
  for (int i=0; i < 3; i++) {
    project.scheduleBuild(0,CAUSE,new LabelAssignmentActionImpl(),new ParametersAction(new StringParameterValue(PARAMETER_NAME,String.valueOf(i))));
  }
  assertEquals("The job is queued as often as it was scheduled.",3,j.getInstance().getQueue().getItems(project).size());
  maintainQueueAndForceRunOfLoadStatisticsUpdater(project);
  assertEquals("The job is still queued as often as it was scheduled.",3,j.getInstance().getQueue().getItems(project).size());
  float labelQueueLength=label.loadStatistics.queueLength.getLatest(TimeScale.SEC10);
  assertThat("After LoadStatisticsUpdater runs, the queue length load statistic for the label is greater than 0.",labelQueueLength,greaterThan(0f));
  project.setAssignedLabel(altLabel);
  maintainQueueAndForceRunOfLoadStatisticsUpdater(project);
  float labelQueueLengthNew=label.loadStatistics.queueLength.getLatest(TimeScale.SEC10);
  assertThat("After assigning an alternate label to the job, the queue length load statistic for the " + "queued builds should not decrease.",labelQueueLengthNew,greaterThan(labelQueueLength));
}
