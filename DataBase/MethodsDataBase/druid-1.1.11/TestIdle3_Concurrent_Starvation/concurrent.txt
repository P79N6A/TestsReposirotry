private void concurrent(final int threadCount) throws Exception {
  Thread[] threads=new Thread[threadCount];
  final CountDownLatch startLatch=new CountDownLatch(1);
  final CountDownLatch endLatch=new CountDownLatch(threadCount);
  final AtomicInteger pass=new AtomicInteger();
  final CyclicBarrier closedBarrier=new CyclicBarrier(threadCount,new Runnable(){
    public void run(){
      Assert.assertEquals(threadCount,dataSource.getPoolingCount());
      dataSource.shrink(false);
      Assert.assertEquals(0,dataSource.getActiveCount());
      Assert.assertEquals(dataSource.getMinIdle(),dataSource.getPoolingCount());
      if (pass.getAndIncrement() % 100 == 0) {
        System.out.println("pass : " + pass.get());
      }
    }
  }
);
  final CyclicBarrier closeBarrier=new CyclicBarrier(threadCount,new Runnable(){
    public void run(){
      Assert.assertEquals(threadCount,dataSource.getActiveCount());
    }
  }
);
  for (int i=0; i < threadCount; ++i) {
    threads[i]=new Thread("thread-" + i){
      public void run(){
        try {
          startLatch.await();
          for (int i=0; i < 1000 * 1; ++i) {
            Connection conn=dataSource.getConnection();
            closeBarrier.await();
            PreparedStatement stmt=conn.prepareStatement("SELECT 1");
            ResultSet rs=stmt.executeQuery();
            rs.next();
            rs.close();
            stmt.close();
            conn.close();
            closedBarrier.await();
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
 finally {
          endLatch.countDown();
        }
      }
    }
;
  }
  startLatch.countDown();
  for (int i=0; i < threadCount; ++i) {
    threads[i].start();
  }
  endLatch.await();
}
