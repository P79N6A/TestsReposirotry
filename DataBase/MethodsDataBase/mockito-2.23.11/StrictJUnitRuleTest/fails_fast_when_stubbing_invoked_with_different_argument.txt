@Test public void fails_fast_when_stubbing_invoked_with_different_argument() throws Throwable {
  rule.expectFailure(new SafeJUnitRule.FailureAssert(){
    public void doAssert(    Throwable t){
      Assertions.assertThat(t).isInstanceOf(PotentialStubbingProblem.class);
      assertEquals(filterLineNo("\n" + "Strict stubbing argument mismatch. Please check:\n" + " - this invocation of 'simpleMethod' method:\n"+ "    mock.simpleMethod(15);\n"+ "    -> at org.mockitousage.strictness.ProductionCode.simpleMethod(ProductionCode.java:0)\n"+ " - has following stubbing(s) with different arguments:\n"+ "    1. mock.simpleMethod(20);\n"+ "      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n"+ "    2. mock.simpleMethod(30);\n"+ "      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n"+ "Typically, stubbing argument mismatch indicates user mistake when writing tests.\n"+ "Mockito fails early so that you can debug potential problem easily.\n"+ "However, there are legit scenarios when this exception generates false negative signal:\n"+ "  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n"+ "    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n"+ "  - stubbed method is intentionally invoked with different arguments by code under test\n"+ "    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).\n"+ "For more information see javadoc for PotentialStubbingProblem class."),filterLineNo(t.getMessage()));
    }
  }
);
  willReturn("10").given(mock).simpleMethod(10);
  willReturn("20").given(mock).simpleMethod(20);
  willReturn("30").given(mock).simpleMethod(30);
  mock.otherMethod();
  mock.simpleMethod(10);
  ProductionCode.simpleMethod(mock,15);
}
