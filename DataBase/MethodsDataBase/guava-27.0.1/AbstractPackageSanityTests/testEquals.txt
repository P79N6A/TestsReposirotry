/** 
 * Tests  {@code equals()} and {@code hashCode()} implementations for every top-level class in thepackage, that explicitly implements  {@link Object#equals}. For a class  {@code C}: <ul> <li>The visible constructor or visible static factory method with the most parameters is used to construct the sample instances. In case of tie, the candidate constructors or factories are tried one after another until one can be used to construct sample instances. <li>For the constructor or static factory method used to construct instances, it's checked that when equal parameters are passed, the result instance should also be equal; and vice versa. <li>Inequality check is not performed against state mutation methods such as  {@link List#add}, or functional update methods such as  {@link com.google.common.base.Joiner#skipNulls}. <li>If the constructor or factory method used to construct instance takes a parameter that {@link AbstractPackageSanityTests} doesn't know how to construct, the test will fail.<li>If there is no visible constructor or visible static factory method declared by  {@code C},  {@code C} is skipped for equality test.<li>Equality test is not performed on method return values unless the method is a visible static factory method whose return type is  {@code C} or {@code C}'s subtype. </ul> <p>In all cases, if  {@code C} needs custom logic for testing {@code equals()}, you can add an explicit  {@code testEquals()} test in the corresponding {@code CTest} class, and {@code C} willbe excluded from the automated  {@code equals} test performed by this method.
 */
@Test public void testEquals() throws Exception {
  for (  Class<?> classToTest : findClassesToTest(loadClassesInPackage(),EQUALS_TEST_METHOD_NAMES)) {
    if (!classToTest.isEnum() && isEqualsDefined(classToTest)) {
      try {
        tester.doTestEquals(classToTest);
      }
 catch (      Throwable e) {
        throw sanityError(classToTest,EQUALS_TEST_METHOD_NAMES,"equals test",e);
      }
    }
  }
}
