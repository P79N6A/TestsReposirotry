/** 
 * Test a java.lang.Error being thrown
 * @throws InterruptedException
 */
@Test public void testErrorThrownViaObserve() throws InterruptedException {
  TestCircuitBreaker circuitBreaker=new TestCircuitBreaker();
  CommandWithErrorThrown command=new CommandWithErrorThrown(circuitBreaker,true);
  final AtomicReference<Throwable> t=new AtomicReference<Throwable>();
  final CountDownLatch latch=new CountDownLatch(1);
  try {
    command.observe().subscribe(new Observer<Boolean>(){
      @Override public void onCompleted(){
        latch.countDown();
      }
      @Override public void onError(      Throwable e){
        t.set(e);
        latch.countDown();
      }
      @Override public void onNext(      Boolean args){
      }
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("we should not get anything thrown, it should be emitted via the Observer#onError method");
  }
  latch.await(1,TimeUnit.SECONDS);
  assertNotNull(t.get());
  t.get().printStackTrace();
  assertTrue(t.get() instanceof HystrixRuntimeException);
  assertEquals("simulated java.lang.Error message",t.get().getCause().getCause().getMessage());
  assertEquals("simulated java.lang.Error message",command.getFailedExecutionException().getCause().getMessage());
  assertTrue(command.getExecutionTimeInMilliseconds() > -1);
  assertTrue(command.isFailedExecution());
  assertCommandExecutionEvents(command,HystrixEventType.FAILURE,HystrixEventType.FALLBACK_MISSING);
  assertNotNull(command.getExecutionException());
  assertEquals(0,circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
  assertFalse(command.isExecutedInThread());
  assertSaneHystrixRequestLog(1);
}
