@Test public void testRejectedViaThreadIsolation() throws InterruptedException {
  final TestCircuitBreaker circuitBreaker=new TestCircuitBreaker();
  final ArrayBlockingQueue<Boolean> results=new ArrayBlockingQueue<Boolean>(10);
  final List<Thread> executionThreads=Collections.synchronizedList(new ArrayList<Thread>(20));
  final List<Thread> responseThreads=Collections.synchronizedList(new ArrayList<Thread>(10));
  final AtomicBoolean exceptionReceived=new AtomicBoolean();
  final CountDownLatch scheduleLatch=new CountDownLatch(2);
  final CountDownLatch successLatch=new CountDownLatch(1);
  final AtomicInteger count=new AtomicInteger();
  final AtomicReference<TestThreadIsolationWithSemaphoreSetSmallCommand> command1Ref=new AtomicReference<TestThreadIsolationWithSemaphoreSetSmallCommand>();
  final AtomicReference<TestThreadIsolationWithSemaphoreSetSmallCommand> command2Ref=new AtomicReference<TestThreadIsolationWithSemaphoreSetSmallCommand>();
  final AtomicReference<TestThreadIsolationWithSemaphoreSetSmallCommand> command3Ref=new AtomicReference<TestThreadIsolationWithSemaphoreSetSmallCommand>();
  Runnable r1=new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(),new Runnable(){
    @Override public void run(){
      final boolean shouldExecute=count.incrementAndGet() < 3;
      try {
        executionThreads.add(Thread.currentThread());
        TestThreadIsolationWithSemaphoreSetSmallCommand command1=new TestThreadIsolationWithSemaphoreSetSmallCommand(circuitBreaker,2,new Action0(){
          @Override public void call(){
            if (shouldExecute) {
              try {
                scheduleLatch.countDown();
                successLatch.await();
              }
 catch (              InterruptedException e) {
              }
            }
          }
        }
);
        command1Ref.set(command1);
        results.add(command1.toObservable().map(new Func1<Boolean,Boolean>(){
          @Override public Boolean call(          Boolean b){
            responseThreads.add(Thread.currentThread());
            return b;
          }
        }
).doAfterTerminate(new Action0(){
          @Override public void call(){
            if (!shouldExecute) {
              successLatch.countDown();
            }
          }
        }
).toBlocking().single());
      }
 catch (      Exception e) {
        e.printStackTrace();
        exceptionReceived.set(true);
      }
    }
  }
);
  Runnable r2=new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(),new Runnable(){
    @Override public void run(){
      final boolean shouldExecute=count.incrementAndGet() < 3;
      try {
        executionThreads.add(Thread.currentThread());
        TestThreadIsolationWithSemaphoreSetSmallCommand command2=new TestThreadIsolationWithSemaphoreSetSmallCommand(circuitBreaker,2,new Action0(){
          @Override public void call(){
            if (shouldExecute) {
              try {
                scheduleLatch.countDown();
                successLatch.await();
              }
 catch (              InterruptedException e) {
              }
            }
          }
        }
);
        command2Ref.set(command2);
        results.add(command2.toObservable().map(new Func1<Boolean,Boolean>(){
          @Override public Boolean call(          Boolean b){
            responseThreads.add(Thread.currentThread());
            return b;
          }
        }
).doAfterTerminate(new Action0(){
          @Override public void call(){
            if (!shouldExecute) {
              successLatch.countDown();
            }
          }
        }
).toBlocking().single());
      }
 catch (      Exception e) {
        e.printStackTrace();
        exceptionReceived.set(true);
      }
    }
  }
);
  Runnable r3=new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(),new Runnable(){
    @Override public void run(){
      final boolean shouldExecute=count.incrementAndGet() < 3;
      try {
        executionThreads.add(Thread.currentThread());
        TestThreadIsolationWithSemaphoreSetSmallCommand command3=new TestThreadIsolationWithSemaphoreSetSmallCommand(circuitBreaker,2,new Action0(){
          @Override public void call(){
            if (shouldExecute) {
              try {
                scheduleLatch.countDown();
                successLatch.await();
              }
 catch (              InterruptedException e) {
              }
            }
          }
        }
);
        command3Ref.set(command3);
        results.add(command3.toObservable().map(new Func1<Boolean,Boolean>(){
          @Override public Boolean call(          Boolean b){
            responseThreads.add(Thread.currentThread());
            return b;
          }
        }
).doAfterTerminate(new Action0(){
          @Override public void call(){
            if (!shouldExecute) {
              successLatch.countDown();
            }
          }
        }
).toBlocking().single());
      }
 catch (      Exception e) {
        e.printStackTrace();
        exceptionReceived.set(true);
      }
    }
  }
);
  Thread t1=new Thread(r1);
  Thread t2=new Thread(r2);
  Thread t3=new Thread(r3);
  t1.start();
  t2.start();
  scheduleLatch.await(500,TimeUnit.MILLISECONDS);
  t3.start();
  try {
    t1.join();
    t2.join();
    t3.join();
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("failed waiting on threads");
  }
  assertEquals(2,results.size());
  assertTrue(exceptionReceived.get());
  assertCommandExecutionEvents(command1Ref.get(),HystrixEventType.EMIT,HystrixEventType.SUCCESS);
  assertCommandExecutionEvents(command2Ref.get(),HystrixEventType.EMIT,HystrixEventType.SUCCESS);
  assertCommandExecutionEvents(command3Ref.get(),HystrixEventType.THREAD_POOL_REJECTED,HystrixEventType.FALLBACK_MISSING);
  assertEquals(0,circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
  assertSaneHystrixRequestLog(3);
}
