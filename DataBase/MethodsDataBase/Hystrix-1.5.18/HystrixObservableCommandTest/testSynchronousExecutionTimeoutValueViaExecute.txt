/** 
 * Test that we can still use thread isolation if desired.
 */
@Test public void testSynchronousExecutionTimeoutValueViaExecute(){
  HystrixObservableCommand.Setter properties=HystrixObservableCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("TestKey")).andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD).withExecutionTimeoutInMilliseconds(50));
  System.out.println(">>>>> Begin: " + System.currentTimeMillis());
  HystrixObservableCommand<String> command=new HystrixObservableCommand<String>(properties){
    @Override protected Observable<String> construct(){
      return Observable.create(new OnSubscribe<String>(){
        @Override public void call(        Subscriber<? super String> t1){
          try {
            Thread.sleep(2000);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
          t1.onNext("hello");
          t1.onCompleted();
        }
      }
);
    }
    @Override protected Observable<String> resumeWithFallback(){
      if (isResponseTimedOut()) {
        return Observable.just("timed-out");
      }
 else {
        return Observable.just("abc");
      }
    }
  }
;
  System.out.println(">>>>> Start: " + System.currentTimeMillis());
  String value=command.observe().toBlocking().single();
  System.out.println(">>>>> End: " + System.currentTimeMillis());
  assertTrue(command.isResponseTimedOut());
  assertEquals("expected fallback value","timed-out",value);
  assertTrue(command.isExecutedInThread());
  assertNotNull(command.getExecutionException());
  assertEquals(0,command.metrics.getCurrentConcurrentExecutionCount());
  assertEquals(1,HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
}
