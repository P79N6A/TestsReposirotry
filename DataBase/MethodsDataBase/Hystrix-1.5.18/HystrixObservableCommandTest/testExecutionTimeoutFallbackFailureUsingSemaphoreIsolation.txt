/** 
 * Test a command execution timeout where the command implemented getFallback but it fails.
 */
@Test public void testExecutionTimeoutFallbackFailureUsingSemaphoreIsolation(){
  TestHystrixObservableCommand<Integer> command=getCommand(ExecutionIsolationStrategy.SEMAPHORE,AbstractTestHystrixCommand.ExecutionResult.SUCCESS,500,AbstractTestHystrixCommand.FallbackResult.FAILURE,200);
  try {
    command.observe().toBlocking().single();
    fail("we shouldn't get here");
  }
 catch (  Exception e) {
    if (e instanceof HystrixRuntimeException) {
      e.printStackTrace();
      HystrixRuntimeException de=(HystrixRuntimeException)e;
      assertNotNull(de.getFallbackException());
      assertFalse(de.getFallbackException() instanceof UnsupportedOperationException);
      assertNotNull(de.getImplementingClass());
      assertNotNull(de.getCause());
      assertTrue(de.getCause() instanceof TimeoutException);
      assertNotNull(command.getExecutionException());
    }
 else {
      fail("the exception should be HystrixRuntimeException");
    }
  }
  assertTrue("Execution Time is: " + command.getExecutionTimeInMilliseconds(),command.getExecutionTimeInMilliseconds() >= 200);
  assertCommandExecutionEvents(command,HystrixEventType.TIMEOUT,HystrixEventType.FALLBACK_FAILURE);
  assertEquals(0,command.metrics.getCurrentConcurrentExecutionCount());
  assertSaneHystrixRequestLog(1);
  assertFalse(command.isExecutedInThread());
}
