/** 
 * See https://github.com/Netflix/Hystrix/issues/212
 */
@Test public void testObservableTimeoutFallbackThreadContext(){
  TestSubscriber<Object> ts=new TestSubscriber<Object>();
  final AtomicReference<Thread> onErrorThread=new AtomicReference<Thread>();
  final AtomicBoolean isRequestContextInitialized=new AtomicBoolean();
  TestHystrixObservableCommand<Integer> command=getCommand(ExecutionIsolationStrategy.SEMAPHORE,AbstractTestHystrixCommand.ExecutionResult.SUCCESS,200,AbstractTestHystrixCommand.FallbackResult.SUCCESS,100);
  command.toObservable().doOnNext(new Action1<Object>(){
    @Override public void call(    Object t1){
      System.out.println("onNext: " + t1);
      System.out.println("onNext Thread: " + Thread.currentThread());
      System.out.println("ThreadContext in onNext: " + HystrixRequestContext.isCurrentThreadInitialized());
      onErrorThread.set(Thread.currentThread());
      isRequestContextInitialized.set(HystrixRequestContext.isCurrentThreadInitialized());
    }
  }
).subscribe(ts);
  ts.awaitTerminalEvent();
  System.out.println("events: " + ts.getOnNextEvents());
  assertTrue(isRequestContextInitialized.get());
  assertTrue(onErrorThread.get().getName().startsWith("HystrixTimer"));
  List<Object> onNexts=ts.getOnNextEvents();
  assertEquals(1,onNexts.size());
  assertTrue(command.getExecutionTimeInMilliseconds() > -1);
  assertTrue(command.isResponseTimedOut());
  assertNotNull(command.getExecutionException());
  assertCommandExecutionEvents(command,HystrixEventType.TIMEOUT,HystrixEventType.FALLBACK_EMIT,HystrixEventType.FALLBACK_SUCCESS);
  assertEquals(0,command.metrics.getCurrentConcurrentExecutionCount());
  assertSaneHystrixRequestLog(1);
  assertFalse(command.isExecutedInThread());
}
