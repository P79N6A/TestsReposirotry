@Test public void testAsyncExecutionTimeoutValueViaObserve(){
  HystrixObservableCommand.Setter properties=HystrixObservableCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("TestKey")).andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(50));
  HystrixObservableCommand<String> command=new HystrixObservableCommand<String>(properties){
    @Override protected Observable<String> construct(){
      return Observable.create(new OnSubscribe<String>(){
        @Override public void call(        Subscriber<? super String> t1){
          try {
            Thread.sleep(2000);
          }
 catch (          InterruptedException e) {
            System.out.println("********** interrupted on timeout");
            e.printStackTrace();
          }
          t1.onNext("hello");
          t1.onCompleted();
        }
      }
).subscribeOn(Schedulers.newThread());
    }
    @Override protected Observable<String> resumeWithFallback(){
      if (isResponseTimedOut()) {
        return Observable.just("timed-out");
      }
 else {
        return Observable.just("abc");
      }
    }
  }
;
  String value=command.observe().toBlocking().last();
  assertTrue(command.isResponseTimedOut());
  assertEquals("expected fallback value","timed-out",value);
  assertFalse(command.isExecutedInThread());
  assertNotNull(command.getExecutionException());
  assertEquals(0,command.metrics.getCurrentConcurrentExecutionCount());
  assertEquals(1,HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
}
