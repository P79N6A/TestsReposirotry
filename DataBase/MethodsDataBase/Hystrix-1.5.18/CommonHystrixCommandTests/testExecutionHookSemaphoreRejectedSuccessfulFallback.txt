/** 
 * Short-circuit? : NO Thread/semaphore: SEMAPHORE Semaphore Permit reached? : YES Fallback: SUCCESS
 */
@Test public void testExecutionHookSemaphoreRejectedSuccessfulFallback(){
  assertHooksOnSuccess(new Func0<C>(){
    @Override public C call(){
      AbstractCommand.TryableSemaphore semaphore=new AbstractCommand.TryableSemaphoreActual(HystrixProperty.Factory.asProperty(2));
      final C cmd1=getLatentCommand(ExecutionIsolationStrategy.SEMAPHORE,ExecutionResult.SUCCESS,1500,FallbackResult.SUCCESS,semaphore);
      final C cmd2=getLatentCommand(ExecutionIsolationStrategy.SEMAPHORE,ExecutionResult.SUCCESS,1500,FallbackResult.SUCCESS,semaphore);
      new Thread(){
        @Override public void run(){
          cmd1.observe();
        }
      }
.start();
      new Thread(){
        @Override public void run(){
          cmd2.observe();
        }
      }
.start();
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException ie) {
        throw new RuntimeException(ie);
      }
      return getLatentCommand(ExecutionIsolationStrategy.SEMAPHORE,ExecutionResult.SUCCESS,500,FallbackResult.SUCCESS,semaphore);
    }
  }
,new Action1<C>(){
    @Override public void call(    C command){
      TestableExecutionHook hook=command.getBuilder().executionHook;
      assertTrue(hook.commandEmissionsMatch(1,0,1));
      assertTrue(hook.executionEventsMatch(0,0,0));
      assertTrue(hook.fallbackEventsMatch(1,0,1));
      assertEquals("onStart - onFallbackStart - onFallbackEmit - !onFallbackSuccess - !onComplete - onEmit - onFallbackSuccess - onSuccess - ",hook.executionSequence.toString());
    }
  }
);
}
