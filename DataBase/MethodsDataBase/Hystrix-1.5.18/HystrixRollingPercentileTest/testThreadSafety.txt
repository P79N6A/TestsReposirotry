@Test public void testThreadSafety(){
  final MockedTime time=new MockedTime();
  final HystrixRollingPercentile p=new HystrixRollingPercentile(time,100,25,1000,HystrixProperty.Factory.asProperty(true));
  final int NUM_THREADS=1000;
  final int NUM_ITERATIONS=1000000;
  final CountDownLatch latch=new CountDownLatch(NUM_THREADS);
  final AtomicInteger aggregateMetrics=new AtomicInteger();
  final Random r=new Random();
  Future<?> metricsPoller=threadPool.submit(new Runnable(){
    @Override public void run(){
      while (!Thread.currentThread().isInterrupted()) {
        aggregateMetrics.addAndGet(p.getMean() + p.getPercentile(10) + p.getPercentile(50)+ p.getPercentile(90));
      }
    }
  }
);
  for (int i=0; i < NUM_THREADS; i++) {
    final int threadId=i;
    threadPool.submit(new Runnable(){
      @Override public void run(){
        for (int j=1; j < NUM_ITERATIONS / NUM_THREADS + 1; j++) {
          int nextInt=r.nextInt(100);
          p.addValue(nextInt);
          if (threadId == 0) {
            time.increment(1);
          }
        }
        latch.countDown();
      }
    }
);
  }
  try {
    latch.await(100,TimeUnit.SECONDS);
    metricsPoller.cancel(true);
  }
 catch (  InterruptedException ex) {
    fail("Timeout on all threads writing percentiles");
  }
  aggregateMetrics.addAndGet(p.getMean() + p.getPercentile(10) + p.getPercentile(50)+ p.getPercentile(90));
  System.out.println(p.getMean() + " : " + p.getPercentile(50)+ " : "+ p.getPercentile(75)+ " : "+ p.getPercentile(90)+ " : "+ p.getPercentile(95)+ " : "+ p.getPercentile(99));
}
