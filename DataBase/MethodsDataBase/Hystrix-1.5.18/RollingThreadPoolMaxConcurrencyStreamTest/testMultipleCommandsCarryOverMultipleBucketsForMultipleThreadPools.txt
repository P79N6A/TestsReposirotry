/** 
 * BUCKETS A    |    B    |    C    |    D    |    E    | 1:  [-------------------------------]              ThreadPool x 2:          [-------------------------------]                 y 3:                      [--]                                  x 4:                              [--]                          x Same input data as above test, just that command 2 runs in a separate threadpool, so concurrency should not get tracked Max concurrency should be 2 for x
 */
@Test public void testMultipleCommandsCarryOverMultipleBucketsForMultipleThreadPools() throws InterruptedException {
  HystrixCommandGroupKey groupKeyX=HystrixCommandGroupKey.Factory.asKey("ThreadPool-Concurrency-X");
  HystrixCommandGroupKey groupKeyY=HystrixCommandGroupKey.Factory.asKey("ThreadPool-Concurrency-Y");
  HystrixThreadPoolKey threadPoolKey=HystrixThreadPoolKey.Factory.asKey("ThreadPool-Concurrency-X");
  HystrixCommandKey keyX=HystrixCommandKey.Factory.asKey("RollingConcurrency-X");
  HystrixCommandKey keyY=HystrixCommandKey.Factory.asKey("RollingConcurrency-Y");
  stream=RollingThreadPoolMaxConcurrencyStream.getInstance(threadPoolKey,10,100);
  stream.startCachingStreamValuesIfUnstarted();
  final CountDownLatch latch=new CountDownLatch(1);
  stream.observe().take(10).subscribe(getSubscriber(latch));
  Command cmd1=Command.from(groupKeyX,keyX,HystrixEventType.SUCCESS,300);
  Command cmd2=Command.from(groupKeyY,keyY,HystrixEventType.SUCCESS,300);
  Command cmd3=Command.from(groupKeyX,keyY,HystrixEventType.SUCCESS,10);
  Command cmd4=Command.from(groupKeyX,keyY,HystrixEventType.SUCCESS,10);
  cmd1.observe();
  Thread.sleep(100);
  cmd2.observe();
  Thread.sleep(100);
  cmd3.observe();
  Thread.sleep(100);
  cmd4.observe();
  assertTrue(latch.await(10000,TimeUnit.MILLISECONDS));
  assertEquals(2,stream.getLatestRollingMax());
}
