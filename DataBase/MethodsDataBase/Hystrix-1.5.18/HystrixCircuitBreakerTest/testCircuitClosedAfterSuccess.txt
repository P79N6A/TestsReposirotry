/** 
 * Test that an open circuit is closed after 1 success.  This also ensures that the rolling window (containing failures) is cleared after the sleep window Otherwise, the next bucket roll would produce another signal to fail unless it is explicitly cleared (via  {@link HystrixCommandMetrics#resetStream()}.
 */
@Test public void testCircuitClosedAfterSuccess(){
  String key="cmd-G";
  try {
    int sleepWindow=100;
    HystrixCommand<Boolean> cmd1=new FailureCommand(key,1,sleepWindow);
    HystrixCircuitBreaker cb=cmd1.circuitBreaker;
    assertTrue(cb.allowRequest());
    assertFalse(cb.isOpen());
    cmd1.execute();
    HystrixCommand<Boolean> cmd2=new FailureCommand(key,1,sleepWindow);
    cmd2.execute();
    HystrixCommand<Boolean> cmd3=new FailureCommand(key,1,sleepWindow);
    cmd3.execute();
    HystrixCommand<Boolean> cmd4=new TimeoutCommand(key,sleepWindow);
    cmd4.execute();
    Thread.sleep(100);
    System.out.println("ReqLog : " + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
    System.out.println("CircuitBreaker state 1 : " + cmd1.getMetrics().getHealthCounts());
    assertFalse(cb.allowRequest());
    assertTrue(cb.isOpen());
    Thread.sleep(sleepWindow + 50);
    assertTrue(cb.isOpen());
    HystrixCommand<Boolean> cmd5=new SuccessCommand(key,60,sleepWindow);
    Observable<Boolean> asyncResult=cmd5.observe();
    assertFalse(cb.allowRequest());
    asyncResult.toBlocking().single();
    Thread.sleep(100);
    System.out.println("CircuitBreaker state 2 : " + cmd1.getMetrics().getHealthCounts());
    assertTrue(cb.allowRequest());
    assertTrue(cb.allowRequest());
    assertTrue(cb.allowRequest());
    assertFalse(cb.isOpen());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("Error occurred: " + e.getMessage());
  }
}
