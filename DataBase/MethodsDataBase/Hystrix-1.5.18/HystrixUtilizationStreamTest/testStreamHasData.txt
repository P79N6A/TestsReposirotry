@Test public void testStreamHasData() throws Exception {
  final AtomicBoolean commandShowsUp=new AtomicBoolean(false);
  final AtomicBoolean threadPoolShowsUp=new AtomicBoolean(false);
  final CountDownLatch latch=new CountDownLatch(1);
  final int NUM=10;
  for (int i=0; i < 2; i++) {
    HystrixCommand<Integer> cmd=Command.from(groupKey,commandKey,HystrixEventType.SUCCESS,50);
    cmd.observe();
  }
  stream.observe().take(NUM).subscribe(new Subscriber<HystrixUtilization>(){
    @Override public void onCompleted(){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " OnCompleted");
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " OnError : "+ e);
      latch.countDown();
    }
    @Override public void onNext(    HystrixUtilization utilization){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " : Received data with : "+ utilization.getCommandUtilizationMap().size()+ " commands");
      if (utilization.getCommandUtilizationMap().containsKey(commandKey)) {
        commandShowsUp.set(true);
      }
      if (!utilization.getThreadPoolUtilizationMap().isEmpty()) {
        threadPoolShowsUp.set(true);
      }
    }
  }
);
  assertTrue(latch.await(10000,TimeUnit.MILLISECONDS));
  assertTrue(commandShowsUp.get());
  assertTrue(threadPoolShowsUp.get());
}
