/** 
 * Some RxJava operators like take(n), zip receive data in an onNext from upstream and immediately unsubscribe. When upstream is a HystrixCommand, Hystrix may get that unsubscribe before it gets to its onCompleted. This should still be marked as a HystrixEventType.SUCCESS.
 */
@Test public void testUnsubscribingDownstreamOperatorStillResultsInSuccessEventType() throws InterruptedException {
  HystrixCommand<Integer> cmd=getCommand(ExecutionIsolationStrategy.THREAD,AbstractTestHystrixCommand.ExecutionResult.SUCCESS,100,AbstractTestHystrixCommand.FallbackResult.UNIMPLEMENTED);
  Observable<Integer> o=cmd.toObservable().doOnNext(new Action1<Integer>(){
    @Override public void call(    Integer i){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " CMD OnNext : "+ i);
    }
  }
).doOnError(new Action1<Throwable>(){
    @Override public void call(    Throwable throwable){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " CMD OnError : "+ throwable);
    }
  }
).doOnCompleted(new Action0(){
    @Override public void call(){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " CMD OnCompleted");
    }
  }
).doOnSubscribe(new Action0(){
    @Override public void call(){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " CMD OnSubscribe");
    }
  }
).doOnUnsubscribe(new Action0(){
    @Override public void call(){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " CMD OnUnsubscribe");
    }
  }
).take(1).observeOn(Schedulers.io()).map(new Func1<Integer,Integer>(){
    @Override public Integer call(    Integer i){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " : Doing some more computation in the onNext!!");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException ex) {
        ex.printStackTrace();
      }
      return i;
    }
  }
);
  final CountDownLatch latch=new CountDownLatch(1);
  o.doOnSubscribe(new Action0(){
    @Override public void call(){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " : OnSubscribe");
    }
  }
).doOnUnsubscribe(new Action0(){
    @Override public void call(){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " : OnUnsubscribe");
    }
  }
).subscribe(new Subscriber<Integer>(){
    @Override public void onCompleted(){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " : OnCompleted");
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " : OnError : "+ e);
      latch.countDown();
    }
    @Override public void onNext(    Integer i){
      System.out.println(Thread.currentThread().getName() + " : " + System.currentTimeMillis()+ " : OnNext : "+ i);
    }
  }
);
  latch.await(1000,TimeUnit.MILLISECONDS);
  System.out.println("ReqLog : " + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
  assertTrue(cmd.isExecutedInThread());
  assertCommandExecutionEvents(cmd,HystrixEventType.SUCCESS);
}
