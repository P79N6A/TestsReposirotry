/** 
 * Test when a command fails to get queued up in the threadpool where the command implemented getFallback. <p> We specifically want to protect against developers getting random thread exceptions and instead just correctly receives a fallback.
 */
@Test public void testRejectedThreadWithFallback() throws InterruptedException {
  HystrixCommandKey key=HystrixCommandKey.Factory.asKey("Rejection-Fallback");
  TestCircuitBreaker circuitBreaker=new TestCircuitBreaker();
  SingleThreadedPoolWithQueue pool=new SingleThreadedPoolWithQueue(1);
  TestCommandRejection command1=new TestCommandRejection(key,circuitBreaker,pool,500,600,TestCommandRejection.FALLBACK_SUCCESS);
  TestCommandRejection command2=new TestCommandRejection(key,circuitBreaker,pool,500,600,TestCommandRejection.FALLBACK_SUCCESS);
  TestCommandRejection command3=new TestCommandRejection(key,circuitBreaker,pool,500,600,TestCommandRejection.FALLBACK_SUCCESS);
  Observable<Boolean> result1=command1.observe();
  Observable<Boolean> result2=command2.observe();
  Thread.sleep(100);
  assertFalse(command3.execute());
  assertTrue(command3.isResponseRejected());
  assertFalse(command1.isResponseRejected());
  assertFalse(command2.isResponseRejected());
  assertTrue(command3.isResponseFromFallback());
  assertNotNull(command3.getExecutionException());
  assertCommandExecutionEvents(command3,HystrixEventType.THREAD_POOL_REJECTED,HystrixEventType.FALLBACK_SUCCESS);
  Observable.merge(result1,result2).toList().toBlocking().single();
  assertEquals(0,circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
  System.out.println("ReqLog : " + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
  assertSaneHystrixRequestLog(3);
}
