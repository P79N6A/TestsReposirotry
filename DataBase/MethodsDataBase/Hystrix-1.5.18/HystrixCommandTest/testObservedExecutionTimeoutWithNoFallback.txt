/** 
 * Test a queued command execution timeout where the command didn't implement getFallback. <p> We specifically want to protect against developers queuing commands and using queue().get() without a timeout (such as queue().get(3000, TimeUnit.Milliseconds)) and ending up blocking indefinitely by skipping the timeout protection of the execute() command.
 */
@Test public void testObservedExecutionTimeoutWithNoFallback(){
  TestHystrixCommand<Integer> command=getCommand(ExecutionIsolationStrategy.THREAD,AbstractTestHystrixCommand.ExecutionResult.SUCCESS,200,AbstractTestHystrixCommand.FallbackResult.UNIMPLEMENTED,50);
  try {
    command.observe().toBlocking().single();
    fail("we shouldn't get here");
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (e instanceof HystrixRuntimeException) {
      HystrixRuntimeException de=(HystrixRuntimeException)e;
      assertNotNull(de.getFallbackException());
      assertTrue(de.getFallbackException() instanceof UnsupportedOperationException);
      assertNotNull(de.getImplementingClass());
      assertNotNull(de.getCause());
      assertTrue(de.getCause() instanceof TimeoutException);
    }
 else {
      fail("the exception should be ExecutionException with cause as HystrixRuntimeException");
    }
  }
  assertTrue(command.getExecutionTimeInMilliseconds() > -1);
  assertTrue(command.isResponseTimedOut());
  assertCommandExecutionEvents(command,HystrixEventType.TIMEOUT,HystrixEventType.FALLBACK_MISSING);
  assertNotNull(command.getExecutionException());
  assertEquals(0,command.getBuilder().metrics.getCurrentConcurrentExecutionCount());
  assertSaneHystrixRequestLog(1);
}
