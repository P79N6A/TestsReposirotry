@Test public void testRequestThenCacheHitAndCacheHitUnsubscribed(){
  AsyncCacheableCommand original=new AsyncCacheableCommand("foo");
  AsyncCacheableCommand fromCache=new AsyncCacheableCommand("foo");
  final AtomicReference<Boolean> originalValue=new AtomicReference<Boolean>(null);
  final AtomicReference<Boolean> fromCacheValue=new AtomicReference<Boolean>(null);
  final CountDownLatch originalLatch=new CountDownLatch(1);
  final CountDownLatch fromCacheLatch=new CountDownLatch(1);
  Observable<Boolean> originalObservable=original.toObservable();
  Observable<Boolean> fromCacheObservable=fromCache.toObservable();
  Subscription originalSubscription=originalObservable.doOnUnsubscribe(new Action0(){
    @Override public void call(){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " Test.Original Unsubscribe");
      originalLatch.countDown();
    }
  }
).subscribe(new Subscriber<Boolean>(){
    @Override public void onCompleted(){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " Test.Original OnCompleted");
      originalLatch.countDown();
    }
    @Override public void onError(    Throwable e){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " Test.Original OnError : "+ e);
      originalLatch.countDown();
    }
    @Override public void onNext(    Boolean b){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " Test.Original OnNext : "+ b);
      originalValue.set(b);
    }
  }
);
  Subscription fromCacheSubscription=fromCacheObservable.doOnUnsubscribe(new Action0(){
    @Override public void call(){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " FromCache Unsubscribe");
      fromCacheLatch.countDown();
    }
  }
).subscribe(new Subscriber<Boolean>(){
    @Override public void onCompleted(){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " FromCache OnCompleted");
      fromCacheLatch.countDown();
    }
    @Override public void onError(    Throwable e){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " FromCache OnError : "+ e);
      fromCacheLatch.countDown();
    }
    @Override public void onNext(    Boolean b){
      System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName()+ " FromCache OnNext : "+ b);
      fromCacheValue.set(b);
    }
  }
);
  try {
    fromCacheSubscription.unsubscribe();
    assertTrue(fromCacheLatch.await(600,TimeUnit.MILLISECONDS));
    assertTrue(originalLatch.await(600,TimeUnit.MILLISECONDS));
    assertEquals("Number of execution semaphores in use (original)",0,original.getExecutionSemaphore().getNumberOfPermitsUsed());
    assertEquals("Number of fallback semaphores in use (original)",0,original.getFallbackSemaphore().getNumberOfPermitsUsed());
    assertTrue(original.isExecutionComplete());
    assertTrue(original.isExecutedInThread());
    assertEquals(null,original.getFailedExecutionException());
    assertNull(original.getExecutionException());
    assertTrue(original.getExecutionTimeInMilliseconds() > -1);
    assertTrue(original.isSuccessfulExecution());
    assertCommandExecutionEvents(original,HystrixEventType.SUCCESS);
    assertTrue(originalValue.get());
    assertEquals(0,original.metrics.getCurrentConcurrentExecutionCount());
    assertEquals("Number of execution semaphores in use (fromCache)",0,fromCache.getExecutionSemaphore().getNumberOfPermitsUsed());
    assertEquals("Number of fallback semaphores in use (fromCache)",0,fromCache.getFallbackSemaphore().getNumberOfPermitsUsed());
    assertFalse(fromCache.isExecutionComplete());
    assertFalse(fromCache.isExecutedInThread());
    assertEquals(null,fromCache.getFailedExecutionException());
    assertNull(fromCache.getExecutionException());
    assertCommandExecutionEvents(fromCache,HystrixEventType.RESPONSE_FROM_CACHE,HystrixEventType.CANCELLED);
    assertTrue(fromCache.getExecutionTimeInMilliseconds() == -1);
    assertFalse(fromCache.isSuccessfulExecution());
    assertEquals(0,fromCache.metrics.getCurrentConcurrentExecutionCount());
    assertFalse(original.isCancelled());
    System.out.println("ReqLog : " + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
    assertSaneHystrixRequestLog(2);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}
