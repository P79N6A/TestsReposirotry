/** 
 * Short-circuit? : NO Thread/semaphore: THREAD Thread Pool full? : YES Thread Pool Queue full?: YES Fallback: SUCCESS
 */
@Test public void testExecutionHookThreadPoolQueueFullSuccessfulFallback(){
  assertHooksOnSuccess(new Func0<TestHystrixCommand<Integer>>(){
    @Override public TestHystrixCommand<Integer> call(){
      HystrixCircuitBreakerTest.TestCircuitBreaker circuitBreaker=new HystrixCircuitBreakerTest.TestCircuitBreaker();
      HystrixThreadPool pool=new SingleThreadedPoolWithQueue(1);
      try {
        getLatentCommand(ExecutionIsolationStrategy.THREAD,AbstractTestHystrixCommand.ExecutionResult.SUCCESS,500,AbstractTestHystrixCommand.FallbackResult.SUCCESS,circuitBreaker,pool,600).observe();
        getLatentCommand(ExecutionIsolationStrategy.THREAD,AbstractTestHystrixCommand.ExecutionResult.SUCCESS,500,AbstractTestHystrixCommand.FallbackResult.SUCCESS,circuitBreaker,pool,600).observe();
      }
 catch (      Exception e) {
      }
      return getLatentCommand(ExecutionIsolationStrategy.THREAD,AbstractTestHystrixCommand.ExecutionResult.SUCCESS,500,AbstractTestHystrixCommand.FallbackResult.SUCCESS,circuitBreaker,pool,600);
    }
  }
,new Action1<TestHystrixCommand<Integer>>(){
    @Override public void call(    TestHystrixCommand<Integer> command){
      TestableExecutionHook hook=command.getBuilder().executionHook;
      assertTrue(hook.commandEmissionsMatch(1,0,1));
      assertTrue(hook.executionEventsMatch(0,0,0));
      assertTrue(hook.fallbackEventsMatch(1,0,1));
      assertEquals("onStart - onFallbackStart - onFallbackEmit - !onFallbackSuccess - !onComplete - onEmit - onFallbackSuccess - onSuccess - ",hook.executionSequence.toString());
    }
  }
);
}
