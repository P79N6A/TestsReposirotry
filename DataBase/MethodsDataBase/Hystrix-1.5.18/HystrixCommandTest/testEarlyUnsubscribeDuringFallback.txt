@Test public void testEarlyUnsubscribeDuringFallback(){
class AsyncCommand extends HystrixCommand<Boolean> {
    public AsyncCommand(){
      super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ASYNC")));
    }
    @Override protected Boolean run(){
      throw new RuntimeException("run failure");
    }
    @Override protected Boolean getFallback(){
      try {
        Thread.sleep(500);
        return false;
      }
 catch (      InterruptedException ex) {
        throw new RuntimeException(ex);
      }
    }
  }
  HystrixCommand<Boolean> cmd=new AsyncCommand();
  final CountDownLatch latch=new CountDownLatch(1);
  Observable<Boolean> o=cmd.toObservable();
  Subscription s=o.doOnUnsubscribe(new Action0(){
    @Override public void call(){
      System.out.println("OnUnsubscribe");
      latch.countDown();
    }
  }
).subscribe(new Subscriber<Boolean>(){
    @Override public void onCompleted(){
      System.out.println("OnCompleted");
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      System.out.println("OnError : " + e);
    }
    @Override public void onNext(    Boolean b){
      System.out.println("OnNext : " + b);
    }
  }
);
  try {
    Thread.sleep(10);
    s.unsubscribe();
    assertTrue(latch.await(200,TimeUnit.MILLISECONDS));
    assertEquals("Number of execution semaphores in use",0,cmd.getExecutionSemaphore().getNumberOfPermitsUsed());
    assertEquals("Number of fallback semaphores in use",0,cmd.getFallbackSemaphore().getNumberOfPermitsUsed());
    assertEquals(0,cmd.metrics.getCurrentConcurrentExecutionCount());
    assertFalse(cmd.isExecutionComplete());
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}
