/** 
 * Tests that the job is not restarted or at least terminates eventually in case that the JobManager loses its leadership.
 * @throws Exception
 */
@Test public void testNotRestartedWhenLosingLeadership() throws Exception {
  UUID leaderSessionID=UUID.randomUUID();
  highAvailabilityServices.grantLeadership(jobId,0,leaderSessionID);
  highAvailabilityServices.notifyRetrievers(jobId,0,leaderSessionID);
  cluster.waitForTaskManagersToBeRegistered(timeout);
  cluster.submitJobDetached(job);
  ActorGateway jm=cluster.getLeaderGateway(timeout);
  Future<Object> wait=jm.ask(new TestingJobManagerMessages.WaitForAllVerticesToBeRunningOrFinished(job.getJobID()),timeout);
  Await.ready(wait,timeout);
  Future<Object> futureExecutionGraph=jm.ask(new TestingJobManagerMessages.RequestExecutionGraph(job.getJobID()),timeout);
  TestingJobManagerMessages.ResponseExecutionGraph responseExecutionGraph=(TestingJobManagerMessages.ResponseExecutionGraph)Await.result(futureExecutionGraph,timeout);
  assertTrue(responseExecutionGraph instanceof TestingJobManagerMessages.ExecutionGraphFound);
  ExecutionGraph executionGraph=(ExecutionGraph)((TestingJobManagerMessages.ExecutionGraphFound)responseExecutionGraph).executionGraph();
  highAvailabilityServices.revokeLeadership(jobId);
  executionGraph.getTerminationFuture().get(30,TimeUnit.SECONDS);
}
