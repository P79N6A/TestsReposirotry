/** 
 * FLINK-6833 <p>Tests that a finished stream task cannot be failed by an asynchronous checkpointing operation after the stream task has stopped running.
 */
@Test public void testConcurrentAsyncCheckpointCannotFailFinishedStreamTask() throws Exception {
  final Configuration taskConfiguration=new Configuration();
  final StreamConfig streamConfig=new StreamConfig(taskConfiguration);
  final NoOpStreamOperator<Long> noOpStreamOperator=new NoOpStreamOperator<>();
  final StateBackend blockingStateBackend=new BlockingStateBackend();
  streamConfig.setStreamOperator(noOpStreamOperator);
  streamConfig.setOperatorID(new OperatorID());
  streamConfig.setStateBackend(blockingStateBackend);
  final long checkpointId=0L;
  final long checkpointTimestamp=0L;
  final JobInformation jobInformation=new JobInformation(new JobID(),"Test Job",new SerializedValue<>(new ExecutionConfig()),new Configuration(),Collections.emptyList(),Collections.emptyList());
  final TaskInformation taskInformation=new TaskInformation(new JobVertexID(),"Test Task",1,1,BlockingStreamTask.class.getName(),taskConfiguration);
  final TaskManagerRuntimeInfo taskManagerRuntimeInfo=new TestingTaskManagerRuntimeInfo();
  TaskEventDispatcher taskEventDispatcher=new TaskEventDispatcher();
  final NetworkEnvironment networkEnv=mock(NetworkEnvironment.class);
  when(networkEnv.createKvStateTaskRegistry(any(JobID.class),any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class));
  when(networkEnv.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
  BlobCacheService blobService=new BlobCacheService(mock(PermanentBlobCache.class),mock(TransientBlobCache.class));
  final Task task=new Task(jobInformation,taskInformation,new ExecutionAttemptID(),new AllocationID(),0,0,Collections.<ResultPartitionDeploymentDescriptor>emptyList(),Collections.<InputGateDeploymentDescriptor>emptyList(),0,new MemoryManager(32L * 1024L,1),new IOManagerAsync(),networkEnv,mock(BroadcastVariableManager.class),new TestTaskStateManager(),mock(TaskManagerActions.class),mock(InputSplitProvider.class),mock(CheckpointResponder.class),blobService,new BlobLibraryCacheManager(blobService.getPermanentBlobService(),FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,new String[0]),mock(FileCache.class),taskManagerRuntimeInfo,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),new NoOpResultPartitionConsumableNotifier(),mock(PartitionProducerStateChecker.class),Executors.directExecutor());
  CompletableFuture<Void> taskRun=CompletableFuture.runAsync(() -> task.run(),TestingUtils.defaultExecutor());
  RUN_LATCH.await();
  task.triggerCheckpointBarrier(checkpointId,checkpointTimestamp,CheckpointOptions.forCheckpointWithDefaultLocation());
  taskRun.get();
  if (task.getFailureCause() != null) {
    throw new Exception("Task failed",task.getFailureCause());
  }
  assertEquals(ExecutionState.FINISHED,task.getExecutionState());
}
