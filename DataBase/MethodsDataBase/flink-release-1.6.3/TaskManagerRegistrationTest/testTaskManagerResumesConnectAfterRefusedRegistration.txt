/** 
 * Make sure that the TaskManager keeps trying to register, even after registration attempts have been refused.
 */
@Test public void testTaskManagerResumesConnectAfterRefusedRegistration(){
  new JavaTestKit(actorSystem){
{
      ActorGateway jm=null;
      ActorGateway taskManager=null;
      try {
        jm=TestingUtils.createForwardingActor(actorSystem,getTestActor(),HighAvailabilityServices.DEFAULT_LEADER_ID,Option.<String>empty());
        final ActorGateway jmGateway=jm;
        FiniteDuration refusedRegistrationPause=new FiniteDuration(500,TimeUnit.MILLISECONDS);
        Configuration tmConfig=new Configuration(config);
        tmConfig.setString(TaskManagerOptions.REFUSED_REGISTRATION_BACKOFF,refusedRegistrationPause.toString());
        highAvailabilityServices.setJobMasterLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID,new SettableLeaderRetrievalService(jm.path(),HighAvailabilityServices.DEFAULT_LEADER_ID));
        taskManager=createTaskManager(actorSystem,highAvailabilityServices,tmConfig,true,false);
        final ActorGateway taskManagerGateway=taskManager;
        new Within(timeout){
          @Override protected void run(){
            expectMsgClass(RegisterTaskManager.class);
            taskManagerGateway.tell(new RefuseRegistration(new Exception("test reason")),jmGateway);
          }
        }
;
        FiniteDuration maxDelay=(FiniteDuration)refusedRegistrationPause.$times(3.0);
        new Within(maxDelay){
          @Override protected void run(){
            expectMsgClass(RegisterTaskManager.class);
          }
        }
;
      }
  finally {
        stopActorGatewaysGracefully(Arrays.asList(taskManager,jm));
      }
    }
  }
;
}
