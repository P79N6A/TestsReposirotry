/** 
 * This test verifies that checkpoint barriers and barrier buffers work correctly with concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e. some inputs receive barriers from an earlier checkpoint, thereby blocking, then all inputs receive barriers from a later checkpoint.
 */
@Test @SuppressWarnings("unchecked") public void testOvertakingCheckpointBarriers() throws Exception {
  final TwoInputStreamTaskTestHarness<String,Integer,String> testHarness=new TwoInputStreamTaskTestHarness<>(TwoInputStreamTask::new,2,2,new int[]{1,2},BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.INT_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
  testHarness.setupOutputForSingletonOperatorChain();
  StreamConfig streamConfig=testHarness.getStreamConfig();
  CoStreamMap<String,Integer,String> coMapOperator=new CoStreamMap<String,Integer,String>(new IdentityMap());
  streamConfig.setStreamOperator(coMapOperator);
  streamConfig.setOperatorID(new OperatorID());
  ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<Object>();
  long initialTime=0L;
  testHarness.invoke();
  testHarness.waitForTaskRunning();
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,0);
  testHarness.processElement(new StreamRecord<String>("Hello-0-0",initialTime),0,0);
  testHarness.processElement(new StreamRecord<String>("Ciao-0-0",initialTime),0,0);
  testHarness.processElement(new StreamRecord<Integer>(42,initialTime),1,1);
  testHarness.processElement(new StreamRecord<Integer>(1337,initialTime),1,1);
  expectedOutput.add(new StreamRecord<String>("42",initialTime));
  expectedOutput.add(new StreamRecord<String>("1337",initialTime));
  testHarness.waitForInputProcessing();
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),0,0);
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),0,1);
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),1,0);
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),1,1);
  expectedOutput.add(new CancelCheckpointMarker(0));
  expectedOutput.add(new StreamRecord<String>("Hello-0-0",initialTime));
  expectedOutput.add(new StreamRecord<String>("Ciao-0-0",initialTime));
  expectedOutput.add(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()));
  testHarness.waitForInputProcessing();
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,1);
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,0);
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,1);
  testHarness.waitForInputProcessing();
  testHarness.endInput();
  testHarness.waitForTaskCompletion();
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
}
