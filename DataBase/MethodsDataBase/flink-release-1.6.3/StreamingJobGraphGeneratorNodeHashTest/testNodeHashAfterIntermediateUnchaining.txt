/** 
 * Tests that (un)chaining affects the node hash (for intermediate nodes). <pre> A (chained): [ (src0) -> (map) -> (filter) -> (sink) ] B (unchained): [ (src0) ] -> [ (map) -> (filter) -> (sink) ] </pre> <p>The hashes for the single vertex in A and the source vertex in B need to be different.
 */
@Test public void testNodeHashAfterIntermediateUnchaining() throws Exception {
  StreamExecutionEnvironment env=StreamExecutionEnvironment.createLocalEnvironment();
  env.setParallelism(4);
  env.addSource(new NoOpSourceFunction()).map(new NoOpMapFunction()).name("map").startNewChain().filter(new NoOpFilterFunction()).addSink(new NoOpSinkFunction());
  JobGraph jobGraph=env.getStreamGraph().getJobGraph();
  JobVertex chainedMap=jobGraph.getVerticesSortedTopologicallyFromSources().get(1);
  assertTrue(chainedMap.getName().startsWith("map"));
  JobVertexID chainedMapId=chainedMap.getID();
  env=StreamExecutionEnvironment.createLocalEnvironment();
  env.setParallelism(4);
  env.addSource(new NoOpSourceFunction()).map(new NoOpMapFunction()).name("map").startNewChain().filter(new NoOpFilterFunction()).startNewChain().addSink(new NoOpSinkFunction());
  jobGraph=env.getStreamGraph().getJobGraph();
  JobVertex unchainedMap=jobGraph.getVerticesSortedTopologicallyFromSources().get(1);
  assertEquals("map",unchainedMap.getName());
  JobVertexID unchainedMapId=unchainedMap.getID();
  assertNotEquals(chainedMapId,unchainedMapId);
}
