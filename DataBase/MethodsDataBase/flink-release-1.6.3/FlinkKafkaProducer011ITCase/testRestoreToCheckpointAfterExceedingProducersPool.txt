/** 
 * This test ensures that transactions reusing transactional.ids (after returning to the pool) will not clash with previous transactions using same transactional.ids.
 */
@Test public void testRestoreToCheckpointAfterExceedingProducersPool() throws Exception {
  String topic="flink-kafka-producer-fail-before-notify";
  try (OneInputStreamOperatorTestHarness<Integer,Object> testHarness1=createTestHarness(topic)){
    testHarness1.setup();
    testHarness1.open();
    testHarness1.processElement(42,0);
    OperatorSubtaskState snapshot=testHarness1.snapshot(0,0);
    testHarness1.processElement(43,0);
    testHarness1.notifyOfCompletedCheckpoint(0);
    try {
      for (int i=0; i < FlinkKafkaProducer011.DEFAULT_KAFKA_PRODUCERS_POOL_SIZE; i++) {
        testHarness1.snapshot(i + 1,0);
        testHarness1.processElement(i,0);
      }
      throw new IllegalStateException("This should not be reached.");
    }
 catch (    Exception ex) {
      if (!isCausedBy(FlinkKafka011ErrorCode.PRODUCERS_POOL_EMPTY,ex)) {
        throw ex;
      }
    }
    try (OneInputStreamOperatorTestHarness<Integer,Object> testHarness2=createTestHarness(topic)){
      testHarness2.setup();
      testHarness2.initializeState(snapshot);
      testHarness2.open();
    }
     assertExactlyOnceForTopic(createProperties(),topic,0,Arrays.asList(42));
    deleteTestTopic(topic);
  }
 catch (  Exception ex) {
    if (!findThrowable(ex,ProducerFencedException.class).isPresent()) {
      throw ex;
    }
  }
}
