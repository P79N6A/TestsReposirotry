@Test public void testConsumptionWithMixedChannels() throws Exception {
  final int numChannels=61;
  final int numLocalChannels=20;
  final int buffersPerChannel=1000;
  List<Boolean> localOrRemote=new ArrayList<>(numChannels);
  for (int i=0; i < numChannels; i++) {
    localOrRemote.add(i < numLocalChannels);
  }
  Collections.shuffle(localOrRemote);
  final ConnectionManager connManager=createDummyConnectionManager();
  final ResultPartition resultPartition=mock(ResultPartition.class);
  final PipelinedSubpartition[] localPartitions=new PipelinedSubpartition[numLocalChannels];
  final ResultPartitionManager resultPartitionManager=createResultPartitionManager(localPartitions);
  final Source[] sources=new Source[numChannels];
  final SingleInputGate gate=new SingleInputGate("Test Task Name",new JobID(),new IntermediateDataSetID(),ResultPartitionType.PIPELINED,0,numChannels,mock(TaskActions.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(),true);
  for (int i=0, local=0; i < numChannels; i++) {
    if (localOrRemote.get(i)) {
      PipelinedSubpartition psp=new PipelinedSubpartition(0,resultPartition);
      localPartitions[local++]=psp;
      sources[i]=new PipelinedSubpartitionSource(psp);
      LocalInputChannel channel=new LocalInputChannel(gate,i,new ResultPartitionID(),resultPartitionManager,mock(TaskEventDispatcher.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup());
      gate.setInputChannel(new IntermediateResultPartitionID(),channel);
    }
 else {
      RemoteInputChannel channel=new RemoteInputChannel(gate,i,new ResultPartitionID(),mock(ConnectionID.class),connManager,0,0,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup());
      gate.setInputChannel(new IntermediateResultPartitionID(),channel);
      sources[i]=new RemoteChannelSource(channel);
    }
  }
  ProducerThread producer=new ProducerThread(sources,numChannels * buffersPerChannel,4,10);
  ConsumerThread consumer=new ConsumerThread(gate,numChannels * buffersPerChannel);
  producer.start();
  consumer.start();
  producer.sync();
  consumer.sync();
}
