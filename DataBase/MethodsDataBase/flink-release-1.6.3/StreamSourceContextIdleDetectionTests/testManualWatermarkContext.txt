/** 
 * Test scenario (idleTimeout = 100): (1) Start from 0 as initial time. (2) As soon as time reaches 100, status should have been toggled to IDLE. (3) After some arbitrary time (until 300), the status should remain IDLE. (4) Emit a record at 310. Status should become ACTIVE. This should fire a idleness detection at 410. (5) Emit another record at 320 (which is before the next check). This should make the idleness check pass. (6) Advance time to 410 and trigger idleness detection. The status should still be ACTIVE due to step (5). Another idleness detection should be fired at 510. (7) Advance time to 510 and trigger idleness detection. Since no records were collected in-between the two idleness detections, status should have been toggle back to IDLE. <p>Inline comments will refer to the corresponding tested steps in the scenario.
 */
@Test public void testManualWatermarkContext() throws Exception {
  long idleTimeout=100;
  long initialTime=0;
  TestProcessingTimeService processingTimeService=new TestProcessingTimeService();
  processingTimeService.setCurrentTime(initialTime);
  final List<StreamElement> output=new ArrayList<>();
  MockStreamStatusMaintainer mockStreamStatusMaintainer=new MockStreamStatusMaintainer();
  SourceFunction.SourceContext<String> context=StreamSourceContexts.getSourceContext(TimeCharacteristic.EventTime,processingTimeService,new Object(),mockStreamStatusMaintainer,new CollectorOutput<String>(output),0,idleTimeout);
  processingTimeService.setCurrentTime(initialTime + idleTimeout);
  assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
  processingTimeService.setCurrentTime(initialTime + 2 * idleTimeout);
  processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout);
  assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
  processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout + idleTimeout / 10);
switch (testMethod) {
case COLLECT:
    context.collect("msg");
  break;
case COLLECT_WITH_TIMESTAMP:
context.collectWithTimestamp("msg",processingTimeService.getCurrentProcessingTime());
break;
case EMIT_WATERMARK:
context.emitWatermark(new Watermark(processingTimeService.getCurrentProcessingTime()));
break;
}
assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout + 2 * idleTimeout / 10);
switch (testMethod) {
case COLLECT:
context.collect("msg");
break;
case COLLECT_WITH_TIMESTAMP:
context.collectWithTimestamp("msg",processingTimeService.getCurrentProcessingTime());
break;
case EMIT_WATERMARK:
context.emitWatermark(new Watermark(processingTimeService.getCurrentProcessingTime()));
break;
}
assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
processingTimeService.setCurrentTime(initialTime + 4 * idleTimeout + idleTimeout / 10);
assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
processingTimeService.setCurrentTime(initialTime + 5 * idleTimeout + idleTimeout / 10);
assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
}
