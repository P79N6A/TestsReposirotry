@Test public void testCheckpointRestore() throws Exception {
  final int initElement=0;
  final int maxElement=100;
  final Set<Long> expectedOutput=new HashSet<>();
  for (long i=initElement; i <= maxElement; i++) {
    expectedOutput.add(i);
  }
  final ConcurrentHashMap<String,List<Long>> outputCollector=new ConcurrentHashMap<>();
  final OneShotLatch latchToTrigger1=new OneShotLatch();
  final OneShotLatch latchToWait1=new OneShotLatch();
  final OneShotLatch latchToTrigger2=new OneShotLatch();
  final OneShotLatch latchToWait2=new OneShotLatch();
  final StatefulSequenceSource source1=new StatefulSequenceSource(initElement,maxElement);
  StreamSource<Long,StatefulSequenceSource> src1=new StreamSource<>(source1);
  final AbstractStreamOperatorTestHarness<Long> testHarness1=new AbstractStreamOperatorTestHarness<>(src1,2,2,0);
  testHarness1.open();
  final StatefulSequenceSource source2=new StatefulSequenceSource(initElement,maxElement);
  StreamSource<Long,StatefulSequenceSource> src2=new StreamSource<>(source2);
  final AbstractStreamOperatorTestHarness<Long> testHarness2=new AbstractStreamOperatorTestHarness<>(src2,2,2,1);
  testHarness2.open();
  final Throwable[] error=new Throwable[3];
  Thread runner1=new Thread(){
    @Override public void run(){
      try {
        source1.run(new BlockingSourceContext("1",latchToTrigger1,latchToWait1,outputCollector,21));
      }
 catch (      Throwable t) {
        t.printStackTrace();
        error[0]=t;
      }
    }
  }
;
  Thread runner2=new Thread(){
    @Override public void run(){
      try {
        source2.run(new BlockingSourceContext("2",latchToTrigger2,latchToWait2,outputCollector,32));
      }
 catch (      Throwable t) {
        t.printStackTrace();
        error[1]=t;
      }
    }
  }
;
  runner1.start();
  runner2.start();
  if (!latchToTrigger1.isTriggered()) {
    latchToTrigger1.await();
  }
  if (!latchToTrigger2.isTriggered()) {
    latchToTrigger2.await();
  }
  OperatorSubtaskState snapshot=AbstractStreamOperatorTestHarness.repackageState(testHarness1.snapshot(0L,0L),testHarness2.snapshot(0L,0L));
  final StatefulSequenceSource source3=new StatefulSequenceSource(initElement,maxElement);
  StreamSource<Long,StatefulSequenceSource> src3=new StreamSource<>(source3);
  final AbstractStreamOperatorTestHarness<Long> testHarness3=new AbstractStreamOperatorTestHarness<>(src3,2,1,0);
  testHarness3.setup();
  testHarness3.initializeState(snapshot);
  testHarness3.open();
  final OneShotLatch latchToTrigger3=new OneShotLatch();
  final OneShotLatch latchToWait3=new OneShotLatch();
  latchToWait3.trigger();
  Thread runner3=new Thread(){
    @Override public void run(){
      try {
        source3.run(new BlockingSourceContext("3",latchToTrigger3,latchToWait3,outputCollector,3));
      }
 catch (      Throwable t) {
        t.printStackTrace();
        error[2]=t;
      }
    }
  }
;
  runner3.start();
  runner3.join();
  Assert.assertEquals(3,outputCollector.size());
  Set<Long> dedupRes=new HashSet<>(Math.abs(maxElement - initElement) + 1);
  for (  Map.Entry<String,List<Long>> elementsPerTask : outputCollector.entrySet()) {
    String key=elementsPerTask.getKey();
    List<Long> elements=outputCollector.get(key);
    Assert.assertTrue(elements.size() > 0);
    for (    Long elem : elements) {
      if (!dedupRes.add(elem)) {
        Assert.fail("Duplicate entry: " + elem);
      }
      if (!expectedOutput.contains(elem)) {
        Assert.fail("Unexpected element: " + elem);
      }
    }
  }
  Assert.assertEquals(Math.abs(initElement - maxElement) + 1,dedupRes.size());
  latchToWait1.trigger();
  latchToWait2.trigger();
  runner1.join();
  runner2.join();
}
