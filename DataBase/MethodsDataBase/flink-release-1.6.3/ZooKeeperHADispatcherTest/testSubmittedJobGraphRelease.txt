/** 
 * Tests that the  {@link Dispatcher} releases a locked {@link SubmittedJobGraph} if itlost the leadership.
 */
@Test public void testSubmittedJobGraphRelease() throws Exception {
  final CuratorFramework client=ZooKeeperUtils.startCuratorFramework(configuration);
  final CuratorFramework otherClient=ZooKeeperUtils.startCuratorFramework(configuration);
  try (final TestingHighAvailabilityServices testingHighAvailabilityServices=new TestingHighAvailabilityServices()){
    testingHighAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client,configuration));
    final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore=ZooKeeperUtils.createSubmittedJobGraphs(otherClient,configuration);
    otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);
    final TestingLeaderElectionService leaderElectionService=new TestingLeaderElectionService();
    testingHighAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);
    final TestingDispatcher dispatcher=createDispatcher(testingHighAvailabilityServices,new TestingJobManagerRunnerFactory(new CompletableFuture<>(),new CompletableFuture<>(),CompletableFuture.completedFuture(null)));
    dispatcher.start();
    try {
      final DispatcherId expectedLeaderId=DispatcherId.generate();
      leaderElectionService.isLeader(expectedLeaderId.toUUID()).get();
      final DispatcherGateway dispatcherGateway=dispatcher.getSelfGateway(DispatcherGateway.class);
      final JobGraph nonEmptyJobGraph=DispatcherHATest.createNonEmptyJobGraph();
      final CompletableFuture<Acknowledge> submissionFuture=dispatcherGateway.submitJob(nonEmptyJobGraph,TIMEOUT);
      submissionFuture.get();
      Collection<JobID> jobIds=otherSubmittedJobGraphStore.getJobIds();
      final JobID jobId=nonEmptyJobGraph.getJobID();
      assertThat(jobIds,Matchers.contains(jobId));
      leaderElectionService.notLeader();
      final CompletableFuture<Void> jobTerminationFuture=dispatcher.getJobTerminationFuture(jobId,TIMEOUT);
      jobTerminationFuture.get();
      final SubmittedJobGraph submittedJobGraph=otherSubmittedJobGraphStore.recoverJobGraph(jobId);
      assertThat(submittedJobGraph,is(notNullValue()));
      otherSubmittedJobGraphStore.removeJobGraph(jobId);
      jobIds=otherSubmittedJobGraphStore.getJobIds();
      assertThat(jobIds,Matchers.not(Matchers.contains(jobId)));
    }
  finally {
      RpcUtils.terminateRpcEndpoint(dispatcher,TIMEOUT);
      client.close();
      otherClient.close();
    }
  }
 }
