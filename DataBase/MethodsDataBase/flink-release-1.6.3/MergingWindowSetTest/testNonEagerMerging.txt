/** 
 * This test uses a special (misbehaving)  {@code MergingWindowAssigner} that produces caseswhere windows that don't overlap with the newly added window are being merged. We verify that the merging window set is nevertheless correct and contains all added windows.
 */
@Test public void testNonEagerMerging() throws Exception {
  @SuppressWarnings("unchecked") ListState<Tuple2<TimeWindow,TimeWindow>> mockState=mock(ListState.class);
  MergingWindowSet<TimeWindow> windowSet=new MergingWindowSet<>(new NonEagerlyMergingWindowAssigner(3000),mockState);
  TestingMergeFunction mergeFunction=new TestingMergeFunction();
  TimeWindow result;
  mergeFunction.reset();
  result=windowSet.addWindow(new TimeWindow(0,2),mergeFunction);
  assertNotNull(windowSet.getStateWindow(result));
  mergeFunction.reset();
  result=windowSet.addWindow(new TimeWindow(2,5),mergeFunction);
  assertNotNull(windowSet.getStateWindow(result));
  mergeFunction.reset();
  result=windowSet.addWindow(new TimeWindow(1,2),mergeFunction);
  assertNotNull(windowSet.getStateWindow(result));
  mergeFunction.reset();
  result=windowSet.addWindow(new TimeWindow(10,12),mergeFunction);
  assertNotNull(windowSet.getStateWindow(result));
}
