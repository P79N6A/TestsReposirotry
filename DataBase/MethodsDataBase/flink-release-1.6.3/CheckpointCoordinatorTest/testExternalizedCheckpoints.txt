/** 
 * Tests that the externalized checkpoint configuration is respected.
 */
@Test public void testExternalizedCheckpoints() throws Exception {
  try {
    final JobID jid=new JobID();
    final long timestamp=System.currentTimeMillis();
    final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
    ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.RETAIN_ON_FAILURE,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    assertTrue(coord.triggerCheckpoint(timestamp,false));
    for (    PendingCheckpoint checkpoint : coord.getPendingCheckpoints().values()) {
      CheckpointProperties props=checkpoint.getProps();
      CheckpointProperties expected=CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE);
      assertEquals(expected,props);
    }
    coord.shutdown(JobStatus.FINISHED);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
