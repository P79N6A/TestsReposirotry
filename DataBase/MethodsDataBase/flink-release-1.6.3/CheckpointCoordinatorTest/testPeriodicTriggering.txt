@Test public void testPeriodicTriggering(){
  try {
    final JobID jid=new JobID();
    final long start=System.currentTimeMillis();
    final ExecutionAttemptID triggerAttemptID=new ExecutionAttemptID();
    final ExecutionAttemptID ackAttemptID=new ExecutionAttemptID();
    final ExecutionAttemptID commitAttemptID=new ExecutionAttemptID();
    ExecutionVertex triggerVertex=mockExecutionVertex(triggerAttemptID);
    ExecutionVertex ackVertex=mockExecutionVertex(ackAttemptID);
    ExecutionVertex commitVertex=mockExecutionVertex(commitAttemptID);
    final AtomicInteger numCalls=new AtomicInteger();
    final Execution execution=triggerVertex.getCurrentExecutionAttempt();
    doAnswer(new Answer<Void>(){
      private long lastId=-1;
      private long lastTs=-1;
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        long id=(Long)invocation.getArguments()[0];
        long ts=(Long)invocation.getArguments()[1];
        assertTrue(id > lastId);
        assertTrue(ts >= lastTs);
        assertTrue(ts >= start);
        lastId=id;
        lastTs=ts;
        numCalls.incrementAndGet();
        return null;
      }
    }
).when(execution).triggerCheckpoint(anyLong(),anyLong(),any(CheckpointOptions.class));
    CheckpointCoordinator coord=new CheckpointCoordinator(jid,10,200000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{triggerVertex},new ExecutionVertex[]{ackVertex},new ExecutionVertex[]{commitVertex},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
    coord.startCheckpointScheduler();
    long timeout=System.currentTimeMillis() + 60000;
    do {
      Thread.sleep(20);
    }
 while (timeout > System.currentTimeMillis() && numCalls.get() < 5);
    assertTrue(numCalls.get() >= 5);
    coord.stopCheckpointScheduler();
    int numCallsSoFar=numCalls.get();
    Thread.sleep(400);
    assertTrue(numCallsSoFar == numCalls.get() || numCallsSoFar + 1 == numCalls.get());
    numCalls.set(0);
    coord.startCheckpointScheduler();
    timeout=System.currentTimeMillis() + 60000;
    do {
      Thread.sleep(20);
    }
 while (timeout > System.currentTimeMillis() && numCalls.get() < 5);
    assertTrue(numCalls.get() >= 5);
    coord.stopCheckpointScheduler();
    numCallsSoFar=numCalls.get();
    Thread.sleep(400);
    assertTrue(numCallsSoFar == numCalls.get() || numCallsSoFar + 1 == numCalls.get());
    coord.shutdown(JobStatus.FINISHED);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
