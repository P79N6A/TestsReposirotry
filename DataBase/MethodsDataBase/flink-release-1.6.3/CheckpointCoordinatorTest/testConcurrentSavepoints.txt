/** 
 * Tests that the savepoints can be triggered concurrently.
 */
@Test public void testConcurrentSavepoints() throws Exception {
  JobID jobId=new JobID();
  final ExecutionAttemptID attemptID1=new ExecutionAttemptID();
  ExecutionVertex vertex1=mockExecutionVertex(attemptID1);
  StandaloneCheckpointIDCounter checkpointIDCounter=new StandaloneCheckpointIDCounter();
  CheckpointCoordinator coord=new CheckpointCoordinator(jobId,100000,200000,0L,1,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},checkpointIDCounter,new StandaloneCompletedCheckpointStore(2),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
  List<CompletableFuture<CompletedCheckpoint>> savepointFutures=new ArrayList<>();
  int numSavepoints=5;
  String savepointDir=tmpFolder.newFolder().getAbsolutePath();
  for (int i=0; i < numSavepoints; i++) {
    savepointFutures.add(coord.triggerSavepoint(i,savepointDir));
  }
  for (  CompletableFuture<CompletedCheckpoint> savepointFuture : savepointFutures) {
    assertFalse(savepointFuture.isDone());
  }
  long checkpointId=checkpointIDCounter.getLast();
  for (int i=0; i < numSavepoints; i++, checkpointId--) {
    coord.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId,attemptID1,checkpointId));
  }
  for (  CompletableFuture<CompletedCheckpoint> savepointFuture : savepointFutures) {
    assertTrue(savepointFuture.isDone());
  }
}
