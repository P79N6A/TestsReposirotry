/** 
 * Tests that the pending checkpoint stats callbacks are created.
 */
@Test public void testCheckpointStatsTrackerPendingCheckpointCallback(){
  final long timestamp=System.currentTimeMillis();
  ExecutionVertex vertex1=mockExecutionVertex(new ExecutionAttemptID());
  CheckpointCoordinator coord=new CheckpointCoordinator(new JobID(),600000,600000,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new ExecutionVertex[]{vertex1},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
  CheckpointStatsTracker tracker=mock(CheckpointStatsTracker.class);
  coord.setCheckpointStatsTracker(tracker);
  when(tracker.reportPendingCheckpoint(anyLong(),anyLong(),any(CheckpointProperties.class))).thenReturn(mock(PendingCheckpointStats.class));
  assertTrue(coord.triggerCheckpoint(timestamp,false));
  verify(tracker,times(1)).reportPendingCheckpoint(eq(1L),eq(timestamp),eq(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)));
}
