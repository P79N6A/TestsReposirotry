@Test public void testMergeConsecutiveWindows(){
  MergingWindowAssigner.MergeCallback callback=mock(MergingWindowAssigner.MergeCallback.class);
  SessionWindowTimeGapExtractor extractor=mock(SessionWindowTimeGapExtractor.class);
  when(extractor.extract(any())).thenReturn(5000L);
  DynamicProcessingTimeSessionWindows assigner=DynamicProcessingTimeSessionWindows.withDynamicGap(extractor);
  assigner.mergeWindows(Lists.newArrayList(new TimeWindow(0,1),new TimeWindow(1,2),new TimeWindow(2,3),new TimeWindow(4,5),new TimeWindow(5,6)),callback);
  verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(0,1),new TimeWindow(1,2),new TimeWindow(2,3))),eq(new TimeWindow(0,3)));
  verify(callback,times(1)).merge((Collection<TimeWindow>)argThat(containsInAnyOrder(new TimeWindow(4,5),new TimeWindow(5,6))),eq(new TimeWindow(4,6)));
  verify(callback,times(2)).merge(anyCollection(),Matchers.anyObject());
}
