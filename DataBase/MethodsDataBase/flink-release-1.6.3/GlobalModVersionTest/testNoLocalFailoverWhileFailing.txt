/** 
 * Tests that failures during a global failover are not handed to the local failover strategy.
 */
@Test public void testNoLocalFailoverWhileFailing() throws Exception {
  final FailoverStrategy mockStrategy=mock(FailoverStrategy.class);
  final ExecutionGraph graph=createSampleGraph(mockStrategy);
  final ExecutionVertex testVertex=getRandomVertex(graph);
  graph.scheduleForExecution();
  assertEquals(JobStatus.RUNNING,graph.getState());
  for (  ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {
    final Execution exec=v.getCurrentExecutionAttempt();
    waitUntilExecutionState(exec,ExecutionState.DEPLOYING,1000);
    exec.switchToRunning();
    assertEquals(ExecutionState.RUNNING,exec.getState());
  }
  graph.failGlobal(new Exception("global failover"));
  assertEquals(JobStatus.FAILING,graph.getState());
  assertEquals(2L,graph.getGlobalModVersion());
  graph.failGlobal(new Exception("should be ignored"));
  assertEquals(JobStatus.FAILING,graph.getState());
  assertEquals(2L,graph.getGlobalModVersion());
  for (  ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {
    final Execution exec=v.getCurrentExecutionAttempt();
    assertEquals(ExecutionState.CANCELING,exec.getState());
  }
  testVertex.getCurrentExecutionAttempt().fail(new Exception("test exception"));
  for (  ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {
    final Execution exec=v.getCurrentExecutionAttempt();
    exec.cancelingComplete();
  }
  assertEquals(JobStatus.RESTARTING,graph.getState());
  verify(mockStrategy,times(0)).onTaskFailure(any(Execution.class),any(Throwable.class));
}
