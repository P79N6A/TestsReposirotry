/** 
 * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint, it should be rethrown; we set a timeout because the test will not finish if the logic is broken. <p>Note that this test does not test the snapshot method is blocked correctly when there are pending records. The test for that is covered in testAtLeastOnceProducer.
 */
@SuppressWarnings("ResultOfMethodCallIgnored") @Test(timeout=10000) public void testAsyncErrorRethrownAfterFlush() throws Throwable {
  final DummyFlinkKinesisProducer<String> producer=new DummyFlinkKinesisProducer<>(new SimpleStringSchema());
  OneInputStreamOperatorTestHarness<String,Object> testHarness=new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer));
  testHarness.open();
  testHarness.processElement(new StreamRecord<>("msg-1"));
  testHarness.processElement(new StreamRecord<>("msg-2"));
  testHarness.processElement(new StreamRecord<>("msg-3"));
  UserRecordResult result=mock(UserRecordResult.class);
  when(result.isSuccessful()).thenReturn(true);
  producer.getPendingRecordFutures().get(0).set(result);
  CheckedThread snapshotThread=new CheckedThread(){
    @Override public void go() throws Exception {
      testHarness.snapshot(123L,123L);
    }
  }
;
  snapshotThread.start();
  producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"));
  producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class));
  try {
    snapshotThread.sync();
  }
 catch (  Exception e) {
    Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e,"artificial async failure for 2nd message").isPresent());
    return;
  }
  Assert.fail();
}
