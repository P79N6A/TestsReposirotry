@Test public void testImmediateShutdown() throws Exception {
  final Object lock=new Object();
  final AtomicReference<Throwable> errorRef=new AtomicReference<>();
  final SystemProcessingTimeService timer=new SystemProcessingTimeService(new ReferenceSettingExceptionHandler(errorRef),lock);
  try {
    assertFalse(timer.isTerminated());
    final OneShotLatch latch=new OneShotLatch();
    timer.registerTimer(System.currentTimeMillis(),new ProcessingTimeCallback(){
      @Override public void onProcessingTime(      long timestamp) throws Exception {
        latch.trigger();
        Thread.sleep(100000000);
      }
    }
);
    latch.await();
    timer.shutdownService();
synchronized (lock) {
      assertTrue(timer.isTerminated());
    }
    try {
      timer.registerTimer(System.currentTimeMillis() + 1000,new ProcessingTimeCallback(){
        @Override public void onProcessingTime(        long timestamp){
        }
      }
);
      fail("should result in an exception");
    }
 catch (    IllegalStateException e) {
    }
    try {
      timer.scheduleAtFixedRate(new ProcessingTimeCallback(){
        @Override public void onProcessingTime(        long timestamp){
        }
      }
,0L,100L);
      fail("should result in an exception");
    }
 catch (    IllegalStateException e) {
    }
    assertNotNull(errorRef.get());
    assertTrue(errorRef.get().getCause() instanceof InterruptedException);
    assertEquals(0,timer.getNumTasksScheduled());
  }
  finally {
    timer.shutdownService();
  }
}
