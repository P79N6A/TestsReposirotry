/** 
 * Verifies that  {@link NetworkEnvironment#registerTask(Task)} sets up (un)bounded buffer poolinstances for various types of input and output channels.
 */
@Test public void testRegisterTaskUsesBoundedBuffers() throws Exception {
  final NetworkEnvironment network=new NetworkEnvironment(numBuffers,memorySegmentSize,0,0,2,8,enableCreditBasedFlowControl);
  ResultPartition rp1=createResultPartition(ResultPartitionType.PIPELINED,2);
  ResultPartition rp2=createResultPartition(ResultPartitionType.BLOCKING,2);
  ResultPartition rp3=createResultPartition(ResultPartitionType.PIPELINED_BOUNDED,2);
  ResultPartition rp4=createResultPartition(ResultPartitionType.PIPELINED_BOUNDED,8);
  final ResultPartition[] resultPartitions=new ResultPartition[]{rp1,rp2,rp3,rp4};
  SingleInputGate ig1=createSingleInputGate(ResultPartitionType.PIPELINED,2);
  SingleInputGate ig2=createSingleInputGate(ResultPartitionType.BLOCKING,2);
  SingleInputGate ig3=createSingleInputGate(ResultPartitionType.PIPELINED_BOUNDED,2);
  SingleInputGate ig4=createSingleInputGate(ResultPartitionType.PIPELINED_BOUNDED,8);
  final SingleInputGate[] inputGates=new SingleInputGate[]{ig1,ig2,ig3,ig4};
  Task task=mock(Task.class);
  when(task.getProducedPartitions()).thenReturn(resultPartitions);
  when(task.getAllInputGates()).thenReturn(inputGates);
  network.registerTask(task);
  assertEquals(rp1.getNumberOfSubpartitions(),rp1.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(rp2.getNumberOfSubpartitions(),rp2.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(rp3.getNumberOfSubpartitions(),rp3.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(rp4.getNumberOfSubpartitions(),rp4.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(Integer.MAX_VALUE,rp1.getBufferPool().getMaxNumberOfMemorySegments());
  assertEquals(Integer.MAX_VALUE,rp2.getBufferPool().getMaxNumberOfMemorySegments());
  assertEquals(2 * 2 + 8,rp3.getBufferPool().getMaxNumberOfMemorySegments());
  assertEquals(8 * 2 + 8,rp4.getBufferPool().getMaxNumberOfMemorySegments());
  assertEquals(enableCreditBasedFlowControl ? 0 : 2,ig1.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(enableCreditBasedFlowControl ? 0 : 2,ig2.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(enableCreditBasedFlowControl ? 0 : 2,ig3.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(enableCreditBasedFlowControl ? 0 : 8,ig4.getBufferPool().getNumberOfRequiredMemorySegments());
  assertEquals(Integer.MAX_VALUE,ig1.getBufferPool().getMaxNumberOfMemorySegments());
  assertEquals(Integer.MAX_VALUE,ig2.getBufferPool().getMaxNumberOfMemorySegments());
  assertEquals(enableCreditBasedFlowControl ? 8 : 2 * 2 + 8,ig3.getBufferPool().getMaxNumberOfMemorySegments());
  assertEquals(enableCreditBasedFlowControl ? 8 : 8 * 2 + 8,ig4.getBufferPool().getMaxNumberOfMemorySegments());
  int invokations=enableCreditBasedFlowControl ? 1 : 0;
  verify(ig1,times(invokations)).assignExclusiveSegments(network.getNetworkBufferPool(),2);
  verify(ig2,times(invokations)).assignExclusiveSegments(network.getNetworkBufferPool(),2);
  verify(ig3,times(invokations)).assignExclusiveSegments(network.getNetworkBufferPool(),2);
  verify(ig4,times(invokations)).assignExclusiveSegments(network.getNetworkBufferPool(),2);
  for (  ResultPartition rp : resultPartitions) {
    rp.release();
  }
  for (  SingleInputGate ig : inputGates) {
    ig.releaseAllResources();
  }
  network.shutdown();
}
