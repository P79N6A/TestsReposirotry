@Test public void testIterativeWithPrevPatternDependencyAfterBranching() throws Exception {
  List<StreamRecord<Event>> inputEvents=new ArrayList<>();
  inputEvents.add(new StreamRecord<>(startEvent1,1L));
  inputEvents.add(new StreamRecord<>(startEvent2,2L));
  inputEvents.add(new StreamRecord<Event>(middleEvent1,4L));
  inputEvents.add(new StreamRecord<>(startEvent3,5L));
  inputEvents.add(new StreamRecord<Event>(middleEvent2,6L));
  inputEvents.add(new StreamRecord<>(endEvent,7L));
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=6215754202506583964L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("start");
    }
  }
).oneOrMore().followedByAny("middle1").subtype(SubEvent.class).where(new SimpleCondition<SubEvent>(){
    private static final long serialVersionUID=2178338526904474690L;
    @Override public boolean filter(    SubEvent value) throws Exception {
      return value.getName().startsWith("foo");
    }
  }
).followedByAny("end").where(new IterativeCondition<Event>(){
    private static final long serialVersionUID=7056763917392056548L;
    @Override public boolean filter(    Event value,    Context<Event> ctx) throws Exception {
      if (!value.getName().equals("end")) {
        return false;
      }
      double sum=0.0;
      for (      Event event : ctx.getEventsForPattern("start")) {
        sum+=event.getPrice();
      }
      return Double.compare(sum,2.0) >= 0;
    }
  }
);
  NFA<Event> nfa=compile(pattern,false);
  List<List<Event>> resultingPatterns=feedNFA(inputEvents,nfa);
  compareMaps(resultingPatterns,Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1,startEvent2,middleEvent1,endEvent),Lists.newArrayList(startEvent2,middleEvent1,endEvent),Lists.newArrayList(startEvent1,startEvent2,middleEvent2,endEvent),Lists.newArrayList(startEvent1,startEvent2,startEvent3,middleEvent2,endEvent),Lists.newArrayList(startEvent2,startEvent3,middleEvent2,endEvent),Lists.newArrayList(startEvent2,middleEvent2,endEvent),Lists.newArrayList(startEvent3,middleEvent2,endEvent)));
}
