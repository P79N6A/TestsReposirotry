/** 
 * FLINK-6612 Checks that a concurrent checkpoint completion won't discard a checkpoint which has been recovered by a different completed checkpoint store.
 */
@Test public void testConcurrentCheckpointOperations() throws Exception {
  final int numberOfCheckpoints=1;
  final long waitingTimeout=50L;
  ZooKeeperCompletedCheckpointStore zkCheckpointStore1=createCompletedCheckpoints(numberOfCheckpoints);
  ZooKeeperCompletedCheckpointStore zkCheckpointStore2=createCompletedCheckpoints(numberOfCheckpoints);
  SharedStateRegistry sharedStateRegistry=new SharedStateRegistry();
  TestCompletedCheckpoint completedCheckpoint=createCheckpoint(1,sharedStateRegistry);
  zkCheckpointStore1.addCheckpoint(completedCheckpoint);
  sharedStateRegistry.close();
  sharedStateRegistry=new SharedStateRegistry();
  zkCheckpointStore2.recover();
  CompletedCheckpoint recoveredCheckpoint=zkCheckpointStore2.getLatestCheckpoint();
  assertTrue(recoveredCheckpoint instanceof TestCompletedCheckpoint);
  TestCompletedCheckpoint recoveredTestCheckpoint=(TestCompletedCheckpoint)recoveredCheckpoint;
  assertFalse(recoveredTestCheckpoint.isDiscarded());
  TestCompletedCheckpoint completedCheckpoint2=createCheckpoint(2,sharedStateRegistry);
  zkCheckpointStore1.addCheckpoint(completedCheckpoint2);
  List<CompletedCheckpoint> allCheckpoints=zkCheckpointStore1.getAllCheckpoints();
  assertEquals(Collections.singletonList(completedCheckpoint2),allCheckpoints);
  assertFalse("The checkpoint should not have been discarded.",recoveredTestCheckpoint.awaitDiscard(waitingTimeout));
  assertFalse(recoveredTestCheckpoint.isDiscarded());
  TestCompletedCheckpoint completedCheckpoint3=createCheckpoint(3,sharedStateRegistry);
  zkCheckpointStore2.addCheckpoint(completedCheckpoint3);
  recoveredTestCheckpoint.awaitDiscard();
}
