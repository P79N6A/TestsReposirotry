/** 
 * This tests that serializers used for snapshots are duplicates of the ones used in processing to avoid race conditions in stateful serializers.
 */
@Test public void testSerializerDuplicationInSnapshot() throws IOException {
  final TestDuplicateSerializer namespaceSerializer=new TestDuplicateSerializer();
  final TestDuplicateSerializer stateSerializer=new TestDuplicateSerializer();
  final TestDuplicateSerializer keySerializer=new TestDuplicateSerializer();
  RegisteredKeyValueStateBackendMetaInfo<Integer,Integer> metaInfo=new RegisteredKeyValueStateBackendMetaInfo<>(StateDescriptor.Type.VALUE,"test",namespaceSerializer,stateSerializer);
  final KeyGroupRange keyGroupRange=new KeyGroupRange(0,0);
  InternalKeyContext<Integer> mockKeyContext=new InternalKeyContext<Integer>(){
    @Override public Integer getCurrentKey(){
      return 0;
    }
    @Override public int getCurrentKeyGroupIndex(){
      return 0;
    }
    @Override public int getNumberOfKeyGroups(){
      return 1;
    }
    @Override public KeyGroupRange getKeyGroupRange(){
      return keyGroupRange;
    }
    @Override public TypeSerializer<Integer> getKeySerializer(){
      return keySerializer;
    }
  }
;
  CopyOnWriteStateTable<Integer,Integer,Integer> table=new CopyOnWriteStateTable<>(mockKeyContext,metaInfo);
  table.put(0,0,0,0);
  table.put(1,0,0,1);
  table.put(2,0,1,2);
  final CopyOnWriteStateTableSnapshot<Integer,Integer,Integer> snapshot=table.stateSnapshot();
  try {
    final StateSnapshot.StateKeyGroupWriter partitionedSnapshot=snapshot.getKeyGroupWriter();
    namespaceSerializer.disable();
    keySerializer.disable();
    stateSerializer.disable();
    partitionedSnapshot.writeStateInKeyGroup(new DataOutputViewStreamWrapper(new ByteArrayOutputStreamWithPos(1024)),0);
  }
  finally {
    table.releaseSnapshot(snapshot);
  }
}
