/** 
 * Verifies that concurrent release via the SingleInputGate and re-triggering of a partition request works smoothly. <ul> <li>SingleInputGate acquires its request lock and tries to release all registered channels. When releasing a channel, it needs to acquire the channel's shared request-release lock.</li> <li>If a LocalInputChannel concurrently retriggers a partition request via a Timer Thread it acquires the channel's request-release lock and calls the retrigger callback on the SingleInputGate, which again tries to acquire the gate's request lock.</li> </ul> <p>For certain timings this obviously leads to a deadlock. This test reliably reproduced such a timing (reported in FLINK-5228). This test is pretty much testing the buggy implementation and has not much more general value. If it becomes obsolete at some point (future greatness ;)), feel free to remove it. <p>The fix in the end was to to not acquire the channels lock when releasing it and/or not doing any input gate callbacks while holding the channel's lock. I decided to do both.
 */
@Test public void testConcurrentReleaseAndRetriggerPartitionRequest() throws Exception {
  final SingleInputGate gate=new SingleInputGate("test task name",new JobID(),new IntermediateDataSetID(),ResultPartitionType.PIPELINED,0,1,mock(TaskActions.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(),true);
  ResultPartitionManager partitionManager=mock(ResultPartitionManager.class);
  when(partitionManager.createSubpartitionView(any(ResultPartitionID.class),anyInt(),any(BufferAvailabilityListener.class))).thenAnswer(new Answer<ResultSubpartitionView>(){
    @Override public ResultSubpartitionView answer(    InvocationOnMock invocationOnMock) throws Throwable {
      Thread.sleep(100);
      throw new PartitionNotFoundException(new ResultPartitionID());
    }
  }
);
  final LocalInputChannel channel=new LocalInputChannel(gate,0,new ResultPartitionID(),partitionManager,new TaskEventDispatcher(),1,1,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup());
  gate.setInputChannel(new IntermediateResultPartitionID(),channel);
  Thread releaser=new Thread(){
    @Override public void run(){
      try {
        gate.releaseAllResources();
      }
 catch (      IOException ignored) {
      }
    }
  }
;
  Thread requester=new Thread(){
    @Override public void run(){
      try {
        channel.requestSubpartition(0);
      }
 catch (      IOException|InterruptedException ignored) {
      }
    }
  }
;
  requester.start();
  releaser.start();
  releaser.join();
  requester.join();
}
