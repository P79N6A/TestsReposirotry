@Test public void testBranchingPatternMixedFollowedBy() throws Exception {
  List<StreamRecord<Event>> inputEvents=new ArrayList<>();
  Event startEvent=new Event(40,"start",1.0);
  SubEvent middleEvent1=new SubEvent(41,"foo1",1.0,10.0);
  SubEvent middleEvent2=new SubEvent(42,"foo2",1.0,10.0);
  SubEvent middleEvent3=new SubEvent(43,"foo3",1.0,10.0);
  SubEvent nextOne1=new SubEvent(44,"next-one",1.0,2.0);
  SubEvent nextOne2=new SubEvent(45,"next-one",1.0,2.0);
  Event endEvent=new Event(46,"end",1.0);
  inputEvents.add(new StreamRecord<>(startEvent,1));
  inputEvents.add(new StreamRecord<Event>(middleEvent1,3));
  inputEvents.add(new StreamRecord<Event>(middleEvent2,4));
  inputEvents.add(new StreamRecord<Event>(middleEvent3,5));
  inputEvents.add(new StreamRecord<Event>(nextOne1,6));
  inputEvents.add(new StreamRecord<Event>(nextOne2,7));
  inputEvents.add(new StreamRecord<>(endEvent,8));
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=5726188262756267490L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("start");
    }
  }
).followedByAny("middle-first").subtype(SubEvent.class).where(new SimpleCondition<SubEvent>(){
    private static final long serialVersionUID=6215754202506583964L;
    @Override public boolean filter(    SubEvent value) throws Exception {
      return value.getVolume() > 5.0;
    }
  }
).followedBy("middle-second").subtype(SubEvent.class).where(new SimpleCondition<SubEvent>(){
    private static final long serialVersionUID=6215754202506583964L;
    @Override public boolean filter(    SubEvent value) throws Exception {
      return value.getName().equals("next-one");
    }
  }
).followedByAny("end").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=7056763917392056548L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("end");
    }
  }
);
  NFA<Event> nfa=compile(pattern,false);
  final List<List<Event>> patterns=feedNFA(inputEvents,nfa);
  compareMaps(patterns,Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent,middleEvent1,nextOne1,endEvent),Lists.newArrayList(startEvent,middleEvent2,nextOne1,endEvent),Lists.newArrayList(startEvent,middleEvent3,nextOne1,endEvent)));
}
