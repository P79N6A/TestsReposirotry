/** 
 * Tests that the NFA successfully filters out expired elements with respect to the window length.
 */
@Test public void testSimplePatternWithTimeWindowNFA() throws Exception {
  List<StreamRecord<Event>> events=new ArrayList<>();
  final Event startEvent;
  final Event middleEvent;
  final Event endEvent;
  events.add(new StreamRecord<>(new Event(1,"start",1.0),1));
  events.add(new StreamRecord<>(startEvent=new Event(2,"start",1.0),2));
  events.add(new StreamRecord<>(middleEvent=new Event(3,"middle",1.0),3));
  events.add(new StreamRecord<>(new Event(4,"foobar",1.0),4));
  events.add(new StreamRecord<>(endEvent=new Event(5,"end",1.0),11));
  events.add(new StreamRecord<>(new Event(6,"end",1.0),13));
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=7907391379273505897L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("start");
    }
  }
).followedBy("middle").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=-3268741540234334074L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("middle");
    }
  }
).followedBy("end").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=-8995174172182138608L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("end");
    }
  }
).within(Time.milliseconds(10));
  NFA<Event> nfa=compile(pattern,false);
  List<List<Event>> resultingPatterns=feedNFA(events,nfa);
  compareMaps(resultingPatterns,Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent,middleEvent,endEvent)));
}
