/** 
 * Tests that the NFA successfully returns partially matched event sequences when they've timed out.
 */
@Test public void testSimplePatternWithTimeoutHandling() throws Exception {
  List<StreamRecord<Event>> events=new ArrayList<>();
  List<Map<String,List<Event>>> resultingPatterns=new ArrayList<>();
  Set<Tuple2<Map<String,List<Event>>,Long>> resultingTimeoutPatterns=new HashSet<>();
  Set<Tuple2<Map<String,List<Event>>,Long>> expectedTimeoutPatterns=new HashSet<>();
  events.add(new StreamRecord<>(new Event(1,"start",1.0),1));
  events.add(new StreamRecord<>(new Event(2,"start",1.0),2));
  events.add(new StreamRecord<>(new Event(3,"middle",1.0),3));
  events.add(new StreamRecord<>(new Event(4,"foobar",1.0),4));
  events.add(new StreamRecord<>(new Event(5,"end",1.0),11));
  events.add(new StreamRecord<>(new Event(6,"end",1.0),13));
  Map<String,List<Event>> timeoutPattern1=new HashMap<>();
  timeoutPattern1.put("start",Collections.singletonList(new Event(1,"start",1.0)));
  timeoutPattern1.put("middle",Collections.singletonList(new Event(3,"middle",1.0)));
  Map<String,List<Event>> timeoutPattern2=new HashMap<>();
  timeoutPattern2.put("start",Collections.singletonList(new Event(2,"start",1.0)));
  timeoutPattern2.put("middle",Collections.singletonList(new Event(3,"middle",1.0)));
  Map<String,List<Event>> timeoutPattern3=new HashMap<>();
  timeoutPattern3.put("start",Collections.singletonList(new Event(1,"start",1.0)));
  Map<String,List<Event>> timeoutPattern4=new HashMap<>();
  timeoutPattern4.put("start",Collections.singletonList(new Event(2,"start",1.0)));
  expectedTimeoutPatterns.add(Tuple2.of(timeoutPattern1,11L));
  expectedTimeoutPatterns.add(Tuple2.of(timeoutPattern2,13L));
  expectedTimeoutPatterns.add(Tuple2.of(timeoutPattern3,11L));
  expectedTimeoutPatterns.add(Tuple2.of(timeoutPattern4,13L));
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=7907391379273505897L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("start");
    }
  }
).followedByAny("middle").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=-3268741540234334074L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("middle");
    }
  }
).followedByAny("end").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=-8995174172182138608L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("end");
    }
  }
).within(Time.milliseconds(10));
  NFA<Event> nfa=compile(pattern,true);
  NFAState nfaState=nfa.createInitialNFAState();
  for (  StreamRecord<Event> event : events) {
    Collection<Tuple2<Map<String,List<Event>>,Long>> timeoutPatterns=nfa.advanceTime(sharedBuffer,nfaState,event.getTimestamp());
    Collection<Map<String,List<Event>>> matchedPatterns=nfa.process(sharedBuffer,nfaState,event.getValue(),event.getTimestamp());
    resultingPatterns.addAll(matchedPatterns);
    resultingTimeoutPatterns.addAll(timeoutPatterns);
  }
  assertEquals(1,resultingPatterns.size());
  assertEquals(expectedTimeoutPatterns.size(),resultingTimeoutPatterns.size());
  assertEquals(expectedTimeoutPatterns,resultingTimeoutPatterns);
}
