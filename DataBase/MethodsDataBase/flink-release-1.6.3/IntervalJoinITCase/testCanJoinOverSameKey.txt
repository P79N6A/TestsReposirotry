@Test public void testCanJoinOverSameKey() throws Exception {
  final StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
  env.setParallelism(1);
  KeyedStream<Tuple2<String,Integer>,String> streamOne=env.fromElements(Tuple2.of("key",0),Tuple2.of("key",1),Tuple2.of("key",2),Tuple2.of("key",3),Tuple2.of("key",4),Tuple2.of("key",5)).assignTimestampsAndWatermarks(new AscendingTuple2TimestampExtractor()).keyBy(new Tuple2KeyExtractor());
  KeyedStream<Tuple2<String,Integer>,String> streamTwo=env.fromElements(Tuple2.of("key",0),Tuple2.of("key",1),Tuple2.of("key",2),Tuple2.of("key",3),Tuple2.of("key",4),Tuple2.of("key",5)).assignTimestampsAndWatermarks(new AscendingTuple2TimestampExtractor()).keyBy(new Tuple2KeyExtractor());
  streamOne.intervalJoin(streamTwo).between(Time.milliseconds(0),Time.milliseconds(0)).process(new ProcessJoinFunction<Tuple2<String,Integer>,Tuple2<String,Integer>,String>(){
    @Override public void processElement(    Tuple2<String,Integer> left,    Tuple2<String,Integer> right,    Context ctx,    Collector<String> out) throws Exception {
      out.collect(left + ":" + right);
    }
  }
).addSink(new ResultSink());
  env.execute();
  expectInAnyOrder("(key,0):(key,0)","(key,1):(key,1)","(key,2):(key,2)","(key,3):(key,3)","(key,4):(key,4)","(key,5):(key,5)");
}
