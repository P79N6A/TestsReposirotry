@Test public void testRetryConnectOnFailure() throws Exception {
  final String testId="laissez les bon temps roulez";
  final UUID leaderId=UUID.randomUUID();
  ExecutorService executor=TestingUtils.defaultExecutor();
  TestRegistrationGateway testGateway=new TestRegistrationGateway(new TestRegistrationSuccess(testId));
  try {
    RpcService rpc=mock(RpcService.class);
    when(rpc.connect(anyString(),any(Class.class))).thenReturn(FutureUtils.completedExceptionally(new Exception("test connect failure")),CompletableFuture.completedFuture(testGateway));
    when(rpc.getExecutor()).thenReturn(executor);
    when(rpc.scheduleRunnable(any(Runnable.class),anyLong(),any(TimeUnit.class))).thenAnswer((    InvocationOnMock invocation) -> {
      final Runnable runnable=invocation.getArgumentAt(0,Runnable.class);
      final long delay=invocation.getArgumentAt(1,Long.class);
      final TimeUnit timeUnit=invocation.getArgumentAt(2,TimeUnit.class);
      return TestingUtils.defaultScheduledExecutor().schedule(runnable,delay,timeUnit);
    }
);
    TestRetryingRegistration registration=new TestRetryingRegistration(rpc,"foobar address",leaderId);
    long start=System.currentTimeMillis();
    registration.startRegistration();
    Tuple2<TestRegistrationGateway,TestRegistrationSuccess> success=registration.getFuture().get(10L,TimeUnit.SECONDS);
    long duration=System.currentTimeMillis() - start;
    assertTrue("The registration should have failed the first time. Thus the duration should be longer than at least a single error delay.",duration > TestRetryingRegistration.DELAY_ON_ERROR);
    assertEquals(testId,success.f1.getCorrelationId());
    assertEquals(leaderId,testGateway.getInvocations().take().leaderId());
  }
  finally {
    testGateway.stop();
  }
}
