/** 
 * This test checks that are strictly co-located vertices are in the same failover region, even through they are connected via a blocking pattern. This is currently an assumption / limitation of the scheduler.
 */
@Test public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception {
  final JobVertex source=new JobVertex("source");
  source.setInvokableClass(NoOpInvokable.class);
  source.setParallelism(10);
  final JobVertex target=new JobVertex("target");
  target.setInvokableClass(NoOpInvokable.class);
  target.setParallelism(10);
  target.connectNewDataSetAsInput(source,DistributionPattern.POINTWISE,ResultPartitionType.PIPELINED);
  final SlotSharingGroup sharingGroup=new SlotSharingGroup();
  source.setSlotSharingGroup(sharingGroup);
  target.setSlotSharingGroup(sharingGroup);
  source.setStrictlyCoLocatedWith(target);
  final JobGraph jobGraph=new JobGraph("test job",source,target);
  final ExecutionGraph eg=createExecutionGraph(jobGraph);
  RestartPipelinedRegionStrategy failoverStrategy=(RestartPipelinedRegionStrategy)eg.getFailoverStrategy();
  FailoverRegion sourceRegion1=failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0]);
  FailoverRegion sourceRegion2=failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[1]);
  FailoverRegion targetRegion1=failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0]);
  FailoverRegion targetRegion2=failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[1]);
  assertTrue(sourceRegion1 == sourceRegion2);
  assertTrue(sourceRegion2 == targetRegion1);
  assertTrue(targetRegion1 == targetRegion2);
}
