/** 
 * Tests that a TaskManager detects a job leader for which it has reserved slots. Upon detecting the job leader, it will offer all reserved slots to the JobManager.
 */
@Test public void testJobLeaderDetection() throws Exception {
  final TaskSlotTable taskSlotTable=new TaskSlotTable(Collections.singleton(ResourceProfile.UNKNOWN),timerService);
  final JobManagerTable jobManagerTable=new JobManagerTable();
  final JobLeaderService jobLeaderService=new JobLeaderService(taskManagerLocation);
  final String resourceManagerAddress="rm";
  final ResourceManagerId resourceManagerLeaderId=ResourceManagerId.generate();
  final TestingResourceManagerGateway resourceManagerGateway=new TestingResourceManagerGateway();
  CompletableFuture<Void> initialSlotReportFuture=new CompletableFuture<>();
  resourceManagerGateway.setSendSlotReportFunction(resourceIDInstanceIDSlotReportTuple3 -> {
    initialSlotReportFuture.complete(null);
    return CompletableFuture.completedFuture(Acknowledge.get());
  }
);
  final String jobManagerAddress="jm";
  final UUID jobManagerLeaderId=UUID.randomUUID();
  final ResourceID jmResourceId=new ResourceID(jobManagerAddress);
  final JobMasterGateway jobMasterGateway=mock(JobMasterGateway.class);
  when(jobMasterGateway.registerTaskManager(any(String.class),eq(taskManagerLocation),any(Time.class))).thenReturn(CompletableFuture.completedFuture(new JMTMRegistrationSuccess(jmResourceId)));
  when(jobMasterGateway.getHostname()).thenReturn(jobManagerAddress);
  when(jobMasterGateway.offerSlots(any(ResourceID.class),any(Collection.class),any(Time.class))).thenReturn(mock(CompletableFuture.class,RETURNS_MOCKS));
  rpc.registerGateway(resourceManagerAddress,resourceManagerGateway);
  rpc.registerGateway(jobManagerAddress,jobMasterGateway);
  final AllocationID allocationId=new AllocationID();
  final SlotID slotId=new SlotID(taskManagerLocation.getResourceID(),0);
  final SlotOffer slotOffer=new SlotOffer(allocationId,0,ResourceProfile.UNKNOWN);
  TaskExecutorLocalStateStoresManager localStateStoresManager=new TaskExecutorLocalStateStoresManager(false,new File[]{tmp.newFolder()},Executors.directExecutor());
  final TaskManagerServices taskManagerServices=new TaskManagerServicesBuilder().setTaskManagerLocation(taskManagerLocation).setTaskSlotTable(taskSlotTable).setJobManagerTable(jobManagerTable).setJobLeaderService(jobLeaderService).setTaskStateManager(localStateStoresManager).build();
  TaskExecutor taskManager=new TaskExecutor(rpc,taskManagerConfiguration,haServices,taskManagerServices,new HeartbeatServices(1000L,1000L),UnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),dummyBlobCacheService,testingFatalErrorHandler);
  try {
    taskManager.start();
    final TaskExecutorGateway tmGateway=taskManager.getSelfGateway(TaskExecutorGateway.class);
    resourceManagerLeaderRetriever.notifyListener(resourceManagerAddress,resourceManagerLeaderId.toUUID());
    initialSlotReportFuture.get();
    CompletableFuture<Acknowledge> slotRequestAck=tmGateway.requestSlot(slotId,jobId,allocationId,jobManagerAddress,resourceManagerLeaderId,timeout);
    slotRequestAck.get();
    jobManagerLeaderRetriever.notifyListener(jobManagerAddress,jobManagerLeaderId);
    verify(jobMasterGateway,Mockito.timeout(timeout.toMilliseconds())).offerSlots(any(ResourceID.class),(Collection<SlotOffer>)Matchers.argThat(contains(slotOffer)),any(Time.class));
  }
  finally {
    RpcUtils.terminateRpcEndpoint(taskManager,timeout);
  }
}
