/** 
 * Tests that we ignore slot requests if the TaskExecutor is not registered at a ResourceManager.
 */
@Test public void testIgnoringSlotRequestsIfNotRegistered() throws Exception {
  final TaskSlotTable taskSlotTable=new TaskSlotTable(Collections.singleton(ResourceProfile.UNKNOWN),timerService);
  final TaskManagerServices taskManagerServices=new TaskManagerServicesBuilder().setTaskSlotTable(taskSlotTable).build();
  final TaskExecutor taskExecutor=createTaskExecutor(taskManagerServices);
  taskExecutor.start();
  try {
    final TestingResourceManagerGateway testingResourceManagerGateway=new TestingResourceManagerGateway();
    final CompletableFuture<RegistrationResponse> registrationFuture=new CompletableFuture<>();
    final CompletableFuture<ResourceID> taskExecutorResourceIdFuture=new CompletableFuture<>();
    testingResourceManagerGateway.setRegisterTaskExecutorFunction(stringResourceIDSlotReportIntegerHardwareDescriptionTuple5 -> {
      taskExecutorResourceIdFuture.complete(stringResourceIDSlotReportIntegerHardwareDescriptionTuple5.f1);
      return registrationFuture;
    }
);
    rpc.registerGateway(testingResourceManagerGateway.getAddress(),testingResourceManagerGateway);
    resourceManagerLeaderRetriever.notifyListener(testingResourceManagerGateway.getAddress(),testingResourceManagerGateway.getFencingToken().toUUID());
    final TaskExecutorGateway taskExecutorGateway=taskExecutor.getSelfGateway(TaskExecutorGateway.class);
    final ResourceID resourceId=taskExecutorResourceIdFuture.get();
    final SlotID slotId=new SlotID(resourceId,0);
    final CompletableFuture<Acknowledge> slotRequestResponse=taskExecutorGateway.requestSlot(slotId,jobId,new AllocationID(),"foobar",testingResourceManagerGateway.getFencingToken(),timeout);
    try {
      slotRequestResponse.get();
      fail("We should not be able to request slots before the TaskExecutor is registered at the ResourceManager.");
    }
 catch (    ExecutionException ee) {
      assertThat(ExceptionUtils.stripExecutionException(ee),instanceOf(TaskManagerException.class));
    }
  }
  finally {
    RpcUtils.terminateRpcEndpoint(taskExecutor,timeout);
  }
}
