/** 
 * Tests that we can submit a task to the TaskManager given that we've allocated a slot there.
 */
@Test(timeout=10000L) public void testTaskSubmission() throws Exception {
  final AllocationID allocationId=new AllocationID();
  final JobMasterId jobMasterId=JobMasterId.generate();
  final JobVertexID jobVertexId=new JobVertexID();
  JobInformation jobInformation=new JobInformation(jobId,name.getMethodName(),new SerializedValue<>(new ExecutionConfig()),new Configuration(),Collections.emptyList(),Collections.emptyList());
  TaskInformation taskInformation=new TaskInformation(jobVertexId,"test task",1,1,TestInvokable.class.getName(),new Configuration());
  SerializedValue<JobInformation> serializedJobInformation=new SerializedValue<>(jobInformation);
  SerializedValue<TaskInformation> serializedJobVertexInformation=new SerializedValue<>(taskInformation);
  final TaskDeploymentDescriptor tdd=new TaskDeploymentDescriptor(jobId,new TaskDeploymentDescriptor.NonOffloaded<>(serializedJobInformation),new TaskDeploymentDescriptor.NonOffloaded<>(serializedJobVertexInformation),new ExecutionAttemptID(),allocationId,0,0,0,null,Collections.emptyList(),Collections.emptyList());
  final LibraryCacheManager libraryCacheManager=mock(LibraryCacheManager.class);
  when(libraryCacheManager.getClassLoader(any(JobID.class))).thenReturn(ClassLoader.getSystemClassLoader());
  final JobMasterGateway jobMasterGateway=mock(JobMasterGateway.class);
  when(jobMasterGateway.getFencingToken()).thenReturn(jobMasterId);
  final JobManagerConnection jobManagerConnection=new JobManagerConnection(jobId,ResourceID.generate(),jobMasterGateway,mock(TaskManagerActions.class),mock(CheckpointResponder.class),libraryCacheManager,new NoOpResultPartitionConsumableNotifier(),mock(PartitionProducerStateChecker.class));
  final JobManagerTable jobManagerTable=new JobManagerTable();
  jobManagerTable.put(jobId,jobManagerConnection);
  final TaskSlotTable taskSlotTable=mock(TaskSlotTable.class);
  when(taskSlotTable.tryMarkSlotActive(eq(jobId),eq(allocationId))).thenReturn(true);
  when(taskSlotTable.addTask(any(Task.class))).thenReturn(true);
  TaskEventDispatcher taskEventDispatcher=new TaskEventDispatcher();
  final NetworkEnvironment networkEnvironment=mock(NetworkEnvironment.class);
  when(networkEnvironment.createKvStateTaskRegistry(eq(jobId),eq(jobVertexId))).thenReturn(mock(TaskKvStateRegistry.class));
  when(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
  TaskExecutorLocalStateStoresManager localStateStoresManager=new TaskExecutorLocalStateStoresManager(false,new File[]{tmp.newFolder()},Executors.directExecutor());
  final TaskManagerServices taskManagerServices=new TaskManagerServicesBuilder().setNetworkEnvironment(networkEnvironment).setTaskSlotTable(taskSlotTable).setJobManagerTable(jobManagerTable).setTaskStateManager(localStateStoresManager).build();
  TaskExecutor taskManager=new TaskExecutor(rpc,taskManagerConfiguration,haServices,taskManagerServices,new HeartbeatServices(1000L,1000L),UnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),dummyBlobCacheService,testingFatalErrorHandler);
  try {
    taskManager.start();
    final TaskExecutorGateway tmGateway=taskManager.getSelfGateway(TaskExecutorGateway.class);
    tmGateway.submitTask(tdd,jobMasterId,timeout);
    CompletableFuture<Boolean> completionFuture=TestInvokable.COMPLETABLE_FUTURE;
    completionFuture.get();
  }
  finally {
    taskManager.shutDown();
    taskManager.getTerminationFuture().get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
  }
}
