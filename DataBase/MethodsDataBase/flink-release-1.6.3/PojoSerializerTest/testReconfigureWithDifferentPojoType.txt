/** 
 * Verifies that reconfiguring with a config snapshot of a preceding POJO serializer with different POJO type will result in INCOMPATIBLE.
 */
@Test public void testReconfigureWithDifferentPojoType() throws Exception {
  PojoSerializer<SubTestUserClassB> pojoSerializer1=(PojoSerializer<SubTestUserClassB>)TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig());
  TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot=pojoSerializer1.snapshotConfiguration();
  byte[] serializedConfig;
  try (ByteArrayOutputStream out=new ByteArrayOutputStream()){
    TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out),pojoSerializerConfigSnapshot);
    serializedConfig=out.toByteArray();
  }
   PojoSerializer<SubTestUserClassA> pojoSerializer2=(PojoSerializer<SubTestUserClassA>)TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig());
  try (ByteArrayInputStream in=new ByteArrayInputStream(serializedConfig)){
    pojoSerializerConfigSnapshot=TypeSerializerSerializationUtil.readSerializerConfigSnapshot(new DataInputViewStreamWrapper(in),Thread.currentThread().getContextClassLoader());
  }
   CompatibilityResult<SubTestUserClassA> compatResult=pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot);
  assertTrue(compatResult.isRequiresMigration());
}
