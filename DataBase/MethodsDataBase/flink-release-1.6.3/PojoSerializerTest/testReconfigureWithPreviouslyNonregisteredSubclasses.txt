/** 
 * Tests that: - Previous Pojo serializer did not have registrations, and created cached serializers for subclasses - On restore, it had those subclasses registered In this case, after reconfiguration, the cache should be repopulated, and registrations should also exist for the subclasses. Note: the cache still needs to be repopulated because previous data of those subclasses were written with the cached serializers. In this case, the repopulated cache has reconfigured serializers for the subclasses so that previous written data can be read, but the registered serializers for the subclasses do not necessarily need to be reconfigured since they will only be used to write new data.
 */
@Test public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {
  PojoSerializer<TestUserClass> pojoSerializer=(PojoSerializer<TestUserClass>)type.createSerializer(new ExecutionConfig());
  pojoSerializer.getSubclassSerializer(SubTestUserClassA.class);
  pojoSerializer.getSubclassSerializer(SubTestUserClassB.class);
  assertEquals(2,pojoSerializer.getSubclassSerializerCache().size());
  assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class));
  assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class));
  assertTrue(pojoSerializer.getRegisteredClasses().isEmpty());
  assertEquals(0,pojoSerializer.getRegisteredSerializers().length);
  TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot=pojoSerializer.snapshotConfiguration();
  byte[] serializedConfig;
  try (ByteArrayOutputStream out=new ByteArrayOutputStream()){
    TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out),pojoSerializerConfigSnapshot);
    serializedConfig=out.toByteArray();
  }
   ExecutionConfig newExecutionConfig=new ExecutionConfig();
  newExecutionConfig.registerPojoType(SubTestUserClassA.class);
  newExecutionConfig.registerPojoType(SubTestUserClassB.class);
  pojoSerializer=(PojoSerializer<TestUserClass>)type.createSerializer(newExecutionConfig);
  try (ByteArrayInputStream in=new ByteArrayInputStream(serializedConfig)){
    pojoSerializerConfigSnapshot=TypeSerializerSerializationUtil.readSerializerConfigSnapshot(new DataInputViewStreamWrapper(in),Thread.currentThread().getContextClassLoader());
  }
   CompatibilityResult<TestUserClass> compatResult=pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot);
  assertFalse(compatResult.isRequiresMigration());
  assertEquals(2,pojoSerializer.getSubclassSerializerCache().size());
  assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class));
  assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class));
  assertEquals(2,pojoSerializer.getRegisteredClasses().size());
  assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class));
  assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class));
}
