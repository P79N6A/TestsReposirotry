@Test public void testAndOrSubtypeConditionsAfterMigration() throws Exception {
  KeySelector<Event,Integer> keySelector=new KeySelector<Event,Integer>(){
    private static final long serialVersionUID=-4873366487571254798L;
    @Override public Integer getKey(    Event value) throws Exception {
      return value.getId();
    }
  }
;
  final Event startEvent1=new SubEvent(42,"start",1.0,6.0);
  OneInputStreamOperatorTestHarness<Event,Map<String,List<Event>>> harness=new KeyedOneInputStreamOperatorTestHarness<>(getKeyedCepOpearator(false,new NFAComplexConditionsFactory()),keySelector,BasicTypeInfo.INT_TYPE_INFO);
  try {
    harness.setup();
    MigrationTestUtil.restoreFromSnapshot(harness,OperatorSnapshotUtil.getResourceFilename("cep-migration-conditions-flink" + migrateVersion + "-snapshot"),migrateVersion);
    harness.open();
    final Event endEvent=new SubEvent(42,"end",1.0,2.0);
    harness.processElement(new StreamRecord<>(endEvent,9));
    harness.processWatermark(new Watermark(20));
    ConcurrentLinkedQueue<Object> result=harness.getOutput();
    assertEquals(2,result.size());
    Object resultObject=result.poll();
    assertTrue(resultObject instanceof StreamRecord);
    StreamRecord<?> resultRecord=(StreamRecord<?>)resultObject;
    assertTrue(resultRecord.getValue() instanceof Map);
    @SuppressWarnings("unchecked") Map<String,List<Event>> patternMap=(Map<String,List<Event>>)resultRecord.getValue();
    assertEquals(startEvent1,patternMap.get("start").get(0));
    assertEquals(endEvent,patternMap.get("start").get(1));
  }
  finally {
    harness.close();
  }
}
