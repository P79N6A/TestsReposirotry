/** 
 * Tests that a job cannot be restarted from a savepoint with a different parallelism if the rescaled operator has non-partitioned state.
 * @throws Exception
 */
@Test public void testSavepointRescalingNonPartitionedStateCausesException() throws Exception {
  final int parallelism=numSlots / 2;
  final int parallelism2=numSlots;
  final int maxParallelism=13;
  Duration timeout=Duration.ofMinutes(3);
  Deadline deadline=Deadline.now().plus(timeout);
  ClusterClient<?> client=cluster.getClusterClient();
  try {
    JobGraph jobGraph=createJobGraphWithOperatorState(parallelism,maxParallelism,OperatorCheckpointMethod.NON_PARTITIONED);
    final JobID jobID=jobGraph.getJobID();
    client.setDetached(true);
    client.submitJob(jobGraph,RescalingITCase.class.getClassLoader());
    StateSourceBase.workStartedLatch.await();
    CompletableFuture<String> savepointPathFuture=client.triggerSavepoint(jobID,null);
    final String savepointPath=savepointPathFuture.get(deadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
    client.cancel(jobID);
    while (!getRunningJobs(client).isEmpty()) {
      Thread.sleep(50);
    }
    JobGraph scaledJobGraph=createJobGraphWithOperatorState(parallelism2,maxParallelism,OperatorCheckpointMethod.NON_PARTITIONED);
    scaledJobGraph.setSavepointRestoreSettings(SavepointRestoreSettings.forPath(savepointPath));
    client.setDetached(false);
    client.submitJob(scaledJobGraph,RescalingITCase.class.getClassLoader());
  }
 catch (  JobExecutionException exception) {
    if (exception.getCause() instanceof IllegalStateException) {
    }
 else {
      throw exception;
    }
  }
}
