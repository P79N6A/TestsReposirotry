@Test public void testReapProcessOnFailure() throws Exception {
  Process taskManagerProcess=null;
  ActorSystem jmActorSystem=null;
  final StringWriter processOutput=new StringWriter();
  final Configuration config=new Configuration();
  final String jobManagerHostname="localhost";
  final int jobManagerPort=NetUtils.getAvailablePort();
  config.setString(JobManagerOptions.ADDRESS,jobManagerHostname);
  config.setInteger(JobManagerOptions.PORT,jobManagerPort);
  final HighAvailabilityServices highAvailabilityServices=HighAvailabilityServicesUtils.createHighAvailabilityServices(config,TestingUtils.defaultExecutor(),HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION);
  try {
    String javaCommand=getJavaCommandPath();
    if (javaCommand == null) {
      System.out.println("---- Skipping TaskManagerProcessReapingTest : Could not find java executable ----");
      return;
    }
    File tempLogFile=File.createTempFile("testlogconfig","properties");
    tempLogFile.deleteOnExit();
    CommonTestUtils.printLog4jDebugConfig(tempLogFile);
    Tuple2<String,Object> localAddress=new Tuple2<String,Object>(jobManagerHostname,jobManagerPort);
    jmActorSystem=AkkaUtils.createActorSystem(config,new Some<>(localAddress));
    ActorRef jmActor=JobManager.startJobManagerActors(config,jmActorSystem,TestingUtils.defaultExecutor(),TestingUtils.defaultExecutor(),highAvailabilityServices,NoOpMetricRegistry.INSTANCE,Option.empty(),JobManager.class,MemoryArchivist.class)._1;
    FlinkResourceManager.startResourceManagerActors(new Configuration(),jmActorSystem,highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID),StandaloneResourceManager.class);
    final int taskManagerPort=NetUtils.getAvailablePort();
    String[] command=new String[]{javaCommand,"-Dlog.level=DEBUG","-Dlog4j.configuration=file:" + tempLogFile.getAbsolutePath(),"-Xms256m","-Xmx256m","-classpath",getCurrentClasspath(),TaskManagerTestEntryPoint.class.getName(),String.valueOf(jobManagerPort),String.valueOf(taskManagerPort)};
    ProcessBuilder bld=new ProcessBuilder(command);
    taskManagerProcess=bld.start();
    new PipeForwarder(taskManagerProcess.getErrorStream(),processOutput);
    String taskManagerActorName=String.format("akka.tcp://flink@%s/user/%s","localhost:" + taskManagerPort,TaskExecutor.TASK_MANAGER_NAME);
    ActorRef taskManagerRef=null;
    Throwable lastError=null;
    for (int i=0; i < 40; i++) {
      try {
        taskManagerRef=TaskManager.getTaskManagerRemoteReference(taskManagerActorName,jmActorSystem,new FiniteDuration(25,TimeUnit.SECONDS));
        break;
      }
 catch (      Throwable t) {
        lastError=t;
      }
      Thread.sleep(500);
    }
    assertTrue("TaskManager process died",isProcessAlive(taskManagerProcess));
    if (taskManagerRef == null) {
      if (lastError != null) {
        lastError.printStackTrace();
      }
      fail("TaskManager process did not launch the TaskManager properly. Failed to look up " + taskManagerActorName);
    }
    onTaskManagerProcessRunning(taskManagerRef);
{
      long now=System.currentTimeMillis();
      long deadline=now + 10000;
      while (now < deadline && isProcessAlive(taskManagerProcess)) {
        Thread.sleep(100);
        now=System.currentTimeMillis();
      }
    }
    assertFalse("TaskManager process did not terminate upon actor death",isProcessAlive(taskManagerProcess));
    int returnCode=taskManagerProcess.exitValue();
    assertEquals("TaskManager died, but not because of the process reaper",TaskManager.RUNTIME_FAILURE_RETURN_CODE(),returnCode);
    onTaskManagerProcessTerminated(processOutput.toString());
  }
 catch (  Exception e) {
    e.printStackTrace();
    printProcessLog(processOutput.toString());
    fail(e.getMessage());
  }
catch (  Error e) {
    e.printStackTrace();
    printProcessLog(processOutput.toString());
    throw e;
  }
 finally {
    if (taskManagerProcess != null) {
      taskManagerProcess.destroy();
    }
    if (jmActorSystem != null) {
      jmActorSystem.shutdown();
    }
    if (highAvailabilityServices != null) {
      highAvailabilityServices.closeAndCleanupAllData();
    }
  }
}
