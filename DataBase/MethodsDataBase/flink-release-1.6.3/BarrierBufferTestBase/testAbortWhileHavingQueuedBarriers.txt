/** 
 * This tests the where a replay of queued checkpoint barriers meets a canceled checkpoint. <p>The replayed newer checkpoint barrier must not try to cancel the already canceled checkpoint.
 */
@Test public void testAbortWhileHavingQueuedBarriers() throws Exception {
  BufferOrEvent[] sequence={createBuffer(1,PAGE_SIZE),createBarrier(1,1),createBuffer(2,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBarrier(2,1),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createCancellationBarrier(1,0),createBuffer(2,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(0,PAGE_SIZE),createBarrier(1,2),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE),createBarrier(2,0),createBarrier(2,2),createBuffer(0,PAGE_SIZE),createBuffer(1,PAGE_SIZE),createBuffer(2,PAGE_SIZE)};
  MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
  BarrierBuffer buffer=createBarrierHandler(gate);
  AbstractInvokable toNotify=mock(AbstractInvokable.class);
  buffer.registerCheckpointEventHandler(toNotify);
  long startTs;
  check(sequence[0],buffer.getNextNonBlocked(),PAGE_SIZE);
  startTs=System.nanoTime();
  check(sequence[2],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[3],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[6],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[4],buffer.getNextNonBlocked(),PAGE_SIZE);
  validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
  verify(toNotify).abortCheckpointOnBarrier(eq(1L),any(CheckpointDeclineOnCancellationBarrierException.class));
  startTs=System.nanoTime();
  check(sequence[9],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[11],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[13],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[15],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[7],buffer.getNextNonBlocked(),PAGE_SIZE);
  validateAlignmentTime(startTs,buffer.getAlignmentDurationNanos());
  verify(toNotify).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(2L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
  check(sequence[10],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[14],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[18],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[19],buffer.getNextNonBlocked(),PAGE_SIZE);
  check(sequence[20],buffer.getNextNonBlocked(),PAGE_SIZE);
  assertNull(buffer.getNextNonBlocked());
  assertNull(buffer.getNextNonBlocked());
  buffer.cleanup();
  verify(toNotify,times(1)).triggerCheckpointOnBarrier(any(CheckpointMetaData.class),any(CheckpointOptions.class),any(CheckpointMetrics.class));
  verify(toNotify,times(1)).abortCheckpointOnBarrier(anyLong(),any(Throwable.class));
}
