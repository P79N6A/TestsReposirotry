/** 
 * Tests that concurrent release operations only trigger the failing of the payload and the return of the slot once.
 */
@Test public void testConcurrentReleaseOperations() throws Exception {
  final CountingSlotOwner countingSlotOwner=new CountingSlotOwner();
  final CountingFailPayload countingFailPayload=new CountingFailPayload();
  final SingleLogicalSlot singleLogicalSlot=createSingleLogicalSlot(countingSlotOwner);
  singleLogicalSlot.tryAssignPayload(countingFailPayload);
  final ExecutorService executorService=Executors.newFixedThreadPool(4);
  try {
    final int numberConcurrentOperations=10;
    final Collection<CompletableFuture<?>> releaseOperationFutures=new ArrayList<>(numberConcurrentOperations);
    for (int i=0; i < numberConcurrentOperations; i++) {
      final CompletableFuture<Void> releaseOperationFuture=CompletableFuture.runAsync(() -> {
        try {
          singleLogicalSlot.releaseSlot(new FlinkException("Test exception")).get();
        }
 catch (        InterruptedException|ExecutionException e) {
          ExceptionUtils.checkInterrupted(e);
          throw new CompletionException(e);
        }
      }
);
      releaseOperationFutures.add(releaseOperationFuture);
    }
    final FutureUtils.ConjunctFuture<Void> releaseOperationsFuture=FutureUtils.waitForAll(releaseOperationFutures);
    releaseOperationsFuture.get();
    assertThat(countingSlotOwner.getReleaseCount(),is(1));
    assertThat(countingFailPayload.getFailCount(),is(1));
  }
  finally {
    executorService.shutdownNow();
  }
}
