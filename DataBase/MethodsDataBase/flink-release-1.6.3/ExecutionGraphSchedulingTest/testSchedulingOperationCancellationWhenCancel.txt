/** 
 * Tests that an ongoing scheduling operation does not fail the  {@link ExecutionGraph}if it gets concurrently cancelled
 */
@Test public void testSchedulingOperationCancellationWhenCancel() throws Exception {
  final JobVertex jobVertex=new JobVertex("NoOp JobVertex");
  jobVertex.setInvokableClass(NoOpInvokable.class);
  jobVertex.setParallelism(2);
  final JobGraph jobGraph=new JobGraph(jobVertex);
  jobGraph.setScheduleMode(ScheduleMode.EAGER);
  jobGraph.setAllowQueuedScheduling(true);
  final CompletableFuture<LogicalSlot> slotFuture1=new CompletableFuture<>();
  final CompletableFuture<LogicalSlot> slotFuture2=new CompletableFuture<>();
  final ProgrammedSlotProvider slotProvider=new ProgrammedSlotProvider(2);
  slotProvider.addSlots(jobVertex.getID(),new CompletableFuture[]{slotFuture1,slotFuture2});
  final ExecutionGraph executionGraph=createExecutionGraph(jobGraph,slotProvider);
  executionGraph.scheduleForExecution();
  final CompletableFuture<?> releaseFuture=new CompletableFuture<>();
  final TestingLogicalSlot slot=createTestingSlot(releaseFuture);
  slotFuture1.complete(slot);
  executionGraph.cancel();
  slotFuture2.complete(new TestingLogicalSlot());
  Thread.sleep(1L);
  releaseFuture.complete(null);
  assertThat(executionGraph.getTerminationFuture().get(),is(JobStatus.CANCELED));
}
