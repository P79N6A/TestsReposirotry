/** 
 * Tests that a failing snapshot method call to the keyed state backend will trigger the closing of the StateSnapshotContextSynchronousImpl and the cancellation of the OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.
 */
@Test public void testFailingBackendSnapshotMethod() throws Exception {
  final long checkpointId=42L;
  final long timestamp=1L;
  final Exception failingException=new Exception("Test exception");
  final CloseableRegistry closeableRegistry=new CloseableRegistry();
  RunnableFuture<SnapshotResult<KeyedStateHandle>> futureKeyedStateHandle=mock(RunnableFuture.class);
  RunnableFuture<SnapshotResult<OperatorStateHandle>> futureOperatorStateHandle=mock(RunnableFuture.class);
  StateSnapshotContextSynchronousImpl context=spy(new StateSnapshotContextSynchronousImpl(checkpointId,timestamp));
  when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle);
  when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle);
  OperatorSnapshotFutures operatorSnapshotResult=spy(new OperatorSnapshotFutures());
  whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context);
  whenNew(OperatorSnapshotFutures.class).withAnyArguments().thenReturn(operatorSnapshotResult);
  StreamTask<Void,AbstractStreamOperator<Void>> containingTask=mock(StreamTask.class);
  when(containingTask.getCancelables()).thenReturn(closeableRegistry);
  AbstractStreamOperator<Void> operator=mock(AbstractStreamOperator.class);
  when(operator.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenCallRealMethod();
  doCallRealMethod().when(operator).close();
  doCallRealMethod().when(operator).dispose();
  doReturn(containingTask).when(operator).getContainingTask();
  RunnableFuture<SnapshotResult<OperatorStateHandle>> futureManagedOperatorStateHandle=mock(RunnableFuture.class);
  OperatorStateBackend operatorStateBackend=mock(OperatorStateBackend.class);
  when(operatorStateBackend.snapshot(eq(checkpointId),eq(timestamp),any(CheckpointStreamFactory.class),any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle);
  AbstractKeyedStateBackend<?> keyedStateBackend=mock(AbstractKeyedStateBackend.class);
  when(keyedStateBackend.snapshot(eq(checkpointId),eq(timestamp),any(CheckpointStreamFactory.class),eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException);
  closeableRegistry.registerCloseable(operatorStateBackend);
  closeableRegistry.registerCloseable(keyedStateBackend);
  Whitebox.setInternalState(operator,"operatorStateBackend",operatorStateBackend);
  Whitebox.setInternalState(operator,"keyedStateBackend",keyedStateBackend);
  try {
    operator.snapshotState(checkpointId,timestamp,CheckpointOptions.forCheckpointWithDefaultLocation(),new MemCheckpointStreamFactory(Integer.MAX_VALUE));
    fail("Exception expected.");
  }
 catch (  Exception e) {
    assertEquals(failingException,e.getCause());
  }
  verify(context).close();
  verify(operatorSnapshotResult).cancel();
  verify(futureKeyedStateHandle).cancel(anyBoolean());
  verify(futureOperatorStateHandle).cancel(anyBoolean());
  verify(futureKeyedStateHandle).cancel(anyBoolean());
  operator.close();
  operator.dispose();
  verify(operatorStateBackend).close();
  verify(keyedStateBackend).close();
  verify(operatorStateBackend).dispose();
  verify(keyedStateBackend).dispose();
}
