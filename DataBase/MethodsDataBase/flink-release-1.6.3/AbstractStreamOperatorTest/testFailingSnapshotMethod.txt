/** 
 * Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.
 */
@Test public void testFailingSnapshotMethod() throws Exception {
  final long checkpointId=42L;
  final long timestamp=1L;
  final Exception failingException=new Exception("Test exception");
  final CloseableRegistry closeableRegistry=new CloseableRegistry();
  StateSnapshotContextSynchronousImpl context=mock(StateSnapshotContextSynchronousImpl.class);
  whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context);
  StreamTask<Void,AbstractStreamOperator<Void>> containingTask=mock(StreamTask.class);
  when(containingTask.getCancelables()).thenReturn(closeableRegistry);
  AbstractStreamOperator<Void> operator=mock(AbstractStreamOperator.class);
  when(operator.snapshotState(anyLong(),anyLong(),any(CheckpointOptions.class),any(CheckpointStreamFactory.class))).thenCallRealMethod();
  doReturn(containingTask).when(operator).getContainingTask();
  doThrow(failingException).when(operator).snapshotState(eq(context));
  try {
    operator.snapshotState(checkpointId,timestamp,CheckpointOptions.forCheckpointWithDefaultLocation(),new MemCheckpointStreamFactory(Integer.MAX_VALUE));
    fail("Exception expected.");
  }
 catch (  Exception e) {
    assertEquals(failingException,e.getCause());
  }
  verify(context).close();
}
