@Test public void testSerializerPresenceOnRestore() throws Exception {
  CheckpointStreamFactory streamFactory=createStreamFactory();
  SharedStateRegistry sharedStateRegistry=new SharedStateRegistry();
  Environment env=new DummyEnvironment();
  AbstractKeyedStateBackend<Integer> backend=createKeyedBackend(IntSerializer.INSTANCE,env);
  try {
    ValueStateDescriptor<TestCustomStateClass> kvId=new ValueStateDescriptor<>("id",new TestReconfigurableCustomTypeSerializerPreUpgrade());
    ValueState<TestCustomStateClass> state=backend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,kvId);
    backend.setCurrentKey(1);
    state.update(new TestCustomStateClass("test-message-1","this-should-be-ignored"));
    backend.setCurrentKey(2);
    state.update(new TestCustomStateClass("test-message-2","this-should-be-ignored"));
    KeyedStateHandle snapshot1=runSnapshot(backend.snapshot(682375462378L,2,streamFactory,CheckpointOptions.forCheckpointWithDefaultLocation()),sharedStateRegistry);
    backend.dispose();
    env=new DummyEnvironment(new ArtificialCNFExceptionThrowingClassLoader(getClass().getClassLoader(),Collections.singleton(TestReconfigurableCustomTypeSerializerPreUpgrade.class.getName())));
    try {
      backend=restoreKeyedBackend(IntSerializer.INSTANCE,snapshot1,env);
    }
 catch (    IOException e) {
      if (!isSerializerPresenceRequiredOnRestore()) {
        fail("Presence of old serializer should not have been required.");
      }
 else {
        return;
      }
    }
    kvId=new ValueStateDescriptor<>("id",new TestReconfigurableCustomTypeSerializerUpgraded());
    state=backend.getPartitionedState(VoidNamespace.INSTANCE,VoidNamespaceSerializer.INSTANCE,kvId);
    backend.setCurrentKey(1);
    state.update(new TestCustomStateClass("new-test-message-1","extra-message-1"));
    backend.setCurrentKey(2);
    state.update(new TestCustomStateClass("new-test-message-2","extra-message-2"));
    KeyedStateHandle snapshot2=runSnapshot(backend.snapshot(682375462379L,3,streamFactory,CheckpointOptions.forCheckpointWithDefaultLocation()),sharedStateRegistry);
    snapshot1.discardState();
  }
  finally {
    backend.dispose();
  }
}
