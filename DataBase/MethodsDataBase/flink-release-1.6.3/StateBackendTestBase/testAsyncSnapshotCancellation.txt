@Test public void testAsyncSnapshotCancellation() throws Exception {
  OneShotLatch blocker=new OneShotLatch();
  OneShotLatch waiter=new OneShotLatch();
  BlockerCheckpointStreamFactory streamFactory=new BlockerCheckpointStreamFactory(1024 * 1024);
  streamFactory.setWaiterLatch(waiter);
  streamFactory.setBlockerLatch(blocker);
  streamFactory.setAfterNumberInvocations(10);
  final AbstractKeyedStateBackend<Integer> backend=createKeyedBackend(IntSerializer.INSTANCE);
  try {
    if (!backend.supportsAsynchronousSnapshots()) {
      return;
    }
    InternalValueState<Integer,VoidNamespace,Integer> valueState=backend.createInternalState(VoidNamespaceSerializer.INSTANCE,new ValueStateDescriptor<>("test",IntSerializer.INSTANCE));
    valueState.setCurrentNamespace(VoidNamespace.INSTANCE);
    for (int i=0; i < 10; ++i) {
      backend.setCurrentKey(i);
      valueState.update(i);
    }
    RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot=backend.snapshot(0L,0L,streamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
    Thread runner=new Thread(snapshot);
    runner.start();
    waiter.await();
    IOUtils.closeQuietly(backend);
    blocker.trigger();
    runner.join();
    try {
      snapshot.get();
      fail("Close was not propagated.");
    }
 catch (    ExecutionException ex) {
    }
  }
  finally {
    backend.dispose();
  }
}
