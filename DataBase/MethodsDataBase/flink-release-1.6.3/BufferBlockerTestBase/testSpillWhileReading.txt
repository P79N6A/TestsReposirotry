@Test public void testSpillWhileReading() throws IOException {
  final int sequences=10;
  final Random rnd=new Random();
  final int maxNumEventsAndBuffers=30000;
  final int maxNumChannels=1656;
  int sequencesConsumed=0;
  ArrayDeque<SequenceToConsume> pendingSequences=new ArrayDeque<SequenceToConsume>();
  SequenceToConsume currentSequence=null;
  int currentNumEvents=0;
  int currentNumRecordAndEvents=0;
  BufferBlocker bufferBlocker=createBufferBlocker();
  for (int round=0; round < 2 * sequences; round++) {
    if (round % 2 == 1) {
      assertNull(bufferBlocker.rollOverReusingResources());
    }
 else {
      final long bufferSeed=rnd.nextLong();
      final Random bufferRnd=new Random(bufferSeed);
      final int numEventsAndBuffers=rnd.nextInt(maxNumEventsAndBuffers) + 1;
      final int numChannels=rnd.nextInt(maxNumChannels) + 1;
      final ArrayList<BufferOrEvent> events=new ArrayList<BufferOrEvent>(128);
      int generated=0;
      while (generated < numEventsAndBuffers) {
        if (currentSequence == null || rnd.nextDouble() < 0.5) {
          boolean isEvent=rnd.nextDouble() < 0.05;
          BufferOrEvent evt;
          if (isEvent) {
            evt=generateRandomEvent(rnd,numChannels);
            events.add(evt);
          }
 else {
            evt=generateRandomBuffer(bufferRnd.nextInt(PAGE_SIZE) + 1,bufferRnd.nextInt(numChannels));
          }
          bufferBlocker.add(evt);
          generated++;
        }
 else {
          BufferOrEvent next=currentSequence.sequence.getNext();
          assertNotNull(next);
          if (next.isEvent()) {
            BufferOrEvent expected=currentSequence.events.get(currentNumEvents++);
            assertEquals(expected.getEvent(),next.getEvent());
            assertEquals(expected.getChannelIndex(),next.getChannelIndex());
          }
 else {
            Random validationRnd=currentSequence.bufferRnd;
            validateBuffer(next,validationRnd.nextInt(PAGE_SIZE) + 1,validationRnd.nextInt(currentSequence.numChannels));
          }
          currentNumRecordAndEvents++;
          if (currentNumRecordAndEvents == currentSequence.numBuffersAndEvents) {
            currentSequence.sequence.cleanup();
            sequencesConsumed++;
            assertEquals(currentSequence.events.size(),currentNumEvents);
            currentSequence=pendingSequences.pollFirst();
            if (currentSequence != null) {
              currentSequence.sequence.open();
            }
            currentNumRecordAndEvents=0;
            currentNumEvents=0;
          }
        }
      }
      bufferRnd.setSeed(bufferSeed);
      BufferOrEventSequence seq=bufferBlocker.rollOverReusingResources();
      SequenceToConsume stc=new SequenceToConsume(bufferRnd,events,seq,numEventsAndBuffers,numChannels);
      if (currentSequence == null) {
        currentSequence=stc;
        stc.sequence.open();
      }
 else {
        pendingSequences.addLast(stc);
      }
    }
  }
  while (currentSequence != null) {
    BufferOrEvent next=currentSequence.sequence.getNext();
    assertNotNull(next);
    if (next.isEvent()) {
      BufferOrEvent expected=currentSequence.events.get(currentNumEvents++);
      assertEquals(expected.getEvent(),next.getEvent());
      assertEquals(expected.getChannelIndex(),next.getChannelIndex());
    }
 else {
      Random validationRnd=currentSequence.bufferRnd;
      validateBuffer(next,validationRnd.nextInt(PAGE_SIZE) + 1,validationRnd.nextInt(currentSequence.numChannels));
    }
    currentNumRecordAndEvents++;
    if (currentNumRecordAndEvents == currentSequence.numBuffersAndEvents) {
      currentSequence.sequence.cleanup();
      sequencesConsumed++;
      assertEquals(currentSequence.events.size(),currentNumEvents);
      currentSequence=pendingSequences.pollFirst();
      if (currentSequence != null) {
        currentSequence.sequence.open();
      }
      currentNumRecordAndEvents=0;
      currentNumEvents=0;
    }
  }
  assertEquals(sequences,sequencesConsumed);
}
