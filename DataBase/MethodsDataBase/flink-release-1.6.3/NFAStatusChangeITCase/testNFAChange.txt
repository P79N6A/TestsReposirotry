@Test public void testNFAChange() throws Exception {
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=1858562682635302605L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("a");
    }
  }
).followedByAny("middle").where(new IterativeCondition<Event>(){
    private static final long serialVersionUID=8061969839441121955L;
    @Override public boolean filter(    Event value,    Context<Event> ctx) throws Exception {
      return value.getName().equals("b");
    }
  }
).oneOrMore().optional().allowCombinations().followedBy("middle2").where(new IterativeCondition<Event>(){
    private static final long serialVersionUID=8061969839441121955L;
    @Override public boolean filter(    Event value,    Context<Event> ctx) throws Exception {
      return value.getName().equals("d");
    }
  }
).followedBy("end").where(new IterativeCondition<Event>(){
    private static final long serialVersionUID=8061969839441121955L;
    @Override public boolean filter(    Event value,    Context<Event> ctx) throws Exception {
      return value.getName().equals("e");
    }
  }
).within(Time.milliseconds(10));
  NFA<Event> nfa=compile(pattern,true);
  NFAState nfaState=nfa.createInitialNFAState();
  nfa.process(sharedBuffer,nfaState,new Event(1,"b",1.0),1L);
  assertFalse("NFA status should not change as the event does not match the take condition of the 'start' state",nfaState.isStateChanged());
  nfaState.resetStateChanged();
  nfa.process(sharedBuffer,nfaState,new Event(2,"a",1.0),2L);
  assertTrue("NFA status should change as the event matches the take condition of the 'start' state",nfaState.isStateChanged());
  nfaState.resetStateChanged();
  nfa.process(sharedBuffer,nfaState,new Event(3,"f",1.0),3L);
  assertTrue("NFA status should change as the event matches the ignore condition and proceed condition of the 'middle:1' state",nfaState.isStateChanged());
  nfaState.resetStateChanged();
  nfa.process(sharedBuffer,nfaState,new Event(4,"f",1.0),4L);
  assertFalse("NFA status should not change as the event only matches the ignore condition of the 'middle:2' state and the target state is still 'middle:2'",nfaState.isStateChanged());
  nfaState.resetStateChanged();
  nfa.process(sharedBuffer,nfaState,new Event(5,"b",1.0),5L);
  assertTrue("NFA status should change as the event matches the take condition of 'middle:2' state",nfaState.isStateChanged());
  nfaState.resetStateChanged();
  nfa.process(sharedBuffer,nfaState,new Event(6,"d",1.0),6L);
  assertTrue("NFA status should change as the event matches the take condition of 'middle2' state",nfaState.isStateChanged());
  nfaState.resetStateChanged();
  nfa.advanceTime(sharedBuffer,nfaState,8L);
  assertFalse("NFA status should not change as the timestamp is within the window",nfaState.isStateChanged());
  nfaState.resetStateChanged();
  Collection<Tuple2<Map<String,List<Event>>,Long>> timeoutResults=nfa.advanceTime(sharedBuffer,nfaState,12L);
  assertTrue("NFA status should change as timeout happens",nfaState.isStateChanged() && !timeoutResults.isEmpty());
}
