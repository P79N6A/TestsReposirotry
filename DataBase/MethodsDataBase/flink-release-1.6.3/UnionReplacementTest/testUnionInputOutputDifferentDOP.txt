/** 
 * Test the input and output shipping strategies for union operators with input and output operators with different parallelisms. Src1 - Map(fullP) -\-/- Union - Map(fullP) - Out X Src2 - Map(halfP) -/-\- Union - Map(halfP) - Out The union operator must always have the same parallelism as its successor and connect to it with a FORWARD strategy. In this program, the input connections for union should be FORWARD for parallelism-preserving connections and PARTITION_RANDOM for parallelism-changing connections.
 */
@Test public void testUnionInputOutputDifferentDOP() throws Exception {
  int fullDop=DEFAULT_PARALLELISM;
  int halfDop=DEFAULT_PARALLELISM / 2;
  ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  env.setParallelism(DEFAULT_PARALLELISM);
  DataSet<Tuple2<Long,Long>> in1=env.fromElements(new Tuple2<>(0L,0L)).map(new IdentityMapper<>()).setParallelism(fullDop).name("inDopFull");
  DataSet<Tuple2<Long,Long>> in2=env.fromElements(new Tuple2<>(0L,0L)).map(new IdentityMapper<>()).setParallelism(halfDop).name("inDopHalf");
  DataSet<Tuple2<Long,Long>> union=in1.union(in2);
  DataSet<Tuple2<Long,Long>> dopFullMap=union.map(new IdentityMapper<>()).setParallelism(fullDop).name("outDopFull");
  DataSet<Tuple2<Long,Long>> dopHalfMap=union.map(new IdentityMapper<>()).setParallelism(halfDop).name("outDopHalf");
  dopFullMap.output(new DiscardingOutputFormat<>());
  dopHalfMap.output(new DiscardingOutputFormat<>());
  OptimizedPlan optimizedPlan=compileNoStats(env.createProgramPlan());
  OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(optimizedPlan);
  SingleInputPlanNode inDopFull=resolver.getNode("inDopFull");
  SingleInputPlanNode inDopHalf=resolver.getNode("inDopHalf");
  SingleInputPlanNode outDopFull=resolver.getNode("outDopFull");
  SingleInputPlanNode outDopHalf=resolver.getNode("outDopHalf");
  NAryUnionPlanNode unionDopFull=(NAryUnionPlanNode)outDopFull.getInput().getSource();
  NAryUnionPlanNode unionDopHalf=(NAryUnionPlanNode)outDopHalf.getInput().getSource();
  assertEquals(2,inDopFull.getOutgoingChannels().size());
  assertEquals(2,inDopHalf.getOutgoingChannels().size());
  assertEquals(fullDop,inDopFull.getParallelism());
  assertEquals(halfDop,inDopHalf.getParallelism());
  assertEquals(fullDop,unionDopFull.getParallelism());
  assertEquals(halfDop,unionDopHalf.getParallelism());
  assertEquals(fullDop,outDopFull.getParallelism());
  assertEquals(halfDop,outDopHalf.getParallelism());
  assertEquals(ShipStrategyType.FORWARD,outDopHalf.getInput().getShipStrategy());
  assertEquals(ShipStrategyType.FORWARD,outDopFull.getInput().getShipStrategy());
  Channel fullFull;
  Channel fullHalf;
  Channel halfFull;
  Channel halfHalf;
  if (inDopFull.getOutgoingChannels().get(0).getTarget() == unionDopFull) {
    fullFull=inDopFull.getOutgoingChannels().get(0);
    fullHalf=inDopFull.getOutgoingChannels().get(1);
  }
 else {
    fullFull=inDopFull.getOutgoingChannels().get(1);
    fullHalf=inDopFull.getOutgoingChannels().get(0);
  }
  if (inDopHalf.getOutgoingChannels().get(0).getTarget() == unionDopFull) {
    halfFull=inDopHalf.getOutgoingChannels().get(0);
    halfHalf=inDopHalf.getOutgoingChannels().get(1);
  }
 else {
    halfFull=inDopHalf.getOutgoingChannels().get(1);
    halfHalf=inDopHalf.getOutgoingChannels().get(0);
  }
  assertEquals(ShipStrategyType.FORWARD,fullFull.getShipStrategy());
  assertEquals(ShipStrategyType.FORWARD,halfHalf.getShipStrategy());
  assertEquals(ShipStrategyType.PARTITION_RANDOM,fullHalf.getShipStrategy());
  assertEquals(ShipStrategyType.PARTITION_RANDOM,halfFull.getShipStrategy());
}
