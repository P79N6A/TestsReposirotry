/** 
 * Tests that when idle channels become active again, they need to "catch up" with the latest watermark before they are considered for min watermark computation again.
 */
@Test public void testMultipleInputWatermarkRealignmentAfterResumeActive(){
  BufferedValveOutputHandler valveOutput=new BufferedValveOutputHandler();
  StatusWatermarkValve valve=new StatusWatermarkValve(3,valveOutput);
  valve.inputWatermark(new Watermark(10),0);
  valve.inputWatermark(new Watermark(7),1);
  valve.inputWatermark(new Watermark(3),2);
  assertEquals(new Watermark(3),valveOutput.popLastSeenOutput());
  assertEquals(null,valveOutput.popLastSeenOutput());
  valve.inputStreamStatus(StreamStatus.IDLE,2);
  assertEquals(new Watermark(7),valveOutput.popLastSeenOutput());
  assertEquals(null,valveOutput.popLastSeenOutput());
  valve.inputStreamStatus(StreamStatus.ACTIVE,2);
  assertFalse(valve.getInputChannelStatus(2).isWatermarkAligned);
  valve.inputWatermark(new Watermark(5),2);
  assertEquals(5,valve.getInputChannelStatus(2).watermark);
  assertEquals(null,valveOutput.popLastSeenOutput());
  valve.inputWatermark(new Watermark(9),2);
  assertTrue(valve.getInputChannelStatus(2).isWatermarkAligned);
  assertEquals(null,valveOutput.popLastSeenOutput());
  valve.inputWatermark(new Watermark(12),1);
  assertEquals(new Watermark(9),valveOutput.popLastSeenOutput());
  assertEquals(null,valveOutput.popLastSeenOutput());
}
