@Test public void testCancellationWhenEmitBlocks() throws Exception {
  final String topic="test-topic";
  final int partition=3;
  final byte[] payload=new byte[]{1,2,3,4};
  final List<ConsumerRecord<byte[],byte[]>> records=Arrays.asList(new ConsumerRecord<>(topic,partition,15,payload,payload),new ConsumerRecord<>(topic,partition,16,payload,payload),new ConsumerRecord<>(topic,partition,17,payload,payload));
  final Map<TopicPartition,List<ConsumerRecord<byte[],byte[]>>> data=new HashMap<>();
  data.put(new TopicPartition(topic,partition),records);
  final ConsumerRecords<byte[],byte[]> consumerRecords=new ConsumerRecords<>(data);
  final KafkaConsumer<?,?> mockConsumer=mock(KafkaConsumer.class);
  when(mockConsumer.poll(anyLong())).thenAnswer(new Answer<ConsumerRecords<?,?>>(){
    @Override public ConsumerRecords<?,?> answer(    InvocationOnMock invocation){
      return consumerRecords;
    }
  }
);
  whenNew(KafkaConsumer.class).withAnyArguments().thenReturn(mockConsumer);
  BlockingSourceContext<String> sourceContext=new BlockingSourceContext<>();
  Map<KafkaTopicPartition,Long> partitionsWithInitialOffsets=Collections.singletonMap(new KafkaTopicPartition(topic,partition),KafkaTopicPartitionStateSentinel.GROUP_OFFSET);
  KeyedDeserializationSchema<String> schema=new KeyedDeserializationSchemaWrapper<>(new SimpleStringSchema());
  final Kafka09Fetcher<String> fetcher=new Kafka09Fetcher<>(sourceContext,partitionsWithInitialOffsets,null,null,new TestProcessingTimeService(),10,this.getClass().getClassLoader(),"task_name",schema,new Properties(),0L,new UnregisteredMetricsGroup(),new UnregisteredMetricsGroup(),false);
  final AtomicReference<Throwable> error=new AtomicReference<>();
  final Thread fetcherRunner=new Thread("fetcher runner"){
    @Override public void run(){
      try {
        fetcher.runFetchLoop();
      }
 catch (      Throwable t) {
        error.set(t);
      }
    }
  }
;
  fetcherRunner.start();
  sourceContext.waitTillHasBlocker();
  fetcher.cancel();
  fetcherRunner.interrupt();
  fetcherRunner.join();
  assertFalse("fetcher threads did not properly finish",sourceContext.isStillBlocking());
}
