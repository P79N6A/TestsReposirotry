/** 
 * Tests that cache entries are cleaned up when their TTL has expired upon calling  {@link ExecutionGraphCache#cleanup()}.
 */
@Test public void testCacheEntryCleanup() throws Exception {
  final Time timeout=Time.milliseconds(100L);
  final Time timeToLive=Time.milliseconds(1L);
  final JobID expectedJobId2=new JobID();
  final ArchivedExecutionGraph expectedExecutionGraph2=new ArchivedExecutionGraphBuilder().build();
  final AtomicInteger requestJobCalls=new AtomicInteger(0);
  final TestingRestfulGateway restfulGateway=TestingRestfulGateway.newBuilder().setRequestJobFunction(jobId -> {
    requestJobCalls.incrementAndGet();
    if (jobId.equals(expectedJobId)) {
      return CompletableFuture.completedFuture(expectedExecutionGraph);
    }
 else     if (jobId.equals(expectedJobId2)) {
      return CompletableFuture.completedFuture(expectedExecutionGraph2);
    }
 else {
      throw new AssertionError("Invalid job id received.");
    }
  }
).build();
  try (ExecutionGraphCache executionGraphCache=new ExecutionGraphCache(timeout,timeToLive)){
    CompletableFuture<AccessExecutionGraph> executionGraph1Future=executionGraphCache.getExecutionGraph(expectedJobId,restfulGateway);
    CompletableFuture<AccessExecutionGraph> executionGraph2Future=executionGraphCache.getExecutionGraph(expectedJobId2,restfulGateway);
    assertEquals(expectedExecutionGraph,executionGraph1Future.get());
    assertEquals(expectedExecutionGraph2,executionGraph2Future.get());
    assertThat(requestJobCalls.get(),Matchers.equalTo(2));
    Thread.sleep(timeToLive.toMilliseconds());
    executionGraphCache.cleanup();
    assertTrue(executionGraphCache.size() == 0);
  }
 }
