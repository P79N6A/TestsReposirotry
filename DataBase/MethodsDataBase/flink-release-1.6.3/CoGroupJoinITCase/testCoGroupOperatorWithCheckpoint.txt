/** 
 * Verifies that pipelines including  {@link CoGroupedStreams} can be checkpointed properly,which includes snapshotting configurations of any involved serializers.
 * @see <a href="https://issues.apache.org/jira/browse/FLINK-6808">FLINK-6808</a>
 */
@Test public void testCoGroupOperatorWithCheckpoint() throws Exception {
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
  env.setParallelism(1);
  DataStream<Tuple2<String,Integer>> source1=env.fromElements(Tuple2.of("a",0),Tuple2.of("b",3));
  DataStream<Tuple2<String,Integer>> source2=env.fromElements(Tuple2.of("a",1),Tuple2.of("b",6));
  DataStream<String> coGroupWindow=source1.coGroup(source2).where(new Tuple2KeyExtractor()).equalTo(new Tuple2KeyExtractor()).window(TumblingEventTimeWindows.of(Time.of(3,TimeUnit.MILLISECONDS))).apply(new CoGroupFunction<Tuple2<String,Integer>,Tuple2<String,Integer>,String>(){
    @Override public void coGroup(    Iterable<Tuple2<String,Integer>> first,    Iterable<Tuple2<String,Integer>> second,    Collector<String> out) throws Exception {
      out.collect(first + ":" + second);
    }
  }
);
  OneInputTransformation<Tuple2<String,Integer>,String> transform=(OneInputTransformation<Tuple2<String,Integer>,String>)coGroupWindow.getTransformation();
  OneInputStreamOperator<Tuple2<String,Integer>,String> operator=transform.getOperator();
  OneInputStreamOperatorTestHarness<Tuple2<String,Integer>,String> testHarness=new KeyedOneInputStreamOperatorTestHarness<>(operator,new Tuple2KeyExtractor(),BasicTypeInfo.STRING_TYPE_INFO);
  testHarness.open();
  testHarness.snapshot(0L,0L);
}
