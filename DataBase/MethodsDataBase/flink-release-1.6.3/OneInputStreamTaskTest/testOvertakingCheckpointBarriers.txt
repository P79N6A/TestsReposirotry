/** 
 * This test verifies that checkpoint barriers and barrier buffers work correctly with concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e. some inputs receive barriers from an earlier checkpoint, thereby blocking, then all inputs receive barriers from a later checkpoint.
 */
@Test public void testOvertakingCheckpointBarriers() throws Exception {
  final OneInputStreamTaskTestHarness<String,String> testHarness=new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new,2,2,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
  testHarness.setupOutputForSingletonOperatorChain();
  StreamConfig streamConfig=testHarness.getStreamConfig();
  StreamMap<String,String> mapOperator=new StreamMap<String,String>(new IdentityMap());
  streamConfig.setStreamOperator(mapOperator);
  streamConfig.setOperatorID(new OperatorID());
  ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<Object>();
  long initialTime=0L;
  testHarness.invoke();
  testHarness.waitForTaskRunning();
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,0);
  testHarness.processElement(new StreamRecord<String>("Hello-0-0",initialTime),0,0);
  testHarness.processElement(new StreamRecord<String>("Ciao-0-0",initialTime),0,0);
  testHarness.processElement(new StreamRecord<String>("Hello-1-1",initialTime),1,1);
  testHarness.processElement(new StreamRecord<String>("Ciao-1-1",initialTime),1,1);
  expectedOutput.add(new StreamRecord<String>("Hello-1-1",initialTime));
  expectedOutput.add(new StreamRecord<String>("Ciao-1-1",initialTime));
  testHarness.waitForInputProcessing();
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),0,0);
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),0,1);
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),1,0);
  testHarness.processEvent(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()),1,1);
  expectedOutput.add(new CancelCheckpointMarker(0));
  expectedOutput.add(new StreamRecord<String>("Hello-0-0",initialTime));
  expectedOutput.add(new StreamRecord<String>("Ciao-0-0",initialTime));
  expectedOutput.add(new CheckpointBarrier(1,1,CheckpointOptions.forCheckpointWithDefaultLocation()));
  testHarness.waitForInputProcessing();
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),0,1);
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,0);
  testHarness.processEvent(new CheckpointBarrier(0,0,CheckpointOptions.forCheckpointWithDefaultLocation()),1,1);
  testHarness.waitForInputProcessing();
  testHarness.endInput();
  testHarness.waitForTaskCompletion();
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
}
