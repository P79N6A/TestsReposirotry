/** 
 * Tests that the metrics are updated properly. We had a bug that required new stats snapshots in order to update the metrics.
 */
@Test @SuppressWarnings("unchecked") public void testMetricsAreUpdated() throws Exception {
  final Map<String,Gauge<?>> registeredGauges=new HashMap<>();
  MetricGroup metricGroup=new UnregisteredMetricsGroup(){
    @Override public <T,G extends Gauge<T>>G gauge(    String name,    G gauge){
      registeredGauges.put(name,gauge);
      return gauge;
    }
  }
;
  ExecutionJobVertex jobVertex=mock(ExecutionJobVertex.class);
  when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());
  when(jobVertex.getParallelism()).thenReturn(1);
  CheckpointStatsTracker stats=new CheckpointStatsTracker(0,Collections.singletonList(jobVertex),mock(CheckpointCoordinatorConfiguration.class),metricGroup);
  assertEquals(9,registeredGauges.size());
  Gauge<Long> numCheckpoints=(Gauge<Long>)registeredGauges.get(CheckpointStatsTracker.NUMBER_OF_CHECKPOINTS_METRIC);
  Gauge<Integer> numInProgressCheckpoints=(Gauge<Integer>)registeredGauges.get(CheckpointStatsTracker.NUMBER_OF_IN_PROGRESS_CHECKPOINTS_METRIC);
  Gauge<Long> numCompletedCheckpoints=(Gauge<Long>)registeredGauges.get(CheckpointStatsTracker.NUMBER_OF_COMPLETED_CHECKPOINTS_METRIC);
  Gauge<Long> numFailedCheckpoints=(Gauge<Long>)registeredGauges.get(CheckpointStatsTracker.NUMBER_OF_FAILED_CHECKPOINTS_METRIC);
  Gauge<Long> latestRestoreTimestamp=(Gauge<Long>)registeredGauges.get(CheckpointStatsTracker.LATEST_RESTORED_CHECKPOINT_TIMESTAMP_METRIC);
  Gauge<Long> latestCompletedSize=(Gauge<Long>)registeredGauges.get(CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_SIZE_METRIC);
  Gauge<Long> latestCompletedDuration=(Gauge<Long>)registeredGauges.get(CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_DURATION_METRIC);
  Gauge<Long> latestCompletedAlignmentBuffered=(Gauge<Long>)registeredGauges.get(CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_ALIGNMENT_BUFFERED_METRIC);
  Gauge<String> latestCompletedExternalPath=(Gauge<String>)registeredGauges.get(CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_EXTERNAL_PATH_METRIC);
  assertEquals(Long.valueOf(0),numCheckpoints.getValue());
  assertEquals(Integer.valueOf(0),numInProgressCheckpoints.getValue());
  assertEquals(Long.valueOf(0),numCompletedCheckpoints.getValue());
  assertEquals(Long.valueOf(0),numFailedCheckpoints.getValue());
  assertEquals(Long.valueOf(-1),latestRestoreTimestamp.getValue());
  assertEquals(Long.valueOf(-1),latestCompletedSize.getValue());
  assertEquals(Long.valueOf(-1),latestCompletedDuration.getValue());
  assertEquals(Long.valueOf(-1),latestCompletedAlignmentBuffered.getValue());
  assertEquals("n/a",latestCompletedExternalPath.getValue());
  PendingCheckpointStats pending=stats.reportPendingCheckpoint(0,0,CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION));
  assertEquals(Long.valueOf(1),numCheckpoints.getValue());
  assertEquals(Integer.valueOf(1),numInProgressCheckpoints.getValue());
  assertEquals(Long.valueOf(0),numCompletedCheckpoints.getValue());
  assertEquals(Long.valueOf(0),numFailedCheckpoints.getValue());
  long ackTimestamp=11231230L;
  long stateSize=12381238L;
  long ignored=0;
  long alignmenetBuffered=182812L;
  String externalPath="myexternalpath";
  SubtaskStateStats subtaskStats=new SubtaskStateStats(0,ackTimestamp,stateSize,ignored,ignored,alignmenetBuffered,ignored);
  assertTrue(pending.reportSubtaskStats(jobVertex.getJobVertexId(),subtaskStats));
  pending.reportCompletedCheckpoint(externalPath);
  assertEquals(Long.valueOf(1),numCheckpoints.getValue());
  assertEquals(Integer.valueOf(0),numInProgressCheckpoints.getValue());
  assertEquals(Long.valueOf(1),numCompletedCheckpoints.getValue());
  assertEquals(Long.valueOf(0),numFailedCheckpoints.getValue());
  assertEquals(Long.valueOf(-1),latestRestoreTimestamp.getValue());
  assertEquals(Long.valueOf(stateSize),latestCompletedSize.getValue());
  assertEquals(Long.valueOf(ackTimestamp),latestCompletedDuration.getValue());
  assertEquals(Long.valueOf(alignmenetBuffered),latestCompletedAlignmentBuffered.getValue());
  assertEquals(externalPath,latestCompletedExternalPath.getValue());
  PendingCheckpointStats nextPending=stats.reportPendingCheckpoint(1,11,CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION));
  long failureTimestamp=1230123L;
  nextPending.reportFailedCheckpoint(failureTimestamp,null);
  assertEquals(Long.valueOf(2),numCheckpoints.getValue());
  assertEquals(Integer.valueOf(0),numInProgressCheckpoints.getValue());
  assertEquals(Long.valueOf(1),numCompletedCheckpoints.getValue());
  assertEquals(Long.valueOf(1),numFailedCheckpoints.getValue());
  long restoreTimestamp=183419283L;
  RestoredCheckpointStats restored=new RestoredCheckpointStats(1,CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),restoreTimestamp,null);
  stats.reportRestoredCheckpoint(restored);
  assertEquals(Long.valueOf(2),numCheckpoints.getValue());
  assertEquals(Integer.valueOf(0),numInProgressCheckpoints.getValue());
  assertEquals(Long.valueOf(1),numCompletedCheckpoints.getValue());
  assertEquals(Long.valueOf(1),numFailedCheckpoints.getValue());
  assertEquals(Long.valueOf(restoreTimestamp),latestRestoreTimestamp.getValue());
  PendingCheckpointStats thirdPending=stats.reportPendingCheckpoint(2,5000,CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION));
  thirdPending.reportSubtaskStats(jobVertex.getJobVertexId(),subtaskStats);
  thirdPending.reportCompletedCheckpoint(null);
  assertEquals("n/a",latestCompletedExternalPath.getValue());
}
