/** 
 * Tests the registration of the checkpoint metrics.
 */
@Test public void testMetricsRegistration() throws Exception {
  final Collection<String> registeredGaugeNames=new ArrayList<>();
  MetricGroup metricGroup=new UnregisteredMetricsGroup(){
    @Override public <T,G extends Gauge<T>>G gauge(    String name,    G gauge){
      if (gauge != null) {
        registeredGaugeNames.add(name);
      }
      return gauge;
    }
  }
;
  ExecutionJobVertex jobVertex=mock(ExecutionJobVertex.class);
  when(jobVertex.getJobVertexId()).thenReturn(new JobVertexID());
  when(jobVertex.getParallelism()).thenReturn(1);
  new CheckpointStatsTracker(0,Collections.singletonList(jobVertex),mock(CheckpointCoordinatorConfiguration.class),metricGroup);
  assertTrue(registeredGaugeNames.containsAll(Arrays.asList(CheckpointStatsTracker.NUMBER_OF_CHECKPOINTS_METRIC,CheckpointStatsTracker.NUMBER_OF_IN_PROGRESS_CHECKPOINTS_METRIC,CheckpointStatsTracker.NUMBER_OF_COMPLETED_CHECKPOINTS_METRIC,CheckpointStatsTracker.NUMBER_OF_FAILED_CHECKPOINTS_METRIC,CheckpointStatsTracker.LATEST_RESTORED_CHECKPOINT_TIMESTAMP_METRIC,CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_SIZE_METRIC,CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_DURATION_METRIC,CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_ALIGNMENT_BUFFERED_METRIC,CheckpointStatsTracker.LATEST_COMPLETED_CHECKPOINT_EXTERNAL_PATH_METRIC)));
  assertEquals(9,registeredGaugeNames.size());
}
