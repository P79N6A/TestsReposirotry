/** 
 * This also verifies that we don't have leakage between keys/namespaces.
 */
@Test public void testSetAndFireEventTimeTimers() throws Exception {
  @SuppressWarnings("unchecked") Triggerable<Integer,String> mockTriggerable=mock(Triggerable.class);
  TestKeyContext keyContext=new TestKeyContext();
  TestProcessingTimeService processingTimeService=new TestProcessingTimeService();
  InternalTimerServiceImpl<Integer,String> timerService=createAndStartInternalTimerService(mockTriggerable,keyContext,processingTimeService,testKeyGroupRange,createQueueFactory());
  int key1=getKeyInKeyGroupRange(testKeyGroupRange,maxParallelism);
  int key2=getKeyInKeyGroupRange(testKeyGroupRange,maxParallelism);
  while (key2 == key1) {
    key2=getKeyInKeyGroupRange(testKeyGroupRange,maxParallelism);
  }
  keyContext.setCurrentKey(key1);
  timerService.registerEventTimeTimer("ciao",10);
  timerService.registerEventTimeTimer("hello",10);
  keyContext.setCurrentKey(key2);
  timerService.registerEventTimeTimer("ciao",10);
  timerService.registerEventTimeTimer("hello",10);
  assertEquals(4,timerService.numEventTimeTimers());
  assertEquals(2,timerService.numEventTimeTimers("hello"));
  assertEquals(2,timerService.numEventTimeTimers("ciao"));
  timerService.advanceWatermark(10);
  verify(mockTriggerable,times(4)).onEventTime(anyInternalTimer());
  verify(mockTriggerable,times(1)).onEventTime(eq(new TimerHeapInternalTimer<>(10,key1,"ciao")));
  verify(mockTriggerable,times(1)).onEventTime(eq(new TimerHeapInternalTimer<>(10,key1,"hello")));
  verify(mockTriggerable,times(1)).onEventTime(eq(new TimerHeapInternalTimer<>(10,key2,"ciao")));
  verify(mockTriggerable,times(1)).onEventTime(eq(new TimerHeapInternalTimer<>(10,key2,"hello")));
  assertEquals(0,timerService.numEventTimeTimers());
}
