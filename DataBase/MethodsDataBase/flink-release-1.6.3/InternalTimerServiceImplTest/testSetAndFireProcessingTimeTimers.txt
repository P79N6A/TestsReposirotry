/** 
 * This also verifies that we don't have leakage between keys/namespaces.
 */
@Test public void testSetAndFireProcessingTimeTimers() throws Exception {
  @SuppressWarnings("unchecked") Triggerable<Integer,String> mockTriggerable=mock(Triggerable.class);
  TestKeyContext keyContext=new TestKeyContext();
  TestProcessingTimeService processingTimeService=new TestProcessingTimeService();
  InternalTimerServiceImpl<Integer,String> timerService=createAndStartInternalTimerService(mockTriggerable,keyContext,processingTimeService,testKeyGroupRange,createQueueFactory());
  int key1=getKeyInKeyGroupRange(testKeyGroupRange,maxParallelism);
  int key2=getKeyInKeyGroupRange(testKeyGroupRange,maxParallelism);
  while (key2 == key1) {
    key2=getKeyInKeyGroupRange(testKeyGroupRange,maxParallelism);
  }
  keyContext.setCurrentKey(key1);
  timerService.registerProcessingTimeTimer("ciao",10);
  timerService.registerProcessingTimeTimer("hello",10);
  keyContext.setCurrentKey(key2);
  timerService.registerProcessingTimeTimer("ciao",10);
  timerService.registerProcessingTimeTimer("hello",10);
  assertEquals(4,timerService.numProcessingTimeTimers());
  assertEquals(2,timerService.numProcessingTimeTimers("hello"));
  assertEquals(2,timerService.numProcessingTimeTimers("ciao"));
  processingTimeService.setCurrentTime(10);
  verify(mockTriggerable,times(4)).onProcessingTime(anyInternalTimer());
  verify(mockTriggerable,times(1)).onProcessingTime(eq(new TimerHeapInternalTimer<>(10,key1,"ciao")));
  verify(mockTriggerable,times(1)).onProcessingTime(eq(new TimerHeapInternalTimer<>(10,key1,"hello")));
  verify(mockTriggerable,times(1)).onProcessingTime(eq(new TimerHeapInternalTimer<>(10,key2,"ciao")));
  verify(mockTriggerable,times(1)).onProcessingTime(eq(new TimerHeapInternalTimer<>(10,key2,"hello")));
  assertEquals(0,timerService.numProcessingTimeTimers());
}
