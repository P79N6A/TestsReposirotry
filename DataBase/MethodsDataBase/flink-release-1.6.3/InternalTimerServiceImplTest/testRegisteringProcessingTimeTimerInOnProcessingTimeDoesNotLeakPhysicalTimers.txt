/** 
 */
@Test public void testRegisteringProcessingTimeTimerInOnProcessingTimeDoesNotLeakPhysicalTimers() throws Exception {
  @SuppressWarnings("unchecked") Triggerable<Integer,String> mockTriggerable=mock(Triggerable.class);
  TestKeyContext keyContext=new TestKeyContext();
  TestProcessingTimeService processingTimeService=new TestProcessingTimeService();
  final InternalTimerServiceImpl<Integer,String> timerService=createAndStartInternalTimerService(mockTriggerable,keyContext,processingTimeService,testKeyGroupRange,createQueueFactory());
  int key=getKeyInKeyGroupRange(testKeyGroupRange,maxParallelism);
  keyContext.setCurrentKey(key);
  timerService.registerProcessingTimeTimer("ciao",10);
  assertEquals(1,timerService.numProcessingTimeTimers());
  assertEquals(1,processingTimeService.getNumActiveTimers());
  assertThat(processingTimeService.getActiveTimerTimestamps(),containsInAnyOrder(10L));
  doAnswer(new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocation) throws Exception {
      timerService.registerProcessingTimeTimer("ciao",20);
      return null;
    }
  }
).when(mockTriggerable).onProcessingTime(anyInternalTimer());
  processingTimeService.setCurrentTime(10);
  assertEquals(1,processingTimeService.getNumActiveTimers());
  assertThat(processingTimeService.getActiveTimerTimestamps(),containsInAnyOrder(20L));
  doAnswer(new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocation) throws Exception {
      timerService.registerProcessingTimeTimer("ciao",30);
      return null;
    }
  }
).when(mockTriggerable).onProcessingTime(anyInternalTimer());
  processingTimeService.setCurrentTime(20);
  assertEquals(1,timerService.numProcessingTimeTimers());
  assertEquals(1,processingTimeService.getNumActiveTimers());
  assertThat(processingTimeService.getActiveTimerTimestamps(),containsInAnyOrder(30L));
}
