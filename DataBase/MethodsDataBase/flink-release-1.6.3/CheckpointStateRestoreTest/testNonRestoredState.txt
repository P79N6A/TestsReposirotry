/** 
 * Tests that the allow non restored state flag is correctly handled. <p>The flag only applies for state that is part of the checkpoint.
 */
@Test public void testNonRestoredState() throws Exception {
  JobVertexID jobVertexId1=new JobVertexID();
  JobVertexID jobVertexId2=new JobVertexID();
  OperatorID operatorId1=OperatorID.fromJobVertexID(jobVertexId1);
  ExecutionVertex vertex11=mockExecutionVertex(mockExecution(),jobVertexId1,0,3);
  ExecutionVertex vertex12=mockExecutionVertex(mockExecution(),jobVertexId1,1,3);
  ExecutionVertex vertex13=mockExecutionVertex(mockExecution(),jobVertexId1,2,3);
  ExecutionVertex vertex21=mockExecutionVertex(mockExecution(),jobVertexId2,0,2);
  ExecutionVertex vertex22=mockExecutionVertex(mockExecution(),jobVertexId2,1,2);
  ExecutionJobVertex jobVertex1=mockExecutionJobVertex(jobVertexId1,new ExecutionVertex[]{vertex11,vertex12,vertex13});
  ExecutionJobVertex jobVertex2=mockExecutionJobVertex(jobVertexId2,new ExecutionVertex[]{vertex21,vertex22});
  Map<JobVertexID,ExecutionJobVertex> tasks=new HashMap<>();
  tasks.put(jobVertexId1,jobVertex1);
  tasks.put(jobVertexId2,jobVertex2);
  CheckpointCoordinator coord=new CheckpointCoordinator(new JobID(),Integer.MAX_VALUE,Integer.MAX_VALUE,0,Integer.MAX_VALUE,CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,new ExecutionVertex[]{},new ExecutionVertex[]{},new ExecutionVertex[]{},new StandaloneCheckpointIDCounter(),new StandaloneCompletedCheckpointStore(1),new MemoryStateBackend(),Executors.directExecutor(),SharedStateRegistry.DEFAULT_FACTORY);
  Map<OperatorID,OperatorState> checkpointTaskStates=new HashMap<>();
{
    OperatorState taskState=new OperatorState(operatorId1,3,3);
    taskState.putState(0,new OperatorSubtaskState());
    taskState.putState(1,new OperatorSubtaskState());
    taskState.putState(2,new OperatorSubtaskState());
    checkpointTaskStates.put(operatorId1,taskState);
  }
  CompletedCheckpoint checkpoint=new CompletedCheckpoint(new JobID(),0,1,2,new HashMap<>(checkpointTaskStates),Collections.<MasterState>emptyList(),CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),new TestCompletedCheckpointStorageLocation());
  coord.getCheckpointStore().addCheckpoint(checkpoint);
  coord.restoreLatestCheckpointedState(tasks,true,false);
  coord.restoreLatestCheckpointedState(tasks,true,true);
  JobVertexID newJobVertexID=new JobVertexID();
  OperatorID newOperatorID=OperatorID.fromJobVertexID(newJobVertexID);
{
    OperatorState taskState=new OperatorState(newOperatorID,1,1);
    taskState.putState(0,new OperatorSubtaskState());
    checkpointTaskStates.put(newOperatorID,taskState);
  }
  checkpoint=new CompletedCheckpoint(new JobID(),1,2,3,new HashMap<>(checkpointTaskStates),Collections.<MasterState>emptyList(),CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),new TestCompletedCheckpointStorageLocation());
  coord.getCheckpointStore().addCheckpoint(checkpoint);
  coord.restoreLatestCheckpointedState(tasks,true,true);
  try {
    coord.restoreLatestCheckpointedState(tasks,true,false);
    fail("Did not throw the expected Exception.");
  }
 catch (  IllegalStateException ignored) {
  }
}
