/** 
 * Tests that the release of the input gate is noticed while polling the channels for available data.
 */
@Test public void testReleaseWhilePollingChannel() throws Exception {
  final AtomicReference<Exception> asyncException=new AtomicReference<>();
  final SingleInputGate inputGate=createInputGate(1);
  InputChannel unknown=new UnknownInputChannel(inputGate,0,new ResultPartitionID(),new ResultPartitionManager(),new TaskEventDispatcher(),new LocalConnectionManager(),0,0,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup());
  inputGate.setInputChannel(unknown.partitionId.getPartitionId(),unknown);
  Thread asyncConsumer=new Thread(){
    @Override public void run(){
      try {
        inputGate.getNextBufferOrEvent();
      }
 catch (      Exception e) {
        asyncException.set(e);
      }
    }
  }
;
  asyncConsumer.start();
  boolean success=false;
  for (int i=0; i < 50; i++) {
    if (asyncConsumer.isAlive()) {
      success=asyncConsumer.getState() == Thread.State.WAITING;
    }
    if (success) {
      break;
    }
 else {
      Thread.sleep(100);
    }
  }
  assertTrue("Did not trigger blocking buffer request.",success);
  inputGate.releaseAllResources();
  asyncConsumer.join();
  assertNotNull(asyncException.get());
  assertEquals(IllegalStateException.class,asyncException.get().getClass());
}
