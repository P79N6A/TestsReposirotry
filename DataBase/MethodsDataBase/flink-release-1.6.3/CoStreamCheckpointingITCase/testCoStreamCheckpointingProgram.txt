/** 
 * Runs the following program. <pre> [ (source)->(filter)->(map) ] -> [ (co-map) ] -> [ (map) ] -> [ (groupBy/reduce)->(sink) ] </pre>
 */
@Test public void testCoStreamCheckpointingProgram() throws Exception {
  assertTrue("Broken test setup",NUM_STRINGS % 40 == 0);
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setParallelism(PARALLELISM);
  env.enableCheckpointing(50);
  env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE,0L));
  DataStream<String> stream=env.addSource(new StringGeneratingSourceFunction(NUM_STRINGS,NUM_STRINGS / 5));
  stream.filter(new StringRichFilterFunction()).connect(stream).flatMap(new LeftIdentityCoRichFlatMapFunction()).map(new StringPrefixCountRichMapFunction()).startNewChain().map(new StatefulCounterFunction()).keyBy("prefix").reduce(new OnceFailingReducer(NUM_STRINGS)).addSink(new SinkFunction<PrefixCount>(){
    @Override public void invoke(    PrefixCount value){
    }
  }
);
  TestUtils.tryExecute(env,"Fault Tolerance Test");
  long filterSum=0;
  for (  long l : StringRichFilterFunction.counts) {
    filterSum+=l;
  }
  long coMapSum=0;
  for (  long l : LeftIdentityCoRichFlatMapFunction.counts) {
    coMapSum+=l;
  }
  long mapSum=0;
  for (  long l : StringPrefixCountRichMapFunction.counts) {
    mapSum+=l;
  }
  long countSum=0;
  for (  long l : StatefulCounterFunction.counts) {
    countSum+=l;
  }
  assertEquals(NUM_STRINGS,filterSum);
  assertEquals(NUM_STRINGS,coMapSum);
  assertEquals(NUM_STRINGS,mapSum);
  assertEquals(NUM_STRINGS,countSum);
}
