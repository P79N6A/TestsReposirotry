/** 
 * Tests that each checkpoint is only aborted once in case of an interleaved cancellation barrier arrival of two consecutive checkpoints.
 */
@Test public void testInterleavedCancellationBarriers() throws Exception {
  BufferOrEvent[] sequence={createBarrier(1L,0),createCancellationBarrier(2L,0),createCancellationBarrier(1L,1),createCancellationBarrier(2L,1),createCancellationBarrier(1L,2),createCancellationBarrier(2L,2),createBuffer(0)};
  MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
  BarrierTracker tracker=new BarrierTracker(gate);
  AbstractInvokable statefulTask=mock(AbstractInvokable.class);
  tracker.registerCheckpointEventHandler(statefulTask);
  for (  BufferOrEvent boe : sequence) {
    if (boe.isBuffer() || (boe.getEvent().getClass() != CheckpointBarrier.class && boe.getEvent().getClass() != CancelCheckpointMarker.class)) {
      assertEquals(boe,tracker.getNextNonBlocked());
    }
  }
  verify(statefulTask,times(1)).abortCheckpointOnBarrier(eq(1L),any(Throwable.class));
  verify(statefulTask,times(1)).abortCheckpointOnBarrier(eq(2L),any(Throwable.class));
}
