@Test public void testFairConsumptionLocalChannels() throws Exception {
  final int numChannels=37;
  final int buffersPerChannel=27;
  final ResultPartition resultPartition=mock(ResultPartition.class);
  try (BufferConsumer bufferConsumer=createFilledBufferConsumer(42)){
    final PipelinedSubpartition[] sources=new PipelinedSubpartition[numChannels];
    for (int i=0; i < numChannels; i++) {
      sources[i]=new PipelinedSubpartition(0,resultPartition);
    }
    ResultPartitionManager resultPartitionManager=createResultPartitionManager(sources);
    SingleInputGate gate=new FairnessVerifyingInputGate("Test Task Name",new JobID(),new IntermediateDataSetID(),0,numChannels,mock(TaskActions.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(),true);
    for (int i=0; i < numChannels; i++) {
      LocalInputChannel channel=new LocalInputChannel(gate,i,new ResultPartitionID(),resultPartitionManager,mock(TaskEventDispatcher.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup());
      gate.setInputChannel(new IntermediateResultPartitionID(),channel);
    }
    sources[12].add(bufferConsumer.copy());
    for (int i=0; i < numChannels * buffersPerChannel; i++) {
      assertNotNull(gate.getNextBufferOrEvent());
      int min=Integer.MAX_VALUE;
      int max=0;
      for (      PipelinedSubpartition source : sources) {
        int size=source.getCurrentNumberOfBuffers();
        min=Math.min(min,size);
        max=Math.max(max,size);
      }
      assertTrue(max == min || max == min + 1);
      if (i % (2 * numChannels) == 0) {
        fillRandom(sources,3,bufferConsumer);
      }
    }
  }
 }
