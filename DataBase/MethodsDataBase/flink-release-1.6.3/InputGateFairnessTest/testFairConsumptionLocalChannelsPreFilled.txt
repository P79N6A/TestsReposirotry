@Test public void testFairConsumptionLocalChannelsPreFilled() throws Exception {
  final int numChannels=37;
  final int buffersPerChannel=27;
  final ResultPartition resultPartition=mock(ResultPartition.class);
  final BufferConsumer bufferConsumer=createFilledBufferConsumer(42);
  final PipelinedSubpartition[] sources=new PipelinedSubpartition[numChannels];
  for (int i=0; i < numChannels; i++) {
    PipelinedSubpartition partition=new PipelinedSubpartition(0,resultPartition);
    for (int p=0; p < buffersPerChannel; p++) {
      partition.add(bufferConsumer.copy());
    }
    partition.finish();
    sources[i]=partition;
  }
  ResultPartitionManager resultPartitionManager=createResultPartitionManager(sources);
  SingleInputGate gate=new FairnessVerifyingInputGate("Test Task Name",new JobID(),new IntermediateDataSetID(),0,numChannels,mock(TaskActions.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(),true);
  for (int i=0; i < numChannels; i++) {
    LocalInputChannel channel=new LocalInputChannel(gate,i,new ResultPartitionID(),resultPartitionManager,mock(TaskEventDispatcher.class),UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup());
    gate.setInputChannel(new IntermediateResultPartitionID(),channel);
  }
  for (int i=numChannels * (buffersPerChannel + 1); i > 0; --i) {
    assertNotNull(gate.getNextBufferOrEvent());
    int min=Integer.MAX_VALUE;
    int max=0;
    for (    PipelinedSubpartition source : sources) {
      int size=source.getCurrentNumberOfBuffers();
      min=Math.min(min,size);
      max=Math.max(max,size);
    }
    assertTrue(max == min || max == (min + 1));
  }
  assertFalse(gate.getNextBufferOrEvent().isPresent());
}
