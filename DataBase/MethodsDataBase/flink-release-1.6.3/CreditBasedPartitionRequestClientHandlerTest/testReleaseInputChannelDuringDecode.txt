/** 
 * Tests a fix for FLINK-1627. <p> FLINK-1627 discovered a race condition, which could lead to an infinite loop when a receiver was cancelled during a certain time of decoding a message. The test reproduces the input, which lead to the infinite loop: when the handler gets a reference to the buffer provider of the receiving input channel, but the respective input channel is released (and the corresponding buffer provider destroyed), the handler did not notice this.
 * @see <a href="https://issues.apache.org/jira/browse/FLINK-1627">FLINK-1627</a>
 */
@Test(timeout=60000) @SuppressWarnings("unchecked") public void testReleaseInputChannelDuringDecode() throws Exception {
  final BufferProvider bufferProvider=mock(BufferProvider.class);
  when(bufferProvider.requestBuffer()).thenReturn(null);
  when(bufferProvider.isDestroyed()).thenReturn(true);
  when(bufferProvider.addBufferListener(any(BufferListener.class))).thenReturn(false);
  final RemoteInputChannel inputChannel=mock(RemoteInputChannel.class);
  when(inputChannel.getInputChannelId()).thenReturn(new InputChannelID());
  when(inputChannel.getBufferProvider()).thenReturn(bufferProvider);
  final BufferResponse receivedBuffer=createBufferResponse(TestBufferFactory.createBuffer(TestBufferFactory.BUFFER_SIZE),0,inputChannel.getInputChannelId(),2);
  final CreditBasedPartitionRequestClientHandler client=new CreditBasedPartitionRequestClientHandler();
  client.addInputChannel(inputChannel);
  client.channelRead(mock(ChannelHandlerContext.class),receivedBuffer);
}
