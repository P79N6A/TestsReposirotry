@Test public void testSnapshotAsyncClose() throws Exception {
  DefaultOperatorStateBackend operatorStateBackend=new DefaultOperatorStateBackend(OperatorStateBackendTest.class.getClassLoader(),new ExecutionConfig(),true);
  ListStateDescriptor<MutableType> stateDescriptor1=new ListStateDescriptor<>("test1",new JavaSerializer<MutableType>());
  ListState<MutableType> listState1=operatorStateBackend.getOperatorState(stateDescriptor1);
  listState1.add(MutableType.of(42));
  listState1.add(MutableType.of(4711));
  MapStateDescriptor<MutableType,MutableType> broadcastStateDescriptor1=new MapStateDescriptor<>("test4",new JavaSerializer<MutableType>(),new JavaSerializer<MutableType>());
  BroadcastState<MutableType,MutableType> broadcastState1=operatorStateBackend.getBroadcastState(broadcastStateDescriptor1);
  broadcastState1.put(MutableType.of(1),MutableType.of(2));
  broadcastState1.put(MutableType.of(2),MutableType.of(5));
  BlockerCheckpointStreamFactory streamFactory=new BlockerCheckpointStreamFactory(1024 * 1024);
  OneShotLatch waiterLatch=new OneShotLatch();
  OneShotLatch blockerLatch=new OneShotLatch();
  streamFactory.setWaiterLatch(waiterLatch);
  streamFactory.setBlockerLatch(blockerLatch);
  RunnableFuture<SnapshotResult<OperatorStateHandle>> runnableFuture=operatorStateBackend.snapshot(1,1,streamFactory,CheckpointOptions.forCheckpointWithDefaultLocation());
  ExecutorService executorService=Executors.newFixedThreadPool(1);
  executorService.submit(runnableFuture);
  waiterLatch.await();
  operatorStateBackend.close();
  blockerLatch.trigger();
  try {
    runnableFuture.get(60,TimeUnit.SECONDS);
    Assert.fail();
  }
 catch (  ExecutionException eex) {
    Assert.assertTrue(eex.getCause() instanceof IOException);
  }
}
