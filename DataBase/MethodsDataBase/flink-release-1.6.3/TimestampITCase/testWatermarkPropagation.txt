/** 
 * These check whether custom timestamp emission works at sources and also whether timestamps arrive at operators throughout a topology. <p>This also checks whether watermarks keep propagating if a source closes early. <p>This only uses map to test the workings of watermarks in a complete, running topology. All tasks and stream operators have dedicated tests that test the watermark propagation behaviour.
 */
@Test public void testWatermarkPropagation() throws Exception {
  final int numWatermarks=10;
  long initialTime=0L;
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
  env.setParallelism(PARALLELISM);
  env.getConfig().disableSysoutLogging();
  DataStream<Integer> source1=env.addSource(new MyTimestampSource(initialTime,numWatermarks));
  DataStream<Integer> source2=env.addSource(new MyTimestampSource(initialTime,numWatermarks / 2));
  source1.union(source2).map(new IdentityMap()).connect(source2).map(new IdentityCoMap()).transform("Custom Operator",BasicTypeInfo.INT_TYPE_INFO,new CustomOperator(true)).addSink(new DiscardingSink<Integer>());
  env.execute();
  for (int i=0; i < PARALLELISM; i++) {
    for (int j=0; j < numWatermarks / 2; j++) {
      if (!CustomOperator.finalWatermarks[i].get(j).equals(new Watermark(initialTime + j))) {
        System.err.println("All Watermarks: ");
        for (int k=0; k <= numWatermarks / 2; k++) {
          System.err.println(CustomOperator.finalWatermarks[i].get(k));
        }
        fail("Wrong watermark.");
      }
    }
    assertEquals(Watermark.MAX_WATERMARK,CustomOperator.finalWatermarks[i].get(CustomOperator.finalWatermarks[i].size() - 1));
  }
}
