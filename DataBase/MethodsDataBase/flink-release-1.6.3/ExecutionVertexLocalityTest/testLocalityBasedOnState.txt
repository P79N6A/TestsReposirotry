/** 
 * This test validates that stateful vertices schedule based in the state's location (which is the prior execution's location).
 */
@Test public void testLocalityBasedOnState() throws Exception {
  final int parallelism=10;
  final TaskManagerLocation[] locations=new TaskManagerLocation[parallelism];
  final ExecutionGraph graph=createTestGraph(parallelism,false);
  for (int i=0; i < parallelism; i++) {
    ExecutionVertex source=graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i];
    ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
    TaskManagerLocation randomLocation=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),10000 + i);
    TaskManagerLocation location=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),20000 + i);
    locations[i]=location;
    initializeLocation(source,randomLocation);
    initializeLocation(target,location);
    setState(source.getCurrentExecutionAttempt(),ExecutionState.CANCELED);
    setState(target.getCurrentExecutionAttempt(),ExecutionState.CANCELED);
  }
  for (  ExecutionJobVertex ejv : graph.getVerticesTopologically()) {
    ejv.resetForNewExecution(System.currentTimeMillis(),graph.getGlobalModVersion());
  }
  for (int i=0; i < parallelism; i++) {
    ExecutionVertex source=graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i];
    TaskManagerLocation randomLocation=new TaskManagerLocation(ResourceID.generate(),InetAddress.getLoopbackAddress(),30000 + i);
    initializeLocation(source,randomLocation);
    ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
    target.getCurrentExecutionAttempt().setInitialState(mock(JobManagerTaskRestore.class));
  }
  for (int i=0; i < parallelism; i++) {
    ExecutionVertex target=graph.getAllVertices().get(targetVertexId).getTaskVertices()[i];
    Iterator<CompletableFuture<TaskManagerLocation>> preference=target.getPreferredLocations().iterator();
    assertTrue(preference.hasNext());
    assertEquals(locations[i],preference.next().get());
    assertFalse(preference.hasNext());
  }
}
