/** 
 * Tests that the initial job registration registers a timeout which will call {@link JobLeaderIdActions#notifyJobTimeout(JobID,UUID)} when executed.
 */
@Test public void testInitialJobTimeout() throws Exception {
  final JobID jobId=new JobID();
  TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
  SettableLeaderRetrievalService leaderRetrievalService=new SettableLeaderRetrievalService(null,null);
  highAvailabilityServices.setJobMasterLeaderRetriever(jobId,leaderRetrievalService);
  ScheduledExecutor scheduledExecutor=mock(ScheduledExecutor.class);
  Time timeout=Time.milliseconds(5000L);
  JobLeaderIdActions jobLeaderIdActions=mock(JobLeaderIdActions.class);
  JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,scheduledExecutor,timeout);
  jobLeaderIdService.start(jobLeaderIdActions);
  jobLeaderIdService.addJob(jobId);
  assertTrue(jobLeaderIdService.containsJob(jobId));
  ArgumentCaptor<Runnable> runnableArgumentCaptor=ArgumentCaptor.forClass(Runnable.class);
  verify(scheduledExecutor).schedule(runnableArgumentCaptor.capture(),anyLong(),any(TimeUnit.class));
  Runnable timeoutRunnable=runnableArgumentCaptor.getValue();
  timeoutRunnable.run();
  ArgumentCaptor<UUID> timeoutIdArgumentCaptor=ArgumentCaptor.forClass(UUID.class);
  verify(jobLeaderIdActions,times(1)).notifyJobTimeout(eq(jobId),timeoutIdArgumentCaptor.capture());
  assertTrue(jobLeaderIdService.isValidTimeout(jobId,timeoutIdArgumentCaptor.getValue()));
}
