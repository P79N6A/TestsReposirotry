/** 
 * Tests that a timeout get cancelled once a job leader has been found. Furthermore, it tests that a new timeout is registered after the jobmanager has lost leadership.
 */
@Test(timeout=10000) public void jobTimeoutAfterLostLeadership() throws Exception {
  final JobID jobId=new JobID();
  final String address="foobar";
  final JobMasterId leaderId=JobMasterId.generate();
  TestingHighAvailabilityServices highAvailabilityServices=new TestingHighAvailabilityServices();
  SettableLeaderRetrievalService leaderRetrievalService=new SettableLeaderRetrievalService(null,null);
  highAvailabilityServices.setJobMasterLeaderRetriever(jobId,leaderRetrievalService);
  ScheduledFuture<?> timeout1=mock(ScheduledFuture.class);
  ScheduledFuture<?> timeout2=mock(ScheduledFuture.class);
  final Queue<ScheduledFuture<?>> timeoutQueue=new ArrayDeque<>(Arrays.asList(timeout1,timeout2));
  ScheduledExecutor scheduledExecutor=mock(ScheduledExecutor.class);
  final AtomicReference<Runnable> lastRunnable=new AtomicReference<>();
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      lastRunnable.set((Runnable)invocation.getArguments()[0]);
      return timeoutQueue.poll();
    }
  }
).when(scheduledExecutor).schedule(any(Runnable.class),anyLong(),any(TimeUnit.class));
  Time timeout=Time.milliseconds(5000L);
  JobLeaderIdActions jobLeaderIdActions=mock(JobLeaderIdActions.class);
  final AtomicReference<UUID> lastTimeoutId=new AtomicReference<>();
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      lastTimeoutId.set((UUID)invocation.getArguments()[1]);
      return null;
    }
  }
).when(jobLeaderIdActions).notifyJobTimeout(eq(jobId),any(UUID.class));
  JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(highAvailabilityServices,scheduledExecutor,timeout);
  jobLeaderIdService.start(jobLeaderIdActions);
  jobLeaderIdService.addJob(jobId);
  CompletableFuture<JobMasterId> leaderIdFuture=jobLeaderIdService.getLeaderId(jobId);
  leaderRetrievalService.notifyListener(address,leaderId.toUUID());
  assertEquals(leaderId,leaderIdFuture.get());
  assertTrue(jobLeaderIdService.containsJob(jobId));
  verify(timeout1,times(1)).cancel(anyBoolean());
  verify(scheduledExecutor,times(1)).schedule(any(Runnable.class),anyLong(),any(TimeUnit.class));
  Runnable runnable=lastRunnable.get();
  assertNotNull(runnable);
  runnable.run();
  verify(jobLeaderIdActions,times(1)).notifyJobTimeout(eq(jobId),any(UUID.class));
  assertFalse(jobLeaderIdService.isValidTimeout(jobId,lastTimeoutId.get()));
  leaderRetrievalService.notifyListener("",null);
  verify(scheduledExecutor,times(2)).schedule(any(Runnable.class),anyLong(),any(TimeUnit.class));
  runnable=lastRunnable.get();
  assertNotNull(runnable);
  runnable.run();
  verify(jobLeaderIdActions,times(2)).notifyJobTimeout(eq(jobId),any(UUID.class));
  assertTrue(jobLeaderIdService.isValidTimeout(jobId,lastTimeoutId.get()));
}
