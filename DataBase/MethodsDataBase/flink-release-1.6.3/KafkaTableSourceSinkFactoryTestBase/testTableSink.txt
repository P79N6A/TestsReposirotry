/** 
 * This test can be unified with the corresponding source test once we have fixed FLINK-9870.
 */
@Test public void testTableSink(){
  final TableSchema schema=TableSchema.builder().field(FRUIT_NAME,Types.STRING()).field(COUNT,Types.DECIMAL()).field(EVENT_TIME,Types.SQL_TIMESTAMP()).build();
  final KafkaTableSink expected=getExpectedKafkaTableSink(schema,TOPIC,KAFKA_PROPERTIES,Optional.of(new FlinkFixedPartitioner<>()),new TestSerializationSchema(schema.toRowType()));
  final TestTableDescriptor testDesc=new TestTableDescriptor(new Kafka().version(getKafkaVersion()).topic(TOPIC).properties(KAFKA_PROPERTIES).sinkPartitionerFixed().startFromSpecificOffsets(OFFSETS)).withFormat(new TestTableFormat()).withSchema(new Schema().field(FRUIT_NAME,Types.STRING()).field(COUNT,Types.DECIMAL()).field(EVENT_TIME,Types.SQL_TIMESTAMP())).inAppendMode();
  final Map<String,String> propertiesMap=DescriptorProperties.toJavaMap(testDesc);
  final TableSink<?> actualSink=TableFactoryService.find(StreamTableSinkFactory.class,propertiesMap).createStreamTableSink(propertiesMap);
  assertEquals(expected,actualSink);
  final KafkaTableSink actualKafkaSink=(KafkaTableSink)actualSink;
  final DataStreamMock streamMock=new DataStreamMock(new StreamExecutionEnvironmentMock(),schema.toRowType());
  actualKafkaSink.emitDataStream(streamMock);
  assertTrue(getExpectedFlinkKafkaProducer().isAssignableFrom(streamMock.sinkFunction.getClass()));
}
