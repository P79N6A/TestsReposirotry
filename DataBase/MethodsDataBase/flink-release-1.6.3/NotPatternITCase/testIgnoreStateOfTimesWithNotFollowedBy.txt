@Test public void testIgnoreStateOfTimesWithNotFollowedBy() throws Exception {
  List<StreamRecord<Event>> inputEvents=new ArrayList<>();
  Event a1=new Event(40,"a",1.0);
  Event e=new Event(41,"e",2.0);
  Event c1=new Event(42,"c",3.0);
  Event b1=new Event(43,"b",4.0);
  Event c2=new Event(44,"c",5.0);
  Event d1=new Event(45,"d",6.0);
  Event d2=new Event(46,"d",7.0);
  inputEvents.add(new StreamRecord<>(a1,1));
  inputEvents.add(new StreamRecord<>(d1,2));
  inputEvents.add(new StreamRecord<>(e,1));
  inputEvents.add(new StreamRecord<>(b1,3));
  inputEvents.add(new StreamRecord<>(c1,2));
  inputEvents.add(new StreamRecord<>(c2,4));
  inputEvents.add(new StreamRecord<>(d2,5));
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=2814850350025111940L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("a");
    }
  }
).notFollowedBy("notPattern").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=4988756153568853834L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("b");
    }
  }
).followedByAny("middle").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=-225909103322018778L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("c");
    }
  }
).times(2).optional().followedBy("end").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=-924294627956373696L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("d");
    }
  }
);
  NFA<Event> nfa=compile(pattern,false);
  final List<List<Event>> matches=feedNFA(inputEvents,nfa);
  compareMaps(matches,Lists.<List<Event>>newArrayList(Lists.newArrayList(a1,d1)));
}
