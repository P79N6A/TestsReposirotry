@Test public void testStateSnapshotAndRestore() throws Exception {
  MergingWindowAssigner<Integer,TimeWindow> mockAssigner=mockMergingAssigner();
  Trigger<Integer,TimeWindow> mockTrigger=mockTrigger();
  InternalWindowFunction<Iterable<Integer>,Void,Integer,TimeWindow> mockWindowFunction=mockWindowFunction();
  KeyedOneInputStreamOperatorTestHarness<Integer,Integer,Void> testHarness=createWindowOperator(mockAssigner,mockTrigger,0L,mockWindowFunction);
  testHarness.open();
  when(mockAssigner.assignWindows(anyInt(),anyLong(),anyAssignerContext())).thenReturn(Arrays.asList(new TimeWindow(2,4),new TimeWindow(0,2)));
  assertEquals(0,testHarness.getOutput().size());
  assertEquals(0,testHarness.numKeyedStateEntries());
  doAnswer(new Answer<TriggerResult>(){
    @Override public TriggerResult answer(    InvocationOnMock invocation) throws Exception {
      Trigger.TriggerContext context=(Trigger.TriggerContext)invocation.getArguments()[3];
      context.registerEventTimeTimer(0L);
      context.getPartitionedState(valueStateDescriptor).update("hello");
      return TriggerResult.CONTINUE;
    }
  }
).when(mockTrigger).onElement(Matchers.<Integer>anyObject(),anyLong(),anyTimeWindow(),anyTriggerContext());
  shouldFireAndPurgeOnEventTime(mockTrigger);
  testHarness.processElement(new StreamRecord<>(0,0L));
  assertEquals(5,testHarness.numKeyedStateEntries());
  assertEquals(4,testHarness.numEventTimeTimers());
  OperatorSubtaskState snapshot=testHarness.snapshot(0,0);
  mockAssigner=mockMergingAssigner();
  mockTrigger=mockTrigger();
  doAnswer(new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocation) throws Exception {
      Trigger.TriggerContext context=(Trigger.TriggerContext)invocation.getArguments()[1];
      context.deleteEventTimeTimer(0L);
      context.getPartitionedState(valueStateDescriptor).clear();
      return null;
    }
  }
).when(mockTrigger).clear(anyTimeWindow(),anyTriggerContext());
  when(mockTrigger.onEventTime(eq(0L),anyTimeWindow(),anyTriggerContext())).thenReturn(TriggerResult.FIRE);
  mockWindowFunction=mockWindowFunction();
  testHarness=createWindowOperator(mockAssigner,mockTrigger,0L,mockWindowFunction);
  testHarness.setup();
  testHarness.initializeState(snapshot);
  testHarness.open();
  assertEquals(0,testHarness.extractOutputStreamRecords().size());
  assertEquals(5,testHarness.numKeyedStateEntries());
  assertEquals(4,testHarness.numEventTimeTimers());
  verify(mockTrigger,never()).clear(anyTimeWindow(),anyTriggerContext());
  testHarness.processWatermark(new Watermark(20L));
  verify(mockTrigger,times(2)).clear(anyTimeWindow(),anyTriggerContext());
  verify(mockWindowFunction,times(2)).process(eq(0),anyTimeWindow(),anyInternalWindowContext(),anyIntIterable(),WindowOperatorContractTest.<Void>anyCollector());
  verify(mockWindowFunction,times(1)).process(eq(0),eq(new TimeWindow(0,2)),anyInternalWindowContext(),intIterable(0),WindowOperatorContractTest.<Void>anyCollector());
  verify(mockWindowFunction,times(1)).process(eq(0),eq(new TimeWindow(2,4)),anyInternalWindowContext(),intIterable(0),WindowOperatorContractTest.<Void>anyCollector());
  verify(mockTrigger,times(4)).onEventTime(anyLong(),anyTimeWindow(),anyTriggerContext());
  verify(mockTrigger,times(1)).onEventTime(eq(0L),eq(new TimeWindow(0,2)),anyTriggerContext());
  verify(mockTrigger,times(1)).onEventTime(eq(0L),eq(new TimeWindow(2,4)),anyTriggerContext());
  assertEquals(0,testHarness.numKeyedStateEntries());
  assertEquals(0,testHarness.numEventTimeTimers());
}
