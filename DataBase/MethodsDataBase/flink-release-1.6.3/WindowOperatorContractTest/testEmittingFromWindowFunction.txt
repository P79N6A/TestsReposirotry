@Test public void testEmittingFromWindowFunction() throws Exception {
  WindowAssigner<Integer,TimeWindow> mockAssigner=mockTimeWindowAssigner();
  Trigger<Integer,TimeWindow> mockTrigger=mockTrigger();
  InternalWindowFunction<Iterable<Integer>,String,Integer,TimeWindow> mockWindowFunction=mockWindowFunction();
  KeyedOneInputStreamOperatorTestHarness<Integer,Integer,String> testHarness=createWindowOperator(mockAssigner,mockTrigger,0L,mockWindowFunction);
  testHarness.open();
  when(mockAssigner.assignWindows(anyInt(),anyLong(),anyAssignerContext())).thenReturn(Collections.singletonList(new TimeWindow(0,2)));
  doAnswer(new Answer<TriggerResult>(){
    @Override public TriggerResult answer(    InvocationOnMock invocation) throws Exception {
      return TriggerResult.FIRE;
    }
  }
).when(mockTrigger).onElement(Matchers.<Integer>anyObject(),anyLong(),anyTimeWindow(),anyTriggerContext());
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Exception {
      @SuppressWarnings("unchecked") Collector<String> out=invocation.getArgumentAt(4,Collector.class);
      out.collect("Hallo");
      out.collect("Ciao");
      return null;
    }
  }
).when(mockWindowFunction).process(eq(0),eq(new TimeWindow(0,2)),anyInternalWindowContext(),intIterable(0),WindowOperatorContractTest.<String>anyCollector());
  testHarness.processElement(new StreamRecord<>(0,0L));
  verify(mockWindowFunction,times(1)).process(eq(0),eq(new TimeWindow(0,2)),anyInternalWindowContext(),intIterable(0),WindowOperatorContractTest.<String>anyCollector());
  assertThat(testHarness.extractOutputStreamRecords(),contains(isStreamRecord("Hallo",1L),isStreamRecord("Ciao",1L)));
}
