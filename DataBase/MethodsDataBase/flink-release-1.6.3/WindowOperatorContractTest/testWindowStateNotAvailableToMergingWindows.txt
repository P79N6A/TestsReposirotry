@Test public void testWindowStateNotAvailableToMergingWindows() throws Exception {
  WindowAssigner<Integer,TimeWindow> mockAssigner=mockMergingAssigner();
  Trigger<Integer,TimeWindow> mockTrigger=mockTrigger();
  InternalWindowFunction<Iterable<Integer>,Void,Integer,TimeWindow> mockWindowFunction=mockWindowFunction();
  KeyedOneInputStreamOperatorTestHarness<Integer,Integer,Void> testHarness=createWindowOperator(mockAssigner,mockTrigger,20L,mockWindowFunction);
  testHarness.open();
  when(mockTrigger.onElement(anyInt(),anyLong(),anyTimeWindow(),anyTriggerContext())).thenReturn(TriggerResult.FIRE);
  when(mockAssigner.assignWindows(anyInt(),anyLong(),anyAssignerContext())).thenReturn(Arrays.asList(new TimeWindow(0,20)));
  doAnswer(new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocationOnMock) throws Throwable {
      InternalWindowFunction.InternalWindowContext context=(InternalWindowFunction.InternalWindowContext)invocationOnMock.getArguments()[2];
      context.windowState().getState(valueStateDescriptor).update("hello");
      return null;
    }
  }
).when(mockWindowFunction).process(anyInt(),anyTimeWindow(),anyInternalWindowContext(),anyIntIterable(),WindowOperatorContractTest.<Void>anyCollector());
  expectedException.expect(UnsupportedOperationException.class);
  expectedException.expectMessage("Per-window state is not allowed when using merging windows.");
  testHarness.processElement(new StreamRecord<>(0,0L));
}
