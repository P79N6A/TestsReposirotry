/** 
 * We connect two different data streams in different chains to a CoMap. (This is not actually self-connect.)
 */
@Test public void differentDataStreamDifferentChain() throws Exception {
  TestListResultSink<String> resultSink=new TestListResultSink<>();
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setParallelism(3);
  DataStream<Integer> src=env.fromElements(1,3,5).disableChaining();
  DataStream<String> stringMap=src.flatMap(new FlatMapFunction<Integer,String>(){
    @Override public void flatMap(    Integer value,    Collector<String> out) throws Exception {
      out.collect("x " + value);
    }
  }
).keyBy(String::length);
  DataStream<Long> longMap=src.map(value -> (long)(value + 1)).keyBy(Long::intValue);
  stringMap.connect(longMap).map(new CoMapFunction<String,Long,String>(){
    @Override public String map1(    String value){
      return value;
    }
    @Override public String map2(    Long value){
      return value.toString();
    }
  }
).addSink(resultSink);
  env.execute();
  List<String> expected=Arrays.asList("x 1","x 3","x 5","2","4","6");
  List<String> result=resultSink.getResult();
  Collections.sort(expected);
  Collections.sort(result);
  assertEquals(expected,result);
}
