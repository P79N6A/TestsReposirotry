@Test public void testKvStateEntry() throws InterruptedException {
  final int threads=10;
  final CountDownLatch latch1=new CountDownLatch(threads);
  final CountDownLatch latch2=new CountDownLatch(1);
  final List<KvStateInfo<?,?,?>> infos=Collections.synchronizedList(new ArrayList<>());
  final JobID jobID=new JobID();
  final JobVertexID jobVertexId=new JobVertexID();
  final KeyGroupRange keyGroupRange=new KeyGroupRange(0,1);
  final String registrationName="foobar";
  final KvStateRegistry kvStateRegistry=new KvStateRegistry();
  final KvStateID stateID=kvStateRegistry.registerKvState(jobID,jobVertexId,keyGroupRange,registrationName,new DummyKvState());
  final AtomicReference<Throwable> exceptionHolder=new AtomicReference<>();
  for (int i=0; i < threads; i++) {
    new Thread(() -> {
      final KvStateEntry<?,?,?> kvState=kvStateRegistry.getKvState(stateID);
      final KvStateInfo<?,?,?> stateInfo=kvState.getInfoForCurrentThread();
      infos.add(stateInfo);
      latch1.countDown();
      try {
        latch2.await();
      }
 catch (      InterruptedException e) {
        exceptionHolder.compareAndSet(null,e);
      }
    }
).start();
  }
  latch1.await();
  final KvStateEntry<?,?,?> kvState=kvStateRegistry.getKvState(stateID);
  Assert.assertEquals(threads,infos.size());
  Assert.assertEquals(threads,kvState.getCacheSize());
  latch2.countDown();
  for (  KvStateInfo<?,?,?> infoA : infos) {
    boolean instanceAlreadyFound=false;
    for (    KvStateInfo<?,?,?> infoB : infos) {
      if (infoA == infoB) {
        if (instanceAlreadyFound) {
          Assert.fail("More than one thread sharing the same serializer instance.");
        }
        instanceAlreadyFound=true;
      }
 else {
        Assert.assertEquals(infoA,infoB);
      }
    }
  }
  kvStateRegistry.unregisterKvState(jobID,jobVertexId,keyGroupRange,registrationName,stateID);
  Assert.assertEquals(0L,kvState.getCacheSize());
  Throwable t=exceptionHolder.get();
  if (t != null) {
    fail(t.getMessage());
  }
}
