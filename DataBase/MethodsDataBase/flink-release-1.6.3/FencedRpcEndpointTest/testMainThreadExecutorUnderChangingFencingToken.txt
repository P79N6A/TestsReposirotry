/** 
 * Tests that call via the MainThreadExecutor fail after the fencing token changes.
 */
@Test public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {
  final Time shortTimeout=Time.milliseconds(100L);
  final UUID initialFencingToken=UUID.randomUUID();
  final String value="foobar";
  final FencedTestingEndpoint fencedTestingEndpoint=new FencedTestingEndpoint(rpcService,value,initialFencingToken);
  try {
    fencedTestingEndpoint.start();
    FencedTestingGateway selfGateway=fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class);
    CompletableFuture<Acknowledge> mainThreadExecutorComputation=selfGateway.triggerMainThreadExecutorComputation(timeout);
    final UUID newFencingToken=UUID.randomUUID();
    CompletableFuture<Acknowledge> newFencingTokenFuture=fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken,timeout);
    newFencingTokenFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    CompletableFuture<Acknowledge> triggerFuture=selfGateway.triggerComputationLatch(timeout);
    triggerFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    try {
      mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(),TimeUnit.MILLISECONDS);
      fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.");
    }
 catch (    TimeoutException ignored) {
    }
  }
  finally {
    fencedTestingEndpoint.shutDown();
    fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
  }
}
