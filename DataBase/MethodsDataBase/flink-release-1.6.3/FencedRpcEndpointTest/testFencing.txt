/** 
 * Tests that messages with the wrong fencing token are filtered out.
 */
@Test public void testFencing() throws Exception {
  final UUID fencingToken=UUID.randomUUID();
  final UUID wrongFencingToken=UUID.randomUUID();
  final String value="barfoo";
  FencedTestingEndpoint fencedTestingEndpoint=new FencedTestingEndpoint(rpcService,value,fencingToken);
  try {
    fencedTestingEndpoint.start();
    final FencedTestingGateway properFencedGateway=rpcService.connect(fencedTestingEndpoint.getAddress(),fencingToken,FencedTestingGateway.class).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    final FencedTestingGateway wronglyFencedGateway=rpcService.connect(fencedTestingEndpoint.getAddress(),wrongFencingToken,FencedTestingGateway.class).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    assertEquals(value,properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS));
    try {
      wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
      fail("This should fail since we have the wrong fencing token.");
    }
 catch (    ExecutionException e) {
      assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException);
    }
    final UUID newFencingToken=UUID.randomUUID();
    CompletableFuture<Acknowledge> newFencingTokenFuture=fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken,timeout);
    newFencingTokenFuture.get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
    try {
      properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
      fail("This should fail since we have the wrong fencing token by now.");
    }
 catch (    ExecutionException e) {
      assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException);
    }
  }
  finally {
    fencedTestingEndpoint.shutDown();
    fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(),TimeUnit.MILLISECONDS);
  }
}
