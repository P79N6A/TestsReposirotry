@Test public void testStreamToLastSeenShardStateIsCorrectlySetWhenNotRestoringFromFailure() throws Exception {
  List<String> fakeStreams=new LinkedList<>();
  fakeStreams.add("fakeStream1");
  fakeStreams.add("fakeStream2");
  fakeStreams.add("fakeStream3");
  fakeStreams.add("fakeStream4");
  HashMap<String,String> subscribedStreamsToLastSeenShardIdsUnderTest=KinesisDataFetcher.createInitialSubscribedStreamsToLastDiscoveredShardsState(fakeStreams);
  Map<String,Integer> streamToShardCount=new HashMap<>();
  Random rand=new Random();
  for (  String fakeStream : fakeStreams) {
    streamToShardCount.put(fakeStream,rand.nextInt(5) + 1);
  }
  final TestableKinesisDataFetcher<String> fetcher=new TestableKinesisDataFetcher<>(fakeStreams,new TestSourceContext<>(),TestUtils.getStandardProperties(),new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),10,2,new AtomicReference<>(),new LinkedList<>(),subscribedStreamsToLastSeenShardIdsUnderTest,FakeKinesisBehavioursFactory.nonReshardedStreamsBehaviour(streamToShardCount));
  final DummyFlinkKinesisConsumer<String> consumer=new DummyFlinkKinesisConsumer<>(TestUtils.getStandardProperties(),fetcher,1,0);
  CheckedThread consumerThread=new CheckedThread(){
    @Override public void go() throws Exception {
      consumer.run(new TestSourceContext<>());
    }
  }
;
  consumerThread.start();
  fetcher.waitUntilRun();
  consumer.cancel();
  consumerThread.sync();
  Set<String> streamsInState=subscribedStreamsToLastSeenShardIdsUnderTest.keySet();
  assertEquals(fakeStreams.size(),streamsInState.size());
  assertTrue(streamsInState.containsAll(fakeStreams));
  for (  Map.Entry<String,String> streamToLastSeenShard : subscribedStreamsToLastSeenShardIdsUnderTest.entrySet()) {
    assertEquals(KinesisShardIdGenerator.generateFromShardOrder(streamToShardCount.get(streamToLastSeenShard.getKey()) - 1),streamToLastSeenShard.getValue());
  }
}
