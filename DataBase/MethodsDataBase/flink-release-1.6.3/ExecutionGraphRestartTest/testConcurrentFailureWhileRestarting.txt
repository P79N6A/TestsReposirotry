/** 
 * Tests that the  {@link ExecutionGraph} can handle concurrent failures whilebeing in the RESTARTING state.
 */
@Test public void testConcurrentFailureWhileRestarting() throws Exception {
  final long timeout=5000L;
  final CountDownLatch countDownLatch=new CountDownLatch(2);
  final CountDownLatchRestartStrategy restartStrategy=new CountDownLatchRestartStrategy(countDownLatch);
  final ExecutionGraph executionGraph=createSimpleExecutionGraph(restartStrategy,new TestingSlotProvider(ignored -> new CompletableFuture<>()));
  executionGraph.setQueuedSchedulingAllowed(true);
  executionGraph.scheduleForExecution();
  assertThat(executionGraph.getState(),is(JobStatus.RUNNING));
  executionGraph.failGlobal(new FlinkException("Test exception"));
  executor.execute(() -> {
    countDownLatch.countDown();
    try {
      countDownLatch.await();
    }
 catch (    InterruptedException e) {
      ExceptionUtils.rethrow(e);
    }
    executionGraph.failGlobal(new FlinkException("Concurrent exception"));
  }
);
  waitUntilJobStatus(executionGraph,JobStatus.RUNNING,timeout);
}
