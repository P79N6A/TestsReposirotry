/** 
 * Tests that only elements before the oldest watermark are returned if they are completed.
 */
@Test public void testCompletionOrder() throws Exception {
  OperatorActions operatorActions=mock(OperatorActions.class);
  final UnorderedStreamElementQueue queue=new UnorderedStreamElementQueue(8,executor,operatorActions);
  StreamRecordQueueEntry<Integer> record1=new StreamRecordQueueEntry<>(new StreamRecord<>(1,0L));
  StreamRecordQueueEntry<Integer> record2=new StreamRecordQueueEntry<>(new StreamRecord<>(2,1L));
  WatermarkQueueEntry watermark1=new WatermarkQueueEntry(new Watermark(2L));
  StreamRecordQueueEntry<Integer> record3=new StreamRecordQueueEntry<>(new StreamRecord<>(3,3L));
  StreamRecordQueueEntry<Integer> record4=new StreamRecordQueueEntry<>(new StreamRecord<>(4,4L));
  WatermarkQueueEntry watermark2=new WatermarkQueueEntry(new Watermark(5L));
  StreamRecordQueueEntry<Integer> record5=new StreamRecordQueueEntry<>(new StreamRecord<>(5,6L));
  StreamRecordQueueEntry<Integer> record6=new StreamRecordQueueEntry<>(new StreamRecord<>(6,7L));
  List<StreamElementQueueEntry<?>> entries=Arrays.asList(record1,record2,watermark1,record3,record4,watermark2,record5,record6);
  for (  StreamElementQueueEntry<?> entry : entries) {
    queue.put(entry);
  }
  Assert.assertTrue(8 == queue.size());
  CompletableFuture<AsyncResult> firstPoll=CompletableFuture.supplyAsync(() -> {
    try {
      return queue.poll();
    }
 catch (    InterruptedException e) {
      throw new CompletionException(e);
    }
  }
,executor);
  record3.complete(Collections.<Integer>emptyList());
  Thread.sleep(10L);
  Assert.assertFalse(firstPoll.isDone());
  record2.complete(Collections.<Integer>emptyList());
  Assert.assertEquals(record2,firstPoll.get());
  CompletableFuture<AsyncResult> secondPoll=CompletableFuture.supplyAsync(() -> {
    try {
      return queue.poll();
    }
 catch (    InterruptedException e) {
      throw new CompletionException(e);
    }
  }
,executor);
  record6.complete(Collections.<Integer>emptyList());
  record4.complete(Collections.<Integer>emptyList());
  Thread.sleep(10L);
  Assert.assertFalse(secondPoll.isDone());
  record1.complete(Collections.<Integer>emptyList());
  Assert.assertEquals(record1,secondPoll.get());
  Assert.assertEquals(watermark1,queue.poll());
  Set<AsyncResult> expected=new HashSet<>(2);
  expected.add(record3);
  expected.add(record4);
  Set<AsyncResult> actual=new HashSet<>(2);
  actual.add(queue.poll());
  actual.add(queue.poll());
  Assert.assertEquals(expected,actual);
  Assert.assertEquals(watermark2,queue.poll());
  Assert.assertEquals(record6,queue.poll());
  Assert.assertTrue(1 == queue.size());
  CompletableFuture<AsyncResult> thirdPoll=CompletableFuture.supplyAsync(() -> {
    try {
      return queue.poll();
    }
 catch (    InterruptedException e) {
      throw new CompletionException(e);
    }
  }
,executor);
  Thread.sleep(10L);
  Assert.assertFalse(thirdPoll.isDone());
  record5.complete(Collections.<Integer>emptyList());
  Assert.assertEquals(record5,thirdPoll.get());
  Assert.assertTrue(queue.isEmpty());
  verify(operatorActions,never()).failOperator(any(Exception.class));
}
