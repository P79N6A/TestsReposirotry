@Test public void testIterativeUntilConditionOneOrMore() throws Exception {
  List<StreamRecord<Event>> inputEvents=new ArrayList<>();
  Event startEvent=new Event(40,"c",1.0);
  Event middleEvent1=new Event(41,"a",2.0);
  Event middleEvent2=new Event(42,"a",3.0);
  Event middleEvent3=new Event(40,"d",1.0);
  Event breaking=new Event(44,"a",5.0);
  Event ignored=new Event(45,"a",6.0);
  inputEvents.add(new StreamRecord<>(startEvent,1));
  inputEvents.add(new StreamRecord<>(middleEvent1,3));
  inputEvents.add(new StreamRecord<>(middleEvent2,4));
  inputEvents.add(new StreamRecord<>(middleEvent3,5));
  inputEvents.add(new StreamRecord<>(breaking,6));
  inputEvents.add(new StreamRecord<>(ignored,7));
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=5726188262756267490L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("c");
    }
  }
).followedBy("middle").oneOrMore().until(new IterativeCondition<Event>(){
    @Override public boolean filter(    Event value,    Context<Event> ctx) throws Exception {
      double sum=0;
      for (      Event middle : ctx.getEventsForPattern("middle")) {
        sum+=middle.getPrice();
      }
      return sum == 6.0;
    }
  }
);
  NFA<Event> nfa=compile(pattern,false);
  NFAState nfaState=nfa.createInitialNFAState();
  final List<List<Event>> resultingPatterns=feedNFA(inputEvents,nfa,nfaState);
  compareMaps(resultingPatterns,Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent,middleEvent1,middleEvent2,middleEvent3),Lists.newArrayList(startEvent,middleEvent1,middleEvent2),Lists.newArrayList(startEvent,middleEvent1)));
  assertEquals(1,nfaState.getPartialMatches().size());
  assertEquals("start",nfaState.getPartialMatches().peek().getCurrentStateName());
}
