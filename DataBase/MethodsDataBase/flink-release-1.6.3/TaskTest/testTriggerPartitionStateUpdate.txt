/** 
 * Tests the trigger partition state update future completions.
 */
@Test public void testTriggerPartitionStateUpdate() throws Exception {
  IntermediateDataSetID resultId=new IntermediateDataSetID();
  ResultPartitionID partitionId=new ResultPartitionID();
  BlobCacheService blobService=createBlobCache();
  LibraryCacheManager libCache=mock(LibraryCacheManager.class);
  when(libCache.getClassLoader(any(JobID.class))).thenReturn(getClass().getClassLoader());
  PartitionProducerStateChecker partitionChecker=mock(PartitionProducerStateChecker.class);
  TaskEventDispatcher taskEventDispatcher=mock(TaskEventDispatcher.class);
  ResultPartitionConsumableNotifier consumableNotifier=new NoOpResultPartitionConsumableNotifier();
  NetworkEnvironment network=mock(NetworkEnvironment.class);
  when(network.getResultPartitionManager()).thenReturn(mock(ResultPartitionManager.class));
  when(network.getDefaultIOMode()).thenReturn(IOManager.IOMode.SYNC);
  when(network.createKvStateTaskRegistry(any(JobID.class),any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class));
  when(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
  createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
{
    createQueuesAndActors();
    Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
    CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
    when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
    task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
    promise.completeExceptionally(new PartitionProducerDisposedException(partitionId));
    assertEquals(ExecutionState.CANCELING,task.getExecutionState());
  }
{
    createQueuesAndActors();
    Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
    CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
    when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
    task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
    promise.completeExceptionally(new RuntimeException("Any other exception"));
    assertEquals(ExecutionState.FAILED,task.getExecutionState());
  }
{
    createQueuesAndActors();
    Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
    SingleInputGate inputGate=mock(SingleInputGate.class);
    when(inputGate.getConsumedResultId()).thenReturn(resultId);
    try {
      task.startTaskThread();
      awaitLatch.await();
      setInputGate(task,inputGate);
      CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
      when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
      task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
      promise.completeExceptionally(new TimeoutException());
      assertEquals(ExecutionState.RUNNING,task.getExecutionState());
      verify(inputGate,times(1)).retriggerPartitionRequest(eq(partitionId.getPartitionId()));
    }
  finally {
      task.getExecutingThread().interrupt();
      task.getExecutingThread().join();
    }
  }
{
    createQueuesAndActors();
    Task task=createTask(InvokableBlockingInInvoke.class,blobService,libCache,network,consumableNotifier,partitionChecker,Executors.directExecutor());
    SingleInputGate inputGate=mock(SingleInputGate.class);
    when(inputGate.getConsumedResultId()).thenReturn(resultId);
    try {
      task.startTaskThread();
      awaitLatch.await();
      setInputGate(task,inputGate);
      CompletableFuture<ExecutionState> promise=new CompletableFuture<>();
      when(partitionChecker.requestPartitionProducerState(eq(task.getJobID()),eq(resultId),eq(partitionId))).thenReturn(promise);
      task.triggerPartitionProducerStateCheck(task.getJobID(),resultId,partitionId);
      promise.complete(ExecutionState.RUNNING);
      assertEquals(ExecutionState.RUNNING,task.getExecutionState());
      verify(inputGate,times(1)).retriggerPartitionRequest(eq(partitionId.getPartitionId()));
    }
  finally {
      task.getExecutingThread().interrupt();
      task.getExecutingThread().join();
    }
  }
}
