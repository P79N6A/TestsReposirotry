/** 
 * This test makes sure that the checkpoint is already registered by the time that the hooks are called
 */
@Test public void ensureRegisteredAtHookTime() throws Exception {
  final String id="id";
  final JobID jid=new JobID();
  final ExecutionAttemptID execId=new ExecutionAttemptID();
  final ExecutionVertex ackVertex=mockExecutionVertex(execId);
  final CheckpointCoordinator cc=instantiateCheckpointCoordinator(jid,ackVertex);
  final MasterTriggerRestoreHook<Void> hook=mockGeneric(MasterTriggerRestoreHook.class);
  when(hook.getIdentifier()).thenReturn(id);
  when(hook.triggerCheckpoint(anyLong(),anyLong(),any(Executor.class))).thenAnswer(new Answer<CompletableFuture<Void>>(){
    @Override public CompletableFuture<Void> answer(    InvocationOnMock invocation) throws Throwable {
      assertEquals(1,cc.getNumberOfPendingCheckpoints());
      long checkpointId=(Long)invocation.getArguments()[0];
      assertNotNull(cc.getPendingCheckpoints().get(checkpointId));
      return null;
    }
  }
);
  cc.addMasterHook(hook);
  assertTrue(cc.triggerCheckpoint(System.currentTimeMillis(),false));
}
