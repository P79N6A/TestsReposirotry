/** 
 * Tests simple reducing state queryable state instance. Each source emits (subtaskIndex, 0)..(subtaskIndex, numElements) tuples, which are then queried. The reducing state instance sums these up. The test succeeds after each subtask index is queried with result n*(n+1)/2.
 */
@Test public void testReducingState() throws Exception {
  final Deadline deadline=Deadline.now().plus(TEST_TIMEOUT);
  final long numElements=1024L;
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setStateBackend(stateBackend);
  env.setParallelism(maxParallelism);
  env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE,1000L));
  DataStream<Tuple2<Integer,Long>> source=env.addSource(new TestAscendingValueSource(numElements));
  ReducingStateDescriptor<Tuple2<Integer,Long>> reducingState=new ReducingStateDescriptor<>("any",new SumReduce(),source.getType());
  source.keyBy(new KeySelector<Tuple2<Integer,Long>,Integer>(){
    private static final long serialVersionUID=8470749712274833552L;
    @Override public Integer getKey(    Tuple2<Integer,Long> value){
      return value.f0;
    }
  }
).asQueryableState("jungle",reducingState);
  try (AutoCancellableJob autoCancellableJob=new AutoCancellableJob(deadline,clusterClient,env)){
    final JobID jobId=autoCancellableJob.getJobId();
    final JobGraph jobGraph=autoCancellableJob.getJobGraph();
    clusterClient.setDetached(true);
    clusterClient.submitJob(jobGraph,AbstractQueryableStateTestBase.class.getClassLoader());
    final long expected=numElements * (numElements + 1L) / 2L;
    for (int key=0; key < maxParallelism; key++) {
      boolean success=false;
      while (deadline.hasTimeLeft() && !success) {
        CompletableFuture<ReducingState<Tuple2<Integer,Long>>> future=getKvState(deadline,client,jobId,"jungle",key,BasicTypeInfo.INT_TYPE_INFO,reducingState,false,executor);
        Tuple2<Integer,Long> value=future.get(deadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS).get();
        assertEquals("Key mismatch",key,value.f0.intValue());
        if (expected == value.f1) {
          success=true;
        }
 else {
          Thread.sleep(RETRY_TIMEOUT);
        }
      }
      assertTrue("Did not succeed query",success);
    }
  }
 }
