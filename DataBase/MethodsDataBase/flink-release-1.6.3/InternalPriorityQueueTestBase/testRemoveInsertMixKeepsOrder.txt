@Test public void testRemoveInsertMixKeepsOrder(){
  InternalPriorityQueue<TestElement> priorityQueue=newPriorityQueue(3);
  final Comparator<Long> comparator=getTestElementPriorityComparator();
  final ThreadLocalRandom random=ThreadLocalRandom.current();
  final int testSize=300;
  final int addCounterMax=testSize / 4;
  int iterationsTillNextAdds=random.nextInt(addCounterMax);
  HashSet<TestElement> checkSet=new HashSet<>(testSize);
  insertRandomElements(priorityQueue,checkSet,testSize);
  while (!checkSet.isEmpty()) {
    final long highestPrioValue=getHighestPriorityValueForComparator();
    Iterator<TestElement> iterator=checkSet.iterator();
    TestElement element=iterator.next();
    iterator.remove();
    final boolean removesHead=element.equals(priorityQueue.peek());
    if (removesHead) {
      Assert.assertTrue(priorityQueue.remove(element));
    }
 else {
      priorityQueue.remove(element);
    }
    long currentPriorityWatermark;
    if (removesHead) {
      currentPriorityWatermark=element.getPriority();
    }
 else {
      currentPriorityWatermark=highestPrioValue;
    }
    while ((element=priorityQueue.poll()) != null) {
      Assert.assertTrue(comparator.compare(element.getPriority(),currentPriorityWatermark) >= 0);
      currentPriorityWatermark=element.getPriority();
      if (--iterationsTillNextAdds == 0) {
        iterationsTillNextAdds=random.nextInt(addCounterMax);
        insertRandomElements(priorityQueue,new HashSet<>(checkSet),1 + random.nextInt(3));
        currentPriorityWatermark=priorityQueue.peek().getPriority();
      }
    }
    Assert.assertTrue(priorityQueue.isEmpty());
    priorityQueue.addAll(checkSet);
  }
}
