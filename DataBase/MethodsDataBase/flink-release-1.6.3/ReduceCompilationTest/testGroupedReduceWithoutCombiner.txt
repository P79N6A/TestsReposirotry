/** 
 * Test program compilation when the Reduce's combiner has been excluded by setting  {@code CombineHint.NONE}.
 */
@Test public void testGroupedReduceWithoutCombiner(){
  ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  env.setParallelism(8);
  DataSet<Tuple2<String,Double>> data=env.readCsvFile("file:///will/never/be/read").types(String.class,Double.class).name("source").setParallelism(6);
  data.groupBy(0).reduce(new RichReduceFunction<Tuple2<String,Double>>(){
    @Override public Tuple2<String,Double> reduce(    Tuple2<String,Double> value1,    Tuple2<String,Double> value2){
      return null;
    }
  }
).setCombineHint(CombineHint.NONE).name("reducer").output(new DiscardingOutputFormat<Tuple2<String,Double>>()).name("sink");
  Plan p=env.createProgramPlan();
  OptimizedPlan op=compileNoStats(p);
  OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(op);
  SourcePlanNode sourceNode=resolver.getNode("source");
  SingleInputPlanNode reduceNode=resolver.getNode("reducer");
  SinkPlanNode sinkNode=resolver.getNode("sink");
  assertEquals(sourceNode,reduceNode.getInput().getSource());
  assertEquals(DriverStrategy.SORTED_REDUCE,reduceNode.getDriverStrategy());
  assertEquals(new FieldList(0),reduceNode.getKeys(0));
  assertEquals(new FieldList(0),reduceNode.getInput().getLocalStrategyKeys());
  assertEquals(6,sourceNode.getParallelism());
  assertEquals(8,reduceNode.getParallelism());
  assertEquals(8,sinkNode.getParallelism());
}
