@Test public void testTimesRangeStrictOptional1() throws Exception {
  List<StreamRecord<Event>> inputEvents=new ArrayList<>();
  inputEvents.add(new StreamRecord<>(ConsecutiveData.startEvent,1));
  inputEvents.add(new StreamRecord<>(ConsecutiveData.middleEvent1,3));
  inputEvents.add(new StreamRecord<>(ConsecutiveData.middleEvent2,5));
  inputEvents.add(new StreamRecord<>(ConsecutiveData.middleEvent3,6));
  inputEvents.add(new StreamRecord<>(ConsecutiveData.end,7));
  Pattern<Event,?> pattern=Pattern.<Event>begin("start").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=5726188262756267490L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("c");
    }
  }
).next("middle").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=5726188262756267490L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("a");
    }
  }
).times(1,3).consecutive().optional().followedBy("end1").where(new SimpleCondition<Event>(){
    private static final long serialVersionUID=5726188262756267490L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("b");
    }
  }
);
  NFA<Event> nfa=compile(pattern,false);
  List<List<Event>> resultingPatterns=feedNFA(inputEvents,nfa);
  compareMaps(resultingPatterns,Lists.<List<Event>>newArrayList(Lists.newArrayList(ConsecutiveData.startEvent,ConsecutiveData.middleEvent1,ConsecutiveData.middleEvent2,ConsecutiveData.middleEvent3,ConsecutiveData.end),Lists.newArrayList(ConsecutiveData.startEvent,ConsecutiveData.middleEvent1,ConsecutiveData.middleEvent2,ConsecutiveData.end),Lists.newArrayList(ConsecutiveData.startEvent,ConsecutiveData.middleEvent1,ConsecutiveData.end),Lists.newArrayList(ConsecutiveData.startEvent,ConsecutiveData.end)));
}
