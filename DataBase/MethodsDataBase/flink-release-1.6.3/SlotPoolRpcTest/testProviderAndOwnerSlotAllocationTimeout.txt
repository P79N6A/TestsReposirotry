/** 
 * This case make sure when allocateSlot in ProviderAndOwner timeout, it will automatically call cancelSlotAllocation as will inject future.whenComplete in ProviderAndOwner.
 */
@Test public void testProviderAndOwnerSlotAllocationTimeout() throws Exception {
  final JobID jid=new JobID();
  final TestingSlotPool pool=new TestingSlotPool(rpcService,jid,SystemClock.getInstance(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime());
  final CompletableFuture<SlotRequestId> releaseSlotFuture=new CompletableFuture<>();
  pool.setReleaseSlotConsumer(slotRequestID -> releaseSlotFuture.complete(slotRequestID));
  try {
    pool.start(JobMasterId.generate(),"foobar");
    ResourceManagerGateway resourceManagerGateway=new TestingResourceManagerGateway();
    pool.connectToResourceManager(resourceManagerGateway);
    CompletableFuture<LogicalSlot> future=pool.getSlotProvider().allocateSlot(new DummyScheduledUnit(),true,SlotProfile.noRequirements(),fastTimeout);
    try {
      future.get();
      fail("We expected a TimeoutException.");
    }
 catch (    ExecutionException e) {
      assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException);
    }
    releaseSlotFuture.get();
    assertEquals(0L,(long)pool.getNumberOfPendingRequests().get());
  }
  finally {
    RpcUtils.terminateRpcEndpoint(pool,timeout);
  }
}
