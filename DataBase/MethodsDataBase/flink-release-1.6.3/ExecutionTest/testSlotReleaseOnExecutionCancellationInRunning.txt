/** 
 * Tests that the slot is released in case of a execution cancellation when being in state RUNNING.
 */
@Test public void testSlotReleaseOnExecutionCancellationInRunning() throws Exception {
  final JobVertex jobVertex=createNoOpJobVertex();
  final JobVertexID jobVertexId=jobVertex.getID();
  final SingleSlotTestingSlotOwner slotOwner=new SingleSlotTestingSlotOwner();
  final SimpleSlot slot=new SimpleSlot(slotOwner,new LocalTaskManagerLocation(),0,new SimpleAckingTaskManagerGateway());
  final ProgrammedSlotProvider slotProvider=new ProgrammedSlotProvider(1);
  slotProvider.addSlot(jobVertexId,0,CompletableFuture.completedFuture(slot));
  ExecutionGraph executionGraph=ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(),slotProvider,new NoRestartStrategy(),jobVertex);
  ExecutionJobVertex executionJobVertex=executionGraph.getJobVertex(jobVertexId);
  final Execution execution=executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt();
  CompletableFuture<Execution> allocationFuture=execution.allocateAndAssignSlotForExecution(slotProvider,false,LocationPreferenceConstraint.ALL,Collections.emptySet(),TestingUtils.infiniteTime());
  assertTrue(allocationFuture.isDone());
  assertEquals(ExecutionState.SCHEDULED,execution.getState());
  assertEquals(slot,execution.getAssignedResource());
  execution.deploy();
  execution.switchToRunning();
  execution.cancel();
  assertEquals(ExecutionState.CANCELING,execution.getState());
  execution.cancelingComplete();
  assertEquals(slot,slotOwner.getReturnedSlotFuture().get());
}
