@Test public void testCEPOperatorCleanupEventTimeWithSameElements() throws Exception {
  Event startEvent=new Event(41,"c",1.0);
  Event middle1Event1=new Event(41,"a",2.0);
  Event middle1Event2=new Event(41,"a",3.0);
  Event middle1Event3=new Event(41,"a",4.0);
  Event middle2Event1=new Event(41,"b",5.0);
  SelectCepOperator<Event,Integer,Map<String,List<Event>>> operator=CepOperatorTestUtilities.getKeyedCepOpearator(false,new ComplexNFAFactory());
  OneInputStreamOperatorTestHarness<Event,Map<String,List<Event>>> harness=CepOperatorTestUtilities.getCepTestHarness(operator);
  try {
    harness.open();
    harness.processWatermark(new Watermark(Long.MIN_VALUE));
    harness.processElement(new StreamRecord<>(middle2Event1,6));
    harness.processElement(new StreamRecord<>(middle1Event3,7));
    harness.processElement(new StreamRecord<>(startEvent,1));
    harness.processElement(new StreamRecord<>(middle1Event1,3));
    harness.processElement(new StreamRecord<>(middle1Event2,3));
    harness.processElement(new StreamRecord<>(middle1Event1,3));
    harness.processElement(new StreamRecord<>(new Event(41,"d",6.0),5));
    assertEquals(1L,harness.numEventTimeTimers());
    assertEquals(7L,operator.getPQSize(41));
    assertTrue(!operator.hasNonEmptySharedBuffer(41));
    harness.processWatermark(new Watermark(2L));
    verifyWatermark(harness.getOutput().poll(),Long.MIN_VALUE);
    verifyWatermark(harness.getOutput().poll(),2L);
    assertEquals(1L,harness.numEventTimeTimers());
    assertEquals(6L,operator.getPQSize(41));
    assertTrue(operator.hasNonEmptySharedBuffer(41));
    harness.processWatermark(new Watermark(8L));
    List<List<Event>> resultingPatterns=new ArrayList<>();
    while (!harness.getOutput().isEmpty()) {
      Object o=harness.getOutput().poll();
      if (!(o instanceof Watermark)) {
        StreamRecord<Map<String,List<Event>>> el=(StreamRecord<Map<String,List<Event>>>)o;
        List<Event> res=new ArrayList<>();
        for (        List<Event> le : el.getValue().values()) {
          res.addAll(le);
        }
        resultingPatterns.add(res);
      }
 else {
        verifyWatermark(o,8L);
      }
    }
    compareMaps(resultingPatterns,Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent,middle1Event1),Lists.newArrayList(startEvent,middle1Event1,middle1Event2),Lists.newArrayList(startEvent,middle2Event1,middle1Event3),Lists.newArrayList(startEvent,middle1Event1,middle1Event2,middle1Event1),Lists.newArrayList(startEvent,middle1Event1,middle2Event1,middle1Event3),Lists.newArrayList(startEvent,middle1Event1,middle1Event1,middle1Event2,middle1Event3),Lists.newArrayList(startEvent,middle1Event1,middle1Event2,middle2Event1,middle1Event3),Lists.newArrayList(startEvent,middle1Event1,middle1Event1,middle1Event2,middle2Event1,middle1Event3)));
    assertEquals(1L,harness.numEventTimeTimers());
    assertEquals(0L,operator.getPQSize(41));
    assertTrue(operator.hasNonEmptySharedBuffer(41));
    harness.processWatermark(new Watermark(17L));
    verifyWatermark(harness.getOutput().poll(),17L);
    assertTrue(!operator.hasNonEmptySharedBuffer(41));
    assertTrue(!operator.hasNonEmptyPQ(41));
    assertEquals(0L,harness.numEventTimeTimers());
  }
  finally {
    harness.close();
  }
}
