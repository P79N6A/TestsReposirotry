/** 
 * This tests the following case: - an alignment starts - barriers from a second checkpoint queue before the first completes - together they are larger than the threshold - after the first checkpoint (with second checkpoint data queued) aborts, the second completes.
 */
@Test public void testAlignmentLimitWithQueuedAlignments() throws Exception {
  BufferOrEvent[] sequence={createBuffer(1,100),createBuffer(2,70),createBarrier(3,2),createBuffer(1,100),createBuffer(2,100),createBarrier(3,0),createBuffer(0,100),createBuffer(1,100),createBarrier(4,0),createBuffer(0,100),createBuffer(0,120),createBuffer(1,100),createBuffer(2,100),createBarrier(3,1),createBarrier(4,1),createBuffer(0,100),createBuffer(1,100),createBuffer(2,100),createBarrier(4,2),createBuffer(0,100),createBuffer(1,100),createBuffer(2,100)};
  MockInputGate gate=new MockInputGate(PAGE_SIZE,3,Arrays.asList(sequence));
  BarrierBuffer buffer=new BarrierBuffer(gate,new BufferSpiller(ioManager,gate.getPageSize()),500);
  AbstractInvokable toNotify=mock(AbstractInvokable.class);
  buffer.registerCheckpointEventHandler(toNotify);
  long startTs;
  check(sequence[0],buffer.getNextNonBlocked());
  check(sequence[1],buffer.getNextNonBlocked());
  startTs=System.nanoTime();
  check(sequence[3],buffer.getNextNonBlocked());
  check(sequence[7],buffer.getNextNonBlocked());
  check(sequence[11],buffer.getNextNonBlocked());
  check(sequence[4],buffer.getNextNonBlocked());
  validateAlignmentTime(startTs,buffer);
  verify(toNotify,times(1)).abortCheckpointOnBarrier(eq(3L),any(AlignmentLimitExceededException.class));
  check(sequence[6],buffer.getNextNonBlocked());
  startTs=System.nanoTime();
  check(sequence[12],buffer.getNextNonBlocked());
  check(sequence[17],buffer.getNextNonBlocked());
  check(sequence[9],buffer.getNextNonBlocked());
  validateAlignmentTime(startTs,buffer);
  verify(toNotify,times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(4L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
  check(sequence[10],buffer.getNextNonBlocked());
  check(sequence[15],buffer.getNextNonBlocked());
  check(sequence[16],buffer.getNextNonBlocked());
  check(sequence[19],buffer.getNextNonBlocked());
  check(sequence[20],buffer.getNextNonBlocked());
  check(sequence[21],buffer.getNextNonBlocked());
  verify(toNotify,times(0)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(3L)),any(CheckpointOptions.class),any(CheckpointMetrics.class));
  assertNull(buffer.getNextNonBlocked());
  assertNull(buffer.getNextNonBlocked());
  buffer.cleanup();
  checkNoTempFilesRemain();
}
