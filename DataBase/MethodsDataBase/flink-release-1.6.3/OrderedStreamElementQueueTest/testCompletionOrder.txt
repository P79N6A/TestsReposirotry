/** 
 * Tests that only the head element is pulled from the ordered queue if it has been completed.
 */
@Test public void testCompletionOrder() throws Exception {
  OperatorActions operatorActions=mock(OperatorActions.class);
  final OrderedStreamElementQueue queue=new OrderedStreamElementQueue(4,executor,operatorActions);
  StreamRecordQueueEntry<Integer> entry1=new StreamRecordQueueEntry<>(new StreamRecord<>(1,0L));
  StreamRecordQueueEntry<Integer> entry2=new StreamRecordQueueEntry<>(new StreamRecord<>(2,1L));
  WatermarkQueueEntry entry3=new WatermarkQueueEntry(new Watermark(2L));
  StreamRecordQueueEntry<Integer> entry4=new StreamRecordQueueEntry<>(new StreamRecord<>(3,3L));
  List<StreamElementQueueEntry<?>> expected=Arrays.asList(entry1,entry2,entry3,entry4);
  for (  StreamElementQueueEntry<?> entry : expected) {
    queue.put(entry);
  }
  CompletableFuture<List<AsyncResult>> pollOperation=CompletableFuture.supplyAsync(() -> {
    List<AsyncResult> result=new ArrayList<>(4);
    while (!queue.isEmpty()) {
      try {
        result.add(queue.poll());
      }
 catch (      InterruptedException e) {
        throw new CompletionException(e);
      }
    }
    return result;
  }
,executor);
  Thread.sleep(10L);
  Assert.assertFalse(pollOperation.isDone());
  entry2.complete(Collections.<Integer>emptyList());
  entry4.complete(Collections.<Integer>emptyList());
  Thread.sleep(10L);
  Assert.assertEquals(4,queue.size());
  entry1.complete(Collections.<Integer>emptyList());
  Assert.assertEquals(expected,pollOperation.get());
  verify(operatorActions,never()).failOperator(any(Exception.class));
}
