@Test public void testRetryWithDelayAndPredicate() throws Exception {
  final ScheduledExecutorService retryExecutor=Executors.newSingleThreadScheduledExecutor();
  final String retryableExceptionMessage="first exception";
class TestStringSupplier implements Supplier<CompletableFuture<String>> {
    private final AtomicInteger counter=new AtomicInteger();
    @Override public CompletableFuture<String> get(){
      if (counter.getAndIncrement() == 0) {
        return FutureUtils.completedExceptionally(new RuntimeException(retryableExceptionMessage));
      }
 else {
        return FutureUtils.completedExceptionally(new RuntimeException("should propagate"));
      }
    }
  }
  try {
    FutureUtils.retryWithDelay(new TestStringSupplier(),1,Time.seconds(0),throwable -> throwable instanceof RuntimeException && throwable.getMessage().contains(retryableExceptionMessage),new ScheduledExecutorServiceAdapter(retryExecutor)).get();
  }
 catch (  final ExecutionException e) {
    assertThat(e.getMessage(),containsString("should propagate"));
  }
 finally {
    retryExecutor.shutdownNow();
  }
}
