/** 
 * Runs the following program. <pre> [ (source)->(filter) ] -> [ (co-map) ] -> [ (map) ] -> [ (groupBy/reduce)->(sink) ] </pre>
 */
@Test public void testProgram(){
  try {
    final StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    assertEquals("test setup broken",PARALLELISM,env.getParallelism());
    env.enableCheckpointing(500);
    env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE,0L));
    final int numElements=10000;
    final int numTaskTotal=PARALLELISM * 5;
    DataStream<Long> stream=env.addSource(new GeneratingSourceFunction(numElements,numTaskTotal));
    stream.filter(new LongRichFilterFunction()).connect(stream).flatMap(new LeftIdentityCoRichFlatMapFunction()).map(new IdentityMapFunction()).startNewChain().keyBy(0).reduce(new OnceFailingReducer(numElements)).addSink(new DiscardingSink<Tuple1<Long>>());
    env.execute();
    final long failureCheckpointID=OnceFailingReducer.failureCheckpointID;
    assertNotEquals(0L,failureCheckpointID);
    List<List<Long>[]> allLists=Arrays.asList(GeneratingSourceFunction.COMPLETED_CHECKPOINTS,LongRichFilterFunction.COMPLETED_CHECKPOINTS,LeftIdentityCoRichFlatMapFunction.COMPLETED_CHECKPOINTS,IdentityMapFunction.COMPLETED_CHECKPOINTS,OnceFailingReducer.COMPLETED_CHECKPOINTS);
    for (    List<Long>[] parallelNotifications : allLists) {
      for (      List<Long> notifications : parallelNotifications) {
        assertTrue("No checkpoint notification was received.",notifications.size() > 0);
        assertFalse("Failure checkpoint was marked as completed.",notifications.contains(failureCheckpointID));
        assertFalse("No checkpoint received after failure.",notifications.get(notifications.size() - 1) == failureCheckpointID);
        assertTrue("Checkpoint notification was received multiple times",notifications.size() == new HashSet<Long>(notifications).size());
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
