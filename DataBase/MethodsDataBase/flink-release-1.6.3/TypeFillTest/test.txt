@Test public void test(){
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
  try {
    env.addSource(new TestSource<Integer>()).print();
    fail();
  }
 catch (  Exception ignored) {
  }
  DataStream<Long> source=env.generateSequence(1,10);
  try {
    source.map(new TestMap<Long,Long>()).print();
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.flatMap(new TestFlatMap<Long,Long>()).print();
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.connect(source).map(new TestCoMap<Long,Long,Integer>()).print();
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.connect(source).flatMap(new TestCoFlatMap<Long,Long,Integer>()).print();
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.keyBy(new TestKeySelector<Long,String>()).print();
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.connect(source).keyBy(new TestKeySelector<Long,String>(),new TestKeySelector<>());
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.coGroup(source).where(new TestKeySelector<>()).equalTo(new TestKeySelector<>());
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.join(source).where(new TestKeySelector<>()).equalTo(new TestKeySelector<>());
    fail();
  }
 catch (  Exception ignored) {
  }
  try {
    source.keyBy((in) -> in).intervalJoin(source.keyBy((in) -> in)).between(Time.milliseconds(10L),Time.milliseconds(10L)).process(new TestProcessJoinFunction<>()).print();
    fail();
  }
 catch (  Exception ignored) {
  }
  env.addSource(new TestSource<Integer>()).returns(Integer.class);
  source.map(new TestMap<Long,Long>()).returns(Long.class).print();
  source.flatMap(new TestFlatMap<Long,Long>()).returns(new TypeHint<Long>(){
  }
).print();
  source.connect(source).map(new TestCoMap<Long,Long,Integer>()).returns(BasicTypeInfo.INT_TYPE_INFO).print();
  source.connect(source).flatMap(new TestCoFlatMap<Long,Long,Integer>()).returns(BasicTypeInfo.INT_TYPE_INFO).print();
  source.connect(source).keyBy(new TestKeySelector<>(),new TestKeySelector<>(),Types.STRING);
  source.coGroup(source).where(new TestKeySelector<>(),Types.STRING).equalTo(new TestKeySelector<>(),Types.STRING);
  source.join(source).where(new TestKeySelector<>(),Types.STRING).equalTo(new TestKeySelector<>(),Types.STRING);
  source.keyBy((in) -> in).intervalJoin(source.keyBy((in) -> in)).between(Time.milliseconds(10L),Time.milliseconds(10L)).process(new TestProcessJoinFunction<Long,Long,String>()).returns(Types.STRING);
  source.keyBy((in) -> in).intervalJoin(source.keyBy((in) -> in)).between(Time.milliseconds(10L),Time.milliseconds(10L)).process(new TestProcessJoinFunction<>(),Types.STRING);
  assertEquals(BasicTypeInfo.LONG_TYPE_INFO,source.map(new TestMap<Long,Long>()).returns(Long.class).getType());
  SingleOutputStreamOperator<String> map=source.map(new MapFunction<Long,String>(){
    @Override public String map(    Long value) throws Exception {
      return null;
    }
  }
);
  map.print();
  try {
    map.returns(String.class);
    fail();
  }
 catch (  Exception ignored) {
  }
}
