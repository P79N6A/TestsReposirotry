/** 
 * This uses a custom bucketing function which determines the bucket from the input. We use a simulated clock to reduce the number of buckets being written to over time. This causes buckets to become 'inactive' and their file parts 'closed' by the sink.
 */
@Test public void testCustomBucketingInactiveBucketCleanup() throws Exception {
  File dataDir=tempFolder.newFolder();
  final int step1NumIds=4;
  final int step2NumIds=2;
  final int numElementsPerStep=20;
  OneInputStreamOperatorTestHarness<String,Object> testHarness=createTestSink(dataDir,1,0);
  testHarness.setProcessingTime(0L);
  testHarness.setup();
  testHarness.open();
  for (int i=0; i < numElementsPerStep; i++) {
    testHarness.processElement(new StreamRecord<>(Integer.toString(i % step1NumIds)));
  }
  testHarness.setProcessingTime(2 * 60 * 1000L);
  for (int i=0; i < numElementsPerStep; i++) {
    testHarness.processElement(new StreamRecord<>(Integer.toString(i % step2NumIds)));
  }
  testHarness.setProcessingTime(6 * 60 * 1000L);
  for (int i=0; i < numElementsPerStep; i++) {
    testHarness.processElement(new StreamRecord<>(Integer.toString(i % step2NumIds)));
  }
  int numFiles=0;
  int numInProgress=0;
  for (  File file : FileUtils.listFiles(dataDir,null,true)) {
    if (file.getAbsolutePath().endsWith("crc")) {
      continue;
    }
    if (file.getPath().endsWith(IN_PROGRESS_SUFFIX)) {
      numInProgress++;
    }
    numFiles++;
  }
  testHarness.close();
  Assert.assertEquals(4,numFiles);
  Assert.assertEquals(2,numInProgress);
}
