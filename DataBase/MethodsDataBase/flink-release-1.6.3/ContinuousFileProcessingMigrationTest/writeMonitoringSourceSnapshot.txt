/** 
 * Manually run this to write binary snapshot data. Remove @Ignore to run.
 */
@Ignore @Test public void writeMonitoringSourceSnapshot() throws Exception {
  File testFolder=tempFolder.newFolder();
  long fileModTime=Long.MIN_VALUE;
  for (int i=0; i < 1; i++) {
    Tuple2<File,String> file=createFileAndFillWithData(testFolder,"file",i,"This is test line.");
    fileModTime=file.f0.lastModified();
  }
  TextInputFormat format=new TextInputFormat(new Path(testFolder.getAbsolutePath()));
  final ContinuousFileMonitoringFunction<String> monitoringFunction=new ContinuousFileMonitoringFunction<>(format,FileProcessingMode.PROCESS_CONTINUOUSLY,1,INTERVAL);
  StreamSource<TimestampedFileInputSplit,ContinuousFileMonitoringFunction<String>> src=new StreamSource<>(monitoringFunction);
  final AbstractStreamOperatorTestHarness<TimestampedFileInputSplit> testHarness=new AbstractStreamOperatorTestHarness<>(src,1,1,0);
  testHarness.open();
  final Throwable[] error=new Throwable[1];
  final OneShotLatch latch=new OneShotLatch();
  Thread runner=new Thread(){
    @Override public void run(){
      try {
        monitoringFunction.run(new DummySourceContext(){
          @Override public void collect(          TimestampedFileInputSplit element){
            latch.trigger();
          }
          @Override public void markAsTemporarilyIdle(){
          }
        }
);
      }
 catch (      Throwable t) {
        t.printStackTrace();
        error[0]=t;
      }
    }
  }
;
  runner.start();
  if (!latch.isTriggered()) {
    latch.await();
  }
  final OperatorSubtaskState snapshot;
synchronized (testHarness.getCheckpointLock()) {
    snapshot=testHarness.snapshot(0L,0L);
  }
  OperatorSnapshotUtil.writeStateHandle(snapshot,"src/test/resources/monitoring-function-migration-test-" + fileModTime + "-flink"+ flinkGenerateSavepointVersion+ "-snapshot");
  monitoringFunction.cancel();
  runner.join();
  testHarness.close();
}
