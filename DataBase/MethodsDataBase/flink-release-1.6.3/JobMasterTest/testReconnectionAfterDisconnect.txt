/** 
 * Tests that we continue reconnecting to the latest known RM after a disconnection message.
 */
@Test public void testReconnectionAfterDisconnect() throws Exception {
  final JobMaster jobMaster=createJobMaster(configuration,jobGraph,haServices,new TestingJobManagerSharedServicesBuilder().build());
  final JobMasterGateway jobMasterGateway=jobMaster.getSelfGateway(JobMasterGateway.class);
  jobMaster.start(jobMasterId,testingTimeout);
  try {
    final TestingResourceManagerGateway testingResourceManagerGateway=new TestingResourceManagerGateway();
    final BlockingQueue<JobMasterId> registrationsQueue=new ArrayBlockingQueue<>(1);
    testingResourceManagerGateway.setRegisterJobManagerConsumer(jobMasterIdResourceIDStringJobIDTuple4 -> registrationsQueue.offer(jobMasterIdResourceIDStringJobIDTuple4.f0));
    rpcService.registerGateway(testingResourceManagerGateway.getAddress(),testingResourceManagerGateway);
    final ResourceManagerId resourceManagerId=testingResourceManagerGateway.getFencingToken();
    rmLeaderRetrievalService.notifyListener(testingResourceManagerGateway.getAddress(),resourceManagerId.toUUID());
    final JobMasterId firstRegistrationAttempt=registrationsQueue.take();
    assertThat(firstRegistrationAttempt,equalTo(jobMasterId));
    assertThat(registrationsQueue.isEmpty(),is(true));
    jobMasterGateway.disconnectResourceManager(resourceManagerId,new FlinkException("Test exception"));
    assertThat(registrationsQueue.take(),equalTo(jobMasterId));
  }
  finally {
    RpcUtils.terminateRpcEndpoint(jobMaster,testingTimeout);
  }
}
