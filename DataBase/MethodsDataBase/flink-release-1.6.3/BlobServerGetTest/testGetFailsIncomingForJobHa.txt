/** 
 * Retrieves a BLOB from the HA store to a  {@link BlobServer} which cannot create incomingfiles. File transfers should fail.
 */
@Test public void testGetFailsIncomingForJobHa() throws IOException {
  assumeTrue(!OperatingSystem.isWindows());
  final JobID jobId=new JobID();
  final Configuration config=new Configuration();
  config.setString(HighAvailabilityOptions.HA_MODE,"ZOOKEEPER");
  config.setString(BlobServerOptions.STORAGE_DIRECTORY,temporaryFolder.newFolder().getAbsolutePath());
  config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,temporaryFolder.newFolder().getPath());
  BlobStoreService blobStore=null;
  try {
    blobStore=BlobUtils.createBlobStoreFromConfig(config);
    File tempFileDir=null;
    try (BlobServer server=new BlobServer(config,blobStore)){
      server.start();
      byte[] data=new byte[2000000];
      rnd.nextBytes(data);
      BlobKey blobKey=put(server,jobId,data,PERMANENT_BLOB);
      assertTrue(server.getStorageLocation(jobId,blobKey).delete());
      tempFileDir=server.createTemporaryFilename().getParentFile();
      assertTrue(tempFileDir.setExecutable(true,false));
      assertTrue(tempFileDir.setReadable(true,false));
      assertTrue(tempFileDir.setWritable(false,false));
      exception.expect(IOException.class);
      exception.expectMessage("Permission denied");
      try {
        get(server,jobId,blobKey);
      }
  finally {
        HashSet<String> expectedDirs=new HashSet<>();
        expectedDirs.add("incoming");
        expectedDirs.add(JOB_DIR_PREFIX + jobId);
        File storageDir=tempFileDir.getParentFile();
        String[] actualDirs=storageDir.list();
        assertNotNull(actualDirs);
        assertEquals(expectedDirs,new HashSet<>(Arrays.asList(actualDirs)));
        File jobDir=new File(tempFileDir.getParentFile(),JOB_DIR_PREFIX + jobId);
        assertArrayEquals(new String[]{},jobDir.list());
      }
    }
  finally {
      if (tempFileDir != null) {
        tempFileDir.setWritable(true,false);
      }
    }
  }
  finally {
    if (blobStore != null) {
      blobStore.closeAndCleanupAllData();
    }
  }
}
