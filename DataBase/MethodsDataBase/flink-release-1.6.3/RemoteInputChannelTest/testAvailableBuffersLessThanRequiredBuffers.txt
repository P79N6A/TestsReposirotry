/** 
 * Tests to verify the behaviours of three different processes if the number of available buffers is less than required buffers. <ol> <li>Recycle the floating buffer</li> <li>Recycle the exclusive buffer</li> <li>Decrease the sender's backlog</li> </ol>
 */
@Test public void testAvailableBuffersLessThanRequiredBuffers() throws Exception {
  final NetworkBufferPool networkBufferPool=new NetworkBufferPool(16,32);
  final int numExclusiveBuffers=2;
  final int numFloatingBuffers=14;
  final SingleInputGate inputGate=createSingleInputGate();
  final RemoteInputChannel inputChannel=createRemoteInputChannel(inputGate);
  inputGate.setInputChannel(inputChannel.partitionId.getPartitionId(),inputChannel);
  Throwable thrown=null;
  try {
    final BufferPool bufferPool=spy(networkBufferPool.createBufferPool(numFloatingBuffers,numFloatingBuffers));
    inputGate.setBufferPool(bufferPool);
    inputGate.assignExclusiveSegments(networkBufferPool,numExclusiveBuffers);
    inputChannel.requestSubpartition(0);
    final Buffer exclusiveBuffer=inputChannel.requestBuffer();
    assertNotNull(exclusiveBuffer);
    final int numRecycleFloatingBuffers=2;
    final ArrayDeque<Buffer> floatingBufferQueue=new ArrayDeque<>(numRecycleFloatingBuffers);
    for (int i=0; i < numRecycleFloatingBuffers; i++) {
      Buffer floatingBuffer=bufferPool.requestBuffer();
      assertNotNull(floatingBuffer);
      floatingBufferQueue.add(floatingBuffer);
    }
    verify(bufferPool,times(numRecycleFloatingBuffers)).requestBuffer();
    inputChannel.onSenderBacklog(14);
    verify(bufferPool,times(15)).requestBuffer();
    verify(bufferPool,times(1)).addBufferListener(inputChannel);
    assertEquals("There should be 13 buffers available in the channel",13,inputChannel.getNumberOfAvailableBuffers());
    assertEquals("There should be 16 buffers required in the channel",16,inputChannel.getNumberOfRequiredBuffers());
    assertEquals("There should be 0 buffers available in local pool",0,bufferPool.getNumberOfAvailableMemorySegments());
    assertTrue(inputChannel.isWaitingForFloatingBuffers());
    inputChannel.onSenderBacklog(16);
    verify(bufferPool,times(15)).requestBuffer();
    verify(bufferPool,times(1)).addBufferListener(inputChannel);
    assertEquals("There should be 13 buffers available in the channel",13,inputChannel.getNumberOfAvailableBuffers());
    assertEquals("There should be 18 buffers required in the channel",18,inputChannel.getNumberOfRequiredBuffers());
    assertEquals("There should be 0 buffers available in local pool",0,bufferPool.getNumberOfAvailableMemorySegments());
    assertTrue(inputChannel.isWaitingForFloatingBuffers());
    exclusiveBuffer.recycleBuffer();
    verify(bufferPool,times(15)).requestBuffer();
    verify(bufferPool,times(1)).addBufferListener(inputChannel);
    assertEquals("There should be 14 buffers available in the channel",14,inputChannel.getNumberOfAvailableBuffers());
    assertEquals("There should be 18 buffers required in the channel",18,inputChannel.getNumberOfRequiredBuffers());
    assertEquals("There should be 0 buffers available in local pool",0,bufferPool.getNumberOfAvailableMemorySegments());
    assertTrue(inputChannel.isWaitingForFloatingBuffers());
    floatingBufferQueue.poll().recycleBuffer();
    verify(bufferPool,times(15)).requestBuffer();
    verify(bufferPool,times(1)).addBufferListener(inputChannel);
    assertEquals("There should be 15 buffers available in the channel",15,inputChannel.getNumberOfAvailableBuffers());
    assertEquals("There should be 18 buffers required in the channel",18,inputChannel.getNumberOfRequiredBuffers());
    assertEquals("There should be 0 buffers available in local pool",0,bufferPool.getNumberOfAvailableMemorySegments());
    assertTrue(inputChannel.isWaitingForFloatingBuffers());
    inputChannel.onSenderBacklog(13);
    verify(bufferPool,times(15)).requestBuffer();
    verify(bufferPool,times(1)).addBufferListener(inputChannel);
    assertEquals("There should be 15 buffers available in the channel",15,inputChannel.getNumberOfAvailableBuffers());
    assertEquals("There should be 15 buffers required in the channel",15,inputChannel.getNumberOfRequiredBuffers());
    assertEquals("There should be 0 buffers available in local pool",0,bufferPool.getNumberOfAvailableMemorySegments());
    assertTrue(inputChannel.isWaitingForFloatingBuffers());
    floatingBufferQueue.poll().recycleBuffer();
    verify(bufferPool,times(15)).requestBuffer();
    verify(bufferPool,times(1)).addBufferListener(inputChannel);
    assertEquals("There should be 15 buffers available in the channel",15,inputChannel.getNumberOfAvailableBuffers());
    assertEquals("There should be 15 buffers required in the channel",15,inputChannel.getNumberOfRequiredBuffers());
    assertEquals("There should be 1 buffers available in local pool",1,bufferPool.getNumberOfAvailableMemorySegments());
    assertFalse(inputChannel.isWaitingForFloatingBuffers());
    inputChannel.onSenderBacklog(15);
    verify(bufferPool,times(17)).requestBuffer();
    verify(bufferPool,times(2)).addBufferListener(inputChannel);
    assertEquals("There should be 16 buffers available in the channel",16,inputChannel.getNumberOfAvailableBuffers());
    assertEquals("There should be 17 buffers required in the channel",17,inputChannel.getNumberOfRequiredBuffers());
    assertEquals("There should be 0 buffers available in local pool",0,bufferPool.getNumberOfAvailableMemorySegments());
    assertTrue(inputChannel.isWaitingForFloatingBuffers());
  }
 catch (  Throwable t) {
    thrown=t;
  }
 finally {
    cleanup(networkBufferPool,null,null,thrown,inputChannel);
  }
}
