/** 
 * Tests to verify that the buffer pool will distribute available floating buffers among all the channel listeners in a fair way.
 */
@Test public void testFairDistributionFloatingBuffers() throws Exception {
  final NetworkBufferPool networkBufferPool=new NetworkBufferPool(12,32);
  final int numExclusiveBuffers=2;
  final int numFloatingBuffers=3;
  final SingleInputGate inputGate=createSingleInputGate();
  final RemoteInputChannel channel1=spy(createRemoteInputChannel(inputGate));
  final RemoteInputChannel channel2=spy(createRemoteInputChannel(inputGate));
  final RemoteInputChannel channel3=spy(createRemoteInputChannel(inputGate));
  inputGate.setInputChannel(channel1.partitionId.getPartitionId(),channel1);
  inputGate.setInputChannel(channel2.partitionId.getPartitionId(),channel2);
  inputGate.setInputChannel(channel3.partitionId.getPartitionId(),channel3);
  Throwable thrown=null;
  try {
    final BufferPool bufferPool=spy(networkBufferPool.createBufferPool(numFloatingBuffers,numFloatingBuffers));
    inputGate.setBufferPool(bufferPool);
    inputGate.assignExclusiveSegments(networkBufferPool,numExclusiveBuffers);
    channel1.requestSubpartition(0);
    channel2.requestSubpartition(0);
    channel3.requestSubpartition(0);
    final List<Buffer> floatingBuffers=new ArrayList<>(numFloatingBuffers);
    for (int i=0; i < numFloatingBuffers; i++) {
      Buffer buffer=bufferPool.requestBuffer();
      assertNotNull(buffer);
      floatingBuffers.add(buffer);
    }
    channel1.onSenderBacklog(8);
    channel2.onSenderBacklog(8);
    channel3.onSenderBacklog(8);
    verify(bufferPool,times(1)).addBufferListener(channel1);
    verify(bufferPool,times(1)).addBufferListener(channel2);
    verify(bufferPool,times(1)).addBufferListener(channel3);
    assertEquals("There should be " + numExclusiveBuffers + " buffers available in the channel",numExclusiveBuffers,channel1.getNumberOfAvailableBuffers());
    assertEquals("There should be " + numExclusiveBuffers + " buffers available in the channel",numExclusiveBuffers,channel2.getNumberOfAvailableBuffers());
    assertEquals("There should be " + numExclusiveBuffers + " buffers available in the channel",numExclusiveBuffers,channel3.getNumberOfAvailableBuffers());
    for (    Buffer buffer : floatingBuffers) {
      buffer.recycleBuffer();
    }
    verify(channel1,times(1)).notifyBufferAvailable(any(Buffer.class));
    verify(channel2,times(1)).notifyBufferAvailable(any(Buffer.class));
    verify(channel3,times(1)).notifyBufferAvailable(any(Buffer.class));
    assertEquals("There should be 3 buffers available in the channel",3,channel1.getNumberOfAvailableBuffers());
    assertEquals("There should be 3 buffers available in the channel",3,channel2.getNumberOfAvailableBuffers());
    assertEquals("There should be 3 buffers available in the channel",3,channel3.getNumberOfAvailableBuffers());
  }
 catch (  Throwable t) {
    thrown=t;
  }
 finally {
    cleanup(networkBufferPool,null,null,thrown,channel1,channel2,channel3);
  }
}
