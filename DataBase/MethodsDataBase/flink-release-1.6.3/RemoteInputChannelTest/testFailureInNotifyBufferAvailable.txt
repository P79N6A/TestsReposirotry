/** 
 * Tests that failures are propagated correctly if {@link RemoteInputChannel#notifyBufferAvailable(Buffer)} throws an exception. Also tests thata second listener will be notified in this case.
 */
@Test public void testFailureInNotifyBufferAvailable() throws Exception {
  final int numExclusiveBuffers=0;
  final int numFloatingBuffers=1;
  final int numTotalBuffers=numExclusiveBuffers + numFloatingBuffers;
  final NetworkBufferPool networkBufferPool=new NetworkBufferPool(numTotalBuffers,32);
  final SingleInputGate inputGate=createSingleInputGate();
  final RemoteInputChannel successfulRemoteIC=createRemoteInputChannel(inputGate);
  inputGate.setInputChannel(successfulRemoteIC.partitionId.getPartitionId(),successfulRemoteIC);
  successfulRemoteIC.requestSubpartition(0);
  final RemoteInputChannel failingRemoteIC=createRemoteInputChannel(inputGate);
  inputGate.setInputChannel(failingRemoteIC.partitionId.getPartitionId(),failingRemoteIC);
  Buffer buffer=null;
  Throwable thrown=null;
  try {
    final BufferPool bufferPool=networkBufferPool.createBufferPool(numFloatingBuffers,numFloatingBuffers);
    inputGate.setBufferPool(bufferPool);
    buffer=bufferPool.requestBufferBlocking();
    failingRemoteIC.onSenderBacklog(1);
    successfulRemoteIC.onSenderBacklog(numExclusiveBuffers + 1);
    buffer.recycleBuffer();
    buffer=null;
    try {
      failingRemoteIC.checkError();
      fail("The input channel should have an error based on the failure in RemoteInputChannel#notifyBufferAvailable()");
    }
 catch (    IOException e) {
      assertThat(e,hasProperty("cause",isA(IllegalStateException.class)));
    }
    assertEquals(0,bufferPool.getNumberOfAvailableMemorySegments());
    buffer=successfulRemoteIC.requestBuffer();
    assertNull("buffer should still remain in failingRemoteIC",buffer);
    failingRemoteIC.releaseAllResources();
    assertEquals(0,bufferPool.getNumberOfAvailableMemorySegments());
    buffer=successfulRemoteIC.requestBuffer();
    assertNotNull("no buffer given to successfulRemoteIC",buffer);
  }
 catch (  Throwable t) {
    thrown=t;
  }
 finally {
    cleanup(networkBufferPool,null,buffer,thrown,failingRemoteIC,successfulRemoteIC);
  }
}
