@Test public void testGrowingPartitions(){
  try {
    final int[] newPartitionIDs={0,1,2,3,4,5,6,7,8,9,10};
    List<KafkaTopicPartition> allPartitions=new ArrayList<>(11);
    for (    int p : newPartitionIDs) {
      KafkaTopicPartition part=new KafkaTopicPartition(TEST_TOPIC,p);
      allPartitions.add(part);
    }
    List<List<KafkaTopicPartition>> mockGetAllPartitionsForTopicsReturnSequence=Arrays.asList(new ArrayList<>(allPartitions.subList(0,7)),allPartitions);
    final Set<KafkaTopicPartition> allNewPartitions=new HashSet<>(allPartitions);
    final Set<KafkaTopicPartition> allInitialPartitions=new HashSet<>(mockGetAllPartitionsForTopicsReturnSequence.get(0));
    final int numConsumers=3;
    final int minInitialPartitionsPerConsumer=mockGetAllPartitionsForTopicsReturnSequence.get(0).size() / numConsumers;
    final int maxInitialPartitionsPerConsumer=mockGetAllPartitionsForTopicsReturnSequence.get(0).size() / numConsumers + 1;
    final int minNewPartitionsPerConsumer=allPartitions.size() / numConsumers;
    final int maxNewPartitionsPerConsumer=allPartitions.size() / numConsumers + 1;
    int startIndex=KafkaTopicPartitionAssigner.assign(allPartitions.get(0),numConsumers);
    TestPartitionDiscoverer partitionDiscovererSubtask0=new TestPartitionDiscoverer(topicsDescriptor,0,numConsumers,TestPartitionDiscoverer.createMockGetAllTopicsSequenceFromFixedReturn(Collections.singletonList(TEST_TOPIC)),deepClone(mockGetAllPartitionsForTopicsReturnSequence));
    partitionDiscovererSubtask0.open();
    TestPartitionDiscoverer partitionDiscovererSubtask1=new TestPartitionDiscoverer(topicsDescriptor,1,numConsumers,TestPartitionDiscoverer.createMockGetAllTopicsSequenceFromFixedReturn(Collections.singletonList(TEST_TOPIC)),deepClone(mockGetAllPartitionsForTopicsReturnSequence));
    partitionDiscovererSubtask1.open();
    TestPartitionDiscoverer partitionDiscovererSubtask2=new TestPartitionDiscoverer(topicsDescriptor,2,numConsumers,TestPartitionDiscoverer.createMockGetAllTopicsSequenceFromFixedReturn(Collections.singletonList(TEST_TOPIC)),deepClone(mockGetAllPartitionsForTopicsReturnSequence));
    partitionDiscovererSubtask2.open();
    List<KafkaTopicPartition> initialDiscoverySubtask0=partitionDiscovererSubtask0.discoverPartitions();
    List<KafkaTopicPartition> initialDiscoverySubtask1=partitionDiscovererSubtask1.discoverPartitions();
    List<KafkaTopicPartition> initialDiscoverySubtask2=partitionDiscovererSubtask2.discoverPartitions();
    assertTrue(initialDiscoverySubtask0.size() >= minInitialPartitionsPerConsumer);
    assertTrue(initialDiscoverySubtask0.size() <= maxInitialPartitionsPerConsumer);
    assertTrue(initialDiscoverySubtask1.size() >= minInitialPartitionsPerConsumer);
    assertTrue(initialDiscoverySubtask1.size() <= maxInitialPartitionsPerConsumer);
    assertTrue(initialDiscoverySubtask2.size() >= minInitialPartitionsPerConsumer);
    assertTrue(initialDiscoverySubtask2.size() <= maxInitialPartitionsPerConsumer);
    for (    KafkaTopicPartition p : initialDiscoverySubtask0) {
      assertTrue(allInitialPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),0);
    }
    for (    KafkaTopicPartition p : initialDiscoverySubtask1) {
      assertTrue(allInitialPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),1);
    }
    for (    KafkaTopicPartition p : initialDiscoverySubtask2) {
      assertTrue(allInitialPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),2);
    }
    assertTrue(allInitialPartitions.isEmpty());
    List<KafkaTopicPartition> secondDiscoverySubtask0=partitionDiscovererSubtask0.discoverPartitions();
    List<KafkaTopicPartition> secondDiscoverySubtask1=partitionDiscovererSubtask1.discoverPartitions();
    List<KafkaTopicPartition> secondDiscoverySubtask2=partitionDiscovererSubtask2.discoverPartitions();
    assertTrue(Collections.disjoint(secondDiscoverySubtask0,initialDiscoverySubtask0));
    assertTrue(Collections.disjoint(secondDiscoverySubtask1,initialDiscoverySubtask1));
    assertTrue(Collections.disjoint(secondDiscoverySubtask2,initialDiscoverySubtask2));
    assertTrue(secondDiscoverySubtask0.size() + initialDiscoverySubtask0.size() >= minNewPartitionsPerConsumer);
    assertTrue(secondDiscoverySubtask0.size() + initialDiscoverySubtask0.size() <= maxNewPartitionsPerConsumer);
    assertTrue(secondDiscoverySubtask1.size() + initialDiscoverySubtask1.size() >= minNewPartitionsPerConsumer);
    assertTrue(secondDiscoverySubtask1.size() + initialDiscoverySubtask1.size() <= maxNewPartitionsPerConsumer);
    assertTrue(secondDiscoverySubtask2.size() + initialDiscoverySubtask2.size() >= minNewPartitionsPerConsumer);
    assertTrue(secondDiscoverySubtask2.size() + initialDiscoverySubtask2.size() <= maxNewPartitionsPerConsumer);
    for (    KafkaTopicPartition p : initialDiscoverySubtask0) {
      assertTrue(allNewPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),0);
    }
    for (    KafkaTopicPartition p : initialDiscoverySubtask1) {
      assertTrue(allNewPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),1);
    }
    for (    KafkaTopicPartition p : initialDiscoverySubtask2) {
      assertTrue(allNewPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),2);
    }
    for (    KafkaTopicPartition p : secondDiscoverySubtask0) {
      assertTrue(allNewPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),0);
    }
    for (    KafkaTopicPartition p : secondDiscoverySubtask1) {
      assertTrue(allNewPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),1);
    }
    for (    KafkaTopicPartition p : secondDiscoverySubtask2) {
      assertTrue(allNewPartitions.remove(p));
      assertEquals(getExpectedSubtaskIndex(p,startIndex,numConsumers),2);
    }
    assertTrue(allNewPartitions.isEmpty());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
