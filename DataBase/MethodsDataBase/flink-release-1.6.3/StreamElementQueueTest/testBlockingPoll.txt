/** 
 * Test that a poll operation on an empty queue blocks.
 */
@Test public void testBlockingPoll() throws Exception {
  OperatorActions operatorActions=mock(OperatorActions.class);
  final StreamElementQueue queue=createStreamElementQueue(1,operatorActions);
  WatermarkQueueEntry watermarkQueueEntry=new WatermarkQueueEntry(new Watermark(1L));
  StreamRecordQueueEntry<Integer> streamRecordQueueEntry=new StreamRecordQueueEntry<>(new StreamRecord<>(1,2L));
  Assert.assertTrue(queue.isEmpty());
  CompletableFuture<AsyncResult> peekOperation=CompletableFuture.supplyAsync(() -> {
    try {
      return queue.peekBlockingly();
    }
 catch (    InterruptedException e) {
      throw new CompletionException(e);
    }
  }
,executor);
  Thread.sleep(10L);
  Assert.assertFalse(peekOperation.isDone());
  queue.put(watermarkQueueEntry);
  AsyncResult watermarkResult=peekOperation.get();
  Assert.assertEquals(watermarkQueueEntry,watermarkResult);
  Assert.assertEquals(1,queue.size());
  Assert.assertEquals(watermarkQueueEntry,queue.poll());
  Assert.assertTrue(queue.isEmpty());
  CompletableFuture<AsyncResult> pollOperation=CompletableFuture.supplyAsync(() -> {
    try {
      return queue.poll();
    }
 catch (    InterruptedException e) {
      throw new CompletionException(e);
    }
  }
,executor);
  Thread.sleep(10L);
  Assert.assertFalse(pollOperation.isDone());
  queue.put(streamRecordQueueEntry);
  Thread.sleep(10L);
  Assert.assertFalse(pollOperation.isDone());
  streamRecordQueueEntry.complete(Collections.<Integer>emptyList());
  Assert.assertEquals(streamRecordQueueEntry,pollOperation.get());
  Assert.assertTrue(queue.isEmpty());
  verify(operatorActions,never()).failOperator(any(Exception.class));
}
