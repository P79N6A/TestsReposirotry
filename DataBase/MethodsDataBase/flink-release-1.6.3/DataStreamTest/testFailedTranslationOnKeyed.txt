/** 
 * Tests that with a  {@link KeyedStream} we have to provide a {@link KeyedBroadcastProcessFunction}.
 */
@Test public void testFailedTranslationOnKeyed(){
  final MapStateDescriptor<Long,String> descriptor=new MapStateDescriptor<>("broadcast",BasicTypeInfo.LONG_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
  final StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  final DataStream<Long> srcOne=env.generateSequence(0L,5L).assignTimestampsAndWatermarks(new CustomWmEmitter<Long>(){
    @Override public long extractTimestamp(    Long element,    long previousElementTimestamp){
      return element;
    }
  }
).keyBy((KeySelector<Long,Long>)value -> value);
  final DataStream<String> srcTwo=env.fromElements("Test:0","Test:1","Test:2","Test:3","Test:4","Test:5").assignTimestampsAndWatermarks(new CustomWmEmitter<String>(){
    @Override public long extractTimestamp(    String element,    long previousElementTimestamp){
      return Long.parseLong(element.split(":")[1]);
    }
  }
);
  BroadcastStream<String> broadcast=srcTwo.broadcast(descriptor);
  BroadcastConnectedStream<Long,String> bcStream=srcOne.connect(broadcast);
  expectedException.expect(IllegalArgumentException.class);
  bcStream.process(new BroadcastProcessFunction<Long,String,String>(){
    @Override public void processBroadcastElement(    String value,    Context ctx,    Collector<String> out) throws Exception {
    }
    @Override public void processElement(    Long value,    ReadOnlyContext ctx,    Collector<String> out) throws Exception {
    }
  }
);
}
