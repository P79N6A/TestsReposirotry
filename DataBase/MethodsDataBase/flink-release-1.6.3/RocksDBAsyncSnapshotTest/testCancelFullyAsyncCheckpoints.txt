/** 
 * This tests ensures that canceling of asynchronous snapshots works as expected and does not block.
 */
@Test public void testCancelFullyAsyncCheckpoints() throws Exception {
  final OneInputStreamTaskTestHarness<String,String> testHarness=new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
  testHarness.setupOutputForSingletonOperatorChain();
  testHarness.configureForKeyedStream(value -> value,BasicTypeInfo.STRING_TYPE_INFO);
  StreamConfig streamConfig=testHarness.getStreamConfig();
  File dbDir=temporaryFolder.newFolder();
  final RocksDBStateBackend.PriorityQueueStateType timerServicePriorityQueueType=RocksDBStateBackend.PriorityQueueStateType.valueOf(RocksDBOptions.TIMER_SERVICE_FACTORY.defaultValue());
  final int skipStreams;
  if (timerServicePriorityQueueType == RocksDBStateBackend.PriorityQueueStateType.HEAP) {
    skipStreams=1;
  }
 else   if (timerServicePriorityQueueType == RocksDBStateBackend.PriorityQueueStateType.ROCKSDB) {
    skipStreams=0;
  }
 else {
    throw new AssertionError(String.format("Unknown timer service priority queue type %s.",timerServicePriorityQueueType));
  }
  BlockerCheckpointStreamFactory blockerCheckpointStreamFactory=new BlockerCheckpointStreamFactory(4 * 1024 * 1024){
    int count=skipStreams;
    @Override public CheckpointStateOutputStream createCheckpointStateOutputStream(    CheckpointedStateScope scope) throws IOException {
      if (count > 0) {
        --count;
        return new BlockingCheckpointOutputStream(new MemCheckpointStreamFactory.MemoryCheckpointOutputStream(maxSize),null,null,Integer.MAX_VALUE);
      }
 else {
        return super.createCheckpointStateOutputStream(scope);
      }
    }
  }
;
  StateBackend stateBackend=new BackendForTestStream(new StaticForwardFactory(blockerCheckpointStreamFactory));
  RocksDBStateBackend backend=new RocksDBStateBackend(stateBackend);
  backend.setDbStoragePath(dbDir.getAbsolutePath());
  streamConfig.setStateBackend(backend);
  streamConfig.setStreamOperator(new AsyncCheckpointOperator());
  streamConfig.setOperatorID(new OperatorID());
  TestTaskStateManager taskStateManagerTestMock=new TestTaskStateManager();
  StreamMockEnvironment mockEnv=new StreamMockEnvironment(testHarness.jobConfig,testHarness.taskConfig,testHarness.memorySize,new MockInputSplitProvider(),testHarness.bufferSize,taskStateManagerTestMock);
  blockerCheckpointStreamFactory.setBlockerLatch(new OneShotLatch());
  blockerCheckpointStreamFactory.setWaiterLatch(new OneShotLatch());
  testHarness.invoke(mockEnv);
  final OneInputStreamTask<String,String> task=testHarness.getTask();
  for (  Field field : StreamTask.class.getDeclaredFields()) {
    if (field.getName().equals("isRunning")) {
      field.setAccessible(true);
      while (!field.getBoolean(task)) {
        Thread.sleep(10);
      }
    }
  }
  task.triggerCheckpoint(new CheckpointMetaData(42,17),CheckpointOptions.forCheckpointWithDefaultLocation());
  testHarness.processElement(new StreamRecord<>("Wohoo",0));
  blockerCheckpointStreamFactory.getWaiterLatch().await();
  task.cancel();
  blockerCheckpointStreamFactory.getBlockerLatch().trigger();
  testHarness.endInput();
  ExecutorService threadPool=task.getAsyncOperationsThreadPool();
  threadPool.shutdown();
  Assert.assertTrue(threadPool.awaitTermination(60_000,TimeUnit.MILLISECONDS));
  Set<BlockingCheckpointOutputStream> createdStreams=blockerCheckpointStreamFactory.getAllCreatedStreams();
  for (  BlockingCheckpointOutputStream stream : createdStreams) {
    Assert.assertTrue("Not all of the " + createdStreams.size() + " created streams have been closed.",stream.isClosed());
  }
  try {
    testHarness.waitForTaskCompletion();
    fail("Operation completed. Cancel failed.");
  }
 catch (  Exception expected) {
    Throwable cause=expected.getCause();
    if (!(cause instanceof CancelTaskException)) {
      fail("Unexpected exception: " + expected);
    }
  }
}
