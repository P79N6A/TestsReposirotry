/** 
 * Tests that a slot request is cancelled if it failed with an exception (e.g. TimeoutException). <p>See FLINK-7870
 */
@Test public void testSlotRequestCancellationUponFailingRequest() throws Exception {
  final SlotPool slotPool=new SlotPool(rpcService,jobId,LocationPreferenceSchedulingStrategy.getInstance());
  final CompletableFuture<Acknowledge> requestSlotFuture=new CompletableFuture<>();
  final CompletableFuture<AllocationID> cancelSlotFuture=new CompletableFuture<>();
  final CompletableFuture<AllocationID> requestSlotFutureAllocationId=new CompletableFuture<>();
  resourceManagerGateway.setRequestSlotFuture(requestSlotFuture);
  resourceManagerGateway.setRequestSlotConsumer(slotRequest -> requestSlotFutureAllocationId.complete(slotRequest.getAllocationId()));
  resourceManagerGateway.setCancelSlotConsumer(allocationID -> cancelSlotFuture.complete(allocationID));
  final ScheduledUnit scheduledUnit=new ScheduledUnit(new JobVertexID(),null,null);
  try {
    final SlotPoolGateway slotPoolGateway=setupSlotPool(slotPool,resourceManagerGateway);
    SlotProfile slotProfile=new SlotProfile(ResourceProfile.UNKNOWN,Collections.emptyList(),Collections.emptyList());
    CompletableFuture<LogicalSlot> slotFuture=slotPoolGateway.allocateSlot(new SlotRequestId(),scheduledUnit,slotProfile,true,timeout);
    requestSlotFuture.completeExceptionally(new FlinkException("Testing exception."));
    try {
      slotFuture.get();
      fail("The slot future should not have been completed properly.");
    }
 catch (    Exception ignored) {
    }
    assertEquals(requestSlotFutureAllocationId.get(),cancelSlotFuture.get());
  }
  finally {
    try {
      RpcUtils.terminateRpcEndpoint(slotPool,timeout);
    }
 catch (    Exception e) {
      LOG.warn("Could not properly terminate the SlotPool.",e);
    }
  }
}
