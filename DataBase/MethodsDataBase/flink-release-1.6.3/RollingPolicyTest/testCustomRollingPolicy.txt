@Test public void testCustomRollingPolicy() throws Exception {
  final File outDir=TEMP_FOLDER.newFolder();
  final Path path=new Path(outDir.toURI());
  final MethodCallCountingPolicyWrapper<String,String> rollingPolicy=new MethodCallCountingPolicyWrapper<>(new RollingPolicy<String,String>(){
    private static final long serialVersionUID=1L;
    @Override public boolean shouldRollOnCheckpoint(    PartFileInfo<String> partFileState){
      return true;
    }
    @Override public boolean shouldRollOnEvent(    PartFileInfo<String> partFileState,    String element) throws IOException {
      return partFileState.getSize() > 9L;
    }
    @Override public boolean shouldRollOnProcessingTime(    PartFileInfo<String> partFileState,    long currentTime){
      return currentTime - partFileState.getLastUpdateTime() >= 10L;
    }
  }
);
  final Buckets<String,String> buckets=createBuckets(path,rollingPolicy);
  rollingPolicy.verifyCallCounters(0L,0L,0L,0L,0L,0L);
  buckets.onElement("test1",new TestUtils.MockSinkContext(1L,1L,2L));
  buckets.onElement("test1",new TestUtils.MockSinkContext(2L,1L,2L));
  rollingPolicy.verifyCallCounters(0L,0L,1L,0L,0L,0L);
  buckets.onElement("test1",new TestUtils.MockSinkContext(2L,1L,2L));
  rollingPolicy.verifyCallCounters(0L,0L,2L,1L,0L,0L);
  buckets.snapshotState(1L,new TestUtils.MockListState<>(),new TestUtils.MockListState<>());
  rollingPolicy.verifyCallCounters(1L,1L,2L,1L,0L,0L);
  buckets.onElement("test1",new TestUtils.MockSinkContext(2L,1L,5L));
  buckets.onProcessingTime(12L);
  rollingPolicy.verifyCallCounters(1L,1L,2L,1L,1L,0L);
  buckets.onProcessingTime(16L);
  rollingPolicy.verifyCallCounters(1L,1L,2L,1L,2L,1L);
  buckets.close();
}
