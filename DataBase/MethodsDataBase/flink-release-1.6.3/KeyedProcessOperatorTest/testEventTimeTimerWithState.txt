/** 
 * Verifies that we don't have leakage between different keys.
 */
@Test public void testEventTimeTimerWithState() throws Exception {
  KeyedProcessOperator<Integer,Integer,String> operator=new KeyedProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.EVENT_TIME));
  OneInputStreamOperatorTestHarness<Integer,String> testHarness=new KeyedOneInputStreamOperatorTestHarness<>(operator,new IdentityKeySelector<Integer>(),BasicTypeInfo.INT_TYPE_INFO);
  testHarness.setup();
  testHarness.open();
  testHarness.processWatermark(new Watermark(1));
  testHarness.processElement(new StreamRecord<>(17,0L));
  testHarness.processElement(new StreamRecord<>(13,0L));
  testHarness.processWatermark(new Watermark(2));
  testHarness.processElement(new StreamRecord<>(42,1L));
  testHarness.processElement(new StreamRecord<>(13,1L));
  testHarness.processWatermark(new Watermark(6));
  testHarness.processWatermark(new Watermark(7));
  ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<>();
  expectedOutput.add(new Watermark(1L));
  expectedOutput.add(new StreamRecord<>("INPUT:17",0L));
  expectedOutput.add(new StreamRecord<>("INPUT:13",0L));
  expectedOutput.add(new Watermark(2L));
  expectedOutput.add(new StreamRecord<>("INPUT:42",1L));
  expectedOutput.add(new StreamRecord<>("STATE:17",6L));
  expectedOutput.add(new Watermark(6L));
  expectedOutput.add(new StreamRecord<>("STATE:42",7L));
  expectedOutput.add(new Watermark(7L));
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
  testHarness.close();
}
