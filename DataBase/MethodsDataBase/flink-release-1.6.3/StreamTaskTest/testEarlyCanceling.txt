/** 
 * This test checks that cancel calls that are issued before the operator is instantiated still lead to proper canceling.
 */
@Test public void testEarlyCanceling() throws Exception {
  Deadline deadline=Deadline.fromNow(Duration.ofMinutes(2));
  StreamConfig cfg=new StreamConfig(new Configuration());
  cfg.setOperatorID(new OperatorID(4711L,42L));
  cfg.setStreamOperator(new SlowlyDeserializingOperator());
  cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);
  Task task=createTask(SourceStreamTask.class,cfg,new Configuration());
  TestingExecutionStateListener testingExecutionStateListener=new TestingExecutionStateListener();
  task.registerExecutionListener(testingExecutionStateListener);
  task.startTaskThread();
  Future<ExecutionState> running=testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.RUNNING);
  ExecutionState executionState=running.get(deadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
  if (executionState != ExecutionState.RUNNING) {
    fail("Task entered state " + task.getExecutionState() + " with error "+ ExceptionUtils.stringifyException(task.getFailureCause()));
  }
  task.cancelExecution();
  Future<ExecutionState> canceling=testingExecutionStateListener.notifyWhenExecutionState(ExecutionState.CANCELING);
  executionState=canceling.get(deadline.timeLeft().toMillis(),TimeUnit.MILLISECONDS);
  assertTrue(executionState == ExecutionState.CANCELING || executionState == ExecutionState.CANCELED);
  task.getExecutingThread().join(deadline.timeLeft().toMillis());
  assertFalse("Task did not cancel",task.getExecutingThread().isAlive());
  assertEquals(ExecutionState.CANCELED,task.getExecutionState());
}
