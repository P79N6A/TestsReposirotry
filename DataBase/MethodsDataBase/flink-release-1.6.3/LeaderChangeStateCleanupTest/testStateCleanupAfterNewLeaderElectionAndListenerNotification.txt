/** 
 * Tests that a job is properly canceled in the case of a leader change. In such an event all TaskManagers have to disconnect from the previous leader and connect to the newly elected leader.
 */
@Test public void testStateCleanupAfterNewLeaderElectionAndListenerNotification() throws Exception {
  UUID leaderSessionID1=UUID.randomUUID();
  UUID leaderSessionID2=UUID.randomUUID();
  highAvailabilityServices.grantLeadership(jobId,0,leaderSessionID1);
  highAvailabilityServices.notifyRetrievers(jobId,0,leaderSessionID1);
  cluster.waitForTaskManagersToBeRegistered(timeout);
  cluster.submitJobDetached(job);
  ActorGateway jm=cluster.getLeaderGateway(timeout);
  Future<Object> wait=jm.ask(new WaitForAllVerticesToBeRunningOrFinished(job.getJobID()),timeout);
  Await.ready(wait,timeout);
  Future<Object> jobRemoval=jm.ask(new NotifyWhenJobRemoved(job.getJobID()),timeout);
  highAvailabilityServices.grantLeadership(jobId,1,leaderSessionID2);
  highAvailabilityServices.notifyRetrievers(jobId,1,leaderSessionID2);
  Await.ready(jobRemoval,timeout);
  cluster.waitForTaskManagersToBeRegistered(timeout);
  ActorGateway jm2=cluster.getLeaderGateway(timeout);
  Future<Object> futureNumberSlots=jm2.ask(JobManagerMessages.getRequestTotalNumberOfSlots(),timeout);
  int numberSlots=(Integer)Await.result(futureNumberSlots,timeout);
  assertEquals(parallelism,numberSlots);
  Tasks.BlockingOnceReceiver$.MODULE$.blocking_$eq(false);
  cluster.submitJobAndWait(job,false,timeout);
}
