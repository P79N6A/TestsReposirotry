/** 
 * a multi-threaded test on weighted round robin
 */
@Test public void testRoundRobinLoadBalanceWithWeight(){
  final Map<Invoker,InvokeResult> totalMap=new HashMap<Invoker,InvokeResult>();
  final AtomicBoolean shouldBegin=new AtomicBoolean(false);
  final int runs=10000;
  List<Thread> threads=new ArrayList<Thread>();
  int threadNum=10;
  for (int i=0; i < threadNum; i++) {
    threads.add(new Thread(){
      @Override public void run(){
        while (!shouldBegin.get()) {
          try {
            sleep(5);
          }
 catch (          InterruptedException e) {
          }
        }
        Map<Invoker,InvokeResult> resultMap=getWeightedInvokeResult(runs,RoundRobinLoadBalance.NAME);
synchronized (totalMap) {
          for (          Entry<Invoker,InvokeResult> entry : resultMap.entrySet()) {
            if (!totalMap.containsKey(entry.getKey())) {
              totalMap.put(entry.getKey(),entry.getValue());
            }
 else {
              totalMap.get(entry.getKey()).getCount().addAndGet(entry.getValue().getCount().get());
            }
          }
        }
      }
    }
);
  }
  for (  Thread thread : threads) {
    thread.start();
  }
  shouldBegin.set(true);
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  assertStrictWRRResult(runs * threadNum,totalMap);
}
