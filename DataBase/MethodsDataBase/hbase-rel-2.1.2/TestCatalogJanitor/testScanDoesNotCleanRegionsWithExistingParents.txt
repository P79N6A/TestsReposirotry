/** 
 * CatalogJanitor.scan() should not clean parent regions if their own parents are still referencing them. This ensures that grandparent regions do not point to deleted parent regions.
 */
@Test public void testScanDoesNotCleanRegionsWithExistingParents() throws Exception {
  TableDescriptor td=createTableDescriptorForCurrentMethod();
  HRegionInfo parent=new HRegionInfo(td.getTableName(),Bytes.toBytes("aaa"),HConstants.EMPTY_BYTE_ARRAY,true);
  Thread.sleep(1001);
  HRegionInfo splita=new HRegionInfo(td.getTableName(),Bytes.toBytes("aaa"),Bytes.toBytes("ccc"),true);
  Thread.sleep(1001);
  HRegionInfo splitaa=new HRegionInfo(td.getTableName(),Bytes.toBytes("aaa"),Bytes.toBytes("bbb"),false);
  HRegionInfo splitab=new HRegionInfo(td.getTableName(),Bytes.toBytes("bbb"),Bytes.toBytes("ccc"),false);
  HRegionInfo splitb=new HRegionInfo(td.getTableName(),Bytes.toBytes("ccc"),HConstants.EMPTY_BYTE_ARRAY);
  Thread.sleep(1001);
  final Map<HRegionInfo,Result> splitParents=new TreeMap<>(new SplitParentFirstComparator());
  splitParents.put(parent,createResult(parent,splita,splitb));
  splita.setOffline(true);
  splitParents.put(splita,createResult(splita,splitaa,splitab));
  final Map<HRegionInfo,Result> mergedRegions=new TreeMap<>();
  CatalogJanitor spy=spy(this.janitor);
  doReturn(new Triple<>(10,mergedRegions,splitParents)).when(spy).getMergedRegionsAndSplitParents();
  LOG.info("parent=" + parent.getShortNameToLog() + ", splita="+ splita.getShortNameToLog());
  Path splitaRef=createReferences(this.masterServices,td,parent,splita,Bytes.toBytes("ccc"),false);
  LOG.info("Created reference " + splitaRef);
  assertEquals(0,spy.scan());
  FileSystem fs=FileSystem.get(HTU.getConfiguration());
  assertTrue(fs.delete(splitaRef,true));
  assertEquals(2,spy.scan());
}
