/** 
 * Test the load balancing algorithm. Invariant is that all servers should be hosting either floor(average) or ceiling(average) at both table level and cluster level Deliberately generate a special case to show the overall strategy can achieve cluster level balance while the bytable strategy cannot
 * @throws Exception
 */
@Test public void testImpactOfBalanceClusterOverall() throws Exception {
  Map<TableName,Map<ServerName,List<RegionInfo>>> clusterLoad=new TreeMap<>();
  Map<ServerName,List<RegionInfo>> clusterServers=mockUniformClusterServers(mockUniformCluster);
  List<ServerAndLoad> clusterList=convertToList(clusterServers);
  clusterLoad.put(TableName.valueOf(name.getMethodName()),clusterServers);
  HashMap<TableName,TreeMap<ServerName,List<RegionInfo>>> result1=mockClusterServersWithTables(clusterServers);
  loadBalancer.setClusterLoad(clusterLoad);
  List<RegionPlan> clusterplans1=new ArrayList<RegionPlan>();
  List<Pair<TableName,Integer>> regionAmountList=new ArrayList<Pair<TableName,Integer>>();
  for (  TreeMap<ServerName,List<RegionInfo>> servers : result1.values()) {
    List<ServerAndLoad> list=convertToList(servers);
    LOG.info("Mock Cluster : " + printMock(list) + " "+ printStats(list));
    List<RegionPlan> partialplans=loadBalancer.balanceCluster(servers);
    if (partialplans != null)     clusterplans1.addAll(partialplans);
    List<ServerAndLoad> balancedClusterPerTable=reconcile(list,partialplans,servers);
    LOG.info("Mock Balance : " + printMock(balancedClusterPerTable));
    assertClusterAsBalanced(balancedClusterPerTable);
    for (    Map.Entry<ServerName,List<RegionInfo>> entry : servers.entrySet()) {
      returnRegions(entry.getValue());
      returnServer(entry.getKey());
    }
  }
  List<ServerAndLoad> balancedCluster1=reconcile(clusterList,clusterplans1,clusterServers);
  assertTrue(assertClusterOverallAsBalanced(balancedCluster1,result1.keySet().size()));
}
