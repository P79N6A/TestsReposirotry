/** 
 * Test the load balancing algorithm. Invariant is that all servers should be hosting either floor(average) or ceiling(average) at both table level and cluster level
 * @throws Exception
 */
@Test public void testBalanceClusterOverall() throws Exception {
  Map<TableName,Map<ServerName,List<RegionInfo>>> clusterLoad=new TreeMap<>();
  for (  int[] mockCluster : clusterStateMocks) {
    Map<ServerName,List<RegionInfo>> clusterServers=mockClusterServers(mockCluster,50);
    List<ServerAndLoad> clusterList=convertToList(clusterServers);
    clusterLoad.put(TableName.valueOf(name.getMethodName()),clusterServers);
    HashMap<TableName,TreeMap<ServerName,List<RegionInfo>>> result=mockClusterServersWithTables(clusterServers);
    loadBalancer.setClusterLoad(clusterLoad);
    List<RegionPlan> clusterplans=new ArrayList<>();
    List<Pair<TableName,Integer>> regionAmountList=new ArrayList<>();
    for (    TreeMap<ServerName,List<RegionInfo>> servers : result.values()) {
      List<ServerAndLoad> list=convertToList(servers);
      LOG.info("Mock Cluster : " + printMock(list) + " "+ printStats(list));
      List<RegionPlan> partialplans=loadBalancer.balanceCluster(servers);
      if (partialplans != null)       clusterplans.addAll(partialplans);
      List<ServerAndLoad> balancedClusterPerTable=reconcile(list,partialplans,servers);
      LOG.info("Mock Balance : " + printMock(balancedClusterPerTable));
      assertClusterAsBalanced(balancedClusterPerTable);
      for (      Map.Entry<ServerName,List<RegionInfo>> entry : servers.entrySet()) {
        returnRegions(entry.getValue());
        returnServer(entry.getKey());
      }
    }
    List<ServerAndLoad> balancedCluster=reconcile(clusterList,clusterplans,clusterServers);
    assertTrue(assertClusterOverallAsBalanced(balancedCluster,result.keySet().size()));
  }
}
