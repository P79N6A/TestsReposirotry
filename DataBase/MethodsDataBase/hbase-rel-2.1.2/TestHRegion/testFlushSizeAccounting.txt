/** 
 * Test we do not lose data if we fail a flush and then close. Part of HBase-10466.  Tests the following from the issue description: "Bug 1: Wrong calculation of HRegion.memstoreSize: When a flush fails, data to be flushed is kept in each MemStore's snapshot and wait for next flush attempt to continue on it. But when the next flush succeeds, the counter of total memstore size in HRegion is always deduced by the sum of current memstore sizes instead of snapshots left from previous failed flush. This calculation is problematic that almost every time there is failed flush, HRegion.memstoreSize gets reduced by a wrong value. If region flush could not proceed for a couple cycles, the size in current memstore could be much larger than the snapshot. It's likely to drift memstoreSize much smaller than expected. In extreme case, if the error accumulates to even bigger than HRegion's memstore size limit, any further flush is skipped because flush does not do anything if memstoreSize is not larger than 0."
 * @throws Exception
 */
@Test public void testFlushSizeAccounting() throws Exception {
  final Configuration conf=HBaseConfiguration.create(CONF);
  final WAL wal=createWALCompatibleWithFaultyFileSystem(method,conf,tableName);
  conf.setInt("hbase.hstore.flush.retries.number",1);
  final User user=User.createUserForTesting(conf,method,new String[]{"foo"});
  conf.setClass("fs.file.impl",FaultyFileSystem.class,FileSystem.class);
  user.runAs(new PrivilegedExceptionAction<Object>(){
    @Override public Object run() throws Exception {
      FileSystem fs=FileSystem.get(conf);
      Assert.assertEquals(FaultyFileSystem.class,fs.getClass());
      FaultyFileSystem ffs=(FaultyFileSystem)fs;
      HRegion region=null;
      try {
        region=initHRegion(tableName,null,null,false,Durability.SYNC_WAL,wal,COLUMN_FAMILY_BYTES);
        long size=region.getMemStoreDataSize();
        Assert.assertEquals(0,size);
        Put p1=new Put(row);
        p1.add(new KeyValue(row,COLUMN_FAMILY_BYTES,qual1,1,(byte[])null));
        region.put(p1);
        final long sizeOfOnePut=region.getMemStoreDataSize();
        try {
          LOG.info("Flushing");
          region.flush(true);
          Assert.fail("Didn't bubble up IOE!");
        }
 catch (        DroppedSnapshotException dse) {
          region.closing.set(false);
        }
        ffs.fault.set(false);
        Assert.assertEquals(sizeOfOnePut,region.getMemStoreDataSize());
        Put p2=new Put(row);
        p2.add(new KeyValue(row,COLUMN_FAMILY_BYTES,qual2,2,(byte[])null));
        p2.add(new KeyValue(row,COLUMN_FAMILY_BYTES,qual3,3,(byte[])null));
        region.put(p2);
        long expectedSize=sizeOfOnePut * 3;
        Assert.assertEquals(expectedSize,region.getMemStoreDataSize());
        region.flush(true);
        Assert.assertEquals(sizeOfOnePut * 2,region.getMemStoreDataSize());
      }
  finally {
        HBaseTestingUtility.closeRegionAndWAL(region);
      }
      return null;
    }
  }
);
  FileSystem.closeAllForUGI(user.getUGI());
}
