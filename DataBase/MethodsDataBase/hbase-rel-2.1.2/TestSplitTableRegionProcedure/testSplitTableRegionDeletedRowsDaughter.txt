@Test public void testSplitTableRegionDeletedRowsDaughter() throws Exception {
  final TableName tableName=TableName.valueOf(name.getMethodName());
  final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
  RegionInfo[] regions=MasterProcedureTestingUtility.createTable(procExec,tableName,null,ColumnFamilyName1,ColumnFamilyName2);
  insertData(tableName);
  int splitRowNum=rowCount;
  deleteData(tableName,splitRowNum);
  byte[] splitKey=Bytes.toBytes("" + splitRowNum);
  assertTrue("not able to find a splittable region",regions != null);
  assertTrue("not able to find a splittable region",regions.length == 1);
  collectAssignmentManagerMetrics();
  long procId=procExec.submitProcedure(new SplitTableRegionProcedure(procExec.getEnvironment(),regions[0],splitKey));
  ProcedureTestingUtility.waitProcedure(procExec,procId);
  ProcedureTestingUtility.assertProcNotFailed(procExec,procId);
  UTIL.getAdmin().majorCompact(tableName);
  UTIL.waitFor(6000,new Waiter.Predicate<IOException>(){
    @Override public boolean evaluate() throws IOException {
      return UTIL.getAdmin().getCompactionState(tableName) == CompactionState.NONE;
    }
  }
);
  List<HRegion> daughters=UTIL.getMiniHBaseCluster().getRegions(tableName);
  assertTrue(daughters.size() == 2);
  final int currentRowCount=splitRowNum - startRowNum;
  assertTrue(UTIL.countRows(tableName) == currentRowCount);
  assertTrue(UTIL.countRows(daughters.get(0)) == 0 || UTIL.countRows(daughters.get(1)) == 0);
  assertEquals(splitSubmittedCount + 1,splitProcMetrics.getSubmittedCounter().getCount());
  assertEquals(splitFailedCount,splitProcMetrics.getFailedCounter().getCount());
}
