@Test public void testRollbackAndDoubleExecution() throws Exception {
  final TableName tableName=TableName.valueOf(name.getMethodName());
  final ProcedureExecutor<MasterProcedureEnv> procExec=getMasterProcedureExecutor();
  RegionInfo[] regions=MasterProcedureTestingUtility.createTable(procExec,tableName,null,ColumnFamilyName1,ColumnFamilyName2);
  insertData(tableName);
  int splitRowNum=startRowNum + rowCount / 2;
  byte[] splitKey=Bytes.toBytes("" + splitRowNum);
  assertTrue("not able to find a splittable region",regions != null);
  assertTrue("not able to find a splittable region",regions.length == 1);
  ProcedureTestingUtility.waitNoProcedureRunning(procExec);
  ProcedureTestingUtility.setKillAndToggleBeforeStoreUpdate(procExec,true);
  collectAssignmentManagerMetrics();
  long procId=procExec.submitProcedure(new SplitTableRegionProcedure(procExec.getEnvironment(),regions[0],splitKey));
  int lastStep=7;
  MasterProcedureTestingUtility.testRollbackAndDoubleExecution(procExec,procId,lastStep,true);
  assertEquals(1,UTIL.getHBaseAdmin().getTableRegions(tableName).size());
  UTIL.waitUntilAllRegionsAssigned(tableName);
  List<HRegion> newRegions=UTIL.getMiniHBaseCluster().getRegions(tableName);
  assertEquals(1,newRegions.size());
  verifyData(newRegions.get(0),startRowNum,rowCount,Bytes.toBytes(ColumnFamilyName1),Bytes.toBytes(ColumnFamilyName2));
  assertEquals(splitSubmittedCount + 1,splitProcMetrics.getSubmittedCounter().getCount());
  assertEquals(splitFailedCount + 1,splitProcMetrics.getFailedCounter().getCount());
}
