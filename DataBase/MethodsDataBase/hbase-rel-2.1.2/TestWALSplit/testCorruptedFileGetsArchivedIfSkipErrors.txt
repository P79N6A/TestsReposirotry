@Test public void testCorruptedFileGetsArchivedIfSkipErrors() throws IOException {
  conf.setBoolean(HBASE_SKIP_ERRORS,true);
  List<FaultyProtobufLogReader.FailureType> failureTypes=Arrays.asList(FaultyProtobufLogReader.FailureType.values()).stream().filter(x -> x != FaultyProtobufLogReader.FailureType.NONE).collect(Collectors.toList());
  for (  FaultyProtobufLogReader.FailureType failureType : failureTypes) {
    final Set<String> walDirContents=splitCorruptWALs(failureType);
    final Set<String> archivedLogs=new HashSet<>();
    final StringBuilder archived=new StringBuilder("Archived logs in CORRUPTDIR:");
    for (    FileStatus log : fs.listStatus(CORRUPTDIR)) {
      archived.append("\n\t").append(log.toString());
      archivedLogs.add(log.getPath().getName());
    }
    LOG.debug(archived.toString());
    assertEquals(failureType.name() + ": expected to find all of our wals corrupt.",archivedLogs,walDirContents);
  }
}
