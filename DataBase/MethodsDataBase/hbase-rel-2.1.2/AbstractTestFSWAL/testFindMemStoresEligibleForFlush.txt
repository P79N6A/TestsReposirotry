/** 
 * On rolling a wal after reaching the threshold,  {@link WAL#rollWriter()} returns the list ofregions which should be flushed in order to archive the oldest wal file. <p> This method tests this behavior by inserting edits and rolling the wal enough times to reach the max number of logs threshold. It checks whether we get the "right regions" for flush on rolling the wal.
 * @throws Exception
 */
@Test public void testFindMemStoresEligibleForFlush() throws Exception {
  LOG.debug("testFindMemStoresEligibleForFlush");
  Configuration conf1=HBaseConfiguration.create(CONF);
  conf1.setInt("hbase.regionserver.maxlogs",1);
  AbstractFSWAL<?> wal=newWAL(FS,CommonFSUtils.getWALRootDir(conf1),DIR.toString(),HConstants.HREGION_OLDLOGDIR_NAME,conf1,null,true,null,null);
  TableDescriptor t1=TableDescriptorBuilder.newBuilder(TableName.valueOf("t1")).setColumnFamily(ColumnFamilyDescriptorBuilder.of("row")).build();
  TableDescriptor t2=TableDescriptorBuilder.newBuilder(TableName.valueOf("t2")).setColumnFamily(ColumnFamilyDescriptorBuilder.of("row")).build();
  RegionInfo hri1=RegionInfoBuilder.newBuilder(t1.getTableName()).build();
  RegionInfo hri2=RegionInfoBuilder.newBuilder(t2.getTableName()).build();
  MultiVersionConcurrencyControl mvcc=new MultiVersionConcurrencyControl();
  NavigableMap<byte[],Integer> scopes1=new TreeMap<>(Bytes.BYTES_COMPARATOR);
  for (  byte[] fam : t1.getColumnFamilyNames()) {
    scopes1.put(fam,0);
  }
  NavigableMap<byte[],Integer> scopes2=new TreeMap<>(Bytes.BYTES_COMPARATOR);
  for (  byte[] fam : t2.getColumnFamilyNames()) {
    scopes2.put(fam,0);
  }
  try {
    addEdits(wal,hri1,t1,2,mvcc,scopes1);
    wal.rollWriter();
    addEdits(wal,hri1,t1,2,mvcc,scopes1);
    wal.rollWriter();
    assertTrue(wal.getNumRolledLogFiles() == 2);
    byte[][] regionsToFlush=wal.findRegionsToForceFlush();
    assertEquals(1,regionsToFlush.length);
    assertEquals(hri1.getEncodedNameAsBytes(),regionsToFlush[0]);
    addEdits(wal,hri2,t2,2,mvcc,scopes2);
    regionsToFlush=wal.findRegionsToForceFlush();
    assertEquals(1,regionsToFlush.length);
    assertEquals(hri1.getEncodedNameAsBytes(),regionsToFlush[0]);
    flushRegion(wal,hri1.getEncodedNameAsBytes(),t1.getColumnFamilyNames());
    wal.rollWriter();
    assertEquals(1,wal.getNumRolledLogFiles());
    flushRegion(wal,hri2.getEncodedNameAsBytes(),t2.getColumnFamilyNames());
    wal.rollWriter(true);
    assertEquals(0,wal.getNumRolledLogFiles());
    addEdits(wal,hri1,t1,2,mvcc,scopes1);
    addEdits(wal,hri2,t2,2,mvcc,scopes2);
    wal.rollWriter();
    assertEquals(1,wal.getNumRolledLogFiles());
    addEdits(wal,hri1,t1,2,mvcc,scopes1);
    wal.rollWriter();
    regionsToFlush=wal.findRegionsToForceFlush();
    assertEquals(2,regionsToFlush.length);
    flushRegion(wal,hri1.getEncodedNameAsBytes(),t1.getColumnFamilyNames());
    flushRegion(wal,hri2.getEncodedNameAsBytes(),t2.getColumnFamilyNames());
    wal.rollWriter(true);
    assertEquals(0,wal.getNumRolledLogFiles());
    addEdits(wal,hri1,t1,2,mvcc,scopes1);
    wal.startCacheFlush(hri1.getEncodedNameAsBytes(),t1.getColumnFamilyNames());
    wal.rollWriter();
    wal.completeCacheFlush(hri1.getEncodedNameAsBytes());
    assertEquals(1,wal.getNumRolledLogFiles());
  }
  finally {
    if (wal != null) {
      wal.close();
    }
  }
}
