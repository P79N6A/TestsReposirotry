/** 
 * Tests wal archiving by adding data, doing flushing/rolling and checking we archive old logs and also don't archive "live logs" (that is, a log with un-flushed entries). <p> This is what it does: It creates two regions, and does a series of inserts along with log rolling. Whenever a WAL is rolled, HLogBase checks previous wals for archiving. A wal is eligible for archiving if for all the regions which have entries in that wal file, have flushed - past their maximum sequence id in that wal file. <p>
 * @throws IOException
 */
@Test public void testWALArchiving() throws IOException {
  LOG.debug(currentTest.getMethodName());
  TableDescriptor table1=TableDescriptorBuilder.newBuilder(TableName.valueOf(currentTest.getMethodName() + "1")).setColumnFamily(ColumnFamilyDescriptorBuilder.of("row")).build();
  TableDescriptor table2=TableDescriptorBuilder.newBuilder(TableName.valueOf(currentTest.getMethodName() + "2")).setColumnFamily(ColumnFamilyDescriptorBuilder.of("row")).build();
  NavigableMap<byte[],Integer> scopes1=new TreeMap<>(Bytes.BYTES_COMPARATOR);
  for (  byte[] fam : table1.getColumnFamilyNames()) {
    scopes1.put(fam,0);
  }
  NavigableMap<byte[],Integer> scopes2=new TreeMap<>(Bytes.BYTES_COMPARATOR);
  for (  byte[] fam : table2.getColumnFamilyNames()) {
    scopes2.put(fam,0);
  }
  Configuration localConf=new Configuration(conf);
  localConf.set(WALFactory.WAL_PROVIDER,FSHLogProvider.class.getName());
  WALFactory wals=new WALFactory(localConf,currentTest.getMethodName());
  try {
    WAL wal=wals.getWAL(null);
    assertEquals(0,AbstractFSWALProvider.getNumRolledLogFiles(wal));
    RegionInfo hri1=RegionInfoBuilder.newBuilder(table1.getTableName()).build();
    RegionInfo hri2=RegionInfoBuilder.newBuilder(table2.getTableName()).build();
    addEdits(wal,hri1,table1,1,scopes1);
    wal.rollWriter();
    assertEquals(1,AbstractFSWALProvider.getNumRolledLogFiles(wal));
    addEdits(wal,hri1,table1,1,scopes1);
    wal.rollWriter();
    assertEquals(2,AbstractFSWALProvider.getNumRolledLogFiles(wal));
    addEdits(wal,hri1,table1,3,scopes1);
    flushRegion(wal,hri1.getEncodedNameAsBytes(),table1.getColumnFamilyNames());
    wal.rollWriter();
    assertEquals(0,AbstractFSWALProvider.getNumRolledLogFiles(wal));
    addEdits(wal,hri2,table2,1,scopes2);
    wal.rollWriter();
    assertEquals(1,AbstractFSWALProvider.getNumRolledLogFiles(wal));
    addEdits(wal,hri1,table1,2,scopes1);
    wal.rollWriter();
    assertEquals(2,AbstractFSWALProvider.getNumRolledLogFiles(wal));
    addEdits(wal,hri2,table2,2,scopes2);
    flushRegion(wal,hri1.getEncodedNameAsBytes(),table2.getColumnFamilyNames());
    wal.rollWriter();
    assertEquals(2,AbstractFSWALProvider.getNumRolledLogFiles(wal));
    addEdits(wal,hri2,table2,2,scopes2);
    flushRegion(wal,hri2.getEncodedNameAsBytes(),table2.getColumnFamilyNames());
    wal.rollWriter();
    assertEquals(0,AbstractFSWALProvider.getNumRolledLogFiles(wal));
  }
  finally {
    if (wals != null) {
      wals.close();
    }
  }
}
