/** 
 * Here is the unit test for UserScanQueryMatcher#mergeFilterResponse: the match code may be changed to SEEK_NEXT_COL or INCLUDE_AND_SEEK_NEXT_COL after merging with filterResponse, even if the passed match code is neither SEEK_NEXT_COL nor INCLUDE_AND_SEEK_NEXT_COL. In that case, we need to make sure that the ColumnTracker has been switched to the next column. <br/> An effective test way is: we only need to check the cell from getKeyForNextColumn(). because that as long as the UserScanQueryMatcher returns SEEK_NEXT_COL or INCLUDE_AND_SEEK_NEXT_COL, UserScanQueryMatcher#getKeyForNextColumn should return an cell whose column is larger than the current cell's.
 */
@Test public void testMergeFilterResponseCase2() throws Exception {
  List<MatchCode> expected=new ArrayList<>();
  expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
  expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
  expected.add(ScanQueryMatcher.MatchCode.INCLUDE);
  expected.add(ScanQueryMatcher.MatchCode.SEEK_NEXT_COL);
  Scan scanWithFilter=new Scan(scan).setFilter(new AlwaysIncludeFilter()).readVersions(3);
  long now=EnvironmentEdgeManager.currentTime();
  UserScanQueryMatcher qm=UserScanQueryMatcher.create(scanWithFilter,new ScanInfo(this.conf,fam2,0,5,ttl,KeepDeletedCells.FALSE,HConstants.DEFAULT_BLOCKSIZE,0,rowComparator,false),get.getFamilyMap().get(fam2),now - ttl,now,null);
  List<KeyValue> memstore=new ArrayList<>();
  memstore.add(new KeyValue(row1,fam1,col2,1,data));
  memstore.add(new KeyValue(row1,fam1,col2,2,data));
  memstore.add(new KeyValue(row1,fam1,col2,3,data));
  memstore.add(new KeyValue(row1,fam1,col2,4,data));
  KeyValue k=memstore.get(0);
  qm.setToNewRow(k);
  for (int i=0; i < memstore.size(); i++) {
    assertEquals(expected.get(i),qm.match(memstore.get(i)));
  }
  Cell lastCell=memstore.get(memstore.size() - 1);
  Cell nextCell=qm.getKeyForNextColumn(lastCell);
  assertArrayEquals(nextCell.getQualifierArray(),col4);
}
