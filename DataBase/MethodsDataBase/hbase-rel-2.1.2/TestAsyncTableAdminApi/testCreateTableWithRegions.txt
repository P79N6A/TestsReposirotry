@Test public void testCreateTableWithRegions() throws Exception {
  byte[][] splitKeys={new byte[]{1,1,1},new byte[]{2,2,2},new byte[]{3,3,3},new byte[]{4,4,4},new byte[]{5,5,5},new byte[]{6,6,6},new byte[]{7,7,7},new byte[]{8,8,8},new byte[]{9,9,9}};
  int expectedRegions=splitKeys.length + 1;
  boolean tablesOnMaster=LoadBalancer.isTablesOnMaster(TEST_UTIL.getConfiguration());
  createTableWithDefaultConf(tableName,splitKeys);
  boolean tableAvailable=admin.isTableAvailable(tableName,splitKeys).get();
  assertTrue("Table should be created with splitKyes + 1 rows in META",tableAvailable);
  AsyncTable<AdvancedScanResultConsumer> metaTable=ASYNC_CONN.getTable(META_TABLE_NAME);
  List<HRegionLocation> regions=AsyncMetaTableAccessor.getTableHRegionLocations(metaTable,Optional.of(tableName)).get();
  Iterator<HRegionLocation> hris=regions.iterator();
  assertEquals("Tried to create " + expectedRegions + " regions "+ "but only found "+ regions.size(),expectedRegions,regions.size());
  System.err.println("Found " + regions.size() + " regions");
  RegionInfo hri;
  hris=regions.iterator();
  hri=hris.next().getRegion();
  assertTrue(hri.getStartKey() == null || hri.getStartKey().length == 0);
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[0]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[0]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[1]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[1]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[2]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[2]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[3]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[3]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[4]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[4]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[5]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[5]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[6]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[6]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[7]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[7]));
  assertTrue(Bytes.equals(hri.getEndKey(),splitKeys[8]));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),splitKeys[8]));
  assertTrue(hri.getEndKey() == null || hri.getEndKey().length == 0);
  if (tablesOnMaster) {
    verifyRoundRobinDistribution(regions,expectedRegions);
  }
  byte[] startKey={1,1,1,1,1,1,1,1,1,1};
  byte[] endKey={9,9,9,9,9,9,9,9,9,9};
  expectedRegions=10;
  final TableName tableName2=TableName.valueOf(tableName.getNameAsString() + "_2");
  TableDescriptorBuilder builder=TableDescriptorBuilder.newBuilder(tableName2);
  builder.setColumnFamily(ColumnFamilyDescriptorBuilder.of(FAMILY));
  admin.createTable(builder.build(),startKey,endKey,expectedRegions).join();
  regions=AsyncMetaTableAccessor.getTableHRegionLocations(metaTable,Optional.of(tableName2)).get();
  assertEquals("Tried to create " + expectedRegions + " regions "+ "but only found "+ regions.size(),expectedRegions,regions.size());
  System.err.println("Found " + regions.size() + " regions");
  hris=regions.iterator();
  hri=hris.next().getRegion();
  assertTrue(hri.getStartKey() == null || hri.getStartKey().length == 0);
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{1,1,1,1,1,1,1,1,1,1}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{1,1,1,1,1,1,1,1,1,1}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{2,2,2,2,2,2,2,2,2,2}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{2,2,2,2,2,2,2,2,2,2}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{3,3,3,3,3,3,3,3,3,3}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{3,3,3,3,3,3,3,3,3,3}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{4,4,4,4,4,4,4,4,4,4}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{4,4,4,4,4,4,4,4,4,4}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{5,5,5,5,5,5,5,5,5,5}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{5,5,5,5,5,5,5,5,5,5}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{6,6,6,6,6,6,6,6,6,6}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{6,6,6,6,6,6,6,6,6,6}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{7,7,7,7,7,7,7,7,7,7}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{7,7,7,7,7,7,7,7,7,7}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{8,8,8,8,8,8,8,8,8,8}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{8,8,8,8,8,8,8,8,8,8}));
  assertTrue(Bytes.equals(hri.getEndKey(),new byte[]{9,9,9,9,9,9,9,9,9,9}));
  hri=hris.next().getRegion();
  assertTrue(Bytes.equals(hri.getStartKey(),new byte[]{9,9,9,9,9,9,9,9,9,9}));
  assertTrue(hri.getEndKey() == null || hri.getEndKey().length == 0);
  if (tablesOnMaster) {
    verifyRoundRobinDistribution(regions,expectedRegions);
  }
  startKey=new byte[]{0,0,0,0,0,0};
  endKey=new byte[]{1,0,0,0,0,0};
  expectedRegions=5;
  final TableName tableName3=TableName.valueOf(tableName.getNameAsString() + "_3");
  builder=TableDescriptorBuilder.newBuilder(tableName3);
  builder.setColumnFamily(ColumnFamilyDescriptorBuilder.of(FAMILY));
  admin.createTable(builder.build(),startKey,endKey,expectedRegions).join();
  regions=AsyncMetaTableAccessor.getTableHRegionLocations(metaTable,Optional.of(tableName3)).get();
  assertEquals("Tried to create " + expectedRegions + " regions "+ "but only found "+ regions.size(),expectedRegions,regions.size());
  System.err.println("Found " + regions.size() + " regions");
  if (tablesOnMaster) {
    verifyRoundRobinDistribution(regions,expectedRegions);
  }
  splitKeys=new byte[][]{new byte[]{1,1,1},new byte[]{2,2,2},new byte[]{3,3,3},new byte[]{2,2,2}};
  final TableName tableName4=TableName.valueOf(tableName.getNameAsString() + "_4");
  try {
    createTableWithDefaultConf(tableName4,splitKeys);
    fail("Should not be able to create this table because of " + "duplicate split keys");
  }
 catch (  CompletionException e) {
    assertTrue(e.getCause() instanceof IllegalArgumentException);
  }
}
