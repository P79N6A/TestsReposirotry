/** 
 * This test exercises the path where there is a split after initial validation but before the atomic bulk load call. We cannot use presplitting to test this path, so we actually inject a split just before the atomic region load.
 */
@Test public void testSplitWhileBulkLoadPhase() throws Exception {
  final TableName table=TableName.valueOf(name.getMethodName());
  try (Connection connection=ConnectionFactory.createConnection(util.getConfiguration())){
    setupTable(connection,table,10);
    populateTable(connection,table,1);
    assertExpectedTable(table,ROWCOUNT,1);
    final AtomicInteger attemptedCalls=new AtomicInteger();
    LoadIncrementalHFiles lih2=new LoadIncrementalHFiles(util.getConfiguration()){
      @Override protected void bulkLoadPhase(      final Table htable,      final Connection conn,      ExecutorService pool,      Deque<LoadQueueItem> queue,      final Multimap<ByteBuffer,LoadQueueItem> regionGroups,      boolean copyFile,      Map<LoadQueueItem,ByteBuffer> item2RegionMap) throws IOException {
        int i=attemptedCalls.incrementAndGet();
        if (i == 1) {
          forceSplit(table);
        }
        super.bulkLoadPhase(htable,conn,pool,queue,regionGroups,copyFile,item2RegionMap);
      }
    }
;
    try (Table t=connection.getTable(table);RegionLocator locator=connection.getRegionLocator(table);Admin admin=connection.getAdmin()){
      Path bulk=buildBulkFiles(table,2);
      lih2.doBulkLoad(bulk,admin,t,locator);
    }
     assertEquals(3,attemptedCalls.get());
    assertExpectedTable(table,ROWCOUNT,2);
  }
 }
