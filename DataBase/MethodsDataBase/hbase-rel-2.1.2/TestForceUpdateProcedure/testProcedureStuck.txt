@Test public void testProcedureStuck() throws IOException, InterruptedException {
  EXEC.submitProcedure(new ParentProcedure());
  EXCHANGER.exchange(Boolean.TRUE);
  UTIL.waitFor(10000,() -> EXEC.getActiveExecutorCount() == 0);
  long procId=EXEC.submitProcedure(new ExchangeProcedure());
  assertEquals(1,STORE.getActiveLogs().size());
  for (int i=0; i < WAL_COUNT - 1; i++) {
    assertTrue(STORE.rollWriterForTesting());
    assertEquals(2 + i,STORE.getActiveLogs().size());
    EXCHANGER.exchange(Boolean.TRUE);
    Thread.sleep(1000);
  }
  STORE.rollWriterForTesting();
  EXCHANGER.exchange(Boolean.FALSE);
  UTIL.waitFor(10000,() -> STORE.getActiveLogs().size() <= 2);
  UTIL.waitFor(10000,() -> EXEC.isFinished(procId));
  stopStoreAndExecutor();
  createStoreAndExecutor();
  Map<Class<?>,Procedure<Void>> procMap=new HashMap<>();
  EXEC.getActiveProceduresNoCopy().forEach(p -> procMap.put(p.getClass(),p));
  assertEquals(3,procMap.size());
  ParentProcedure parentProc=(ParentProcedure)procMap.get(ParentProcedure.class);
  assertEquals(ProcedureState.WAITING,parentProc.getState());
  WaitingProcedure waitingProc=(WaitingProcedure)procMap.get(WaitingProcedure.class);
  assertEquals(ProcedureState.WAITING_TIMEOUT,waitingProc.getState());
  NoopProcedure<Void> noopProc=(NoopProcedure<Void>)procMap.get(NoopProcedure.class);
  assertEquals(ProcedureState.SUCCESS,noopProc.getState());
}
