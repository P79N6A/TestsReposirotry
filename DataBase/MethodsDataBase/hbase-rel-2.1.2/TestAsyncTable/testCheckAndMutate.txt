@Test public void testCheckAndMutate() throws InterruptedException, ExecutionException {
  AsyncTable<?> table=getTable.get();
  int count=10;
  CountDownLatch putLatch=new CountDownLatch(count + 1);
  table.put(new Put(row).addColumn(FAMILY,QUALIFIER,VALUE)).thenRun(() -> putLatch.countDown());
  IntStream.range(0,count).forEach(i -> table.put(new Put(row).addColumn(FAMILY,concat(QUALIFIER,i),VALUE)).thenRun(() -> putLatch.countDown()));
  putLatch.await();
  AtomicInteger successCount=new AtomicInteger(0);
  AtomicInteger successIndex=new AtomicInteger(-1);
  CountDownLatch mutateLatch=new CountDownLatch(count);
  IntStream.range(0,count).forEach(i -> {
    RowMutations mutation=new RowMutations(row);
    try {
      mutation.add(new Delete(row).addColumn(FAMILY,QUALIFIER));
      mutation.add(new Put(row).addColumn(FAMILY,concat(QUALIFIER,i),concat(VALUE,i)));
    }
 catch (    IOException e) {
      throw new UncheckedIOException(e);
    }
    table.checkAndMutate(row,FAMILY).qualifier(QUALIFIER).ifEquals(VALUE).thenMutate(mutation).thenAccept(x -> {
      if (x) {
        successCount.incrementAndGet();
        successIndex.set(i);
      }
      mutateLatch.countDown();
    }
);
  }
);
  mutateLatch.await();
  assertEquals(1,successCount.get());
  Result result=table.get(new Get(row)).get();
  IntStream.range(0,count).forEach(i -> {
    if (i == successIndex.get()) {
      assertArrayEquals(concat(VALUE,i),result.getValue(FAMILY,concat(QUALIFIER,i)));
    }
 else {
      assertArrayEquals(VALUE,result.getValue(FAMILY,concat(QUALIFIER,i)));
    }
  }
);
}
