@Test public void testCheckAndDelete() throws InterruptedException, ExecutionException {
  AsyncTable<?> table=getTable.get();
  int count=10;
  CountDownLatch putLatch=new CountDownLatch(count + 1);
  table.put(new Put(row).addColumn(FAMILY,QUALIFIER,VALUE)).thenRun(() -> putLatch.countDown());
  IntStream.range(0,count).forEach(i -> table.put(new Put(row).addColumn(FAMILY,concat(QUALIFIER,i),VALUE)).thenRun(() -> putLatch.countDown()));
  putLatch.await();
  AtomicInteger successCount=new AtomicInteger(0);
  AtomicInteger successIndex=new AtomicInteger(-1);
  CountDownLatch deleteLatch=new CountDownLatch(count);
  IntStream.range(0,count).forEach(i -> table.checkAndMutate(row,FAMILY).qualifier(QUALIFIER).ifEquals(VALUE).thenDelete(new Delete(row).addColumn(FAMILY,QUALIFIER).addColumn(FAMILY,concat(QUALIFIER,i))).thenAccept(x -> {
    if (x) {
      successCount.incrementAndGet();
      successIndex.set(i);
    }
    deleteLatch.countDown();
  }
));
  deleteLatch.await();
  assertEquals(1,successCount.get());
  Result result=table.get(new Get(row)).get();
  IntStream.range(0,count).forEach(i -> {
    if (i == successIndex.get()) {
      assertFalse(result.containsColumn(FAMILY,concat(QUALIFIER,i)));
    }
 else {
      assertArrayEquals(VALUE,result.getValue(FAMILY,concat(QUALIFIER,i)));
    }
  }
);
}
