@Test public void test() throws Exception {
  CONF.setInt("hbase.hregion.memstore.flush.size",1024 * 1024 * 10);
  CONF.setInt("hbase.hstore.report.interval.edits",1);
  CONF.setInt("hbase.hstore.report.period",0);
  final RegionServerAccounting rsAccounting=new RegionServerAccounting(CONF);
  RegionServerServices rs=Mockito.mock(RegionServerServices.class);
  ChunkCreator.initialize(MemStoreLABImpl.CHUNK_SIZE_DEFAULT,false,0,0,0,null);
  Mockito.when(rs.getRegionServerAccounting()).thenReturn(rsAccounting);
  Mockito.when(rs.isAborted()).thenReturn(false);
  Mockito.when(rs.getNonceManager()).thenReturn(null);
  Mockito.when(rs.getServerName()).thenReturn(ServerName.valueOf("test",0,111));
  TableName testTable=TableName.valueOf("testRecoveredEidtsReplayAndAbort");
  TableDescriptor htd=TableDescriptorBuilder.newBuilder(testTable).addColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(fam1).build()).build();
  HRegionInfo info=new HRegionInfo(htd.getTableName(),HConstants.EMPTY_BYTE_ARRAY,HConstants.EMPTY_BYTE_ARRAY,false);
  Path logDir=TEST_UTIL.getDataTestDirOnTestFS("TestRecoveredEidtsReplayAndAbort.log");
  final WAL wal=HBaseTestingUtility.createWal(CONF,logDir,info);
  Path rootDir=TEST_UTIL.getDataTestDir();
  Path tableDir=FSUtils.getTableDir(rootDir,info.getTable());
  HRegionFileSystem.createRegionOnFileSystem(CONF,TEST_UTIL.getTestFileSystem(),tableDir,info);
  region=HRegion.newHRegion(tableDir,wal,TEST_UTIL.getTestFileSystem(),CONF,info,htd,rs);
  final WALFactory wals=new WALFactory(CONF,method);
  try {
    Path regiondir=region.getRegionFileSystem().getRegionDir();
    FileSystem fs=region.getRegionFileSystem().getFileSystem();
    byte[] regionName=region.getRegionInfo().getEncodedNameAsBytes();
    Path recoveredEditsDir=WALSplitter.getRegionDirRecoveredEditsDir(regiondir);
    long maxSeqId=1200;
    long minSeqId=1000;
    long totalEdits=maxSeqId - minSeqId;
    for (long i=minSeqId; i <= maxSeqId; i+=100) {
      Path recoveredEdits=new Path(recoveredEditsDir,String.format("%019d",i));
      LOG.info("Begin to write recovered.edits : " + recoveredEdits);
      fs.create(recoveredEdits);
      WALProvider.Writer writer=wals.createRecoveredEditsWriter(fs,recoveredEdits);
      for (long j=i; j < i + 100; j++) {
        long time=System.nanoTime();
        WALEdit edit=new WALEdit();
        byte[] value=new byte[200 * 1024];
        random.nextBytes(value);
        edit.add(new KeyValue(row,fam1,Bytes.toBytes(j),time,KeyValue.Type.Put,value));
        writer.append(new WAL.Entry(new WALKeyImpl(regionName,tableName,j,time,HConstants.DEFAULT_CLUSTER_ID),edit));
      }
      writer.close();
    }
    MonitoredTask status=TaskMonitor.get().createStatus(method);
    try {
      region.initialize(new CancelableProgressable(){
        private long replayedEdits=0;
        @Override public boolean progress(){
          replayedEdits++;
          Assert.assertEquals(rsAccounting.getGlobalMemStoreDataSize(),region.getMemStoreDataSize());
          Assert.assertEquals(rsAccounting.getGlobalMemStoreHeapSize(),region.getMemStoreHeapSize());
          Assert.assertEquals(rsAccounting.getGlobalMemStoreOffHeapSize(),region.getMemStoreOffHeapSize());
          return replayedEdits < totalEdits - 10;
        }
      }
);
      Assert.fail("Should not reach here");
    }
 catch (    IOException t) {
      LOG.info("Current memstore: " + region.getMemStoreDataSize() + ", "+ region.getMemStoreHeapSize()+ ", "+ region.getMemStoreOffHeapSize());
    }
    Assert.assertEquals(0,rsAccounting.getGlobalMemStoreDataSize());
    Assert.assertEquals(0,region.getMemStoreDataSize());
    Assert.assertEquals(0,ChunkCreator.getInstance().numberOfMappedChunks());
  }
  finally {
    HBaseTestingUtility.closeRegionAndWAL(this.region);
    this.region=null;
    wals.close();
  }
}
