/** 
 * This test verifies region exception doesn't corrupt the results of batch. The prescription is shown below. 1) honor the action result rather than region exception. If the action have both of true result and region exception, the action is fine as the exception is caused by other actions which are in the same region. 2) honor the action exception rather than region exception. If the action have both of action exception and region exception, we deal with the action exception only. If we also handle the region exception for the same action, it will introduce the negative count of actions in progress. The AsyncRequestFuture#waitUntilDone will block forever. If the RetriesExhaustedWithDetailsException contains the whole batch, each result should be of IOE. Otherwise, the row operation which is not in the exception should have a true result. The no-cluster test is in TestAsyncProcessWithRegionException.
 */
@Test public void testRegionExceptionByAsync() throws Exception {
  List<Row> batches=new ArrayList<>();
  batches.add(new Put(Bytes.toBytes("good")).addColumn(FAMILY,null,new byte[10]));
  RowMutations rm=new RowMutations(Bytes.toBytes("fail"));
  rm.add(new Put(rm.getRow()).addColumn(FAMILY,null,new byte[CELL_SIZE]));
  batches.add(rm);
  try (AsyncConnection asyncConnection=ConnectionFactory.createAsyncConnection(TEST_UTIL.getConfiguration()).get()){
    AsyncTable<AdvancedScanResultConsumer> table=asyncConnection.getTable(TABLE_NAME);
    List<CompletableFuture<AdvancedScanResultConsumer>> results=table.batch(batches);
    assertEquals(2,results.size());
    try {
      results.get(1).get();
      fail("Where is the exception? We put the malformed cells!!!");
    }
 catch (    ExecutionException e) {
    }
    Result result=table.get(new Get(Bytes.toBytes("good"))).get();
    assertEquals(1,result.size());
    Cell cell=result.getColumnLatestCell(FAMILY,null);
    assertTrue(Bytes.equals(CellUtil.cloneValue(cell),new byte[10]));
  }
 }
