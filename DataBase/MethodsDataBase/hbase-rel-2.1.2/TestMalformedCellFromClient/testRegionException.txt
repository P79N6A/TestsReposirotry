/** 
 * The purpose of this ut is to check the consistency between the exception and results. If the RetriesExhaustedWithDetailsException contains the whole batch, each result should be of IOE. Otherwise, the row operation which is not in the exception should have a true result.
 */
@Test public void testRegionException() throws InterruptedException, IOException {
  List<Row> batches=new ArrayList<>();
  batches.add(new Put(Bytes.toBytes("good")).addColumn(FAMILY,null,new byte[10]));
  RowMutations rm=new RowMutations(Bytes.toBytes("fail"));
  rm.add(new Put(rm.getRow()).addColumn(FAMILY,null,new byte[CELL_SIZE]));
  batches.add(rm);
  Object[] results=new Object[batches.size()];
  try (Table table=TEST_UTIL.getConnection().getTable(TABLE_NAME)){
    Throwable exceptionByCaught=null;
    try {
      table.batch(batches,results);
      fail("Where is the exception? We put the malformed cells!!!");
    }
 catch (    RetriesExhaustedWithDetailsException e) {
      for (      Throwable throwable : e.getCauses()) {
        assertNotNull(throwable);
      }
      assertEquals(1,e.getNumExceptions());
      exceptionByCaught=e.getCause(0);
    }
    for (    Object obj : results) {
      assertNotNull(obj);
    }
    assertEquals(Result.class,results[0].getClass());
    assertEquals(exceptionByCaught.getClass(),results[1].getClass());
    Result result=table.get(new Get(Bytes.toBytes("good")));
    assertEquals(1,result.size());
    Cell cell=result.getColumnLatestCell(FAMILY,null);
    assertTrue(Bytes.equals(CellUtil.cloneValue(cell),new byte[10]));
  }
 }
