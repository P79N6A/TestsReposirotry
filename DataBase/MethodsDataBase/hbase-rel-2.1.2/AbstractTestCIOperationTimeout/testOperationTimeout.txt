/** 
 * Test that an operation can fail if we read the global operation timeout, even if the individual timeout is fine. We do that with: <ul> <li>client side: an operation timeout of 30 seconds</li> <li>server side: we sleep 20 second at each attempt. The first work fails, the second one succeeds. But the client won't wait that much, because 20 + 20 > 30, so the client timed out when the server answers.</li> </ul>
 */
@Test public void testOperationTimeout() throws IOException {
  TableBuilder builder=TEST_UTIL.getConnection().getTableBuilder(tableName,null).setRpcTimeout(Integer.MAX_VALUE).setReadRpcTimeout(Integer.MAX_VALUE).setWriteRpcTimeout(Integer.MAX_VALUE);
  SleepAndFailFirstTime.ct.set(0);
  try (Table table=builder.setOperationTimeout(120 * 1000).build()){
    execute(table);
  }
   SleepAndFailFirstTime.ct.set(0);
  try (Table table=builder.setOperationTimeout(30 * 1000).build()){
    SleepAndFailFirstTime.ct.set(0);
    execute(table);
    fail("We expect an exception here");
  }
 catch (  SocketTimeoutException|RetriesExhaustedWithDetailsException e) {
    LOG.info("We received an exception, as expected ",e);
  }
}
