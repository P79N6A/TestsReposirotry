/** 
 * Check that the table queue is not deletable until every procedure in-progress is completed (this is a special case for read-locks).
 */
@Test public void testCreateDeleteTableOperationsWithReadLock() throws Exception {
  final TableName tableName=TableName.valueOf(name.getMethodName());
  final int nitems=2;
  final TestTableProcedure dummyProc=new TestTableProcedure(100,tableName,TableProcedureInterface.TableOperationType.DELETE);
  for (int i=1; i <= nitems; ++i) {
    queue.addBack(new TestTableProcedure(i,tableName,TableProcedureInterface.TableOperationType.READ));
  }
  assertFalse(queue.markTableAsDeleted(tableName,dummyProc));
  Procedure<?>[] procs=new Procedure[nitems];
  for (int i=0; i < nitems; ++i) {
    Procedure<?> proc=queue.poll();
    procs[i]=proc;
    assertEquals(i + 1,proc.getProcId());
    assertEquals(false,queue.waitTableSharedLock(proc,tableName));
    assertFalse(queue.markTableAsDeleted(tableName,dummyProc));
  }
  for (int i=0; i < nitems; ++i) {
    assertFalse(queue.markTableAsDeleted(tableName,dummyProc));
    queue.wakeTableSharedLock(procs[i],tableName);
  }
  assertEquals(0,queue.size());
  assertTrue(queue.markTableAsDeleted(tableName,dummyProc));
}
