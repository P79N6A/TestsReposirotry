@Test public void testConcurrentPeerOperations() throws Exception {
  TestPeerProcedureSet procSet=new TestPeerProcedureSet(queue);
  int NUM_ITEMS=10;
  int NUM_PEERS=5;
  AtomicInteger opsCount=new AtomicInteger(0);
  for (int i=0; i < NUM_PEERS; ++i) {
    String peerId=String.format("test-peer-%04d",i);
    for (int j=1; j < NUM_ITEMS; ++j) {
      procSet.addBack(new TestPeerProcedure(i * 100 + j,peerId,PeerOperationType.ADD));
      opsCount.incrementAndGet();
    }
  }
  assertEquals(opsCount.get(),queue.size());
  Thread[] threads=new Thread[NUM_PEERS * 2];
  HashSet<String> concurrentPeers=new HashSet<>();
  ArrayList<String> failures=new ArrayList<>();
  AtomicInteger concurrentCount=new AtomicInteger(0);
  for (int i=0; i < threads.length; ++i) {
    threads[i]=new Thread(){
      @Override public void run(){
        while (opsCount.get() > 0) {
          try {
            TestPeerProcedure proc=procSet.acquire();
            if (proc == null) {
              queue.signalAll();
              if (opsCount.get() > 0) {
                continue;
              }
              break;
            }
            String peerId=proc.getPeerId();
synchronized (concurrentPeers) {
              assertTrue("unexpected concurrency on " + peerId,concurrentPeers.add(peerId));
            }
            assertTrue(opsCount.decrementAndGet() >= 0);
            try {
              long procId=proc.getProcId();
              int concurrent=concurrentCount.incrementAndGet();
              assertTrue("inc-concurrent=" + concurrent + " 1 <= concurrent <= "+ NUM_PEERS,concurrent >= 1 && concurrent <= NUM_PEERS);
              LOG.debug("[S] peerId=" + peerId + " procId="+ procId+ " concurrent="+ concurrent);
              Thread.sleep(2000);
              concurrent=concurrentCount.decrementAndGet();
              LOG.debug("[E] peerId=" + peerId + " procId="+ procId+ " concurrent="+ concurrent);
              assertTrue("dec-concurrent=" + concurrent,concurrent < NUM_PEERS);
            }
  finally {
synchronized (concurrentPeers) {
                assertTrue(concurrentPeers.remove(peerId));
              }
              procSet.release(proc);
            }
          }
 catch (          Throwable e) {
            LOG.error("Failed " + e.getMessage(),e);
synchronized (failures) {
              failures.add(e.getMessage());
            }
          }
 finally {
            queue.signalAll();
          }
        }
      }
    }
;
    threads[i].start();
  }
  for (int i=0; i < threads.length; ++i) {
    threads[i].join();
  }
  assertTrue(failures.toString(),failures.isEmpty());
  assertEquals(0,opsCount.get());
  assertEquals(0,queue.size());
}
