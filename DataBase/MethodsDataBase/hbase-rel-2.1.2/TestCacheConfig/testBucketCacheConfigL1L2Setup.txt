/** 
 * Assert that when BUCKET_CACHE_COMBINED_KEY is false, the non-default, that we deploy LruBlockCache as L1 with a BucketCache for L2.
 */
@Test public void testBucketCacheConfigL1L2Setup(){
  this.conf.set(HConstants.BUCKET_CACHE_IOENGINE_KEY,"offheap");
  this.conf.setFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY,0.001f);
  MemoryUsage mu=ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
  long lruExpectedSize=MemorySizeUtil.getOnHeapCacheSize(this.conf);
  final int bcSize=100;
  long bcExpectedSize=100 * 1024 * 1024;
  assertTrue(lruExpectedSize < bcExpectedSize);
  this.conf.setInt(HConstants.BUCKET_CACHE_SIZE_KEY,bcSize);
  CacheConfig.instantiateBlockCache(this.conf);
  CacheConfig cc=new CacheConfig(this.conf);
  basicBlockCacheOps(cc,false,false);
  assertTrue(cc.getBlockCache() instanceof CombinedBlockCache);
  CombinedBlockCache cbc=(CombinedBlockCache)cc.getBlockCache();
  LruBlockCache lbc=cbc.onHeapCache;
  assertEquals(lruExpectedSize,lbc.getMaxSize());
  BlockCache bc=cbc.l2Cache;
  assertEquals(bcExpectedSize,((BucketCache)bc).getMaxSize());
  long initialL1BlockCount=lbc.getBlockCount();
  long initialL2BlockCount=bc.getBlockCount();
  Cacheable c=new DataCacheEntry();
  BlockCacheKey bck=new BlockCacheKey("bck",0);
  lbc.cacheBlock(bck,c,false);
  assertEquals(initialL1BlockCount + 1,lbc.getBlockCount());
  assertEquals(initialL2BlockCount,bc.getBlockCount());
  final long justTooBigSize=lbc.acceptableSize() + 1;
  lbc.cacheBlock(new BlockCacheKey("bck2",0),new DataCacheEntry(){
    @Override public long heapSize(){
      return justTooBigSize;
    }
    @Override public int getSerializedLength(){
      return (int)heapSize();
    }
  }
);
  while (initialL1BlockCount != lbc.getBlockCount())   Threads.sleep(10);
  assertEquals(initialL1BlockCount,lbc.getBlockCount());
}
