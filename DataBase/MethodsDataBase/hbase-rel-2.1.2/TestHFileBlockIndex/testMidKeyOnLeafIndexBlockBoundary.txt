/** 
 * to check if looks good when midKey on a leaf index block boundary
 * @throws IOException
 */
@Test public void testMidKeyOnLeafIndexBlockBoundary() throws IOException {
  Path hfilePath=new Path(TEST_UTIL.getDataTestDir(),"hfile_for_midkey");
  int maxChunkSize=512;
  conf.setInt(HFileBlockIndex.MAX_CHUNK_SIZE_KEY,maxChunkSize);
  conf.setBoolean(CacheConfig.CACHE_INDEX_BLOCKS_ON_WRITE_KEY,true);
  CacheConfig.instantiateBlockCache(conf);
  CacheConfig cacheConf=new CacheConfig(conf);
  BlockCache blockCache=cacheConf.getBlockCache();
  blockCache.evictBlocksByHfileName(hfilePath.getName());
  HFileContext meta=new HFileContextBuilder().withBlockSize(SMALL_BLOCK_SIZE).withCompression(Algorithm.NONE).withDataBlockEncoding(DataBlockEncoding.NONE).build();
  HFile.Writer writer=HFile.getWriterFactory(conf,cacheConf).withPath(fs,hfilePath).withFileContext(meta).create();
  Random rand=new Random(19231737);
  byte[] family=Bytes.toBytes("f");
  byte[] qualifier=Bytes.toBytes("q");
  int kvNumberToBeWritten=16;
  for (int i=0; i < kvNumberToBeWritten; ++i) {
    byte[] row=RandomKeyValueUtil.randomOrderedFixedLengthKey(rand,i,30);
    KeyValue kv=new KeyValue(row,family,qualifier,EnvironmentEdgeManager.currentTime(),RandomKeyValueUtil.randomFixedLengthValue(rand,SMALL_BLOCK_SIZE));
    writer.append(kv);
  }
  writer.close();
  conf.setBoolean(CacheConfig.CACHE_INDEX_BLOCKS_ON_WRITE_KEY,false);
  HFile.Reader reader=HFile.createReader(fs,hfilePath,cacheConf,true,conf);
  boolean hasArrayIndexOutOfBoundsException=false;
  try {
    reader.midKey();
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    hasArrayIndexOutOfBoundsException=true;
  }
 finally {
    reader.close();
  }
  assertFalse(hasArrayIndexOutOfBoundsException);
}
