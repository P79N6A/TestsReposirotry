/** 
 * One side finding several paths to one node previously visited by the other side. The other side is kept busy with a chain of cost zero.
 */
@Test public void test3(){
  graph.makeEdge("a","b","cost",(double)0);
  graph.makeEdge("b","c","cost",(float)0);
  graph.makeEdge("c","d","cost",(long)0);
  graph.makeEdge("d","e","cost",0);
  graph.makeEdge("e","f","cost",(byte)0);
  graph.makeEdge("f","g","cost",(float)0);
  graph.makeEdge("g","h","cost",(short)0);
  graph.makeEdge("h","i","cost",(double)0);
  graph.makeEdge("i","j","cost",(double)0);
  graph.makeEdge("j","k","cost",(double)0);
  graph.makeEdge("z","y","cost",(double)0);
  graph.makeEdge("y","x","cost",(double)0);
  graph.makeEdge("x","w","cost",(double)0);
  graph.makeEdge("w","b","cost",(double)1);
  graph.makeEdge("x","b","cost",(float)2);
  graph.makeEdge("y","b","cost",(long)1);
  graph.makeEdge("z","b","cost",1);
  graph.makeEdge("zz","z","cost",(double)0);
  Dijkstra<Double> dijkstra=getDijkstra(graph,0.0,"a","zz");
  assertEquals(3,dijkstra.getPathsAsNodes().size());
  assertEquals(1.0,dijkstra.getCost(),0.0);
}
