@Test void flushAndForceMustNotLockPageCacheForWholeDuration(){
  assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
    maxPages=5000;
    configureStandardPageCache();
    PageCache pageCache=this.pageCache;
    this.pageCache=null;
    File a=existingFile("a");
    File b=existingFile("b");
    try (PagedFile pfA=map(pageCache,a,filePageSize)){
      try (PageCursor cursor=pfA.io(0,PF_SHARED_WRITE_LOCK)){
        for (int i=0; i < maxPages; i++) {
          assertTrue(cursor.next());
        }
      }
       BinaryLatch limiterStartLatch=new BinaryLatch();
      BinaryLatch limiterBlockLatch=new BinaryLatch();
      Future<?> flusher=executor.submit(() -> {
        pageCache.flushAndForce((stamp,ios,flushable) -> {
          limiterStartLatch.release();
          limiterBlockLatch.await();
          return 0;
        }
);
        return null;
      }
);
      limiterStartLatch.await();
      map(pageCache,b,filePageSize).close();
      pageCache.listExistingMappings();
      pageCache.getExistingMapping(a).ifPresent(pf -> {
        try {
          pf.close();
        }
 catch (        IOException e) {
          throw new UncheckedIOException(e);
        }
      }
);
      limiterBlockLatch.release();
      flusher.get();
    }
   }
);
}
