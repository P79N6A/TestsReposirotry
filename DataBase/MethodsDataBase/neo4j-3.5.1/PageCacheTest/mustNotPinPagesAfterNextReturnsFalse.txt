@Test void mustNotPinPagesAfterNextReturnsFalse(){
  assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
    final CountDownLatch startLatch=new CountDownLatch(1);
    final CountDownLatch unpinLatch=new CountDownLatch(1);
    final AtomicReference<Exception> exceptionRef=new AtomicReference<>();
    configureStandardPageCache();
    generateFileWithRecords(file("a"),recordsPerFilePage,recordSize);
    final PagedFile pagedFile=map(file("a"),filePageSize);
    Runnable runnable=() -> {
      try (PageCursor cursorA=pagedFile.io(0,PF_SHARED_WRITE_LOCK | PF_NO_GROW)){
        assertTrue(cursorA.next());
        assertFalse(cursorA.next());
        startLatch.countDown();
        unpinLatch.await();
      }
 catch (      Exception e) {
        exceptionRef.set(e);
      }
    }
;
    executor.submit(runnable);
    startLatch.await();
    try (PageCursor cursorB=pagedFile.io(1,PF_SHARED_WRITE_LOCK)){
      assertTrue(cursorB.next());
      unpinLatch.countDown();
    }
  finally {
      pagedFile.close();
    }
    Exception e=exceptionRef.get();
    if (e != null) {
      throw new Exception("Child thread got exception",e);
    }
  }
);
}
