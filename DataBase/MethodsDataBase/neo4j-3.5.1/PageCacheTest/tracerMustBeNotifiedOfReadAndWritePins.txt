@Test void tracerMustBeNotifiedOfReadAndWritePins() throws Exception {
  final AtomicInteger writeCount=new AtomicInteger();
  final AtomicInteger readCount=new AtomicInteger();
  DefaultPageCacheTracer tracer=new DefaultPageCacheTracer();
  DefaultPageCursorTracer pageCursorTracer=new DefaultPageCursorTracer(){
    @Override public PinEvent beginPin(    boolean writeLock,    long filePageId,    PageSwapper swapper){
      (writeLock ? writeCount : readCount).getAndIncrement();
      return super.beginPin(writeLock,filePageId,swapper);
    }
  }
;
  ConfigurablePageCursorTracerSupplier<DefaultPageCursorTracer> cursorTracerSupplier=new ConfigurablePageCursorTracerSupplier<>(pageCursorTracer);
  getPageCache(fs,maxPages,tracer,cursorTracerSupplier);
  generateFileWithRecords(file("a"),recordCount,recordSize);
  int pinsForRead=13;
  int pinsForWrite=42;
  try (PagedFile pagedFile=map(file("a"),filePageSize)){
    try (PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      for (int i=0; i < pinsForRead; i++) {
        assertTrue(cursor.next());
      }
    }
     dirtyManyPages(pagedFile,pinsForWrite);
  }
   pageCache.reportEvents();
  assertThat("wrong read pin count",readCount.get(),is(pinsForRead));
  assertThat("wrong write pin count",writeCount.get(),is(pinsForWrite));
}
