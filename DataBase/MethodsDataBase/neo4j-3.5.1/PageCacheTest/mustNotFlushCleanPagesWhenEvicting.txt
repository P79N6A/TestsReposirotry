@Test void mustNotFlushCleanPagesWhenEvicting(){
  assertTimeout(ofMillis(SHORT_TIMEOUT_MILLIS),() -> {
    final AtomicBoolean observedWrite=new AtomicBoolean();
    FileSystemAbstraction fs=new DelegatingFileSystemAbstraction(this.fs){
      @Override public StoreChannel open(      File fileName,      OpenMode openMode) throws IOException {
        StoreChannel channel=super.open(fileName,openMode);
        return new DelegatingStoreChannel(channel){
          @Override public long write(          ByteBuffer[] srcs,          int offset,          int length) throws IOException {
            observedWrite.set(true);
            throw new IOException("not allowed");
          }
          @Override public void writeAll(          ByteBuffer src,          long position) throws IOException {
            observedWrite.set(true);
            throw new IOException("not allowed");
          }
          @Override public void writeAll(          ByteBuffer src) throws IOException {
            observedWrite.set(true);
            throw new IOException("not allowed");
          }
          @Override public int write(          ByteBuffer src) throws IOException {
            observedWrite.set(true);
            throw new IOException("not allowed");
          }
          @Override public long write(          ByteBuffer[] srcs) throws IOException {
            observedWrite.set(true);
            throw new IOException("not allowed");
          }
        }
;
      }
    }
;
    getPageCache(fs,maxPages,PageCacheTracer.NULL,PageCursorTracerSupplier.NULL);
    generateFileWithRecords(file("a"),recordCount,recordSize);
    try (PagedFile pagedFile=map(file("a"),filePageSize);PageCursor cursor=pagedFile.io(0,PF_SHARED_READ_LOCK)){
      while (cursor.next()) {
        verifyRecordsMatchExpected(cursor);
      }
    }
     assertFalse(observedWrite.get());
  }
);
}
