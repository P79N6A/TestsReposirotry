@Test(timeout=60_000L) public void shouldReportCauseOfPopulationFailureIfPopulationFailsDuringRecovery() throws IOException, IndexNotFoundKernelException, InterruptedException {
  long indexId=1;
  StoreIndexDescriptor indexRule=uniqueIndex.withId(indexId);
  Barrier.Control barrier=new Barrier.Control();
  CountDownLatch exceptionBarrier=new CountDownLatch(1);
  IndexingService indexing=newIndexingServiceWithMockedDependencies(populator,accessor,withData(),new IndexingService.MonitorAdapter(){
    @Override public void awaitingPopulationOfRecoveredIndex(    StoreIndexDescriptor descriptor){
      barrier.reached();
    }
  }
,indexRule);
  when(indexProvider.getInitialState(indexRule)).thenReturn(POPULATING);
  life.init();
  ExecutorService executor=Executors.newSingleThreadExecutor();
  try {
    AtomicReference<Throwable> startException=new AtomicReference<>();
    executor.submit(() -> {
      try {
        life.start();
      }
 catch (      Throwable t) {
        startException.set(t);
        exceptionBarrier.countDown();
      }
    }
);
    barrier.await();
    IndexProxy indexProxy=indexing.getIndexProxy(indexRule.schema());
    assertThat(indexProxy,instanceOf(ContractCheckingIndexProxy.class));
    ContractCheckingIndexProxy contractCheckingIndexProxy=(ContractCheckingIndexProxy)indexProxy;
    IndexProxy delegate=contractCheckingIndexProxy.getDelegate();
    assertThat(delegate,instanceOf(FlippableIndexProxy.class));
    FlippableIndexProxy flippableIndexProxy=(FlippableIndexProxy)delegate;
    Exception expectedCause=new Exception("index was failed on purpose");
    IndexPopulationFailure indexFailure=IndexPopulationFailure.failure(expectedCause);
    flippableIndexProxy.flipTo(new FailedIndexProxy(mock(CapableIndexDescriptor.class),"string",mock(IndexPopulator.class),indexFailure,mock(IndexCountsRemover.class),internalLogProvider));
    barrier.release();
    exceptionBarrier.await();
    Throwable actual=startException.get();
    assertThat(actual.getCause(),instanceOf(IllegalStateException.class));
    assertThat(Exceptions.stringify(actual.getCause()),Matchers.containsString(Exceptions.stringify(expectedCause)));
  }
  finally {
    executor.shutdown();
  }
}
