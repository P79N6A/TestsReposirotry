@Test(timeout=TIMEOUT) public void unlockExclusiveAndTakeWriteLockMustBeAtomic() throws Exception {
  int threads=Runtime.getRuntime().availableProcessors() - 1;
  CountDownLatch start=new CountDownLatch(threads);
  AtomicBoolean stop=new AtomicBoolean();
  pageList.tryExclusiveLock(pageRef);
  Runnable runnable=() -> {
    while (!stop.get()) {
      if (pageList.tryExclusiveLock(pageRef)) {
        pageList.unlockExclusive(pageRef);
        throw new RuntimeException("I should not have gotten that lock");
      }
      start.countDown();
    }
  }
;
  List<Future<?>> futures=new ArrayList<>();
  for (int i=0; i < threads; i++) {
    futures.add(executor.submit(runnable));
  }
  start.await();
  pageList.unlockExclusiveAndTakeWriteLock(pageRef);
  stop.set(true);
  for (  Future<?> future : futures) {
    future.get();
  }
}
