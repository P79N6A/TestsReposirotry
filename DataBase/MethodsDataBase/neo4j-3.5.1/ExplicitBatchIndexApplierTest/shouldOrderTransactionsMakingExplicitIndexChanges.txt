@Test public void shouldOrderTransactionsMakingExplicitIndexChanges() throws Throwable {
  MutableObjectIntMap<String> names=ObjectIntHashMap.newWithKeysValues("first",0,"second",1);
  MutableObjectIntMap<String> keys=ObjectIntHashMap.newWithKeysValues("key",0);
  String applierName="test-applier";
  ExplicitIndexApplierLookup applierLookup=mock(ExplicitIndexApplierLookup.class);
  TransactionApplier transactionApplier=mock(TransactionApplier.class);
  when(applierLookup.newApplier(anyString(),anyBoolean())).thenReturn(transactionApplier);
  IndexConfigStore config=newIndexConfigStore(names,applierName);
  SynchronizedArrayIdOrderingQueue queue=new SynchronizedArrayIdOrderingQueue();
  final AtomicLong lastAppliedTxId=new AtomicLong(-1);
  Race race=new Race();
  for (long i=0; i < 100; i++) {
    final long txId=i;
    race.addContestant(() -> {
      try (ExplicitBatchIndexApplier applier=new ExplicitBatchIndexApplier(config,applierLookup,queue,INTERNAL)){
        TransactionToApply txToApply=new TransactionToApply(new PhysicalTransactionRepresentation(new ArrayList<>()));
        FakeCommitment commitment=new FakeCommitment(txId,mock(TransactionIdStore.class));
        commitment.setHasExplicitIndexChanges(true);
        txToApply.commitment(commitment,txId);
        TransactionApplier txApplier=applier.startTx(txToApply);
        Thread.sleep(ThreadLocalRandom.current().nextInt(5));
        assertTrue(lastAppliedTxId.compareAndSet(txId - 1,txId));
        txApplier.close();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
);
    queue.offer(txId);
  }
  race.go();
}
