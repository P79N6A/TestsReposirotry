@Test public void shouldSeeThatACleanDatabaseShouldNotRequireRecovery() throws Exception {
  File file=logFiles.getLogFileForVersion(logVersion);
  writeSomeData(file,pair -> {
    LogEntryWriter writer=pair.first();
    Consumer<LogPositionMarker> consumer=pair.other();
    LogPositionMarker marker=new LogPositionMarker();
    consumer.accept(marker);
    writer.writeStartEntry(0,1,2L,3L,new byte[0]);
    writer.writeCommitEntry(4L,5L);
    consumer.accept(marker);
    writer.writeCheckPointEntry(marker.newPosition());
    return true;
  }
);
  LifeSupport life=new LifeSupport();
  RecoveryMonitor monitor=mock(RecoveryMonitor.class);
  try {
    StorageEngine storageEngine=mock(StorageEngine.class);
    final LogEntryReader<ReadableClosablePositionAwareChannel> reader=new VersionAwareLogEntryReader<>();
    LogTailScanner tailScanner=getTailScanner(logFiles,reader);
    TransactionMetadataCache metadataCache=new TransactionMetadataCache();
    LogicalTransactionStore txStore=new PhysicalLogicalTransactionStore(logFiles,metadataCache,reader,monitors,false);
    CorruptedLogsTruncator logPruner=new CorruptedLogsTruncator(storeDir,logFiles,fileSystemRule.get());
    life.add(new Recovery(new DefaultRecoveryService(storageEngine,tailScanner,transactionIdStore,txStore,versionRepository,NO_MONITOR){
      @Override public void startRecovery(){
        fail("Recovery should not be required");
      }
    }
,logPruner,monitor,SilentProgressReporter.INSTANCE,false));
    life.start();
    verifyZeroInteractions(monitor);
  }
  finally {
    life.shutdown();
  }
}
