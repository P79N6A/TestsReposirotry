@Test public void shouldHandleTheWholeWorkloadShebang() throws Throwable {
  final int size=1_000;
  final long bufferTime=3;
  VerifyingConsumer consumer=new VerifyingConsumer(size);
  final Clock clock=Clocks.systemClock();
  Supplier<Long> chunkThreshold=clock::millis;
  Predicate<Long> safeThreshold=time -> clock.millis() - bufferTime >= time;
  final DelayedBuffer<Long> buffer=new DelayedBuffer<>(chunkThreshold,safeThreshold,10,consumer);
  MaintenanceThread maintenance=new MaintenanceThread(buffer,5);
  Race adders=new Race();
  final int numberOfAdders=20;
  final byte[] offeredIds=new byte[size];
  for (int i=0; i < numberOfAdders; i++) {
    final int finalI=i;
    adders.addContestant(() -> {
      for (int j=0; j < size; j++) {
        if (j % numberOfAdders == finalI) {
          buffer.offer(j);
          offeredIds[j]=1;
          parkNanos(MILLISECONDS.toNanos(current().nextInt(2)));
        }
      }
    }
);
  }
  adders.go();
  for (int i=0; i < size; i++) {
    assertEquals("ID " + i,(byte)1,offeredIds[i]);
  }
  maintenance.halt();
  buffer.close();
  consumer.assertHaveOnlySeenRange(0,size - 1);
}
