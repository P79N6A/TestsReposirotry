@Test public void shouldWorkWhileHavingHeavyConcurrentUpdates() throws Exception {
  final long[] nodes=repeatCreateNamedPeopleFor(NAMES.length * CREATION_MULTIPLIER);
  int initialNodes=nodes.length;
  int threads=5;
  indexOnlineMonitor.initialize(threads);
  ExecutorService executorService=Executors.newFixedThreadPool(threads);
  final IndexReference index=createPersonNameIndex();
  final Collection<Callable<UpdatesTracker>> jobs=new ArrayList<>(threads);
  for (int i=0; i < threads; i++) {
    jobs.add(() -> executeCreationsDeletionsAndUpdates(nodes,CREATION_MULTIPLIER));
  }
  List<Future<UpdatesTracker>> futures=executorService.invokeAll(jobs);
  UpdatesTracker result=new UpdatesTracker();
  result.notifyPopulationCompleted();
  for (  Future<UpdatesTracker> future : futures) {
    result.add(future.get());
  }
  awaitIndexesOnline();
  executorService.shutdown();
  assertTrue(executorService.awaitTermination(1,TimeUnit.MINUTES));
  assertIndexedNodesMatchesStoreNodes();
  int seenWhilePopulating=initialNodes + result.createdDuringPopulation() - result.deletedDuringPopulation();
  double expectedSelectivity=UNIQUE_NAMES / seenWhilePopulating;
  assertCorrectIndexSelectivity(expectedSelectivity,indexSelectivity(index));
  assertCorrectIndexSize("Tracker had " + result,seenWhilePopulating,indexSize(index));
  int expectedIndexUpdates=result.deletedAfterPopulation() + result.createdAfterPopulation() + result.updatedAfterPopulation();
  assertCorrectIndexUpdates("Tracker had " + result,expectedIndexUpdates,indexUpdates(index));
}
