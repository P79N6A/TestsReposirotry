@Documented("Find node by query.\n" + "\n" + "The query language used here depends on what type of index you are\n"+ "querying. The default index type is Lucene, in which case you should use\n"+ "the Lucene query language here. Below an example of a fuzzy search over\n"+ "multiple keys.\n"+ "\n"+ "See: {lucene-base-uri}/queryparser/org/apache/lucene/queryparser/classic/package-summary.html\n"+ "\n"+ "Getting the results with a predefined ordering requires adding the\n"+ "parameter\n"+ "\n"+ "`order=ordering`\n"+ "\n"+ "where ordering is one of index, relevance or score. In this case an\n"+ "additional field will be added to each result, named score, that holds\n"+ "the float value that is the score reported by the query result.") @Test public void shouldAddToIndexAndRetrieveItByQuery() throws JsonParseException {
  String indexName=indexes.newInstance();
  String key="Name";
  String value="Builder";
  long node=helper.createNode(MapUtil.map(key,value));
  helper.addNodeToIndex(indexName,key,value,node);
  helper.addNodeToIndex(indexName,"Gender","Male",node);
  String entity=gen().expectedStatus(200).get(functionalTestHelper.indexNodeUri(indexName) + "?query=" + key+ ":Build~0.1%20AND%20Gender:Male").entity();
  Collection<?> hits=(Collection<?>)JsonHelper.readJson(entity);
  assertEquals(1,hits.size());
  LinkedHashMap<String,String> nodeMap=(LinkedHashMap)hits.iterator().next();
  assertNull("score should not be present when not explicitly ordering",nodeMap.get("score"));
}
