@Test @Resources.Life(STARTED) public void shouldNotEndUpInBrokenStateAfterRotationFailure() throws Exception {
  FakeClock clock=Clocks.fakeClock();
  CallTrackingClock callTrackingClock=new CallTrackingClock(clock);
  CountsTracker tracker=resourceManager.managed(newTracker(callTrackingClock,EmptyVersionContextSupplier.EMPTY));
  int labelId=1;
  try (CountsAccessor.Updater tx=tracker.apply(2).get()){
    tx.incrementNodeCount(labelId,1);
  }
   Predicate<Thread> arrived=thread -> stackTraceContains(thread,all(classNameContains("Rotation"),methodIs("rotate")));
  Future<Object> rotation=threading.executeAndAwait(t -> t.rotate(4),tracker,arrived,1,SECONDS);
  try (CountsAccessor.Updater tx=tracker.apply(3).get()){
    tx.incrementNodeCount(labelId,1);
  }
   while (callTrackingClock.callsToNanos() == 0) {
    Thread.sleep(10);
  }
  clock.forward(Config.defaults().get(GraphDatabaseSettings.counts_store_rotation_timeout).toMillis() * 2,MILLISECONDS);
  try {
    rotation.get();
    fail("Should've failed rotation due to timeout");
  }
 catch (  ExecutionException e) {
    assertTrue(e.getCause() instanceof RotationTimeoutException);
  }
  Register.DoubleLongRegister register=Registers.newDoubleLongRegister();
  tracker.get(CountsKeyFactory.nodeKey(labelId),register);
  assertEquals(2,register.readSecond());
  try (CountsAccessor.Updater tx=tracker.apply(4).get()){
    tx.incrementNodeCount(labelId,1);
  }
   tracker.rotate(4);
  tracker.get(CountsKeyFactory.nodeKey(labelId),register);
  assertEquals(3,register.readSecond());
}
