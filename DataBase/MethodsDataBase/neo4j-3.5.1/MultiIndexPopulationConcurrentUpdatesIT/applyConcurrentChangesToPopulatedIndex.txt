@Test public void applyConcurrentChangesToPopulatedIndex() throws Exception {
  List<EntityUpdates> updates=new ArrayList<>(2);
  updates.add(EntityUpdates.forEntity(color2.getId()).withTokens(id(COLOR_LABEL)).changed(propertyId,Values.of("green"),Values.of("pink")).build());
  updates.add(EntityUpdates.forEntity(car2.getId()).withTokens(id(CAR_LABEL)).changed(propertyId,Values.of("Ford"),Values.of("SAAB")).build());
  launchCustomIndexPopulation(labelsNameIdMap,propertyId,new UpdateGenerator(updates));
  waitAndActivateIndexes(labelsNameIdMap,propertyId);
  try (Transaction ignored=embeddedDatabase.beginTx()){
    Integer colorLabelId=labelsNameIdMap.get(COLOR_LABEL);
    Integer carLabelId=labelsNameIdMap.get(CAR_LABEL);
    try (IndexReader indexReader=getIndexReader(propertyId,colorLabelId)){
      assertEquals(format("Should be deleted by concurrent change. Reader is: %s, ",indexReader),0,indexReader.countIndexedNodes(color2.getId(),new int[]{propertyId},Values.of("green")));
    }
     try (IndexReader indexReader=getIndexReader(propertyId,colorLabelId)){
      assertEquals("Should be updated by concurrent change.",1,indexReader.countIndexedNodes(color2.getId(),new int[]{propertyId},Values.of("pink")));
    }
     try (IndexReader indexReader=getIndexReader(propertyId,carLabelId)){
      assertEquals("Should be added by concurrent change.",1,indexReader.countIndexedNodes(car2.getId(),new int[]{propertyId},Values.of("SAAB")));
    }
   }
 }
