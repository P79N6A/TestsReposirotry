@Test public void shouldIncludeStackTraceInUnexpectedCheckException(){
  ConsistencySummaryStatistics summary=mock(ConsistencySummaryStatistics.class);
  RecordAccess records=mock(RecordAccess.class);
  final AtomicReference<String> loggedError=new AtomicReference<>();
  InconsistencyLogger logger=new InconsistencyLogger(){
    @Override public void error(    RecordType recordType,    AbstractBaseRecord record,    String message,    Object[] args){
      assertTrue(loggedError.compareAndSet(null,message));
    }
    @Override public void error(    RecordType recordType,    AbstractBaseRecord oldRecord,    AbstractBaseRecord newRecord,    String message,    Object[] args){
      assertTrue(loggedError.compareAndSet(null,message));
    }
    @Override public void warning(    RecordType recordType,    AbstractBaseRecord record,    String message,    Object[] args){
    }
    @Override public void warning(    RecordType recordType,    AbstractBaseRecord oldRecord,    AbstractBaseRecord newRecord,    String message,    Object[] args){
    }
  }
;
  InconsistencyReport inconsistencyReport=new InconsistencyReport(logger,summary);
  ConsistencyReporter reporter=new ConsistencyReporter(records,inconsistencyReport);
  NodeRecord node=new NodeRecord(10);
  RecordCheck<NodeRecord,NodeConsistencyReport> checker=mock(RecordCheck.class);
  RuntimeException exception=new RuntimeException("My specific exception");
  doThrow(exception).when(checker).check(any(NodeRecord.class),any(CheckerEngine.class),any(RecordAccess.class));
  reporter.forNode(node,checker);
  assertNotNull(loggedError.get());
  String error=loggedError.get();
  assertThat(error,containsString("at "));
  assertThat(error,containsString(testName.getMethodName()));
}
