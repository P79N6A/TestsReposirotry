@Test public void shouldDetectCorrectDuplicateInputIdsWhereManyAccidentalInManyGroups(){
  final ControlledEncoder encoder=new ControlledEncoder(new LongEncoder());
  final int idsPerGroup=20;
  int groupCount=5;
  for (int i=0; i < groupCount; i++) {
    groups.getOrCreate("Group " + i);
  }
  IdMapper mapper=mapper(encoder,Radix.LONG,NO_MONITOR,ParallelSort.DEFAULT,numberOfCollisions -> new LongCollisionValues(NumberArrayFactory.HEAP,numberOfCollisions));
  final AtomicReference<Group> group=new AtomicReference<>();
  LongFunction<Object> ids=nodeId -> {
    int groupId=toIntExact(nodeId / idsPerGroup);
    if (groupId == groupCount) {
      return null;
    }
    group.set(groups.get(groupId));
    if (nodeId % idsPerGroup < 2) {
      encoder.useThisIdToEncodeNoMatterWhatComesIn(Long.valueOf(1234567));
      return Long.valueOf(nodeId % idsPerGroup);
    }
    encoder.useThisIdToEncodeNoMatterWhatComesIn(Long.valueOf(123456 - group.get().id()));
    return Long.valueOf(nodeId);
  }
;
  int count=idsPerGroup * groupCount;
  for (long nodeId=0; nodeId < count; nodeId++) {
    mapper.put(ids.apply(nodeId),nodeId,group.get());
  }
  Collector collector=mock(Collector.class);
  mapper.prepare(ids,collector,NONE);
  verifyNoMoreInteractions(collector);
  for (long nodeId=0; nodeId < count; nodeId++) {
    assertEquals(nodeId,mapper.get(ids.apply(nodeId),group.get()));
  }
  verifyNoMoreInteractions(collector);
  assertFalse(mapper.leftOverDuplicateNodesIds().hasNext());
}
