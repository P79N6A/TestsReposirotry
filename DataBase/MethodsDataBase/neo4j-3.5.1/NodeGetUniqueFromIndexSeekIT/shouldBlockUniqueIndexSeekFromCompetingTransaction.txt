@Test(timeout=10_000) public void shouldBlockUniqueIndexSeekFromCompetingTransaction() throws Exception {
  final DoubleLatch latch=new DoubleLatch();
  final IndexReference index=createUniquenessConstraint(labelId,propertyId1);
  final Value value=Values.of("value");
  Write write=dataWriteInNewTransaction();
  long nodeId=write.nodeCreate();
  write.nodeAddLabel(nodeId,labelId);
  write.nodeSetProperty(nodeId,propertyId1,value);
  Runnable runnableForThread2=() -> {
    latch.waitForAllToStart();
    try (Transaction tx=kernel.beginTransaction(Transaction.Type.implicit,LoginContext.AUTH_DISABLED)){
      tx.dataRead().lockingNodeUniqueIndexSeek(index,exact(propertyId1,value));
      tx.success();
    }
 catch (    KernelException e) {
      throw new RuntimeException(e);
    }
 finally {
      latch.finish();
    }
  }
;
  Thread thread2=new Thread(runnableForThread2,"Transaction Thread 2");
  thread2.start();
  latch.startAndWaitForAllToStart();
  while ((thread2.getState() != Thread.State.TIMED_WAITING) && (thread2.getState() != Thread.State.WAITING)) {
    Thread.yield();
  }
  commit();
  latch.waitForAllToFinish();
}
