@Test public void shouldHaveAllConcurrentAppendersSeePanic() throws Throwable {
  Adversary adversary=new ClassGuardedAdversary(new CountingAdversary(1,true),failMethod(BatchingTransactionAppender.class,"force"));
  EphemeralFileSystemAbstraction efs=new EphemeralFileSystemAbstraction();
  FileSystemAbstraction fs=new AdversarialFileSystemAbstraction(adversary,efs);
  life.add(new FileSystemLifecycleAdapter(fs));
  DatabaseHealth databaseHealth=new DatabaseHealth(mock(DatabasePanicEventGenerator.class),NullLog.getInstance());
  LogFiles logFiles=LogFilesBuilder.builder(testDirectory.databaseLayout(),fs).withLogVersionRepository(logVersionRepository).withTransactionIdStore(transactionIdStore).build();
  life.add(logFiles);
  final BatchingTransactionAppender appender=life.add(new BatchingTransactionAppender(logFiles,logRotation,transactionMetadataCache,transactionIdStore,explicitIndexTransactionOrdering,databaseHealth));
  life.start();
  int numberOfAppenders=10;
  final CountDownLatch trap=new CountDownLatch(numberOfAppenders);
  final LogAppendEvent beforeForceTrappingEvent=new LogAppendEvent.Empty(){
    @Override public LogForceWaitEvent beginLogForceWait(){
      trap.countDown();
      awaitLatch(trap);
      return super.beginLogForceWait();
    }
  }
;
  Race race=new Race();
  for (int i=0; i < numberOfAppenders; i++) {
    race.addContestant(() -> {
      try {
        appender.append(tx(),beforeForceTrappingEvent);
        fail("No transaction should be considered appended");
      }
 catch (      IOException e) {
      }
    }
);
  }
  race.go();
}
