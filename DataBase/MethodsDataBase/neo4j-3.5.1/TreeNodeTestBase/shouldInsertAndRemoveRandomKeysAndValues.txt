@Test void shouldInsertAndRemoveRandomKeysAndValues(){
  node.initializeLeaf(cursor,STABLE_GENERATION,UNSTABLE_GENERATION);
  List<KEY> expectedKeys=new ArrayList<>();
  List<VALUE> expectedValues=new ArrayList<>();
  int expectedKeyCount=0;
  KEY readKey=layout.newKey();
  VALUE readValue=layout.newValue();
  for (int i=0; i < 1000; i++) {
    if (random.nextFloat() < 0.7) {
      KEY newKey;
      do {
        newKey=key(random.nextLong());
      }
 while (contains(expectedKeys,newKey,layout));
      VALUE newValue=value(random.nextLong());
      Overflow overflow=node.leafOverflow(cursor,expectedKeyCount,newKey,newValue);
      if (overflow == NO_NEED_DEFRAG) {
        node.defragmentLeaf(cursor);
      }
      if (overflow != YES) {
        int position=expectedKeyCount == 0 ? 0 : random.nextInt(expectedKeyCount);
        node.insertKeyValueAt(cursor,newKey,newValue,position,expectedKeyCount);
        expectedKeys.add(position,newKey);
        expectedValues.add(position,newValue);
        TreeNode.setKeyCount(cursor,++expectedKeyCount);
      }
    }
 else {
      if (expectedKeyCount > 0) {
        int position=random.nextInt(expectedKeyCount);
        node.keyAt(cursor,readKey,position,LEAF);
        node.valueAt(cursor,readValue,position);
        node.removeKeyValueAt(cursor,position,expectedKeyCount);
        KEY expectedKey=expectedKeys.remove(position);
        VALUE expectedValue=expectedValues.remove(position);
        assertEquals(0,layout.compare(expectedKey,readKey),String.format("Key differ with expected%n    readKey=%s %nexpectedKey=%s%n",readKey,expectedKey));
        assertEquals(0,layout.compareValue(expectedValue,readValue),"Value differ with expected, value=" + readValue + ", expectedValue="+ expectedValue);
        TreeNode.setKeyCount(cursor,--expectedKeyCount);
      }
    }
  }
  assertContent(expectedKeys,expectedValues,expectedKeyCount);
}
