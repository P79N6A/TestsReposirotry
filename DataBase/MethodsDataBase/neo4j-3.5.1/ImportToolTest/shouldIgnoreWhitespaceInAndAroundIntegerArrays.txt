@Test public void shouldIgnoreWhitespaceInAndAroundIntegerArrays() throws Exception {
  String[] values=new String[]{"   17","21","99   ","  34  ","-34","        -12","-92 "};
  File data=writeArrayCsv(new String[]{"s:short[]","b:byte[]","i:int[]","l:long[]","f:float[]","d:double[]"},values);
  importTool("--into",dbRule.getDatabaseDirAbsolutePath(),"--quote","'","--nodes",data.getAbsolutePath());
  String iExpected=joinStringArray(values);
  String fExpected=Arrays.stream(values).map(String::trim).map(Double::valueOf).map(String::valueOf).collect(joining(", ","[","]"));
  int nodeCount=0;
  try (Transaction tx=dbRule.beginTx()){
    for (    Node node : dbRule.getAllNodes()) {
      nodeCount++;
      assertEquals(6,node.getAllProperties().size());
      for (      String key : node.getPropertyKeys()) {
        Object things=node.getProperty(key);
        String result="";
        String expected=iExpected;
switch (key) {
case "s":
          result=Arrays.toString((short[])things);
        break;
case "b":
      result=Arrays.toString((byte[])things);
    break;
case "i":
  result=Arrays.toString((int[])things);
break;
case "l":
result=Arrays.toString((long[])things);
break;
case "f":
result=Arrays.toString((float[])things);
expected=fExpected;
break;
case "d":
result=Arrays.toString((double[])things);
expected=fExpected;
break;
default :
break;
}
assertEquals(expected,result);
}
}
tx.success();
}
 assertEquals(1,nodeCount);
}
