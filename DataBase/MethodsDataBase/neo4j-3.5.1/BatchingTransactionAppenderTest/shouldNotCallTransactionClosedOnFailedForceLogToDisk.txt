@Test public void shouldNotCallTransactionClosedOnFailedForceLogToDisk() throws Exception {
  long txId=3;
  String failureMessage="Forces a failure";
  FlushablePositionAwareChannel channel=spy(new InMemoryClosableChannel());
  IOException failure=new IOException(failureMessage);
  final Flushable flushable=mock(Flushable.class);
  doAnswer(invocation -> {
    invocation.callRealMethod();
    return flushable;
  }
).when(channel).prepareForFlush();
  doThrow(failure).when(flushable).flush();
  when(logFile.getWriter()).thenReturn(channel);
  TransactionMetadataCache metadataCache=new TransactionMetadataCache();
  TransactionIdStore transactionIdStore=mock(TransactionIdStore.class);
  when(transactionIdStore.nextCommittingTransactionId()).thenReturn(txId);
  Mockito.reset(databaseHealth);
  TransactionAppender appender=life.add(new BatchingTransactionAppender(logFiles,NO_ROTATION,metadataCache,transactionIdStore,BYPASS,databaseHealth));
  TransactionRepresentation transaction=mock(TransactionRepresentation.class);
  when(transaction.additionalHeader()).thenReturn(new byte[0]);
  try {
    appender.append(new TransactionToApply(transaction),logAppendEvent);
    fail("Expected append to fail. Something is wrong with the test itself");
  }
 catch (  IOException e) {
    assertSame(failure,e);
    verify(transactionIdStore,times(1)).nextCommittingTransactionId();
    verify(transactionIdStore,never()).transactionClosed(eq(txId),anyLong(),anyLong());
    verify(databaseHealth).panic(failure);
  }
}
