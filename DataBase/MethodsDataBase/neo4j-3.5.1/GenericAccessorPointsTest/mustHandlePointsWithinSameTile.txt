/** 
 * This test verify that we correctly handle unique points that all belong to the same tile on the space filling curve. All points share at least one dimension coordinate with another point to exercise minimal splitter. We verify this by asserting that we always get exactly one hit on an exact match and that the value is what we expect.
 */
@Test public void mustHandlePointsWithinSameTile() throws IndexEntryConflictException, IndexNotApplicableKernelException {
  int nbrOfValues=10000;
  PointValue origin=Values.pointValue(WGS84,0.0,0.0);
  Long derivedValueForCenterPoint=curve.derivedValueFor(origin.coordinate());
  double[] centerPoint=curve.centerPointFor(derivedValueForCenterPoint);
  double xWidthMultiplier=curve.getTileWidth(0,curve.getMaxLevel()) / 2;
  double yWidthMultiplier=curve.getTileWidth(1,curve.getMaxLevel()) / 2;
  List<Value> pointValues=new ArrayList<>();
  List<IndexEntryUpdate<?>> updates=new ArrayList<>();
  long nodeId=1;
  for (int i=0; i < nbrOfValues / 4; i++) {
    double x1=(random.nextDouble() * 2 - 1) * xWidthMultiplier;
    double x2=(random.nextDouble() * 2 - 1) * xWidthMultiplier;
    double y1=(random.nextDouble() * 2 - 1) * yWidthMultiplier;
    double y2=(random.nextDouble() * 2 - 1) * yWidthMultiplier;
    PointValue value11=Values.pointValue(WGS84,centerPoint[0] + x1,centerPoint[1] + y1);
    PointValue value12=Values.pointValue(WGS84,centerPoint[0] + x1,centerPoint[1] + y2);
    PointValue value21=Values.pointValue(WGS84,centerPoint[0] + x2,centerPoint[1] + y1);
    PointValue value22=Values.pointValue(WGS84,centerPoint[0] + x2,centerPoint[1] + y2);
    assertDerivedValue(derivedValueForCenterPoint,value11,value12,value21,value22);
    nodeId=addPointsToLists(pointValues,updates,nodeId,value11,value12,value21,value22);
  }
  processAll(updates);
  exactMatchOnAllValues(pointValues);
}
