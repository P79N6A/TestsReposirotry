/** 
 * This test verify that we correctly handle unique point arrays where every point in every array belong to the same tile on the space filling curve. We verify this by asserting that we always get exactly one hit on an exact match and that the value is what we expect.
 */
@Test public void mustHandlePointArraysWithinSameTile() throws IndexEntryConflictException, IndexNotApplicableKernelException {
  int nbrOfValues=10000;
  PointValue origin=Values.pointValue(WGS84,0.0,0.0);
  Long derivedValueForCenterPoint=curve.derivedValueFor(origin.coordinate());
  double[] centerPoint=curve.centerPointFor(derivedValueForCenterPoint);
  double xWidthMultiplier=curve.getTileWidth(0,curve.getMaxLevel()) / 2;
  double yWidthMultiplier=curve.getTileWidth(1,curve.getMaxLevel()) / 2;
  List<Value> pointArrays=new ArrayList<>();
  List<IndexEntryUpdate<?>> updates=new ArrayList<>();
  for (int i=0; i < nbrOfValues; i++) {
    int arrayLength=random.nextInt(5) + 1;
    PointValue[] pointValues=new PointValue[arrayLength];
    for (int j=0; j < arrayLength; j++) {
      double x=(random.nextDouble() * 2 - 1) * xWidthMultiplier;
      double y=(random.nextDouble() * 2 - 1) * yWidthMultiplier;
      PointValue value=Values.pointValue(WGS84,centerPoint[0] + x,centerPoint[1] + y);
      assertDerivedValue(derivedValueForCenterPoint,value);
      pointValues[j]=value;
    }
    PointArray array=Values.pointArray(pointValues);
    pointArrays.add(array);
    updates.add(IndexEntryUpdate.add(i,descriptor,array));
  }
  processAll(updates);
  exactMatchOnAllValues(pointArrays);
}
