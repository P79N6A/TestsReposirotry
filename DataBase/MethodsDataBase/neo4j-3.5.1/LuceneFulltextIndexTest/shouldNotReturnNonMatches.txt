@Test public void shouldNotReturnNonMatches() throws Exception {
  SchemaDescriptor nodes=fulltextAdapter.schemaFor(NODE,new String[]{LABEL.name()},settings,PROP);
  SchemaDescriptor rels=fulltextAdapter.schemaFor(RELATIONSHIP,new String[]{RELTYPE.name()},settings,PROP);
  IndexReference nodesIndex;
  IndexReference relsIndex;
  try (KernelTransactionImplementation tx=getKernelTransaction()){
    nodesIndex=tx.schemaWrite().indexCreate(nodes,FulltextIndexProviderFactory.DESCRIPTOR.name(),Optional.of(NODE_INDEX_NAME));
    relsIndex=tx.schemaWrite().indexCreate(rels,FulltextIndexProviderFactory.DESCRIPTOR.name(),Optional.of(REL_INDEX_NAME));
    tx.success();
  }
   await(nodesIndex);
  await(relsIndex);
  try (Transaction tx=db.beginTx()){
    long firstNode=createNodeIndexableByPropertyValue(LABEL,"Hello. Hello again.");
    long secondNode=createNodeWithProperty(LABEL,"prop2","A zebroid (also zedonk, zorse, zebra mule, zonkey, and zebmule) is the offspring of any " + "cross between a zebra and any other equine: essentially, a zebra hybrid.");
    createRelationshipIndexableByPropertyValue(firstNode,secondNode,"Hello. Hello again.");
    createRelationshipWithProperty(secondNode,firstNode,"prop2","A zebroid (also zedonk, zorse, zebra mule, zonkey, and zebmule) is the offspring of any " + "cross between a zebra and any other equine: essentially, a zebra hybrid.");
    tx.success();
  }
   try (Transaction tx=db.beginTx()){
    KernelTransaction ktx=kernelTransaction(tx);
    assertQueryFindsNothing(ktx,NODE_INDEX_NAME,"zebra");
    assertQueryFindsNothing(ktx,REL_INDEX_NAME,"zebra");
  }
 }
