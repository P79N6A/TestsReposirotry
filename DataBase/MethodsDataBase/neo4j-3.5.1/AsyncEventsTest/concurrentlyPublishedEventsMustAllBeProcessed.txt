@Test void concurrentlyPublishedEventsMustAllBeProcessed(){
  assertTimeout(ofSeconds(10),() -> {
    EventConsumer consumer=new EventConsumer();
    final CountDownLatch startLatch=new CountDownLatch(1);
    final int threads=10;
    final int iterations=2_000;
    final AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
    executor.submit(asyncEvents);
    ExecutorService threadPool=Executors.newFixedThreadPool(threads);
    Runnable runner=() -> {
      try {
        startLatch.await();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
      for (int i=0; i < iterations; i++) {
        asyncEvents.send(new Event());
      }
    }
;
    for (int i=0; i < threads; i++) {
      threadPool.submit(runner);
    }
    startLatch.countDown();
    Thread thisThread=Thread.currentThread();
    int eventCount=threads * iterations;
    try {
      for (int i=0; i < eventCount; i++) {
        Event event=consumer.poll(1,TimeUnit.SECONDS);
        if (event == null) {
          i--;
        }
 else {
          assertThat(event.processedBy,is(not(thisThread)));
        }
      }
    }
  finally {
      asyncEvents.shutdown();
    }
  }
);
}
