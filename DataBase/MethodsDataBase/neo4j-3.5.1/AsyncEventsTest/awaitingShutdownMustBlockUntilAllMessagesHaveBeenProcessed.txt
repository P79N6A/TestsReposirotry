@Test void awaitingShutdownMustBlockUntilAllMessagesHaveBeenProcessed() throws Exception {
  final Event specialShutdownObservedEvent=new Event();
  final CountDownLatch awaitStartLatch=new CountDownLatch(1);
  final EventConsumer consumer=new EventConsumer();
  final AsyncEvents<Event> asyncEvents=new AsyncEvents<>(consumer,AsyncEvents.Monitor.NONE);
  executor.submit(asyncEvents);
  do {
    asyncEvents.send(new Event());
  }
 while (consumer.eventsProcessed.take().processedBy == Thread.currentThread());
  Future<?> awaitShutdownFuture=executor.submit(() -> {
    awaitStartLatch.countDown();
    asyncEvents.awaitTermination();
    consumer.eventsProcessed.offer(specialShutdownObservedEvent);
  }
);
  awaitStartLatch.await();
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  asyncEvents.send(new Event());
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.take(),is(notNullValue()));
  assertThat(consumer.eventsProcessed.poll(20,TimeUnit.MILLISECONDS),is(nullValue()));
  asyncEvents.shutdown();
  awaitShutdownFuture.get();
  assertThat(consumer.eventsProcessed.take(),sameInstance(specialShutdownObservedEvent));
}
