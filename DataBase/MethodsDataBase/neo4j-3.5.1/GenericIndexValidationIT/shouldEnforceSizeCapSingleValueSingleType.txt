/** 
 * Key size validation test for single type. Validate that we handle index reads and writes correctly for dynamically sized values (arrays and strings) of all different types with length close to and over the max limit for given type. We do this by inserting arrays of increasing size (doubling each iteration) and when we hit the upper limit we do binary search between the established min and max limit. We also verify that the largest successful array length for each type is as expected because this value is documented and if it changes, documentation also needs to change.
 */
@Test public void shouldEnforceSizeCapSingleValueSingleType(){
  NamedDynamicValueGenerator[] dynamicValueGenerators=NamedDynamicValueGenerator.values();
  for (  NamedDynamicValueGenerator generator : dynamicValueGenerators) {
    String propKey=PROP_KEYS[0] + generator.name();
    createIndex(propKey);
    BinarySearch binarySearch=new BinarySearch();
    Object propValue;
    while (!binarySearch.finished()) {
      propValue=generator.dynamicValue(binarySearch.arrayLength);
      long expectedNodeId=-1;
      boolean wasAbleToWrite=true;
      try (Transaction tx=db.beginTx()){
        Node node=db.createNode(LABEL_ONE);
        node.setProperty(propKey,propValue);
        expectedNodeId=node.getId();
        tx.success();
      }
 catch (      Exception e) {
        wasAbleToWrite=false;
      }
      verifyReadExpected(propKey,propValue,expectedNodeId,wasAbleToWrite);
      binarySearch.progress(wasAbleToWrite);
    }
    assertEquals(format("expected longest successful array length for type %s, to be %d but was %d. " + "This is a strong indication that documentation of max limit needs to be updated.",generator.name(),generator.expectedMax,binarySearch.longestSuccessful),generator.expectedMax,binarySearch.longestSuccessful);
  }
}
