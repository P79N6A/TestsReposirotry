/** 
 * Key size validation test for mixed types in composite index. Validate that we handle index reads and writes correctly for dynamically sized values (arrays and strings) of all different types with length close to and over the max limit for given type. We do this by trying to insert random dynamically sized values with size in range that covers the limit, taking into account the number of slots in the index. Then we verify that we either - write successfully and are able to read value back - fail to write and no result is found during read Even though we don't keep track of all inserted values, the probability that we will ever generate two identical values is, for single property boolean array which is the most likely, (1/2)^3995. As a reference (1/2)^100 = 7.8886091e-31.
 */
@Test public void shouldEnforceSizeCapMixedTypes(){
  for (int numberOfSlots=1; numberOfSlots < 5; numberOfSlots++) {
    String[] propKeys=generatePropertyKeys(numberOfSlots);
    createIndex(propKeys);
    int keySizeLimitPerSlot=KEY_SIZE_LIMIT / propKeys.length - ESTIMATED_OVERHEAD_PER_SLOT;
    int wiggleRoomPerSlot=WIGGLE_ROOM / propKeys.length;
    SuccessAndFail successAndFail=new SuccessAndFail();
    for (int i=0; i < 1_000; i++) {
      Object[] propValues=generatePropertyValues(propKeys,keySizeLimitPerSlot,wiggleRoomPerSlot);
      long expectedNodeId=-1;
      boolean ableToWrite=true;
      try (Transaction tx=db.beginTx()){
        Node node=db.createNode(LABEL_ONE);
        setProperties(propKeys,propValues,node);
        expectedNodeId=node.getId();
        tx.success();
      }
 catch (      Exception e) {
        ableToWrite=false;
      }
      successAndFail.ableToWrite(ableToWrite);
      verifyReadExpected(propKeys,propValues,expectedNodeId,ableToWrite);
    }
    successAndFail.verifyBothSuccessAndFail();
  }
}
