/** 
 * All entries in composite index look like (booleanValue, randomValue ). Range queries in composite only work if all predicates before it is exact. We use boolean values for exact part so that we get some real ranges to work on in second composite slot where the random values are.
 */
@Test public void testRangeMatchOnRandomValues() throws Exception {
  Assume.assumeTrue("Assume support for granular composite queries",testSuite.supportsGranularCompositeQueries());
  ValueType[] types=randomSetOfSupportedAndSortableTypes();
  List<ValueTuple> values=generateValuesFromType(types);
  List<IndexEntryUpdate<?>> updates=generateUpdatesFromValues(values);
  updateAndCommit(updates);
  TreeSet<IndexEntryUpdate> sortedValues=new TreeSet<>((u1,u2) -> ValueTuple.COMPARATOR.compare(ValueTuple.of(u1.values()[0],u1.values()[1]),ValueTuple.of(u2.values()[0],u2.values()[1])));
  sortedValues.addAll(updates);
  for (int i=0; i < 100; i++) {
    Value booleanValue=random.randomValues().nextBooleanValue();
    ValueType type=random.among(types);
    Value from=random.randomValues().nextValueOfType(type);
    Value to=random.randomValues().nextValueOfType(type);
    if (Values.COMPARATOR.compare(from,to) > 0) {
      Value tmp=from;
      from=to;
      to=tmp;
    }
    boolean fromInclusive=random.nextBoolean();
    boolean toInclusive=random.nextBoolean();
    List<Long> expectedIds=expectedIds(sortedValues,booleanValue,from,to,fromInclusive,toInclusive);
    IndexQuery[] predicates=new IndexQuery[]{IndexQuery.exact(100,booleanValue),IndexQuery.range(101,from,fromInclusive,to,toInclusive)};
    ValueCategory[] valueCategories=getValueCategories(predicates);
    IndexOrder[] indexOrders=indexProvider.getCapability(descriptor).orderCapability(valueCategories);
    for (    IndexOrder order : indexOrders) {
      List<Long> actualIds=assertInOrder(order,predicates);
      actualIds.sort(Long::compare);
      assertThat(actualIds,equalTo(expectedIds));
    }
  }
}
