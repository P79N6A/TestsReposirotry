@Test public void checkpointMustRecognizeFailedCleaning() throws Exception {
  makeDirty();
  RuntimeException cleanupException=new RuntimeException("Fail cleaning job");
  CleanJobControlledMonitor cleanupMonitor=new CleanJobControlledMonitor(){
    @Override public void cleanupFinished(    long numberOfPagesVisited,    long numberOfCleanedCrashPointers,    long durationMillis){
      super.cleanupFinished(numberOfPagesVisited,numberOfCleanedCrashPointers,durationMillis);
      throw cleanupException;
    }
  }
;
  ControlledRecoveryCleanupWorkCollector collector=new ControlledRecoveryCleanupWorkCollector();
  try (GBPTree<MutableLong,MutableLong> index=index().with(cleanupMonitor).with(collector).build()){
    index.writer().close();
    Future<?> cleanup=executor.submit(throwing(collector::start));
    shouldWait(cleanup);
    Future<?> checkpoint=executor.submit(throwing(() -> index.checkpoint(UNLIMITED)));
    shouldWait(checkpoint);
    cleanupMonitor.barrier.release();
    cleanup.get();
    try {
      checkpoint.get();
      fail("Expected checkpoint to fail because of failed cleaning job");
    }
 catch (    ExecutionException e) {
      assertThat(e.getMessage(),allOf(containsString("cleaning"),containsString("failed")));
    }
  }
 }
