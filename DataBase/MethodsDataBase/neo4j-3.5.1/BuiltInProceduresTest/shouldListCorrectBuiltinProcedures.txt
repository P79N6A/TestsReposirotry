@Test public void shouldListCorrectBuiltinProcedures() throws Throwable {
  assertThat(call("dbms.procedures"),containsInAnyOrder(record("dbms.listConfig","dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?)","List the currently active config of Neo4j.","DBMS"),record("db.awaitIndex","db.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID","Wait for an index to come online (for example: CALL db.awaitIndex(\":Person(name)\")).","READ"),record("db.awaitIndexes","db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID","Wait for all indexes to come online (for example: CALL db.awaitIndexes(\"500\")).","READ"),record("db.constraints","db.constraints() :: (description :: STRING?)","List all constraints in the database.","READ"),record("db.indexes","db.indexes() :: (description :: STRING?, indexName :: STRING?, " + "tokenNames :: LIST? OF STRING?, properties :: LIST? OF STRING?, state :: STRING?, " + "type :: STRING?, progress :: FLOAT?, provider :: MAP?, id :: INTEGER?, failureMessage :: STRING?)","List all indexes in the database.","READ"),record("db.labels","db.labels() :: (label :: STRING?)","List all labels in the database.","READ"),record("db.propertyKeys","db.propertyKeys() :: (propertyKey :: STRING?)","List all property keys in the database.","READ"),record("db.relationshipTypes","db.relationshipTypes() :: (relationshipType :: STRING?)","List all relationship types in the database.","READ"),record("db.resampleIndex","db.resampleIndex(index :: STRING?) :: VOID","Schedule resampling of an index (for example: CALL db.resampleIndex(\":Person(name)\")).","READ"),record("db.resampleOutdatedIndexes","db.resampleOutdatedIndexes() :: VOID","Schedule resampling of all outdated indexes.","READ"),record("db.schema","db.schema() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","Show the schema of the data.","READ"),record("db.schema.visualization","db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","Visualize the schema of the data. Replaces db.schema.","READ"),record("db.schema.nodeTypeProperties","db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, " + "propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)","Show the derived property schema of the nodes in tabular form.","READ"),record("db.schema.relTypeProperties","db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?," + " mandatory :: BOOLEAN?)","Show the derived property schema of the relationships in tabular form.","READ"),record("db.index.explicit.searchNodes","db.index.explicit.searchNodes(indexName :: STRING?, query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)","Search nodes in explicit index. Replaces `START n=node:nodes('key:foo*')`","READ"),record("db.index.explicit.seekNodes","db.index.explicit.seekNodes(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (node :: NODE?)","Get node from explicit index. Replaces `START n=node:nodes(key = 'A')`","READ"),record("db.index.explicit.searchRelationships","db.index.explicit.searchRelationships(indexName :: STRING?, query :: ANY?) :: " + "(relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index. Replaces `START r=relationship:relIndex('key:foo*')`","READ"),record("db.index.explicit.searchRelationshipsIn","db.index.explicit.searchRelationshipsIn(indexName :: STRING?, in :: NODE?, query :: ANY?) :: " + "(relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, starting at the node 'in'.","READ"),record("db.index.explicit.searchRelationshipsOut","db.index.explicit.searchRelationshipsOut(indexName :: STRING?, out :: NODE?, query :: ANY?) :: " + "(relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, ending at the node 'out'.","READ"),record("db.index.explicit.searchRelationshipsBetween","db.index.explicit.searchRelationshipsBetween(indexName :: STRING?, in :: NODE?, out :: NODE?, query :: ANY?) :: " + "(relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, starting at the node 'in' and ending at 'out'.","READ"),record("db.index.explicit.seekRelationships","db.index.explicit.seekRelationships(indexName :: STRING?, key :: STRING?, value :: ANY?) :: " + "(relationship :: RELATIONSHIP?)","Get relationship from explicit index. Replaces `START r=relationship:relIndex(key = 'A')`","READ"),record("db.index.explicit.auto.searchNodes","db.index.explicit.auto.searchNodes(query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)","Search nodes in explicit automatic index. Replaces `START n=node:node_auto_index('key:foo*')`","READ"),record("db.index.explicit.auto.seekNodes","db.index.explicit.auto.seekNodes(key :: STRING?, value :: ANY?) :: (node :: NODE?)","Get node from explicit automatic index. Replaces `START n=node:node_auto_index(key = 'A')`","READ"),record("db.index.explicit.auto.searchRelationships","db.index.explicit.auto.searchRelationships(query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit automatic index. Replaces `START r=relationship:relationship_auto_index('key:foo*')`","READ"),record("db.index.explicit.auto.seekRelationships","db.index.explicit.auto.seekRelationships(key :: STRING?, value :: ANY?) :: " + "(relationship :: RELATIONSHIP?)","Get relationship from explicit automatic index. Replaces `START r=relationship:relationship_auto_index(key = 'A')`","READ"),record("db.index.explicit.addNode","db.index.explicit.addNode(indexName :: STRING?, node :: NODE?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)","Add a node to an explicit index based on a specified key and value","WRITE"),record("db.index.explicit.addRelationship","db.index.explicit.addRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key :: STRING?, value :: ANY?) :: " + "(success :: BOOLEAN?)","Add a relationship to an explicit index based on a specified key and value","WRITE"),record("db.index.explicit.removeNode","db.index.explicit.removeNode(indexName :: STRING?, node :: NODE?, " + "key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)","Remove a node from an explicit index with an optional key","WRITE"),record("db.index.explicit.removeRelationship","db.index.explicit.removeRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, " + "key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: " + "(success :: BOOLEAN?)","Remove a relationship from an explicit index with an optional key","WRITE"),record("db.index.explicit.drop","db.index.explicit.drop(indexName :: STRING?) :: " + "(type :: STRING?, name :: STRING?, config :: MAP?)","Remove an explicit index - YIELD type,name,config","WRITE"),record("db.index.explicit.forNodes","db.index.explicit.forNodes(indexName :: STRING?, config = {} :: MAP?) :: " + "(type :: STRING?, name :: STRING?, config :: MAP?)","Get or create a node explicit index - YIELD type,name,config","WRITE"),record("db.index.explicit.forRelationships","db.index.explicit.forRelationships(indexName :: STRING?, config = {} :: MAP?) :: " + "(type :: STRING?, name :: STRING?, config :: MAP?)","Get or create a relationship explicit index - YIELD type,name,config","WRITE"),record("db.index.explicit.existsForNodes","db.index.explicit.existsForNodes(indexName :: STRING?) :: (success :: BOOLEAN?)","Check if a node explicit index exists","READ"),record("db.index.explicit.existsForRelationships","db.index.explicit.existsForRelationships(indexName :: STRING?) :: (success :: BOOLEAN?)","Check if a relationship explicit index exists","READ"),record("db.index.explicit.list","db.index.explicit.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)","List all explicit indexes - YIELD type,name,config","READ"),record("dbms.components","dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)","List DBMS components and their versions.","DBMS"),record("dbms.procedures","dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, mode :: STRING?)","List all procedures in the DBMS.","DBMS"),record("dbms.functions","dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?)","List all user functions in the DBMS.","DBMS"),record("dbms.queryJmx","dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: " + "MAP?)","Query JMX management data by domain and name. For instance, \"org.neo4j:*\"","DBMS"),record("dbms.clearQueryCaches","dbms.clearQueryCaches() :: (value :: STRING?)","Clears all query caches.","DBMS"),record("db.createIndex","db.createIndex(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?)","Create a schema index with specified index provider (for example: CALL db.createIndex(\":Person(name)\", \"lucene+native-2.0\")) - " + "YIELD index, providerName, status","SCHEMA"),record("db.createUniquePropertyConstraint","db.createUniquePropertyConstraint(index :: STRING?, providerName :: STRING?) :: " + "(index :: STRING?, providerName :: STRING?, status :: STRING?)","Create a unique property constraint with index backed by specified index provider " + "(for example: CALL db.createUniquePropertyConstraint(\":Person(name)\", \"lucene+native-2.0\")) - " + "YIELD index, providerName, status","SCHEMA")));
}
