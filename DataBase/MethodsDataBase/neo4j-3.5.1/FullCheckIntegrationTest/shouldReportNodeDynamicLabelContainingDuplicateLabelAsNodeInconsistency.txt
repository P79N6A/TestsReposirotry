@Test public void shouldReportNodeDynamicLabelContainingDuplicateLabelAsNodeInconsistency() throws Exception {
  int nodeId=1000;
  Collection<DynamicRecord> duplicatedLabel=new ArrayList<>();
  final Pair<List<DynamicRecord>,List<Integer>> labels=chainOfDynamicRecordsWithLabelsForANode(1);
  fixture.apply(new GraphStoreFixture.Transaction(){
    @Override protected void transactionData(    GraphStoreFixture.TransactionDataBuilder tx,    GraphStoreFixture.IdGenerator next){
      NodeRecord node=new NodeRecord(nodeId,false,-1,-1);
      node.setInUse(true);
      List<DynamicRecord> labelRecords=labels.first();
      node.setLabelField(dynamicPointer(labelRecords),labelRecords);
      tx.create(node);
      Integer labelId=labels.other().get(0);
      DynamicRecord record=inUse(new DynamicRecord(labelId));
      allocateFromNumbers(duplicatedLabel,new long[]{nodeId,labelId,labelId},new ReusableRecordsAllocator(60,record));
    }
  }
);
  StoreAccess storeAccess=fixture.directStoreAccess().nativeStores();
  NodeRecord nodeRecord=new NodeRecord(nodeId);
  storeAccess.getNodeStore().getRecord(nodeId,nodeRecord,FORCE);
  nodeRecord.setLabelField(dynamicPointer(duplicatedLabel),duplicatedLabel);
  nodeRecord.setInUse(true);
  storeAccess.getNodeStore().updateRecord(nodeRecord);
  ConsistencySummaryStatistics stats=check();
  on(stats).verify(RecordType.NODE,1).verify(RecordType.COUNTS,0).andThatsAllFolks();
}
