@Test public void recoverNotAFirstCorruptedTransactionMultipleFilesNoCheckpoints() throws IOException {
  GraphDatabaseAPI database=(GraphDatabaseAPI)databaseFactory.newEmbeddedDatabase(storeDir);
  TransactionIdStore transactionIdStore=getTransactionIdStore(database);
  long lastClosedTransactionBeforeStart=transactionIdStore.getLastClosedTransactionId();
  generateTransactionsAndRotate(database,3);
  for (int i=0; i < 7; i++) {
    generateTransaction(database);
  }
  long numberOfTransactions=transactionIdStore.getLastClosedTransactionId() - lastClosedTransactionBeforeStart;
  database.shutdown();
  LogFiles logFiles=buildDefaultLogFiles();
  File highestLogFile=logFiles.getHighestLogFile();
  long originalFileLength=highestLogFile.length();
  removeLastCheckpointRecordFromLastLogFile();
  addCorruptedCommandsToLastLogFile();
  long modifiedFileLength=highestLogFile.length();
  assertThat(modifiedFileLength,greaterThan(originalFileLength));
  database=startDbNoRecoveryOfCorruptedLogs();
  database.shutdown();
  logProvider.assertContainsMessageContaining("Fail to read transaction log version 3.");
  logProvider.assertContainsMessageContaining("Recovery required from position LogPosition{logVersion=0, byteOffset=16}");
  logProvider.assertContainsMessageContaining("Fail to recover all transactions.");
  logProvider.assertContainsMessageContaining("Any later transaction after LogPosition{logVersion=3, byteOffset=4632} are unreadable and will be truncated.");
  assertEquals(3,logFiles.getHighestLogVersion());
  ObjectLongMap<Class> logEntriesDistribution=getLogEntriesDistribution(logFiles);
  assertEquals(1,logEntriesDistribution.get(CheckPoint.class));
  assertEquals(numberOfTransactions,recoveryMonitor.getNumberOfRecoveredTransactions());
  assertEquals(originalFileLength,highestLogFile.length());
}
