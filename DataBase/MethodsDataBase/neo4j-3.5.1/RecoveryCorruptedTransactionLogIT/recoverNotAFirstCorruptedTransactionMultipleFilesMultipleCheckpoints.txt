@Test public void recoverNotAFirstCorruptedTransactionMultipleFilesMultipleCheckpoints() throws IOException {
  GraphDatabaseAPI database=(GraphDatabaseAPI)databaseFactory.newEmbeddedDatabase(storeDir);
  long transactionsToRecover=7;
  generateTransactionsAndRotateWithCheckpoint(database,3);
  for (int i=0; i < transactionsToRecover; i++) {
    generateTransaction(database);
  }
  database.shutdown();
  File highestLogFile=logFiles.getHighestLogFile();
  long originalFileLength=highestLogFile.length();
  removeLastCheckpointRecordFromLastLogFile();
  addCorruptedCommandsToLastLogFile();
  long modifiedFileLength=highestLogFile.length();
  assertThat(modifiedFileLength,greaterThan(originalFileLength));
  database=startDbNoRecoveryOfCorruptedLogs();
  database.shutdown();
  logProvider.assertContainsMessageContaining("Fail to read transaction log version 3.");
  logProvider.assertContainsMessageContaining("Recovery required from position LogPosition{logVersion=3, byteOffset=593}");
  logProvider.assertContainsMessageContaining("Fail to recover all transactions.");
  logProvider.assertContainsMessageContaining("Any later transaction after LogPosition{logVersion=3, byteOffset=4650} are unreadable and will be truncated.");
  assertEquals(3,logFiles.getHighestLogVersion());
  ObjectLongMap<Class> logEntriesDistribution=getLogEntriesDistribution(logFiles);
  assertEquals(4,logEntriesDistribution.get(CheckPoint.class));
  assertEquals(transactionsToRecover,recoveryMonitor.getNumberOfRecoveredTransactions());
  assertEquals(originalFileLength,highestLogFile.length());
}
