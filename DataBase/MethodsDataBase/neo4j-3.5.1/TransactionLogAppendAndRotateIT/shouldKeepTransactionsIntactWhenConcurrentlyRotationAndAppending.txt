@Test public void shouldKeepTransactionsIntactWhenConcurrentlyRotationAndAppending() throws Throwable {
  LogVersionRepository logVersionRepository=new SimpleLogVersionRepository();
  LogFiles logFiles=LogFilesBuilder.builder(directory.databaseLayout(),fileSystemRule.get()).withLogVersionRepository(logVersionRepository).withRotationThreshold(ByteUnit.mebiBytes(1)).withTransactionIdStore(new SimpleTransactionIdStore()).build();
  life.add(logFiles);
  final AtomicBoolean end=new AtomicBoolean();
  AllTheMonitoring monitoring=new AllTheMonitoring(end,100);
  TransactionIdStore txIdStore=new SimpleTransactionIdStore();
  TransactionMetadataCache metadataCache=new TransactionMetadataCache();
  monitoring.setLogFile(logFiles.getLogFile());
  DatabaseHealth health=new DatabaseHealth(mock(DatabasePanicEventGenerator.class),NullLog.getInstance());
  LogRotation rotation=new LogRotationImpl(monitoring,logFiles,health);
  final TransactionAppender appender=life.add(new BatchingTransactionAppender(logFiles,rotation,metadataCache,txIdStore,BYPASS,health));
  Race race=new Race();
  for (int i=0; i < 10; i++) {
    race.addContestant(() -> {
      while (!end.get()) {
        try {
          appender.append(new TransactionToApply(sillyTransaction(1_000)),NULL);
        }
 catch (        Exception e) {
          e.printStackTrace(System.out);
          end.set(true);
          fail(e.getMessage());
        }
      }
    }
);
  }
  race.addContestant(endAfterMax(10,SECONDS,end));
  race.go();
  assertTrue(monitoring.numberOfRotations() > 0);
}
