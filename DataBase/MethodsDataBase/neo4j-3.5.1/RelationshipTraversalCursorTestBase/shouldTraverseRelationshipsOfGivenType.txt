@Test public void shouldTraverseRelationshipsOfGivenType(){
  try (NodeCursor node=cursors.allocateNodeCursor();RelationshipGroupCursor group=cursors.allocateRelationshipGroupCursor();RelationshipTraversalCursor relationship=cursors.allocateRelationshipTraversalCursor()){
    int empty=0;
    read.allNodesScan(node);
    while (node.next()) {
      node.relationships(group);
      boolean none=true;
      while (group.next()) {
        none=false;
        Sizes degree=new Sizes();
        group.outgoing(relationship);
        while (relationship.next()) {
          assertEquals("node #" + node.nodeReference() + " relationship should have same label as group",group.type(),relationship.type());
          degree.outgoing++;
        }
        group.incoming(relationship);
        while (relationship.next()) {
          assertEquals("node #" + node.nodeReference() + "relationship should have same label as group",group.type(),relationship.type());
          degree.incoming++;
        }
        group.loops(relationship);
        while (relationship.next()) {
          assertEquals("node #" + node.nodeReference() + "relationship should have same label as group",group.type(),relationship.type());
          degree.loop++;
        }
        assertNotEquals("all",0,degree.incoming + degree.outgoing + degree.loop);
        assertEquals("node #" + node.nodeReference() + " outgoing",group.outgoingCount(),degree.outgoing);
        assertEquals("node #" + node.nodeReference() + " incoming",group.incomingCount(),degree.incoming);
        assertEquals("node #" + node.nodeReference() + " loop",group.loopCount(),degree.loop);
        assertEquals("node #" + node.nodeReference() + " all = incoming + outgoing - loop",group.totalCount(),degree.incoming + degree.outgoing + degree.loop);
      }
      if (none) {
        empty++;
      }
    }
    assertEquals("number of empty nodes",1,empty);
  }
 }
