@Test(timeout=TEST_TIMEOUT) public void timeoutOnAcquiringSharedLock() throws Exception {
  expectedException.expect(new RootCauseMatcher<>(LockAcquisitionTimeoutException.class,"The transaction has been terminated. " + "Retry your operation in a new transaction, and you should see a successful result. " + "Unable to acquire lock within configured timeout (dbms.lock.acquisition.timeout). "+ "Unable to acquire lock for resource: LABEL with id: 1 within 2000 millis."));
  try (Transaction ignored=database.beginTx()){
    Locks lockManger=getLockManager();
    lockManger.newClient().acquireExclusive(LockTracer.NONE,ResourceTypes.LABEL,1);
    Future<Void> propertySetFuture=secondTransactionExecutor.executeDontWait(state -> {
      try (Transaction nestedTransaction=database.beginTx()){
        ResourceIterator<Node> nodes=database.findNodes(marker);
        Node node=nodes.next();
        node.addLabel(Label.label("anotherLabel"));
        nestedTransaction.success();
      }
       return null;
    }
);
    secondTransactionExecutor.waitUntilWaiting(sharedLockWaitingPredicate());
    clockExecutor.execute((OtherThreadExecutor.WorkerCommand<Void,Void>)state -> {
      fakeClock.forward(3,TimeUnit.SECONDS);
      return null;
    }
);
    propertySetFuture.get();
    fail("Should throw termination exception.");
  }
 }
