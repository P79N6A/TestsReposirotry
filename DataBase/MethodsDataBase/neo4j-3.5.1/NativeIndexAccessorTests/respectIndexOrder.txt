@Test public void respectIndexOrder() throws Exception {
  int nUpdates=10000;
  ValueType[] types=supportedTypesExcludingNonOrderable();
  Iterator<IndexEntryUpdate<IndexDescriptor>> randomUpdateGenerator=valueCreatorUtil.randomUpdateGenerator(random,types);
  IndexEntryUpdate<IndexDescriptor>[] someUpdates=new IndexEntryUpdate[nUpdates];
  for (int i=0; i < nUpdates; i++) {
    someUpdates[i]=randomUpdateGenerator.next();
  }
  processAll(someUpdates);
  Value[] allValues=valueCreatorUtil.extractValuesFromUpdates(someUpdates);
  try (IndexReader reader=accessor.newReader()){
    ValueGroup valueGroup=random.among(allValues).valueGroup();
    IndexQuery.RangePredicate<?> supportedQuery=IndexQuery.range(0,valueGroup);
    IndexOrder[] supportedOrders=indexCapability().orderCapability(valueGroup.category());
    for (    IndexOrder supportedOrder : supportedOrders) {
      if (supportedOrder == IndexOrder.NONE) {
        continue;
      }
      Value[] expectedValues=Arrays.stream(allValues).filter(v -> v.valueGroup() == valueGroup).toArray(Value[]::new);
      if (supportedOrder == IndexOrder.ASCENDING) {
        Arrays.sort(expectedValues,Values.COMPARATOR);
      }
      if (supportedOrder == IndexOrder.DESCENDING) {
        Arrays.sort(expectedValues,Values.COMPARATOR.reversed());
      }
      SimpleNodeValueClient client=new SimpleNodeValueClient();
      reader.query(client,supportedOrder,true,supportedQuery);
      int i=0;
      while (client.next()) {
        assertEquals("values in order",expectedValues[i++],client.values[0]);
      }
      assertEquals("found all values",i,expectedValues.length);
    }
  }
 }
