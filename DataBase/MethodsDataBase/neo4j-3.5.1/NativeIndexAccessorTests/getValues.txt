@Test public void getValues() throws IndexEntryConflictException, IndexNotApplicableKernelException {
  int nUpdates=10000;
  Iterator<IndexEntryUpdate<IndexDescriptor>> randomUpdateGenerator=valueCreatorUtil.randomUpdateGenerator(random);
  IndexEntryUpdate<IndexDescriptor>[] someUpdates=new IndexEntryUpdate[nUpdates];
  for (int i=0; i < nUpdates; i++) {
    someUpdates[i]=randomUpdateGenerator.next();
  }
  processAll(someUpdates);
  Value[] allValues=valueCreatorUtil.extractValuesFromUpdates(someUpdates);
  Value value=random.among(allValues);
  ValueGroup valueGroup=value.valueGroup();
  IndexValueCapability valueCapability=indexCapability().valueCapability(valueGroup.category());
  if (!valueCapability.equals(IndexValueCapability.YES)) {
    return;
  }
  IndexQuery.RangePredicate<?> supportedQuery;
  List<Value> expectedValues;
  if (Values.isGeometryValue(value)) {
    CoordinateReferenceSystem crs=((PointValue)value).getCoordinateReferenceSystem();
    supportedQuery=IndexQuery.range(0,crs);
    expectedValues=Arrays.stream(allValues).filter(v -> v.valueGroup() == ValueGroup.GEOMETRY).filter(v -> ((PointValue)v).getCoordinateReferenceSystem() == crs).collect(Collectors.toList());
  }
 else {
    supportedQuery=IndexQuery.range(0,valueGroup);
    expectedValues=Arrays.stream(allValues).filter(v -> v.valueGroup() == valueGroup).collect(Collectors.toList());
  }
  try (IndexReader reader=accessor.newReader()){
    SimpleNodeValueClient client=new SimpleNodeValueClient();
    reader.query(client,IndexOrder.NONE,true,supportedQuery);
    while (client.next()) {
      Value foundValue=client.values[0];
      assertTrue("found value that was not expected " + foundValue,expectedValues.remove(foundValue));
    }
    assertThat("did not find all expected values",expectedValues.size(),CoreMatchers.is(0));
  }
 }
