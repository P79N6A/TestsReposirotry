@Test public void shouldProvideResultInOrderIfCapable() throws KernelException {
  int label=token.nodeLabel("Node");
  int prop=token.propertyKey("prop");
  RandomValues randomValues=randomRule.randomValues();
  IndexReference index=schemaRead.index(label,prop);
  for (int i=0; i < N_ITERATIONS; i++) {
    ValueType type=randomValues.among(targetedTypes);
    IndexOrder[] order=index.orderCapability(type.valueGroup.category());
    for (    IndexOrder indexOrder : order) {
      if (indexOrder == IndexOrder.NONE) {
        continue;
      }
      NodeValueTuple from=new NodeValueTuple(Long.MIN_VALUE,randomValues.nextValueOfType(type));
      NodeValueTuple to=new NodeValueTuple(Long.MAX_VALUE,randomValues.nextValueOfType(type));
      if (COMPARATOR.compare(from,to) > 0) {
        NodeValueTuple tmp=from;
        from=to;
        to=tmp;
      }
      boolean fromInclusive=randomValues.nextBoolean();
      boolean toInclusive=randomValues.nextBoolean();
      IndexQuery.RangePredicate<?> range=IndexQuery.range(prop,from.getOnlyValue(),fromInclusive,to.getOnlyValue(),toInclusive);
      try (NodeValueIndexCursor node=cursors.allocateNodeValueIndexCursor()){
        read.nodeIndexSeek(index,node,indexOrder,false,range);
        List<Long> expectedIdsInOrder=expectedIdsInOrder(from,fromInclusive,to,toInclusive,indexOrder);
        List<Long> actualIdsInOrder=new ArrayList<>();
        while (node.next()) {
          actualIdsInOrder.add(node.nodeReference());
        }
        assertEquals(expectedIdsInOrder,actualIdsInOrder,"actual node ids not in same order as expected");
      }
     }
  }
}
