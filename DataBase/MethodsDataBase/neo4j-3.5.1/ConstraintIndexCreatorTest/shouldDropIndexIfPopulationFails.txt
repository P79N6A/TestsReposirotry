@Test public void shouldDropIndexIfPopulationFails() throws Exception {
  StubKernel kernel=new StubKernel();
  IndexingService indexingService=mock(IndexingService.class);
  IndexProxy indexProxy=mock(IndexProxy.class);
  when(indexingService.getIndexProxy(INDEX_ID)).thenReturn(indexProxy);
  when(indexingService.getIndexProxy(descriptor)).thenReturn(indexProxy);
  when(indexProxy.getDescriptor()).thenReturn(index.withId(INDEX_ID).withoutCapabilities());
  IndexEntryConflictException cause=new IndexEntryConflictException(2,1,Values.of("a"));
  doThrow(new IndexPopulationFailedKernelException("some index",cause)).when(indexProxy).awaitStoreScanCompleted();
  NodePropertyAccessor nodePropertyAccessor=mock(NodePropertyAccessor.class);
  when(schemaRead.index(any(SchemaDescriptor.class))).thenReturn(IndexReference.NO_INDEX).thenReturn(indexReference);
  ConstraintIndexCreator creator=new ConstraintIndexCreator(() -> kernel,indexingService,nodePropertyAccessor,logProvider);
  KernelTransactionImplementation transaction=createTransaction();
  try {
    creator.createUniquenessConstraintIndex(transaction,descriptor,getDefaultProvider());
    fail("expected exception");
  }
 catch (  UniquePropertyValueValidationException e) {
    assertEquals("Existing data does not satisfy CONSTRAINT ON ( label[123]:label[123] ) " + "ASSERT label[123].property[456] IS UNIQUE: Both node 2 and node 1 share the property value ( String(\"a\") )",e.getMessage());
  }
  assertEquals(2,kernel.transactions.size());
  KernelTransactionImplementation tx1=kernel.transactions.get(0);
  SchemaDescriptor newIndex=index.schema();
  verify(tx1).indexUniqueCreate(eq(newIndex),eq(getDefaultProvider()));
  verify(schemaRead).indexGetCommittedId(indexReference);
  verify(schemaRead,times(2)).index(descriptor);
  verifyNoMoreInteractions(schemaRead);
  TransactionState tx2=kernel.transactions.get(1).txState();
  verify(tx2).indexDoDrop(index);
  verifyNoMoreInteractions(tx2);
}
