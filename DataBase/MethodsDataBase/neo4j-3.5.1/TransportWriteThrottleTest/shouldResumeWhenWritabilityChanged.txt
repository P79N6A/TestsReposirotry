@Test public void shouldResumeWhenWritabilityChanged() throws Exception {
  TestThrottleLock lockOverride=new TestThrottleLock();
  TransportThrottle throttle=newThrottleAndInstall(channel,lockOverride);
  when(channel.isWritable()).thenReturn(false);
  Future<Void> completionFuture=otherThread.execute(state -> {
    throttle.acquire(channel);
    return null;
  }
);
  otherThread.get().waitUntilWaiting();
  when(channel.isWritable()).thenReturn(true);
  ArgumentCaptor<ChannelInboundHandler> captor=ArgumentCaptor.forClass(ChannelInboundHandler.class);
  verify(channel.pipeline()).addLast(captor.capture());
  captor.getValue().channelWritabilityChanged(context);
  otherThread.get().awaitFuture(completionFuture);
  assertThat(lockOverride.lockCallCount(),greaterThan(0));
  assertThat(lockOverride.unlockCallCount(),is(1));
}
