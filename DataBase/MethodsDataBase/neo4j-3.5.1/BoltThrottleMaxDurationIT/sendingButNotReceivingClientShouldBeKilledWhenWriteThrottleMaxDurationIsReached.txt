@Test public void sendingButNotReceivingClientShouldBeKilledWhenWriteThrottleMaxDurationIsReached() throws Exception {
  int numberOfRunDiscardPairs=10_000;
  String largeString=StringUtils.repeat(" ",8 * 1024);
  client.connect(address).send(util.acceptedVersions(1,0,0,0)).send(util.chunk(new InitMessage("TestClient/1.1",emptyMap())));
  assertThat(client,eventuallyReceives(new byte[]{0,0,0,1}));
  assertThat(client,util.eventuallyReceives(msgSuccess()));
  Future sender=otherThread.execute(state -> {
    for (int i=0; i < numberOfRunDiscardPairs; i++) {
      client.send(util.chunk(new RunMessage("RETURN $data as data",ValueUtils.asMapValue(singletonMap("data",largeString))),PullAllMessage.INSTANCE));
    }
    return null;
  }
);
  try {
    otherThread.get().awaitFuture(sender);
    fail("should throw ExecutionException instead");
  }
 catch (  ExecutionException e) {
    assertThat(Exceptions.rootCause(e),instanceOf(SocketException.class));
  }
  logProvider.assertAtLeastOnce(inLog(Matchers.containsString(BoltConnection.class.getPackage().getName())).error(startsWith("Unexpected error detected in bolt session"),hasProperty("cause",matchesExceptionMessage(containsString("will be closed because the client did not consume outgoing buffers for ")))));
}
