@Test public void shouldProcessAllMultiThreadedAndWithChangingProcessorCount() throws Exception {
  StageControl control=mock(StageControl.class);
  int availableProcessors=Runtime.getRuntime().availableProcessors();
  BatchProcessor step=new BatchProcessor(control,availableProcessors);
  TrackingStep downstream=new TrackingStep();
  step.setDownstream(downstream);
  step.start(0);
  AtomicLong nextTicket=new AtomicLong();
  Thread[] submitters=new Thread[3];
  AtomicBoolean end=new AtomicBoolean();
  for (int i=0; i < submitters.length; i++) {
    submitters[i]=new Thread(() -> {
      ThreadLocalRandom random=ThreadLocalRandom.current();
      while (!end.get()) {
synchronized (nextTicket) {
          if (random.nextFloat() < 0.1) {
            step.processors(random.nextInt(-2,4));
          }
          long ticket=nextTicket.incrementAndGet();
          Batch batch=new Batch(step.processors(0));
          step.receive(ticket,batch);
        }
      }
    }
);
    submitters[i].start();
  }
  while (downstream.received.get() < 200) {
    Thread.sleep(10);
  }
  end.set(true);
  for (  Thread submitter : submitters) {
    submitter.join();
  }
  step.endOfUpstream();
  step.close();
}
