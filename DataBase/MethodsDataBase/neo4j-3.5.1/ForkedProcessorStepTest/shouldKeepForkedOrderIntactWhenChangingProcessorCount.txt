@Test public void shouldKeepForkedOrderIntactWhenChangingProcessorCount() throws Exception {
  int length=100;
  AtomicIntegerArray reference=new AtomicIntegerArray(length);
  StageControl control=mock(StageControl.class);
  int availableProcessors=Runtime.getRuntime().availableProcessors();
  ForkedProcessorStep<int[]> step=new ForkedProcessorStep<int[]>(control,"Processor",config(availableProcessors)){
    @Override protected void forkedProcess(    int id,    int processors,    int[] batch) throws InterruptedException {
      int ticket=batch[0];
      Thread.sleep(ThreadLocalRandom.current().nextInt(10));
      for (int i=1; i < batch.length; i++) {
        if (batch[i] % processors == id) {
          boolean compareAndSet=reference.compareAndSet(batch[i],ticket,ticket + 1);
          assertTrue("I am " + id + ". Was expecting "+ ticket+ " for "+ batch[i]+ " but was "+ reference.get(batch[i]),compareAndSet);
        }
      }
    }
  }
;
  DeadEndStep downstream=new DeadEndStep(control);
  step.setDownstream(downstream);
  step.start(0);
  downstream.start(0);
  ThreadLocalRandom random=ThreadLocalRandom.current();
  for (int ticket=0; ticket < 200; ticket++) {
    if (random.nextFloat() < 0.1) {
      int p=step.processors(random.nextInt(-2,4));
    }
    int[] batch=new int[length];
    batch[0]=ticket;
    for (int j=1; j < batch.length; j++) {
      batch[j]=j - 1;
    }
    step.receive(ticket,batch);
  }
  step.endOfUpstream();
  step.awaitCompleted();
  step.close();
}
