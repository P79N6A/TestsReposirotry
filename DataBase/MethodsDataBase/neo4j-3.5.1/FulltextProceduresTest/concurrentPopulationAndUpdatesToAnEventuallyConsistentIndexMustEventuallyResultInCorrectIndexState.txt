@Test public void concurrentPopulationAndUpdatesToAnEventuallyConsistentIndexMustEventuallyResultInCorrectIndexState() throws Exception {
  String oldValue="red";
  String newValue="green";
  db=createDatabase();
  int entityCount=200;
  LongHashSet nodeIds=new LongHashSet();
  LongHashSet relIds=new LongHashSet();
  try (Transaction tx=db.beginTx()){
    for (int i=0; i < entityCount; i++) {
      Node node=db.createNode(LABEL);
      node.setProperty(PROP,oldValue);
      Relationship rel=node.createRelationshipTo(node,REL);
      rel.setProperty(PROP,oldValue);
      nodeIds.add(node.getId());
      relIds.add(rel.getId());
    }
    tx.success();
  }
   CountDownLatch readyLatch=new CountDownLatch(2);
  BinaryLatch startLatch=new BinaryLatch();
  Runnable createIndexes=() -> {
    readyLatch.countDown();
    startLatch.await();
    try (Transaction tx=db.beginTx()){
      db.execute(format(NODE_CREATE,"node",array(LABEL.name()),array(PROP) + EVENTUALLY_CONSISTENT));
      db.execute(format(RELATIONSHIP_CREATE,"rel",array(REL.name()),array(PROP) + EVENTUALLY_CONSISTENT));
      tx.success();
    }
   }
;
  Runnable makeAllEntitiesGreen=() -> {
    try (Transaction tx=db.beginTx()){
      nodeIds.forEach(nodeId -> db.getNodeById(nodeId).setProperty(PROP,newValue));
      relIds.forEach(relId -> db.getRelationshipById(relId).setProperty(PROP,newValue));
      tx.success();
      readyLatch.countDown();
      startLatch.await();
    }
   }
;
  ExecutorService executor=cleanup.add(Executors.newFixedThreadPool(2));
  Future<?> future1=executor.submit(createIndexes);
  Future<?> future2=executor.submit(makeAllEntitiesGreen);
  readyLatch.await();
  startLatch.release();
  future1.get();
  future2.get();
  awaitIndexesOnline();
  db.execute(AWAIT_REFRESH).close();
  assertQueryFindsIds(db,true,"node",newValue,nodeIds);
  assertQueryFindsIds(db,false,"rel",newValue,relIds);
}
