@Test void mustNotApplyAsyncWorkInParallelUnderStress() throws Exception {
  int workers=Runtime.getRuntime().availableProcessors() * 5;
  int iterations=1_000;
  int incrementValue=42;
  CountDownLatch startLatch=new CountDownLatch(workers);
  CountDownLatch endLatch=new CountDownLatch(workers);
  AtomicBoolean start=new AtomicBoolean();
  Callable<Void> work=() -> {
    startLatch.countDown();
    boolean spin;
    do {
      spin=!start.get();
    }
 while (spin);
    ThreadLocalRandom rng=ThreadLocalRandom.current();
    List<AsyncApply> asyncs=new ArrayList<>();
    for (int i=0; i < iterations; i++) {
      asyncs.add(sync.applyAsync(new AddWork(incrementValue)));
      if (rng.nextInt(10) == 0) {
        for (        AsyncApply async : asyncs) {
          async.await();
        }
        asyncs.clear();
      }
    }
    for (    AsyncApply async : asyncs) {
      async.await();
    }
    endLatch.countDown();
    return null;
  }
;
  List<Future<Void>> futureList=new ArrayList<>();
  for (int i=0; i < workers; i++) {
    futureList.add(executor.submit(work));
  }
  startLatch.await();
  start.set(true);
  endLatch.await();
  for (  Future<Void> future : futureList) {
    future.get();
  }
  assertThat(count.sum(),lessThan((long)(workers * iterations)));
  assertThat(sum.sum(),is((long)(incrementValue * workers * iterations)));
}
