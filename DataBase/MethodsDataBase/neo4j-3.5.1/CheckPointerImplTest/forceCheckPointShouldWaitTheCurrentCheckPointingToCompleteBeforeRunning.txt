@Test public void forceCheckPointShouldWaitTheCurrentCheckPointingToCompleteBeforeRunning() throws Throwable {
  Lock lock=new ReentrantLock();
  final Lock spyLock=spy(lock);
  doAnswer(invocation -> {
    verify(appender).checkPoint(any(LogPosition.class),any(LogCheckPointEvent.class));
    reset(appender);
    invocation.callRealMethod();
    return null;
  }
).when(spyLock).unlock();
  final CheckPointerImpl checkPointing=checkPointer(mutex(spyLock));
  mockTxIdStore();
  final CountDownLatch startSignal=new CountDownLatch(2);
  final CountDownLatch completed=new CountDownLatch(2);
  checkPointing.start();
  Thread checkPointerThread=new CheckPointerThread(checkPointing,startSignal,completed);
  Thread forceCheckPointThread=new Thread(() -> {
    try {
      startSignal.countDown();
      startSignal.await();
      checkPointing.forceCheckPoint(INFO);
      completed.countDown();
    }
 catch (    Throwable e) {
      throw new RuntimeException(e);
    }
  }
);
  checkPointerThread.start();
  forceCheckPointThread.start();
  completed.await();
  verify(spyLock,times(2)).lock();
  verify(spyLock,times(2)).unlock();
}
