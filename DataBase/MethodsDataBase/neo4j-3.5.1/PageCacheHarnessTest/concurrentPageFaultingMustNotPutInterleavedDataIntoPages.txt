@Test void concurrentPageFaultingMustNotPutInterleavedDataIntoPages(){
  assertTimeout(ofMillis(LONG_TIMEOUT_MILLIS),() -> {
    final int filePageCount=11;
    final RecordFormat recordFormat=new PageCountRecordFormat();
    try (RandomPageCacheTestHarness harness=new RandomPageCacheTestHarness()){
      harness.setConcurrencyLevel(11);
      harness.setUseAdversarialIO(false);
      harness.setCachePageCount(3);
      harness.setFilePageCount(filePageCount);
      harness.setInitialMappedFiles(1);
      harness.setCommandCount(10000);
      harness.setRecordFormat(recordFormat);
      harness.setFileSystem(fs);
      harness.useProfiler(profiler);
      harness.disableCommands(FlushCache,FlushFile,MapFile,UnmapFile,WriteRecord,WriteMulti);
      harness.setPreparation((cache,fs,filesTouched) -> {
        File file=filesTouched.iterator().next();
        try (PagedFile pf=cache.map(file,cache.pageSize());PageCursor cursor=pf.io(0,PF_SHARED_WRITE_LOCK)){
          for (int pageId=0; pageId < filePageCount; pageId++) {
            cursor.next();
            recordFormat.fillWithRecords(cursor);
          }
        }
       }
);
      harness.run(LONG_TIMEOUT_MILLIS,MILLISECONDS);
    }
   }
);
}
