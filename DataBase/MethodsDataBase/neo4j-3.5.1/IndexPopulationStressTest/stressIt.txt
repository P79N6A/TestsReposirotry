@Test public void stressIt() throws Throwable {
  Race race=new Race();
  AtomicReferenceArray<List<? extends IndexEntryUpdate<?>>> lastBatches=new AtomicReferenceArray<>(THREADS);
  Generator[] generators=new Generator[THREADS];
  populator.create();
  CountDownLatch insertersDone=new CountDownLatch(THREADS);
  ReadWriteLock updateLock=new ReentrantReadWriteLock(true);
  for (int i=0; i < THREADS; i++) {
    race.addContestant(inserter(lastBatches,generators,insertersDone,updateLock,i),1);
  }
  Collection<IndexEntryUpdate<?>> updates=new ArrayList<>();
  race.addContestant(updater(lastBatches,insertersDone,updateLock,updates));
  race.go();
  populator.close(true);
  populator=null;
  buildReferencePopulatorSingleThreaded(generators,updates);
  try (IndexAccessor accessor=indexProvider.getOnlineAccessor(descriptor,samplingConfig);IndexAccessor referenceAccessor=indexProvider.getOnlineAccessor(descriptor2,samplingConfig);IndexReader reader=accessor.newReader();IndexReader referenceReader=referenceAccessor.newReader()){
    SimpleNodeValueClient entries=new SimpleNodeValueClient();
    SimpleNodeValueClient referenceEntries=new SimpleNodeValueClient();
    reader.query(entries,IndexOrder.NONE,hasValues,IndexQuery.exists(0));
    referenceReader.query(referenceEntries,IndexOrder.NONE,hasValues,IndexQuery.exists(0));
    while (referenceEntries.next()) {
      assertTrue(entries.next());
      assertEquals(referenceEntries.reference,entries.reference);
      if (hasValues) {
        assertEquals(ValueTuple.of(referenceEntries.values),ValueTuple.of(entries.values));
      }
    }
    assertFalse(entries.next());
  }
 }
