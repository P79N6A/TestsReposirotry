@SuppressWarnings("ConstantConditions") @Test public void neverStopsExecutingQueryDuringCommitAndRestartTx(){
  KernelTransaction initialKTX=mockTransaction(initialStatement);
  InternalTransaction initialTransaction=mock(InternalTransaction.class,new ReturnsDeepStubs());
  KernelTransaction.Type transactionType=KernelTransaction.Type.implicit;
  SecurityContext securityContext=SecurityContext.AUTH_DISABLED;
  when(initialTransaction.transactionType()).thenReturn(transactionType);
  when(initialTransaction.securityContext()).thenReturn(securityContext);
  when(initialTransaction.terminationReason()).thenReturn(Optional.empty());
  QueryRegistryOperations initialQueryRegistry=mock(QueryRegistryOperations.class);
  ExecutingQuery executingQuery=mock(ExecutingQuery.class);
  PropertyContainerLocker locker=null;
  ThreadToStatementContextBridge txBridge=mock(ThreadToStatementContextBridge.class);
  Statement secondStatement=mock(Statement.class);
  KernelTransaction secondKTX=mockTransaction(secondStatement);
  InternalTransaction secondTransaction=mock(InternalTransaction.class);
  when(secondTransaction.terminationReason()).thenReturn(Optional.empty());
  QueryRegistryOperations secondQueryRegistry=mock(QueryRegistryOperations.class);
  when(executingQuery.queryText()).thenReturn("X");
  when(executingQuery.queryParameters()).thenReturn(EMPTY_MAP);
  when(initialStatement.queryRegistration()).thenReturn(initialQueryRegistry);
  when(queryService.beginTransaction(transactionType,securityContext)).thenReturn(secondTransaction);
  when(txBridge.getKernelTransactionBoundToThisThread(true)).thenReturn(initialKTX,initialKTX,secondKTX);
  when(secondStatement.queryRegistration()).thenReturn(secondQueryRegistry);
  Kernel kernel=mock(Kernel.class);
  Neo4jTransactionalContext context=new Neo4jTransactionalContext(queryService,txBridge,locker,initialTransaction,initialStatement,executingQuery,kernel);
  context.commitAndRestartTx();
  Object[] mocks={txBridge,initialTransaction,initialKTX,initialQueryRegistry,secondQueryRegistry,secondKTX};
  InOrder order=Mockito.inOrder(mocks);
  order.verify(initialTransaction).transactionType();
  order.verify(initialTransaction).securityContext();
  order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
  order.verify(initialTransaction).terminationReason();
  order.verify(initialKTX).executionStatistics();
  order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
  order.verify(txBridge).unbindTransactionFromCurrentThread();
  order.verify(txBridge).getKernelTransactionBoundToThisThread(true);
  order.verify(secondKTX).acquireStatement();
  order.verify(secondQueryRegistry).registerExecutingQuery(executingQuery);
  order.verify(txBridge).unbindTransactionFromCurrentThread();
  order.verify(txBridge).bindTransactionToCurrentThread(initialKTX);
  order.verify(initialQueryRegistry).unregisterExecutingQuery(executingQuery);
  order.verify(initialTransaction).success();
  order.verify(initialTransaction).close();
  order.verify(txBridge).unbindTransactionFromCurrentThread();
  order.verify(txBridge).bindTransactionToCurrentThread(secondKTX);
  verifyNoMoreInteractions(mocks);
}
