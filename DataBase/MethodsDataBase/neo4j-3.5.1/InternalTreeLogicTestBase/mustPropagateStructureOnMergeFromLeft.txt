@Test public void mustPropagateStructureOnMergeFromLeft() throws Exception {
  assumeTrue("No checkpointing, no successor",isCheckpointing);
  List<KEY> allKeys=new ArrayList<>();
  initialize();
  long targetLastId=id.lastId() + 3;
  long i=0;
  for (; id.lastId() < targetLastId; i++) {
    KEY key=key(i);
    insert(key,value(i));
    allKeys.add(key);
  }
  goTo(readCursor,rootId);
  assertEquals(2,keyCount());
  long oldRootId=readCursor.getCurrentPageId();
  long oldLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
  long oldMiddleChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
  long oldRightChild=childAt(readCursor,2,stableGeneration,unstableGeneration);
  assertSiblings(oldLeftChild,oldMiddleChild,oldRightChild);
  generationManager.checkpoint();
  KEY middleKey=keyAt(oldMiddleChild,0,LEAF);
  remove(middleKey,dontCare);
  allKeys.remove(middleKey);
  goTo(readCursor,oldRootId);
  assertEquals(2,keyCount());
  goTo(readCursor,rootId);
  assertEquals(1,keyCount());
  long newLeftChild=childAt(readCursor,0,stableGeneration,unstableGeneration);
  assertNotEquals(newLeftChild,oldLeftChild);
  assertNotEquals(newLeftChild,oldMiddleChild);
  long newRightChild=childAt(readCursor,1,stableGeneration,unstableGeneration);
  assertEquals(newRightChild,oldRightChild);
  goTo(readCursor,oldLeftChild);
  assertEquals(newLeftChild,successor(readCursor,stableGeneration,unstableGeneration));
  goTo(readCursor,oldMiddleChild);
  assertEquals(newLeftChild,successor(readCursor,stableGeneration,unstableGeneration));
  goTo(readCursor,oldRightChild);
  KEY firstKeyOfOldRightChild=keyAt(0,LEAF);
  int index=indexOf(firstKeyOfOldRightChild,allKeys,layout);
  List<KEY> expectedKeysInNewLeftChild=allKeys.subList(0,index);
  goTo(readCursor,newLeftChild);
  assertNodeContainsExpectedKeys(expectedKeysInNewLeftChild,LEAF);
  assertSiblings(newLeftChild,oldRightChild,TreeNode.NO_NODE_FLAG);
}
