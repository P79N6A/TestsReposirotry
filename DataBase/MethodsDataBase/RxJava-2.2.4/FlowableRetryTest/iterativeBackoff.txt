@Test public void iterativeBackoff(){
  Subscriber<String> consumer=TestHelper.mockSubscriber();
  Flowable<String> producer=Flowable.unsafeCreate(new Publisher<String>(){
    private AtomicInteger count=new AtomicInteger(4);
    long last=System.currentTimeMillis();
    @Override public void subscribe(    Subscriber<? super String> t1){
      t1.onSubscribe(new BooleanSubscription());
      System.out.println(count.get() + " @ " + String.valueOf(last - System.currentTimeMillis()));
      last=System.currentTimeMillis();
      if (count.getAndDecrement() == 0) {
        t1.onNext("hello");
        t1.onComplete();
      }
 else {
        t1.onError(new RuntimeException());
      }
    }
  }
);
  TestSubscriber<String> ts=new TestSubscriber<String>(consumer);
  producer.retryWhen(new Function<Flowable<? extends Throwable>,Flowable<Object>>(){
    @Override public Flowable<Object> apply(    Flowable<? extends Throwable> attempts){
      return attempts.map(new Function<Throwable,Tuple>(){
        @Override public Tuple apply(        Throwable n){
          return new Tuple(new Long(1),n);
        }
      }
).scan(new BiFunction<Tuple,Tuple,Tuple>(){
        @Override public Tuple apply(        Tuple t,        Tuple n){
          return new Tuple(t.count + n.count,n.n);
        }
      }
).flatMap(new Function<Tuple,Flowable<Object>>(){
        @Override public Flowable<Object> apply(        Tuple t){
          System.out.println("Retry # " + t.count);
          return t.count > 20 ? Flowable.<Object>error(t.n) : Flowable.timer(t.count * 1L,TimeUnit.MILLISECONDS).cast(Object.class);
        }
      }
);
    }
  }
).subscribe(ts);
  ts.awaitTerminalEvent();
  ts.assertNoErrors();
  InOrder inOrder=inOrder(consumer);
  inOrder.verify(consumer,never()).onError(any(Throwable.class));
  inOrder.verify(consumer,times(1)).onNext("hello");
  inOrder.verify(consumer,times(1)).onComplete();
  inOrder.verifyNoMoreInteractions();
}
