@Test public void testUnsubscribeViaTakeOnGroupThenMergeAndTake(){
  final AtomicInteger subscribeCounter=new AtomicInteger();
  final AtomicInteger sentEventCounter=new AtomicInteger();
  final AtomicInteger eventCounter=new AtomicInteger();
  SYNC_INFINITE_OBSERVABLE_OF_EVENT(4,subscribeCounter,sentEventCounter).groupBy(new Function<Event,Integer>(){
    @Override public Integer apply(    Event e){
      return e.source;
    }
  }
).take(2).flatMap(new Function<GroupedFlowable<Integer,Event>,Flowable<String>>(){
    @Override public Flowable<String> apply(    GroupedFlowable<Integer,Event> eventGroupedFlowable){
      return eventGroupedFlowable.map(new Function<Event,String>(){
        @Override public String apply(        Event event){
          return "testUnsubscribe => Source: " + event.source + "  Message: "+ event.message;
        }
      }
);
    }
  }
).take(30).subscribe(new Consumer<String>(){
    @Override public void accept(    String s){
      eventCounter.incrementAndGet();
      System.out.println("=> " + s);
    }
  }
);
  assertEquals(30,eventCounter.get());
  assertEquals(58,sentEventCounter.get());
}
