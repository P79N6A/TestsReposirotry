@Test public void normalBehavior(){
  Flowable<String> source=Flowable.fromIterable(Arrays.asList("  foo"," FoO ","baR  ","foO "," Baz   ","  qux ","   bar"," BAR  ","FOO ","baz  "," bAZ ","    fOo    "));
  Function<String,String> keysel=new Function<String,String>(){
    @Override public String apply(    String t1){
      return t1.trim().toLowerCase();
    }
  }
;
  Function<String,String> valuesel=new Function<String,String>(){
    @Override public String apply(    String t1){
      return t1 + t1;
    }
  }
;
  Flowable<String> m=source.groupBy(keysel,valuesel).flatMap(new Function<GroupedFlowable<String,String>,Publisher<String>>(){
    @Override public Publisher<String> apply(    final GroupedFlowable<String,String> g){
      System.out.println("-----------> NEXT: " + g.getKey());
      return g.take(2).map(new Function<String,String>(){
        int count;
        @Override public String apply(        String v){
          System.out.println(v);
          return g.getKey() + "-" + count++;
        }
      }
);
    }
  }
);
  TestSubscriber<String> ts=new TestSubscriber<String>();
  m.subscribe(ts);
  ts.awaitTerminalEvent();
  System.out.println("ts .get " + ts.values());
  ts.assertNoErrors();
  assertEquals(ts.values(),Arrays.asList("foo-0","foo-1","bar-0","foo-0","baz-0","qux-0","bar-1","bar-0","foo-1","baz-1","baz-0","foo-0"));
}
