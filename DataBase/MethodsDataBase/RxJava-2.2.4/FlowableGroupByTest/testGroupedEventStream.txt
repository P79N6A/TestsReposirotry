/** 
 * Assert that only a single subscription to a stream occurs and that all events are received.
 * @throws Throwable some method call is declared throws
 */
@Test public void testGroupedEventStream() throws Throwable {
  final AtomicInteger eventCounter=new AtomicInteger();
  final AtomicInteger subscribeCounter=new AtomicInteger();
  final AtomicInteger groupCounter=new AtomicInteger();
  final CountDownLatch latch=new CountDownLatch(1);
  final int count=100;
  final int groupCount=2;
  Flowable<Event> es=Flowable.unsafeCreate(new Publisher<Event>(){
    @Override public void subscribe(    final Subscriber<? super Event> subscriber){
      subscriber.onSubscribe(new BooleanSubscription());
      System.out.println("*** Subscribing to EventStream ***");
      subscribeCounter.incrementAndGet();
      new Thread(new Runnable(){
        @Override public void run(){
          for (int i=0; i < count; i++) {
            Event e=new Event();
            e.source=i % groupCount;
            e.message="Event-" + i;
            subscriber.onNext(e);
          }
          subscriber.onComplete();
        }
      }
).start();
    }
  }
);
  es.groupBy(new Function<Event,Integer>(){
    @Override public Integer apply(    Event e){
      return e.source;
    }
  }
).flatMap(new Function<GroupedFlowable<Integer,Event>,Flowable<String>>(){
    @Override public Flowable<String> apply(    GroupedFlowable<Integer,Event> eventGroupedFlowable){
      System.out.println("GroupedFlowable Key: " + eventGroupedFlowable.getKey());
      groupCounter.incrementAndGet();
      return eventGroupedFlowable.map(new Function<Event,String>(){
        @Override public String apply(        Event event){
          return "Source: " + event.source + "  Message: "+ event.message;
        }
      }
);
    }
  }
).subscribe(new DefaultSubscriber<String>(){
    @Override public void onComplete(){
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      e.printStackTrace();
      latch.countDown();
    }
    @Override public void onNext(    String outputMessage){
      System.out.println(outputMessage);
      eventCounter.incrementAndGet();
    }
  }
);
  latch.await(5000,TimeUnit.MILLISECONDS);
  assertEquals(1,subscribeCounter.get());
  assertEquals(groupCount,groupCounter.get());
  assertEquals(count,eventCounter.get());
}
