@Test public void testUnsubscribeViaTakeOnGroupThenTakeOnInner(){
  final AtomicInteger subscribeCounter=new AtomicInteger();
  final AtomicInteger sentEventCounter=new AtomicInteger();
  final AtomicInteger eventCounter=new AtomicInteger();
  SYNC_INFINITE_OBSERVABLE_OF_EVENT(4,subscribeCounter,sentEventCounter).groupBy(new Function<Event,Integer>(){
    @Override public Integer apply(    Event e){
      return e.source;
    }
  }
).take(2).flatMap(new Function<GroupedFlowable<Integer,Event>,Flowable<String>>(){
    @Override public Flowable<String> apply(    GroupedFlowable<Integer,Event> eventGroupedFlowable){
      int numToTake=0;
      if (eventGroupedFlowable.getKey() == 1) {
        numToTake=10;
      }
 else       if (eventGroupedFlowable.getKey() == 2) {
        numToTake=5;
      }
      return eventGroupedFlowable.take(numToTake).map(new Function<Event,String>(){
        @Override public String apply(        Event event){
          return "testUnsubscribe => Source: " + event.source + "  Message: "+ event.message;
        }
      }
);
    }
  }
).subscribe(new Consumer<String>(){
    @Override public void accept(    String s){
      eventCounter.incrementAndGet();
      System.out.println("=> " + s);
    }
  }
);
  assertEquals(15,eventCounter.get());
  assertEquals(37,sentEventCounter.get());
}
