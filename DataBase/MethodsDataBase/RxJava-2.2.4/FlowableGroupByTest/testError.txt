@Test public void testError(){
  Flowable<String> sourceStrings=Flowable.just("one","two","three","four","five","six");
  Flowable<String> errorSource=Flowable.error(new TestException("forced failure"));
  Flowable<String> source=Flowable.concat(sourceStrings,errorSource);
  Flowable<GroupedFlowable<Integer,String>> grouped=source.groupBy(length);
  final AtomicInteger groupCounter=new AtomicInteger();
  final AtomicInteger eventCounter=new AtomicInteger();
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  grouped.flatMap(new Function<GroupedFlowable<Integer,String>,Flowable<String>>(){
    @Override public Flowable<String> apply(    final GroupedFlowable<Integer,String> f){
      groupCounter.incrementAndGet();
      return f.map(new Function<String,String>(){
        @Override public String apply(        String v){
          return "Event => key: " + f.getKey() + " value: "+ v;
        }
      }
);
    }
  }
).subscribe(new DefaultSubscriber<String>(){
    @Override public void onComplete(){
    }
    @Override public void onError(    Throwable e){
      error.set(e);
    }
    @Override public void onNext(    String v){
      eventCounter.incrementAndGet();
      System.out.println(v);
    }
  }
);
  assertEquals(3,groupCounter.get());
  assertEquals(6,eventCounter.get());
  assertNotNull(error.get());
  assertTrue("" + error.get(),error.get() instanceof TestException);
  assertEquals(error.get().getMessage(),"forced failure");
}
