@Test public void testIgnoringGroups(){
  final AtomicInteger subscribeCounter=new AtomicInteger();
  final AtomicInteger sentEventCounter=new AtomicInteger();
  final AtomicInteger eventCounter=new AtomicInteger();
  SYNC_INFINITE_OBSERVABLE_OF_EVENT(4,subscribeCounter,sentEventCounter).groupBy(new Function<Event,Integer>(){
    @Override public Integer apply(    Event e){
      return e.source;
    }
  }
).flatMap(new Function<GroupedFlowable<Integer,Event>,Flowable<String>>(){
    @Override public Flowable<String> apply(    GroupedFlowable<Integer,Event> eventGroupedFlowable){
      Flowable<Event> eventStream=eventGroupedFlowable;
      if (eventGroupedFlowable.getKey() >= 2) {
        eventStream=eventGroupedFlowable.filter(new Predicate<Event>(){
          @Override public boolean test(          Event t1){
            return false;
          }
        }
);
      }
      return eventStream.map(new Function<Event,String>(){
        @Override public String apply(        Event event){
          return "testUnsubscribe => Source: " + event.source + "  Message: "+ event.message;
        }
      }
);
    }
  }
).take(30).subscribe(new Consumer<String>(){
    @Override public void accept(    String s){
      eventCounter.incrementAndGet();
      System.out.println("=> " + s);
    }
  }
);
  assertEquals(30,eventCounter.get());
  assertEquals(60,sentEventCounter.get());
}
