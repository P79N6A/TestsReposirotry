@Test public void testThreadName() throws InterruptedException {
  System.out.println("Main Thread: " + Thread.currentThread().getName());
  Flowable<String> obs=Flowable.just("one","null","two","three","four");
  Subscriber<String> subscriber=TestHelper.mockSubscriber();
  final String parentThreadName=Thread.currentThread().getName();
  final CountDownLatch completedLatch=new CountDownLatch(1);
  obs=obs.doOnNext(new Consumer<String>(){
    @Override public void accept(    String s){
      String threadName=Thread.currentThread().getName();
      System.out.println("Source ThreadName: " + threadName + "  Expected => "+ parentThreadName);
      assertEquals(parentThreadName,threadName);
    }
  }
);
  obs.observeOn(Schedulers.newThread()).doOnNext(new Consumer<String>(){
    @Override public void accept(    String t1){
      String threadName=Thread.currentThread().getName();
      boolean correctThreadName=threadName.startsWith("RxNewThreadScheduler");
      System.out.println("ObserveOn ThreadName: " + threadName + "  Correct => "+ correctThreadName);
      assertTrue(correctThreadName);
    }
  }
).doAfterTerminate(new Action(){
    @Override public void run(){
      completedLatch.countDown();
    }
  }
).subscribe(subscriber);
  if (!completedLatch.await(1000,TimeUnit.MILLISECONDS)) {
    fail("timed out waiting");
  }
  verify(subscriber,never()).onError(any(Throwable.class));
  verify(subscriber,times(5)).onNext(any(String.class));
  verify(subscriber,times(1)).onComplete();
}
