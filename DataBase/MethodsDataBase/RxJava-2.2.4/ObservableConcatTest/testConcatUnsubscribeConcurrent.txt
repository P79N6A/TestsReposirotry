/** 
 * All observables will be running in different threads so subscribe() is unblocked. CountDownLatch is only used in order to call unsubscribe() in a predictable manner.
 */
@Test public void testConcatUnsubscribeConcurrent(){
  final CountDownLatch callOnce=new CountDownLatch(1);
  final CountDownLatch okToContinue=new CountDownLatch(1);
  final TestObservable<String> w1=new TestObservable<String>("one","two","three");
  final TestObservable<String> w2=new TestObservable<String>(callOnce,okToContinue,"four","five","six");
  Observer<String> observer=TestHelper.mockObserver();
  TestObserver<String> to=new TestObserver<String>(observer);
  @SuppressWarnings("unchecked") TestObservable<Observable<String>> observableOfObservables=new TestObservable<Observable<String>>(Observable.unsafeCreate(w1),Observable.unsafeCreate(w2));
  Observable<String> concatF=Observable.concat(Observable.unsafeCreate(observableOfObservables));
  concatF.subscribe(to);
  try {
    callOnce.await();
    to.dispose();
    okToContinue.countDown();
    w1.t.join();
    w2.t.join();
  }
 catch (  Throwable e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
  InOrder inOrder=inOrder(observer);
  inOrder.verify(observer,times(1)).onNext("one");
  inOrder.verify(observer,times(1)).onNext("two");
  inOrder.verify(observer,times(1)).onNext("three");
  inOrder.verify(observer,times(1)).onNext("four");
  inOrder.verify(observer,never()).onNext("five");
  inOrder.verify(observer,never()).onNext("six");
  verify(observer,never()).onComplete();
  verify(observer,never()).onError(any(Throwable.class));
}
