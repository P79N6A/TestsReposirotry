@Test public void failingInnerCancelsSource(){
  final AtomicInteger counter=new AtomicInteger();
  Observable.range(1,5).doOnNext(new Consumer<Integer>(){
    @Override public void accept(    Integer v) throws Exception {
      counter.getAndIncrement();
    }
  }
).flatMapIterable(new Function<Integer,Iterable<Integer>>(){
    @Override public Iterable<Integer> apply(    Integer v) throws Exception {
      return new Iterable<Integer>(){
        @Override public Iterator<Integer> iterator(){
          return new Iterator<Integer>(){
            @Override public boolean hasNext(){
              return true;
            }
            @Override public Integer next(){
              throw new TestException();
            }
            @Override public void remove(){
              throw new UnsupportedOperationException();
            }
          }
;
        }
      }
;
    }
  }
).test().assertFailure(TestException.class);
  assertEquals(1,counter.get());
}
