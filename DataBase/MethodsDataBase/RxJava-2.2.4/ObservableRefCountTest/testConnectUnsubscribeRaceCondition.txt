@Test public void testConnectUnsubscribeRaceCondition() throws InterruptedException {
  final AtomicInteger subUnsubCount=new AtomicInteger();
  Observable<Long> o=synchronousInterval().doOnDispose(new Action(){
    @Override public void run(){
      System.out.println("******************************* Unsubscribe received");
      subUnsubCount.decrementAndGet();
    }
  }
).doOnSubscribe(new Consumer<Disposable>(){
    @Override public void accept(    Disposable d){
      System.out.println("******************************* SUBSCRIBE received");
      subUnsubCount.incrementAndGet();
    }
  }
);
  TestObserver<Long> observer=new TestObserver<Long>();
  o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(observer);
  System.out.println("send unsubscribe");
  observer.dispose();
  Thread.sleep(10);
  int counter=200;
  while (subUnsubCount.get() != 0 && counter-- != 0) {
    Thread.sleep(10);
  }
  assertEquals(0,subUnsubCount.get());
  System.out.println("DONE sending unsubscribe ... now waiting");
  System.out.println("Errors: " + observer.errors());
  if (observer.errors().size() > 0) {
    observer.errors().get(0).printStackTrace();
  }
  observer.assertNoErrors();
}
