@Test(timeout=1000) public void testUnSubscribeObservableOfObservables() throws InterruptedException {
  final AtomicBoolean unsubscribed=new AtomicBoolean();
  final CountDownLatch latch=new CountDownLatch(1);
  Observable<Observable<Long>> source=Observable.unsafeCreate(new ObservableSource<Observable<Long>>(){
    @Override public void subscribe(    final Observer<? super Observable<Long>> observer){
      final Disposable upstream=Disposables.fromRunnable(new Runnable(){
        @Override public void run(){
          System.out.println("*** unsubscribed");
          unsubscribed.set(true);
        }
      }
);
      observer.onSubscribe(upstream);
      new Thread(new Runnable(){
        @Override public void run(){
          while (!unsubscribed.get()) {
            observer.onNext(Observable.just(1L,2L));
          }
          System.out.println("Done looping after unsubscribe: " + unsubscribed.get());
          observer.onComplete();
          latch.countDown();
        }
      }
).start();
    }
  }
);
  final AtomicInteger count=new AtomicInteger();
  Observable.merge(source).take(6).blockingForEach(new Consumer<Long>(){
    @Override public void accept(    Long v){
      System.out.println("Value: " + v);
      int c=count.incrementAndGet();
      if (c > 6) {
        fail("Should be only 6");
      }
    }
  }
);
  latch.await(1000,TimeUnit.MILLISECONDS);
  System.out.println("unsubscribed: " + unsubscribed.get());
  assertTrue(unsubscribed.get());
}
