@Test public void testSynchronizationOfMultipleSequences() throws Throwable {
  final TestASynchronousObservable o1=new TestASynchronousObservable();
  final TestASynchronousObservable o2=new TestASynchronousObservable();
  final CountDownLatch endLatch=new CountDownLatch(1);
  final AtomicInteger concurrentCounter=new AtomicInteger();
  final AtomicInteger totalCounter=new AtomicInteger();
  Observable<String> m=Observable.merge(Observable.unsafeCreate(o1),Observable.unsafeCreate(o2));
  m.subscribe(new DefaultObserver<String>(){
    @Override public void onComplete(){
    }
    @Override public void onError(    Throwable e){
      throw new RuntimeException("failed",e);
    }
    @Override public void onNext(    String v){
      totalCounter.incrementAndGet();
      concurrentCounter.incrementAndGet();
      try {
        if (Thread.currentThread().getName().equals("TestASynchronousObservable")) {
          endLatch.await();
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        throw new RuntimeException("failed",e);
      }
 finally {
        concurrentCounter.decrementAndGet();
      }
    }
  }
);
  o1.onNextBeingSent.await();
  o2.onNextBeingSent.await();
  int timeout=20;
  while (timeout-- > 0 && concurrentCounter.get() != 1) {
    Thread.sleep(100);
  }
  try {
    assertEquals(1,concurrentCounter.get());
  }
  finally {
    endLatch.countDown();
  }
  try {
    o1.t.join();
    o2.t.join();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  assertEquals(2,totalCounter.get());
  assertEquals(0,concurrentCounter.get());
}
