/** 
 * This is the same as the upstreams ones, but now adds the downstream as well by using observeOn. This requires merge to also obey the Product.request values coming from it's child Observer.
 * @throws InterruptedException if the test is interrupted
 */
@Test(timeout=10000) public void testBackpressureDownstreamWithConcurrentStreams() throws InterruptedException {
  final AtomicInteger generated1=new AtomicInteger();
  Observable<Integer> o1=createInfiniteObservable(generated1).subscribeOn(Schedulers.computation());
  final AtomicInteger generated2=new AtomicInteger();
  Observable<Integer> o2=createInfiniteObservable(generated2).subscribeOn(Schedulers.computation());
  TestObserver<Integer> to=new TestObserver<Integer>(){
    @Override public void onNext(    Integer t){
      if (t < 100) {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      super.onNext(t);
    }
  }
;
  Observable.merge(o1.take(Flowable.bufferSize() * 2),o2.take(Flowable.bufferSize() * 2)).observeOn(Schedulers.computation()).subscribe(to);
  to.awaitTerminalEvent();
  if (to.errors().size() > 0) {
    to.errors().get(0).printStackTrace();
  }
  to.assertNoErrors();
  System.err.println(to.values());
  assertEquals(Flowable.bufferSize() * 4,to.values().size());
  System.out.println("Generated 1: " + generated1.get());
  System.out.println("Generated 2: " + generated2.get());
  assertTrue(generated1.get() >= Flowable.bufferSize() * 2 && generated1.get() <= Flowable.bufferSize() * 4);
}
