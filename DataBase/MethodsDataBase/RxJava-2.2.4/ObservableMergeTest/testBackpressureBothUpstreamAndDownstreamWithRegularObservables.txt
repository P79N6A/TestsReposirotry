/** 
 * Currently there is no solution to this ... we can't exert backpressure on the outer Observable if we can't know if the ones we've received so far are going to emit or not, otherwise we could starve the system. For example, 10,000 Observables are being merged (bad use case to begin with, but ...) and it's only one of them that will ever emit. If backpressure only allowed the first 1,000 to be sent, we would hang and never receive an event. Thus, we must allow all Observables to be sent. The ScalarSynchronousObservable use case is an exception to this since we can grab the value synchronously.
 * @throws InterruptedException if the await is interrupted
 */
@Test(timeout=5000) public void testBackpressureBothUpstreamAndDownstreamWithRegularObservables() throws InterruptedException {
  final AtomicInteger generated1=new AtomicInteger();
  Observable<Observable<Integer>> o1=createInfiniteObservable(generated1).map(new Function<Integer,Observable<Integer>>(){
    @Override public Observable<Integer> apply(    Integer t1){
      return Observable.just(1,2,3);
    }
  }
);
  TestObserver<Integer> to=new TestObserver<Integer>(){
    int i;
    @Override public void onNext(    Integer t){
      if (i++ < 400) {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      super.onNext(t);
    }
  }
;
  Observable.merge(o1).observeOn(Schedulers.computation()).take(Flowable.bufferSize() * 2).subscribe(to);
  to.awaitTerminalEvent();
  if (to.errors().size() > 0) {
    to.errors().get(0).printStackTrace();
  }
  to.assertNoErrors();
  System.out.println("Generated 1: " + generated1.get());
  System.err.println(to.values());
  System.out.println("done1 testBackpressureBothUpstreamAndDownstreamWithRegularObservables ");
  assertEquals(Flowable.bufferSize() * 2,to.values().size());
  System.out.println("done2 testBackpressureBothUpstreamAndDownstreamWithRegularObservables ");
}
