/** 
 * Test that we receive the onError if an exception is thrown from an operator that does not have manual try/catch handling like map does.
 */
@Test @Ignore("Failed operator may leave the child subscriber in an inconsistent state which prevents further error delivery.") public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperator(){
  TestSubscriber<String> ts=new TestSubscriber<String>();
  Flowable.just(1).lift(new FlowableOperator<String,Integer>(){
    @Override public Subscriber<? super Integer> apply(    Subscriber<? super String> t1){
      throw new RuntimeException("failed");
    }
  }
).onErrorResumeNext(new Function<Throwable,Flowable<String>>(){
    @Override public Flowable<String> apply(    Throwable t1){
      if (t1.getMessage().equals("failed")) {
        return Flowable.just("success");
      }
 else {
        return Flowable.error(t1);
      }
    }
  }
).subscribe(ts);
  ts.assertTerminated();
  System.out.println(ts.values());
  ts.assertValue("success");
}
