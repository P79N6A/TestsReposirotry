/** 
 * Attempts to confirm that when pauses exist between events, the ScheduledObserver does not lose or reorder any events since the scheduler will not block, but will be re-scheduled when it receives new events after each pause. This is non-deterministic in proving success, but if it ever fails (non-deterministically) it is a sign of potential issues as thread-races and scheduling should not affect output.
 */
@Test public void testObserveOnOrderingConcurrency(){
  final AtomicInteger count=new AtomicInteger();
  final int _multiple=99;
  Observable.range(1,10000).map(new Function<Integer,Integer>(){
    @Override public Integer apply(    Integer t1){
      if (randomIntFrom0to100() > 98) {
        try {
          Thread.sleep(2);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      return t1 * _multiple;
    }
  }
).observeOn(Schedulers.computation()).blockingForEach(new Consumer<Integer>(){
    @Override public void accept(    Integer t1){
      assertEquals(count.incrementAndGet() * _multiple,t1.intValue());
      String name=Thread.currentThread().getName();
      assertFalse("Wrong thread name: " + name,name.startsWith("Rx"));
    }
  }
);
}
