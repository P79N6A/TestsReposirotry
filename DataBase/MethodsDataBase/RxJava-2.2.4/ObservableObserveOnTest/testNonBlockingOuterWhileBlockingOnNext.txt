@Test public void testNonBlockingOuterWhileBlockingOnNext() throws InterruptedException {
  final CountDownLatch completedLatch=new CountDownLatch(1);
  final CountDownLatch nextLatch=new CountDownLatch(1);
  final AtomicLong completeTime=new AtomicLong();
  Observable.range(1,2).subscribeOn(Schedulers.newThread()).observeOn(Schedulers.newThread()).subscribe(new DefaultObserver<Integer>(){
    @Override public void onComplete(){
      System.out.println("onComplete");
      completeTime.set(System.nanoTime());
      completedLatch.countDown();
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    Integer t){
      try {
        if (!nextLatch.await(1000,TimeUnit.MILLISECONDS)) {
          throw new RuntimeException("it shouldn't have timed out");
        }
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("it shouldn't have failed");
      }
    }
  }
);
  long afterSubscribeTime=System.nanoTime();
  System.out.println("After subscribe: " + completedLatch.getCount());
  assertEquals(1,completedLatch.getCount());
  nextLatch.countDown();
  completedLatch.await(1000,TimeUnit.MILLISECONDS);
  assertTrue(completeTime.get() > afterSubscribeTime);
  System.out.println("onComplete nanos after subscribe: " + (completeTime.get() - afterSubscribeTime));
}
