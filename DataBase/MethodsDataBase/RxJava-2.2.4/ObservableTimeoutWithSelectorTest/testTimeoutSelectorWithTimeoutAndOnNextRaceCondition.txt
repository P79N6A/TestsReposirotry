@Test public void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {
  final CountDownLatch observerReceivedTwo=new CountDownLatch(1);
  final CountDownLatch timeoutEmittedOne=new CountDownLatch(1);
  final CountDownLatch observerCompleted=new CountDownLatch(1);
  final CountDownLatch enteredTimeoutOne=new CountDownLatch(1);
  final AtomicBoolean latchTimeout=new AtomicBoolean(false);
  final Function<Integer,Observable<Integer>> timeoutFunc=new Function<Integer,Observable<Integer>>(){
    @Override public Observable<Integer> apply(    Integer t1){
      if (t1 == 1) {
        return Observable.unsafeCreate(new ObservableSource<Integer>(){
          @Override public void subscribe(          Observer<? super Integer> observer){
            observer.onSubscribe(Disposables.empty());
            enteredTimeoutOne.countDown();
            while (true) {
              try {
                if (!observerReceivedTwo.await(30,TimeUnit.SECONDS)) {
                  latchTimeout.set(true);
                }
                break;
              }
 catch (              InterruptedException e) {
              }
            }
            observer.onNext(1);
            timeoutEmittedOne.countDown();
          }
        }
).subscribeOn(Schedulers.newThread());
      }
 else {
        return PublishSubject.create();
      }
    }
  }
;
  final Observer<Integer> o=TestHelper.mockObserver();
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      observerReceivedTwo.countDown();
      return null;
    }
  }
).when(o).onNext(2);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      observerCompleted.countDown();
      return null;
    }
  }
).when(o).onComplete();
  final TestObserver<Integer> to=new TestObserver<Integer>(o);
  new Thread(new Runnable(){
    @Override public void run(){
      PublishSubject<Integer> source=PublishSubject.create();
      source.timeout(timeoutFunc,Observable.just(3)).subscribe(to);
      source.onNext(1);
      try {
        if (!enteredTimeoutOne.await(30,TimeUnit.SECONDS)) {
          latchTimeout.set(true);
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      source.onNext(2);
      try {
        if (!timeoutEmittedOne.await(30,TimeUnit.SECONDS)) {
          latchTimeout.set(true);
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      source.onComplete();
    }
  }
).start();
  if (!observerCompleted.await(30,TimeUnit.SECONDS)) {
    latchTimeout.set(true);
  }
  assertFalse("CoundDownLatch timeout",latchTimeout.get());
  InOrder inOrder=inOrder(o);
  inOrder.verify(o).onSubscribe((Disposable)notNull());
  inOrder.verify(o).onNext(1);
  inOrder.verify(o).onNext(2);
  inOrder.verify(o,never()).onNext(3);
  inOrder.verify(o).onComplete();
  inOrder.verifyNoMoreInteractions();
}
