@Test public void publishNoLeak2() throws Exception {
  System.gc();
  Thread.sleep(100);
  long start=ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
  source=Flowable.fromCallable(new Callable<Object>(){
    @Override public Object call() throws Exception {
      return new byte[100 * 1000 * 1000];
    }
  }
).concatWith(Flowable.never()).publish().refCount();
  Disposable d1=source.test();
  Disposable d2=source.test();
  d1.dispose();
  d2.dispose();
  d1=null;
  d2=null;
  System.gc();
  Thread.sleep(100);
  long after=ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
  source=null;
  assertTrue(String.format("%,3d -> %,3d%n",start,after),start + 20 * 1000 * 1000 > after);
}
