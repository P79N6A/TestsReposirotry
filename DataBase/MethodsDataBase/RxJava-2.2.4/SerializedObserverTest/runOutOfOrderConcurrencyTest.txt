/** 
 * A non-realistic use case that tries to expose thread-safety issues by throwing lots of out-of-order events on many threads.
 */
@Test public void runOutOfOrderConcurrencyTest(){
  ExecutorService tp=Executors.newFixedThreadPool(20);
  List<Throwable> errors=TestHelper.trackPluginErrors();
  try {
    TestConcurrencySubscriber tw=new TestConcurrencySubscriber();
    Observer<String> w=serializedObserver(new SafeObserver<String>(tw));
    Future<?> f1=tp.submit(new OnNextThread(w,12000));
    Future<?> f2=tp.submit(new OnNextThread(w,5000));
    Future<?> f3=tp.submit(new OnNextThread(w,75000));
    Future<?> f4=tp.submit(new OnNextThread(w,13500));
    Future<?> f5=tp.submit(new OnNextThread(w,22000));
    Future<?> f6=tp.submit(new OnNextThread(w,15000));
    Future<?> f7=tp.submit(new OnNextThread(w,7500));
    Future<?> f8=tp.submit(new OnNextThread(w,23500));
    Future<?> f10=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onComplete,f1,f2,f3,f4));
    try {
      Thread.sleep(1);
    }
 catch (    InterruptedException e) {
    }
    Future<?> f11=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onComplete,f4,f6,f7));
    Future<?> f12=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onComplete,f4,f6,f7));
    Future<?> f13=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onComplete,f4,f6,f7));
    Future<?> f14=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onComplete,f4,f6,f7));
    Future<?> f15=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onError,f1,f2,f3,f4));
    Future<?> f16=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onError,f1,f2,f3,f4));
    Future<?> f17=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onError,f1,f2,f3,f4));
    Future<?> f18=tp.submit(new CompletionThread(w,TestConcurrencySubscriberEvent.onError,f1,f2,f3,f4));
    waitOnThreads(f1,f2,f3,f4,f5,f6,f7,f8,f10,f11,f12,f13,f14,f15,f16,f17,f18);
    @SuppressWarnings("unused") int numNextEvents=tw.assertEvents(null);
    for (int i=0; i < errors.size(); i++) {
      TestHelper.assertUndeliverable(errors,i,RuntimeException.class);
    }
  }
 catch (  Throwable e) {
    fail("Concurrency test failed: " + e.getMessage());
    e.printStackTrace();
  }
 finally {
    tp.shutdown();
    try {
      tp.awaitTermination(5000,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    RxJavaPlugins.reset();
  }
}
