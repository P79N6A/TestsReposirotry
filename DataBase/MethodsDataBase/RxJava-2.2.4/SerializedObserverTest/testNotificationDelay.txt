/** 
 * Test that a notification does not get delayed in the queue waiting for the next event to push it through.
 * @throws InterruptedException if the await is interrupted
 */
@Ignore("this is non-deterministic ... haven't figured out what's wrong with the test yet (benjchristensen: July 2014)") @Test public void testNotificationDelay() throws InterruptedException {
  ExecutorService tp1=Executors.newFixedThreadPool(1);
  ExecutorService tp2=Executors.newFixedThreadPool(1);
  try {
    int n=10;
    for (int i=0; i < n; i++) {
      final CountDownLatch firstOnNext=new CountDownLatch(1);
      final CountDownLatch onNextCount=new CountDownLatch(2);
      final CountDownLatch latch=new CountDownLatch(1);
      final CountDownLatch running=new CountDownLatch(2);
      TestObserver<String> to=new TestObserver<String>(new DefaultObserver<String>(){
        @Override public void onComplete(){
        }
        @Override public void onError(        Throwable e){
        }
        @Override public void onNext(        String t){
          firstOnNext.countDown();
          try {
            latch.await();
          }
 catch (          InterruptedException e) {
          }
        }
      }
);
      Observer<String> o=serializedObserver(to);
      Future<?> f1=tp1.submit(new OnNextThread(o,1,onNextCount,running));
      Future<?> f2=tp2.submit(new OnNextThread(o,1,onNextCount,running));
      running.await();
      firstOnNext.await();
      Thread t1=to.lastThread();
      System.out.println("first onNext on thread: " + t1);
      latch.countDown();
      waitOnThreads(f1,f2);
      assertEquals(2,to.valueCount());
      Thread t2=to.lastThread();
      System.out.println("second onNext on thread: " + t2);
      assertSame(t1,t2);
      System.out.println(to.values());
      o.onComplete();
      System.out.println(to.values());
    }
  }
  finally {
    tp1.shutdown();
    tp2.shutdown();
  }
}
