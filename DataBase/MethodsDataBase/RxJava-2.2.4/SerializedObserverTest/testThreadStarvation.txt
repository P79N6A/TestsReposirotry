/** 
 * Demonstrates thread starvation problem. No solution on this for now. Trade-off in this direction as per https://github.com/ReactiveX/RxJava/issues/998#issuecomment-38959474 Probably need backpressure for this to work When using SynchronizedSubscriber we get this output: p1: 18 p2: 68 => should be close to each other unless we have thread starvation When using SerializedObserver we get: p1: 1 p2: 2445261 => should be close to each other unless we have thread starvation This demonstrates how SynchronizedSubscriber balances back and forth better, and blocks emission. The real issue in this example is the async buffer-bloat, so we need backpressure.
 * @throws InterruptedException if the await is interrupted
 */
@Ignore("Demonstrates thread starvation problem. Read JavaDoc") @Test public void testThreadStarvation() throws InterruptedException {
  TestObserver<String> to=new TestObserver<String>(new DefaultObserver<String>(){
    @Override public void onComplete(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    String t){
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
);
  final Observer<String> o=serializedObserver(to);
  AtomicInteger p1=new AtomicInteger();
  AtomicInteger p2=new AtomicInteger();
  o.onSubscribe(Disposables.empty());
  DisposableObserver<String> as1=new DisposableObserver<String>(){
    @Override public void onNext(    String t){
      o.onNext(t);
    }
    @Override public void onError(    Throwable t){
      RxJavaPlugins.onError(t);
    }
    @Override public void onComplete(){
    }
  }
;
  DisposableObserver<String> as2=new DisposableObserver<String>(){
    @Override public void onNext(    String t){
      o.onNext(t);
    }
    @Override public void onError(    Throwable t){
      RxJavaPlugins.onError(t);
    }
    @Override public void onComplete(){
    }
  }
;
  infinite(p1).subscribe(as1);
  infinite(p2).subscribe(as2);
  Thread.sleep(100);
  System.out.println("p1: " + p1.get() + " p2: "+ p2.get()+ " => should be close to each other unless we have thread starvation");
  assertEquals(p1.get(),p2.get(),10000);
  as1.dispose();
  as2.dispose();
}
