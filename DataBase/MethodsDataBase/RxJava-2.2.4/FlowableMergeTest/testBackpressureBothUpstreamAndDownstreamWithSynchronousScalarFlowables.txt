@Test public void testBackpressureBothUpstreamAndDownstreamWithSynchronousScalarFlowables() throws InterruptedException {
  final AtomicInteger generated1=new AtomicInteger();
  Flowable<Flowable<Integer>> f1=createInfiniteFlowable(generated1).map(new Function<Integer,Flowable<Integer>>(){
    @Override public Flowable<Integer> apply(    Integer t1){
      return Flowable.just(t1);
    }
  }
);
  TestSubscriber<Integer> testSubscriber=new TestSubscriber<Integer>(){
    @Override public void onNext(    Integer t){
      if (t < 100) {
        try {
          Thread.sleep(2);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      super.onNext(t);
    }
  }
;
  Flowable.merge(f1).observeOn(Schedulers.computation()).take(Flowable.bufferSize() * 2).subscribe(testSubscriber);
  testSubscriber.awaitTerminalEvent();
  if (testSubscriber.errors().size() > 0) {
    testSubscriber.errors().get(0).printStackTrace();
  }
  testSubscriber.assertNoErrors();
  System.out.println("Generated 1: " + generated1.get());
  System.err.println(testSubscriber.values());
  assertEquals(Flowable.bufferSize() * 2,testSubscriber.values().size());
  assertTrue(generated1.get() >= Flowable.bufferSize() * 2 && generated1.get() <= Flowable.bufferSize() * 4);
}
