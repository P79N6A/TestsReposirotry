@Test(timeout=1000) public void testUnSubscribeFlowableOfFlowables() throws InterruptedException {
  final AtomicBoolean unsubscribed=new AtomicBoolean();
  final CountDownLatch latch=new CountDownLatch(1);
  Flowable<Flowable<Long>> source=Flowable.unsafeCreate(new Publisher<Flowable<Long>>(){
    @Override public void subscribe(    final Subscriber<? super Flowable<Long>> subscriber){
      final Subscription s=new Subscription(){
        @Override public void request(        long n){
        }
        @Override public void cancel(){
          System.out.println("*** unsubscribed");
          unsubscribed.set(true);
        }
      }
;
      subscriber.onSubscribe(s);
      new Thread(new Runnable(){
        @Override public void run(){
          while (!unsubscribed.get()) {
            subscriber.onNext(Flowable.just(1L,2L));
          }
          System.out.println("Done looping after unsubscribe: " + unsubscribed.get());
          subscriber.onComplete();
          latch.countDown();
        }
      }
).start();
    }
  }
);
  final AtomicInteger count=new AtomicInteger();
  Flowable.merge(source).take(6).blockingForEach(new Consumer<Long>(){
    @Override public void accept(    Long v){
      System.out.println("Value: " + v);
      int c=count.incrementAndGet();
      if (c > 6) {
        fail("Should be only 6");
      }
    }
  }
);
  latch.await(1000,TimeUnit.MILLISECONDS);
  System.out.println("unsubscribed: " + unsubscribed.get());
  assertTrue(unsubscribed.get());
}
