@Test public void testSynchronizationOfMultipleSequences() throws Throwable {
  final TestASynchronousFlowable f1=new TestASynchronousFlowable();
  final TestASynchronousFlowable f2=new TestASynchronousFlowable();
  final CountDownLatch endLatch=new CountDownLatch(1);
  final AtomicInteger concurrentCounter=new AtomicInteger();
  final AtomicInteger totalCounter=new AtomicInteger();
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  Flowable<String> m=Flowable.merge(Flowable.unsafeCreate(f1),Flowable.unsafeCreate(f2));
  m.subscribe(new DefaultSubscriber<String>(){
    @Override public void onComplete(){
    }
    @Override public void onError(    Throwable e){
      error.set(e);
    }
    @Override public void onNext(    String v){
      totalCounter.incrementAndGet();
      concurrentCounter.incrementAndGet();
      try {
        if (Thread.currentThread().getName().equals("TestASynchronousFlowable")) {
          endLatch.await();
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        throw new RuntimeException("failed",e);
      }
 finally {
        concurrentCounter.decrementAndGet();
      }
    }
  }
);
  f1.onNextBeingSent.await();
  f2.onNextBeingSent.await();
  int timeout=20;
  while (timeout-- > 0 && concurrentCounter.get() != 1) {
    Thread.sleep(100);
  }
  try {
    if (error.get() != null) {
      throw ExceptionHelper.wrapOrThrow(error.get());
    }
    assertEquals(1,concurrentCounter.get());
  }
  finally {
    endLatch.countDown();
  }
  try {
    f1.t.join();
    f2.t.join();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  assertEquals(2,totalCounter.get());
  assertEquals(0,concurrentCounter.get());
}
