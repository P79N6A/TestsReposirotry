@Test public void testReplaySubjectEmissionSubscriptionRace() throws Exception {
  Scheduler s=Schedulers.io();
  Scheduler.Worker worker=Schedulers.io().createWorker();
  try {
    for (int i=0; i < 50000; i++) {
      if (i % 1000 == 0) {
        System.out.println(i);
      }
      final ReplayProcessor<Object> rs=ReplayProcessor.create();
      final CountDownLatch finish=new CountDownLatch(1);
      final CountDownLatch start=new CountDownLatch(1);
      worker.schedule(new Runnable(){
        @Override public void run(){
          try {
            start.await();
          }
 catch (          Exception e1) {
            e1.printStackTrace();
          }
          rs.onNext(1);
        }
      }
);
      final AtomicReference<Object> o=new AtomicReference<Object>();
      rs.subscribeOn(s).observeOn(Schedulers.io()).subscribe(new DefaultSubscriber<Object>(){
        @Override public void onComplete(){
          o.set(-1);
          finish.countDown();
        }
        @Override public void onError(        Throwable e){
          o.set(e);
          finish.countDown();
        }
        @Override public void onNext(        Object t){
          o.set(t);
          finish.countDown();
        }
      }
);
      start.countDown();
      if (!finish.await(5,TimeUnit.SECONDS)) {
        System.out.println(o.get());
        System.out.println(rs.hasSubscribers());
        rs.onComplete();
        Assert.fail("Timeout @ " + i);
        break;
      }
 else {
        Assert.assertEquals(1,o.get());
        worker.schedule(new Runnable(){
          @Override public void run(){
            rs.onComplete();
          }
        }
);
      }
    }
  }
  finally {
    worker.dispose();
  }
}
