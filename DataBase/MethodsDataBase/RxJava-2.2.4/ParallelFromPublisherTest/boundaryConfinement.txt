@Test public void boundaryConfinement(){
  final Set<String> between=new HashSet<String>();
  final ConcurrentHashMap<String,String> processing=new ConcurrentHashMap<String,String>();
  Flowable.range(1,10).observeOn(Schedulers.single(),false,1).doOnNext(new Consumer<Integer>(){
    @Override public void accept(    Integer v) throws Exception {
      between.add(Thread.currentThread().getName());
    }
  }
).parallel(2,1).runOn(Schedulers.computation(),1).map(new Function<Integer,Object>(){
    @Override public Object apply(    Integer v) throws Exception {
      processing.putIfAbsent(Thread.currentThread().getName(),"");
      return v;
    }
  }
).sequential().test().awaitDone(5,TimeUnit.SECONDS).assertSubscribed().assertValueSet(Arrays.asList(1,2,3,4,5,6,7,8,9,10)).assertComplete().assertNoErrors();
  assertEquals(between.toString(),1,between.size());
  assertTrue(between.toString(),between.iterator().next().contains("RxSingleScheduler"));
  Map<String,String> map=processing;
  for (  String e : map.keySet()) {
    assertTrue(map.toString(),e.contains("RxComputationThreadPool"));
  }
}
