/** 
 * This is a regression test for #1702. Concurrent work scheduling that is improperly synchronized can cause an action to be added or removed onto the priority queue during a poll, which can result in NPEs during queue sifting. While it is difficult to isolate the issue directly, we can easily trigger the behavior by spamming the trampoline with enqueue requests from multiple threads concurrently.
 */
@Test public void testTrampolineWorkerHandlesConcurrentScheduling(){
  final Worker trampolineWorker=Schedulers.trampoline().createWorker();
  final Subscriber<Object> subscriber=TestHelper.mockSubscriber();
  final TestSubscriber<Disposable> ts=new TestSubscriber<Disposable>(subscriber);
  Flowable.range(0,50).flatMap(new Function<Integer,Publisher<Disposable>>(){
    @Override public Publisher<Disposable> apply(    Integer count){
      return Flowable.interval(1,TimeUnit.MICROSECONDS).map(new Function<Long,Disposable>(){
        @Override public Disposable apply(        Long ount1){
          return trampolineWorker.schedule(Functions.EMPTY_RUNNABLE);
        }
      }
).take(100);
    }
  }
).subscribeOn(Schedulers.computation()).subscribe(ts);
  ts.awaitTerminalEvent();
  ts.assertNoErrors();
}
