/** 
 * The error from the user provided Observer is not handled by the subscribe method try/catch. It is handled by the AtomicObserver that wraps the provided Observer. Result: Passes (if AtomicObserver functionality exists)
 * @throws InterruptedException if the test is interrupted
 */
@Test public void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicInteger count=new AtomicInteger();
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  Flowable.just("1","2","three","4").subscribeOn(Schedulers.newThread()).safeSubscribe(new DefaultSubscriber<String>(){
    @Override public void onComplete(){
      System.out.println("completed");
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      error.set(e);
      System.out.println("error");
      e.printStackTrace();
      latch.countDown();
    }
    @Override public void onNext(    String v){
      int num=Integer.parseInt(v);
      System.out.println(num);
      count.incrementAndGet();
    }
  }
);
  latch.await();
  assertEquals(2,count.get());
  assertNotNull(error.get());
  if (!(error.get() instanceof NumberFormatException)) {
    fail("It should be a NumberFormatException");
  }
}
