/** 
 * The error from the user provided Observable is handled by the subscribe try/catch because this is synchronous. Result: Passes
 */
@Test public void testCustomObservableWithErrorInObservableSynchronous(){
  final AtomicInteger count=new AtomicInteger();
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  Flowable.just("1","2").concatWith(Flowable.<String>error(new Callable<Throwable>(){
    @Override public Throwable call(){
      return new NumberFormatException();
    }
  }
)).subscribe(new DefaultSubscriber<String>(){
    @Override public void onComplete(){
      System.out.println("completed");
    }
    @Override public void onError(    Throwable e){
      error.set(e);
      System.out.println("error");
      e.printStackTrace();
    }
    @Override public void onNext(    String v){
      System.out.println(v);
      count.incrementAndGet();
    }
  }
);
  assertEquals(2,count.get());
  assertNotNull(error.get());
  if (!(error.get() instanceof NumberFormatException)) {
    fail("It should be a NumberFormatException");
  }
}
