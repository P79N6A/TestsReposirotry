/** 
 * Make sure an asynchronous reduce with flatMap works. Original Reactor-Core test case: https://gist.github.com/jurna/353a2bd8ff83f0b24f0b5bc772077d61
 */
@Test public void shouldReduceTo10EventsFlowable(){
  final AtomicInteger count=new AtomicInteger();
  Flowable.range(0,10).flatMap(new Function<Integer,Publisher<String>>(){
    @Override public Publisher<String> apply(    final Integer x) throws Exception {
      return Flowable.range(0,2).map(new Function<Integer,String>(){
        @Override public String apply(        Integer y) throws Exception {
          return blockingOp(x,y);
        }
      }
).subscribeOn(Schedulers.io()).reduce(new BiFunction<String,String,String>(){
        @Override public String apply(        String l,        String r) throws Exception {
          return l + "_" + r;
        }
      }
).toFlowable().doOnNext(new Consumer<String>(){
        @Override public void accept(        String s) throws Exception {
          count.incrementAndGet();
          System.out.println("Completed with " + s);
        }
      }
);
    }
  }
).blockingLast();
  assertEquals(10,count.get());
}
