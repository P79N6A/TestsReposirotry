/** 
 * Test an async Flowable that emits more async Observables.
 * @throws InterruptedException if the test is interrupted
 */
@Test public void testNestedAsyncConcat() throws InterruptedException {
  Subscriber<String> subscriber=TestHelper.mockSubscriber();
  final TestObservable<String> o1=new TestObservable<String>("one","two","three");
  final TestObservable<String> o2=new TestObservable<String>("four","five","six");
  final TestObservable<String> o3=new TestObservable<String>("seven","eight","nine");
  final CountDownLatch allowThird=new CountDownLatch(1);
  final AtomicReference<Thread> parent=new AtomicReference<Thread>();
  final CountDownLatch parentHasStarted=new CountDownLatch(1);
  final CountDownLatch parentHasFinished=new CountDownLatch(1);
  Flowable<Flowable<String>> observableOfObservables=Flowable.unsafeCreate(new Publisher<Flowable<String>>(){
    @Override public void subscribe(    final Subscriber<? super Flowable<String>> subscriber){
      final Disposable d=Disposables.empty();
      subscriber.onSubscribe(new Subscription(){
        @Override public void request(        long n){
        }
        @Override public void cancel(){
          d.dispose();
        }
      }
);
      parent.set(new Thread(new Runnable(){
        @Override public void run(){
          try {
            if (!d.isDisposed()) {
              System.out.println("Emit o1");
              subscriber.onNext(Flowable.unsafeCreate(o1));
            }
            if (!d.isDisposed()) {
              System.out.println("Emit o2");
              subscriber.onNext(Flowable.unsafeCreate(o2));
            }
            try {
              allowThird.await();
            }
 catch (            InterruptedException e) {
              subscriber.onError(e);
            }
            if (!d.isDisposed()) {
              System.out.println("Emit o3");
              subscriber.onNext(Flowable.unsafeCreate(o3));
            }
          }
 catch (          Throwable e) {
            subscriber.onError(e);
          }
 finally {
            System.out.println("Done parent Flowable");
            subscriber.onComplete();
            parentHasFinished.countDown();
          }
        }
      }
));
      parent.get().start();
      parentHasStarted.countDown();
    }
  }
);
  Flowable.concat(observableOfObservables).subscribe(subscriber);
  parentHasStarted.await();
  try {
    System.out.println("Thread1 is starting ... waiting for it to complete ...");
    o1.waitForThreadDone();
    System.out.println("Thread2 is starting ... waiting for it to complete ...");
    o2.waitForThreadDone();
  }
 catch (  Throwable e) {
    throw new RuntimeException("failed waiting on threads",e);
  }
  InOrder inOrder=inOrder(subscriber);
  inOrder.verify(subscriber,times(1)).onNext("one");
  inOrder.verify(subscriber,times(1)).onNext("two");
  inOrder.verify(subscriber,times(1)).onNext("three");
  inOrder.verify(subscriber,times(1)).onNext("four");
  inOrder.verify(subscriber,times(1)).onNext("five");
  inOrder.verify(subscriber,times(1)).onNext("six");
  inOrder.verify(subscriber,never()).onNext("seven");
  inOrder.verify(subscriber,never()).onNext("eight");
  inOrder.verify(subscriber,never()).onNext("nine");
  verify(subscriber,never()).onComplete();
  verify(subscriber,never()).onError(any(Throwable.class));
  allowThird.countDown();
  try {
    o3.waitForThreadDone();
  }
 catch (  Throwable e) {
    throw new RuntimeException("failed waiting on threads",e);
  }
  try {
    if (!parentHasFinished.await(5,TimeUnit.SECONDS)) {
      fail("Parent didn't finish within the time limit");
    }
  }
 catch (  Throwable e) {
    throw new RuntimeException("failed waiting on threads",e);
  }
  inOrder.verify(subscriber,times(1)).onNext("seven");
  inOrder.verify(subscriber,times(1)).onNext("eight");
  inOrder.verify(subscriber,times(1)).onNext("nine");
  verify(subscriber,never()).onError(any(Throwable.class));
  inOrder.verify(subscriber,times(1)).onComplete();
}
