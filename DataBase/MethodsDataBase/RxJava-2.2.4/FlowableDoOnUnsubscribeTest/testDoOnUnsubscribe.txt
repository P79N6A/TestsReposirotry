@Test public void testDoOnUnsubscribe() throws Exception {
  int subCount=3;
  final CountDownLatch upperLatch=new CountDownLatch(subCount);
  final CountDownLatch lowerLatch=new CountDownLatch(subCount);
  final CountDownLatch onNextLatch=new CountDownLatch(subCount);
  final AtomicInteger upperCount=new AtomicInteger();
  final AtomicInteger lowerCount=new AtomicInteger();
  Flowable<Long> longs=Flowable.interval(50,TimeUnit.MILLISECONDS).doOnCancel(new Action(){
    @Override public void run(){
      upperLatch.countDown();
      upperCount.incrementAndGet();
    }
  }
).doOnNext(new Consumer<Long>(){
    @Override public void accept(    Long aLong){
      onNextLatch.countDown();
    }
  }
).doOnCancel(new Action(){
    @Override public void run(){
      lowerLatch.countDown();
      lowerCount.incrementAndGet();
    }
  }
);
  List<Disposable> subscriptions=new ArrayList<Disposable>();
  List<TestSubscriber<Long>> subscribers=new ArrayList<TestSubscriber<Long>>();
  for (int i=0; i < subCount; ++i) {
    TestSubscriber<Long> subscriber=new TestSubscriber<Long>();
    subscriptions.add(subscriber);
    longs.subscribe(subscriber);
    subscribers.add(subscriber);
  }
  onNextLatch.await();
  for (int i=0; i < subCount; ++i) {
    subscriptions.get(i).dispose();
  }
  upperLatch.await();
  lowerLatch.await();
  assertEquals(String.format("There should exactly %d un-subscription events for upper stream",subCount),subCount,upperCount.get());
  assertEquals(String.format("There should exactly %d un-subscription events for lower stream",subCount),subCount,lowerCount.get());
}
