/** 
 * Test that we receive the onError if an exception is thrown from an operator that does not have manual try/catch handling like map does.
 */
@Test @Ignore("A crashing operator may leave the downstream in an inconsistent state and not suitable for event delivery") public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperatorOnNext(){
  TestObserver<String> to=new TestObserver<String>();
  Observable.just(1).lift(new ObservableOperator<String,Integer>(){
    @Override public Observer<? super Integer> apply(    final Observer<? super String> t1){
      return new Observer<Integer>(){
        @Override public void onSubscribe(        Disposable d){
          t1.onSubscribe(d);
        }
        @Override public void onComplete(){
          throw new RuntimeException("failed");
        }
        @Override public void onError(        Throwable e){
          throw new RuntimeException("failed");
        }
        @Override public void onNext(        Integer t){
          throw new RuntimeException("failed");
        }
      }
;
    }
  }
).onErrorResumeNext(new Function<Throwable,Observable<String>>(){
    @Override public Observable<String> apply(    Throwable t1){
      if (t1.getMessage().equals("failed")) {
        return Observable.just("success");
      }
 else {
        return Observable.error(t1);
      }
    }
  }
).subscribe(to);
  to.assertTerminated();
  System.out.println(to.values());
  to.assertValue("success");
}
