/** 
 * Test that we receive the onError if an exception is thrown from an operator that does not have manual try/catch handling like map does.
 */
@Test @Ignore("Failed operator may leave the child Observer in an inconsistent state which prevents further error delivery.") public void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperator(){
  TestObserver<String> to=new TestObserver<String>();
  Observable.just(1).lift(new ObservableOperator<String,Integer>(){
    @Override public Observer<? super Integer> apply(    Observer<? super String> t1){
      throw new RuntimeException("failed");
    }
  }
).onErrorResumeNext(new Function<Throwable,Observable<String>>(){
    @Override public Observable<String> apply(    Throwable t1){
      if (t1.getMessage().equals("failed")) {
        return Observable.just("success");
      }
 else {
        return Observable.error(t1);
      }
    }
  }
).subscribe(to);
  to.assertTerminated();
  System.out.println(to.values());
  to.assertValue("success");
}
