@Test public final void testSubscribeOnNestedConcurrency() throws InterruptedException {
  final Scheduler scheduler=getScheduler();
  Flowable<String> f=Flowable.fromArray("one","two","three","four","five","six","seven","eight","nine","ten").flatMap(new Function<String,Flowable<String>>(){
    @Override public Flowable<String> apply(    final String v){
      return Flowable.unsafeCreate(new Publisher<String>(){
        @Override public void subscribe(        Subscriber<? super String> subscriber){
          subscriber.onSubscribe(new BooleanSubscription());
          subscriber.onNext("value_after_map-" + v);
          subscriber.onComplete();
        }
      }
).subscribeOn(scheduler);
    }
  }
);
  ConcurrentObserverValidator<String> observer=new ConcurrentObserverValidator<String>();
  f.subscribe(observer);
  if (!observer.completed.await(3000,TimeUnit.MILLISECONDS)) {
    fail("timed out");
  }
  if (observer.error.get() != null) {
    observer.error.get().printStackTrace();
    fail("Error: " + observer.error.get().getMessage());
  }
}
