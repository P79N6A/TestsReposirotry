@Test public void testRecursionAndOuterUnsubscribe() throws InterruptedException {
  final CountDownLatch latch=new CountDownLatch(10);
  final CountDownLatch completionLatch=new CountDownLatch(1);
  final Worker inner=getScheduler().createWorker();
  try {
    Flowable<Integer> obs=Flowable.unsafeCreate(new Publisher<Integer>(){
      @Override public void subscribe(      final Subscriber<? super Integer> subscriber){
        inner.schedule(new Runnable(){
          @Override public void run(){
            subscriber.onNext(42);
            latch.countDown();
            inner.schedule(this);
          }
        }
);
        subscriber.onSubscribe(new Subscription(){
          @Override public void cancel(){
            inner.dispose();
            subscriber.onComplete();
            completionLatch.countDown();
          }
          @Override public void request(          long n){
          }
        }
);
      }
    }
);
    final AtomicInteger count=new AtomicInteger();
    final AtomicBoolean completed=new AtomicBoolean(false);
    ResourceSubscriber<Integer> s=new ResourceSubscriber<Integer>(){
      @Override public void onComplete(){
        System.out.println("Completed");
        completed.set(true);
      }
      @Override public void onError(      Throwable e){
        System.out.println("Error");
      }
      @Override public void onNext(      Integer args){
        count.incrementAndGet();
        System.out.println(args);
      }
    }
;
    obs.subscribe(s);
    if (!latch.await(5000,TimeUnit.MILLISECONDS)) {
      fail("Timed out waiting on onNext latch");
    }
    s.dispose();
    System.out.println("unsubscribe");
    if (!completionLatch.await(5000,TimeUnit.MILLISECONDS)) {
      fail("Timed out waiting on completion latch");
    }
    assertTrue(count.get() >= 10);
    assertTrue(completed.get());
  }
  finally {
    inner.dispose();
  }
}
