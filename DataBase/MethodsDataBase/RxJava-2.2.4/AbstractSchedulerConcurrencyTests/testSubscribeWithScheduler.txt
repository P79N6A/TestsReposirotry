@Test public final void testSubscribeWithScheduler() throws InterruptedException {
  final Scheduler scheduler=getScheduler();
  final AtomicInteger count=new AtomicInteger();
  Flowable<Integer> f1=Flowable.<Integer>just(1,2,3,4,5);
  f1.subscribe(new Consumer<Integer>(){
    @Override public void accept(    Integer t){
      System.out.println("Thread: " + Thread.currentThread().getName());
      System.out.println("t: " + t);
      count.incrementAndGet();
    }
  }
);
  assertEquals(5,count.get());
  count.set(0);
  final String currentThreadName=Thread.currentThread().getName();
  final CountDownLatch latch=new CountDownLatch(5);
  final CountDownLatch first=new CountDownLatch(1);
  f1.subscribeOn(scheduler).subscribe(new Consumer<Integer>(){
    @Override public void accept(    Integer t){
      try {
        first.await(1000,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("The latch should have released if we are async.",e);
      }
      assertFalse(Thread.currentThread().getName().equals(currentThreadName));
      System.out.println("Thread: " + Thread.currentThread().getName());
      System.out.println("t: " + t);
      count.incrementAndGet();
      latch.countDown();
    }
  }
);
  assertEquals(0,count.get());
  first.countDown();
  latch.await();
  assertEquals(5,count.get());
}
