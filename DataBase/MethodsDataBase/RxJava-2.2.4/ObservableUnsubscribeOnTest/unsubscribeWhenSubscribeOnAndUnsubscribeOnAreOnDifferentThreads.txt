@Test(timeout=5000) public void unsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnDifferentThreads() throws InterruptedException {
  UIEventLoopScheduler uiEventLoop=new UIEventLoopScheduler();
  try {
    final ThreadSubscription subscription=new ThreadSubscription();
    final AtomicReference<Thread> subscribeThread=new AtomicReference<Thread>();
    Observable<Integer> w=Observable.unsafeCreate(new ObservableSource<Integer>(){
      @Override public void subscribe(      Observer<? super Integer> t1){
        subscribeThread.set(Thread.currentThread());
        t1.onSubscribe(subscription);
        t1.onNext(1);
        t1.onNext(2);
      }
    }
);
    TestObserver<Integer> observer=new TestObserver<Integer>();
    w.subscribeOn(Schedulers.newThread()).observeOn(Schedulers.computation()).unsubscribeOn(uiEventLoop).take(2).subscribe(observer);
    observer.awaitTerminalEvent(1,TimeUnit.SECONDS);
    Thread unsubscribeThread=subscription.getThread();
    assertNotNull(unsubscribeThread);
    assertNotSame(Thread.currentThread(),unsubscribeThread);
    assertNotNull(subscribeThread.get());
    assertNotSame(Thread.currentThread(),subscribeThread.get());
    System.out.println("UI Thread: " + uiEventLoop.getThread());
    System.out.println("unsubscribeThread: " + unsubscribeThread);
    System.out.println("subscribeThread.get(): " + subscribeThread.get());
    assertSame(unsubscribeThread,uiEventLoop.getThread());
    observer.assertValues(1,2);
    observer.assertTerminated();
  }
  finally {
    uiEventLoop.shutdown();
  }
}
