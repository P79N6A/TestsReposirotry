/** 
 * Assert that unsubscribe propagates when passing in a SingleObserver and not a Subscriber.
 * @throws InterruptedException if the test is interrupted
 */
@Test public void testUnsubscribeViaReturnedSubscription() throws InterruptedException {
  final AtomicBoolean unsubscribed=new AtomicBoolean();
  final AtomicBoolean interrupted=new AtomicBoolean();
  final CountDownLatch latch=new CountDownLatch(2);
  Single<String> s1=Single.unsafeCreate(new SingleSource<String>(){
    @Override public void subscribe(    final SingleObserver<? super String> observer){
      SerialDisposable sd=new SerialDisposable();
      observer.onSubscribe(sd);
      final Thread t=new Thread(new Runnable(){
        @Override public void run(){
          try {
            Thread.sleep(5000);
            observer.onSuccess("success");
          }
 catch (          InterruptedException e) {
            interrupted.set(true);
            latch.countDown();
          }
        }
      }
);
      sd.replace(Disposables.fromRunnable(new Runnable(){
        @Override public void run(){
          unsubscribed.set(true);
          t.interrupt();
          latch.countDown();
        }
      }
));
      t.start();
    }
  }
);
  Disposable subscription=s1.subscribe();
  Thread.sleep(100);
  subscription.dispose();
  if (latch.await(1000,TimeUnit.MILLISECONDS)) {
    assertTrue(unsubscribed.get());
    assertTrue(interrupted.get());
  }
 else {
    fail("timed out waiting for latch");
  }
}
