@Test public void composeIfNotEmptyIsEmpty(){
  final FlowableTransformer<Integer,Integer> transformer=new FlowableTransformer<Integer,Integer>(){
    @Override public Publisher<Integer> apply(    Flowable<Integer> g){
      return g.map(new Function<Integer,Integer>(){
        @Override public Integer apply(        Integer v) throws Exception {
          return v + 1;
        }
      }
);
    }
  }
;
  final AtomicInteger calls=new AtomicInteger();
  Flowable.<Integer>empty().hide().publish(new Function<Flowable<Integer>,Publisher<Integer>>(){
    @Override public Publisher<Integer> apply(    final Flowable<Integer> shared) throws Exception {
      return shared.take(1).concatMap(new Function<Integer,Publisher<? extends Integer>>(){
        @Override public Publisher<? extends Integer> apply(        Integer first) throws Exception {
          calls.incrementAndGet();
          return transformer.apply(Flowable.just(first).concatWith(shared));
        }
      }
);
    }
  }
).test().assertResult();
  assertEquals(0,calls.get());
}
