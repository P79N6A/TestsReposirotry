@Test(timeout=2000) public void bufferWithStartEndBoundaryTake2(){
  Observable<Long> start=Observable.interval(61,61,TimeUnit.MILLISECONDS,scheduler);
  Function<Long,Observable<Long>> end=new Function<Long,Observable<Long>>(){
    @Override public Observable<Long> apply(    Long t1){
      return Observable.interval(100,100,TimeUnit.MILLISECONDS,scheduler);
    }
  }
;
  Observable<Long> source=Observable.interval(40,40,TimeUnit.MILLISECONDS,scheduler);
  Observable<List<Long>> result=source.buffer(start,end).take(2);
  Observer<Object> o=TestHelper.mockObserver();
  InOrder inOrder=inOrder(o);
  result.doOnNext(new Consumer<List<Long>>(){
    @Override public void accept(    List<Long> pv){
      System.out.println(pv);
    }
  }
).subscribe(o);
  scheduler.advanceTimeBy(5,TimeUnit.SECONDS);
  inOrder.verify(o).onNext(Arrays.asList(1L,2L,3L));
  inOrder.verify(o).onNext(Arrays.asList(3L,4L));
  inOrder.verify(o).onComplete();
  verify(o,never()).onError(any(Throwable.class));
}
