@Test public void testConvertToConcurrentQueue(){
  final AtomicReference<Throwable> thrown=new AtomicReference<Throwable>(null);
  final AtomicBoolean isFinished=new AtomicBoolean(false);
  ConcurrentLinkedQueue<? extends Integer> queue=Flowable.range(0,5).flatMap(new Function<Integer,Publisher<Integer>>(){
    @Override public Publisher<Integer> apply(    final Integer i){
      return Flowable.range(0,5).observeOn(Schedulers.io()).map(new Function<Integer,Integer>(){
        @Override public Integer apply(        Integer k){
          try {
            Thread.sleep(System.currentTimeMillis() % 100);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
          return i + k;
        }
      }
);
    }
  }
).to(new Function<Flowable<Integer>,ConcurrentLinkedQueue<Integer>>(){
    @Override public ConcurrentLinkedQueue<Integer> apply(    Flowable<Integer> onSubscribe){
      final ConcurrentLinkedQueue<Integer> q=new ConcurrentLinkedQueue<Integer>();
      onSubscribe.subscribe(new DefaultSubscriber<Integer>(){
        @Override public void onComplete(){
          isFinished.set(true);
        }
        @Override public void onError(        Throwable e){
          thrown.set(e);
        }
        @Override public void onNext(        Integer t){
          q.add(t);
        }
      }
);
      return q;
    }
  }
);
  int x=0;
  while (!isFinished.get()) {
    Integer i=queue.poll();
    if (i != null) {
      x++;
      System.out.println(x + " item: " + i);
    }
  }
  Assert.assertNull(thrown.get());
}
