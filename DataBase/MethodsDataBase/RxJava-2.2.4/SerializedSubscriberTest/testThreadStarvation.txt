/** 
 * Demonstrates thread starvation problem. No solution on this for now. Trade-off in this direction as per https://github.com/ReactiveX/RxJava/issues/998#issuecomment-38959474 Probably need backpressure for this to work When using SynchronizedSubscriber we get this output: p1: 18 p2: 68 => should be close to each other unless we have thread starvation When using SerializedSubscriber we get: p1: 1 p2: 2445261 => should be close to each other unless we have thread starvation This demonstrates how SynchronizedSubscriber balances back and forth better, and blocks emission. The real issue in this example is the async buffer-bloat, so we need backpressure.
 * @throws InterruptedException if the await is interrupted
 */
@Ignore("Demonstrates thread starvation problem. Read JavaDoc") @Test public void testThreadStarvation() throws InterruptedException {
  TestSubscriber<String> ts=new TestSubscriber<String>(new DefaultSubscriber<String>(){
    @Override public void onComplete(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    String t){
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
);
  final Subscriber<String> subscriber=serializedSubscriber(ts);
  AtomicInteger p1=new AtomicInteger();
  AtomicInteger p2=new AtomicInteger();
  subscriber.onSubscribe(new BooleanSubscription());
  ResourceSubscriber<String> as1=new ResourceSubscriber<String>(){
    @Override public void onNext(    String t){
      subscriber.onNext(t);
    }
    @Override public void onError(    Throwable t){
      RxJavaPlugins.onError(t);
    }
    @Override public void onComplete(){
    }
  }
;
  ResourceSubscriber<String> as2=new ResourceSubscriber<String>(){
    @Override public void onNext(    String t){
      subscriber.onNext(t);
    }
    @Override public void onError(    Throwable t){
      RxJavaPlugins.onError(t);
    }
    @Override public void onComplete(){
    }
  }
;
  infinite(p1).subscribe(as1);
  infinite(p2).subscribe(as2);
  Thread.sleep(100);
  System.out.println("p1: " + p1.get() + " p2: "+ p2.get()+ " => should be close to each other unless we have thread starvation");
  assertEquals(p1.get(),p2.get(),10000);
  as1.dispose();
  as2.dispose();
}
