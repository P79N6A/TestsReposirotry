@Test(timeout=5000) public void testConcurrentSizeAndHasAnyValue() throws InterruptedException {
  final ReplaySubject<Object> rs=ReplaySubject.createUnbounded();
  final CyclicBarrier cb=new CyclicBarrier(2);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        cb.await();
      }
 catch (      InterruptedException e) {
        return;
      }
catch (      BrokenBarrierException e) {
        return;
      }
      for (int i=0; i < 1000000; i++) {
        rs.onNext(i);
      }
      rs.onComplete();
      System.out.println("Replay fill Thread finished!");
    }
  }
);
  t.start();
  try {
    cb.await();
  }
 catch (  InterruptedException e) {
    return;
  }
catch (  BrokenBarrierException e) {
    return;
  }
  int lastSize=0;
  for (; !rs.hasThrowable() && !rs.hasComplete(); ) {
    int size=rs.size();
    boolean hasAny=rs.hasValue();
    Object[] values=rs.getValues();
    if (size < lastSize) {
      Assert.fail("Size decreased! " + lastSize + " -> "+ size);
    }
    if ((size > 0) && !hasAny) {
      Assert.fail("hasAnyValue reports emptyness but size doesn't");
    }
    if (size > values.length) {
      Assert.fail("Got fewer values than size! " + size + " -> "+ values.length);
    }
    for (int i=0; i < values.length - 1; i++) {
      Integer v1=(Integer)values[i];
      Integer v2=(Integer)values[i + 1];
      assertEquals(1,v2 - v1);
    }
    lastSize=size;
  }
  t.join();
}
