@Test public void supplierDisposeMainBoundaryCompleteRace(){
  for (int i=0; i < TestHelper.RACE_LONG_LOOPS; i++) {
    final AtomicReference<Observer<? super Object>> refMain=new AtomicReference<Observer<? super Object>>();
    final AtomicReference<Observer<? super Object>> ref=new AtomicReference<Observer<? super Object>>();
    final TestObserver<Observable<Object>> to=new Observable<Object>(){
      @Override protected void subscribeActual(      Observer<? super Object> observer){
        observer.onSubscribe(Disposables.empty());
        refMain.set(observer);
      }
    }
.window(Functions.justCallable(new Observable<Object>(){
      @Override protected void subscribeActual(      Observer<? super Object> observer){
        final AtomicInteger counter=new AtomicInteger();
        observer.onSubscribe(new Disposable(){
          @Override public void dispose(){
            for (int i=0; i < 100; i++) {
              counter.incrementAndGet();
            }
          }
          @Override public boolean isDisposed(){
            return false;
          }
        }
);
        ref.set(observer);
      }
    }
)).test();
    Runnable r1=new Runnable(){
      @Override public void run(){
        to.cancel();
      }
    }
;
    Runnable r2=new Runnable(){
      @Override public void run(){
        Observer<Object> o=ref.get();
        o.onNext(1);
        o.onComplete();
      }
    }
;
    TestHelper.race(r1,r2);
  }
}
