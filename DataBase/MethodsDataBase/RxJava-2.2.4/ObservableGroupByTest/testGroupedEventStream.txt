/** 
 * Assert that only a single subscription to a stream occurs and that all events are received.
 * @throws Throwable some method may throw
 */
@Test public void testGroupedEventStream() throws Throwable {
  final AtomicInteger eventCounter=new AtomicInteger();
  final AtomicInteger subscribeCounter=new AtomicInteger();
  final AtomicInteger groupCounter=new AtomicInteger();
  final CountDownLatch latch=new CountDownLatch(1);
  final int count=100;
  final int groupCount=2;
  Observable<Event> es=Observable.unsafeCreate(new ObservableSource<Event>(){
    @Override public void subscribe(    final Observer<? super Event> observer){
      observer.onSubscribe(Disposables.empty());
      System.out.println("*** Subscribing to EventStream ***");
      subscribeCounter.incrementAndGet();
      new Thread(new Runnable(){
        @Override public void run(){
          for (int i=0; i < count; i++) {
            Event e=new Event();
            e.source=i % groupCount;
            e.message="Event-" + i;
            observer.onNext(e);
          }
          observer.onComplete();
        }
      }
).start();
    }
  }
);
  es.groupBy(new Function<Event,Integer>(){
    @Override public Integer apply(    Event e){
      return e.source;
    }
  }
).flatMap(new Function<GroupedObservable<Integer,Event>,Observable<String>>(){
    @Override public Observable<String> apply(    GroupedObservable<Integer,Event> eventGroupedObservable){
      System.out.println("GroupedObservable Key: " + eventGroupedObservable.getKey());
      groupCounter.incrementAndGet();
      return eventGroupedObservable.map(new Function<Event,String>(){
        @Override public String apply(        Event event){
          return "Source: " + event.source + "  Message: "+ event.message;
        }
      }
);
    }
  }
).subscribe(new DefaultObserver<String>(){
    @Override public void onComplete(){
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      e.printStackTrace();
      latch.countDown();
    }
    @Override public void onNext(    String outputMessage){
      System.out.println(outputMessage);
      eventCounter.incrementAndGet();
    }
  }
);
  latch.await(5000,TimeUnit.MILLISECONDS);
  assertEquals(1,subscribeCounter.get());
  assertEquals(groupCount,groupCounter.get());
  assertEquals(count,eventCounter.get());
}
