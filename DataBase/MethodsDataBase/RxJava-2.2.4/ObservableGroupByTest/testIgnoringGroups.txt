@Test public void testIgnoringGroups(){
  final AtomicInteger subscribeCounter=new AtomicInteger();
  final AtomicInteger sentEventCounter=new AtomicInteger();
  final AtomicInteger eventCounter=new AtomicInteger();
  SYNC_INFINITE_OBSERVABLE_OF_EVENT(4,subscribeCounter,sentEventCounter).groupBy(new Function<Event,Integer>(){
    @Override public Integer apply(    Event e){
      return e.source;
    }
  }
).flatMap(new Function<GroupedObservable<Integer,Event>,Observable<String>>(){
    @Override public Observable<String> apply(    GroupedObservable<Integer,Event> eventGroupedObservable){
      Observable<Event> eventStream=eventGroupedObservable;
      if (eventGroupedObservable.getKey() >= 2) {
        eventStream=eventGroupedObservable.filter(new Predicate<Event>(){
          @Override public boolean test(          Event t1){
            return false;
          }
        }
);
      }
      return eventStream.map(new Function<Event,String>(){
        @Override public String apply(        Event event){
          return "testUnsubscribe => Source: " + event.source + "  Message: "+ event.message;
        }
      }
);
    }
  }
).take(30).subscribe(new Consumer<String>(){
    @Override public void accept(    String s){
      eventCounter.incrementAndGet();
      System.out.println("=> " + s);
    }
  }
);
  assertEquals(30,eventCounter.get());
  assertEquals(60,sentEventCounter.get());
}
