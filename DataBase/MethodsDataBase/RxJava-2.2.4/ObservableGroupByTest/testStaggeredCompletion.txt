@Test public void testStaggeredCompletion() throws InterruptedException {
  final AtomicInteger eventCounter=new AtomicInteger();
  final CountDownLatch latch=new CountDownLatch(1);
  Observable.range(0,100).groupBy(new Function<Integer,Integer>(){
    @Override public Integer apply(    Integer i){
      return i % 2;
    }
  }
).flatMap(new Function<GroupedObservable<Integer,Integer>,Observable<Integer>>(){
    @Override public Observable<Integer> apply(    GroupedObservable<Integer,Integer> group){
      if (group.getKey() == 0) {
        return group.delay(100,TimeUnit.MILLISECONDS).map(new Function<Integer,Integer>(){
          @Override public Integer apply(          Integer t){
            return t * 10;
          }
        }
);
      }
 else {
        return group;
      }
    }
  }
).subscribe(new DefaultObserver<Integer>(){
    @Override public void onComplete(){
      System.out.println("=> onComplete");
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      e.printStackTrace();
      latch.countDown();
    }
    @Override public void onNext(    Integer s){
      eventCounter.incrementAndGet();
      System.out.println("=> " + s);
    }
  }
);
  if (!latch.await(3000,TimeUnit.MILLISECONDS)) {
    fail("timed out");
  }
  assertEquals(100,eventCounter.get());
}
