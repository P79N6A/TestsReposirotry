@Test public void iterativeBackoff(){
  Observer<String> consumer=TestHelper.mockObserver();
  Observable<String> producer=Observable.unsafeCreate(new ObservableSource<String>(){
    private AtomicInteger count=new AtomicInteger(4);
    long last=System.currentTimeMillis();
    @Override public void subscribe(    Observer<? super String> t1){
      t1.onSubscribe(Disposables.empty());
      System.out.println(count.get() + " @ " + String.valueOf(last - System.currentTimeMillis()));
      last=System.currentTimeMillis();
      if (count.getAndDecrement() == 0) {
        t1.onNext("hello");
        t1.onComplete();
      }
 else {
        t1.onError(new RuntimeException());
      }
    }
  }
);
  TestObserver<String> to=new TestObserver<String>(consumer);
  producer.retryWhen(new Function<Observable<? extends Throwable>,Observable<Object>>(){
    @Override public Observable<Object> apply(    Observable<? extends Throwable> attempts){
      return attempts.map(new Function<Throwable,Tuple>(){
        @Override public Tuple apply(        Throwable n){
          return new Tuple(new Long(1),n);
        }
      }
).scan(new BiFunction<Tuple,Tuple,Tuple>(){
        @Override public Tuple apply(        Tuple t,        Tuple n){
          return new Tuple(t.count + n.count,n.n);
        }
      }
).flatMap(new Function<Tuple,Observable<Long>>(){
        @Override public Observable<Long> apply(        Tuple t){
          System.out.println("Retry # " + t.count);
          return t.count > 20 ? Observable.<Long>error(t.n) : Observable.timer(t.count * 1L,TimeUnit.MILLISECONDS);
        }
      }
).cast(Object.class);
    }
  }
).subscribe(to);
  to.awaitTerminalEvent();
  to.assertNoErrors();
  InOrder inOrder=inOrder(consumer);
  inOrder.verify(consumer,never()).onError(any(Throwable.class));
  inOrder.verify(consumer,times(1)).onNext("hello");
  inOrder.verify(consumer,times(1)).onComplete();
  inOrder.verifyNoMoreInteractions();
}
