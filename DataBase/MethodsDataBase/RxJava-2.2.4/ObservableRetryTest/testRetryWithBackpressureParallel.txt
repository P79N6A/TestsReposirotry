@Test public void testRetryWithBackpressureParallel() throws InterruptedException {
  final int NUM_LOOPS=1;
  final int NUM_RETRIES=Flowable.bufferSize() * 2;
  int ncpu=Runtime.getRuntime().availableProcessors();
  ExecutorService exec=Executors.newFixedThreadPool(Math.max(ncpu / 2,2));
  try {
    for (int r=0; r < NUM_LOOPS; r++) {
      if (r % 10 == 0) {
        System.out.println("testRetryWithBackpressureParallelLoop -> " + r);
      }
      final AtomicInteger timeouts=new AtomicInteger();
      final Map<Integer,List<String>> data=new ConcurrentHashMap<Integer,List<String>>();
      int m=5000;
      final CountDownLatch cdl=new CountDownLatch(m);
      for (int i=0; i < m; i++) {
        final int j=i;
        exec.execute(new Runnable(){
          @Override public void run(){
            final AtomicInteger nexts=new AtomicInteger();
            try {
              Observable<String> origin=Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
              TestObserver<String> to=new TestObserver<String>();
              origin.retry().observeOn(Schedulers.computation()).subscribe(to);
              to.awaitTerminalEvent(2500,TimeUnit.MILLISECONDS);
              List<String> onNextEvents=new ArrayList<String>(to.values());
              if (onNextEvents.size() != NUM_RETRIES + 2) {
                for (                Throwable t : to.errors()) {
                  onNextEvents.add(t.toString());
                }
                for (long err=to.completions(); err != 0; err--) {
                  onNextEvents.add("onComplete");
                }
                data.put(j,onNextEvents);
              }
            }
 catch (            Throwable t) {
              timeouts.incrementAndGet();
              System.out.println(j + " | " + cdl.getCount()+ " !!! "+ nexts.get());
            }
            cdl.countDown();
          }
        }
);
      }
      cdl.await();
      assertEquals(0,timeouts.get());
      if (data.size() > 0) {
        fail("Data content mismatch: " + allSequenceFrequency(data));
      }
    }
  }
  finally {
    exec.shutdown();
  }
}
