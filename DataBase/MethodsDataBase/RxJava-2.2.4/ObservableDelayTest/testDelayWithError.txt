@Test public void testDelayWithError(){
  Observable<Long> source=Observable.interval(1L,TimeUnit.SECONDS,scheduler).map(new Function<Long,Long>(){
    @Override public Long apply(    Long value){
      if (value == 1L) {
        throw new RuntimeException("error!");
      }
      return value;
    }
  }
);
  Observable<Long> delayed=source.delay(1L,TimeUnit.SECONDS,scheduler);
  delayed.subscribe(observer);
  InOrder inOrder=inOrder(observer);
  scheduler.advanceTimeTo(1999L,TimeUnit.MILLISECONDS);
  verify(observer,never()).onNext(anyLong());
  verify(observer,never()).onComplete();
  verify(observer,never()).onError(any(Throwable.class));
  scheduler.advanceTimeTo(2000L,TimeUnit.MILLISECONDS);
  inOrder.verify(observer,times(1)).onError(any(Throwable.class));
  inOrder.verify(observer,never()).onNext(anyLong());
  verify(observer,never()).onComplete();
  scheduler.advanceTimeTo(5000L,TimeUnit.MILLISECONDS);
  inOrder.verify(observer,never()).onNext(anyLong());
  inOrder.verify(observer,never()).onError(any(Throwable.class));
  verify(observer,never()).onComplete();
}
