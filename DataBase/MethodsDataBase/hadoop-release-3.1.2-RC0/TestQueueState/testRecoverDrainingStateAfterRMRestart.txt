@Test(timeout=30000) public void testRecoverDrainingStateAfterRMRestart() throws Exception {
  CapacitySchedulerConfiguration newConf=new CapacitySchedulerConfiguration();
  newConf.setBoolean(YarnConfiguration.RECOVERY_ENABLED,true);
  newConf.setBoolean(YarnConfiguration.RM_WORK_PRESERVING_RECOVERY_ENABLED,false);
  newConf.set(YarnConfiguration.RM_STORE,MemoryRMStateStore.class.getName());
  newConf.setInt(YarnConfiguration.RM_MAX_COMPLETED_APPLICATIONS,1);
  newConf.setQueues(CapacitySchedulerConfiguration.ROOT,new String[]{Q1});
  newConf.setQueues(Q1_PATH,new String[]{Q2});
  newConf.setCapacity(Q1_PATH,100);
  newConf.setCapacity(Q2_PATH,100);
  MemoryRMStateStore newMemStore=new MemoryRMStateStore();
  newMemStore.init(newConf);
  MockRM rm=new MockRM(newConf,newMemStore);
  rm.start();
  MockNM nm=rm.registerNode("h1:1234",204800);
  RMApp app=rm.submitApp(1024,"appname","appuser",null,Q2);
  MockRM.launchAM(app,rm,nm);
  rm.waitForState(app.getApplicationId(),RMAppState.ACCEPTED);
  newConf.setState(Q1_PATH,QueueState.STOPPED);
  CapacityScheduler capacityScheduler=(CapacityScheduler)rm.getRMContext().getScheduler();
  capacityScheduler.reinitialize(newConf,rm.getRMContext());
  Assert.assertEquals(QueueState.DRAINING,capacityScheduler.getQueue(Q2).getState());
  Assert.assertEquals(QueueState.DRAINING,capacityScheduler.getQueue(Q1).getState());
  rm=new MockRM(newConf,newMemStore);
  rm.start();
  rm.registerNode("h1:1234",204800);
  rm.waitForState(app.getApplicationId(),RMAppState.ACCEPTED);
  capacityScheduler=(CapacityScheduler)rm.getRMContext().getScheduler();
  Assert.assertEquals(QueueState.DRAINING,capacityScheduler.getQueue(Q2).getState());
  Assert.assertEquals(QueueState.DRAINING,capacityScheduler.getQueue(Q1).getState());
  rm.close();
}
