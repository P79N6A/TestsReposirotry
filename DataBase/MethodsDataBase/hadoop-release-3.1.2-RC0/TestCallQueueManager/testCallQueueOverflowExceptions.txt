@SuppressWarnings("unchecked") @Test public void testCallQueueOverflowExceptions() throws Exception {
  RpcScheduler scheduler=Mockito.mock(RpcScheduler.class);
  BlockingQueue<Schedulable> queue=Mockito.mock(BlockingQueue.class);
  CallQueueManager<Schedulable> cqm=Mockito.spy(new CallQueueManager<>(queue,scheduler,false));
  Schedulable call=new FakeCall(0);
  doThrow(CallQueueOverflowException.KEEPALIVE).when(queue).add(call);
  try {
    cqm.add(call);
    fail("didn't throw");
  }
 catch (  CallQueueOverflowException cqe) {
    assertSame(CallQueueOverflowException.KEEPALIVE,cqe);
  }
  doThrow(new IllegalStateException()).when(queue).add(call);
  try {
    cqm.add(call);
    fail("didn't throw");
  }
 catch (  Exception ex) {
    assertTrue(ex.toString(),ex instanceof CallQueueOverflowException);
  }
  reset(queue);
  cqm.setClientBackoffEnabled(false);
  cqm.put(call);
  verify(queue,times(1)).put(call);
  verify(queue,times(0)).add(call);
  reset(queue);
  cqm.setClientBackoffEnabled(true);
  doReturn(Boolean.FALSE).when(cqm).shouldBackOff(call);
  cqm.put(call);
  verify(queue,times(0)).put(call);
  verify(queue,times(1)).add(call);
  reset(queue);
  reset(queue);
  cqm.setClientBackoffEnabled(true);
  doReturn(Boolean.TRUE).when(cqm).shouldBackOff(call);
  try {
    cqm.put(call);
    fail("didn't fail");
  }
 catch (  Exception ex) {
    assertTrue(ex.toString(),ex instanceof CallQueueOverflowException);
  }
  verify(queue,times(0)).put(call);
  verify(queue,times(0)).add(call);
}
