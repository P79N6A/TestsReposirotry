/** 
 * Test to check rename returns false when sticky bit is set on parent of source parent directory and the source does not exist
 */
@Test public void testRenameOnNonExistentSourceWithStickyBit() throws Throwable {
  final Path parentSrcDir=new Path("/testRenameOnNonExistentSourceWithStickyBitSrc");
  final Path srcPath=new Path(parentSrcDir,"test1.dat");
  final Path parentDstDir=new Path("/testRenameOnNonExistentSourceWithStickyBitDest");
  final Path dstPath=new Path(parentDstDir,"test2.dat");
  authorizer.addAuthRuleForOwner("/",WRITE,true);
  authorizer.addAuthRuleForOwner(parentSrcDir.toString(),WRITE,true);
  fs.updateWasbAuthorizer(authorizer);
  try {
    fs.mkdirs(parentSrcDir);
    assertIsDirectory(fs,parentSrcDir);
    fs.mkdirs(parentDstDir);
    assertIsDirectory(fs,parentDstDir);
    fs.setPermission(parentSrcDir,new FsPermission(STICKYBIT_PERMISSION_CONSTANT));
    UserGroupInformation dummyUser=UserGroupInformation.createUserForTesting("dummyUser",new String[]{"dummygroup"});
    dummyUser.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        authorizer.addAuthRule(parentSrcDir.toString(),WRITE,getCurrentUserShortName(),true);
        authorizer.addAuthRule(parentDstDir.toString(),WRITE,getCurrentUserShortName(),true);
        assertRenameOutcome(fs,srcPath,dstPath,false);
        assertPathDoesNotExist(fs,"destPath exists",dstPath);
        return null;
      }
    }
);
  }
  finally {
    recursiveDelete(parentSrcDir);
    recursiveDelete(parentDstDir);
  }
}
