@Test(timeout=8000) public void testConcurrentGetCurrentUser() throws Exception {
  final CyclicBarrier barrier=new CyclicBarrier(2);
  final CountDownLatch latch=new CountDownLatch(1);
  final UserGroupInformation testUgi1=UserGroupInformation.createRemoteUser("testUgi1");
  final UserGroupInformation testUgi2=UserGroupInformation.createRemoteUser("testUgi2");
  Set<Principal> principals=testUgi1.getSubject().getPrincipals();
  User user=testUgi1.getSubject().getPrincipals(User.class).iterator().next();
  final User spyUser=Mockito.spy(user);
  principals.remove(user);
  principals.add(spyUser);
  when(spyUser.getName()).thenAnswer(new Answer<String>(){
    @Override public String answer(    InvocationOnMock invocation) throws Throwable {
      latch.countDown();
      barrier.await();
      return (String)invocation.callRealMethod();
    }
  }
);
  Future<UserGroupInformation> blockingLookup=Executors.newSingleThreadExecutor().submit(new Callable<UserGroupInformation>(){
    @Override public UserGroupInformation call() throws Exception {
      return testUgi1.doAs(new PrivilegedExceptionAction<UserGroupInformation>(){
        @Override public UserGroupInformation run() throws Exception {
          return UserGroupInformation.getCurrentUser();
        }
      }
);
    }
  }
);
  latch.await();
  principals.remove(spyUser);
  principals.add(user);
  UserGroupInformation ugi;
  ugi=testUgi1.doAs(new PrivilegedExceptionAction<UserGroupInformation>(){
    @Override public UserGroupInformation run() throws Exception {
      return UserGroupInformation.getCurrentUser();
    }
  }
);
  assertSame(testUgi1.getSubject(),ugi.getSubject());
  ugi=testUgi2.doAs(new PrivilegedExceptionAction<UserGroupInformation>(){
    @Override public UserGroupInformation run() throws Exception {
      return UserGroupInformation.getCurrentUser();
    }
  }
);
  assertSame(testUgi2.getSubject(),ugi.getSubject());
  barrier.await();
  assertSame(testUgi1.getSubject(),blockingLookup.get().getSubject());
}
