@Test public void testUpdateCollectorInfo() throws Exception {
  LOG.info("Running testUpdateCollectorInfo");
  Configuration conf=new Configuration();
  conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,true);
  conf.setFloat(YarnConfiguration.TIMELINE_SERVICE_VERSION,2.0f);
  ApplicationId appId=ApplicationId.newInstance(1,1);
  ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(appId,1);
  JobId jobId=MRBuilderUtils.newJobId(appId,0);
  Job mockJob=mock(Job.class);
  when(mockJob.getReport()).thenReturn(MRBuilderUtils.newJobReport(jobId,"job","user",JobState.RUNNING,0,0,0,0,0,0,0,"jobfile",null,false,""));
  String localAddr="localhost:1234";
  UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
  TimelineDelegationTokenIdentifier ident=new TimelineDelegationTokenIdentifier(new Text(ugi.getUserName()),new Text("renewer"),null);
  ident.setSequenceNumber(1);
  Token<TimelineDelegationTokenIdentifier> collectorToken=new Token<TimelineDelegationTokenIdentifier>(ident.getBytes(),new byte[0],TimelineDelegationTokenIdentifier.KIND_NAME,new Text(localAddr));
  org.apache.hadoop.yarn.api.records.Token token=org.apache.hadoop.yarn.api.records.Token.newInstance(collectorToken.getIdentifier(),collectorToken.getKind().toString(),collectorToken.getPassword(),collectorToken.getService().toString());
  CollectorInfo collectorInfo=CollectorInfo.newInstance(localAddr,token);
  final MockSchedulerForTimelineCollector mockScheduler=new MockSchedulerForTimelineCollector(collectorInfo);
  MyContainerAllocator allocator=new MyContainerAllocator(null,conf,attemptId,mockJob,SystemClock.getInstance()){
    @Override protected void register(){
    }
    @Override protected ApplicationMasterProtocol createSchedulerProxy(){
      return mockScheduler;
    }
  }
;
  ArrayList<Token<? extends TokenIdentifier>> tokens=new ArrayList<>(ugi.getTokens());
  assertEquals(0,tokens.size());
  TimelineV2Client client=spy(TimelineV2Client.createTimelineClient(appId));
  client.init(conf);
  when(((RunningAppContext)allocator.getContext()).getTimelineV2Client()).thenReturn(client);
  allocator.schedule();
  verify(client).setTimelineCollectorInfo(collectorInfo);
  tokens=new ArrayList<>(ugi.getTokens());
  assertEquals(1,tokens.size());
  assertEquals(TimelineDelegationTokenIdentifier.KIND_NAME,tokens.get(0).getKind());
  assertEquals(collectorToken.decodeIdentifier(),tokens.get(0).decodeIdentifier());
  ident.setSequenceNumber(100);
  Token<TimelineDelegationTokenIdentifier> collectorToken1=new Token<TimelineDelegationTokenIdentifier>(ident.getBytes(),new byte[0],TimelineDelegationTokenIdentifier.KIND_NAME,new Text(localAddr));
  token=org.apache.hadoop.yarn.api.records.Token.newInstance(collectorToken1.getIdentifier(),collectorToken1.getKind().toString(),collectorToken1.getPassword(),collectorToken1.getService().toString());
  collectorInfo=CollectorInfo.newInstance(localAddr,token);
  mockScheduler.updateCollectorInfo(collectorInfo);
  allocator.schedule();
  verify(client).setTimelineCollectorInfo(collectorInfo);
  tokens=new ArrayList<>(ugi.getTokens());
  assertEquals(1,tokens.size());
  assertEquals(TimelineDelegationTokenIdentifier.KIND_NAME,tokens.get(0).getKind());
  assertEquals(collectorToken1.decodeIdentifier(),tokens.get(0).decodeIdentifier());
  allocator.close();
}
