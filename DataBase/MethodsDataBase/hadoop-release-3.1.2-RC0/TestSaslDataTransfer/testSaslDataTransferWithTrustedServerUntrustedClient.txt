/** 
 * Verifies that SaslDataTransferClient#checkTrustAndSend should not trust a partially trusted channel.
 */
@Test public void testSaslDataTransferWithTrustedServerUntrustedClient() throws Exception {
  HdfsConfiguration conf=createSecureConfig("authentication,integrity,privacy");
  AtomicBoolean fallbackToSimpleAuth=new AtomicBoolean(false);
  TrustedChannelResolver trustedChannelResolver=new TrustedChannelResolver(){
    @Override public boolean isTrusted(){
      return true;
    }
    @Override public boolean isTrusted(    InetAddress peerAddress){
      return false;
    }
  }
;
  SaslDataTransferClient saslClient=new SaslDataTransferClient(conf,DataTransferSaslUtil.getSaslPropertiesResolver(conf),trustedChannelResolver,fallbackToSimpleAuth);
  ServerSocket serverSocket=null;
  Socket socket=null;
  DataEncryptionKeyFactory dataEncryptionKeyFactory=null;
  try {
    serverSocket=new ServerSocket(10002,10);
    socket=new Socket(serverSocket.getInetAddress(),serverSocket.getLocalPort());
    dataEncryptionKeyFactory=mock(DataEncryptionKeyFactory.class);
    Mockito.when(dataEncryptionKeyFactory.newDataEncryptionKey()).thenThrow(new IOException("Encryption enabled"));
    saslClient.socketSend(socket,null,null,dataEncryptionKeyFactory,null,null);
    Assert.fail("Expected IOException from " + "SaslDataTransferClient#checkTrustAndSend");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Encryption enabled",e);
    verify(dataEncryptionKeyFactory,times(1)).newDataEncryptionKey();
  }
 finally {
    IOUtils.cleanupWithLogger(null,socket,serverSocket);
  }
}
