@Test public void testCloseWhileRecoverLease() throws Exception {
  cluster.setLeasePeriod(LONG_LEASE_PERIOD,LONG_LEASE_PERIOD);
  int size=AppendTestUtil.nextInt(FILE_SIZE);
  String filestr="/testCloseWhileRecoverLease";
  AppendTestUtil.LOG.info("filestr=" + filestr);
  Path filepath=new Path(filestr);
  FSDataOutputStream stm=dfs.create(filepath,true,BUF_SIZE,REPLICATION_NUM,BLOCK_SIZE);
  assertTrue(dfs.dfs.exists(filestr));
  AppendTestUtil.LOG.info("hflush");
  stm.hflush();
  ArrayList<DataNode> dataNodes=cluster.getDataNodes();
  for (  DataNode dn : dataNodes) {
    DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,false);
  }
  LOG.info("pause IBR");
  for (  DataNode dn : dataNodes) {
    DataNodeTestUtils.pauseIBR(dn);
  }
  AppendTestUtil.LOG.info("size=" + size);
  stm.write(buffer,0,size);
  AppendTestUtil.LOG.info("hflush");
  stm.hflush();
  LOG.info("recover lease");
  dfs.recoverLease(filepath);
  try {
    stm.close();
    fail("close() should fail because the file is under recovery.");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("whereas it is under recovery",ioe);
  }
  for (  DataNode dn : dataNodes) {
    DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,false);
  }
  LOG.info("trigger heartbeats");
  for (  DataNode dn : dataNodes) {
    DataNodeTestUtils.triggerHeartbeat(dn);
  }
  stm.close();
  assertEquals(cluster.getNamesystem().getBlockManager().getMissingBlocksCount(),0);
}
