@Test public void testNoExitCodeFromPrivilegedOperation() throws Exception {
  Configuration conf=new Configuration();
  final PrivilegedOperationExecutor spyPrivilegedExecutor=spy(PrivilegedOperationExecutor.getInstance(conf));
  doThrow(new PrivilegedOperationException("interrupted")).when(spyPrivilegedExecutor).executePrivilegedOperation(any(List.class),any(PrivilegedOperation.class),any(File.class),any(Map.class),anyBoolean(),anyBoolean());
  LinuxContainerRuntime runtime=new DefaultLinuxContainerRuntime(spyPrivilegedExecutor);
  runtime.initialize(conf,null);
  mockExec=new LinuxContainerExecutor(runtime);
  mockExec.setConf(conf);
  LinuxContainerExecutor lce=new LinuxContainerExecutor(runtime){
    @Override protected PrivilegedOperationExecutor getPrivilegedOperationExecutor(){
      return spyPrivilegedExecutor;
    }
  }
;
  lce.setConf(conf);
  InetSocketAddress address=InetSocketAddress.createUnresolved("localhost",8040);
  Path nmPrivateCTokensPath=new Path("file:///bin/nmPrivateCTokensPath");
  LocalDirsHandlerService dirService=new LocalDirsHandlerService();
  dirService.init(conf);
  String appSubmitter="nobody";
  ApplicationId appId=ApplicationId.newInstance(1,1);
  ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(appId,1);
  ContainerId cid=ContainerId.newContainerId(attemptId,1);
  HashMap<String,String> env=new HashMap<>();
  Container container=mock(Container.class);
  ContainerLaunchContext context=mock(ContainerLaunchContext.class);
  when(container.getContainerId()).thenReturn(cid);
  when(container.getLaunchContext()).thenReturn(context);
  when(context.getEnvironment()).thenReturn(env);
  Path workDir=new Path("/tmp");
  try {
    lce.startLocalizer(new LocalizerStartContext.Builder().setNmPrivateContainerTokens(nmPrivateCTokensPath).setNmAddr(address).setUser(appSubmitter).setAppId(appId.toString()).setLocId("12345").setDirsHandler(dirService).build());
    Assert.fail("startLocalizer should have thrown an exception");
  }
 catch (  IOException e) {
    assertTrue("Unexpected exception " + e,e.getMessage().contains("exitCode"));
  }
  lce.activateContainer(cid,new Path(workDir,"pid.txt"));
  lce.launchContainer(new ContainerStartContext.Builder().setContainer(container).setNmPrivateContainerScriptPath(new Path("file:///bin/echo")).setNmPrivateTokensPath(new Path("file:///dev/null")).setUser(appSubmitter).setAppId(appId.toString()).setContainerWorkDir(workDir).setLocalDirs(dirsHandler.getLocalDirs()).setLogDirs(dirsHandler.getLogDirs()).setFilecacheDirs(new ArrayList<>()).setUserLocalDirs(new ArrayList<>()).setContainerLocalDirs(new ArrayList<>()).setContainerLogDirs(new ArrayList<>()).setUserFilecacheDirs(new ArrayList<>()).setApplicationLocalDirs(new ArrayList<>()).build());
  lce.deleteAsUser(new DeletionAsUserContext.Builder().setUser(appSubmitter).setSubDir(new Path("/tmp/testdir")).build());
  try {
    lce.mountCgroups(new ArrayList<String>(),"hierarchy");
    Assert.fail("mountCgroups should have thrown an exception");
  }
 catch (  IOException e) {
    assertTrue("Unexpected exception " + e,e.getMessage().contains("exit code"));
  }
}
