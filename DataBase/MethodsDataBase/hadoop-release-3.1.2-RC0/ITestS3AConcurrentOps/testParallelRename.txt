/** 
 * Attempts to trigger a deadlock that would happen if any bounded resource pool became saturated with control tasks that depended on other tasks that now can't enter the resource pool to get completed.
 */
@Test @SuppressWarnings("unchecked") public void testParallelRename() throws InterruptedException, ExecutionException, IOException {
  ExecutorService executor=Executors.newFixedThreadPool(concurrentRenames,new ThreadFactory(){
    private AtomicInteger count=new AtomicInteger(0);
    public Thread newThread(    Runnable r){
      return new Thread(r,"testParallelRename" + count.getAndIncrement());
    }
  }
);
  ((ThreadPoolExecutor)executor).prestartAllCoreThreads();
  Future<Boolean>[] futures=new Future[concurrentRenames];
  for (int i=0; i < concurrentRenames; i++) {
    final int index=i;
    futures[i]=executor.submit(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        NanoTimer timer=new NanoTimer();
        boolean result=fs.rename(source[index],target[index]);
        timer.end("parallel rename %d",index);
        LOG.info("Rename {} ran from {} to {}",index,timer.getStartTime(),timer.getEndTime());
        return result;
      }
    }
);
  }
  LOG.info("Waiting for tasks to complete...");
  LOG.info("Deadlock may have occurred if nothing else is logged" + " or the test times out");
  for (int i=0; i < concurrentRenames; i++) {
    assertTrue("No future " + i,futures[i].get());
    assertPathExists("target path",target[i]);
    assertPathDoesNotExist("source path",source[i]);
  }
  LOG.info("All tasks have completed successfully");
}
