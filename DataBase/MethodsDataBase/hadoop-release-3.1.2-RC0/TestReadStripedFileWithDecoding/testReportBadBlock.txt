/** 
 * After reading a corrupted block, make sure the client can correctly report the corruption to the NameNode.
 */
@Test public void testReportBadBlock() throws IOException {
  final Path file=new Path("/corrupted");
  final int length=10;
  final byte[] bytes=StripedFileTestUtil.generateBytes(length);
  DFSTestUtil.writeFile(dfs,file,bytes);
  int dnIndex=ReadStripedFileWithDecodingHelper.findFirstDataNode(cluster,dfs,file,CELL_SIZE * NUM_DATA_UNITS);
  Assert.assertNotEquals(-1,dnIndex);
  LocatedStripedBlock slb=(LocatedStripedBlock)dfs.getClient().getLocatedBlocks(file.toString(),0,CELL_SIZE * NUM_DATA_UNITS).get(0);
  final LocatedBlock[] blks=StripedBlockUtil.parseStripedBlockGroup(slb,CELL_SIZE,NUM_DATA_UNITS,NUM_PARITY_UNITS);
  File storageDir=cluster.getInstanceStorageDir(dnIndex,0);
  File blkFile=MiniDFSCluster.getBlockFile(storageDir,blks[0].getBlock());
  Assert.assertTrue("Block file does not exist",blkFile.exists());
  LOG.info("Deliberately corrupting file " + blkFile.getName());
  try (FileOutputStream out=new FileOutputStream(blkFile)){
    out.write("corruption".getBytes());
  }
   for (  DataNode dn : cluster.getDataNodes()) {
    DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,true);
  }
  try {
    StripedFileTestUtil.verifyStatefulRead(dfs,file,length,bytes,ByteBuffer.allocate(1024));
    final FSNamesystem ns=cluster.getNamesystem();
    final BlockManager bm=ns.getBlockManager();
    BlockInfo blockInfo=(ns.getFSDirectory().getINode4Write(file.toString()).asFile().getBlocks())[0];
    Assert.assertEquals(1,bm.getCorruptReplicas(blockInfo).size());
  }
  finally {
    for (    DataNode dn : cluster.getDataNodes()) {
      DataNodeTestUtils.setHeartbeatsDisabledForTests(dn,false);
    }
  }
}
