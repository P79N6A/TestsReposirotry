/** 
 * Test for queue deletion.
 * @throws Exception
 */
@Test public void testRefreshQueuesWithQueueDelete() throws Exception {
  CapacityScheduler cs=new CapacityScheduler();
  CapacitySchedulerConfiguration conf=new CapacitySchedulerConfiguration();
  RMContextImpl rmContext=new RMContextImpl(null,null,null,null,null,null,new RMContainerTokenSecretManager(conf),new NMTokenSecretManagerInRM(conf),new ClientToAMTokenSecretManagerInRM(),null);
  setupQueueConfiguration(conf);
  cs.setConf(new YarnConfiguration());
  cs.setRMContext(resourceManager.getRMContext());
  cs.init(conf);
  cs.start();
  cs.reinitialize(conf,rmContext);
  checkQueueCapacities(cs,A_CAPACITY,B_CAPACITY);
  Map<String,CSQueue> queues=cs.getCapacitySchedulerQueueManager().getQueues();
  String b1QTobeDeleted="b1";
  LeafQueue csB1Queue=Mockito.spy((LeafQueue)queues.get(b1QTobeDeleted));
  when(csB1Queue.getState()).thenReturn(QueueState.DRAINING).thenReturn(QueueState.STOPPED);
  queues.put(b1QTobeDeleted,csB1Queue);
  conf=new CapacitySchedulerConfiguration();
  setupQueueConfigurationWithOutB1(conf);
  try {
    cs.reinitialize(conf,mockContext);
    fail("Expected to throw exception when refresh queue tries to delete a" + " queue with running apps");
  }
 catch (  IOException e) {
  }
  conf=new CapacitySchedulerConfiguration();
  setupQueueConfigurationWithOutB1(conf);
  try {
    cs.reinitialize(conf,mockContext);
  }
 catch (  IOException e) {
    LOG.error("Expected to NOT throw exception when refresh queue tries to delete" + " a queue WITHOUT running apps",e);
    fail("Expected to NOT throw exception when refresh queue tries to delete" + " a queue WITHOUT running apps");
  }
  CSQueue rootQueue=cs.getRootQueue();
  CSQueue queueB=findQueue(rootQueue,B);
  CSQueue queueB3=findQueue(queueB,B1);
  assertNull("Refresh needs to support delete of leaf queue ",queueB3);
  conf=new CapacitySchedulerConfiguration();
  setupQueueConfiguration(conf);
  cs.reinitialize(conf,rmContext);
  checkQueueCapacities(cs,A_CAPACITY,B_CAPACITY);
  queues=cs.getCapacitySchedulerQueueManager().getQueues();
  CSQueue bQueue=Mockito.spy((ParentQueue)queues.get("b"));
  when(bQueue.getState()).thenReturn(QueueState.DRAINING).thenReturn(QueueState.STOPPED);
  queues.put("b",bQueue);
  bQueue=Mockito.spy((LeafQueue)queues.get("b1"));
  when(bQueue.getState()).thenReturn(QueueState.STOPPED);
  queues.put("b1",bQueue);
  bQueue=Mockito.spy((LeafQueue)queues.get("b2"));
  when(bQueue.getState()).thenReturn(QueueState.STOPPED);
  queues.put("b2",bQueue);
  bQueue=Mockito.spy((LeafQueue)queues.get("b3"));
  when(bQueue.getState()).thenReturn(QueueState.STOPPED);
  queues.put("b3",bQueue);
  conf=new CapacitySchedulerConfiguration();
  setupQueueConfigurationWithOutB(conf);
  try {
    cs.reinitialize(conf,mockContext);
    fail("Expected to throw exception when refresh queue tries to delete a" + " parent queue with running apps in children queue");
  }
 catch (  IOException e) {
  }
  conf=new CapacitySchedulerConfiguration();
  setupQueueConfigurationWithOutB(conf);
  try {
    cs.reinitialize(conf,mockContext);
  }
 catch (  IOException e) {
    fail("Expected to not throw exception when refresh queue tries to delete" + " a queue without running apps");
  }
  rootQueue=cs.getRootQueue();
  queueB=findQueue(rootQueue,B);
  String message="Refresh needs to support delete of Parent queue and its children.";
  assertNull(message,queueB);
  assertNull(message,cs.getCapacitySchedulerQueueManager().getQueues().get("b"));
  assertNull(message,cs.getCapacitySchedulerQueueManager().getQueues().get("b1"));
  assertNull(message,cs.getCapacitySchedulerQueueManager().getQueues().get("b2"));
  cs.stop();
}
