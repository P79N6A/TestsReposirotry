/** 
 * If register is slow, async allocate requests in the meanwhile should not throw or be dropped.
 */
@Test(timeout=5000) public void testSlowRegisterCall() throws YarnException, IOException, InterruptedException {
  Thread registerAMThread=new Thread(new Runnable(){
    @Override public void run(){
      try {
        launchUAM(attemptId);
        registerApplicationMaster(RegisterApplicationMasterRequest.newInstance(null,1001,null),attemptId);
      }
 catch (      Exception e) {
        LOG.info("Register thread exception",e);
      }
    }
  }
);
  Object syncObj=MockResourceManagerFacade.getSyncObj();
synchronized (syncObj) {
    LOG.info("Starting register thread");
    registerAMThread.start();
    try {
      LOG.info("Test main starts waiting");
      syncObj.wait();
      LOG.info("Test main wait finished");
    }
 catch (    Exception e) {
      LOG.info("Test main wait interrupted",e);
    }
  }
  allocateAsync(AllocateRequest.newInstance(0,0,null,null,null),callback,attemptId);
synchronized (syncObj) {
    syncObj.notifyAll();
  }
  LOG.info("Test main wait for register thread to finish");
  registerAMThread.join();
  LOG.info("Register thread finished");
  allocateAsync(AllocateRequest.newInstance(0,0,null,null,null),callback,attemptId);
  waitForCallBackCountAndCheckZeroPending(callback,2);
  finishApplicationMaster(FinishApplicationMasterRequest.newInstance(null,null,null),attemptId);
  allocateAsync(AllocateRequest.newInstance(0,0,null,null,null),callback,attemptId);
  allocateAsync(AllocateRequest.newInstance(0,0,null,null,null),callback,attemptId);
  Assert.assertEquals(0,callback.requestQueueSize);
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
  }
  Assert.assertEquals(2,callback.callBackCount);
}
