/** 
 * edit lengths [3,4,5] first recovery: - sees [3,4,x] - picks length 4 for recoveryEndTxId - calls acceptRecovery() - crashes before finalizing second recovery: - sees [x, 4, 5] - should pick recovery length 4, even though it saw a larger txid, because a previous recovery accepted it
 */
@Test public void testRecoverAfterIncompleteRecovery() throws Exception {
  setupLoggers345();
  cluster.getJournalNode(2).stopAndJoin(0);
  qjm=createSpyingQJM();
  spies=qjm.getLoggerSetForTests().getLoggersForTests();
  for (  AsyncLogger spy : spies) {
    TestQuorumJournalManagerUnit.futureThrows(new IOException("injected")).when(spy).finalizeLogSegment(Mockito.eq(1L),Mockito.eq(4L));
  }
  try {
    qjm.recoverUnfinalizedSegments();
    fail("Should have failed recovery since no finalization occurred");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("injected",ioe);
  }
  cluster.getJournalNode(0).stopAndJoin(0);
  cluster.restartJournalNode(2);
  qjm=createSpyingQJM();
  spies=qjm.getLoggerSetForTests().getLoggersForTests();
  qjm.recoverUnfinalizedSegments();
  checkRecovery(cluster,1,4);
}
