/** 
 * Test to verify sorting with multiple decommissioned datanodes exists in storage lists. We have storage list, marked decommissioned internal blocks with a ' d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12 mapping to indices 0', 1', 2, 3, 4, 5, 6, 7', 8', 0, 1, 7, 8 Decommissioned node indices: 0, 1, 7, 8 So in the original list nodes d0, d1, d7, d8 are decommissioned state. After sorting the expected block indices list should be, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0', 1', 7', 8' After sorting the expected storage list will be, d9, d10, d2, d3, d4, d5, d6, d11, d12, d0, d1, d7, d8. Note: after sorting block indices will not be in ascending order.
 */
@Test(timeout=10000) public void testWithMultipleDecommnDatanodes(){
  LOG.info("Starting test testSortWithMultipleDecommnDatanodes");
  int lbsCount=2;
  List<Integer> decommnNodeIndices=new ArrayList<>();
  decommnNodeIndices.add(0);
  decommnNodeIndices.add(1);
  decommnNodeIndices.add(7);
  decommnNodeIndices.add(8);
  List<Integer> targetNodeIndices=new ArrayList<>();
  targetNodeIndices.addAll(decommnNodeIndices);
  HashMap<Integer,List<String>> decommissionedNodes=new HashMap<>(lbsCount * decommnNodeIndices.size());
  List<LocatedBlock> lbs=createLocatedStripedBlocks(lbsCount,dataBlocks,parityBlocks,decommnNodeIndices,targetNodeIndices,decommissionedNodes);
  List<HashMap<DatanodeInfo,Byte>> locToIndexList=new ArrayList<>();
  List<HashMap<DatanodeInfo,Token<BlockTokenIdentifier>>> locToTokenList=new ArrayList<>();
  prepareBlockIndexAndTokenList(lbs,locToIndexList,locToTokenList);
  dm.sortLocatedBlocks(null,lbs);
  assertDecommnNodePosition(groupSize,decommissionedNodes,lbs);
  assertBlockIndexAndTokenPosition(lbs,locToIndexList,locToTokenList);
}
