@Test public void shouldSupportPropertyPlaceholdersOnAllProperties() throws Exception {
  final Set<Invocation> invocations=new LinkedHashSet<>();
  final ModelCamelContext context=mock(ModelCamelContext.class,withSettings().invocationListeners(i -> invocations.add((Invocation)i.getInvocation())));
  when(context.resolvePropertyPlaceholders(anyString())).thenAnswer(invocation -> {
    final String placeholder=invocation.getArgument(0);
    if (valuesThatReturnBoolean.contains(placeholder) || placeholder.endsWith("Enabled}}")) {
      return "true";
    }
    if (valuesThatReturnLong.contains(placeholder)) {
      return "1";
    }
    return "string";
  }
);
  when(context.getTypeConverter()).thenReturn(typeConverter);
  when(context.getRuntimeEndpointRegistry()).thenReturn(mock(RuntimeEndpointRegistry.class));
  when(context.getManagementNameStrategy()).thenReturn(mock(ManagementNameStrategy.class));
  when(context.getExecutorServiceManager()).thenReturn(mock(ExecutorServiceManager.class));
  @SuppressWarnings("unchecked") final AbstractCamelContextFactoryBean<ModelCamelContext> factory=mock(AbstractCamelContextFactoryBean.class);
  when(factory.getContext()).thenReturn(context);
  doCallRealMethod().when(factory).initCamelContext(context);
  final Set<String> expectedPropertiesToBeResolved=propertiesToBeResolved(factory);
  factory.initCamelContext(context);
  final ArgumentCaptor<String> capturedPlaceholders=ArgumentCaptor.forClass(String.class);
  verify(context,atLeastOnce()).resolvePropertyPlaceholders(capturedPlaceholders.capture());
  expectedPropertiesToBeResolved.removeAll(propertiesThatAreNotPlaceholdered);
  assertThat(capturedPlaceholders.getAllValues()).as("The expectation is that all abstract getter methods that return Strings should support property " + "placeholders, and that for those will delegate to CamelContext::resolvePropertyPlaceholders, " + "we captured all placeholders that tried to resolve and found differences").containsAll(expectedPropertiesToBeResolved);
}
