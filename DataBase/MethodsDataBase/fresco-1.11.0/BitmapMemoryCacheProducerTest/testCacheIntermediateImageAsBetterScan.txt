@Test public void testCacheIntermediateImageAsBetterScan(){
  setupInputProducerStreamingSuccess();
  CloseableImage closeableImage=mock(CloseableImage.class);
  when(closeableImage.getQualityInfo()).thenReturn(ImmutableQualityInfo.of(INTERMEDIATE_SCAN_1,false,false));
  CloseableReference<CloseableImage> closeableImageRef=CloseableReference.of(closeableImage);
  setupBitmapMemoryCacheGetSuccessOnSecondRead(closeableImageRef);
  mBitmapMemoryCacheProducer.produceResults(mConsumer,mProducerContext);
  verify(mMemoryCache).cache(mBitmapMemoryCacheKey,mIntermediateImageReference);
  verify(mMemoryCache).cache(mBitmapMemoryCacheKey,mFinalImageReference);
  verify(mConsumer).onNewResult(mIntermediateImageReferenceClone,Consumer.NO_FLAGS);
  verify(mConsumer).onNewResult(mFinalImageReferenceClone,Consumer.IS_LAST);
  Assert.assertTrue(!mIntermediateImageReferenceClone.isValid());
  Assert.assertTrue(!mFinalImageReferenceClone.isValid());
  Assert.assertEquals(0,closeableImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
  verify(mProducerListener).onProducerStart(mRequestId,PRODUCER_NAME);
  Map<String,String> extraMap=ImmutableMap.of(BitmapMemoryCacheProducer.EXTRA_CACHED_VALUE_FOUND,"false");
  verify(mProducerListener).onProducerFinishWithSuccess(mRequestId,PRODUCER_NAME,extraMap);
  verify(mProducerListener,never()).onUltimateProducerReached(anyString(),anyString(),anyBoolean());
}
