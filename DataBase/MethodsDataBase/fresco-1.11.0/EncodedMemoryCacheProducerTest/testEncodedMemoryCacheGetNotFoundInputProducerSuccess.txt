@Test public void testEncodedMemoryCacheGetNotFoundInputProducerSuccess(){
  setupEncodedMemoryCacheGetNotFound();
  setupInputProducerStreamingSuccess();
  mEncodedMemoryCacheProducer.produceResults(mConsumer,mProducerContext);
  verify(mMemoryCache,never()).cache(mCacheKey,mIntermediateImageReference);
  ArgumentCaptor<CloseableReference> argumentCaptor=ArgumentCaptor.forClass(CloseableReference.class);
  verify(mMemoryCache).cache(eq(mCacheKey),argumentCaptor.capture());
  CloseableReference<PooledByteBuffer> capturedRef=(CloseableReference<PooledByteBuffer>)argumentCaptor.getValue();
  Assert.assertSame(mFinalImageReference.getUnderlyingReferenceTestOnly(),capturedRef.getUnderlyingReferenceTestOnly());
  verify(mConsumer).onNewResult(mIntermediateEncodedImage,Consumer.NO_FLAGS);
  verify(mConsumer).onNewResult(mFinalEncodedImage,Consumer.IS_LAST);
  Assert.assertTrue(EncodedImage.isValid(mFinalEncodedImageClone));
  verify(mProducerListener).onProducerStart(mRequestId,PRODUCER_NAME);
  Map<String,String> extraMap=ImmutableMap.of(EncodedMemoryCacheProducer.EXTRA_CACHED_VALUE_FOUND,"false");
  verify(mProducerListener).onProducerFinishWithSuccess(mRequestId,PRODUCER_NAME,extraMap);
  verify(mProducerListener,never()).onUltimateProducerReached(anyString(),anyString(),anyBoolean());
}
