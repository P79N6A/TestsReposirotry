/** 
 * Test which proves that a non-static property placeholder bean cannot be declared in the same configuration class that has a  {@code @Value} field in need ofplaceholder replacement. It's an obvious chicken-and-egg issue. <p>One solution is to do as  {@link #valueFieldsAreProcessedWhenPlaceholderConfigurerIsSegregated()}does and segregate the two bean definitions across configuration classes. <p>Another solution is to simply make the  {@code @Bean} method for the propertyplaceholder  {@code static} as in{@link #valueFieldsAreProcessedWhenStaticPlaceholderConfigurerIsIntegrated()}.
 */
@Test @SuppressWarnings("resource") public void valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated(){
  AnnotationConfigApplicationContext ctx=new AnnotationConfigApplicationContext();
  ctx.register(ConfigWithValueFieldAndPlaceholderConfigurer.class);
  System.setProperty("test.name","foo");
  ctx.refresh();
  System.clearProperty("test.name");
  TestBean testBean=ctx.getBean(TestBean.class);
  assertThat(testBean.getName(),nullValue());
}
