/** 
 * Story: User wants to use canopy clustering to input the initial clusters for kmeans job.
 */
@Test public void testKMeansWithCanopyClusterInput() throws Exception {
  List<VectorWritable> points=getPointsWritable(REFERENCE);
  Path pointsPath=getTestTempDirPath("points");
  Configuration conf=getConfiguration();
  ClusteringTestUtils.writePointsToFile(points,true,new Path(pointsPath,"file1"),fs,conf);
  ClusteringTestUtils.writePointsToFile(points,true,new Path(pointsPath,"file2"),fs,conf);
  Path outputPath=getTestTempDirPath("output");
  CanopyDriver.run(conf,pointsPath,outputPath,new ManhattanDistanceMeasure(),3.1,2.1,false,0.0,false);
  DummyOutputCollector<Text,ClusterWritable> collector1=new DummyOutputCollector<>();
  FileStatus[] outParts=FileSystem.get(conf).globStatus(new Path(outputPath,"clusters-0-final/*-0*"));
  for (  FileStatus outPartStat : outParts) {
    for (    Pair<Text,ClusterWritable> record : new SequenceFileIterable<Text,ClusterWritable>(outPartStat.getPath(),conf)) {
      collector1.collect(record.getFirst(),record.getSecond());
    }
  }
  boolean got15=false;
  boolean got43=false;
  int count=0;
  for (  Text k : collector1.getKeys()) {
    count++;
    List<ClusterWritable> vl=collector1.getValue(k);
    assertEquals("non-singleton centroid!",1,vl.size());
    ClusterWritable clusterWritable=vl.get(0);
    Vector v=clusterWritable.getValue().getCenter();
    assertEquals("cetriod vector is wrong length",2,v.size());
    if ((Math.abs(v.get(0) - 1.5) < EPSILON) && (Math.abs(v.get(1) - 1.5) < EPSILON) && !got15) {
      got15=true;
    }
 else     if ((Math.abs(v.get(0) - 4.333333333333334) < EPSILON) && (Math.abs(v.get(1) - 4.333333333333334) < EPSILON) && !got43) {
      got43=true;
    }
 else {
      fail("got unexpected center: " + v + " ["+ v.getClass().toString()+ ']');
    }
  }
  assertEquals("got unexpected number of centers",2,count);
  Path kmeansOutput=new Path(outputPath,"kmeans");
  KMeansDriver.run(getConfiguration(),pointsPath,new Path(outputPath,"clusters-0-final"),kmeansOutput,0.001,10,true,0.0,false);
  Path clusteredPointsPath=new Path(kmeansOutput,"clusteredPoints");
  DummyOutputCollector<IntWritable,WeightedPropertyVectorWritable> collector=new DummyOutputCollector<>();
  for (  Pair<IntWritable,WeightedPropertyVectorWritable> record : new SequenceFileIterable<IntWritable,WeightedPropertyVectorWritable>(new Path(clusteredPointsPath,"part-m-00000"),conf)) {
    collector.collect(record.getFirst(),record.getSecond());
  }
  for (  IntWritable k : collector.getKeys()) {
    List<WeightedPropertyVectorWritable> wpvList=collector.getValue(k);
    assertTrue("empty cluster!",!wpvList.isEmpty());
    if (wpvList.get(0).getVector().get(0) <= 2.0) {
      for (      WeightedPropertyVectorWritable wv : wpvList) {
        Vector v=wv.getVector();
        int idx=v.maxValueIndex();
        assertTrue("bad cluster!",v.get(idx) <= 2.0);
      }
      assertEquals("Wrong size cluster",4,wpvList.size());
    }
 else {
      for (      WeightedPropertyVectorWritable wv : wpvList) {
        Vector v=wv.getVector();
        int idx=v.minValueIndex();
        assertTrue("bad cluster!",v.get(idx) > 2.0);
      }
      assertEquals("Wrong size cluster",5,wpvList.size());
    }
  }
}
