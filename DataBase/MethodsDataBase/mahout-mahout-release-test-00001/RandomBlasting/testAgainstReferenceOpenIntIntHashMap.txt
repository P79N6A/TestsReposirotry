@Test @Repeat(iterations=20) public void testAgainstReferenceOpenIntIntHashMap(){
  OpenIntIntHashMap base=new OpenIntIntHashMap();
  HashMap<Integer,Integer> reference=new HashMap<>();
  List<Operation> ops=Lists.newArrayList();
  addOp(ops,Operation.ADD,60);
  addOp(ops,Operation.REMOVE,30);
  addOp(ops,Operation.INDEXOF,30);
  addOp(ops,Operation.CLEAR,5);
  addOp(ops,Operation.ISEMPTY,2);
  addOp(ops,Operation.SIZE,2);
  int max=randomIntBetween(1000,20000);
  for (int reps=0; reps < max; reps++) {
    int k=randomIntBetween(0,max / 4);
    int v=randomInt();
switch (randomFrom(ops)) {
case ADD:
      Integer prevValue=reference.put(k,v);
    if (prevValue == null) {
      assertEquals(true,base.put(k,v));
    }
 else {
      assertEquals(prevValue.intValue(),base.get(k));
      assertEquals(false,base.put(k,v));
    }
  break;
case REMOVE:
assertEquals(reference.containsKey(k),base.containsKey(k));
Integer removed=reference.remove(k);
if (removed == null) {
assertEquals(false,base.removeKey(k));
}
 else {
assertEquals(removed.intValue(),base.get(k));
assertEquals(true,base.removeKey(k));
}
break;
case INDEXOF:
assertEquals(reference.containsKey(k),base.containsKey(k));
break;
case CLEAR:
reference.clear();
base.clear();
break;
case ISEMPTY:
assertEquals(reference.isEmpty(),base.isEmpty());
break;
case SIZE:
assertEquals(reference.size(),base.size());
break;
default :
throw new RuntimeException();
}
}
}
