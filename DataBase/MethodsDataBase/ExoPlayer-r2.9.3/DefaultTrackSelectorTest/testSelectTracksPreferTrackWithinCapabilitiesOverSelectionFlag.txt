/** 
 * Tests that track selector will prefer tracks that are within renderer's capabilities over tracks that have  {@link C#SELECTION_FLAG_DEFAULT} but exceed renderer's capabilities.
 */
@Test public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlag() throws Exception {
  Format supportedFormat=Format.createAudioSampleFormat("supportedFormat",MimeTypes.AUDIO_AAC,null,Format.NO_VALUE,Format.NO_VALUE,2,44100,null,null,0,null);
  Format exceededWithSelectionFlagFormat=Format.createAudioSampleFormat("exceededFormat",MimeTypes.AUDIO_AAC,null,Format.NO_VALUE,Format.NO_VALUE,2,44100,null,null,C.SELECTION_FLAG_DEFAULT,null);
  Map<String,Integer> mappedCapabilities=new HashMap<>();
  mappedCapabilities.put(supportedFormat.id,FORMAT_HANDLED);
  mappedCapabilities.put(exceededWithSelectionFlagFormat.id,FORMAT_EXCEEDS_CAPABILITIES);
  RendererCapabilities mappedAudioRendererCapabilities=new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO,mappedCapabilities);
  TrackSelectorResult result=trackSelector.selectTracks(new RendererCapabilities[]{mappedAudioRendererCapabilities},singleTrackGroup(exceededWithSelectionFlagFormat,supportedFormat));
  assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(supportedFormat);
}
