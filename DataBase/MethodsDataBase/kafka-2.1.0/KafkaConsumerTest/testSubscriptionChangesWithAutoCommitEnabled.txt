/** 
 * Verify that when a consumer changes its topic subscription its assigned partitions do not immediately change, and the latest consumed offsets of its to-be-revoked partitions are properly committed (when auto-commit is enabled). Upon unsubscribing from subscribed topics the consumer subscription and assignment are both updated right away but its consumed offsets are not auto committed.
 */
@Test public void testSubscriptionChangesWithAutoCommitEnabled(){
  Time time=new MockTime();
  Map<String,Integer> tpCounts=new HashMap<>();
  tpCounts.put(topic,1);
  tpCounts.put(topic2,1);
  tpCounts.put(topic3,1);
  Cluster cluster=TestUtils.singletonCluster(tpCounts);
  Node node=cluster.nodes().get(0);
  Metadata metadata=createMetadata();
  metadata.update(cluster,Collections.<String>emptySet(),time.milliseconds());
  MockClient client=new MockClient(time,metadata);
  client.setNode(node);
  PartitionAssignor assignor=new RangeAssignor();
  KafkaConsumer<String,String> consumer=newConsumer(time,client,metadata,assignor,true);
  consumer.subscribe(Arrays.asList(topic,topic2),getConsumerRebalanceListener(consumer));
  assertTrue(consumer.subscription().size() == 2);
  assertTrue(consumer.subscription().contains(topic) && consumer.subscription().contains(topic2));
  assertTrue(consumer.assignment().isEmpty());
  Node coordinator=prepareRebalance(client,node,assignor,Arrays.asList(tp0,t2p0),null);
  consumer.updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE));
  consumer.poll(Duration.ZERO);
  assertEquals(2,consumer.subscription().size());
  assertTrue(consumer.subscription().contains(topic) && consumer.subscription().contains(topic2));
  assertEquals(2,consumer.assignment().size());
  assertTrue(consumer.assignment().contains(tp0) && consumer.assignment().contains(t2p0));
  Map<TopicPartition,FetchInfo> fetches1=new HashMap<>();
  fetches1.put(tp0,new FetchInfo(0,1));
  fetches1.put(t2p0,new FetchInfo(0,10));
  client.respondFrom(fetchResponse(fetches1),node);
  client.poll(0,time.milliseconds());
  ConsumerRecords<String,String> records=consumer.poll(Duration.ofMillis(1));
  fetches1.put(tp0,new FetchInfo(1,0));
  fetches1.put(t2p0,new FetchInfo(10,0));
  client.respondFrom(fetchResponse(fetches1),node);
  client.poll(0,time.milliseconds());
  assertEquals(11,records.count());
  assertEquals(1L,consumer.position(tp0));
  assertEquals(10L,consumer.position(t2p0));
  consumer.subscribe(Arrays.asList(topic,topic3),getConsumerRebalanceListener(consumer));
  assertTrue(consumer.subscription().size() == 2);
  assertTrue(consumer.subscription().contains(topic) && consumer.subscription().contains(topic3));
  assertTrue(consumer.assignment().size() == 2);
  assertTrue(consumer.assignment().contains(tp0) && consumer.assignment().contains(t2p0));
  Map<TopicPartition,Long> partitionOffsets1=new HashMap<>();
  partitionOffsets1.put(tp0,1L);
  partitionOffsets1.put(t2p0,10L);
  AtomicBoolean commitReceived=prepareOffsetCommitResponse(client,coordinator,partitionOffsets1);
  prepareRebalance(client,node,assignor,Arrays.asList(tp0,t3p0),coordinator);
  Map<TopicPartition,FetchInfo> fetches2=new HashMap<>();
  fetches2.put(tp0,new FetchInfo(1,1));
  fetches2.put(t3p0,new FetchInfo(0,100));
  client.prepareResponse(fetchResponse(fetches2));
  records=consumer.poll(Duration.ofMillis(1));
  assertEquals(101,records.count());
  assertEquals(2L,consumer.position(tp0));
  assertEquals(100L,consumer.position(t3p0));
  assertTrue(commitReceived.get());
  assertTrue(consumer.subscription().size() == 2);
  assertTrue(consumer.subscription().contains(topic) && consumer.subscription().contains(topic3));
  assertTrue(consumer.assignment().size() == 2);
  assertTrue(consumer.assignment().contains(tp0) && consumer.assignment().contains(t3p0));
  consumer.unsubscribe();
  assertTrue(consumer.subscription().isEmpty());
  assertTrue(consumer.assignment().isEmpty());
  client.requests().clear();
  consumer.close();
}
