@Test public void testDisallowCommitOnProduceFailure() throws InterruptedException {
  final long pid=13131L;
  final short epoch=1;
  doInitTransactions(pid,epoch);
  transactionManager.beginTransaction();
  transactionManager.maybeAddPartitionToTransaction(tp0);
  Future<RecordMetadata> responseFuture=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT).future;
  TransactionalRequestResult commitResult=transactionManager.beginCommit();
  assertFalse(responseFuture.isDone());
  prepareAddPartitionsToTxnResponse(Errors.NONE,tp0,epoch,pid);
  prepareProduceResponse(Errors.OUT_OF_ORDER_SEQUENCE_NUMBER,pid,epoch);
  sender.run(time.milliseconds());
  assertFalse(commitResult.isCompleted());
  sender.run(time.milliseconds());
  sender.run(time.milliseconds());
  assertTrue(commitResult.isCompleted());
  try {
    commitResult.await();
    fail();
  }
 catch (  KafkaException e) {
  }
  try {
    responseFuture.get();
    fail("Expected produce future to raise an exception");
  }
 catch (  ExecutionException e) {
    assertTrue(e.getCause() instanceof OutOfOrderSequenceException);
  }
  TransactionalRequestResult abortResult=transactionManager.beginAbort();
  prepareEndTxnResponse(Errors.NONE,TransactionResult.ABORT,pid,epoch);
  sender.run(time.milliseconds());
  assertTrue(abortResult.isCompleted());
  assertTrue(abortResult.isSuccessful());
  assertTrue(transactionManager.isReady());
}
