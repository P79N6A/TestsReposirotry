@Test public void testNoDrainWhenPartitionsPending() throws InterruptedException {
  final long pid=13131L;
  final short epoch=1;
  doInitTransactions(pid,epoch);
  transactionManager.beginTransaction();
  transactionManager.maybeAddPartitionToTransaction(tp0);
  accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT);
  transactionManager.maybeAddPartitionToTransaction(tp1);
  accumulator.append(tp1,time.milliseconds(),"key".getBytes(),"value".getBytes(),Record.EMPTY_HEADERS,null,MAX_BLOCK_TIMEOUT);
  assertFalse(transactionManager.isSendToPartitionAllowed(tp0));
  assertFalse(transactionManager.isSendToPartitionAllowed(tp1));
  Node node1=new Node(0,"localhost",1111);
  Node node2=new Node(1,"localhost",1112);
  PartitionInfo part1=new PartitionInfo(topic,0,node1,null,null);
  PartitionInfo part2=new PartitionInfo(topic,1,node2,null,null);
  Cluster cluster=new Cluster(null,Arrays.asList(node1,node2),Arrays.asList(part1,part2),Collections.<String>emptySet(),Collections.<String>emptySet());
  Set<Node> nodes=new HashSet<>();
  nodes.add(node1);
  nodes.add(node2);
  Map<Integer,List<ProducerBatch>> drainedBatches=accumulator.drain(cluster,nodes,Integer.MAX_VALUE,time.milliseconds());
  assertTrue(drainedBatches.containsKey(node1.id()));
  assertTrue(drainedBatches.get(node1.id()).isEmpty());
  assertTrue(drainedBatches.containsKey(node2.id()));
  assertTrue(drainedBatches.get(node2.id()).isEmpty());
  assertFalse(transactionManager.hasError());
}
