@Test public void shouldBeReentrantAndNotBreakLRU(){
  final LRUCacheEntry dirty=new LRUCacheEntry(new byte[]{3},null,true,0,0,0,"");
  final LRUCacheEntry clean=new LRUCacheEntry(new byte[]{3});
  cache.put(Bytes.wrap(new byte[]{0}),dirty);
  cache.put(Bytes.wrap(new byte[]{1}),clean);
  cache.put(Bytes.wrap(new byte[]{2}),clean);
  assertEquals(3 * cache.head().size(),cache.sizeInBytes());
  cache.setListener(new ThreadCache.DirtyEntryFlushListener(){
    @Override public void apply(    final List<ThreadCache.DirtyEntry> dirty){
      cache.put(Bytes.wrap(new byte[]{3}),clean);
      cache.evict();
      cache.evict();
    }
  }
);
  assertEquals(3 * cache.head().size(),cache.sizeInBytes());
  cache.evict();
  final Bytes entryFour=Bytes.wrap(new byte[]{4});
  cache.put(entryFour,dirty);
  final NamedCache.LRUNode head=cache.head();
  final NamedCache.LRUNode tail=cache.tail();
  assertEquals(2,cache.size());
  assertEquals(2 * head.size(),cache.sizeInBytes());
  assertEquals(entryFour,head.key());
  assertEquals(Bytes.wrap(new byte[]{3}),tail.key());
  assertSame(tail,head.next());
  assertNull(head.previous());
  assertSame(head,tail.previous());
  assertNull(tail.next());
  cache.evict();
  assertSame(cache.head(),cache.tail());
  assertEquals(entryFour,cache.head().key());
  assertNull(cache.head().next());
  assertNull(cache.head().previous());
}
