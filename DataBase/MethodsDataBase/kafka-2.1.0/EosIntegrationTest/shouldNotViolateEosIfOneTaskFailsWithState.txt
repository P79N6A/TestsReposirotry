@Test public void shouldNotViolateEosIfOneTaskFailsWithState() throws Exception {
  final KafkaStreams streams=getKafkaStreams(true,"appDir",2);
  try {
    streams.start();
    final List<KeyValue<Long,Long>> committedDataBeforeFailure=prepareData(0L,10L,0L,1L);
    final List<KeyValue<Long,Long>> uncommittedDataBeforeFailure=prepareData(10L,15L,0L,1L,2L,3L);
    final List<KeyValue<Long,Long>> dataBeforeFailure=new ArrayList<>();
    dataBeforeFailure.addAll(committedDataBeforeFailure);
    dataBeforeFailure.addAll(uncommittedDataBeforeFailure);
    final List<KeyValue<Long,Long>> dataAfterFailure=prepareData(15L,20L,0L,1L);
    writeInputData(committedDataBeforeFailure);
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return commitRequested.get() == 2;
      }
    }
,MAX_WAIT_TIME_MS,"SteamsTasks did not request commit.");
    writeInputData(uncommittedDataBeforeFailure);
    final List<KeyValue<Long,Long>> uncommittedRecords=readResult(dataBeforeFailure.size(),null);
    final List<KeyValue<Long,Long>> committedRecords=readResult(committedDataBeforeFailure.size(),CONSUMER_GROUP_ID);
    final List<KeyValue<Long,Long>> expectedResultBeforeFailure=computeExpectedResult(dataBeforeFailure);
    checkResultPerKey(committedRecords,computeExpectedResult(committedDataBeforeFailure));
    checkResultPerKey(uncommittedRecords,expectedResultBeforeFailure);
    verifyStateStore(streams,getMaxPerKey(expectedResultBeforeFailure));
    errorInjected.set(true);
    writeInputData(dataAfterFailure);
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return uncaughtException != null;
      }
    }
,MAX_WAIT_TIME_MS,"Should receive uncaught exception from one StreamThread.");
    final List<KeyValue<Long,Long>> allCommittedRecords=readResult(committedDataBeforeFailure.size() + uncommittedDataBeforeFailure.size() + dataAfterFailure.size(),CONSUMER_GROUP_ID + "_ALL");
    final List<KeyValue<Long,Long>> committedRecordsAfterFailure=readResult(uncommittedDataBeforeFailure.size() + dataAfterFailure.size(),CONSUMER_GROUP_ID);
    final List<KeyValue<Long,Long>> allExpectedCommittedRecordsAfterRecovery=new ArrayList<>();
    allExpectedCommittedRecordsAfterRecovery.addAll(committedDataBeforeFailure);
    allExpectedCommittedRecordsAfterRecovery.addAll(uncommittedDataBeforeFailure);
    allExpectedCommittedRecordsAfterRecovery.addAll(dataAfterFailure);
    final List<KeyValue<Long,Long>> expectedResult=computeExpectedResult(allExpectedCommittedRecordsAfterRecovery);
    checkResultPerKey(allCommittedRecords,expectedResult);
    checkResultPerKey(committedRecordsAfterFailure,expectedResult.subList(committedDataBeforeFailure.size(),expectedResult.size()));
    verifyStateStore(streams,getMaxPerKey(expectedResult));
  }
  finally {
    streams.close();
  }
}
