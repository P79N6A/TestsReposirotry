@Test public void shouldNotViolateEosIfOneTaskFails() throws Exception {
  final KafkaStreams streams=getKafkaStreams(false,"appDir",2);
  try {
    streams.start();
    final List<KeyValue<Long,Long>> committedDataBeforeFailure=prepareData(0L,10L,0L,1L);
    final List<KeyValue<Long,Long>> uncommittedDataBeforeFailure=prepareData(10L,15L,0L,1L);
    final List<KeyValue<Long,Long>> dataBeforeFailure=new ArrayList<>();
    dataBeforeFailure.addAll(committedDataBeforeFailure);
    dataBeforeFailure.addAll(uncommittedDataBeforeFailure);
    final List<KeyValue<Long,Long>> dataAfterFailure=prepareData(15L,20L,0L,1L);
    writeInputData(committedDataBeforeFailure);
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return commitRequested.get() == 2;
      }
    }
,MAX_WAIT_TIME_MS,"SteamsTasks did not request commit.");
    writeInputData(uncommittedDataBeforeFailure);
    final List<KeyValue<Long,Long>> uncommittedRecords=readResult(dataBeforeFailure.size(),null);
    final List<KeyValue<Long,Long>> committedRecords=readResult(committedDataBeforeFailure.size(),CONSUMER_GROUP_ID);
    checkResultPerKey(committedRecords,committedDataBeforeFailure);
    checkResultPerKey(uncommittedRecords,dataBeforeFailure);
    errorInjected.set(true);
    writeInputData(dataAfterFailure);
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return uncaughtException != null;
      }
    }
,MAX_WAIT_TIME_MS,"Should receive uncaught exception from one StreamThread.");
    final List<KeyValue<Long,Long>> allCommittedRecords=readResult(committedDataBeforeFailure.size() + uncommittedDataBeforeFailure.size() + dataAfterFailure.size(),CONSUMER_GROUP_ID + "_ALL");
    final List<KeyValue<Long,Long>> committedRecordsAfterFailure=readResult(uncommittedDataBeforeFailure.size() + dataAfterFailure.size(),CONSUMER_GROUP_ID);
    final List<KeyValue<Long,Long>> allExpectedCommittedRecordsAfterRecovery=new ArrayList<>();
    allExpectedCommittedRecordsAfterRecovery.addAll(committedDataBeforeFailure);
    allExpectedCommittedRecordsAfterRecovery.addAll(uncommittedDataBeforeFailure);
    allExpectedCommittedRecordsAfterRecovery.addAll(dataAfterFailure);
    final List<KeyValue<Long,Long>> expectedCommittedRecordsAfterRecovery=new ArrayList<>();
    expectedCommittedRecordsAfterRecovery.addAll(uncommittedDataBeforeFailure);
    expectedCommittedRecordsAfterRecovery.addAll(dataAfterFailure);
    checkResultPerKey(allCommittedRecords,allExpectedCommittedRecordsAfterRecovery);
    checkResultPerKey(committedRecordsAfterFailure,expectedCommittedRecordsAfterRecovery);
  }
  finally {
    streams.close();
  }
}
