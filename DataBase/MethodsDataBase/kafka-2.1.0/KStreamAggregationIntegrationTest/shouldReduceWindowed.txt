@Test public void shouldReduceWindowed() throws Exception {
  final long firstBatchTimestamp=mockTime.milliseconds();
  mockTime.sleep(1000);
  produceMessages(firstBatchTimestamp);
  final long secondBatchTimestamp=mockTime.milliseconds();
  produceMessages(secondBatchTimestamp);
  produceMessages(secondBatchTimestamp);
  final Serde<Windowed<String>> windowedSerde=WindowedSerdes.timeWindowedSerdeFrom(String.class);
  groupedStream.windowedBy(TimeWindows.of(ofMillis(500L))).reduce(reducer).toStream().to(outputTopic,Produced.with(windowedSerde,Serdes.String()));
  startStreams();
  final List<KeyValue<Windowed<String>,String>> windowedOutput=receiveMessages(new TimeWindowedDeserializer<>(),new StringDeserializer(),String.class,15);
  final String resultFromConsoleConsumer=readWindowedKeyedMessagesViaConsoleConsumer(new TimeWindowedDeserializer<String>(),new StringDeserializer(),String.class,15,false);
  final Comparator<KeyValue<Windowed<String>,String>> comparator=Comparator.comparing((  KeyValue<Windowed<String>,String> o) -> o.key.key()).thenComparing(o -> o.value);
  Collections.sort(windowedOutput,comparator);
  final long firstBatchWindow=firstBatchTimestamp / 500 * 500;
  final long secondBatchWindow=secondBatchTimestamp / 500 * 500;
  final List<KeyValue<Windowed<String>,String>> expectResult=Arrays.asList(new KeyValue<>(new Windowed<>("A",new TimeWindow(firstBatchWindow,Long.MAX_VALUE)),"A"),new KeyValue<>(new Windowed<>("A",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"A"),new KeyValue<>(new Windowed<>("A",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"A:A"),new KeyValue<>(new Windowed<>("B",new TimeWindow(firstBatchWindow,Long.MAX_VALUE)),"B"),new KeyValue<>(new Windowed<>("B",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"B"),new KeyValue<>(new Windowed<>("B",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"B:B"),new KeyValue<>(new Windowed<>("C",new TimeWindow(firstBatchWindow,Long.MAX_VALUE)),"C"),new KeyValue<>(new Windowed<>("C",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"C"),new KeyValue<>(new Windowed<>("C",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"C:C"),new KeyValue<>(new Windowed<>("D",new TimeWindow(firstBatchWindow,Long.MAX_VALUE)),"D"),new KeyValue<>(new Windowed<>("D",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"D"),new KeyValue<>(new Windowed<>("D",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"D:D"),new KeyValue<>(new Windowed<>("E",new TimeWindow(firstBatchWindow,Long.MAX_VALUE)),"E"),new KeyValue<>(new Windowed<>("E",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"E"),new KeyValue<>(new Windowed<>("E",new TimeWindow(secondBatchWindow,Long.MAX_VALUE)),"E:E"));
  assertThat(windowedOutput,is(expectResult));
  final Set<String> expectResultString=new HashSet<>(expectResult.size());
  for (  final KeyValue<Windowed<String>,String> eachRecord : expectResult) {
    expectResultString.add(eachRecord.toString());
  }
  final String[] allRecords=resultFromConsoleConsumer.split("\n");
  for (  final String record : allRecords) {
    assertTrue(expectResultString.contains("KeyValue(" + record + ")"));
  }
}
