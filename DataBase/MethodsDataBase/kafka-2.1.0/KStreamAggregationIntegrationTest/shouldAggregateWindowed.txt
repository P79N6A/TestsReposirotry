@Test public void shouldAggregateWindowed() throws Exception {
  final long firstTimestamp=mockTime.milliseconds();
  mockTime.sleep(1000);
  produceMessages(firstTimestamp);
  final long secondTimestamp=mockTime.milliseconds();
  produceMessages(secondTimestamp);
  produceMessages(secondTimestamp);
  final Serde<Windowed<String>> windowedSerde=WindowedSerdes.timeWindowedSerdeFrom(String.class);
  groupedStream.windowedBy(TimeWindows.of(ofMillis(500L))).aggregate(initializer,aggregator,Materialized.with(null,Serdes.Integer())).toStream().to(outputTopic,Produced.with(windowedSerde,Serdes.Integer()));
  startStreams();
  final List<KeyValue<Windowed<String>,KeyValue<Integer,Long>>> windowedMessages=receiveMessagesWithTimestamp(new TimeWindowedDeserializer<>(),new IntegerDeserializer(),String.class,15);
  final String resultFromConsoleConsumer=readWindowedKeyedMessagesViaConsoleConsumer(new TimeWindowedDeserializer<String>(),new IntegerDeserializer(),String.class,15,true);
  final Comparator<KeyValue<Windowed<String>,KeyValue<Integer,Long>>> comparator=Comparator.comparing((  KeyValue<Windowed<String>,KeyValue<Integer,Long>> o) -> o.key.key()).thenComparingInt(o -> o.value.key);
  Collections.sort(windowedMessages,comparator);
  final long firstWindow=firstTimestamp / 500 * 500;
  final long secondWindow=secondTimestamp / 500 * 500;
  final List<KeyValue<Windowed<String>,KeyValue<Integer,Long>>> expectResult=Arrays.asList(new KeyValue<>(new Windowed<>("A",new TimeWindow(firstWindow,Long.MAX_VALUE)),KeyValue.pair(1,firstTimestamp)),new KeyValue<>(new Windowed<>("A",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(1,secondTimestamp)),new KeyValue<>(new Windowed<>("A",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(2,secondTimestamp)),new KeyValue<>(new Windowed<>("B",new TimeWindow(firstWindow,Long.MAX_VALUE)),KeyValue.pair(1,firstTimestamp)),new KeyValue<>(new Windowed<>("B",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(1,secondTimestamp)),new KeyValue<>(new Windowed<>("B",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(2,secondTimestamp)),new KeyValue<>(new Windowed<>("C",new TimeWindow(firstWindow,Long.MAX_VALUE)),KeyValue.pair(1,firstTimestamp)),new KeyValue<>(new Windowed<>("C",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(1,secondTimestamp)),new KeyValue<>(new Windowed<>("C",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(2,secondTimestamp)),new KeyValue<>(new Windowed<>("D",new TimeWindow(firstWindow,Long.MAX_VALUE)),KeyValue.pair(1,firstTimestamp)),new KeyValue<>(new Windowed<>("D",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(1,secondTimestamp)),new KeyValue<>(new Windowed<>("D",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(2,secondTimestamp)),new KeyValue<>(new Windowed<>("E",new TimeWindow(firstWindow,Long.MAX_VALUE)),KeyValue.pair(1,firstTimestamp)),new KeyValue<>(new Windowed<>("E",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(1,secondTimestamp)),new KeyValue<>(new Windowed<>("E",new TimeWindow(secondWindow,Long.MAX_VALUE)),KeyValue.pair(2,secondTimestamp)));
  assertThat(windowedMessages,is(expectResult));
  final Set<String> expectResultString=new HashSet<>(expectResult.size());
  for (  final KeyValue<Windowed<String>,KeyValue<Integer,Long>> eachRecord : expectResult) {
    expectResultString.add("CreateTime:" + eachRecord.value.value + ", "+ eachRecord.key.toString()+ ", "+ eachRecord.value.key);
  }
  final String[] allRecords=resultFromConsoleConsumer.split("\n");
  for (  final String record : allRecords) {
    assertTrue(expectResultString.contains(record));
  }
}
