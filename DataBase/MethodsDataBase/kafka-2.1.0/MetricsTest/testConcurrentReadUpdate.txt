/** 
 * Verifies that concurrent sensor add, remove, updates and read don't result in errors or deadlock.
 */
@Test public void testConcurrentReadUpdate() throws Exception {
  final Random random=new Random();
  final Deque<Sensor> sensors=new ConcurrentLinkedDeque<>();
  metrics=new Metrics(new MockTime(10));
  SensorCreator sensorCreator=new SensorCreator(metrics);
  final AtomicBoolean alive=new AtomicBoolean(true);
  executorService=Executors.newSingleThreadExecutor();
  executorService.submit(new ConcurrentMetricOperation(alive,"record",() -> sensors.forEach(sensor -> sensor.record(random.nextInt(10000)))));
  for (int i=0; i < 10000; i++) {
    if (sensors.size() > 5) {
      Sensor sensor=random.nextBoolean() ? sensors.removeFirst() : sensors.removeLast();
      metrics.removeSensor(sensor.name());
    }
    StatType statType=StatType.forId(random.nextInt(StatType.values().length));
    sensors.add(sensorCreator.createSensor(statType,i));
    for (    Sensor sensor : sensors) {
      for (      KafkaMetric metric : sensor.metrics()) {
        assertNotNull("Invalid metric value",metric.metricValue());
      }
    }
  }
  alive.set(false);
}
