/** 
 * The Sensor#checkQuotas should be thread-safe since the method may be used by many ReplicaFetcherThreads.
 */
@Test public void testCheckQuotasInMultiThreads() throws InterruptedException, ExecutionException {
  final Metrics metrics=new Metrics(new MetricConfig().quota(Quota.upperBound(Double.MAX_VALUE)).timeWindow(1,TimeUnit.MILLISECONDS).samples(100));
  final Sensor sensor=metrics.sensor("sensor");
  assertTrue(sensor.add(metrics.metricName("test-metric","test-group"),new Rate()));
  final int threadCount=10;
  final CountDownLatch latch=new CountDownLatch(1);
  ExecutorService service=Executors.newFixedThreadPool(threadCount);
  List<Future<Throwable>> workers=new ArrayList<>(threadCount);
  boolean needShutdown=true;
  try {
    for (int i=0; i != threadCount; ++i) {
      final int index=i;
      workers.add(service.submit(new Callable<Throwable>(){
        @Override public Throwable call(){
          try {
            assertTrue(latch.await(5,TimeUnit.SECONDS));
            for (int j=0; j != 20; ++j) {
              sensor.record(j * index,System.currentTimeMillis() + j,false);
              sensor.checkQuotas();
            }
            return null;
          }
 catch (          Throwable e) {
            return e;
          }
        }
      }
));
    }
    latch.countDown();
    service.shutdown();
    assertTrue(service.awaitTermination(10,TimeUnit.SECONDS));
    needShutdown=false;
    for (    Future<Throwable> callable : workers) {
      assertTrue("If this failure happen frequently, we can try to increase the wait time",callable.isDone());
      assertNull("Sensor#checkQuotas SHOULD be thread-safe!",callable.get());
    }
  }
  finally {
    if (needShutdown) {
      service.shutdownNow();
    }
  }
}
