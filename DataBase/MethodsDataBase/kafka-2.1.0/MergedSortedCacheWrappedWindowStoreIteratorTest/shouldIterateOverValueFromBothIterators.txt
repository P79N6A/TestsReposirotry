@Test public void shouldIterateOverValueFromBothIterators(){
  final List<KeyValue<Long,byte[]>> expectedKvPairs=new ArrayList<>();
  for (long t=0; t < 100; t+=20) {
    final byte[] v1Bytes=String.valueOf(t).getBytes();
    final KeyValue<Long,byte[]> v1=KeyValue.pair(t,v1Bytes);
    windowStoreKvPairs.add(v1);
    expectedKvPairs.add(KeyValue.pair(t,v1Bytes));
    final Bytes keyBytes=WindowKeySchema.toStoreKeyBinary("a",t + 10,0,stateSerdes);
    final byte[] valBytes=String.valueOf(t + 10).getBytes();
    expectedKvPairs.add(KeyValue.pair(t + 10,valBytes));
    cache.put(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(keyBytes),new LRUCacheEntry(valBytes));
  }
  final Bytes fromBytes=WindowKeySchema.toStoreKeyBinary("a",0,0,stateSerdes);
  final Bytes toBytes=WindowKeySchema.toStoreKeyBinary("a",100,0,stateSerdes);
  final KeyValueIterator<Long,byte[]> storeIterator=new DelegatingPeekingKeyValueIterator<>("store",new KeyValueIteratorStub<>(windowStoreKvPairs.iterator()));
  final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator=cache.range(namespace,SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(fromBytes),SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(toBytes));
  final MergedSortedCacheWindowStoreIterator iterator=new MergedSortedCacheWindowStoreIterator(cacheIterator,storeIterator);
  int index=0;
  while (iterator.hasNext()) {
    final KeyValue<Long,byte[]> next=iterator.next();
    final KeyValue<Long,byte[]> expected=expectedKvPairs.get(index++);
    assertArrayEquals(expected.value,next.value);
    assertEquals(expected.key,next.key);
  }
  iterator.close();
}
