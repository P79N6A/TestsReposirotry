/** 
 * Testing a special case of final results: that even with a grace period of 0, it will still buffer events and emit only after the end of the window. As opposed to emitting immediately the way regular suppression would with a time limit of 0.
 */
@Test public void finalResultsWithZeroGraceShouldStillBufferUntilTheWindowEnd(){
  final Harness<Windowed<String>,Long> harness=new Harness<>(finalResults(ofMillis(0L)),timeWindowedSerdeFrom(String.class,100L),Long());
  final MockInternalProcessorContext context=harness.context;
  final KTableSuppressProcessor<Windowed<String>,Long> processor=harness.processor;
  final long timestamp=5L;
  final long streamTime=99L;
  final long windowEnd=100L;
  context.setRecordMetadata("",0,0L,null,timestamp);
  context.setStreamTime(streamTime);
  final Windowed<String> key=new Windowed<>("hey",new TimeWindow(0,windowEnd));
  final Change<Long> value=ARBITRARY_CHANGE;
  processor.process(key,value);
  assertThat(context.forwarded(),hasSize(0));
  context.setRecordMetadata("",0,1L,null,windowEnd);
  context.setStreamTime(windowEnd);
  processor.process(new Windowed<>("dummyKey",new TimeWindow(windowEnd,windowEnd + 100L)),ARBITRARY_CHANGE);
  assertThat(context.forwarded(),hasSize(1));
  final MockProcessorContext.CapturedForward capturedForward=context.forwarded().get(0);
  assertThat(capturedForward.keyValue(),is(new KeyValue<>(key,value)));
  assertThat(capturedForward.timestamp(),is(timestamp));
}
