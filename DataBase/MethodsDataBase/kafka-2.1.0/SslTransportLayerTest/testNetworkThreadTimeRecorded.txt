/** 
 * Tests that time spent on the network thread is accumulated on each channel
 */
@Test public void testNetworkThreadTimeRecorded() throws Exception {
  selector.close();
  this.selector=new Selector(NetworkReceive.UNLIMITED,Selector.NO_IDLE_TIMEOUT_MS,new Metrics(),Time.SYSTEM,"MetricGroup",new HashMap<String,String>(),false,true,channelBuilder,MemoryPool.NONE,new LogContext());
  String node="0";
  server=createEchoServer(SecurityProtocol.SSL);
  InetSocketAddress addr=new InetSocketAddress("localhost",server.port());
  selector.connect(node,addr,BUFFER_SIZE,BUFFER_SIZE);
  String message=TestUtils.randomString(1024 * 1024);
  NetworkTestUtils.waitForChannelReady(selector,node);
  final KafkaChannel channel=selector.channel(node);
  assertTrue("SSL handshake time not recorded",channel.getAndResetNetworkThreadTimeNanos() > 0);
  assertEquals("Time not reset",0,channel.getAndResetNetworkThreadTimeNanos());
  selector.mute(node);
  selector.send(new NetworkSend(node,ByteBuffer.wrap(message.getBytes())));
  while (selector.completedSends().isEmpty()) {
    selector.poll(100L);
  }
  long sendTimeNanos=channel.getAndResetNetworkThreadTimeNanos();
  assertTrue("Send time not recorded: " + sendTimeNanos,sendTimeNanos > 0);
  assertEquals("Time not reset",0,channel.getAndResetNetworkThreadTimeNanos());
  assertFalse("Unexpected bytes buffered",channel.hasBytesBuffered());
  assertEquals(0,selector.completedReceives().size());
  selector.unmute(node);
  TestUtils.waitForCondition(new TestCondition(){
    @Override public boolean conditionMet(){
      try {
        selector.poll(100L);
        assertEquals(0,selector.numStagedReceives(channel));
      }
 catch (      IOException e) {
        return false;
      }
      return !selector.completedReceives().isEmpty();
    }
  }
,"Timed out waiting for a message to receive from echo server");
  long receiveTimeNanos=channel.getAndResetNetworkThreadTimeNanos();
  assertTrue("Receive time not recorded: " + receiveTimeNanos,receiveTimeNanos > 0);
}
