@Test public void evict() throws IOException {
  final List<KeyValue<String,String>> received=new ArrayList<>();
  final List<KeyValue<String,String>> expected=Collections.singletonList(new KeyValue<>("K1","V1"));
  final List<KeyValue<String,String>> toInsert=Arrays.asList(new KeyValue<>("K1","V1"),new KeyValue<>("K2","V2"),new KeyValue<>("K3","V3"),new KeyValue<>("K4","V4"),new KeyValue<>("K5","V5"));
  final KeyValue<String,String> kv=toInsert.get(0);
  final ThreadCache cache=new ThreadCache(logContext,memoryCacheEntrySize(kv.key.getBytes(),kv.value.getBytes(),""),new MockStreamsMetrics(new Metrics()));
  cache.addDirtyEntryFlushListener(namespace,new ThreadCache.DirtyEntryFlushListener(){
    @Override public void apply(    final List<ThreadCache.DirtyEntry> dirty){
      for (      final ThreadCache.DirtyEntry dirtyEntry : dirty) {
        received.add(new KeyValue<>(dirtyEntry.key().toString(),new String(dirtyEntry.newValue())));
      }
    }
  }
);
  for (  final KeyValue<String,String> kvToInsert : toInsert) {
    final Bytes key=Bytes.wrap(kvToInsert.key.getBytes());
    final byte[] value=kvToInsert.value.getBytes();
    cache.put(namespace,key,new LRUCacheEntry(value,null,true,1,1,1,""));
  }
  for (int i=0; i < expected.size(); i++) {
    final KeyValue<String,String> expectedRecord=expected.get(i);
    final KeyValue<String,String> actualRecord=received.get(i);
    assertEquals(expectedRecord,actualRecord);
  }
  assertEquals(cache.evicts(),4);
}
