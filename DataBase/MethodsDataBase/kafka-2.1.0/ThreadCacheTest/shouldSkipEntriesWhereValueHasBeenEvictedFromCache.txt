@Test public void shouldSkipEntriesWhereValueHasBeenEvictedFromCache(){
  final int entrySize=memoryCacheEntrySize(new byte[1],new byte[1],"");
  final ThreadCache cache=new ThreadCache(logContext,entrySize * 5,new MockStreamsMetrics(new Metrics()));
  cache.addDirtyEntryFlushListener(namespace,new ThreadCache.DirtyEntryFlushListener(){
    @Override public void apply(    final List<ThreadCache.DirtyEntry> dirty){
    }
  }
);
  final byte[][] bytes={{0},{1},{2},{3},{4},{5},{6},{7},{8},{9}};
  for (int i=0; i < 5; i++) {
    cache.put(namespace,Bytes.wrap(bytes[i]),dirtyEntry(bytes[i]));
  }
  assertEquals(5,cache.size());
  final ThreadCache.MemoryLRUCacheBytesIterator range=cache.range(namespace,Bytes.wrap(new byte[]{0}),Bytes.wrap(new byte[]{5}));
  cache.put(namespace,Bytes.wrap(new byte[]{6}),dirtyEntry(new byte[]{6}));
  assertEquals(Bytes.wrap(new byte[]{1}),range.peekNextKey());
}
