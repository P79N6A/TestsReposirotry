@Test public void shouldNotLoopForEverWhenEvictingAndCurrentCacheIsEmpty(){
  final int maxCacheSizeInBytes=100;
  final ThreadCache threadCache=new ThreadCache(logContext,maxCacheSizeInBytes,new MockStreamsMetrics(new Metrics()));
  threadCache.addDirtyEntryFlushListener(namespace,new ThreadCache.DirtyEntryFlushListener(){
    @Override public void apply(    final List<ThreadCache.DirtyEntry> dirty){
      threadCache.put(namespace1,Bytes.wrap(new byte[]{0}),dirtyEntry(new byte[2]));
    }
  }
);
  threadCache.addDirtyEntryFlushListener(namespace1,new ThreadCache.DirtyEntryFlushListener(){
    @Override public void apply(    final List<ThreadCache.DirtyEntry> dirty){
    }
  }
);
  threadCache.addDirtyEntryFlushListener(namespace2,new ThreadCache.DirtyEntryFlushListener(){
    @Override public void apply(    final List<ThreadCache.DirtyEntry> dirty){
    }
  }
);
  threadCache.put(namespace2,Bytes.wrap(new byte[]{1}),dirtyEntry(new byte[1]));
  threadCache.put(namespace,Bytes.wrap(new byte[]{1}),dirtyEntry(new byte[1]));
  final int remaining=(int)(maxCacheSizeInBytes - threadCache.sizeBytes());
  threadCache.put(namespace,Bytes.wrap(new byte[]{2}),dirtyEntry(new byte[remaining + 100]));
}
