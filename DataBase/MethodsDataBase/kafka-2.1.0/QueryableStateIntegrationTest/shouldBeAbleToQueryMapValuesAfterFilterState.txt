@Test public void shouldBeAbleToQueryMapValuesAfterFilterState() throws Exception {
  streamsConfiguration.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG,Serdes.String().getClass());
  streamsConfiguration.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG,Serdes.String().getClass());
  final StreamsBuilder builder=new StreamsBuilder();
  final String[] keys={"hello","goodbye","welcome","go","kafka"};
  final Set<KeyValue<String,String>> batch1=new HashSet<>(Arrays.asList(new KeyValue<>(keys[0],"1"),new KeyValue<>(keys[1],"1"),new KeyValue<>(keys[2],"3"),new KeyValue<>(keys[3],"5"),new KeyValue<>(keys[4],"2")));
  final Set<KeyValue<String,Long>> expectedBatch1=new HashSet<>(Collections.singleton(new KeyValue<>(keys[4],2L)));
  IntegrationTestUtils.produceKeyValuesSynchronously(streamOne,batch1,TestUtils.producerConfig(CLUSTER.bootstrapServers(),StringSerializer.class,StringSerializer.class,new Properties()),mockTime);
  final Predicate<String,String> filterPredicate=new Predicate<String,String>(){
    @Override public boolean test(    final String key,    final String value){
      return key.contains("kafka");
    }
  }
;
  final KTable<String,String> t1=builder.table(streamOne);
  final KTable<String,String> t2=t1.filter(filterPredicate,Materialized.<String,String,KeyValueStore<Bytes,byte[]>>as("queryFilter"));
  final KTable<String,Long> t3=t2.mapValues(new ValueMapper<String,Long>(){
    @Override public Long apply(    final String value){
      return Long.valueOf(value);
    }
  }
,Materialized.<String,Long,KeyValueStore<Bytes,byte[]>>as("queryMapValues").withValueSerde(Serdes.Long()));
  t3.toStream().to(outputTopic,Produced.with(Serdes.String(),Serdes.Long()));
  kafkaStreams=new KafkaStreams(builder.build(),streamsConfiguration);
  kafkaStreams.start();
  waitUntilAtLeastNumRecordProcessed(outputTopic,1);
  final ReadOnlyKeyValueStore<String,Long> myMapStore=kafkaStreams.store("queryMapValues",QueryableStoreTypes.<String,Long>keyValueStore());
  for (  final KeyValue<String,Long> expectedEntry : expectedBatch1) {
    assertEquals(myMapStore.get(expectedEntry.key),expectedEntry.value);
  }
  for (  final KeyValue<String,String> batchEntry : batch1) {
    final KeyValue<String,Long> batchEntryMapValue=new KeyValue<>(batchEntry.key,Long.valueOf(batchEntry.value));
    if (!expectedBatch1.contains(batchEntryMapValue)) {
      assertNull(myMapStore.get(batchEntry.key));
    }
  }
}
