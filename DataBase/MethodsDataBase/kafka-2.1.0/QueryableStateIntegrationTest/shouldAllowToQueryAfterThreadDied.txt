@Test public void shouldAllowToQueryAfterThreadDied() throws Exception {
  final AtomicBoolean beforeFailure=new AtomicBoolean(true);
  final AtomicBoolean failed=new AtomicBoolean(false);
  final String storeName="store";
  final StreamsBuilder builder=new StreamsBuilder();
  final KStream<String,String> input=builder.stream(streamOne);
  input.groupByKey().reduce(new Reducer<String>(){
    @Override public String apply(    final String value1,    final String value2){
      if (value1.length() > 1) {
        if (beforeFailure.compareAndSet(true,false)) {
          throw new RuntimeException("Injected test exception");
        }
      }
      return value1 + value2;
    }
  }
,Materialized.<String,String,KeyValueStore<Bytes,byte[]>>as(storeName)).toStream().to(outputTopic);
  streamsConfiguration.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG,2);
  kafkaStreams=new KafkaStreams(builder.build(),streamsConfiguration);
  kafkaStreams.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    final Thread t,    final Throwable e){
      failed.set(true);
    }
  }
);
  kafkaStreams.start();
  IntegrationTestUtils.produceKeyValuesSynchronously(streamOne,Arrays.asList(KeyValue.pair("a","1"),KeyValue.pair("a","2"),KeyValue.pair("b","3"),KeyValue.pair("b","4")),TestUtils.producerConfig(CLUSTER.bootstrapServers(),StringSerializer.class,StringSerializer.class,new Properties()),mockTime);
  final int maxWaitMs=30000;
  TestUtils.waitForCondition(new WaitForStore(storeName),maxWaitMs,"waiting for store " + storeName);
  final ReadOnlyKeyValueStore<String,String> store=kafkaStreams.store(storeName,QueryableStoreTypes.<String,String>keyValueStore());
  TestUtils.waitForCondition(new TestCondition(){
    @Override public boolean conditionMet(){
      return "12".equals(store.get("a")) && "34".equals(store.get("b"));
    }
  }
,maxWaitMs,"wait for agg to be <a,12> and <b,34>");
  IntegrationTestUtils.produceKeyValuesSynchronously(streamOne,Collections.singleton(KeyValue.pair("a","5")),TestUtils.producerConfig(CLUSTER.bootstrapServers(),StringSerializer.class,StringSerializer.class,new Properties()),mockTime);
  TestUtils.waitForCondition(new TestCondition(){
    @Override public boolean conditionMet(){
      return failed.get();
    }
  }
,30000,"wait for thread to fail");
  TestUtils.waitForCondition(new WaitForStore(storeName),maxWaitMs,"waiting for store " + storeName);
  final ReadOnlyKeyValueStore<String,String> store2=kafkaStreams.store(storeName,QueryableStoreTypes.<String,String>keyValueStore());
  try {
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return ("125".equals(store2.get("a")) || "1225".equals(store2.get("a")) || "12125".equals(store2.get("a"))) && ("34".equals(store2.get("b")) || "344".equals(store2.get("b")) || "3434".equals(store2.get("b")));
      }
    }
,maxWaitMs,"wait for agg to be <a,125>||<a,1225>||<a,12125> and <b,34>||<b,344>||<b,3434>");
  }
 catch (  final Throwable t) {
    throw new RuntimeException("Store content is a: " + store2.get("a") + "; b: "+ store2.get("b"),t);
  }
}
