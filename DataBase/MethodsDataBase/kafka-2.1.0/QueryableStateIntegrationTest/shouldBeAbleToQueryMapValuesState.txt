@Test public void shouldBeAbleToQueryMapValuesState() throws Exception {
  streamsConfiguration.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG,Serdes.String().getClass());
  streamsConfiguration.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG,Serdes.String().getClass());
  final StreamsBuilder builder=new StreamsBuilder();
  final String[] keys={"hello","goodbye","welcome","go","kafka"};
  final Set<KeyValue<String,String>> batch1=new HashSet<>(Arrays.asList(new KeyValue<>(keys[0],"1"),new KeyValue<>(keys[1],"1"),new KeyValue<>(keys[2],"3"),new KeyValue<>(keys[3],"5"),new KeyValue<>(keys[4],"2")));
  IntegrationTestUtils.produceKeyValuesSynchronously(streamOne,batch1,TestUtils.producerConfig(CLUSTER.bootstrapServers(),StringSerializer.class,StringSerializer.class,new Properties()),mockTime);
  final KTable<String,String> t1=builder.table(streamOne);
  t1.mapValues(new ValueMapper<String,Long>(){
    @Override public Long apply(    final String value){
      return Long.valueOf(value);
    }
  }
,Materialized.<String,Long,KeyValueStore<Bytes,byte[]>>as("queryMapValues").withValueSerde(Serdes.Long())).toStream().to(outputTopic,Produced.with(Serdes.String(),Serdes.Long()));
  kafkaStreams=new KafkaStreams(builder.build(),streamsConfiguration);
  kafkaStreams.start();
  waitUntilAtLeastNumRecordProcessed(outputTopic,5);
  final ReadOnlyKeyValueStore<String,Long> myMapStore=kafkaStreams.store("queryMapValues",QueryableStoreTypes.<String,Long>keyValueStore());
  for (  final KeyValue<String,String> batchEntry : batch1) {
    assertEquals(Long.valueOf(batchEntry.value),myMapStore.get(batchEntry.key));
  }
}
