@Test public void shouldNotMakeStoreAvailableUntilAllStoresAvailable() throws Exception {
  final StreamsBuilder builder=new StreamsBuilder();
  final KStream<String,String> stream=builder.stream(streamThree);
  final String storeName="count-by-key";
  stream.groupByKey().count(Materialized.<String,Long,KeyValueStore<Bytes,byte[]>>as(storeName));
  kafkaStreams=new KafkaStreams(builder.build(),streamsConfiguration);
  kafkaStreams.start();
  final KeyValue<String,String> hello=KeyValue.pair("hello","hello");
  IntegrationTestUtils.produceKeyValuesSynchronously(streamThree,Arrays.asList(hello,hello,hello,hello,hello,hello,hello,hello),TestUtils.producerConfig(CLUSTER.bootstrapServers(),StringSerializer.class,StringSerializer.class,new Properties()),mockTime);
  final int maxWaitMs=30000;
  TestUtils.waitForCondition(new WaitForStore(storeName),maxWaitMs,"waiting for store " + storeName);
  final ReadOnlyKeyValueStore<String,Long> store=kafkaStreams.store(storeName,QueryableStoreTypes.<String,Long>keyValueStore());
  TestUtils.waitForCondition(new TestCondition(){
    @Override public boolean conditionMet(){
      return new Long(8).equals(store.get("hello"));
    }
  }
,maxWaitMs,"wait for count to be 8");
  kafkaStreams.close();
  kafkaStreams=new KafkaStreams(builder.build(),streamsConfiguration);
  kafkaStreams.start();
  TestUtils.waitForCondition(new TestCondition(){
    @Override public boolean conditionMet(){
      try {
        assertEquals(Long.valueOf(8L),kafkaStreams.store(storeName,QueryableStoreTypes.<String,Long>keyValueStore()).get("hello"));
        return true;
      }
 catch (      final InvalidStateStoreException ise) {
        return false;
      }
    }
  }
,maxWaitMs,"waiting for store " + storeName);
}
