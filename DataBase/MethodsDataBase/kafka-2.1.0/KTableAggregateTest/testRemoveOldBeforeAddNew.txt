@Test public void testRemoveOldBeforeAddNew(){
  final StreamsBuilder builder=new StreamsBuilder();
  final String input="count-test-input";
  final MockProcessorSupplier<String,String> supplier=new MockProcessorSupplier<>();
  builder.table(input,consumed).groupBy(new KeyValueMapper<String,String,KeyValue<String,String>>(){
    @Override public KeyValue<String,String> apply(    final String key,    final String value){
      return KeyValue.pair(String.valueOf(key.charAt(0)),String.valueOf(key.charAt(1)));
    }
  }
,stringSerialzied).aggregate(new Initializer<String>(){
    @Override public String apply(){
      return "";
    }
  }
,new Aggregator<String,String,String>(){
    @Override public String apply(    final String aggKey,    final String value,    final String aggregate){
      return aggregate + value;
    }
  }
,new Aggregator<String,String,String>(){
    @Override public String apply(    final String key,    final String value,    final String aggregate){
      return aggregate.replaceAll(value,"");
    }
  }
,Materialized.<String,String,KeyValueStore<Bytes,byte[]>>as("someStore").withValueSerde(Serdes.String())).toStream().process(supplier);
  driver.setUp(builder,stateDir);
  final MockProcessor<String,String> proc=supplier.theCapturedProcessor();
  driver.process(input,"11","A");
  driver.flushState();
  driver.process(input,"12","B");
  driver.flushState();
  driver.process(input,"11",null);
  driver.flushState();
  driver.process(input,"12","C");
  driver.flushState();
  assertEquals(Utils.mkList("1:1","1:12","1:2","1:2"),proc.processed);
}
