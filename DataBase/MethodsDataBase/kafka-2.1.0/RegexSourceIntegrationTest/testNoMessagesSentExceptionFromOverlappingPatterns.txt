@Test public void testNoMessagesSentExceptionFromOverlappingPatterns() throws Exception {
  final String fMessage="fMessage";
  final String fooMessage="fooMessage";
  final Serde<String> stringSerde=Serdes.String();
  final StreamsBuilder builder=new StreamsBuilder();
  final KStream<String,String> pattern1Stream=builder.stream(Pattern.compile("foo.*"));
  final KStream<String,String> pattern2Stream=builder.stream(Pattern.compile("f.*"));
  pattern1Stream.to(DEFAULT_OUTPUT_TOPIC,Produced.with(stringSerde,stringSerde));
  pattern2Stream.to(DEFAULT_OUTPUT_TOPIC,Produced.with(stringSerde,stringSerde));
  final AtomicBoolean expectError=new AtomicBoolean(false);
  streams=new KafkaStreams(builder.build(),streamsConfiguration);
  streams.setStateListener(new KafkaStreams.StateListener(){
    @Override public void onChange(    final KafkaStreams.State newState,    final KafkaStreams.State oldState){
      if (newState == KafkaStreams.State.ERROR)       expectError.set(true);
    }
  }
);
  streams.start();
  final Properties producerConfig=TestUtils.producerConfig(CLUSTER.bootstrapServers(),StringSerializer.class,StringSerializer.class);
  IntegrationTestUtils.produceValuesSynchronously(FA_TOPIC,Arrays.asList(fMessage),producerConfig,mockTime);
  IntegrationTestUtils.produceValuesSynchronously(FOO_TOPIC,Arrays.asList(fooMessage),producerConfig,mockTime);
  final Properties consumerConfig=TestUtils.consumerConfig(CLUSTER.bootstrapServers(),StringDeserializer.class,StringDeserializer.class);
  try {
    IntegrationTestUtils.waitUntilMinKeyValueRecordsReceived(consumerConfig,DEFAULT_OUTPUT_TOPIC,2,5000);
    throw new IllegalStateException("This should not happen: an assertion error should have been thrown before this.");
  }
 catch (  final AssertionError e) {
  }
  assertThat(expectError.get(),is(true));
}
