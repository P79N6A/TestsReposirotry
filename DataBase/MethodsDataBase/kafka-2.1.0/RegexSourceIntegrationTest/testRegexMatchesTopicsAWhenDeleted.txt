@Test public void testRegexMatchesTopicsAWhenDeleted() throws Exception {
  final Serde<String> stringSerde=Serdes.String();
  final List<String> expectedFirstAssignment=Arrays.asList("TEST-TOPIC-A","TEST-TOPIC-B");
  final List<String> expectedSecondAssignment=Arrays.asList("TEST-TOPIC-B");
  CLUSTER.createTopics("TEST-TOPIC-A","TEST-TOPIC-B");
  final StreamsBuilder builder=new StreamsBuilder();
  final KStream<String,String> pattern1Stream=builder.stream(Pattern.compile("TEST-TOPIC-[A-Z]"));
  pattern1Stream.to(DEFAULT_OUTPUT_TOPIC,Produced.with(stringSerde,stringSerde));
  final List<String> assignedTopics=new ArrayList<>();
  streams=new KafkaStreams(builder.build(),streamsConfiguration,new DefaultKafkaClientSupplier(){
    @Override public Consumer<byte[],byte[]> getConsumer(    final Map<String,Object> config){
      return new KafkaConsumer<byte[],byte[]>(config,new ByteArrayDeserializer(),new ByteArrayDeserializer()){
        @Override public void subscribe(        final Pattern topics,        final ConsumerRebalanceListener listener){
          super.subscribe(topics,new TheConsumerRebalanceListener(assignedTopics,listener));
        }
      }
;
    }
  }
);
  streams.start();
  TestUtils.waitForCondition(new TestCondition(){
    @Override public boolean conditionMet(){
      return assignedTopics.equals(expectedFirstAssignment);
    }
  }
,STREAM_TASKS_NOT_UPDATED);
  CLUSTER.deleteTopic("TEST-TOPIC-A");
  TestUtils.waitForCondition(new TestCondition(){
    @Override public boolean conditionMet(){
      return assignedTopics.equals(expectedSecondAssignment);
    }
  }
,STREAM_TASKS_NOT_UPDATED);
}
