@Test public void shouldFetchRangeCorrectlyAcrossSegments(){
  final Windowed<Bytes> a1=new Windowed<>(keyA,new SessionWindow(SEGMENT_INTERVAL * 0,SEGMENT_INTERVAL * 0));
  final Windowed<Bytes> aa1=new Windowed<>(keyAA,new SessionWindow(SEGMENT_INTERVAL * 0,SEGMENT_INTERVAL * 0));
  final Windowed<Bytes> a2=new Windowed<>(keyA,new SessionWindow(SEGMENT_INTERVAL * 1,SEGMENT_INTERVAL * 1));
  final Windowed<Bytes> a3=new Windowed<>(keyA,new SessionWindow(SEGMENT_INTERVAL * 2,SEGMENT_INTERVAL * 2));
  final Windowed<Bytes> aa3=new Windowed<>(keyAA,new SessionWindow(SEGMENT_INTERVAL * 2,SEGMENT_INTERVAL * 2));
  cachingStore.put(a1,"1".getBytes());
  cachingStore.put(aa1,"1".getBytes());
  cachingStore.put(a2,"2".getBytes());
  cachingStore.put(a3,"3".getBytes());
  cachingStore.put(aa3,"3".getBytes());
  cachingStore.flush();
  final KeyValueIterator<Windowed<Bytes>,byte[]> rangeResults=cachingStore.findSessions(keyA,keyAA,0,SEGMENT_INTERVAL * 2);
  final Set<Windowed<Bytes>> keys=new HashSet<>();
  while (rangeResults.hasNext()) {
    keys.add(rangeResults.next().key);
  }
  rangeResults.close();
  assertEquals(mkSet(a1,a2,a3,aa1,aa3),keys);
}
