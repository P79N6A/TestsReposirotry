@SuppressWarnings("deprecation") @Test public void shouldUseRecordMetadataTimestampExtractorWhenInternalRepartitioningTopicCreatedWithRetention(){
  final StreamsBuilder builder=new StreamsBuilder();
  final KStream<String,String> kStream=builder.stream("topic-1",stringConsumed);
  final ValueJoiner<String,String,String> valueJoiner=MockValueJoiner.instance(":");
  final long windowSize=TimeUnit.MILLISECONDS.convert(1,TimeUnit.DAYS);
  final KStream<String,String> stream=kStream.map(new KeyValueMapper<String,String,KeyValue<? extends String,? extends String>>(){
    @Override public KeyValue<? extends String,? extends String> apply(    final String key,    final String value){
      return KeyValue.pair(value,value);
    }
  }
);
  stream.join(kStream,valueJoiner,JoinWindows.of(ofMillis(windowSize)).until(3 * windowSize),Joined.with(Serdes.String(),Serdes.String(),Serdes.String())).to("output-topic",Produced.with(Serdes.String(),Serdes.String()));
  final ProcessorTopology topology=TopologyWrapper.getInternalTopologyBuilder(builder.build()).setApplicationId("X").build();
  final SourceNode originalSourceNode=topology.source("topic-1");
  for (  final SourceNode sourceNode : topology.sources()) {
    if (sourceNode.name().equals(originalSourceNode.name())) {
      assertNull(sourceNode.getTimestampExtractor());
    }
 else {
      assertThat(sourceNode.getTimestampExtractor(),instanceOf(FailOnInvalidTimestamp.class));
    }
  }
}
