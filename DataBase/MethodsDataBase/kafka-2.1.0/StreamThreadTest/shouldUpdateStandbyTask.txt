@SuppressWarnings("unchecked") @Test public void shouldUpdateStandbyTask() throws IOException {
  final String storeName1="count-one";
  final String storeName2="table-two";
  final String changelogName1=applicationId + "-" + storeName1+ "-changelog";
  final String changelogName2=applicationId + "-" + storeName2+ "-changelog";
  final TopicPartition partition1=new TopicPartition(changelogName1,1);
  final TopicPartition partition2=new TopicPartition(changelogName2,1);
  internalStreamsBuilder.stream(Collections.singleton(topic1),consumed).groupByKey().count(Materialized.<Object,Long,KeyValueStore<Bytes,byte[]>>as(storeName1));
  final MaterializedInternal materialized=new MaterializedInternal(Materialized.as(storeName2));
  materialized.generateStoreNameIfNeeded(internalStreamsBuilder,"");
  internalStreamsBuilder.table(topic2,new ConsumedInternal(),materialized);
  internalStreamsBuilder.buildAndOptimizeTopology();
  final StreamThread thread=createStreamThread(clientId,config,false);
  final MockConsumer<byte[],byte[]> restoreConsumer=clientSupplier.restoreConsumer;
  restoreConsumer.updatePartitions(changelogName1,singletonList(new PartitionInfo(changelogName1,1,null,new Node[0],new Node[0])));
  restoreConsumer.assign(Utils.mkSet(partition1,partition2));
  restoreConsumer.updateEndOffsets(Collections.singletonMap(partition1,10L));
  restoreConsumer.updateBeginningOffsets(Collections.singletonMap(partition1,0L));
  restoreConsumer.updateEndOffsets(Collections.singletonMap(partition2,10L));
  restoreConsumer.updateBeginningOffsets(Collections.singletonMap(partition2,0L));
  final OffsetCheckpoint checkpoint=new OffsetCheckpoint(new File(stateDirectory.directoryForTask(task3),CHECKPOINT_FILE_NAME));
  checkpoint.write(Collections.singletonMap(partition2,5L));
  for (long i=0L; i < 10L; i++) {
    restoreConsumer.addRecord(new ConsumerRecord<>(changelogName1,1,i,("K" + i).getBytes(),("V" + i).getBytes()));
    restoreConsumer.addRecord(new ConsumerRecord<>(changelogName2,1,i,("K" + i).getBytes(),("V" + i).getBytes()));
  }
  thread.setState(StreamThread.State.RUNNING);
  thread.rebalanceListener.onPartitionsRevoked(null);
  final Map<TaskId,Set<TopicPartition>> standbyTasks=new HashMap<>();
  standbyTasks.put(task1,Collections.singleton(t1p1));
  standbyTasks.put(task3,Collections.singleton(t2p1));
  thread.taskManager().setAssignmentMetadata(Collections.<TaskId,Set<TopicPartition>>emptyMap(),standbyTasks);
  thread.rebalanceListener.onPartitionsAssigned(Collections.<TopicPartition>emptyList());
  thread.runOnce();
  final StandbyTask standbyTask1=thread.taskManager().standbyTask(partition1);
  final StandbyTask standbyTask2=thread.taskManager().standbyTask(partition2);
  final KeyValueStore<Object,Long> store1=(KeyValueStore<Object,Long>)standbyTask1.getStore(storeName1);
  final KeyValueStore<Object,Long> store2=(KeyValueStore<Object,Long>)standbyTask2.getStore(storeName2);
  assertEquals(10L,store1.approximateNumEntries());
  assertEquals(5L,store2.approximateNumEntries());
  assertEquals(0,thread.standbyRecords().size());
}
