@Test public void shouldAlwaysReturnEmptyTasksMetadataWhileRebalancingStateAndTasksNotRunning(){
  internalStreamsBuilder.stream(Collections.singleton(topic1),consumed).groupByKey().count(Materialized.<Object,Long,KeyValueStore<Bytes,byte[]>>as("count-one"));
  internalStreamsBuilder.buildAndOptimizeTopology();
  final StreamThread thread=createStreamThread(clientId,config,false);
  final MockConsumer<byte[],byte[]> restoreConsumer=clientSupplier.restoreConsumer;
  restoreConsumer.updatePartitions("stream-thread-test-count-one-changelog",Utils.mkList(new PartitionInfo("stream-thread-test-count-one-changelog",0,null,new Node[0],new Node[0]),new PartitionInfo("stream-thread-test-count-one-changelog",1,null,new Node[0],new Node[0])));
  final HashMap<TopicPartition,Long> offsets=new HashMap<>();
  offsets.put(new TopicPartition("stream-thread-test-count-one-changelog",0),0L);
  offsets.put(new TopicPartition("stream-thread-test-count-one-changelog",1),0L);
  restoreConsumer.updateEndOffsets(offsets);
  restoreConsumer.updateBeginningOffsets(offsets);
  clientSupplier.consumer.updateBeginningOffsets(Collections.singletonMap(t1p1,0L));
  thread.setState(StreamThread.State.RUNNING);
  final List<TopicPartition> assignedPartitions=new ArrayList<>();
  thread.rebalanceListener.onPartitionsRevoked(assignedPartitions);
  assertThreadMetadataHasEmptyTasksWithState(thread.threadMetadata(),StreamThread.State.PARTITIONS_REVOKED);
  final Map<TaskId,Set<TopicPartition>> activeTasks=new HashMap<>();
  final Map<TaskId,Set<TopicPartition>> standbyTasks=new HashMap<>();
  assignedPartitions.add(t1p1);
  activeTasks.put(task1,Collections.singleton(t1p1));
  standbyTasks.put(task2,Collections.singleton(t1p2));
  thread.taskManager().setAssignmentMetadata(activeTasks,standbyTasks);
  thread.rebalanceListener.onPartitionsAssigned(assignedPartitions);
  assertThreadMetadataHasEmptyTasksWithState(thread.threadMetadata(),StreamThread.State.PARTITIONS_ASSIGNED);
}
