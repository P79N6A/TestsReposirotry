@Test public void shouldRecoverFromInvalidOffsetExceptionOnRestoreAndFinishRestore() throws Exception {
  internalStreamsBuilder.stream(Collections.singleton("topic"),consumed).groupByKey().count(Materialized.<Object,Long,KeyValueStore<Bytes,byte[]>>as("count"));
  internalStreamsBuilder.buildAndOptimizeTopology();
  final StreamThread thread=createStreamThread("clientId",config,false);
  final MockConsumer<byte[],byte[]> mockConsumer=(MockConsumer<byte[],byte[]>)thread.consumer;
  final MockConsumer<byte[],byte[]> mockRestoreConsumer=(MockConsumer<byte[],byte[]>)thread.restoreConsumer;
  final TopicPartition topicPartition=new TopicPartition("topic",0);
  final Set<TopicPartition> topicPartitionSet=Collections.singleton(topicPartition);
  final Map<TaskId,Set<TopicPartition>> activeTasks=new HashMap<>();
  activeTasks.put(new TaskId(0,0),topicPartitionSet);
  thread.taskManager().setAssignmentMetadata(activeTasks,Collections.<TaskId,Set<TopicPartition>>emptyMap());
  mockConsumer.updatePartitions("topic",singletonList(new PartitionInfo("topic",0,null,new Node[0],new Node[0])));
  mockConsumer.updateBeginningOffsets(Collections.singletonMap(topicPartition,0L));
  mockRestoreConsumer.updatePartitions("stream-thread-test-count-changelog",singletonList(new PartitionInfo("stream-thread-test-count-changelog",0,null,new Node[0],new Node[0])));
  final TopicPartition changelogPartition=new TopicPartition("stream-thread-test-count-changelog",0);
  final Set<TopicPartition> changelogPartitionSet=Collections.singleton(changelogPartition);
  mockRestoreConsumer.updateBeginningOffsets(Collections.singletonMap(changelogPartition,0L));
  mockRestoreConsumer.updateEndOffsets(Collections.singletonMap(changelogPartition,2L));
  mockConsumer.schedulePollTask(new Runnable(){
    @Override public void run(){
      thread.setState(StreamThread.State.PARTITIONS_REVOKED);
      thread.rebalanceListener.onPartitionsAssigned(topicPartitionSet);
    }
  }
);
  try {
    thread.start();
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return mockRestoreConsumer.assignment().size() == 1;
      }
    }
,"Never restore first record");
    mockRestoreConsumer.addRecord(new ConsumerRecord<>("stream-thread-test-count-changelog",0,0L,"K1".getBytes(),"V1".getBytes()));
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        return mockRestoreConsumer.position(changelogPartition) == 1L;
      }
    }
,"Never restore first record");
    mockRestoreConsumer.setException(new InvalidOffsetException("Try Again!"){
      @Override public Set<TopicPartition> partitions(){
        return changelogPartitionSet;
      }
    }
);
    mockRestoreConsumer.addRecord(new ConsumerRecord<>("stream-thread-test-count-changelog",0,0L,"K1".getBytes(),"V1".getBytes()));
    mockRestoreConsumer.addRecord(new ConsumerRecord<>("stream-thread-test-count-changelog",0,1L,"K2".getBytes(),"V2".getBytes()));
    TestUtils.waitForCondition(new TestCondition(){
      @Override public boolean conditionMet(){
        mockRestoreConsumer.assign(changelogPartitionSet);
        return mockRestoreConsumer.position(changelogPartition) == 2L;
      }
    }
,"Never finished restore");
  }
  finally {
    thread.shutdown();
    thread.join(10000);
  }
}
