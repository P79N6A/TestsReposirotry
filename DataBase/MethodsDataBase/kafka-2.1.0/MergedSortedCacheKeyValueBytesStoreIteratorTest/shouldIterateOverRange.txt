@Test public void shouldIterateOverRange() throws Exception {
  final byte[][] bytes={{0},{1},{2},{3},{4},{5},{6},{7},{8},{9},{10},{11}};
  for (int i=0; i < bytes.length; i+=2) {
    store.put(Bytes.wrap(bytes[i]),bytes[i]);
    cache.put(namespace,Bytes.wrap(bytes[i + 1]),new LRUCacheEntry(bytes[i + 1]));
  }
  final Bytes from=Bytes.wrap(new byte[]{2});
  final Bytes to=Bytes.wrap(new byte[]{9});
  final KeyValueIterator<Bytes,byte[]> storeIterator=new DelegatingPeekingKeyValueIterator<>("store",store.range(from,to));
  final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator=cache.range(namespace,from,to);
  final MergedSortedCacheKeyValueBytesStoreIterator iterator=new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator,storeIterator);
  final byte[][] values=new byte[8][];
  int index=0;
  int bytesIndex=2;
  while (iterator.hasNext()) {
    final byte[] value=iterator.next().value;
    values[index++]=value;
    assertArrayEquals(bytes[bytesIndex++],value);
  }
  iterator.close();
}
