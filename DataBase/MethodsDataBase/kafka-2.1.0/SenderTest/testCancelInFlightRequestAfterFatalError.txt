@Test public void testCancelInFlightRequestAfterFatalError() throws Exception {
  final long producerId=343434L;
  TransactionManager transactionManager=new TransactionManager();
  setupWithTransactionState(transactionManager);
  client.setNode(new Node(1,"localhost",33343));
  prepareAndReceiveInitProducerId(producerId,Errors.NONE);
  assertTrue(transactionManager.hasProducerId());
  Future<RecordMetadata> future1=accumulator.append(tp0,time.milliseconds(),"key".getBytes(),"value".getBytes(),null,null,MAX_BLOCK_TIMEOUT).future;
  sender.run(time.milliseconds());
  Future<RecordMetadata> future2=accumulator.append(tp1,time.milliseconds(),"key".getBytes(),"value".getBytes(),null,null,MAX_BLOCK_TIMEOUT).future;
  sender.run(time.milliseconds());
  client.respond(new MockClient.RequestMatcher(){
    @Override public boolean matches(    AbstractRequest body){
      return body instanceof ProduceRequest && ((ProduceRequest)body).isIdempotent();
    }
  }
,produceResponse(tp0,-1,Errors.CLUSTER_AUTHORIZATION_FAILED,0));
  sender.run(time.milliseconds());
  assertTrue(transactionManager.hasFatalError());
  assertFutureFailure(future1,ClusterAuthorizationException.class);
  sender.run(time.milliseconds());
  assertFutureFailure(future2,ClusterAuthorizationException.class);
  client.respond(new MockClient.RequestMatcher(){
    @Override public boolean matches(    AbstractRequest body){
      return body instanceof ProduceRequest && ((ProduceRequest)body).isIdempotent();
    }
  }
,produceResponse(tp1,0,Errors.NONE,0));
  sender.run(time.milliseconds());
}
