@Test public void testDownConversionForMismatchedMagicValues() throws Exception {
  long offset=0;
  apiVersions.update("0",NodeApiVersions.create());
  Future<RecordMetadata> future1=accumulator.append(tp0,0L,"key".getBytes(),"value".getBytes(),null,null,MAX_BLOCK_TIMEOUT).future;
  apiVersions.update("0",NodeApiVersions.create(Collections.singleton(new ApiVersionsResponse.ApiVersion(ApiKeys.PRODUCE.id,(short)0,(short)2))));
  Future<RecordMetadata> future2=accumulator.append(tp1,0L,"key".getBytes(),"value".getBytes(),null,null,MAX_BLOCK_TIMEOUT).future;
  apiVersions.update("0",NodeApiVersions.create());
  ProduceResponse.PartitionResponse resp=new ProduceResponse.PartitionResponse(Errors.NONE,offset,RecordBatch.NO_TIMESTAMP,100);
  Map<TopicPartition,ProduceResponse.PartitionResponse> partResp=new HashMap<>();
  partResp.put(tp0,resp);
  partResp.put(tp1,resp);
  ProduceResponse produceResponse=new ProduceResponse(partResp,0);
  client.prepareResponse(new MockClient.RequestMatcher(){
    @Override public boolean matches(    AbstractRequest body){
      ProduceRequest request=(ProduceRequest)body;
      if (request.version() != 2)       return false;
      Map<TopicPartition,MemoryRecords> recordsMap=request.partitionRecordsOrFail();
      if (recordsMap.size() != 2)       return false;
      for (      MemoryRecords records : recordsMap.values()) {
        if (records == null || records.sizeInBytes() == 0 || !records.hasMatchingMagic(RecordBatch.MAGIC_VALUE_V1))         return false;
      }
      return true;
    }
  }
,produceResponse);
  sender.run(time.milliseconds());
  sender.run(time.milliseconds());
  assertTrue("Request should be completed",future1.isDone());
  assertTrue("Request should be completed",future2.isDone());
}
