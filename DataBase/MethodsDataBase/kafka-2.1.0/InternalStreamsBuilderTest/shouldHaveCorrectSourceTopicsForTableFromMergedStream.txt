@Test public void shouldHaveCorrectSourceTopicsForTableFromMergedStream(){
  final String topic1="topic-1";
  final String topic2="topic-2";
  final String topic3="topic-3";
  final KStream<String,String> source1=builder.stream(Collections.singleton(topic1),consumed);
  final KStream<String,String> source2=builder.stream(Collections.singleton(topic2),consumed);
  final KStream<String,String> source3=builder.stream(Collections.singleton(topic3),consumed);
  final KStream<String,String> processedSource1=source1.mapValues(new ValueMapper<String,String>(){
    @Override public String apply(    final String value){
      return value;
    }
  }
).filter(new Predicate<String,String>(){
    @Override public boolean test(    final String key,    final String value){
      return true;
    }
  }
);
  final KStream<String,String> processedSource2=source2.filter(new Predicate<String,String>(){
    @Override public boolean test(    final String key,    final String value){
      return true;
    }
  }
);
  final KStream<String,String> merged=processedSource1.merge(processedSource2).merge(source3);
  merged.groupByKey().count(Materialized.<String,Long,KeyValueStore<Bytes,byte[]>>as("my-table"));
  builder.buildAndOptimizeTopology();
  final Map<String,List<String>> actual=builder.internalTopologyBuilder.stateStoreNameToSourceTopics();
  assertEquals(Utils.mkList("topic-1","topic-2","topic-3"),actual.get("my-table"));
}
