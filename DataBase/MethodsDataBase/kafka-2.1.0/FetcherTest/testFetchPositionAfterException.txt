@Test public void testFetchPositionAfterException(){
  subscriptionsNoAutoReset.assignFromUser(Utils.mkSet(tp0,tp1));
  subscriptionsNoAutoReset.seek(tp0,1);
  subscriptionsNoAutoReset.seek(tp1,1);
  assertEquals(1,fetcherNoAutoReset.sendFetches());
  Map<TopicPartition,FetchResponse.PartitionData<MemoryRecords>> partitions=new LinkedHashMap<>();
  partitions.put(tp1,new FetchResponse.PartitionData<>(Errors.NONE,100,FetchResponse.INVALID_LAST_STABLE_OFFSET,FetchResponse.INVALID_LOG_START_OFFSET,null,records));
  partitions.put(tp0,new FetchResponse.PartitionData<>(Errors.OFFSET_OUT_OF_RANGE,100,FetchResponse.INVALID_LAST_STABLE_OFFSET,FetchResponse.INVALID_LOG_START_OFFSET,null,MemoryRecords.EMPTY));
  client.prepareResponse(new FetchResponse<>(Errors.NONE,new LinkedHashMap<>(partitions),0,INVALID_SESSION_ID));
  consumerClient.poll(time.timer(0));
  List<ConsumerRecord<byte[],byte[]>> fetchedRecords=new ArrayList<>();
  List<OffsetOutOfRangeException> exceptions=new ArrayList<>();
  for (  List<ConsumerRecord<byte[],byte[]>> records : fetcherNoAutoReset.fetchedRecords().values())   fetchedRecords.addAll(records);
  assertEquals(fetchedRecords.size(),subscriptionsNoAutoReset.position(tp1) - 1);
  try {
    for (    List<ConsumerRecord<byte[],byte[]>> records : fetcherNoAutoReset.fetchedRecords().values())     fetchedRecords.addAll(records);
  }
 catch (  OffsetOutOfRangeException e) {
    exceptions.add(e);
  }
  assertEquals(4,subscriptionsNoAutoReset.position(tp1).longValue());
  assertEquals(3,fetchedRecords.size());
  assertEquals(1,exceptions.size());
  OffsetOutOfRangeException e=exceptions.get(0);
  assertTrue(e.offsetOutOfRangePartitions().containsKey(tp0));
  assertEquals(e.offsetOutOfRangePartitions().size(),1);
}
