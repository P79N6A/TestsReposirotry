@Test public void shouldCloseProperlyAndThrowIfInterrupted() throws Exception {
  Properties props=new Properties();
  props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,"localhost:9999");
  props.setProperty(ProducerConfig.PARTITIONER_CLASS_CONFIG,MockPartitioner.class.getName());
  props.setProperty(ProducerConfig.BATCH_SIZE_CONFIG,"1");
  Time time=new MockTime();
  Cluster cluster=TestUtils.singletonCluster("topic",1);
  Node node=cluster.nodes().get(0);
  Metadata metadata=new Metadata(0,Long.MAX_VALUE,true);
  metadata.update(cluster,Collections.emptySet(),time.milliseconds());
  MockClient client=new MockClient(time,metadata);
  client.setNode(node);
  final Producer<String,String> producer=new KafkaProducer<>(new ProducerConfig(ProducerConfig.addSerializerToConfig(props,new StringSerializer(),new StringSerializer())),new StringSerializer(),new StringSerializer(),metadata,client,null,time);
  ExecutorService executor=Executors.newSingleThreadExecutor();
  final AtomicReference<Exception> closeException=new AtomicReference<>();
  try {
    Future<?> future=executor.submit(() -> {
      producer.send(new ProducerRecord<>("topic","key","value"));
      try {
        producer.close();
        fail("Close should block and throw.");
      }
 catch (      Exception e) {
        closeException.set(e);
      }
    }
);
    try {
      future.get(100,TimeUnit.MILLISECONDS);
      fail("Close completed without waiting for send");
    }
 catch (    java.util.concurrent.TimeoutException expected) {
    }
    client.waitForRequests(1,1000);
    assertTrue("Close terminated prematurely",future.cancel(true));
    TestUtils.waitForCondition(() -> closeException.get() != null,"InterruptException did not occur within timeout.");
    assertTrue("Expected exception not thrown " + closeException,closeException.get() instanceof InterruptException);
  }
  finally {
    executor.shutdownNow();
  }
}
