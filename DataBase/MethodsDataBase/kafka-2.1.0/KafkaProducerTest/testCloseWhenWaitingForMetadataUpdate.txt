@Test public void testCloseWhenWaitingForMetadataUpdate() throws InterruptedException {
  Properties props=new Properties();
  props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG,Long.MAX_VALUE);
  props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,"localhost:9000");
  String topicName="test";
  Time time=new MockTime();
  Cluster cluster=TestUtils.singletonCluster();
  Node node=cluster.nodes().get(0);
  Metadata metadata=new Metadata(0,Long.MAX_VALUE,false);
  metadata.update(cluster,Collections.emptySet(),time.milliseconds());
  MockClient client=new MockClient(time,metadata);
  client.setNode(node);
  Producer<String,String> producer=new KafkaProducer<>(new ProducerConfig(ProducerConfig.addSerializerToConfig(props,new StringSerializer(),new StringSerializer())),new StringSerializer(),new StringSerializer(),metadata,client,null,time);
  ExecutorService executor=Executors.newSingleThreadExecutor();
  final AtomicReference<Exception> sendException=new AtomicReference<>();
  try {
    executor.submit(() -> {
      try {
        producer.send(new ProducerRecord<>(topicName,"key","value"));
        fail();
      }
 catch (      Exception e) {
        sendException.set(e);
      }
    }
);
    TestUtils.waitForCondition(() -> metadata.containsTopic(topicName),"Timeout when waiting for topic to be added to metadata");
    producer.close(0,TimeUnit.MILLISECONDS);
    TestUtils.waitForCondition(() -> sendException.get() != null,"No producer exception within timeout");
    assertEquals(KafkaException.class,sendException.get().getClass());
  }
  finally {
    executor.shutdownNow();
  }
}
