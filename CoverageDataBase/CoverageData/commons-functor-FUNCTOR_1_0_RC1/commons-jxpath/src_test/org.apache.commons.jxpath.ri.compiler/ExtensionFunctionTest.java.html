<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ExtensionFunctionTest.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-jxpath (Jan 19, 2019 5:24:34 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-jxpath</a> &gt; <a href="../index.html" class="el_bundle">src/test</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.jxpath.ri.compiler</a> &gt; <span class="el_source">ExtensionFunctionTest.java</span></div><h1>ExtensionFunctionTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.jxpath.ri.compiler;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;

import org.apache.commons.jxpath.ClassFunctions;
import org.apache.commons.jxpath.ExpressionContext;
import org.apache.commons.jxpath.Function;
import org.apache.commons.jxpath.FunctionLibrary;
import org.apache.commons.jxpath.Functions;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathTestCase;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.PackageFunctions;
import org.apache.commons.jxpath.Pointer;
import org.apache.commons.jxpath.TestBean;
import org.apache.commons.jxpath.Variables;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter;
import org.apache.commons.jxpath.util.TypeConverter;
import org.apache.commons.jxpath.util.TypeUtils;

/**
 * Test extension functions.
 *
 * @author Dmitri Plotnikov
 * @version $Revision$ $Date$
 */
<span class="fc" id="L47">public class ExtensionFunctionTest extends JXPathTestCase {</span>
    private Functions functions;
    private JXPathContext context;
    private TestBean testBean;
    private TypeConverter typeConverter;

    public void setUp() {
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (context == null) {</span>
<span class="fc" id="L55">            testBean = new TestBean();</span>
<span class="fc" id="L56">            context = JXPathContext.newContext(testBean);</span>
<span class="fc" id="L57">            Variables vars = context.getVariables();</span>
<span class="fc" id="L58">            vars.declareVariable(&quot;test&quot;, new TestFunctions(4, &quot;test&quot;));</span>

<span class="fc" id="L60">            FunctionLibrary lib = new FunctionLibrary();</span>
<span class="pc bfc" id="L61" title="All 2 branches covered.">            lib.addFunctions(new ClassFunctions(TestFunctions.class, &quot;test&quot;));</span>
<span class="pc bfc" id="L62" title="All 2 branches covered.">            lib.addFunctions(new ClassFunctions(TestFunctions2.class, &quot;test&quot;));</span>
<span class="fc" id="L63">            lib.addFunctions(new PackageFunctions(&quot;&quot;, &quot;call&quot;));</span>
<span class="fc" id="L64">            lib.addFunctions(</span>
<span class="fc" id="L65">                new PackageFunctions(</span>
<span class="fc" id="L66">                    &quot;org.apache.commons.jxpath.ri.compiler.&quot;,</span>
<span class="fc" id="L67">                    &quot;jxpathtest&quot;));</span>
<span class="fc" id="L68">            lib.addFunctions(new PackageFunctions(&quot;&quot;, null));</span>
<span class="fc" id="L69">            context.setFunctions(lib);</span>
<span class="pc bfc" id="L70" title="All 2 branches covered.">            context.getVariables().declareVariable(&quot;List.class&quot;, List.class);</span>
<span class="pc bfc" id="L71" title="All 2 branches covered.">            context.getVariables().declareVariable(&quot;NodeSet.class&quot;, NodeSet.class);</span>
        }
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        functions = new ClassFunctions(TestFunctions.class, &quot;test&quot;);</span>
<span class="fc" id="L74">        typeConverter = TypeUtils.getTypeConverter();</span>
<span class="fc" id="L75">    }</span>

    public void tearDown() {
<span class="fc" id="L78">        TypeUtils.setTypeConverter(typeConverter);</span>
<span class="fc" id="L79">    }</span>

    public void testConstructorLookup() {
<span class="fc" id="L82">        Object[] args = new Object[] { new Integer(1), &quot;x&quot; };</span>
<span class="fc" id="L83">        Function func = functions.getFunction(&quot;test&quot;, &quot;new&quot;, args);</span>

<span class="fc" id="L85">        assertEquals(</span>
<span class="fc" id="L86">            &quot;test:new(1, x)&quot;,</span>
<span class="fc" id="L87">            func.invoke(new Context(null), args).toString(),</span>
<span class="fc" id="L88">            &quot;foo=1; bar=x&quot;);</span>
<span class="fc" id="L89">    }</span>

    public void testConstructorLookupWithExpressionContext() {
<span class="fc" id="L92">        Object[] args = new Object[] { &quot;baz&quot; };</span>
<span class="fc" id="L93">        Function func = functions.getFunction(&quot;test&quot;, &quot;new&quot;, args);</span>
<span class="fc" id="L94">        assertEquals(</span>
<span class="fc" id="L95">            &quot;test:new('baz')&quot;,</span>
<span class="fc" id="L96">            func.invoke(new Context(new Integer(1)), args).toString(),</span>
<span class="fc" id="L97">            &quot;foo=1; bar=baz&quot;);</span>
<span class="fc" id="L98">    }</span>

    public void testStaticMethodLookup() {
<span class="fc" id="L101">        Object[] args = new Object[] { new Integer(1), &quot;x&quot; };</span>
<span class="fc" id="L102">        Function func = functions.getFunction(&quot;test&quot;, &quot;build&quot;, args);</span>
<span class="fc" id="L103">        assertEquals(</span>
<span class="fc" id="L104">            &quot;test:build(1, x)&quot;,</span>
<span class="fc" id="L105">            func.invoke(new Context(null), args).toString(),</span>
<span class="fc" id="L106">            &quot;foo=1; bar=x&quot;);</span>
<span class="fc" id="L107">    }</span>

    public void testStaticMethodLookupWithConversion() {
<span class="fc" id="L110">        Object[] args = new Object[] { &quot;7&quot;, new Integer(1)};</span>
<span class="fc" id="L111">        Function func = functions.getFunction(&quot;test&quot;, &quot;build&quot;, args);</span>
<span class="fc" id="L112">        assertEquals(</span>
<span class="fc" id="L113">            &quot;test:build('7', 1)&quot;,</span>
<span class="fc" id="L114">            func.invoke(new Context(null), args).toString(),</span>
<span class="fc" id="L115">            &quot;foo=7; bar=1&quot;);</span>
<span class="fc" id="L116">    }</span>

    public void testMethodLookup() {
<span class="fc" id="L119">        Object[] args = new Object[] { new TestFunctions()};</span>
<span class="fc" id="L120">        Function func = functions.getFunction(&quot;test&quot;, &quot;getFoo&quot;, args);</span>
<span class="fc" id="L121">        assertEquals(</span>
<span class="fc" id="L122">            &quot;test:getFoo($test, 1, x)&quot;,</span>
<span class="fc" id="L123">            func.invoke(new Context(null), args).toString(),</span>
<span class="fc" id="L124">            &quot;0&quot;);</span>
<span class="fc" id="L125">    }</span>

    public void testStaticMethodLookupWithExpressionContext() {
<span class="fc" id="L128">        Object[] args = new Object[0];</span>
<span class="fc" id="L129">        Function func = functions.getFunction(&quot;test&quot;, &quot;path&quot;, args);</span>
<span class="fc" id="L130">        assertEquals(</span>
<span class="fc" id="L131">            &quot;test:path()&quot;,</span>
<span class="fc" id="L132">            func.invoke(new Context(new Integer(1)), args),</span>
<span class="fc" id="L133">            &quot;1&quot;);</span>
<span class="fc" id="L134">    }</span>

    public void testMethodLookupWithExpressionContext() {
<span class="fc" id="L137">        Object[] args = new Object[] { new TestFunctions()};</span>
<span class="fc" id="L138">        Function func = functions.getFunction(&quot;test&quot;, &quot;instancePath&quot;, args);</span>
<span class="fc" id="L139">        assertEquals(</span>
<span class="fc" id="L140">            &quot;test:instancePath()&quot;,</span>
<span class="fc" id="L141">            func.invoke(new Context(new Integer(1)), args),</span>
<span class="fc" id="L142">            &quot;1&quot;);</span>
<span class="fc" id="L143">    }</span>

    public void testMethodLookupWithExpressionContextAndArgument() {
<span class="fc" id="L146">        Object[] args = new Object[] { new TestFunctions(), &quot;*&quot; };</span>
<span class="fc" id="L147">        Function func = functions.getFunction(&quot;test&quot;, &quot;pathWithSuffix&quot;, args);</span>
<span class="fc" id="L148">        assertEquals(</span>
<span class="fc" id="L149">            &quot;test:pathWithSuffix('*')&quot;,</span>
<span class="fc" id="L150">            func.invoke(new Context(new Integer(1)), args),</span>
<span class="fc" id="L151">            &quot;1*&quot;);</span>
<span class="fc" id="L152">    }</span>

    public void testAllocation() {
        
        // Allocate new object using the default constructor
<span class="fc" id="L157">        assertXPathValue(context, &quot;string(test:new())&quot;, &quot;foo=0; bar=null&quot;);</span>

        // Allocate new object using PackageFunctions and class name
<span class="fc" id="L160">        assertXPathValue(</span>
<span class="fc" id="L161">            context,</span>
<span class="fc" id="L162">            &quot;string(jxpathtest:TestFunctions.new())&quot;,</span>
<span class="fc" id="L163">            &quot;foo=0; bar=null&quot;);</span>

        // Allocate new object using a fully qualified class name
<span class="fc" id="L166">        assertXPathValue(</span>
<span class="fc" id="L167">            context,</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">            &quot;string(&quot; + TestFunctions.class.getName() + &quot;.new())&quot;,</span>
<span class="fc" id="L169">            &quot;foo=0; bar=null&quot;);</span>

        // Allocate new object using a custom constructor
<span class="fc" id="L172">        assertXPathValue(</span>
<span class="fc" id="L173">            context,</span>
<span class="fc" id="L174">            &quot;string(test:new(3, 'baz'))&quot;,</span>
<span class="fc" id="L175">            &quot;foo=3; bar=baz&quot;);</span>

        // Allocate new object using a custom constructor - type conversion
<span class="fc" id="L178">        assertXPathValue(context, &quot;string(test:new('3', 4))&quot;, &quot;foo=3; bar=4.0&quot;);</span>
        
<span class="fc" id="L180">        context.getVariables().declareVariable(&quot;A&quot;, &quot;baz&quot;);        </span>
<span class="fc" id="L181">        assertXPathValue(</span>
<span class="fc" id="L182">                context,</span>
<span class="fc" id="L183">                &quot;string(test:new(2, $A, false))&quot;,</span>
<span class="fc" id="L184">                &quot;foo=2; bar=baz&quot;);</span>
<span class="fc" id="L185">    }</span>

    public void testMethodCall() {
<span class="fc" id="L188">        assertXPathValue(context, &quot;length('foo')&quot;, new Integer(3));</span>

        // We are just calling a method - prefix is ignored
<span class="fc" id="L191">        assertXPathValue(context, &quot;call:substring('foo', 1, 2)&quot;, &quot;o&quot;);</span>

        // Invoke a function implemented as a regular method
<span class="fc" id="L194">        assertXPathValue(context, &quot;string(test:getFoo($test))&quot;, &quot;4&quot;);</span>
        
        // Note that the prefix is ignored anyway, we are just calling a method
<span class="fc" id="L197">        assertXPathValue(context, &quot;string(call:getFoo($test))&quot;, &quot;4&quot;);</span>

        // We don't really need to supply a prefix in this case
<span class="fc" id="L200">        assertXPathValue(context, &quot;string(getFoo($test))&quot;, &quot;4&quot;);</span>

        // Method with two arguments
<span class="fc" id="L203">        assertXPathValue(</span>
<span class="fc" id="L204">            context,</span>
<span class="fc" id="L205">            &quot;string(test:setFooAndBar($test, 7, 'biz'))&quot;,</span>
<span class="fc" id="L206">            &quot;foo=7; bar=biz&quot;);</span>
<span class="fc" id="L207">    }</span>
    
    public void testCollectionMethodCall() {
        
<span class="fc" id="L211">        List list = new ArrayList();</span>
<span class="fc" id="L212">        list.add(&quot;foo&quot;);</span>
<span class="fc" id="L213">        context.getVariables().declareVariable(&quot;myList&quot;, list);</span>

<span class="fc" id="L215">        assertXPathValue(</span>
<span class="fc" id="L216">            context, </span>
<span class="fc" id="L217">            &quot;size($myList)&quot;, </span>
<span class="fc" id="L218">            new Integer(1));</span>
    
<span class="fc" id="L220">        assertXPathValue(</span>
<span class="fc" id="L221">            context, </span>
<span class="fc" id="L222">            &quot;size(beans)&quot;, </span>
<span class="fc" id="L223">            new Integer(2));</span>
            
<span class="fc" id="L225">        context.getValue(&quot;add($myList, 'hello')&quot;);</span>
<span class="fc" id="L226">        assertEquals(&quot;After adding an element&quot;, 2, list.size());</span>
        
<span class="fc" id="L228">        JXPathContext context = JXPathContext.newContext(new ArrayList());</span>
<span class="fc" id="L229">        assertEquals(&quot;Extension function on root collection&quot;, &quot;0&quot;, String</span>
<span class="fc" id="L230">                .valueOf(context.getValue(&quot;size(/)&quot;)));</span>
<span class="fc" id="L231">    }</span>

    public void testStaticMethodCall() {

<span class="fc" id="L235">        assertXPathValue(</span>
<span class="fc" id="L236">            context,</span>
<span class="fc" id="L237">            &quot;string(test:build(8, 'goober'))&quot;,</span>
<span class="fc" id="L238">            &quot;foo=8; bar=goober&quot;);</span>

        // Call a static method using PackageFunctions and class name
<span class="fc" id="L241">        assertXPathValue(</span>
<span class="fc" id="L242">            context,</span>
<span class="fc" id="L243">            &quot;string(jxpathtest:TestFunctions.build(8, 'goober'))&quot;,</span>
<span class="fc" id="L244">            &quot;foo=8; bar=goober&quot;);</span>

        // Call a static method with a fully qualified class name
<span class="fc" id="L247">        assertXPathValue(</span>
<span class="fc" id="L248">            context,</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            &quot;string(&quot; + TestFunctions.class.getName() + &quot;.build(8, 'goober'))&quot;,</span>
<span class="fc" id="L250">            &quot;foo=8; bar=goober&quot;);</span>

        // Two ClassFunctions are sharing the same prefix.
        // This is TestFunctions2
<span class="fc" id="L254">        assertXPathValue(context, &quot;string(test:increment(8))&quot;, &quot;9&quot;);</span>
        
        // See that a NodeSet gets properly converted to a string
<span class="fc" id="L257">        assertXPathValue(context, &quot;test:string(/beans/name)&quot;, &quot;Name 1&quot;);</span>
<span class="fc" id="L258">    }</span>

    public void testExpressionContext() {
        // Execute an extension function for each node while searching
        // The function uses ExpressionContext to get to the current
        // node.
<span class="fc" id="L264">        assertXPathValue(</span>
<span class="fc" id="L265">            context, </span>
<span class="fc" id="L266">            &quot;//.[test:isMap()]/Key1&quot;, </span>
<span class="fc" id="L267">            &quot;Value 1&quot;);</span>

        // The function gets all
        // nodes in the context that match the pattern.
<span class="fc" id="L271">        assertXPathValue(</span>
<span class="fc" id="L272">            context,</span>
<span class="fc" id="L273">            &quot;count(//.[test:count(strings) = 3])&quot;,</span>
<span class="fc" id="L274">            new Double(7));</span>

        // The function receives a collection of strings
        // and checks their type for testing purposes            
<span class="fc" id="L278">        assertXPathValue(</span>
<span class="fc" id="L279">            context,</span>
<span class="fc" id="L280">            &quot;test:count(//strings)&quot;,</span>
<span class="fc" id="L281">            new Integer(21));</span>

        
        // The function receives a collection of pointers
        // and checks their type for testing purposes            
<span class="fc" id="L286">        assertXPathValue(</span>
<span class="fc" id="L287">            context,</span>
<span class="fc" id="L288">            &quot;test:countPointers(//strings)&quot;,</span>
<span class="fc" id="L289">            new Integer(21));</span>
            
        // The function uses ExpressionContext to get to the current
        // pointer and returns its path.
<span class="fc" id="L293">        assertXPathValue(</span>
<span class="fc" id="L294">            context,</span>
<span class="fc" id="L295">            &quot;/beans[contains(test:path(), '[2]')]/name&quot;,</span>
<span class="fc" id="L296">            &quot;Name 2&quot;);</span>
<span class="fc" id="L297">    }</span>
    
    public void testCollectionReturn() {
<span class="fc" id="L300">        assertXPathValueIterator(</span>
<span class="fc" id="L301">            context,</span>
<span class="fc" id="L302">            &quot;test:collection()/name&quot;,</span>
<span class="fc" id="L303">            list(&quot;foo&quot;, &quot;bar&quot;));</span>

<span class="fc" id="L305">        assertXPathPointerIterator(</span>
<span class="fc" id="L306">            context,</span>
<span class="fc" id="L307">            &quot;test:collection()/name&quot;,</span>
<span class="fc" id="L308">            list(&quot;/.[1]/name&quot;, &quot;/.[2]/name&quot;));</span>
            
<span class="fc" id="L310">        assertXPathValue(</span>
<span class="fc" id="L311">            context,</span>
<span class="fc" id="L312">            &quot;test:collection()/name&quot;,</span>
<span class="fc" id="L313">            &quot;foo&quot;);        </span>

<span class="fc" id="L315">        assertXPathValue(</span>
<span class="fc" id="L316">            context,</span>
<span class="fc" id="L317">            &quot;test:collection()/@name&quot;,</span>
<span class="fc" id="L318">            &quot;foo&quot;);   </span>
        
<span class="fc" id="L320">        List list = new ArrayList();</span>
<span class="fc" id="L321">        list.add(&quot;foo&quot;);</span>
<span class="fc" id="L322">        list.add(&quot;bar&quot;);</span>
<span class="fc" id="L323">        context.getVariables().declareVariable(&quot;list&quot;, list);</span>
<span class="fc" id="L324">        Object values = context.getValue(&quot;test:items($list)&quot;);</span>
<span class="fc" id="L325">        assertTrue(&quot;Return type: &quot;, values instanceof Collection);</span>
<span class="fc" id="L326">        assertEquals(</span>
<span class="fc" id="L327">            &quot;Return values: &quot;,</span>
<span class="fc" id="L328">            list,</span>
<span class="fc" id="L329">            new ArrayList((Collection) values));</span>
<span class="fc" id="L330">    }</span>

    public void testNodeSetReturn() {
<span class="fc" id="L333">        assertXPathValueIterator(</span>
<span class="fc" id="L334">            context,</span>
<span class="fc" id="L335">            &quot;test:nodeSet()/name&quot;,</span>
<span class="fc" id="L336">            list(&quot;Name 1&quot;, &quot;Name 2&quot;));</span>

<span class="fc" id="L338">        assertXPathValueIterator(</span>
<span class="fc" id="L339">            context,</span>
<span class="fc" id="L340">            &quot;test:nodeSet()&quot;,</span>
<span class="fc" id="L341">            list(testBean.getBeans()[0], testBean.getBeans()[1]));</span>

<span class="fc" id="L343">        assertXPathPointerIterator(</span>
<span class="fc" id="L344">            context,</span>
<span class="fc" id="L345">            &quot;test:nodeSet()/name&quot;,</span>
<span class="fc" id="L346">            list(&quot;/beans[1]/name&quot;, &quot;/beans[2]/name&quot;));</span>
            
<span class="fc" id="L348">        assertXPathValueAndPointer(</span>
<span class="fc" id="L349">            context,</span>
<span class="fc" id="L350">            &quot;test:nodeSet()/name&quot;,</span>
<span class="fc" id="L351">            &quot;Name 1&quot;,</span>
<span class="fc" id="L352">            &quot;/beans[1]/name&quot;);        </span>

<span class="fc" id="L354">        assertXPathValueAndPointer(</span>
<span class="fc" id="L355">            context,</span>
<span class="fc" id="L356">            &quot;test:nodeSet()/@name&quot;,</span>
<span class="fc" id="L357">            &quot;Name 1&quot;,</span>
<span class="fc" id="L358">            &quot;/beans[1]/@name&quot;);</span>

<span class="fc" id="L360">        assertEquals(2, ((Number) context.getValue(&quot;count(test:nodeSet())&quot;)).intValue());</span>

<span class="fc" id="L362">        assertXPathValue(context, &quot;test:nodeSet()&quot;, testBean.getBeans()[0]);</span>
<span class="fc" id="L363">    }</span>

    public void testEstablishNodeSetBaseline() {
<span class="fc" id="L366">        assertXPathValue(</span>
<span class="fc" id="L367">            context,</span>
<span class="fc" id="L368">            &quot;test:isInstance(//strings, $List.class)&quot;,</span>
<span class="fc" id="L369">            Boolean.TRUE);</span>
<span class="fc" id="L370">        assertXPathValue(</span>
<span class="fc" id="L371">            context,</span>
<span class="fc" id="L372">            &quot;test:isInstance(//strings, $NodeSet.class)&quot;,</span>
<span class="fc" id="L373">            Boolean.FALSE);</span>
<span class="fc" id="L374">    }</span>

    public void testBCNodeSetHack() {
<span class="fc" id="L377">        TypeUtils.setTypeConverter(new JXPath11CompatibleTypeConverter());</span>
<span class="fc" id="L378">        assertXPathValue(</span>
<span class="fc" id="L379">            context,</span>
<span class="fc" id="L380">            &quot;test:isInstance(//strings, $List.class)&quot;,</span>
<span class="fc" id="L381">            Boolean.FALSE);</span>
<span class="fc" id="L382">        assertXPathValue(</span>
<span class="fc" id="L383">            context,</span>
<span class="fc" id="L384">            &quot;test:isInstance(//strings, $NodeSet.class)&quot;,</span>
<span class="fc" id="L385">            Boolean.TRUE);</span>
<span class="fc" id="L386">    }</span>

    private static class Context implements ExpressionContext {
        private Object object;

<span class="fc" id="L391">        public Context(Object object) {</span>
<span class="fc" id="L392">            this.object = object;</span>
<span class="fc" id="L393">        }</span>

        public Pointer getContextNodePointer() {
<span class="fc" id="L396">            return NodePointer</span>
<span class="fc" id="L397">                    .newNodePointer(null, object, Locale.getDefault());</span>
        }

        public List getContextNodeList() {
<span class="nc" id="L401">            return null;</span>
        }

        public JXPathContext getJXPathContext() {
<span class="nc" id="L405">            return null;</span>
        }

        public int getPosition() {
<span class="nc" id="L409">            return 0;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-jxpath (Jan 19, 2019 5:24:34 PM)</div></body></html>